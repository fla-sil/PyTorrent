{"info": {"author": "", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: BSD License", "Topic :: Utilities"], "description": "# NetworkDisk\n\nAim is to provide a generic class for manupulating graphs and networks on disk.\nThe final goal is to provide:\n\t* compatibility with networkx;\n\t* tools dedicated to perform searches into on graph stored on (local or remote) Disk;\n\t* evaluating complex queries by interfacing with on disk databases.\n\nIn order to keep the class versatile and simple to use,\nwe define abstract class to overload with methods dedicated to handle\nspecific \"ondisk\" technologies.\n\nExamples include:\n\t* naive implementation on RAM;\n\t* SQLite local implementation;\n\t* PostgreSQL implementation;\n\t* Cassandra distributed implementation (TODO);\n\t* Any efficient database implementing abstract functions\n\t will do but to get acceptable performance, some tuning with\n\t a dedicated work on index and data representation have to be\n\t done.\n\nEfficiency of the package heavily relies on the implementation.\nFrom PostgreSQL implementation, the package inherit ACID transactions\nand concurrent access to the graph by several clients.\n\nThe package however provides some examples of generic implementation\nin SQL as well as methods for improving searches and (TODO) support\nof query languages.\n\n## The Graphs abstraction methods\n\n## Searches\n\nSearches in graphs can be an intensive task when it come to very large\ngraphs. Few methods exists to index data in order to find path and\nsubgraphs between nodes.\nFurthermore, those searches can be restricted by filter and automaton\naggregation (TODO) using datas that labels every node.\n\nIn this package, searches return an intermediate data-structure, called\na _multilayeredDAG_. From a multilayeredDAG, it is easy (linear) to\ncompute paths, to enumerate shortest paths and to count the number of\npaths.\n\n## Embedding\n(TODO)\n\nThe NetworkDisk package offer some methods to compute some topology,\ncalled embeddings, for a given network.\nSome of the computations are intensive and require a lot of RAM and\nare not suitable for dynamic graphs, others can be performed directly\non disk and may also be maintained under update.\n\n\nWhen an embedding is available, it becomes possible to improve\nsearches within the graph by best-first search like algorithm.\n\n# Embedding-guided Search\n\nEfficiently answering regular path queries on very large graphs, by\nguiding the search through distances in an embedding of the graph.\nThis embedding is precomputed in quasi-linear time and space,\nindependently of the regular query.\n\n# TODO list\n\n## TODO on Abstract class\n\n3. TODO `remove_embedding_from_node` and `remove_embedding` to EmbeddedGraph\n4. Add `type` to edges (that become multiegdes?). Maybe extend Graph for that.\n5. Import `RDF`\n7. Add for `landmarks` maintenance for new nodes.\n9. TODO: Introduced other kind of embeddings.\n10. TODO: Should we care about properties values type?\n11. TODO: Bulk loading implementation\n\n## TODO add EmbeddedDataGraph\n\nFrom now, we don't need EmbeddedDataGraph (which is just a merge of Data\nGraph and embeddedGraph). However some specific methods can be useful here:\n\n1. Data biais random_walk\n2. Data biais landmarks computations\n\n## TODO on SQLish Implementations\n\n6. Implement on disk embedding computation for landmarks embeddings\n7. See with Magnet for ondisk implementation of word2vec? (not existing)\n8. TODO: Implement functions in SQL local  to database instead of python version when possible.\n9. TODO/ Use the edges/nodes/properties pass through the `__init__` to perform a\n   bulkload (desactivate index, load datas, add index)\n\n## TODO on sqlite Implementations\n\n1. Look for SQLite Extensions allowing to deal with nicer data Type.\n   i.e. Maybe for indexation of json documents?\n2. DONE: Management of default sqlite scripts: move it to an external module?\n3.\tDONE: Add table for degrees.\n\n## TODO on PostgreSQL Implementation\n\n1. DONE Postgresql\n2. TODO: distant embedding and search computation\n3. Use of JSON_B indexation\n4. Use of full_text_search indexes.\n\n## TODO On multilayerDag\n\n1. DONE: Exctract root-to-root betweeness centrality for nodes (#nb of shortest path\n   from root to root going through the node ). Should be linear in the\n   multilayerDag.\n\n2. DONE: Multilateral Breath First Search\n\n3. TODO: merge bilat\u00e9ral BFS with multilateral BFS.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://packages.python.org/an_example_pypi_project", "keywords": "graph,networkx,database", "license": "", "maintainer": "", "maintainer_email": "", "name": "networkdisk", "package_url": "https://pypi.org/project/networkdisk/", "platform": "", "project_url": "https://pypi.org/project/networkdisk/", "project_urls": {"Homepage": "http://packages.python.org/an_example_pypi_project"}, "release_url": "https://pypi.org/project/networkdisk/0.2/", "requires_dist": null, "requires_python": "", "summary": "", "version": "0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            # NetworkDisk<br><br>Aim is to provide a generic class for manupulating graphs and networks on disk.<br>The final goal is to provide:<br>\t* compatibility with networkx;<br>\t* tools dedicated to perform searches into on graph stored on (local or remote) Disk;<br>\t* evaluating complex queries by interfacing with on disk databases.<br><br>In order to keep the class versatile and simple to use,<br>we define abstract class to overload with methods dedicated to handle<br>specific \"ondisk\" technologies.<br><br>Examples include:<br>\t* naive implementation on RAM;<br>\t* SQLite local implementation;<br>\t* PostgreSQL implementation;<br>\t* Cassandra distributed implementation (TODO);<br>\t* Any efficient database implementing abstract functions<br>\t will do but to get acceptable performance, some tuning with<br>\t a dedicated work on index and data representation have to be<br>\t done.<br><br>Efficiency of the package heavily relies on the implementation.<br>From PostgreSQL implementation, the package inherit ACID transactions<br>and concurrent access to the graph by several clients.<br><br>The package however provides some examples of generic implementation<br>in SQL as well as methods for improving searches and (TODO) support<br>of query languages.<br><br>## The Graphs abstraction methods<br><br>## Searches<br><br>Searches in graphs can be an intensive task when it come to very large<br>graphs. Few methods exists to index data in order to find path and<br>subgraphs between nodes.<br>Furthermore, those searches can be restricted by filter and automaton<br>aggregation (TODO) using datas that labels every node.<br><br>In this package, searches return an intermediate data-structure, called<br>a _multilayeredDAG_. From a multilayeredDAG, it is easy (linear) to<br>compute paths, to enumerate shortest paths and to count the number of<br>paths.<br><br>## Embedding<br>(TODO)<br><br>The NetworkDisk package offer some methods to compute some topology,<br>called embeddings, for a given network.<br>Some of the computations are intensive and require a lot of RAM and<br>are not suitable for dynamic graphs, others can be performed directly<br>on disk and may also be maintained under update.<br><br><br>When an embedding is available, it becomes possible to improve<br>searches within the graph by best-first search like algorithm.<br><br># Embedding-guided Search<br><br>Efficiently answering regular path queries on very large graphs, by<br>guiding the search through distances in an embedding of the graph.<br>This embedding is precomputed in quasi-linear time and space,<br>independently of the regular query.<br><br># TODO list<br><br>## TODO on Abstract class<br><br>3. TODO `remove_embedding_from_node` and `remove_embedding` to EmbeddedGraph<br>4. Add `type` to edges (that become multiegdes?). Maybe extend Graph for that.<br>5. Import `RDF`<br>7. Add for `landmarks` maintenance for new nodes.<br>9. TODO: Introduced other kind of embeddings.<br>10. TODO: Should we care about properties values type?<br>11. TODO: Bulk loading implementation<br><br>## TODO add EmbeddedDataGraph<br><br>From now, we don't need EmbeddedDataGraph (which is just a merge of Data<br>Graph and embeddedGraph). However some specific methods can be useful here:<br><br>1. Data biais random_walk<br>2. Data biais landmarks computations<br><br>## TODO on SQLish Implementations<br><br>6. Implement on disk embedding computation for landmarks embeddings<br>7. See with Magnet for ondisk implementation of word2vec? (not existing)<br>8. TODO: Implement functions in SQL local  to database instead of python version when possible.<br>9. TODO/ Use the edges/nodes/properties pass through the `__init__` to perform a<br>   bulkload (desactivate index, load datas, add index)<br><br>## TODO on sqlite Implementations<br><br>1. Look for SQLite Extensions allowing to deal with nicer data Type.<br>   i.e. Maybe for indexation of json documents?<br>2. DONE: Management of default sqlite scripts: move it to an external module?<br>3.\tDONE: Add table for degrees.<br><br>## TODO on PostgreSQL Implementation<br><br>1. DONE Postgresql<br>2. TODO: distant embedding and search computation<br>3. Use of JSON_B indexation<br>4. Use of full_text_search indexes.<br><br>## TODO On multilayerDag<br><br>1. DONE: Exctract root-to-root betweeness centrality for nodes (#nb of shortest path<br>   from root to root going through the node ). Should be linear in the<br>   multilayerDag.<br><br>2. DONE: Multilateral Breath First Search<br><br>3. TODO: merge bilat\u00e9ral BFS with multilateral BFS.\n          </div>"}, "last_serial": 4949695, "releases": {"0.2": [{"comment_text": "", "digests": {"md5": "2bf88016a91fc67a359a674e158a3594", "sha256": "f26f4c7410985f7ab3e00220ea15e2764c921044de8ae4fa09cb60ef499c3daa"}, "downloads": -1, "filename": "networkdisk-0.2.tar.gz", "has_sig": false, "md5_digest": "2bf88016a91fc67a359a674e158a3594", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32146, "upload_time": "2019-03-17T08:06:49", "upload_time_iso_8601": "2019-03-17T08:06:49.748453Z", "url": "https://files.pythonhosted.org/packages/88/3b/7999c22e101a9015ccf6fe97751890222673e44e7f253c16c8fff401be0e/networkdisk-0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2bf88016a91fc67a359a674e158a3594", "sha256": "f26f4c7410985f7ab3e00220ea15e2764c921044de8ae4fa09cb60ef499c3daa"}, "downloads": -1, "filename": "networkdisk-0.2.tar.gz", "has_sig": false, "md5_digest": "2bf88016a91fc67a359a674e158a3594", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32146, "upload_time": "2019-03-17T08:06:49", "upload_time_iso_8601": "2019-03-17T08:06:49.748453Z", "url": "https://files.pythonhosted.org/packages/88/3b/7999c22e101a9015ccf6fe97751890222673e44e7f253c16c8fff401be0e/networkdisk-0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:45:53 2020"}