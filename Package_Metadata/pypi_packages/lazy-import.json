{"info": {"author": "Manuel Nuno Melo", "author_email": "manuel.nuno.melo@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "lazy_import\n===========\n\n|Build Status|\n\n``lazy_import`` provides a set of functions that load modules, and related\nattributes, in a lazy fashion. This allows deferring of ``ImportErrors`` to\nactual module use-time. Likewise, actual module initialization only takes place\nat use-time. This is useful when using optional dependencies with heavy loading\ntimes and/or footprints, since that cost is only paid if the module is actually\nused.\n\nFor minimal impact to other code running in the same session ``lazy_import``\nfunctionality is implemented without the use of import hooks.\n\n``lazy_import`` is compatible with Python \u2265 2.7 or \u2265 3.4.\n\nExamples: lazy module loading\n-----------------------------\n\n.. code:: python\n\n    import lazy_import\n    np = lazy_import.lazy_module(\"numpy\")\n    # np is now available in the namespace and is listed in sys.modules under\n    #  the 'numpy' key:\n    import sys\n    sys.modules['numpy']\n    # The module is present as \"Lazily-loaded module numpy\"\n\n    # Subsequent imports of the same module return the lazy version present\n    #  in sys.modules\n    import numpy # At this point numpy and np point to the same lazy module.\n    # This is true for any import of 'numpy', even if from other modules!\n\n    # Accessing attributes causes the full loading of the module ...\n    np.pi\n    # ... and the module is changed in place. np and numpy are now \n    #  \"<module 'numpy' from '/usr/local/lib/python/site-packages/numpy/__init__.py'>\"\n\n    # Lazy-importing a module that's already fully loaded returns the full\n    #  module instead (even if it was loaded elsewhere in the current session)\n    #  because there's no point in being lazy in this case:\n    os = lazy_import.lazy_module(\"os\")\n    # \"<module 'os' from '/usr/lib/python/os.py'>\"\n\nIn the above code it can be seen that issuing\n``lazy_import.lazy_module(\"numpy\")`` registers the lazy module in the\nsession-wide ``sys.modules`` registry. This means that *any* subsequent import\nof ``numpy`` in the same session, while the module is still not fully loaded,\nwill get served a lazy version of the ``numpy`` module. This will happen also\noutside the code that calls ``lazy_module``:\n\n.. code:: python\n   \n    import lazy_import\n    np = lazy_import.lazy_module(\"numpy\")\n    import module_that_uses_numpy # This module will get a lazy module upon\n                                  # 'import numpy'\n\nNormally this is ok because the lazy module will behave pretty much as the real\nthing once fully-loaded. Still, it might be a good practice to document that\nyou're lazily importing modules so-and-so, so that users are warned.\n\nFurther uses are to delay ``ImportErrors``:\n\n.. code:: python\n\n    import lazy_import\n    # The following succeeds even when asking for a module that's not available\n    missing = lazy_import.lazy_module(\"missing_module\")\n\n    missing.some_attr # This causes the full loading of the module, which now fails.\n    \"ImportError: __main__ attempted to use a functionality that requires module\n     missing_module, but it couldn't be loaded. Please install missing_module and retry.\"\n\n\nSubmodules work too:\n\n.. code:: python\n\n    import lazy_import\n    mod = lazy_import.lazy_module(\"some.sub.module\")\n    # mod now points to the some.sub.module lazy module\n    #  equivalent to \"from some.sub import module as mod\"\n\n    # Alternatively the returned reference can be made to point to the\n    #  base module:\n    some = lazy_import.lazy_module(\"some.sub.module\", level=\"base\")\n\n    # This is equivalent to \"import some.sub.module\" in that only the base\n    #  module's name is added to the namespace. All submodules must be accessed\n    #  via that:\n    some.sub # Returns lazy module 'some.sub' without triggering full loading.\n    some.sub.attr # Triggers full loading of 'some' and 'some.sub'.\n    some.sub.module.function() # Triggers loading also of 'some.sub.module'.\n\n\nFinally, if you want to mark some modules and submodules your package imports\nas always being lazy, it is as simple as lazily importing them at the root\n`__init__.py` level. Other files can then import all modules normally, and\nthose that have already been loaded as lazy in `__init__.py` will remain so:\n\n.. code:: python\n\n    # in __init__.py:\n\n    import lazy_import\n    lazy_import.lazy_module(\"numpy\")\n    lazy_import.lazy_module(\"scipy.stats\")\n\n\n    # then, in any other file in the package just use the imports normally:\n\n    import requests # This one is not lazy.\n    import numpy # This one is lazy, as long as no other code caused its\n                 #  loading in the meantime.\n    import scipy # This one is also lazy. It was lazily loaded as part of the\n                 #  lazy loading of scipy.stats.\n    import scipy.stats # Also lazy.\n    import scipy.linalg # Uh-oh, we didn't lazily import the 'linalg' submodule\n                        #  earlier, and importing it like this here will cause\n                        #  both scipy and scipy.linalg (but not scipy.stats) to\n                        #  immediately become fully loaded.\n\n\nExamples: lazy callable loading\n-------------------------------\n\nTo emulate the ``from some.module import function`` syntax ``lazy_module``\nprovides ``lazy_callable``. It returns a wrapper function. Only upon being\ncalled will it trigger the loading of the target module and the calling of the\ntarget callable (function, class, etc.).\n\n.. code:: python\n\n    import lazy_import\n    fn = lazy_import.lazy_callable(\"numpy.arange\")\n    # 'numpy' is now in sys.modules and is 'Lazily-loaded module numpy'\n\n    fn(10)\n    # array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n``lazy_callable`` is only useful when the target callable is going to be called:\n\n.. code:: python\n\n    import lazy_import\n    cl = lazy_import.lazy_callable(\"numpy.ndarray\") # a class\n\n    obj = cl([1, 2]) # This works OK (and also triggers the loading of numpy)\n\n    class MySubclass(cl): # This fails because cl is just a wrapper,\n        pass              #  not an actual class.\n\n\nInstallation\n------------\n\n.. code:: bash\n\n    pip install lazy_import\n\nOr, to include dependencies needed to run regression tests:\n\n.. code:: bash\n\n    pip install lazy_import[test]\n\nTests\n-----\n\nThe ``lazy_module`` module comes with a series of tests. If you install with\ntest dependencies (see above), just run\n\n.. code:: python\n\n    import lazy_import.test_lazy\n    lazy_import.test_lazy.run()\n    # This will automatically parallelize over the available number of cores\n\nAlternatively, tests can be run from the command line:\n\n.. code:: bash\n\n    pytest -n 4 --boxed -v --pyargs lazy_import\n    # (replace '4' with the number of cores in your machine, or set to 1 if\n    #  you'd rather test in serial)\n\nTests depend only on |pytest|_ and |pytest-xdist|_, so if you didn't install\nthem along ``lazy_import`` (as described under `Installation`_) just run\n\n.. code:: bash\n\n    pip install pytest pytest-xdist\n\nNote that ``pytest-xdist`` is required even for serial testing because of its\n``--boxed`` functionality.\n\nLicense\n-------\n\n``lazy_import`` is released under GPL v3. It was based on code from the\n|importing|_ module from the PEAK_ package. The licenses for both\n``lazy_import`` and the PEAK package are included in the ``LICENSE`` file. The\nrespective license notices are reproduced here:\n\n  lazy_import \u2014 a module to allow lazy importing of python modules\n\n  Copyright (C) 2017-2018 Manuel Nuno Melo \n\n  lazy_import is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  lazy_import is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with lazy_import.  If not, see <http://www.gnu.org/licenses/>.\n\n\nThe PEAK ``importing`` code is\n\n  Copyright (C) 1996-2004 by Phillip J. Eby and Tyler C. Sarna.\n  All rights reserved.  This software may be used under the same terms\n  as Zope or Python.  THERE ARE ABSOLUTELY NO WARRANTIES OF ANY KIND.\n  Code quality varies between modules, from \"beta\" to \"experimental\n  pre-alpha\".  :)\n  \nCode pertaining to lazy loading from PEAK ``importing`` was included in\n``lazy_import``, modified in a number of ways. These are detailed in the\n``CHANGELOG`` file of ``lazy_import``. Changes mainly involved Python 3\ncompatibility, extension to allow customizable behavior, and added\nfunctionality (lazy importing of callable objects).\n\n\n.. |Build Status| image:: https://api.travis-ci.org/mnmelo/lazy_import.svg\n   :target: https://travis-ci.org/mnmelo/lazy_import\n\n.. |importing| replace:: ``importing``\n.. |pytest| replace:: ``pytest``\n.. |pytest-xdist| replace:: ``pytest-xdist``\n\n.. _importing: http://peak.telecommunity.com/DevCenter/Importing\n.. _PEAK: http://peak.telecommunity.com/DevCenter/FrontPage\n.. _pytest: https://docs.pytest.org/en/latest/\n.. _pytest-xdist: https://pypi.python.org/pypi/pytest-xdist", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/mnmelo/lazy_import", "keywords": "", "license": "GPL", "maintainer": "", "maintainer_email": "", "name": "lazy-import", "package_url": "https://pypi.org/project/lazy-import/", "platform": "any", "project_url": "https://pypi.org/project/lazy-import/", "project_urls": {"Homepage": "https://github.com/mnmelo/lazy_import"}, "release_url": "https://pypi.org/project/lazy-import/0.2.2/", "requires_dist": null, "requires_python": "", "summary": "A module for lazy loading of Python modules", "version": "0.2.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://travis-ci.org/mnmelo/lazy_import\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/44cc5ee180668e41fbd832c64c99069dd7243484/68747470733a2f2f6170692e7472617669732d63692e6f72672f6d6e6d656c6f2f6c617a795f696d706f72742e737667\"></a></p>\n<p><tt>lazy_import</tt> provides a set of functions that load modules, and related\nattributes, in a lazy fashion. This allows deferring of <tt>ImportErrors</tt> to\nactual module use-time. Likewise, actual module initialization only takes place\nat use-time. This is useful when using optional dependencies with heavy loading\ntimes and/or footprints, since that cost is only paid if the module is actually\nused.</p>\n<p>For minimal impact to other code running in the same session <tt>lazy_import</tt>\nfunctionality is implemented without the use of import hooks.</p>\n<p><tt>lazy_import</tt> is compatible with Python \u2265 2.7 or \u2265 3.4.</p>\n<div id=\"examples-lazy-module-loading\">\n<h2>Examples: lazy module loading</h2>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">lazy_import</span>\n<span class=\"n\">np</span> <span class=\"o\">=</span> <span class=\"n\">lazy_import</span><span class=\"o\">.</span><span class=\"n\">lazy_module</span><span class=\"p\">(</span><span class=\"s2\">\"numpy\"</span><span class=\"p\">)</span>\n<span class=\"c1\"># np is now available in the namespace and is listed in sys.modules under</span>\n<span class=\"c1\">#  the 'numpy' key:</span>\n<span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">modules</span><span class=\"p\">[</span><span class=\"s1\">'numpy'</span><span class=\"p\">]</span>\n<span class=\"c1\"># The module is present as \"Lazily-loaded module numpy\"</span>\n\n<span class=\"c1\"># Subsequent imports of the same module return the lazy version present</span>\n<span class=\"c1\">#  in sys.modules</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"c1\"># At this point numpy and np point to the same lazy module.</span>\n<span class=\"c1\"># This is true for any import of 'numpy', even if from other modules!</span>\n\n<span class=\"c1\"># Accessing attributes causes the full loading of the module ...</span>\n<span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span>\n<span class=\"c1\"># ... and the module is changed in place. np and numpy are now</span>\n<span class=\"c1\">#  \"&lt;module 'numpy' from '/usr/local/lib/python/site-packages/numpy/__init__.py'&gt;\"</span>\n\n<span class=\"c1\"># Lazy-importing a module that's already fully loaded returns the full</span>\n<span class=\"c1\">#  module instead (even if it was loaded elsewhere in the current session)</span>\n<span class=\"c1\">#  because there's no point in being lazy in this case:</span>\n<span class=\"n\">os</span> <span class=\"o\">=</span> <span class=\"n\">lazy_import</span><span class=\"o\">.</span><span class=\"n\">lazy_module</span><span class=\"p\">(</span><span class=\"s2\">\"os\"</span><span class=\"p\">)</span>\n<span class=\"c1\"># \"&lt;module 'os' from '/usr/lib/python/os.py'&gt;\"</span>\n</pre>\n<p>In the above code it can be seen that issuing\n<tt><span class=\"pre\">lazy_import.lazy_module(\"numpy\")</span></tt> registers the lazy module in the\nsession-wide <tt>sys.modules</tt> registry. This means that <em>any</em> subsequent import\nof <tt>numpy</tt> in the same session, while the module is still not fully loaded,\nwill get served a lazy version of the <tt>numpy</tt> module. This will happen also\noutside the code that calls <tt>lazy_module</tt>:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">lazy_import</span>\n<span class=\"n\">np</span> <span class=\"o\">=</span> <span class=\"n\">lazy_import</span><span class=\"o\">.</span><span class=\"n\">lazy_module</span><span class=\"p\">(</span><span class=\"s2\">\"numpy\"</span><span class=\"p\">)</span>\n<span class=\"kn\">import</span> <span class=\"nn\">module_that_uses_numpy</span> <span class=\"c1\"># This module will get a lazy module upon</span>\n                              <span class=\"c1\"># 'import numpy'</span>\n</pre>\n<p>Normally this is ok because the lazy module will behave pretty much as the real\nthing once fully-loaded. Still, it might be a good practice to document that\nyou\u2019re lazily importing modules so-and-so, so that users are warned.</p>\n<p>Further uses are to delay <tt>ImportErrors</tt>:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">lazy_import</span>\n<span class=\"c1\"># The following succeeds even when asking for a module that's not available</span>\n<span class=\"n\">missing</span> <span class=\"o\">=</span> <span class=\"n\">lazy_import</span><span class=\"o\">.</span><span class=\"n\">lazy_module</span><span class=\"p\">(</span><span class=\"s2\">\"missing_module\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">missing</span><span class=\"o\">.</span><span class=\"n\">some_attr</span> <span class=\"c1\"># This causes the full loading of the module, which now fails.</span>\n<span class=\"s2\">\"ImportError: __main__ attempted to use a functionality that requires module</span>\n <span class=\"n\">missing_module</span><span class=\"p\">,</span> <span class=\"n\">but</span> <span class=\"n\">it</span> <span class=\"n\">couldn</span><span class=\"s1\">'t be loaded. Please install missing_module and retry.\"</span>\n</pre>\n<p>Submodules work too:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">lazy_import</span>\n<span class=\"n\">mod</span> <span class=\"o\">=</span> <span class=\"n\">lazy_import</span><span class=\"o\">.</span><span class=\"n\">lazy_module</span><span class=\"p\">(</span><span class=\"s2\">\"some.sub.module\"</span><span class=\"p\">)</span>\n<span class=\"c1\"># mod now points to the some.sub.module lazy module</span>\n<span class=\"c1\">#  equivalent to \"from some.sub import module as mod\"</span>\n\n<span class=\"c1\"># Alternatively the returned reference can be made to point to the</span>\n<span class=\"c1\">#  base module:</span>\n<span class=\"n\">some</span> <span class=\"o\">=</span> <span class=\"n\">lazy_import</span><span class=\"o\">.</span><span class=\"n\">lazy_module</span><span class=\"p\">(</span><span class=\"s2\">\"some.sub.module\"</span><span class=\"p\">,</span> <span class=\"n\">level</span><span class=\"o\">=</span><span class=\"s2\">\"base\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># This is equivalent to \"import some.sub.module\" in that only the base</span>\n<span class=\"c1\">#  module's name is added to the namespace. All submodules must be accessed</span>\n<span class=\"c1\">#  via that:</span>\n<span class=\"n\">some</span><span class=\"o\">.</span><span class=\"n\">sub</span> <span class=\"c1\"># Returns lazy module 'some.sub' without triggering full loading.</span>\n<span class=\"n\">some</span><span class=\"o\">.</span><span class=\"n\">sub</span><span class=\"o\">.</span><span class=\"n\">attr</span> <span class=\"c1\"># Triggers full loading of 'some' and 'some.sub'.</span>\n<span class=\"n\">some</span><span class=\"o\">.</span><span class=\"n\">sub</span><span class=\"o\">.</span><span class=\"n\">module</span><span class=\"o\">.</span><span class=\"n\">function</span><span class=\"p\">()</span> <span class=\"c1\"># Triggers loading also of 'some.sub.module'.</span>\n</pre>\n<p>Finally, if you want to mark some modules and submodules your package imports\nas always being lazy, it is as simple as lazily importing them at the root\n<cite>__init__.py</cite> level. Other files can then import all modules normally, and\nthose that have already been loaded as lazy in <cite>__init__.py</cite> will remain so:</p>\n<pre><span class=\"c1\"># in __init__.py:</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">lazy_import</span>\n<span class=\"n\">lazy_import</span><span class=\"o\">.</span><span class=\"n\">lazy_module</span><span class=\"p\">(</span><span class=\"s2\">\"numpy\"</span><span class=\"p\">)</span>\n<span class=\"n\">lazy_import</span><span class=\"o\">.</span><span class=\"n\">lazy_module</span><span class=\"p\">(</span><span class=\"s2\">\"scipy.stats\"</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># then, in any other file in the package just use the imports normally:</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">requests</span> <span class=\"c1\"># This one is not lazy.</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"c1\"># This one is lazy, as long as no other code caused its</span>\n             <span class=\"c1\">#  loading in the meantime.</span>\n<span class=\"kn\">import</span> <span class=\"nn\">scipy</span> <span class=\"c1\"># This one is also lazy. It was lazily loaded as part of the</span>\n             <span class=\"c1\">#  lazy loading of scipy.stats.</span>\n<span class=\"kn\">import</span> <span class=\"nn\">scipy.stats</span> <span class=\"c1\"># Also lazy.</span>\n<span class=\"kn\">import</span> <span class=\"nn\">scipy.linalg</span> <span class=\"c1\"># Uh-oh, we didn't lazily import the 'linalg' submodule</span>\n                    <span class=\"c1\">#  earlier, and importing it like this here will cause</span>\n                    <span class=\"c1\">#  both scipy and scipy.linalg (but not scipy.stats) to</span>\n                    <span class=\"c1\">#  immediately become fully loaded.</span>\n</pre>\n</div>\n<div id=\"examples-lazy-callable-loading\">\n<h2>Examples: lazy callable loading</h2>\n<p>To emulate the <tt>from some.module import function</tt> syntax <tt>lazy_module</tt>\nprovides <tt>lazy_callable</tt>. It returns a wrapper function. Only upon being\ncalled will it trigger the loading of the target module and the calling of the\ntarget callable (function, class, etc.).</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">lazy_import</span>\n<span class=\"n\">fn</span> <span class=\"o\">=</span> <span class=\"n\">lazy_import</span><span class=\"o\">.</span><span class=\"n\">lazy_callable</span><span class=\"p\">(</span><span class=\"s2\">\"numpy.arange\"</span><span class=\"p\">)</span>\n<span class=\"c1\"># 'numpy' is now in sys.modules and is 'Lazily-loaded module numpy'</span>\n\n<span class=\"n\">fn</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"c1\"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>\n</pre>\n<p><tt>lazy_callable</tt> is only useful when the target callable is going to be called:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">lazy_import</span>\n<span class=\"n\">cl</span> <span class=\"o\">=</span> <span class=\"n\">lazy_import</span><span class=\"o\">.</span><span class=\"n\">lazy_callable</span><span class=\"p\">(</span><span class=\"s2\">\"numpy.ndarray\"</span><span class=\"p\">)</span> <span class=\"c1\"># a class</span>\n\n<span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"n\">cl</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span> <span class=\"c1\"># This works OK (and also triggers the loading of numpy)</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MySubclass</span><span class=\"p\">(</span><span class=\"n\">cl</span><span class=\"p\">):</span> <span class=\"c1\"># This fails because cl is just a wrapper,</span>\n    <span class=\"k\">pass</span>              <span class=\"c1\">#  not an actual class.</span>\n</pre>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<pre>pip install lazy_import\n</pre>\n<p>Or, to include dependencies needed to run regression tests:</p>\n<pre>pip install lazy_import<span class=\"o\">[</span>test<span class=\"o\">]</span>\n</pre>\n</div>\n<div id=\"tests\">\n<h2>Tests</h2>\n<p>The <tt>lazy_module</tt> module comes with a series of tests. If you install with\ntest dependencies (see above), just run</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">lazy_import.test_lazy</span>\n<span class=\"n\">lazy_import</span><span class=\"o\">.</span><span class=\"n\">test_lazy</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n<span class=\"c1\"># This will automatically parallelize over the available number of cores</span>\n</pre>\n<p>Alternatively, tests can be run from the command line:</p>\n<pre>pytest -n <span class=\"m\">4</span> --boxed -v --pyargs lazy_import\n<span class=\"c1\"># (replace '4' with the number of cores in your machine, or set to 1 if\n#  you'd rather test in serial)</span>\n</pre>\n<p>Tests depend only on <a href=\"https://docs.pytest.org/en/latest/\" rel=\"nofollow\"><tt>pytest</tt></a> and <a href=\"https://pypi.python.org/pypi/pytest-xdist\" rel=\"nofollow\"><tt><span class=\"pre\">pytest-xdist</span></tt></a>, so if you didn\u2019t install\nthem along <tt>lazy_import</tt> (as described under <a href=\"#installation\" rel=\"nofollow\">Installation</a>) just run</p>\n<pre>pip install pytest pytest-xdist\n</pre>\n<p>Note that <tt><span class=\"pre\">pytest-xdist</span></tt> is required even for serial testing because of its\n<tt><span class=\"pre\">--boxed</span></tt> functionality.</p>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p><tt>lazy_import</tt> is released under GPL v3. It was based on code from the\n<a href=\"http://peak.telecommunity.com/DevCenter/Importing\" rel=\"nofollow\"><tt>importing</tt></a> module from the <a href=\"http://peak.telecommunity.com/DevCenter/FrontPage\" rel=\"nofollow\">PEAK</a> package. The licenses for both\n<tt>lazy_import</tt> and the PEAK package are included in the <tt>LICENSE</tt> file. The\nrespective license notices are reproduced here:</p>\n<blockquote>\n<p>lazy_import \u2014 a module to allow lazy importing of python modules</p>\n<p>Copyright (C) 2017-2018 Manuel Nuno Melo</p>\n<p>lazy_import is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.</p>\n<p>lazy_import is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.</p>\n<p>You should have received a copy of the GNU General Public License\nalong with lazy_import.  If not, see &lt;<a href=\"http://www.gnu.org/licenses/\" rel=\"nofollow\">http://www.gnu.org/licenses/</a>&gt;.</p>\n</blockquote>\n<p>The PEAK <tt>importing</tt> code is</p>\n<blockquote>\nCopyright (C) 1996-2004 by Phillip J. Eby and Tyler C. Sarna.\nAll rights reserved.  This software may be used under the same terms\nas Zope or Python.  THERE ARE ABSOLUTELY NO WARRANTIES OF ANY KIND.\nCode quality varies between modules, from \u201cbeta\u201d to \u201cexperimental\npre-alpha\u201d.  :)</blockquote>\n<p>Code pertaining to lazy loading from PEAK <tt>importing</tt> was included in\n<tt>lazy_import</tt>, modified in a number of ways. These are detailed in the\n<tt>CHANGELOG</tt> file of <tt>lazy_import</tt>. Changes mainly involved Python 3\ncompatibility, extension to allow customizable behavior, and added\nfunctionality (lazy importing of callable objects).</p>\n</div>\n\n          </div>"}, "last_serial": 3509931, "releases": {"0.2": [{"comment_text": "", "digests": {"md5": "5698fa1bbfff309a0d238a2c84c5008f", "sha256": "1fafd8016bb652cc55e04b25d732f1de6cc31e1d15fa1b22ab236c3a85ae6b62"}, "downloads": -1, "filename": "lazy_import-0.2.tar.gz", "has_sig": false, "md5_digest": "5698fa1bbfff309a0d238a2c84c5008f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14519, "upload_time": "2018-01-17T14:43:34", "upload_time_iso_8601": "2018-01-17T14:43:34.470844Z", "url": "https://files.pythonhosted.org/packages/48/5a/5fcd8d0708435b00aee85ecbbb2acf942ada1880fbb2ba9f9f4bbb2f0499/lazy_import-0.2.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "c7432383c598033c842741b9dd0373af", "sha256": "83ab2c1c26a838dbd5732f4d48b730e4552d0f3a33f171133a05bbf6f5cb6d95"}, "downloads": -1, "filename": "lazy_import-0.2.1.tar.gz", "has_sig": false, "md5_digest": "c7432383c598033c842741b9dd0373af", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14528, "upload_time": "2018-01-17T18:00:34", "upload_time_iso_8601": "2018-01-17T18:00:34.724172Z", "url": "https://files.pythonhosted.org/packages/28/00/e782668b7798ac2dcc90032c1d6fface94f795d3e4c7a8c6bba6956e1fed/lazy_import-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "564449119705a15eb288fa94d21b018a", "sha256": "2149aef8579459407c62cfeccf118527939c9931ace124f355236360644f8a3d"}, "downloads": -1, "filename": "lazy_import-0.2.2.tar.gz", "has_sig": false, "md5_digest": "564449119705a15eb288fa94d21b018a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15265, "upload_time": "2018-01-22T02:19:32", "upload_time_iso_8601": "2018-01-22T02:19:32.029357Z", "url": "https://files.pythonhosted.org/packages/44/2e/5378f9b9cbc893826c2ecb022646c97ece9efbaad351adf89425fff33990/lazy_import-0.2.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "564449119705a15eb288fa94d21b018a", "sha256": "2149aef8579459407c62cfeccf118527939c9931ace124f355236360644f8a3d"}, "downloads": -1, "filename": "lazy_import-0.2.2.tar.gz", "has_sig": false, "md5_digest": "564449119705a15eb288fa94d21b018a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15265, "upload_time": "2018-01-22T02:19:32", "upload_time_iso_8601": "2018-01-22T02:19:32.029357Z", "url": "https://files.pythonhosted.org/packages/44/2e/5378f9b9cbc893826c2ecb022646c97ece9efbaad351adf89425fff33990/lazy_import-0.2.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:47:36 2020"}