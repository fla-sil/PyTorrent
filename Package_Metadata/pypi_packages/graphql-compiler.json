{"info": {"author": "Kensho Technologies, LLC.", "author_email": "graphql-compiler-maintainer@kensho.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Database :: Front-Ends", "Topic :: Software Development :: Compilers"], "description": "# graphql-compiler\n\n[![Build Status](https://travis-ci.org/kensho-technologies/graphql-compiler.svg?branch=master)](https://travis-ci.org/kensho-technologies/graphql-compiler)\n[![Coverage Status](https://coveralls.io/repos/github/kensho-technologies/graphql-compiler/badge.svg?branch=master)](https://coveralls.io/github/kensho-technologies/graphql-compiler?branch=master)\n[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0)\n[![PyPI Python](https://img.shields.io/pypi/pyversions/graphql-compiler.svg)](https://pypi.python.org/pypi/graphql-compiler)\n[![PyPI Version](https://img.shields.io/pypi/v/graphql-compiler.svg)](https://pypi.python.org/pypi/graphql-compiler)\n[![PyPI Status](https://img.shields.io/pypi/status/graphql-compiler.svg)](https://pypi.python.org/pypi/graphql-compiler)\n[![PyPI Wheel](https://img.shields.io/pypi/wheel/graphql-compiler.svg)](https://pypi.python.org/pypi/graphql-compiler)\n\nTurn complex GraphQL queries into optimized database queries.\n\n```\npip install graphql-compiler\n```\n\n## Quick Overview \n\nThrough the GraphQL compiler, users can write powerful queries that uncover \ndeep relationships in the data while not having to worry about the underlying database query \nlanguage. The GraphQL compiler turns read-only queries written in GraphQL syntax to different \nquery languages. \n\nFurthermore, the GraphQL compiler validates queries through the use of a GraphQL schema \nthat specifies the underlying schema of the database. We can currently autogenerate a \nGraphQL schema by introspecting an OrientDB database, (see [End to End Example](#end-to-end-example)). \n\nIn the near future, we plan to add schema autogeneration from SQLAlchemy metadata as well. \n\nFor a more detailed overview and getting started guide, please see\n[our blog post](https://blog.kensho.com/compiled-graphql-as-a-database-query-language-72e106844282).\n\n## Table of contents\n  * [Features](#features)\n  * [End to End Example](#end-to-end-example)\n  * [Definitions](#definitions)\n  * [Directives](#directives)\n     * [@optional](#optional)\n     * [@output](#output)\n     * [@fold](#fold)\n     * [@tag](#tag)\n     * [@filter](#filter)\n     * [@recurse](#recurse)\n     * [@output_source](#output_source)\n  * [Supported filtering operations](#supported-filtering-operations)\n     * [Comparison operators](#comparison-operators)\n     * [name_or_alias](#name_or_alias)\n     * [between](#between)\n     * [in_collection](#in_collection)\n     * [not_in_collection](#not_in_collection)\n     * [has_substring](#has_substring)\n     * [contains](#contains)\n     * [not_contains](#not_contains)\n     * [intersects](#intersects)\n     * [has_edge_degree](#has_edge_degree)\n  * [Type coercions](#type-coercions)\n  * [Meta fields](#meta-fields)\n     * [\\__typename](#__typename)\n     * [\\_x_count](#_x_count)\n  * [The GraphQL schema](#the-graphql-schema)\n  * [Execution model](#execution-model)\n  * [SQL](#sql)\n     * [Configuring SQLAlchemy](#configuring-sqlalchemy)\n     * [End-To-End SQL Example](#end-to-end-sql-example)\n     * [Configuring the SQL Database to Match the GraphQL Schema](#configuring-the-sql-database-to-match-the-graphql-schema)\n  * [Miscellaneous](#miscellaneous)\n     * [Pretty-Printing GraphQL Queries](#pretty-printing-graphql-queries)\n     * [Expanding `@optional` vertex fields](#expanding-optional-vertex-fields)\n     * [Optional `type_equivalence_hints` compilation parameter](#optional-type_equivalence_hints-parameter)\n     * [SchemaGraph](#schemagraph)\n     * [Cypher query parameters](#cypher-query-parameters)\n  * [FAQ](#faq)\n  * [License](#license)\n\n## Features\n* **Databases and Query Languages:** We currently support a single database, OrientDB version 2.2.28+, and two query languages that OrientDB supports: the OrientDB dialect of gremlin, and OrientDB's own custom SQL-like query language that we refer to as MATCH, after the name of its graph traversal operator. With OrientDB, MATCH should be the preferred choice for most users, since it tends to run faster than gremlin, and has other desirable properties. See the Execution model section for more details.\n\n   Support for relational databases including PostgreSQL, MySQL, SQLite,\n   and Microsoft SQL Server is a work in progress. A subset of compiler features are available for\n   these databases. See the [SQL](#sql) section for more details.\n* **GraphQL Language Features:**  We prioritized and implemented a subset of all functionality supported by the GraphQL language. We hope to add more functionality over time.\n\n## End-to-End Example\nEven though this example specifically targets an OrientDB database, it is meant as a generic \nend-to-end example of how to use the GraphQL compiler.\n\n```python\nfrom graphql.utils.schema_printer import print_schema\nfrom graphql_compiler import (\n    get_graphql_schema_from_orientdb_schema_data, graphql_to_match\n)\nfrom graphql_compiler.schema_generation.orientdb.utils import ORIENTDB_SCHEMA_RECORDS_QUERY\n\n# Step 1: Get schema metadata from hypothetical Animals database.\nclient = your_function_that_returns_an_orientdb_client()\nschema_records = client.command(ORIENTDB_SCHEMA_RECORDS_QUERY)\nschema_data = [record.oRecordData for record in schema_records]\n\n# Step 2: Generate GraphQL schema from metadata.\nschema, type_equivalence_hints = get_graphql_schema_from_orientdb_schema_data(schema_data)\n\nprint(print_schema(schema))\n# schema {\n#    query: RootSchemaQuery\n# }\n#\n# directive @filter(op_name: String!, value: [String!]!) on FIELD | INLINE_FRAGMENT\n#\n# directive @tag(tag_name: String!) on FIELD\n#\n# directive @output(out_name: String!) on FIELD\n#\n# directive @output_source on FIELD\n#\n# directive @optional on FIELD\n#\n# directive @recurse(depth: Int!) on FIELD\n#\n# directive @fold on FIELD\n#\n# type Animal {\n#     name: String\n#     net_worth: Int\n#     limbs: Int\n# }\n#\n# type RootSchemaQuery{\n#     Animal: [Animal]\n# }\n\n# Step 3: Write GraphQL query that returns the names of all animals with a certain net worth.\n# Note that we prefix net_worth with '$' and surround it with quotes to indicate it's a parameter.\ngraphql_query = '''\n{\n    Animal {\n        name @output(out_name: \"animal_name\")\n        net_worth @filter(op_name: \"=\", value: [\"$net_worth\"])\n    }\n}\n'''\nparameters = {\n    'net_worth': '100',\n}\n\n# Step 4: Use autogenerated GraphQL schema to compile query into the target database language.\ncompilation_result = graphql_to_match(schema, graphql_query, parameters, type_equivalence_hints)\nprint(compilation_result.query)\n# SELECT Animal___1.name AS `animal_name` \n# FROM  ( MATCH  { class: Animal, where: ((net_worth = decimal(\"100\"))), as: Animal___1 } \n# RETURN $matches)\n```\n## Definitions\n- **Vertex field**: A field corresponding to a vertex in the graph. In the below example, `Animal`\n  and `out_Entity_Related` are vertex fields. The `Animal` field is the field at which querying\n  starts, and is therefore the **root vertex field**. In any scope, fields with the prefix `out_`\n  denote vertex fields connected by an outbound edge, whereas ones with the prefix `in_` denote\n  vertex fields connected by an inbound edge.\n```graphql\n{\n    Animal {\n        name @output(out_name: \"name\")\n        out_Entity_Related {\n            ... on Species {\n                description @output(out_name: \"description\")\n            }\n        }\n    }\n}\n```\n- **Property field**: A field corresponding to a property of a vertex in the graph. In the\n  above example, the `name` and `description` fields are property fields. In any given scope,\n  **property fields must appear before vertex fields**.\n- **Result set**: An assignment of vertices in the graph to scopes (locations) in the query.\n  As the database processes the query, new result sets may be created (e.g. when traversing edges),\n  and result sets may be discarded when they do not satisfy filters or type coercions. After all\n  parts of the query are processed by the database, all remaining result sets are used to form the\n  query result, by taking their values at all properties marked for output.\n- **Scope**: The part of a query between any pair of curly braces. The compiler infers the type\n  of each scope. For example, in the above query, the scope beginning with `Animal {` is of\n  type `Animal`, the one beginning with `out_Entity_Related {` is of type `Entity`, and the one\n  beginning with `... on Species {` is of type `Species`.\n- **Type coercion**: An operation that produces a new scope of narrower type than the\n  scope in which it exists. Any result sets that cannot satisfy the narrower type are filtered out\n  and not returned. In the above query, `... on Species` is a type coercion which takes\n  its enclosing scope of type `Entity`, and coerces it into a narrower scope of\n  type `Species`. This is possible since `Entity` is an interface, and `Species` is a type\n  that implements the `Entity` interface.\n\n## Directives\n\n### @optional\n\nWithout this directive, when a query includes a vertex field, any results matching that query\nmust be able to produce a value for that vertex field. Applied to a vertex field,\nthis directive prevents result sets that are unable to produce a value for that field from\nbeing discarded, and allowed to continue processing the remainder of the query.\n\n#### Example Use\n```graphql\n{\n    Animal {\n        name @output(out_name: \"name\")\n        out_Animal_ParentOf @optional {\n            name @output(out_name: \"child_name\")\n        }\n    }\n}\n```\nFor each `Animal`:\n- if it is a parent of another animal, at least one row containing the\n  parent and child animal's names, in the `name` and `child_name` columns respectively;\n- if it is not a parent of another animal, a row with its name in the `name` column,\n  and a `null` value in the `child_name` column.\n\n#### Constraints and Rules\n- `@optional` can only be applied to vertex fields, except the root vertex field.\n- It is allowed to expand vertex fields within an `@optional` scope.\n  However, doing so is currently associated with a performance penalty in `MATCH`.\n  For more detail, see: [Expanding `@optional` vertex fields](#expanding-optional-vertex-fields).\n- `@recurse`, `@fold`, or `@output_source` may not be used at the same vertex field as `@optional`.\n- `@output_source` and `@fold` may not be used anywhere within a scope\n  marked `@optional`.\n\nIf a given result set is unable to produce a value for a vertex field marked `@optional`,\nany fields marked `@output` within that vertex field return the `null` value.\n\nWhen filtering (via `@filter`) or type coercion (via e.g. `... on Animal`) are applied\nat or within a vertex field marked `@optional`, the `@optional` is given precedence:\n- If a given result set cannot produce a value for the optional vertex field, it is preserved:\nthe `@optional` directive is applied first, and no filtering or type coercion can happen.\n- If a given result set is able to produce a value for the optional vertex field,\nthe `@optional` does not apply, and that value is then checked against the filtering or type\ncoercion. These subsequent operations may then cause the result set to be discarded if it does\nnot match.\n\nFor example, suppose we have two `Person` vertices with names `Albert` and `Betty` such that there is a `Person_Knows` edge from `Albert` to `Betty`.\n\nThen the following query:\n```graphql\n{\n  Person {\n    out_Person_Knows @optional {\n      name @filter(op_name: \"=\", value: [\"$name\"])\n    }\n    name @output(out_name: \"person_name\")\n  }\n}\n```\nwith runtime parameter\n```python\n{\n  \"name\": \"Charles\"\n}\n```\nwould output an empty list because the `Person_Knows` edge from `Albert` to `Betty` satisfies the `@optional` directive, but `Betty` doesn't match the filter checking for a node with name `Charles`.\n\nHowever, if no such `Person_Knows` edge existed from `Albert`, then the output would be\n```python\n{\n  name: 'Albert'\n}\n```\nbecause no such edge can satisfy the `@optional` directive, and no filtering happens.\n\n### @output\n\nDenotes that the value of a property field should be included in the output.\nIts `out_name` argument specifies the name of the column in which the\noutput value should be returned.\n\n#### Example Use\n```graphql\n{\n    Animal {\n        name @output(out_name: \"animal_name\")\n    }\n}\n```\nThis query returns the name of each `Animal` in the graph, in a column named `animal_name`.\n\n#### Constraints and Rules\n- `@output` can only be applied to property fields.\n- The value provided for `out_name` may only consist of upper or lower case letters\n  (`A-Z`, `a-z`), or underscores (`_`).\n- The value provided for `out_name` cannot be prefixed with `___` (three underscores). This\nnamespace is reserved for compiler internal use.\n- For any given query, all `out_name` values must be unique. In other words, output columns must\n  have unique names.\n\nIf the property field marked `@output` exists within a scope marked `@optional`, result sets that\nare unable to assign a value to the optional scope return the value `null` as the output\nof that property field.\n\n### @fold\n\nApplying `@fold` on a scope \"folds\" all outputs from within that scope: rather than appearing\non separate rows in the query result, the folded outputs are coalesced into lists starting\nat the scope marked `@fold`.\n\n#### Example Use\n```graphql\n{\n    Animal {\n        name @output(out_name: \"animal_name\")\n        out_Animal_ParentOf @fold {\n            name @output(out_name: \"child_names\")\n        }\n    }\n}\n```\nEach returned row has two columns: `animal_name` with the name of each `Animal` in the graph,\nand `child_names` with a list of the names of all children of the `Animal` named `animal_name`.\nIf a given `Animal` has no children, its `child_names` list is empty.\n\n#### Constraints and Rules\n- `@fold` can only be applied to vertex fields, except the root vertex field.\n- May not exist at the same vertex field as `@recurse`, `@optional`, or `@output_source`.\n- Any scope that is either marked with `@fold` or is nested within a `@fold` marked scope,\n  may expand at most one vertex field.\n- There must be at least one `@output` field within a `@fold` scope.\n- All `@output` fields within a `@fold` traversal must be present at the innermost scope.\n  It is invalid to expand vertex fields within a `@fold` after encountering an `@output` directive.\n- `@tag`, `@recurse`, `@optional`, `@output_source` and `@fold` may not be used anywhere\n  within a scope marked `@fold`.\n- Use of type coercions or `@filter` at or within the vertex field marked `@fold` is allowed.\n  Only data that satisfies the given type coercions and filters is returned by the `@fold`.\n- If the compiler is able to prove that the type coercion in the `@fold` scope is actually a no-op,\n  it may optimize it away. See the\n  [Optional `type_equivalence_hints` compilation parameter](#optional-type_equivalence_hints-parameter)\n  section for more details.\n\n#### Example\nThe following GraphQL is *not allowed* and will produce a `GraphQLCompilationError`.\nThis query is *invalid* for two separate reasons:\n- It expands vertex fields after an `@output` directive (outputting `animal_name`)\n- The `in_Animal_ParentOf` scope, which is within a scope marked `@fold`,\n  expands two vertex fields instead of at most one.\n```graphql\n{\n    Animal {\n        out_Animal_ParentOf @fold {\n            name @output(out_name: \"animal_name\")\n            in_Animal_ParentOf {\n                out_Animal_OfSpecies {\n                    uuid @output(out_name: \"species_id\")\n                }\n                out_Entity_Related {\n                    ... on Animal {\n                        name @output(out_name: \"relative_name\")\n                    }\n                }\n            }\n        }\n    }\n}\n```\nThe following is a valid use of `@fold`:\n```graphql\n{\n    Animal {\n        out_Animal_ParentOf @fold {\n            in_Animal_ParentOf {\n                in_Animal_ParentOf {\n                    out_Entity_Related {\n                        ... on Animal {\n                            name @output(out_name: \"final_name\")\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n### @tag\n\nThe `@tag` directive enables filtering based on values encountered elsewhere in the same query.\nApplied on a property field, it assigns a name to the value of that property field, allowing that\nvalue to then be used as part of a `@filter` directive.\n\nTo supply a tagged value to a `@filter` directive, place the tag name (prefixed with a `%` symbol)\nin the `@filter`'s `value` array. See [Passing parameters](#passing-parameters)\nfor more details.\n\n#### Example Use\n```graphql\n{\n    Animal {\n        name @tag(tag_name: \"parent_name\")\n        out_Animal_ParentOf {\n            name @filter(op_name: \"<\", value: [\"%parent_name\"])\n                 @output(out_name: \"child_name\")\n        }\n    }\n}\n```\nEach row returned by this query contains, in the `child_name` column, the name of an `Animal`\nthat is the child of another `Animal`, and has a name that is lexicographically smaller than\nthe name of its parent.\n\n#### Constraints and Rules\n- `@tag` can only be applied to property fields.\n- The value provided for `tag_name` may only consist of upper or lower case letters\n  (`A-Z`, `a-z`), or underscores (`_`).\n- For any given query, all `tag_name` values must be unique.\n- Cannot be applied to property fields within a scope marked `@fold`.\n- Using a `@tag` and a `@filter` that references the tag within the same vertex is allowed,\n  so long as the two do not appear on the exact same property field.\n\n### @filter\n\nAllows filtering of the data to be returned, based on any of a set of filtering operations.\nConceptually, it is the GraphQL equivalent of the SQL `WHERE` keyword.\n\nSee [Supported filtering operations](#supported-filtering-operations)\nfor details on the various types of filtering that the compiler currently supports.\nThese operations are currently hardcoded in the compiler; in the future,\nwe may enable the addition of custom filtering operations via compiler plugins.\n\nMultiple `@filter` directives may be applied to the same field at once. Conceptually,\nit is as if the different `@filter` directives were joined by SQL `AND` keywords.\n\nUsing a `@tag` and a `@filter` that references the tag within the same vertex is allowed,\nso long as the two do not appear on the exact same property field.\n\n#### Passing Parameters\n\nThe `@filter` directive accepts two types of parameters: runtime parameters and tagged parameters.\n\n**Runtime parameters** are represented with a `$` prefix (e.g. `$foo`), and denote parameters\nwhose values will be known at runtime. The compiler will compile the GraphQL query leaving a\nspot for the value to fill at runtime. After compilation, the user will have to supply values for\nall runtime parameters, and their values will be inserted into the final query before it can be\nexecuted against the database.\n\nConsider the following query:\n```graphql\n{\n    Animal {\n        name @output(out_name: \"animal_name\")\n        color @filter(op_name: \"=\", value: [\"$animal_color\"])\n    }\n}\n```\nIt returns one row for every `Animal` vertex that has a color equal to `$animal_color`. Each row\ncontains the animal's name in a column named `animal_name`. The parameter `$animal_color` is\na runtime parameter -- the user must pass in a value (e.g. `{\"animal_color\": \"blue\"}`) that\nwill be inserted into the query before querying the database.\n\n**Tagged parameters** are represented with a `%` prefix (e.g. `%foo`) and denote parameters\nwhose values are derived from a property field encountered elsewhere in the query.\nIf the user marks a property field with a `@tag` directive and a suitable name,\nthat value becomes available to use as a tagged parameter in all subsequent `@filter` directives.\n\nConsider the following query:\n```graphql\n{\n    Animal {\n        name @tag(out_name: \"parent_name\")\n        out_Animal_ParentOf {\n            name @filter(op_name: \"has_substring\", value: [\"%parent_name\"])\n                 @output(out_name: \"child_name\")\n        }\n    }\n}\n```\nIt returns the names of animals that contain their parent's name as a substring of their own.\nThe database captures the value of the parent animal's name as the `parent_name` tag, and this\nvalue is then used as the `%parent_name` tagged parameter in the child animal's `@filter`.\n\nWe considered and **rejected** the idea of allowing literal values (e.g. `123`)\nas `@filter` parameters, for several reasons:\n- The GraphQL type of the `@filter` directive's `value` field cannot reasonably encompass\n  all the different types of arguments that people might supply. Even counting scalar types only,\n  there's already `ID, Int, Float, Boolean, String, Date, DateTime...` -- way too many to include.\n- Literal values would be used when the parameter's value is known to be fixed. We can just as\n  easily accomplish the same thing by using a runtime parameter with a fixed value. That approach\n  has the added benefit of potentially reducing the number of different queries that have to be\n  compiled: two queries with different literal values would have to be compiled twice, whereas\n  using two different sets of runtime arguments only requires the compilation of one query.\n- We were concerned about the potential for accidental misuse of literal values. SQL systems have\n  supported stored procedures and parameterized queries for decades, and yet ad-hoc SQL query\n  construction via simple string interpolation is still a serious problem and is the source of\n  many SQL injection vulnerabilities. We felt that disallowing literal values in the query will\n  drastically reduce both the use and the risks of unsafe string interpolation,\n  at an acceptable cost.\n\n#### Constraints and Rules\n- The value provided for `op_name` may only consist of upper or lower case letters\n  (`A-Z`, `a-z`), or underscores (`_`).\n- Values provided in the `value` list must start with either `$`\n  (denoting a runtime parameter) or `%` (denoting a tagged parameter),\n  followed by exclusively upper or lower case letters (`A-Z`, `a-z`) or underscores (`_`).\n- The `@tag` directives corresponding to any tagged parameters in a given `@filter` query\n  must be applied to fields that appear either at the same vertex as the one with the `@filter`,\n  or strictly before the field with the `@filter` directive.\n- \"Can't compare apples and oranges\" -- the GraphQL type of the parameters supplied to the `@filter`\n  must match the GraphQL types the compiler infers based on the field the `@filter` is applied to.\n- If the `@tag` corresponding to a tagged parameter originates from within a vertex field\n  marked `@optional`, the emitted code for the `@filter` checks if the `@optional` field was\n  assigned a value. If no value was assigned to the `@optional` field, comparisons against the\n  tagged parameter from within that field return `True`.\n  - For example, assuming `%from_optional` originates from an `@optional` scope, when no value is\n    assigned to the `@optional` field:\n    - using `@filter(op_name: \"=\", value: [\"%from_optional\"])` is equivalent to not\n      having the filter at all;\n    - using `@filter(op_name: \"between\", value: [\"$lower\", \"%from_optional\"])` is equivalent to\n      `@filter(op_name: \">=\", value: [\"$lower\"])`.\n- Using a `@tag` and a `@filter` that references the tag within the same vertex is allowed,\n  so long as the two do not appear on the exact same property field.\n\n\n### @recurse\n\nApplied to a vertex field, specifies that the edge connecting that vertex field to the current\nvertex should be visited repeatedly, up to `depth` times. The recursion always starts\nat `depth = 0`, i.e. the current vertex -- see the below sections for a more thorough explanation.\n\n#### Example Use\nSay the user wants to fetch the names of the children and grandchildren of each `Animal`.\nThat could be accomplished by running the following two queries and concatenating their results:\n```graphql\n{\n    Animal {\n        name @output(out_name: \"ancestor\")\n        out_Animal_ParentOf {\n            name @output(out_name: \"descendant\")\n        }\n    }\n}\n```\n```graphql\n{\n    Animal {\n        name @output(out_name: \"ancestor\")\n        out_Animal_ParentOf {\n            out_Animal_ParentOf {\n                name @output(out_name: \"descendant\")\n            }\n        }\n    }\n}\n```\nIf the user then wanted to also add great-grandchildren to the `descendants` output, that would\nrequire yet another query, and so on. Instead of concatenating the results of multiple queries,\nthe user can simply use the `@recurse` directive. The following query returns the child and\ngrandchild descendants:\n```graphql\n{\n    Animal {\n        name @output(out_name: \"ancestor\")\n        out_Animal_ParentOf {\n            out_Animal_ParentOf @recurse(depth: 1) {\n                name @output(out_name: \"descendant\")\n            }\n        }\n    }\n}\n```\nEach row returned by this query contains the name of an `Animal` in the `ancestor` column\nand the name of its child or grandchild in the `descendant` column.\nThe `out_Animal_ParentOf` vertex field marked `@recurse` is already enclosed within\nanother `out_Animal_ParentOf` vertex field, so the recursion starts at the\n\"child\" level (the `out_Animal_ParentOf` not marked with `@recurse`).\nTherefore, the `descendant` column contains the names of an `ancestor`'s\nchildren (from `depth = 0` of the recursion) and the names of its grandchildren (from `depth = 1`).\n\nRecursion using this directive is possible since the types of the enclosing scope and the recursion\nscope work out: the `@recurse` directive is applied to a vertex field of type `Animal` and\nits vertex field is enclosed within a scope of type `Animal`.\nAdditional cases where recursion is allowed are described in detail below.\n\nThe `descendant` column cannot have the name of the `ancestor` animal since the `@recurse`\nis already within one `out_Animal_ParentOf` and not at the root `Animal` vertex field.\nSimilarly, it cannot have descendants that are more than two steps removed\n(e.g., great-grandchildren), since the `depth` parameter of `@recurse` is set to `1`.\n\nNow, let's see what happens when we eliminate the outer `out_Animal_ParentOf` vertex field\nand simply have the `@recurse` applied on the `out_Animal_ParentOf` in the root vertex field scope:\n```graphql\n{\n    Animal {\n        name @output(out_name: \"ancestor\")\n        out_Animal_ParentOf @recurse(depth: 1) {\n            name @output(out_name: \"self_or_descendant\")\n        }\n    }\n}\n```\nIn this case, when the recursion starts at `depth = 0`, the `Animal` within the recursion scope\nwill be the same `Animal` at the root vertex field, and therefore, in the `depth = 0` step of\nthe recursion, the value of the `self_or_descendant` field will be equal to the value of\nthe `ancestor` field.\n\n#### Constraints and Rules\n- \"The types must work out\" -- when applied within a scope of type `A`,\n  to a vertex field of type `B`, at least one of the following must be true:\n  - `A` is a GraphQL union;\n  - `B` is a GraphQL interface, and `A` is a type that implements that interface;\n  - `A` and `B` are the same type.\n- `@recurse` can only be applied to vertex fields other than the root vertex field of a query.\n- Cannot be used within a scope marked `@optional` or `@fold`.\n- The `depth` parameter of the recursion must always have a value greater than or equal to 1.\n  Using `depth = 1` produces the current vertex and its neighboring vertices along the\n  specified edge.\n- Type coercions and `@filter` directives within a scope marked `@recurse` do not limit the\n  recursion depth. Conceptually, recursion to the specified depth happens first,\n  and then type coercions and `@filter` directives eliminate some of the locations reached\n  by the recursion.\n- As demonstrated by the examples above, the recursion always starts at depth 0,\n  so the recursion scope always includes the vertex at the scope that encloses\n  the vertex field marked `@recurse`.\n\n### @output_source\n\nSee the [Completeness of returned results](#completeness-of-returned-results) section\nfor a description of the directive and examples.\n\n#### Constraints and Rules\n- May exist at most once in any given GraphQL query.\n- Can exist only on a vertex field, and only on the last vertex field used in the query.\n- Cannot be used within a scope marked `@optional` or `@fold`.\n\n## Supported filtering operations\n\n### Comparison operators\n\nSupported comparison operators:\n- Equal to: `=`\n- Not equal to: `!=`\n- Greater than: `>`\n- Less than: `<`\n- Greater than or equal to: `>=`\n- Less than or equal to: `<=`\n\n#### Example Use\n\n##### Equal to (`=`):\n```graphql\n{\n    Species {\n        name @filter(op_name: \"=\", value: [\"$species_name\"])\n        uuid @output(out_name: \"species_uuid\")\n    }\n}\n```\nThis returns one row for every `Species` whose name is equal to the value of the `$species_name`\nparameter. Each row contains the `uuid` of the `Species` in a column named `species_uuid`.\n\n##### Greater than or equal to (`>=`):\n```\n{\n    Animal {\n        name @output(out_name: \"name\")\n        birthday @output(out_name: \"birthday\")\n                 @filter(op_name: \">=\", value: [\"$point_in_time\"])\n    }\n}\n```\nThis returns one row for every `Animal` vertex that was born after or on a `$point_in_time`.\nEach row contains the animal's name and birthday in columns named `name` and `birthday`, respectively.\n\n#### Constraints and Rules\n- All comparison operators must be on a property field.\n\n### name_or_alias\n\nAllows you to filter on vertices which contain the exact string `$wanted_name_or_alias` in their\n`name` or `alias` fields.\n\n#### Example Use\n```graphql\n{\n    Animal @filter(op_name: \"name_or_alias\", value: [\"$wanted_name_or_alias\"]) {\n        name @output(out_name: \"name\")\n    }\n}\n```\nThis returns one row for every `Animal` vertex whose name and/or alias is equal to `$wanted_name_or_alias`.\nEach row contains the animal's name in a column named `name`.\n\nThe value provided for `$wanted_name_or_alias` must be the full name and/or alias of the `Animal`.\nSubstrings will not be matched.\n\n#### Constraints and Rules\n- Must be on a vertex field that has `name` and `alias` properties.\n\n### between\n#### Example Use\n```graphql\n{\n    Animal {\n        name @output(out_name: \"name\")\n        birthday @filter(op_name: \"between\", value: [\"$lower\", \"$upper\"])\n                 @output(out_name: \"birthday\")\n    }\n}\n```\nThis returns:\n- One row for every `Animal` vertex whose birthday is in between `$lower` and `$upper` dates (inclusive).\nEach row contains the animal's name in a column named `name`.\n\n#### Constraints and Rules\n- Must be on a property field.\n- The lower and upper bounds represent an inclusive interval, which means that the output may\n  contain values that match them exactly.\n\n### in_collection\n#### Example Use\n```graphql\n{\n    Animal {\n        name @output(out_name: \"animal_name\")\n        color @output(out_name: \"color\")\n              @filter(op_name: \"in_collection\", value: [\"$colors\"])\n    }\n}\n```\nThis returns one row for every `Animal` vertex which has a color contained in a list of colors.\nEach row contains the `Animal`'s name and color in columns named `animal_name` and `color`, respectively.\n\n#### Constraints and Rules\n- Must be on a property field that is not of list type.\n\n### not_in_collection\n#### Example Use\n```graphql\n{\n    Animal {\n        name @output(out_name: \"animal_name\")\n        color @output(out_name: \"color\")\n              @filter(op_name: \"not_in_collection\", value: [\"$colors\"])\n    }\n}\n```\nThis returns one row for every `Animal` vertex which has a color not contained in a list of colors.\nEach row contains the `Animal`'s name and color in columns named `animal_name` and `color`, respectively.\n\n#### Constraints and Rules\n- Must be on a property field that is not of list type.\n\n### has_substring\n#### Example Use\n```graphql\n{\n    Animal {\n        name @filter(op_name: \"has_substring\", value: [\"$substring\"])\n             @output(out_name: \"animal_name\")\n    }\n}\n```\nThis returns one row for every `Animal` vertex whose name contains the value supplied\nfor the `$substring` parameter. Each row contains the matching `Animal`'s name\nin a column named `animal_name`.\n\n#### Constraints and Rules\n- Must be on a property field of string type.\n\n### contains\n#### Example Use\n```graphql\n{\n    Animal {\n        alias @filter(op_name: \"contains\", value: [\"$wanted\"])\n        name @output(out_name: \"animal_name\")\n    }\n}\n```\nThis returns one row for every `Animal` vertex whose list of aliases contains the value supplied\nfor the `$wanted` parameter. Each row contains the matching `Animal`'s name\nin a column named `animal_name`.\n\n#### Constraints and Rules\n- Must be on a property field of list type.\n\n### not_contains\n#### Example Use\n```graphql\n{\n    Animal {\n        alias @filter(op_name: \"not_contains\", value: [\"$wanted\"])\n        name @output(out_name: \"animal_name\")\n    }\n}\n```\nThis returns one row for every `Animal` vertex whose list of aliases does not contain the value supplied\nfor the `$wanted` parameter. Each row contains the matching `Animal`'s name\nin a column named `animal_name`.\n\n#### Constraints and Rules\n- Must be on a property field of list type.\n\n### intersects\n#### Example Use\n```graphql\n{\n    Animal {\n        alias @filter(op_name: \"intersects\", value: [\"$wanted\"])\n        name @output(out_name: \"animal_name\")\n    }\n}\n```\nThis returns one row for every `Animal` vertex whose list of aliases has a non-empty intersection\nwith the list of values supplied for the `$wanted` parameter.\nEach row contains the matching `Animal`'s name in a column named `animal_name`.\n\n#### Constraints and Rules\n- Must be on a property field of list type.\n\n### has_edge_degree\n#### Example Use\n```graphql\n{\n    Animal {\n        name @output(out_name: \"animal_name\")\n\n        out_Animal_ParentOf @filter(op_name: \"has_edge_degree\", value: [\"$child_count\"]) @optional {\n            uuid\n        }\n    }\n}\n```\nThis returns one row for every `Animal` vertex that has exactly `$child_count` children\n(i.e. where the `out_Animal_ParentOf` edge appears exactly `$child_count` times).\nEach row contains the matching `Animal`'s name, in a column named `animal_name`.\n\nThe `uuid` field within the `out_Animal_ParentOf` vertex field is added simply to satisfy\nthe GraphQL syntax rule that requires at least one field to exist within any `{}`.\nSince this field is not marked with any directive, it has no effect on the query.\n\n*N.B.:* Please note the `@optional` directive on the vertex field being filtered above.\nIf in your use case you expect to set `$child_count` to 0, you must also mark that\nvertex field `@optional`. Recall that absence of `@optional` implies that at least one\nsuch edge must exist. If the `has_edge_degree` filter is used with a parameter set to 0,\nthat requires the edge to not exist. Therefore, if the `@optional` is not present in this situation,\nno valid result sets can be produced, and the resulting query will return no results.\n\n#### Constraints and Rules\n- Must be on a vertex field that is not the root vertex of the query.\n- Tagged values are not supported as parameters for this filter.\n- If the runtime parameter for this operator can be `0`, it is *strongly recommended* to also apply\n`@optional` to the vertex field being filtered (see N.B. above for details).\n\n## Type coercions\n\nType coercions are operations that create a new scope whose type is different than the type of the\nenclosing scope of the coercion -- they coerce the enclosing scope into a different type.\nType coercions are represented with GraphQL inline fragments.\n\n#### Example Use\n```graphql\n{\n    Species {\n        name @output(out_name: \"species_name\")\n        out_Species_Eats {\n            ... on Food {\n                name @output(out_name: \"food_name\")\n            }\n        }\n    }\n}\n```\nHere, the `out_Species_Eats` vertex field is of the `Union__Food__FoodOrSpecies__Species` union type. To proceed\nwith the query, the user must choose which of the types in the `Union__Food__FoodOrSpecies__Species` union to use.\nIn this example, `... on Food` indicates that the `Food` type was chosen, and any vertices\nat that scope that are not of type `Food` are filtered out and discarded.\n\n```graphql\n{\n    Species {\n        name @output(out_name: \"species_name\")\n        out_Entity_Related {\n            ... on Species {\n                name @output(out_name: \"food_name\")\n            }\n        }\n    }\n}\n```\nIn this query, the `out_Entity_Related` is of `Entity` type. However, the query only wants to\nreturn results where the related entity is a `Species`, which `... on Species` ensures is the case.\n\n## Meta fields\n\n### \\_\\_typename\n\nThe compiler supports the standard GraphQL meta field `__typename`, which returns the runtime type\nof the scope where the field is found. Assuming the GraphQL schema matches the database's schema,\nthe runtime type will always be a subtype of (or exactly equal to) the static type of the scope\ndetermined by the GraphQL type system. Below, we provide an example query in which\nthe runtime type is a subtype of the static type, but is not equal to it.\n\nThe `__typename` field is treated as a property field of type `String`, and supports\nall directives that can be applied to any other property field.\n\n#### Example Use\n\n```graphql\n{\n    Entity {\n        __typename @output(out_name: \"entity_type\")\n        name @output(out_name: \"entity_name\")\n    }\n}\n```\nThis query returns one row for each `Entity` vertex. The scope in which `__typename` appears is\nof static type `Entity`. However, `Animal` is a type of `Entity`, as are `Species`, `Food`,\nand others. Vertices of all subtypes of `Entity` will therefore be returned, and the `entity_type`\ncolumn that outputs the `__typename` field will show their runtime type: `Animal`, `Species`,\n`Food`, etc.\n\n### \\_x\\_count\n\nThe `_x_count` meta field is a non-standard meta field defined by the GraphQL compiler that makes it\npossible to interact with the _number_ of elements in a scope marked `@fold`. By applying directives\nlike `@output` and `@filter` to this meta field, queries can output the number of elements captured\nin the `@fold` and filter down results to select only those with the desired fold sizes.\n\nWe use the `_x_` prefix to signify that this is an extension meta field introduced by the compiler,\nand not part of the canonical set of GraphQL meta fields defined by the GraphQL specification.\nWe do not use the GraphQL standard double-underscore (`__`) prefix for meta fields,\nsince all names with that prefix are\n[explicitly reserved and prohibited from being used](https://facebook.github.io/graphql/draft/#sec-Reserved-Names)\nin directives, fields, or any other artifacts.\n\n#### Adding the `_x_count` meta field to your schema\n\nSince the `_x_count` meta field is not currently part of the GraphQL standard, it has to be\nexplicitly added to all interfaces and types in your schema. There are two ways to do this.\n\nThe preferred way to do this is to use the `EXTENDED_META_FIELD_DEFINITIONS` constant as\na starting point for building your interfaces' and types' field descriptions:\n```\nfrom graphql import GraphQLInt, GraphQLField, GraphQLObjectType, GraphQLString\nfrom graphql_compiler import EXTENDED_META_FIELD_DEFINITIONS\n\nfields = EXTENDED_META_FIELD_DEFINITIONS.copy()\nfields.update({\n    'foo': GraphQLField(GraphQLString),\n    'bar': GraphQLField(GraphQLInt),\n    # etc.\n})\ngraphql_type = GraphQLObjectType('MyType', fields)\n# etc.\n```\n\nIf you are not able to programmatically define the schema, and instead simply have a pre-made\nGraphQL schema object that you are able to mutate, the alternative approach is via the\n`insert_meta_fields_into_existing_schema()` helper function defined by the compiler:\n```\n# assuming that existing_schema is your GraphQL schema object\ninsert_meta_fields_into_existing_schema(existing_schema)\n# existing_schema was mutated in-place and all custom meta-fields were added\n```\n\n#### Example Use\n\n```graphql\n{\n    Animal {\n        name @output(out_name: \"name\")\n        out_Animal_ParentOf @fold {\n            _x_count @output(out_name: \"number_of_children\")\n            name @output(out_name: \"child_names\")\n        }\n    }\n}\n```\nThis query returns one row for each `Animal` vertex. Each row contains its name, and the number and names\nof its children. While the output type of the `child_names` selection is a list of strings,\nthe output type of the `number_of_children` selection is an integer.\n\n```graphql\n{\n    Animal {\n        name @output(out_name: \"name\")\n        out_Animal_ParentOf @fold {\n            _x_count @filter(op_name: \">=\", value: [\"$min_children\"])\n                    @output(out_name: \"number_of_children\")\n            name @filter(op_name: \"has_substring\", value: [\"$substr\"])\n                 @output(out_name: \"child_names\")\n        }\n    }\n}\n```\nHere, we've modified the above query to add two more filtering constraints to the returned rows:\n- child `Animal` vertices must contain the value of `$substr` as a substring in their name, and\n- `Animal` vertices must have at least `$min_children` children that satisfy the above filter.\n\nImportantly, any filtering on `_x_count` is applied *after* any other filters and type coercions\nthat are present in the `@fold` in question. This order of operations matters a lot: selecting\n`Animal` vertices with 3+ children, then filtering the children based on their names is not the same\nas filtering the children first, and then selecting `Animal` vertices that have 3+ children that\nmatched the earlier filter.\n\n#### Constraints and Rules\n- The `_x_count` field is only allowed to appear within a vertex field marked `@fold`.\n- Filtering on `_x_count` is always applied *after* any other filters and type coercions present\n  in that `@fold`.\n- Filtering or outputting the value of the `_x_count` field must always be done at the innermost\n  scope of the `@fold`. It is invalid to expand vertex fields within a `@fold` after filtering\n  or outputting the value of the `_x_count` meta field.\n\n#### How is filtering on `_x_count` different from `@filter` with `has_edge_degree`?\n\nThe `has_edge_degree` filter allows filtering based on the number of edges of a particular type.\nThere are situations in which filtering with `has_edge_degree` and filtering using `=` on `_x_count`\nproduce equivalent queries. Here is one such pair of queries:\n```graphql\n{\n    Species {\n        name @output(out_name: \"name\")\n        in_Animal_OfSpecies @filter(op_name: \"has_edge_degree\", value: [\"$num_animals\"]) {\n            uuid\n        }\n    }\n}\n```\nand\n```graphql\n{\n    Species {\n        name @output(out_name: \"name\")\n        in_Animal_OfSpecies @fold {\n            _x_count @filter(op_name: \"=\", value: [\"$num_animals\"])\n        }\n    }\n}\n```\nIn both of these queries, we ask for the names of the `Species` vertices that have precisely\n`$num_animals` members. However, we have expressed this question in two different ways: once\nas a property of the `Species` vertex (\"the degree of the `in_Animal_OfSpecies` is `$num_animals`\"),\nand once as a property of the list of `Animal` vertices produced by the `@fold` (\"the number of\nelements in the `@fold` is `$num_animals`\").\n\nWhen we add additional filtering within the `Animal` vertices of the `in_Animal_OfSpecies` vertex\nfield, this distinction becomes very important. Compare the following two queries:\n```graphql\n{\n    Species {\n        name @output(out_name: \"name\")\n        in_Animal_OfSpecies @filter(op_name: \"has_edge_degree\", value: [\"$num_animals\"]) {\n            out_Animal_LivesIn {\n                name @filter(op_name: \"=\", value: [\"$location\"])\n            }\n        }\n    }\n}\n```\nversus\n```graphql\n{\n    Species {\n        name @output(out_name: \"name\")\n        in_Animal_OfSpecies @fold {\n            out_Animal_LivesIn {\n                _x_count @filter(op_name: \"=\", value: [\"$num_animals\"])\n                name @filter(op_name: \"=\", value: [\"$location\"])\n            }\n        }\n    }\n}\n```\nIn the first, for the purposes of the `has_edge_degree` filtering, the location where the animals\nlive is irrelevant: the `has_edge_degree` only makes sure that the `Species` vertex has the\ncorrect number of edges of type `in_Animal_OfSpecies`, and that's it. In contrast, the second query\nensures that only `Species` vertices that have `$num_animals` animals that live in the selected\nlocation are returned -- the location matters since the `@filter` on the `_x_count` field applies\nto the number of elements in the `@fold` scope.\n\n## The GraphQL schema\n\nThis section assumes that the reader is familiar with the way schemas work in the\n[reference implementation of GraphQL](http://graphql.org/learn/schema/).\n\nThe GraphQL schema used with the compiler must contain the custom directives and custom `Date`\nand `DateTime` scalar types defined by the compiler:\n```\ndirective @recurse(depth: Int!) on FIELD\n\ndirective @filter(value: [String!]!, op_name: String!) on FIELD | INLINE_FRAGMENT\n\ndirective @tag(tag_name: String!) on FIELD\n\ndirective @output(out_name: String!) on FIELD\n\ndirective @output_source on FIELD\n\ndirective @optional on FIELD\n\ndirective @fold on FIELD\n\nscalar DateTime\n\nscalar Date\n```\nIf constructing the schema programmatically, one can simply import the the Python object\nrepresentations of the custom directives and the custom types:\n```\nfrom graphql_compiler import DIRECTIVES  # the list of custom directives\nfrom graphql_compiler import GraphQLDate, GraphQLDateTime  # the custom types\n```\n\nSince the GraphQL and OrientDB type systems have different rules, there is no one-size-fits-all\nsolution to writing the GraphQL schema for a given database schema.\nHowever, the following rules of thumb are useful to keep in mind:\n- Generally, represent OrientDB abstract classes as GraphQL interfaces. In GraphQL's type system,\n  GraphQL interfaces cannot inherit from other GraphQL interfaces.\n- Generally, represent OrientDB non-abstract classes as GraphQL types,\n  listing the GraphQL interfaces that they implement. In GraphQL's type system, GraphQL types\n  cannot inherit from other GraphQL types.\n- Inheritance relationships between two OrientDB non-abstract classes,\n  or between two OrientDB abstract classes, introduce some difficulties in GraphQL.\n  When modelling your data in OrientDB, it's best to avoid such inheritance if possible.\n- If it is impossible to avoid having two non-abstract OrientDB classes `A` and `B` such that\n  `B` inherits from `A`, you have two options:\n    - You may choose to represent the `A` OrientDB class as a GraphQL interface,\n      which the GraphQL type corresponding to `B` can implement.\n      In this case, the GraphQL schema preserves the inheritance relationship\n      between `A` and `B`, but sacrifices the representation of any inheritance relationships\n      `A` may have with any OrientDB superclasses.\n    - You may choose to represent both `A` and `B` as GraphQL types. The tradeoff in this case is\n      exactly the opposite from the previous case: the GraphQL schema\n      sacrifices the inheritance relationship between `A` and `B`, but preserves the\n      inheritance relationships of `A` with its superclasses.\n      In this case, it is recommended to create a GraphQL union type `A | B`,\n      and to use that GraphQL union type for any vertex fields that\n      in OrientDB would be of type `A`.\n- If it is impossible to avoid having two abstract OrientDB classes `A` and `B` such that\n  `B` inherits from `A`, you similarly have two options:\n    - You may choose to represent `B` as a GraphQL type that can implement the GraphQL interface\n      corresponding to `A`. This makes the GraphQL schema preserve the inheritance relationship\n      between `A` and `B`, but sacrifices the ability for other GraphQL types to inherit from `B`.\n    - You may choose to represent both `A` and `B` as GraphQL interfaces, sacrificing the schema's\n      representation of the inheritance between `A` and `B`, but allowing GraphQL types\n      to inherit from both `A` and `B`. If necessary, you can then create a GraphQL\n      union type `A | B` and use it for any vertex fields that in OrientDB would be of type `A`.\n- It is legal to fully omit classes and fields that are not representable in GraphQL. The compiler\n  currently does not support OrientDB's `EmbeddedMap` type nor embedded non-primitive typed fields,\n  so such fields can simply be omitted in the GraphQL representation of their classes.\n  Alternatively, the entire OrientDB class and all edges that may point to it may be omitted\n  entirely from the GraphQL schema.\n\n## Execution model\n\nSince the GraphQL compiler can target multiple different query languages, each with its own\nbehaviors and limitations, the execution model must also be defined as a function of the\ncompilation target language. While we strive to minimize the differences between\ncompilation targets, some differences are unavoidable.\n\nThe compiler abides by the following principles:\n- When the database is queried with a compiled query string, its response must always be in the\n  form of a list of results.\n- The precise format of each such result is defined by each compilation target separately.\n  - `gremlin`, `MATCH` and `SQL` return data in a tabular format, where each result is\n    a row of the table, and fields marked for output are columns.\n  - However, future compilation targets may have a different format. For example, each result\n    may appear in the nested tree format used by the standard GraphQL specification.\n- Each such result must satisfy all directives and types in its corresponding GraphQL query.\n- The returned list of results is **not** guaranteed to be complete!\n  - In other words, there may have been additional result sets that satisfy all directives and\n    types in the corresponding GraphQL query, but were not returned by the database.\n  - However, compilation target implementations are encouraged to return complete results\n    if at all practical. The `MATCH` compilation target is guaranteed to produce complete results.\n\n### Completeness of returned results\n\nTo explain the completeness of returned results in more detail, assume the database contains\nthe following example graph:\n```\na  ---->_ x\n|____   /|\n    _|_/\n   / |____\n  /      \\/\nb  ----> y\n```\nLet `a, b, x, y` be the values of the `name` property field of four vertices.\nLet the vertices named `a` and `b` be of type `S`, and let `x` and `y` be of type `T`.\nLet vertex `a` be connected to both `x` and `y` via directed edges of type `E`.\nSimilarly, let vertex `b` also be connected to both `x` and `y` via directed edges of type `E`.\n\nConsider the GraphQL query:\n```\n{\n    S {\n        name @output(out_name: \"s_name\")\n        out_E {\n            name @output(out_name: \"t_name\")\n        }\n    }\n}\n```\n\nBetween the data in the database and the query's structure, it is clear that combining any of\n`a` or `b` with any of `x` or `y` would produce a valid result. Therefore,\nthe complete result list, shown here in JSON format, would be:\n```\n[\n    {\"s_name\": \"a\", \"t_name\": \"x\"},\n    {\"s_name\": \"a\", \"t_name\": \"y\"},\n    {\"s_name\": \"b\", \"t_name\": \"x\"},\n    {\"s_name\": \"b\", \"t_name\": \"y\"},\n]\n```\n\nThis is precisely what the `MATCH` compilation target is guaranteed to produce.\nThe remainder of this section is only applicable to the `gremlin` compilation target. If using\n`MATCH`, all of the queries listed in the remainder of this section will produce the same, complete\nresult list.\n\nSince the `gremlin` compilation target does not guarantee a complete result list,\nquerying the database using a query string generated by the `gremlin` compilation target\nwill produce only a partial result list resembling the following:\n```\n[\n    {\"s_name\": \"a\", \"t_name\": \"x\"},\n    {\"s_name\": \"b\", \"t_name\": \"x\"},\n]\n```\n\nDue to limitations in the underlying query language, `gremlin` will by default produce at most one\nresult for each of the starting locations in the query. The above GraphQL query started at\nthe type `S`, so each `s_name` in the returned result list is therefore distinct. Furthermore,\nthere is no guarantee (and no way to know ahead of time) whether `x` or `y` will be returned as\nthe `t_name` value in each result, as they are both valid results.\n\nUsers may apply the `@output_source` directive on the last scope of the query\nto alter this behavior:\n```graphql\n{\n    S {\n        name @output(out_name: \"s_name\")\n        out_E @output_source {\n            name @output(out_name: \"t_name\")\n        }\n    }\n}\n```\n\nRather than producing at most one result for each `S`, the query will now produce\nat most one result for each distinct value that can be found at `out_E`, where the directive\nis applied:\n```graphql\n[\n    {\"s_name\": \"a\", \"t_name\": \"x\"},\n    {\"s_name\": \"a\", \"t_name\": \"y\"},\n]\n```\n\nConceptually, applying the `@output_source` directive makes it as if the query were written in\nthe opposite order:\n```graphql\n{\n    T {\n        name @output(out_name: \"t_name\")\n        in_E {\n            name @output(out_name: \"s_name\")\n        }\n    }\n}\n```\n\n## SQL\nThe following table outlines GraphQL compiler features, and their support (if any) by various \nrelational database flavors:\n\n\n| Feature/Dialect      | Required Edges | @filter                                                                                                                         | @output                                                          | @recurse | @fold | @optional | @output_source |\n|----------------------|----------------|---------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------|----------|-------|-----------|----------------|\n| PostgreSQL           | No             | Limited, [intersects](#intersects), [has_edge_degree](#has_edge_degree), and [name_or_alias](#name_or_alias) filter unsupported | Limited, [\\__typename](#__typename) output metafield unsupported | No       | No    | No        | No             |\n| SQLite               | No             | Limited, [intersects](#intersects), [has_edge_degree](#has_edge_degree), and [name_or_alias](#name_or_alias) filter unsupported | Limited, [\\__typename](#__typename) output metafield unsupported | No       | No    | No        | No             |\n| Microsoft SQL Server | No             | Limited, [intersects](#intersects), [has_edge_degree](#has_edge_degree), and [name_or_alias](#name_or_alias) filter unsupported | Limited, [\\__typename](#__typename) output metafield unsupported | No       | No    | No        | No             |\n| MySQL                | No             | Limited, [intersects](#intersects), [has_edge_degree](#has_edge_degree), and [name_or_alias](#name_or_alias) filter unsupported | Limited, [\\__typename](#__typename) output metafield unsupported | No       | No    | No        | No             |\n| MariaDB              | No             | Limited, [intersects](#intersects), [has_edge_degree](#has_edge_degree), and [name_or_alias](#name_or_alias) filter unsupported | Limited, [\\__typename](#__typename) output metafield unsupported | No       | No    | No        | No             |\n\n### Configuring SQLAlchemy\nRelational databases are supported by compiling to SQLAlchemy core as an intermediate\nlanguage, and then relying on SQLAlchemy's compilation of the dialect specific SQL string to query\nthe target database.\n\nFor the SQL backend, GraphQL types are assumed to have a SQL table of the same name, and with the\nsame properties. For example, a schema type \n```\ntype Animal {\n    name: String\n}\n```\nis expected to correspond to a SQLAlchemy table object of the same name, case insensitive. For this\nschema type this could look like:\n\n```python\nfrom sqlalchemy import MetaData, Table, Column, String\n# table for GraphQL type Animal\nmetadata = MetaData()\nanimal_table = Table(\n    'animal', # name of table matches type name from schema\n    metadata,\n    Column('name', String(length=12)), # Animal.name GraphQL field has corresponding 'name' column\n)\n```\n\nIf a table of the schema type name does not exist, an exception will be raised at compile time. See\n[Configuring the SQL Database to Match the GraphQL Schema](#configuring-the-sql-database-to-match-the-graphql-schema)\nfor a possible option to resolve such naming discrepancies.\n\n\n### End-To-End SQL Example\nAn end-to-end example including relevant GraphQL schema and SQLAlchemy engine preparation follows.\n\nThis is intended to show the setup steps for the SQL backend of the GraphQL compiler, and\ndoes not represent best practices for configuring and running SQLAlchemy in a production system. \n\n```python\nfrom graphql import parse\nfrom graphql.utils.build_ast_schema import build_ast_schema\nfrom sqlalchemy import MetaData, Table, Column, String, create_engine\nfrom graphql_compiler.compiler.ir_lowering_sql.metadata import SqlMetadata\nfrom graphql_compiler import graphql_to_sql\n\n# Step 1: Configure a GraphQL schema (note that this can also be done programmatically)\nschema_text = '''\nschema {\n    query: RootSchemaQuery\n}\n# IMPORTANT NOTE: all compiler directives are expected here, but not shown to keep the example brief\n\ndirective @filter(op_name: String!, value: [String!]!) on FIELD | INLINE_FRAGMENT\n\n# < more directives here, see the GraphQL schema section of this README for more details. >\n\ndirective @output(out_name: String!) on FIELD\n\ntype Animal {\n    name: String\n}\n'''\nschema = build_ast_schema(parse(schema_text))\n\n# Step 2: For all GraphQL types, bind all corresponding SQLAlchemy Tables to a single SQLAlchemy\n# metadata instance, using the expected naming detailed above.\n# See https://docs.sqlalchemy.org/en/latest/core/metadata.html for more details on this step.\nmetadata = MetaData()\nanimal_table = Table(\n    'animal', # name of table matches type name from schema\n    metadata,\n    # Animal.name schema field has corresponding 'name' column in animal table\n    Column('name', String(length=12)), \n)\n\n# Step 3: Prepare a SQLAlchemy engine to query the target relational database.\n# See https://docs.sqlalchemy.org/en/latest/core/engines.html for more detail on this step.\nengine = create_engine('<connection string>')\n\n# Step 4: Wrap the SQLAlchemy metadata and dialect as a SqlMetadata GraphQL compiler object\nsql_metadata = SqlMetadata(engine.dialect, metadata)\n\n# Step 5: Prepare and compile a GraphQL query against the schema\ngraphql_query = '''\n{\n    Animal {\n        name @output(out_name: \"animal_name\")\n             @filter(op_name: \"in_collection\", value: [\"$names\"])\n    }\n}\n'''\nparameters = {\n    'names': ['animal name 1', 'animal name 2'],\n}\n\ncompilation_result = graphql_to_sql(schema, graphql_query, parameters, sql_metadata)\n\n# Step 6: Execute compiled query against a SQLAlchemy engine/connection. \n# See https://docs.sqlalchemy.org/en/latest/core/connections.html for more details.\nquery = compilation_result.query\nquery_results = [dict(result_proxy) for result_proxy in engine.execute(query)]\n```\n\n### Configuring the SQL Database to Match the GraphQL Schema\nFor simplicity, the SQL backend expects an exact match between SQLAlchemy Tables and GraphQL types, \nand between SQLAlchemy Columns and GraphQL fields. What if the table name or column name in the\ndatabase doesn't conform to these rules? Eventually the plan is to make this aspect of the\nSQL backend more configurable. In the near-term, a possible way to address this is by using\nSQL views.\n\nFor example, suppose there is a table in the database called `animal_table` and it has a column\ncalled `animal_name`. If the desired schema has type\n```\ntype Animal {\n    name: String\n}\n```\nThen this could be exposed via a view like:\n```sql\nCREATE VIEW animal AS \n    SELECT\n        animal_name AS name\n    FROM animal_table\n```\nAt this point, the `animal` view can be used in the SQLAlchemy Table for the purposes of compiling.\n\n## Miscellaneous\n\n### Pretty-Printing GraphQL Queries\n\nTo pretty-print GraphQL queries, use the included pretty-printer:\n```\npython -m graphql_compiler.tool <input_file.graphql >output_file.graphql\n```\nIt's modeled after Python's `json.tool`, reading from stdin and writing to stdout.\n\n\n### Expanding [`@optional`](#optional) vertex fields\nIncluding an optional statement in GraphQL has no performance issues on its own,\nbut if you continue expanding vertex fields within an optional scope,\nthere may be significant performance implications.\n\nGoing forward, we will refer to two different kinds of `@optional` directives.\n\n- A *\"simple\"* optional is a vertex with an `@optional` directive that does not expand\nany vertex fields within it.\nFor example:\n```graphql\n{\n    Animal {\n        name @output(out_name: \"name\")\n        in_Animal_ParentOf @optional {\n            name @output(out_name: \"parent_name\")\n        }\n    }\n}\n```\nOrientDB `MATCH` currently allows the last step in any traversal to be optional.\nTherefore, the equivalent `MATCH` traversal for the above `GraphQL` is as follows:\n```\nSELECT\n    Animal___1.name as `name`,\n    Animal__in_Animal_ParentOf___1.name as `parent_name`\nFROM (\n    MATCH {\n        class: Animal,\n        as: Animal___1\n    }.in('Animal_ParentOf') {\n        as: Animal__in_Animal_ParentOf___1\n    }\n    RETURN $matches\n)\n```\n\n- A *\"compound\"* optional is a vertex with an `@optional` directive which does expand\nvertex fields within it.\nFor example:\n```graphql\n{\n    Animal {\n        name @output(out_name: \"name\")\n        in_Animal_ParentOf @optional {\n            name @output(out_name: \"parent_name\")\n            in_Animal_ParentOf {\n                name @output(out_name: \"grandparent_name\")\n            }\n        }\n    }\n}\n```\nCurrently, this cannot represented by a simple `MATCH` query.\nSpecifically, the following is *NOT* a valid `MATCH` statement,\nbecause the optional traversal follows another edge:\n```\n-- NOT A VALID QUERY\nSELECT\n    Animal___1.name as `name`,\n    Animal__in_Animal_ParentOf___1.name as `parent_name`\nFROM (\n    MATCH {\n        class: Animal,\n        as: Animal___1\n    }.in('Animal_ParentOf') {\n        optional: true,\n        as: Animal__in_Animal_ParentOf___1\n    }.in('Animal_ParentOf') {\n        as: Animal__in_Animal_ParentOf__in_Animal_ParentOf___1\n    }\n    RETURN $matches\n)\n```\n\nInstead, we represent a *compound* optional by taking an union (`UNIONALL`) of two distinct\n`MATCH` queries. For instance, the `GraphQL` query above can be represented as follows:\n```\nSELECT EXPAND($final_match)\nLET\n    $match1 = (\n        SELECT\n            Animal___1.name AS `name`\n        FROM (\n            MATCH {\n                class: Animal,\n                as: Animal___1,\n                where: (\n                    (in_Animal_ParentOf IS null)\n                    OR\n                    (in_Animal_ParentOf.size() = 0)\n                ),\n            }\n        )\n    ),\n    $match2 = (\n        SELECT\n            Animal___1.name AS `name`,\n            Animal__in_Animal_ParentOf___1.name AS `parent_name`\n        FROM (\n            MATCH {\n                class: Animal,\n                as: Animal___1\n            }.in('Animal_ParentOf') {\n                as: Animal__in_Animal_ParentOf___1\n            }.in('Animal_ParentOf') {\n                as: Animal__in_Animal_ParentOf__in_Animal_ParentOf___1\n            }\n        )\n    ),\n    $final_match = UNIONALL($match1, $match2)\n```\nIn the first case where the optional edge is not followed,\nwe have to explicitly filter out all vertices where the edge *could have been followed*.\nThis is to eliminate duplicates between the two `MATCH` selections.\n\nThe previous example is not *exactly* how we implement *compound* optionals\n(we also have `SELECT` statements within `$match1` and `$match2`),\nbut it illustrates the the general idea.\n\n#### Performance Penalty\n\nIf we have many *compound* optionals in the given `GraphQL`,\nthe above procedure results in the union of a large number of `MATCH` queries.\nSpecifically, for `n` compound optionals, we generate 2<sup>n</sup> different `MATCH` queries.\nFor each of the 2<sup>n</sup> subsets `S` of the `n` optional edges:\n- We remove the `@optional` restriction for each traversal in `S`.\n- For each traverse `t` in the complement of `S`, we entirely discard `t`\n  along with all the vertices and directives within it, and we add a filter\n  on the previous traverse to ensure that the edge corresponding to `t` does not exist.\n\nTherefore, we get a performance penalty that grows exponentially\nwith the number of *compound* optional edges.\nThis is important to keep in mind when writing queries with many optional directives.\n\nIf some of those *compound* optionals contain `@optional` vertex fields of their own,\nthe performance penalty grows since we have to account for all possible subsets of `@optional`\nstatements that can be satisfied simultaneously.\n\n### Optional `type_equivalence_hints` parameter\n\nThis compilation parameter is a workaround for the limitations of the GraphQL and Gremlin\ntype systems:\n- GraphQL does not allow `type` to inherit from another `type`, only to implement an `interface`.\n- Gremlin does not have first-class support for inheritance at all.\n\nAssume the following GraphQL schema:\n```graphql\ntype Animal {\n    name: String\n}\n\ntype Cat {\n    name: String\n}\n\ntype Dog {\n    name: String\n}\n\nunion AnimalCatDog = Animal | Cat | Dog\n\ntype Foo {\n    adjacent_animal: AnimalCatDog\n}\n```\n\nAn appropriate `type_equivalence_hints` value here would be `{ Animal: AnimalCatDog }`.\nThis lets the compiler know that the `AnimalCatDog` union type is implicitly equivalent to\nthe `Animal` type, as there are no other types that inherit from `Animal` in the database schema.\nThis allows the compiler to perform accurate type coercions in Gremlin, as well as optimize away\ntype coercions across edges of union type if the coercion is coercing to the\nunion's equivalent type.\n\nSetting `type_equivalence_hints = { Animal: AnimalCatDog }` during compilation\nwould enable the use of a `@fold` on the `adjacent_animal` vertex field of `Foo`:\n```graphql\n{\n    Foo {\n        adjacent_animal @fold {\n            ... on Animal {\n                name @output(out_name: \"name\")\n            }\n        }\n    }\n}\n```\n\n### SchemaGraph \nWhen building a GraphQL schema from the database metadata, we first build a `SchemaGraph` from \nthe metadata and then, from the `SchemaGraph`, build the GraphQL schema. The `SchemaGraph` is also \na representation of the underlying database schema, but it has three main advantages that make it a \nmore powerful schema introspection tool:\n 1. It's able to store and expose a schema's index information. The interface for accessing index \n    information is provisional though and might change in the near future.\n 2. Its classes are allowed to inherit from non-abstract classes.\n 3. It exposes many utility functions, such as `get_subclass_set`, that make it easier to explore \n    the schema.\n\nSee below for a mock example of how to build and use the `SchemaGraph`: \n\n```python\nfrom graphql_compiler.schema_generation.orientdb.schema_graph_builder import (\n    get_orientdb_schema_graph\n)\nfrom graphql_compiler.schema_generation.orientdb.utils import (\n    ORIENTDB_INDEX_RECORDS_QUERY, ORIENTDB_SCHEMA_RECORDS_QUERY\n)\n\n# Get schema metadata from hypothetical Animals database.\nclient = your_function_that_returns_an_orientdb_client()\nschema_records = client.command(ORIENTDB_SCHEMA_RECORDS_QUERY)\nschema_data = [record.oRecordData for record in schema_records]\n\n# Get index data. \nindex_records = client.command(ORIENTDB_INDEX_RECORDS_QUERY)\nindex_query_data = [record.oRecordData for record in index_records]\n\n# Build SchemaGraph.\nschema_graph = get_orientdb_schema_graph(schema_data, index_query_data)\n\n# Get all the subclasses of a class.\nprint(schema_graph.get_subclass_set('Animal'))\n# {'Animal', 'Dog'}\n\n# Get all the outgoing edge classes of a vertex class.\nprint(schema_graph.get_vertex_schema_element_or_raise('Animal').out_connections)\n# {'Animal_Eats', 'Animal_FedAt', 'Animal_LivesIn'}\n\n# Get the vertex classes allowed as the destination vertex of an edge class.\nprint(schema_graph.get_edge_schema_element_or_raise('Animal_Eats').out_connections)\n# {'Fruit', 'Food'}\n\n# Get the superclass of all classes allowed as the destination vertex of an edge class.\nprint(schema_graph.get_edge_schema_element_or_raise('Animal_Eats').base_out_connection)\n# Food\n\n# Get the unique indexes defined on a class.\nprint(schema_graph.get_unique_indexes_for_class('Animal'))\n# [IndexDefinition(name='uuid', 'base_classname'='Animal', fields={'uuid'}, unique=True, ordered=False, ignore_nulls=False)]\n```\n\nIn the future, we plan to add `SchemaGraph` generation from SQLAlchemy metadata. We also plan to \nadd a mechanism where one can query a `SchemaGraph` using GraphQL queries.\n\n### Cypher query parameters\nRedisGraph [doesn't support query parameters](https://github.com/RedisGraph/RedisGraph/issues/544#issuecomment-507963576), so we perform manual parameter interpolation in the\n`graphql_to_redisgraph_cypher` function. However, for Neo4j, we can use Neo4j's client to do\nparameter interpolation on its own so that we don't reinvent the wheel.\n\nThe function `insert_arguments_into_query` does so based on the query language, which isn't\nfine-grained enough here-- for Cypher backends, we only want to insert parameters if the backend\nis RedisGraph, but not if it's Neo4j.\n\nInstead, the correct approach for Neo4j Cypher is as follows, given a Neo4j Python client called `neo4j_client`:\n```python\ncompilation_result = compile_graphql_to_cypher(\n    schema, graphql_query, type_equivalence_hints=type_equivalence_hints)\nwith neo4j_client.driver.session() as session:\n    result = session.run(compilation_result.query, parameters)\n```\n## Amending Parsed Custom Scalar Types\nInformation about the description, serialization and parsing of custom scalar type\nobjects is lost when a GraphQL schema is parsed from a string. This causes issues when\nworking with custom scalar type objects. In order to avoid these issues, one can use the code \nsnippet below to amend the definitions of the custom scalar types used by the compiler. \n\n```python\nfrom graphql_compiler.schema import CUSTOM_SCALAR_TYPES\nfrom graphql_compiler.schema_generation.utils import amend_custom_scalar_types\n\namend_custom_scalar_types(your_schema, CUSTOM_SCALAR_TYPES)\n```\n\n## FAQ\n\n**Q: Do you really use GraphQL, or do you just use GraphQL-like syntax?**\n\nA: We really use GraphQL. Any query that the compiler will accept is entirely valid GraphQL,\n   and we actually use the Python port of the GraphQL core library for parsing and type checking.\n   However, since the database queries produced by compiling GraphQL are subject to the limitations\n   of the database system they run on, our execution model is somewhat different compared to\n   the one described in the standard GraphQL specification. See the\n   [Execution model](#execution-model) section for more details.\n\n**Q: Does this project come with a GraphQL server implementation?**\n\nA: No -- there are many existing frameworks for running a web server. We simply built a tool\n   that takes GraphQL query strings (and their parameters) and returns a query string you can\n   use with your database. The compiler does not execute the query string against the database,\n   nor does it deserialize the results. Therefore, it is agnostic to the choice of\n   server framework and database client library used.\n\n**Q: Do you plan to support other databases / more GraphQL features in the future?**\n\nA: We'd love to, and we could really use your help! Please consider contributing to this project\n   by opening issues, opening pull requests, or participating in discussions.\n\n**Q: I think I found a bug, what do I do?**\n\nA: Please check if an issue has already been created for the bug, and open a new one if not.\n   Make sure to describe the bug in as much detail as possible, including any stack traces or\n   error messages you may have seen, which database you're using, and what query you compiled.\n\n**Q: I think I found a security vulnerability, what do I do?**\n\nA: Please reach out to us at\n[graphql-compiler-maintainer@kensho.com](mailto:graphql-compiler-maintainer@kensho.com)\nso we can triage the issue and take appropriate action.\n\n\n\n\n## License\n\nLicensed under the Apache 2.0 License. Unless required by applicable law or agreed to in writing,\nsoftware distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\nCONDITIONS OF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n\nCopyright 2017-present Kensho Technologies, LLC. The present date is determined by the timestamp\nof the most recent commit in the repository.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kensho-technologies/graphql-compiler", "keywords": "graphql database compiler orientdb", "license": "Apache 2.0", "maintainer": "", "maintainer_email": "", "name": "graphql-compiler", "package_url": "https://pypi.org/project/graphql-compiler/", "platform": "", "project_url": "https://pypi.org/project/graphql-compiler/", "project_urls": {"Homepage": "https://github.com/kensho-technologies/graphql-compiler"}, "release_url": "https://pypi.org/project/graphql-compiler/1.11.0/", "requires_dist": ["arrow (<1,>=0.7.0)", "funcy (<2,>=1.6)", "graphql-core (<3,>=2.1)", "pytz (>=2016.10)", "six (>=1.10.0)", "sqlalchemy (<2,>=1.3.0)"], "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "summary": "Turn complex GraphQL queries into optimized database queries.", "version": "1.11.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>graphql-compiler</h1>\n<p><a href=\"https://travis-ci.org/kensho-technologies/graphql-compiler\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cc1809d5318d668135b287b0bacaa0ffe8b813d2/68747470733a2f2f7472617669732d63692e6f72672f6b656e73686f2d746563686e6f6c6f676965732f6772617068716c2d636f6d70696c65722e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/kensho-technologies/graphql-compiler?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/44103190414d1e4dda769814b84ba7736e765086/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f6b656e73686f2d746563686e6f6c6f676965732f6772617068716c2d636f6d70696c65722f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://opensource.org/licenses/Apache-2.0\" rel=\"nofollow\"><img alt=\"License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b97ca76cf5d8fd16c7bc4731270e0bbe53df7aa1/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d417061636865253230322e302d626c75652e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/graphql-compiler\" rel=\"nofollow\"><img alt=\"PyPI Python\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8734e50fc925f6c93b28ae28d1fd7065cdd5c561/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f6772617068716c2d636f6d70696c65722e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/graphql-compiler\" rel=\"nofollow\"><img alt=\"PyPI Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b10268d78033196925587ed6a30ccbac23416025/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6772617068716c2d636f6d70696c65722e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/graphql-compiler\" rel=\"nofollow\"><img alt=\"PyPI Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8e09b1096901ca7067330d2f90917060a243f58e/68747470733a2f2f696d672e736869656c64732e696f2f707970692f7374617475732f6772617068716c2d636f6d70696c65722e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/graphql-compiler\" rel=\"nofollow\"><img alt=\"PyPI Wheel\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/25c0c23ed1851385dfd46d8f4c87bf7204968a40/68747470733a2f2f696d672e736869656c64732e696f2f707970692f776865656c2f6772617068716c2d636f6d70696c65722e737667\"></a></p>\n<p>Turn complex GraphQL queries into optimized database queries.</p>\n<pre><code>pip install graphql-compiler\n</code></pre>\n<h2>Quick Overview</h2>\n<p>Through the GraphQL compiler, users can write powerful queries that uncover\ndeep relationships in the data while not having to worry about the underlying database query\nlanguage. The GraphQL compiler turns read-only queries written in GraphQL syntax to different\nquery languages.</p>\n<p>Furthermore, the GraphQL compiler validates queries through the use of a GraphQL schema\nthat specifies the underlying schema of the database. We can currently autogenerate a\nGraphQL schema by introspecting an OrientDB database, (see <a href=\"#end-to-end-example\" rel=\"nofollow\">End to End Example</a>).</p>\n<p>In the near future, we plan to add schema autogeneration from SQLAlchemy metadata as well.</p>\n<p>For a more detailed overview and getting started guide, please see\n<a href=\"https://blog.kensho.com/compiled-graphql-as-a-database-query-language-72e106844282\" rel=\"nofollow\">our blog post</a>.</p>\n<h2>Table of contents</h2>\n<ul>\n<li><a href=\"#features\" rel=\"nofollow\">Features</a></li>\n<li><a href=\"#end-to-end-example\" rel=\"nofollow\">End to End Example</a></li>\n<li><a href=\"#definitions\" rel=\"nofollow\">Definitions</a></li>\n<li><a href=\"#directives\" rel=\"nofollow\">Directives</a>\n<ul>\n<li><a href=\"#optional\" rel=\"nofollow\">@optional</a></li>\n<li><a href=\"#output\" rel=\"nofollow\">@output</a></li>\n<li><a href=\"#fold\" rel=\"nofollow\">@fold</a></li>\n<li><a href=\"#tag\" rel=\"nofollow\">@tag</a></li>\n<li><a href=\"#filter\" rel=\"nofollow\">@filter</a></li>\n<li><a href=\"#recurse\" rel=\"nofollow\">@recurse</a></li>\n<li><a href=\"#output_source\" rel=\"nofollow\">@output_source</a></li>\n</ul>\n</li>\n<li><a href=\"#supported-filtering-operations\" rel=\"nofollow\">Supported filtering operations</a>\n<ul>\n<li><a href=\"#comparison-operators\" rel=\"nofollow\">Comparison operators</a></li>\n<li><a href=\"#name_or_alias\" rel=\"nofollow\">name_or_alias</a></li>\n<li><a href=\"#between\" rel=\"nofollow\">between</a></li>\n<li><a href=\"#in_collection\" rel=\"nofollow\">in_collection</a></li>\n<li><a href=\"#not_in_collection\" rel=\"nofollow\">not_in_collection</a></li>\n<li><a href=\"#has_substring\" rel=\"nofollow\">has_substring</a></li>\n<li><a href=\"#contains\" rel=\"nofollow\">contains</a></li>\n<li><a href=\"#not_contains\" rel=\"nofollow\">not_contains</a></li>\n<li><a href=\"#intersects\" rel=\"nofollow\">intersects</a></li>\n<li><a href=\"#has_edge_degree\" rel=\"nofollow\">has_edge_degree</a></li>\n</ul>\n</li>\n<li><a href=\"#type-coercions\" rel=\"nofollow\">Type coercions</a></li>\n<li><a href=\"#meta-fields\" rel=\"nofollow\">Meta fields</a>\n<ul>\n<li><a href=\"#__typename\" rel=\"nofollow\">__typename</a></li>\n<li><a href=\"#_x_count\" rel=\"nofollow\">_x_count</a></li>\n</ul>\n</li>\n<li><a href=\"#the-graphql-schema\" rel=\"nofollow\">The GraphQL schema</a></li>\n<li><a href=\"#execution-model\" rel=\"nofollow\">Execution model</a></li>\n<li><a href=\"#sql\" rel=\"nofollow\">SQL</a>\n<ul>\n<li><a href=\"#configuring-sqlalchemy\" rel=\"nofollow\">Configuring SQLAlchemy</a></li>\n<li><a href=\"#end-to-end-sql-example\" rel=\"nofollow\">End-To-End SQL Example</a></li>\n<li><a href=\"#configuring-the-sql-database-to-match-the-graphql-schema\" rel=\"nofollow\">Configuring the SQL Database to Match the GraphQL Schema</a></li>\n</ul>\n</li>\n<li><a href=\"#miscellaneous\" rel=\"nofollow\">Miscellaneous</a>\n<ul>\n<li><a href=\"#pretty-printing-graphql-queries\" rel=\"nofollow\">Pretty-Printing GraphQL Queries</a></li>\n<li><a href=\"#expanding-optional-vertex-fields\" rel=\"nofollow\">Expanding <code>@optional</code> vertex fields</a></li>\n<li><a href=\"#optional-type_equivalence_hints-parameter\" rel=\"nofollow\">Optional <code>type_equivalence_hints</code> compilation parameter</a></li>\n<li><a href=\"#schemagraph\" rel=\"nofollow\">SchemaGraph</a></li>\n<li><a href=\"#cypher-query-parameters\" rel=\"nofollow\">Cypher query parameters</a></li>\n</ul>\n</li>\n<li><a href=\"#faq\" rel=\"nofollow\">FAQ</a></li>\n<li><a href=\"#license\" rel=\"nofollow\">License</a></li>\n</ul>\n<h2>Features</h2>\n<ul>\n<li>\n<p><strong>Databases and Query Languages:</strong> We currently support a single database, OrientDB version 2.2.28+, and two query languages that OrientDB supports: the OrientDB dialect of gremlin, and OrientDB's own custom SQL-like query language that we refer to as MATCH, after the name of its graph traversal operator. With OrientDB, MATCH should be the preferred choice for most users, since it tends to run faster than gremlin, and has other desirable properties. See the Execution model section for more details.</p>\n<p>Support for relational databases including PostgreSQL, MySQL, SQLite,\nand Microsoft SQL Server is a work in progress. A subset of compiler features are available for\nthese databases. See the <a href=\"#sql\" rel=\"nofollow\">SQL</a> section for more details.</p>\n</li>\n<li>\n<p><strong>GraphQL Language Features:</strong>  We prioritized and implemented a subset of all functionality supported by the GraphQL language. We hope to add more functionality over time.</p>\n</li>\n</ul>\n<h2>End-to-End Example</h2>\n<p>Even though this example specifically targets an OrientDB database, it is meant as a generic\nend-to-end example of how to use the GraphQL compiler.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">graphql.utils.schema_printer</span> <span class=\"kn\">import</span> <span class=\"n\">print_schema</span>\n<span class=\"kn\">from</span> <span class=\"nn\">graphql_compiler</span> <span class=\"kn\">import</span> <span class=\"p\">(</span>\n    <span class=\"n\">get_graphql_schema_from_orientdb_schema_data</span><span class=\"p\">,</span> <span class=\"n\">graphql_to_match</span>\n<span class=\"p\">)</span>\n<span class=\"kn\">from</span> <span class=\"nn\">graphql_compiler.schema_generation.orientdb.utils</span> <span class=\"kn\">import</span> <span class=\"n\">ORIENTDB_SCHEMA_RECORDS_QUERY</span>\n\n<span class=\"c1\"># Step 1: Get schema metadata from hypothetical Animals database.</span>\n<span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">your_function_that_returns_an_orientdb_client</span><span class=\"p\">()</span>\n<span class=\"n\">schema_records</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">command</span><span class=\"p\">(</span><span class=\"n\">ORIENTDB_SCHEMA_RECORDS_QUERY</span><span class=\"p\">)</span>\n<span class=\"n\">schema_data</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">record</span><span class=\"o\">.</span><span class=\"n\">oRecordData</span> <span class=\"k\">for</span> <span class=\"n\">record</span> <span class=\"ow\">in</span> <span class=\"n\">schema_records</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Step 2: Generate GraphQL schema from metadata.</span>\n<span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"n\">type_equivalence_hints</span> <span class=\"o\">=</span> <span class=\"n\">get_graphql_schema_from_orientdb_schema_data</span><span class=\"p\">(</span><span class=\"n\">schema_data</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">print_schema</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">))</span>\n<span class=\"c1\"># schema {</span>\n<span class=\"c1\">#    query: RootSchemaQuery</span>\n<span class=\"c1\"># }</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># directive @filter(op_name: String!, value: [String!]!) on FIELD | INLINE_FRAGMENT</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># directive @tag(tag_name: String!) on FIELD</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># directive @output(out_name: String!) on FIELD</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># directive @output_source on FIELD</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># directive @optional on FIELD</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># directive @recurse(depth: Int!) on FIELD</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># directive @fold on FIELD</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># type Animal {</span>\n<span class=\"c1\">#     name: String</span>\n<span class=\"c1\">#     net_worth: Int</span>\n<span class=\"c1\">#     limbs: Int</span>\n<span class=\"c1\"># }</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># type RootSchemaQuery{</span>\n<span class=\"c1\">#     Animal: [Animal]</span>\n<span class=\"c1\"># }</span>\n\n<span class=\"c1\"># Step 3: Write GraphQL query that returns the names of all animals with a certain net worth.</span>\n<span class=\"c1\"># Note that we prefix net_worth with '$' and surround it with quotes to indicate it's a parameter.</span>\n<span class=\"n\">graphql_query</span> <span class=\"o\">=</span> <span class=\"s1\">'''</span>\n<span class=\"s1\">{</span>\n<span class=\"s1\">    Animal {</span>\n<span class=\"s1\">        name @output(out_name: \"animal_name\")</span>\n<span class=\"s1\">        net_worth @filter(op_name: \"=\", value: [\"$net_worth\"])</span>\n<span class=\"s1\">    }</span>\n<span class=\"s1\">}</span>\n<span class=\"s1\">'''</span>\n<span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'net_worth'</span><span class=\"p\">:</span> <span class=\"s1\">'100'</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\"># Step 4: Use autogenerated GraphQL schema to compile query into the target database language.</span>\n<span class=\"n\">compilation_result</span> <span class=\"o\">=</span> <span class=\"n\">graphql_to_match</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"n\">graphql_query</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"n\">type_equivalence_hints</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">compilation_result</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">)</span>\n<span class=\"c1\"># SELECT Animal___1.name AS `animal_name` </span>\n<span class=\"c1\"># FROM  ( MATCH  { class: Animal, where: ((net_worth = decimal(\"100\"))), as: Animal___1 } </span>\n<span class=\"c1\"># RETURN $matches)</span>\n</pre>\n<h2>Definitions</h2>\n<ul>\n<li><strong>Vertex field</strong>: A field corresponding to a vertex in the graph. In the below example, <code>Animal</code>\nand <code>out_Entity_Related</code> are vertex fields. The <code>Animal</code> field is the field at which querying\nstarts, and is therefore the <strong>root vertex field</strong>. In any scope, fields with the prefix <code>out_</code>\ndenote vertex fields connected by an outbound edge, whereas ones with the prefix <code>in_</code> denote\nvertex fields connected by an inbound edge.</li>\n</ul>\n<pre>{\n    Animal {\n        name @output(out_name: \"name\")\n        out_Entity_Related {\n            ... on Species {\n                description @output(out_name: \"description\")\n            }\n        }\n    }\n}\n</pre>\n<ul>\n<li><strong>Property field</strong>: A field corresponding to a property of a vertex in the graph. In the\nabove example, the <code>name</code> and <code>description</code> fields are property fields. In any given scope,\n<strong>property fields must appear before vertex fields</strong>.</li>\n<li><strong>Result set</strong>: An assignment of vertices in the graph to scopes (locations) in the query.\nAs the database processes the query, new result sets may be created (e.g. when traversing edges),\nand result sets may be discarded when they do not satisfy filters or type coercions. After all\nparts of the query are processed by the database, all remaining result sets are used to form the\nquery result, by taking their values at all properties marked for output.</li>\n<li><strong>Scope</strong>: The part of a query between any pair of curly braces. The compiler infers the type\nof each scope. For example, in the above query, the scope beginning with <code>Animal {</code> is of\ntype <code>Animal</code>, the one beginning with <code>out_Entity_Related {</code> is of type <code>Entity</code>, and the one\nbeginning with <code>... on Species {</code> is of type <code>Species</code>.</li>\n<li><strong>Type coercion</strong>: An operation that produces a new scope of narrower type than the\nscope in which it exists. Any result sets that cannot satisfy the narrower type are filtered out\nand not returned. In the above query, <code>... on Species</code> is a type coercion which takes\nits enclosing scope of type <code>Entity</code>, and coerces it into a narrower scope of\ntype <code>Species</code>. This is possible since <code>Entity</code> is an interface, and <code>Species</code> is a type\nthat implements the <code>Entity</code> interface.</li>\n</ul>\n<h2>Directives</h2>\n<h3>@optional</h3>\n<p>Without this directive, when a query includes a vertex field, any results matching that query\nmust be able to produce a value for that vertex field. Applied to a vertex field,\nthis directive prevents result sets that are unable to produce a value for that field from\nbeing discarded, and allowed to continue processing the remainder of the query.</p>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        name @output(out_name: \"name\")\n        out_Animal_ParentOf @optional {\n            name @output(out_name: \"child_name\")\n        }\n    }\n}\n</pre>\n<p>For each <code>Animal</code>:</p>\n<ul>\n<li>if it is a parent of another animal, at least one row containing the\nparent and child animal's names, in the <code>name</code> and <code>child_name</code> columns respectively;</li>\n<li>if it is not a parent of another animal, a row with its name in the <code>name</code> column,\nand a <code>null</code> value in the <code>child_name</code> column.</li>\n</ul>\n<h4>Constraints and Rules</h4>\n<ul>\n<li><code>@optional</code> can only be applied to vertex fields, except the root vertex field.</li>\n<li>It is allowed to expand vertex fields within an <code>@optional</code> scope.\nHowever, doing so is currently associated with a performance penalty in <code>MATCH</code>.\nFor more detail, see: <a href=\"#expanding-optional-vertex-fields\" rel=\"nofollow\">Expanding <code>@optional</code> vertex fields</a>.</li>\n<li><code>@recurse</code>, <code>@fold</code>, or <code>@output_source</code> may not be used at the same vertex field as <code>@optional</code>.</li>\n<li><code>@output_source</code> and <code>@fold</code> may not be used anywhere within a scope\nmarked <code>@optional</code>.</li>\n</ul>\n<p>If a given result set is unable to produce a value for a vertex field marked <code>@optional</code>,\nany fields marked <code>@output</code> within that vertex field return the <code>null</code> value.</p>\n<p>When filtering (via <code>@filter</code>) or type coercion (via e.g. <code>... on Animal</code>) are applied\nat or within a vertex field marked <code>@optional</code>, the <code>@optional</code> is given precedence:</p>\n<ul>\n<li>If a given result set cannot produce a value for the optional vertex field, it is preserved:\nthe <code>@optional</code> directive is applied first, and no filtering or type coercion can happen.</li>\n<li>If a given result set is able to produce a value for the optional vertex field,\nthe <code>@optional</code> does not apply, and that value is then checked against the filtering or type\ncoercion. These subsequent operations may then cause the result set to be discarded if it does\nnot match.</li>\n</ul>\n<p>For example, suppose we have two <code>Person</code> vertices with names <code>Albert</code> and <code>Betty</code> such that there is a <code>Person_Knows</code> edge from <code>Albert</code> to <code>Betty</code>.</p>\n<p>Then the following query:</p>\n<pre>{\n  Person {\n    out_Person_Knows @optional {\n      name @filter(op_name: \"=\", value: [\"$name\"])\n    }\n    name @output(out_name: \"person_name\")\n  }\n}\n</pre>\n<p>with runtime parameter</p>\n<pre><span class=\"p\">{</span>\n  <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Charles\"</span>\n<span class=\"p\">}</span>\n</pre>\n<p>would output an empty list because the <code>Person_Knows</code> edge from <code>Albert</code> to <code>Betty</code> satisfies the <code>@optional</code> directive, but <code>Betty</code> doesn't match the filter checking for a node with name <code>Charles</code>.</p>\n<p>However, if no such <code>Person_Knows</code> edge existed from <code>Albert</code>, then the output would be</p>\n<pre><span class=\"p\">{</span>\n  <span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"s1\">'Albert'</span>\n<span class=\"p\">}</span>\n</pre>\n<p>because no such edge can satisfy the <code>@optional</code> directive, and no filtering happens.</p>\n<h3>@output</h3>\n<p>Denotes that the value of a property field should be included in the output.\nIts <code>out_name</code> argument specifies the name of the column in which the\noutput value should be returned.</p>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        name @output(out_name: \"animal_name\")\n    }\n}\n</pre>\n<p>This query returns the name of each <code>Animal</code> in the graph, in a column named <code>animal_name</code>.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li><code>@output</code> can only be applied to property fields.</li>\n<li>The value provided for <code>out_name</code> may only consist of upper or lower case letters\n(<code>A-Z</code>, <code>a-z</code>), or underscores (<code>_</code>).</li>\n<li>The value provided for <code>out_name</code> cannot be prefixed with <code>___</code> (three underscores). This\nnamespace is reserved for compiler internal use.</li>\n<li>For any given query, all <code>out_name</code> values must be unique. In other words, output columns must\nhave unique names.</li>\n</ul>\n<p>If the property field marked <code>@output</code> exists within a scope marked <code>@optional</code>, result sets that\nare unable to assign a value to the optional scope return the value <code>null</code> as the output\nof that property field.</p>\n<h3>@fold</h3>\n<p>Applying <code>@fold</code> on a scope \"folds\" all outputs from within that scope: rather than appearing\non separate rows in the query result, the folded outputs are coalesced into lists starting\nat the scope marked <code>@fold</code>.</p>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        name @output(out_name: \"animal_name\")\n        out_Animal_ParentOf @fold {\n            name @output(out_name: \"child_names\")\n        }\n    }\n}\n</pre>\n<p>Each returned row has two columns: <code>animal_name</code> with the name of each <code>Animal</code> in the graph,\nand <code>child_names</code> with a list of the names of all children of the <code>Animal</code> named <code>animal_name</code>.\nIf a given <code>Animal</code> has no children, its <code>child_names</code> list is empty.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li><code>@fold</code> can only be applied to vertex fields, except the root vertex field.</li>\n<li>May not exist at the same vertex field as <code>@recurse</code>, <code>@optional</code>, or <code>@output_source</code>.</li>\n<li>Any scope that is either marked with <code>@fold</code> or is nested within a <code>@fold</code> marked scope,\nmay expand at most one vertex field.</li>\n<li>There must be at least one <code>@output</code> field within a <code>@fold</code> scope.</li>\n<li>All <code>@output</code> fields within a <code>@fold</code> traversal must be present at the innermost scope.\nIt is invalid to expand vertex fields within a <code>@fold</code> after encountering an <code>@output</code> directive.</li>\n<li><code>@tag</code>, <code>@recurse</code>, <code>@optional</code>, <code>@output_source</code> and <code>@fold</code> may not be used anywhere\nwithin a scope marked <code>@fold</code>.</li>\n<li>Use of type coercions or <code>@filter</code> at or within the vertex field marked <code>@fold</code> is allowed.\nOnly data that satisfies the given type coercions and filters is returned by the <code>@fold</code>.</li>\n<li>If the compiler is able to prove that the type coercion in the <code>@fold</code> scope is actually a no-op,\nit may optimize it away. See the\n<a href=\"#optional-type_equivalence_hints-parameter\" rel=\"nofollow\">Optional <code>type_equivalence_hints</code> compilation parameter</a>\nsection for more details.</li>\n</ul>\n<h4>Example</h4>\n<p>The following GraphQL is <em>not allowed</em> and will produce a <code>GraphQLCompilationError</code>.\nThis query is <em>invalid</em> for two separate reasons:</p>\n<ul>\n<li>It expands vertex fields after an <code>@output</code> directive (outputting <code>animal_name</code>)</li>\n<li>The <code>in_Animal_ParentOf</code> scope, which is within a scope marked <code>@fold</code>,\nexpands two vertex fields instead of at most one.</li>\n</ul>\n<pre>{\n    Animal {\n        out_Animal_ParentOf @fold {\n            name @output(out_name: \"animal_name\")\n            in_Animal_ParentOf {\n                out_Animal_OfSpecies {\n                    uuid @output(out_name: \"species_id\")\n                }\n                out_Entity_Related {\n                    ... on Animal {\n                        name @output(out_name: \"relative_name\")\n                    }\n                }\n            }\n        }\n    }\n}\n</pre>\n<p>The following is a valid use of <code>@fold</code>:</p>\n<pre>{\n    Animal {\n        out_Animal_ParentOf @fold {\n            in_Animal_ParentOf {\n                in_Animal_ParentOf {\n                    out_Entity_Related {\n                        ... on Animal {\n                            name @output(out_name: \"final_name\")\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n</pre>\n<h3>@tag</h3>\n<p>The <code>@tag</code> directive enables filtering based on values encountered elsewhere in the same query.\nApplied on a property field, it assigns a name to the value of that property field, allowing that\nvalue to then be used as part of a <code>@filter</code> directive.</p>\n<p>To supply a tagged value to a <code>@filter</code> directive, place the tag name (prefixed with a <code>%</code> symbol)\nin the <code>@filter</code>'s <code>value</code> array. See <a href=\"#passing-parameters\" rel=\"nofollow\">Passing parameters</a>\nfor more details.</p>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        name @tag(tag_name: \"parent_name\")\n        out_Animal_ParentOf {\n            name @filter(op_name: \"&lt;\", value: [\"%parent_name\"])\n                 @output(out_name: \"child_name\")\n        }\n    }\n}\n</pre>\n<p>Each row returned by this query contains, in the <code>child_name</code> column, the name of an <code>Animal</code>\nthat is the child of another <code>Animal</code>, and has a name that is lexicographically smaller than\nthe name of its parent.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li><code>@tag</code> can only be applied to property fields.</li>\n<li>The value provided for <code>tag_name</code> may only consist of upper or lower case letters\n(<code>A-Z</code>, <code>a-z</code>), or underscores (<code>_</code>).</li>\n<li>For any given query, all <code>tag_name</code> values must be unique.</li>\n<li>Cannot be applied to property fields within a scope marked <code>@fold</code>.</li>\n<li>Using a <code>@tag</code> and a <code>@filter</code> that references the tag within the same vertex is allowed,\nso long as the two do not appear on the exact same property field.</li>\n</ul>\n<h3>@filter</h3>\n<p>Allows filtering of the data to be returned, based on any of a set of filtering operations.\nConceptually, it is the GraphQL equivalent of the SQL <code>WHERE</code> keyword.</p>\n<p>See <a href=\"#supported-filtering-operations\" rel=\"nofollow\">Supported filtering operations</a>\nfor details on the various types of filtering that the compiler currently supports.\nThese operations are currently hardcoded in the compiler; in the future,\nwe may enable the addition of custom filtering operations via compiler plugins.</p>\n<p>Multiple <code>@filter</code> directives may be applied to the same field at once. Conceptually,\nit is as if the different <code>@filter</code> directives were joined by SQL <code>AND</code> keywords.</p>\n<p>Using a <code>@tag</code> and a <code>@filter</code> that references the tag within the same vertex is allowed,\nso long as the two do not appear on the exact same property field.</p>\n<h4>Passing Parameters</h4>\n<p>The <code>@filter</code> directive accepts two types of parameters: runtime parameters and tagged parameters.</p>\n<p><strong>Runtime parameters</strong> are represented with a <code>$</code> prefix (e.g. <code>$foo</code>), and denote parameters\nwhose values will be known at runtime. The compiler will compile the GraphQL query leaving a\nspot for the value to fill at runtime. After compilation, the user will have to supply values for\nall runtime parameters, and their values will be inserted into the final query before it can be\nexecuted against the database.</p>\n<p>Consider the following query:</p>\n<pre>{\n    Animal {\n        name @output(out_name: \"animal_name\")\n        color @filter(op_name: \"=\", value: [\"$animal_color\"])\n    }\n}\n</pre>\n<p>It returns one row for every <code>Animal</code> vertex that has a color equal to <code>$animal_color</code>. Each row\ncontains the animal's name in a column named <code>animal_name</code>. The parameter <code>$animal_color</code> is\na runtime parameter -- the user must pass in a value (e.g. <code>{\"animal_color\": \"blue\"}</code>) that\nwill be inserted into the query before querying the database.</p>\n<p><strong>Tagged parameters</strong> are represented with a <code>%</code> prefix (e.g. <code>%foo</code>) and denote parameters\nwhose values are derived from a property field encountered elsewhere in the query.\nIf the user marks a property field with a <code>@tag</code> directive and a suitable name,\nthat value becomes available to use as a tagged parameter in all subsequent <code>@filter</code> directives.</p>\n<p>Consider the following query:</p>\n<pre>{\n    Animal {\n        name @tag(out_name: \"parent_name\")\n        out_Animal_ParentOf {\n            name @filter(op_name: \"has_substring\", value: [\"%parent_name\"])\n                 @output(out_name: \"child_name\")\n        }\n    }\n}\n</pre>\n<p>It returns the names of animals that contain their parent's name as a substring of their own.\nThe database captures the value of the parent animal's name as the <code>parent_name</code> tag, and this\nvalue is then used as the <code>%parent_name</code> tagged parameter in the child animal's <code>@filter</code>.</p>\n<p>We considered and <strong>rejected</strong> the idea of allowing literal values (e.g. <code>123</code>)\nas <code>@filter</code> parameters, for several reasons:</p>\n<ul>\n<li>The GraphQL type of the <code>@filter</code> directive's <code>value</code> field cannot reasonably encompass\nall the different types of arguments that people might supply. Even counting scalar types only,\nthere's already <code>ID, Int, Float, Boolean, String, Date, DateTime...</code> -- way too many to include.</li>\n<li>Literal values would be used when the parameter's value is known to be fixed. We can just as\neasily accomplish the same thing by using a runtime parameter with a fixed value. That approach\nhas the added benefit of potentially reducing the number of different queries that have to be\ncompiled: two queries with different literal values would have to be compiled twice, whereas\nusing two different sets of runtime arguments only requires the compilation of one query.</li>\n<li>We were concerned about the potential for accidental misuse of literal values. SQL systems have\nsupported stored procedures and parameterized queries for decades, and yet ad-hoc SQL query\nconstruction via simple string interpolation is still a serious problem and is the source of\nmany SQL injection vulnerabilities. We felt that disallowing literal values in the query will\ndrastically reduce both the use and the risks of unsafe string interpolation,\nat an acceptable cost.</li>\n</ul>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>The value provided for <code>op_name</code> may only consist of upper or lower case letters\n(<code>A-Z</code>, <code>a-z</code>), or underscores (<code>_</code>).</li>\n<li>Values provided in the <code>value</code> list must start with either <code>$</code>\n(denoting a runtime parameter) or <code>%</code> (denoting a tagged parameter),\nfollowed by exclusively upper or lower case letters (<code>A-Z</code>, <code>a-z</code>) or underscores (<code>_</code>).</li>\n<li>The <code>@tag</code> directives corresponding to any tagged parameters in a given <code>@filter</code> query\nmust be applied to fields that appear either at the same vertex as the one with the <code>@filter</code>,\nor strictly before the field with the <code>@filter</code> directive.</li>\n<li>\"Can't compare apples and oranges\" -- the GraphQL type of the parameters supplied to the <code>@filter</code>\nmust match the GraphQL types the compiler infers based on the field the <code>@filter</code> is applied to.</li>\n<li>If the <code>@tag</code> corresponding to a tagged parameter originates from within a vertex field\nmarked <code>@optional</code>, the emitted code for the <code>@filter</code> checks if the <code>@optional</code> field was\nassigned a value. If no value was assigned to the <code>@optional</code> field, comparisons against the\ntagged parameter from within that field return <code>True</code>.\n<ul>\n<li>For example, assuming <code>%from_optional</code> originates from an <code>@optional</code> scope, when no value is\nassigned to the <code>@optional</code> field:\n<ul>\n<li>using <code>@filter(op_name: \"=\", value: [\"%from_optional\"])</code> is equivalent to not\nhaving the filter at all;</li>\n<li>using <code>@filter(op_name: \"between\", value: [\"$lower\", \"%from_optional\"])</code> is equivalent to\n<code>@filter(op_name: \"&gt;=\", value: [\"$lower\"])</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Using a <code>@tag</code> and a <code>@filter</code> that references the tag within the same vertex is allowed,\nso long as the two do not appear on the exact same property field.</li>\n</ul>\n<h3>@recurse</h3>\n<p>Applied to a vertex field, specifies that the edge connecting that vertex field to the current\nvertex should be visited repeatedly, up to <code>depth</code> times. The recursion always starts\nat <code>depth = 0</code>, i.e. the current vertex -- see the below sections for a more thorough explanation.</p>\n<h4>Example Use</h4>\n<p>Say the user wants to fetch the names of the children and grandchildren of each <code>Animal</code>.\nThat could be accomplished by running the following two queries and concatenating their results:</p>\n<pre>{\n    Animal {\n        name @output(out_name: \"ancestor\")\n        out_Animal_ParentOf {\n            name @output(out_name: \"descendant\")\n        }\n    }\n}\n</pre>\n<pre>{\n    Animal {\n        name @output(out_name: \"ancestor\")\n        out_Animal_ParentOf {\n            out_Animal_ParentOf {\n                name @output(out_name: \"descendant\")\n            }\n        }\n    }\n}\n</pre>\n<p>If the user then wanted to also add great-grandchildren to the <code>descendants</code> output, that would\nrequire yet another query, and so on. Instead of concatenating the results of multiple queries,\nthe user can simply use the <code>@recurse</code> directive. The following query returns the child and\ngrandchild descendants:</p>\n<pre>{\n    Animal {\n        name @output(out_name: \"ancestor\")\n        out_Animal_ParentOf {\n            out_Animal_ParentOf @recurse(depth: 1) {\n                name @output(out_name: \"descendant\")\n            }\n        }\n    }\n}\n</pre>\n<p>Each row returned by this query contains the name of an <code>Animal</code> in the <code>ancestor</code> column\nand the name of its child or grandchild in the <code>descendant</code> column.\nThe <code>out_Animal_ParentOf</code> vertex field marked <code>@recurse</code> is already enclosed within\nanother <code>out_Animal_ParentOf</code> vertex field, so the recursion starts at the\n\"child\" level (the <code>out_Animal_ParentOf</code> not marked with <code>@recurse</code>).\nTherefore, the <code>descendant</code> column contains the names of an <code>ancestor</code>'s\nchildren (from <code>depth = 0</code> of the recursion) and the names of its grandchildren (from <code>depth = 1</code>).</p>\n<p>Recursion using this directive is possible since the types of the enclosing scope and the recursion\nscope work out: the <code>@recurse</code> directive is applied to a vertex field of type <code>Animal</code> and\nits vertex field is enclosed within a scope of type <code>Animal</code>.\nAdditional cases where recursion is allowed are described in detail below.</p>\n<p>The <code>descendant</code> column cannot have the name of the <code>ancestor</code> animal since the <code>@recurse</code>\nis already within one <code>out_Animal_ParentOf</code> and not at the root <code>Animal</code> vertex field.\nSimilarly, it cannot have descendants that are more than two steps removed\n(e.g., great-grandchildren), since the <code>depth</code> parameter of <code>@recurse</code> is set to <code>1</code>.</p>\n<p>Now, let's see what happens when we eliminate the outer <code>out_Animal_ParentOf</code> vertex field\nand simply have the <code>@recurse</code> applied on the <code>out_Animal_ParentOf</code> in the root vertex field scope:</p>\n<pre>{\n    Animal {\n        name @output(out_name: \"ancestor\")\n        out_Animal_ParentOf @recurse(depth: 1) {\n            name @output(out_name: \"self_or_descendant\")\n        }\n    }\n}\n</pre>\n<p>In this case, when the recursion starts at <code>depth = 0</code>, the <code>Animal</code> within the recursion scope\nwill be the same <code>Animal</code> at the root vertex field, and therefore, in the <code>depth = 0</code> step of\nthe recursion, the value of the <code>self_or_descendant</code> field will be equal to the value of\nthe <code>ancestor</code> field.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>\"The types must work out\" -- when applied within a scope of type <code>A</code>,\nto a vertex field of type <code>B</code>, at least one of the following must be true:\n<ul>\n<li><code>A</code> is a GraphQL union;</li>\n<li><code>B</code> is a GraphQL interface, and <code>A</code> is a type that implements that interface;</li>\n<li><code>A</code> and <code>B</code> are the same type.</li>\n</ul>\n</li>\n<li><code>@recurse</code> can only be applied to vertex fields other than the root vertex field of a query.</li>\n<li>Cannot be used within a scope marked <code>@optional</code> or <code>@fold</code>.</li>\n<li>The <code>depth</code> parameter of the recursion must always have a value greater than or equal to 1.\nUsing <code>depth = 1</code> produces the current vertex and its neighboring vertices along the\nspecified edge.</li>\n<li>Type coercions and <code>@filter</code> directives within a scope marked <code>@recurse</code> do not limit the\nrecursion depth. Conceptually, recursion to the specified depth happens first,\nand then type coercions and <code>@filter</code> directives eliminate some of the locations reached\nby the recursion.</li>\n<li>As demonstrated by the examples above, the recursion always starts at depth 0,\nso the recursion scope always includes the vertex at the scope that encloses\nthe vertex field marked <code>@recurse</code>.</li>\n</ul>\n<h3>@output_source</h3>\n<p>See the <a href=\"#completeness-of-returned-results\" rel=\"nofollow\">Completeness of returned results</a> section\nfor a description of the directive and examples.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>May exist at most once in any given GraphQL query.</li>\n<li>Can exist only on a vertex field, and only on the last vertex field used in the query.</li>\n<li>Cannot be used within a scope marked <code>@optional</code> or <code>@fold</code>.</li>\n</ul>\n<h2>Supported filtering operations</h2>\n<h3>Comparison operators</h3>\n<p>Supported comparison operators:</p>\n<ul>\n<li>Equal to: <code>=</code></li>\n<li>Not equal to: <code>!=</code></li>\n<li>Greater than: <code>&gt;</code></li>\n<li>Less than: <code>&lt;</code></li>\n<li>Greater than or equal to: <code>&gt;=</code></li>\n<li>Less than or equal to: <code>&lt;=</code></li>\n</ul>\n<h4>Example Use</h4>\n<h5>Equal to (<code>=</code>):</h5>\n<pre>{\n    Species {\n        name @filter(op_name: \"=\", value: [\"$species_name\"])\n        uuid @output(out_name: \"species_uuid\")\n    }\n}\n</pre>\n<p>This returns one row for every <code>Species</code> whose name is equal to the value of the <code>$species_name</code>\nparameter. Each row contains the <code>uuid</code> of the <code>Species</code> in a column named <code>species_uuid</code>.</p>\n<h5>Greater than or equal to (<code>&gt;=</code>):</h5>\n<pre><code>{\n    Animal {\n        name @output(out_name: \"name\")\n        birthday @output(out_name: \"birthday\")\n                 @filter(op_name: \"&gt;=\", value: [\"$point_in_time\"])\n    }\n}\n</code></pre>\n<p>This returns one row for every <code>Animal</code> vertex that was born after or on a <code>$point_in_time</code>.\nEach row contains the animal's name and birthday in columns named <code>name</code> and <code>birthday</code>, respectively.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>All comparison operators must be on a property field.</li>\n</ul>\n<h3>name_or_alias</h3>\n<p>Allows you to filter on vertices which contain the exact string <code>$wanted_name_or_alias</code> in their\n<code>name</code> or <code>alias</code> fields.</p>\n<h4>Example Use</h4>\n<pre>{\n    Animal @filter(op_name: \"name_or_alias\", value: [\"$wanted_name_or_alias\"]) {\n        name @output(out_name: \"name\")\n    }\n}\n</pre>\n<p>This returns one row for every <code>Animal</code> vertex whose name and/or alias is equal to <code>$wanted_name_or_alias</code>.\nEach row contains the animal's name in a column named <code>name</code>.</p>\n<p>The value provided for <code>$wanted_name_or_alias</code> must be the full name and/or alias of the <code>Animal</code>.\nSubstrings will not be matched.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>Must be on a vertex field that has <code>name</code> and <code>alias</code> properties.</li>\n</ul>\n<h3>between</h3>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        name @output(out_name: \"name\")\n        birthday @filter(op_name: \"between\", value: [\"$lower\", \"$upper\"])\n                 @output(out_name: \"birthday\")\n    }\n}\n</pre>\n<p>This returns:</p>\n<ul>\n<li>One row for every <code>Animal</code> vertex whose birthday is in between <code>$lower</code> and <code>$upper</code> dates (inclusive).\nEach row contains the animal's name in a column named <code>name</code>.</li>\n</ul>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>Must be on a property field.</li>\n<li>The lower and upper bounds represent an inclusive interval, which means that the output may\ncontain values that match them exactly.</li>\n</ul>\n<h3>in_collection</h3>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        name @output(out_name: \"animal_name\")\n        color @output(out_name: \"color\")\n              @filter(op_name: \"in_collection\", value: [\"$colors\"])\n    }\n}\n</pre>\n<p>This returns one row for every <code>Animal</code> vertex which has a color contained in a list of colors.\nEach row contains the <code>Animal</code>'s name and color in columns named <code>animal_name</code> and <code>color</code>, respectively.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>Must be on a property field that is not of list type.</li>\n</ul>\n<h3>not_in_collection</h3>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        name @output(out_name: \"animal_name\")\n        color @output(out_name: \"color\")\n              @filter(op_name: \"not_in_collection\", value: [\"$colors\"])\n    }\n}\n</pre>\n<p>This returns one row for every <code>Animal</code> vertex which has a color not contained in a list of colors.\nEach row contains the <code>Animal</code>'s name and color in columns named <code>animal_name</code> and <code>color</code>, respectively.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>Must be on a property field that is not of list type.</li>\n</ul>\n<h3>has_substring</h3>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        name @filter(op_name: \"has_substring\", value: [\"$substring\"])\n             @output(out_name: \"animal_name\")\n    }\n}\n</pre>\n<p>This returns one row for every <code>Animal</code> vertex whose name contains the value supplied\nfor the <code>$substring</code> parameter. Each row contains the matching <code>Animal</code>'s name\nin a column named <code>animal_name</code>.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>Must be on a property field of string type.</li>\n</ul>\n<h3>contains</h3>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        alias @filter(op_name: \"contains\", value: [\"$wanted\"])\n        name @output(out_name: \"animal_name\")\n    }\n}\n</pre>\n<p>This returns one row for every <code>Animal</code> vertex whose list of aliases contains the value supplied\nfor the <code>$wanted</code> parameter. Each row contains the matching <code>Animal</code>'s name\nin a column named <code>animal_name</code>.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>Must be on a property field of list type.</li>\n</ul>\n<h3>not_contains</h3>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        alias @filter(op_name: \"not_contains\", value: [\"$wanted\"])\n        name @output(out_name: \"animal_name\")\n    }\n}\n</pre>\n<p>This returns one row for every <code>Animal</code> vertex whose list of aliases does not contain the value supplied\nfor the <code>$wanted</code> parameter. Each row contains the matching <code>Animal</code>'s name\nin a column named <code>animal_name</code>.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>Must be on a property field of list type.</li>\n</ul>\n<h3>intersects</h3>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        alias @filter(op_name: \"intersects\", value: [\"$wanted\"])\n        name @output(out_name: \"animal_name\")\n    }\n}\n</pre>\n<p>This returns one row for every <code>Animal</code> vertex whose list of aliases has a non-empty intersection\nwith the list of values supplied for the <code>$wanted</code> parameter.\nEach row contains the matching <code>Animal</code>'s name in a column named <code>animal_name</code>.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>Must be on a property field of list type.</li>\n</ul>\n<h3>has_edge_degree</h3>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        name @output(out_name: \"animal_name\")\n\n        out_Animal_ParentOf @filter(op_name: \"has_edge_degree\", value: [\"$child_count\"]) @optional {\n            uuid\n        }\n    }\n}\n</pre>\n<p>This returns one row for every <code>Animal</code> vertex that has exactly <code>$child_count</code> children\n(i.e. where the <code>out_Animal_ParentOf</code> edge appears exactly <code>$child_count</code> times).\nEach row contains the matching <code>Animal</code>'s name, in a column named <code>animal_name</code>.</p>\n<p>The <code>uuid</code> field within the <code>out_Animal_ParentOf</code> vertex field is added simply to satisfy\nthe GraphQL syntax rule that requires at least one field to exist within any <code>{}</code>.\nSince this field is not marked with any directive, it has no effect on the query.</p>\n<p><em>N.B.:</em> Please note the <code>@optional</code> directive on the vertex field being filtered above.\nIf in your use case you expect to set <code>$child_count</code> to 0, you must also mark that\nvertex field <code>@optional</code>. Recall that absence of <code>@optional</code> implies that at least one\nsuch edge must exist. If the <code>has_edge_degree</code> filter is used with a parameter set to 0,\nthat requires the edge to not exist. Therefore, if the <code>@optional</code> is not present in this situation,\nno valid result sets can be produced, and the resulting query will return no results.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>Must be on a vertex field that is not the root vertex of the query.</li>\n<li>Tagged values are not supported as parameters for this filter.</li>\n<li>If the runtime parameter for this operator can be <code>0</code>, it is <em>strongly recommended</em> to also apply\n<code>@optional</code> to the vertex field being filtered (see N.B. above for details).</li>\n</ul>\n<h2>Type coercions</h2>\n<p>Type coercions are operations that create a new scope whose type is different than the type of the\nenclosing scope of the coercion -- they coerce the enclosing scope into a different type.\nType coercions are represented with GraphQL inline fragments.</p>\n<h4>Example Use</h4>\n<pre>{\n    Species {\n        name @output(out_name: \"species_name\")\n        out_Species_Eats {\n            ... on Food {\n                name @output(out_name: \"food_name\")\n            }\n        }\n    }\n}\n</pre>\n<p>Here, the <code>out_Species_Eats</code> vertex field is of the <code>Union__Food__FoodOrSpecies__Species</code> union type. To proceed\nwith the query, the user must choose which of the types in the <code>Union__Food__FoodOrSpecies__Species</code> union to use.\nIn this example, <code>... on Food</code> indicates that the <code>Food</code> type was chosen, and any vertices\nat that scope that are not of type <code>Food</code> are filtered out and discarded.</p>\n<pre>{\n    Species {\n        name @output(out_name: \"species_name\")\n        out_Entity_Related {\n            ... on Species {\n                name @output(out_name: \"food_name\")\n            }\n        }\n    }\n}\n</pre>\n<p>In this query, the <code>out_Entity_Related</code> is of <code>Entity</code> type. However, the query only wants to\nreturn results where the related entity is a <code>Species</code>, which <code>... on Species</code> ensures is the case.</p>\n<h2>Meta fields</h2>\n<h3>__typename</h3>\n<p>The compiler supports the standard GraphQL meta field <code>__typename</code>, which returns the runtime type\nof the scope where the field is found. Assuming the GraphQL schema matches the database's schema,\nthe runtime type will always be a subtype of (or exactly equal to) the static type of the scope\ndetermined by the GraphQL type system. Below, we provide an example query in which\nthe runtime type is a subtype of the static type, but is not equal to it.</p>\n<p>The <code>__typename</code> field is treated as a property field of type <code>String</code>, and supports\nall directives that can be applied to any other property field.</p>\n<h4>Example Use</h4>\n<pre>{\n    Entity {\n        __typename @output(out_name: \"entity_type\")\n        name @output(out_name: \"entity_name\")\n    }\n}\n</pre>\n<p>This query returns one row for each <code>Entity</code> vertex. The scope in which <code>__typename</code> appears is\nof static type <code>Entity</code>. However, <code>Animal</code> is a type of <code>Entity</code>, as are <code>Species</code>, <code>Food</code>,\nand others. Vertices of all subtypes of <code>Entity</code> will therefore be returned, and the <code>entity_type</code>\ncolumn that outputs the <code>__typename</code> field will show their runtime type: <code>Animal</code>, <code>Species</code>,\n<code>Food</code>, etc.</p>\n<h3>_x_count</h3>\n<p>The <code>_x_count</code> meta field is a non-standard meta field defined by the GraphQL compiler that makes it\npossible to interact with the <em>number</em> of elements in a scope marked <code>@fold</code>. By applying directives\nlike <code>@output</code> and <code>@filter</code> to this meta field, queries can output the number of elements captured\nin the <code>@fold</code> and filter down results to select only those with the desired fold sizes.</p>\n<p>We use the <code>_x_</code> prefix to signify that this is an extension meta field introduced by the compiler,\nand not part of the canonical set of GraphQL meta fields defined by the GraphQL specification.\nWe do not use the GraphQL standard double-underscore (<code>__</code>) prefix for meta fields,\nsince all names with that prefix are\n<a href=\"https://facebook.github.io/graphql/draft/#sec-Reserved-Names\" rel=\"nofollow\">explicitly reserved and prohibited from being used</a>\nin directives, fields, or any other artifacts.</p>\n<h4>Adding the <code>_x_count</code> meta field to your schema</h4>\n<p>Since the <code>_x_count</code> meta field is not currently part of the GraphQL standard, it has to be\nexplicitly added to all interfaces and types in your schema. There are two ways to do this.</p>\n<p>The preferred way to do this is to use the <code>EXTENDED_META_FIELD_DEFINITIONS</code> constant as\na starting point for building your interfaces' and types' field descriptions:</p>\n<pre><code>from graphql import GraphQLInt, GraphQLField, GraphQLObjectType, GraphQLString\nfrom graphql_compiler import EXTENDED_META_FIELD_DEFINITIONS\n\nfields = EXTENDED_META_FIELD_DEFINITIONS.copy()\nfields.update({\n    'foo': GraphQLField(GraphQLString),\n    'bar': GraphQLField(GraphQLInt),\n    # etc.\n})\ngraphql_type = GraphQLObjectType('MyType', fields)\n# etc.\n</code></pre>\n<p>If you are not able to programmatically define the schema, and instead simply have a pre-made\nGraphQL schema object that you are able to mutate, the alternative approach is via the\n<code>insert_meta_fields_into_existing_schema()</code> helper function defined by the compiler:</p>\n<pre><code># assuming that existing_schema is your GraphQL schema object\ninsert_meta_fields_into_existing_schema(existing_schema)\n# existing_schema was mutated in-place and all custom meta-fields were added\n</code></pre>\n<h4>Example Use</h4>\n<pre>{\n    Animal {\n        name @output(out_name: \"name\")\n        out_Animal_ParentOf @fold {\n            _x_count @output(out_name: \"number_of_children\")\n            name @output(out_name: \"child_names\")\n        }\n    }\n}\n</pre>\n<p>This query returns one row for each <code>Animal</code> vertex. Each row contains its name, and the number and names\nof its children. While the output type of the <code>child_names</code> selection is a list of strings,\nthe output type of the <code>number_of_children</code> selection is an integer.</p>\n<pre>{\n    Animal {\n        name @output(out_name: \"name\")\n        out_Animal_ParentOf @fold {\n            _x_count @filter(op_name: \"&gt;=\", value: [\"$min_children\"])\n                    @output(out_name: \"number_of_children\")\n            name @filter(op_name: \"has_substring\", value: [\"$substr\"])\n                 @output(out_name: \"child_names\")\n        }\n    }\n}\n</pre>\n<p>Here, we've modified the above query to add two more filtering constraints to the returned rows:</p>\n<ul>\n<li>child <code>Animal</code> vertices must contain the value of <code>$substr</code> as a substring in their name, and</li>\n<li><code>Animal</code> vertices must have at least <code>$min_children</code> children that satisfy the above filter.</li>\n</ul>\n<p>Importantly, any filtering on <code>_x_count</code> is applied <em>after</em> any other filters and type coercions\nthat are present in the <code>@fold</code> in question. This order of operations matters a lot: selecting\n<code>Animal</code> vertices with 3+ children, then filtering the children based on their names is not the same\nas filtering the children first, and then selecting <code>Animal</code> vertices that have 3+ children that\nmatched the earlier filter.</p>\n<h4>Constraints and Rules</h4>\n<ul>\n<li>The <code>_x_count</code> field is only allowed to appear within a vertex field marked <code>@fold</code>.</li>\n<li>Filtering on <code>_x_count</code> is always applied <em>after</em> any other filters and type coercions present\nin that <code>@fold</code>.</li>\n<li>Filtering or outputting the value of the <code>_x_count</code> field must always be done at the innermost\nscope of the <code>@fold</code>. It is invalid to expand vertex fields within a <code>@fold</code> after filtering\nor outputting the value of the <code>_x_count</code> meta field.</li>\n</ul>\n<h4>How is filtering on <code>_x_count</code> different from <code>@filter</code> with <code>has_edge_degree</code>?</h4>\n<p>The <code>has_edge_degree</code> filter allows filtering based on the number of edges of a particular type.\nThere are situations in which filtering with <code>has_edge_degree</code> and filtering using <code>=</code> on <code>_x_count</code>\nproduce equivalent queries. Here is one such pair of queries:</p>\n<pre>{\n    Species {\n        name @output(out_name: \"name\")\n        in_Animal_OfSpecies @filter(op_name: \"has_edge_degree\", value: [\"$num_animals\"]) {\n            uuid\n        }\n    }\n}\n</pre>\n<p>and</p>\n<pre>{\n    Species {\n        name @output(out_name: \"name\")\n        in_Animal_OfSpecies @fold {\n            _x_count @filter(op_name: \"=\", value: [\"$num_animals\"])\n        }\n    }\n}\n</pre>\n<p>In both of these queries, we ask for the names of the <code>Species</code> vertices that have precisely\n<code>$num_animals</code> members. However, we have expressed this question in two different ways: once\nas a property of the <code>Species</code> vertex (\"the degree of the <code>in_Animal_OfSpecies</code> is <code>$num_animals</code>\"),\nand once as a property of the list of <code>Animal</code> vertices produced by the <code>@fold</code> (\"the number of\nelements in the <code>@fold</code> is <code>$num_animals</code>\").</p>\n<p>When we add additional filtering within the <code>Animal</code> vertices of the <code>in_Animal_OfSpecies</code> vertex\nfield, this distinction becomes very important. Compare the following two queries:</p>\n<pre>{\n    Species {\n        name @output(out_name: \"name\")\n        in_Animal_OfSpecies @filter(op_name: \"has_edge_degree\", value: [\"$num_animals\"]) {\n            out_Animal_LivesIn {\n                name @filter(op_name: \"=\", value: [\"$location\"])\n            }\n        }\n    }\n}\n</pre>\n<p>versus</p>\n<pre>{\n    Species {\n        name @output(out_name: \"name\")\n        in_Animal_OfSpecies @fold {\n            out_Animal_LivesIn {\n                _x_count @filter(op_name: \"=\", value: [\"$num_animals\"])\n                name @filter(op_name: \"=\", value: [\"$location\"])\n            }\n        }\n    }\n}\n</pre>\n<p>In the first, for the purposes of the <code>has_edge_degree</code> filtering, the location where the animals\nlive is irrelevant: the <code>has_edge_degree</code> only makes sure that the <code>Species</code> vertex has the\ncorrect number of edges of type <code>in_Animal_OfSpecies</code>, and that's it. In contrast, the second query\nensures that only <code>Species</code> vertices that have <code>$num_animals</code> animals that live in the selected\nlocation are returned -- the location matters since the <code>@filter</code> on the <code>_x_count</code> field applies\nto the number of elements in the <code>@fold</code> scope.</p>\n<h2>The GraphQL schema</h2>\n<p>This section assumes that the reader is familiar with the way schemas work in the\n<a href=\"http://graphql.org/learn/schema/\" rel=\"nofollow\">reference implementation of GraphQL</a>.</p>\n<p>The GraphQL schema used with the compiler must contain the custom directives and custom <code>Date</code>\nand <code>DateTime</code> scalar types defined by the compiler:</p>\n<pre><code>directive @recurse(depth: Int!) on FIELD\n\ndirective @filter(value: [String!]!, op_name: String!) on FIELD | INLINE_FRAGMENT\n\ndirective @tag(tag_name: String!) on FIELD\n\ndirective @output(out_name: String!) on FIELD\n\ndirective @output_source on FIELD\n\ndirective @optional on FIELD\n\ndirective @fold on FIELD\n\nscalar DateTime\n\nscalar Date\n</code></pre>\n<p>If constructing the schema programmatically, one can simply import the the Python object\nrepresentations of the custom directives and the custom types:</p>\n<pre><code>from graphql_compiler import DIRECTIVES  # the list of custom directives\nfrom graphql_compiler import GraphQLDate, GraphQLDateTime  # the custom types\n</code></pre>\n<p>Since the GraphQL and OrientDB type systems have different rules, there is no one-size-fits-all\nsolution to writing the GraphQL schema for a given database schema.\nHowever, the following rules of thumb are useful to keep in mind:</p>\n<ul>\n<li>Generally, represent OrientDB abstract classes as GraphQL interfaces. In GraphQL's type system,\nGraphQL interfaces cannot inherit from other GraphQL interfaces.</li>\n<li>Generally, represent OrientDB non-abstract classes as GraphQL types,\nlisting the GraphQL interfaces that they implement. In GraphQL's type system, GraphQL types\ncannot inherit from other GraphQL types.</li>\n<li>Inheritance relationships between two OrientDB non-abstract classes,\nor between two OrientDB abstract classes, introduce some difficulties in GraphQL.\nWhen modelling your data in OrientDB, it's best to avoid such inheritance if possible.</li>\n<li>If it is impossible to avoid having two non-abstract OrientDB classes <code>A</code> and <code>B</code> such that\n<code>B</code> inherits from <code>A</code>, you have two options:\n<ul>\n<li>You may choose to represent the <code>A</code> OrientDB class as a GraphQL interface,\nwhich the GraphQL type corresponding to <code>B</code> can implement.\nIn this case, the GraphQL schema preserves the inheritance relationship\nbetween <code>A</code> and <code>B</code>, but sacrifices the representation of any inheritance relationships\n<code>A</code> may have with any OrientDB superclasses.</li>\n<li>You may choose to represent both <code>A</code> and <code>B</code> as GraphQL types. The tradeoff in this case is\nexactly the opposite from the previous case: the GraphQL schema\nsacrifices the inheritance relationship between <code>A</code> and <code>B</code>, but preserves the\ninheritance relationships of <code>A</code> with its superclasses.\nIn this case, it is recommended to create a GraphQL union type <code>A | B</code>,\nand to use that GraphQL union type for any vertex fields that\nin OrientDB would be of type <code>A</code>.</li>\n</ul>\n</li>\n<li>If it is impossible to avoid having two abstract OrientDB classes <code>A</code> and <code>B</code> such that\n<code>B</code> inherits from <code>A</code>, you similarly have two options:\n<ul>\n<li>You may choose to represent <code>B</code> as a GraphQL type that can implement the GraphQL interface\ncorresponding to <code>A</code>. This makes the GraphQL schema preserve the inheritance relationship\nbetween <code>A</code> and <code>B</code>, but sacrifices the ability for other GraphQL types to inherit from <code>B</code>.</li>\n<li>You may choose to represent both <code>A</code> and <code>B</code> as GraphQL interfaces, sacrificing the schema's\nrepresentation of the inheritance between <code>A</code> and <code>B</code>, but allowing GraphQL types\nto inherit from both <code>A</code> and <code>B</code>. If necessary, you can then create a GraphQL\nunion type <code>A | B</code> and use it for any vertex fields that in OrientDB would be of type <code>A</code>.</li>\n</ul>\n</li>\n<li>It is legal to fully omit classes and fields that are not representable in GraphQL. The compiler\ncurrently does not support OrientDB's <code>EmbeddedMap</code> type nor embedded non-primitive typed fields,\nso such fields can simply be omitted in the GraphQL representation of their classes.\nAlternatively, the entire OrientDB class and all edges that may point to it may be omitted\nentirely from the GraphQL schema.</li>\n</ul>\n<h2>Execution model</h2>\n<p>Since the GraphQL compiler can target multiple different query languages, each with its own\nbehaviors and limitations, the execution model must also be defined as a function of the\ncompilation target language. While we strive to minimize the differences between\ncompilation targets, some differences are unavoidable.</p>\n<p>The compiler abides by the following principles:</p>\n<ul>\n<li>When the database is queried with a compiled query string, its response must always be in the\nform of a list of results.</li>\n<li>The precise format of each such result is defined by each compilation target separately.\n<ul>\n<li><code>gremlin</code>, <code>MATCH</code> and <code>SQL</code> return data in a tabular format, where each result is\na row of the table, and fields marked for output are columns.</li>\n<li>However, future compilation targets may have a different format. For example, each result\nmay appear in the nested tree format used by the standard GraphQL specification.</li>\n</ul>\n</li>\n<li>Each such result must satisfy all directives and types in its corresponding GraphQL query.</li>\n<li>The returned list of results is <strong>not</strong> guaranteed to be complete!\n<ul>\n<li>In other words, there may have been additional result sets that satisfy all directives and\ntypes in the corresponding GraphQL query, but were not returned by the database.</li>\n<li>However, compilation target implementations are encouraged to return complete results\nif at all practical. The <code>MATCH</code> compilation target is guaranteed to produce complete results.</li>\n</ul>\n</li>\n</ul>\n<h3>Completeness of returned results</h3>\n<p>To explain the completeness of returned results in more detail, assume the database contains\nthe following example graph:</p>\n<pre><code>a  ----&gt;_ x\n|____   /|\n    _|_/\n   / |____\n  /      \\/\nb  ----&gt; y\n</code></pre>\n<p>Let <code>a, b, x, y</code> be the values of the <code>name</code> property field of four vertices.\nLet the vertices named <code>a</code> and <code>b</code> be of type <code>S</code>, and let <code>x</code> and <code>y</code> be of type <code>T</code>.\nLet vertex <code>a</code> be connected to both <code>x</code> and <code>y</code> via directed edges of type <code>E</code>.\nSimilarly, let vertex <code>b</code> also be connected to both <code>x</code> and <code>y</code> via directed edges of type <code>E</code>.</p>\n<p>Consider the GraphQL query:</p>\n<pre><code>{\n    S {\n        name @output(out_name: \"s_name\")\n        out_E {\n            name @output(out_name: \"t_name\")\n        }\n    }\n}\n</code></pre>\n<p>Between the data in the database and the query's structure, it is clear that combining any of\n<code>a</code> or <code>b</code> with any of <code>x</code> or <code>y</code> would produce a valid result. Therefore,\nthe complete result list, shown here in JSON format, would be:</p>\n<pre><code>[\n    {\"s_name\": \"a\", \"t_name\": \"x\"},\n    {\"s_name\": \"a\", \"t_name\": \"y\"},\n    {\"s_name\": \"b\", \"t_name\": \"x\"},\n    {\"s_name\": \"b\", \"t_name\": \"y\"},\n]\n</code></pre>\n<p>This is precisely what the <code>MATCH</code> compilation target is guaranteed to produce.\nThe remainder of this section is only applicable to the <code>gremlin</code> compilation target. If using\n<code>MATCH</code>, all of the queries listed in the remainder of this section will produce the same, complete\nresult list.</p>\n<p>Since the <code>gremlin</code> compilation target does not guarantee a complete result list,\nquerying the database using a query string generated by the <code>gremlin</code> compilation target\nwill produce only a partial result list resembling the following:</p>\n<pre><code>[\n    {\"s_name\": \"a\", \"t_name\": \"x\"},\n    {\"s_name\": \"b\", \"t_name\": \"x\"},\n]\n</code></pre>\n<p>Due to limitations in the underlying query language, <code>gremlin</code> will by default produce at most one\nresult for each of the starting locations in the query. The above GraphQL query started at\nthe type <code>S</code>, so each <code>s_name</code> in the returned result list is therefore distinct. Furthermore,\nthere is no guarantee (and no way to know ahead of time) whether <code>x</code> or <code>y</code> will be returned as\nthe <code>t_name</code> value in each result, as they are both valid results.</p>\n<p>Users may apply the <code>@output_source</code> directive on the last scope of the query\nto alter this behavior:</p>\n<pre>{\n    S {\n        name @output(out_name: \"s_name\")\n        out_E @output_source {\n            name @output(out_name: \"t_name\")\n        }\n    }\n}\n</pre>\n<p>Rather than producing at most one result for each <code>S</code>, the query will now produce\nat most one result for each distinct value that can be found at <code>out_E</code>, where the directive\nis applied:</p>\n<pre>[\n    {\"s_name\": \"a\", \"t_name\": \"x\"},\n    {\"s_name\": \"a\", \"t_name\": \"y\"},\n]\n</pre>\n<p>Conceptually, applying the <code>@output_source</code> directive makes it as if the query were written in\nthe opposite order:</p>\n<pre>{\n    T {\n        name @output(out_name: \"t_name\")\n        in_E {\n            name @output(out_name: \"s_name\")\n        }\n    }\n}\n</pre>\n<h2>SQL</h2>\n<p>The following table outlines GraphQL compiler features, and their support (if any) by various\nrelational database flavors:</p>\n<table>\n<thead>\n<tr>\n<th>Feature/Dialect</th>\n<th>Required Edges</th>\n<th>@filter</th>\n<th>@output</th>\n<th>@recurse</th>\n<th>@fold</th>\n<th>@optional</th>\n<th>@output_source</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PostgreSQL</td>\n<td>No</td>\n<td>Limited, <a href=\"#intersects\" rel=\"nofollow\">intersects</a>, <a href=\"#has_edge_degree\" rel=\"nofollow\">has_edge_degree</a>, and <a href=\"#name_or_alias\" rel=\"nofollow\">name_or_alias</a> filter unsupported</td>\n<td>Limited, <a href=\"#__typename\" rel=\"nofollow\">__typename</a> output metafield unsupported</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>SQLite</td>\n<td>No</td>\n<td>Limited, <a href=\"#intersects\" rel=\"nofollow\">intersects</a>, <a href=\"#has_edge_degree\" rel=\"nofollow\">has_edge_degree</a>, and <a href=\"#name_or_alias\" rel=\"nofollow\">name_or_alias</a> filter unsupported</td>\n<td>Limited, <a href=\"#__typename\" rel=\"nofollow\">__typename</a> output metafield unsupported</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Microsoft SQL Server</td>\n<td>No</td>\n<td>Limited, <a href=\"#intersects\" rel=\"nofollow\">intersects</a>, <a href=\"#has_edge_degree\" rel=\"nofollow\">has_edge_degree</a>, and <a href=\"#name_or_alias\" rel=\"nofollow\">name_or_alias</a> filter unsupported</td>\n<td>Limited, <a href=\"#__typename\" rel=\"nofollow\">__typename</a> output metafield unsupported</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>MySQL</td>\n<td>No</td>\n<td>Limited, <a href=\"#intersects\" rel=\"nofollow\">intersects</a>, <a href=\"#has_edge_degree\" rel=\"nofollow\">has_edge_degree</a>, and <a href=\"#name_or_alias\" rel=\"nofollow\">name_or_alias</a> filter unsupported</td>\n<td>Limited, <a href=\"#__typename\" rel=\"nofollow\">__typename</a> output metafield unsupported</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>MariaDB</td>\n<td>No</td>\n<td>Limited, <a href=\"#intersects\" rel=\"nofollow\">intersects</a>, <a href=\"#has_edge_degree\" rel=\"nofollow\">has_edge_degree</a>, and <a href=\"#name_or_alias\" rel=\"nofollow\">name_or_alias</a> filter unsupported</td>\n<td>Limited, <a href=\"#__typename\" rel=\"nofollow\">__typename</a> output metafield unsupported</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n</tr></tbody></table>\n<h3>Configuring SQLAlchemy</h3>\n<p>Relational databases are supported by compiling to SQLAlchemy core as an intermediate\nlanguage, and then relying on SQLAlchemy's compilation of the dialect specific SQL string to query\nthe target database.</p>\n<p>For the SQL backend, GraphQL types are assumed to have a SQL table of the same name, and with the\nsame properties. For example, a schema type</p>\n<pre><code>type Animal {\n    name: String\n}\n</code></pre>\n<p>is expected to correspond to a SQLAlchemy table object of the same name, case insensitive. For this\nschema type this could look like:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">sqlalchemy</span> <span class=\"kn\">import</span> <span class=\"n\">MetaData</span><span class=\"p\">,</span> <span class=\"n\">Table</span><span class=\"p\">,</span> <span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">String</span>\n<span class=\"c1\"># table for GraphQL type Animal</span>\n<span class=\"n\">metadata</span> <span class=\"o\">=</span> <span class=\"n\">MetaData</span><span class=\"p\">()</span>\n<span class=\"n\">animal_table</span> <span class=\"o\">=</span> <span class=\"n\">Table</span><span class=\"p\">(</span>\n    <span class=\"s1\">'animal'</span><span class=\"p\">,</span> <span class=\"c1\"># name of table matches type name from schema</span>\n    <span class=\"n\">metadata</span><span class=\"p\">,</span>\n    <span class=\"n\">Column</span><span class=\"p\">(</span><span class=\"s1\">'name'</span><span class=\"p\">,</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">length</span><span class=\"o\">=</span><span class=\"mi\">12</span><span class=\"p\">)),</span> <span class=\"c1\"># Animal.name GraphQL field has corresponding 'name' column</span>\n<span class=\"p\">)</span>\n</pre>\n<p>If a table of the schema type name does not exist, an exception will be raised at compile time. See\n<a href=\"#configuring-the-sql-database-to-match-the-graphql-schema\" rel=\"nofollow\">Configuring the SQL Database to Match the GraphQL Schema</a>\nfor a possible option to resolve such naming discrepancies.</p>\n<h3>End-To-End SQL Example</h3>\n<p>An end-to-end example including relevant GraphQL schema and SQLAlchemy engine preparation follows.</p>\n<p>This is intended to show the setup steps for the SQL backend of the GraphQL compiler, and\ndoes not represent best practices for configuring and running SQLAlchemy in a production system.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">graphql</span> <span class=\"kn\">import</span> <span class=\"n\">parse</span>\n<span class=\"kn\">from</span> <span class=\"nn\">graphql.utils.build_ast_schema</span> <span class=\"kn\">import</span> <span class=\"n\">build_ast_schema</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sqlalchemy</span> <span class=\"kn\">import</span> <span class=\"n\">MetaData</span><span class=\"p\">,</span> <span class=\"n\">Table</span><span class=\"p\">,</span> <span class=\"n\">Column</span><span class=\"p\">,</span> <span class=\"n\">String</span><span class=\"p\">,</span> <span class=\"n\">create_engine</span>\n<span class=\"kn\">from</span> <span class=\"nn\">graphql_compiler.compiler.ir_lowering_sql.metadata</span> <span class=\"kn\">import</span> <span class=\"n\">SqlMetadata</span>\n<span class=\"kn\">from</span> <span class=\"nn\">graphql_compiler</span> <span class=\"kn\">import</span> <span class=\"n\">graphql_to_sql</span>\n\n<span class=\"c1\"># Step 1: Configure a GraphQL schema (note that this can also be done programmatically)</span>\n<span class=\"n\">schema_text</span> <span class=\"o\">=</span> <span class=\"s1\">'''</span>\n<span class=\"s1\">schema {</span>\n<span class=\"s1\">    query: RootSchemaQuery</span>\n<span class=\"s1\">}</span>\n<span class=\"s1\"># IMPORTANT NOTE: all compiler directives are expected here, but not shown to keep the example brief</span>\n\n<span class=\"s1\">directive @filter(op_name: String!, value: [String!]!) on FIELD | INLINE_FRAGMENT</span>\n\n<span class=\"s1\"># &lt; more directives here, see the GraphQL schema section of this README for more details. &gt;</span>\n\n<span class=\"s1\">directive @output(out_name: String!) on FIELD</span>\n\n<span class=\"s1\">type Animal {</span>\n<span class=\"s1\">    name: String</span>\n<span class=\"s1\">}</span>\n<span class=\"s1\">'''</span>\n<span class=\"n\">schema</span> <span class=\"o\">=</span> <span class=\"n\">build_ast_schema</span><span class=\"p\">(</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">schema_text</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Step 2: For all GraphQL types, bind all corresponding SQLAlchemy Tables to a single SQLAlchemy</span>\n<span class=\"c1\"># metadata instance, using the expected naming detailed above.</span>\n<span class=\"c1\"># See https://docs.sqlalchemy.org/en/latest/core/metadata.html for more details on this step.</span>\n<span class=\"n\">metadata</span> <span class=\"o\">=</span> <span class=\"n\">MetaData</span><span class=\"p\">()</span>\n<span class=\"n\">animal_table</span> <span class=\"o\">=</span> <span class=\"n\">Table</span><span class=\"p\">(</span>\n    <span class=\"s1\">'animal'</span><span class=\"p\">,</span> <span class=\"c1\"># name of table matches type name from schema</span>\n    <span class=\"n\">metadata</span><span class=\"p\">,</span>\n    <span class=\"c1\"># Animal.name schema field has corresponding 'name' column in animal table</span>\n    <span class=\"n\">Column</span><span class=\"p\">(</span><span class=\"s1\">'name'</span><span class=\"p\">,</span> <span class=\"n\">String</span><span class=\"p\">(</span><span class=\"n\">length</span><span class=\"o\">=</span><span class=\"mi\">12</span><span class=\"p\">)),</span> \n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Step 3: Prepare a SQLAlchemy engine to query the target relational database.</span>\n<span class=\"c1\"># See https://docs.sqlalchemy.org/en/latest/core/engines.html for more detail on this step.</span>\n<span class=\"n\">engine</span> <span class=\"o\">=</span> <span class=\"n\">create_engine</span><span class=\"p\">(</span><span class=\"s1\">'&lt;connection string&gt;'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Step 4: Wrap the SQLAlchemy metadata and dialect as a SqlMetadata GraphQL compiler object</span>\n<span class=\"n\">sql_metadata</span> <span class=\"o\">=</span> <span class=\"n\">SqlMetadata</span><span class=\"p\">(</span><span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">dialect</span><span class=\"p\">,</span> <span class=\"n\">metadata</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Step 5: Prepare and compile a GraphQL query against the schema</span>\n<span class=\"n\">graphql_query</span> <span class=\"o\">=</span> <span class=\"s1\">'''</span>\n<span class=\"s1\">{</span>\n<span class=\"s1\">    Animal {</span>\n<span class=\"s1\">        name @output(out_name: \"animal_name\")</span>\n<span class=\"s1\">             @filter(op_name: \"in_collection\", value: [\"$names\"])</span>\n<span class=\"s1\">    }</span>\n<span class=\"s1\">}</span>\n<span class=\"s1\">'''</span>\n<span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'names'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'animal name 1'</span><span class=\"p\">,</span> <span class=\"s1\">'animal name 2'</span><span class=\"p\">],</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">compilation_result</span> <span class=\"o\">=</span> <span class=\"n\">graphql_to_sql</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"n\">graphql_query</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">,</span> <span class=\"n\">sql_metadata</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Step 6: Execute compiled query against a SQLAlchemy engine/connection. </span>\n<span class=\"c1\"># See https://docs.sqlalchemy.org/en/latest/core/connections.html for more details.</span>\n<span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"n\">compilation_result</span><span class=\"o\">.</span><span class=\"n\">query</span>\n<span class=\"n\">query_results</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">result_proxy</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">result_proxy</span> <span class=\"ow\">in</span> <span class=\"n\">engine</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">)]</span>\n</pre>\n<h3>Configuring the SQL Database to Match the GraphQL Schema</h3>\n<p>For simplicity, the SQL backend expects an exact match between SQLAlchemy Tables and GraphQL types,\nand between SQLAlchemy Columns and GraphQL fields. What if the table name or column name in the\ndatabase doesn't conform to these rules? Eventually the plan is to make this aspect of the\nSQL backend more configurable. In the near-term, a possible way to address this is by using\nSQL views.</p>\n<p>For example, suppose there is a table in the database called <code>animal_table</code> and it has a column\ncalled <code>animal_name</code>. If the desired schema has type</p>\n<pre><code>type Animal {\n    name: String\n}\n</code></pre>\n<p>Then this could be exposed via a view like:</p>\n<pre><span class=\"k\">CREATE</span> <span class=\"k\">VIEW</span> <span class=\"n\">animal</span> <span class=\"k\">AS</span> \n    <span class=\"k\">SELECT</span>\n        <span class=\"n\">animal_name</span> <span class=\"k\">AS</span> <span class=\"n\">name</span>\n    <span class=\"k\">FROM</span> <span class=\"n\">animal_table</span>\n</pre>\n<p>At this point, the <code>animal</code> view can be used in the SQLAlchemy Table for the purposes of compiling.</p>\n<h2>Miscellaneous</h2>\n<h3>Pretty-Printing GraphQL Queries</h3>\n<p>To pretty-print GraphQL queries, use the included pretty-printer:</p>\n<pre><code>python -m graphql_compiler.tool &lt;input_file.graphql &gt;output_file.graphql\n</code></pre>\n<p>It's modeled after Python's <code>json.tool</code>, reading from stdin and writing to stdout.</p>\n<h3>Expanding <a href=\"#optional\" rel=\"nofollow\"><code>@optional</code></a> vertex fields</h3>\n<p>Including an optional statement in GraphQL has no performance issues on its own,\nbut if you continue expanding vertex fields within an optional scope,\nthere may be significant performance implications.</p>\n<p>Going forward, we will refer to two different kinds of <code>@optional</code> directives.</p>\n<ul>\n<li>A <em>\"simple\"</em> optional is a vertex with an <code>@optional</code> directive that does not expand\nany vertex fields within it.\nFor example:</li>\n</ul>\n<pre>{\n    Animal {\n        name @output(out_name: \"name\")\n        in_Animal_ParentOf @optional {\n            name @output(out_name: \"parent_name\")\n        }\n    }\n}\n</pre>\n<p>OrientDB <code>MATCH</code> currently allows the last step in any traversal to be optional.\nTherefore, the equivalent <code>MATCH</code> traversal for the above <code>GraphQL</code> is as follows:</p>\n<pre><code>SELECT\n    Animal___1.name as `name`,\n    Animal__in_Animal_ParentOf___1.name as `parent_name`\nFROM (\n    MATCH {\n        class: Animal,\n        as: Animal___1\n    }.in('Animal_ParentOf') {\n        as: Animal__in_Animal_ParentOf___1\n    }\n    RETURN $matches\n)\n</code></pre>\n<ul>\n<li>A <em>\"compound\"</em> optional is a vertex with an <code>@optional</code> directive which does expand\nvertex fields within it.\nFor example:</li>\n</ul>\n<pre>{\n    Animal {\n        name @output(out_name: \"name\")\n        in_Animal_ParentOf @optional {\n            name @output(out_name: \"parent_name\")\n            in_Animal_ParentOf {\n                name @output(out_name: \"grandparent_name\")\n            }\n        }\n    }\n}\n</pre>\n<p>Currently, this cannot represented by a simple <code>MATCH</code> query.\nSpecifically, the following is <em>NOT</em> a valid <code>MATCH</code> statement,\nbecause the optional traversal follows another edge:</p>\n<pre><code>-- NOT A VALID QUERY\nSELECT\n    Animal___1.name as `name`,\n    Animal__in_Animal_ParentOf___1.name as `parent_name`\nFROM (\n    MATCH {\n        class: Animal,\n        as: Animal___1\n    }.in('Animal_ParentOf') {\n        optional: true,\n        as: Animal__in_Animal_ParentOf___1\n    }.in('Animal_ParentOf') {\n        as: Animal__in_Animal_ParentOf__in_Animal_ParentOf___1\n    }\n    RETURN $matches\n)\n</code></pre>\n<p>Instead, we represent a <em>compound</em> optional by taking an union (<code>UNIONALL</code>) of two distinct\n<code>MATCH</code> queries. For instance, the <code>GraphQL</code> query above can be represented as follows:</p>\n<pre><code>SELECT EXPAND($final_match)\nLET\n    $match1 = (\n        SELECT\n            Animal___1.name AS `name`\n        FROM (\n            MATCH {\n                class: Animal,\n                as: Animal___1,\n                where: (\n                    (in_Animal_ParentOf IS null)\n                    OR\n                    (in_Animal_ParentOf.size() = 0)\n                ),\n            }\n        )\n    ),\n    $match2 = (\n        SELECT\n            Animal___1.name AS `name`,\n            Animal__in_Animal_ParentOf___1.name AS `parent_name`\n        FROM (\n            MATCH {\n                class: Animal,\n                as: Animal___1\n            }.in('Animal_ParentOf') {\n                as: Animal__in_Animal_ParentOf___1\n            }.in('Animal_ParentOf') {\n                as: Animal__in_Animal_ParentOf__in_Animal_ParentOf___1\n            }\n        )\n    ),\n    $final_match = UNIONALL($match1, $match2)\n</code></pre>\n<p>In the first case where the optional edge is not followed,\nwe have to explicitly filter out all vertices where the edge <em>could have been followed</em>.\nThis is to eliminate duplicates between the two <code>MATCH</code> selections.</p>\n<p>The previous example is not <em>exactly</em> how we implement <em>compound</em> optionals\n(we also have <code>SELECT</code> statements within <code>$match1</code> and <code>$match2</code>),\nbut it illustrates the the general idea.</p>\n<h4>Performance Penalty</h4>\n<p>If we have many <em>compound</em> optionals in the given <code>GraphQL</code>,\nthe above procedure results in the union of a large number of <code>MATCH</code> queries.\nSpecifically, for <code>n</code> compound optionals, we generate 2<sup>n</sup> different <code>MATCH</code> queries.\nFor each of the 2<sup>n</sup> subsets <code>S</code> of the <code>n</code> optional edges:</p>\n<ul>\n<li>We remove the <code>@optional</code> restriction for each traversal in <code>S</code>.</li>\n<li>For each traverse <code>t</code> in the complement of <code>S</code>, we entirely discard <code>t</code>\nalong with all the vertices and directives within it, and we add a filter\non the previous traverse to ensure that the edge corresponding to <code>t</code> does not exist.</li>\n</ul>\n<p>Therefore, we get a performance penalty that grows exponentially\nwith the number of <em>compound</em> optional edges.\nThis is important to keep in mind when writing queries with many optional directives.</p>\n<p>If some of those <em>compound</em> optionals contain <code>@optional</code> vertex fields of their own,\nthe performance penalty grows since we have to account for all possible subsets of <code>@optional</code>\nstatements that can be satisfied simultaneously.</p>\n<h3>Optional <code>type_equivalence_hints</code> parameter</h3>\n<p>This compilation parameter is a workaround for the limitations of the GraphQL and Gremlin\ntype systems:</p>\n<ul>\n<li>GraphQL does not allow <code>type</code> to inherit from another <code>type</code>, only to implement an <code>interface</code>.</li>\n<li>Gremlin does not have first-class support for inheritance at all.</li>\n</ul>\n<p>Assume the following GraphQL schema:</p>\n<pre>type Animal {\n    name: String\n}\n\ntype Cat {\n    name: String\n}\n\ntype Dog {\n    name: String\n}\n\nunion AnimalCatDog = Animal | Cat | Dog\n\ntype Foo {\n    adjacent_animal: AnimalCatDog\n}\n</pre>\n<p>An appropriate <code>type_equivalence_hints</code> value here would be <code>{ Animal: AnimalCatDog }</code>.\nThis lets the compiler know that the <code>AnimalCatDog</code> union type is implicitly equivalent to\nthe <code>Animal</code> type, as there are no other types that inherit from <code>Animal</code> in the database schema.\nThis allows the compiler to perform accurate type coercions in Gremlin, as well as optimize away\ntype coercions across edges of union type if the coercion is coercing to the\nunion's equivalent type.</p>\n<p>Setting <code>type_equivalence_hints = { Animal: AnimalCatDog }</code> during compilation\nwould enable the use of a <code>@fold</code> on the <code>adjacent_animal</code> vertex field of <code>Foo</code>:</p>\n<pre>{\n    Foo {\n        adjacent_animal @fold {\n            ... on Animal {\n                name @output(out_name: \"name\")\n            }\n        }\n    }\n}\n</pre>\n<h3>SchemaGraph</h3>\n<p>When building a GraphQL schema from the database metadata, we first build a <code>SchemaGraph</code> from\nthe metadata and then, from the <code>SchemaGraph</code>, build the GraphQL schema. The <code>SchemaGraph</code> is also\na representation of the underlying database schema, but it has three main advantages that make it a\nmore powerful schema introspection tool:</p>\n<ol>\n<li>It's able to store and expose a schema's index information. The interface for accessing index\ninformation is provisional though and might change in the near future.</li>\n<li>Its classes are allowed to inherit from non-abstract classes.</li>\n<li>It exposes many utility functions, such as <code>get_subclass_set</code>, that make it easier to explore\nthe schema.</li>\n</ol>\n<p>See below for a mock example of how to build and use the <code>SchemaGraph</code>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">graphql_compiler.schema_generation.orientdb.schema_graph_builder</span> <span class=\"kn\">import</span> <span class=\"p\">(</span>\n    <span class=\"n\">get_orientdb_schema_graph</span>\n<span class=\"p\">)</span>\n<span class=\"kn\">from</span> <span class=\"nn\">graphql_compiler.schema_generation.orientdb.utils</span> <span class=\"kn\">import</span> <span class=\"p\">(</span>\n    <span class=\"n\">ORIENTDB_INDEX_RECORDS_QUERY</span><span class=\"p\">,</span> <span class=\"n\">ORIENTDB_SCHEMA_RECORDS_QUERY</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Get schema metadata from hypothetical Animals database.</span>\n<span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">your_function_that_returns_an_orientdb_client</span><span class=\"p\">()</span>\n<span class=\"n\">schema_records</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">command</span><span class=\"p\">(</span><span class=\"n\">ORIENTDB_SCHEMA_RECORDS_QUERY</span><span class=\"p\">)</span>\n<span class=\"n\">schema_data</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">record</span><span class=\"o\">.</span><span class=\"n\">oRecordData</span> <span class=\"k\">for</span> <span class=\"n\">record</span> <span class=\"ow\">in</span> <span class=\"n\">schema_records</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Get index data. </span>\n<span class=\"n\">index_records</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">command</span><span class=\"p\">(</span><span class=\"n\">ORIENTDB_INDEX_RECORDS_QUERY</span><span class=\"p\">)</span>\n<span class=\"n\">index_query_data</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">record</span><span class=\"o\">.</span><span class=\"n\">oRecordData</span> <span class=\"k\">for</span> <span class=\"n\">record</span> <span class=\"ow\">in</span> <span class=\"n\">index_records</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Build SchemaGraph.</span>\n<span class=\"n\">schema_graph</span> <span class=\"o\">=</span> <span class=\"n\">get_orientdb_schema_graph</span><span class=\"p\">(</span><span class=\"n\">schema_data</span><span class=\"p\">,</span> <span class=\"n\">index_query_data</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Get all the subclasses of a class.</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">schema_graph</span><span class=\"o\">.</span><span class=\"n\">get_subclass_set</span><span class=\"p\">(</span><span class=\"s1\">'Animal'</span><span class=\"p\">))</span>\n<span class=\"c1\"># {'Animal', 'Dog'}</span>\n\n<span class=\"c1\"># Get all the outgoing edge classes of a vertex class.</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">schema_graph</span><span class=\"o\">.</span><span class=\"n\">get_vertex_schema_element_or_raise</span><span class=\"p\">(</span><span class=\"s1\">'Animal'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">out_connections</span><span class=\"p\">)</span>\n<span class=\"c1\"># {'Animal_Eats', 'Animal_FedAt', 'Animal_LivesIn'}</span>\n\n<span class=\"c1\"># Get the vertex classes allowed as the destination vertex of an edge class.</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">schema_graph</span><span class=\"o\">.</span><span class=\"n\">get_edge_schema_element_or_raise</span><span class=\"p\">(</span><span class=\"s1\">'Animal_Eats'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">out_connections</span><span class=\"p\">)</span>\n<span class=\"c1\"># {'Fruit', 'Food'}</span>\n\n<span class=\"c1\"># Get the superclass of all classes allowed as the destination vertex of an edge class.</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">schema_graph</span><span class=\"o\">.</span><span class=\"n\">get_edge_schema_element_or_raise</span><span class=\"p\">(</span><span class=\"s1\">'Animal_Eats'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">base_out_connection</span><span class=\"p\">)</span>\n<span class=\"c1\"># Food</span>\n\n<span class=\"c1\"># Get the unique indexes defined on a class.</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">schema_graph</span><span class=\"o\">.</span><span class=\"n\">get_unique_indexes_for_class</span><span class=\"p\">(</span><span class=\"s1\">'Animal'</span><span class=\"p\">))</span>\n<span class=\"c1\"># [IndexDefinition(name='uuid', 'base_classname'='Animal', fields={'uuid'}, unique=True, ordered=False, ignore_nulls=False)]</span>\n</pre>\n<p>In the future, we plan to add <code>SchemaGraph</code> generation from SQLAlchemy metadata. We also plan to\nadd a mechanism where one can query a <code>SchemaGraph</code> using GraphQL queries.</p>\n<h3>Cypher query parameters</h3>\n<p>RedisGraph <a href=\"https://github.com/RedisGraph/RedisGraph/issues/544#issuecomment-507963576\" rel=\"nofollow\">doesn't support query parameters</a>, so we perform manual parameter interpolation in the\n<code>graphql_to_redisgraph_cypher</code> function. However, for Neo4j, we can use Neo4j's client to do\nparameter interpolation on its own so that we don't reinvent the wheel.</p>\n<p>The function <code>insert_arguments_into_query</code> does so based on the query language, which isn't\nfine-grained enough here-- for Cypher backends, we only want to insert parameters if the backend\nis RedisGraph, but not if it's Neo4j.</p>\n<p>Instead, the correct approach for Neo4j Cypher is as follows, given a Neo4j Python client called <code>neo4j_client</code>:</p>\n<pre><span class=\"n\">compilation_result</span> <span class=\"o\">=</span> <span class=\"n\">compile_graphql_to_cypher</span><span class=\"p\">(</span>\n    <span class=\"n\">schema</span><span class=\"p\">,</span> <span class=\"n\">graphql_query</span><span class=\"p\">,</span> <span class=\"n\">type_equivalence_hints</span><span class=\"o\">=</span><span class=\"n\">type_equivalence_hints</span><span class=\"p\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">neo4j_client</span><span class=\"o\">.</span><span class=\"n\">driver</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">session</span><span class=\"p\">:</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">compilation_result</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n</pre>\n<h2>Amending Parsed Custom Scalar Types</h2>\n<p>Information about the description, serialization and parsing of custom scalar type\nobjects is lost when a GraphQL schema is parsed from a string. This causes issues when\nworking with custom scalar type objects. In order to avoid these issues, one can use the code\nsnippet below to amend the definitions of the custom scalar types used by the compiler.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">graphql_compiler.schema</span> <span class=\"kn\">import</span> <span class=\"n\">CUSTOM_SCALAR_TYPES</span>\n<span class=\"kn\">from</span> <span class=\"nn\">graphql_compiler.schema_generation.utils</span> <span class=\"kn\">import</span> <span class=\"n\">amend_custom_scalar_types</span>\n\n<span class=\"n\">amend_custom_scalar_types</span><span class=\"p\">(</span><span class=\"n\">your_schema</span><span class=\"p\">,</span> <span class=\"n\">CUSTOM_SCALAR_TYPES</span><span class=\"p\">)</span>\n</pre>\n<h2>FAQ</h2>\n<p><strong>Q: Do you really use GraphQL, or do you just use GraphQL-like syntax?</strong></p>\n<p>A: We really use GraphQL. Any query that the compiler will accept is entirely valid GraphQL,\nand we actually use the Python port of the GraphQL core library for parsing and type checking.\nHowever, since the database queries produced by compiling GraphQL are subject to the limitations\nof the database system they run on, our execution model is somewhat different compared to\nthe one described in the standard GraphQL specification. See the\n<a href=\"#execution-model\" rel=\"nofollow\">Execution model</a> section for more details.</p>\n<p><strong>Q: Does this project come with a GraphQL server implementation?</strong></p>\n<p>A: No -- there are many existing frameworks for running a web server. We simply built a tool\nthat takes GraphQL query strings (and their parameters) and returns a query string you can\nuse with your database. The compiler does not execute the query string against the database,\nnor does it deserialize the results. Therefore, it is agnostic to the choice of\nserver framework and database client library used.</p>\n<p><strong>Q: Do you plan to support other databases / more GraphQL features in the future?</strong></p>\n<p>A: We'd love to, and we could really use your help! Please consider contributing to this project\nby opening issues, opening pull requests, or participating in discussions.</p>\n<p><strong>Q: I think I found a bug, what do I do?</strong></p>\n<p>A: Please check if an issue has already been created for the bug, and open a new one if not.\nMake sure to describe the bug in as much detail as possible, including any stack traces or\nerror messages you may have seen, which database you're using, and what query you compiled.</p>\n<p><strong>Q: I think I found a security vulnerability, what do I do?</strong></p>\n<p>A: Please reach out to us at\n<a href=\"mailto:graphql-compiler-maintainer@kensho.com\">graphql-compiler-maintainer@kensho.com</a>\nso we can triage the issue and take appropriate action.</p>\n<h2>License</h2>\n<p>Licensed under the Apache 2.0 License. Unless required by applicable law or agreed to in writing,\nsoftware distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\nCONDITIONS OF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.</p>\n<p>Copyright 2017-present Kensho Technologies, LLC. The present date is determined by the timestamp\nof the most recent commit in the repository.</p>\n\n          </div>"}, "last_serial": 7174219, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "2b4872683b1dc788ae309b4a08664578", "sha256": "73b056c22d5c3328c006eeb55671e257ffc5614e59727f6e93fb3302b58d9c7f"}, "downloads": -1, "filename": "graphql_compiler-1.0.0-py2-none-any.whl", "has_sig": false, "md5_digest": "2b4872683b1dc788ae309b4a08664578", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": ">=2.7, <3", "size": 93887, "upload_time": "2017-07-19T01:12:37", "upload_time_iso_8601": "2017-07-19T01:12:37.005545Z", "url": "https://files.pythonhosted.org/packages/eb/06/01d29e8c4254c9d4781ccc7eb56d0121fa06b7d58ced183bfb65f2f91a01/graphql_compiler-1.0.0-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e8b03afe0e0343130b94aa422688ebe3", "sha256": "dbd27ae1c4ea5743d930f399566d184c1a27013716b521ad9f1a0c1cfcb8a3a0"}, "downloads": -1, "filename": "graphql-compiler-1.0.0.tar.gz", "has_sig": false, "md5_digest": "e8b03afe0e0343130b94aa422688ebe3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7, <3", "size": 73134, "upload_time": "2017-07-19T01:12:38", "upload_time_iso_8601": "2017-07-19T01:12:38.585619Z", "url": "https://files.pythonhosted.org/packages/cb/39/1aac6729601be38826ff03e774186e73c0221a12f162a52ccbbb9fc339c3/graphql-compiler-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "1d9abfc6cc3de04524f4d4400862123b", "sha256": "b9e06edf505e06b5759ff2a994406ad04f05ec5a3ae2398b2b507e8c249c992b"}, "downloads": -1, "filename": "graphql_compiler-1.0.1-py2-none-any.whl", "has_sig": false, "md5_digest": "1d9abfc6cc3de04524f4d4400862123b", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": ">=2.7, <3", "size": 96454, "upload_time": "2017-07-25T17:20:46", "upload_time_iso_8601": "2017-07-25T17:20:46.086673Z", "url": "https://files.pythonhosted.org/packages/01/a0/eab7e7589f86fc48c4bfa9f7f1a66bdc2a075abd5d407dc01a7fada45770/graphql_compiler-1.0.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "385948b40e7949e8966c4bb17c93671d", "sha256": "cdefe074b7ec884319bb7e1419af25736b1c2e253c293031ac755b325ec567a4"}, "downloads": -1, "filename": "graphql-compiler-1.0.1.tar.gz", "has_sig": false, "md5_digest": "385948b40e7949e8966c4bb17c93671d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7, <3", "size": 74738, "upload_time": "2017-07-25T17:20:47", "upload_time_iso_8601": "2017-07-25T17:20:47.895912Z", "url": "https://files.pythonhosted.org/packages/63/07/b305b95e68f446175e6540a790a6db1a3f900ce0edb41c93f50d00c413b2/graphql-compiler-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "588cdeaf27626bcb0090b75e785c7247", "sha256": "acaec248c4ed99f010a88f76318711deca1b2df69cb0dbdfa7cf74b703d2c710"}, "downloads": -1, "filename": "graphql_compiler-1.0.2-py2-none-any.whl", "has_sig": false, "md5_digest": "588cdeaf27626bcb0090b75e785c7247", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": ">=2.7, <3", "size": 96817, "upload_time": "2017-08-11T20:13:19", "upload_time_iso_8601": "2017-08-11T20:13:19.460116Z", "url": "https://files.pythonhosted.org/packages/5d/c7/518c965db33e5a69f9376bb1c2b7b1b73b1c16352cb820c6c57035b50937/graphql_compiler-1.0.2-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8e0e3c24740425829ab472c390110c8a", "sha256": "0ecf0993eaf657ac440b5a31b8fb62190c040389ed608387f56d18ee39af116d"}, "downloads": -1, "filename": "graphql-compiler-1.0.2.tar.gz", "has_sig": false, "md5_digest": "8e0e3c24740425829ab472c390110c8a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7, <3", "size": 75013, "upload_time": "2017-08-11T20:13:21", "upload_time_iso_8601": "2017-08-11T20:13:21.191917Z", "url": "https://files.pythonhosted.org/packages/a2/14/032d6bbc4d066a8f4f4d594e95bfed4e47d1e9e8e91d66f98649c54299b9/graphql-compiler-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "ecd3aafa04636f9b7171cb2aeaf74ba1", "sha256": "3040357379ccdc5a2810762cabcf22aabe61b0d10dabc085825138829999f12d"}, "downloads": -1, "filename": "graphql_compiler-1.0.3-py2-none-any.whl", "has_sig": false, "md5_digest": "ecd3aafa04636f9b7171cb2aeaf74ba1", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": ">=2.7, <3", "size": 96966, "upload_time": "2017-08-15T22:27:19", "upload_time_iso_8601": "2017-08-15T22:27:19.818474Z", "url": "https://files.pythonhosted.org/packages/9d/bf/acb2a88723ea2e7e0d0a04bb65ccf2532b056a54664ccfcb124f9b6deabd/graphql_compiler-1.0.3-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d71aaa728ec727e0d558af2d649dfaae", "sha256": "7955cdbb9663d9436df3b3fe2978467ee863295efb618f8c7abc532e57ec3cc2"}, "downloads": -1, "filename": "graphql-compiler-1.0.3.tar.gz", "has_sig": false, "md5_digest": "d71aaa728ec727e0d558af2d649dfaae", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7, <3", "size": 75140, "upload_time": "2017-08-15T22:27:21", "upload_time_iso_8601": "2017-08-15T22:27:21.599806Z", "url": "https://files.pythonhosted.org/packages/eb/67/4190a6bc1c6b13ca7dbafc1b44815bdce896dcd664692c40e9d3dc3aafbb/graphql-compiler-1.0.3.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "e766b7421e3b94e9d16c0660042f7520", "sha256": "7899376d6247ea2ea3ad0e215d2c8457e57948326d74dd55f8f7ef85458d5178"}, "downloads": -1, "filename": "graphql_compiler-1.1.0-py2-none-any.whl", "has_sig": false, "md5_digest": "e766b7421e3b94e9d16c0660042f7520", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": ">=2.7", "size": 98741, "upload_time": "2017-09-18T20:51:27", "upload_time_iso_8601": "2017-09-18T20:51:27.691649Z", "url": "https://files.pythonhosted.org/packages/19/a6/5a740a012702b7ab596d108ada1957aab8fb3e505ef98ffb603eb70211f8/graphql_compiler-1.1.0-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "75515f3141c7089ee4a336e089b89ec7", "sha256": "83a38dc33e02717758a1845728dad8690b9def47938a616ea0e708a73df38038"}, "downloads": -1, "filename": "graphql_compiler-1.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "75515f3141c7089ee4a336e089b89ec7", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7", "size": 98743, "upload_time": "2017-09-18T20:54:45", "upload_time_iso_8601": "2017-09-18T20:54:45.589530Z", "url": "https://files.pythonhosted.org/packages/14/0a/283443592840a86d91f75f2e5c2db17978acde5a2e6c592c25083f19bf59/graphql_compiler-1.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0cd29ca7b7ccdf0bca4d3a083f0a853f", "sha256": "528d766e85840422932b33913ad50b57373184ba5bb66249b44c104265b471f0"}, "downloads": -1, "filename": "graphql-compiler-1.1.0.tar.gz", "has_sig": false, "md5_digest": "0cd29ca7b7ccdf0bca4d3a083f0a853f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7", "size": 76428, "upload_time": "2017-09-18T20:51:29", "upload_time_iso_8601": "2017-09-18T20:51:29.422194Z", "url": "https://files.pythonhosted.org/packages/59/7e/0370e4c2b6c1ce81bcec63e5ceb51aaf5b5549cb9a2e141b6b41d61cbf75/graphql-compiler-1.1.0.tar.gz", "yanked": false}], "1.10.0": [{"comment_text": "", "digests": {"md5": "5c366bfa147c20d31933e443bb35f14a", "sha256": "3a82cc21caacfb1fb9c123f89fc4370c5d933cae29e351710c911f5689e0042d"}, "downloads": -1, "filename": "graphql_compiler-1.10.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "5c366bfa147c20d31933e443bb35f14a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 517041, "upload_time": "2019-01-31T20:48:31", "upload_time_iso_8601": "2019-01-31T20:48:31.751739Z", "url": "https://files.pythonhosted.org/packages/04/75/6b18a008f1432615387cc876b1b81edb819c1e85f72788598879e46b7798/graphql_compiler-1.10.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6ca3b68fcd0c8e7c06e423a2a52c2583", "sha256": "a6a02c6fd5a351c8417efee15b2fd8e1e586de835eae043eb913fe06f77e3578"}, "downloads": -1, "filename": "graphql-compiler-1.10.0.tar.gz", "has_sig": false, "md5_digest": "6ca3b68fcd0c8e7c06e423a2a52c2583", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 476085, "upload_time": "2019-01-31T20:48:33", "upload_time_iso_8601": "2019-01-31T20:48:33.707029Z", "url": "https://files.pythonhosted.org/packages/d8/53/4c0918ab5641e27f93a68acc873cd9fe9deafb82f5d5d81127cceeb0aefc/graphql-compiler-1.10.0.tar.gz", "yanked": false}], "1.10.1": [{"comment_text": "", "digests": {"md5": "4bb91ea97fc42c57178fa86925b91030", "sha256": "2f66a07c46e0d8994a55dc9d7774ebd4e352af2965f64851b73f5ed9478166db"}, "downloads": -1, "filename": "graphql_compiler-1.10.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "4bb91ea97fc42c57178fa86925b91030", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 542491, "upload_time": "2019-05-04T23:49:05", "upload_time_iso_8601": "2019-05-04T23:49:05.535643Z", "url": "https://files.pythonhosted.org/packages/d3/ae/db26ec248b1bb4a95f3d7679bebcacd8f700054a4a81060ee0e3749c2f49/graphql_compiler-1.10.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "74c8b71a9184c3c697a73e82f58710bb", "sha256": "806d8820f3a537ed2756b9c33f5ce50fbaf7ddabb281adeddac6a538887d2f33"}, "downloads": -1, "filename": "graphql-compiler-1.10.1.tar.gz", "has_sig": false, "md5_digest": "74c8b71a9184c3c697a73e82f58710bb", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 503757, "upload_time": "2019-05-04T23:49:08", "upload_time_iso_8601": "2019-05-04T23:49:08.008122Z", "url": "https://files.pythonhosted.org/packages/27/6f/410058fa4f3dd5d9d63d927d08185f0d81cfb04144f79fd7301420eb23a5/graphql-compiler-1.10.1.tar.gz", "yanked": false}], "1.11.0": [{"comment_text": "", "digests": {"md5": "d001f7f5d1f46b42d6440a338b7dd2d9", "sha256": "f341b95c43e07b8dcff741ca7f0b9ae390bf995839b9f976d197ffa10a802e00"}, "downloads": -1, "filename": "graphql_compiler-1.11.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d001f7f5d1f46b42d6440a338b7dd2d9", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 604590, "upload_time": "2019-07-22T23:41:13", "upload_time_iso_8601": "2019-07-22T23:41:13.742378Z", "url": "https://files.pythonhosted.org/packages/6b/2f/7ec11bd6d9f67f24a2a994f8cac29cc7c30fe15c7b60654826a95811ae58/graphql_compiler-1.11.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d2490d55bf0292676f40e411467912a1", "sha256": "8a8da4da1e5dd8d5f855ebf6bb575522477666e75f0d83afefa7f0db6915567a"}, "downloads": -1, "filename": "graphql-compiler-1.11.0.tar.gz", "has_sig": false, "md5_digest": "d2490d55bf0292676f40e411467912a1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 553450, "upload_time": "2019-07-22T23:41:16", "upload_time_iso_8601": "2019-07-22T23:41:16.607977Z", "url": "https://files.pythonhosted.org/packages/a1/0b/35d89eee17c0ec72239e38289088964709af4abfc0c76e0c302b3f9bf559/graphql-compiler-1.11.0.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "b3d356d70455738dba4f933719ff6d72", "sha256": "7a728a7480cd64b571a6310a184da91b4eca44b2e13104b3af444b35c88f281d"}, "downloads": -1, "filename": "graphql_compiler-1.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "b3d356d70455738dba4f933719ff6d72", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 106898, "upload_time": "2017-10-05T20:54:08", "upload_time_iso_8601": "2017-10-05T20:54:08.734228Z", "url": "https://files.pythonhosted.org/packages/80/64/bee3d61d207bc5877ce62e3657c9dac0cbf434279ddb6e92b4d42384436b/graphql_compiler-1.2.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2b4ebae89c7c064b2ee879e3a4b0d886", "sha256": "a97b03ee4221d74f956c07e7b9fa1978d0b9fcd2c5b890bc69939f8049036e38"}, "downloads": -1, "filename": "graphql-compiler-1.2.0.tar.gz", "has_sig": false, "md5_digest": "2b4ebae89c7c064b2ee879e3a4b0d886", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 92785, "upload_time": "2017-10-05T20:54:11", "upload_time_iso_8601": "2017-10-05T20:54:11.073013Z", "url": "https://files.pythonhosted.org/packages/b9/1e/65e953d7251b3a98425ad29e5630b9872abff4039f7e9d02e77d97095992/graphql-compiler-1.2.0.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "ca04e36e6cd321d1e76903954acbc6bf", "sha256": "8730c6d29568f5a67a38fa2ea6f5bf256378fe7b32168f6910206050c592e1ab"}, "downloads": -1, "filename": "graphql_compiler-1.2.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "ca04e36e6cd321d1e76903954acbc6bf", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 106972, "upload_time": "2017-10-12T20:00:26", "upload_time_iso_8601": "2017-10-12T20:00:26.528827Z", "url": "https://files.pythonhosted.org/packages/06/f7/d4d3c9db5c1264b6b2ff46a1e7bfad3f341dcf37997d12992917f3c82d92/graphql_compiler-1.2.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a20ca679643d914d8ff2f49153568617", "sha256": "0cb2649c7b0f948f376758e6daad0201aabf57b3ecf1ae3af2eac3bcd8e90501"}, "downloads": -1, "filename": "graphql-compiler-1.2.1.tar.gz", "has_sig": false, "md5_digest": "a20ca679643d914d8ff2f49153568617", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 92822, "upload_time": "2017-10-12T20:00:30", "upload_time_iso_8601": "2017-10-12T20:00:30.863036Z", "url": "https://files.pythonhosted.org/packages/3d/ad/58773d385e07cc5b194bd1026b543ae60c7e5ee1cff7535bacd0ebd7d693/graphql-compiler-1.2.1.tar.gz", "yanked": false}], "1.3.0": [{"comment_text": "", "digests": {"md5": "3468abd82fa413300af58b3503f34f8c", "sha256": "59e74406b67067aca69d8cbc9bed6982062010c265524f37c01d789a1910a318"}, "downloads": -1, "filename": "graphql_compiler-1.3.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "3468abd82fa413300af58b3503f34f8c", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 109967, "upload_time": "2017-10-25T18:33:36", "upload_time_iso_8601": "2017-10-25T18:33:36.546096Z", "url": "https://files.pythonhosted.org/packages/d5/72/0eabd815c71494a56c557008b739e92785e27db4dbd3e074a26f30d7828d/graphql_compiler-1.3.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2543d6b8569c39d8f4cbc1a251fc2709", "sha256": "45f8055aa00c9638a8facb2854bbb52f9b84718fa46d64ce5d5e2fc774d2a17f"}, "downloads": -1, "filename": "graphql-compiler-1.3.0.tar.gz", "has_sig": false, "md5_digest": "2543d6b8569c39d8f4cbc1a251fc2709", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 97472, "upload_time": "2017-10-25T18:33:38", "upload_time_iso_8601": "2017-10-25T18:33:38.452336Z", "url": "https://files.pythonhosted.org/packages/64/8a/a2fee75156aae75eb01ed1b9fd0ba55a23382c1151daddc2a57a4c1405ed/graphql-compiler-1.3.0.tar.gz", "yanked": false}], "1.3.1": [{"comment_text": "", "digests": {"md5": "166feff7d0119b06a15f4d32b18c308f", "sha256": "76dd402a5ba2d916884de420daccbe3b8b4a513e6f94f861ac791db8e60458ea"}, "downloads": -1, "filename": "graphql_compiler-1.3.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "166feff7d0119b06a15f4d32b18c308f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 111257, "upload_time": "2018-03-01T18:45:22", "upload_time_iso_8601": "2018-03-01T18:45:22.894906Z", "url": "https://files.pythonhosted.org/packages/3a/90/09d469b4b65acca12839eaae5e53401646a21493ad952d7a4278554f76c3/graphql_compiler-1.3.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dcf4ed84148d77c96cce0a24b118dc74", "sha256": "226616812874cae23327c0f813426f31e5958fc271977adc305d745219bd761e"}, "downloads": -1, "filename": "graphql-compiler-1.3.1.tar.gz", "has_sig": false, "md5_digest": "dcf4ed84148d77c96cce0a24b118dc74", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 98575, "upload_time": "2018-03-01T18:45:25", "upload_time_iso_8601": "2018-03-01T18:45:25.665976Z", "url": "https://files.pythonhosted.org/packages/27/af/0e2530eb825c56a5b1aacdced53da65de1f9c372e6b4f4560dc0dad2a50b/graphql-compiler-1.3.1.tar.gz", "yanked": false}], "1.4.0": [{"comment_text": "", "digests": {"md5": "83f843a3452993c60ea2ae657306dd02", "sha256": "1d4f6ebdfcf2833e355f7a8e454e403b4652193e5f903c548e0eb910f537461c"}, "downloads": -1, "filename": "graphql_compiler-1.4.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "83f843a3452993c60ea2ae657306dd02", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 111983, "upload_time": "2018-04-10T17:57:59", "upload_time_iso_8601": "2018-04-10T17:57:59.468312Z", "url": "https://files.pythonhosted.org/packages/4d/fd/a39105548c2c2da843125bb9577c337903b59752aeecf8c90ec3e51d7b02/graphql_compiler-1.4.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f76f8514d093e97206b00d3e9023e08e", "sha256": "d6067e7049529138566980daac984dc4ea5a37c33cce763912ff74a757c8e3da"}, "downloads": -1, "filename": "graphql-compiler-1.4.0.tar.gz", "has_sig": false, "md5_digest": "f76f8514d093e97206b00d3e9023e08e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 100661, "upload_time": "2018-04-10T17:58:00", "upload_time_iso_8601": "2018-04-10T17:58:00.921149Z", "url": "https://files.pythonhosted.org/packages/e9/26/888a2dfc6068789a6f8f672bfa391ed99cce2323041201a2fd07b6789f73/graphql-compiler-1.4.0.tar.gz", "yanked": false}], "1.4.1": [{"comment_text": "", "digests": {"md5": "35e0d8726759200b6865efbb5d6cd60d", "sha256": "7335cca9ad0220e64ce537c8349e666261d37eab414bd3d0c3ca78cad1145b04"}, "downloads": -1, "filename": "graphql_compiler-1.4.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "35e0d8726759200b6865efbb5d6cd60d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 114454, "upload_time": "2018-04-25T20:42:21", "upload_time_iso_8601": "2018-04-25T20:42:21.494562Z", "url": "https://files.pythonhosted.org/packages/e0/b1/9f7322098ff80083b12fd85c7a37dfaf8e221cec6784abfd992cb03318b4/graphql_compiler-1.4.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a0fc2fcad4fc7cee7a8a070c3069677e", "sha256": "79f1e747493d1bdb58ac20bfbd1f3b37b1c397b3de9144a4b353c27ec09e7ad8"}, "downloads": -1, "filename": "graphql-compiler-1.4.1.tar.gz", "has_sig": false, "md5_digest": "a0fc2fcad4fc7cee7a8a070c3069677e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 102829, "upload_time": "2018-04-25T20:42:22", "upload_time_iso_8601": "2018-04-25T20:42:22.640963Z", "url": "https://files.pythonhosted.org/packages/23/fe/de5decb0c0cddbcfcf7f1f923c4e4c9fac87130dbbc688f7d95e0ff785ff/graphql-compiler-1.4.1.tar.gz", "yanked": false}], "1.5.0": [{"comment_text": "", "digests": {"md5": "ff0e9f92dc5fe6cb0538548a923fb431", "sha256": "3c2a3b6241134a9c098ba7a9d59bb9c330621aba511c25d954a3a1decfb25fd3"}, "downloads": -1, "filename": "graphql_compiler-1.5.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "ff0e9f92dc5fe6cb0538548a923fb431", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 142198, "upload_time": "2018-05-21T20:57:07", "upload_time_iso_8601": "2018-05-21T20:57:07.962215Z", "url": "https://files.pythonhosted.org/packages/16/c8/6792fafa6e45ae7e4b5e8db3edf68832ae9e7d1ae7bad23cef5470897936/graphql_compiler-1.5.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e5a1bf4d26dc03b5b42efd27d15e0ae7", "sha256": "de28c4768847935f1479aadf68d3e00d17d9db9e14a11db6fcdb9dade34b8a7d"}, "downloads": -1, "filename": "graphql-compiler-1.5.0.tar.gz", "has_sig": false, "md5_digest": "e5a1bf4d26dc03b5b42efd27d15e0ae7", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 117338, "upload_time": "2018-05-21T20:57:09", "upload_time_iso_8601": "2018-05-21T20:57:09.434608Z", "url": "https://files.pythonhosted.org/packages/a2/7f/1a4905779b152c36acefdcb98a0c11467f16e41332af33b067bb287682ad/graphql-compiler-1.5.0.tar.gz", "yanked": false}], "1.6.0": [{"comment_text": "", "digests": {"md5": "e3702111414a77a0e029a00aa576fbf9", "sha256": "44aa931c168d792b02b3ac5e0a30e2e1e3bfd445b813fbc37131cd0f9c5ddb8a"}, "downloads": -1, "filename": "graphql_compiler-1.6.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "e3702111414a77a0e029a00aa576fbf9", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 132414, "upload_time": "2018-05-25T20:17:22", "upload_time_iso_8601": "2018-05-25T20:17:22.428583Z", "url": "https://files.pythonhosted.org/packages/e2/5b/d8f1998a552b4a2f43f2692b3b63118954fde24e59fc17e00d2dc13d5e4e/graphql_compiler-1.6.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c9fdcb78e45ffd162da503e4d01fdd55", "sha256": "59a08e0d2987e4ac470303585f506983d61667c46c30926a6192ecf413d90795"}, "downloads": -1, "filename": "graphql-compiler-1.6.0.tar.gz", "has_sig": false, "md5_digest": "c9fdcb78e45ffd162da503e4d01fdd55", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 118356, "upload_time": "2018-05-25T20:17:23", "upload_time_iso_8601": "2018-05-25T20:17:23.745764Z", "url": "https://files.pythonhosted.org/packages/5f/33/cd9e638f33890fc7c36ab82a4ea10f32bea61c7aa6ca175f4fc5cac73ff2/graphql-compiler-1.6.0.tar.gz", "yanked": false}], "1.6.1": [{"comment_text": "", "digests": {"md5": "8e9a7a055e06db495e98c208273fa2a5", "sha256": "7574896053e97556bb22e43791da699301978b4bd450da8137cc3ec07389156c"}, "downloads": -1, "filename": "graphql_compiler-1.6.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "8e9a7a055e06db495e98c208273fa2a5", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 134697, "upload_time": "2018-05-31T20:24:12", "upload_time_iso_8601": "2018-05-31T20:24:12.093591Z", "url": "https://files.pythonhosted.org/packages/eb/4c/8a895a5c160161d95b8dbf3e14abe0402524252fbd03fabfca6c141e6cc7/graphql_compiler-1.6.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "684379e8587d5aadf924922c3ea71b69", "sha256": "dc0e9c66d0c46912f723802cedfca0d6794549e5683a4edff0b7c9a9ee64b9cb"}, "downloads": -1, "filename": "graphql-compiler-1.6.1.tar.gz", "has_sig": false, "md5_digest": "684379e8587d5aadf924922c3ea71b69", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 120670, "upload_time": "2018-05-31T20:24:13", "upload_time_iso_8601": "2018-05-31T20:24:13.460205Z", "url": "https://files.pythonhosted.org/packages/8f/92/3de3074531ffc053cdeb7c55a092db00a4891298ac0b0ea19dfa171acc13/graphql-compiler-1.6.1.tar.gz", "yanked": false}], "1.6.2": [{"comment_text": "", "digests": {"md5": "58c37eda06e632ffa0be0c7a3281b0ae", "sha256": "00bf3034bcfd897ebfac3866635bf51b6e27e6d8e067d9629f6baae68c119b07"}, "downloads": -1, "filename": "graphql_compiler-1.6.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "58c37eda06e632ffa0be0c7a3281b0ae", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 138873, "upload_time": "2018-07-05T19:02:30", "upload_time_iso_8601": "2018-07-05T19:02:30.042862Z", "url": "https://files.pythonhosted.org/packages/77/63/6a9fb78777f8a9602d61667bfd90ca2709da1ff73e9b97a9b20f0e5f4115/graphql_compiler-1.6.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "65b07ddfa7512f95cf023dc2137bf5e3", "sha256": "b2d6571ed16d540b9d1093b5b39b790d39ccb67fc6b9684f9e0b073a73bdf6b9"}, "downloads": -1, "filename": "graphql-compiler-1.6.2.tar.gz", "has_sig": false, "md5_digest": "65b07ddfa7512f95cf023dc2137bf5e3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 124608, "upload_time": "2018-07-05T19:02:31", "upload_time_iso_8601": "2018-07-05T19:02:31.100988Z", "url": "https://files.pythonhosted.org/packages/13/df/45044479f436e9959dd473e96e366284fb1b2794850aa7220f8f0744b29c/graphql-compiler-1.6.2.tar.gz", "yanked": false}], "1.7.0": [{"comment_text": "", "digests": {"md5": "808bf2dc700de19adb0a4bd26d413cc6", "sha256": "25adfbb58ad9b78cfc2c1113e4671b1b517e0c0277da901c9efa37d90376b1ff"}, "downloads": -1, "filename": "graphql_compiler-1.7.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "808bf2dc700de19adb0a4bd26d413cc6", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 145299, "upload_time": "2018-07-17T18:30:07", "upload_time_iso_8601": "2018-07-17T18:30:07.702744Z", "url": "https://files.pythonhosted.org/packages/41/89/64578e4943a0b50fa8b3582f6969881e970d2915766b50fbd006c29eb9fb/graphql_compiler-1.7.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "db27ea85bfca5deef377227269310219", "sha256": "be78a86c03360a9aec762c6f924a0e05b7b94ec22174546f530f65d7debb8156"}, "downloads": -1, "filename": "graphql-compiler-1.7.0.tar.gz", "has_sig": false, "md5_digest": "db27ea85bfca5deef377227269310219", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 130359, "upload_time": "2018-07-17T18:30:09", "upload_time_iso_8601": "2018-07-17T18:30:09.084754Z", "url": "https://files.pythonhosted.org/packages/d4/65/f4024a24c9fdee7b11542109cdb2d06c1643b82c25cf13cf5660002bd83c/graphql-compiler-1.7.0.tar.gz", "yanked": false}], "1.7.2": [{"comment_text": "", "digests": {"md5": "fb1e8e2692e9d329ad94122b6b981840", "sha256": "8cb3c58774ff98343feb820b678fef93207002b55382b6cd102a9a3ce960f0a8"}, "downloads": -1, "filename": "graphql_compiler-1.7.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "fb1e8e2692e9d329ad94122b6b981840", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 465245, "upload_time": "2018-07-30T21:55:58", "upload_time_iso_8601": "2018-07-30T21:55:58.020279Z", "url": "https://files.pythonhosted.org/packages/61/1b/3734082f5deb303e43e30a8de8f12b2f78627523ca630ab91d2e7d84ac05/graphql_compiler-1.7.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8cbd5569eb49582069c9d0c5e7627dd6", "sha256": "0b1dac05ea1a1ce2c608119b954fde173a374b3028db8947114fa801835295a3"}, "downloads": -1, "filename": "graphql-compiler-1.7.2.tar.gz", "has_sig": false, "md5_digest": "8cbd5569eb49582069c9d0c5e7627dd6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 416795, "upload_time": "2018-07-30T21:55:59", "upload_time_iso_8601": "2018-07-30T21:55:59.921551Z", "url": "https://files.pythonhosted.org/packages/96/c6/551dc5fa7615695ebae774c0c08d13f88ac2fdbc762a902a7661f51c35ca/graphql-compiler-1.7.2.tar.gz", "yanked": false}], "1.8.0": [{"comment_text": "", "digests": {"md5": "5f27652ffe6bab0f8d1c1eff8258273f", "sha256": "b4b35017bde83256b7f78545d37651c60e29476ffffb21d605c152674461c42b"}, "downloads": -1, "filename": "graphql_compiler-1.8.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "5f27652ffe6bab0f8d1c1eff8258273f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 467772, "upload_time": "2018-09-04T18:53:25", "upload_time_iso_8601": "2018-09-04T18:53:25.686644Z", "url": "https://files.pythonhosted.org/packages/f7/5a/1171ae8b25385ed02bac52c8b311700704877a059039037701d8499afec9/graphql_compiler-1.8.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e5c9af6151b30cbef948bc379ff9a972", "sha256": "103fb6f0567f8cc311521eb8c137fbbf3620b5631e8b360c3f4b55f90da937d6"}, "downloads": -1, "filename": "graphql-compiler-1.8.0.tar.gz", "has_sig": false, "md5_digest": "e5c9af6151b30cbef948bc379ff9a972", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 418758, "upload_time": "2018-09-04T18:53:27", "upload_time_iso_8601": "2018-09-04T18:53:27.969961Z", "url": "https://files.pythonhosted.org/packages/bd/20/de83b32c12ab29ba5deec8c48a8b3d9f17da39be6f67422ca13d6a9335c2/graphql-compiler-1.8.0.tar.gz", "yanked": false}], "1.8.1": [{"comment_text": "", "digests": {"md5": "79c9a49e835dfc531d75481af2e17903", "sha256": "89556e9e183155e709875f087c9884bac07117ba4302fac816fae6210babeb4b"}, "downloads": -1, "filename": "graphql_compiler-1.8.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "79c9a49e835dfc531d75481af2e17903", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 468655, "upload_time": "2018-09-12T20:24:30", "upload_time_iso_8601": "2018-09-12T20:24:30.428213Z", "url": "https://files.pythonhosted.org/packages/16/1b/62d2e9bfab55363bbd55a8418dd2e068fb794f9d327fe63c5b88a74d7b32/graphql_compiler-1.8.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4a6cc164f1d46b02680c3f0e446a5511", "sha256": "d361f5e74f47242047d4d5bba506fbc0b03b782fea97501535ba396d02ca4d89"}, "downloads": -1, "filename": "graphql-compiler-1.8.1.tar.gz", "has_sig": false, "md5_digest": "4a6cc164f1d46b02680c3f0e446a5511", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 419614, "upload_time": "2018-09-12T20:24:32", "upload_time_iso_8601": "2018-09-12T20:24:32.363385Z", "url": "https://files.pythonhosted.org/packages/95/49/08e9d1dc59688ff940e66e39b414da828726cf72eb8b16dcb86a680b1ba7/graphql-compiler-1.8.1.tar.gz", "yanked": false}], "1.8.2": [{"comment_text": "", "digests": {"md5": "86d6d0e2746d76d055aad0830ede4c6c", "sha256": "8e494abaef4082b4029d8664193c7df01dbc444007dec65cb582e6176cd6514c"}, "downloads": -1, "filename": "graphql_compiler-1.8.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "86d6d0e2746d76d055aad0830ede4c6c", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 469561, "upload_time": "2018-09-18T20:14:38", "upload_time_iso_8601": "2018-09-18T20:14:38.198619Z", "url": "https://files.pythonhosted.org/packages/e9/23/1db2fa0e9c211c78e022d0ef27be2e39fb37717d87a7945d87d9c4fdc4d4/graphql_compiler-1.8.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6d44912a3da0788bb11c03c1b96748ee", "sha256": "000465bde1528befd7dd43303fc72ca82da16fb0ffa2a6632032cb9a02537b43"}, "downloads": -1, "filename": "graphql-compiler-1.8.2.tar.gz", "has_sig": false, "md5_digest": "6d44912a3da0788bb11c03c1b96748ee", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 420538, "upload_time": "2018-09-18T20:14:40", "upload_time_iso_8601": "2018-09-18T20:14:40.548455Z", "url": "https://files.pythonhosted.org/packages/69/a7/9a089fa305f8875687bcf29ddcc2505f09804afcbc13d33d38fe5c564e75/graphql-compiler-1.8.2.tar.gz", "yanked": false}], "1.8.3": [{"comment_text": "", "digests": {"md5": "75c6e045f9d014398d3bbd7fc96e4ac9", "sha256": "25a22366f43f87db2632bafebbd6356f02a167a9cc514b352df34067b3f19a86"}, "downloads": -1, "filename": "graphql_compiler-1.8.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "75c6e045f9d014398d3bbd7fc96e4ac9", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 493706, "upload_time": "2019-01-08T22:06:52", "upload_time_iso_8601": "2019-01-08T22:06:52.908694Z", "url": "https://files.pythonhosted.org/packages/31/9c/48b9ee58d96aa943a3ea2c79837a04ca7f515aa9c7c35dd9e8a90c66cdef/graphql_compiler-1.8.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "713572cf5679169b3bd07b522d42d17e", "sha256": "aa7458d9c8ba5e7219d09388e4ba05af70bf9804cd2ea4930c23dcf0db76070b"}, "downloads": -1, "filename": "graphql-compiler-1.8.3.tar.gz", "has_sig": false, "md5_digest": "713572cf5679169b3bd07b522d42d17e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 452907, "upload_time": "2019-01-08T22:06:54", "upload_time_iso_8601": "2019-01-08T22:06:54.673711Z", "url": "https://files.pythonhosted.org/packages/51/5d/9d80273705176e1d5ea5b0b052efe7de2970ecc556be315a59e18233c77c/graphql-compiler-1.8.3.tar.gz", "yanked": false}], "1.9.0": [{"comment_text": "", "digests": {"md5": "db24d2a82a025d02b191844ea990a33b", "sha256": "0e75c0524748ad1b5456ec9686e111f5c2a809eeb638839a8fc4ad58b729c6bf"}, "downloads": -1, "filename": "graphql_compiler-1.9.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "db24d2a82a025d02b191844ea990a33b", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 505763, "upload_time": "2019-01-23T15:38:21", "upload_time_iso_8601": "2019-01-23T15:38:21.533827Z", "url": "https://files.pythonhosted.org/packages/80/ff/a85d47b751ff4fcf03ef7a51fe0f6faea038f791f5806ade6f01bcc5300a/graphql_compiler-1.9.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "36d79b18a2d03690e944f0881cffdfd6", "sha256": "0cd991ed0c582c9426f91812489f2e5072ab109ec5e98283f7b147a40d8f7ee6"}, "downloads": -1, "filename": "graphql-compiler-1.9.0.tar.gz", "has_sig": false, "md5_digest": "36d79b18a2d03690e944f0881cffdfd6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 466769, "upload_time": "2019-01-23T15:38:23", "upload_time_iso_8601": "2019-01-23T15:38:23.733104Z", "url": "https://files.pythonhosted.org/packages/f3/ff/03179f0a0c137bf6f2f374bd49a5e04b1b01edcdf869b98446b834e7ecb3/graphql-compiler-1.9.0.tar.gz", "yanked": false}], "2.0.0.dev1": [{"comment_text": "", "digests": {"md5": "a7a3656797ceead51184de1bed5e85ab", "sha256": "657ce5c913a3cf8c929bb6a7db4df4b61a1ba467a6c709c64ede95e5b45477a7"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a7a3656797ceead51184de1bed5e85ab", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 519024, "upload_time": "2019-01-17T22:52:09", "upload_time_iso_8601": "2019-01-17T22:52:09.230789Z", "url": "https://files.pythonhosted.org/packages/f6/06/b2b38fe090e4e2f8f279c09a562f727a992ceb1f3369eaf449db00c647e4/graphql_compiler-2.0.0.dev1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "74b46322749844f81f268fe99ffabd33", "sha256": "fe96822e464c97b970fd0e48a0c2509b9c6e79cfc336d2f11d918d9b3b2075a2"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev1.tar.gz", "has_sig": false, "md5_digest": "74b46322749844f81f268fe99ffabd33", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 475553, "upload_time": "2019-01-17T22:52:11", "upload_time_iso_8601": "2019-01-17T22:52:11.278467Z", "url": "https://files.pythonhosted.org/packages/d4/0a/f36a08facbae2da980985ce6ea7250ab6d2f738454661bfa3fde7a2d0c39/graphql-compiler-2.0.0.dev1.tar.gz", "yanked": false}], "2.0.0.dev10": [{"comment_text": "", "digests": {"md5": "a1776c85cf6e657c24e8243661585d85", "sha256": "d1ff0ab3c62979bf9a768cc955b632b890932448112fdc6993ff82c1d0d0f162"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev10-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a1776c85cf6e657c24e8243661585d85", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 778825, "upload_time": "2020-02-24T21:40:54", "upload_time_iso_8601": "2020-02-24T21:40:54.151432Z", "url": "https://files.pythonhosted.org/packages/ea/b0/faca696b885bd14cbd97c7b10e95e742185d1e46d6da4467b532f22b16e2/graphql_compiler-2.0.0.dev10-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "942b8d6bb06f657b7aefd30c28494751", "sha256": "b4cb152d503b5c904a28cb6d47c4d151f364dda8f0a7d0e8e9351145e0fc7bb9"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev10.tar.gz", "has_sig": false, "md5_digest": "942b8d6bb06f657b7aefd30c28494751", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 713229, "upload_time": "2020-02-24T21:40:57", "upload_time_iso_8601": "2020-02-24T21:40:57.682787Z", "url": "https://files.pythonhosted.org/packages/6d/45/07698ef2c3141e47da6e9bf83a60ecbb4b5974bd61cc3dbfaa43443ea4fc/graphql-compiler-2.0.0.dev10.tar.gz", "yanked": false}], "2.0.0.dev11": [{"comment_text": "", "digests": {"md5": "0ef677adaac0d1c63320c22f0c3de117", "sha256": "45b25397ce471988f7474805b822e7f498d263bfe1889cbc18141745dc6b0544"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev11-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "0ef677adaac0d1c63320c22f0c3de117", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 778623, "upload_time": "2020-02-26T17:34:57", "upload_time_iso_8601": "2020-02-26T17:34:57.254039Z", "url": "https://files.pythonhosted.org/packages/77/55/bf8c2f4f9387a0e179df2b11f0b90250bdc51343a166bd11ac53103d1bbb/graphql_compiler-2.0.0.dev11-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d37ce53a4f8eb2d075a0a198a7f2f0e2", "sha256": "87d26e0c122f4b9a44af28be027918511c0d0c551c45dec1d35958171b24e6a3"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev11.tar.gz", "has_sig": false, "md5_digest": "d37ce53a4f8eb2d075a0a198a7f2f0e2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 713154, "upload_time": "2020-02-26T17:34:59", "upload_time_iso_8601": "2020-02-26T17:34:59.976182Z", "url": "https://files.pythonhosted.org/packages/7a/0b/482f340b9d0c3a0fa7a5a43c2905e50598b7fb9736c03ab42aaf08ccbc56/graphql-compiler-2.0.0.dev11.tar.gz", "yanked": false}], "2.0.0.dev12": [{"comment_text": "", "digests": {"md5": "b713a15d086d4985c42dfb4d87cae034", "sha256": "3f0e006c8449fd077876f892ea13667cb4e989b1624bf44e33fb517c48c3d574"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev12-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "b713a15d086d4985c42dfb4d87cae034", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 779272, "upload_time": "2020-03-02T18:30:03", "upload_time_iso_8601": "2020-03-02T18:30:03.963933Z", "url": "https://files.pythonhosted.org/packages/c4/d9/2b1aa016c5ba1666feb5941bd5410b9af5340508f03bbaa96757adb039e4/graphql_compiler-2.0.0.dev12-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7d015b8a9933547880c6dd07a5866772", "sha256": "9fca46fa2fb65aa54e30bc6c839dc6c741b34f37070fb5015a1c89d6f503c48a"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev12.tar.gz", "has_sig": false, "md5_digest": "7d015b8a9933547880c6dd07a5866772", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 709934, "upload_time": "2020-03-02T18:30:07", "upload_time_iso_8601": "2020-03-02T18:30:07.726115Z", "url": "https://files.pythonhosted.org/packages/88/ef/97bb7c6974548e650dd102d4dedf75f19779bf6512388b8be28ab0283adc/graphql-compiler-2.0.0.dev12.tar.gz", "yanked": false}], "2.0.0.dev13": [{"comment_text": "", "digests": {"md5": "5bb8bd467c31422fc905974d488a5e7b", "sha256": "aacf196720e55f812810cfda18394e385c3edfaaf4930ced394f874f70e30107"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev13-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "5bb8bd467c31422fc905974d488a5e7b", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 781120, "upload_time": "2020-03-11T04:54:31", "upload_time_iso_8601": "2020-03-11T04:54:31.016529Z", "url": "https://files.pythonhosted.org/packages/bd/16/32a440dbca181a30d21ceab77918f4680744ab5d3709ca726f53dd4cc31a/graphql_compiler-2.0.0.dev13-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e3ac15e0cba41384570862cb4ed05ac5", "sha256": "abe78abfecc94833a5386f4999384e1ac85995889d33791ca5ea1f6ccea70779"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev13.tar.gz", "has_sig": false, "md5_digest": "e3ac15e0cba41384570862cb4ed05ac5", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 715881, "upload_time": "2020-03-11T04:54:33", "upload_time_iso_8601": "2020-03-11T04:54:33.877846Z", "url": "https://files.pythonhosted.org/packages/bd/68/a6d57b881d2aabdf47b13b9affcb6db6e90a61f920c2e7b42029542038ef/graphql-compiler-2.0.0.dev13.tar.gz", "yanked": false}], "2.0.0.dev14": [{"comment_text": "", "digests": {"md5": "a4180466562637d4cf25e31d93e77c3d", "sha256": "25335b9bb68cdd68b3072efe3e413c353f0ca7096eed71d267cd15fac5716ee5"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev14-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a4180466562637d4cf25e31d93e77c3d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 781591, "upload_time": "2020-03-17T18:28:19", "upload_time_iso_8601": "2020-03-17T18:28:19.793331Z", "url": "https://files.pythonhosted.org/packages/70/77/09e45880699121d1942e1c44c54c81485e8ca32f7e3a2e3543e4d84777ac/graphql_compiler-2.0.0.dev14-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1426b7b68d6d7207436c325896e221b5", "sha256": "cd2c25025614e748580ce3da5ae01dc3208b2a943fac7c636c318c8deb1cc1aa"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev14.tar.gz", "has_sig": false, "md5_digest": "1426b7b68d6d7207436c325896e221b5", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 716257, "upload_time": "2020-03-17T18:28:24", "upload_time_iso_8601": "2020-03-17T18:28:24.270238Z", "url": "https://files.pythonhosted.org/packages/86/7b/452034187dba57de049130b729899a9d1cf5500de2e17c1735e8a2ee20f9/graphql-compiler-2.0.0.dev14.tar.gz", "yanked": false}], "2.0.0.dev15": [{"comment_text": "", "digests": {"md5": "341375b2ea5bbdfdd92753586a295dfc", "sha256": "bb2c5b6109750db1d092dc0e06b05208c84e6b4f52149862037dba91c4da72bb"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev15-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "341375b2ea5bbdfdd92753586a295dfc", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 782394, "upload_time": "2020-03-19T20:20:57", "upload_time_iso_8601": "2020-03-19T20:20:57.058715Z", "url": "https://files.pythonhosted.org/packages/0b/ef/5b052a1dbb6f10c6ab2cedc0ee6af1082de5a31a3ccc078dfefc9e668a3a/graphql_compiler-2.0.0.dev15-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "eb24be6cb70e60a74071821d18db0c95", "sha256": "cbae7eb5cf51068fe93de278c824baf4a5829ba0c0d7fe2fefbe882d53026a33"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev15.tar.gz", "has_sig": false, "md5_digest": "eb24be6cb70e60a74071821d18db0c95", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 717534, "upload_time": "2020-03-19T20:21:00", "upload_time_iso_8601": "2020-03-19T20:21:00.020565Z", "url": "https://files.pythonhosted.org/packages/7b/0a/3df807f53cf1ffff3cf4ac2bc3a95c15b467c4293209174d146688107525/graphql-compiler-2.0.0.dev15.tar.gz", "yanked": false}], "2.0.0.dev16": [{"comment_text": "", "digests": {"md5": "2de884e6fe06cc39587ac9e4c2164dc5", "sha256": "a9e737fa9c473cca8138a787389e86e61de2058401f06167d2873c1612f837eb"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev16-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "2de884e6fe06cc39587ac9e4c2164dc5", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 785547, "upload_time": "2020-04-09T15:07:26", "upload_time_iso_8601": "2020-04-09T15:07:26.749290Z", "url": "https://files.pythonhosted.org/packages/70/d3/9eba1e383f776b35963b2d1c2f5034ac848eb14b43378cdfda90ba0ad8c0/graphql_compiler-2.0.0.dev16-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ca9d21244ad456789128939bc3624fc6", "sha256": "600c8452a17d1c90650fe23406ac2d33fae36ef7abdda8234d572031b2678522"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev16.tar.gz", "has_sig": false, "md5_digest": "ca9d21244ad456789128939bc3624fc6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 720326, "upload_time": "2020-04-09T15:07:29", "upload_time_iso_8601": "2020-04-09T15:07:29.619472Z", "url": "https://files.pythonhosted.org/packages/67/6f/0c754cf4adaf804d4ba4bff05180b73b8dbd6afdd94e12326a0cb128fad0/graphql-compiler-2.0.0.dev16.tar.gz", "yanked": false}], "2.0.0.dev17": [{"comment_text": "", "digests": {"md5": "0f810729588c679481506005fd394177", "sha256": "cf2f6c1e72f76115904d1de59e226fff2e11a1089668e41315ad1daad6c91efa"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev17-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "0f810729588c679481506005fd394177", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 786708, "upload_time": "2020-04-22T18:24:21", "upload_time_iso_8601": "2020-04-22T18:24:21.144081Z", "url": "https://files.pythonhosted.org/packages/7d/02/4d4de91a42b31db2c11b117bc2319b509f7d16a38364c767e9c597b5f5d6/graphql_compiler-2.0.0.dev17-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c61fe84efaf1409daec5f6db74fe7f1c", "sha256": "0d444a87046859136e7c56be88855e1686256d263a5524551c3e8eccad1fa7d0"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev17.tar.gz", "has_sig": false, "md5_digest": "c61fe84efaf1409daec5f6db74fe7f1c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 717452, "upload_time": "2020-04-22T18:24:24", "upload_time_iso_8601": "2020-04-22T18:24:24.193386Z", "url": "https://files.pythonhosted.org/packages/20/fc/965c0fcc25767f61e0f2b75d49927215e39dee0d3a272de250a035ae741c/graphql-compiler-2.0.0.dev17.tar.gz", "yanked": false}], "2.0.0.dev18": [{"comment_text": "", "digests": {"md5": "8114341150e7fb50a9e3a07e56962adb", "sha256": "d93b7e5ac15681aa4cea34979d971e0022b24918a17394bd1cfd184f39b9a890"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev18-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "8114341150e7fb50a9e3a07e56962adb", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 787967, "upload_time": "2020-04-28T19:55:11", "upload_time_iso_8601": "2020-04-28T19:55:11.925125Z", "url": "https://files.pythonhosted.org/packages/4e/b0/bf31c7d4dbb1a7916de8beb8239ebd634d306a85bda0f9b56cd8a75af243/graphql_compiler-2.0.0.dev18-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "386d4b9697226b216cf4540cd32d3633", "sha256": "0c92531e60d86ba710067df2cdcaf9367bb3c3f9f405be010384bbd998333035"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev18.tar.gz", "has_sig": false, "md5_digest": "386d4b9697226b216cf4540cd32d3633", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 723264, "upload_time": "2020-04-28T19:55:14", "upload_time_iso_8601": "2020-04-28T19:55:14.390105Z", "url": "https://files.pythonhosted.org/packages/cc/4e/f5ca344fa5209aebb786131621d6f5a6a5d32eea4253228289d7d92043f1/graphql-compiler-2.0.0.dev18.tar.gz", "yanked": false}], "2.0.0.dev19": [{"comment_text": "", "digests": {"md5": "21938464c9919a920dd0b7ec845cf152", "sha256": "5d6d492f49955c0ba4f6c1c86be34bbf0a95f39955e1d31abc44b581ab8dd6ec"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev19-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "21938464c9919a920dd0b7ec845cf152", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 790149, "upload_time": "2020-05-05T17:24:07", "upload_time_iso_8601": "2020-05-05T17:24:07.472883Z", "url": "https://files.pythonhosted.org/packages/8b/46/7c5a98740b6692ed13fae26ce263bab8166efa775048da7238125865b88d/graphql_compiler-2.0.0.dev19-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "956485ed977ac21047d0953937a7ce74", "sha256": "b3095766f742565f19b5edea331947505320bccff7753b62d4c3fb985a0c55fe"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev19.tar.gz", "has_sig": false, "md5_digest": "956485ed977ac21047d0953937a7ce74", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 725577, "upload_time": "2020-05-05T17:24:10", "upload_time_iso_8601": "2020-05-05T17:24:10.131119Z", "url": "https://files.pythonhosted.org/packages/a5/da/0c39a82025c7d1b50e3f28eb69a1bf1c3b6b13c9b46725c38b9161085f47/graphql-compiler-2.0.0.dev19.tar.gz", "yanked": false}], "2.0.0.dev2": [{"comment_text": "", "digests": {"md5": "ff147b9b73c82342aa00faf95dc38e4d", "sha256": "13663bef96064c9f8f20d5568f312ec80fe33118e3dfc3d19b86217bb0cbfdba"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "ff147b9b73c82342aa00faf95dc38e4d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 564994, "upload_time": "2019-03-26T22:09:06", "upload_time_iso_8601": "2019-03-26T22:09:06.642654Z", "url": "https://files.pythonhosted.org/packages/0d/ca/a298a5013be035d41aa77983d72c981be63bafcc60e2e75f1189d2422263/graphql_compiler-2.0.0.dev2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "19ae70a7301423d1fd70519fc3fa6527", "sha256": "c57c3c697523f9da7fc51d8c6dd901ae5a79098cf6828d113f9fcb2dd63da714"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev2.tar.gz", "has_sig": false, "md5_digest": "19ae70a7301423d1fd70519fc3fa6527", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 516195, "upload_time": "2019-03-26T22:09:08", "upload_time_iso_8601": "2019-03-26T22:09:08.639521Z", "url": "https://files.pythonhosted.org/packages/5b/7f/5056b53cae57268ae54746b8ed03920997b3ceba7b24e5342dd767e18a03/graphql-compiler-2.0.0.dev2.tar.gz", "yanked": false}], "2.0.0.dev20": [{"comment_text": "", "digests": {"md5": "255676f9ca72b50c2c981ae584404aa0", "sha256": "ab8ae43a4806fc2ba52ff67bfeff5cd9c697f0aabe15bf65b8dd49e7e4dfee7c"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev20-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "255676f9ca72b50c2c981ae584404aa0", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 791302, "upload_time": "2020-05-05T17:37:32", "upload_time_iso_8601": "2020-05-05T17:37:32.891325Z", "url": "https://files.pythonhosted.org/packages/15/f5/70ee8f3a9636a48c212efb72ffb237e10f9cfcbbf6c546ed45e1748c923d/graphql_compiler-2.0.0.dev20-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "642fec16574423974a8c7a8d53b11d09", "sha256": "fe7fb87b83d004aaa27cdec8df02a3224acd190233ba3ebe647158f2a265e154"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev20.tar.gz", "has_sig": false, "md5_digest": "642fec16574423974a8c7a8d53b11d09", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 726547, "upload_time": "2020-05-05T17:37:36", "upload_time_iso_8601": "2020-05-05T17:37:36.126793Z", "url": "https://files.pythonhosted.org/packages/14/40/ba5552cbd8bec4fc6b3e258475a620d7d9b510458dee942085f149329b13/graphql-compiler-2.0.0.dev20.tar.gz", "yanked": false}], "2.0.0.dev3": [{"comment_text": "", "digests": {"md5": "b4d0c86864453a177a5db67f46e2acbb", "sha256": "999bb8ef4c959ac3b9f76b1f3cbad0469e68ed16711d08f2ced1e104219d1326"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "b4d0c86864453a177a5db67f46e2acbb", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 566409, "upload_time": "2019-03-29T20:15:11", "upload_time_iso_8601": "2019-03-29T20:15:11.838783Z", "url": "https://files.pythonhosted.org/packages/15/32/008748117bd38edd36b81c2594f23fa665e09bf14df4484c25231301f024/graphql_compiler-2.0.0.dev3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8ea7aaeba773ec57ca5b2de88b3966be", "sha256": "13ba1a5e98a33cc98f653556ab5e87f419c35ef387430eeedd35aa197a03c073"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev3.tar.gz", "has_sig": false, "md5_digest": "8ea7aaeba773ec57ca5b2de88b3966be", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 519206, "upload_time": "2019-03-29T20:15:13", "upload_time_iso_8601": "2019-03-29T20:15:13.939074Z", "url": "https://files.pythonhosted.org/packages/a9/cf/83f8246c720ae6aa690bad3a1ecf1a5f707933a7c13ea00e7dc75dc85d43/graphql-compiler-2.0.0.dev3.tar.gz", "yanked": false}], "2.0.0.dev4": [{"comment_text": "", "digests": {"md5": "b579b3a1d8c6520e4f15f5f285fc1f54", "sha256": "4670e1ca1d543226ae1544e289a6ca1757cb46090e10411a34b9f0318d95da83"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev4-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "b579b3a1d8c6520e4f15f5f285fc1f54", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 712143, "upload_time": "2019-09-13T14:02:08", "upload_time_iso_8601": "2019-09-13T14:02:08.011437Z", "url": "https://files.pythonhosted.org/packages/57/ac/4f41cd08d35613c9bfb42060417aa5ea0449081880186e78bcccf4c55470/graphql_compiler-2.0.0.dev4-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "24789379de67036f597df45fc12b48ec", "sha256": "9ee502e9adb52645c5067f2e410e50a12716599a9dd1279257242474cdb704e3"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev4.tar.gz", "has_sig": false, "md5_digest": "24789379de67036f597df45fc12b48ec", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 641557, "upload_time": "2019-09-13T14:02:10", "upload_time_iso_8601": "2019-09-13T14:02:10.937553Z", "url": "https://files.pythonhosted.org/packages/b9/cd/72f811adf3a1540def0fa74e8f459477f2d4578ade15137dc42e7b18a609/graphql-compiler-2.0.0.dev4.tar.gz", "yanked": false}], "2.0.0.dev5": [{"comment_text": "", "digests": {"md5": "8ccde46787be136081d4f69e136952bd", "sha256": "3af84ee332a56d74200404611ff6a938d1f5e85eab73ea00482a02cd86dba8d0"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev5-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "8ccde46787be136081d4f69e136952bd", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 735426, "upload_time": "2019-11-08T23:05:12", "upload_time_iso_8601": "2019-11-08T23:05:12.606892Z", "url": "https://files.pythonhosted.org/packages/3a/29/9903c85ef74e73171fd3f9bd5367c026f8908fd26f4a2c45ebb04f33d922/graphql_compiler-2.0.0.dev5-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "99817b22fbd63d120aadcb5628cd0be3", "sha256": "4f048c935e9d66ccd85b8faeb0e48ae7cca2320205d13ce21e56f01e8fadc7e5"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev5.tar.gz", "has_sig": false, "md5_digest": "99817b22fbd63d120aadcb5628cd0be3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 673027, "upload_time": "2019-11-08T23:05:16", "upload_time_iso_8601": "2019-11-08T23:05:16.349910Z", "url": "https://files.pythonhosted.org/packages/56/73/dca2d3be1a714fa6bb04eb37919812c61e569d5227996e49d138bdda72d2/graphql-compiler-2.0.0.dev5.tar.gz", "yanked": false}], "2.0.0.dev6": [{"comment_text": "", "digests": {"md5": "39a43c3af74315bbd9a26293366981d6", "sha256": "cfabdc00c6ad6c5afe9c5fc9c245fd8b559f33525577c012a5e6c0d6f4db93b9"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev6-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "39a43c3af74315bbd9a26293366981d6", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 764008, "upload_time": "2020-01-23T22:26:52", "upload_time_iso_8601": "2020-01-23T22:26:52.911471Z", "url": "https://files.pythonhosted.org/packages/49/86/139400c4c52d078d9c4e101443dca602c2384b89da36e28885f757a40a0f/graphql_compiler-2.0.0.dev6-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d78a1acbd8df93270f6ce6c96b9a1e86", "sha256": "846d18e045d05ecbfa2504732b4a0870f59d05309932383861f6cf4ac01063e3"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev6.tar.gz", "has_sig": false, "md5_digest": "d78a1acbd8df93270f6ce6c96b9a1e86", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 697703, "upload_time": "2020-01-23T22:26:56", "upload_time_iso_8601": "2020-01-23T22:26:56.565019Z", "url": "https://files.pythonhosted.org/packages/4b/22/f0a5df9da266f708e39e6b33d68aa76152bcbe51852a309d9e5e64a1436e/graphql-compiler-2.0.0.dev6.tar.gz", "yanked": false}], "2.0.0.dev7": [{"comment_text": "", "digests": {"md5": "6524ae5dcc0b0974bf7e05fdffab8959", "sha256": "c3034e7016ddd0291da681a444c28d1c89567c60a9a81e5dbe4bd97125ce625f"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev7-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "6524ae5dcc0b0974bf7e05fdffab8959", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 773904, "upload_time": "2020-01-30T15:54:17", "upload_time_iso_8601": "2020-01-30T15:54:17.433695Z", "url": "https://files.pythonhosted.org/packages/9b/a3/aeb6d7257032b46dbdc67e7d3072c44cf253a27c63b5a8627829b3eb81a2/graphql_compiler-2.0.0.dev7-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "90c71fb342b2e071050232e3c6d4b841", "sha256": "01b0e619fb73e1830735b361f28fd028ab104200ff0de85d2cb1514ba0bd1a74"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev7.tar.gz", "has_sig": false, "md5_digest": "90c71fb342b2e071050232e3c6d4b841", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 706347, "upload_time": "2020-01-30T15:54:20", "upload_time_iso_8601": "2020-01-30T15:54:20.642777Z", "url": "https://files.pythonhosted.org/packages/06/d4/20ad4f38a167f69603c831fd986c901f1c5c85a1e4810dc497f0a9c720fb/graphql-compiler-2.0.0.dev7.tar.gz", "yanked": false}], "2.0.0.dev8": [{"comment_text": "", "digests": {"md5": "1bb856c19129b4375e5ca11e57ca11d2", "sha256": "4fe38a4fd377af6f2f6ae8cbe434a0f98c20b61b8f9f024b5b162676be9d0c1a"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev8-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "1bb856c19129b4375e5ca11e57ca11d2", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 774329, "upload_time": "2020-01-30T20:32:03", "upload_time_iso_8601": "2020-01-30T20:32:03.343653Z", "url": "https://files.pythonhosted.org/packages/d9/5e/079ce77cce1b00dcabe903308e2f4e203e6eec9ce4bae4f072ff4b8a0bce/graphql_compiler-2.0.0.dev8-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9565337a03b76a92e55b6e2def44ddea", "sha256": "c07c7687d15fb099e933ecf751225668e214a90b624b3c88fba542665783996b"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev8.tar.gz", "has_sig": false, "md5_digest": "9565337a03b76a92e55b6e2def44ddea", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 706742, "upload_time": "2020-01-30T20:32:06", "upload_time_iso_8601": "2020-01-30T20:32:06.450703Z", "url": "https://files.pythonhosted.org/packages/f3/78/2e72a9acc41c584376194a806b90221ebfeff0905e71a8cf298f7138b884/graphql-compiler-2.0.0.dev8.tar.gz", "yanked": false}], "2.0.0.dev9": [{"comment_text": "", "digests": {"md5": "0200ae94ccf3dd3910dcc2aaadfddba5", "sha256": "f48ff1c3b5baa9f16f460baf7fee3002ad7dca1b121cf1dc63d4d9e809e9227a"}, "downloads": -1, "filename": "graphql_compiler-2.0.0.dev9-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "0200ae94ccf3dd3910dcc2aaadfddba5", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6", "size": 774400, "upload_time": "2020-01-31T00:26:50", "upload_time_iso_8601": "2020-01-31T00:26:50.720441Z", "url": "https://files.pythonhosted.org/packages/d2/f4/c584fdd0bec2ac72de4963a8b81611235c424b61fffd31dfb7c607c3f659/graphql_compiler-2.0.0.dev9-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "97ab6711dd9ad7db393a08e889c31051", "sha256": "722be688e7001190f5f4587055984cf4b3463588a9eaa398c7dae25ae0860d2f"}, "downloads": -1, "filename": "graphql-compiler-2.0.0.dev9.tar.gz", "has_sig": false, "md5_digest": "97ab6711dd9ad7db393a08e889c31051", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 706824, "upload_time": "2020-01-31T00:26:54", "upload_time_iso_8601": "2020-01-31T00:26:54.044094Z", "url": "https://files.pythonhosted.org/packages/1c/01/192fa39565d5c776b329df55eee52d61d1934d470bcfa90850a7311f869e/graphql-compiler-2.0.0.dev9.tar.gz", "yanked": false}], "2.0.0b1": [{"comment_text": "", "digests": {"md5": "d69f4b300be58ff1d7fbb358d4bb7f97", "sha256": "fef435e389d806f142733955a7d7298511e5078ce6dae259aed81bfcbb220667"}, "downloads": -1, "filename": "graphql_compiler-2.0.0b1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d69f4b300be58ff1d7fbb358d4bb7f97", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 709649, "upload_time": "2019-09-07T19:43:07", "upload_time_iso_8601": "2019-09-07T19:43:07.310859Z", "url": "https://files.pythonhosted.org/packages/e4/0e/87cdf982ea85d707e1f68296dc8f9f27692a0e4722fb1597eb63702f360b/graphql_compiler-2.0.0b1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b5548bde1b192bd786a81ea9439dada2", "sha256": "a42151bbaf9e10a42d180af22ca25fb0630c0b5319c8e88d5be483898058fd79"}, "downloads": -1, "filename": "graphql-compiler-2.0.0b1.tar.gz", "has_sig": false, "md5_digest": "b5548bde1b192bd786a81ea9439dada2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 639251, "upload_time": "2019-09-07T19:43:10", "upload_time_iso_8601": "2019-09-07T19:43:10.159950Z", "url": "https://files.pythonhosted.org/packages/84/07/58a4e84e98948b17fb7414dcddedd4cdaac458a1cd48f0dc02ed09bc34dc/graphql-compiler-2.0.0b1.tar.gz", "yanked": false}], "2.0.0b2": [{"comment_text": "", "digests": {"md5": "f6abd3e330aba961df85a2812239d9ea", "sha256": "bf97750ddbdae93fcf842bbc7a697c3938dd7c94403f4a083b1e488933b65697"}, "downloads": -1, "filename": "graphql_compiler-2.0.0b2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f6abd3e330aba961df85a2812239d9ea", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 722401, "upload_time": "2019-10-07T15:12:01", "upload_time_iso_8601": "2019-10-07T15:12:01.443363Z", "url": "https://files.pythonhosted.org/packages/17/88/cfe70abdd9eab75aa17ea968deb1375f008d3dc252c3f59dd77f70dd62dd/graphql_compiler-2.0.0b2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f009e0f6f72a7b2e9a43a2b1132c89ce", "sha256": "180f5c5957a9316df32f831e4b7e7ba3abd2f9695f9fb5b23938d6a67c2d1ffe"}, "downloads": -1, "filename": "graphql-compiler-2.0.0b2.tar.gz", "has_sig": false, "md5_digest": "f009e0f6f72a7b2e9a43a2b1132c89ce", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 660774, "upload_time": "2019-10-07T15:12:15", "upload_time_iso_8601": "2019-10-07T15:12:15.750241Z", "url": "https://files.pythonhosted.org/packages/cb/10/f7b47152f49eb0ed1629355836e29aba07d7f9b24c91b7ca04f7fbfb4eb3/graphql-compiler-2.0.0b2.tar.gz", "yanked": false}], "2.0.0b3": [{"comment_text": "", "digests": {"md5": "687390108abc33471b8fd00f0d7edaf1", "sha256": "41aca55966b3445f4ffcb95251b3c3e0a5ce230b259e4d75cfc25cf18377a9cb"}, "downloads": -1, "filename": "graphql_compiler-2.0.0b3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "687390108abc33471b8fd00f0d7edaf1", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 728885, "upload_time": "2019-10-30T14:55:16", "upload_time_iso_8601": "2019-10-30T14:55:16.713187Z", "url": "https://files.pythonhosted.org/packages/c6/14/f1d4a92c1a70c7f8a758ea25e8649d16dd1d43b27fb17a1bafd0213c681d/graphql_compiler-2.0.0b3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fcf4852f6198a4def21ee13ba7974780", "sha256": "020a18d7366934d658ad4900a8558ca7ef5a4d2a30dd47527beb02f659751676"}, "downloads": -1, "filename": "graphql-compiler-2.0.0b3.tar.gz", "has_sig": false, "md5_digest": "fcf4852f6198a4def21ee13ba7974780", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 666590, "upload_time": "2019-10-30T14:55:20", "upload_time_iso_8601": "2019-10-30T14:55:20.842792Z", "url": "https://files.pythonhosted.org/packages/55/9b/05f214b754168f93da749e1546958b26b1c3fcb77275e482be0406e2e367/graphql-compiler-2.0.0b3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d001f7f5d1f46b42d6440a338b7dd2d9", "sha256": "f341b95c43e07b8dcff741ca7f0b9ae390bf995839b9f976d197ffa10a802e00"}, "downloads": -1, "filename": "graphql_compiler-1.11.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d001f7f5d1f46b42d6440a338b7dd2d9", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 604590, "upload_time": "2019-07-22T23:41:13", "upload_time_iso_8601": "2019-07-22T23:41:13.742378Z", "url": "https://files.pythonhosted.org/packages/6b/2f/7ec11bd6d9f67f24a2a994f8cac29cc7c30fe15c7b60654826a95811ae58/graphql_compiler-1.11.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d2490d55bf0292676f40e411467912a1", "sha256": "8a8da4da1e5dd8d5f855ebf6bb575522477666e75f0d83afefa7f0db6915567a"}, "downloads": -1, "filename": "graphql-compiler-1.11.0.tar.gz", "has_sig": false, "md5_digest": "d2490d55bf0292676f40e411467912a1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*", "size": 553450, "upload_time": "2019-07-22T23:41:16", "upload_time_iso_8601": "2019-07-22T23:41:16.607977Z", "url": "https://files.pythonhosted.org/packages/a1/0b/35d89eee17c0ec72239e38289088964709af4abfc0c76e0c302b3f9bf559/graphql-compiler-1.11.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:34 2020"}