{"info": {"author": "Lovely Systems", "author_email": "office@lovelysystems.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Internet :: WWW/HTTP"], "description": "=======\nTagging\n=======\n\nA tagging engine allows you to assign tags to any type of object by an user. A\ntag is a simple string.\n\n  >>> from lovely import tag\n\nTagging Engine\n--------------\n\nThe tagging engine provides the capabilities to manipulate and and query\ntagged items.\n\n  >>> engine = tag.TaggingEngine()\n  >>> engine\n  <TaggingEngine entries=0>\n\nThe first step is to associate tags with an item for a user. Items are\nreferenced by their intId, the user is a system-wide unique string and\nthe tags is a simple list of strings.\n\nBefore updating the engine we need to ensure that persistent objects can be\nadapted to key references:\n\n  >>> import zope.component\n  >>> from zope.app.keyreference import testing\n\n  >>> zope.component.provideAdapter(testing.SimpleKeyReference)\n\n\nInstead providing a separate API for adding and updating tags, both actions\nare done via the ``update()`` method. Think of it as updating the tagging\nengine.\n\n  >>> engine.update(1, u'srichter', [u'USA', u'personal'])\n  >>> engine.update(2, u'srichter', [u'austria', u'lovely'])\n  >>> engine.update(3, u'jodok', [u'Austria', u'personal'])\n  >>> engine.update(2, u'jodok', [u'austria', u'lovely', u'work'])\n\nNext you can ask the engine several questions.\n\nQuerying for Tags\n~~~~~~~~~~~~~~~~~\n\nA common request is to ask for tags based on items and users. First, you can\nask for all tags for a particular item:\n\n  >>> sorted(engine.getTags(items=(1,)))\n  [u'USA', u'personal']\n\nNote: The query methods return sets.\n\n  >>> type(engine.getTags())\n  <type 'set'>\n\nThe method always returns the normalized tag strings. You can also specify\nseveral items:\n\n  >>> sorted(engine.getTags(items=(1, 2)))\n  [u'USA', u'austria', u'lovely', u'personal', u'work']\n\nYou can also ask for tags of a user:\n\n  >>> sorted(engine.getTags(users=(u'srichter',)))\n  [u'USA', u'austria', u'lovely', u'personal']\n\nAgain, you can specify multiple users:\n\n  >>> sorted(engine.getTags(users=(u'srichter', u'jodok')))\n  [u'Austria', u'USA', u'austria', u'lovely', u'personal', u'work']\n\nFinally, you can also specify a combination of both:\n\n  >>> sorted(engine.getTags(items=(1,), users=(u'srichter',)))\n  [u'USA', u'personal']\n  >>> sorted(engine.getTags(items=(1, 2), users=(u'srichter',)))\n  [u'USA', u'austria', u'lovely', u'personal']\n  >>> sorted(engine.getTags(items=(3,), users=(u'srichter',)))\n  []\n\nYou can also query all tags by not specifying items or users:\n\n  >>> sorted(engine.getTags())\n  [u'Austria', u'USA', u'austria', u'lovely', u'personal', u'work']\n\n\nQuerying for Items\n~~~~~~~~~~~~~~~~~~\n\nThis method allows to look for items. For example, we would like to find all\nitems that have the \"personal\" tag:\n\n  >>> sorted(engine.getItems(tags=(u'personal',)))\n  [1, 3]\n\nNote: The query methods return sets.\n\n  >>> type(engine.getItems())\n  <type 'set'>\n\nFurthermore, you can query for all items of a particular user:\n\n  >>> sorted(engine.getItems(users=(u'srichter',)))\n  [1, 2]\n  >>> sorted(engine.getItems(users=(u'srichter', u'jodok')))\n  [1, 2, 3]\n\nFinally, you can combine tag and user specifications:\n\n  >>> sorted(engine.getItems(\n  ...     tags=(u'personal',), users=(u'srichter', u'jodok')))\n  [1, 3]\n\nYou can also query all items by not specifying tags or users:\n\n  >>> sorted(engine.getItems())\n  [1, 2, 3]\n\n\nQuerying for Users\n~~~~~~~~~~~~~~~~~~\n\nSimilar to the two methods above, you can query for users. First we are\nlooking for all users specifying a particular tag.\n\n  >>> sorted(engine.getUsers(tags=(u'personal',)))\n  [u'jodok', u'srichter']\n  >>> sorted(engine.getUsers(tags=(u'Austria',)))\n  [u'jodok']\n\nNote: The query methods return sets.\n\n  >>> type(engine.getUsers())\n  <type 'set'>\n\nNext you can also find all items that that have been tagged by a user:\n\n  >>> sorted(engine.getUsers(items=(1,)))\n  [u'srichter']\n  >>> sorted(engine.getUsers(items=(2,)))\n  [u'jodok', u'srichter']\n\nAs before you can combine the two criteria as well:\n\n  >>> sorted(engine.getUsers(tags=(u'USA',), items=(1,)))\n  [u'srichter']\n  >>> sorted(engine.getUsers(tags=(u'personal',), items=(1, 3)))\n  [u'jodok', u'srichter']\n\nYou can also query all users by not specifying tags or items:\n\n  >>> sorted(engine.getUsers())\n  [u'jodok', u'srichter']\n\n\nQuerying for Tagobjects\n~~~~~~~~~~~~~~~~~~~~~~~\n\nSometimes it is usefull to have the actual tag objects directly. These\ntag objects can be queried by tagnames, users and items.\n\n  >>> sorted(engine.getTagObjects(tags=(u'personal',)))\n  [<Tag u'personal' for 1 by u'srichter'>,\n   <Tag u'personal' for 3 by u'jodok'>]\n  >>> sorted(engine.getTagObjects(tags=(u'personal',),\n  ...                             users=(u'srichter',)))\n  [<Tag u'personal' for 1 by u'srichter'>]\n  >>> sorted(engine.getTagObjects(tags=(u'personal',),\n  ...                             items=(3,)))\n  [<Tag u'personal' for 3 by u'jodok'>]\n\nWe can also search fr\n\nTagging Statistics\n------------------\n\n  >>> from lovely.tag.interfaces import ITaggingStatistics\n  >>> ITaggingStatistics.providedBy(engine)\n  True\n  >>> engine.tagCount\n  6\n  >>> engine.itemCount\n  3\n  >>> engine.userCount\n  2\n\n\nCombining Queries\n-----------------\n\nSince those query methods return sets, you can easily combine them:\n\n  >>> users1 = engine.getUsers(items=(1,))\n  >>> users2 = engine.getUsers(items=(2,))\n  >>> sorted(users1.intersection(users2))\n  [u'srichter']\n\n\nChanging and deleting Entries\n-----------------------------\n\n\"srichter\" moved from USA to Germany:\n\n  >>> engine.update(1, u'srichter', [u'Germany', u'personal'])\n  >>> sorted(engine.getTags(items=(1,), users=(u'srichter',)))\n  [u'Germany', u'personal']\n\n\nWe delete entries by passing an empty list to the update method:\n\n  >>> engine.update(1, u'srichter', [])\n  >>> sorted(engine.getTags(items=(1,)))\n  []\n  >>> sorted(engine.getTags())\n  [u'Austria', u'austria', u'lovely', u'personal', u'work']\n  >>> sorted(engine.getItems())\n  [2, 3]\n\nNow let's delete the tags of the second item. We want to be sure that\n\"srichter\" can't be found anymore:\n\n  >>> engine.update(2, u'srichter', [])\n  >>> sorted(engine.getUsers())\n  [u'jodok']\n\nIn order to delete entries globaly use the delete method described below.\n\nTag Object\n----------\n\nInternally, the tagging engine uses the ``Tag`` class to store all data about\none particular item, user and tag names pair.\n\n  >>> from lovely.tag.tag import Tag\n\nThe ``Tag`` object is initialized with the three pieces information mentioned\nabove.\n\n  >>> sample = Tag(1, u'user', u'tag1')\n  >>> sample\n  <Tag u'tag1' for 1 by u'user'>\n\nYou can also think of those three items as the unique key of the\ntag. Additionally to those three attributes, a creation date is also\nspecified:\n\n  >>> sample.item\n  1\n  >>> sample.user\n  u'user'\n  >>> sample.name\n  u'tag1'\n  >>> sample.timestamp\n  datetime.datetime(...)\n\n\nTaggable Objects\n----------------\n\nTheoretically all objects are taggable. But this might not be desirable. Thus\nobjects must provide the ``ITaggable`` interface to be taggable.\n\n  >>> import zope.interface\n\n  >>> class Image(object):\n  ...     zope.interface.implements(tag.interfaces.ITaggable)\n  >>> image = Image()\n\n  >>> class File(object):\n  ...     pass\n  >>> file = File()\n\nTaggable objects can then be adapted to the ``ITagging`` interface. For this\nto work we have to register the adapter:\n\n  >>> zope.component.provideAdapter(tag.Tagging)\n\nBefore we can now use the tagging object, we need to register our tagging\nengine as well as the integer id generator as a utility:\n\n  >>> zope.component.provideUtility(engine, tag.interfaces.ITaggingEngine)\n\n  >>> from zope.app import intid\n  >>> intIds = intid.IntIds()\n  >>> zope.component.provideUtility(intIds, intid.interfaces.IIntIds)\n\nAdapting the file to be tagged should fail:\n\n  >>> tag.interfaces.ITagging(file)\n  Traceback (most recent call last):\n  ...\n  TypeError: ('Could not adapt', <File ...>, <InterfaceClass ...ITagging>)\n\nBut images can be tagged:\n\n  >>> tagging = tag.interfaces.ITagging(image)\n\nAt first there are no tags for the image:\n\n  >>> sorted(tagging.getTags())\n  []\n\nLet's now have \"srichter\" and \"jodok\" add a few tags:\n\n  >>> tagging.update(u'srichter', [u'home', u'USA'])\n  >>> tagging.update(u'jodok', [u'vacation', u'USA'])\n\n  >>> sorted(tagging.getTags())\n  [u'USA', u'home', u'vacation']\n\nOf course, you can also ask just for the tags by \"srichter\":\n\n  >>> sorted(tagging.getTags(users=[u'srichter']))\n  [u'USA', u'home']\n\nFurther you can request to see all users that have tagged the image:\n\n  >>> sorted(tagging.getUsers())\n  [u'jodok', u'srichter']\n\nor all users that have specified a particular tag:\n\n  >>> sorted(tagging.getUsers(tags=(u'home',)))\n  [u'srichter']\n  >>> sorted(tagging.getUsers(tags=(u'USA',)))\n  [u'jodok', u'srichter']\n\nUsing Named Tagging Engines\n---------------------------\n\n  >>> class INamedTagging(tag.interfaces.ITagging):\n  ...     pass\n  >>> class NamedTagging(tag.Tagging):\n  ...     zope.interface.implements(INamedTagging)\n  ...     zope.component.adapts(tag.interfaces.ITaggable)\n  ...     engineName = 'IAmNamed'\n  >>> zope.component.provideAdapter(NamedTagging,\n  ...                               (tag.interfaces.ITaggable,),\n  ...                               INamedTagging)\n\n  >>> namedTagging = INamedTagging(image)\n  >>> namedTagging.tags = ['named1', 'named2']\n  >>> namedTagging.update(u'jukart', [u'works', u'hard'])\n  Traceback (most recent call last):\n  ...\n  ComponentLookupError: (<InterfaceClass lovely.tag.interfaces.ITaggingEngine>, 'IAmNamed')\n\nWe have no named tagging engine registered yet. Let's see what happens if we\nupdate with an empty list of tags.\n\n  >>> namedTagging.update(u'jukart', [])\n\nIf we update without tags it is possible that we do this because an object has\nbeen deleted. This is usually done in an event handler for ObjectRemovedEvent.\nIf we would raise an exeption in this case it is not possible to delete a site.\n\nNow we register a named tagging engine.\n\n  >>> namedEngine = tag.TaggingEngine()\n  >>> zope.component.provideUtility(namedEngine, tag.interfaces.ITaggingEngine,\n  ...                               name='IAmNamed')\n\n  >>> namedTagging = INamedTagging(image)\n  >>> namedTagging.tags = ['named1', 'named2']\n  >>> sorted(namedTagging.getTags())\n  []\n  >>> namedTagging.update(u'jukart', [u'works', u'hard'])\n  >>> sorted(namedTagging.getTags())\n  [u'hard', u'works']\n\nThe new tags are not in the unnamed tagging engine.\n\n  >>> sorted(tagging.getTags())\n  [u'USA', u'home', u'vacation']\n\n\nIUserTagging\n------------\n\nThere is also an adapter for ITaggable objects which provides a simple\ntag attribute which accepts a list of tags defined for the ITaggable\nby the current principal.\n\n  >>> zope.component.provideAdapter(tag.UserTagging)\n  >>> userTagging = tag.interfaces.IUserTagging(image)\n  >>> userTagging.tags\n  Traceback (most recent call last):\n  ...\n  ValueError: User not found\n\nWe get a ValueError because we have no interaction in this test, and\ntherefore the implementation cannot find the principal. We have to\ncreate a principal and a participation.\n\n  >>> from zope.security.testing import Principal, Participation\n  >>> from zope.security import management\n  >>> p = Principal(u'srichter')\n  >>> participation = Participation(p)\n  >>> management.endInteraction()\n  >>> management.newInteraction(participation)\n  >>> sorted(userTagging.tags)\n  [u'USA', u'home']\n  >>> userTagging.tags = [u'zope3', u'guru']\n  >>> sorted(userTagging.tags)\n  [u'guru', u'zope3']\n\nTag Clouds\n----------\n\nAll portals like Flickr, del.icio.us use tagging and generate tag clouds.\nTag clouds contain tags and their frequency.\n\nThe ``getCloud`` method returns a set of tuples in the form of\n('tag', frequency). It takes the same arguments as getTags.\n\n  >>> type(engine.getCloud())\n  <type 'set'>\n\nNow let's add some tags to generate clouds later:\n\n  >>> engine.update(3, u'michael', [u'Austria', u'Bizau'])\n  >>> engine.update(2, u'michael', [u'lovely', u'USA'])\n  >>> engine.update(1, u'jodok', [u'USA',])\n\nThe most common use-case is to generate a global tag cloud.\n\n  >>> sorted(engine.getCloud())\n  [(u'Austria', 2), (u'Bizau', 1), (u'USA', 3), (u'austria', 1),\n   (u'guru', 1), (u'lovely', 2), (u'personal', 1), (u'vacation', 1),\n   (u'work', 1), (u'zope3', 1)]\n\nOf course you can generate clouds on item basis. You can't pass a tuple of\nitems, only a single one is allowed:\n\n  >>> sorted(engine.getCloud(items=[1]))\n  [(u'USA', 1)]\n\nThe same applies to queries by user:\n\n  >>> sorted(engine.getCloud(users=[u'srichter']))\n  [(u'guru', 1), (u'zope3', 1)]\n\nOr more users, and a few items.\n\n  >>> sorted(engine.getCloud(items=[1, 2, 3], users=[u'srichter', u'jodok']))\n  [(u'Austria', 1), (u'USA', 1), (u'austria', 1),\n   (u'lovely', 1), (u'personal', 1), (u'work', 1)]\n\nRe-updating tags for same user does not affect cloud weight\n\n   >>> engine.update(1, u'jodok', [u'USA',])\n   >>> sorted(engine.getCloud(items=[1, 2, 3], users=[u'srichter', u'jodok']))\n   [(u'Austria', 1), (u'USA', 1), (u'austria', 1),\n   (u'lovely', 1), (u'personal', 1), (u'work', 1)]\n\n\nRe-updating tags for same user does not affect cloud weight\n\n  >>> engine.update(1, u'jodok', [u'USA',])\n  >>> sorted(engine.getCloud(items=[1, 2, 3], users=[u'srichter', u'jodok']))\n  [(u'Austria', 1), (u'USA', 1), (u'austria', 1),\n   (u'lovely', 1), (u'personal', 1), (u'work', 1)]\n\n\nRelated Tags\n------------\n\nAn advanced feature of the tagging engine is to find all tags that are related\nto a given tag.\n\n  >>> sorted(engine.getRelatedTags(u'austria'))\n  [u'lovely', u'work']\n\nBy default the method only searches for the first degree related tags. You can\nalso search for other degrees:\n\n  >>> engine.update(4, u'jodok', [u'lovely', u'dornbirn', u'personal'])\n  >>> sorted(engine.getRelatedTags(u'austria', degree=2))\n  [u'USA', u'dornbirn', u'lovely', u'personal', u'work']\n\n  >>> engine.update(4, u'jodok', [u'lovely', u'dornbirn', u'personal'])\n  >>> sorted(engine.getRelatedTags(u'austria', degree=3))\n  [u'Austria', u'USA', u'dornbirn', u'lovely', u'personal',\n   u'vacation', u'work']\n\n\nRelated Items\n-------------\n\nAnother advanced feature is to provide related items.\n\nWe set up a new engine for this test. Items are related if they have at least\none tag in common.\n\n  >>> relatedEngine = tag.TaggingEngine()\n  >>> relatedEngine.update(1, u'srichter', [u'USA', u'personal', u'zope'])\n  >>> relatedEngine.update(2, u'srichter', [u'austria', u'lovely'])\n  >>> relatedEngine.update(3, u'jodok', [u'Austria', u'personal'])\n  >>> relatedEngine.update(2, u'jodok', [u'austria', u'lovely', u'work'])\n  >>> relatedEngine.update(4, u'jukart', [u'austria', u'Austria', u'lovely', u'work'])\n  >>> relatedEngine.update(5, u'jim', [u'USA', u'zope'])\n\nWe get tuples with the related item and the number of tags in common.\n\n  >>> relatedEngine.getRelatedItems(1)\n  [(5, 2), (3, 1)]\n  >>> relatedEngine.getRelatedItems(5)\n  [(1, 2)]\n  >>> relatedEngine.getRelatedItems(2)\n  [(4, 3)]\n\n\nRelated Users\n-------------\n\nWe can also get related users. Users are related if they have at least one tag\nin common.\n\n  >>> relatedEngine.getRelatedUsers(u'jim')\n  [(u'srichter', 2)]\n  >>> relatedEngine.getRelatedUsers(u'jodok')\n  [(u'jukart', 4), (u'srichter', 3)]\n\n\nFrequency Of Tags\n-----------------\n\nIf we have a list of tags we can ask for the frequencies of the tags.\n\n  >>> sorted(engine.getFrequency([u'Austria', u'USA']))\n  [(u'Austria', 2), (u'USA', 3)]\n\nWe get a frequency of 0 if we ask for a tag which is not in the engine.\n\n  >>> sorted(engine.getFrequency([u'Austria', u'jukart', u'USA']))\n  [(u'Austria', 2), (u'USA', 3), (u'jukart', 0)]\n\n\nRemoval of Tag objects\n----------------------\n\n\nWhen an object is unregistered from the intids utility it will be\nremoved from each engine. Let us see how much items we have so far.\n\n  >>> len(engine.getItems())\n  5\n  >>> len(namedEngine.getItems())\n  1\n\nWe can use the delete method of the tagging engine to delete tag\nobjects by defining the user, item or a tag name.\n\n  >>> u'austria' in engine.getTags()\n  True\n  >>> engine.delete(tag=u'austria')\n  >>> u'austria' in engine.getTags()\n  False\n\nIf we delete tags for a user, the tags still exists for other users.\n\n  >>> sorted(engine.getTags(users=(u'jodok',)))\n  [u'Austria', u'USA', u'dornbirn', u'lovely',\n   u'personal', u'vacation', u'work']\n  >>> engine.delete(user=u'jodok')\n  >>> sorted(engine.getTags(users=(u'jodok',)))\n  []\n  >>> sorted(engine.getTags())\n  [u'Austria', u'Bizau', u'USA', u'guru', u'lovely', u'zope3']\n\nThis is also possible with items.\n\n  >>> sorted(engine.getTags(items=(3,)))\n  [u'Austria', u'Bizau']\n\nLet us add a tag tag from the item to another item to show the behaviour.\n\n  >>> engine.update(2, u'srichter', [u'Austria'])\n  >>> engine.delete(item=3)\n  >>> sorted(engine.getTags(items=(3,)))\n  []\n\nThe 'Austria' tag is still there.\n\n  >>> sorted(engine.getTags())\n  [u'Austria', u'USA', u'guru', u'lovely', u'zope3']\n\nLet us setup the handler and events.\n\n  >>> from zope.component import eventtesting\n  >>> from zope import event\n  >>> from lovely.tag.engine import removeItemSubscriber\n  >>> from zope.app.intid.interfaces import IntIdRemovedEvent\n  >>> from zope.app.intid import removeIntIdSubscriber\n  >>> zope.component.provideHandler(removeItemSubscriber)\n\nIf we now fire the intid remove event with our image object, it should\nget removed in both engines.\n\n  >>> len(namedEngine.getItems())\n  1\n  >>> len(engine.getItems())\n  2\n  >>> removeIntIdSubscriber(image, None)\n  >>> len(namedEngine.getItems())\n  0\n  >>> len(engine.getItems())\n  1\n\n\nRemoving Stale Items\n--------------------\n\nYou can remove stale items from the tagging engine. Stale means that\nthe item is not available anymore by the intids utility.\n\nBecause we removed any objects with intids before, we have an empty\nintid utility.\n\n  >>> sorted(intIds.refs.keys())\n  []\n\nBut above we defined an item with an id that does not exist. So this\nis a stale item.\n\n  >>> sorted(engine.getItems())\n  [2]\n\nLet us add our image object again.\n\n  >>> tagging = tag.interfaces.ITagging(image)\n  >>> tagging.update(u'srichter', [u'newtag'])\n\nThis is our first and only entry in the intid util\n\n   >>> intIds.refs.keys()[0] in engine.getItems()\n   True\n\nOur stale entry is 2. The intids of the items deleted are returned.\n\n   >>> 2  in engine.getItems()\n   True\n   >>> engine.cleanStaleItems()\n   [2]\n\nWe now only have our real image item.\n\n   >>> 2  in engine.getItems()\n   False\n   >>> len(engine.getItems())\n   1\n   >>> sorted(engine.getItems())[0] == intIds.refs.keys()[0]\n   True\n\n\nRenaming Tags\n-------------\n\nIt is also possible to rename tags globally in the engine.\n\n   >>> tagging.update(u'srichter', [u'tagtorename', u'usa'])\n   >>> tagging.update(u'jukart', [\n   ...     u'tagtorename', u'someothertag', u'renamedtag'])\n   >>> engine.update(123, 'jukart', [u'tagtorename'])\n   >>> sorted(engine.getTags())\n   [u'renamedtag', u'someothertag', u'tagtorename', u'usa']\n   >>> sorted(engine.getTags(users=[u'jukart']))\n   [u'renamedtag', u'someothertag', u'tagtorename']\n   >>> len(sorted(engine.getItems(tags=[u'tagtorename'])))\n   2\n   >>> len(sorted(engine.getItems(tags=[u'renamedtag'])))\n   1\n   >>> sorted(engine.getTags(users=[u'srichter']))\n   [u'tagtorename', u'usa']\n\nThe rename method returns the number of renamed tag objects.\n\n   >>> engine.rename(u'tagtorename', u'renamedtag')\n   3\n   >>> sorted(engine.getTags())\n   [u'renamedtag', u'someothertag', u'usa']\n\nTags are joined if the new name already exists.\n\n   >>> sorted(engine.getTags(users=[u'jukart']))\n   [u'renamedtag', u'someothertag']\n   >>> sorted(engine.getTags(users=[u'srichter']))\n   [u'renamedtag', u'usa']\n   >>> len(sorted(engine.getItems(tags=[u'tagtorename'])))\n   0\n   >>> len(sorted(engine.getItems(tags=[u'renamedtag'])))\n   2\n\nNormalizing Tags\n----------------\n\nIt is also possible to normalize tags with a callable ojbect which\nreturns a new name for any given name.\nlower case.\n\n   >>> engine.update(123, 'jukart', [u'RenamedTag', u'USA'])\n   >>> sorted(engine.getTags())\n   [u'RenamedTag', u'USA', u'renamedtag', u'someothertag', u'usa']\n\nLet us normalize all tags to lowercase by using the lower function\nfrom the string module.\n\n   >>> import string\n\nThe normalize method returns the number of tag objects affected.\n\n   >>> engine.normalize(string.lower)\n   2\n   >>> sorted(engine.getTags())\n   [u'renamedtag', u'someothertag', u'usa']\n\nThe normalize method also accepts a python dotted name, which will be\nresolved to a global object.\n\n   >>> engine.normalize('string.upper')\n   7\n   >>> sorted(engine.getTags())\n   [u'RENAMEDTAG', u'SOMEOTHERTAG', u'USA']\n\n\n=======\nCHANGES\n=======\n\n1.1.1 (2009-11-18)\n------------------\n\n- Renamed a conflicting 'zmi_views' menu entry. There were two\n  entries entitled 'Manage'. The CSVExportView became 'CSV Export'.\n  [trollfot]\n\n\n1.1.0 (2009-11-18)\n------------------\n\n- Fixed an important error on the tag update handling : tags were\n  registered more than once if an update was made for the same user,\n  item and tag. The issue came from the set comparison method, that\n  uses the hash and not a classical cmp method. We had to introduce a\n  comparison basis we called \"brain\" in order to get the expected\n  behavior. A test was added to emphasis this behavior. [trollfot]\n\n\n1.0.0 (2009-07-24)\n------------------\n\n- Fixed tests to conform to latest packages.\n\n- Cleanup release boilerplate.\n\n\n0.3.0b2 (2007-07-18)\n--------------------\n\n- in case of a not matching query lovely.tag will not longer return\n  None but an empty IFTreeSet. (this is caused because zope.app.catalog\n  will ignore None which results in a boolean or operation)\n\n\n0.3.0b1 (2007-06-13)\n--------------------\n\n- use iobtree for tag persistence instead of persistent list and intid\n  util, should be much faster now with big numbers of tags. (this is a\n  new database generation)", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/lovely.tag", "keywords": "zope3 lovely tag cloud", "license": "ZPL 2.1", "maintainer": null, "maintainer_email": null, "name": "lovely.tag", "package_url": "https://pypi.org/project/lovely.tag/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/lovely.tag/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/lovely.tag"}, "release_url": "https://pypi.org/project/lovely.tag/1.1.1/", "requires_dist": null, "requires_python": null, "summary": "A tagging engine for Zope 3", "version": "1.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"tagging\">\n<h2>Tagging</h2>\n<p>A tagging engine allows you to assign tags to any type of object by an user. A\ntag is a simple string.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from lovely import tag\n</pre>\n</blockquote>\n<div id=\"tagging-engine\">\n<h3>Tagging Engine</h3>\n<p>The tagging engine provides the capabilities to manipulate and and query\ntagged items.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine = tag.TaggingEngine()\n&gt;&gt;&gt; engine\n&lt;TaggingEngine entries=0&gt;\n</pre>\n</blockquote>\n<p>The first step is to associate tags with an item for a user. Items are\nreferenced by their intId, the user is a system-wide unique string and\nthe tags is a simple list of strings.</p>\n<p>Before updating the engine we need to ensure that persistent objects can be\nadapted to key references:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from zope.app.keyreference import testing\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(testing.SimpleKeyReference)\n</pre>\n</blockquote>\n<p>Instead providing a separate API for adding and updating tags, both actions\nare done via the <tt>update()</tt> method. Think of it as updating the tagging\nengine.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.update(1, u'srichter', [u'USA', u'personal'])\n&gt;&gt;&gt; engine.update(2, u'srichter', [u'austria', u'lovely'])\n&gt;&gt;&gt; engine.update(3, u'jodok', [u'Austria', u'personal'])\n&gt;&gt;&gt; engine.update(2, u'jodok', [u'austria', u'lovely', u'work'])\n</pre>\n</blockquote>\n<p>Next you can ask the engine several questions.</p>\n<div id=\"querying-for-tags\">\n<h4>Querying for Tags</h4>\n<p>A common request is to ask for tags based on items and users. First, you can\nask for all tags for a particular item:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getTags(items=(1,)))\n[u'USA', u'personal']\n</pre>\n</blockquote>\n<p>Note: The query methods return sets.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; type(engine.getTags())\n&lt;type 'set'&gt;\n</pre>\n</blockquote>\n<p>The method always returns the normalized tag strings. You can also specify\nseveral items:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getTags(items=(1, 2)))\n[u'USA', u'austria', u'lovely', u'personal', u'work']\n</pre>\n</blockquote>\n<p>You can also ask for tags of a user:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getTags(users=(u'srichter',)))\n[u'USA', u'austria', u'lovely', u'personal']\n</pre>\n</blockquote>\n<p>Again, you can specify multiple users:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getTags(users=(u'srichter', u'jodok')))\n[u'Austria', u'USA', u'austria', u'lovely', u'personal', u'work']\n</pre>\n</blockquote>\n<p>Finally, you can also specify a combination of both:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getTags(items=(1,), users=(u'srichter',)))\n[u'USA', u'personal']\n&gt;&gt;&gt; sorted(engine.getTags(items=(1, 2), users=(u'srichter',)))\n[u'USA', u'austria', u'lovely', u'personal']\n&gt;&gt;&gt; sorted(engine.getTags(items=(3,), users=(u'srichter',)))\n[]\n</pre>\n</blockquote>\n<p>You can also query all tags by not specifying items or users:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getTags())\n[u'Austria', u'USA', u'austria', u'lovely', u'personal', u'work']\n</pre>\n</blockquote>\n</div>\n<div id=\"querying-for-items\">\n<h4>Querying for Items</h4>\n<p>This method allows to look for items. For example, we would like to find all\nitems that have the \u201cpersonal\u201d tag:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getItems(tags=(u'personal',)))\n[1, 3]\n</pre>\n</blockquote>\n<p>Note: The query methods return sets.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; type(engine.getItems())\n&lt;type 'set'&gt;\n</pre>\n</blockquote>\n<p>Furthermore, you can query for all items of a particular user:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getItems(users=(u'srichter',)))\n[1, 2]\n&gt;&gt;&gt; sorted(engine.getItems(users=(u'srichter', u'jodok')))\n[1, 2, 3]\n</pre>\n</blockquote>\n<p>Finally, you can combine tag and user specifications:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getItems(\n...     tags=(u'personal',), users=(u'srichter', u'jodok')))\n[1, 3]\n</pre>\n</blockquote>\n<p>You can also query all items by not specifying tags or users:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getItems())\n[1, 2, 3]\n</pre>\n</blockquote>\n</div>\n<div id=\"querying-for-users\">\n<h4>Querying for Users</h4>\n<p>Similar to the two methods above, you can query for users. First we are\nlooking for all users specifying a particular tag.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getUsers(tags=(u'personal',)))\n[u'jodok', u'srichter']\n&gt;&gt;&gt; sorted(engine.getUsers(tags=(u'Austria',)))\n[u'jodok']\n</pre>\n</blockquote>\n<p>Note: The query methods return sets.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; type(engine.getUsers())\n&lt;type 'set'&gt;\n</pre>\n</blockquote>\n<p>Next you can also find all items that that have been tagged by a user:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getUsers(items=(1,)))\n[u'srichter']\n&gt;&gt;&gt; sorted(engine.getUsers(items=(2,)))\n[u'jodok', u'srichter']\n</pre>\n</blockquote>\n<p>As before you can combine the two criteria as well:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getUsers(tags=(u'USA',), items=(1,)))\n[u'srichter']\n&gt;&gt;&gt; sorted(engine.getUsers(tags=(u'personal',), items=(1, 3)))\n[u'jodok', u'srichter']\n</pre>\n</blockquote>\n<p>You can also query all users by not specifying tags or items:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getUsers())\n[u'jodok', u'srichter']\n</pre>\n</blockquote>\n</div>\n<div id=\"querying-for-tagobjects\">\n<h4>Querying for Tagobjects</h4>\n<p>Sometimes it is usefull to have the actual tag objects directly. These\ntag objects can be queried by tagnames, users and items.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getTagObjects(tags=(u'personal',)))\n[&lt;Tag u'personal' for 1 by u'srichter'&gt;,\n &lt;Tag u'personal' for 3 by u'jodok'&gt;]\n&gt;&gt;&gt; sorted(engine.getTagObjects(tags=(u'personal',),\n...                             users=(u'srichter',)))\n[&lt;Tag u'personal' for 1 by u'srichter'&gt;]\n&gt;&gt;&gt; sorted(engine.getTagObjects(tags=(u'personal',),\n...                             items=(3,)))\n[&lt;Tag u'personal' for 3 by u'jodok'&gt;]\n</pre>\n</blockquote>\n<p>We can also search fr</p>\n</div>\n</div>\n<div id=\"tagging-statistics\">\n<h3>Tagging Statistics</h3>\n<blockquote>\n<pre>&gt;&gt;&gt; from lovely.tag.interfaces import ITaggingStatistics\n&gt;&gt;&gt; ITaggingStatistics.providedBy(engine)\nTrue\n&gt;&gt;&gt; engine.tagCount\n6\n&gt;&gt;&gt; engine.itemCount\n3\n&gt;&gt;&gt; engine.userCount\n2\n</pre>\n</blockquote>\n</div>\n<div id=\"combining-queries\">\n<h3>Combining Queries</h3>\n<p>Since those query methods return sets, you can easily combine them:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; users1 = engine.getUsers(items=(1,))\n&gt;&gt;&gt; users2 = engine.getUsers(items=(2,))\n&gt;&gt;&gt; sorted(users1.intersection(users2))\n[u'srichter']\n</pre>\n</blockquote>\n</div>\n<div id=\"changing-and-deleting-entries\">\n<h3>Changing and deleting Entries</h3>\n<p>\u201csrichter\u201d moved from USA to Germany:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.update(1, u'srichter', [u'Germany', u'personal'])\n&gt;&gt;&gt; sorted(engine.getTags(items=(1,), users=(u'srichter',)))\n[u'Germany', u'personal']\n</pre>\n</blockquote>\n<p>We delete entries by passing an empty list to the update method:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.update(1, u'srichter', [])\n&gt;&gt;&gt; sorted(engine.getTags(items=(1,)))\n[]\n&gt;&gt;&gt; sorted(engine.getTags())\n[u'Austria', u'austria', u'lovely', u'personal', u'work']\n&gt;&gt;&gt; sorted(engine.getItems())\n[2, 3]\n</pre>\n</blockquote>\n<p>Now let\u2019s delete the tags of the second item. We want to be sure that\n\u201csrichter\u201d can\u2019t be found anymore:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.update(2, u'srichter', [])\n&gt;&gt;&gt; sorted(engine.getUsers())\n[u'jodok']\n</pre>\n</blockquote>\n<p>In order to delete entries globaly use the delete method described below.</p>\n</div>\n<div id=\"tag-object\">\n<h3>Tag Object</h3>\n<p>Internally, the tagging engine uses the <tt>Tag</tt> class to store all data about\none particular item, user and tag names pair.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from lovely.tag.tag import Tag\n</pre>\n</blockquote>\n<p>The <tt>Tag</tt> object is initialized with the three pieces information mentioned\nabove.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sample = Tag(1, u'user', u'tag1')\n&gt;&gt;&gt; sample\n&lt;Tag u'tag1' for 1 by u'user'&gt;\n</pre>\n</blockquote>\n<p>You can also think of those three items as the unique key of the\ntag. Additionally to those three attributes, a creation date is also\nspecified:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sample.item\n1\n&gt;&gt;&gt; sample.user\nu'user'\n&gt;&gt;&gt; sample.name\nu'tag1'\n&gt;&gt;&gt; sample.timestamp\ndatetime.datetime(...)\n</pre>\n</blockquote>\n</div>\n<div id=\"taggable-objects\">\n<h3>Taggable Objects</h3>\n<p>Theoretically all objects are taggable. But this might not be desirable. Thus\nobjects must provide the <tt>ITaggable</tt> interface to be taggable.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n</pre>\n<pre>&gt;&gt;&gt; class Image(object):\n...     zope.interface.implements(tag.interfaces.ITaggable)\n&gt;&gt;&gt; image = Image()\n</pre>\n<pre>&gt;&gt;&gt; class File(object):\n...     pass\n&gt;&gt;&gt; file = File()\n</pre>\n</blockquote>\n<p>Taggable objects can then be adapted to the <tt>ITagging</tt> interface. For this\nto work we have to register the adapter:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(tag.Tagging)\n</pre>\n</blockquote>\n<p>Before we can now use the tagging object, we need to register our tagging\nengine as well as the integer id generator as a utility:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.provideUtility(engine, tag.interfaces.ITaggingEngine)\n</pre>\n<pre>&gt;&gt;&gt; from zope.app import intid\n&gt;&gt;&gt; intIds = intid.IntIds()\n&gt;&gt;&gt; zope.component.provideUtility(intIds, intid.interfaces.IIntIds)\n</pre>\n</blockquote>\n<p>Adapting the file to be tagged should fail:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; tag.interfaces.ITagging(file)\nTraceback (most recent call last):\n...\nTypeError: ('Could not adapt', &lt;File ...&gt;, &lt;InterfaceClass ...ITagging&gt;)\n</pre>\n</blockquote>\n<p>But images can be tagged:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; tagging = tag.interfaces.ITagging(image)\n</pre>\n</blockquote>\n<p>At first there are no tags for the image:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(tagging.getTags())\n[]\n</pre>\n</blockquote>\n<p>Let\u2019s now have \u201csrichter\u201d and \u201cjodok\u201d add a few tags:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; tagging.update(u'srichter', [u'home', u'USA'])\n&gt;&gt;&gt; tagging.update(u'jodok', [u'vacation', u'USA'])\n</pre>\n<pre>&gt;&gt;&gt; sorted(tagging.getTags())\n[u'USA', u'home', u'vacation']\n</pre>\n</blockquote>\n<p>Of course, you can also ask just for the tags by \u201csrichter\u201d:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(tagging.getTags(users=[u'srichter']))\n[u'USA', u'home']\n</pre>\n</blockquote>\n<p>Further you can request to see all users that have tagged the image:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(tagging.getUsers())\n[u'jodok', u'srichter']\n</pre>\n</blockquote>\n<p>or all users that have specified a particular tag:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(tagging.getUsers(tags=(u'home',)))\n[u'srichter']\n&gt;&gt;&gt; sorted(tagging.getUsers(tags=(u'USA',)))\n[u'jodok', u'srichter']\n</pre>\n</blockquote>\n</div>\n<div id=\"using-named-tagging-engines\">\n<h3>Using Named Tagging Engines</h3>\n<blockquote>\n<pre>&gt;&gt;&gt; class INamedTagging(tag.interfaces.ITagging):\n...     pass\n&gt;&gt;&gt; class NamedTagging(tag.Tagging):\n...     zope.interface.implements(INamedTagging)\n...     zope.component.adapts(tag.interfaces.ITaggable)\n...     engineName = 'IAmNamed'\n&gt;&gt;&gt; zope.component.provideAdapter(NamedTagging,\n...                               (tag.interfaces.ITaggable,),\n...                               INamedTagging)\n</pre>\n<pre>&gt;&gt;&gt; namedTagging = INamedTagging(image)\n&gt;&gt;&gt; namedTagging.tags = ['named1', 'named2']\n&gt;&gt;&gt; namedTagging.update(u'jukart', [u'works', u'hard'])\nTraceback (most recent call last):\n...\nComponentLookupError: (&lt;InterfaceClass lovely.tag.interfaces.ITaggingEngine&gt;, 'IAmNamed')\n</pre>\n</blockquote>\n<p>We have no named tagging engine registered yet. Let\u2019s see what happens if we\nupdate with an empty list of tags.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; namedTagging.update(u'jukart', [])\n</pre>\n</blockquote>\n<p>If we update without tags it is possible that we do this because an object has\nbeen deleted. This is usually done in an event handler for ObjectRemovedEvent.\nIf we would raise an exeption in this case it is not possible to delete a site.</p>\n<p>Now we register a named tagging engine.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; namedEngine = tag.TaggingEngine()\n&gt;&gt;&gt; zope.component.provideUtility(namedEngine, tag.interfaces.ITaggingEngine,\n...                               name='IAmNamed')\n</pre>\n<pre>&gt;&gt;&gt; namedTagging = INamedTagging(image)\n&gt;&gt;&gt; namedTagging.tags = ['named1', 'named2']\n&gt;&gt;&gt; sorted(namedTagging.getTags())\n[]\n&gt;&gt;&gt; namedTagging.update(u'jukart', [u'works', u'hard'])\n&gt;&gt;&gt; sorted(namedTagging.getTags())\n[u'hard', u'works']\n</pre>\n</blockquote>\n<p>The new tags are not in the unnamed tagging engine.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(tagging.getTags())\n[u'USA', u'home', u'vacation']\n</pre>\n</blockquote>\n</div>\n<div id=\"iusertagging\">\n<h3>IUserTagging</h3>\n<p>There is also an adapter for ITaggable objects which provides a simple\ntag attribute which accepts a list of tags defined for the ITaggable\nby the current principal.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(tag.UserTagging)\n&gt;&gt;&gt; userTagging = tag.interfaces.IUserTagging(image)\n&gt;&gt;&gt; userTagging.tags\nTraceback (most recent call last):\n...\nValueError: User not found\n</pre>\n</blockquote>\n<p>We get a ValueError because we have no interaction in this test, and\ntherefore the implementation cannot find the principal. We have to\ncreate a principal and a participation.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.security.testing import Principal, Participation\n&gt;&gt;&gt; from zope.security import management\n&gt;&gt;&gt; p = Principal(u'srichter')\n&gt;&gt;&gt; participation = Participation(p)\n&gt;&gt;&gt; management.endInteraction()\n&gt;&gt;&gt; management.newInteraction(participation)\n&gt;&gt;&gt; sorted(userTagging.tags)\n[u'USA', u'home']\n&gt;&gt;&gt; userTagging.tags = [u'zope3', u'guru']\n&gt;&gt;&gt; sorted(userTagging.tags)\n[u'guru', u'zope3']\n</pre>\n</blockquote>\n</div>\n<div id=\"tag-clouds\">\n<h3>Tag Clouds</h3>\n<p>All portals like Flickr, del.icio.us use tagging and generate tag clouds.\nTag clouds contain tags and their frequency.</p>\n<p>The <tt>getCloud</tt> method returns a set of tuples in the form of\n(\u2018tag\u2019, frequency). It takes the same arguments as getTags.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; type(engine.getCloud())\n&lt;type 'set'&gt;\n</pre>\n</blockquote>\n<p>Now let\u2019s add some tags to generate clouds later:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.update(3, u'michael', [u'Austria', u'Bizau'])\n&gt;&gt;&gt; engine.update(2, u'michael', [u'lovely', u'USA'])\n&gt;&gt;&gt; engine.update(1, u'jodok', [u'USA',])\n</pre>\n</blockquote>\n<p>The most common use-case is to generate a global tag cloud.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getCloud())\n[(u'Austria', 2), (u'Bizau', 1), (u'USA', 3), (u'austria', 1),\n (u'guru', 1), (u'lovely', 2), (u'personal', 1), (u'vacation', 1),\n (u'work', 1), (u'zope3', 1)]\n</pre>\n</blockquote>\n<p>Of course you can generate clouds on item basis. You can\u2019t pass a tuple of\nitems, only a single one is allowed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getCloud(items=[1]))\n[(u'USA', 1)]\n</pre>\n</blockquote>\n<p>The same applies to queries by user:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getCloud(users=[u'srichter']))\n[(u'guru', 1), (u'zope3', 1)]\n</pre>\n</blockquote>\n<p>Or more users, and a few items.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getCloud(items=[1, 2, 3], users=[u'srichter', u'jodok']))\n[(u'Austria', 1), (u'USA', 1), (u'austria', 1),\n (u'lovely', 1), (u'personal', 1), (u'work', 1)]\n</pre>\n</blockquote>\n<p>Re-updating tags for same user does not affect cloud weight</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.update(1, u'jodok', [u'USA',])\n&gt;&gt;&gt; sorted(engine.getCloud(items=[1, 2, 3], users=[u'srichter', u'jodok']))\n[(u'Austria', 1), (u'USA', 1), (u'austria', 1),\n(u'lovely', 1), (u'personal', 1), (u'work', 1)]\n</pre>\n</blockquote>\n<p>Re-updating tags for same user does not affect cloud weight</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.update(1, u'jodok', [u'USA',])\n&gt;&gt;&gt; sorted(engine.getCloud(items=[1, 2, 3], users=[u'srichter', u'jodok']))\n[(u'Austria', 1), (u'USA', 1), (u'austria', 1),\n (u'lovely', 1), (u'personal', 1), (u'work', 1)]\n</pre>\n</blockquote>\n</div>\n<div id=\"related-tags\">\n<h3>Related Tags</h3>\n<p>An advanced feature of the tagging engine is to find all tags that are related\nto a given tag.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getRelatedTags(u'austria'))\n[u'lovely', u'work']\n</pre>\n</blockquote>\n<p>By default the method only searches for the first degree related tags. You can\nalso search for other degrees:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.update(4, u'jodok', [u'lovely', u'dornbirn', u'personal'])\n&gt;&gt;&gt; sorted(engine.getRelatedTags(u'austria', degree=2))\n[u'USA', u'dornbirn', u'lovely', u'personal', u'work']\n</pre>\n<pre>&gt;&gt;&gt; engine.update(4, u'jodok', [u'lovely', u'dornbirn', u'personal'])\n&gt;&gt;&gt; sorted(engine.getRelatedTags(u'austria', degree=3))\n[u'Austria', u'USA', u'dornbirn', u'lovely', u'personal',\n u'vacation', u'work']\n</pre>\n</blockquote>\n</div>\n<div id=\"related-items\">\n<h3>Related Items</h3>\n<p>Another advanced feature is to provide related items.</p>\n<p>We set up a new engine for this test. Items are related if they have at least\none tag in common.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; relatedEngine = tag.TaggingEngine()\n&gt;&gt;&gt; relatedEngine.update(1, u'srichter', [u'USA', u'personal', u'zope'])\n&gt;&gt;&gt; relatedEngine.update(2, u'srichter', [u'austria', u'lovely'])\n&gt;&gt;&gt; relatedEngine.update(3, u'jodok', [u'Austria', u'personal'])\n&gt;&gt;&gt; relatedEngine.update(2, u'jodok', [u'austria', u'lovely', u'work'])\n&gt;&gt;&gt; relatedEngine.update(4, u'jukart', [u'austria', u'Austria', u'lovely', u'work'])\n&gt;&gt;&gt; relatedEngine.update(5, u'jim', [u'USA', u'zope'])\n</pre>\n</blockquote>\n<p>We get tuples with the related item and the number of tags in common.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; relatedEngine.getRelatedItems(1)\n[(5, 2), (3, 1)]\n&gt;&gt;&gt; relatedEngine.getRelatedItems(5)\n[(1, 2)]\n&gt;&gt;&gt; relatedEngine.getRelatedItems(2)\n[(4, 3)]\n</pre>\n</blockquote>\n</div>\n<div id=\"related-users\">\n<h3>Related Users</h3>\n<p>We can also get related users. Users are related if they have at least one tag\nin common.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; relatedEngine.getRelatedUsers(u'jim')\n[(u'srichter', 2)]\n&gt;&gt;&gt; relatedEngine.getRelatedUsers(u'jodok')\n[(u'jukart', 4), (u'srichter', 3)]\n</pre>\n</blockquote>\n</div>\n<div id=\"frequency-of-tags\">\n<h3>Frequency Of Tags</h3>\n<p>If we have a list of tags we can ask for the frequencies of the tags.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getFrequency([u'Austria', u'USA']))\n[(u'Austria', 2), (u'USA', 3)]\n</pre>\n</blockquote>\n<p>We get a frequency of 0 if we ask for a tag which is not in the engine.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getFrequency([u'Austria', u'jukart', u'USA']))\n[(u'Austria', 2), (u'USA', 3), (u'jukart', 0)]\n</pre>\n</blockquote>\n</div>\n<div id=\"removal-of-tag-objects\">\n<h3>Removal of Tag objects</h3>\n<p>When an object is unregistered from the intids utility it will be\nremoved from each engine. Let us see how much items we have so far.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(engine.getItems())\n5\n&gt;&gt;&gt; len(namedEngine.getItems())\n1\n</pre>\n</blockquote>\n<p>We can use the delete method of the tagging engine to delete tag\nobjects by defining the user, item or a tag name.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; u'austria' in engine.getTags()\nTrue\n&gt;&gt;&gt; engine.delete(tag=u'austria')\n&gt;&gt;&gt; u'austria' in engine.getTags()\nFalse\n</pre>\n</blockquote>\n<p>If we delete tags for a user, the tags still exists for other users.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getTags(users=(u'jodok',)))\n[u'Austria', u'USA', u'dornbirn', u'lovely',\n u'personal', u'vacation', u'work']\n&gt;&gt;&gt; engine.delete(user=u'jodok')\n&gt;&gt;&gt; sorted(engine.getTags(users=(u'jodok',)))\n[]\n&gt;&gt;&gt; sorted(engine.getTags())\n[u'Austria', u'Bizau', u'USA', u'guru', u'lovely', u'zope3']\n</pre>\n</blockquote>\n<p>This is also possible with items.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getTags(items=(3,)))\n[u'Austria', u'Bizau']\n</pre>\n</blockquote>\n<p>Let us add a tag tag from the item to another item to show the behaviour.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.update(2, u'srichter', [u'Austria'])\n&gt;&gt;&gt; engine.delete(item=3)\n&gt;&gt;&gt; sorted(engine.getTags(items=(3,)))\n[]\n</pre>\n</blockquote>\n<p>The \u2018Austria\u2019 tag is still there.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getTags())\n[u'Austria', u'USA', u'guru', u'lovely', u'zope3']\n</pre>\n</blockquote>\n<p>Let us setup the handler and events.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.component import eventtesting\n&gt;&gt;&gt; from zope import event\n&gt;&gt;&gt; from lovely.tag.engine import removeItemSubscriber\n&gt;&gt;&gt; from zope.app.intid.interfaces import IntIdRemovedEvent\n&gt;&gt;&gt; from zope.app.intid import removeIntIdSubscriber\n&gt;&gt;&gt; zope.component.provideHandler(removeItemSubscriber)\n</pre>\n</blockquote>\n<p>If we now fire the intid remove event with our image object, it should\nget removed in both engines.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(namedEngine.getItems())\n1\n&gt;&gt;&gt; len(engine.getItems())\n2\n&gt;&gt;&gt; removeIntIdSubscriber(image, None)\n&gt;&gt;&gt; len(namedEngine.getItems())\n0\n&gt;&gt;&gt; len(engine.getItems())\n1\n</pre>\n</blockquote>\n</div>\n<div id=\"removing-stale-items\">\n<h3>Removing Stale Items</h3>\n<p>You can remove stale items from the tagging engine. Stale means that\nthe item is not available anymore by the intids utility.</p>\n<p>Because we removed any objects with intids before, we have an empty\nintid utility.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(intIds.refs.keys())\n[]\n</pre>\n</blockquote>\n<p>But above we defined an item with an id that does not exist. So this\nis a stale item.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getItems())\n[2]\n</pre>\n</blockquote>\n<p>Let us add our image object again.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; tagging = tag.interfaces.ITagging(image)\n&gt;&gt;&gt; tagging.update(u'srichter', [u'newtag'])\n</pre>\n</blockquote>\n<p>This is our first and only entry in the intid util</p>\n<blockquote>\n<pre>&gt;&gt;&gt; intIds.refs.keys()[0] in engine.getItems()\nTrue\n</pre>\n</blockquote>\n<p>Our stale entry is 2. The intids of the items deleted are returned.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; 2  in engine.getItems()\nTrue\n&gt;&gt;&gt; engine.cleanStaleItems()\n[2]\n</pre>\n</blockquote>\n<p>We now only have our real image item.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; 2  in engine.getItems()\nFalse\n&gt;&gt;&gt; len(engine.getItems())\n1\n&gt;&gt;&gt; sorted(engine.getItems())[0] == intIds.refs.keys()[0]\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"renaming-tags\">\n<h3>Renaming Tags</h3>\n<p>It is also possible to rename tags globally in the engine.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; tagging.update(u'srichter', [u'tagtorename', u'usa'])\n&gt;&gt;&gt; tagging.update(u'jukart', [\n...     u'tagtorename', u'someothertag', u'renamedtag'])\n&gt;&gt;&gt; engine.update(123, 'jukart', [u'tagtorename'])\n&gt;&gt;&gt; sorted(engine.getTags())\n[u'renamedtag', u'someothertag', u'tagtorename', u'usa']\n&gt;&gt;&gt; sorted(engine.getTags(users=[u'jukart']))\n[u'renamedtag', u'someothertag', u'tagtorename']\n&gt;&gt;&gt; len(sorted(engine.getItems(tags=[u'tagtorename'])))\n2\n&gt;&gt;&gt; len(sorted(engine.getItems(tags=[u'renamedtag'])))\n1\n&gt;&gt;&gt; sorted(engine.getTags(users=[u'srichter']))\n[u'tagtorename', u'usa']\n</pre>\n</blockquote>\n<p>The rename method returns the number of renamed tag objects.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.rename(u'tagtorename', u'renamedtag')\n3\n&gt;&gt;&gt; sorted(engine.getTags())\n[u'renamedtag', u'someothertag', u'usa']\n</pre>\n</blockquote>\n<p>Tags are joined if the new name already exists.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(engine.getTags(users=[u'jukart']))\n[u'renamedtag', u'someothertag']\n&gt;&gt;&gt; sorted(engine.getTags(users=[u'srichter']))\n[u'renamedtag', u'usa']\n&gt;&gt;&gt; len(sorted(engine.getItems(tags=[u'tagtorename'])))\n0\n&gt;&gt;&gt; len(sorted(engine.getItems(tags=[u'renamedtag'])))\n2\n</pre>\n</blockquote>\n</div>\n<div id=\"normalizing-tags\">\n<h3>Normalizing Tags</h3>\n<p>It is also possible to normalize tags with a callable ojbect which\nreturns a new name for any given name.\nlower case.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.update(123, 'jukart', [u'RenamedTag', u'USA'])\n&gt;&gt;&gt; sorted(engine.getTags())\n[u'RenamedTag', u'USA', u'renamedtag', u'someothertag', u'usa']\n</pre>\n</blockquote>\n<p>Let us normalize all tags to lowercase by using the lower function\nfrom the string module.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import string\n</pre>\n</blockquote>\n<p>The normalize method returns the number of tag objects affected.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.normalize(string.lower)\n2\n&gt;&gt;&gt; sorted(engine.getTags())\n[u'renamedtag', u'someothertag', u'usa']\n</pre>\n</blockquote>\n<p>The normalize method also accepts a python dotted name, which will be\nresolved to a global object.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; engine.normalize('string.upper')\n7\n&gt;&gt;&gt; sorted(engine.getTags())\n[u'RENAMEDTAG', u'SOMEOTHERTAG', u'USA']\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"changes\">\n<h2>CHANGES</h2>\n<div id=\"id1\">\n<h3>1.1.1 (2009-11-18)</h3>\n<ul>\n<li>Renamed a conflicting \u2018zmi_views\u2019 menu entry. There were two\nentries entitled \u2018Manage\u2019. The CSVExportView became \u2018CSV Export\u2019.\n[trollfot]</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>1.1.0 (2009-11-18)</h3>\n<ul>\n<li>Fixed an important error on the tag update handling : tags were\nregistered more than once if an update was made for the same user,\nitem and tag. The issue came from the set comparison method, that\nuses the hash and not a classical cmp method. We had to introduce a\ncomparison basis we called \u201cbrain\u201d in order to get the expected\nbehavior. A test was added to emphasis this behavior. [trollfot]</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>1.0.0 (2009-07-24)</h3>\n<ul>\n<li>Fixed tests to conform to latest packages.</li>\n<li>Cleanup release boilerplate.</li>\n</ul>\n</div>\n<div id=\"b2-2007-07-18\">\n<h3>0.3.0b2 (2007-07-18)</h3>\n<ul>\n<li>in case of a not matching query lovely.tag will not longer return\nNone but an empty IFTreeSet. (this is caused because zope.app.catalog\nwill ignore None which results in a boolean or operation)</li>\n</ul>\n</div>\n<div id=\"b1-2007-06-13\">\n<h3>0.3.0b1 (2007-06-13)</h3>\n<ul>\n<li>use iobtree for tag persistence instead of persistent list and intid\nutil, should be much faster now with big numbers of tags. (this is a\nnew database generation)</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 683106, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "0072fa11fc5d87906f5e050207b98718", "sha256": "382b06beb847728fd3cb03de9438105e5e8e52f83f64be0fd90c5fedccf86bde"}, "downloads": -1, "filename": "lovely.tag-1.0.0.tar.gz", "has_sig": false, "md5_digest": "0072fa11fc5d87906f5e050207b98718", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 219898, "upload_time": "2009-07-24T20:56:41", "upload_time_iso_8601": "2009-07-24T20:56:41.465190Z", "url": "https://files.pythonhosted.org/packages/9d/86/1b52c6c892df2d3772ae22c6f2815f0fcaf6db9d9486d2a578e2000dc3de/lovely.tag-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "c8dabee891f5cbc5f32dce5aca8a046d", "sha256": "8763e27c566740331594060275db1fb8c5c4e5e954f27892e91ee3fe0d4626bb"}, "downloads": -1, "filename": "lovely.tag-1.1.0.tar.gz", "has_sig": false, "md5_digest": "c8dabee891f5cbc5f32dce5aca8a046d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 216368, "upload_time": "2009-11-18T14:40:17", "upload_time_iso_8601": "2009-11-18T14:40:17.812024Z", "url": "https://files.pythonhosted.org/packages/60/37/ef4ee305884f760153daf83cfdf467717cb210296f5a0945ca779701ec68/lovely.tag-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "b1e87d4ad0c3bc4b49fe865bb47ce086", "sha256": "47e9a1f1b105e78083cb40be1d76665a516669ae900d29e7503ba792bbbf963a"}, "downloads": -1, "filename": "lovely.tag-1.1.1.tar.gz", "has_sig": false, "md5_digest": "b1e87d4ad0c3bc4b49fe865bb47ce086", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 216610, "upload_time": "2009-11-18T17:29:14", "upload_time_iso_8601": "2009-11-18T17:29:14.352462Z", "url": "https://files.pythonhosted.org/packages/4a/0f/999f71a74dac72e9266eb411dfae2334c4a9fc4c939ebec37a2399b233ba/lovely.tag-1.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b1e87d4ad0c3bc4b49fe865bb47ce086", "sha256": "47e9a1f1b105e78083cb40be1d76665a516669ae900d29e7503ba792bbbf963a"}, "downloads": -1, "filename": "lovely.tag-1.1.1.tar.gz", "has_sig": false, "md5_digest": "b1e87d4ad0c3bc4b49fe865bb47ce086", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 216610, "upload_time": "2009-11-18T17:29:14", "upload_time_iso_8601": "2009-11-18T17:29:14.352462Z", "url": "https://files.pythonhosted.org/packages/4a/0f/999f71a74dac72e9266eb411dfae2334c4a9fc4c939ebec37a2399b233ba/lovely.tag-1.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:43:40 2020"}