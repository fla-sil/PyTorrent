{"info": {"author": "Lukas Prokop", "author_email": "admin@lukas-prokop.at", "bugtrack_url": null, "classifiers": ["Development Status :: 6 - Mature", "Environment :: Console", "Intended Audience :: Developers", "Intended Audience :: Education", "Intended Audience :: Science/Research", "License :: Public Domain", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3 :: Only", "Topic :: Scientific/Engineering"], "description": "cnf-hash-py\n===========\n\n:author:        Lukas Prokop\n:date:          August 2015, May 2016\n:version:       2.1.2\n:license:       CC-0\n\nA python3 implementation to hash DIMACS CNF files.\nSee `the technical report <http://lukas-prokop.at/proj/megosat/downloads/cnf-hash.pdf>`_ for more details.\nThis implementation was pushed to `Python Package Index PyPI <https://pypi.python.org/pypi/cnfhash>`_.\n\nHow to use\n----------\n\nTo install use pip3::\n\n    pip3 install cnfhash\n\nThen you can use the following API in python3::\n\n    import cnfhash\n\n    # reading blockwise from a DIMACS file\n\n    def read_blockwise(filepath):\n        with open(filepath) as fd:\n            while True:\n                buf = fd.read(4096)\n                if len(buf) == 0:\n                    break\n                yield buf\n\n    reader = read_blockwise('test.cnf')\n    print(cnfhash.hash_dimacs(reader))\n\n    # or use integers directly\n\n    print(cnfhash.hash_cnf([3, 2, 1, -3, 0, -1, 2, 0]))\n\nTesting the software\n--------------------\n\nDownload `the testsuite <http://github.com/prokls/cnf-hash-tests1/>`_.\nProvide the folder location as environment variable::\n\n    export TESTSUITE=\"/home/prokls/Downloads/cnf-hash/tests1/\"\n\nThen run all files in the ``tests`` directory::\n\n    python3 tests/test_testsuite.py\n\nThe testsuite has been run successfully, if the exit code has always been 0.\n\nDIMACS file assumptions\n-----------------------\n\nA DIMACS file is valid iff\n\n1. Any line starting with \"c\" or consisting only of whitespace is considered as *comment line* and content is not interpreted until the next newline character occurs.\n2. The remaining file is a sequence of whitespace separated values.\n\n   1. The first value is required to be \"p\"\n   2. The second value is required to be \"cnf\"\n   3. The third value is required to be a non-negative integer and called *nbvars*.\n   4. The fourth value is required to be a non-negative integer and called *nbclauses*.\n   5. The remaining non-zero integers are called *lits*.\n   6. The remaining zero integers are called *clause terminators*.\n\n3. A DIMACS file must be terminated by a clause terminator.\n4. Every lit must satisfy ``-nbvars \u2264 lit \u2264 nbvars``.\n5. The number of clause terminators must equate nbclauses.\n\n============== =========================================\n**term**       **ASCII mapping**\n-------------- -----------------------------------------\n\"c\"            U+0063\n\"p\"            U+0070\n\"cnf\"          U+0063 U+006E U+0066 U+0020\nsign           U+002D\nnonzero digit  U+0031 \u2013 U+0039\ndigits         U+0030 \u2013 U+0039\nwhitespace     U+0020, U+000D, U+000A, U+0009\nzero           U+0030\n============== =========================================\n\nFormal specification\n--------------------\n\nA valid DIMACS file is read in and a SHA1 instance is fed with bytes:\n\n1. The first four values are dropped.\n2. Lits are treated as integers without leading zeros. Integers are submitted as base 10 ASCII digits with an optional leading sign to the SHA1 instance.\n3. Clause terminators are submitted as zero character followed by a newline character to the SHA1 instance.\n\nPerformance and memory\n----------------------\n\nThe DIMACS parser uses OS' page size as default block size.\nA few constant values and the python runtime is also stored in memory.\nSo for a python program, this implementation is very memory-friendly.\n\nThe technical report shows that 45 DIMACS files summing up to 1 GB memory\ncan be read in 2989 seconds. In terms of performance, the equivalent `Go\nimplementation <http://github.com/prokls/cnf-hash-go/>`_ is recommended.\n\nExample\n-------\n\n::\n\n    % cat test.cnf\n    p cnf 5 6\n    1 2 3 0\n    2 3 -4 0\n    1 -2 0\n    -1 2 0\n    1 3 5 0\n    1 -4 -5 0\n    % cnf-hash-py test.cnf\n    cnf-hash-py 2.1.2 2016-05-29T12:27:13.991260 /root\n    cnf2$776d81a0c805104e265667917b22ffefe9f39433  test.cnf\n    %\n\nCheers!", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://lukas-prokop.at/proj/cnf-hash/", "keywords": null, "license": "Public Domain", "maintainer": null, "maintainer_email": null, "name": "cnfhash", "package_url": "https://pypi.org/project/cnfhash/", "platform": "any", "project_url": "https://pypi.org/project/cnfhash/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://lukas-prokop.at/proj/cnf-hash/"}, "release_url": "https://pypi.org/project/cnfhash/2.1.2/", "requires_dist": null, "requires_python": null, "summary": "CNF hashing implemented in python3", "version": "2.1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <table>\n<col>\n<col>\n<tbody>\n<tr><th>Author:</th>\n<td>Lukas Prokop</td></tr>\n<tr><th>Date:</th>\n<td>August 2015, May 2016</td></tr>\n<tr><th>Version:</th>\n<td>2.1.2</td></tr>\n<tr><th>license:</th><td>CC-0</td>\n</tr>\n</tbody>\n</table>\n<p>A python3 implementation to hash DIMACS CNF files.\nSee <a href=\"http://lukas-prokop.at/proj/megosat/downloads/cnf-hash.pdf\" rel=\"nofollow\">the technical report</a> for more details.\nThis implementation was pushed to <a href=\"https://pypi.python.org/pypi/cnfhash\" rel=\"nofollow\">Python Package Index PyPI</a>.</p>\n<div id=\"how-to-use\">\n<h2>How to use</h2>\n<p>To install use pip3:</p>\n<pre>pip3 install cnfhash\n</pre>\n<p>Then you can use the following API in python3:</p>\n<pre>import cnfhash\n\n# reading blockwise from a DIMACS file\n\ndef read_blockwise(filepath):\n    with open(filepath) as fd:\n        while True:\n            buf = fd.read(4096)\n            if len(buf) == 0:\n                break\n            yield buf\n\nreader = read_blockwise('test.cnf')\nprint(cnfhash.hash_dimacs(reader))\n\n# or use integers directly\n\nprint(cnfhash.hash_cnf([3, 2, 1, -3, 0, -1, 2, 0]))\n</pre>\n</div>\n<div id=\"testing-the-software\">\n<h2>Testing the software</h2>\n<p>Download <a href=\"http://github.com/prokls/cnf-hash-tests1/\" rel=\"nofollow\">the testsuite</a>.\nProvide the folder location as environment variable:</p>\n<pre>export TESTSUITE=\"/home/prokls/Downloads/cnf-hash/tests1/\"\n</pre>\n<p>Then run all files in the <tt>tests</tt> directory:</p>\n<pre>python3 tests/test_testsuite.py\n</pre>\n<p>The testsuite has been run successfully, if the exit code has always been 0.</p>\n</div>\n<div id=\"dimacs-file-assumptions\">\n<h2>DIMACS file assumptions</h2>\n<p>A DIMACS file is valid iff</p>\n<ol>\n<li>Any line starting with \u201cc\u201d or consisting only of whitespace is considered as <em>comment line</em> and content is not interpreted until the next newline character occurs.</li>\n<li>The remaining file is a sequence of whitespace separated values.<ol>\n<li>The first value is required to be \u201cp\u201d</li>\n<li>The second value is required to be \u201ccnf\u201d</li>\n<li>The third value is required to be a non-negative integer and called <em>nbvars</em>.</li>\n<li>The fourth value is required to be a non-negative integer and called <em>nbclauses</em>.</li>\n<li>The remaining non-zero integers are called <em>lits</em>.</li>\n<li>The remaining zero integers are called <em>clause terminators</em>.</li>\n</ol>\n</li>\n<li>A DIMACS file must be terminated by a clause terminator.</li>\n<li>Every lit must satisfy <tt><span class=\"pre\">-nbvars</span> \u2264 lit \u2264 nbvars</tt>.</li>\n<li>The number of clause terminators must equate nbclauses.</li>\n</ol>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><td><strong>term</strong></td>\n<td><strong>ASCII mapping</strong></td>\n</tr>\n<tr><td>\u201cc\u201d</td>\n<td>U+0063</td>\n</tr>\n<tr><td>\u201cp\u201d</td>\n<td>U+0070</td>\n</tr>\n<tr><td>\u201ccnf\u201d</td>\n<td>U+0063 U+006E U+0066 U+0020</td>\n</tr>\n<tr><td>sign</td>\n<td>U+002D</td>\n</tr>\n<tr><td>nonzero digit</td>\n<td>U+0031 \u2013 U+0039</td>\n</tr>\n<tr><td>digits</td>\n<td>U+0030 \u2013 U+0039</td>\n</tr>\n<tr><td>whitespace</td>\n<td>U+0020, U+000D, U+000A, U+0009</td>\n</tr>\n<tr><td>zero</td>\n<td>U+0030</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"formal-specification\">\n<h2>Formal specification</h2>\n<p>A valid DIMACS file is read in and a SHA1 instance is fed with bytes:</p>\n<ol>\n<li>The first four values are dropped.</li>\n<li>Lits are treated as integers without leading zeros. Integers are submitted as base 10 ASCII digits with an optional leading sign to the SHA1 instance.</li>\n<li>Clause terminators are submitted as zero character followed by a newline character to the SHA1 instance.</li>\n</ol>\n</div>\n<div id=\"performance-and-memory\">\n<h2>Performance and memory</h2>\n<p>The DIMACS parser uses OS\u2019 page size as default block size.\nA few constant values and the python runtime is also stored in memory.\nSo for a python program, this implementation is very memory-friendly.</p>\n<p>The technical report shows that 45 DIMACS files summing up to 1 GB memory\ncan be read in 2989 seconds. In terms of performance, the equivalent <a href=\"http://github.com/prokls/cnf-hash-go/\" rel=\"nofollow\">Go\nimplementation</a> is recommended.</p>\n</div>\n<div id=\"example\">\n<h2>Example</h2>\n<pre>% cat test.cnf\np cnf 5 6\n1 2 3 0\n2 3 -4 0\n1 -2 0\n-1 2 0\n1 3 5 0\n1 -4 -5 0\n% cnf-hash-py test.cnf\ncnf-hash-py 2.1.2 2016-05-29T12:27:13.991260 /root\ncnf2$776d81a0c805104e265667917b22ffefe9f39433  test.cnf\n%\n</pre>\n<p>Cheers!</p>\n</div>\n\n          </div>"}, "last_serial": 2234907, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "49ac6e6abea7f773a874c28ae234664e", "sha256": "81f73f019b66f5533e85da41f7d9c8d103fefea1901b33271dfad4d8ba539c42"}, "downloads": -1, "filename": "cnfhash-1.0.0.tar.gz", "has_sig": false, "md5_digest": "49ac6e6abea7f773a874c28ae234664e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7124, "upload_time": "2016-05-29T13:13:22", "upload_time_iso_8601": "2016-05-29T13:13:22.371470Z", "url": "https://files.pythonhosted.org/packages/7d/76/6b14263704633c25d5ad9f791d3d1da86fcaa0007257815e3f56750c45eb/cnfhash-1.0.0.tar.gz", "yanked": false}], "2.1.2": [{"comment_text": "", "digests": {"md5": "06988f53a73181583e7dcfedc31abdeb", "sha256": "3fd452e9085626b121c9d1e52a836eb5ef6c3ae777de3b115f36e8b2006b9eec"}, "downloads": -1, "filename": "cnfhash-2.1.2.tar.gz", "has_sig": false, "md5_digest": "06988f53a73181583e7dcfedc31abdeb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6152, "upload_time": "2016-07-21T00:53:15", "upload_time_iso_8601": "2016-07-21T00:53:15.428668Z", "url": "https://files.pythonhosted.org/packages/f5/25/bdc9113c7fea4d23d239a3de23505e7b50d7be1fdb7e12437cfefd380d8b/cnfhash-2.1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "06988f53a73181583e7dcfedc31abdeb", "sha256": "3fd452e9085626b121c9d1e52a836eb5ef6c3ae777de3b115f36e8b2006b9eec"}, "downloads": -1, "filename": "cnfhash-2.1.2.tar.gz", "has_sig": false, "md5_digest": "06988f53a73181583e7dcfedc31abdeb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6152, "upload_time": "2016-07-21T00:53:15", "upload_time_iso_8601": "2016-07-21T00:53:15.428668Z", "url": "https://files.pythonhosted.org/packages/f5/25/bdc9113c7fea4d23d239a3de23505e7b50d7be1fdb7e12437cfefd380d8b/cnfhash-2.1.2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:18:28 2020"}