{"info": {"author": "Brendan W. McAdams", "author_email": "bwmcadams@evilmonkeylabs.com", "bugtrack_url": null, "classifiers": [], "description": "===============\nSocketTornad.IO\n===============\n\nRelease 0.1.3\n^^^^^^^^^^^^^\n\nContributors\n------------\n- Brendan W. McAdams bwmcadams@evilmonkeylabs.com\n- `Matt Swanson <http://github.com/swanson>`_\n\n\nLicense\n-------\n  Copyright (c) 2010, Brendan W. McAdams & Novus Partners, Inc. <http://novus.com> \n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n\n\n\nImplementation of the `Socket.IO <http://socket.io>`_ Websocket\nemulation protocol in Python on top of the non-blocking\n`Tornado Web Framework <http://www.tornadoweb.org/>`_. Socket.IO is\na JavaScript library for providing full emulation of Websockets for\nbrowsers which don't support it. While the client-side programmer\ncodes as if they have a constantly open bi-directional\ncommunication channel, Socket.IO will (if the browser doesn't\nsupport Websockets) use several fallback protocols to provide the\nbehavior. These fallback protocols require a negotiation between\nthe client and server to determine an agreeable protocol; the\n`reference implementation <http://github.com/learnboost/socket.io-node>`_\nof the server is done in Node.JS which was less than agreeable to\nour needs. There are also implementations in Ruby Rack and Go but\nwe rejected those for simlar reasons to Node.JS.\n\nThis version is designed for making\n`Pythonistas <http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html>`_\nhappy.\n\nImplementing SocketTornad.IO\n----------------------------\n\nAs a user your only major requirement is to subclass\n``tornad_io.socket_io.SocketIOHandler``. This base class provides\nTornado Handler logic for the entire Socket.IO protocol - it\nautomatically responds to protocol handshakes and notifies you of\nthree events, represented by Python methods on your class:\n\n\n1. ``on_open``: Called when a Socket.IO handshake completes\n   successfully and a client is brought online. Gets a copy of the\n   ``*args`` and ``**kwargs`` from the request... can be used for you\n   as a user to do further authentication of the connection. By way of\n   example, we lookup certain authorization information once a\n   connection finishes and decide if we'll allow the connection to\n   continue.\n   **This is not a required method - you need not implement it if you don't care about it.**\n2. ``on_close``: Called when a Socket.IO connection is fully\n   closed. Passes no arguments, but lets you do any cleanup of\n   database handles, etc.\n   **This is not a required method - you need not implement it if you don't care about it.**\n3. ``on_message``: The main method. This is invoked whenever the\n   browser client sends a message. It is automatically decoded, and\n   any JSON will be passed as a fully parsed Python object. This\n   method receives a single argument of ``message`` which contains the\n   parsed message. You can respond with the ``self.send`` method (see\n   below)\n\nYou can send messages to the client by use of the ``self.send``\nmethod. This takes a single argument of ``message`` and transmits\nit to the client. If you pass a string it will be pased \"as is\" to\nthe browser; if you want to send JSON you should pass a ``dict``\nin, which will be JSON encoded and marked as JSON in the Socket.IO\nwire format. An Object is also acceptable as long as *simplejson*\nis able to encode it to JSON.\n\nThere *is* fallback code for the JSON import - if you don't have\n``simplejson`` installed it will import the ``json`` module (based\non ``simplejson``) which has been included with Python since 2.6\ninstead (thanks to `swanson <http://github.com/swanson>`_ for the\npatch). However, the version of ``json`` which ships with Python\nlacks built in support for encoding ``decimal.Decimal`` objects,\nwhich is why we prefer (as specified in ``setup.py``)\n``simplejson >= 2.1``. If you do not have an appropriate version of\n``simplejson`` installed and try to send an object or ``dict``\ncontaining ``decimal.Decimal`` instances to the client, you may\nencounter errors.\n\nFor those of you who know Tornado already, do *not* call the\n``self.write`` method unless you want things to act weird.\n``self.write`` still (in the current iteration) sends raw data to\nthe client - but Socket.IO uses a wire format which requires\ncertain encoding. Anything you pass via ``self.write`` will likely\nnot be understood by the client.\n\nThis is an example handler:\n\n::\n\n    class EchoHandler(SocketIOHandler):\n        def on_open(self, *args, **kwargs):\n            logging.info(\"Socket.IO Client connected with protocol '%s' {session id: '%s'}\" % (self.protocol, self.session.id))\n            logging.info(\"Extra Data for Open: '%s'\" % (kwargs.get('extra', None)))\n    \n        def on_message(self, message):\n            logging.info(\"[echo] %s\" % message)\n            self.send(\"[echo] %s\" % message)\n    \n        def on_close(self):\n            logging.info(\"Closing Socket.IO Client for protocol '%s'\" % (self.protocol))\n\nThis handler is meant to be simple: It merely echoes back any\nmessage it receives to the client. Were you to test this in your\nbrowser your console will reflect back what you send:\n\n::\n\n    > socket.send(\"OMG! Ponies!\")\n    [echo] OMG! Ponies!\n\n(In this case I have my test page set to print any messages to\n``console.log()``.)\n\nUseful properties\n-----------------\n\nEvery subclass of ``SocketIOHandler`` has a few useful properties\nattached to it:\n\n\n-  ``protocol``: This is a string containing the name of the\n   protocol currently being used to communicate with the client.\n-  ``session``: This is a `Beaker <http://beaker.groovie.org>`_\n   Session object which can be used to track information about the\n   connection in question. We use it internally to direct output to\n   the right place in polling. Feel free to save your own data - just\n   make sure to call ``self.session.save()`` if you modify it or your\n   changes will be lost.\n\nConfiguring SocketTornad.IO\n---------------------------\n\nRoutes (e.g. how clients access you)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIt is necessary in Tornado set up your 'resources' (known in some\nframeworks as 'routes') which define what paths are valid and what\ncontrollers handle the request. Because the paths Socket.IO uses to\nnegotiate the connection and speak (esp. in the fallback protocols)\nare hairy, we have instead created a ClassMethod on\n``SocketIOHandler`` which allows you to easily get the correct\nroute for your service:\n\n::\n\n    echoRoute = EchoHandler.routes(\"echoTest\", \"(?P<sec_a>123)(?P<sec_b>.*)\", extraSep='/')\n\nThis returns the data structure which Tornado expects to configure\nitself, with all requests for '/echoTest' pointed at the\nEchoHandler class. For the curious, the structure returned looks\nlike this:\n\n::\n\n    ('/(?P<resource>echoTest)/(?P<extra>(?P<sec_a>123)(?P<sec_b>.*))/(?P<protocol>(websocket|xhr-multipart|htmlfile|jsonp-polling|flashsocket|xhr-polling))/?(?P<session_id>[0-9a-zA-Z]*?)/?((?P<protocol_init>\\\\d*?)|(?P<xhr_path>\\\\w*?))/?(?P<jsonp_index>\\\\d*?)', <class 'tornad_io.EchoHandler'>)\n\nHence the ``routes`` classmethod to easily configure with...\n``resource`` can be any valid string, including, if necessary, a\nRegular Expression. Any requests beginning with your ``resource``\nparameter will be routed to ``EchoHandler`` for processing. The\nadditional cruft in there are regular expressions to handle the\nmyriad of extra path information Socket.IO ships to find a valid\nprotocol.\n\nWe also accept two additional optional parameters to configure\nroutes (only the ``resource`` parameter is required).\n\n\n-  ``extraRE`` is an optional string containing a regular\n   expression for 'extra' information to capture on the URL. In my\n   case, I have a PHP process pass an authenticated secure token to\n   the Tornado process on each request to help identify and authorize\n   a user. I pass this as part of the Socket.IO ``resource`` - while\n   my Tornado resource is configured as 'echoTest', I want to capture\n   and separate the additional secure token. By setting up an\n   ``extraRE`` SocketTornad.IO will automatically save the extra data\n   in ``**kwargs['extra']`` - specifically accessible in ``on_open``\n   for further authentication. You *MAY* put capture groups inside\n   ``extraRE`` - if you name them they are available from ``on_open``\n   in ``**kwargs``, otherwise they will be in unnamed buckets inside\n   of ``*args*``.\n\n-  ``extraSep`` indicates a character to separate the 'base'\n   ``resource`` and ``extraRE`` with. By default there is none - they\n   are expected to run together. I typically set ``extraSep`` to a '/'\n   character.\n\n\nAfter that you simply need to pass the configured route to\nTornado:\n\n::\n\n    application = tornado.web.Application([\n        echoRoute\n    ])\n\nService Settings (ports, etc)\n-----------------------------\n\nYou can configure the service very easily by passing arguments into\nthe Tornado application object. There are currently 4 user\nconfigurable properties:\n\n\n-  **enabled\\_protocols**: This is a ``list`` of the Socket.IO\n   protocols the server will respond to requests for. Clients try them\n   one by one until the server and client both find one they both\n   support. The possibilities are:\n-  *websocket*: Standard HTML5 Spec Websockets. Our implementation\n   uses the one built into Tornado with a slight tweak to message\n   receipt to enable decoding of the special Socket.IO wire encoding\n   format. (Works in Chrome and any other browser with native\n   Websocket support)\n-  *flashsocket*: HTML5 Websockets emulated in Flash for older\n   browsers like Firefox. *EXACTLY* the same implementation wise to\n   *websocket*, but starts up a Flash policy server which is necessary\n   for Flash sockets to work. (Tested in IE8, and Firefox 3)\n-  *xhr-multipart*: XMLHTTPRequest (AJAX) Multipart messaging.\n   Opens and long polls a GET request to send from server to client,\n   client sends a POST to send client to server. Uses multipart &\n   chunking to send a continuous stream of messages down the same open\n   GET channel. Best option after *websocket*/*flashsocket*. (Tested\n   in IE8, Firefox 3 and Chrome)\n-  *xhr-polling*: XMLHTTPRequest (AJAX) Long Polling. Client polls\n   on a GET until a message is available, closes the GET after getting\n   a message and then opens a new one until a message is available.\n   (Tested in IE8, Firefox 3 - does NOT work with Chrome at all)\n-  *jsonp-polling*: Identical protocol to *xhr-polling* but pushes\n   Javascript script data via JSONp. (Tested in IE8, Firefox 3 - does\n   NOT work with Chrome at all)\n-  *htmlfile*: Appears to be for much older IE browsers w/o proper\n   AJAX support, creates an AJAX HTMLFile control and does some iframe\n   nastiness. I haven't found a browser that properly supports this so\n   if you test it let me know ... Copied implementation from reference\n   Node code.\n\nThe default setting is to enable *ALL* protocols, i.e.:\n\n::\n\n        ['websocket', 'flashsocket', 'xhr-multipart', 'xhr-polling', 'jsonp-polling', 'htmlfile']\n\n\n-  **socket\\_io\\_port**: The port for the Socket IO Server to\n   listen on.\n   *This configuration setting is ignored unless you explicitly use the ``SocketIOServer`` class to start Tornado (See below).*\n-  **flash\\_policy\\_file** A fully qualified path to a Flash Policy\n   XML File. A default permissive one is included in this distribution\n   as ``flashpolicy.xml``; by default the Flash service looks for\n   ``flashpolicy.xml`` in the same directory as the current execution.\n   *This configuration setting is ignored unless you explicitly use the ``SocketIOServer`` class to start Tornado (See below).*\n-  **flash\\_policy\\_port** The port for the Flash policy server to\n   listen on. This defaults to port **843** - Flash absolutely\n   *will not* connect to any other port so if you change this, make\n   sure you setup a portmap on the frontend. Without a valid policy\n   service Flash fallback sockets will not work.\n   *This configuration setting is ignored unless you explicitly use the ``SocketIOServer`` class to start Tornado (See below).*\n\nConfiguring these settings is done by passing them to the\n``tornado.web.Application`` constructor as kwargs:\n\n::\n\n    application = tornado.web.Application([\n        echoRoute \n    ], enabled_protocols=['websocket', 'flashsocket', 'xhr-multipart', 'xhr-polling'],\n       flash_policy_port=8043, flash_policy_file='/etc/lighttpd/flashpolicy.xml', socket_io_port=8888)\n\nStarting Up\n-----------\n\nBest Way: SocketIOServer\n^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe SocketTornad.IO distribution contains a modified version of the\nTornado ``HTTPServer`` class designed to automatically read the\nnecessary configuration settings and start everything up. If\n``flashsocket`` is enabled it will start the Flash Policy server,\nand it starts the Socket.IO Service for you (as opposed to you\nstarting it up manually).\n\nAssuming you set the configuration options on your ``Application``\ninstance (or are happy with the defaults) you need merely\ninstantiate a ``tornad_io.SocketIOServer``:\n\n::\n\n    if __name__ == \"__main__\":\n        socketio_server = SocketIOServer(application)\n\nStarting Manually\n^^^^^^^^^^^^^^^^^\n\nIf you'd like more control over how you start everything up you can\nstart things manually, similar to the\n`Tornado Docs <http://www.tornadoweb.org/documentation>`_. This\nrequires booting the IOLoop yourself:\n\n::\n\n    if __name__ == \"__main__\":\n        flash_policy = tornad_io.websocket.flash.FlashPolicyServer(port=8043, policy_file=\"/etc/lighttpd/flashpolicy.xml\")\n        http_server = tornado.httpserver.HTTPServer(application)\n        http_server.listen(8888)\n        tornado.ioloop.IOLoop.instance().start()\n\nExamples\n--------\n\nChatroom Example\n^^^^^^^^^^^^^^^^\n\nThere is a chatroom example application contributed by\n`swanson <http://github.com/swanson>`_. It is in the\n``examples/chatroom`` directory. For instructions, please see its\n`README <http://github.com/novus/SocketTornad.IO/blob/master/examples/chatroom/README.md>`_.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/SocketTornadIO/SocketTornad.IO", "keywords": null, "license": "Copyright (c) 2010, Brendan W. McAdams & Novus Partners, Inc. <http://novus.com> \n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.", "maintainer": null, "maintainer_email": null, "name": "SocketTornad.IO", "package_url": "https://pypi.org/project/SocketTornad.IO/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/SocketTornad.IO/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/SocketTornadIO/SocketTornad.IO"}, "release_url": "https://pypi.org/project/SocketTornad.IO/0.1.3/", "requires_dist": null, "requires_python": null, "summary": "Python implementation of the Socket.IO protocol for the Tornado webserver/framework.", "version": "0.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"release-0-1-3\">\n<h2>Release 0.1.3</h2>\n<div id=\"contributors\">\n<h3>Contributors</h3>\n<ul>\n<li>Brendan W. McAdams <a href=\"mailto:bwmcadams%40evilmonkeylabs.com\">bwmcadams<span>@</span>evilmonkeylabs<span>.</span>com</a></li>\n<li><a href=\"http://github.com/swanson\" rel=\"nofollow\">Matt Swanson</a></li>\n</ul>\n</div>\n<div id=\"license\">\n<h3>License</h3>\n<blockquote>\n<p>Copyright (c) 2010, Brendan W. McAdams &amp; Novus Partners, Inc. &lt;<a href=\"http://novus.com\" rel=\"nofollow\">http://novus.com</a>&gt;</p>\n<p>Licensed under the Apache License, Version 2.0 (the \u201cLicense\u201d);\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at</p>\n<blockquote>\n<a href=\"http://www.apache.org/licenses/LICENSE-2.0\" rel=\"nofollow\">http://www.apache.org/licenses/LICENSE-2.0</a></blockquote>\n<p>Unless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \u201cAS IS\u201d BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.</p>\n</blockquote>\n<p>Implementation of the <a href=\"http://socket.io\" rel=\"nofollow\">Socket.IO</a> Websocket\nemulation protocol in Python on top of the non-blocking\n<a href=\"http://www.tornadoweb.org/\" rel=\"nofollow\">Tornado Web Framework</a>. Socket.IO is\na JavaScript library for providing full emulation of Websockets for\nbrowsers which don\u2019t support it. While the client-side programmer\ncodes as if they have a constantly open bi-directional\ncommunication channel, Socket.IO will (if the browser doesn\u2019t\nsupport Websockets) use several fallback protocols to provide the\nbehavior. These fallback protocols require a negotiation between\nthe client and server to determine an agreeable protocol; the\n<a href=\"http://github.com/learnboost/socket.io-node\" rel=\"nofollow\">reference implementation</a>\nof the server is done in Node.JS which was less than agreeable to\nour needs. There are also implementations in Ruby Rack and Go but\nwe rejected those for simlar reasons to Node.JS.</p>\n<p>This version is designed for making\n<a href=\"http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html\" rel=\"nofollow\">Pythonistas</a>\nhappy.</p>\n</div>\n<div id=\"implementing-sockettornad-io\">\n<h3>Implementing SocketTornad.IO</h3>\n<p>As a user your only major requirement is to subclass\n<tt>tornad_io.socket_io.SocketIOHandler</tt>. This base class provides\nTornado Handler logic for the entire Socket.IO protocol - it\nautomatically responds to protocol handshakes and notifies you of\nthree events, represented by Python methods on your class:</p>\n<ol>\n<li><tt>on_open</tt>: Called when a Socket.IO handshake completes\nsuccessfully and a client is brought online. Gets a copy of the\n<tt>*args</tt> and <tt>**kwargs</tt> from the request\u2026 can be used for you\nas a user to do further authentication of the connection. By way of\nexample, we lookup certain authorization information once a\nconnection finishes and decide if we\u2019ll allow the connection to\ncontinue.\n<strong>This is not a required method - you need not implement it if you don\u2019t care about it.</strong></li>\n<li><tt>on_close</tt>: Called when a Socket.IO connection is fully\nclosed. Passes no arguments, but lets you do any cleanup of\ndatabase handles, etc.\n<strong>This is not a required method - you need not implement it if you don\u2019t care about it.</strong></li>\n<li><tt>on_message</tt>: The main method. This is invoked whenever the\nbrowser client sends a message. It is automatically decoded, and\nany JSON will be passed as a fully parsed Python object. This\nmethod receives a single argument of <tt>message</tt> which contains the\nparsed message. You can respond with the <tt>self.send</tt> method (see\nbelow)</li>\n</ol>\n<p>You can send messages to the client by use of the <tt>self.send</tt>\nmethod. This takes a single argument of <tt>message</tt> and transmits\nit to the client. If you pass a string it will be pased \u201cas is\u201d to\nthe browser; if you want to send JSON you should pass a <tt>dict</tt>\nin, which will be JSON encoded and marked as JSON in the Socket.IO\nwire format. An Object is also acceptable as long as <em>simplejson</em>\nis able to encode it to JSON.</p>\n<p>There <em>is</em> fallback code for the JSON import - if you don\u2019t have\n<tt>simplejson</tt> installed it will import the <tt>json</tt> module (based\non <tt>simplejson</tt>) which has been included with Python since 2.6\ninstead (thanks to <a href=\"http://github.com/swanson\" rel=\"nofollow\">swanson</a> for the\npatch). However, the version of <tt>json</tt> which ships with Python\nlacks built in support for encoding <tt>decimal.Decimal</tt> objects,\nwhich is why we prefer (as specified in <tt>setup.py</tt>)\n<tt>simplejson &gt;= 2.1</tt>. If you do not have an appropriate version of\n<tt>simplejson</tt> installed and try to send an object or <tt>dict</tt>\ncontaining <tt>decimal.Decimal</tt> instances to the client, you may\nencounter errors.</p>\n<p>For those of you who know Tornado already, do <em>not</em> call the\n<tt>self.write</tt> method unless you want things to act weird.\n<tt>self.write</tt> still (in the current iteration) sends raw data to\nthe client - but Socket.IO uses a wire format which requires\ncertain encoding. Anything you pass via <tt>self.write</tt> will likely\nnot be understood by the client.</p>\n<p>This is an example handler:</p>\n<pre>class EchoHandler(SocketIOHandler):\n    def on_open(self, *args, **kwargs):\n        logging.info(\"Socket.IO Client connected with protocol '%s' {session id: '%s'}\" % (self.protocol, self.session.id))\n        logging.info(\"Extra Data for Open: '%s'\" % (kwargs.get('extra', None)))\n\n    def on_message(self, message):\n        logging.info(\"[echo] %s\" % message)\n        self.send(\"[echo] %s\" % message)\n\n    def on_close(self):\n        logging.info(\"Closing Socket.IO Client for protocol '%s'\" % (self.protocol))\n</pre>\n<p>This handler is meant to be simple: It merely echoes back any\nmessage it receives to the client. Were you to test this in your\nbrowser your console will reflect back what you send:</p>\n<pre>&gt; socket.send(\"OMG! Ponies!\")\n[echo] OMG! Ponies!\n</pre>\n<p>(In this case I have my test page set to print any messages to\n<tt>console.log()</tt>.)</p>\n</div>\n<div id=\"useful-properties\">\n<h3>Useful properties</h3>\n<p>Every subclass of <tt>SocketIOHandler</tt> has a few useful properties\nattached to it:</p>\n<ul>\n<li><tt>protocol</tt>: This is a string containing the name of the\nprotocol currently being used to communicate with the client.</li>\n<li><tt>session</tt>: This is a <a href=\"http://beaker.groovie.org\" rel=\"nofollow\">Beaker</a>\nSession object which can be used to track information about the\nconnection in question. We use it internally to direct output to\nthe right place in polling. Feel free to save your own data - just\nmake sure to call <tt>self.session.save()</tt> if you modify it or your\nchanges will be lost.</li>\n</ul>\n</div>\n<div id=\"configuring-sockettornad-io\">\n<h3>Configuring SocketTornad.IO</h3>\n</div>\n</div>\n<div id=\"routes-e-g-how-clients-access-you\">\n<h2>Routes (e.g. how clients access you)</h2>\n<p>It is necessary in Tornado set up your \u2018resources\u2019 (known in some\nframeworks as \u2018routes\u2019) which define what paths are valid and what\ncontrollers handle the request. Because the paths Socket.IO uses to\nnegotiate the connection and speak (esp. in the fallback protocols)\nare hairy, we have instead created a ClassMethod on\n<tt>SocketIOHandler</tt> which allows you to easily get the correct\nroute for your service:</p>\n<pre>echoRoute = EchoHandler.routes(\"echoTest\", \"(?P&lt;sec_a&gt;123)(?P&lt;sec_b&gt;.*)\", extraSep='/')\n</pre>\n<p>This returns the data structure which Tornado expects to configure\nitself, with all requests for \u2018/echoTest\u2019 pointed at the\nEchoHandler class. For the curious, the structure returned looks\nlike this:</p>\n<pre>('/(?P&lt;resource&gt;echoTest)/(?P&lt;extra&gt;(?P&lt;sec_a&gt;123)(?P&lt;sec_b&gt;.*))/(?P&lt;protocol&gt;(websocket|xhr-multipart|htmlfile|jsonp-polling|flashsocket|xhr-polling))/?(?P&lt;session_id&gt;[0-9a-zA-Z]*?)/?((?P&lt;protocol_init&gt;\\\\d*?)|(?P&lt;xhr_path&gt;\\\\w*?))/?(?P&lt;jsonp_index&gt;\\\\d*?)', &lt;class 'tornad_io.EchoHandler'&gt;)\n</pre>\n<p>Hence the <tt>routes</tt> classmethod to easily configure with\u2026\n<tt>resource</tt> can be any valid string, including, if necessary, a\nRegular Expression. Any requests beginning with your <tt>resource</tt>\nparameter will be routed to <tt>EchoHandler</tt> for processing. The\nadditional cruft in there are regular expressions to handle the\nmyriad of extra path information Socket.IO ships to find a valid\nprotocol.</p>\n<p>We also accept two additional optional parameters to configure\nroutes (only the <tt>resource</tt> parameter is required).</p>\n<ul>\n<li><tt>extraRE</tt> is an optional string containing a regular\nexpression for \u2018extra\u2019 information to capture on the URL. In my\ncase, I have a PHP process pass an authenticated secure token to\nthe Tornado process on each request to help identify and authorize\na user. I pass this as part of the Socket.IO <tt>resource</tt> - while\nmy Tornado resource is configured as \u2018echoTest\u2019, I want to capture\nand separate the additional secure token. By setting up an\n<tt>extraRE</tt> SocketTornad.IO will automatically save the extra data\nin <tt><span class=\"pre\">**kwargs['extra']</span></tt> - specifically accessible in <tt>on_open</tt>\nfor further authentication. You <em>MAY</em> put capture groups inside\n<tt>extraRE</tt> - if you name them they are available from <tt>on_open</tt>\nin <tt>**kwargs</tt>, otherwise they will be in unnamed buckets inside\nof <tt>*args*</tt>.</li>\n<li><tt>extraSep</tt> indicates a character to separate the \u2018base\u2019\n<tt>resource</tt> and <tt>extraRE</tt> with. By default there is none - they\nare expected to run together. I typically set <tt>extraSep</tt> to a \u2018/\u2019\ncharacter.</li>\n</ul>\n<p>After that you simply need to pass the configured route to\nTornado:</p>\n<pre>application = tornado.web.Application([\n    echoRoute\n])\n</pre>\n<div id=\"service-settings-ports-etc\">\n<h3>Service Settings (ports, etc)</h3>\n<p>You can configure the service very easily by passing arguments into\nthe Tornado application object. There are currently 4 user\nconfigurable properties:</p>\n<ul>\n<li><strong>enabled_protocols</strong>: This is a <tt>list</tt> of the Socket.IO\nprotocols the server will respond to requests for. Clients try them\none by one until the server and client both find one they both\nsupport. The possibilities are:</li>\n<li><em>websocket</em>: Standard HTML5 Spec Websockets. Our implementation\nuses the one built into Tornado with a slight tweak to message\nreceipt to enable decoding of the special Socket.IO wire encoding\nformat. (Works in Chrome and any other browser with native\nWebsocket support)</li>\n<li><em>flashsocket</em>: HTML5 Websockets emulated in Flash for older\nbrowsers like Firefox. <em>EXACTLY</em> the same implementation wise to\n<em>websocket</em>, but starts up a Flash policy server which is necessary\nfor Flash sockets to work. (Tested in IE8, and Firefox 3)</li>\n<li><em>xhr-multipart</em>: XMLHTTPRequest (AJAX) Multipart messaging.\nOpens and long polls a GET request to send from server to client,\nclient sends a POST to send client to server. Uses multipart &amp;\nchunking to send a continuous stream of messages down the same open\nGET channel. Best option after <em>websocket</em>/<em>flashsocket</em>. (Tested\nin IE8, Firefox 3 and Chrome)</li>\n<li><em>xhr-polling</em>: XMLHTTPRequest (AJAX) Long Polling. Client polls\non a GET until a message is available, closes the GET after getting\na message and then opens a new one until a message is available.\n(Tested in IE8, Firefox 3 - does NOT work with Chrome at all)</li>\n<li><em>jsonp-polling</em>: Identical protocol to <em>xhr-polling</em> but pushes\nJavascript script data via JSONp. (Tested in IE8, Firefox 3 - does\nNOT work with Chrome at all)</li>\n<li><em>htmlfile</em>: Appears to be for much older IE browsers w/o proper\nAJAX support, creates an AJAX HTMLFile control and does some iframe\nnastiness. I haven\u2019t found a browser that properly supports this so\nif you test it let me know \u2026 Copied implementation from reference\nNode code.</li>\n</ul>\n<p>The default setting is to enable <em>ALL</em> protocols, i.e.:</p>\n<pre>['websocket', 'flashsocket', 'xhr-multipart', 'xhr-polling', 'jsonp-polling', 'htmlfile']\n</pre>\n<ul>\n<li><strong>socket_io_port</strong>: The port for the Socket IO Server to\nlisten on.\n<em>This configuration setting is ignored unless you explicitly use the ``SocketIOServer`` class to start Tornado (See below).</em></li>\n<li><strong>flash_policy_file</strong> A fully qualified path to a Flash Policy\nXML File. A default permissive one is included in this distribution\nas <tt>flashpolicy.xml</tt>; by default the Flash service looks for\n<tt>flashpolicy.xml</tt> in the same directory as the current execution.\n<em>This configuration setting is ignored unless you explicitly use the ``SocketIOServer`` class to start Tornado (See below).</em></li>\n<li><strong>flash_policy_port</strong> The port for the Flash policy server to\nlisten on. This defaults to port <strong>843</strong> - Flash absolutely\n<em>will not</em> connect to any other port so if you change this, make\nsure you setup a portmap on the frontend. Without a valid policy\nservice Flash fallback sockets will not work.\n<em>This configuration setting is ignored unless you explicitly use the ``SocketIOServer`` class to start Tornado (See below).</em></li>\n</ul>\n<p>Configuring these settings is done by passing them to the\n<tt>tornado.web.Application</tt> constructor as kwargs:</p>\n<pre>application = tornado.web.Application([\n    echoRoute\n], enabled_protocols=['websocket', 'flashsocket', 'xhr-multipart', 'xhr-polling'],\n   flash_policy_port=8043, flash_policy_file='/etc/lighttpd/flashpolicy.xml', socket_io_port=8888)\n</pre>\n</div>\n<div id=\"starting-up\">\n<h3>Starting Up</h3>\n</div>\n</div>\n<div id=\"best-way-socketioserver\">\n<h2>Best Way: SocketIOServer</h2>\n<p>The SocketTornad.IO distribution contains a modified version of the\nTornado <tt>HTTPServer</tt> class designed to automatically read the\nnecessary configuration settings and start everything up. If\n<tt>flashsocket</tt> is enabled it will start the Flash Policy server,\nand it starts the Socket.IO Service for you (as opposed to you\nstarting it up manually).</p>\n<p>Assuming you set the configuration options on your <tt>Application</tt>\ninstance (or are happy with the defaults) you need merely\ninstantiate a <tt>tornad_io.SocketIOServer</tt>:</p>\n<pre>if __name__ == \"__main__\":\n    socketio_server = SocketIOServer(application)\n</pre>\n</div>\n<div id=\"starting-manually\">\n<h2>Starting Manually</h2>\n<p>If you\u2019d like more control over how you start everything up you can\nstart things manually, similar to the\n<a href=\"http://www.tornadoweb.org/documentation\" rel=\"nofollow\">Tornado Docs</a>. This\nrequires booting the IOLoop yourself:</p>\n<pre>if __name__ == \"__main__\":\n    flash_policy = tornad_io.websocket.flash.FlashPolicyServer(port=8043, policy_file=\"/etc/lighttpd/flashpolicy.xml\")\n    http_server = tornado.httpserver.HTTPServer(application)\n    http_server.listen(8888)\n    tornado.ioloop.IOLoop.instance().start()\n</pre>\n<div id=\"examples\">\n<h3>Examples</h3>\n</div>\n</div>\n<div id=\"chatroom-example\">\n<h2>Chatroom Example</h2>\n<p>There is a chatroom example application contributed by\n<a href=\"http://github.com/swanson\" rel=\"nofollow\">swanson</a>. It is in the\n<tt>examples/chatroom</tt> directory. For instructions, please see its\n<a href=\"http://github.com/novus/SocketTornad.IO/blob/master/examples/chatroom/README.md\" rel=\"nofollow\">README</a>.</p>\n</div>\n\n          </div>"}, "last_serial": 785688, "releases": {"0.1.0": [], "0.1.1": [{"comment_text": "", "digests": {"md5": "cfe0ff74d28a5d811070f03a8a48b1c9", "sha256": "85bce4303a56e8e2b7270020acd7a785f051d979cf79cda80661e3fe38f46770"}, "downloads": -1, "filename": "SocketTornad.IO-0.1.1.tar.gz", "has_sig": false, "md5_digest": "cfe0ff74d28a5d811070f03a8a48b1c9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13413, "upload_time": "2010-10-04T18:34:45", "upload_time_iso_8601": "2010-10-04T18:34:45.790476Z", "url": "https://files.pythonhosted.org/packages/ae/39/4ea3222e9ffeb120319b5a249ed26f71f444a11a5937fffe7425f11e5a13/SocketTornad.IO-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "9d2792a18c0a7ce8b3c0e60c169025a8", "sha256": "c7fed6c4f387a55074a7779a0b98be8c139bfc12a2700ec331553f8fc868c521"}, "downloads": -1, "filename": "SocketTornad.IO-0.1.2.tar.gz", "has_sig": false, "md5_digest": "9d2792a18c0a7ce8b3c0e60c169025a8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9346, "upload_time": "2010-10-04T22:12:28", "upload_time_iso_8601": "2010-10-04T22:12:28.711748Z", "url": "https://files.pythonhosted.org/packages/a3/3b/29045035ba4df99b3390276c83746c993e3a57ac0da07970537e4a366914/SocketTornad.IO-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "f11af0c58cae60f3b34cb4f9dfcb5e88", "sha256": "49e2226882beedf4366ee15b99fb1114594872ca18a614341b5b04122bfdd629"}, "downloads": -1, "filename": "SocketTornad.IO-0.1.3.tar.gz", "has_sig": false, "md5_digest": "f11af0c58cae60f3b34cb4f9dfcb5e88", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19890, "upload_time": "2010-10-14T21:52:18", "upload_time_iso_8601": "2010-10-14T21:52:18.744318Z", "url": "https://files.pythonhosted.org/packages/12/39/e28687ab1239d41850b74be26f27e4c3754b223bb08d33595500ec413b25/SocketTornad.IO-0.1.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f11af0c58cae60f3b34cb4f9dfcb5e88", "sha256": "49e2226882beedf4366ee15b99fb1114594872ca18a614341b5b04122bfdd629"}, "downloads": -1, "filename": "SocketTornad.IO-0.1.3.tar.gz", "has_sig": false, "md5_digest": "f11af0c58cae60f3b34cb4f9dfcb5e88", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19890, "upload_time": "2010-10-14T21:52:18", "upload_time_iso_8601": "2010-10-14T21:52:18.744318Z", "url": "https://files.pythonhosted.org/packages/12/39/e28687ab1239d41850b74be26f27e4c3754b223bb08d33595500ec413b25/SocketTornad.IO-0.1.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:07:00 2020"}