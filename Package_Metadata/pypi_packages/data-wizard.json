{"info": {"author": "S. Andrew Sheppard", "author_email": "andrew@wq.io", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Django", "Framework :: Django :: 1.11", "Framework :: Django :: 1.8", "Framework :: Django :: 2.0", "Framework :: Django :: 2.1", "Framework :: Django :: 2.2", "Framework :: Django :: 3.0", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Programming Language :: JavaScript", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Database :: Database Engines/Servers", "Topic :: Scientific/Engineering :: GIS"], "description": "**Django Data Wizard** is an interactive tool for mapping tabular data (e.g. Excel, CSV, XML, JSON) into a normalized database structure via [Django REST Framework] and [IterTable].  Django Data Wizard allows novice users to map spreadsheet columns to serializer fields (and cell values to foreign keys) on-the-fly during the import process.  This reduces the need for preset spreadsheet formats, which most data import solutions require.\n\n<img width=\"33%\"\n     alt=\"Column Choices\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/02-columns.png\">\n<img width=\"33%\"\n     alt=\"Auto Import - Progress Bar\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/08-data75.png\">\n<img width=\"33%\"\n     alt=\"Imported Records\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/10-records.png\">\n\nThe Data Wizard supports straightforward one-to-one mappings from spreadsheet columns to database fields, as well as more complex scenarios like [natural keys] and [Entity-Attribute-Value] (or \"wide\") table mappings.  It was originally developed for use with the [ERAV data model][ERAV] provided by [vera].\n\n[![Latest PyPI Release](https://img.shields.io/pypi/v/data-wizard.svg)](https://pypi.org/project/data-wizard)\n[![Release Notes](https://img.shields.io/github/release/wq/django-data-wizard.svg)](https://github.com/wq/django-data-wizard/releases)\n[![License](https://img.shields.io/pypi/l/data-wizard.svg)](https://github.com/wq/django-data-wizard/blob/master/LICENSE)\n[![GitHub Stars](https://img.shields.io/github/stars/wq/django-data-wizard.svg)](https://github.com/wq/django-data-wizard/stargazers)\n[![GitHub Forks](https://img.shields.io/github/forks/wq/django-data-wizard.svg)](https://github.com/wq/django-data-wizard/network)\n[![GitHub Issues](https://img.shields.io/github/issues/wq/django-data-wizard.svg)](https://github.com/wq/django-data-wizard/issues)\n\n[![Travis Build Status](https://img.shields.io/travis/wq/django-data-wizard.svg)](https://travis-ci.org/wq/django-data-wizard)\n[![Python Support](https://img.shields.io/pypi/pyversions/data-wizard.svg)](https://pypi.org/project/data-wizard)\n[![Django Support](https://img.shields.io/pypi/djversions/data-wizard.svg)](https://pypi.org/project/data-wizard)\n\n# Usage\n\nDjango Data Wizard provides a [web interface](#api-documentation), [JSON API](#api-documentation), and [CLI](#command-line-interface) for specifying a [data source](#custom-data-sources) to import (e.g. a previously-uploaded file), selecting a [serializer](#custom-serializers), mapping the data [columns](#columns) and [identifiers](#ids), and (asynchronously) importing the [data](#data) into any target model in the database.\n\nData Wizard is designed to allow users to iteratively refine their data import flow.  For example, decisions made during an initial data import are preserved for future imports of files with the same structure.  The included [data model](#data-model) makes this workflow possible. \n\n### Table Of Contents\n\n 1. **Getting Started**\n    * [Installation](#installation)\n    * [Initial Configuration](#initial-configuration)\n    * [**Target Model Registration (required)**](#target-model-registration)\n 2. **API Documentation**\n    * [Run API & Admin Screens](#api-documentation)\n    * [Data Model](#data-model)\n    * [Command-Line Interface](#command-line-interface)\n 3. **Advanced Customization**\n    * [Custom Serializers](#custom-serializers)\n    * [Custom Data Sources](#custom-data-sources)\n    * [Task Backends](#task-backends)\n    * [wq Framework Integration](#wq-framework-integration)\n\n## Installation\n\n```bash\n# Recommended: create virtual environment\n# python3 -m venv venv\n# . venv/bin/activate\n\npython3 -m pip install data-wizard\n```\n\nSee <https://github.com/wq/django-data-wizard> to report any issues.\n\n## Initial Configuration\n\nWithin a new or existing Django project, add `data_wizard` to your `INSTALLED_APPS`:\n\n```python\n# myproject/settings.py\nINSTALLED_APPS = (\n   # ...\n   'data_wizard',\n   'data_wizard.sources',  # Recommended\n)\n\n# This can be omitted to use the defaults\nDATA_WIZARD = {\n    'BACKEND': 'data_wizard.backends.threading',\n    'LOADER': 'data_wizard.loaders.FileLoader',\n    'IDMAP': 'data_wizard.idmap.never',   # 'data_wizard.idmap.existing' in 2.0\n    'AUTHENTICATION': 'rest_framework.authentication.SessionAuthentication',\n    'PERMISSION': 'rest_framework.permissions.IsAdminUser',\n}\n```\n\nIf you would like to use the built-in data source tables (`FileSource` and `URLSource`), also include `data_wizard.sources` in your `INSTALLED_APPS`.  Otherwise, you will want to configure one or more [custom data sources (see below)](#custom-data-sources).\n\n> Note: In version 1.1.0 and later, Django Data Wizard uses a simple [threading backend](#data_wizardbackendsthreading) for executing asynchronous tasks.  The old [celery backend](#data_wizardbackendscelery) can also be used but this is no longer required.\n\n\nNext, add `\"data_wizard.urls\"` to your URL configuration.\n\n```python\n# myproject/urls.py\nfrom django.urls import path, include\n\nurlpatterns = [\n    # ...\n    path('datawizard/', include('data_wizard.urls')),\n]\n```\n\n> Note: If you are upgrading from 1.0, you will need to update your URLs to add the `datawizard/` prefix as shown above.\n\n### Target Model Registration\n\nIn order to use the wizard, you **must** register one or more target models and/or serializers.  Target model registration helps the wizard know where to put the data it finds in each row of the source spreadsheet.  (By contrast, *source* model registration is optional, as long as you are using the provided `data_wizard.sources` app.)\n\nThe registration API is modeled after the  Django admin and `admin.py`.  Specifically, Data Wizard will look for a `wizard.py` file in your app directory, which should have the following structure:\n\n```python\n# myapp/wizard.py\nimport data_wizard\nfrom .models import MyModel\n\ndata_wizard.register(MyModel)\n```\n\nInternally, the wizard will automatically create a Django REST Framework serializer class corresponding to the target model.  If needed, you can also specify a [custom serializer class](#custom-serializers) to configure how the target model is validated and populated.\n\nOnce everything is configured, upload a source file in the Django admin, select \"Import via data wizard\" from the admin actions menu, and navigate through the screens described below.\n\n## API Documentation\n\nDjango Data Wizard is implemented as a series of views that can be accessed via the Django admin as well as via a JSON API.\n\n---\n\n<img align=\"right\" width=320 height=240\n     alt=\"Select Source & Start Import\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/A2-source-list.png\">\n\n### New Run\n\n#### `POST /datawizard/`\n\nCreates a new instance of the wizard (i.e. a `Run`).  If you are using the Django admin integration, this step is executed when you select \"Import via Data Wizard\" from the admin actions menu.  If you are using the JSON API, the returned run `id` should be used in all subsequent calls to the API.  Each `Run` is tied to the source model via a [generic foreign key].\n\nparameter         | description\n------------------|----------------------------------------\n`object_id` | The primary key of the *source* model instance containing the data to be imported.\n`content_type_id` | The *source* model's app label and model name (in the format `app_label.modelname`).\n`loader` | (Optional) The class name to use for loading the source dataset via [IterTable].  The default loader (`data_wizard.loaders.FileLoader`) assumes that the source model contains a `FileField` named `file`.\n`serializer` | (Optional) The serializer class to use when populating the *target* model.  This can be left unset to allow the user to select the target during the wizard run.\n\n---\n\n<img align=\"right\" width=320 height=240\n     alt=\"Auto Import - Progress Bar\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/06-data25.png\">\n\n### auto\n#### `POST /datawizard/[id]/auto`\n\nThe `auto` task attempts to run the entire data wizard process from beginning to end.  If any input is needed, the import will halt and redirect to the necessary screen.  If no input is needed, the `auto` task is equivalent to starting the `data` task directly.  This is an asynchronous method, and returns a `task_id` to be used with the status API.\n\nThe [run_detail.html] template provides an example form that initiates the `auto` task.  The `auto` task itself uses the [run_auto.html] template.  \n\n---\n\n### status\n#### `GET /datawizard/[id]/status.json?task=[task]`\n\nThe `status` API is used to check the status of an asynchronous task (one of `auto` or `data`).  The API is used by the provided [data_wizard/js/progress.js] to update the `<progress>` bar in the [run_auto.html] and [run_data.html] templates.  Unlike the other methods, this API is JSON-only and has no HTML equivalent.  An object of the following format will be returned:\n\n```js\n{\n    // General properties\n    \"status\": \"PROGRESS\", // or \"SUCCESS\", \"FAILURE\"\n    \"stage\": \"meta\",      // or \"data\"\n    \"current\": 23,        // currently processing row\n    \"total\": 100,         // total number of rows\n\n    // \"FAILURE\"\n    \"error\": \"Error Message\",\n\n    // Task complete (\"SUCCESS\")\n    \"action\": \"records\",        // or \"serializers\", \"columns\" \"ids\"\n    \"message\": \"Input Needed\",  // if action is not \"records\"\n    \"skipped\": [...],           // rows that could not be imported\n    \"location\": \"/datawizard/[id]/records\",\n}\n```\n\nThe potential values for the  `status` field are the same as common [Celery task states], even when not using the `celery` backend.  When running an `auto` task, the result is `SUCCESS` whenever the task ends without errors, even if there is additional input needed to fully complete the run.\n\nThe default [run_auto.html] and [run_data.html] templates include a `<progress>` element for use with the status task.\n\n---\n\n<img align=\"right\" width=320 height=240\n     alt=\"Serializer Choices\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/00-serializers.png\">\n\n### serializers\n#### `GET /datawizard/[id]/serializers`\n\nThe `serializers` task provides a list of all registered serializers (i.e. target models).  This screen is shown by the `auto` task if a serializer was not specified when the `Run` was created.  The default [run_serializers.html] template includes an interface for selecting a target.  If a serializer is already selected, the template will display the label and a button to (re)start the `auto` task.\n\n<br>\n\n---\n\n<img align=\"right\" width=320 height=240\n     alt=\"Serializer Selected\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/01-updateserializer.png\">\n\n### updateserializer\n#### `POST /datawizard/[id]/updateserializer`\n\nThe `updateserializer` task updates the specified `Run` with the selected target serializer name.  This is typically called from [the form][run_serializers.html] generated by the `serializers` task, and will redirect to that task when complete.\n\nparameter    | description\n-------------|----------------------------------------\n`serializer` | The class name (or label) of the target serializer to use for this run.\n\n---\n\n<img align=\"right\" width=320 height=240\n     alt=\"Column Choices\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/02-columns.png\">\n\n### columns\n#### `GET /datawizard/[id]/columns`\n\nThe `columns` task lists all of the columns found in the source dataset (i.e. spreadsheet) and their mappings to target serializer fields.  This screen is shown by the `auto` task if there are any column names that could not be automatically mapped.  The potential mappings are one of:\n\n  * simple serializer field names (e.g. `field`)\n  * nested field names (for [natural keys], e.g. `nested[record][field]`)\n  * [EAV][Entity-Attribute-Value] attribute-value mappings (e.g. `values[][value];attribute_id=1`).  Note that EAV support requires a [custom serializer class](#custom-serializers).\n\nThe default [run_columns.html] template includes an interface for mapping data columns to serializer fields.  If all columns are already mapped, the template will display the mappings and a button to (re)start the `auto` task.\n\n---\n\n<img align=\"right\" width=320 height=240\n     alt=\"Columns Selected\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/03-updatecolumns.png\">\n\n### updatecolumns\n#### `POST /datawizard/[id]/updatecolumns`\n\nThe `updatecolumns` task saves the specified mappings from source data columns to target serializer fields.  This is typically called from [the form][run_columns.html] generated by the `columns` task, and will redirect to that task when complete.\n\nparameter     | description\n--------------|----------------------------------------\n`rel_[relid]` | The column to map to the specified serializer field.  The `relid` and the complete list of possible mappings will be provided by the `columns` task.\n\n---\n\n<img align=\"right\" width=320 height=240\n     alt=\"Identifier Choices\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/04-ids.png\">\n\n### ids\n#### `GET /datawizard/[id]/ids`\n\nThe `ids` task lists all of the foreign key values found in the source dataset (i.e. spreadsheet).  If there are any unmapped foreign key values, the auto task will stop and redirect to the `ids` task.  The default [run_ids.html] template includes an interface for mapping row identifiers to foreign key values.  The potential mappings depend on the serializer field used to represent the foreign key.\n\n * For [PrimaryKeyRelatedField], [SlugRelatedField], and [NaturalKeySerializer][natural keys], the choices will include all existing record ID or slugs.\n * For `NaturalKeySerializer` only, a`\"new\"` choice will also be included, allowing for the possibility of creating new records in the foreign table on the fly.\n\nOnce all ids are mapped, the template will display the mappings and a button to (re)start the `auto` task.\n\nNote that the `auto` task will skip the `ids` task entirely if any of the following are true:\n  * The file contains no foreign key columns\n  * All foreign key values were already mapped during a previous import run\n  * All foreign key values can be automatically mapped via the `DATA_WIZARD['IDMAP']` setting:\n\n`DATA_WIZARD['IDMAP']` | notes | detail\n--|--|--\n`\"data_wizard.idmap.never\"` | Default&nbsp;in&nbsp;1.x | Require user to manually map all IDs the first time they are found in a file\n`\"data_wizard.idmap.existing\"` | New&nbsp;in&nbsp;1.3, Default&nbsp;in&nbsp;2.0 | Automatically map existing IDs, but require user to map unknown ids\n`\"data_wizard.idmap.always\"` | New&nbsp;in&nbsp;1.3 | Always map IDs (skip manual mapping).  Unknown IDs will be passed on as-is to the serializer, which will cause per-row errors unless using natural keys.\n(custom import path) | New&nbsp;in&nbsp;1.3 | The function should accept an identifier and a serializer field, and return the mapped value (or `None` if no automatic mapping is available).  See the [built-in functions][idmap.py] for examples.\n\nNote that the configured `IDMAP` function will only be called the first time a new identifier is encountered.  Once the mapping is established (manually or automatically), it will be re-used in subsequent wizard runs.\n\n---\n\n<img align=\"right\" width=320 height=240\n     alt=\"Identifiers Selected\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/05-updateids.png\">\n\n### updateids\n#### `POST /datawizard/[id]/updateids`\n\nThe `updateids` task saves the specified mappings from row identifiers to foreign key values.  This is typically called from [the form][run_ids.html] generated by the `ids` task, and will redirect to that task when complete.\n\nparameter            | description\n---------------------|----------------------------------------\n`ident_[identid]_id` | The identifier to map to the specified foreign key value.  The `identid` and the complete list of possible mappings will be provided by the `ids` task.\n\n---\n\n<img align=\"right\" width=320 height=240\n     alt=\"Auto Import - Progress Bar\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/08-data75.png\">\n\n### data\n#### `POST /datawizard/[id]/data`\n\nThe `data` task starts the actual import process (and is called by `auto` behind the scenes).  Unlike `auto`, calling `data` directly will not cause a redirect to one of the other tasks if any meta input is needed.  Instead, `data` will attempt to import each record as-is, and report any errors that occured due to e.g. missing fields or unmapped foreign keys.\n\nThis is an asynchronous method, and returns a `task_id` to be used with the `status` API.  The default [run_data.html] template includes a `<progress>` element for use with status task.\n\n---\n\n<img align=\"right\" width=320 height=240\n     alt=\"Imported Records\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/10-records.png\">\n\n### records\n#### `GET /datawizard/[id]/records`\n\nThe `records` task provides a list of imported rows (including errors).  It is redirected to by the `auto` and `data` tasks upon completion.  Successfully imported `Record` instances will have a [generic foreign key] pointing to the target model.  The `records` task will include links to the `get_absolute_url()` or admin screen for each newly imported target model instance.  The default [run_records.html] template includes an interface for displaying the record details.\n\n<br>\n\n---\n\n<img align=\"right\" width=320 height=240\n     alt=\"Run List\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/11-run-list.png\">\n\n### Run List\n#### `GET /datawizard/`\n\nDjango Data Wizard provides a list view that summarises prior runs and the number of records imported by each.  Incomplete runs can also be restarted from this list.\n\n<br><br>\n\n---\n\n<img align=\"right\" width=320 height=240\n     alt=\"Identifier Admin\"\n     src=\"https://raw.githubusercontent.com/wq/django-data-wizard/master/images/A3-identifiers.png\">\n\n### Identifier Admin\n#### `GET /admin/data_wizard/identifer/`\n\nAs of version 1.1.0, Django Data Wizard identifier mappings can be viewed and edited via the Django Admin.  Runs can also be viewed through the admin - though the Run List above will generally be more useful.\n\n<br>\n\n## Data Model\n\nDjango Data Wizard provides a number of Django models that help track the import process, and preserve data mapping decisions for future reuse.  While a *source* model is required, your *target* data model(s) generally do not have to be changed to support Data Wizard integration.\n\nstep | description | model\n-----|-------------|--------\n0 | Upload **source** file | Create `FileSource` (or custom source model)\n1 | Start data wizard run | Create `Run`\n2 | Select serializer (& target model) | Update `Run`\n3 | Map columns to database field names | One `Identifier` per column, if needed\n4 | Map cell values to foreign keys | One `Identifier` per unique value\n5 | Import data into **target** model | One `Record` + one target model instance per row\n\nThe `Run` model includes a [generic foreign key] pointing to the source model (e.g. `FileSource`.)  Each row in the source spreadsheet will be mapped to a `Record`.  If the row was successfully imported, a new instance of the target data model will be created, and the `Record` will have a generic foreign key pointing to it.  The `Identifier` model contains no foreign keys, since identifier mappings are reused for subsequent imports.  Instead, a separate `Range` model tracks the location(s) (rows/columns) of each `Identifier` in each `Run`.\n\nNote that the above workflow just describes the most common use case.  You can create [custom serializers](#custom-serializers) that update more than one target data model per spreadsheet row.  And you can specify [custom data sources](#custom-data-sources) that might not be a spreadsheet or even a file.\n\n## Command-Line Interface\n\nDjango Data Wizard provides a single [management command], `runwizard`, that can be used to initiate the `auto` task from the command line.  This can be used to facilitate automated processing, for example as part of a regular cron job.  Note that the CLI does not (currently) support interactively mapping columns and ids, so these should be pre-mapped using the web or JSON API.\n\nUsage:\n\n```bash\n./manage.py runwizard myapp.mymodel 123 \\\n    --loader myapp.loaders.customloader \\\n    --serializer myapp.serializer.customserializer \\\n    --username myusername\n```\n\nThe basic usage is similar to the [New Run API](#new-run).  Only a content type and object id are required, while the other arguments will be auto-detected if possible.  In particular, you may want to use [set_loader()](#custom-loader) to predefine the default `loader` and `serializer` for any models you plan to use with the CLI.\n\nThe `runwizard` command will create a new `Run` and immediately start the `auto` task.  Errors will be shown on the console.\n\n## Custom Serializers\n\nData Wizard uses instances of Django REST Framework's [Serializer class][ModelSerializer] to determine the destination fields on the target model.  Specifically, the default serializer is [NaturalKeyModelSerializer], which is based on [ModelSerializer].\n\nYou can override the default serializer by calling `data_wizard.register()` with a name and a serializer class instead of a model class.  Multiple serializers can be registered with the wizard to support multiple import configurations and target models.  \n\n```python\n# myapp/wizard.py\nfrom rest_framework import serializers\nimport data_wizard\nfrom .models import TimeSeries\n\n\nclass TimeSeriesSerializer(serializers.ModelSerializer):\n    # (custom fields here)\n    class Meta:\n        model = TimeSeries\n        fields = '__all__'\n\n        # Optional - see options below\n        data_wizard = {\n            'header_row': 0,\n            'start_row': 1,\n            'show_in_list': True,\n            'idmap': data_wizard.idmap.existing,\n        }\n\n# Use default name & serializer\ndata_wizard.register(TimeSeries)\n\n# Use custom name & serializer\ndata_wizard.register(\"Time Series - Custom Serializer\", TimeSeriesSerializer)\n```\n\nAt least one serializer or model should be registered in order to use the wizard.  Note the use of a human-friendly serializer label when registering a serializer.  This name should be unique throughout the project, but can be changed later on without breaking existing data.  (The class path is used as the actual identifier behind the scenes.)\n\n### Serializer Options\n\nIn general, custom serializers have all the capabilities of regular [Django REST Framework serializers][serializers], including custom validation rules and the ability to populate multiple target models.  While the `request` context is not available, information about the run (including the user) can be retrieved through the `data_wizard` context instead.\n\nWhen overriding a serializer for a [natural key model][natural keys], be sure to extend [NaturalKeyModelSerializer], as in [this example][naturalkey_wizard].  In other cases, extend [ModelSerializer] (as in the example above) or the base [Serializer](serializers) class.\n\nCustom serializers can be used to support [Entity-Attribute-Value] spreadsheets where the attribute names are specified as additional columns.  To support this scenario, the `Entity` serializer should include a nested `Value` serializer with `many=True`, and the `Value` serializer should have a foreign key to the `Attribute` table, as in [this example][eav_wizard].\n\nData Wizard also supports additional configuration by setting a `data_wizard` attribute on the `Meta` class of the serializer.  The following options are supported.\n\nname | default | notes\n--|--|--\n`header_row` | 0 | Specifies the first row of the spreadsheet that contains column headers.  If this is greater than 0, the space above the column headers will be scanned for anything that looks like a one-off \"global\" value intended to be applied to every row in the imported data.\n`start_row` | 1 | The first row of data.  If this is greater than `header_row + 1`, the column headers will be assumed to span multiple rows.  A common case is when EAV parameter names are on the first row and units are on the second.\n`show_in_list` | `True` | **New in 1.2**.  If set to `False`, the serializer will be available through the API but not listed in the wizard views.  This is useful if you have a serializer that should only be used during fully automated workflows.\n`idmap` | [`IDMAP` setting](#ids) | **New in 1.3**.  Can be any of `data_wizard.idmap.*` or a custom function.  Unlike the `IDMAP` setting, this should always be an actual function and not an import path.\n\n## Custom Data Sources\n\nDjango Data Wizard uses [IterTable] to determine the source columns present on the spreadsheet or other data source.  Django Data Wizard can use any Django model instance as a source for its data, provided there is a registered loader that can convert the source model into a [Iter class][IterTable].  Data Wizard provides two out-of-the the box loaders, [FileLoader] and [URLLoader], that can be used with the provided models in `data_wizard.sources` (`FileSource` and `URLSource`, respectively).\n\n### Extending FileLoader\nThe default `FileLoader` can be used with any Django model with a `FileField` named `file`.  You can use a model with a different `FileField` name by creating a subclass of `data_wizard.loaders.FileLoader` and setting it as the loader for your model.\n\n```python\n# myapp/models.py\nfrom django.db import models\n\nclass FileModel(models.Model):\n    spreadsheet = models.FileField(upload_to='spreadsheets')\n```\n\n```python\n# myapp/loaders.py\nfrom data_wizard import loaders\n\nclass FileLoader(loaders.FileLoader):\n    file_attr = 'spreadsheet'\n```\n\n```python\n# myapp/wizard.py\nimport data_wizard\nfrom .models import FileModel\n\ndata_wizard.set_loader(FileModel, \"myapp.loaders.FileLoader\")\n```\n\nIf you have a generic loader that can work with multiple source models, you can also set the default loader globally:\n\n```python\n# myapp/settings.py\nDATA_WIZARD = {\n    'LOADER': 'myapp.loaders.FileLoader'\n}\n```\n\nAs of Django Data Wizard 1.2, you should register a custom `ModelAdmin` class to add the Import action in the admin panel for your model.\n\n```python\n# myapp/admin.py\nfrom django.contrib import admin\nfrom data_wizard.admin import ImportActionModelAdmin\n\nfrom .models import FileModel\n\n\n@admin.register(FileModel)\nclass FileModelAdmin(ImportActionModelAdmin):\n    pass\n```\n\n### Custom Loader\nThe default loaders support any file format supported by [IterTable] (Excel, CSV, JSON, and XML).  Additional formats can be integrating by creating a [custom IterTable class][custom-iter] and then registering it with the wizard.  For example, the [Climata Viewer] uses Django Data Wizard to import data from [climata]'s IterTable-based web service client.  To do this, extend `data_wizard.loaders.BaseLoader` with a custom `load_iter()` function that returns the data from IterTable, as in the example below.\n\nIt is likely that you will want to use a specific serializer with your custom loader.  If so, override `default_serializer` or `get_serializer_name()` on the loader.  By default, these return `None`, which requires the user to specify the serializer when creating or executing the `Run`.\n\n```python\n# myapp/models.py\nfrom django.db import models\n\nclass CustomIterSource(models.Model):\n    some_option = models.TextField()\n```\n\n```python\n# myapp/loaders.py\nfrom data_wizard import loaders\nfrom .iter import CustomIter\n\nclass CustomIterLoader(loaders.BaseLoader):\n    default_serializer = 'mydataapp.wizard.CustomSerializer'\n    def load_iter(self):\n        source = self.run.content_object\n        return CustomIter(some_option=source.some_option)\n```\n\n```python\n# myapp/wizard.py\nimport data_wizard\nfrom .models import CustomIterSource\n\ndata_wizard.set_loader(CustomIterSource, \"myapp.loaders.CustomIterLoader\")\n```\n\n\n## Task Backends\n\nAs of version 1.1.0, Django Data Wizard **no longer requires** the use of `celery` as a task runner.  Any of the following backends can be configured with via the `BACKEND` setting:\n\n```python\n# myproject/settings.py\n\nDATA_WIZARD = {\n   \"BACKEND\": \"data_wizard.backends.threading\"  # Default in 1.1.x\n              \"data_wizard.backends.immediate\"\n              \"data_wizard.backends.celery\"     # Only choice in 1.0.x\n}\n```\n\nFor backwards compatibility with 1.0.x, the default backend reverts to `celery` if you have `CELERY_RESULT_BACKEND` defined in your project settings.  However, it is recommended to explicitly set `BACKEND`, as this behavior may change in a future major version of Data Wizard.\n\n### `data_wizard.backends.threading`\n\nThe `threading` backend creates a separate thread for long-running asynchronous tasks (i.e. `auto` and `data`).  The threading backend leverages the Django cache to pass results back to the status API.  As of Django Data Wizard 1.1.0, **this backend is the default** unless you have configured Celery.\n\n### `data_wizard.backends.immediate`\n\nThe `immediate` backend completes all processing before returning a result to the client, even for the otherwise \"asynchronous\" tasks (`auto` and `data`).  This backend is suitable for small spreadsheets, or for working around threading issues.  This backend maintains minimal state, and is not recommended for use cases involving large spreadsheets or multiple simultanous import processes.\n\n### `data_wizard.backends.celery`\n\nThe `celery` backend leverages [Celery] to handle asynchronous tasks, and is usually used with [Redis] as the memory store.\n**Celery is no longer required to use Django Data Wizard,** unless you would like to use the `celery` backend.  If so, be sure to configure these libraries first or the REST API may not work as expected.  You can use these steps on Ubuntu:\n\n```bash\n# Install redis and celery\nsudo apt-get install redis-server\npip install celery redis\n```\n\nOnce Redis is installed, configure the following files in your project:\n```python\n# myproject/settings.py\nDATA_WIZARD {\n    'BACKEND': 'data_wizard.backends.celery'\n}\nCELERY_RESULT_BACKEND = BROKER_URL = 'redis://localhost:6379/1'\n\n# myproject/celery.py\nfrom __future__ import absolute_import\nfrom celery import Celery\nfrom django.conf import settings\napp = Celery('myproject')\napp.config_from_object('django.conf:settings')\napp.autodiscover_tasks(lambda: settings.INSTALLED_APPS)\n\n# myproject/__init__.py\nfrom .celery import app as celery_app\n```\n\nFinally, run celery with `celery -A myproject`.  You may want to use celery's [daemonization] to keep the process running in the background.  Any time you change your serializer registration, be sure to reload celery in addition to restarting the Django WSGI instance.\n\n> Note that the requirement for an extra daemon means this backend can break more easily after a server restart.  Even worse, you may not notice that the backend is down for several months (e.g. until a user tries to import a spreadsheet).  For this reason, **we recommend using one of the other backends** unless you are already using celery for other background processing tasks.\n\n## wq Framework integration\n\nThe Django Data Wizard has built-in support for integration with the [wq framework].  On the server, configuration is mostly the same, except that you do not need to add `\"data_wizard.urls\"` to your urls.py as the wizard will register itself with [wq.db] instead.\n\nData Wizard provides mustache templates for each of the above tasks to integrate with the wq.app UI.  These are rendered on the server and do not need to be included in your JavaScript build.  However, you should install the [@wq/progress] plugin via NPM and register it with [@wq/app].\n\n```javascript\n// src/index.js\nimport app from '@wq/app';\nimport progress from '@wq/progress';\n\napp.use(progress);\napp.init(config).then(...);\n```\n\nOnce everything is set up, add the following `<form>` to the detail template that wq generates for your source model.  Note that you will need to add this `<form>` manually even if the source model is one of `data_wizard.sources`.  After adding the form, be sure to skip template regeneration for the source model.\n\n```html\n<!-- filesource_detail.html -->\n<h1>{{label}}</h1>\n<a href=\"{{rt}}/media/{{file}}\" rel=\"external\">Download File</a>\n\n<form action=\"{{rt}}/datawizard/\" method=\"post\">\n  {{>csrf}}\n  <input type=\"hidden\" name=\"content_type_id\" value=\"sources.filesource\">\n  <input type=\"hidden\" name=\"object_id\" value=\"{{id}}\">\n  <button type=\"submit\">Import Data from This File</button>\n</form>\n```\n\n[IterTable]: https://github.com/wq/itertable\n[Django REST Framework]: http://www.django-rest-framework.org/\n[natural keys]: https://github.com/wq/django-natural-keys\n[Entity-Attribute-Value]: https://wq.io/docs/eav-vs-relational\n[ERAV]: https://wq.io/docs/erav\n[vera]: https://wq.io/vera\n\n[wq.db]: https://wq.io/wq.db\n[custom-iter]: https://github.com/wq/itertable/blob/master/docs/about.md\n[Climata Viewer]: https://github.com/heigeo/climata-viewer\n[climata]: https://github.com/heigeo/climata\n[wq framework]: https://wq.io/\n[wq.db.rest]: https://wq.io/docs/about-rest\n[ModelSerializer]: http://www.django-rest-framework.org/api-guide/serializers/#modelserializer\n[serializers]: http://www.django-rest-framework.org/api-guide/serializers/\n[NaturalKeyModelSerializer]: https://github.com/wq/django-natural-keys#naturalkeymodelserializer\n[FileLoader]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/loaders.py\n[URLLoader]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/loaders.py\n[generic foreign key]: https://docs.djangoproject.com/en/1.11/ref/contrib/contenttypes/\n[data_wizard/js/progress.js]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/static/data_wizard/js/progress.js\n[wq/progress.js]: https://wq.io/docs/progress-js\n[Celery]: http://www.celeryproject.org/\n[Redis]: https://redis.io/\n[daemonization]: http://docs.celeryproject.org/en/latest/userguide/daemonizing.html\n[wq.app]: https://wq.io/wq.app\n[Celery task states]: http://docs.celeryproject.org/en/latest/userguide/tasks.html#task-states\n\n[PrimaryKeyRelatedField]: http://www.django-rest-framework.org/api-guide/relations/#primarykeyrelatedfield\n[SlugRelatedField]: http://www.django-rest-framework.org/api-guide/relations/#slugrelatedfield\n\n[run_detail.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_detail.html\n[run_auto.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_auto.html\n[run_serializers.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_serializers.html\n[run_columns.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_columns.html\n[run_ids.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_ids.html\n[idmap.py]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/idmap.py\n[run_data.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_data.html\n[run_records.html]: https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_records.html\n\n[naturalkey_wizard]: https://github.com/wq/django-data-wizard/blob/master/tests/naturalkey_app/wizard.py\n[eav_wizard]: https://github.com/wq/django-data-wizard/blob/master/tests/eav_app/wizard.py\n[management command]: https://docs.djangoproject.com/en/2.1/ref/django-admin/\n\n[@wq/progress]: https://github.com/wq/django-data-wizard/tree/master/packages/progress\n[@wq/app]: https://wq.io/docs/app-js\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/wq/django-data-wizard", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "data-wizard", "package_url": "https://pypi.org/project/data-wizard/", "platform": "", "project_url": "https://pypi.org/project/data-wizard/", "project_urls": {"Homepage": "https://github.com/wq/django-data-wizard"}, "release_url": "https://pypi.org/project/data-wizard/1.3.0/", "requires_dist": ["djangorestframework", "itertable", "natural-keys", "html-json-forms", "python-dateutil"], "requires_python": "", "summary": "Interactive web-based wizard for importing structured data into Django models.", "version": "1.3.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><strong>Django Data Wizard</strong> is an interactive tool for mapping tabular data (e.g. Excel, CSV, XML, JSON) into a normalized database structure via <a href=\"http://www.django-rest-framework.org/\" rel=\"nofollow\">Django REST Framework</a> and <a href=\"https://github.com/wq/itertable\" rel=\"nofollow\">IterTable</a>.  Django Data Wizard allows novice users to map spreadsheet columns to serializer fields (and cell values to foreign keys) on-the-fly during the import process.  This reduces the need for preset spreadsheet formats, which most data import solutions require.</p>\n<p><img alt=\"Column Choices\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ef92cc9986f1639fa8b31c5fb92f8af164e0f05d/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f30322d636f6c756d6e732e706e67\" width=\"33%\">\n<img alt=\"Auto Import - Progress Bar\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4f0d117be1d8eceddc0ad98755951ab0074bcf47/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f30382d6461746137352e706e67\" width=\"33%\">\n<img alt=\"Imported Records\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a1d70264ed420083571790da73ffd175d1c2af05/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f31302d7265636f7264732e706e67\" width=\"33%\"></p>\n<p>The Data Wizard supports straightforward one-to-one mappings from spreadsheet columns to database fields, as well as more complex scenarios like <a href=\"https://github.com/wq/django-natural-keys\" rel=\"nofollow\">natural keys</a> and <a href=\"https://wq.io/docs/eav-vs-relational\" rel=\"nofollow\">Entity-Attribute-Value</a> (or \"wide\") table mappings.  It was originally developed for use with the <a href=\"https://wq.io/docs/erav\" rel=\"nofollow\">ERAV data model</a> provided by <a href=\"https://wq.io/vera\" rel=\"nofollow\">vera</a>.</p>\n<p><a href=\"https://pypi.org/project/data-wizard\" rel=\"nofollow\"><img alt=\"Latest PyPI Release\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/33b94bf98a3e44aea16bb24b701bf1551f5e091a/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f646174612d77697a6172642e737667\"></a>\n<a href=\"https://github.com/wq/django-data-wizard/releases\" rel=\"nofollow\"><img alt=\"Release Notes\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/db50ad9932e8f1815803e5191891a7f37b2bbd42/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f72656c656173652f77712f646a616e676f2d646174612d77697a6172642e737667\"></a>\n<a href=\"https://github.com/wq/django-data-wizard/blob/master/LICENSE\" rel=\"nofollow\"><img alt=\"License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f43eb563236a5eaa6ffd93ae6b2877707b455c1a/68747470733a2f2f696d672e736869656c64732e696f2f707970692f6c2f646174612d77697a6172642e737667\"></a>\n<a href=\"https://github.com/wq/django-data-wizard/stargazers\" rel=\"nofollow\"><img alt=\"GitHub Stars\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/edf19383ca8d81c8184c28cf1e3c8dbda4e2995d/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f73746172732f77712f646a616e676f2d646174612d77697a6172642e737667\"></a>\n<a href=\"https://github.com/wq/django-data-wizard/network\" rel=\"nofollow\"><img alt=\"GitHub Forks\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fd718a11f0a9c6c825c0af762d08a8996c58c7d3/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f666f726b732f77712f646a616e676f2d646174612d77697a6172642e737667\"></a>\n<a href=\"https://github.com/wq/django-data-wizard/issues\" rel=\"nofollow\"><img alt=\"GitHub Issues\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/83ab46c346571dc17afe948aaecda0019ec5c2f3/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6973737565732f77712f646a616e676f2d646174612d77697a6172642e737667\"></a></p>\n<p><a href=\"https://travis-ci.org/wq/django-data-wizard\" rel=\"nofollow\"><img alt=\"Travis Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d6a0f732b65dc496eaac46fdb85a3972a5f9ae5d/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f77712f646a616e676f2d646174612d77697a6172642e737667\"></a>\n<a href=\"https://pypi.org/project/data-wizard\" rel=\"nofollow\"><img alt=\"Python Support\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a0cffc5847f31f7f8a8b0122005a6fbd7306cd82/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f646174612d77697a6172642e737667\"></a>\n<a href=\"https://pypi.org/project/data-wizard\" rel=\"nofollow\"><img alt=\"Django Support\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/208fdc519020f92e673df5db9cbeb09c186752aa/68747470733a2f2f696d672e736869656c64732e696f2f707970692f646a76657273696f6e732f646174612d77697a6172642e737667\"></a></p>\n<h1>Usage</h1>\n<p>Django Data Wizard provides a <a href=\"#api-documentation\" rel=\"nofollow\">web interface</a>, <a href=\"#api-documentation\" rel=\"nofollow\">JSON API</a>, and <a href=\"#command-line-interface\" rel=\"nofollow\">CLI</a> for specifying a <a href=\"#custom-data-sources\" rel=\"nofollow\">data source</a> to import (e.g. a previously-uploaded file), selecting a <a href=\"#custom-serializers\" rel=\"nofollow\">serializer</a>, mapping the data <a href=\"#columns\" rel=\"nofollow\">columns</a> and <a href=\"#ids\" rel=\"nofollow\">identifiers</a>, and (asynchronously) importing the <a href=\"#data\" rel=\"nofollow\">data</a> into any target model in the database.</p>\n<p>Data Wizard is designed to allow users to iteratively refine their data import flow.  For example, decisions made during an initial data import are preserved for future imports of files with the same structure.  The included <a href=\"#data-model\" rel=\"nofollow\">data model</a> makes this workflow possible.</p>\n<h3>Table Of Contents</h3>\n<ol>\n<li><strong>Getting Started</strong>\n<ul>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#initial-configuration\" rel=\"nofollow\">Initial Configuration</a></li>\n<li><a href=\"#target-model-registration\" rel=\"nofollow\"><strong>Target Model Registration (required)</strong></a></li>\n</ul>\n</li>\n<li><strong>API Documentation</strong>\n<ul>\n<li><a href=\"#api-documentation\" rel=\"nofollow\">Run API &amp; Admin Screens</a></li>\n<li><a href=\"#data-model\" rel=\"nofollow\">Data Model</a></li>\n<li><a href=\"#command-line-interface\" rel=\"nofollow\">Command-Line Interface</a></li>\n</ul>\n</li>\n<li><strong>Advanced Customization</strong>\n<ul>\n<li><a href=\"#custom-serializers\" rel=\"nofollow\">Custom Serializers</a></li>\n<li><a href=\"#custom-data-sources\" rel=\"nofollow\">Custom Data Sources</a></li>\n<li><a href=\"#task-backends\" rel=\"nofollow\">Task Backends</a></li>\n<li><a href=\"#wq-framework-integration\" rel=\"nofollow\">wq Framework Integration</a></li>\n</ul>\n</li>\n</ol>\n<h2>Installation</h2>\n<pre><span class=\"c1\"># Recommended: create virtual environment</span>\n<span class=\"c1\"># python3 -m venv venv</span>\n<span class=\"c1\"># . venv/bin/activate</span>\n\npython3 -m pip install data-wizard\n</pre>\n<p>See <a href=\"https://github.com/wq/django-data-wizard\" rel=\"nofollow\">https://github.com/wq/django-data-wizard</a> to report any issues.</p>\n<h2>Initial Configuration</h2>\n<p>Within a new or existing Django project, add <code>data_wizard</code> to your <code>INSTALLED_APPS</code>:</p>\n<pre><span class=\"c1\"># myproject/settings.py</span>\n<span class=\"n\">INSTALLED_APPS</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n   <span class=\"c1\"># ...</span>\n   <span class=\"s1\">'data_wizard'</span><span class=\"p\">,</span>\n   <span class=\"s1\">'data_wizard.sources'</span><span class=\"p\">,</span>  <span class=\"c1\"># Recommended</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># This can be omitted to use the defaults</span>\n<span class=\"n\">DATA_WIZARD</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'BACKEND'</span><span class=\"p\">:</span> <span class=\"s1\">'data_wizard.backends.threading'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'LOADER'</span><span class=\"p\">:</span> <span class=\"s1\">'data_wizard.loaders.FileLoader'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'IDMAP'</span><span class=\"p\">:</span> <span class=\"s1\">'data_wizard.idmap.never'</span><span class=\"p\">,</span>   <span class=\"c1\"># 'data_wizard.idmap.existing' in 2.0</span>\n    <span class=\"s1\">'AUTHENTICATION'</span><span class=\"p\">:</span> <span class=\"s1\">'rest_framework.authentication.SessionAuthentication'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'PERMISSION'</span><span class=\"p\">:</span> <span class=\"s1\">'rest_framework.permissions.IsAdminUser'</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n</pre>\n<p>If you would like to use the built-in data source tables (<code>FileSource</code> and <code>URLSource</code>), also include <code>data_wizard.sources</code> in your <code>INSTALLED_APPS</code>.  Otherwise, you will want to configure one or more <a href=\"#custom-data-sources\" rel=\"nofollow\">custom data sources (see below)</a>.</p>\n<blockquote>\n<p>Note: In version 1.1.0 and later, Django Data Wizard uses a simple <a href=\"#data_wizardbackendsthreading\" rel=\"nofollow\">threading backend</a> for executing asynchronous tasks.  The old <a href=\"#data_wizardbackendscelery\" rel=\"nofollow\">celery backend</a> can also be used but this is no longer required.</p>\n</blockquote>\n<p>Next, add <code>\"data_wizard.urls\"</code> to your URL configuration.</p>\n<pre><span class=\"c1\"># myproject/urls.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.urls</span> <span class=\"kn\">import</span> <span class=\"n\">path</span><span class=\"p\">,</span> <span class=\"n\">include</span>\n\n<span class=\"n\">urlpatterns</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"c1\"># ...</span>\n    <span class=\"n\">path</span><span class=\"p\">(</span><span class=\"s1\">'datawizard/'</span><span class=\"p\">,</span> <span class=\"n\">include</span><span class=\"p\">(</span><span class=\"s1\">'data_wizard.urls'</span><span class=\"p\">)),</span>\n<span class=\"p\">]</span>\n</pre>\n<blockquote>\n<p>Note: If you are upgrading from 1.0, you will need to update your URLs to add the <code>datawizard/</code> prefix as shown above.</p>\n</blockquote>\n<h3>Target Model Registration</h3>\n<p>In order to use the wizard, you <strong>must</strong> register one or more target models and/or serializers.  Target model registration helps the wizard know where to put the data it finds in each row of the source spreadsheet.  (By contrast, <em>source</em> model registration is optional, as long as you are using the provided <code>data_wizard.sources</code> app.)</p>\n<p>The registration API is modeled after the  Django admin and <code>admin.py</code>.  Specifically, Data Wizard will look for a <code>wizard.py</code> file in your app directory, which should have the following structure:</p>\n<pre><span class=\"c1\"># myapp/wizard.py</span>\n<span class=\"kn\">import</span> <span class=\"nn\">data_wizard</span>\n<span class=\"kn\">from</span> <span class=\"nn\">.models</span> <span class=\"kn\">import</span> <span class=\"n\">MyModel</span>\n\n<span class=\"n\">data_wizard</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"n\">MyModel</span><span class=\"p\">)</span>\n</pre>\n<p>Internally, the wizard will automatically create a Django REST Framework serializer class corresponding to the target model.  If needed, you can also specify a <a href=\"#custom-serializers\" rel=\"nofollow\">custom serializer class</a> to configure how the target model is validated and populated.</p>\n<p>Once everything is configured, upload a source file in the Django admin, select \"Import via data wizard\" from the admin actions menu, and navigate through the screens described below.</p>\n<h2>API Documentation</h2>\n<p>Django Data Wizard is implemented as a series of views that can be accessed via the Django admin as well as via a JSON API.</p>\n<hr>\n<p><img align=\"right\" alt=\"Select Source &amp; Start Import\" height=\"240\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/44d4313416412149555a1d3cd10c0cfbd1b384f2/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f41322d736f757263652d6c6973742e706e67\" width=\"320\"></p>\n<h3>New Run</h3>\n<h4><code>POST /datawizard/</code></h4>\n<p>Creates a new instance of the wizard (i.e. a <code>Run</code>).  If you are using the Django admin integration, this step is executed when you select \"Import via Data Wizard\" from the admin actions menu.  If you are using the JSON API, the returned run <code>id</code> should be used in all subsequent calls to the API.  Each <code>Run</code> is tied to the source model via a <a href=\"https://docs.djangoproject.com/en/1.11/ref/contrib/contenttypes/\" rel=\"nofollow\">generic foreign key</a>.</p>\n<table>\n<thead>\n<tr>\n<th>parameter</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>object_id</code></td>\n<td>The primary key of the <em>source</em> model instance containing the data to be imported.</td>\n</tr>\n<tr>\n<td><code>content_type_id</code></td>\n<td>The <em>source</em> model's app label and model name (in the format <code>app_label.modelname</code>).</td>\n</tr>\n<tr>\n<td><code>loader</code></td>\n<td>(Optional) The class name to use for loading the source dataset via <a href=\"https://github.com/wq/itertable\" rel=\"nofollow\">IterTable</a>.  The default loader (<code>data_wizard.loaders.FileLoader</code>) assumes that the source model contains a <code>FileField</code> named <code>file</code>.</td>\n</tr>\n<tr>\n<td><code>serializer</code></td>\n<td>(Optional) The serializer class to use when populating the <em>target</em> model.  This can be left unset to allow the user to select the target during the wizard run.</td>\n</tr></tbody></table>\n<hr>\n<p><img align=\"right\" alt=\"Auto Import - Progress Bar\" height=\"240\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/806235d37767e042f60c04836d3b2587c797a7f4/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f30362d6461746132352e706e67\" width=\"320\"></p>\n<h3>auto</h3>\n<h4><code>POST /datawizard/[id]/auto</code></h4>\n<p>The <code>auto</code> task attempts to run the entire data wizard process from beginning to end.  If any input is needed, the import will halt and redirect to the necessary screen.  If no input is needed, the <code>auto</code> task is equivalent to starting the <code>data</code> task directly.  This is an asynchronous method, and returns a <code>task_id</code> to be used with the status API.</p>\n<p>The <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_detail.html\" rel=\"nofollow\">run_detail.html</a> template provides an example form that initiates the <code>auto</code> task.  The <code>auto</code> task itself uses the <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_auto.html\" rel=\"nofollow\">run_auto.html</a> template.</p>\n<hr>\n<h3>status</h3>\n<h4><code>GET /datawizard/[id]/status.json?task=[task]</code></h4>\n<p>The <code>status</code> API is used to check the status of an asynchronous task (one of <code>auto</code> or <code>data</code>).  The API is used by the provided <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/static/data_wizard/js/progress.js\" rel=\"nofollow\">data_wizard/js/progress.js</a> to update the <code>&lt;progress&gt;</code> bar in the <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_auto.html\" rel=\"nofollow\">run_auto.html</a> and <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_data.html\" rel=\"nofollow\">run_data.html</a> templates.  Unlike the other methods, this API is JSON-only and has no HTML equivalent.  An object of the following format will be returned:</p>\n<pre><span class=\"p\">{</span>\n    <span class=\"c1\">// General properties</span>\n    <span class=\"s2\">\"status\"</span><span class=\"o\">:</span> <span class=\"s2\">\"PROGRESS\"</span><span class=\"p\">,</span> <span class=\"c1\">// or \"SUCCESS\", \"FAILURE\"</span>\n    <span class=\"s2\">\"stage\"</span><span class=\"o\">:</span> <span class=\"s2\">\"meta\"</span><span class=\"p\">,</span>      <span class=\"c1\">// or \"data\"</span>\n    <span class=\"s2\">\"current\"</span><span class=\"o\">:</span> <span class=\"mi\">23</span><span class=\"p\">,</span>        <span class=\"c1\">// currently processing row</span>\n    <span class=\"s2\">\"total\"</span><span class=\"o\">:</span> <span class=\"mi\">100</span><span class=\"p\">,</span>         <span class=\"c1\">// total number of rows</span>\n\n    <span class=\"c1\">// \"FAILURE\"</span>\n    <span class=\"s2\">\"error\"</span><span class=\"o\">:</span> <span class=\"s2\">\"Error Message\"</span><span class=\"p\">,</span>\n\n    <span class=\"c1\">// Task complete (\"SUCCESS\")</span>\n    <span class=\"s2\">\"action\"</span><span class=\"o\">:</span> <span class=\"s2\">\"records\"</span><span class=\"p\">,</span>        <span class=\"c1\">// or \"serializers\", \"columns\" \"ids\"</span>\n    <span class=\"s2\">\"message\"</span><span class=\"o\">:</span> <span class=\"s2\">\"Input Needed\"</span><span class=\"p\">,</span>  <span class=\"c1\">// if action is not \"records\"</span>\n    <span class=\"s2\">\"skipped\"</span><span class=\"o\">:</span> <span class=\"p\">[...],</span>           <span class=\"c1\">// rows that could not be imported</span>\n    <span class=\"s2\">\"location\"</span><span class=\"o\">:</span> <span class=\"s2\">\"/datawizard/[id]/records\"</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n</pre>\n<p>The potential values for the  <code>status</code> field are the same as common <a href=\"http://docs.celeryproject.org/en/latest/userguide/tasks.html#task-states\" rel=\"nofollow\">Celery task states</a>, even when not using the <code>celery</code> backend.  When running an <code>auto</code> task, the result is <code>SUCCESS</code> whenever the task ends without errors, even if there is additional input needed to fully complete the run.</p>\n<p>The default <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_auto.html\" rel=\"nofollow\">run_auto.html</a> and <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_data.html\" rel=\"nofollow\">run_data.html</a> templates include a <code>&lt;progress&gt;</code> element for use with the status task.</p>\n<hr>\n<p><img align=\"right\" alt=\"Serializer Choices\" height=\"240\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/efcce372d93811326ec300b433dadb53803fdd6b/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f30302d73657269616c697a6572732e706e67\" width=\"320\"></p>\n<h3>serializers</h3>\n<h4><code>GET /datawizard/[id]/serializers</code></h4>\n<p>The <code>serializers</code> task provides a list of all registered serializers (i.e. target models).  This screen is shown by the <code>auto</code> task if a serializer was not specified when the <code>Run</code> was created.  The default <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_serializers.html\" rel=\"nofollow\">run_serializers.html</a> template includes an interface for selecting a target.  If a serializer is already selected, the template will display the label and a button to (re)start the <code>auto</code> task.</p>\n<br>\n<hr>\n<p><img align=\"right\" alt=\"Serializer Selected\" height=\"240\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/33d7862fc3774658815847429d5acd4dd97d69ef/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f30312d75706461746573657269616c697a65722e706e67\" width=\"320\"></p>\n<h3>updateserializer</h3>\n<h4><code>POST /datawizard/[id]/updateserializer</code></h4>\n<p>The <code>updateserializer</code> task updates the specified <code>Run</code> with the selected target serializer name.  This is typically called from <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_serializers.html\" rel=\"nofollow\">the form</a> generated by the <code>serializers</code> task, and will redirect to that task when complete.</p>\n<table>\n<thead>\n<tr>\n<th>parameter</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>serializer</code></td>\n<td>The class name (or label) of the target serializer to use for this run.</td>\n</tr></tbody></table>\n<hr>\n<p><img align=\"right\" alt=\"Column Choices\" height=\"240\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ef92cc9986f1639fa8b31c5fb92f8af164e0f05d/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f30322d636f6c756d6e732e706e67\" width=\"320\"></p>\n<h3>columns</h3>\n<h4><code>GET /datawizard/[id]/columns</code></h4>\n<p>The <code>columns</code> task lists all of the columns found in the source dataset (i.e. spreadsheet) and their mappings to target serializer fields.  This screen is shown by the <code>auto</code> task if there are any column names that could not be automatically mapped.  The potential mappings are one of:</p>\n<ul>\n<li>simple serializer field names (e.g. <code>field</code>)</li>\n<li>nested field names (for <a href=\"https://github.com/wq/django-natural-keys\" rel=\"nofollow\">natural keys</a>, e.g. <code>nested[record][field]</code>)</li>\n<li><a href=\"https://wq.io/docs/eav-vs-relational\" rel=\"nofollow\">EAV</a> attribute-value mappings (e.g. <code>values[][value];attribute_id=1</code>).  Note that EAV support requires a <a href=\"#custom-serializers\" rel=\"nofollow\">custom serializer class</a>.</li>\n</ul>\n<p>The default <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_columns.html\" rel=\"nofollow\">run_columns.html</a> template includes an interface for mapping data columns to serializer fields.  If all columns are already mapped, the template will display the mappings and a button to (re)start the <code>auto</code> task.</p>\n<hr>\n<p><img align=\"right\" alt=\"Columns Selected\" height=\"240\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/81ca582a117cdd4f388f497bd394a7dbd981a33c/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f30332d757064617465636f6c756d6e732e706e67\" width=\"320\"></p>\n<h3>updatecolumns</h3>\n<h4><code>POST /datawizard/[id]/updatecolumns</code></h4>\n<p>The <code>updatecolumns</code> task saves the specified mappings from source data columns to target serializer fields.  This is typically called from <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_columns.html\" rel=\"nofollow\">the form</a> generated by the <code>columns</code> task, and will redirect to that task when complete.</p>\n<table>\n<thead>\n<tr>\n<th>parameter</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>rel_[relid]</code></td>\n<td>The column to map to the specified serializer field.  The <code>relid</code> and the complete list of possible mappings will be provided by the <code>columns</code> task.</td>\n</tr></tbody></table>\n<hr>\n<p><img align=\"right\" alt=\"Identifier Choices\" height=\"240\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3682d4178a49db3a8358b8d4c49ef0e0a8068212/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f30342d6964732e706e67\" width=\"320\"></p>\n<h3>ids</h3>\n<h4><code>GET /datawizard/[id]/ids</code></h4>\n<p>The <code>ids</code> task lists all of the foreign key values found in the source dataset (i.e. spreadsheet).  If there are any unmapped foreign key values, the auto task will stop and redirect to the <code>ids</code> task.  The default <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_ids.html\" rel=\"nofollow\">run_ids.html</a> template includes an interface for mapping row identifiers to foreign key values.  The potential mappings depend on the serializer field used to represent the foreign key.</p>\n<ul>\n<li>For <a href=\"http://www.django-rest-framework.org/api-guide/relations/#primarykeyrelatedfield\" rel=\"nofollow\">PrimaryKeyRelatedField</a>, <a href=\"http://www.django-rest-framework.org/api-guide/relations/#slugrelatedfield\" rel=\"nofollow\">SlugRelatedField</a>, and <a href=\"https://github.com/wq/django-natural-keys\" rel=\"nofollow\">NaturalKeySerializer</a>, the choices will include all existing record ID or slugs.</li>\n<li>For <code>NaturalKeySerializer</code> only, a<code>\"new\"</code> choice will also be included, allowing for the possibility of creating new records in the foreign table on the fly.</li>\n</ul>\n<p>Once all ids are mapped, the template will display the mappings and a button to (re)start the <code>auto</code> task.</p>\n<p>Note that the <code>auto</code> task will skip the <code>ids</code> task entirely if any of the following are true:</p>\n<ul>\n<li>The file contains no foreign key columns</li>\n<li>All foreign key values were already mapped during a previous import run</li>\n<li>All foreign key values can be automatically mapped via the <code>DATA_WIZARD['IDMAP']</code> setting:</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><code>DATA_WIZARD['IDMAP']</code></th>\n<th>notes</th>\n<th>detail</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\"data_wizard.idmap.never\"</code></td>\n<td>Default\u00a0in\u00a01.x</td>\n<td>Require user to manually map all IDs the first time they are found in a file</td>\n</tr>\n<tr>\n<td><code>\"data_wizard.idmap.existing\"</code></td>\n<td>New\u00a0in\u00a01.3, Default\u00a0in\u00a02.0</td>\n<td>Automatically map existing IDs, but require user to map unknown ids</td>\n</tr>\n<tr>\n<td><code>\"data_wizard.idmap.always\"</code></td>\n<td>New\u00a0in\u00a01.3</td>\n<td>Always map IDs (skip manual mapping).  Unknown IDs will be passed on as-is to the serializer, which will cause per-row errors unless using natural keys.</td>\n</tr>\n<tr>\n<td>(custom import path)</td>\n<td>New\u00a0in\u00a01.3</td>\n<td>The function should accept an identifier and a serializer field, and return the mapped value (or <code>None</code> if no automatic mapping is available).  See the <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/idmap.py\" rel=\"nofollow\">built-in functions</a> for examples.</td>\n</tr></tbody></table>\n<p>Note that the configured <code>IDMAP</code> function will only be called the first time a new identifier is encountered.  Once the mapping is established (manually or automatically), it will be re-used in subsequent wizard runs.</p>\n<hr>\n<p><img align=\"right\" alt=\"Identifiers Selected\" height=\"240\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f1cc64e20fb26ddf9f55710d578159871a9195eb/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f30352d7570646174656964732e706e67\" width=\"320\"></p>\n<h3>updateids</h3>\n<h4><code>POST /datawizard/[id]/updateids</code></h4>\n<p>The <code>updateids</code> task saves the specified mappings from row identifiers to foreign key values.  This is typically called from <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_ids.html\" rel=\"nofollow\">the form</a> generated by the <code>ids</code> task, and will redirect to that task when complete.</p>\n<table>\n<thead>\n<tr>\n<th>parameter</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ident_[identid]_id</code></td>\n<td>The identifier to map to the specified foreign key value.  The <code>identid</code> and the complete list of possible mappings will be provided by the <code>ids</code> task.</td>\n</tr></tbody></table>\n<hr>\n<p><img align=\"right\" alt=\"Auto Import - Progress Bar\" height=\"240\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4f0d117be1d8eceddc0ad98755951ab0074bcf47/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f30382d6461746137352e706e67\" width=\"320\"></p>\n<h3>data</h3>\n<h4><code>POST /datawizard/[id]/data</code></h4>\n<p>The <code>data</code> task starts the actual import process (and is called by <code>auto</code> behind the scenes).  Unlike <code>auto</code>, calling <code>data</code> directly will not cause a redirect to one of the other tasks if any meta input is needed.  Instead, <code>data</code> will attempt to import each record as-is, and report any errors that occured due to e.g. missing fields or unmapped foreign keys.</p>\n<p>This is an asynchronous method, and returns a <code>task_id</code> to be used with the <code>status</code> API.  The default <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_data.html\" rel=\"nofollow\">run_data.html</a> template includes a <code>&lt;progress&gt;</code> element for use with status task.</p>\n<hr>\n<p><img align=\"right\" alt=\"Imported Records\" height=\"240\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a1d70264ed420083571790da73ffd175d1c2af05/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f31302d7265636f7264732e706e67\" width=\"320\"></p>\n<h3>records</h3>\n<h4><code>GET /datawizard/[id]/records</code></h4>\n<p>The <code>records</code> task provides a list of imported rows (including errors).  It is redirected to by the <code>auto</code> and <code>data</code> tasks upon completion.  Successfully imported <code>Record</code> instances will have a <a href=\"https://docs.djangoproject.com/en/1.11/ref/contrib/contenttypes/\" rel=\"nofollow\">generic foreign key</a> pointing to the target model.  The <code>records</code> task will include links to the <code>get_absolute_url()</code> or admin screen for each newly imported target model instance.  The default <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/templates/data_wizard/run_records.html\" rel=\"nofollow\">run_records.html</a> template includes an interface for displaying the record details.</p>\n<br>\n<hr>\n<p><img align=\"right\" alt=\"Run List\" height=\"240\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/91b88fd2fa4fa9a114983e36fb3a365aec22ff92/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f31312d72756e2d6c6973742e706e67\" width=\"320\"></p>\n<h3>Run List</h3>\n<h4><code>GET /datawizard/</code></h4>\n<p>Django Data Wizard provides a list view that summarises prior runs and the number of records imported by each.  Incomplete runs can also be restarted from this list.</p>\n<p><br><br></p>\n<hr>\n<p><img align=\"right\" alt=\"Identifier Admin\" height=\"240\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1f35ec395c7608d50e0f9b1fb8652728f7317859/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f77712f646a616e676f2d646174612d77697a6172642f6d61737465722f696d616765732f41332d6964656e746966696572732e706e67\" width=\"320\"></p>\n<h3>Identifier Admin</h3>\n<h4><code>GET /admin/data_wizard/identifer/</code></h4>\n<p>As of version 1.1.0, Django Data Wizard identifier mappings can be viewed and edited via the Django Admin.  Runs can also be viewed through the admin - though the Run List above will generally be more useful.</p>\n<br>\n<h2>Data Model</h2>\n<p>Django Data Wizard provides a number of Django models that help track the import process, and preserve data mapping decisions for future reuse.  While a <em>source</em> model is required, your <em>target</em> data model(s) generally do not have to be changed to support Data Wizard integration.</p>\n<table>\n<thead>\n<tr>\n<th>step</th>\n<th>description</th>\n<th>model</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>Upload <strong>source</strong> file</td>\n<td>Create <code>FileSource</code> (or custom source model)</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Start data wizard run</td>\n<td>Create <code>Run</code></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Select serializer (&amp; target model)</td>\n<td>Update <code>Run</code></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Map columns to database field names</td>\n<td>One <code>Identifier</code> per column, if needed</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Map cell values to foreign keys</td>\n<td>One <code>Identifier</code> per unique value</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Import data into <strong>target</strong> model</td>\n<td>One <code>Record</code> + one target model instance per row</td>\n</tr></tbody></table>\n<p>The <code>Run</code> model includes a <a href=\"https://docs.djangoproject.com/en/1.11/ref/contrib/contenttypes/\" rel=\"nofollow\">generic foreign key</a> pointing to the source model (e.g. <code>FileSource</code>.)  Each row in the source spreadsheet will be mapped to a <code>Record</code>.  If the row was successfully imported, a new instance of the target data model will be created, and the <code>Record</code> will have a generic foreign key pointing to it.  The <code>Identifier</code> model contains no foreign keys, since identifier mappings are reused for subsequent imports.  Instead, a separate <code>Range</code> model tracks the location(s) (rows/columns) of each <code>Identifier</code> in each <code>Run</code>.</p>\n<p>Note that the above workflow just describes the most common use case.  You can create <a href=\"#custom-serializers\" rel=\"nofollow\">custom serializers</a> that update more than one target data model per spreadsheet row.  And you can specify <a href=\"#custom-data-sources\" rel=\"nofollow\">custom data sources</a> that might not be a spreadsheet or even a file.</p>\n<h2>Command-Line Interface</h2>\n<p>Django Data Wizard provides a single <a href=\"https://docs.djangoproject.com/en/2.1/ref/django-admin/\" rel=\"nofollow\">management command</a>, <code>runwizard</code>, that can be used to initiate the <code>auto</code> task from the command line.  This can be used to facilitate automated processing, for example as part of a regular cron job.  Note that the CLI does not (currently) support interactively mapping columns and ids, so these should be pre-mapped using the web or JSON API.</p>\n<p>Usage:</p>\n<pre>./manage.py runwizard myapp.mymodel <span class=\"m\">123</span> <span class=\"se\">\\</span>\n    --loader myapp.loaders.customloader <span class=\"se\">\\</span>\n    --serializer myapp.serializer.customserializer <span class=\"se\">\\</span>\n    --username myusername\n</pre>\n<p>The basic usage is similar to the <a href=\"#new-run\" rel=\"nofollow\">New Run API</a>.  Only a content type and object id are required, while the other arguments will be auto-detected if possible.  In particular, you may want to use <a href=\"#custom-loader\" rel=\"nofollow\">set_loader()</a> to predefine the default <code>loader</code> and <code>serializer</code> for any models you plan to use with the CLI.</p>\n<p>The <code>runwizard</code> command will create a new <code>Run</code> and immediately start the <code>auto</code> task.  Errors will be shown on the console.</p>\n<h2>Custom Serializers</h2>\n<p>Data Wizard uses instances of Django REST Framework's <a href=\"http://www.django-rest-framework.org/api-guide/serializers/#modelserializer\" rel=\"nofollow\">Serializer class</a> to determine the destination fields on the target model.  Specifically, the default serializer is <a href=\"https://github.com/wq/django-natural-keys#naturalkeymodelserializer\" rel=\"nofollow\">NaturalKeyModelSerializer</a>, which is based on <a href=\"http://www.django-rest-framework.org/api-guide/serializers/#modelserializer\" rel=\"nofollow\">ModelSerializer</a>.</p>\n<p>You can override the default serializer by calling <code>data_wizard.register()</code> with a name and a serializer class instead of a model class.  Multiple serializers can be registered with the wizard to support multiple import configurations and target models.</p>\n<pre><span class=\"c1\"># myapp/wizard.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">rest_framework</span> <span class=\"kn\">import</span> <span class=\"n\">serializers</span>\n<span class=\"kn\">import</span> <span class=\"nn\">data_wizard</span>\n<span class=\"kn\">from</span> <span class=\"nn\">.models</span> <span class=\"kn\">import</span> <span class=\"n\">TimeSeries</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">TimeSeriesSerializer</span><span class=\"p\">(</span><span class=\"n\">serializers</span><span class=\"o\">.</span><span class=\"n\">ModelSerializer</span><span class=\"p\">):</span>\n    <span class=\"c1\"># (custom fields here)</span>\n    <span class=\"k\">class</span> <span class=\"nc\">Meta</span><span class=\"p\">:</span>\n        <span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">TimeSeries</span>\n        <span class=\"n\">fields</span> <span class=\"o\">=</span> <span class=\"s1\">'__all__'</span>\n\n        <span class=\"c1\"># Optional - see options below</span>\n        <span class=\"n\">data_wizard</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'header_row'</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n            <span class=\"s1\">'start_row'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n            <span class=\"s1\">'show_in_list'</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">,</span>\n            <span class=\"s1\">'idmap'</span><span class=\"p\">:</span> <span class=\"n\">data_wizard</span><span class=\"o\">.</span><span class=\"n\">idmap</span><span class=\"o\">.</span><span class=\"n\">existing</span><span class=\"p\">,</span>\n        <span class=\"p\">}</span>\n\n<span class=\"c1\"># Use default name &amp; serializer</span>\n<span class=\"n\">data_wizard</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"n\">TimeSeries</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Use custom name &amp; serializer</span>\n<span class=\"n\">data_wizard</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"s2\">\"Time Series - Custom Serializer\"</span><span class=\"p\">,</span> <span class=\"n\">TimeSeriesSerializer</span><span class=\"p\">)</span>\n</pre>\n<p>At least one serializer or model should be registered in order to use the wizard.  Note the use of a human-friendly serializer label when registering a serializer.  This name should be unique throughout the project, but can be changed later on without breaking existing data.  (The class path is used as the actual identifier behind the scenes.)</p>\n<h3>Serializer Options</h3>\n<p>In general, custom serializers have all the capabilities of regular <a href=\"http://www.django-rest-framework.org/api-guide/serializers/\" rel=\"nofollow\">Django REST Framework serializers</a>, including custom validation rules and the ability to populate multiple target models.  While the <code>request</code> context is not available, information about the run (including the user) can be retrieved through the <code>data_wizard</code> context instead.</p>\n<p>When overriding a serializer for a <a href=\"https://github.com/wq/django-natural-keys\" rel=\"nofollow\">natural key model</a>, be sure to extend <a href=\"https://github.com/wq/django-natural-keys#naturalkeymodelserializer\" rel=\"nofollow\">NaturalKeyModelSerializer</a>, as in <a href=\"https://github.com/wq/django-data-wizard/blob/master/tests/naturalkey_app/wizard.py\" rel=\"nofollow\">this example</a>.  In other cases, extend <a href=\"http://www.django-rest-framework.org/api-guide/serializers/#modelserializer\" rel=\"nofollow\">ModelSerializer</a> (as in the example above) or the base <a href=\"serializers\" rel=\"nofollow\">Serializer</a> class.</p>\n<p>Custom serializers can be used to support <a href=\"https://wq.io/docs/eav-vs-relational\" rel=\"nofollow\">Entity-Attribute-Value</a> spreadsheets where the attribute names are specified as additional columns.  To support this scenario, the <code>Entity</code> serializer should include a nested <code>Value</code> serializer with <code>many=True</code>, and the <code>Value</code> serializer should have a foreign key to the <code>Attribute</code> table, as in <a href=\"https://github.com/wq/django-data-wizard/blob/master/tests/eav_app/wizard.py\" rel=\"nofollow\">this example</a>.</p>\n<p>Data Wizard also supports additional configuration by setting a <code>data_wizard</code> attribute on the <code>Meta</code> class of the serializer.  The following options are supported.</p>\n<table>\n<thead>\n<tr>\n<th>name</th>\n<th>default</th>\n<th>notes</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>header_row</code></td>\n<td>0</td>\n<td>Specifies the first row of the spreadsheet that contains column headers.  If this is greater than 0, the space above the column headers will be scanned for anything that looks like a one-off \"global\" value intended to be applied to every row in the imported data.</td>\n</tr>\n<tr>\n<td><code>start_row</code></td>\n<td>1</td>\n<td>The first row of data.  If this is greater than <code>header_row + 1</code>, the column headers will be assumed to span multiple rows.  A common case is when EAV parameter names are on the first row and units are on the second.</td>\n</tr>\n<tr>\n<td><code>show_in_list</code></td>\n<td><code>True</code></td>\n<td><strong>New in 1.2</strong>.  If set to <code>False</code>, the serializer will be available through the API but not listed in the wizard views.  This is useful if you have a serializer that should only be used during fully automated workflows.</td>\n</tr>\n<tr>\n<td><code>idmap</code></td>\n<td><a href=\"#ids\" rel=\"nofollow\"><code>IDMAP</code> setting</a></td>\n<td><strong>New in 1.3</strong>.  Can be any of <code>data_wizard.idmap.*</code> or a custom function.  Unlike the <code>IDMAP</code> setting, this should always be an actual function and not an import path.</td>\n</tr></tbody></table>\n<h2>Custom Data Sources</h2>\n<p>Django Data Wizard uses <a href=\"https://github.com/wq/itertable\" rel=\"nofollow\">IterTable</a> to determine the source columns present on the spreadsheet or other data source.  Django Data Wizard can use any Django model instance as a source for its data, provided there is a registered loader that can convert the source model into a <a href=\"https://github.com/wq/itertable\" rel=\"nofollow\">Iter class</a>.  Data Wizard provides two out-of-the the box loaders, <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/loaders.py\" rel=\"nofollow\">FileLoader</a> and <a href=\"https://github.com/wq/django-data-wizard/blob/master/data_wizard/loaders.py\" rel=\"nofollow\">URLLoader</a>, that can be used with the provided models in <code>data_wizard.sources</code> (<code>FileSource</code> and <code>URLSource</code>, respectively).</p>\n<h3>Extending FileLoader</h3>\n<p>The default <code>FileLoader</code> can be used with any Django model with a <code>FileField</code> named <code>file</code>.  You can use a model with a different <code>FileField</code> name by creating a subclass of <code>data_wizard.loaders.FileLoader</code> and setting it as the loader for your model.</p>\n<pre><span class=\"c1\"># myapp/models.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.db</span> <span class=\"kn\">import</span> <span class=\"n\">models</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">FileModel</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">spreadsheet</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">FileField</span><span class=\"p\">(</span><span class=\"n\">upload_to</span><span class=\"o\">=</span><span class=\"s1\">'spreadsheets'</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"c1\"># myapp/loaders.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">data_wizard</span> <span class=\"kn\">import</span> <span class=\"n\">loaders</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">FileLoader</span><span class=\"p\">(</span><span class=\"n\">loaders</span><span class=\"o\">.</span><span class=\"n\">FileLoader</span><span class=\"p\">):</span>\n    <span class=\"n\">file_attr</span> <span class=\"o\">=</span> <span class=\"s1\">'spreadsheet'</span>\n</pre>\n<pre><span class=\"c1\"># myapp/wizard.py</span>\n<span class=\"kn\">import</span> <span class=\"nn\">data_wizard</span>\n<span class=\"kn\">from</span> <span class=\"nn\">.models</span> <span class=\"kn\">import</span> <span class=\"n\">FileModel</span>\n\n<span class=\"n\">data_wizard</span><span class=\"o\">.</span><span class=\"n\">set_loader</span><span class=\"p\">(</span><span class=\"n\">FileModel</span><span class=\"p\">,</span> <span class=\"s2\">\"myapp.loaders.FileLoader\"</span><span class=\"p\">)</span>\n</pre>\n<p>If you have a generic loader that can work with multiple source models, you can also set the default loader globally:</p>\n<pre><span class=\"c1\"># myapp/settings.py</span>\n<span class=\"n\">DATA_WIZARD</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'LOADER'</span><span class=\"p\">:</span> <span class=\"s1\">'myapp.loaders.FileLoader'</span>\n<span class=\"p\">}</span>\n</pre>\n<p>As of Django Data Wizard 1.2, you should register a custom <code>ModelAdmin</code> class to add the Import action in the admin panel for your model.</p>\n<pre><span class=\"c1\"># myapp/admin.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.contrib</span> <span class=\"kn\">import</span> <span class=\"n\">admin</span>\n<span class=\"kn\">from</span> <span class=\"nn\">data_wizard.admin</span> <span class=\"kn\">import</span> <span class=\"n\">ImportActionModelAdmin</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">.models</span> <span class=\"kn\">import</span> <span class=\"n\">FileModel</span>\n\n\n<span class=\"nd\">@admin</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"n\">FileModel</span><span class=\"p\">)</span>\n<span class=\"k\">class</span> <span class=\"nc\">FileModelAdmin</span><span class=\"p\">(</span><span class=\"n\">ImportActionModelAdmin</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n</pre>\n<h3>Custom Loader</h3>\n<p>The default loaders support any file format supported by <a href=\"https://github.com/wq/itertable\" rel=\"nofollow\">IterTable</a> (Excel, CSV, JSON, and XML).  Additional formats can be integrating by creating a <a href=\"https://github.com/wq/itertable/blob/master/docs/about.md\" rel=\"nofollow\">custom IterTable class</a> and then registering it with the wizard.  For example, the <a href=\"https://github.com/heigeo/climata-viewer\" rel=\"nofollow\">Climata Viewer</a> uses Django Data Wizard to import data from <a href=\"https://github.com/heigeo/climata\" rel=\"nofollow\">climata</a>'s IterTable-based web service client.  To do this, extend <code>data_wizard.loaders.BaseLoader</code> with a custom <code>load_iter()</code> function that returns the data from IterTable, as in the example below.</p>\n<p>It is likely that you will want to use a specific serializer with your custom loader.  If so, override <code>default_serializer</code> or <code>get_serializer_name()</code> on the loader.  By default, these return <code>None</code>, which requires the user to specify the serializer when creating or executing the <code>Run</code>.</p>\n<pre><span class=\"c1\"># myapp/models.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.db</span> <span class=\"kn\">import</span> <span class=\"n\">models</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">CustomIterSource</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">some_option</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">TextField</span><span class=\"p\">()</span>\n</pre>\n<pre><span class=\"c1\"># myapp/loaders.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">data_wizard</span> <span class=\"kn\">import</span> <span class=\"n\">loaders</span>\n<span class=\"kn\">from</span> <span class=\"nn\">.iter</span> <span class=\"kn\">import</span> <span class=\"n\">CustomIter</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">CustomIterLoader</span><span class=\"p\">(</span><span class=\"n\">loaders</span><span class=\"o\">.</span><span class=\"n\">BaseLoader</span><span class=\"p\">):</span>\n    <span class=\"n\">default_serializer</span> <span class=\"o\">=</span> <span class=\"s1\">'mydataapp.wizard.CustomSerializer'</span>\n    <span class=\"k\">def</span> <span class=\"nf\">load_iter</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">source</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"o\">.</span><span class=\"n\">content_object</span>\n        <span class=\"k\">return</span> <span class=\"n\">CustomIter</span><span class=\"p\">(</span><span class=\"n\">some_option</span><span class=\"o\">=</span><span class=\"n\">source</span><span class=\"o\">.</span><span class=\"n\">some_option</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"c1\"># myapp/wizard.py</span>\n<span class=\"kn\">import</span> <span class=\"nn\">data_wizard</span>\n<span class=\"kn\">from</span> <span class=\"nn\">.models</span> <span class=\"kn\">import</span> <span class=\"n\">CustomIterSource</span>\n\n<span class=\"n\">data_wizard</span><span class=\"o\">.</span><span class=\"n\">set_loader</span><span class=\"p\">(</span><span class=\"n\">CustomIterSource</span><span class=\"p\">,</span> <span class=\"s2\">\"myapp.loaders.CustomIterLoader\"</span><span class=\"p\">)</span>\n</pre>\n<h2>Task Backends</h2>\n<p>As of version 1.1.0, Django Data Wizard <strong>no longer requires</strong> the use of <code>celery</code> as a task runner.  Any of the following backends can be configured with via the <code>BACKEND</code> setting:</p>\n<pre><span class=\"c1\"># myproject/settings.py</span>\n\n<span class=\"n\">DATA_WIZARD</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n   <span class=\"s2\">\"BACKEND\"</span><span class=\"p\">:</span> <span class=\"s2\">\"data_wizard.backends.threading\"</span>  <span class=\"c1\"># Default in 1.1.x</span>\n              <span class=\"s2\">\"data_wizard.backends.immediate\"</span>\n              <span class=\"s2\">\"data_wizard.backends.celery\"</span>     <span class=\"c1\"># Only choice in 1.0.x</span>\n<span class=\"p\">}</span>\n</pre>\n<p>For backwards compatibility with 1.0.x, the default backend reverts to <code>celery</code> if you have <code>CELERY_RESULT_BACKEND</code> defined in your project settings.  However, it is recommended to explicitly set <code>BACKEND</code>, as this behavior may change in a future major version of Data Wizard.</p>\n<h3><code>data_wizard.backends.threading</code></h3>\n<p>The <code>threading</code> backend creates a separate thread for long-running asynchronous tasks (i.e. <code>auto</code> and <code>data</code>).  The threading backend leverages the Django cache to pass results back to the status API.  As of Django Data Wizard 1.1.0, <strong>this backend is the default</strong> unless you have configured Celery.</p>\n<h3><code>data_wizard.backends.immediate</code></h3>\n<p>The <code>immediate</code> backend completes all processing before returning a result to the client, even for the otherwise \"asynchronous\" tasks (<code>auto</code> and <code>data</code>).  This backend is suitable for small spreadsheets, or for working around threading issues.  This backend maintains minimal state, and is not recommended for use cases involving large spreadsheets or multiple simultanous import processes.</p>\n<h3><code>data_wizard.backends.celery</code></h3>\n<p>The <code>celery</code> backend leverages <a href=\"http://www.celeryproject.org/\" rel=\"nofollow\">Celery</a> to handle asynchronous tasks, and is usually used with <a href=\"https://redis.io/\" rel=\"nofollow\">Redis</a> as the memory store.\n<strong>Celery is no longer required to use Django Data Wizard,</strong> unless you would like to use the <code>celery</code> backend.  If so, be sure to configure these libraries first or the REST API may not work as expected.  You can use these steps on Ubuntu:</p>\n<pre><span class=\"c1\"># Install redis and celery</span>\nsudo apt-get install redis-server\npip install celery redis\n</pre>\n<p>Once Redis is installed, configure the following files in your project:</p>\n<pre><span class=\"c1\"># myproject/settings.py</span>\n<span class=\"n\">DATA_WIZARD</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'BACKEND'</span><span class=\"p\">:</span> <span class=\"s1\">'data_wizard.backends.celery'</span>\n<span class=\"p\">}</span>\n<span class=\"n\">CELERY_RESULT_BACKEND</span> <span class=\"o\">=</span> <span class=\"n\">BROKER_URL</span> <span class=\"o\">=</span> <span class=\"s1\">'redis://localhost:6379/1'</span>\n\n<span class=\"c1\"># myproject/celery.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">__future__</span> <span class=\"kn\">import</span> <span class=\"n\">absolute_import</span>\n<span class=\"kn\">from</span> <span class=\"nn\">celery</span> <span class=\"kn\">import</span> <span class=\"n\">Celery</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.conf</span> <span class=\"kn\">import</span> <span class=\"n\">settings</span>\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Celery</span><span class=\"p\">(</span><span class=\"s1\">'myproject'</span><span class=\"p\">)</span>\n<span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">config_from_object</span><span class=\"p\">(</span><span class=\"s1\">'django.conf:settings'</span><span class=\"p\">)</span>\n<span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">autodiscover_tasks</span><span class=\"p\">(</span><span class=\"k\">lambda</span><span class=\"p\">:</span> <span class=\"n\">settings</span><span class=\"o\">.</span><span class=\"n\">INSTALLED_APPS</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># myproject/__init__.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">.celery</span> <span class=\"kn\">import</span> <span class=\"n\">app</span> <span class=\"k\">as</span> <span class=\"n\">celery_app</span>\n</pre>\n<p>Finally, run celery with <code>celery -A myproject</code>.  You may want to use celery's <a href=\"http://docs.celeryproject.org/en/latest/userguide/daemonizing.html\" rel=\"nofollow\">daemonization</a> to keep the process running in the background.  Any time you change your serializer registration, be sure to reload celery in addition to restarting the Django WSGI instance.</p>\n<blockquote>\n<p>Note that the requirement for an extra daemon means this backend can break more easily after a server restart.  Even worse, you may not notice that the backend is down for several months (e.g. until a user tries to import a spreadsheet).  For this reason, <strong>we recommend using one of the other backends</strong> unless you are already using celery for other background processing tasks.</p>\n</blockquote>\n<h2>wq Framework integration</h2>\n<p>The Django Data Wizard has built-in support for integration with the <a href=\"https://wq.io/\" rel=\"nofollow\">wq framework</a>.  On the server, configuration is mostly the same, except that you do not need to add <code>\"data_wizard.urls\"</code> to your urls.py as the wizard will register itself with <a href=\"https://wq.io/wq.db\" rel=\"nofollow\">wq.db</a> instead.</p>\n<p>Data Wizard provides mustache templates for each of the above tasks to integrate with the wq.app UI.  These are rendered on the server and do not need to be included in your JavaScript build.  However, you should install the <a href=\"https://github.com/wq/django-data-wizard/tree/master/packages/progress\" rel=\"nofollow\">@wq/progress</a> plugin via NPM and register it with <a href=\"https://wq.io/docs/app-js\" rel=\"nofollow\">@wq/app</a>.</p>\n<pre><span class=\"c1\">// src/index.js</span>\n<span class=\"kr\">import</span> <span class=\"nx\">app</span> <span class=\"nx\">from</span> <span class=\"s1\">'@wq/app'</span><span class=\"p\">;</span>\n<span class=\"kr\">import</span> <span class=\"nx\">progress</span> <span class=\"nx\">from</span> <span class=\"s1\">'@wq/progress'</span><span class=\"p\">;</span>\n\n<span class=\"nx\">app</span><span class=\"p\">.</span><span class=\"nx\">use</span><span class=\"p\">(</span><span class=\"nx\">progress</span><span class=\"p\">);</span>\n<span class=\"nx\">app</span><span class=\"p\">.</span><span class=\"nx\">init</span><span class=\"p\">(</span><span class=\"nx\">config</span><span class=\"p\">).</span><span class=\"nx\">then</span><span class=\"p\">(...);</span>\n</pre>\n<p>Once everything is set up, add the following <code>&lt;form&gt;</code> to the detail template that wq generates for your source model.  Note that you will need to add this <code>&lt;form&gt;</code> manually even if the source model is one of <code>data_wizard.sources</code>.  After adding the form, be sure to skip template regeneration for the source model.</p>\n<pre><span class=\"c\">&lt;!-- filesource_detail.html --&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">h1</span><span class=\"p\">&gt;</span>{{label}}<span class=\"p\">&lt;/</span><span class=\"nt\">h1</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">a</span> <span class=\"na\">href</span><span class=\"o\">=</span><span class=\"s\">\"{{rt}}/media/{{file}}\"</span> <span class=\"na\">rel</span><span class=\"o\">=</span><span class=\"s\">\"external\"</span><span class=\"p\">&gt;</span>Download File<span class=\"p\">&lt;/</span><span class=\"nt\">a</span><span class=\"p\">&gt;</span>\n\n<span class=\"p\">&lt;</span><span class=\"nt\">form</span> <span class=\"na\">action</span><span class=\"o\">=</span><span class=\"s\">\"{{rt}}/datawizard/\"</span> <span class=\"na\">method</span><span class=\"o\">=</span><span class=\"s\">\"post\"</span><span class=\"p\">&gt;</span>\n  {{&gt;csrf}}\n  <span class=\"p\">&lt;</span><span class=\"nt\">input</span> <span class=\"na\">type</span><span class=\"o\">=</span><span class=\"s\">\"hidden\"</span> <span class=\"na\">name</span><span class=\"o\">=</span><span class=\"s\">\"content_type_id\"</span> <span class=\"na\">value</span><span class=\"o\">=</span><span class=\"s\">\"sources.filesource\"</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;</span><span class=\"nt\">input</span> <span class=\"na\">type</span><span class=\"o\">=</span><span class=\"s\">\"hidden\"</span> <span class=\"na\">name</span><span class=\"o\">=</span><span class=\"s\">\"object_id\"</span> <span class=\"na\">value</span><span class=\"o\">=</span><span class=\"s\">\"{{id}}\"</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;</span><span class=\"nt\">button</span> <span class=\"na\">type</span><span class=\"o\">=</span><span class=\"s\">\"submit\"</span><span class=\"p\">&gt;</span>Import Data from This File<span class=\"p\">&lt;/</span><span class=\"nt\">button</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">form</span><span class=\"p\">&gt;</span>\n</pre>\n\n          </div>"}, "last_serial": 6671882, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "606585319078f94069bcd4d663ce68cb", "sha256": "1ddbc42e5cb24bfffb0bda4beed9c670ef5da0beedb4032417346095fdd0dd7b"}, "downloads": -1, "filename": "data-wizard-1.0.0.tar.gz", "has_sig": false, "md5_digest": "606585319078f94069bcd4d663ce68cb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33656, "upload_time": "2017-07-31T21:47:05", "upload_time_iso_8601": "2017-07-31T21:47:05.385792Z", "url": "https://files.pythonhosted.org/packages/37/f8/d8f1c261513673fb9e7a65de6bde2534e46ffb91117d42afd22811d0f1a6/data-wizard-1.0.0.tar.gz", "yanked": false}], "1.0.0b1": [{"comment_text": "", "digests": {"md5": "d629a87e23c09b459648884f9aad81b3", "sha256": "9d6b839c94c26816c3cfdddc857c41fa8e7b633ff32032ad10c3201e6977eb73"}, "downloads": -1, "filename": "data-wizard-1.0.0b1.tar.gz", "has_sig": false, "md5_digest": "d629a87e23c09b459648884f9aad81b3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13899, "upload_time": "2016-09-08T18:25:58", "upload_time_iso_8601": "2016-09-08T18:25:58.523719Z", "url": "https://files.pythonhosted.org/packages/21/60/c2fbd47f54bcb498cb93a0cfa3ecf4e8f3565c5d2d0f8bc14d1e4ed96f87/data-wizard-1.0.0b1.tar.gz", "yanked": false}], "1.0.0b2": [{"comment_text": "", "digests": {"md5": "5be30c4b6d0d586255b3fa2e459aefeb", "sha256": "75c38810e71ed89cacae29d7d928e00403a910139588f04a7e84129436ca0d06"}, "downloads": -1, "filename": "data-wizard-1.0.0b2.tar.gz", "has_sig": false, "md5_digest": "5be30c4b6d0d586255b3fa2e459aefeb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15647, "upload_time": "2016-11-08T22:22:09", "upload_time_iso_8601": "2016-11-08T22:22:09.896165Z", "url": "https://files.pythonhosted.org/packages/67/f9/217d2e50cb26d1089b73e6d1af7db73c95ebb87af3797c06df40dc414c9d/data-wizard-1.0.0b2.tar.gz", "yanked": false}], "1.0.0rc1": [{"comment_text": "", "digests": {"md5": "0789e01fdd7e009a1b18b497256c09ab", "sha256": "636dd89fc17e3232af0ef5c744c2afbfb9cd3880fd06c03570eb6de5ddda1dd8"}, "downloads": -1, "filename": "data-wizard-1.0.0rc1.tar.gz", "has_sig": false, "md5_digest": "0789e01fdd7e009a1b18b497256c09ab", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25212, "upload_time": "2017-06-16T16:05:47", "upload_time_iso_8601": "2017-06-16T16:05:47.813167Z", "url": "https://files.pythonhosted.org/packages/d9/c4/b1c6639b412f1f751faef2c80dbc95cd8ea6538106f5f6ea6ee64c285ea7/data-wizard-1.0.0rc1.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "0cfe484f1cca211fee3fe02c09e5ad18", "sha256": "f3cdcd87edea3dbef8fb6e23ca25d6be9fe1be14f50005bf92d9724689c13cbc"}, "downloads": -1, "filename": "data-wizard-1.0.1.tar.gz", "has_sig": false, "md5_digest": "0cfe484f1cca211fee3fe02c09e5ad18", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33637, "upload_time": "2017-09-12T20:17:56", "upload_time_iso_8601": "2017-09-12T20:17:56.042543Z", "url": "https://files.pythonhosted.org/packages/9c/41/14688985fbbfaf90c92d179a1e86dc365122a01ca444a13b9078cd1ef93b/data-wizard-1.0.1.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "42edcc26c33ed58e2a75ae362d027907", "sha256": "fb2debe3558525c27a8cc5be82f662ab14c2bfb788d0d80f743e64976acdb8d1"}, "downloads": -1, "filename": "data_wizard-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "42edcc26c33ed58e2a75ae362d027907", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 54622, "upload_time": "2019-03-15T02:33:43", "upload_time_iso_8601": "2019-03-15T02:33:43.049736Z", "url": "https://files.pythonhosted.org/packages/dc/ec/b8f664ac91e719cbd929696cdb0c70041511dcd780cbcb941f46f26642f7/data_wizard-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b53c95293b2ee8d9be165be4558b2629", "sha256": "5794ee5cbcde45009ad1d9356075effdfab67e166da352286ace5117944db1da"}, "downloads": -1, "filename": "data-wizard-1.1.0.tar.gz", "has_sig": false, "md5_digest": "b53c95293b2ee8d9be165be4558b2629", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 573674, "upload_time": "2019-03-15T02:33:45", "upload_time_iso_8601": "2019-03-15T02:33:45.091601Z", "url": "https://files.pythonhosted.org/packages/9a/c1/c8a83e6d9ce22962c64e6ae3cd411fbb1134aa688f7499c3bd6a8e8e9c6e/data-wizard-1.1.0.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "4f3677c3452078636c6fbbaaa6e48a28", "sha256": "591093e4de8c7f763acccb8cccb85a5b7d10f8a68cb4a76f5d49d0563c8a30e0"}, "downloads": -1, "filename": "data_wizard-1.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "4f3677c3452078636c6fbbaaa6e48a28", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 55827, "upload_time": "2019-09-02T03:32:07", "upload_time_iso_8601": "2019-09-02T03:32:07.507450Z", "url": "https://files.pythonhosted.org/packages/23/a5/0c656db9e2f506c2e8395cb70cfa3a21882d5a22f07d95361b4753d0dd5c/data_wizard-1.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8811d51eab583e8ae34744b33e9dca41", "sha256": "800b88da2ae764e10dfadb5a2ff878a0d679d3b0405f066b57b0f44125dee2ec"}, "downloads": -1, "filename": "data-wizard-1.2.0.tar.gz", "has_sig": false, "md5_digest": "8811d51eab583e8ae34744b33e9dca41", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 800800, "upload_time": "2019-09-02T03:32:10", "upload_time_iso_8601": "2019-09-02T03:32:10.052627Z", "url": "https://files.pythonhosted.org/packages/95/14/75597ecb7c0e0724985404bb30c8e91db6013069990d33266d346794dcb7/data-wizard-1.2.0.tar.gz", "yanked": false}], "1.3.0": [{"comment_text": "", "digests": {"md5": "23c010fc5f6e43be26c4d5e0d8e7d3c9", "sha256": "08e25e0ad98c81e779f154dc871752424ce4bab35e6179a143d9a7e756d6cf68"}, "downloads": -1, "filename": "data_wizard-1.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "23c010fc5f6e43be26c4d5e0d8e7d3c9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 58425, "upload_time": "2020-02-21T01:06:18", "upload_time_iso_8601": "2020-02-21T01:06:18.128308Z", "url": "https://files.pythonhosted.org/packages/06/f9/61b014ac5e41b3e77436f07fb9f332717e670ef699efed77a37370b9295a/data_wizard-1.3.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "34eda141b4e213b4dba5c7022b77726e", "sha256": "ae0db10a44e035370b446f15165f7e89cdbc02442a34b22936daba8c8eb8627c"}, "downloads": -1, "filename": "data-wizard-1.3.0.tar.gz", "has_sig": false, "md5_digest": "34eda141b4e213b4dba5c7022b77726e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 919942, "upload_time": "2020-02-21T01:06:21", "upload_time_iso_8601": "2020-02-21T01:06:21.301213Z", "url": "https://files.pythonhosted.org/packages/82/43/96b645119f035cad09c1dbb50f1ac1dc6d0f432f0177130d968fee58d443/data-wizard-1.3.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "23c010fc5f6e43be26c4d5e0d8e7d3c9", "sha256": "08e25e0ad98c81e779f154dc871752424ce4bab35e6179a143d9a7e756d6cf68"}, "downloads": -1, "filename": "data_wizard-1.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "23c010fc5f6e43be26c4d5e0d8e7d3c9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 58425, "upload_time": "2020-02-21T01:06:18", "upload_time_iso_8601": "2020-02-21T01:06:18.128308Z", "url": "https://files.pythonhosted.org/packages/06/f9/61b014ac5e41b3e77436f07fb9f332717e670ef699efed77a37370b9295a/data_wizard-1.3.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "34eda141b4e213b4dba5c7022b77726e", "sha256": "ae0db10a44e035370b446f15165f7e89cdbc02442a34b22936daba8c8eb8627c"}, "downloads": -1, "filename": "data-wizard-1.3.0.tar.gz", "has_sig": false, "md5_digest": "34eda141b4e213b4dba5c7022b77726e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 919942, "upload_time": "2020-02-21T01:06:21", "upload_time_iso_8601": "2020-02-21T01:06:21.301213Z", "url": "https://files.pythonhosted.org/packages/82/43/96b645119f035cad09c1dbb50f1ac1dc6d0f432f0177130d968fee58d443/data-wizard-1.3.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:40:06 2020"}