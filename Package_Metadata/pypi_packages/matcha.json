{"info": {"author": "hirokiky", "author_email": "hirokiky@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Web Environment", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Topic :: Internet :: WWW/HTTP", "Topic :: Internet :: WWW/HTTP :: WSGI", "Topic :: Internet :: WWW/HTTP :: WSGI :: Middleware"], "description": "======\nmatcha\n======\n\nA WSGI dispatcher.\n\n.. image:: https://travis-ci.org/hirokiky/matcha.png\n   :target: https://travis-ci.org/hirokiky/matcha\n\nAt a glance\n===========\nmatcha is a dispatcher for all WSGI application\nbased on a matching pattern of PATH_INFO in environ.\n\nLet's register your WSGI applications to matchings and\ncreate WSGI application.\n\n.. code-block:: python\n\n    >>> from wsgiref.simple_server import make_server\n    >>> from matcha import Matching as m, bundle, make_wsgi_app\n    >>>\n    >>> from yourproject import home_app\n    >>> from yourproject.blog import post_list_app, post_detail_app\n    >>>\n    >>>\n    >>> matching = bundle(\n    ...     m('/', home_app, 'home'),\n    ...     m('/post/', post_list_app, 'post_list'),\n    ...     m('/post/{post_slug}/', post_detail_app, 'post_detail'),\n    ... )\n    >>>\n    >>> if __name__ == '__main__':\n    ...     app = make_wsgi_app(matching)\n    ...\n    ...     httpd = make_server('', 8000, app)\n    ...     httpd.serve_forever()\n\nNow, accessing from your browser:\n\n* http://127.0.0.1:8000/ => home_app will be called\n* http://127.0.0.1:8000/post/ => post_list_app will be called\n* http://127.0.0.1:8000/post/some_slug/ => post_detail_app will be called\n\nURL arguments\n=============\nWhen path elements covered with braces, this handled as **URL arguments**.\nThis path element can match any string and you can use that string\nin your WSGI application.\n\nThe URL arguments can get from *environ['matcha.matched_dict']*\nin your WSGI application.\nFor instance, accessing to **'/post/hello_world/'**,\nyou can get **'hello_world'** string as URL arguments like this:\n\n.. code-block:: python\n\n   >>> # In post_detail_app:\n   >>> environ['matcha.matched_dict']\n   {'post_slug': 'hello_world'}\n\nWildcard\n=========\nIf the last element in pattern starts with '*',\nthe following string is considered as `wildcard_name`.\nAnd correspond path will always match.\n\n.. code-block:: python\n\n   >>> matching = bundle(\n       m('/', home_app, 'home'),\n       m('/docs/*doc_tree', document_app, 'docs')\n   )\n\nAnd then, you can access them:\n\n* http://127.0.0.1:8000/ => home_app\n* http://127.0.0.1:8000/docs => document_app\n* http://127.0.0.1:8000/docs/about => document_app\n* http://127.0.0.1:8000/docs/about/contributing => document_app\n\nAfter /docs/ it will match any cases.\n\nAnd getting the argument.\n\n.. code-block:: python\n\n   >>> # In document_app, when accessed by '/docs/about/contributing'\n   >>> environ['matcha.mathed_dict']\n   {'doc_tree', ['about', 'contributing']}\n   >>> environ['PATH_INFO']\n   '/about/contributing'\n   >>> environ['SCRIPT_NAME']\n   '/docs'\n\nYou can also use this implementation to call another WSGI application\nsuch as dispatching again by using the left PATH_INFO\n\nReversing\n=========\nWeb pages usually contains some URLs for a another page.\nIn this case, post list page is for showing URLs\nto each Blog posts (to post_detail application).\n\nLet's take URL to post_detail application. You can do like this:\n\n.. code-block:: python\n\n   >>> # In post_list_app\n   >>> matching = environ['matcha.matching']\n   >>> matching.reverse('post_detail', post_slug='about_matcha')\n   '/post/about_matcha/'\n\n* The first positional argument is a signature string for applications.\n  It provided as the third argument of each Matching's constructors.\n* The keyword argument is a string to fill up the URL arguments.\n* Careflly, reverse method will raise NotReverced exception when\n  any URLs is not matched.\n\nOK. and then, you can provide this URL to some TemplateEngines\nto display HTML pages.\n\nIncluding another matchings\n===========================\nFor more reusability, let's separate applications for blogs\nfrom core matching.\n\n.. code-block:: python\n\n   # In yourproject/blog/matching.py file\n   \n   from matcha import Matching as m, bundle\n   \n   from yourproject.blog import post_list_app, post_detail_app\n\n\n   matching = bundle(\n       m('/', post_list_app, 'post_list'),\n       m('/{post_slug}/', post_detail_app, 'post_detail'),\n   )\n\nAnd then, applying this to core by using *include* function:\n\n.. code-block:: python\n\n    >>> from matcha import include\n    >>> from yourproject.blog.matching import matching as blog_matching\n    >>>\n    >>> matching = bundle(\n    ...     m('/', home_app, 'home'),\n    ...     include('/post/', blog_matching)\n    ... )\n\nMatching paths will be like this:\n\n* `/` => home application\n* `/post/` => post_list application\n* `/post/some_slug/` => post_detail application\n\nBy using *include*, you can separate paths based on each applications\nand avoid repeating of descriptions (such as '/post/').\n\nName for reverisng to childs are not affected in any way.\nThis value should be unique, even in the all of matchings\n(fixed in matcha 0.3):\n\n.. code-block:: python\n\n    >>> matching.reverse('post_detail', post_slug='some_slug')\n    '/post/some_slug/'\n\nSetting your 404 WSGI application\n=================================\nThe path matching failed the maked application by matcha will\nreturn a plain 404 page.\nBut most cases, you want to custorm this page more friendly\nfor users.\n\nFor solving this, *matcha.make_wsgi_app* can take `not_found_app`\nkeyword argument to provide your own WSGI application for showing\n404 page.\n\nBy default, the not_found_app is matcha.not_found_app.\n\nWhat is Matching objects\n========================\nAlmost core features provided by matcha dispatcher\nis implamented as Matching objects.\n\nNow, through above example, you recognize matching is like this:\n\n* matching is created by using bundle function and Matching class.\n* Registering WSGI apllications to matching.\n* matching can get from environ dictionaly\n\nNot wrong, but Matching class is something more flexible than\nyour recognition.\n\nCalling\n-------\nmatching is callable\n\n* taking environ dictionary\n* sideeffecting environ dictionary\n* returning matched case and dictionary\n\nThat sideeffection is for PATH_INFO and SCRIPT_NAME to tell\nwhich path elements are processed to another WSGI application.\n\n.. code-block:: python\n\n   >>> environ = {'PATH_INFO': '/htt', 'SCRIPT_NAME': '/about'}\n   >>> Matching('/htt', about_htt_app)(environ)\n   (about_htt_app, {})\n   >>> environ\n   {'PATH_INFO': '', 'SCRIPT_NAME': '/about/htt'}\n\nGetitem from matching\n---------------------\ncailling of matching requires environ dictionaly, but using getitem\nyou can only apply path to get matched case and dictionaly.\n\n.. code-block:: python\n\n   >>> Matching('/htt', about_htt_app)['/htt']\n   (about_htt_app, {})\n\nRegistering not only WSGI app\n-----------------------------\nSecond positional argument (*case* keyword argument) of Matching class\ncan take any objects you like, not only WSGI app.\n\n.. code-block:: python\n\n    >>> Matching('/home', 'home')['/home']\n    ('home', {})\n    \nFor instance, you can register strings and use this as signature\nfor some views. something like **route_name** on\n`Pyramid <http://www.pylonsproject.org/>`_.\n\nAdding matchings\n----------------\nActually, *bundle* function used in above examples is just for\nadding provided positional arguments (addable objects).\nSo you can make WSGI application without this function:\n\n.. code-block:: python\n\n    >>> app = make_wsgi_app(\n    ...     Matching('/', home_app) + \\\n    ...     Matching('/abount', about_app)\n    ... )\n\nThanks\n======\nmatcha dispatcher has been influenced these dispatchers:\n\n* `Django <https://github.com/django/django/>`_ 's URL dispatcher\n* `WebDispatch <https://github.com/aodag/WebDispatch>`_\n* `gargant.dispatch <https://github.com/hirokiky/gargant.dispatch>`_\n\nThanks for them.\n\nResources\n=========\n* `PyPI <https://pypi.python.org/pypi/matcha>`_\n* `Repository <https://github.com/hirokiky/matcha>`_\n* `Testing <https://travis-ci.org/hirokiky/matcha>`_\n\nChanges\n===========\n\n0.3\n-----\n\nUn-supporting name argument on include function\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nBefore this change, user applied include name,\nthe reversing in included app will break, because\nthe name for reversing already changed.\n\n0.2\n-----\n* Supporting Wildcard\n\n0.1\n-----\n\nInitial release.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/hirokiky/matcha", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "matcha", "package_url": "https://pypi.org/project/matcha/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/matcha/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/hirokiky/matcha"}, "release_url": "https://pypi.org/project/matcha/0.3/", "requires_dist": null, "requires_python": null, "summary": "A WSGI dispatcher.", "version": "0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>A WSGI dispatcher.</p>\n<a href=\"https://travis-ci.org/hirokiky/matcha\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/hirokiky/matcha.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0e3ac32c2028933c90437ef687bf28485bc50029/68747470733a2f2f7472617669732d63692e6f72672f6869726f6b696b792f6d61746368612e706e67\"></a>\n<div id=\"at-a-glance\">\n<h2>At a glance</h2>\n<p>matcha is a dispatcher for all WSGI application\nbased on a matching pattern of PATH_INFO in environ.</p>\n<p>Let\u2019s register your WSGI applications to matchings and\ncreate WSGI application.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">wsgiref.simple_server</span> <span class=\"kn\">import</span> <span class=\"n\">make_server</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">matcha</span> <span class=\"kn\">import</span> <span class=\"n\">Matching</span> <span class=\"k\">as</span> <span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">bundle</span><span class=\"p\">,</span> <span class=\"n\">make_wsgi_app</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">yourproject</span> <span class=\"kn\">import</span> <span class=\"n\">home_app</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">yourproject.blog</span> <span class=\"kn\">import</span> <span class=\"n\">post_list_app</span><span class=\"p\">,</span> <span class=\"n\">post_detail_app</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">matching</span> <span class=\"o\">=</span> <span class=\"n\">bundle</span><span class=\"p\">(</span>\n<span class=\"o\">...</span>     <span class=\"n\">m</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">,</span> <span class=\"n\">home_app</span><span class=\"p\">,</span> <span class=\"s1\">'home'</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>     <span class=\"n\">m</span><span class=\"p\">(</span><span class=\"s1\">'/post/'</span><span class=\"p\">,</span> <span class=\"n\">post_list_app</span><span class=\"p\">,</span> <span class=\"s1\">'post_list'</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>     <span class=\"n\">m</span><span class=\"p\">(</span><span class=\"s1\">'/post/</span><span class=\"si\">{post_slug}</span><span class=\"s1\">/'</span><span class=\"p\">,</span> <span class=\"n\">post_detail_app</span><span class=\"p\">,</span> <span class=\"s1\">'post_detail'</span><span class=\"p\">),</span>\n<span class=\"o\">...</span> <span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>     <span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">make_wsgi_app</span><span class=\"p\">(</span><span class=\"n\">matching</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n<span class=\"o\">...</span>     <span class=\"n\">httpd</span> <span class=\"o\">=</span> <span class=\"n\">make_server</span><span class=\"p\">(</span><span class=\"s1\">''</span><span class=\"p\">,</span> <span class=\"mi\">8000</span><span class=\"p\">,</span> <span class=\"n\">app</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>     <span class=\"n\">httpd</span><span class=\"o\">.</span><span class=\"n\">serve_forever</span><span class=\"p\">()</span>\n</pre>\n<p>Now, accessing from your browser:</p>\n<ul>\n<li><a href=\"http://127.0.0.1:8000/\" rel=\"nofollow\">http://127.0.0.1:8000/</a> =&gt; home_app will be called</li>\n<li><a href=\"http://127.0.0.1:8000/post/\" rel=\"nofollow\">http://127.0.0.1:8000/post/</a> =&gt; post_list_app will be called</li>\n<li><a href=\"http://127.0.0.1:8000/post/some_slug/\" rel=\"nofollow\">http://127.0.0.1:8000/post/some_slug/</a> =&gt; post_detail_app will be called</li>\n</ul>\n</div>\n<div id=\"url-arguments\">\n<h2>URL arguments</h2>\n<p>When path elements covered with braces, this handled as <strong>URL arguments</strong>.\nThis path element can match any string and you can use that string\nin your WSGI application.</p>\n<p>The URL arguments can get from <em>environ[\u2018matcha.matched_dict\u2019]</em>\nin your WSGI application.\nFor instance, accessing to <strong>\u2018/post/hello_world/\u2019</strong>,\nyou can get <strong>\u2018hello_world\u2019</strong> string as URL arguments like this:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># In post_detail_app:</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">environ</span><span class=\"p\">[</span><span class=\"s1\">'matcha.matched_dict'</span><span class=\"p\">]</span>\n<span class=\"p\">{</span><span class=\"s1\">'post_slug'</span><span class=\"p\">:</span> <span class=\"s1\">'hello_world'</span><span class=\"p\">}</span>\n</pre>\n</div>\n<div id=\"wildcard\">\n<h2>Wildcard</h2>\n<p>If the last element in pattern starts with \u2018*\u2019,\nthe following string is considered as <cite>wildcard_name</cite>.\nAnd correspond path will always match.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">matching</span> <span class=\"o\">=</span> <span class=\"n\">bundle</span><span class=\"p\">(</span>\n    <span class=\"n\">m</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">,</span> <span class=\"n\">home_app</span><span class=\"p\">,</span> <span class=\"s1\">'home'</span><span class=\"p\">),</span>\n    <span class=\"n\">m</span><span class=\"p\">(</span><span class=\"s1\">'/docs/*doc_tree'</span><span class=\"p\">,</span> <span class=\"n\">document_app</span><span class=\"p\">,</span> <span class=\"s1\">'docs'</span><span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</pre>\n<p>And then, you can access them:</p>\n<ul>\n<li><a href=\"http://127.0.0.1:8000/\" rel=\"nofollow\">http://127.0.0.1:8000/</a> =&gt; home_app</li>\n<li><a href=\"http://127.0.0.1:8000/docs\" rel=\"nofollow\">http://127.0.0.1:8000/docs</a> =&gt; document_app</li>\n<li><a href=\"http://127.0.0.1:8000/docs/about\" rel=\"nofollow\">http://127.0.0.1:8000/docs/about</a> =&gt; document_app</li>\n<li><a href=\"http://127.0.0.1:8000/docs/about/contributing\" rel=\"nofollow\">http://127.0.0.1:8000/docs/about/contributing</a> =&gt; document_app</li>\n</ul>\n<p>After /docs/ it will match any cases.</p>\n<p>And getting the argument.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># In document_app, when accessed by '/docs/about/contributing'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">environ</span><span class=\"p\">[</span><span class=\"s1\">'matcha.mathed_dict'</span><span class=\"p\">]</span>\n<span class=\"p\">{</span><span class=\"s1\">'doc_tree'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'about'</span><span class=\"p\">,</span> <span class=\"s1\">'contributing'</span><span class=\"p\">]}</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">environ</span><span class=\"p\">[</span><span class=\"s1\">'PATH_INFO'</span><span class=\"p\">]</span>\n<span class=\"s1\">'/about/contributing'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">environ</span><span class=\"p\">[</span><span class=\"s1\">'SCRIPT_NAME'</span><span class=\"p\">]</span>\n<span class=\"s1\">'/docs'</span>\n</pre>\n<p>You can also use this implementation to call another WSGI application\nsuch as dispatching again by using the left PATH_INFO</p>\n</div>\n<div id=\"reversing\">\n<h2>Reversing</h2>\n<p>Web pages usually contains some URLs for a another page.\nIn this case, post list page is for showing URLs\nto each Blog posts (to post_detail application).</p>\n<p>Let\u2019s take URL to post_detail application. You can do like this:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># In post_list_app</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">matching</span> <span class=\"o\">=</span> <span class=\"n\">environ</span><span class=\"p\">[</span><span class=\"s1\">'matcha.matching'</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">matching</span><span class=\"o\">.</span><span class=\"n\">reverse</span><span class=\"p\">(</span><span class=\"s1\">'post_detail'</span><span class=\"p\">,</span> <span class=\"n\">post_slug</span><span class=\"o\">=</span><span class=\"s1\">'about_matcha'</span><span class=\"p\">)</span>\n<span class=\"s1\">'/post/about_matcha/'</span>\n</pre>\n<ul>\n<li>The first positional argument is a signature string for applications.\nIt provided as the third argument of each Matching\u2019s constructors.</li>\n<li>The keyword argument is a string to fill up the URL arguments.</li>\n<li>Careflly, reverse method will raise NotReverced exception when\nany URLs is not matched.</li>\n</ul>\n<p>OK. and then, you can provide this URL to some TemplateEngines\nto display HTML pages.</p>\n</div>\n<div id=\"including-another-matchings\">\n<h2>Including another matchings</h2>\n<p>For more reusability, let\u2019s separate applications for blogs\nfrom core matching.</p>\n<pre><span class=\"c1\"># In yourproject/blog/matching.py file</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">matcha</span> <span class=\"kn\">import</span> <span class=\"n\">Matching</span> <span class=\"k\">as</span> <span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">bundle</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">yourproject.blog</span> <span class=\"kn\">import</span> <span class=\"n\">post_list_app</span><span class=\"p\">,</span> <span class=\"n\">post_detail_app</span>\n\n\n<span class=\"n\">matching</span> <span class=\"o\">=</span> <span class=\"n\">bundle</span><span class=\"p\">(</span>\n    <span class=\"n\">m</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">,</span> <span class=\"n\">post_list_app</span><span class=\"p\">,</span> <span class=\"s1\">'post_list'</span><span class=\"p\">),</span>\n    <span class=\"n\">m</span><span class=\"p\">(</span><span class=\"s1\">'/</span><span class=\"si\">{post_slug}</span><span class=\"s1\">/'</span><span class=\"p\">,</span> <span class=\"n\">post_detail_app</span><span class=\"p\">,</span> <span class=\"s1\">'post_detail'</span><span class=\"p\">),</span>\n<span class=\"p\">)</span>\n</pre>\n<p>And then, applying this to core by using <em>include</em> function:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">matcha</span> <span class=\"kn\">import</span> <span class=\"n\">include</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">yourproject.blog.matching</span> <span class=\"kn\">import</span> <span class=\"n\">matching</span> <span class=\"k\">as</span> <span class=\"n\">blog_matching</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">matching</span> <span class=\"o\">=</span> <span class=\"n\">bundle</span><span class=\"p\">(</span>\n<span class=\"o\">...</span>     <span class=\"n\">m</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">,</span> <span class=\"n\">home_app</span><span class=\"p\">,</span> <span class=\"s1\">'home'</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>     <span class=\"n\">include</span><span class=\"p\">(</span><span class=\"s1\">'/post/'</span><span class=\"p\">,</span> <span class=\"n\">blog_matching</span><span class=\"p\">)</span>\n<span class=\"o\">...</span> <span class=\"p\">)</span>\n</pre>\n<p>Matching paths will be like this:</p>\n<ul>\n<li><cite>/</cite> =&gt; home application</li>\n<li><cite>/post/</cite> =&gt; post_list application</li>\n<li><cite>/post/some_slug/</cite> =&gt; post_detail application</li>\n</ul>\n<p>By using <em>include</em>, you can separate paths based on each applications\nand avoid repeating of descriptions (such as \u2018/post/\u2019).</p>\n<p>Name for reverisng to childs are not affected in any way.\nThis value should be unique, even in the all of matchings\n(fixed in matcha 0.3):</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">matching</span><span class=\"o\">.</span><span class=\"n\">reverse</span><span class=\"p\">(</span><span class=\"s1\">'post_detail'</span><span class=\"p\">,</span> <span class=\"n\">post_slug</span><span class=\"o\">=</span><span class=\"s1\">'some_slug'</span><span class=\"p\">)</span>\n<span class=\"s1\">'/post/some_slug/'</span>\n</pre>\n</div>\n<div id=\"setting-your-404-wsgi-application\">\n<h2>Setting your 404 WSGI application</h2>\n<p>The path matching failed the maked application by matcha will\nreturn a plain 404 page.\nBut most cases, you want to custorm this page more friendly\nfor users.</p>\n<p>For solving this, <em>matcha.make_wsgi_app</em> can take <cite>not_found_app</cite>\nkeyword argument to provide your own WSGI application for showing\n404 page.</p>\n<p>By default, the not_found_app is matcha.not_found_app.</p>\n</div>\n<div id=\"what-is-matching-objects\">\n<h2>What is Matching objects</h2>\n<p>Almost core features provided by matcha dispatcher\nis implamented as Matching objects.</p>\n<p>Now, through above example, you recognize matching is like this:</p>\n<ul>\n<li>matching is created by using bundle function and Matching class.</li>\n<li>Registering WSGI apllications to matching.</li>\n<li>matching can get from environ dictionaly</li>\n</ul>\n<p>Not wrong, but Matching class is something more flexible than\nyour recognition.</p>\n<div id=\"calling\">\n<h3>Calling</h3>\n<p>matching is callable</p>\n<ul>\n<li>taking environ dictionary</li>\n<li>sideeffecting environ dictionary</li>\n<li>returning matched case and dictionary</li>\n</ul>\n<p>That sideeffection is for PATH_INFO and SCRIPT_NAME to tell\nwhich path elements are processed to another WSGI application.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">environ</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'PATH_INFO'</span><span class=\"p\">:</span> <span class=\"s1\">'/htt'</span><span class=\"p\">,</span> <span class=\"s1\">'SCRIPT_NAME'</span><span class=\"p\">:</span> <span class=\"s1\">'/about'</span><span class=\"p\">}</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Matching</span><span class=\"p\">(</span><span class=\"s1\">'/htt'</span><span class=\"p\">,</span> <span class=\"n\">about_htt_app</span><span class=\"p\">)(</span><span class=\"n\">environ</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">about_htt_app</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">environ</span>\n<span class=\"p\">{</span><span class=\"s1\">'PATH_INFO'</span><span class=\"p\">:</span> <span class=\"s1\">''</span><span class=\"p\">,</span> <span class=\"s1\">'SCRIPT_NAME'</span><span class=\"p\">:</span> <span class=\"s1\">'/about/htt'</span><span class=\"p\">}</span>\n</pre>\n</div>\n<div id=\"getitem-from-matching\">\n<h3>Getitem from matching</h3>\n<p>cailling of matching requires environ dictionaly, but using getitem\nyou can only apply path to get matched case and dictionaly.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Matching</span><span class=\"p\">(</span><span class=\"s1\">'/htt'</span><span class=\"p\">,</span> <span class=\"n\">about_htt_app</span><span class=\"p\">)[</span><span class=\"s1\">'/htt'</span><span class=\"p\">]</span>\n<span class=\"p\">(</span><span class=\"n\">about_htt_app</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n</pre>\n</div>\n<div id=\"registering-not-only-wsgi-app\">\n<h3>Registering not only WSGI app</h3>\n<p>Second positional argument (<em>case</em> keyword argument) of Matching class\ncan take any objects you like, not only WSGI app.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Matching</span><span class=\"p\">(</span><span class=\"s1\">'/home'</span><span class=\"p\">,</span> <span class=\"s1\">'home'</span><span class=\"p\">)[</span><span class=\"s1\">'/home'</span><span class=\"p\">]</span>\n<span class=\"p\">(</span><span class=\"s1\">'home'</span><span class=\"p\">,</span> <span class=\"p\">{})</span>\n</pre>\n<p>For instance, you can register strings and use this as signature\nfor some views. something like <strong>route_name</strong> on\n<a href=\"http://www.pylonsproject.org/\" rel=\"nofollow\">Pyramid</a>.</p>\n</div>\n<div id=\"adding-matchings\">\n<h3>Adding matchings</h3>\n<p>Actually, <em>bundle</em> function used in above examples is just for\nadding provided positional arguments (addable objects).\nSo you can make WSGI application without this function:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">make_wsgi_app</span><span class=\"p\">(</span>\n<span class=\"o\">...</span>     <span class=\"n\">Matching</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">,</span> <span class=\"n\">home_app</span><span class=\"p\">)</span> <span class=\"o\">+</span> \\\n<span class=\"o\">...</span>     <span class=\"n\">Matching</span><span class=\"p\">(</span><span class=\"s1\">'/abount'</span><span class=\"p\">,</span> <span class=\"n\">about_app</span><span class=\"p\">)</span>\n<span class=\"o\">...</span> <span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"thanks\">\n<h2>Thanks</h2>\n<p>matcha dispatcher has been influenced these dispatchers:</p>\n<ul>\n<li><a href=\"https://github.com/django/django/\" rel=\"nofollow\">Django</a> \u2018s URL dispatcher</li>\n<li><a href=\"https://github.com/aodag/WebDispatch\" rel=\"nofollow\">WebDispatch</a></li>\n<li><a href=\"https://github.com/hirokiky/gargant.dispatch\" rel=\"nofollow\">gargant.dispatch</a></li>\n</ul>\n<p>Thanks for them.</p>\n</div>\n<div id=\"resources\">\n<h2>Resources</h2>\n<ul>\n<li><a href=\"https://pypi.python.org/pypi/matcha\" rel=\"nofollow\">PyPI</a></li>\n<li><a href=\"https://github.com/hirokiky/matcha\" rel=\"nofollow\">Repository</a></li>\n<li><a href=\"https://travis-ci.org/hirokiky/matcha\" rel=\"nofollow\">Testing</a></li>\n</ul>\n</div>\n<div id=\"changes\">\n<h2>Changes</h2>\n<div id=\"id1\">\n<h3>0.3</h3>\n<h3 id=\"un-supporting-name-argument-on-include-function\"><span class=\"section-subtitle\">Un-supporting name argument on include function</span></h3>\n<p>Before this change, user applied include name,\nthe reversing in included app will break, because\nthe name for reversing already changed.</p>\n</div>\n<div id=\"id2\">\n<h3>0.2</h3>\n<ul>\n<li>Supporting Wildcard</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>0.1</h3>\n<p>Initial release.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 894902, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "41db88e1632510ff3fa3238665e3a784", "sha256": "5b54f49ccea67faf55d244bf5afecd66fe71e65b4aa6e59aac23ef09202dbb12"}, "downloads": -1, "filename": "matcha-0.1.tar.gz", "has_sig": false, "md5_digest": "41db88e1632510ff3fa3238665e3a784", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5289, "upload_time": "2013-10-05T17:22:48", "upload_time_iso_8601": "2013-10-05T17:22:48.358454Z", "url": "https://files.pythonhosted.org/packages/1f/86/965a836afc89d30e509a7edf4ab03baacd42f0a2db5ed1c40b9269539dd3/matcha-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "caa2e3b910255848df369e36619f4952", "sha256": "5cb259773c9b57c0f5d37ffaa9de59c4d892fa9821c163e6cf22b7f5e92d88d6"}, "downloads": -1, "filename": "matcha-0.2.tar.gz", "has_sig": false, "md5_digest": "caa2e3b910255848df369e36619f4952", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6193, "upload_time": "2013-10-08T14:44:17", "upload_time_iso_8601": "2013-10-08T14:44:17.109455Z", "url": "https://files.pythonhosted.org/packages/6c/0b/05063895b90a6138910511adb4b0751d63b7b396505fe188b55ea86bf9da/matcha-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "c157bf0ef535d5ddeff7690bfa03b720", "sha256": "f27277c7d7f21898e42c49ab7efb536e86d2cd16d417eb6eacfc686526ac50d0"}, "downloads": -1, "filename": "matcha-0.3.tar.gz", "has_sig": false, "md5_digest": "c157bf0ef535d5ddeff7690bfa03b720", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6389, "upload_time": "2013-10-15T14:33:27", "upload_time_iso_8601": "2013-10-15T14:33:27.921522Z", "url": "https://files.pythonhosted.org/packages/cc/e7/e111d28dd0e1e70fc8a9d8a827975e0969c85b7f62ee418e86c441da346a/matcha-0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c157bf0ef535d5ddeff7690bfa03b720", "sha256": "f27277c7d7f21898e42c49ab7efb536e86d2cd16d417eb6eacfc686526ac50d0"}, "downloads": -1, "filename": "matcha-0.3.tar.gz", "has_sig": false, "md5_digest": "c157bf0ef535d5ddeff7690bfa03b720", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6389, "upload_time": "2013-10-15T14:33:27", "upload_time_iso_8601": "2013-10-15T14:33:27.921522Z", "url": "https://files.pythonhosted.org/packages/cc/e7/e111d28dd0e1e70fc8a9d8a827975e0969c85b7f62ee418e86c441da346a/matcha-0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:57:25 2020"}