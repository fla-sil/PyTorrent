{"info": {"author": "Michael Heinzinger", "author_email": "mheinzinger@rostlab.org", "bugtrack_url": null, "classifiers": ["Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Scientific/Engineering :: Artificial Intelligence", "Topic :: Scientific/Engineering :: Bio-Informatics"], "description": "# SeqVec\n\nRepository for the paper [Modeling aspects of the language of life through transfer-learning protein sequences](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-019-3220-8).\nHolds pre-trained SeqVec model for creating embeddings for amino acid sequences. Also, contains checkpoint for fine-tuning.\n\n# Abstract\n**Background**: One common task in Computational Biology is the prediction of aspects of protein function and structure from their amino acid sequence. For 26 years, most state-of-the-art approaches toward this end have been marrying machine learning and evolutionary information. The retrieval of related proteins from ever growing sequence databases is becoming so time-consuming that the analysis of entire proteomes becomes challenging. On top, evolutionary information is less powerful for small families, e.g. for proteins from the Dark Proteome.\n\n**Results**: We introduce a novel way to represent protein sequences as continuous vectors (embeddings) by using the deep bi-directional model ELMo taken from natural language processing (NLP). The model has effectively captured the biophysical properties of protein sequences from unlabeled big data (UniRef50). After training, this knowledge is transferred to single protein sequences by predicting relevant sequence features. We refer to these new embeddings as SeqVec (Sequence-to-Vector) and demonstrate their effectiveness by training simple convolutional neural networks on existing data sets for two completely different prediction tasks. At the per-residue level, we significantly improved secondary structure (for NetSurfP-2.0 data set: Q3=79%\u00b11, Q8=68%\u00b11) and disorder predictions (MCC=0.59\u00b10.03) over methods not using evolutionary information. At the per-protein level, we predicted subcellular localization in ten classes (for DeepLoc data set: Q10=68%\u00b11) and distinguished membrane- bound from water-soluble proteins (Q2= 87%\u00b11). All results built upon the embeddings gained from the new tool SeqVec neither explicitly nor implicitly using evolutionary information. Nevertheless, it improved over some methods using such information. Where the lightning-fast HHblits needed on average about two minutes to generate the evolutionary information for a target protein, SeqVec created the vector representation on average in 0.03 seconds.\n\n**Conclusion**: We have shown that transfer learning can be used to capture biochemical or biophysical properties of protein sequences from large unlabeled sequence databases. The effectiveness of the proposed approach was showcased for different prediction tasks using only single protein sequences. SeqVec embeddings enable predictions that outperform even some methods using evolutionary information. Thus, they prove to condense the underlying principles of protein sequences. This might be the first step towards competitive predictions based only on single protein sequences.\n\n# t-SNE projections of SeqVec\n![2D t-SNE projections](seqvec_tsne.png \"2D t-SNE projections of SeqVec\")\n*2D t-SNE projections of unsupervised SeqVec embeddings highlight different realities of proteins and their constituent parts, amino acids.* Panels (b) to (d) are based on the same data set (Structural Classification of Proteins \u2013 extended (SCOPe) 2.07, redundancy reduced at 40%). For these plots, only subsets of SCOPe containing proteins with the annotation of interest (enzymatic activity (c) and kingdom (d)) may be displayed. **Panel (a)**: the embedding space confirms: the 20 standard amino acids are clustered according to their biochemical and biophysical properties, i.e. hydrophobicity, charge or size. The unique role of Cysteine (C, mostly hydrophobic and polar) is conserved. **Panel (b)**: SeqVec embeddings capture structural information as annotated in the main classes in SCOPe without ever having been explicitly trained on structural features. **Panel (c)**: many small, local clusters share function as given by the main classes in the Enzyme Commission Number (E.C.). **Panel (d)**: similarly, small, local clusters represent different kingdoms of life.\n\n# Model availability\nThe ELMo model trained on UniRef50 (=SeqVec) is available at:\n[SeqVec-model](https://rostlab.org/~deepppi/seqvec.zip)\n\nThe checkpoint for the pre-trained model is available at:\n[SeqVec-checkpoint](https://rostlab.org/~deepppi/seqvec_checkpoint.tar.gz)\n\n# Installation\n\n```\npip install seqvec\n```\n\nWe are working on a python package with more embedders and a commong interface to them; see [bio_embeddings](https://github.com/sacdallago/bio_embeddings)\n\n# Example\n\nIn the [bio_embeddings](https://github.com/sacdallago/bio_embeddings) github repo, you can find examples in the `notebooks` folder.\n\nFor a general example on how to extract embeddings using ELMo, please check the \nofficial allennlp ELMo website: [ELMo-Tutorial](https://github.com/allenai/allennlp/blob/master/tutorials/how_to/elmo.md)\n\nYou can compute embeddings for a fasta file with the `seqvec` command. Add `--protein True` to get an embedding per protein instead of per residue.\n\n```\nseqvec -i sequences.fasta -o embeddings.npz\n```\n\nLoad the embeddings with numpy:\n\n```python\nimport numpy as np\ndata = np.load(\"embeddings.npz\")  # type: Dict[str, np.ndarray]\n```\n\nIf you specify `.npy` as output format (e.g. with `-o embeddings.npy`), the script will save the embeddings as an numpy array and the corresponding identifiers (as extracted from the header line in the fasta file) in a json file besides it. The sorting in the json file corresponds to the indexing in the npy file. The npy file can be loaded via:\n\n```python\nimport json\nimport numpy as np\n\ndata = np.load(\"embeddings.npy\") # shape=(n_proteins,)\nwith open(\"embeddings.json\") as fp:\n    labels = json.load(fp)\n```\n\n**How to integrate the embedder into an existing workflow:**\n\n\nLoad pre-trained model:\n\n```python\nfrom allennlp.commands.elmo import ElmoEmbedder\nfrom pathlib import Path\n\nmodel_dir = Path('path/to/pretrained/SeqVec_directory')\nweights = model_dir / 'weights.hdf5'\noptions = model_dir / 'options.json'\nembedder = ElmoEmbedder(options,weights, cuda_device=0) # cuda_device=-1 for CPU\n```\n\nGet embedding for amino acid sequence:\n\n```python\nseq = 'SEQWENCE' # your amino acid sequence\nembedding = embedder.embed_sentence(list(seq)) # List-of-Lists with shape [3,L,1024]\n```\n\nBatch embed sequences:\n\n```python\nseq1 = 'SEQWENCE' # your amino acid sequence\nseq2 = 'PROTEIN'\nseqs = [list(seq1), list(seq2)]\nseqs.sort(key=len) # sorting is crucial for speed\nembedding = embedder.embed_sentences(seqs) # returns: List-of-Lists with shape [3,L,1024]\n```\n\nGet 1024-dimensional embedding for per-residue predictions:\n\n```python\nimport torch\nresidue_embd = torch.tensor(embedding).sum(dim=0) # Tensor with shape [L,1024]\n```\n\nGet 1024-dimensional embedding for per-protein predictions:\n```python\nprotein_embd = torch.tensor(embedding).sum(dim=0).mean(dim=0) # Vector with shape [1024]\n```\n# FAQ\n**Torch version conflict**\nIf you encounter a version conflict while pip-installing seqvec (```ERROR: No matching distribution found for torch<1.3,>=1.2 (from seqvec)```), creating a new conda-environment with Python 3.7 can resolve your issue. \n\n\n\n# Web-service for Predictions based on SeqVec\n[SeqVec predictions - Chris' Protein properties](https://embed.protein.properties/)\n\n# Bibtex-Reference\n```\n@article{heinzinger2019modeling,\n  title={Modeling aspects of the language of life through transfer-learning protein sequences},\n  author={Heinzinger, Michael and Elnaggar, Ahmed and Wang, Yu and Dallago, Christian and Nechaev, Dmitrii and Matthes, Florian and Rost, Burkhard},\n  journal={BMC bioinformatics},\n  volume={20},\n  number={1},\n  pages={723},\n  year={2019},\n  publisher={Springer}\n}\n```\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Rostlab/SeqVec", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "seqvec", "package_url": "https://pypi.org/project/seqvec/", "platform": "", "project_url": "https://pypi.org/project/seqvec/", "project_urls": {"Homepage": "https://github.com/Rostlab/SeqVec", "Repository": "https://github.com/Rostlab/SeqVec"}, "release_url": "https://pypi.org/project/seqvec/0.2.1/", "requires_dist": ["tqdm (>=4.36,<5.0)", "numpy (>=1.17,<2.0)", "torch (>=1.2,<2.0)", "allennlp (>=0.9.0,<0.10.0)", "h5py (>=2.10.0,<3.0.0)", "gevent (==1.4.0)"], "requires_python": ">=3.6.1", "summary": "Embeeder tool for 'Modelling the Language of Life - Deep Learning Protein Sequences'", "version": "0.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>SeqVec</h1>\n<p>Repository for the paper <a href=\"https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-019-3220-8\" rel=\"nofollow\">Modeling aspects of the language of life through transfer-learning protein sequences</a>.\nHolds pre-trained SeqVec model for creating embeddings for amino acid sequences. Also, contains checkpoint for fine-tuning.</p>\n<h1>Abstract</h1>\n<p><strong>Background</strong>: One common task in Computational Biology is the prediction of aspects of protein function and structure from their amino acid sequence. For 26 years, most state-of-the-art approaches toward this end have been marrying machine learning and evolutionary information. The retrieval of related proteins from ever growing sequence databases is becoming so time-consuming that the analysis of entire proteomes becomes challenging. On top, evolutionary information is less powerful for small families, e.g. for proteins from the Dark Proteome.</p>\n<p><strong>Results</strong>: We introduce a novel way to represent protein sequences as continuous vectors (embeddings) by using the deep bi-directional model ELMo taken from natural language processing (NLP). The model has effectively captured the biophysical properties of protein sequences from unlabeled big data (UniRef50). After training, this knowledge is transferred to single protein sequences by predicting relevant sequence features. We refer to these new embeddings as SeqVec (Sequence-to-Vector) and demonstrate their effectiveness by training simple convolutional neural networks on existing data sets for two completely different prediction tasks. At the per-residue level, we significantly improved secondary structure (for NetSurfP-2.0 data set: Q3=79%\u00b11, Q8=68%\u00b11) and disorder predictions (MCC=0.59\u00b10.03) over methods not using evolutionary information. At the per-protein level, we predicted subcellular localization in ten classes (for DeepLoc data set: Q10=68%\u00b11) and distinguished membrane- bound from water-soluble proteins (Q2= 87%\u00b11). All results built upon the embeddings gained from the new tool SeqVec neither explicitly nor implicitly using evolutionary information. Nevertheless, it improved over some methods using such information. Where the lightning-fast HHblits needed on average about two minutes to generate the evolutionary information for a target protein, SeqVec created the vector representation on average in 0.03 seconds.</p>\n<p><strong>Conclusion</strong>: We have shown that transfer learning can be used to capture biochemical or biophysical properties of protein sequences from large unlabeled sequence databases. The effectiveness of the proposed approach was showcased for different prediction tasks using only single protein sequences. SeqVec embeddings enable predictions that outperform even some methods using evolutionary information. Thus, they prove to condense the underlying principles of protein sequences. This might be the first step towards competitive predictions based only on single protein sequences.</p>\n<h1>t-SNE projections of SeqVec</h1>\n<p><img alt=\"2D t-SNE projections\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0d3d208ef96004253cdaf0a11b1e207e488c915b/7365717665635f74736e652e706e67\">\n<em>2D t-SNE projections of unsupervised SeqVec embeddings highlight different realities of proteins and their constituent parts, amino acids.</em> Panels (b) to (d) are based on the same data set (Structural Classification of Proteins \u2013 extended (SCOPe) 2.07, redundancy reduced at 40%). For these plots, only subsets of SCOPe containing proteins with the annotation of interest (enzymatic activity (c) and kingdom (d)) may be displayed. <strong>Panel (a)</strong>: the embedding space confirms: the 20 standard amino acids are clustered according to their biochemical and biophysical properties, i.e. hydrophobicity, charge or size. The unique role of Cysteine (C, mostly hydrophobic and polar) is conserved. <strong>Panel (b)</strong>: SeqVec embeddings capture structural information as annotated in the main classes in SCOPe without ever having been explicitly trained on structural features. <strong>Panel (c)</strong>: many small, local clusters share function as given by the main classes in the Enzyme Commission Number (E.C.). <strong>Panel (d)</strong>: similarly, small, local clusters represent different kingdoms of life.</p>\n<h1>Model availability</h1>\n<p>The ELMo model trained on UniRef50 (=SeqVec) is available at:\n<a href=\"https://rostlab.org/%7Edeepppi/seqvec.zip\" rel=\"nofollow\">SeqVec-model</a></p>\n<p>The checkpoint for the pre-trained model is available at:\n<a href=\"https://rostlab.org/%7Edeepppi/seqvec_checkpoint.tar.gz\" rel=\"nofollow\">SeqVec-checkpoint</a></p>\n<h1>Installation</h1>\n<pre><code>pip install seqvec\n</code></pre>\n<p>We are working on a python package with more embedders and a commong interface to them; see <a href=\"https://github.com/sacdallago/bio_embeddings\" rel=\"nofollow\">bio_embeddings</a></p>\n<h1>Example</h1>\n<p>In the <a href=\"https://github.com/sacdallago/bio_embeddings\" rel=\"nofollow\">bio_embeddings</a> github repo, you can find examples in the <code>notebooks</code> folder.</p>\n<p>For a general example on how to extract embeddings using ELMo, please check the\nofficial allennlp ELMo website: <a href=\"https://github.com/allenai/allennlp/blob/master/tutorials/how_to/elmo.md\" rel=\"nofollow\">ELMo-Tutorial</a></p>\n<p>You can compute embeddings for a fasta file with the <code>seqvec</code> command. Add <code>--protein True</code> to get an embedding per protein instead of per residue.</p>\n<pre><code>seqvec -i sequences.fasta -o embeddings.npz\n</code></pre>\n<p>Load the embeddings with numpy:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s2\">\"embeddings.npz\"</span><span class=\"p\">)</span>  <span class=\"c1\"># type: Dict[str, np.ndarray]</span>\n</pre>\n<p>If you specify <code>.npy</code> as output format (e.g. with <code>-o embeddings.npy</code>), the script will save the embeddings as an numpy array and the corresponding identifiers (as extracted from the header line in the fasta file) in a json file besides it. The sorting in the json file corresponds to the indexing in the npy file. The npy file can be loaded via:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">json</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s2\">\"embeddings.npy\"</span><span class=\"p\">)</span> <span class=\"c1\"># shape=(n_proteins,)</span>\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"embeddings.json\"</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">fp</span><span class=\"p\">:</span>\n    <span class=\"n\">labels</span> <span class=\"o\">=</span> <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">fp</span><span class=\"p\">)</span>\n</pre>\n<p><strong>How to integrate the embedder into an existing workflow:</strong></p>\n<p>Load pre-trained model:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">allennlp.commands.elmo</span> <span class=\"kn\">import</span> <span class=\"n\">ElmoEmbedder</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pathlib</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span>\n\n<span class=\"n\">model_dir</span> <span class=\"o\">=</span> <span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s1\">'path/to/pretrained/SeqVec_directory'</span><span class=\"p\">)</span>\n<span class=\"n\">weights</span> <span class=\"o\">=</span> <span class=\"n\">model_dir</span> <span class=\"o\">/</span> <span class=\"s1\">'weights.hdf5'</span>\n<span class=\"n\">options</span> <span class=\"o\">=</span> <span class=\"n\">model_dir</span> <span class=\"o\">/</span> <span class=\"s1\">'options.json'</span>\n<span class=\"n\">embedder</span> <span class=\"o\">=</span> <span class=\"n\">ElmoEmbedder</span><span class=\"p\">(</span><span class=\"n\">options</span><span class=\"p\">,</span><span class=\"n\">weights</span><span class=\"p\">,</span> <span class=\"n\">cuda_device</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\"># cuda_device=-1 for CPU</span>\n</pre>\n<p>Get embedding for amino acid sequence:</p>\n<pre><span class=\"n\">seq</span> <span class=\"o\">=</span> <span class=\"s1\">'SEQWENCE'</span> <span class=\"c1\"># your amino acid sequence</span>\n<span class=\"n\">embedding</span> <span class=\"o\">=</span> <span class=\"n\">embedder</span><span class=\"o\">.</span><span class=\"n\">embed_sentence</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">seq</span><span class=\"p\">))</span> <span class=\"c1\"># List-of-Lists with shape [3,L,1024]</span>\n</pre>\n<p>Batch embed sequences:</p>\n<pre><span class=\"n\">seq1</span> <span class=\"o\">=</span> <span class=\"s1\">'SEQWENCE'</span> <span class=\"c1\"># your amino acid sequence</span>\n<span class=\"n\">seq2</span> <span class=\"o\">=</span> <span class=\"s1\">'PROTEIN'</span>\n<span class=\"n\">seqs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">seq1</span><span class=\"p\">),</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">seq2</span><span class=\"p\">)]</span>\n<span class=\"n\">seqs</span><span class=\"o\">.</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"o\">=</span><span class=\"nb\">len</span><span class=\"p\">)</span> <span class=\"c1\"># sorting is crucial for speed</span>\n<span class=\"n\">embedding</span> <span class=\"o\">=</span> <span class=\"n\">embedder</span><span class=\"o\">.</span><span class=\"n\">embed_sentences</span><span class=\"p\">(</span><span class=\"n\">seqs</span><span class=\"p\">)</span> <span class=\"c1\"># returns: List-of-Lists with shape [3,L,1024]</span>\n</pre>\n<p>Get 1024-dimensional embedding for per-residue predictions:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">torch</span>\n<span class=\"n\">residue_embd</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">(</span><span class=\"n\">embedding</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\"># Tensor with shape [L,1024]</span>\n</pre>\n<p>Get 1024-dimensional embedding for per-protein predictions:</p>\n<pre><span class=\"n\">protein_embd</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">(</span><span class=\"n\">embedding</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\"># Vector with shape [1024]</span>\n</pre>\n<h1>FAQ</h1>\n<p><strong>Torch version conflict</strong>\nIf you encounter a version conflict while pip-installing seqvec (<code>ERROR: No matching distribution found for torch&lt;1.3,&gt;=1.2 (from seqvec)</code>), creating a new conda-environment with Python 3.7 can resolve your issue.</p>\n<h1>Web-service for Predictions based on SeqVec</h1>\n<p><a href=\"https://embed.protein.properties/\" rel=\"nofollow\">SeqVec predictions - Chris' Protein properties</a></p>\n<h1>Bibtex-Reference</h1>\n<pre><code>@article{heinzinger2019modeling,\n  title={Modeling aspects of the language of life through transfer-learning protein sequences},\n  author={Heinzinger, Michael and Elnaggar, Ahmed and Wang, Yu and Dallago, Christian and Nechaev, Dmitrii and Matthes, Florian and Rost, Burkhard},\n  journal={BMC bioinformatics},\n  volume={20},\n  number={1},\n  pages={723},\n  year={2019},\n  publisher={Springer}\n}\n</code></pre>\n\n          </div>"}, "last_serial": 7015772, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "ec3addc389331e9f021c927a849fdcd5", "sha256": "57fcc75952b52fd107c3972a802a5caa29b0990287a87449f48abd4107ea247d"}, "downloads": -1, "filename": "seqvec-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "ec3addc389331e9f021c927a849fdcd5", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.1", "size": 10132, "upload_time": "2019-12-05T17:48:23", "upload_time_iso_8601": "2019-12-05T17:48:23.475569Z", "url": "https://files.pythonhosted.org/packages/63/ce/0a59fb8273451aff2e615d07538181d11f164c5b99e61e6ae718ee911f2c/seqvec-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ec65ea31fd147d0ccc112457f36ef189", "sha256": "b5ab1010968d3bfa6a712aa6b0fa4d48149394669f5f3bf569282e00ef1c621c"}, "downloads": -1, "filename": "seqvec-0.1.0.tar.gz", "has_sig": false, "md5_digest": "ec65ea31fd147d0ccc112457f36ef189", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.1", "size": 10350, "upload_time": "2019-12-05T17:48:26", "upload_time_iso_8601": "2019-12-05T17:48:26.202789Z", "url": "https://files.pythonhosted.org/packages/6e/b8/c826cd167610efa2738688c1fbbed5acf230c2da065547bdb002a398db6c/seqvec-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "1b455d6e5d0e7faf1a82352461efa836", "sha256": "b0d92f7013e375ea7b3d43a67bcbc6a061bba84208b91e0064fbc358898320c7"}, "downloads": -1, "filename": "seqvec-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "1b455d6e5d0e7faf1a82352461efa836", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.1", "size": 10201, "upload_time": "2020-02-26T20:10:50", "upload_time_iso_8601": "2020-02-26T20:10:50.948336Z", "url": "https://files.pythonhosted.org/packages/42/3f/83d4b1a139363c239869f767832bf4be7426d1fc38eeefef3692bae41857/seqvec-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "24fd9818b6f870a6c301b66164672e9f", "sha256": "efa1a832dafd54ef23699bf1c3e9dbf60c06262483f2b9788e92a0b4fdfa2f51"}, "downloads": -1, "filename": "seqvec-0.2.0.tar.gz", "has_sig": false, "md5_digest": "24fd9818b6f870a6c301b66164672e9f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.1", "size": 10529, "upload_time": "2020-02-26T20:10:53", "upload_time_iso_8601": "2020-02-26T20:10:53.282782Z", "url": "https://files.pythonhosted.org/packages/ce/0d/38ffd2f934e08988403242c3ec3e6e18d30a248724d79a92705b0b551aea/seqvec-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "7d8d9813f7150d1c2241f007b08cbfae", "sha256": "61067f61eb3034091a95feb314c68b3339357e52302e160b5659145615d4cab4"}, "downloads": -1, "filename": "seqvec-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "7d8d9813f7150d1c2241f007b08cbfae", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.1", "size": 10360, "upload_time": "2020-04-14T09:16:26", "upload_time_iso_8601": "2020-04-14T09:16:26.842677Z", "url": "https://files.pythonhosted.org/packages/46/a8/2f7111f823592bca86d59609802350cb3af0980569268c55afbfe092dd61/seqvec-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c7d9132d30b9eebde24e21414854ee12", "sha256": "dca9398701e7d2e0ae440df1a61ade2c7c8bf1d4ea6c71daaa8849a6e5df6b8e"}, "downloads": -1, "filename": "seqvec-0.2.1.tar.gz", "has_sig": false, "md5_digest": "c7d9132d30b9eebde24e21414854ee12", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.1", "size": 10750, "upload_time": "2020-04-14T09:16:28", "upload_time_iso_8601": "2020-04-14T09:16:28.576693Z", "url": "https://files.pythonhosted.org/packages/66/39/99f9f99de49a00fc90e32002b4375db051295bd82c0e64d37872b73f0f68/seqvec-0.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7d8d9813f7150d1c2241f007b08cbfae", "sha256": "61067f61eb3034091a95feb314c68b3339357e52302e160b5659145615d4cab4"}, "downloads": -1, "filename": "seqvec-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "7d8d9813f7150d1c2241f007b08cbfae", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.1", "size": 10360, "upload_time": "2020-04-14T09:16:26", "upload_time_iso_8601": "2020-04-14T09:16:26.842677Z", "url": "https://files.pythonhosted.org/packages/46/a8/2f7111f823592bca86d59609802350cb3af0980569268c55afbfe092dd61/seqvec-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c7d9132d30b9eebde24e21414854ee12", "sha256": "dca9398701e7d2e0ae440df1a61ade2c7c8bf1d4ea6c71daaa8849a6e5df6b8e"}, "downloads": -1, "filename": "seqvec-0.2.1.tar.gz", "has_sig": false, "md5_digest": "c7d9132d30b9eebde24e21414854ee12", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.1", "size": 10750, "upload_time": "2020-04-14T09:16:28", "upload_time_iso_8601": "2020-04-14T09:16:28.576693Z", "url": "https://files.pythonhosted.org/packages/66/39/99f9f99de49a00fc90e32002b4375db051295bd82c0e64d37872b73f0f68/seqvec-0.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:15:22 2020"}