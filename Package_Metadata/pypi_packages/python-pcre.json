{"info": {"author": "Arkadiusz Wahlig", "author_email": "UNKNOWN", "bugtrack_url": null, "classifiers": [], "description": "python-pcre\n===========\n\nPython bindings for PCRE regex engine.\n\n\nRequirements\n------------\n\n* [PCRE](http://www.pcre.org) 8.x\n* [Python](http://python.org) 2.6+ or 3.x\n\nTested with Python 2.6, 2.7, 3.4 and PCRE 8.12, 8.30, 8.35.\n\n\nBuilding and installation\n-------------------------\n\nA standard distutils `setup.py` script is provided.\nAfter making sure all dependencies are installed, building\nand installation should be as simple as:\n\n```\n$ python setup.py build install\n```\n\nWhen building PCRE, UTF-8 mode must be enabled (`./configure --enable-utf`).  You might\nalso want to enable stackless recursion (`--disable-stack-for-recursion`) and unicode\ncharacter properties (`--enable-unicode-properties`).  If you plan to use JIT,\nadd `--enable-jit`.\n\n\nDifferences between python-pcre and re\n--------------------------------------\n\nThe API is very similar to that of the built-in\n[re module](http://docs.python.org/library/re.html).\n\nDifferences:\n\n* slightly different regex syntax\n* by default, `sub()`, `subn()`, `expand()` use `str.format()` instead of `\\1` substitution\n  (see below)\n* `DEBUG` and `LOCALE` flags are not supported\n* patterns are not cached\n* scanner APIs are not supported\n\nFor a comprehensive PCRE regex syntax you can visit\n[PHP documentation](http://php.net/manual/en/reference.pcre.pattern.syntax.php).\n\n\nSubstitution\n------------\n\nBy default, python-pcre uses `str.format()` instead of the `re`-style `\\1` and `\\g<name>`\nsubstitution in calls to `sub()`, `subn()` and `expand()`.\n\nExample:\n\n```python\n>>> import pcre\n>>> pcre.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):',\n...          'static PyObject*\\npy_{1}(void)\\n{{',  # str.format() template\n...          'def myfunc():')\n'static PyObject*\\npy_myfunc(void)\\n{'\n```\nNote `{1}` and escaped `{{` in the template string.\n\nThe built-in re module would use `\\1` instead:\n`r'static PyObject*\\npy_\\1(void)\\n{'`\n\nNamed groups are referenced using `{name}` instead of `\\g<name>`.\n\nEntire match can be referenced using `{0}`.\n\nThis makes the template string easier to read and means that it no longer needs to be\na raw string.\n\nHowever, `re` template mode can be enabled using `enable_re_template_mode()`.\nThis might be useful if python-pcre is to be used with existing `re`-based code.\n\n```python\n>>> pcre.enable_re_template_mode()\n>>> pcre.sub(r'(.)', r'[\\1]', 'foo')\n'[f][o][o]'\n```\n\nA function to convert `re` templates is also provided for those one-off cases.\n\n```python\n>>> pcre.convert_re_template(r'static PyObject*\\npy_\\1(void)\\n{')\n'static PyObject*\\npy_{1}(void)\\n{{'\n```\n\nA small difference between the two modes is that in `str.format()` mode, groups that\ndidn't match are replaced with `''` whereas in `re` mode it's an error to reference\nsuch groups in the template.\n\nAlso note that in Python 3.x `bytes.format()` is not available so the template needs\nto be a `str`.\n\n\nUnicode handling\n----------------\n\npython-pcre internally uses the UTF-8 interface of the PCRE library.\n\nPatterns or matched subjects specified as byte strings that contain ascii characters\nonly (0-127) are passed to PCRE directly, as ascii is a subset of UTF-8.\nOther byte strings are internally re-encoded using a simple Latin1 to UTF-8 codec\nwhich maps characters 128-255 to unicode codepoints of the same value.\nThis conversion is transparent to the caller.\n\nIf you know that your byte strings are UTF-8, you can use the `pcre.UTF8` flag\nto tell python-pcre to pass them directly to PCRE.  This flag has to be specified\nevery time a UTF-8 pattern is compiled or a UTF-8 subject is matched.  Note that\nin this mode things like `.` may match multiple bytes:\n\n```python\n>>> pcre.compile('.').match(b'\\xc3\\x9c', flags=pcre.UTF8).group()\nb'\\xc3\\x9c'  # two bytes\n>>> _.decode('utf-8')\nu'\\xdc'  # one character\n```\n\npython-pcre also accepts unicode strings as input.  In Python 3.3 or newer, which\nimplement [PEP 393](http://legacy.python.org/dev/peps/pep-0393/), unicode strings\nstored internally as ascii are passed to PCRE directly.  Other internal formats are\nencoded into UTF-8 using Python APIs (which use the UTF-8 form cached in the unicode\nobject if available).  In older Python versions these optimizations are not supported\nso all unicode objects require the extra encoding step.\n\npython-pcre also accepts objects supporting the buffer interface, such as `array.array`\nobjects.  Supported are both old and new buffer APIs with buffers containing either bytes\nor unicode characters, with the same UTF-8 encoding strategy as byte/unicode strings.\n\nWhen internally encoding subject strings to UTF-8, any offsets accepted as input\nor provided as output are also converted between byte and character offsets so that\nthe caller doesn't need to be aware of the conversion -- the offsets are always\nindexes into the specified subject string, whether it's a byte string or a unicode\nstring.\n\n\nLicense\n-------\n\n```\nCopyright (c) 2012-2015, Arkadiusz Wahlig\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the following disclaimer in the\n  documentation and/or other materials provided with the distribution.\n* Neither the name of the <organization> nor the\n  names of its contributors may be used to endorse or promote products\n  derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n```\n", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/awahlig/python-pcre", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "python-pcre", "package_url": "https://pypi.org/project/python-pcre/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/python-pcre/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/awahlig/python-pcre"}, "release_url": "https://pypi.org/project/python-pcre/0.7/", "requires_dist": null, "requires_python": null, "summary": "Python PCRE bindings", "version": "0.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            python-pcre<br>===========<br><br>Python bindings for PCRE regex engine.<br><br><br>Requirements<br>------------<br><br>* [PCRE](http://www.pcre.org) 8.x<br>* [Python](http://python.org) 2.6+ or 3.x<br><br>Tested with Python 2.6, 2.7, 3.4 and PCRE 8.12, 8.30, 8.35.<br><br><br>Building and installation<br>-------------------------<br><br>A standard distutils `setup.py` script is provided.<br>After making sure all dependencies are installed, building<br>and installation should be as simple as:<br><br>```<br>$ python setup.py build install<br>```<br><br>When building PCRE, UTF-8 mode must be enabled (`./configure --enable-utf`).  You might<br>also want to enable stackless recursion (`--disable-stack-for-recursion`) and unicode<br>character properties (`--enable-unicode-properties`).  If you plan to use JIT,<br>add `--enable-jit`.<br><br><br>Differences between python-pcre and re<br>--------------------------------------<br><br>The API is very similar to that of the built-in<br>[re module](http://docs.python.org/library/re.html).<br><br>Differences:<br><br>* slightly different regex syntax<br>* by default, `sub()`, `subn()`, `expand()` use `str.format()` instead of `\\1` substitution<br>  (see below)<br>* `DEBUG` and `LOCALE` flags are not supported<br>* patterns are not cached<br>* scanner APIs are not supported<br><br>For a comprehensive PCRE regex syntax you can visit<br>[PHP documentation](http://php.net/manual/en/reference.pcre.pattern.syntax.php).<br><br><br>Substitution<br>------------<br><br>By default, python-pcre uses `str.format()` instead of the `re`-style `\\1` and `\\g&lt;name&gt;`<br>substitution in calls to `sub()`, `subn()` and `expand()`.<br><br>Example:<br><br>```python<br>&gt;&gt;&gt; import pcre<br>&gt;&gt;&gt; pcre.sub(r'def\\s+([a-zA-Z_][a-zA-Z_0-9]*)\\s*\\(\\s*\\):',<br>...          'static PyObject*\\npy_{1}(void)\\n{{',  # str.format() template<br>...          'def myfunc():')<br>'static PyObject*\\npy_myfunc(void)\\n{'<br>```<br>Note `{1}` and escaped `{{` in the template string.<br><br>The built-in re module would use `\\1` instead:<br>`r'static PyObject*\\npy_\\1(void)\\n{'`<br><br>Named groups are referenced using `{name}` instead of `\\g&lt;name&gt;`.<br><br>Entire match can be referenced using `{0}`.<br><br>This makes the template string easier to read and means that it no longer needs to be<br>a raw string.<br><br>However, `re` template mode can be enabled using `enable_re_template_mode()`.<br>This might be useful if python-pcre is to be used with existing `re`-based code.<br><br>```python<br>&gt;&gt;&gt; pcre.enable_re_template_mode()<br>&gt;&gt;&gt; pcre.sub(r'(.)', r'[\\1]', 'foo')<br>'[f][o][o]'<br>```<br><br>A function to convert `re` templates is also provided for those one-off cases.<br><br>```python<br>&gt;&gt;&gt; pcre.convert_re_template(r'static PyObject*\\npy_\\1(void)\\n{')<br>'static PyObject*\\npy_{1}(void)\\n{{'<br>```<br><br>A small difference between the two modes is that in `str.format()` mode, groups that<br>didn't match are replaced with `''` whereas in `re` mode it's an error to reference<br>such groups in the template.<br><br>Also note that in Python 3.x `bytes.format()` is not available so the template needs<br>to be a `str`.<br><br><br>Unicode handling<br>----------------<br><br>python-pcre internally uses the UTF-8 interface of the PCRE library.<br><br>Patterns or matched subjects specified as byte strings that contain ascii characters<br>only (0-127) are passed to PCRE directly, as ascii is a subset of UTF-8.<br>Other byte strings are internally re-encoded using a simple Latin1 to UTF-8 codec<br>which maps characters 128-255 to unicode codepoints of the same value.<br>This conversion is transparent to the caller.<br><br>If you know that your byte strings are UTF-8, you can use the `pcre.UTF8` flag<br>to tell python-pcre to pass them directly to PCRE.  This flag has to be specified<br>every time a UTF-8 pattern is compiled or a UTF-8 subject is matched.  Note that<br>in this mode things like `.` may match multiple bytes:<br><br>```python<br>&gt;&gt;&gt; pcre.compile('.').match(b'\\xc3\\x9c', flags=pcre.UTF8).group()<br>b'\\xc3\\x9c'  # two bytes<br>&gt;&gt;&gt; _.decode('utf-8')<br>u'\\xdc'  # one character<br>```<br><br>python-pcre also accepts unicode strings as input.  In Python 3.3 or newer, which<br>implement [PEP 393](http://legacy.python.org/dev/peps/pep-0393/), unicode strings<br>stored internally as ascii are passed to PCRE directly.  Other internal formats are<br>encoded into UTF-8 using Python APIs (which use the UTF-8 form cached in the unicode<br>object if available).  In older Python versions these optimizations are not supported<br>so all unicode objects require the extra encoding step.<br><br>python-pcre also accepts objects supporting the buffer interface, such as `array.array`<br>objects.  Supported are both old and new buffer APIs with buffers containing either bytes<br>or unicode characters, with the same UTF-8 encoding strategy as byte/unicode strings.<br><br>When internally encoding subject strings to UTF-8, any offsets accepted as input<br>or provided as output are also converted between byte and character offsets so that<br>the caller doesn't need to be aware of the conversion -- the offsets are always<br>indexes into the specified subject string, whether it's a byte string or a unicode<br>string.<br><br><br>License<br>-------<br><br>```<br>Copyright (c) 2012-2015, Arkadiusz Wahlig<br>All rights reserved.<br><br>Redistribution and use in source and binary forms, with or without<br>modification, are permitted provided that the following conditions are met:<br>* Redistributions of source code must retain the above copyright<br>  notice, this list of conditions and the following disclaimer.<br>* Redistributions in binary form must reproduce the above copyright<br>  notice, this list of conditions and the following disclaimer in the<br>  documentation and/or other materials provided with the distribution.<br>* Neither the name of the &lt;organization&gt; nor the<br>  names of its contributors may be used to endorse or promote products<br>  derived from this software without specific prior written permission.<br><br>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND<br>ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED<br>WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE<br>DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY<br>DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES<br>(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<br>LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND<br>ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT<br>(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS<br>SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<br>```<br>\n          </div>"}, "last_serial": 1766147, "releases": {"0.6": [{"comment_text": "", "digests": {"md5": "8862e9abc3777c8d5e4199f784398c24", "sha256": "7fed1460f844075a7b2fe22f728b4645a4440e55ad4337c9efc057b7f5ae1ccc"}, "downloads": -1, "filename": "python-pcre-0.6.tar.gz", "has_sig": false, "md5_digest": "8862e9abc3777c8d5e4199f784398c24", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52690, "upload_time": "2015-06-17T12:26:45", "upload_time_iso_8601": "2015-06-17T12:26:45.536140Z", "url": "https://files.pythonhosted.org/packages/56/cf/f5a67b58576bb0f453988efd24e48f0558cae7bf860302074a29c5a13b07/python-pcre-0.6.tar.gz", "yanked": false}], "0.7": [{"comment_text": "", "digests": {"md5": "fe1333c7675ab97049e1ee183578025b", "sha256": "4286f3f31e9f08a8c6bff537940ce0ca86aad8eb3f78ad486620266f5099f681"}, "downloads": -1, "filename": "python-pcre-0.7.tar.gz", "has_sig": false, "md5_digest": "fe1333c7675ab97049e1ee183578025b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52596, "upload_time": "2015-10-13T12:17:56", "upload_time_iso_8601": "2015-10-13T12:17:56.519337Z", "url": "https://files.pythonhosted.org/packages/9d/af/61435bd163f01fe3709fca9b1f79e4978d8089ee671d2e004fc85e10de29/python-pcre-0.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fe1333c7675ab97049e1ee183578025b", "sha256": "4286f3f31e9f08a8c6bff537940ce0ca86aad8eb3f78ad486620266f5099f681"}, "downloads": -1, "filename": "python-pcre-0.7.tar.gz", "has_sig": false, "md5_digest": "fe1333c7675ab97049e1ee183578025b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52596, "upload_time": "2015-10-13T12:17:56", "upload_time_iso_8601": "2015-10-13T12:17:56.519337Z", "url": "https://files.pythonhosted.org/packages/9d/af/61435bd163f01fe3709fca9b1f79e4978d8089ee671d2e004fc85e10de29/python-pcre-0.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:16:01 2020"}