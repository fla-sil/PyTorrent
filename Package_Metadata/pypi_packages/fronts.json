{"info": {"author": "Gabriel S. Gerlero", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Science/Research", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Scientific/Engineering :: Physics", "Topic :: Software Development :: Libraries"], "description": "# <img alt=\"Fronts\" src=\"https://raw.githubusercontent.com/gerlero/fronts/master/resources/logo.png\" height=\"100\">\n\nFronts is a Python numerical library for solving one-dimensional transient nonlinear diffusion problems in semi-infinite domains.\n\nFronts finds solutions to initial-boundary value problems of the form:\n\n> **General problem**\n> \n> Given a scalar-valued positive function _D_, scalars _Si_, _Sb_ and _ob_, and coordinate unit vector **\u0213**, find a function _S_ of _r_ and _t_ such that:\n> \n> <img alt=\"General problem\" src=\"https://latex.codecogs.com/svg.latex?%5Cbegin%7Bcases%7D%20%5Cdfrac%7B%5Cpartial%20S%7D%7B%5Cpartial%20t%7D%20%3D%20%5Cnabla%5Ccdot%5Cleft%5BD%5Cleft%28S%5Cright%29%5Cdfrac%7B%5Cpartial%20S%7D%7B%5Cpartial%20r%7D%5Cmathbf%7B%5Chat%7Br%7D%7D%5Cright%20%5D%20%26%20r%3Er_b%28t%29%2Ct%3E0%5C%5C%20S%28r%2C%200%29%20%3D%20S_i%20%26%20r%3E0%20%5C%5C%20S%28r_b%28t%29%2C%20t%29%20%3D%20S_b%20%26%20t%3E0%20%5C%5C%20r_b%28t%29%20%3D%20o_b%5Csqrt%20t%5Cend%7Bcases%7D\">\n\nFronts works by transforming the governing nonlinear partial differential equation (PDE) into a more manageable (but still nonlinear) ordinary differential equation (ODE), using a technique known as the [Boltzmann transformation](https://en.wikipedia.org/wiki/Boltzmann\u2013Matano_analysis), which it then solves with a combination of numerical ODE solvers and specialized logic.\n\nFor this class of problems, you will find that Fronts can be easier to use, faster, and more robust than the classical numerical PDE solvers you would otherwise have to use.\n\nIn some instances, Fronts can also solve the inverse problem of finding _D_ when _S_ is given. And, if you need something a little different, Fronts gives you easy access to the underlying ODE so that you can use your own solving algorithm or boundary condition (which you are then welcome to contribute to the project!).\n\nFronts is open source and works great with [NumPy](https://numpy.org) and [SciPy](https://www.scipy.org/scipylib/index.html). \n\n\n## Common problem\n\nIf the general problem supported by Fronts looks too complicated, note that in the common case where **\u0213** is a Cartesian unit vector and the boundary is fixed at _r_=0, the problem can be reduced to what we call the common problem:\n\n> **Common problem**\n> \n> Given a scalar-valued positive function _D_, and scalars _Si_ and _Sb_, find a function _S_ of _r_ and _t_ such that:\n>\n> <img alt=\"Common problem\" src=\"https://latex.codecogs.com/svg.latex?%5Cbegin%7Bcases%7D%20%5Cdfrac%7B%5Cpartial%20S%7D%7B%5Cpartial%20t%7D%20%3D%20%5Cdfrac%7B%5Cpartial%7D%7B%5Cpartial%20r%7D%20%5Cleft%28D%5Cleft%28S%5Cright%29%5Cdfrac%7B%5Cpartial%20S%7D%7B%5Cpartial%20r%7D%5Cright%29%20%26%20r%3E0%2Ct%3E0%5C%5C%20S%28r%2C%200%29%20%3D%20S_i%20%26%20r%3E0%20%5C%5C%20S%280%2C%20t%29%20%3D%20S_b%20%26%20t%3E0%20%5Cend%7Bcases%7D\">\n\n\nThe main solver function ``solve()`` will assume that you want to work with this common problem unless you explicitly provide the optional `radial` and `ob` parameters. \n\n\n## Uses\n\nProblems supported by Fronts appear in many areas of physics. For instance, if we take _S_ as the water content or saturation and _D_ as the moisture diffusivity, the above PDE translates into what is known as the moisture diffusivity equation, which is a special case of the [Richards equation](https://en.wikipedia.org/wiki/Richards_equation) that describes capillary flow in porous media.\n\nOf particular interest to the creators of Fronts is the fact that the common problem supported by Fronts can directly model the configuration known as \"lateral flow\" in the field of paper-based microfluidics. In fact, the name \"Fronts\" is a reference to the wetting fronts that appear under these conditions, the study of which motivated the creation of this library.\n\nOther problems of this class appear in the study of diffusion of solutions in polymer matrices as well as diffusion problems in solids (e.g. annealing problems in metallurgy). \n\nAs mentioned before, if your problem is supported, you can expect Fronts to be easier to use, faster, and more robust than other tools. Try it out!\n\n## Installation\n\n### Prerequisites\n\n* **Python**. Fronts runs on Python 3.5 and later, as well as on the older Python 2.7. It has been tested on various releases of Python 2.7, 3.5, 3.6, 3.7 and 3.8.\n\n* **pip**. Installation of Fronts requires the Python package manager [pip](https://pip.pypa.io/en/stable/) to be installed on your system.\n\n### Installation\n\nInstall Fronts by running the following command:\n\n```\n$ pip install fronts\n```\n\nThis will install the [most recent version of Fronts available on PyPI](https://pypi.org/project/fronts/).\n\n##### Optional: Matplotlib\n\nRunning the bundled examples requires the visualization library [Matplotlib](https://matplotlib.org). This library is not installed automatically with Fronts, so if you don't already have it, you may want to install it manually by running:\n\n```\n$ pip install matplotlib\n```\n\nOptionally, the ```--user```  option can be added to the previous commands to install the packages for the current user only, which does not require system administrator privileges.\n\n## Documentation and features\n\nThe following is a complete list of the functions and classes that Fronts provides, with a short description of each. You will find the full details on each object in the [reference documentation](https://fronts.readthedocs.io).\n\n### Solvers and solutions\n\n* [**```fronts.solve()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.solve.html) \u2014 meshless solver\n\n    Main solver. ```solve``` solves any instance of the general problem. Returns a ```Solution``` object.\n    \n* [**```fronts.solve_from_guess()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.solve_from_guess.html) \u2014 mesh-based solver\n    \n    Alternative solver. ```solve_from_guess``` works like ``solve`` but it uses a different procedure that starts from a guess of the solution on an initial mesh. It supports the same problems as ```solve```. Although usually faster, ```solve_from_guess``` is significantly less robust than `solve`\u2014whether it converges will usually depend heavily on the problem, the initial mesh and the guess of the solution. It also returns a ```Solution``` on success.\n\n\n* [**```fronts.Solution```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.Solution.html), [**```fronts.BaseSolution```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.BaseSolution.html) \u2014 continuous solutions\n\n    ```BaseSolution``` objects provide the continuous functions ```S```, ```dS_dr```, ```dS_dt``` and ```flux``` that make up the solution to a problem. The solvers in Fronts return a ```Solution```\u2014a subclass of ```BaseSolution```\u2014as part of their results. If you called ```ode``` and solved the ODE yourself, you can create a ```BaseSolution``` or ```Solution``` by passing the solution to the ODE to the appropiate constructor.\n    \n    Note that in problems of the moisture diffusivity equation, the diffusive flux (which can be obtained by calling ```flux``` on a ```BaseSolution``` object) gives the velocity of the wetting fluid. In particular, if `S` is taken to mean volumetric water content, it is the Darcy velocity; if `S` is saturation, it is the fluid's true velocity. These velocity fields can be used directly in more complex problems of solute transport.\n\n\n* [**```fronts.inverse()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.inverse.html) \u2014 solve the inverse problem\n    \n     Inverse solver. ```inverse``` solves the inverse problem of finding _D_ when _S_ is known. For instance, ```inverse``` can extract _D_ from experimental results. The returned _D_ function can be used in Fronts to solve other problems. Use of this function for inverse problems [comes with some limitations](https://fronts.readthedocs.io/en/latest/stubs/fronts.inverse.html).\n    \n\n### Boltzmann transformation and ODE\n\n* [**```fronts.o()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.o.html), [**```fronts.do_dr()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.do_dr.html), [**```fronts.do_dt()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.do_dt.html), [**```fronts.r()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.r.html), [**```fronts.t()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.t.html), [**```fronts.as_o()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.as_o.html) \u2014 Boltzmann transformation\n\n    These are convenience functions for working with the Boltzmann transformation.\n\n* [**```fronts.ode()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.ode.html) \u2014 access the ODE\n\n    The ```ode``` function transforms the PDE into its corresponding ODE using the Boltzmann transformation. ```ode``` returns _fun_ and _jac_ callables that are directly compatible with SciPy's solvers (i.e., those in the  [```scipy.integrate```](https://docs.scipy.org/doc/scipy/reference/integrate.html) module). The solvers in Fronts actually use this function internally. You may call this function if you want to solve the ODE yourself instead of using Fronts' solvers, for example if you need to deal with a different boundary condition or want to use your own solving algorithm.\n\n### _D_ functions and ```fronts.D```\n\nMany of the functions in Fronts either take or return _D_ functions to work. _D_ functions have to be defined as follows:\n\n> ``D`` : _callable_\n> \n> Twice-differentiable function that maps the range of _S_ to positive values. It can be called as ``D(S)`` to evaluate it at `S`. It can also be called as ``D(S, derivatives)`` with `derivatives` equal to 1 or 2, in which case the first `derivatives` derivatives of the function evaluated at the same `S` are included (in order) as additional return values. While mathematically a scalar function, `D` operates in a vectorized fashion with the same semantics when `S` is a `numpy.ndarray`.\n \n\nWith the above definition you can easily write any functions you need to solve your particular problems. \n\nFronts also comes with a submodule ```fronts.D``` that lets you access some predefined functions:\n\n* [**```fronts.D.constant()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.D.constant.html) \u2014\u00a0create a constant function:\n\n    <img src=\"https://latex.codecogs.com/svg.latex?%5Csmall%20D%28S%29%20%3D%20D_0\">\n\n* [**```fronts.D.power_law()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.D.power_law.html) \u2014 create a function of the form:\n\n    <img src=\"https://latex.codecogs.com/svg.latex?%5Csmall%20D%28S%29%3Da%20S%5Ek%20&plus;%20%5Cvarepsilon\">\n\n* [**```fronts.D.van_genuchten()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.D.van_genuchten.html) \u2014 create a [Van Genuchten](https://doi.org/10.2136/sssaj1980.03615995004400050002x) moisture diffusivity function:\n\n    <img src=\"https://latex.codecogs.com/svg.latex?%5Csmall%20D%28S%29%3D%5Cfrac%7B%281-m%29K_s%7D%7B%5Calpha%20m%20%28S_s-S_r%29%7DS_e%5E%7Bl-%5Cfrac%7B1%7D%7Bm%7D%7D%5Cleft%28%281-S_e%5E%5Cfrac%7B1%7D%7Bm%7D%29%5E%7B-m%7D%20&plus;%20%281-S_e%5E%5Cfrac%7B1%7D%7Bm%7D%29%5Em%20-%202%20%5Cright%29\">\n    \n    where _S_ is either water content or saturation, and _Se_ is defined as:\n    \n    <img src=\"https://latex.codecogs.com/svg.latex?%5Csmall%20S_e%20%3D%20%5Cfrac%7BS-S_r%7D%7BS_s-S_r%7D\">\n\n\n* [**```fronts.D.richards()```**](https://fronts.readthedocs.io/en/latest/stubs/fronts.D.richards.html) \u2014\u00a0make a moisture diffusivity function from a relative permeability/conductivity function _kr_ and a capillary capacity function _C_, using the definition: \n    \n    <img src=\"https://latex.codecogs.com/svg.latex?%5Csmall%20D%28S%29%20%3D%20%5Cfrac%7BK_Sk_r%28S%29%7D%7BC%28S%29%7D\">\n\n    Can be used to convert problems of the Richards equation (for which those two functions are parameters) in horizontal domains into moisture diffusivity problems that can be solved with Fronts.\n    \n## Examples\n\n### Introductory example\n\n_Plotting the solution in this example requires_ [Matplotlib](https://matplotlib.org)_._\n\nLet us solve the following initial-boundary value problem defined in a semi-infinite domain:\n\n> **Example problem**\n>\n> Find _S_ such that:\n>\n> <img alt=\"Example problem\" src=\"https://latex.codecogs.com/svg.latex?%5Cbegin%7Bcases%7D%20%5Cdfrac%7B%5Cpartial%20S%7D%7B%5Cpartial%20t%7D%20%3D%20%5Cdfrac%7B%5Cpartial%7D%7B%5Cpartial%20r%7D%5Cleft%28S%5E4%5Cdfrac%7B%5Cpartial%20S%7D%7B%5Cpartial%20r%7D%5Cright%29%20%26%20r%3E0%2Ct%3E0%20%5C%5C%20S%28r%2C0%29%20%3D%200.1%20%26%20r%3E0%20%5C%5C%20S%280%2Ct%29%20%3D%201%20%26%20t%3E0%20%5C%5C%20%5Cend%7Bcases%7D\">\n\nBy comparing the example problem with the common problem introduced above, we see that  the parameters are:\n\n<img alt=\"Parameters\" src=\"https://latex.codecogs.com/svg.latex?%5Cbegin%7Bcases%7D%20D%28S%29%20%3D%20S%5E4%20%5C%5C%20S_i%20%3D%200.1%20%5C%5C%20S_b%20%3D%201%20%5Cend%7Bcases%7D\">\n\nIn this case it is not necessary to write the function `D` it ourselves. The function we need can be obtained from the ``fronts.D`` module:\n\n```python\nfrom fronts.D import power_law\nD = power_law(k=4)\n```\n\nWe are now ready to solve the problem with ``fronts.solve``. We simply pass it the parameters ``D``, ``Si`` and ``Sb``.\n\n```python\nfrom fronts import solve\nsolution = solve(D, Si=0.1, Sb=1)\n```\n\nThe call to ```fronts.solve``` completes within a second and we get back a ```Solution``` object, which holds the functions ```S```, ```dS_dr```, ```dS_dt```and ```flux```.\n\nWe can now plot _S_ for arbitrary _r_ and _t_. For example, with _r_ between 0 and 10 and _t_=60:\n\n```python\nimport matplotlib.pyplot as plt\nr = np.linspace(0, 10, 200)\nplt.plot(r, solution.S(r, t=60))\nplt.xlabel(\"r\")\nplt.ylabel(\"S\")\nplt.show()\n```\n\nThe plot will look like this:\n\n<img alt=\"S plot\" src=\"https://raw.githubusercontent.com/gerlero/fronts/master/resources/powerlaw_S.png\" height=400>\n\nFinally, let us plot the flux at _t_=60:\n\n```python\nplt.plot(r, solution.flux(r, t=60))\nplt.xlabel(\"r\")\nplt.ylabel(\"flux\")\nplt.show()\n```\n\n<img alt=\"flux plot\" src=\"https://raw.githubusercontent.com/gerlero/fronts/master/resources/powerlaw_flux.png\" height=400>\n\n### More examples\n\nThe included examples can be found in the ``examples`` directory of this project. The directory contains the following files:\n\n\n* subdirectory **``powerlaw/``** \u2014 cases based on the introductory example presented above\n    * **``solve.py``**: solve the case with `fronts.solve()`.\n    * **``radial.py``**: solve a radial case (with a moving boundary) using `fronts.solve()`.\n    * **``inverse.py``**: more examples of usage of `fronts.solve()` and of `fronts.inverse()`.\n    * **``D.py``**: plot D for this case.\n* subdirectory **``1INFILTR/``** \u2014 the _1INFILTR_ test case from [Hydrus-1D](https://www.pc-progress.com/en/Default.aspx?hydrus-1d), in horizontal\n    * **``solve.py``**: solve the case with `fronts.solve()`.\n    * **``validation.py``**: results for the same case obtained using Hydrus for comparison.\n* subdirectory **``HF135/``**\u2014 infiltration into an HF135 nitrocellulose membrane (data from the [PhD work of J.R. Buser](http://hdl.handle.net/1773/38064))\n    * **``solve.py``**: solve the lateral flow case with `fronts.solve()`.\n    * **``refine.py``**: get a rough approximation of the solution to the lateral flow case using `fronts.solve()` with a high tolerance, and then refine it with both `fronts.solve()` and `fronts.solve_from_guess()`.\n    * **``radial.py``**: radial (cylindrical) flow case.\n    * \ud83d\udc0c **``inverse1.py``**: use `fronts.inverse()` to extract _D_ from a solution. Here, the solution is obtained with \n`fronts.solve()`. The extracted _D_ is then used with `fronts.solve()` and the\nsame conditions to verify that an equivalent solution is obtained.\n    * \ud83d\udc0c **``inverse2.py``**: use `fronts.inverse()` to obtain _D_ \nfrom the validation case and then use it to solve the same problem.\n    * **``validation.py``**: results with the same case solved with [porousMultiphaseFoam](https://github.com/phorgue/porousMultiphaseFoam) for comparison.\n    * **``D.py``**: plot D for this case.\n* subdirectory **``exact/``** \u2014 solve a case with a _D_ function proposed by [Philip](https://doi.org/10.1071/PH600001) that has an exact solution\n    * **``solve.py``**: solve the case with `fronts.solve()` and compare with the exact solution.\n    * **``fromguess.py``**: solve the case with `fronts.solve_from_guess()` and compare with the exact solution.\n    * **``D.py``**: plot D for this case.\n\n\n**Note:** the examples marked with \ud83d\udc0c are significantly more computationally intensive and may take more than a minute to run to completion. All other cases should finish within a few seconds at the most.\n\n## Authors\n\n* **Gabriel S. Gerlero** [@gerlero](https://github.com/gerlero)\n* **Pablo A. Kler** [@pabloakler](https://github.com/pabloakler)\n* **Claudio L.A. Berli**\n\nFronts was conceived and is developed by members of the [Santa Fe Microfluidics Group (GSaM)](http://www.microfluidica.com.ar) at the [Research Center for Computational Methods (CIMEC, UNL-CONICET)](https://www.cimec.org.ar) and the [Institute of Technological Development for the Chemical Industry (INTEC, UNL-CONICET)](https://intec.conicet.gov.ar) in Santa Fe, Argentina.\n\n\n\n<img alt=\"CIMEC (UNL-CONICET)\" src=\"https://raw.githubusercontent.com/gerlero/fronts/master/resources/CIMEC.png\" height=70> &nbsp; <img alt=\"INTEC (UNL-CONICET)\" src=\"https://raw.githubusercontent.com/gerlero/fronts/master/resources/INTEC.png\" height=65> &nbsp; <img alt=\"GSaM\" src=\"https://raw.githubusercontent.com/gerlero/fronts/master/resources/GSaMLogo.png\" height=65> \n\n \n\n\n## License\n\nFronts is open-source software available under the BSD 3-clause license.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/gerlero/fronts", "keywords": "", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "fronts", "package_url": "https://pypi.org/project/fronts/", "platform": "", "project_url": "https://pypi.org/project/fronts/", "project_urls": {"Bug Tracker": "https://github.com/gerlero/fronts/issues", "Documentation": "https://fronts.readthedocs.io", "Homepage": "https://github.com/gerlero/fronts", "Source Code": "https://github.com/gerlero/fronts"}, "release_url": "https://pypi.org/project/fronts/0.9.7/", "requires_dist": null, "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "summary": "Numerical library for one-dimensional nonlinear diffusion problems in semi-infinite domains", "version": "0.9.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1><img alt=\"Fronts\" height=\"100\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bac4f0783632cbeddd42556f101825b425473f03/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6765726c65726f2f66726f6e74732f6d61737465722f7265736f75726365732f6c6f676f2e706e67\"></h1>\n<p>Fronts is a Python numerical library for solving one-dimensional transient nonlinear diffusion problems in semi-infinite domains.</p>\n<p>Fronts finds solutions to initial-boundary value problems of the form:</p>\n<blockquote>\n<p><strong>General problem</strong></p>\n<p>Given a scalar-valued positive function <em>D</em>, scalars <em>Si</em>, <em>Sb</em> and <em>ob</em>, and coordinate unit vector <strong>\u0213</strong>, find a function <em>S</em> of <em>r</em> and <em>t</em> such that:</p>\n<img alt=\"General problem\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cdc59be7520575afe91ca01e190cd5f5cfa0a058/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f253543626567696e253742636173657325374425323025354364667261632537422535437061727469616c253230532537442537422535437061727469616c253230742537442532302533442532302535436e61626c6125354363646f742535436c656674253542442535436c65667425323853253543726967687425323925354364667261632537422535437061727469616c253230532537442537422535437061727469616c253230722537442535436d617468626625374225354368617425374272253744253744253543726967687425323025354425323025323625323072253345725f62253238742532392532437425334530253543253543253230532532387225324325323030253239253230253344253230535f69253230253236253230722533453025323025354325354325323053253238725f622532387425323925324325323074253239253230253344253230535f622532302532362532307425334530253230253543253543253230725f62253238742532392532302533442532306f5f622535437371727425323074253543656e642537426361736573253744\">\n</blockquote>\n<p>Fronts works by transforming the governing nonlinear partial differential equation (PDE) into a more manageable (but still nonlinear) ordinary differential equation (ODE), using a technique known as the <a href=\"https://en.wikipedia.org/wiki/Boltzmann%E2%80%93Matano_analysis\" rel=\"nofollow\">Boltzmann transformation</a>, which it then solves with a combination of numerical ODE solvers and specialized logic.</p>\n<p>For this class of problems, you will find that Fronts can be easier to use, faster, and more robust than the classical numerical PDE solvers you would otherwise have to use.</p>\n<p>In some instances, Fronts can also solve the inverse problem of finding <em>D</em> when <em>S</em> is given. And, if you need something a little different, Fronts gives you easy access to the underlying ODE so that you can use your own solving algorithm or boundary condition (which you are then welcome to contribute to the project!).</p>\n<p>Fronts is open source and works great with <a href=\"https://numpy.org\" rel=\"nofollow\">NumPy</a> and <a href=\"https://www.scipy.org/scipylib/index.html\" rel=\"nofollow\">SciPy</a>.</p>\n<h2>Common problem</h2>\n<p>If the general problem supported by Fronts looks too complicated, note that in the common case where <strong>\u0213</strong> is a Cartesian unit vector and the boundary is fixed at <em>r</em>=0, the problem can be reduced to what we call the common problem:</p>\n<blockquote>\n<p><strong>Common problem</strong></p>\n<p>Given a scalar-valued positive function <em>D</em>, and scalars <em>Si</em> and <em>Sb</em>, find a function <em>S</em> of <em>r</em> and <em>t</em> such that:</p>\n<img alt=\"Common problem\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fb01b4dc2d9ca966afe44e6806f469f0248fca8f/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f253543626567696e253742636173657325374425323025354364667261632537422535437061727469616c253230532537442537422535437061727469616c2532307425374425323025334425323025354364667261632537422535437061727469616c2537442537422535437061727469616c253230722537442532302535436c656674253238442535436c65667425323853253543726967687425323925354364667261632537422535437061727469616c253230532537442537422535437061727469616c25323072253744253543726967687425323925323025323625323072253345302532437425334530253543253543253230532532387225324325323030253239253230253344253230535f692532302532362532307225334530253230253543253543253230532532383025324325323074253239253230253344253230535f622532302532362532307425334530253230253543656e642537426361736573253744\">\n</blockquote>\n<p>The main solver function <code>solve()</code> will assume that you want to work with this common problem unless you explicitly provide the optional <code>radial</code> and <code>ob</code> parameters.</p>\n<h2>Uses</h2>\n<p>Problems supported by Fronts appear in many areas of physics. For instance, if we take <em>S</em> as the water content or saturation and <em>D</em> as the moisture diffusivity, the above PDE translates into what is known as the moisture diffusivity equation, which is a special case of the <a href=\"https://en.wikipedia.org/wiki/Richards_equation\" rel=\"nofollow\">Richards equation</a> that describes capillary flow in porous media.</p>\n<p>Of particular interest to the creators of Fronts is the fact that the common problem supported by Fronts can directly model the configuration known as \"lateral flow\" in the field of paper-based microfluidics. In fact, the name \"Fronts\" is a reference to the wetting fronts that appear under these conditions, the study of which motivated the creation of this library.</p>\n<p>Other problems of this class appear in the study of diffusion of solutions in polymer matrices as well as diffusion problems in solids (e.g. annealing problems in metallurgy).</p>\n<p>As mentioned before, if your problem is supported, you can expect Fronts to be easier to use, faster, and more robust than other tools. Try it out!</p>\n<h2>Installation</h2>\n<h3>Prerequisites</h3>\n<ul>\n<li>\n<p><strong>Python</strong>. Fronts runs on Python 3.5 and later, as well as on the older Python 2.7. It has been tested on various releases of Python 2.7, 3.5, 3.6, 3.7 and 3.8.</p>\n</li>\n<li>\n<p><strong>pip</strong>. Installation of Fronts requires the Python package manager <a href=\"https://pip.pypa.io/en/stable/\" rel=\"nofollow\">pip</a> to be installed on your system.</p>\n</li>\n</ul>\n<h3>Installation</h3>\n<p>Install Fronts by running the following command:</p>\n<pre><code>$ pip install fronts\n</code></pre>\n<p>This will install the <a href=\"https://pypi.org/project/fronts/\" rel=\"nofollow\">most recent version of Fronts available on PyPI</a>.</p>\n<h5>Optional: Matplotlib</h5>\n<p>Running the bundled examples requires the visualization library <a href=\"https://matplotlib.org\" rel=\"nofollow\">Matplotlib</a>. This library is not installed automatically with Fronts, so if you don't already have it, you may want to install it manually by running:</p>\n<pre><code>$ pip install matplotlib\n</code></pre>\n<p>Optionally, the <code>--user</code>  option can be added to the previous commands to install the packages for the current user only, which does not require system administrator privileges.</p>\n<h2>Documentation and features</h2>\n<p>The following is a complete list of the functions and classes that Fronts provides, with a short description of each. You will find the full details on each object in the <a href=\"https://fronts.readthedocs.io\" rel=\"nofollow\">reference documentation</a>.</p>\n<h3>Solvers and solutions</h3>\n<ul>\n<li>\n<p><a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.solve.html\" rel=\"nofollow\"><strong><code>fronts.solve()</code></strong></a> \u2014 meshless solver</p>\n<p>Main solver. <code>solve</code> solves any instance of the general problem. Returns a <code>Solution</code> object.</p>\n</li>\n<li>\n<p><a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.solve_from_guess.html\" rel=\"nofollow\"><strong><code>fronts.solve_from_guess()</code></strong></a> \u2014 mesh-based solver</p>\n<p>Alternative solver. <code>solve_from_guess</code> works like <code>solve</code> but it uses a different procedure that starts from a guess of the solution on an initial mesh. It supports the same problems as <code>solve</code>. Although usually faster, <code>solve_from_guess</code> is significantly less robust than <code>solve</code>\u2014whether it converges will usually depend heavily on the problem, the initial mesh and the guess of the solution. It also returns a <code>Solution</code> on success.</p>\n</li>\n<li>\n<p><a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.Solution.html\" rel=\"nofollow\"><strong><code>fronts.Solution</code></strong></a>, <a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.BaseSolution.html\" rel=\"nofollow\"><strong><code>fronts.BaseSolution</code></strong></a> \u2014 continuous solutions</p>\n<p><code>BaseSolution</code> objects provide the continuous functions <code>S</code>, <code>dS_dr</code>, <code>dS_dt</code> and <code>flux</code> that make up the solution to a problem. The solvers in Fronts return a <code>Solution</code>\u2014a subclass of <code>BaseSolution</code>\u2014as part of their results. If you called <code>ode</code> and solved the ODE yourself, you can create a <code>BaseSolution</code> or <code>Solution</code> by passing the solution to the ODE to the appropiate constructor.</p>\n<p>Note that in problems of the moisture diffusivity equation, the diffusive flux (which can be obtained by calling <code>flux</code> on a <code>BaseSolution</code> object) gives the velocity of the wetting fluid. In particular, if <code>S</code> is taken to mean volumetric water content, it is the Darcy velocity; if <code>S</code> is saturation, it is the fluid's true velocity. These velocity fields can be used directly in more complex problems of solute transport.</p>\n</li>\n<li>\n<p><a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.inverse.html\" rel=\"nofollow\"><strong><code>fronts.inverse()</code></strong></a> \u2014 solve the inverse problem</p>\n<p>Inverse solver. <code>inverse</code> solves the inverse problem of finding <em>D</em> when <em>S</em> is known. For instance, <code>inverse</code> can extract <em>D</em> from experimental results. The returned <em>D</em> function can be used in Fronts to solve other problems. Use of this function for inverse problems <a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.inverse.html\" rel=\"nofollow\">comes with some limitations</a>.</p>\n</li>\n</ul>\n<h3>Boltzmann transformation and ODE</h3>\n<ul>\n<li>\n<p><a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.o.html\" rel=\"nofollow\"><strong><code>fronts.o()</code></strong></a>, <a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.do_dr.html\" rel=\"nofollow\"><strong><code>fronts.do_dr()</code></strong></a>, <a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.do_dt.html\" rel=\"nofollow\"><strong><code>fronts.do_dt()</code></strong></a>, <a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.r.html\" rel=\"nofollow\"><strong><code>fronts.r()</code></strong></a>, <a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.t.html\" rel=\"nofollow\"><strong><code>fronts.t()</code></strong></a>, <a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.as_o.html\" rel=\"nofollow\"><strong><code>fronts.as_o()</code></strong></a> \u2014 Boltzmann transformation</p>\n<p>These are convenience functions for working with the Boltzmann transformation.</p>\n</li>\n<li>\n<p><a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.ode.html\" rel=\"nofollow\"><strong><code>fronts.ode()</code></strong></a> \u2014 access the ODE</p>\n<p>The <code>ode</code> function transforms the PDE into its corresponding ODE using the Boltzmann transformation. <code>ode</code> returns <em>fun</em> and <em>jac</em> callables that are directly compatible with SciPy's solvers (i.e., those in the  <a href=\"https://docs.scipy.org/doc/scipy/reference/integrate.html\" rel=\"nofollow\"><code>scipy.integrate</code></a> module). The solvers in Fronts actually use this function internally. You may call this function if you want to solve the ODE yourself instead of using Fronts' solvers, for example if you need to deal with a different boundary condition or want to use your own solving algorithm.</p>\n</li>\n</ul>\n<h3><em>D</em> functions and <code>fronts.D</code></h3>\n<p>Many of the functions in Fronts either take or return <em>D</em> functions to work. <em>D</em> functions have to be defined as follows:</p>\n<blockquote>\n<p><code>D</code> : <em>callable</em></p>\n<p>Twice-differentiable function that maps the range of <em>S</em> to positive values. It can be called as <code>D(S)</code> to evaluate it at <code>S</code>. It can also be called as <code>D(S, derivatives)</code> with <code>derivatives</code> equal to 1 or 2, in which case the first <code>derivatives</code> derivatives of the function evaluated at the same <code>S</code> are included (in order) as additional return values. While mathematically a scalar function, <code>D</code> operates in a vectorized fashion with the same semantics when <code>S</code> is a <code>numpy.ndarray</code>.</p>\n</blockquote>\n<p>With the above definition you can easily write any functions you need to solve your particular problems.</p>\n<p>Fronts also comes with a submodule <code>fronts.D</code> that lets you access some predefined functions:</p>\n<ul>\n<li>\n<p><a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.D.constant.html\" rel=\"nofollow\"><strong><code>fronts.D.constant()</code></strong></a> \u2014\u00a0create a constant function:</p>\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c4081322932d67de2950496eb0caa36f9bffea1d/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f253543736d616c6c2532304425323853253239253230253344253230445f30\">\n</li>\n<li>\n<p><a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.D.power_law.html\" rel=\"nofollow\"><strong><code>fronts.D.power_law()</code></strong></a> \u2014 create a function of the form:</p>\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/38353e4c994ea47f421ce2a8b6995a901a0fe6bf/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f253543736d616c6c253230442532385325323925334461253230532535456b25323026706c75733b253230253543766172657073696c6f6e\">\n</li>\n<li>\n<p><a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.D.van_genuchten.html\" rel=\"nofollow\"><strong><code>fronts.D.van_genuchten()</code></strong></a> \u2014 create a <a href=\"https://doi.org/10.2136/sssaj1980.03615995004400050002x\" rel=\"nofollow\">Van Genuchten</a> moisture diffusivity function:</p>\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1d8627784b2661ead108403c0bd70157e110be8f/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f253543736d616c6c253230442532385325323925334425354366726163253742253238312d6d2532394b5f73253744253742253543616c7068612532306d253230253238535f732d535f72253239253744535f652535452537426c2d25354366726163253742312537442537426d2537442537442535436c656674253238253238312d535f6525354525354366726163253742312537442537426d2537442532392535452537422d6d25374425323026706c75733b253230253238312d535f6525354525354366726163253742312537442537426d2537442532392535456d2532302d253230322532302535437269676874253239\">\n<p>where <em>S</em> is either water content or saturation, and <em>Se</em> is defined as:</p>\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a2f137968fc854290a1b387f7fbd8fe5e7c043c5/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f253543736d616c6c253230535f6525323025334425323025354366726163253742532d535f72253744253742535f732d535f72253744\">\n</li>\n<li>\n<p><a href=\"https://fronts.readthedocs.io/en/latest/stubs/fronts.D.richards.html\" rel=\"nofollow\"><strong><code>fronts.D.richards()</code></strong></a> \u2014\u00a0make a moisture diffusivity function from a relative permeability/conductivity function <em>kr</em> and a capillary capacity function <em>C</em>, using the definition:</p>\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4a98daa6e30291a15688246edc4ac46a645945a0/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f253543736d616c6c2532304425323853253239253230253344253230253543667261632537424b5f536b5f72253238532532392537442537424325323853253239253744\">\n<p>Can be used to convert problems of the Richards equation (for which those two functions are parameters) in horizontal domains into moisture diffusivity problems that can be solved with Fronts.</p>\n</li>\n</ul>\n<h2>Examples</h2>\n<h3>Introductory example</h3>\n<p><em>Plotting the solution in this example requires</em> <a href=\"https://matplotlib.org\" rel=\"nofollow\">Matplotlib</a><em>.</em></p>\n<p>Let us solve the following initial-boundary value problem defined in a semi-infinite domain:</p>\n<blockquote>\n<p><strong>Example problem</strong></p>\n<p>Find <em>S</em> such that:</p>\n<img alt=\"Example problem\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/22dd585d4df64fc91280303a5d812f3b2fc64feb/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f253543626567696e253742636173657325374425323025354364667261632537422535437061727469616c253230532537442537422535437061727469616c2532307425374425323025334425323025354364667261632537422535437061727469616c2537442537422535437061727469616c253230722537442535436c656674253238532535453425354364667261632537422535437061727469616c253230532537442537422535437061727469616c25323072253744253543726967687425323925323025323625323072253345302532437425334530253230253543253543253230532532387225324330253239253230253344253230302e312532302532362532307225334530253230253543253543253230532532383025324374253239253230253344253230312532302532362532307425334530253230253543253543253230253543656e642537426361736573253744\">\n</blockquote>\n<p>By comparing the example problem with the common problem introduced above, we see that  the parameters are:</p>\n<img alt=\"Parameters\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/61f107ad529c23cf73d5c7bcb3a6ca9b1a1523de/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f7376672e6c617465783f253543626567696e253742636173657325374425323044253238532532392532302533442532305325354534253230253543253543253230535f69253230253344253230302e31253230253543253543253230535f6225323025334425323031253230253543656e642537426361736573253744\">\n<p>In this case it is not necessary to write the function <code>D</code> it ourselves. The function we need can be obtained from the <code>fronts.D</code> module:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">fronts.D</span> <span class=\"kn\">import</span> <span class=\"n\">power_law</span>\n<span class=\"n\">D</span> <span class=\"o\">=</span> <span class=\"n\">power_law</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n</pre>\n<p>We are now ready to solve the problem with <code>fronts.solve</code>. We simply pass it the parameters <code>D</code>, <code>Si</code> and <code>Sb</code>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">fronts</span> <span class=\"kn\">import</span> <span class=\"n\">solve</span>\n<span class=\"n\">solution</span> <span class=\"o\">=</span> <span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">D</span><span class=\"p\">,</span> <span class=\"n\">Si</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">Sb</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>The call to <code>fronts.solve</code> completes within a second and we get back a <code>Solution</code> object, which holds the functions <code>S</code>, <code>dS_dr</code>, <code>dS_dt</code>and <code>flux</code>.</p>\n<p>We can now plot <em>S</em> for arbitrary <em>r</em> and <em>t</em>. For example, with <em>r</em> between 0 and 10 and <em>t</em>=60:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">solution</span><span class=\"o\">.</span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mi\">60</span><span class=\"p\">))</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">xlabel</span><span class=\"p\">(</span><span class=\"s2\">\"r\"</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">ylabel</span><span class=\"p\">(</span><span class=\"s2\">\"S\"</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p>The plot will look like this:</p>\n<img alt=\"S plot\" height=\"400\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/496daedc4c29fc90f17018f40486ae18d8904f1c/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6765726c65726f2f66726f6e74732f6d61737465722f7265736f75726365732f706f7765726c61775f532e706e67\">\n<p>Finally, let us plot the flux at <em>t</em>=60:</p>\n<pre><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">solution</span><span class=\"o\">.</span><span class=\"n\">flux</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mi\">60</span><span class=\"p\">))</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">xlabel</span><span class=\"p\">(</span><span class=\"s2\">\"r\"</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">ylabel</span><span class=\"p\">(</span><span class=\"s2\">\"flux\"</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<img alt=\"flux plot\" height=\"400\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d5a6e28f68851d75f218cf2bd07a2e4be08ea1da/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6765726c65726f2f66726f6e74732f6d61737465722f7265736f75726365732f706f7765726c61775f666c75782e706e67\">\n<h3>More examples</h3>\n<p>The included examples can be found in the <code>examples</code> directory of this project. The directory contains the following files:</p>\n<ul>\n<li>subdirectory <strong><code>powerlaw/</code></strong> \u2014 cases based on the introductory example presented above\n<ul>\n<li><strong><code>solve.py</code></strong>: solve the case with <code>fronts.solve()</code>.</li>\n<li><strong><code>radial.py</code></strong>: solve a radial case (with a moving boundary) using <code>fronts.solve()</code>.</li>\n<li><strong><code>inverse.py</code></strong>: more examples of usage of <code>fronts.solve()</code> and of <code>fronts.inverse()</code>.</li>\n<li><strong><code>D.py</code></strong>: plot D for this case.</li>\n</ul>\n</li>\n<li>subdirectory <strong><code>1INFILTR/</code></strong> \u2014 the <em>1INFILTR</em> test case from <a href=\"https://www.pc-progress.com/en/Default.aspx?hydrus-1d\" rel=\"nofollow\">Hydrus-1D</a>, in horizontal\n<ul>\n<li><strong><code>solve.py</code></strong>: solve the case with <code>fronts.solve()</code>.</li>\n<li><strong><code>validation.py</code></strong>: results for the same case obtained using Hydrus for comparison.</li>\n</ul>\n</li>\n<li>subdirectory <strong><code>HF135/</code></strong>\u2014 infiltration into an HF135 nitrocellulose membrane (data from the <a href=\"http://hdl.handle.net/1773/38064\" rel=\"nofollow\">PhD work of J.R. Buser</a>)\n<ul>\n<li><strong><code>solve.py</code></strong>: solve the lateral flow case with <code>fronts.solve()</code>.</li>\n<li><strong><code>refine.py</code></strong>: get a rough approximation of the solution to the lateral flow case using <code>fronts.solve()</code> with a high tolerance, and then refine it with both <code>fronts.solve()</code> and <code>fronts.solve_from_guess()</code>.</li>\n<li><strong><code>radial.py</code></strong>: radial (cylindrical) flow case.</li>\n<li>\ud83d\udc0c <strong><code>inverse1.py</code></strong>: use <code>fronts.inverse()</code> to extract <em>D</em> from a solution. Here, the solution is obtained with\n<code>fronts.solve()</code>. The extracted <em>D</em> is then used with <code>fronts.solve()</code> and the\nsame conditions to verify that an equivalent solution is obtained.</li>\n<li>\ud83d\udc0c <strong><code>inverse2.py</code></strong>: use <code>fronts.inverse()</code> to obtain <em>D</em>\nfrom the validation case and then use it to solve the same problem.</li>\n<li><strong><code>validation.py</code></strong>: results with the same case solved with <a href=\"https://github.com/phorgue/porousMultiphaseFoam\" rel=\"nofollow\">porousMultiphaseFoam</a> for comparison.</li>\n<li><strong><code>D.py</code></strong>: plot D for this case.</li>\n</ul>\n</li>\n<li>subdirectory <strong><code>exact/</code></strong> \u2014 solve a case with a <em>D</em> function proposed by <a href=\"https://doi.org/10.1071/PH600001\" rel=\"nofollow\">Philip</a> that has an exact solution\n<ul>\n<li><strong><code>solve.py</code></strong>: solve the case with <code>fronts.solve()</code> and compare with the exact solution.</li>\n<li><strong><code>fromguess.py</code></strong>: solve the case with <code>fronts.solve_from_guess()</code> and compare with the exact solution.</li>\n<li><strong><code>D.py</code></strong>: plot D for this case.</li>\n</ul>\n</li>\n</ul>\n<p><strong>Note:</strong> the examples marked with \ud83d\udc0c are significantly more computationally intensive and may take more than a minute to run to completion. All other cases should finish within a few seconds at the most.</p>\n<h2>Authors</h2>\n<ul>\n<li><strong>Gabriel S. Gerlero</strong> <a href=\"https://github.com/gerlero\" rel=\"nofollow\">@gerlero</a></li>\n<li><strong>Pablo A. Kler</strong> <a href=\"https://github.com/pabloakler\" rel=\"nofollow\">@pabloakler</a></li>\n<li><strong>Claudio L.A. Berli</strong></li>\n</ul>\n<p>Fronts was conceived and is developed by members of the <a href=\"http://www.microfluidica.com.ar\" rel=\"nofollow\">Santa Fe Microfluidics Group (GSaM)</a> at the <a href=\"https://www.cimec.org.ar\" rel=\"nofollow\">Research Center for Computational Methods (CIMEC, UNL-CONICET)</a> and the <a href=\"https://intec.conicet.gov.ar\" rel=\"nofollow\">Institute of Technological Development for the Chemical Industry (INTEC, UNL-CONICET)</a> in Santa Fe, Argentina.</p>\n<p><img alt=\"CIMEC (UNL-CONICET)\" height=\"70\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6f506c8f31fc08be6679befdc321ac05d8d361cf/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6765726c65726f2f66726f6e74732f6d61737465722f7265736f75726365732f43494d45432e706e67\"> \u00a0 <img alt=\"INTEC (UNL-CONICET)\" height=\"65\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/821cf163fa0899b46931559dbf861d59a9af8064/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6765726c65726f2f66726f6e74732f6d61737465722f7265736f75726365732f494e5445432e706e67\"> \u00a0 <img alt=\"GSaM\" height=\"65\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/905f546079ddea049bf4b530274b4e5936c1c0d7/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6765726c65726f2f66726f6e74732f6d61737465722f7265736f75726365732f4753614d4c6f676f2e706e67\"></p>\n<h2>License</h2>\n<p>Fronts is open-source software available under the BSD 3-clause license.</p>\n\n          </div>"}, "last_serial": 6612068, "releases": {"0.9.0": [{"comment_text": "", "digests": {"md5": "40541476c74ad683c53036a53293866c", "sha256": "ef916bb472bdbce40bfd5014e5e8d8d5c3d0780003500d1da0513fa69db68102"}, "downloads": -1, "filename": "fronts-0.9.0.tar.gz", "has_sig": false, "md5_digest": "40541476c74ad683c53036a53293866c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 23811, "upload_time": "2019-09-16T17:05:04", "upload_time_iso_8601": "2019-09-16T17:05:04.784110Z", "url": "https://files.pythonhosted.org/packages/da/ca/c17e95767ea9a3a91b10d47930fce2627f6094917149a185bf32965ab7ae/fronts-0.9.0.tar.gz", "yanked": false}], "0.9.1": [{"comment_text": "", "digests": {"md5": "72edae36358d2f6ec496b6dfd96ed778", "sha256": "663c9d5218b07f1228501f5af6ebeb441521f0f450e03807342c9e2437ed2aff"}, "downloads": -1, "filename": "fronts-0.9.1.tar.gz", "has_sig": false, "md5_digest": "72edae36358d2f6ec496b6dfd96ed778", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 23797, "upload_time": "2019-09-16T18:09:56", "upload_time_iso_8601": "2019-09-16T18:09:56.230432Z", "url": "https://files.pythonhosted.org/packages/25/d0/d62a3780942340f1021b121f5bbd21a52fa28a9417bcb17c6013baa3c7ba/fronts-0.9.1.tar.gz", "yanked": false}], "0.9.2": [{"comment_text": "", "digests": {"md5": "90811e105ad74d9a8eea4a3e2640129c", "sha256": "49fac93f654f8b23590c126e86edb1bc7ea58208db4c05c63068bdf706542d0c"}, "downloads": -1, "filename": "fronts-0.9.2.tar.gz", "has_sig": false, "md5_digest": "90811e105ad74d9a8eea4a3e2640129c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 23826, "upload_time": "2019-09-16T18:15:17", "upload_time_iso_8601": "2019-09-16T18:15:17.858426Z", "url": "https://files.pythonhosted.org/packages/07/ad/db8ffa0f14bd5b4e68065ee349f26e0e7b86a6d9b0f20820cbddaa9168d0/fronts-0.9.2.tar.gz", "yanked": false}], "0.9.3": [{"comment_text": "", "digests": {"md5": "622ca9ad3e4ae3e2bf61ae655617c4e7", "sha256": "fe58c0a79e2d5a21fb5b456c6608b6aec2bd552d76170769ab49df375308a7d8"}, "downloads": -1, "filename": "fronts-0.9.3.tar.gz", "has_sig": false, "md5_digest": "622ca9ad3e4ae3e2bf61ae655617c4e7", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 24215, "upload_time": "2019-09-27T17:53:20", "upload_time_iso_8601": "2019-09-27T17:53:20.880648Z", "url": "https://files.pythonhosted.org/packages/d8/26/a4a927cd1c9ca491b91ae22b3a9e29be1b2d03b4acf6f212b64d1886831a/fronts-0.9.3.tar.gz", "yanked": false}], "0.9.4": [{"comment_text": "", "digests": {"md5": "7aef286391a202db34e153064321848f", "sha256": "2e937c54cd7abee1d1575c5f3fd36236d1ffc05b81125cab06d5808838133c7a"}, "downloads": -1, "filename": "fronts-0.9.4.tar.gz", "has_sig": false, "md5_digest": "7aef286391a202db34e153064321848f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 24073, "upload_time": "2019-10-09T15:17:09", "upload_time_iso_8601": "2019-10-09T15:17:09.988318Z", "url": "https://files.pythonhosted.org/packages/7c/4a/2cd33f70e72a38a66a71e708e6be826861c71337bc06a011efdd1472d5a3/fronts-0.9.4.tar.gz", "yanked": false}], "0.9.5": [{"comment_text": "", "digests": {"md5": "eb84f22bc8c3004d4972921bbff7f24b", "sha256": "7f6bed05f861eb809933090a4d96f82ffbc3908bdc02dcdfd1e0f59e89c6a6c4"}, "downloads": -1, "filename": "fronts-0.9.5.tar.gz", "has_sig": false, "md5_digest": "eb84f22bc8c3004d4972921bbff7f24b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 24173, "upload_time": "2019-12-26T14:39:15", "upload_time_iso_8601": "2019-12-26T14:39:15.848611Z", "url": "https://files.pythonhosted.org/packages/f7/31/70a1cb5d4cf913c1477708c7654fd490b5101ea241065dc7deeb9a19d94d/fronts-0.9.5.tar.gz", "yanked": false}], "0.9.6": [{"comment_text": "", "digests": {"md5": "9b2514b481bd8691d30fe5057a163a73", "sha256": "6bab2f6a0d61533d8b8f5387a94d6f06be619245090d61daf1f4343d1ded72af"}, "downloads": -1, "filename": "fronts-0.9.6.tar.gz", "has_sig": false, "md5_digest": "9b2514b481bd8691d30fe5057a163a73", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 25262, "upload_time": "2020-02-10T16:24:15", "upload_time_iso_8601": "2020-02-10T16:24:15.438737Z", "url": "https://files.pythonhosted.org/packages/ec/dd/9f7e57ce06b17303b4f48f6e201d586032b3c395a9a5ca5c20e62219a51f/fronts-0.9.6.tar.gz", "yanked": false}], "0.9.7": [{"comment_text": "", "digests": {"md5": "a9efcab2a7f5f9d3df88123b6160fc08", "sha256": "561e26fba6d3e86b3f4e62732e13bb5fe104765cd792694dad37bd824f334962"}, "downloads": -1, "filename": "fronts-0.9.7.tar.gz", "has_sig": false, "md5_digest": "a9efcab2a7f5f9d3df88123b6160fc08", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 25297, "upload_time": "2020-02-11T21:03:01", "upload_time_iso_8601": "2020-02-11T21:03:01.002300Z", "url": "https://files.pythonhosted.org/packages/7d/f9/46f157befa26da037830f44e94eb183328583138f666d3371025f2daea39/fronts-0.9.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a9efcab2a7f5f9d3df88123b6160fc08", "sha256": "561e26fba6d3e86b3f4e62732e13bb5fe104765cd792694dad37bd824f334962"}, "downloads": -1, "filename": "fronts-0.9.7.tar.gz", "has_sig": false, "md5_digest": "a9efcab2a7f5f9d3df88123b6160fc08", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7,!=3.0.*,!=3.1.*,!=3.2.*,!=3.3.*,!=3.4.*", "size": 25297, "upload_time": "2020-02-11T21:03:01", "upload_time_iso_8601": "2020-02-11T21:03:01.002300Z", "url": "https://files.pythonhosted.org/packages/7d/f9/46f157befa26da037830f44e94eb183328583138f666d3371025f2daea39/fronts-0.9.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 01:00:09 2020"}