{"info": {"author": "Marcell Vazquez-Chanlatte", "author_email": "marcell.vc@eecs.berkeley.edu", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "# Lazy Tree\n\n[![Build Status](https://cloud.drone.io/api/badges/mvcisback/pyLazyTree/status.svg)](https://cloud.drone.io/mvcisback/pyLazyTree)\n[![codecov](https://codecov.io/gh/mvcisback/DiscreteSignals/branch/master/graph/badge.svg)](https://codecov.io/gh/mvcisback/pyLazyTree)\n[![PyPI version](https://badge.fury.io/py/lazytree.svg)](https://badge.fury.io/py/lazytree)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->\n**Table of Contents**\n\n- [Installation](#installation)\n- [Usage](#usage)\n- [View the current root.](#view-the-current-root)\n\n<!-- markdown-toc end -->\n\n\n# Installation\n\nIf you just need to use `lazytree`, you can just run:\n\n`$ pip install lazytree`\n\nFor developers, note that this project uses the\n[poetry](https://poetry.eustace.io/) python package/dependency\nmanagement tool. Please familarize yourself with it and then\nrun:\n\n`$ poetry install`\n\n# Usage\n\nA `LazyTree` is a triple, `(root, child_map, view)` where `root : A`\nand a child map, `child_map`, which maps `a` to a (finite) list of\nchildren `child_map : A -> List[A]` define the tree's structure and\n`view : A -> B` defines what the tree represents. The default view is\nthe identity map, `lambda x: x`.\n\nThis structure is useful for modeling infinite (or really large) trees\nwhere only a finite number of nodes need to be accessed. For example,\nthe following Binary tree represents the recursive subdivision of the\ninterval [0, 1].\n\n```python\nfrom lazytree import LazyTree\n\ndef split(itvl):\n    lo, hi = itvl\n    mid = lo + (hi - lo)/2\n    return (lo, mid), (mid, hi)\n\ntree = LazyTree(\n    root=(0, 1),  # Initial Itvl\n    child_map=split  # Itvl -> [Itvl]\n)\n```\n\nConceptually a `LazyTree` object can be thought of as containing the pieces of data.\n\n1. The `root` of the tree.\n2. The data represented by the `root`, accessed via the `view` method.\n3. The child subtrees - computed using `child_map` and accessed through the `.children` attribute.\n\nFor example, in our interval example, each node corresponds to an interval of `(0, 1)` and has two child subtrees.\n\n```python\n# View the current root.\nassert tree.view() == tree.root\n\nsubtrees = tree.children\nassert len(subtrees) == 2\n```\n\nOften, for each node in a tree, one is interested in computing a particular function. This can be done using the `map` and `view` methods. For example, below `map` each interval in the tree to it's size. This results in a new `LazyTree` object.\n\n```python\ntree2 = tree.map(lambda itvl: itvl[1] - itvl[0])  # Change view to itvl size.\nassert tree2.view() == 1\n\n# Access the root's subtrees\nsubtrees = tree2.children\nassert len(subtrees) == 2\nassert subtrees[0].root == (0, 0.5)\nassert subtrees[0].view() == 0.5\n```\n\nTravesals of a `LazyTree` object are also implemented. For example,\n\n```python\n# Breadth First Search through tree.\n## Note: calls .view() before returning. \nitvls = tree.bfs()  # returns a generator.\nsizes = tree2.bfs()  # returns a generator.\n\nassert next(itvls) == (0, 1)\nassert next(sizes) == 1\n\nassert next(itvls) == (0, 0.5)\nassert next(sizes) == 0.5\n\nassert next(itvls) == (0.5, 1)\nassert next(sizes) == 0.5\n\n# Cost guided traversal.\n## Note: Smaller means higher priority.\nsizes = tree2.cost_guided_refinement(cost=lambda x: x)\nassert next(sizes)  == 1  # (0, 1)\nassert next(sizes)  == 0.5  # (0, 0.5)\nassert next(sizes)  == 0.25  # (0, 0.25)\n\n# Iterative Deepening Depth First Traversal\nsizes = tree2.iddfs(max_depth=3)  # returns a generator.\nassert list(sizes) == [1, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125]\n\n# Note, you can reset the current view.\ntree3 = tree2.with_identity_view()\nassert tree3.view() == tree.view()\n```\n\nFinally, one can \"prune\" away subtrees by labeling them as leaf nodes using the `prune` method. If you are sure that the resulting tree is finite (either due to pruning or the provided `child_map`) then one can compute the leaves of the tree.\n\n```python\n# Prune subtrees with a root of size less than 0.1.\ntree4 = tree2.prune(isleaf=lambda s: s < 0.2)\nsizes = tree.bfs()\nassert all(s > 0.001 for s in sizes)  # Note that sizes is now finite.\n\n\n\n# Compute leafs of tree. Careful! Could be infinite!\nassert all(s == 0.125 for s in tree4.leaves())\nassert len(list(tree4.leaves())) == 8\n```\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/mvcisback/pyLazyTree", "keywords": "", "license": "MIT", "maintainer": "Marcell Vazquez-Chanlatte", "maintainer_email": "marcell.vc@eecs.berkeley.edu", "name": "lazytree", "package_url": "https://pypi.org/project/lazytree/", "platform": "", "project_url": "https://pypi.org/project/lazytree/", "project_urls": {"Homepage": "https://github.com/mvcisback/pyLazyTree", "Repository": "https://github.com/mvcisback/pyLazyTree"}, "release_url": "https://pypi.org/project/lazytree/0.3.1/", "requires_dist": ["attrs (>=19.1,<20.0)", "funcy (>=1.12,<2.0)"], "requires_python": ">=3.6,<4.0", "summary": "Python library for manipulating infinite trees.", "version": "0.3.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Lazy Tree</h1>\n<p><a href=\"https://cloud.drone.io/mvcisback/pyLazyTree\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9a99529c2819642db12c89e4d9a1d1feb986abd0/68747470733a2f2f636c6f75642e64726f6e652e696f2f6170692f6261646765732f6d766369736261636b2f70794c617a79547265652f7374617475732e737667\"></a>\n<a href=\"https://codecov.io/gh/mvcisback/pyLazyTree\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cb405eed48f5db057dcf29dc0209bc646462cccc/68747470733a2f2f636f6465636f762e696f2f67682f6d766369736261636b2f44697363726574655369676e616c732f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://badge.fury.io/py/lazytree\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f3ba754d0709d9c9cb8280b9e6a5efb8cc4d9172/68747470733a2f2f62616467652e667572792e696f2f70792f6c617a79747265652e737667\"></a>\n<a href=\"https://opensource.org/licenses/MIT\" rel=\"nofollow\"><img alt=\"License: MIT\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8645b002dd7ec1b54275a80574942e7a318e03c6/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d79656c6c6f772e737667\"></a></p>\n\n<p><strong>Table of Contents</strong></p>\n<ul>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#usage\" rel=\"nofollow\">Usage</a></li>\n<li><a href=\"#view-the-current-root\" rel=\"nofollow\">View the current root.</a></li>\n</ul>\n\n<h1>Installation</h1>\n<p>If you just need to use <code>lazytree</code>, you can just run:</p>\n<p><code>$ pip install lazytree</code></p>\n<p>For developers, note that this project uses the\n<a href=\"https://poetry.eustace.io/\" rel=\"nofollow\">poetry</a> python package/dependency\nmanagement tool. Please familarize yourself with it and then\nrun:</p>\n<p><code>$ poetry install</code></p>\n<h1>Usage</h1>\n<p>A <code>LazyTree</code> is a triple, <code>(root, child_map, view)</code> where <code>root : A</code>\nand a child map, <code>child_map</code>, which maps <code>a</code> to a (finite) list of\nchildren <code>child_map : A -&gt; List[A]</code> define the tree's structure and\n<code>view : A -&gt; B</code> defines what the tree represents. The default view is\nthe identity map, <code>lambda x: x</code>.</p>\n<p>This structure is useful for modeling infinite (or really large) trees\nwhere only a finite number of nodes need to be accessed. For example,\nthe following Binary tree represents the recursive subdivision of the\ninterval [0, 1].</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">lazytree</span> <span class=\"kn\">import</span> <span class=\"n\">LazyTree</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">split</span><span class=\"p\">(</span><span class=\"n\">itvl</span><span class=\"p\">):</span>\n    <span class=\"n\">lo</span><span class=\"p\">,</span> <span class=\"n\">hi</span> <span class=\"o\">=</span> <span class=\"n\">itvl</span>\n    <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"n\">lo</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">hi</span> <span class=\"o\">-</span> <span class=\"n\">lo</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"mi\">2</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">lo</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">mid</span><span class=\"p\">,</span> <span class=\"n\">hi</span><span class=\"p\">)</span>\n\n<span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"n\">LazyTree</span><span class=\"p\">(</span>\n    <span class=\"n\">root</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">),</span>  <span class=\"c1\"># Initial Itvl</span>\n    <span class=\"n\">child_map</span><span class=\"o\">=</span><span class=\"n\">split</span>  <span class=\"c1\"># Itvl -&gt; [Itvl]</span>\n<span class=\"p\">)</span>\n</pre>\n<p>Conceptually a <code>LazyTree</code> object can be thought of as containing the pieces of data.</p>\n<ol>\n<li>The <code>root</code> of the tree.</li>\n<li>The data represented by the <code>root</code>, accessed via the <code>view</code> method.</li>\n<li>The child subtrees - computed using <code>child_map</code> and accessed through the <code>.children</code> attribute.</li>\n</ol>\n<p>For example, in our interval example, each node corresponds to an interval of <code>(0, 1)</code> and has two child subtrees.</p>\n<pre><span class=\"c1\"># View the current root.</span>\n<span class=\"k\">assert</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">root</span>\n\n<span class=\"n\">subtrees</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">children</span>\n<span class=\"k\">assert</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">subtrees</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span>\n</pre>\n<p>Often, for each node in a tree, one is interested in computing a particular function. This can be done using the <code>map</code> and <code>view</code> methods. For example, below <code>map</code> each interval in the tree to it's size. This results in a new <code>LazyTree</code> object.</p>\n<pre><span class=\"n\">tree2</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">itvl</span><span class=\"p\">:</span> <span class=\"n\">itvl</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">itvl</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>  <span class=\"c1\"># Change view to itvl size.</span>\n<span class=\"k\">assert</span> <span class=\"n\">tree2</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\"># Access the root's subtrees</span>\n<span class=\"n\">subtrees</span> <span class=\"o\">=</span> <span class=\"n\">tree2</span><span class=\"o\">.</span><span class=\"n\">children</span>\n<span class=\"k\">assert</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">subtrees</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span>\n<span class=\"k\">assert</span> <span class=\"n\">subtrees</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">subtrees</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mf\">0.5</span>\n</pre>\n<p>Travesals of a <code>LazyTree</code> object are also implemented. For example,</p>\n<pre><span class=\"c1\"># Breadth First Search through tree.</span>\n<span class=\"c1\">## Note: calls .view() before returning. </span>\n<span class=\"n\">itvls</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">bfs</span><span class=\"p\">()</span>  <span class=\"c1\"># returns a generator.</span>\n<span class=\"n\">sizes</span> <span class=\"o\">=</span> <span class=\"n\">tree2</span><span class=\"o\">.</span><span class=\"n\">bfs</span><span class=\"p\">()</span>  <span class=\"c1\"># returns a generator.</span>\n\n<span class=\"k\">assert</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">itvls</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">sizes</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>\n\n<span class=\"k\">assert</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">itvls</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">sizes</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mf\">0.5</span>\n\n<span class=\"k\">assert</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">itvls</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">sizes</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mf\">0.5</span>\n\n<span class=\"c1\"># Cost guided traversal.</span>\n<span class=\"c1\">## Note: Smaller means higher priority.</span>\n<span class=\"n\">sizes</span> <span class=\"o\">=</span> <span class=\"n\">tree2</span><span class=\"o\">.</span><span class=\"n\">cost_guided_refinement</span><span class=\"p\">(</span><span class=\"n\">cost</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">sizes</span><span class=\"p\">)</span>  <span class=\"o\">==</span> <span class=\"mi\">1</span>  <span class=\"c1\"># (0, 1)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">sizes</span><span class=\"p\">)</span>  <span class=\"o\">==</span> <span class=\"mf\">0.5</span>  <span class=\"c1\"># (0, 0.5)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">sizes</span><span class=\"p\">)</span>  <span class=\"o\">==</span> <span class=\"mf\">0.25</span>  <span class=\"c1\"># (0, 0.25)</span>\n\n<span class=\"c1\"># Iterative Deepening Depth First Traversal</span>\n<span class=\"n\">sizes</span> <span class=\"o\">=</span> <span class=\"n\">tree2</span><span class=\"o\">.</span><span class=\"n\">iddfs</span><span class=\"p\">(</span><span class=\"n\">max_depth</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># returns a generator.</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">sizes</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.25</span><span class=\"p\">,</span> <span class=\"mf\">0.25</span><span class=\"p\">,</span> <span class=\"mf\">0.25</span><span class=\"p\">,</span> <span class=\"mf\">0.25</span><span class=\"p\">,</span> <span class=\"mf\">0.125</span><span class=\"p\">,</span> <span class=\"mf\">0.125</span><span class=\"p\">,</span> <span class=\"mf\">0.125</span><span class=\"p\">,</span> <span class=\"mf\">0.125</span><span class=\"p\">,</span> <span class=\"mf\">0.125</span><span class=\"p\">,</span> <span class=\"mf\">0.125</span><span class=\"p\">,</span> <span class=\"mf\">0.125</span><span class=\"p\">,</span> <span class=\"mf\">0.125</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Note, you can reset the current view.</span>\n<span class=\"n\">tree3</span> <span class=\"o\">=</span> <span class=\"n\">tree2</span><span class=\"o\">.</span><span class=\"n\">with_identity_view</span><span class=\"p\">()</span>\n<span class=\"k\">assert</span> <span class=\"n\">tree3</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">()</span>\n</pre>\n<p>Finally, one can \"prune\" away subtrees by labeling them as leaf nodes using the <code>prune</code> method. If you are sure that the resulting tree is finite (either due to pruning or the provided <code>child_map</code>) then one can compute the leaves of the tree.</p>\n<pre><span class=\"c1\"># Prune subtrees with a root of size less than 0.1.</span>\n<span class=\"n\">tree4</span> <span class=\"o\">=</span> <span class=\"n\">tree2</span><span class=\"o\">.</span><span class=\"n\">prune</span><span class=\"p\">(</span><span class=\"n\">isleaf</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">s</span> <span class=\"o\">&lt;</span> <span class=\"mf\">0.2</span><span class=\"p\">)</span>\n<span class=\"n\">sizes</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">bfs</span><span class=\"p\">()</span>\n<span class=\"k\">assert</span> <span class=\"nb\">all</span><span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"o\">&gt;</span> <span class=\"mf\">0.001</span> <span class=\"k\">for</span> <span class=\"n\">s</span> <span class=\"ow\">in</span> <span class=\"n\">sizes</span><span class=\"p\">)</span>  <span class=\"c1\"># Note that sizes is now finite.</span>\n\n\n\n<span class=\"c1\"># Compute leafs of tree. Careful! Could be infinite!</span>\n<span class=\"k\">assert</span> <span class=\"nb\">all</span><span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"o\">==</span> <span class=\"mf\">0.125</span> <span class=\"k\">for</span> <span class=\"n\">s</span> <span class=\"ow\">in</span> <span class=\"n\">tree4</span><span class=\"o\">.</span><span class=\"n\">leaves</span><span class=\"p\">())</span>\n<span class=\"k\">assert</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">tree4</span><span class=\"o\">.</span><span class=\"n\">leaves</span><span class=\"p\">()))</span> <span class=\"o\">==</span> <span class=\"mi\">8</span>\n</pre>\n\n          </div>"}, "last_serial": 5591063, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "099b7a5bb67ab16e9ab7a3a71ae3ee21", "sha256": "fda15f399384466876e13472ff128f8a8d5068ceb74a50c50b7cb8ab005b0d7f"}, "downloads": -1, "filename": "lazytree-0.1.0.tar.gz", "has_sig": false, "md5_digest": "099b7a5bb67ab16e9ab7a3a71ae3ee21", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2231, "upload_time": "2018-12-29T23:55:09", "upload_time_iso_8601": "2018-12-29T23:55:09.828398Z", "url": "https://files.pythonhosted.org/packages/27/68/fd285f7df96a983dedeea55f5bcff2b7b9178924d8214e9cb85dc057f875/lazytree-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "8ecf3207f7fcd3bbbdab204be78fea8f", "sha256": "d505091e18591e79f7ca681b5b22d3de0d47512d6f242b1042aa26ae66fed6b3"}, "downloads": -1, "filename": "lazytree-0.2.0.tar.gz", "has_sig": false, "md5_digest": "8ecf3207f7fcd3bbbdab204be78fea8f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3021, "upload_time": "2019-01-14T06:54:57", "upload_time_iso_8601": "2019-01-14T06:54:57.560501Z", "url": "https://files.pythonhosted.org/packages/46/35/abc964606c0bb3a2d384a877fdbd3c865104f874e1c2744a811711106de1/lazytree-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "3382f1fa804ddd1450fe13ba9971339a", "sha256": "ca7b5b5c252883b3bd7216b30c6895ad25d2a4848eadd4448a8ebfa41e22f385"}, "downloads": -1, "filename": "lazytree-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "3382f1fa804ddd1450fe13ba9971339a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 3514, "upload_time": "2019-06-14T03:26:18", "upload_time_iso_8601": "2019-06-14T03:26:18.470933Z", "url": "https://files.pythonhosted.org/packages/01/f2/3e3066f88d4b3cf794fe9fa04dc7fa7b3c1922c9908c1af88c2b8317d28c/lazytree-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "941d78f3d366d4067d6953080c92e156", "sha256": "9f399fa59e164890a1ebb82582062dda15d98ec96a16d915037560b790a87a47"}, "downloads": -1, "filename": "lazytree-0.2.1.tar.gz", "has_sig": false, "md5_digest": "941d78f3d366d4067d6953080c92e156", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 2914, "upload_time": "2019-06-14T03:26:20", "upload_time_iso_8601": "2019-06-14T03:26:20.094022Z", "url": "https://files.pythonhosted.org/packages/f5/83/3eeffcfbcbb2b3d70369aa5c1e75db997b4052cd34998c92140c66c03832/lazytree-0.2.1.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "85d7a99e3593e62eaa25f05977e70383", "sha256": "f04fa548b621da4a440edf4122695298c5fa1c187ac7f8af5399f618b9ff5503"}, "downloads": -1, "filename": "lazytree-0.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "85d7a99e3593e62eaa25f05977e70383", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 3653, "upload_time": "2019-07-04T03:00:41", "upload_time_iso_8601": "2019-07-04T03:00:41.037216Z", "url": "https://files.pythonhosted.org/packages/72/c2/60406816b35b387336e45f51f975de2835b2ca75069d312304c932438af9/lazytree-0.3.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "60c0aecca32f14ab8d1fbafb1eaf2f03", "sha256": "a2cd89293d7256f36788502bf725f278ad5d071e24a0b3b47a36cf6f54193d78"}, "downloads": -1, "filename": "lazytree-0.3.0.tar.gz", "has_sig": false, "md5_digest": "60c0aecca32f14ab8d1fbafb1eaf2f03", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 3033, "upload_time": "2019-07-04T03:00:42", "upload_time_iso_8601": "2019-07-04T03:00:42.418605Z", "url": "https://files.pythonhosted.org/packages/76/2d/c507fe40fcc37ebf56682193c3403a014dd4f4abd6cc595fc387b9fcc53a/lazytree-0.3.0.tar.gz", "yanked": false}], "0.3.1": [{"comment_text": "", "digests": {"md5": "22be8eb285d355a3502f7c0f12039496", "sha256": "9e2d5a237dbb9be3388edb26fc8d0d06ae1d41186ff6a8f362d10befb951e1f4"}, "downloads": -1, "filename": "lazytree-0.3.1-py3-none-any.whl", "has_sig": false, "md5_digest": "22be8eb285d355a3502f7c0f12039496", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 5637, "upload_time": "2019-07-26T22:32:52", "upload_time_iso_8601": "2019-07-26T22:32:52.118288Z", "url": "https://files.pythonhosted.org/packages/92/a6/4a31b2ba1b07314b888beb95959732b7a88ece908fe384404439829a6ebe/lazytree-0.3.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "050de37eea92d421bc47951a2bb22ba3", "sha256": "23096b04eb48743e1e90151c285a604e8281c304c7aaa4abb083c0ccca28fa55"}, "downloads": -1, "filename": "lazytree-0.3.1.tar.gz", "has_sig": false, "md5_digest": "050de37eea92d421bc47951a2bb22ba3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 5508, "upload_time": "2019-07-26T22:32:53", "upload_time_iso_8601": "2019-07-26T22:32:53.642434Z", "url": "https://files.pythonhosted.org/packages/61/88/14f8b6d6690b8f3c0a6ded481a9c1e018458d8a653d211d9c5836b4a1a66/lazytree-0.3.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "22be8eb285d355a3502f7c0f12039496", "sha256": "9e2d5a237dbb9be3388edb26fc8d0d06ae1d41186ff6a8f362d10befb951e1f4"}, "downloads": -1, "filename": "lazytree-0.3.1-py3-none-any.whl", "has_sig": false, "md5_digest": "22be8eb285d355a3502f7c0f12039496", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 5637, "upload_time": "2019-07-26T22:32:52", "upload_time_iso_8601": "2019-07-26T22:32:52.118288Z", "url": "https://files.pythonhosted.org/packages/92/a6/4a31b2ba1b07314b888beb95959732b7a88ece908fe384404439829a6ebe/lazytree-0.3.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "050de37eea92d421bc47951a2bb22ba3", "sha256": "23096b04eb48743e1e90151c285a604e8281c304c7aaa4abb083c0ccca28fa55"}, "downloads": -1, "filename": "lazytree-0.3.1.tar.gz", "has_sig": false, "md5_digest": "050de37eea92d421bc47951a2bb22ba3", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 5508, "upload_time": "2019-07-26T22:32:53", "upload_time_iso_8601": "2019-07-26T22:32:53.642434Z", "url": "https://files.pythonhosted.org/packages/61/88/14f8b6d6690b8f3c0a6ded481a9c1e018458d8a653d211d9c5836b4a1a66/lazytree-0.3.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:47:34 2020"}