{"info": {"author": "Eric Larson", "author_email": "eric@ionrock.org", "bugtrack_url": null, "classifiers": [], "description": "=================================\n MgoQuery (MongoDB Query Parser)\n=================================\n\nA simple query language that returns a valid MongoDB query.\n\nMongoDB provides a flexible query model that is powerful, yet verbose\nat times. MgoQuery provides a simple query langauge to create a\nconcise, search-like syntax for constructing MongoDB queries.\n\nGoals\n-----\n\n 1. Provide a safe and limited interface for querying MongoDB.\n 2. Provide a query language that is URL friendly\n\n\nQuery Syntax\n------------\n\nThe MgoQuery syntax is inspired by tools such as Xapian, Lucene and\nGMail's advance query search.\n\nHere is an example of the basic format: ::\n\n  \"x>3, x<5\" | \"y>10, z:True\"\n\nWhich translates to: ::\n\n  {'$or': [{'$and': [{'x': {'$gte': 3}},\n                     {'x': {'$lte': 5}}]},\n           {'$and': [{'y': {'$gte': 10}},\n                     {'z': True}]}]}\n\n\nSpaces are optional which means the above query could be rewritten as: ::\n\n  \"x>3,x<5\"|\"y>10,z:True\"\n  \"x>3, x<5\" | \"y>10, z:True\"\n\nExpressions\n~~~~~~~~~~~\n\nAn expression defines a single requirement for a single key in a\nMongoDB query. For example ::\n\n  {'x': 1}\n\nAn expression in a MgoQuery is as follows: ::\n\n  $key <-> operator <-> $value\n\nThe operators are as follows:\n\n  equals = \":\"\n  greater than or equal to >= \">\"\n  less than or equal to <= \"<\"\n\nIt should be noted that we only use greater/less than or equal to as\nthe theory is it will be easier for users to understand the value they\nuse will be included in the results.\n\nHere are some examples: ::\n\n  x:3     => {'x': '3'}\n  foo > 4 => {'foo': {'$gte': '4'}}\n  y < x   => {'y': {'$lte': 'x'}}\n\nOne thing to note in the above examples is that the values are all\nstrings. I will explain how to help the parser know when you want to\nuse different types in the parsed output.\n\nExpressions can be combined in order to create more complex\nexpressions. There are two ways to combine expressions, grouping and\ncombination operators.\n\nCombination Operators\n~~~~~~~~~~~~~~~~~~~~~\n\nSimilar to the operators in expressions, combination operators act\nupon two expressions. ::\n\n  expression <-> operator <-> expression\n\nHere are two examples using the two combination operators: ::\n\n  x:1 , y:2 => {'$and': [{'x': '1'}, {'y': '2'}]}\n  x:1 | y:2 => {'$or': [{'x': '1'}, {'y': '2'}]}\n\n\nThe \",\" acts as an AND operator meaning both expressions would need to\nmatch in the document for it to be returned.\n\nThe \"|\" acts as an OR operator such that either expression can match\nin order for the document to be returned.\n\nI should be noted that you may only use combination operator at a\ntime. There is no precendence that takes place in order to clarify\nhow the expression should be applied. For example: ::\n\n  x:1, y:2 | foo:bar\n\nThere is no way for the parser to know whether you intended the 'y:2'\nexpression to be compared first to the 'x:1' with AND or with the\n'foo:bar' using OR.\n\nIt is possible to use different combination operators by using groups.\n\nGroups\n~~~~~~\n\nGroups allow you to use more than one combination operator in a\nquery. Here is the format for a group: ::\n\n  \"expression [<-> operator]\"\n\nQuotes are used to wrap the expressions and the combination operator\nsuch that you can use more than one. Here is a more complex example to\nsee how this works: ::\n\n  \"x>1, x<5\" | \"y>2, x:None\"\n\nIn this example the groups are surrounded in the quotes and use the\nAND operator. Both groups are then used in an OR operation. In english\nthe example would read as:\n\n  Select all documents if:\n    The key 'x' is greater than or equal to 1 AND\n    The key 'x' is less than or equal to 5\n  OR\n    The key 'y' is greater than or equal to 2 AND\n    The key 'x' does not exist or is None.\n\nCurrently groups cannot be nested as we do not have the use case for\nthis complex of queries.\n\n\nUsing the Parser\n================\n\nHere is a small session showing how to use the parser in order to\nconstruct queries: ::\n\n  Python 2.7.1 (r271:86832, Jul 31 2011, 19:30:53)\n  [GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2335.15.00)] on darwin\n  Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n  >>> from pprint import pprint\n  >>> from mgoquery import Parser\n  >>> p = Parser()\n  >>> result = p.parse('x > 5, y < 3')\n  >>> print result\n  {'$and': [{'x': {'$gte': '5'}}, {'y': {'$lte': '3'}}]}\n\nConverting Values in Queries\n----------------------------\n\nAs you can see from the examples, the parser default does not make an\neffort to understand the type of value for each expression. In order\nto convert the value to the correct type you can pass a conversion\nfunction to the Parser constructor.\n\nHere is a simple session using the same example from above: ::\n\n  >>> p = Parser(conversion=lambda key, value: int(value))\n  >>> print(p.parse('x:1, y:2'))\n  {'$and': [{'x': 1}, {'y': 2}]}\n\nThe conversion function should take two arguments, a \"key\" and\n\"value\". The key is the name of the key used by the documents you want\nto query. As MongoDB doesn't support forcing a type on a specific key\nin a collection of documents, we use the name of the key to provide a\nsuggestion as to what type to use.\n\nHere is an example using a potential date parsing function: ::\n\n  from mylibs import parse_date\n  from mgoquery import Parser\n\n  def value_conversion(key, value):\n      if 'date' in key or 'time' in key:\n          return parse_date(value)\n      return value\n\n\n  p = Parser(conversion=value_conversion)\n  print(p.parse('startdate:2012-02-03'))\n  # prints -> {'starttdate': datetime(2012, 2, 3)}\n\nThe return value of the conversion function should be the converted\nvalue. It is also appropriate to validate the input and throw an error\nif it is invalid.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/elarson/mgoquery", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "MgoQuery", "package_url": "https://pypi.org/project/MgoQuery/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/MgoQuery/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://bitbucket.org/elarson/mgoquery"}, "release_url": "https://pypi.org/project/MgoQuery/0.5.5/", "requires_dist": null, "requires_python": null, "summary": "A concise language parser for creating MongoDB queries", "version": "0.5.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>A simple query language that returns a valid MongoDB query.</p>\n<p>MongoDB provides a flexible query model that is powerful, yet verbose\nat times. MgoQuery provides a simple query langauge to create a\nconcise, search-like syntax for constructing MongoDB queries.</p>\n<div id=\"goals\">\n<h2>Goals</h2>\n<blockquote>\n<ol>\n<li>Provide a safe and limited interface for querying MongoDB.</li>\n<li>Provide a query language that is URL friendly</li>\n</ol>\n</blockquote>\n</div>\n<div id=\"query-syntax\">\n<h2>Query Syntax</h2>\n<p>The MgoQuery syntax is inspired by tools such as Xapian, Lucene and\nGMail\u2019s advance query search.</p>\n<p>Here is an example of the basic format:</p>\n<pre>\"x&gt;3, x&lt;5\" | \"y&gt;10, z:True\"\n</pre>\n<p>Which translates to:</p>\n<pre>{'$or': [{'$and': [{'x': {'$gte': 3}},\n                   {'x': {'$lte': 5}}]},\n         {'$and': [{'y': {'$gte': 10}},\n                   {'z': True}]}]}\n</pre>\n<p>Spaces are optional which means the above query could be rewritten as:</p>\n<pre>\"x&gt;3,x&lt;5\"|\"y&gt;10,z:True\"\n\"x&gt;3, x&lt;5\" | \"y&gt;10, z:True\"\n</pre>\n<div id=\"expressions\">\n<h3>Expressions</h3>\n<p>An expression defines a single requirement for a single key in a\nMongoDB query. For example</p>\n<pre>{'x': 1}\n</pre>\n<p>An expression in a MgoQuery is as follows:</p>\n<pre>$key &lt;-&gt; operator &lt;-&gt; $value\n</pre>\n<p>The operators are as follows:</p>\n<blockquote>\nequals = \u201c:\u201d\ngreater than or equal to &gt;= \u201c&gt;\u201d\nless than or equal to &lt;= \u201c&lt;\u201d</blockquote>\n<p>It should be noted that we only use greater/less than or equal to as\nthe theory is it will be easier for users to understand the value they\nuse will be included in the results.</p>\n<p>Here are some examples:</p>\n<pre>x:3     =&gt; {'x': '3'}\nfoo &gt; 4 =&gt; {'foo': {'$gte': '4'}}\ny &lt; x   =&gt; {'y': {'$lte': 'x'}}\n</pre>\n<p>One thing to note in the above examples is that the values are all\nstrings. I will explain how to help the parser know when you want to\nuse different types in the parsed output.</p>\n<p>Expressions can be combined in order to create more complex\nexpressions. There are two ways to combine expressions, grouping and\ncombination operators.</p>\n</div>\n<div id=\"combination-operators\">\n<h3>Combination Operators</h3>\n<p>Similar to the operators in expressions, combination operators act\nupon two expressions.</p>\n<pre>expression &lt;-&gt; operator &lt;-&gt; expression\n</pre>\n<p>Here are two examples using the two combination operators:</p>\n<pre>x:1 , y:2 =&gt; {'$and': [{'x': '1'}, {'y': '2'}]}\nx:1 | y:2 =&gt; {'$or': [{'x': '1'}, {'y': '2'}]}\n</pre>\n<p>The \u201c,\u201d acts as an AND operator meaning both expressions would need to\nmatch in the document for it to be returned.</p>\n<p>The \u201c|\u201d acts as an OR operator such that either expression can match\nin order for the document to be returned.</p>\n<p>I should be noted that you may only use combination operator at a\ntime. There is no precendence that takes place in order to clarify\nhow the expression should be applied. For example:</p>\n<pre>x:1, y:2 | foo:bar\n</pre>\n<p>There is no way for the parser to know whether you intended the \u2018y:2\u2019\nexpression to be compared first to the \u2018x:1\u2019 with AND or with the\n\u2018foo:bar\u2019 using OR.</p>\n<p>It is possible to use different combination operators by using groups.</p>\n</div>\n<div id=\"groups\">\n<h3>Groups</h3>\n<p>Groups allow you to use more than one combination operator in a\nquery. Here is the format for a group:</p>\n<pre>\"expression [&lt;-&gt; operator]\"\n</pre>\n<p>Quotes are used to wrap the expressions and the combination operator\nsuch that you can use more than one. Here is a more complex example to\nsee how this works:</p>\n<pre>\"x&gt;1, x&lt;5\" | \"y&gt;2, x:None\"\n</pre>\n<p>In this example the groups are surrounded in the quotes and use the\nAND operator. Both groups are then used in an OR operation. In english\nthe example would read as:</p>\n<blockquote>\n<dl>\n<dt>Select all documents if:</dt>\n<dd>The key \u2018x\u2019 is greater than or equal to 1 AND\nThe key \u2018x\u2019 is less than or equal to 5</dd>\n<dt>OR</dt>\n<dd>The key \u2018y\u2019 is greater than or equal to 2 AND\nThe key \u2018x\u2019 does not exist or is None.</dd>\n</dl>\n</blockquote>\n<p>Currently groups cannot be nested as we do not have the use case for\nthis complex of queries.</p>\n<div id=\"using-the-parser\">\n<h4>Using the Parser</h4>\n<p>Here is a small session showing how to use the parser in order to\nconstruct queries:</p>\n<pre>Python 2.7.1 (r271:86832, Jul 31 2011, 19:30:53)\n[GCC 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2335.15.00)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; from mgoquery import Parser\n&gt;&gt;&gt; p = Parser()\n&gt;&gt;&gt; result = p.parse('x &gt; 5, y &lt; 3')\n&gt;&gt;&gt; print result\n{'$and': [{'x': {'$gte': '5'}}, {'y': {'$lte': '3'}}]}\n</pre>\n</div>\n</div>\n</div>\n<div id=\"converting-values-in-queries\">\n<h2>Converting Values in Queries</h2>\n<p>As you can see from the examples, the parser default does not make an\neffort to understand the type of value for each expression. In order\nto convert the value to the correct type you can pass a conversion\nfunction to the Parser constructor.</p>\n<p>Here is a simple session using the same example from above:</p>\n<pre>&gt;&gt;&gt; p = Parser(conversion=lambda key, value: int(value))\n&gt;&gt;&gt; print(p.parse('x:1, y:2'))\n{'$and': [{'x': 1}, {'y': 2}]}\n</pre>\n<p>The conversion function should take two arguments, a \u201ckey\u201d and\n\u201cvalue\u201d. The key is the name of the key used by the documents you want\nto query. As MongoDB doesn\u2019t support forcing a type on a specific key\nin a collection of documents, we use the name of the key to provide a\nsuggestion as to what type to use.</p>\n<p>Here is an example using a potential date parsing function:</p>\n<pre>from mylibs import parse_date\nfrom mgoquery import Parser\n\ndef value_conversion(key, value):\n    if 'date' in key or 'time' in key:\n        return parse_date(value)\n    return value\n\n\np = Parser(conversion=value_conversion)\nprint(p.parse('startdate:2012-02-03'))\n# prints -&gt; {'starttdate': datetime(2012, 2, 3)}\n</pre>\n<p>The return value of the conversion function should be the converted\nvalue. It is also appropriate to validate the input and throw an error\nif it is invalid.</p>\n</div>\n\n          </div>"}, "last_serial": 2607540, "releases": {"0.5.2": [], "0.5.3": [{"comment_text": "", "digests": {"md5": "8e3ddb4f8eaee62c2c89893f7a4ba8bb", "sha256": "86e476c70156fbf0e1ccc85f29bbd2576b7de8694cfe5ad43597ffe764623b45"}, "downloads": -1, "filename": "MgoQuery-0.5.3.tar.gz", "has_sig": false, "md5_digest": "8e3ddb4f8eaee62c2c89893f7a4ba8bb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6199, "upload_time": "2013-09-12T01:55:03", "upload_time_iso_8601": "2013-09-12T01:55:03.454772Z", "url": "https://files.pythonhosted.org/packages/26/49/6d2eb7e4f78a449c00f11b6f493e793a116f7671e9ac5c76a0eca4995d27/MgoQuery-0.5.3.tar.gz", "yanked": false}], "0.5.4": [{"comment_text": "", "digests": {"md5": "03f6151e51c6a6b355d37cf2475a337b", "sha256": "1c67e19f84fa26444358f4296fc38f03b4f88e7aa02dafb56ab715779d0de673"}, "downloads": -1, "filename": "MgoQuery-0.5.4.tar.gz", "has_sig": false, "md5_digest": "03f6151e51c6a6b355d37cf2475a337b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6230, "upload_time": "2013-09-12T02:02:33", "upload_time_iso_8601": "2013-09-12T02:02:33.954795Z", "url": "https://files.pythonhosted.org/packages/80/6b/46ffbeba9db7acdb883f65fe45c6edb8e221e839e804e8e99ea3574183fe/MgoQuery-0.5.4.tar.gz", "yanked": false}], "0.5.5": [{"comment_text": "", "digests": {"md5": "f7282e02abcea3fbcb5226144713c704", "sha256": "77fba749a1d1179aba361b156cd5cca23b433fab6f903698091f9db7171bbc73"}, "downloads": -1, "filename": "MgoQuery-0.5.5.tar.gz", "has_sig": false, "md5_digest": "f7282e02abcea3fbcb5226144713c704", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4906, "upload_time": "2017-01-30T20:32:18", "upload_time_iso_8601": "2017-01-30T20:32:18.691444Z", "url": "https://files.pythonhosted.org/packages/ee/10/8e43578b14a18221e13f8488d4be779fa8b0cf329c247d38f23aef8cbdc4/MgoQuery-0.5.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f7282e02abcea3fbcb5226144713c704", "sha256": "77fba749a1d1179aba361b156cd5cca23b433fab6f903698091f9db7171bbc73"}, "downloads": -1, "filename": "MgoQuery-0.5.5.tar.gz", "has_sig": false, "md5_digest": "f7282e02abcea3fbcb5226144713c704", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4906, "upload_time": "2017-01-30T20:32:18", "upload_time_iso_8601": "2017-01-30T20:32:18.691444Z", "url": "https://files.pythonhosted.org/packages/ee/10/8e43578b14a18221e13f8488d4be779fa8b0cf329c247d38f23aef8cbdc4/MgoQuery-0.5.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:55:27 2020"}