{"info": {"author": "G.Launay", "author_email": "pitooon@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering :: Bio-Informatics", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# A Python package and C Library for fast molecular contact map computation\n\n[Current Version 2.1.3](https://pypi.org/project/ccmap/)\n\nThis package was designed as a tool to quickly compute thousands of sets of atomic or residue molecular contacts. The contacts can be evaluated inside a single body or across two bodies. The library scales well, with the support of the native python multithreading.\nThe module also provides docking poses evaluation by the application of triplets of Euler angles and translation vectors to initial unbound conformations.\n\n## Installing and using the python module\n\n### Installation\n\nShould be as simple as `pip intstall ccmap`. Alternatively you can clone this repo and run `python setup.py install` at the root folder.\nCurrent release was successfully installed through pip on the following combinations of interpreter/platforms.\n\n* python3.8/OSX.10.14.6\n* python3.8/Ubuntu LTS\n\n### Usage\n\nFrom there you can load the package and display its help.\n\n```python\nimport ccmap\nhelp(ccmap)\n```\n\n#### Functions\n\nFour functions are available:\n\n* cmap: computes the contacts of one single/two body molecule\n* lcmap: computes the contacts of a list of single/two body molecules\n* zmap: computes the contacts between a receptor and a ligand molecule after applying transformations to the ligand coordinates\n* lzmap: computes many sets of contacts between a receptor and a ligand molecule, one for each applied ligand transformation\n\n#### Parameters\n\nAll module functions take molecular object coordinates as dictionaries, where keys are atoms descriptors and values are lists.\n\n* 'x' : list of float x coordinates\n* 'y' : list of float x coordinates\n* 'y' : list of float x coordinates\n* 'seqRes' : list of strings\n* 'chainID' : list of one-letter string\n* 'resName' : list of strings\n* 'name' : list of strings\n\n#### Additional arguments\n\n##### Contact threshold distance\n\nIn Angstrom's unit, its default value is 4.5. It can be redefined by the name parameter `d`.\n\n##### encode : Boolean\n\nIf True, contacts are returned as integers. Each integer encoding one pair of atoms/residues positions in contact with this simple formula,\n\n```python\ndef K2IJ(k, sizeBody1, sizeBody2):\n    nCol = sizeBody2 if sizeBody2 else sizeBody1\n    return int(k/nCol), k%nCol\n```\n\nif False, contacts are returned as strings of JSON Objects\n\n##### atomic : Boolean\n\nIf True, compute contact at the atomic level. By default, this if False and the contacts are computed at the residue level.\n\n##### apply : Boolean\n\nIf True, the past dictionaries of coordinates will be modified according to Euler/translation parameters.\nThis is useful to generate single docking conformation.\nThis argument is only available for the **cmap** function.\n\n##### offsetRec and offsetLig\n\nWhen working with protein docking data, unbound conformations are often centered to the origin of the coordinates system. Specify the translation vectors for each body with the `offsetRec` and `offsetLig` named arguments. Only available for the **zmap** and **lzmap** functions.\n\n### Working with PDB coordinates files\n\n#### Parsing coordinate data\n\nWe usually work with molecules in the PDB format. We can use the [pyproteinsExt](https://pypi.org/search/?q=pyproteinsExt) package to handle the boilerplate. \n\n```python\nimport pyproteinsExt\nparser = PDB.Parser()\npdbREC = parser.load(file=\"dummy_A.pdb\")\npdbDictREC = pdbREC.atomDictorize\npdbDictREC.keys()\n#dict_keys(['x', 'y', 'z', 'seqRes', 'chainID', 'resName', 'name']) ```\n```\n\nBy convention, following examples will use two molecules names REC(eptor) and LIG(and).\n\n```python\npdbLIG = parser.load(file=\"dummy_B.pdb\")\npdbDictLIG = pdbLIG.atomDictorize\npdbDictLIG.keys()\n#dict_keys(['x', 'y', 'z', 'seqRes', 'chainID', 'resName', 'name']) ```\n```\n\n## Examples\n\n### Computing single body contact map\n\n#### Computing one map\n\nSetting contact distance of 6.0 and recovering residue-residue contact as an integer list.\n\n```python\nccmap.cmap(pdbDictLIG, d=6.0, encode=True)\n```\n\n#### Computing many maps\n\nUsing default contact distance and recovering atomic contact maps as JSON object string. The first positional argument specifies a list of bodies to process independently. \n\n```python\nimport json\njson.load( ccmap.lcmap([ pdbDictLIG, pdbDictREC ], atomic=True) )\n```\n\n### Computing two-body contact map\n\n#### Straight computation of one map\n\nThe second positional argument of **cmap** is optional and defines the second body.\n\n```python\nccmap.cmap(pdbDictLIG, pdbDictLIG, d=6.0, encode=True)\n```\n\n#### Straight computation of many maps\n\nThe second positional argument of **lcmap** is an optional list of second bodies. The first two arguments must be of the same size, as the *i*-element of the first will be processed with the *i*-element of the second.\n\n```python\nccmap.lcmap([pdbDictREC_1, ..., pdbDictREC_n], [pdbDictLIG_1, pdbDictLIG_n], d=6.0, encode=True)\n```\n\n#### Computation of one map after conformational change\n\nUse the **zmap** function with third and fourth positional arguments respectively specifying the :\n\n* Euler angles triplet\n* translation vector\n\n```python\nccmap.zmap(pdbDictREC, pdbDictLIG , (e1, e2, e3), (t1, t2, t3) )\n```\n\nTransformations are always applied to the coordinates provided as a second argument, e.g. : `pdbDictLIG`.\n\n#### Computation of many maps after conformational changes\n\nUse the **lzmap** function, arguments are similar but for the Euler angles and translation vectors which must be supplied as lists.\n\n```python\nccmap.lzmap(pdbDictREC, pdbDictLIG , [(e1, e2, e3),], [(t1, t2, t3),] )\n```\n\n### Generating docking conformations\n\nThe conformations obtained by coordinate transformation can be back mapped to PDB files.\nHere, offset vectors `[u1, u2, u3]` and `[v1, v2, v3]` respectively center `pdbDictREC` and `pdbDictLIG` and one transformation defined by the `[e1, e2, e3]` Euler's angles and the `[t1, t2, t3]` translation vector is applied to `pdbDictLIG`. The resulting two-body conformation is finally **applied** to the provided `pdbDictREC` and `pdbDictLIG`. These updated coordinates update the original PDB object for later writing to file.\n\n```python\n# Perform computation & alter provided dictionaries\nccmap.zmap( pdbDictREC, pdbDictLIG,\n\\ [e1, e2, e3], [t1, t2, t3],\n\\ offsetRec=[u1, u2, u3],\n\\ offsetLig=[v1, v2, v3],\n\\ apply=True)\n# Update PDB containers from previous examples\npdbREC.setCoordinateFromDictorize(pdbDictREC)\npdbLIG.setCoordinateFromDictorize(pdbDictLIG)\n# Dump to coordinate files\nwith open(\"new_receptor.pdb\", \"w\") as fp:\n    fp.write( str(pdbREC) )\nwith open(\"new_ligand.pdb\", \"w\") as fp:\n    fp.write( str(pdbLIG) )\n```\n\n## Multithreading\n\nThe C implementation makes it possible for the ccmap functions to release Python Global Interpreter Lock. Hence, \"actual\" multithreading can be achieved and performances scale decently with the number of workers. For this benchmark, up to 50000 docking poses were generated and processed for three coordinate sets of increasing number of atoms: 1974([1GL1](https://www.rcsb.org/structure/1GL1)) 3424([1F34](https://www.rcsb.org/structure/1F34)) 10677([2VIS](https://www.rcsb.org/structure/2VIS)).\n\n<figure> <img src=\"notebook/img/LZMAP_benchmark_1.png\" alt=\"benchmark\" /> </figure>\n\nA simple example of a multithread implementation can be found in the provided [script](tests/scripts/threadsTest.py). The `tests` folder allows for the reproduction of the above benchmark.\n\n## Installing and using the C Library\n\nC executable can be generated with the provided makefile. The low-level functions are the same, but the following limitations exist:\n\n* One computation per executable call\n* No multithreading.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/MMSB-MOBI/ccmap", "keywords": "protein docking bioinformatics structure", "license": "", "maintainer": "", "maintainer_email": "", "name": "ccmap", "package_url": "https://pypi.org/project/ccmap/", "platform": "", "project_url": "https://pypi.org/project/ccmap/", "project_urls": {"Homepage": "https://github.com/MMSB-MOBI/ccmap"}, "release_url": "https://pypi.org/project/ccmap/2.1.3/", "requires_dist": null, "requires_python": "", "summary": "A C implementation of a mesh based atomic pairwise distance computating engine, with docking pose generation capabilities", "version": "2.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>A Python package and C Library for fast molecular contact map computation</h1>\n<p><a href=\"https://pypi.org/project/ccmap/\" rel=\"nofollow\">Current Version 2.1.3</a></p>\n<p>This package was designed as a tool to quickly compute thousands of sets of atomic or residue molecular contacts. The contacts can be evaluated inside a single body or across two bodies. The library scales well, with the support of the native python multithreading.\nThe module also provides docking poses evaluation by the application of triplets of Euler angles and translation vectors to initial unbound conformations.</p>\n<h2>Installing and using the python module</h2>\n<h3>Installation</h3>\n<p>Should be as simple as <code>pip intstall ccmap</code>. Alternatively you can clone this repo and run <code>python setup.py install</code> at the root folder.\nCurrent release was successfully installed through pip on the following combinations of interpreter/platforms.</p>\n<ul>\n<li>python3.8/OSX.10.14.6</li>\n<li>python3.8/Ubuntu LTS</li>\n</ul>\n<h3>Usage</h3>\n<p>From there you can load the package and display its help.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">ccmap</span>\n<span class=\"n\">help</span><span class=\"p\">(</span><span class=\"n\">ccmap</span><span class=\"p\">)</span>\n</pre>\n<h4>Functions</h4>\n<p>Four functions are available:</p>\n<ul>\n<li>cmap: computes the contacts of one single/two body molecule</li>\n<li>lcmap: computes the contacts of a list of single/two body molecules</li>\n<li>zmap: computes the contacts between a receptor and a ligand molecule after applying transformations to the ligand coordinates</li>\n<li>lzmap: computes many sets of contacts between a receptor and a ligand molecule, one for each applied ligand transformation</li>\n</ul>\n<h4>Parameters</h4>\n<p>All module functions take molecular object coordinates as dictionaries, where keys are atoms descriptors and values are lists.</p>\n<ul>\n<li>'x' : list of float x coordinates</li>\n<li>'y' : list of float x coordinates</li>\n<li>'y' : list of float x coordinates</li>\n<li>'seqRes' : list of strings</li>\n<li>'chainID' : list of one-letter string</li>\n<li>'resName' : list of strings</li>\n<li>'name' : list of strings</li>\n</ul>\n<h4>Additional arguments</h4>\n<h5>Contact threshold distance</h5>\n<p>In Angstrom's unit, its default value is 4.5. It can be redefined by the name parameter <code>d</code>.</p>\n<h5>encode : Boolean</h5>\n<p>If True, contacts are returned as integers. Each integer encoding one pair of atoms/residues positions in contact with this simple formula,</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">K2IJ</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">sizeBody1</span><span class=\"p\">,</span> <span class=\"n\">sizeBody2</span><span class=\"p\">):</span>\n    <span class=\"n\">nCol</span> <span class=\"o\">=</span> <span class=\"n\">sizeBody2</span> <span class=\"k\">if</span> <span class=\"n\">sizeBody2</span> <span class=\"k\">else</span> <span class=\"n\">sizeBody1</span>\n    <span class=\"k\">return</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"o\">/</span><span class=\"n\">nCol</span><span class=\"p\">),</span> <span class=\"n\">k</span><span class=\"o\">%</span><span class=\"n\">nCol</span>\n</pre>\n<p>if False, contacts are returned as strings of JSON Objects</p>\n<h5>atomic : Boolean</h5>\n<p>If True, compute contact at the atomic level. By default, this if False and the contacts are computed at the residue level.</p>\n<h5>apply : Boolean</h5>\n<p>If True, the past dictionaries of coordinates will be modified according to Euler/translation parameters.\nThis is useful to generate single docking conformation.\nThis argument is only available for the <strong>cmap</strong> function.</p>\n<h5>offsetRec and offsetLig</h5>\n<p>When working with protein docking data, unbound conformations are often centered to the origin of the coordinates system. Specify the translation vectors for each body with the <code>offsetRec</code> and <code>offsetLig</code> named arguments. Only available for the <strong>zmap</strong> and <strong>lzmap</strong> functions.</p>\n<h3>Working with PDB coordinates files</h3>\n<h4>Parsing coordinate data</h4>\n<p>We usually work with molecules in the PDB format. We can use the <a href=\"https://pypi.org/search/?q=pyproteinsExt\" rel=\"nofollow\">pyproteinsExt</a> package to handle the boilerplate.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pyproteinsExt</span>\n<span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">PDB</span><span class=\"o\">.</span><span class=\"n\">Parser</span><span class=\"p\">()</span>\n<span class=\"n\">pdbREC</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"o\">=</span><span class=\"s2\">\"dummy_A.pdb\"</span><span class=\"p\">)</span>\n<span class=\"n\">pdbDictREC</span> <span class=\"o\">=</span> <span class=\"n\">pdbREC</span><span class=\"o\">.</span><span class=\"n\">atomDictorize</span>\n<span class=\"n\">pdbDictREC</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">()</span>\n<span class=\"c1\">#dict_keys(['x', 'y', 'z', 'seqRes', 'chainID', 'resName', 'name']) ```</span>\n</pre>\n<p>By convention, following examples will use two molecules names REC(eptor) and LIG(and).</p>\n<pre><span class=\"n\">pdbLIG</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"o\">=</span><span class=\"s2\">\"dummy_B.pdb\"</span><span class=\"p\">)</span>\n<span class=\"n\">pdbDictLIG</span> <span class=\"o\">=</span> <span class=\"n\">pdbLIG</span><span class=\"o\">.</span><span class=\"n\">atomDictorize</span>\n<span class=\"n\">pdbDictLIG</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">()</span>\n<span class=\"c1\">#dict_keys(['x', 'y', 'z', 'seqRes', 'chainID', 'resName', 'name']) ```</span>\n</pre>\n<h2>Examples</h2>\n<h3>Computing single body contact map</h3>\n<h4>Computing one map</h4>\n<p>Setting contact distance of 6.0 and recovering residue-residue contact as an integer list.</p>\n<pre><span class=\"n\">ccmap</span><span class=\"o\">.</span><span class=\"n\">cmap</span><span class=\"p\">(</span><span class=\"n\">pdbDictLIG</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">=</span><span class=\"mf\">6.0</span><span class=\"p\">,</span> <span class=\"n\">encode</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<h4>Computing many maps</h4>\n<p>Using default contact distance and recovering atomic contact maps as JSON object string. The first positional argument specifies a list of bodies to process independently.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">json</span>\n<span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span> <span class=\"n\">ccmap</span><span class=\"o\">.</span><span class=\"n\">lcmap</span><span class=\"p\">([</span> <span class=\"n\">pdbDictLIG</span><span class=\"p\">,</span> <span class=\"n\">pdbDictREC</span> <span class=\"p\">],</span> <span class=\"n\">atomic</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"p\">)</span>\n</pre>\n<h3>Computing two-body contact map</h3>\n<h4>Straight computation of one map</h4>\n<p>The second positional argument of <strong>cmap</strong> is optional and defines the second body.</p>\n<pre><span class=\"n\">ccmap</span><span class=\"o\">.</span><span class=\"n\">cmap</span><span class=\"p\">(</span><span class=\"n\">pdbDictLIG</span><span class=\"p\">,</span> <span class=\"n\">pdbDictLIG</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"o\">=</span><span class=\"mf\">6.0</span><span class=\"p\">,</span> <span class=\"n\">encode</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<h4>Straight computation of many maps</h4>\n<p>The second positional argument of <strong>lcmap</strong> is an optional list of second bodies. The first two arguments must be of the same size, as the <em>i</em>-element of the first will be processed with the <em>i</em>-element of the second.</p>\n<pre><span class=\"n\">ccmap</span><span class=\"o\">.</span><span class=\"n\">lcmap</span><span class=\"p\">([</span><span class=\"n\">pdbDictREC_1</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">pdbDictREC_n</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"n\">pdbDictLIG_1</span><span class=\"p\">,</span> <span class=\"n\">pdbDictLIG_n</span><span class=\"p\">],</span> <span class=\"n\">d</span><span class=\"o\">=</span><span class=\"mf\">6.0</span><span class=\"p\">,</span> <span class=\"n\">encode</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<h4>Computation of one map after conformational change</h4>\n<p>Use the <strong>zmap</strong> function with third and fourth positional arguments respectively specifying the :</p>\n<ul>\n<li>Euler angles triplet</li>\n<li>translation vector</li>\n</ul>\n<pre><span class=\"n\">ccmap</span><span class=\"o\">.</span><span class=\"n\">zmap</span><span class=\"p\">(</span><span class=\"n\">pdbDictREC</span><span class=\"p\">,</span> <span class=\"n\">pdbDictLIG</span> <span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">e1</span><span class=\"p\">,</span> <span class=\"n\">e2</span><span class=\"p\">,</span> <span class=\"n\">e3</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">t1</span><span class=\"p\">,</span> <span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"n\">t3</span><span class=\"p\">)</span> <span class=\"p\">)</span>\n</pre>\n<p>Transformations are always applied to the coordinates provided as a second argument, e.g. : <code>pdbDictLIG</code>.</p>\n<h4>Computation of many maps after conformational changes</h4>\n<p>Use the <strong>lzmap</strong> function, arguments are similar but for the Euler angles and translation vectors which must be supplied as lists.</p>\n<pre><span class=\"n\">ccmap</span><span class=\"o\">.</span><span class=\"n\">lzmap</span><span class=\"p\">(</span><span class=\"n\">pdbDictREC</span><span class=\"p\">,</span> <span class=\"n\">pdbDictLIG</span> <span class=\"p\">,</span> <span class=\"p\">[(</span><span class=\"n\">e1</span><span class=\"p\">,</span> <span class=\"n\">e2</span><span class=\"p\">,</span> <span class=\"n\">e3</span><span class=\"p\">),],</span> <span class=\"p\">[(</span><span class=\"n\">t1</span><span class=\"p\">,</span> <span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"n\">t3</span><span class=\"p\">),]</span> <span class=\"p\">)</span>\n</pre>\n<h3>Generating docking conformations</h3>\n<p>The conformations obtained by coordinate transformation can be back mapped to PDB files.\nHere, offset vectors <code>[u1, u2, u3]</code> and <code>[v1, v2, v3]</code> respectively center <code>pdbDictREC</code> and <code>pdbDictLIG</code> and one transformation defined by the <code>[e1, e2, e3]</code> Euler's angles and the <code>[t1, t2, t3]</code> translation vector is applied to <code>pdbDictLIG</code>. The resulting two-body conformation is finally <strong>applied</strong> to the provided <code>pdbDictREC</code> and <code>pdbDictLIG</code>. These updated coordinates update the original PDB object for later writing to file.</p>\n<pre><span class=\"c1\"># Perform computation &amp; alter provided dictionaries</span>\n<span class=\"n\">ccmap</span><span class=\"o\">.</span><span class=\"n\">zmap</span><span class=\"p\">(</span> <span class=\"n\">pdbDictREC</span><span class=\"p\">,</span> <span class=\"n\">pdbDictLIG</span><span class=\"p\">,</span>\n\\ <span class=\"p\">[</span><span class=\"n\">e1</span><span class=\"p\">,</span> <span class=\"n\">e2</span><span class=\"p\">,</span> <span class=\"n\">e3</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"n\">t1</span><span class=\"p\">,</span> <span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"n\">t3</span><span class=\"p\">],</span>\n\\ <span class=\"n\">offsetRec</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">u1</span><span class=\"p\">,</span> <span class=\"n\">u2</span><span class=\"p\">,</span> <span class=\"n\">u3</span><span class=\"p\">],</span>\n\\ <span class=\"n\">offsetLig</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"n\">v1</span><span class=\"p\">,</span> <span class=\"n\">v2</span><span class=\"p\">,</span> <span class=\"n\">v3</span><span class=\"p\">],</span>\n\\ <span class=\"n\">apply</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"c1\"># Update PDB containers from previous examples</span>\n<span class=\"n\">pdbREC</span><span class=\"o\">.</span><span class=\"n\">setCoordinateFromDictorize</span><span class=\"p\">(</span><span class=\"n\">pdbDictREC</span><span class=\"p\">)</span>\n<span class=\"n\">pdbLIG</span><span class=\"o\">.</span><span class=\"n\">setCoordinateFromDictorize</span><span class=\"p\">(</span><span class=\"n\">pdbDictLIG</span><span class=\"p\">)</span>\n<span class=\"c1\"># Dump to coordinate files</span>\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"new_receptor.pdb\"</span><span class=\"p\">,</span> <span class=\"s2\">\"w\"</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">fp</span><span class=\"p\">:</span>\n    <span class=\"n\">fp</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">pdbREC</span><span class=\"p\">)</span> <span class=\"p\">)</span>\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"new_ligand.pdb\"</span><span class=\"p\">,</span> <span class=\"s2\">\"w\"</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">fp</span><span class=\"p\">:</span>\n    <span class=\"n\">fp</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">pdbLIG</span><span class=\"p\">)</span> <span class=\"p\">)</span>\n</pre>\n<h2>Multithreading</h2>\n<p>The C implementation makes it possible for the ccmap functions to release Python Global Interpreter Lock. Hence, \"actual\" multithreading can be achieved and performances scale decently with the number of workers. For this benchmark, up to 50000 docking poses were generated and processed for three coordinate sets of increasing number of atoms: 1974(<a href=\"https://www.rcsb.org/structure/1GL1\" rel=\"nofollow\">1GL1</a>) 3424(<a href=\"https://www.rcsb.org/structure/1F34\" rel=\"nofollow\">1F34</a>) 10677(<a href=\"https://www.rcsb.org/structure/2VIS\" rel=\"nofollow\">2VIS</a>).</p>\n&lt;figure&gt; <img alt=\"benchmark\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/594203dfaad11c5f29a03f2c8d9333fbb3feecb9/6e6f7465626f6f6b2f696d672f4c5a4d41505f62656e63686d61726b5f312e706e67\"> &lt;/figure&gt;\n<p>A simple example of a multithread implementation can be found in the provided <a href=\"tests/scripts/threadsTest.py\" rel=\"nofollow\">script</a>. The <code>tests</code> folder allows for the reproduction of the above benchmark.</p>\n<h2>Installing and using the C Library</h2>\n<p>C executable can be generated with the provided makefile. The low-level functions are the same, but the following limitations exist:</p>\n<ul>\n<li>One computation per executable call</li>\n<li>No multithreading.</li>\n</ul>\n\n          </div>"}, "last_serial": 6984391, "releases": {"2.0": [{"comment_text": "", "digests": {"md5": "9b82ed6eff894bbfa30fb77c52fe4b7c", "sha256": "22afc0098fb95320cf7baf1a51699113d28fe9e4e2d1a31df6bc69051b9959aa"}, "downloads": -1, "filename": "ccmap-2.0.tar.gz", "has_sig": false, "md5_digest": "9b82ed6eff894bbfa30fb77c52fe4b7c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28722, "upload_time": "2020-04-07T16:03:32", "upload_time_iso_8601": "2020-04-07T16:03:32.748244Z", "url": "https://files.pythonhosted.org/packages/34/48/a889b9b6f1059efabf188126716e9ce9cf9f892e85f75d552e94725c92d4/ccmap-2.0.tar.gz", "yanked": false}], "2.1": [{"comment_text": "", "digests": {"md5": "cfe3726fe7a9ad412ee3010054933b28", "sha256": "ed89d35a6ea220848ceb3f80f5b0b6414fa3f23d5ee67d56db8d8c5db335d868"}, "downloads": -1, "filename": "ccmap-2.1.tar.gz", "has_sig": false, "md5_digest": "cfe3726fe7a9ad412ee3010054933b28", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28795, "upload_time": "2020-04-08T18:59:43", "upload_time_iso_8601": "2020-04-08T18:59:43.916963Z", "url": "https://files.pythonhosted.org/packages/b6/0c/676c6f7cf8e217a4c3d07e5a20f93c035e7ba5f3ccd7a8e88ea72a38f361/ccmap-2.1.tar.gz", "yanked": false}], "2.1.1": [{"comment_text": "", "digests": {"md5": "1a97e876b6118d038806be8b4134bf6b", "sha256": "848c2dbb223e1e14d21bcaad1a1bf779e0e1fc86a4edf1f617d6f8d56bfa5642"}, "downloads": -1, "filename": "ccmap-2.1.1.tar.gz", "has_sig": false, "md5_digest": "1a97e876b6118d038806be8b4134bf6b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34736, "upload_time": "2020-04-09T07:44:08", "upload_time_iso_8601": "2020-04-09T07:44:08.357100Z", "url": "https://files.pythonhosted.org/packages/63/23/4025feb2819b557c7b51510739a81cced3b65f001ed3d5767d6241c2f670/ccmap-2.1.1.tar.gz", "yanked": false}], "2.1.2": [{"comment_text": "", "digests": {"md5": "cbd641b0b560eabd0523de8f5a7168d1", "sha256": "187ff129c0305cd05a5d57ad6efea7218e19bdc4cdd7977ad650b255c42f3de1"}, "downloads": -1, "filename": "ccmap-2.1.2.tar.gz", "has_sig": false, "md5_digest": "cbd641b0b560eabd0523de8f5a7168d1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35179, "upload_time": "2020-04-09T08:00:50", "upload_time_iso_8601": "2020-04-09T08:00:50.031265Z", "url": "https://files.pythonhosted.org/packages/7b/c8/6a11fdcc26a5c6620e18e4e8681a7ba9f207b8c5341ff710c231f1b5dd9b/ccmap-2.1.2.tar.gz", "yanked": false}], "2.1.3": [{"comment_text": "", "digests": {"md5": "08f2ab04d919e2d4366d17515d56f553", "sha256": "1f6df950e98398bde982c606a6d9ed765260bed43c8e8b9339294f3db56dfabc"}, "downloads": -1, "filename": "ccmap-2.1.3.tar.gz", "has_sig": false, "md5_digest": "08f2ab04d919e2d4366d17515d56f553", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35477, "upload_time": "2020-04-09T08:57:12", "upload_time_iso_8601": "2020-04-09T08:57:12.434109Z", "url": "https://files.pythonhosted.org/packages/a9/08/bda218b11beb5be95aadaf1aa84cf016cdafdaa658318c79739fd600e4d0/ccmap-2.1.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "08f2ab04d919e2d4366d17515d56f553", "sha256": "1f6df950e98398bde982c606a6d9ed765260bed43c8e8b9339294f3db56dfabc"}, "downloads": -1, "filename": "ccmap-2.1.3.tar.gz", "has_sig": false, "md5_digest": "08f2ab04d919e2d4366d17515d56f553", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35477, "upload_time": "2020-04-09T08:57:12", "upload_time_iso_8601": "2020-04-09T08:57:12.434109Z", "url": "https://files.pythonhosted.org/packages/a9/08/bda218b11beb5be95aadaf1aa84cf016cdafdaa658318c79739fd600e4d0/ccmap-2.1.3.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:35:06 2020"}