{"info": {"author": "Brian Carlsen", "author_email": "carlsen.bri@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# Easy Biologic\nA library allowing easy control over BioLogic devices.\nHigh and low level control over Biologic devices are available. \nLow level control is included in the `lib` subpackage, while high level control\nis available in the main module. \n> Install with `python -m pip install easy-biologic`\n\n## High Level API\nThere are two high level API modules containing three classes, and two convenience modules.\n\n### Biologic Device\nRepresents an instance of a Biologic Device.\n\n#### Methods\n+ **BiologicDevice( address, timeout = 5 ):** Creates a new Biologic Device representing the device conencted at `address`.\n\n+ **connect( bin_file, xlx_file ):** Connects to the device, loading the bin and xlx file if provided.\n\n+ **disconnect():** Disconnects from the device.\n\n+ **is_connected():** Whether the device is connected or not.\n\n+ **load_technique( ch, technique, params, index = 0, last = True, types = none ):** Loads a technique onto the given device channel.\n\n+ **load_techniques( ch, techniques, parameters, types = None ):** Loads a series of techniques onto the given device channel.\n\n+ **update_parameters( ch, technique, parameters, index = 0, types = None ):** Update the parameters of the given technqiue on the specified device channel.\n\n+ **start_channel( ch ):** Starts the given channel.\n\n+ **start_channels( chs = None ):** Starts multiple channels.\n\n+ **stop_channel( ch ):** Stops the given channel.\n\n+ **stop_channels( chs = None ):** Stops the given channels.\n\n+ **channel_info( ch ):** Returns information about the given channel.\n\n+ **get_values( ch ):** Returns current values of the given channel.\n\n+ **get_data( ch ):** Returns buffered data of the given channel.\n\n\n#### Properties\n+ **address:** Connection address of the device.\n+ **idn:** ID of the device.\n+ **kind:** Device model.\n+ **info:** DeviceInfo structure.\n+ **plugged:** List of available channels. \n+ **channels:** List of ChannelInfo structures.\n+ **techniques:** List of TechParams loaded on each channel.\n\n### Biologic Program\n`Abstract Class`\nRepresents a program to be run on a device.\n\n#### Methods\n+ **BiologicProgram( device, params, channels = None, autoconnect = True, barrier = None, stop_event = None, threaded = False ):** Creates a new program.\n\n+ **channel_state( channels = None ):** Returns the state of the channels.\n\n+ **on_data( callback, index = None ):** Registers a callback function to run when data is collected.\n\n+ **run():** Runs the program.\n\n+ **stop():** Sets the stop event flag.\n\n+ **save_data( file, append = False, by_channel = False ):** Saves data to the given file.\n\n+ **sync():** Waits for barrier, if set.\n\n+ **_connect():** Connects to the device\n\n#### Properties\n+ **device:** BiologicDevice. <br>\n+ **params:** Passed in parameters. <br>\n+ **channels:** Device channels. <br>\n+ **autoconnect:** Whether connection to the device should be automatic or + not. <br>\n+ **barrier:** A threading.Barrier to use for channel syncronization. [See ProgramRummer] <br>\n+ **field_titles:** Column names for saving data. <br>\n+ **data:** Data collected during the program. <br>\n+ **status:** Status of the program. <br>\n+ **fields:** Data fields teh program returns. <br>\n+ **technqiues:** List of techniques the program uses.\n\n### Program Runner\nRepresents a program to be run on a device channel.\n\n#### Methods\n+ **ProgramRunner( programs, sync = False ):** Creates a new program runner.\n\n+ **start():** Runs the programs.\n\n+ **wait():** Wait for all threads to finish.\n\n+ **stop():** Sets stop event.\n\n#### Properties\n+ **threads:** List of threads for each program. <br>\n+ **sync:** Whether to sync the threads or not. \n\n### Base Programs\nContains basic implementations of BiologicPrograms.\n\n#### OCV\n##### Params\n+ **time:** Run time in seconds.\n\n+ **time_interval:** Maximum time between readings. \n[Default: 1]\n\n+ **voltage_interval:** Maximum interval between voltage readings.\n[Default: 0.01]\n\n#### CA\n##### Params\n+ **voltages:** List of voltages.\n\n+ **durations:** List of times in seconds.\n\n+ **vs_initial:** If step is vs. initial or previous. \n[Default: False] \n\n+ **time_interval:** Maximum time interval between points.\n[Default: 1]\n\n+ **current_interval:** Maximum current change between points.\n[Default: 0.001]\n\n+ **current_range:** Current range. Use ec_lib.IRange.\n[Default: IRange.m10 ]\n\n##### Methods\n+ **update_voltage( voltages, durations = None, vs_initial = None ):** Updates the voltage. \n\n#### CALimit\n##### Params\n+ **voltages:** List of voltages.\n\n+ **durations:** List of times in seconds.\n\n+ **vs_initial:** If step is vs. initial or previous. \n[Default: False] \n\n+ **time_interval:** Maximum time interval between points.\n[Default: 1]\n\n+ **current_interval:** Maximum current change between points.\n[Default: 0.001]\n\n+ **current_range:** Current range. Use ec_lib.IRange.\n[Default: IRange.m10 ]\n\n##### Methods\n+ **update_voltage( voltages, durations = None, vs_initial = None ):** Updates the voltage.\n\n#### JV_Scan\nPerforms a JV scan.\n\n##### Params\n+ **start:** Start voltage. \n[ Defualt: 0 ]\n\n+ **end:** End voltage.\n\n+ **step:** Voltage step. \n[Default: 0.01]\n\n+ **rate:** Scan rate in mV/s. \n[Default: 10]\n\n+ **average:** Average over points. \n[Default: False]\n\n\n#### MPP_Tracking\nPerforms MPP tracking.\n\n##### Params\n+ **run_time:** Run time in seconds.\n\n+ **init_vmpp:** Initial v_mpp.\n\n+ **probe_step:** Voltage step for probe. \n[Default: 0.01 V]\n\n+ **probe_points:** Number of data points to collect for probe. \n[Default: 5]\n\n+ **probe_interval:** How often to probe in seconds. \n[Default: 2]\n\n+ **record_interval:** How often to record a data point in seconds. \n[Default: 1]\n\n\n#### MPP\nRuns MPP tracking, finding the initial Vmpp by first measuring Voc, then performing a JV scan from 0 to Voc.\n\n##### Params\n+ **run_time:** Run time in seconds.\n\n+ **probe_step:** Voltage step for probe. \n[Default: 0.01 V]\n\n+ **probe_points:** Number of data points to collect for probe. \n[Default: 5]\n\n+ **probe_interval:** How often to probe in seconds. \n[Default: 2]\n\n+ **record_interval:** How often to record a data point in seconds. \n[Default: 1]\n\n\n#### MPP Cycles\nRuns multiple MPP cycles, performing Voc and JV scans at the beginning of each.\n\n##### Params\n+ **run_time:** Run time in seconds\n\n+ **scan_interval:** How often to perform a JV scan.\n\n+ **probe_step:** Voltage step for probe. [Default: 0.01 V]\n\n+ **probe_points:** Number of data points to collect for probe. [Default: 5]\n\n+ **probe_interval:** How often to probe in seconds. [Default: 2]\n\n+ **record_interval:** How often to record a data point in seconds. [Default: 1]\n\n### Find Devices\nA convenience script for finding connected devices.\n\n#### Use\n1. Open a python shell.\n2. Import the Find Devices module. <br>\n`import easy_biologic.find_devices as fd`\n3. Run the program. <br>\n`fd.run()`\n\n## Low Level API\nThe low level API gives direct control of the Biologic device using the provided DLL libraries. The subpackage contains five modules.\n\n### EC Lib\nContains methods converting the `BL_*` DLL functions for use, enumeration classes to encapsulate program and device states, and C Structures for sending and receiving data from th device.\n\n#### Methods\n+ **connect( address, timeout = 5 ):** Connects to the device at the given address.\n\n+ **disconnect( idn ):** Disconnects given device.\n\n+ **is_connected( address ):** Checks if teh device at the given address is connected.\n\n+ **is_channel_connected( idn, ch ):** Checks whether the given device channel is connected.\n\n+ **get_channels( idn, length = 16 ):** Returns a list of booleans of whether the cahnnel at the index exists.\n\n+ **channel_info( idn, ch ):** Returns a ChannlInfo struct of the given device channel.\n\n+ **load_technique( idn, ch, technique, params, first = True, last = True, verbose = False ):** \nLoads the technique with parameter on the given device channel.\n\n+ **create_parameter( name, value, index, kind = None ):** \nCreates an EccParam struct.\n\n+ **update_paramters( idn, ch, technique, params, tech_index = 0 ):** \nUpdates the paramters of a technique on teh given device channel.\n\n+ **cast_parameters( parameters, types ):** Cast parameters to given types.\n\n+ **start_channel( idn, ch ):** Starts the given device channel.\n\n+ **start_channels( idn, ch ):** Starts the given device channels.\n\n+ **srop_channel( idn, ch ):** Stops the given device channel.\n\n+ **srop_channels( idn, chs ):** Stops the given device channels.\n\n+ **get_values( idn, ch ):** Gets the current values and states of the given device channel.\n\n+ **raise_exception( err ):** Raises an exception based on a calls error code. \n\n#### Enum Classes\n+ **IRange:** Current ranges. <br>\nValues: [ p100, n1, n10, n100, u1, u10, u100, m1, m10, m100, a1, KEEP, BOOSTER, AUTO ]\n\n+ **ERange:** Voltage ranges. <br>\nValues: [ v2_5, v5, v10, AUTO ]\n\n+ **ConnectionType:** Whether the device is floating or grounded. <br>\nValues: [ GROUNDED, FLOATING ]\n\n+ **TechniqueId:** ID of the technique. (Not fully implemented.) <br>\nValues: [ NONE, OCV, CA, CP, CV, PEIS, CALIMIT ]\n\n+ **ChannelState:** State of the channel. <br>\nValues: [ STOP, RUN, PAUSE ]\n\n+ **ParameterType:** Type of a parameter. <br>\nValues: [ INT32, BOOLEAN, SINGLE, FLOAT ]\n(FLOAT is an alias of SINGLE.)\n\n#### Structures\n+ **DeviceInfo:** Information representing the device. Used by `connect()`. <br>\nFields: [ DeviceCode, RAMSize, CPU, NumberOfChannles, NumberOfSlots, FirmwareVersion, FirmwareDate_yyyy, FirmwareDate_mm, FirmwareDate_dd, HTdisplayOn, NbOfConnectedPC ]\n\n+ **ChannelInfo:** Information representing a device channel. Used by `channel_info()`. <br>\nFields: [ Channel, BoardVersion, BoardSerialNumber, FirmwareVersion, XilinxVersion, AmpCode, NbAmps, Lcboard, Zboard, RESERVED, MemSize, State, MaxIRange, MinIRange, MaxBandwidth, NbOfTechniques ]\n\n+ **EccParam:** A technique parameter. <br>\nFields: [ ParamStr, ParamType, ParamVal, ParamIndex ]\n\n+ **EccParams:** A bundle of technique parameters. <br>\nFields: [ len, pParams ]\n\n+ **CurrentValues:** Values measured from and states of the device. <br>\nFields: [ State, MemFilled, TimeBase, Ewe, EweRangeMin, EweRangeMax, Ece, EceRangeMin, EceRangeMax, Eoverflow, I, IRange, Ioverflow, ElapsedTime, Freq, Rcomp, Saturation, OptErr, OptPos ]\n\n+ **DataInfo:** Metadata of measured data. <br>\nFields: [ IRQskipped, NbRows, NbCols, TechniqueIndex, TechniqueID, processIndex, loop, StartTime, MuxPad ]\n\n### Data Parser\nParses data received from a technique and contains technique fields for different device types.\n\n#### Methods\n+ **parse( datam info, fields = None ):** Parses data received from a technique.\n\n+ **calculate_time( t_high, t_low, data_info, current_value ):** Calculates elapsed time from time data.\n\n#### Classes\n+ **VMP3_Fields:** Contains technqiue fields for VMP3 devices. \n(Not all techniques are implemented)\nProperties: [ OCV, CP, CA, CPLIMIT, CALIMIT, CV ]\n\n+ **SP300_Fields:** Contains technqiue fields for SP-300 devices. \n(Not all techniques are implemented)\nProperties: [ OCV, CP, CA, CPLIMIT, CALIMIT, CV ]\n\n### EC Find\nImplements the BL Find DLL.\n\n#### Methods\nAll BL Find DLL functions are implemented under the same name.\n\n+ **find_devices( connection = None ):** Finds conencted devices.\n\n### Technique Fields\nParameter types for techniques. (Not all techniques are implemented.)\n\n#### Classes\n+ OCV\n+ CV\n+ CA\n+ CALIMIT\n\n### EC Errors\nImplements EC errors.\n\n#### Classes\n+ **EcError( value = None, code = None, message = None )** \n\n## Example\n\nA basic example running an MPP program on channels 0 - 7 for 10 minutes.\n```python\nimport easy_biologic as ebl\nimport easy_biologic.base_programs as blp\n\n\n# create device\nbl = ebl.BiologicDevice( 'USB0' )\n\n# create mpp program\nparams = {\n\t'run_time': 10* 60\t\t\n}\n\nmpp = blp.MPP(\n    bl,\n    params, \t\n    channels = [ 0, 1, 2, 3, 4, 5, 7 ]        \n)\n\n# run program\nmpp.run( 'data' )\n```\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "easy-biologic", "package_url": "https://pypi.org/project/easy-biologic/", "platform": "", "project_url": "https://pypi.org/project/easy-biologic/", "project_urls": null, "release_url": "https://pypi.org/project/easy-biologic/0.0.6/", "requires_dist": null, "requires_python": "", "summary": "Controller class for communicating with BioLogic devices.", "version": "0.0.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Easy Biologic</h1>\n<p>A library allowing easy control over BioLogic devices.\nHigh and low level control over Biologic devices are available.\nLow level control is included in the <code>lib</code> subpackage, while high level control\nis available in the main module.</p>\n<blockquote>\n<p>Install with <code>python -m pip install easy-biologic</code></p>\n</blockquote>\n<h2>High Level API</h2>\n<p>There are two high level API modules containing three classes, and two convenience modules.</p>\n<h3>Biologic Device</h3>\n<p>Represents an instance of a Biologic Device.</p>\n<h4>Methods</h4>\n<ul>\n<li>\n<p><strong>BiologicDevice( address, timeout = 5 ):</strong> Creates a new Biologic Device representing the device conencted at <code>address</code>.</p>\n</li>\n<li>\n<p><strong>connect( bin_file, xlx_file ):</strong> Connects to the device, loading the bin and xlx file if provided.</p>\n</li>\n<li>\n<p><strong>disconnect():</strong> Disconnects from the device.</p>\n</li>\n<li>\n<p><strong>is_connected():</strong> Whether the device is connected or not.</p>\n</li>\n<li>\n<p><strong>load_technique( ch, technique, params, index = 0, last = True, types = none ):</strong> Loads a technique onto the given device channel.</p>\n</li>\n<li>\n<p><strong>load_techniques( ch, techniques, parameters, types = None ):</strong> Loads a series of techniques onto the given device channel.</p>\n</li>\n<li>\n<p><strong>update_parameters( ch, technique, parameters, index = 0, types = None ):</strong> Update the parameters of the given technqiue on the specified device channel.</p>\n</li>\n<li>\n<p><strong>start_channel( ch ):</strong> Starts the given channel.</p>\n</li>\n<li>\n<p><strong>start_channels( chs = None ):</strong> Starts multiple channels.</p>\n</li>\n<li>\n<p><strong>stop_channel( ch ):</strong> Stops the given channel.</p>\n</li>\n<li>\n<p><strong>stop_channels( chs = None ):</strong> Stops the given channels.</p>\n</li>\n<li>\n<p><strong>channel_info( ch ):</strong> Returns information about the given channel.</p>\n</li>\n<li>\n<p><strong>get_values( ch ):</strong> Returns current values of the given channel.</p>\n</li>\n<li>\n<p><strong>get_data( ch ):</strong> Returns buffered data of the given channel.</p>\n</li>\n</ul>\n<h4>Properties</h4>\n<ul>\n<li><strong>address:</strong> Connection address of the device.</li>\n<li><strong>idn:</strong> ID of the device.</li>\n<li><strong>kind:</strong> Device model.</li>\n<li><strong>info:</strong> DeviceInfo structure.</li>\n<li><strong>plugged:</strong> List of available channels.</li>\n<li><strong>channels:</strong> List of ChannelInfo structures.</li>\n<li><strong>techniques:</strong> List of TechParams loaded on each channel.</li>\n</ul>\n<h3>Biologic Program</h3>\n<p><code>Abstract Class</code>\nRepresents a program to be run on a device.</p>\n<h4>Methods</h4>\n<ul>\n<li>\n<p><strong>BiologicProgram( device, params, channels = None, autoconnect = True, barrier = None, stop_event = None, threaded = False ):</strong> Creates a new program.</p>\n</li>\n<li>\n<p><strong>channel_state( channels = None ):</strong> Returns the state of the channels.</p>\n</li>\n<li>\n<p><strong>on_data( callback, index = None ):</strong> Registers a callback function to run when data is collected.</p>\n</li>\n<li>\n<p><strong>run():</strong> Runs the program.</p>\n</li>\n<li>\n<p><strong>stop():</strong> Sets the stop event flag.</p>\n</li>\n<li>\n<p><strong>save_data( file, append = False, by_channel = False ):</strong> Saves data to the given file.</p>\n</li>\n<li>\n<p><strong>sync():</strong> Waits for barrier, if set.</p>\n</li>\n<li>\n<p><strong>_connect():</strong> Connects to the device</p>\n</li>\n</ul>\n<h4>Properties</h4>\n<ul>\n<li><strong>device:</strong> BiologicDevice. <br></li>\n<li><strong>params:</strong> Passed in parameters. <br></li>\n<li><strong>channels:</strong> Device channels. <br></li>\n<li><strong>autoconnect:</strong> Whether connection to the device should be automatic or + not. <br></li>\n<li><strong>barrier:</strong> A threading.Barrier to use for channel syncronization. [See ProgramRummer] <br></li>\n<li><strong>field_titles:</strong> Column names for saving data. <br></li>\n<li><strong>data:</strong> Data collected during the program. <br></li>\n<li><strong>status:</strong> Status of the program. <br></li>\n<li><strong>fields:</strong> Data fields teh program returns. <br></li>\n<li><strong>technqiues:</strong> List of techniques the program uses.</li>\n</ul>\n<h3>Program Runner</h3>\n<p>Represents a program to be run on a device channel.</p>\n<h4>Methods</h4>\n<ul>\n<li>\n<p><strong>ProgramRunner( programs, sync = False ):</strong> Creates a new program runner.</p>\n</li>\n<li>\n<p><strong>start():</strong> Runs the programs.</p>\n</li>\n<li>\n<p><strong>wait():</strong> Wait for all threads to finish.</p>\n</li>\n<li>\n<p><strong>stop():</strong> Sets stop event.</p>\n</li>\n</ul>\n<h4>Properties</h4>\n<ul>\n<li><strong>threads:</strong> List of threads for each program. <br></li>\n<li><strong>sync:</strong> Whether to sync the threads or not.</li>\n</ul>\n<h3>Base Programs</h3>\n<p>Contains basic implementations of BiologicPrograms.</p>\n<h4>OCV</h4>\n<h5>Params</h5>\n<ul>\n<li>\n<p><strong>time:</strong> Run time in seconds.</p>\n</li>\n<li>\n<p><strong>time_interval:</strong> Maximum time between readings.\n[Default: 1]</p>\n</li>\n<li>\n<p><strong>voltage_interval:</strong> Maximum interval between voltage readings.\n[Default: 0.01]</p>\n</li>\n</ul>\n<h4>CA</h4>\n<h5>Params</h5>\n<ul>\n<li>\n<p><strong>voltages:</strong> List of voltages.</p>\n</li>\n<li>\n<p><strong>durations:</strong> List of times in seconds.</p>\n</li>\n<li>\n<p><strong>vs_initial:</strong> If step is vs. initial or previous.\n[Default: False]</p>\n</li>\n<li>\n<p><strong>time_interval:</strong> Maximum time interval between points.\n[Default: 1]</p>\n</li>\n<li>\n<p><strong>current_interval:</strong> Maximum current change between points.\n[Default: 0.001]</p>\n</li>\n<li>\n<p><strong>current_range:</strong> Current range. Use ec_lib.IRange.\n[Default: IRange.m10 ]</p>\n</li>\n</ul>\n<h5>Methods</h5>\n<ul>\n<li><strong>update_voltage( voltages, durations = None, vs_initial = None ):</strong> Updates the voltage.</li>\n</ul>\n<h4>CALimit</h4>\n<h5>Params</h5>\n<ul>\n<li>\n<p><strong>voltages:</strong> List of voltages.</p>\n</li>\n<li>\n<p><strong>durations:</strong> List of times in seconds.</p>\n</li>\n<li>\n<p><strong>vs_initial:</strong> If step is vs. initial or previous.\n[Default: False]</p>\n</li>\n<li>\n<p><strong>time_interval:</strong> Maximum time interval between points.\n[Default: 1]</p>\n</li>\n<li>\n<p><strong>current_interval:</strong> Maximum current change between points.\n[Default: 0.001]</p>\n</li>\n<li>\n<p><strong>current_range:</strong> Current range. Use ec_lib.IRange.\n[Default: IRange.m10 ]</p>\n</li>\n</ul>\n<h5>Methods</h5>\n<ul>\n<li><strong>update_voltage( voltages, durations = None, vs_initial = None ):</strong> Updates the voltage.</li>\n</ul>\n<h4>JV_Scan</h4>\n<p>Performs a JV scan.</p>\n<h5>Params</h5>\n<ul>\n<li>\n<p><strong>start:</strong> Start voltage.\n[ Defualt: 0 ]</p>\n</li>\n<li>\n<p><strong>end:</strong> End voltage.</p>\n</li>\n<li>\n<p><strong>step:</strong> Voltage step.\n[Default: 0.01]</p>\n</li>\n<li>\n<p><strong>rate:</strong> Scan rate in mV/s.\n[Default: 10]</p>\n</li>\n<li>\n<p><strong>average:</strong> Average over points.\n[Default: False]</p>\n</li>\n</ul>\n<h4>MPP_Tracking</h4>\n<p>Performs MPP tracking.</p>\n<h5>Params</h5>\n<ul>\n<li>\n<p><strong>run_time:</strong> Run time in seconds.</p>\n</li>\n<li>\n<p><strong>init_vmpp:</strong> Initial v_mpp.</p>\n</li>\n<li>\n<p><strong>probe_step:</strong> Voltage step for probe.\n[Default: 0.01 V]</p>\n</li>\n<li>\n<p><strong>probe_points:</strong> Number of data points to collect for probe.\n[Default: 5]</p>\n</li>\n<li>\n<p><strong>probe_interval:</strong> How often to probe in seconds.\n[Default: 2]</p>\n</li>\n<li>\n<p><strong>record_interval:</strong> How often to record a data point in seconds.\n[Default: 1]</p>\n</li>\n</ul>\n<h4>MPP</h4>\n<p>Runs MPP tracking, finding the initial Vmpp by first measuring Voc, then performing a JV scan from 0 to Voc.</p>\n<h5>Params</h5>\n<ul>\n<li>\n<p><strong>run_time:</strong> Run time in seconds.</p>\n</li>\n<li>\n<p><strong>probe_step:</strong> Voltage step for probe.\n[Default: 0.01 V]</p>\n</li>\n<li>\n<p><strong>probe_points:</strong> Number of data points to collect for probe.\n[Default: 5]</p>\n</li>\n<li>\n<p><strong>probe_interval:</strong> How often to probe in seconds.\n[Default: 2]</p>\n</li>\n<li>\n<p><strong>record_interval:</strong> How often to record a data point in seconds.\n[Default: 1]</p>\n</li>\n</ul>\n<h4>MPP Cycles</h4>\n<p>Runs multiple MPP cycles, performing Voc and JV scans at the beginning of each.</p>\n<h5>Params</h5>\n<ul>\n<li>\n<p><strong>run_time:</strong> Run time in seconds</p>\n</li>\n<li>\n<p><strong>scan_interval:</strong> How often to perform a JV scan.</p>\n</li>\n<li>\n<p><strong>probe_step:</strong> Voltage step for probe. [Default: 0.01 V]</p>\n</li>\n<li>\n<p><strong>probe_points:</strong> Number of data points to collect for probe. [Default: 5]</p>\n</li>\n<li>\n<p><strong>probe_interval:</strong> How often to probe in seconds. [Default: 2]</p>\n</li>\n<li>\n<p><strong>record_interval:</strong> How often to record a data point in seconds. [Default: 1]</p>\n</li>\n</ul>\n<h3>Find Devices</h3>\n<p>A convenience script for finding connected devices.</p>\n<h4>Use</h4>\n<ol>\n<li>Open a python shell.</li>\n<li>Import the Find Devices module. <br>\n<code>import easy_biologic.find_devices as fd</code></li>\n<li>Run the program. <br>\n<code>fd.run()</code></li>\n</ol>\n<h2>Low Level API</h2>\n<p>The low level API gives direct control of the Biologic device using the provided DLL libraries. The subpackage contains five modules.</p>\n<h3>EC Lib</h3>\n<p>Contains methods converting the <code>BL_*</code> DLL functions for use, enumeration classes to encapsulate program and device states, and C Structures for sending and receiving data from th device.</p>\n<h4>Methods</h4>\n<ul>\n<li>\n<p><strong>connect( address, timeout = 5 ):</strong> Connects to the device at the given address.</p>\n</li>\n<li>\n<p><strong>disconnect( idn ):</strong> Disconnects given device.</p>\n</li>\n<li>\n<p><strong>is_connected( address ):</strong> Checks if teh device at the given address is connected.</p>\n</li>\n<li>\n<p><strong>is_channel_connected( idn, ch ):</strong> Checks whether the given device channel is connected.</p>\n</li>\n<li>\n<p><strong>get_channels( idn, length = 16 ):</strong> Returns a list of booleans of whether the cahnnel at the index exists.</p>\n</li>\n<li>\n<p><strong>channel_info( idn, ch ):</strong> Returns a ChannlInfo struct of the given device channel.</p>\n</li>\n<li>\n<p><strong>load_technique( idn, ch, technique, params, first = True, last = True, verbose = False ):</strong>\nLoads the technique with parameter on the given device channel.</p>\n</li>\n<li>\n<p><strong>create_parameter( name, value, index, kind = None ):</strong>\nCreates an EccParam struct.</p>\n</li>\n<li>\n<p><strong>update_paramters( idn, ch, technique, params, tech_index = 0 ):</strong>\nUpdates the paramters of a technique on teh given device channel.</p>\n</li>\n<li>\n<p><strong>cast_parameters( parameters, types ):</strong> Cast parameters to given types.</p>\n</li>\n<li>\n<p><strong>start_channel( idn, ch ):</strong> Starts the given device channel.</p>\n</li>\n<li>\n<p><strong>start_channels( idn, ch ):</strong> Starts the given device channels.</p>\n</li>\n<li>\n<p><strong>srop_channel( idn, ch ):</strong> Stops the given device channel.</p>\n</li>\n<li>\n<p><strong>srop_channels( idn, chs ):</strong> Stops the given device channels.</p>\n</li>\n<li>\n<p><strong>get_values( idn, ch ):</strong> Gets the current values and states of the given device channel.</p>\n</li>\n<li>\n<p><strong>raise_exception( err ):</strong> Raises an exception based on a calls error code.</p>\n</li>\n</ul>\n<h4>Enum Classes</h4>\n<ul>\n<li>\n<p><strong>IRange:</strong> Current ranges. <br>\nValues: [ p100, n1, n10, n100, u1, u10, u100, m1, m10, m100, a1, KEEP, BOOSTER, AUTO ]</p>\n</li>\n<li>\n<p><strong>ERange:</strong> Voltage ranges. <br>\nValues: [ v2_5, v5, v10, AUTO ]</p>\n</li>\n<li>\n<p><strong>ConnectionType:</strong> Whether the device is floating or grounded. <br>\nValues: [ GROUNDED, FLOATING ]</p>\n</li>\n<li>\n<p><strong>TechniqueId:</strong> ID of the technique. (Not fully implemented.) <br>\nValues: [ NONE, OCV, CA, CP, CV, PEIS, CALIMIT ]</p>\n</li>\n<li>\n<p><strong>ChannelState:</strong> State of the channel. <br>\nValues: [ STOP, RUN, PAUSE ]</p>\n</li>\n<li>\n<p><strong>ParameterType:</strong> Type of a parameter. <br>\nValues: [ INT32, BOOLEAN, SINGLE, FLOAT ]\n(FLOAT is an alias of SINGLE.)</p>\n</li>\n</ul>\n<h4>Structures</h4>\n<ul>\n<li>\n<p><strong>DeviceInfo:</strong> Information representing the device. Used by <code>connect()</code>. <br>\nFields: [ DeviceCode, RAMSize, CPU, NumberOfChannles, NumberOfSlots, FirmwareVersion, FirmwareDate_yyyy, FirmwareDate_mm, FirmwareDate_dd, HTdisplayOn, NbOfConnectedPC ]</p>\n</li>\n<li>\n<p><strong>ChannelInfo:</strong> Information representing a device channel. Used by <code>channel_info()</code>. <br>\nFields: [ Channel, BoardVersion, BoardSerialNumber, FirmwareVersion, XilinxVersion, AmpCode, NbAmps, Lcboard, Zboard, RESERVED, MemSize, State, MaxIRange, MinIRange, MaxBandwidth, NbOfTechniques ]</p>\n</li>\n<li>\n<p><strong>EccParam:</strong> A technique parameter. <br>\nFields: [ ParamStr, ParamType, ParamVal, ParamIndex ]</p>\n</li>\n<li>\n<p><strong>EccParams:</strong> A bundle of technique parameters. <br>\nFields: [ len, pParams ]</p>\n</li>\n<li>\n<p><strong>CurrentValues:</strong> Values measured from and states of the device. <br>\nFields: [ State, MemFilled, TimeBase, Ewe, EweRangeMin, EweRangeMax, Ece, EceRangeMin, EceRangeMax, Eoverflow, I, IRange, Ioverflow, ElapsedTime, Freq, Rcomp, Saturation, OptErr, OptPos ]</p>\n</li>\n<li>\n<p><strong>DataInfo:</strong> Metadata of measured data. <br>\nFields: [ IRQskipped, NbRows, NbCols, TechniqueIndex, TechniqueID, processIndex, loop, StartTime, MuxPad ]</p>\n</li>\n</ul>\n<h3>Data Parser</h3>\n<p>Parses data received from a technique and contains technique fields for different device types.</p>\n<h4>Methods</h4>\n<ul>\n<li>\n<p><strong>parse( datam info, fields = None ):</strong> Parses data received from a technique.</p>\n</li>\n<li>\n<p><strong>calculate_time( t_high, t_low, data_info, current_value ):</strong> Calculates elapsed time from time data.</p>\n</li>\n</ul>\n<h4>Classes</h4>\n<ul>\n<li>\n<p><strong>VMP3_Fields:</strong> Contains technqiue fields for VMP3 devices.\n(Not all techniques are implemented)\nProperties: [ OCV, CP, CA, CPLIMIT, CALIMIT, CV ]</p>\n</li>\n<li>\n<p><strong>SP300_Fields:</strong> Contains technqiue fields for SP-300 devices.\n(Not all techniques are implemented)\nProperties: [ OCV, CP, CA, CPLIMIT, CALIMIT, CV ]</p>\n</li>\n</ul>\n<h3>EC Find</h3>\n<p>Implements the BL Find DLL.</p>\n<h4>Methods</h4>\n<p>All BL Find DLL functions are implemented under the same name.</p>\n<ul>\n<li><strong>find_devices( connection = None ):</strong> Finds conencted devices.</li>\n</ul>\n<h3>Technique Fields</h3>\n<p>Parameter types for techniques. (Not all techniques are implemented.)</p>\n<h4>Classes</h4>\n<ul>\n<li>OCV</li>\n<li>CV</li>\n<li>CA</li>\n<li>CALIMIT</li>\n</ul>\n<h3>EC Errors</h3>\n<p>Implements EC errors.</p>\n<h4>Classes</h4>\n<ul>\n<li><strong>EcError( value = None, code = None, message = None )</strong></li>\n</ul>\n<h2>Example</h2>\n<p>A basic example running an MPP program on channels 0 - 7 for 10 minutes.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">easy_biologic</span> <span class=\"k\">as</span> <span class=\"nn\">ebl</span>\n<span class=\"kn\">import</span> <span class=\"nn\">easy_biologic.base_programs</span> <span class=\"k\">as</span> <span class=\"nn\">blp</span>\n\n\n<span class=\"c1\"># create device</span>\n<span class=\"n\">bl</span> <span class=\"o\">=</span> <span class=\"n\">ebl</span><span class=\"o\">.</span><span class=\"n\">BiologicDevice</span><span class=\"p\">(</span> <span class=\"s1\">'USB0'</span> <span class=\"p\">)</span>\n\n<span class=\"c1\"># create mpp program</span>\n<span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n\t<span class=\"s1\">'run_time'</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"o\">*</span> <span class=\"mi\">60</span>\t\t\n<span class=\"p\">}</span>\n\n<span class=\"n\">mpp</span> <span class=\"o\">=</span> <span class=\"n\">blp</span><span class=\"o\">.</span><span class=\"n\">MPP</span><span class=\"p\">(</span>\n    <span class=\"n\">bl</span><span class=\"p\">,</span>\n    <span class=\"n\">params</span><span class=\"p\">,</span> \t\n    <span class=\"n\">channels</span> <span class=\"o\">=</span> <span class=\"p\">[</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">7</span> <span class=\"p\">]</span>        \n<span class=\"p\">)</span>\n\n<span class=\"c1\"># run program</span>\n<span class=\"n\">mpp</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span> <span class=\"s1\">'data'</span> <span class=\"p\">)</span>\n</pre>\n\n          </div>"}, "last_serial": 6576871, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "3339b2157c09bbb627e7c8a7a5456d58", "sha256": "433390b4c742155e0172997ebdd02669918477ea37b380d5426a7fe0c098f00b"}, "downloads": -1, "filename": "easy_biologic-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "3339b2157c09bbb627e7c8a7a5456d58", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 51796, "upload_time": "2019-10-18T11:45:39", "upload_time_iso_8601": "2019-10-18T11:45:39.002858Z", "url": "https://files.pythonhosted.org/packages/23/c6/454d4b528e89c6cc280ba945fcf68aaf20c9a184e247d9e508ee7d2daf50/easy_biologic-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3444b4faaa6b3318837b7a1be8c93a61", "sha256": "903008d632dc9497150fae734ff5390476e28091cb4523b39967ea1258efd8ac"}, "downloads": -1, "filename": "easy-biologic-0.0.1.tar.gz", "has_sig": false, "md5_digest": "3444b4faaa6b3318837b7a1be8c93a61", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26799, "upload_time": "2019-10-18T11:45:41", "upload_time_iso_8601": "2019-10-18T11:45:41.347802Z", "url": "https://files.pythonhosted.org/packages/f9/c4/4f220a0860090c117f930dfef3bcaa99d18d9976b041cfb6ccbee1e6bbf8/easy-biologic-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "778a91ea0d96d829a5d98c22e2cef681", "sha256": "d6e83f200b8adaca4588cbd350c876415b9bf50ff0a135c93598e012af84769c"}, "downloads": -1, "filename": "easy_biologic-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "778a91ea0d96d829a5d98c22e2cef681", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 53855, "upload_time": "2019-10-31T14:25:16", "upload_time_iso_8601": "2019-10-31T14:25:16.971158Z", "url": "https://files.pythonhosted.org/packages/13/cc/12cef1a6bd3203d1a3e92a290a7bffab8d6189d1a219c629d6d89d45ec89/easy_biologic-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c2d236dc94fb3a83c67b86ae7b1d8943", "sha256": "ff5d4ce95271f3268dbd7fff3dc07c16f7a92f9f30bc12154c7f7f1215a6245b"}, "downloads": -1, "filename": "easy-biologic-0.0.2.tar.gz", "has_sig": false, "md5_digest": "c2d236dc94fb3a83c67b86ae7b1d8943", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28389, "upload_time": "2019-10-31T14:25:19", "upload_time_iso_8601": "2019-10-31T14:25:19.571232Z", "url": "https://files.pythonhosted.org/packages/0a/29/356f4563238c8bf20a938fd93b9c821488de2917e7be9752e93472e9067b/easy-biologic-0.0.2.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "9826aaaba3694a735470b863e724c024", "sha256": "447dc90fed1bc86cfee142fa66331b48581e1cfa9083e467802c98a37361bbfc"}, "downloads": -1, "filename": "easy_biologic-0.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "9826aaaba3694a735470b863e724c024", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 53833, "upload_time": "2019-10-31T15:28:56", "upload_time_iso_8601": "2019-10-31T15:28:56.944332Z", "url": "https://files.pythonhosted.org/packages/63/68/67792daf3989e34bab6a601c1c355cb68a2db086f8801df6951b194962c8/easy_biologic-0.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "640a51977dd493febe8dcc6f584851e3", "sha256": "9fd54b032e71bfa5eafa9dc09ee45c5b0529f29f112511c477372136a58dda69"}, "downloads": -1, "filename": "easy-biologic-0.0.4.tar.gz", "has_sig": false, "md5_digest": "640a51977dd493febe8dcc6f584851e3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28379, "upload_time": "2019-10-31T15:28:58", "upload_time_iso_8601": "2019-10-31T15:28:58.875029Z", "url": "https://files.pythonhosted.org/packages/a3/57/589ff329604a8debe5584f663cd59388d618540e2fb262762001cb0becf0/easy-biologic-0.0.4.tar.gz", "yanked": false}], "0.0.5": [{"comment_text": "", "digests": {"md5": "98840982f94cadc171810796331e77b5", "sha256": "548171cb7e9f9387b7195ef29e1bc8bb08f0f6efb9febb81322b512d771bd84d"}, "downloads": -1, "filename": "easy_biologic-0.0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "98840982f94cadc171810796331e77b5", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5978526, "upload_time": "2019-10-31T16:18:27", "upload_time_iso_8601": "2019-10-31T16:18:27.421844Z", "url": "https://files.pythonhosted.org/packages/05/82/e42644b048607dfd3b45ba100d7aa20382ffba869883d2d3ca58c762f770/easy_biologic-0.0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5aea068e6a4ab9ed55dee0ebbf2ed900", "sha256": "b016c4505817030575593bb3c1db36f6b81db11d1da63c4bf1155f266ad82713"}, "downloads": -1, "filename": "easy-biologic-0.0.5.tar.gz", "has_sig": false, "md5_digest": "5aea068e6a4ab9ed55dee0ebbf2ed900", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5878135, "upload_time": "2019-10-31T16:18:31", "upload_time_iso_8601": "2019-10-31T16:18:31.554371Z", "url": "https://files.pythonhosted.org/packages/d9/e5/da927501f48cdcf8969244b3ae29751f24b1124315d8f6b97c887e2e78a6/easy-biologic-0.0.5.tar.gz", "yanked": false}], "0.0.6": [{"comment_text": "", "digests": {"md5": "720ca2a76441dd241d7686a81a783209", "sha256": "a1fccd4eb39eff1e1b097482350607ded315161ff8a23d89cc3755d7f92ae54a"}, "downloads": -1, "filename": "easy_biologic-0.0.6-py3-none-any.whl", "has_sig": false, "md5_digest": "720ca2a76441dd241d7686a81a783209", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5984655, "upload_time": "2020-02-05T16:27:47", "upload_time_iso_8601": "2020-02-05T16:27:47.498247Z", "url": "https://files.pythonhosted.org/packages/18/13/1ff6838d36bb5b032f9d3124cc9ac12ceeafd87eb987f04d063458296889/easy_biologic-0.0.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b7fc1d6de2c952dc8aa17c2e847782ad", "sha256": "5a12ab30af067e2fa36b57c59d0d77b0cf3efe8ceb05866a24035c93fa7cde39"}, "downloads": -1, "filename": "easy-biologic-0.0.6.tar.gz", "has_sig": false, "md5_digest": "b7fc1d6de2c952dc8aa17c2e847782ad", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5884388, "upload_time": "2020-02-05T16:27:50", "upload_time_iso_8601": "2020-02-05T16:27:50.254740Z", "url": "https://files.pythonhosted.org/packages/84/bf/615526d7be7d5bfe61f5c38a85e0b4c161c6914051a857c4e7e882839a69/easy-biologic-0.0.6.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "720ca2a76441dd241d7686a81a783209", "sha256": "a1fccd4eb39eff1e1b097482350607ded315161ff8a23d89cc3755d7f92ae54a"}, "downloads": -1, "filename": "easy_biologic-0.0.6-py3-none-any.whl", "has_sig": false, "md5_digest": "720ca2a76441dd241d7686a81a783209", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 5984655, "upload_time": "2020-02-05T16:27:47", "upload_time_iso_8601": "2020-02-05T16:27:47.498247Z", "url": "https://files.pythonhosted.org/packages/18/13/1ff6838d36bb5b032f9d3124cc9ac12ceeafd87eb987f04d063458296889/easy_biologic-0.0.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b7fc1d6de2c952dc8aa17c2e847782ad", "sha256": "5a12ab30af067e2fa36b57c59d0d77b0cf3efe8ceb05866a24035c93fa7cde39"}, "downloads": -1, "filename": "easy-biologic-0.0.6.tar.gz", "has_sig": false, "md5_digest": "b7fc1d6de2c952dc8aa17c2e847782ad", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5884388, "upload_time": "2020-02-05T16:27:50", "upload_time_iso_8601": "2020-02-05T16:27:50.254740Z", "url": "https://files.pythonhosted.org/packages/84/bf/615526d7be7d5bfe61f5c38a85e0b4c161c6914051a857c4e7e882839a69/easy-biologic-0.0.6.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:48:27 2020"}