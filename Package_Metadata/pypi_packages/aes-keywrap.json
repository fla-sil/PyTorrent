{"info": {"author": "Kurt Rose", "author_email": "kurt@kurtrose.com", "bugtrack_url": null, "classifiers": [], "description": "AES keywrap\n'''''''''''\nimplementation of RFC 3394 AES key wrapping/unwrapping\n\nhttp://www.ietf.org/rfc/rfc3394.txt\n\nalso, alternative IV per RFC 5649\n\nhttp://www.ietf.org/rfc/rfc5649.txt\n\nThis is a symmetric key-encryption algorithm.  It should only be used\nto encrypt keys (short and globally unique strings.)\n\nIn documentation, the key used for this kind of algorithm is\noften called the KEK (Key-Encryption-Key), to distinguish\nit from data encryption keys.\n\n\nusage\n'''''\n\n.. code-block:: python\n\n    import binascii\n    from aes_keywrap import aes_wrap_key, aes_unwrap_key\n    KEK = binascii.unhexlify(\"000102030405060708090A0B0C0D0E0F\")\n    CIPHER = binascii.unhexlify(\"1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5\")\n    PLAIN = binascii.unhexlify(\"00112233445566778899AABBCCDDEEFF\")\n    assert aes_unwrap_key(KEK, CIPHER) == PLAIN\n    assert aes_wrap_key(KEK, PLAIN) == CIPHER\n\n\nWhy a special key-encryption algorithm?\n'''''''''''''''''''''''''''''''''''''''\n\nIn a word: size.  By assuming keys are high enough\nentropy to be globally unique, and small enough\nnot to require streaming encryption, aes-keywrap is able to avoid\nan IV (initial value) or nonce that increases the size\nof the ciphertext.  This can be a significant\nsavings -- if the data being encrypted is a 32\nbyte AES-256 key, AES-GCM would result in a\n60 byte ciphertext (87% overhead), AES-CTR or AES-CBC would result\nin a 48 byte ciphertext (50% overhead) and would also not provide\nauthenticated encryption, but aes-keywrap\nwould result in a 32 byte ciphertext (no overhead).\n\nIn an application where there are many keys being generated\nand encrypted (e.g. a separate data encryption key for\neach row in a database), this overhead can be significant.\n\nAnother important use case is compatibility with\nexisting systems.", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kurtbrose/aes_keywrap", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "aes-keywrap", "package_url": "https://pypi.org/project/aes-keywrap/", "platform": "", "project_url": "https://pypi.org/project/aes-keywrap/", "project_urls": {"Homepage": "https://github.com/kurtbrose/aes_keywrap"}, "release_url": "https://pypi.org/project/aes-keywrap/17.12.1/", "requires_dist": null, "requires_python": "", "summary": "", "version": "17.12.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"aes-keywrap\">\n<h2>AES keywrap</h2>\n<p>implementation of RFC 3394 AES key wrapping/unwrapping</p>\n<p><a href=\"http://www.ietf.org/rfc/rfc3394.txt\" rel=\"nofollow\">http://www.ietf.org/rfc/rfc3394.txt</a></p>\n<p>also, alternative IV per RFC 5649</p>\n<p><a href=\"http://www.ietf.org/rfc/rfc5649.txt\" rel=\"nofollow\">http://www.ietf.org/rfc/rfc5649.txt</a></p>\n<p>This is a symmetric key-encryption algorithm.  It should only be used\nto encrypt keys (short and globally unique strings.)</p>\n<p>In documentation, the key used for this kind of algorithm is\noften called the KEK (Key-Encryption-Key), to distinguish\nit from data encryption keys.</p>\n</div>\n<div id=\"usage\">\n<h2>usage</h2>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">binascii</span>\n<span class=\"kn\">from</span> <span class=\"nn\">aes_keywrap</span> <span class=\"kn\">import</span> <span class=\"n\">aes_wrap_key</span><span class=\"p\">,</span> <span class=\"n\">aes_unwrap_key</span>\n<span class=\"n\">KEK</span> <span class=\"o\">=</span> <span class=\"n\">binascii</span><span class=\"o\">.</span><span class=\"n\">unhexlify</span><span class=\"p\">(</span><span class=\"s2\">\"000102030405060708090A0B0C0D0E0F\"</span><span class=\"p\">)</span>\n<span class=\"n\">CIPHER</span> <span class=\"o\">=</span> <span class=\"n\">binascii</span><span class=\"o\">.</span><span class=\"n\">unhexlify</span><span class=\"p\">(</span><span class=\"s2\">\"1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5\"</span><span class=\"p\">)</span>\n<span class=\"n\">PLAIN</span> <span class=\"o\">=</span> <span class=\"n\">binascii</span><span class=\"o\">.</span><span class=\"n\">unhexlify</span><span class=\"p\">(</span><span class=\"s2\">\"00112233445566778899AABBCCDDEEFF\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">aes_unwrap_key</span><span class=\"p\">(</span><span class=\"n\">KEK</span><span class=\"p\">,</span> <span class=\"n\">CIPHER</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">PLAIN</span>\n<span class=\"k\">assert</span> <span class=\"n\">aes_wrap_key</span><span class=\"p\">(</span><span class=\"n\">KEK</span><span class=\"p\">,</span> <span class=\"n\">PLAIN</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">CIPHER</span>\n</pre>\n</div>\n<div id=\"why-a-special-key-encryption-algorithm\">\n<h2>Why a special key-encryption algorithm?</h2>\n<p>In a word: size.  By assuming keys are high enough\nentropy to be globally unique, and small enough\nnot to require streaming encryption, aes-keywrap is able to avoid\nan IV (initial value) or nonce that increases the size\nof the ciphertext.  This can be a significant\nsavings \u2013 if the data being encrypted is a 32\nbyte AES-256 key, AES-GCM would result in a\n60 byte ciphertext (87% overhead), AES-CTR or AES-CBC would result\nin a 48 byte ciphertext (50% overhead) and would also not provide\nauthenticated encryption, but aes-keywrap\nwould result in a 32 byte ciphertext (no overhead).</p>\n<p>In an application where there are many keys being generated\nand encrypted (e.g. a separate data encryption key for\neach row in a database), this overhead can be significant.</p>\n<p>Another important use case is compatibility with\nexisting systems.</p>\n</div>\n\n          </div>"}, "last_serial": 3449004, "releases": {"17.12.0": [{"comment_text": "", "digests": {"md5": "226fa8aa5bddcb03cfcfa4540b683c8e", "sha256": "e18e20605fe75e9745b2d35226b3a92f54dc9eb464ad832916d3aedb7718c9c1"}, "downloads": -1, "filename": "aes-keywrap-17.12.0.tar.gz", "has_sig": false, "md5_digest": "226fa8aa5bddcb03cfcfa4540b683c8e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2865, "upload_time": "2017-12-29T01:42:35", "upload_time_iso_8601": "2017-12-29T01:42:35.687365Z", "url": "https://files.pythonhosted.org/packages/86/4c/1f75cb626a2804cc6d8617a81824f8de6e32c89eedab5e078f3793f6a659/aes-keywrap-17.12.0.tar.gz", "yanked": false}], "17.12.1": [{"comment_text": "", "digests": {"md5": "4402698e3c23f8582c9964e52f46ef6e", "sha256": "0977f08e80f66aa6c2591eca3716ef8ab9e7ee7ad9cd5fb63e72c6308bda2619"}, "downloads": -1, "filename": "aes-keywrap-17.12.1.tar.gz", "has_sig": false, "md5_digest": "4402698e3c23f8582c9964e52f46ef6e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2864, "upload_time": "2017-12-29T01:50:02", "upload_time_iso_8601": "2017-12-29T01:50:02.204157Z", "url": "https://files.pythonhosted.org/packages/40/be/631f1dd7a65c1ee7419fff826073620e50055d8e77a7dae152436250bf1a/aes-keywrap-17.12.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4402698e3c23f8582c9964e52f46ef6e", "sha256": "0977f08e80f66aa6c2591eca3716ef8ab9e7ee7ad9cd5fb63e72c6308bda2619"}, "downloads": -1, "filename": "aes-keywrap-17.12.1.tar.gz", "has_sig": false, "md5_digest": "4402698e3c23f8582c9964e52f46ef6e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2864, "upload_time": "2017-12-29T01:50:02", "upload_time_iso_8601": "2017-12-29T01:50:02.204157Z", "url": "https://files.pythonhosted.org/packages/40/be/631f1dd7a65c1ee7419fff826073620e50055d8e77a7dae152436250bf1a/aes-keywrap-17.12.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:22:52 2020"}