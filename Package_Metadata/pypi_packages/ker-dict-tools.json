{"info": {"author": "Luca Buccioni", "author_email": "kerkops7@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "# ker_dict_tools\n\nSmart tools to operate on Python's dicts.\n\n  - **_dict_diff()_**: Function to compare two dicts reporting their differences.\n  - **_get_value_by_path()_**: Get single or multiple values from a dict passing the path leading to them.\n  - **_set_value_by_path()_**: Set a value in a nested dict passing the path leading to it.\n  \n### The 'path' concept:\nI needed a smart way to access dict whose structure could change unpredictably (for example nested list of dicts) putting them in relationship with other objects.\nSo i developed the functions 'get_value_by_path()' and 'set_value_by_path()' that allows me to access to those values in a safe and rapid way.\nThe _path_ is a list of values, each one pointing to a subsequential sub-level of the dict.\nFor example, given the dict:\n```\ndct = {\n    \"foo\": [\n        {\"bar\":1},\n        {\"baz\":2}\n    ]\n}\n```\nthe path to access to the value _2_ is:\n```\n[\n    \"foo\",      # Key for outer level of the dict\n    1,          # Index for list contained in the \"foo\" value\n    \"baz\"       # Key for dict at index 1 of the list\n]\n```\nSince is designed to be used in a context where the actual dict could be partially unknown, the entry point to define a path to be used is the **_get_value_by_path()_** function, wich accepts a much more \"elastic\" list (allowing simple queries on the dict).\n## get_value_by_path(_dct_, _path_, _fail=False_, _debug=False_)\nAllows to retrieve the value (or values) stored somewhere in the _dct_ dict if the given _path_ is correct (corresponds to the structure of the dict).\nThe _dct_ argument can be either a _dict_ or a _list of dicts_.\nIf the _fail_ argument is passed (_True_), when an element in the _path_ doesn't correspond to the the layer of the _dct_ dict where is applied, a _TypeError_ exception will be raised. Otherwise the function will return an empty namedtuple with _0_ as value for _.found_ attribute.\nIf the _debug_ argument is passed (_True_), the function will log (using the _logging_ module) every operation with a _debug_ level.\n\n#### Accepted values in the _path_ list when passed to _get_values_by_path()_\n\n| Dict layer type | Accepted Values |\n|-----------------|-----------------|\n| List of dicts | **int** (Index of list) |\n| | **dict** (_key:value_ pair to be matched in one or more dicts inside the list) |\n| | **list (of dicts)** (list of dicts containing a single _key:value_pair, all to be matched in one or more dict inside the list)|\n| | **str** (key to be found among keys of dicts contained in the list)|\n| | **string \"\\*\"** (wildcard to return all the elements in the list)|\n| Dict | **str** (key for the dict) |\n| | **string \"\\*\"** (wildcard to return all items in the dict) |\n\nFor example:\n```\ndct = [\n{ \"foo\": [{\"bar\":1, \"baz\":2},{\"bar\":3, \"baz\":4}] },\n{ \"foo\": [{\"bar\":5, \"baz\":6},{\"bar\":7, \"baz\":8}] },\n]\npath1 = [0, \"foo\", {\"bar\":1}, \"baz\"] \npath2 = [0, \"foo\", 0, \"baz\"]\n```\n_path1_ and _path2_ will lead to the value 2.\nWith:\n```\npath3 = [0, \"foo\", \"*\", \"baz\"]\n```\n_path3_ will lead to the values _2_ and _4_\n\n#### Object returned by _get_value_by_path()_\nThe function will return a _dict_search_ object.\n```\nres = get_value_by_path(myDict, myPath)\n\nres => 'dict_search'(\n    found=n, # -> number of matches\n    results=[\n        dict_branch(\n            path={list1} # Path leading to the value #1\n            value={value1} # Value #1\n            ),\n        dict_branch(\n            path={list2} # Path leading to the value #2\n            value={any} # Value #2\n            ),\n        ...\n            \n    ]\n    )\n```\nThe function will return a '_dict_search_' namedtuple, containing two attributes:\n - **.found** {int}: Number of elements in the dict matching the given _path_\n - **.results** {list}: List of _dict_branch_ namedtuples, each one specifing the _path_ and _value_ of for the elements matching the given path.\n##### _dict_branch_ namedtuple structure:\n- **.path** {list}: \"normalized\" path leading to the value (contains only dict keys or list indexes)\n- **.value** {any}: value found at specified _path_\n### Using _get_value_by_path()_ to query the dict\nIs also possible to verify if a given value is present at a certain layer of the dict passing as path the path leading to it and specifing the value to find as last item in the path's list.\nThe function returns a namedtuple that specifies at index 0 (_.found_) the number of matches for the given path.\n\n## set_value_by_path(_dct_, _path_, _value_, _debug=False_)\nAllows to set a given _value_ at a certain position of the _dct_ dict specified with the given _path_.\nThe _path_ argument must be a list of _ints_ or _strings_ according to the structure of the dict (such those returned in the _dict_search_ object from _get_value_by_path()_).\n\n## diff_dict(_dct1_, _dct2_, _fail=False_, _startPath=None_)\nPerforms a comparison from _dct1_ and _dct2_ dicts. \nThose two arguments must be of the same type (bot lists of dicts or simple dicts).\nReturns a '_diff_results_' object, containing four attributes:\n- **.compared** {bool}: True if the comparison has been performed without problems.\n- **.updated** {list}: List of '_updated_item_' namedtuple (see below) containing info about elements present in both dicts but with different values.\n- **.added** {list}: List of paths pointing elements found in the _dct2_ but not in the _dct1_.\n- **.removed** {list}: List of paths pointing elements found in the _dct1_ but not in the _dct2_.\n\nThe _updated_item_ namedtuple, that populates the _.updated_ list, has the follwing structure:\n- **.path** {list}: Path leading to updated element.\n- **.old_value** {any}: Old value for the element.\n- **.old_type** {type}: Old type for element's value.\n- **.new_value** {any}: New value for the element.\n- **.new_type** {type}: New type for element's value.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/kerkops/dict_tools", "keywords": "dicts,dict,path,paths,paths for dicts,dict diff,dict differences,diff,operations on dictionaries,dict values by path,dict queries,dict query,differences between nested dicts,Intended Audience :: Developers,Topic :: Software Development :: Build Tools,License :: OSI Approved :: MIT License,Programming Language :: Python :: 3,Programming Language :: Python :: 3.6,Programming Language :: Python :: 2,Programming Language :: Python :: 2.7", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "ker-dict-tools", "package_url": "https://pypi.org/project/ker-dict-tools/", "platform": "", "project_url": "https://pypi.org/project/ker-dict-tools/", "project_urls": {"Homepage": "https://bitbucket.org/kerkops/dict_tools"}, "release_url": "https://pypi.org/project/ker-dict-tools/0.1.1/", "requires_dist": null, "requires_python": "", "summary": "Tools for smart operations with python dicts", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>ker_dict_tools</h1>\n<p>Smart tools to operate on Python's dicts.</p>\n<ul>\n<li><strong><em>dict_diff()</em></strong>: Function to compare two dicts reporting their differences.</li>\n<li><strong><em>get_value_by_path()</em></strong>: Get single or multiple values from a dict passing the path leading to them.</li>\n<li><strong><em>set_value_by_path()</em></strong>: Set a value in a nested dict passing the path leading to it.</li>\n</ul>\n<h3>The 'path' concept:</h3>\n<p>I needed a smart way to access dict whose structure could change unpredictably (for example nested list of dicts) putting them in relationship with other objects.\nSo i developed the functions 'get_value_by_path()' and 'set_value_by_path()' that allows me to access to those values in a safe and rapid way.\nThe <em>path</em> is a list of values, each one pointing to a subsequential sub-level of the dict.\nFor example, given the dict:</p>\n<pre><code>dct = {\n    \"foo\": [\n        {\"bar\":1},\n        {\"baz\":2}\n    ]\n}\n</code></pre>\n<p>the path to access to the value <em>2</em> is:</p>\n<pre><code>[\n    \"foo\",      # Key for outer level of the dict\n    1,          # Index for list contained in the \"foo\" value\n    \"baz\"       # Key for dict at index 1 of the list\n]\n</code></pre>\n<p>Since is designed to be used in a context where the actual dict could be partially unknown, the entry point to define a path to be used is the <strong><em>get_value_by_path()</em></strong> function, wich accepts a much more \"elastic\" list (allowing simple queries on the dict).</p>\n<h2>get_value_by_path(<em>dct</em>, <em>path</em>, <em>fail=False</em>, <em>debug=False</em>)</h2>\n<p>Allows to retrieve the value (or values) stored somewhere in the <em>dct</em> dict if the given <em>path</em> is correct (corresponds to the structure of the dict).\nThe <em>dct</em> argument can be either a <em>dict</em> or a <em>list of dicts</em>.\nIf the <em>fail</em> argument is passed (<em>True</em>), when an element in the <em>path</em> doesn't correspond to the the layer of the <em>dct</em> dict where is applied, a <em>TypeError</em> exception will be raised. Otherwise the function will return an empty namedtuple with <em>0</em> as value for <em>.found</em> attribute.\nIf the <em>debug</em> argument is passed (<em>True</em>), the function will log (using the <em>logging</em> module) every operation with a <em>debug</em> level.</p>\n<h4>Accepted values in the <em>path</em> list when passed to <em>get_values_by_path()</em></h4>\n<table>\n<thead>\n<tr>\n<th>Dict layer type</th>\n<th>Accepted Values</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>List of dicts</td>\n<td><strong>int</strong> (Index of list)</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>dict</strong> (<em>key:value</em> pair to be matched in one or more dicts inside the list)</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>list (of dicts)</strong> (list of dicts containing a single _key:value_pair, all to be matched in one or more dict inside the list)</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>str</strong> (key to be found among keys of dicts contained in the list)</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>string \"*\"</strong> (wildcard to return all the elements in the list)</td>\n</tr>\n<tr>\n<td>Dict</td>\n<td><strong>str</strong> (key for the dict)</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>string \"*\"</strong> (wildcard to return all items in the dict)</td>\n</tr></tbody></table>\n<p>For example:</p>\n<pre><code>dct = [\n{ \"foo\": [{\"bar\":1, \"baz\":2},{\"bar\":3, \"baz\":4}] },\n{ \"foo\": [{\"bar\":5, \"baz\":6},{\"bar\":7, \"baz\":8}] },\n]\npath1 = [0, \"foo\", {\"bar\":1}, \"baz\"] \npath2 = [0, \"foo\", 0, \"baz\"]\n</code></pre>\n<p><em>path1</em> and <em>path2</em> will lead to the value 2.\nWith:</p>\n<pre><code>path3 = [0, \"foo\", \"*\", \"baz\"]\n</code></pre>\n<p><em>path3</em> will lead to the values <em>2</em> and <em>4</em></p>\n<h4>Object returned by <em>get_value_by_path()</em></h4>\n<p>The function will return a <em>dict_search</em> object.</p>\n<pre><code>res = get_value_by_path(myDict, myPath)\n\nres =&gt; 'dict_search'(\n    found=n, # -&gt; number of matches\n    results=[\n        dict_branch(\n            path={list1} # Path leading to the value #1\n            value={value1} # Value #1\n            ),\n        dict_branch(\n            path={list2} # Path leading to the value #2\n            value={any} # Value #2\n            ),\n        ...\n            \n    ]\n    )\n</code></pre>\n<p>The function will return a '<em>dict_search</em>' namedtuple, containing two attributes:</p>\n<ul>\n<li><strong>.found</strong> {int}: Number of elements in the dict matching the given <em>path</em></li>\n<li><strong>.results</strong> {list}: List of <em>dict_branch</em> namedtuples, each one specifing the <em>path</em> and <em>value</em> of for the elements matching the given path.</li>\n</ul>\n<h5><em>dict_branch</em> namedtuple structure:</h5>\n<ul>\n<li><strong>.path</strong> {list}: \"normalized\" path leading to the value (contains only dict keys or list indexes)</li>\n<li><strong>.value</strong> {any}: value found at specified <em>path</em></li>\n</ul>\n<h3>Using <em>get_value_by_path()</em> to query the dict</h3>\n<p>Is also possible to verify if a given value is present at a certain layer of the dict passing as path the path leading to it and specifing the value to find as last item in the path's list.\nThe function returns a namedtuple that specifies at index 0 (<em>.found</em>) the number of matches for the given path.</p>\n<h2>set_value_by_path(<em>dct</em>, <em>path</em>, <em>value</em>, <em>debug=False</em>)</h2>\n<p>Allows to set a given <em>value</em> at a certain position of the <em>dct</em> dict specified with the given <em>path</em>.\nThe <em>path</em> argument must be a list of <em>ints</em> or <em>strings</em> according to the structure of the dict (such those returned in the <em>dict_search</em> object from <em>get_value_by_path()</em>).</p>\n<h2>diff_dict(<em>dct1</em>, <em>dct2</em>, <em>fail=False</em>, <em>startPath=None</em>)</h2>\n<p>Performs a comparison from <em>dct1</em> and <em>dct2</em> dicts.\nThose two arguments must be of the same type (bot lists of dicts or simple dicts).\nReturns a '<em>diff_results</em>' object, containing four attributes:</p>\n<ul>\n<li><strong>.compared</strong> {bool}: True if the comparison has been performed without problems.</li>\n<li><strong>.updated</strong> {list}: List of '<em>updated_item</em>' namedtuple (see below) containing info about elements present in both dicts but with different values.</li>\n<li><strong>.added</strong> {list}: List of paths pointing elements found in the <em>dct2</em> but not in the <em>dct1</em>.</li>\n<li><strong>.removed</strong> {list}: List of paths pointing elements found in the <em>dct1</em> but not in the <em>dct2</em>.</li>\n</ul>\n<p>The <em>updated_item</em> namedtuple, that populates the <em>.updated</em> list, has the follwing structure:</p>\n<ul>\n<li><strong>.path</strong> {list}: Path leading to updated element.</li>\n<li><strong>.old_value</strong> {any}: Old value for the element.</li>\n<li><strong>.old_type</strong> {type}: Old type for element's value.</li>\n<li><strong>.new_value</strong> {any}: New value for the element.</li>\n<li><strong>.new_type</strong> {type}: New type for element's value.</li>\n</ul>\n\n          </div>"}, "last_serial": 4387533, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "ce185295a7a9a56907b596ab91c99b45", "sha256": "79510df50766663f7039ee85ebff6f114c1987764939f47f5b041cd21e1ec195"}, "downloads": -1, "filename": "ker_dict_tools-0.1.tar.gz", "has_sig": false, "md5_digest": "ce185295a7a9a56907b596ab91c99b45", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8418, "upload_time": "2018-10-17T16:55:13", "upload_time_iso_8601": "2018-10-17T16:55:13.481467Z", "url": "https://files.pythonhosted.org/packages/69/ab/2a8ec4068083ed8aca02174d5fb736c2ebd9a62f7bb82041cdaf23b86066/ker_dict_tools-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "2087b0e173075608c3ded283681592b1", "sha256": "651288c025f667026b31d31b9139af7fec69556fa41d90955bbc70e8e82d109e"}, "downloads": -1, "filename": "ker_dict_tools-0.1.1.tar.gz", "has_sig": false, "md5_digest": "2087b0e173075608c3ded283681592b1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13036, "upload_time": "2018-10-17T20:01:11", "upload_time_iso_8601": "2018-10-17T20:01:11.025436Z", "url": "https://files.pythonhosted.org/packages/13/1a/d2fd5f7de4b28e6e962d490c1bb21679086510e780c65dba535d173de197/ker_dict_tools-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2087b0e173075608c3ded283681592b1", "sha256": "651288c025f667026b31d31b9139af7fec69556fa41d90955bbc70e8e82d109e"}, "downloads": -1, "filename": "ker_dict_tools-0.1.1.tar.gz", "has_sig": false, "md5_digest": "2087b0e173075608c3ded283681592b1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13036, "upload_time": "2018-10-17T20:01:11", "upload_time_iso_8601": "2018-10-17T20:01:11.025436Z", "url": "https://files.pythonhosted.org/packages/13/1a/d2fd5f7de4b28e6e962d490c1bb21679086510e780c65dba535d173de197/ker_dict_tools-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:50:07 2020"}