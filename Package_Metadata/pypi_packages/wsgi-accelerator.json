{"info": {"author": "Carl Bystr\u00f6m", "author_email": "cgbystrom@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "================\nwsgi-accelerator\n================\n\n\nSimple HTTP cache for Python/WSGI applications with fine-grained invalidation.\n\nEnables caching of HTTP resources in your application with smart control of invalidation through tags.\nIf you know what invalidates your cache entries and have a relatively low turn over (e.g your reads outnumbers your writes)\nyou can benefit greatly from wsgi-accelerator. See Use-case section for a more detailed description.\n\nCaching at the HTTP level is really powerful since it allows you to cache responses that already are\nrendered/serialized and compressed, ready to be sent without additional computation for each request.\n\n********\nFeatures\n********\n\n* Cache read-heavy URLs\n* ETag support\n* Fine-grained, tag-based cache invalidation\n* Time-based cache invalidation (ala Cache-Control)\n* Pluggable cache stores - In-memory and Redis store included\n* Super simple and hackable - less than 200 LOC excluding tests\n* MIT licensed\n\n***************\nGetting started\n***************\n\nRight now wsgi-accelerator is not available through PyPI as it is still receiving tweaks.\nBut after that it will be the normal ``pip install`` scenario.\n\nOnce you installed it you can enable it with the default in-memory store like this:\n\n.. code-block:: python\n\n  from accelerator import WSGIAccelerator\n\n  def app(environ, start_response):\n      response_body = 'Hello World'\n      status = '200 OK'\n\n      response_headers = [\n          ('Content-Type', 'text/plain'),\n          ('Content-Length', str(len(response_body)))\n      ]\n\n      environ['accelerator.cache_for'] = 5 # Cache for five seconds\n      environ['accelerator.tags'] = ['foo', 'bar']\n      start_response(status, response_headers)\n      return [response_body]\n\n  app = WSGIAccelerator(app)\n\n  # To invalidate the response generated by the WSGI app above, just call:\n  app.invalidate_tag(['foo'])\n\n  # This will trigger invalidation of that URL path + query since it was\n  # tagged when the response was generated.\n\n\nPlease note that the in-memory store is not intended for production use.\nIt is merely for testing and to serve as a correct reference implementation.\n\nMaybe it goes without saying but all responses cached through wsgi-accelerator must NOT contain user-specific data at all.\n\n********\nUse-case\n********\n\nImagine you have a popular site with lots of users and social feature. Having a popular site also means you serve quite a lot of traffic,\nmeaning large costs in terms of hardware and bandwidth. One of the reasons for this is that you usually need to serve fresh content every HTTP\nfrom your servers since that could have been changed.\n\nOther sites that also are high-traffic but more static in nature, such as Wikipedia or newspaper, usually reach for an HTTP cache like Varnish to help cope with this problem.\nThis works incredibly well and can lessen CPU load quite significantly.\nIt is also worth noting that caching only realizes it's full potential when reads outnumbers expensive writes.\n\nBut for a dynamic site with more user-generated content, caching is usually a lot trickier if not impossible at an HTTP level.\nSo most caching end up taking place at the \"business/domain logic\" level inside the application. Such caching really do help a lot\nfor saving resources but still requires each HTTP request to trigger code paths deep in your application resulting burned CPU cycles.\n\nA good solution to this problem would be to enable HTTP-level caching of volatile, user-generated content.\nAnd that's where wsgi-accelerator comes in :)\n\nAn example\n----------\nOn this imaginary site, we have user profile page similar to this:\n\n.. image:: http://cgbystrom.com/static/img/profile_page.png\n\nWhere each yellow bubble represents data sources making up the final page.\n\nIf we were to cache this page through traditional means, it would go stale as soon as the user did an action that changed any of the above.\nClearly less than optimal.\nBut the good thing is that we know exactly when those actions can and will take place. By using this information we could make sure to invalidate\nthe cache entry for that page as soon as the user trigger any of those events.\nSo the next time that page is loaded it would hit the application as normal, getting rendered and cached with the new changed data.\nThis concept of having fine-grained ways of triggering invalidation of content residing in the cache enables you to cache entire HTTP responses without the risk of serving stale data.\n\nAnd with this being a normal WSGI middleware, no extra servers/proxies are needed except for a possible backing cache store.\n\n*******\nLicense\n*******\n\nOpen source licensed under the MIT license (see LICENSE file for details).\n\n\nIf you find this idea and library useful, please let me know.\nWould love to hear your story and use-case.\n\n`Carl Bystr\u00f6m <http://cgbystrom.com/>`_ (`@cgbystrom <http://twitter.com/cgbystrom>`_)", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/cgbystrom/wsgi-accelerator", "keywords": null, "license": "The MIT License\r\n\r\nCopyright (c) 2013 Carl Bystr\u00f6m\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.", "maintainer": null, "maintainer_email": null, "name": "wsgi-accelerator", "package_url": "https://pypi.org/project/wsgi-accelerator/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/wsgi-accelerator/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/cgbystrom/wsgi-accelerator"}, "release_url": "https://pypi.org/project/wsgi-accelerator/0.1.0/", "requires_dist": null, "requires_python": null, "summary": "Simple HTTP cache for WSGI apps with fine-grained invalidation", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Simple HTTP cache for Python/WSGI applications with fine-grained invalidation.</p>\n<p>Enables caching of HTTP resources in your application with smart control of invalidation through tags.\nIf you know what invalidates your cache entries and have a relatively low turn over (e.g your reads outnumbers your writes)\nyou can benefit greatly from wsgi-accelerator. See Use-case section for a more detailed description.</p>\n<p>Caching at the HTTP level is really powerful since it allows you to cache responses that already are\nrendered/serialized and compressed, ready to be sent without additional computation for each request.</p>\n<div id=\"features\">\n<h2>Features</h2>\n<ul>\n<li>Cache read-heavy URLs</li>\n<li>ETag support</li>\n<li>Fine-grained, tag-based cache invalidation</li>\n<li>Time-based cache invalidation (ala Cache-Control)</li>\n<li>Pluggable cache stores - In-memory and Redis store included</li>\n<li>Super simple and hackable - less than 200 LOC excluding tests</li>\n<li>MIT licensed</li>\n</ul>\n</div>\n<div id=\"getting-started\">\n<h2>Getting started</h2>\n<p>Right now wsgi-accelerator is not available through PyPI as it is still receiving tweaks.\nBut after that it will be the normal <tt>pip install</tt> scenario.</p>\n<p>Once you installed it you can enable it with the default in-memory store like this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">accelerator</span> <span class=\"kn\">import</span> <span class=\"n\">WSGIAccelerator</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">app</span><span class=\"p\">(</span><span class=\"n\">environ</span><span class=\"p\">,</span> <span class=\"n\">start_response</span><span class=\"p\">):</span>\n    <span class=\"n\">response_body</span> <span class=\"o\">=</span> <span class=\"s1\">'Hello World'</span>\n    <span class=\"n\">status</span> <span class=\"o\">=</span> <span class=\"s1\">'200 OK'</span>\n\n    <span class=\"n\">response_headers</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n        <span class=\"p\">(</span><span class=\"s1\">'Content-Type'</span><span class=\"p\">,</span> <span class=\"s1\">'text/plain'</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"s1\">'Content-Length'</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">response_body</span><span class=\"p\">)))</span>\n    <span class=\"p\">]</span>\n\n    <span class=\"n\">environ</span><span class=\"p\">[</span><span class=\"s1\">'accelerator.cache_for'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">5</span> <span class=\"c1\"># Cache for five seconds</span>\n    <span class=\"n\">environ</span><span class=\"p\">[</span><span class=\"s1\">'accelerator.tags'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"s1\">'bar'</span><span class=\"p\">]</span>\n    <span class=\"n\">start_response</span><span class=\"p\">(</span><span class=\"n\">status</span><span class=\"p\">,</span> <span class=\"n\">response_headers</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">response_body</span><span class=\"p\">]</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">WSGIAccelerator</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># To invalidate the response generated by the WSGI app above, just call:</span>\n<span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">invalidate_tag</span><span class=\"p\">([</span><span class=\"s1\">'foo'</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># This will trigger invalidation of that URL path + query since it was</span>\n<span class=\"c1\"># tagged when the response was generated.</span>\n</pre>\n<p>Please note that the in-memory store is not intended for production use.\nIt is merely for testing and to serve as a correct reference implementation.</p>\n<p>Maybe it goes without saying but all responses cached through wsgi-accelerator must NOT contain user-specific data at all.</p>\n</div>\n<div id=\"use-case\">\n<h2>Use-case</h2>\n<p>Imagine you have a popular site with lots of users and social feature. Having a popular site also means you serve quite a lot of traffic,\nmeaning large costs in terms of hardware and bandwidth. One of the reasons for this is that you usually need to serve fresh content every HTTP\nfrom your servers since that could have been changed.</p>\n<p>Other sites that also are high-traffic but more static in nature, such as Wikipedia or newspaper, usually reach for an HTTP cache like Varnish to help cope with this problem.\nThis works incredibly well and can lessen CPU load quite significantly.\nIt is also worth noting that caching only realizes it\u2019s full potential when reads outnumbers expensive writes.</p>\n<p>But for a dynamic site with more user-generated content, caching is usually a lot trickier if not impossible at an HTTP level.\nSo most caching end up taking place at the \u201cbusiness/domain logic\u201d level inside the application. Such caching really do help a lot\nfor saving resources but still requires each HTTP request to trigger code paths deep in your application resulting burned CPU cycles.</p>\n<p>A good solution to this problem would be to enable HTTP-level caching of volatile, user-generated content.\nAnd that\u2019s where wsgi-accelerator comes in :)</p>\n<div id=\"an-example\">\n<h3>An example</h3>\n<p>On this imaginary site, we have user profile page similar to this:</p>\n<img alt=\"http://cgbystrom.com/static/img/profile_page.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/11a03a2c2352075eba5c286eebca8f31c7ca5167/687474703a2f2f636762797374726f6d2e636f6d2f7374617469632f696d672f70726f66696c655f706167652e706e67\">\n<p>Where each yellow bubble represents data sources making up the final page.</p>\n<p>If we were to cache this page through traditional means, it would go stale as soon as the user did an action that changed any of the above.\nClearly less than optimal.\nBut the good thing is that we know exactly when those actions can and will take place. By using this information we could make sure to invalidate\nthe cache entry for that page as soon as the user trigger any of those events.\nSo the next time that page is loaded it would hit the application as normal, getting rendered and cached with the new changed data.\nThis concept of having fine-grained ways of triggering invalidation of content residing in the cache enables you to cache entire HTTP responses without the risk of serving stale data.</p>\n<p>And with this being a normal WSGI middleware, no extra servers/proxies are needed except for a possible backing cache store.</p>\n</div>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>Open source licensed under the MIT license (see LICENSE file for details).</p>\n<p>If you find this idea and library useful, please let me know.\nWould love to hear your story and use-case.</p>\n<p><a href=\"http://cgbystrom.com/\" rel=\"nofollow\">Carl Bystr\u00f6m</a> (<a href=\"http://twitter.com/cgbystrom\" rel=\"nofollow\">@cgbystrom</a>)</p>\n</div>\n\n          </div>"}, "last_serial": 900074, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "6d529f08fd1001e72d86c7f4de74b0ee", "sha256": "83f2448b25ab94bac6d659fba3fd97c24cbe742e21f93172ed5641650cc50521"}, "downloads": -1, "filename": "wsgi-accelerator-0.1.0.tar.gz", "has_sig": false, "md5_digest": "6d529f08fd1001e72d86c7f4de74b0ee", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8113, "upload_time": "2013-10-21T19:50:37", "upload_time_iso_8601": "2013-10-21T19:50:37.448760Z", "url": "https://files.pythonhosted.org/packages/43/93/0c4d45619e2ec0643ce33b5dd0e1752df0962d3b73d1bd8d72b4f4b87fee/wsgi-accelerator-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6d529f08fd1001e72d86c7f4de74b0ee", "sha256": "83f2448b25ab94bac6d659fba3fd97c24cbe742e21f93172ed5641650cc50521"}, "downloads": -1, "filename": "wsgi-accelerator-0.1.0.tar.gz", "has_sig": false, "md5_digest": "6d529f08fd1001e72d86c7f4de74b0ee", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8113, "upload_time": "2013-10-21T19:50:37", "upload_time_iso_8601": "2013-10-21T19:50:37.448760Z", "url": "https://files.pythonhosted.org/packages/43/93/0c4d45619e2ec0643ce33b5dd0e1752df0962d3b73d1bd8d72b4f4b87fee/wsgi-accelerator-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:27:09 2020"}