{"info": {"author": "Brian Jay Stanley", "author_email": "brian@brianjaystanley.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Framework :: Django", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Internet :: WWW/HTTP :: Dynamic Content", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "``django-cachetree`` provides caching of configurable trees of related model\ninstances in Django. For example, with ``django-cachetree`` you could easily\ncache a user instance and the user's photos and comments on a photo-sharing\nsite as a single item in the cache. When a user is fetched from the database,\nits related objects are \"prefetched\" before the user object is set in the\ncache. This means that when you retrieve the user object from the cache, the\nrelated objects are there with it and you can access them without hitting the\ndatabase (or hitting the cache again)::\n\n    user = User.objects.get_cached(pk=1) # user not yet in cache, hits the \n                                         # database and prefetches related objects\n\n    ....\n    \n    user = User.objects.get_cached(pk=1) # hits the cache\n    photos = user.photo_set.all()\n    print photos[0].title # doesn't hit database or cache\n    comments = user.comment_set.all()\n    print comments[0].date # doesn't hit database or cache\n\nYou can configure ``django-cachetree`` to cache related objects of related\nobjects of related objects, to any depth. For example, on a blog, you could\ncache author objects along with their set of blog entries, the set of comments\nfor each of those entries, and the commenter for each of those comments.\n\n``django-cachetree`` automatically invalidates cached objects when they or the\nrelated objects cached with them are changed, deleted, or created.\n\nRequirements \n============ \n``django-cachetree`` requires Django 1.3 and Python 2.5, 2.6, or 2.7.\n\nInstallation\n============\nYou can install ``django-cachetree`` with ::\n\n    pip install django-cachetree\n\nor ::\n\n    easy_install django-cachetree\n\nThis will add ``cachetree`` to your Python path. Add ``'cachetree'`` to your ``INSTALLED_APPS``, and add ``'cachetree.middleware.InstallCachetree'`` to your middleware classes. This will add a ``get_cached`` method to\nthe default manager for each of your cached models. (Note that because\n``get_cached`` is added to the manager class, it will be available on all\ninstances of that manager class. However, attempting to use it on a model not defined in your ``CACHETREE`` setting will raise a ``ValueError``.) If\ninvalidation is enabled, ``cachetree.install()`` also registers signal\nhandlers that are used for invalidation.\n\nInstalling ``cachetree`` via middleware will only work if there is a page request to trigger the middleware. To install and use ``cachetree`` outside of a request-response context (for example, in a test suite), run ::\n\n    cachetree.install()\n    \nin your testrunner or at the bottom of your models file. \n\n\nThe ``CACHETREE`` setting\n=================================\nTo use ``django-cachetree``, add a ``CACHETREE`` setting to ``settings.py``.\nThe ``CACHETREE`` setting consists of nested dictionaries that tell\n``django-cachetree`` what to cache. The keys in the topmost dictionary should\ncontain the ``app_label`` for each app that has models you wish to cache. Each\n``app_label``'s dictionary should contain a key with the class name (as a\nstring) for each cached model in the app. These are the models whose managers\nwill provide a ``get_cached`` method, and are known as \"root models\" in\n``django-cachetree``'s terminology. For example, to cache ``Author`` and\n``Entry`` models but none of their related objects in an app called ``myapp``,\nyou would write::\n\n    CACHETREE = {\n        \"myapp\": {\n            \"Author\": {},\n            \"Entry\": {},\n        }\n    }\n\nThe dictionary for each root model can contain three optional keys,\n``\"timeout\"``, ``\"lookups\"``, and ``\"prefetch\"``.\n\n``timeout`` \n    The timeout, in seconds, to use when caching instances of this model.\n    Overrides your global timeout setting in ``CACHES``.\n    \n``lookups``\n    A tuple containing the field names that can be used as kwargs when calling\n    ``get_cached`` for this model. By default, lookups are allowed by primary\n    key. If your model's primary key field is ``id``, the default setting\n    would be ``(\"pk\", \"id\")``.\n \n    To lookup by a combination of fields, include the field names as a tuple\n    within your ``lookups`` tuple. For example, to look up ``User`` instances\n    by ``id`` or by ``first_name`` and ``last_name``::\n\n        CACHETREE = {\n            \"auth\": {\n                \"User\": {\n                    \"lookups\": (\n                        \"id\",\n                        (\"first_name\", \"last_name\"),\n                    )\n                }\n            }\n        }\n    \n    If invalidation is enabled, lookups are restricted to fields defined on\n    the model, including ``ForeignKey`` fields and ``OneToOneField``\\s but\n    excluding ``ManyToManyField``\\s. Specifying ``ManyToManyField``\\s or\n    reverse ``ForeignKey`` or ``OneToOneField``\\s will raise\n    ``cachetree.ImproperlyConfigured``. Lookup separators (for example,\n    ``username__contains``) are also not allowed and will raise\n    ``ImproperlyConfigured``. To know what keys to invalidate,\n    ``django-cachetree`` requires exact lookups (which is the default when no\n    lookup separator is used).\n    \n``prefetch``\n    A dictionary specifying the tree of related objects to prefetch and cache\n    with the root model instance. Each key should be the attribute name (as a\n    string) of the related instance(s) to be prefetched. Each key's value\n    should be a dictionary of attribute names to prefetch on the related\n    instance(s), or an empty dictionary (or ``None``) if no further\n    relationships should be prefetched. Any relationship can be prefetched:\n    ``OneToOneField``, ``ForeignKey``, and ``ManyToManyField``, forward or\n    reverse. For example, to cache author objects, their set of entries, those\n    entries' comments, and each comment's commenter, you might write::\n\n        CACHETREE = {\n            \"myapp\": {\n                \"Author\": {\n                    \"lookups\": (\n                        \"pk\",\n                        \"id\",\n                        (\"first_name\", \"last_name\"),\n                    ),\n                    \"prefetch\": {\n                        \"entry_set\": {\n                            \"comment_set\": {\n                                \"commenter\": {},\n                            },\n                        },\n                    },\n                },\n            },\n        }\n    \n    The above example assumes that each ``Author`` object is related to its\n    entries by an ``entry_set`` attribute, each entry object is related to its\n    comments by a ``comment_set`` attribute, and each comment object relates\n    to its commenter by a ``commenter`` field. \n    \n    If invalidation is enabled, there is one restriction on prefetching. If\n    you prefetch a ``ManyToManyField`` (forward or reverse) that defines a\n    custom intermediary model (as specified with the ``through`` argument on\n    the model field definition), you must also prefetch the attribute that\n    points to the intermediary instances. For example, if you have an\n    ``Entry`` model related to a ``Category`` model through a custom\n    intermediary model called ``EntryCategory``, and you prefetch\n    ``Entry.categories`` (a ``ManyToManyField``), you must also prefetch the\n    ``Entry.entrycategory_set`` attribute that Django adds to your ``Entry``\n    model, or ``ImproperlyConfigured`` will be raised.\n    \nYou can find example ``CACHETREE`` settings in ``django-cachetree``'s test\nmodule, which defines models and settings covering all possible relationships.\n\nPrefetching ``ManyToManyField``\\s and Reverse ``ForeignKey``\\s\n==============================================================\nWhen you configure ``django-cachetree`` to cache a ``ManyToManyField`` or\nreverse ``ForeignKey``, such as ``user.photo_set`` (where ``Photo`` has a\nforeign key to ``User``), ``django-cachetree`` calls ``user.photo_set.all()``,\nevaluates the queryset, and caches the results on the ``user`` when\nprefetching. Subsequent calls to ``user.photo_set.all()`` will return the\ncached results, rather than returning a new queryset (which would require\nhitting the database again to evaluate). ``django-cachetree`` patches the manager on\n``ManyToManyField`` and ``ForeignKey`` descriptors to make this behavior\npossible. However, only the ``all()`` method is patched. If you call\n``user.photo_set.count()`` or ``user.photo_set.filter()`` or any other method\nbesides ``all()``, you will bypass the cached results and hit the database.\nAssuming your object set is not huge, you can avoid hitting the database by\ncalling ``all()`` and counting or filtering the results within your code.\n\nHow Invalidation Works\n======================\nWhen you call ``cachetree.install()``, ``django-cachetree`` analyzes your\n``CACHETREE`` setting and determines which relationships must be followed in\norder to traverse the tree backwards from prefetched related instances to\ntheir root model instances. Using this information, whenever a model defined\nin your ``CACHETREE`` setting (either as a root model or as a prefetched\nrelationship) is created, saved, or deleted (and in the case of\n``ManyToManyField``\\s and reverse ``ForeignKey``\\s, added, removed, or cleared\nusing the field manager's ``add()``, ``remove()``, or ``clear()`` methods),\n``django-cachetree`` traverses its relationships back to the root model\ninstance(s) that need to be invalidated. ``django-cachetree`` uses a\n``post_init`` signal handler to keep track of each instance's initial state,\nand when the instance changes and is saved, ``django-cachetree`` follows both\nthe instance's new and initial values to find the root model instances that\nneed to be invalidated. For example, if you cache ``Author`` objects along\nwith their ``entry_set``, and you change an ``Entry`` object's author,\n``django-cachetree`` will invalidate both the new and the initial ``Author``\nobjects for that entry.\n\n**Important Caveat**: ``django-cachetree`` does not perform invalidation when\nyou run an ``UPDATE`` query using a manager's ``update()`` method. You will\neither need to invalidate the affected instances yourself by calling\n``invalidate()`` (described below), rely on the cached objects to expire naturally,\nor avoid using ``update()``.\n    \nCachetree Authentication Backend\n================================\nIf ``django.contrib.auth`` is installed in your project, you can use\n``django-cachetree``'s authentication backend::\n\n    AUTHENTICATION_BACKENDS = (\n        \"cachetree.auth.CachedModelBackend\",\n    )\n\nThis will look in the cache before hitting the database when authenticating\nusers. Adding the ``auth.User`` model to your ``CACHETREE`` setting is\noptional. Not adding it implies the following settings::\n    \n    CACHETREE = {\n\n            ...\n            \n            \"auth\": {\n                \"User\": {\n                    \"lookups\":(\n                        \"pk\",\n                        \"username\",\n                    ),\n                },\n            },\n        }\n\nIf you wish to allow additional lookups on ``User`` or to prefetch related\ninstances, explicitly define ``User`` in your ``CACHETREE`` setting.\n\nUtils\n=====\nThe following functions can be imported from ``cachetree``:\n\n``get_cached_object_or_404``\n    Works like ``get_object_or_404``, but uses ``get_cached`` instead of ``get``. \n    \n``invalidate(*instances)``\n    Traverses relationships on each of the ``instances`` to find and invalidate\n    its root model instance(s).\n\n``no_invalidation``\n    Decorator that disables invalidation for the duration of the function it decorates.\n\nAdditional Settings\n===================\n``CACHETREE_DISABLE``\n    Set to ``True`` to disable ``django-cachetree``. Calls to ``get_cached()``\n    or ``get_cached_object_or_404()`` will use ``get()``. Calls to\n    ``invalidate()`` and uses of the ``no_invalidation`` decorator will have\n    no effect. This allows you to temporarily disable ``django-cachetree``\n    without modifying any code. Default: ``False``.\n\n``CACHETREE_INVALIDATE``\n    Set to ``False`` to disable invalidation. ``django-cachetree`` will\n    continue to cache model objects but will not invalidate them when they\n    change. Calls to ``invalidate()`` and uses of the ``no_invalidation``\n    decorator will have no effect. Default: ``True``.\n\n``CACHETREE_MANY_RELATED_PREFIX``\n    Controls the prefix ``django-cachetree`` uses when it prefetches a set of\n    related objects and caches it on a model instance. In the example of\n    ``author.entry_set.all()``, ``django-cachetree`` caches the author's set\n    of entries as ``author._cached_entry_set``, and subsequent calls to\n    ``author.entry_set.all()`` return this attribute. Normally you will not\n    need to access this attribute directly, but this setting allows you to\n    change the prefix in case of name conflicts. Default: ``_cached_``.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/brianjaystanley/django-cachetree", "keywords": "django cache", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "django-cachetree", "package_url": "https://pypi.org/project/django-cachetree/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/django-cachetree/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/brianjaystanley/django-cachetree"}, "release_url": "https://pypi.org/project/django-cachetree/0.1.3/", "requires_dist": null, "requires_python": null, "summary": "cache configurable trees of related model instances in Django", "version": "0.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><tt><span class=\"pre\">django-cachetree</span></tt> provides caching of configurable trees of related model\ninstances in Django. For example, with <tt><span class=\"pre\">django-cachetree</span></tt> you could easily\ncache a user instance and the user\u2019s photos and comments on a photo-sharing\nsite as a single item in the cache. When a user is fetched from the database,\nits related objects are \u201cprefetched\u201d before the user object is set in the\ncache. This means that when you retrieve the user object from the cache, the\nrelated objects are there with it and you can access them without hitting the\ndatabase (or hitting the cache again):</p>\n<pre>user = User.objects.get_cached(pk=1) # user not yet in cache, hits the\n                                     # database and prefetches related objects\n\n....\n\nuser = User.objects.get_cached(pk=1) # hits the cache\nphotos = user.photo_set.all()\nprint photos[0].title # doesn't hit database or cache\ncomments = user.comment_set.all()\nprint comments[0].date # doesn't hit database or cache\n</pre>\n<p>You can configure <tt><span class=\"pre\">django-cachetree</span></tt> to cache related objects of related\nobjects of related objects, to any depth. For example, on a blog, you could\ncache author objects along with their set of blog entries, the set of comments\nfor each of those entries, and the commenter for each of those comments.</p>\n<p><tt><span class=\"pre\">django-cachetree</span></tt> automatically invalidates cached objects when they or the\nrelated objects cached with them are changed, deleted, or created.</p>\n<div id=\"requirements\">\n<h2>Requirements</h2>\n<p><tt><span class=\"pre\">django-cachetree</span></tt> requires Django 1.3 and Python 2.5, 2.6, or 2.7.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>You can install <tt><span class=\"pre\">django-cachetree</span></tt> with</p>\n<pre>pip install django-cachetree\n</pre>\n<p>or</p>\n<pre>easy_install django-cachetree\n</pre>\n<p>This will add <tt>cachetree</tt> to your Python path. Add <tt>'cachetree'</tt> to your <tt>INSTALLED_APPS</tt>, and add <tt>'cachetree.middleware.InstallCachetree'</tt> to your middleware classes. This will add a <tt>get_cached</tt> method to\nthe default manager for each of your cached models. (Note that because\n<tt>get_cached</tt> is added to the manager class, it will be available on all\ninstances of that manager class. However, attempting to use it on a model not defined in your <tt>CACHETREE</tt> setting will raise a <tt>ValueError</tt>.) If\ninvalidation is enabled, <tt>cachetree.install()</tt> also registers signal\nhandlers that are used for invalidation.</p>\n<p>Installing <tt>cachetree</tt> via middleware will only work if there is a page request to trigger the middleware. To install and use <tt>cachetree</tt> outside of a request-response context (for example, in a test suite), run</p>\n<pre>cachetree.install()\n</pre>\n<p>in your testrunner or at the bottom of your models file.</p>\n</div>\n<div id=\"the-cachetree-setting\">\n<h2>The <tt>CACHETREE</tt> setting</h2>\n<p>To use <tt><span class=\"pre\">django-cachetree</span></tt>, add a <tt>CACHETREE</tt> setting to <tt>settings.py</tt>.\nThe <tt>CACHETREE</tt> setting consists of nested dictionaries that tell\n<tt><span class=\"pre\">django-cachetree</span></tt> what to cache. The keys in the topmost dictionary should\ncontain the <tt>app_label</tt> for each app that has models you wish to cache. Each\n<tt>app_label</tt>\u2019s dictionary should contain a key with the class name (as a\nstring) for each cached model in the app. These are the models whose managers\nwill provide a <tt>get_cached</tt> method, and are known as \u201croot models\u201d in\n<tt><span class=\"pre\">django-cachetree</span></tt>\u2019s terminology. For example, to cache <tt>Author</tt> and\n<tt>Entry</tt> models but none of their related objects in an app called <tt>myapp</tt>,\nyou would write:</p>\n<pre>CACHETREE = {\n    \"myapp\": {\n        \"Author\": {},\n        \"Entry\": {},\n    }\n}\n</pre>\n<p>The dictionary for each root model can contain three optional keys,\n<tt>\"timeout\"</tt>, <tt>\"lookups\"</tt>, and <tt>\"prefetch\"</tt>.</p>\n<dl>\n<dt><tt>timeout</tt></dt>\n<dd>The timeout, in seconds, to use when caching instances of this model.\nOverrides your global timeout setting in <tt>CACHES</tt>.</dd>\n<dt><tt>lookups</tt></dt>\n<dd><p>A tuple containing the field names that can be used as kwargs when calling\n<tt>get_cached</tt> for this model. By default, lookups are allowed by primary\nkey. If your model\u2019s primary key field is <tt>id</tt>, the default setting\nwould be <tt>(\"pk\", \"id\")</tt>.</p>\n<p>To lookup by a combination of fields, include the field names as a tuple\nwithin your <tt>lookups</tt> tuple. For example, to look up <tt>User</tt> instances\nby <tt>id</tt> or by <tt>first_name</tt> and <tt>last_name</tt>:</p>\n<pre>CACHETREE = {\n    \"auth\": {\n        \"User\": {\n            \"lookups\": (\n                \"id\",\n                (\"first_name\", \"last_name\"),\n            )\n        }\n    }\n}\n</pre>\n<p>If invalidation is enabled, lookups are restricted to fields defined on\nthe model, including <tt>ForeignKey</tt> fields and <tt>OneToOneField</tt>s but\nexcluding <tt>ManyToManyField</tt>s. Specifying <tt>ManyToManyField</tt>s or\nreverse <tt>ForeignKey</tt> or <tt>OneToOneField</tt>s will raise\n<tt>cachetree.ImproperlyConfigured</tt>. Lookup separators (for example,\n<tt>username__contains</tt>) are also not allowed and will raise\n<tt>ImproperlyConfigured</tt>. To know what keys to invalidate,\n<tt><span class=\"pre\">django-cachetree</span></tt> requires exact lookups (which is the default when no\nlookup separator is used).</p>\n</dd>\n<dt><tt>prefetch</tt></dt>\n<dd><p>A dictionary specifying the tree of related objects to prefetch and cache\nwith the root model instance. Each key should be the attribute name (as a\nstring) of the related instance(s) to be prefetched. Each key\u2019s value\nshould be a dictionary of attribute names to prefetch on the related\ninstance(s), or an empty dictionary (or <tt>None</tt>) if no further\nrelationships should be prefetched. Any relationship can be prefetched:\n<tt>OneToOneField</tt>, <tt>ForeignKey</tt>, and <tt>ManyToManyField</tt>, forward or\nreverse. For example, to cache author objects, their set of entries, those\nentries\u2019 comments, and each comment\u2019s commenter, you might write:</p>\n<pre>CACHETREE = {\n    \"myapp\": {\n        \"Author\": {\n            \"lookups\": (\n                \"pk\",\n                \"id\",\n                (\"first_name\", \"last_name\"),\n            ),\n            \"prefetch\": {\n                \"entry_set\": {\n                    \"comment_set\": {\n                        \"commenter\": {},\n                    },\n                },\n            },\n        },\n    },\n}\n</pre>\n<p>The above example assumes that each <tt>Author</tt> object is related to its\nentries by an <tt>entry_set</tt> attribute, each entry object is related to its\ncomments by a <tt>comment_set</tt> attribute, and each comment object relates\nto its commenter by a <tt>commenter</tt> field.</p>\n<p>If invalidation is enabled, there is one restriction on prefetching. If\nyou prefetch a <tt>ManyToManyField</tt> (forward or reverse) that defines a\ncustom intermediary model (as specified with the <tt>through</tt> argument on\nthe model field definition), you must also prefetch the attribute that\npoints to the intermediary instances. For example, if you have an\n<tt>Entry</tt> model related to a <tt>Category</tt> model through a custom\nintermediary model called <tt>EntryCategory</tt>, and you prefetch\n<tt>Entry.categories</tt> (a <tt>ManyToManyField</tt>), you must also prefetch the\n<tt>Entry.entrycategory_set</tt> attribute that Django adds to your <tt>Entry</tt>\nmodel, or <tt>ImproperlyConfigured</tt> will be raised.</p>\n</dd>\n</dl>\n<p>You can find example <tt>CACHETREE</tt> settings in <tt><span class=\"pre\">django-cachetree</span></tt>\u2019s test\nmodule, which defines models and settings covering all possible relationships.</p>\n</div>\n<div id=\"prefetching-manytomanyfields-and-reverse-foreignkeys\">\n<h2>Prefetching <tt>ManyToManyField</tt>s and Reverse <tt>ForeignKey</tt>s</h2>\n<p>When you configure <tt><span class=\"pre\">django-cachetree</span></tt> to cache a <tt>ManyToManyField</tt> or\nreverse <tt>ForeignKey</tt>, such as <tt>user.photo_set</tt> (where <tt>Photo</tt> has a\nforeign key to <tt>User</tt>), <tt><span class=\"pre\">django-cachetree</span></tt> calls <tt>user.photo_set.all()</tt>,\nevaluates the queryset, and caches the results on the <tt>user</tt> when\nprefetching. Subsequent calls to <tt>user.photo_set.all()</tt> will return the\ncached results, rather than returning a new queryset (which would require\nhitting the database again to evaluate). <tt><span class=\"pre\">django-cachetree</span></tt> patches the manager on\n<tt>ManyToManyField</tt> and <tt>ForeignKey</tt> descriptors to make this behavior\npossible. However, only the <tt>all()</tt> method is patched. If you call\n<tt>user.photo_set.count()</tt> or <tt>user.photo_set.filter()</tt> or any other method\nbesides <tt>all()</tt>, you will bypass the cached results and hit the database.\nAssuming your object set is not huge, you can avoid hitting the database by\ncalling <tt>all()</tt> and counting or filtering the results within your code.</p>\n</div>\n<div id=\"how-invalidation-works\">\n<h2>How Invalidation Works</h2>\n<p>When you call <tt>cachetree.install()</tt>, <tt><span class=\"pre\">django-cachetree</span></tt> analyzes your\n<tt>CACHETREE</tt> setting and determines which relationships must be followed in\norder to traverse the tree backwards from prefetched related instances to\ntheir root model instances. Using this information, whenever a model defined\nin your <tt>CACHETREE</tt> setting (either as a root model or as a prefetched\nrelationship) is created, saved, or deleted (and in the case of\n<tt>ManyToManyField</tt>s and reverse <tt>ForeignKey</tt>s, added, removed, or cleared\nusing the field manager\u2019s <tt>add()</tt>, <tt>remove()</tt>, or <tt>clear()</tt> methods),\n<tt><span class=\"pre\">django-cachetree</span></tt> traverses its relationships back to the root model\ninstance(s) that need to be invalidated. <tt><span class=\"pre\">django-cachetree</span></tt> uses a\n<tt>post_init</tt> signal handler to keep track of each instance\u2019s initial state,\nand when the instance changes and is saved, <tt><span class=\"pre\">django-cachetree</span></tt> follows both\nthe instance\u2019s new and initial values to find the root model instances that\nneed to be invalidated. For example, if you cache <tt>Author</tt> objects along\nwith their <tt>entry_set</tt>, and you change an <tt>Entry</tt> object\u2019s author,\n<tt><span class=\"pre\">django-cachetree</span></tt> will invalidate both the new and the initial <tt>Author</tt>\nobjects for that entry.</p>\n<p><strong>Important Caveat</strong>: <tt><span class=\"pre\">django-cachetree</span></tt> does not perform invalidation when\nyou run an <tt>UPDATE</tt> query using a manager\u2019s <tt>update()</tt> method. You will\neither need to invalidate the affected instances yourself by calling\n<tt>invalidate()</tt> (described below), rely on the cached objects to expire naturally,\nor avoid using <tt>update()</tt>.</p>\n</div>\n<div id=\"cachetree-authentication-backend\">\n<h2>Cachetree Authentication Backend</h2>\n<p>If <tt>django.contrib.auth</tt> is installed in your project, you can use\n<tt><span class=\"pre\">django-cachetree</span></tt>\u2019s authentication backend:</p>\n<pre>AUTHENTICATION_BACKENDS = (\n    \"cachetree.auth.CachedModelBackend\",\n)\n</pre>\n<p>This will look in the cache before hitting the database when authenticating\nusers. Adding the <tt>auth.User</tt> model to your <tt>CACHETREE</tt> setting is\noptional. Not adding it implies the following settings:</p>\n<pre>CACHETREE = {\n\n        ...\n\n        \"auth\": {\n            \"User\": {\n                \"lookups\":(\n                    \"pk\",\n                    \"username\",\n                ),\n            },\n        },\n    }\n</pre>\n<p>If you wish to allow additional lookups on <tt>User</tt> or to prefetch related\ninstances, explicitly define <tt>User</tt> in your <tt>CACHETREE</tt> setting.</p>\n</div>\n<div id=\"utils\">\n<h2>Utils</h2>\n<p>The following functions can be imported from <tt>cachetree</tt>:</p>\n<dl>\n<dt><tt>get_cached_object_or_404</tt></dt>\n<dd>Works like <tt>get_object_or_404</tt>, but uses <tt>get_cached</tt> instead of <tt>get</tt>.</dd>\n<dt><tt><span class=\"pre\">invalidate(*instances)</span></tt></dt>\n<dd>Traverses relationships on each of the <tt>instances</tt> to find and invalidate\nits root model instance(s).</dd>\n<dt><tt>no_invalidation</tt></dt>\n<dd>Decorator that disables invalidation for the duration of the function it decorates.</dd>\n</dl>\n</div>\n<div id=\"additional-settings\">\n<h2>Additional Settings</h2>\n<dl>\n<dt><tt>CACHETREE_DISABLE</tt></dt>\n<dd>Set to <tt>True</tt> to disable <tt><span class=\"pre\">django-cachetree</span></tt>. Calls to <tt>get_cached()</tt>\nor <tt>get_cached_object_or_404()</tt> will use <tt>get()</tt>. Calls to\n<tt>invalidate()</tt> and uses of the <tt>no_invalidation</tt> decorator will have\nno effect. This allows you to temporarily disable <tt><span class=\"pre\">django-cachetree</span></tt>\nwithout modifying any code. Default: <tt>False</tt>.</dd>\n<dt><tt>CACHETREE_INVALIDATE</tt></dt>\n<dd>Set to <tt>False</tt> to disable invalidation. <tt><span class=\"pre\">django-cachetree</span></tt> will\ncontinue to cache model objects but will not invalidate them when they\nchange. Calls to <tt>invalidate()</tt> and uses of the <tt>no_invalidation</tt>\ndecorator will have no effect. Default: <tt>True</tt>.</dd>\n<dt><tt>CACHETREE_MANY_RELATED_PREFIX</tt></dt>\n<dd>Controls the prefix <tt><span class=\"pre\">django-cachetree</span></tt> uses when it prefetches a set of\nrelated objects and caches it on a model instance. In the example of\n<tt>author.entry_set.all()</tt>, <tt><span class=\"pre\">django-cachetree</span></tt> caches the author\u2019s set\nof entries as <tt>author._cached_entry_set</tt>, and subsequent calls to\n<tt>author.entry_set.all()</tt> return this attribute. Normally you will not\nneed to access this attribute directly, but this setting allows you to\nchange the prefix in case of name conflicts. Default: <tt>_cached_</tt>.</dd>\n</dl>\n</div>\n\n          </div>"}, "last_serial": 1532909, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "7cb15bb1229f93bdf8799e3df1628a52", "sha256": "48eb9a97141fecc37b0aa44b9c74955ddd2cf026979367db6e17cf4c80a584aa"}, "downloads": -1, "filename": "django-cachetree-0.1.0.zip", "has_sig": false, "md5_digest": "7cb15bb1229f93bdf8799e3df1628a52", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37234, "upload_time": "2011-08-25T16:37:34", "upload_time_iso_8601": "2011-08-25T16:37:34.962494Z", "url": "https://files.pythonhosted.org/packages/07/ab/2feff628221a2b68a6371e5418fbcdb5ba19186dd9bb91005e83280ec228/django-cachetree-0.1.0.zip", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "032f1b883d540f907a08517d7d943e5b", "sha256": "0f4e69bc9b8066c79a249377d6f5e82a17ca013b78706957f56966d5b1af4c6b"}, "downloads": -1, "filename": "django-cachetree-0.1.1.zip", "has_sig": false, "md5_digest": "032f1b883d540f907a08517d7d943e5b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37361, "upload_time": "2011-08-30T17:49:33", "upload_time_iso_8601": "2011-08-30T17:49:33.672991Z", "url": "https://files.pythonhosted.org/packages/86/b2/5822d9f63f77bd51db3c6d59afdf39e468129dde21b894d3a0fbc0f75c72/django-cachetree-0.1.1.zip", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "dca070ce73fea27ea5ce7f09eb561561", "sha256": "e57a60375fdba0c94b5d79f1770eea34746947c703f9fbe4964e2c1a1fcac71d"}, "downloads": -1, "filename": "django-cachetree-0.1.2.zip", "has_sig": false, "md5_digest": "dca070ce73fea27ea5ce7f09eb561561", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37439, "upload_time": "2011-09-20T15:33:08", "upload_time_iso_8601": "2011-09-20T15:33:08.693065Z", "url": "https://files.pythonhosted.org/packages/ab/be/0001f22b386bfb530edebb6ab7613dd1d80e6ea752937901b8f5c1623325/django-cachetree-0.1.2.zip", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "6272d8c742ddebe28fc6c387b7df2fe9", "sha256": "9ac48a2fa23c492106510a19e80408b73adec7eac01257829ec3c79777165dca"}, "downloads": -1, "filename": "django-cachetree-0.1.3.zip", "has_sig": false, "md5_digest": "6272d8c742ddebe28fc6c387b7df2fe9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38447, "upload_time": "2015-05-04T19:01:19", "upload_time_iso_8601": "2015-05-04T19:01:19.169919Z", "url": "https://files.pythonhosted.org/packages/86/4b/3ebb6884437fabc8291ec9e6e592964a0183d610e8a75dfc74d97cb85632/django-cachetree-0.1.3.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6272d8c742ddebe28fc6c387b7df2fe9", "sha256": "9ac48a2fa23c492106510a19e80408b73adec7eac01257829ec3c79777165dca"}, "downloads": -1, "filename": "django-cachetree-0.1.3.zip", "has_sig": false, "md5_digest": "6272d8c742ddebe28fc6c387b7df2fe9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38447, "upload_time": "2015-05-04T19:01:19", "upload_time_iso_8601": "2015-05-04T19:01:19.169919Z", "url": "https://files.pythonhosted.org/packages/86/4b/3ebb6884437fabc8291ec9e6e592964a0183d610e8a75dfc74d97cb85632/django-cachetree-0.1.3.zip", "yanked": false}], "timestamp": "Fri May  8 00:37:16 2020"}