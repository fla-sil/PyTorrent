{"info": {"author": "Goncalo Pinheira", "author_email": "goncalopp+pybofh@quorumverita.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Intended Audience :: System Administrators", "License :: OSI Approved :: BSD License", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Topic :: System :: Clustering", "Topic :: System :: Filesystems", "Topic :: System :: Monitoring", "Topic :: System :: Systems Administration"], "description": "pybofh\n======\n\nA Linux system administration automation toolset.\n\nAbstracts common CLIs into python functions and classes.\n\nCurrent command modules:\n - blockdevice\n - btrfs\n - encryption (cryptsetup)\n - drbd\n - lvm\n - xen\n\nExample\n-------\n\nStart all Xen DomUs\n\n    from pybofh import xen\n\n    for domu in xen.allDomus():\n        if not xen.isDomuRunning(domu):\n            xen.startDomu( domu )\n\n\nFeatures\n========\n\nSite-specific configuration\n---------------------------\n\nCustomize `site_specific.py` to match your local environment\n\nAtomic operations\n-----------------\n\nHaving a automated administration tool that leaves a talk half-finished is worse than having no automated administration tool.\n\n`pybofh` supports context managers:\n\n\n    TMP_MNTS= [\"/media/tmp\", \"/media/tmp2\"]\n    mountpool= blockdevice.MountPool( TMP_MNTS )\n    with mountpool.mount( '/dev/sda1' ) as sda1_mountpoint:\n        #/dev/sda1 is now mounted\n        with mountpoint.mount( '/dev/sda2') as sda2_mountpoint:\n            #/dev/sda2 is now mounted\n            with mountpoint.mount( '/dev/sda3') as sda3_mountpoint:\n                #fails, no more mountpoints available\n                pass\n     #/dev/sda1 and /dev/sda2 are now unmounted\n     \nBut, of course, not all operations make sense as a context manager. Take, for example, creating a new VM from disk on LVM:\n\n    lvm.createLV(\"my_vg\", \"my_vm\", \"10gb\")\n    blockdevice.create_filesystem( '/dev/my_vg/my_vm')\n    #...\n\nWhat happens if `create_filesystem` fails? You'll may be left with a inconsistent filesystem on the LV. Worse, once you fix the problem and try to run this again, `createLV` will fail, because the LV is already there, so you'll have to either create the VM manually or fix your script.\n\nA context manager makes no sense in this case: you don't want to delete the LV if all operations succeed. You have to keep track of the operations you performed, and rollback if something fails. You could do that by hand, of course, but that's no fun:\n\n    with Atomic() as atomic:\n        atomic.lvm.createLV(\"my_vg\", \"my_vm\", \"10gb\")\n        blockdevice.create_filesystem( '/dev/my_vg/my_vm')\n\nNow, the LV will be deleted only *if **any** operation inside the context manager fails*. If you have multiple `atomic` calls, it will keep track of them, and rollback them in the reverse order they were executed on. \n\nWhile `Atomic` pre-packages some knowledge, `AtomicOperationSequence` is operation agnostic - it works by defining rollback functions:\n\n    def f1():\n        print \"f1 executed\"\n    \n    def reverse(f, args, kwargs):\n         if f==f1:\n             print \"f1 reversed\"\n    \n    with AtomicOperationSequence(reverse) as atomic:\n        atomic.f1()\n\nFAQ\n===\n\npybofh? What kind of name is that?\n----------------------------------\nIt's a tribute to the [Bastard Operator From Hell](http://en.wikipedia.org/wiki/Bastard_Operator_From_Hell) stories\n\nWhere does development happen?\n------------------------------\nhttps://github.com/goncalopp/pybofh\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/goncalopp/pybofh", "keywords": "linux sysadmin library toolset", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "pybofh", "package_url": "https://pypi.org/project/pybofh/", "platform": "", "project_url": "https://pypi.org/project/pybofh/", "project_urls": {"Homepage": "https://github.com/goncalopp/pybofh"}, "release_url": "https://pypi.org/project/pybofh/0.2.1/", "requires_dist": null, "requires_python": "", "summary": "A Linux system administration automation toolset", "version": "0.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            pybofh<br>======<br><br>A Linux system administration automation toolset.<br><br>Abstracts common CLIs into python functions and classes.<br><br>Current command modules:<br> - blockdevice<br> - btrfs<br> - encryption (cryptsetup)<br> - drbd<br> - lvm<br> - xen<br><br>Example<br>-------<br><br>Start all Xen DomUs<br><br>    from pybofh import xen<br><br>    for domu in xen.allDomus():<br>        if not xen.isDomuRunning(domu):<br>            xen.startDomu( domu )<br><br><br>Features<br>========<br><br>Site-specific configuration<br>---------------------------<br><br>Customize `site_specific.py` to match your local environment<br><br>Atomic operations<br>-----------------<br><br>Having a automated administration tool that leaves a talk half-finished is worse than having no automated administration tool.<br><br>`pybofh` supports context managers:<br><br><br>    TMP_MNTS= [\"/media/tmp\", \"/media/tmp2\"]<br>    mountpool= blockdevice.MountPool( TMP_MNTS )<br>    with mountpool.mount( '/dev/sda1' ) as sda1_mountpoint:<br>        #/dev/sda1 is now mounted<br>        with mountpoint.mount( '/dev/sda2') as sda2_mountpoint:<br>            #/dev/sda2 is now mounted<br>            with mountpoint.mount( '/dev/sda3') as sda3_mountpoint:<br>                #fails, no more mountpoints available<br>                pass<br>     #/dev/sda1 and /dev/sda2 are now unmounted<br>     <br>But, of course, not all operations make sense as a context manager. Take, for example, creating a new VM from disk on LVM:<br><br>    lvm.createLV(\"my_vg\", \"my_vm\", \"10gb\")<br>    blockdevice.create_filesystem( '/dev/my_vg/my_vm')<br>    #...<br><br>What happens if `create_filesystem` fails? You'll may be left with a inconsistent filesystem on the LV. Worse, once you fix the problem and try to run this again, `createLV` will fail, because the LV is already there, so you'll have to either create the VM manually or fix your script.<br><br>A context manager makes no sense in this case: you don't want to delete the LV if all operations succeed. You have to keep track of the operations you performed, and rollback if something fails. You could do that by hand, of course, but that's no fun:<br><br>    with Atomic() as atomic:<br>        atomic.lvm.createLV(\"my_vg\", \"my_vm\", \"10gb\")<br>        blockdevice.create_filesystem( '/dev/my_vg/my_vm')<br><br>Now, the LV will be deleted only *if **any** operation inside the context manager fails*. If you have multiple `atomic` calls, it will keep track of them, and rollback them in the reverse order they were executed on. <br><br>While `Atomic` pre-packages some knowledge, `AtomicOperationSequence` is operation agnostic - it works by defining rollback functions:<br><br>    def f1():<br>        print \"f1 executed\"<br>    <br>    def reverse(f, args, kwargs):<br>         if f==f1:<br>             print \"f1 reversed\"<br>    <br>    with AtomicOperationSequence(reverse) as atomic:<br>        atomic.f1()<br><br>FAQ<br>===<br><br>pybofh? What kind of name is that?<br>----------------------------------<br>It's a tribute to the [Bastard Operator From Hell](http://en.wikipedia.org/wiki/Bastard_Operator_From_Hell) stories<br><br>Where does development happen?<br>------------------------------<br>https://github.com/goncalopp/pybofh<br>\n          </div>"}, "last_serial": 3671851, "releases": {"0.2.1": [{"comment_text": "", "digests": {"md5": "a5a9ddc1cd8bb55c0648d2577ee37ead", "sha256": "dc7a74117a1dc3d238cc783ca9fd5ea38009f0d682e5d96dab79ef06c9b17c76"}, "downloads": -1, "filename": "pybofh-0.2.1.tar.gz", "has_sig": false, "md5_digest": "a5a9ddc1cd8bb55c0648d2577ee37ead", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 44134, "upload_time": "2018-03-15T10:04:06", "upload_time_iso_8601": "2018-03-15T10:04:06.246382Z", "url": "https://files.pythonhosted.org/packages/83/00/27d9f137bba71f82a533be722008201fc8ffdb67eeaa49e2a7a7b551535d/pybofh-0.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a5a9ddc1cd8bb55c0648d2577ee37ead", "sha256": "dc7a74117a1dc3d238cc783ca9fd5ea38009f0d682e5d96dab79ef06c9b17c76"}, "downloads": -1, "filename": "pybofh-0.2.1.tar.gz", "has_sig": false, "md5_digest": "a5a9ddc1cd8bb55c0648d2577ee37ead", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 44134, "upload_time": "2018-03-15T10:04:06", "upload_time_iso_8601": "2018-03-15T10:04:06.246382Z", "url": "https://files.pythonhosted.org/packages/83/00/27d9f137bba71f82a533be722008201fc8ffdb67eeaa49e2a7a7b551535d/pybofh-0.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:09:06 2020"}