{"info": {"author": "Stephan Kamrad", "author_email": "stephan.kamrad@crick.ac.uk", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "![pyphe logo](https://github.com/Bahler-Lab/pyphe/blob/master/icons/toolbox-72dpi_white.png)\n\n# Welcome to the pyphe toolbox\nA python toolbox for phenotype analysis of arrayed microbial colonies written by Stephan Kamrad (stephan.kamrad at crick.ac.uk).\n\nPlease see our preprint for a detailed description of the algorithms and applications and the FAQs at the bottom of the page.\n\n\n## Installation\n1. Most tools are cross-platform compatible but scanning will only work on a Linux OS. The scanners need to be accessible by [SANE](http://www.sane-project.org/) and [ImageMagick](https://imagemagick.org/) needs to be installed and callable from the comman line.\n2. Pyphe requires Python 3 and a few common packages, available through the [anaconda distribution](https://www.anaconda.com/distribution/).\n3. Install pyphe by running 'pip install pyphe' in your terminal.\n4. Open a new terminal and try and run 'pyphe-quantify -h' which should show the help page of one of pyphe's command line tools. See the FAQs at the end for what to do if you're on Windows.\n\n\n## Overview\nA typical fitness screen with pyphe will involve:\n1. Image acquisition with [_pyphe-scan_](#pyphe-scan), or [_pyphe-scan-timecourse_](#pyphe-scan-timecourse)\n2. Quantification of colony properties from images using [_pyphe-quantify_](#pyphe-quantify). In the case of growth curves, parameters are additionally extracted with [_pyphe-growthcurves_](#pyphe-growthcurves).\n3. Normalisation and data aggregation using [_pyphe-analyse_](#pyphe-analyse).\n4. Statistics and hit calling using [_pyphe-interpret_](#pyphe-interpret)\nPlease see our paper for a detailed protocol and explanations of the algorithms.\n\n\n## Support\nPlease check the manuals below carefully, they are also available in the terminal by running the command with the -h option only. If things are still not working, please email me (stephan.kamrad@crick.ac.uk) and I will try and help. If you think you have discovered a bug, or would like to request a new feature, please raise an issue on www.github.com/Bahler-Lab/pyphe.\n\n## Manual\n\nAll pyphe tools have a similar command line interface, based on the python argparse package. Generally, parameters are set using --<parameter_name> optionally followed by a value. All _pyphe_ tools can be used with relative file paths so make sure to navigate to the correct working directory before running a _pyphe_ command.\n\n\n### Pyphe-scan\nThis tools allows you to take consecutive scans of sets of plates, which are then automatically cropped, rotated and named in in a continuos filename scheme of your choice. \n\n#### Prerequisites\n1. This tool will only run on Linux operating systems and uses the SANE library for image acquisition.\n\n2. Make sure your scanner is installed correctly and you can acquire images using the scanimage command. The Gray mode will only work on Epson V800 scanners (potentially the V700 and V750 model as well) and the TPU8x10 transmission scanning source must be enabled. This was first implemented in by Zackrisson et al. in the [scanomatics pipeline](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5015956/) and requires the installation of a hacked SANE driver. See the instructions in their [wiki](https://github.com/Scan-o-Matic/scanomatic/wiki/Installing-scanners) for how to do this.\n\n2. Make sure [ImageMagick](https://imagemagick.org/index.php) is installed and the 'convert' tool can be called from the command line.\n\n3. If the Pyphe toolbox has been installed correctly, you should be able to run _pyphe-scan_ in your terminal. If not, check that the files in the 'bin' directory are executable and the bin folder has been added to your path variable.\n\n4. With a laser cutter, make a fixture to hold your plates in place. We provide an svg file with the cutting shape in the Documentation directory. Use tape to hold your fixture into place, it should be pushed against the back of the scanner (where the cables are) with the top of the plates facing left. Pyphe-scan and pyphe-quantify come pre-configured for using the provided fixture on an Epson V800 scanner but it is easy to add your own fixture and cropping settings. If you want to use your own fixture, see below of how to add the geometry information to pyphe-scan. \n\n#### Scanning plate batches\n\n1. Open the file manager and navigate to the folder in which you want to save your images. The script will create a sub-folder that begins with the current date to save all your images. \n\n2. Right click and select 'Open in Terminal'\n\n3. Run scanplates with the options as detaild below. \n\n```\nusage: pyphe-scan [-h] [--nplates NPLATES] [--start START] [--prefix PREFIX]\n                  [--postfix POSTFIX] [--fixture {som3_edge,som3}]\n                  [--resolution {150,300,600,900,1200}] [--scanner {1,2,3}]\n                  [--mode {Gray,Color}]\n\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --nplates NPLATES     Number of plates to scan. This defaults to 100 and the\n                        script can be terminated by Ctr+C when done.\n  --start START         Where to start numbering from. Defaults to 1.\n  --prefix PREFIX       Name prefix for output files. The default is the\n                        current date YYYYMMDD.\n  --postfix POSTFIX     Name postfix for output files. Defaults to empty\n                        string.\n  --fixture {som3_edge,som3}\n                        ID of the fixture you are using.\n  --resolution {150,300,600,900,1200}\n                        Resolution for scanning in dpi. Default is 600.\n  --scanner {1,2,3}     Which scanner to use. Scanners are not uniquely\n                        identified and may switch when turned off/unplugged.\n                        This option does not need to be set when only one\n                        scanner is connected.\n  --mode {Gray,Color}   Which color mode to use for scanning. Defaults to\n                        Gray.\n```\n\nAll arguments except the fixture have default values and are optional. A folder prefix_postfix will be created in your current directory and the program will abort if a folder with this name already exists. \n\n\n\n### Pyphe-scan-timecourse\n\nThis tool acquires image timeseries by scanning in fixed time intervals. For each position in the fixture, a folder is created. Image names contain number of scan. Other options for this tool are similar to [_pyphe-scan_](#pyphe-scan). More than one scanner can be connected and used at the same time. Scanner numbers are defined by the order in which they are connected to the computer. Proceed as follows: (1) disconnect all scanners, (2) prepare the first scanner with plates, connect it and turn it on. (3) start scanning with --scanner 1 option, (4) prepare the second scanner, connect it and turn it on, (5) start scanning with --scanner 2 option. Repeat step (4) and (5), each time incrementing the --scanner argument. \n\n```\nusage: pyphe-scan-timecourse [-h] [--nscans NSCANS] [--interval INTERVAL]\n                             [--prefix PREFIX] [--postfix POSTFIX]\n                             [--fixture {som3_edge,som3}]\n                             [--resolution {150,300,600,900,1200}]\n                             [--scanner {1,2,3}] [--mode {Gray,Color}]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --nscans NSCANS       Number of time points to scan. This defaults to 100\n                        and the script can be terminated by Ctr+C when done.\n  --interval INTERVAL   Time in minutes between scans. Defaults to 20.\n  --prefix PREFIX       Name prefix for output files. The default is the\n                        current date YYYYMMDD.\n  --postfix POSTFIX     Name postfix for output files. Defaults to empty\n                        string.\n  --fixture {som3_edge,som3}\n                        ID of the fixture you are using.\n  --resolution {150,300,600,900,1200}\n                        Resolution for scanning in dpi. Default is 600.\n  --scanner {1,2,3}     Which scanner to use. Scanners are not uniquely\n                        identified and may switch when turned off/unplugged.\n                        This option does not need to be set when only one\n                        scanner is connected.\n  --mode {Gray,Color}   Which color mode to use for scanning. Defaults to\n                        Gray.\n```\n\n\n### Pyphe-growthcurves\nThis tool performs non-parametric analysis of growth curves. It was written specifically to analyse colony size timeseries data obtained with _pyphe-quantify_ _timeseries_.\n\nIt is important that your csv with the growth data is in the right format. The file must contain one growth curve per column. The first column must be the timepoints and there must be a header row with unique identifiers for each curve. For example data and expected outputs, check out the files included in this Documentation folder. Sensible default parameters are set for all options but, depending on your data, you may wish to customise these, so check out the help section below. \n\n```\nusage: pyphe-growthcurves [-h] --input INPUT [--fitrange FITRANGE]\n                          [--lag-method {abs,rel}]\n                          [--lag-threshold LAG_THRESHOLD]\n                          [--t0-fitrange T0_FITRANGE] [--plots]\n                          [--plot-ylim PLOT_YLIM]\n\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --input INPUT         Path to the growth curve file to analyse. This file\n                        contains one growth curve per column. The first column\n                        must be the timepoints and there must be a header row\n                        with unique identifiers for each curve.\n  --fitrange FITRANGE   Number of timepoint over which to fit linear\n                        regression. Defaults to 4. Please adjust this to the\n                        density of your timepoints and use higher values for\n                        more noisy data.\n  --lag-method {abs,rel}\n                        Method to use for determining lag. \"abs\" will measure\n                        time until the defined biomass threshold is crossed.\n                        \"rel\" will fist determine the inital biomass and\n                        measure the time until the biomass has passed this\n                        value times the threshold. Defaults to \"rel\".\n  --lag-threshold LAG_THRESHOLD\n                        Threshold to use for determining lag. With method\n                        \"abs\", this will measure time until the defined\n                        biomass threshold is crossed. With \"rel\" will fist\n                        determine the inital biomass and measure the time\n                        until the biomass has passed this value times the\n                        threshold. Defaults to 2.0, so with method \"rel\", this\n                        will measure the time taken for the first doubling.\n  --t0-fitrange T0_FITRANGE\n                        Specify the number of timepoint to use at the\n                        beginning of the growth curve to determine the initial\n                        biomass by averaging them. Defaults to 3.\n  --plots               Set this option (no argument required) to produce a\n                        plot of all growthcurves as pdf.\n  --plot-ylim PLOT_YLIM\n                        Specify the upper limit of the y-axis of growth curve\n                        plots. Useful if you want curves to be directly\n                        comparable. If not set, the axis of each curve is\n                        scaled to the data.\n```\n\n\n#### Interpreting results\nPyphe-growthcurves will produce a csv file with extracted growth parameters. The maximum slope is determined by fitting all possible linear regressions in sliding windows of length n and chosing the one with the highest slope. The lag phase is determined as the first timepoint which exceeds a settable relative or absolute threshold. \n\n| Parameter        | Explanation  |\n| ---------------- |---------------|\n|initial biomass|The average of the first n timepoints of the growth curve|\n|lag |  Lag phase |\n| max_slope| The maximum slope of the growth curve|\n| r2 | The R2 parameter of the linear regression that produced the highest maximum slope |\n|t_max | Time at which maximum growth slope is reached (center of the sliding window)|\n|y-intercept|Y-intercept of the regression which produced the maximum slope|\n|x-intercept|X-intercept of the regression which produced the maximum slope. This is interpreted as lag phase by some people|\n\n\n\n### Pyphe-quantify\n\nPyphe quantify extracts colony parameters from images. In can operate in three distinct modes analysing colony sizes for each image individually (batch mode), analysing redness for each image individually (redness mode) or obtaining a growth curve from an image timeseries (timeseries mode).\nThe --grid parameter is required define the position of colonies on the plate. You can either use automatic grid detection, one of our preconfigured positions if you are using the pp3 fixture or define your own (see the manual below). Images can be in any format (e.g. jpg, tiff, png). Images should be cropped closely to the colonies (this is important for good thresholding and automatic grid detection), i.e. not contain parts of the plate edges or surroundings. In batch and timecourse mode, pyphe-quantify assumes that images were acquired using transmission scanning, where colonies appear darker then the surrounding agar. If this is not the case and you took images by reflective scanning or with a camera, use --negate False. In batch and timecourse mode, images are epxected to be grayscale. If they are not, they will be converted (by simply summing all channels) and a warning will be thrown. \n\n\n```\nusage: pyphe-quantify [-h] --grid GRID [--pattern PATTERN] [--t T] [--d D]\n                      [--s S] [--negate NEGATE] [--reportAll]\n                      [--reportFileNames]\n                      [--hardImageThreshold HARDIMAGETHRESHOLD]\n                      [--hardSizeThreshold HARDSIZETHRESHOLD] [--qc QC]\n                      [--out OUT]\n                      {batch,timecourse,redness}\n\npositional arguments:\n  {batch,timecourse,redness}\n                        Pyphe-quantify can be run in three different modes. In\n                        batch mode, it quantifies colony sizes for all images\n                        mathcing the pattern individually. A separate results\n                        table and qc image is produced for each. Redness mode\n                        is similar except that the redness of each colony is\n                        quantified. In timecourse mode, all images matching\n                        the pattern are analysed jointly. The final image\n                        matching the pattern is used to create a mask of where\n                        the colonies are and this mask is then applied to all\n                        previous images in the timeseries. A single output\n                        table, where the timepoints are the rows and each\n                        individual colony is a row.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --grid GRID           This option is required (all others have defaults set)\n                        and specifies the grid in which the colonies are\n                        arranged. The argument has to be in the form of 6\n                        integer numbers separated by \"-\": <number of colony\n                        rows>-<number of colony columns>-<x-position of the\n                        top left colony>-<y-position of the top left\n                        colony>-<x-position of the bottom right\n                        colony>-<y-position of the bottom right colony>.\n                        Positions must be integers and are the distance in\n                        number of pixels from the image origin in each\n                        dimension (x is width dimension, y is height\n                        dimension). The image origin is, in line with scikit-\n                        image, in the top left corner.\n  --pattern PATTERN     Pattern describing files to analyse. This follows\n                        standard unix convention and can be used to specify\n                        subfolders in which to look for images\n                        (<subfolder>/*.jpg) or the image format (*.tiff,\n                        *.png, etc.). By default, all jpg images in the\n                        working directory are analysed.\n  --t T                 By default the intensity threshold to distinguish\n                        colonies from the background is determined by the Otsu\n                        method. The determined value will be multiplied by\n                        this argument to give the final threshold. Useful for\n                        easily fine-tuning colony detection.\n  --d D                 The distance between two grid positions will be\n                        divided by this number to compute the maximum distance\n                        a putative colony can be away from its reference grid\n                        position. Decreasing this number towards 2 makes\n                        colony-to-grid-matching more permissive (might help\n                        when some of your plates are at a slight angle or out\n                        of position).\n  --s S                 Detected putative colonies will be filtered by size\n                        and small components (usually image noise) will be\n                        excluded. The default threshold is the image\n                        area*0.00005 and is therefore independent of scanning\n                        resolution. This default is then multiplied by this\n                        argument to give the final threshold. Useful for when\n                        colonies have unusual sizes.\n  --negate NEGATE       In images acquired by transmission scanning, the\n                        colonies are darker than the background. Before\n                        thresholding, the image needs to be inverted/negated.\n                        Ignored in redness mode.\n  --reportAll           Sometimes, two putative colonies are identified that\n                        are within the distance threshold of a grid position.\n                        By default, only the closest colony is reported. This\n                        can be changed by setting this option (without\n                        parameter). This option allows pyphe quantify to be\n                        used even if colonies are not arrayed in a regular\n                        grid (you still need to provide a grid parameter\n                        though that spans the colonies you are interested i).\n  --reportFileNames     Only for timecourse mode, otherwise ignored. Use\n                        filenames as index for output table instead of\n                        timepoints. Useful when the ordering of timepoints is\n                        not the same as returned by the pattern.\n  --hardImageThreshold HARDIMAGETHRESHOLD\n                        Allows a hard (fixed) intensity threshold in the range\n                        [0,1] to be used instead of Otsu thresholding. But\n                        images intensities are re-scaled to [0,1] before\n                        thresholding.\n  --hardSizeThreshold HARDSIZETHRESHOLD\n                        Allows a hard (fixed) size threshold [number of\n                        pixels] to be used for filtering small colonies.\n  --qc QC               Directory to save qc images in. Defaults to\n                        \"qc_images\".\n  --out OUT             Directory to save output files in. Defaults to\n                        \"pyphe_quant\".\n```\n\n\n\n### Pyphe-analyse\n_Pyphe-analyse_ is a tool for spatial normalisation and data aggregation across many plates. It implements a grid normalisation based on the concept proposed by [Zackrisson et al. 2016](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5015956/) and row/column median normalisation. Please see our paper and the protocol in it to find out more. _Pyphe-analyse_ can be run from the command line, with options below, or using the graphical user interface by running _pyphe-analyse-gui_.\n\n\n```\nusage: pyphe-analyse.txt [-h] --edt EDT --format\n                         {gitter,pyphe-redness,pyphe-growthcurves} [--out OUT]\n                         [--load_layouts]\n                         [--gridnorm {standard384,standard1536}]\n                         [--extrapolate_corners] [--rcmedian] [--check CHECK]\n                         [--qc_plots QC_PLOTS]\n\nWelcome to pyphe-analyse, part of the pyphe toolbox. Written by\nstephan.kamrad@crick.ac.uk and maintained at https://github.com/Bahler-\nLab/pyphe\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --edt EDT             Path to the Experimental Design Table (EDT) listing\n                        all plates of the experiment. The table must be in csv\n                        format, the first column must contain unique plate IDs\n                        and there must be a column named 'Data_path' that\n                        contains abolute or relative file paths to each\n                        plate's data file. A 'Layout_path' column can be\n                        included, see below. Any additional columns included\n                        in this file will bestored in each plate's meta-data\n                        and included in the final data output.\n  --format {gitter,pyphe-redness,pyphe-growthcurves}\n                        Type of inout data.\n  --out OUT             Specifies the path where to save the output data\n                        result. By default, the data report is saved in the\n                        working directory as \"pyphe-analyse_data_report.csv\"\n                        and will overwrite the file if it exists.\n  --load_layouts        Set this option (without parameters) to load layouts\n                        (requires Layout_path column in the EDT).\n  --gridnorm {standard384,standard1536}\n                        Perform reference grid normalisation. Standard384\n                        refers to plates which are in 384 (16x24) format with\n                        the reference grid in 96 format in the top left\n                        corner. Standard1536 refers to plates in 1536 format\n                        (32x48( with two 96 reference grids in the top left\n                        and bottom right corners.\n  --extrapolate_corners\n                        If working in standard1536 format, set this option to\n                        extrapolate the reference grid in the bottom left and\n                        top right corner. A linear regression will be trained\n                        across all top left and bottom right corners on plates\n                        in the experiment to predict hypothetical grid colony\n                        sizes in the other two corners.\n  --rcmedian            Perform row/column median normalisation. If --gridnorm\n                        will be performed first if both parameters are set.\n  --check CHECK         Check colony sizes after normalisation for negative\n                        and infinite colony sizes *(normalisation artefacts),\n                        throw a warning and set to NA.\n  --qc_plots QC_PLOTS   Specify a folder in which to save qc plots for each\n                        plate.\n\n```\n\nIf you prefer to use the GUI, just run 'pyphe-analyse-gui'. You will need PySimpleGUI installed, which you can do by running 'pip install pysimplegui' in the terminal. It is deliberately not included in the package dependencies so 'pip install pyphe' won't install it for you. \n\n![pyphe-analyse GUI](https://github.com/Bahler-Lab/pyphe/blob/master/icons/gui.png)\n\n### Pyphe-interpret\n\nPyphe-interpret reports summary statistics and tests for differential fitness using t-tests. It is flexible and can in theory be used with any dataset in tidy format. Specifically, it was designed to answer two types of questions: (1) Check for each condition separately (--axis_column <condition_column>) if there is a significant difference in means between a mutant strain and a control strain (--grouping_column <strain_id_column>). Or (2) Check for each strain separately (--axis_column <strain_id_column>) if there is a significant difference in the means of the strain in the assay condition versus the control condition (--grouping_column <condition_column>). The second option tests for condition-specific growth effects (i.e. is does not return significant results if a strain is always faster or always slower growing than the grid strain). \n\n```\nusage: pyphe-interpret [-h] --ld LD [--out OUT] --axis_column AXIS_COLUMN\n                       --grouping_column GROUPING_COLUMN\n                       [--values_column VALUES_COLUMN] --control CONTROL\n                       [--ld_encoding LD_ENCODING]\n                       [--filter_circularity FILTER_CIRCULARITY]\n                       [--set_missing_na]\n\nWelcome to pyphe-interpret, part of the pyphe toolbox. Written by\nstephan.kamrad@crick.ac.uk and maintained at https://github.com/Bahler-\nLab/pyphe. Setting your column names correctly is crucial. Let us assume you\nhave measured many strains in many conditions. Now you would like to know for\neach strain-condition pair if it is significant. There are essentially two\nways of doing this. (1) Check for each condition separately (--axis_column\n<condition_column>) if there is a significant difference in means between a\nmutant strain and a control strain (--grouping_column <strain_id_column>). Or\n(2) Check for each strain separately (--axis_column <strain_id_column>) if\nthere is a significant difference in the means of the strain in the assay\ncondition versus the control condition (--grouping_column <condition_column>).\nThe second option tests for condition-specific growth effects (i.e. is does\nnot return significant results if a strain is always faster or always slower\ngrowing than the grid strain). In both cases you need to specify the control\nagainst which to test usiing --control and this has to be a value that appears\nin the axis column. You should define the dependent variable of the t-test\nusing --values_column.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --ld LD               Path to the Data Report Table produced by pyphe-\n                        analyse.\n  --out OUT             Specifies the path where to save the output data\n                        result. By default, a table with all replicates will\n                        be saved as pyphe-quantify-report_reps.csv and the\n                        statistic table will be saved as pyphe-quantify-\n                        report_summaryStats.csv in the current working\n                        directory. Existing files will be overwritten.\n  --axis_column AXIS_COLUMN\n                        Name of the column in the data report to repeat\n                        t-tests along. Data will be grouped by the\n                        grouping_column and differences between all unique\n                        values found in the axis column versus the specified\n                        control will be tested for.\n  --grouping_column GROUPING_COLUMN\n                        Name of the column in the data report to use as the\n                        grouping variable for t-tests.\n  --values_column VALUES_COLUMN\n                        Name of the column in the data report to use as\n                        fitness values. This will be the dependent variable\n                        for t-tests. Defaults to \"Colony_size_corr_checked\".\n  --control CONTROL     Name of the control to compare against. This must be a\n                        value found in the axis column.\n  --ld_encoding LD_ENCODING\n                        Encoding of the data report table to be passed to\n                        pandas.read_csv().\n  --filter_circularity FILTER_CIRCULARITY\n                        Exclude colonies from the analysis with a circularity\n                        below the one specified. A circularity of 1\n                        corresponds to a perfect circle. We recommend a\n                        threshold around 0.85.\n  --set_missing_na      Set 0-sized colonies to NA. This is recommended if you\n                        expect no missing colonies in your data, which means\n                        these are probably due to pinning errors.\n```\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Bahler-Lab/pyphe", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pyphe", "package_url": "https://pypi.org/project/pyphe/", "platform": "", "project_url": "https://pypi.org/project/pyphe/", "project_urls": {"Homepage": "https://github.com/Bahler-Lab/pyphe"}, "release_url": "https://pypi.org/project/pyphe/0.95/", "requires_dist": ["pandas", "matplotlib", "numpy", "seaborn", "scipy", "scikit-image", "scikit-learn"], "requires_python": ">=3.7", "summary": "Python toolbox for phenotype analysis of arrayed microbial colonies", "version": "0.95", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><img alt=\"pyphe logo\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/686776e565d020f130a9dee2d4c22ac35318b4ba/68747470733a2f2f6769746875622e636f6d2f4261686c65722d4c61622f70797068652f626c6f622f6d61737465722f69636f6e732f746f6f6c626f782d37326470695f77686974652e706e67\"></p>\n<h1>Welcome to the pyphe toolbox</h1>\n<p>A python toolbox for phenotype analysis of arrayed microbial colonies written by Stephan Kamrad (stephan.kamrad at crick.ac.uk).</p>\n<p>Please see our preprint for a detailed description of the algorithms and applications and the FAQs at the bottom of the page.</p>\n<h2>Installation</h2>\n<ol>\n<li>Most tools are cross-platform compatible but scanning will only work on a Linux OS. The scanners need to be accessible by <a href=\"http://www.sane-project.org/\" rel=\"nofollow\">SANE</a> and <a href=\"https://imagemagick.org/\" rel=\"nofollow\">ImageMagick</a> needs to be installed and callable from the comman line.</li>\n<li>Pyphe requires Python 3 and a few common packages, available through the <a href=\"https://www.anaconda.com/distribution/\" rel=\"nofollow\">anaconda distribution</a>.</li>\n<li>Install pyphe by running 'pip install pyphe' in your terminal.</li>\n<li>Open a new terminal and try and run 'pyphe-quantify -h' which should show the help page of one of pyphe's command line tools. See the FAQs at the end for what to do if you're on Windows.</li>\n</ol>\n<h2>Overview</h2>\n<p>A typical fitness screen with pyphe will involve:</p>\n<ol>\n<li>Image acquisition with <a href=\"#pyphe-scan\" rel=\"nofollow\"><em>pyphe-scan</em></a>, or <a href=\"#pyphe-scan-timecourse\" rel=\"nofollow\"><em>pyphe-scan-timecourse</em></a></li>\n<li>Quantification of colony properties from images using <a href=\"#pyphe-quantify\" rel=\"nofollow\"><em>pyphe-quantify</em></a>. In the case of growth curves, parameters are additionally extracted with <a href=\"#pyphe-growthcurves\" rel=\"nofollow\"><em>pyphe-growthcurves</em></a>.</li>\n<li>Normalisation and data aggregation using <a href=\"#pyphe-analyse\" rel=\"nofollow\"><em>pyphe-analyse</em></a>.</li>\n<li>Statistics and hit calling using <a href=\"#pyphe-interpret\" rel=\"nofollow\"><em>pyphe-interpret</em></a>\nPlease see our paper for a detailed protocol and explanations of the algorithms.</li>\n</ol>\n<h2>Support</h2>\n<p>Please check the manuals below carefully, they are also available in the terminal by running the command with the -h option only. If things are still not working, please email me (<a href=\"mailto:stephan.kamrad@crick.ac.uk\">stephan.kamrad@crick.ac.uk</a>) and I will try and help. If you think you have discovered a bug, or would like to request a new feature, please raise an issue on <a href=\"http://www.github.com/Bahler-Lab/pyphe\" rel=\"nofollow\">www.github.com/Bahler-Lab/pyphe</a>.</p>\n<h2>Manual</h2>\n<p>All pyphe tools have a similar command line interface, based on the python argparse package. Generally, parameters are set using --&lt;parameter_name&gt; optionally followed by a value. All <em>pyphe</em> tools can be used with relative file paths so make sure to navigate to the correct working directory before running a <em>pyphe</em> command.</p>\n<h3>Pyphe-scan</h3>\n<p>This tools allows you to take consecutive scans of sets of plates, which are then automatically cropped, rotated and named in in a continuos filename scheme of your choice.</p>\n<h4>Prerequisites</h4>\n<ol>\n<li>\n<p>This tool will only run on Linux operating systems and uses the SANE library for image acquisition.</p>\n</li>\n<li>\n<p>Make sure your scanner is installed correctly and you can acquire images using the scanimage command. The Gray mode will only work on Epson V800 scanners (potentially the V700 and V750 model as well) and the TPU8x10 transmission scanning source must be enabled. This was first implemented in by Zackrisson et al. in the <a href=\"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5015956/\" rel=\"nofollow\">scanomatics pipeline</a> and requires the installation of a hacked SANE driver. See the instructions in their <a href=\"https://github.com/Scan-o-Matic/scanomatic/wiki/Installing-scanners\" rel=\"nofollow\">wiki</a> for how to do this.</p>\n</li>\n<li>\n<p>Make sure <a href=\"https://imagemagick.org/index.php\" rel=\"nofollow\">ImageMagick</a> is installed and the 'convert' tool can be called from the command line.</p>\n</li>\n<li>\n<p>If the Pyphe toolbox has been installed correctly, you should be able to run <em>pyphe-scan</em> in your terminal. If not, check that the files in the 'bin' directory are executable and the bin folder has been added to your path variable.</p>\n</li>\n<li>\n<p>With a laser cutter, make a fixture to hold your plates in place. We provide an svg file with the cutting shape in the Documentation directory. Use tape to hold your fixture into place, it should be pushed against the back of the scanner (where the cables are) with the top of the plates facing left. Pyphe-scan and pyphe-quantify come pre-configured for using the provided fixture on an Epson V800 scanner but it is easy to add your own fixture and cropping settings. If you want to use your own fixture, see below of how to add the geometry information to pyphe-scan.</p>\n</li>\n</ol>\n<h4>Scanning plate batches</h4>\n<ol>\n<li>\n<p>Open the file manager and navigate to the folder in which you want to save your images. The script will create a sub-folder that begins with the current date to save all your images.</p>\n</li>\n<li>\n<p>Right click and select 'Open in Terminal'</p>\n</li>\n<li>\n<p>Run scanplates with the options as detaild below.</p>\n</li>\n</ol>\n<pre><code>usage: pyphe-scan [-h] [--nplates NPLATES] [--start START] [--prefix PREFIX]\n                  [--postfix POSTFIX] [--fixture {som3_edge,som3}]\n                  [--resolution {150,300,600,900,1200}] [--scanner {1,2,3}]\n                  [--mode {Gray,Color}]\n\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --nplates NPLATES     Number of plates to scan. This defaults to 100 and the\n                        script can be terminated by Ctr+C when done.\n  --start START         Where to start numbering from. Defaults to 1.\n  --prefix PREFIX       Name prefix for output files. The default is the\n                        current date YYYYMMDD.\n  --postfix POSTFIX     Name postfix for output files. Defaults to empty\n                        string.\n  --fixture {som3_edge,som3}\n                        ID of the fixture you are using.\n  --resolution {150,300,600,900,1200}\n                        Resolution for scanning in dpi. Default is 600.\n  --scanner {1,2,3}     Which scanner to use. Scanners are not uniquely\n                        identified and may switch when turned off/unplugged.\n                        This option does not need to be set when only one\n                        scanner is connected.\n  --mode {Gray,Color}   Which color mode to use for scanning. Defaults to\n                        Gray.\n</code></pre>\n<p>All arguments except the fixture have default values and are optional. A folder prefix_postfix will be created in your current directory and the program will abort if a folder with this name already exists.</p>\n<h3>Pyphe-scan-timecourse</h3>\n<p>This tool acquires image timeseries by scanning in fixed time intervals. For each position in the fixture, a folder is created. Image names contain number of scan. Other options for this tool are similar to <a href=\"#pyphe-scan\" rel=\"nofollow\"><em>pyphe-scan</em></a>. More than one scanner can be connected and used at the same time. Scanner numbers are defined by the order in which they are connected to the computer. Proceed as follows: (1) disconnect all scanners, (2) prepare the first scanner with plates, connect it and turn it on. (3) start scanning with --scanner 1 option, (4) prepare the second scanner, connect it and turn it on, (5) start scanning with --scanner 2 option. Repeat step (4) and (5), each time incrementing the --scanner argument.</p>\n<pre><code>usage: pyphe-scan-timecourse [-h] [--nscans NSCANS] [--interval INTERVAL]\n                             [--prefix PREFIX] [--postfix POSTFIX]\n                             [--fixture {som3_edge,som3}]\n                             [--resolution {150,300,600,900,1200}]\n                             [--scanner {1,2,3}] [--mode {Gray,Color}]\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --nscans NSCANS       Number of time points to scan. This defaults to 100\n                        and the script can be terminated by Ctr+C when done.\n  --interval INTERVAL   Time in minutes between scans. Defaults to 20.\n  --prefix PREFIX       Name prefix for output files. The default is the\n                        current date YYYYMMDD.\n  --postfix POSTFIX     Name postfix for output files. Defaults to empty\n                        string.\n  --fixture {som3_edge,som3}\n                        ID of the fixture you are using.\n  --resolution {150,300,600,900,1200}\n                        Resolution for scanning in dpi. Default is 600.\n  --scanner {1,2,3}     Which scanner to use. Scanners are not uniquely\n                        identified and may switch when turned off/unplugged.\n                        This option does not need to be set when only one\n                        scanner is connected.\n  --mode {Gray,Color}   Which color mode to use for scanning. Defaults to\n                        Gray.\n</code></pre>\n<h3>Pyphe-growthcurves</h3>\n<p>This tool performs non-parametric analysis of growth curves. It was written specifically to analyse colony size timeseries data obtained with <em>pyphe-quantify</em> <em>timeseries</em>.</p>\n<p>It is important that your csv with the growth data is in the right format. The file must contain one growth curve per column. The first column must be the timepoints and there must be a header row with unique identifiers for each curve. For example data and expected outputs, check out the files included in this Documentation folder. Sensible default parameters are set for all options but, depending on your data, you may wish to customise these, so check out the help section below.</p>\n<pre><code>usage: pyphe-growthcurves [-h] --input INPUT [--fitrange FITRANGE]\n                          [--lag-method {abs,rel}]\n                          [--lag-threshold LAG_THRESHOLD]\n                          [--t0-fitrange T0_FITRANGE] [--plots]\n                          [--plot-ylim PLOT_YLIM]\n\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --input INPUT         Path to the growth curve file to analyse. This file\n                        contains one growth curve per column. The first column\n                        must be the timepoints and there must be a header row\n                        with unique identifiers for each curve.\n  --fitrange FITRANGE   Number of timepoint over which to fit linear\n                        regression. Defaults to 4. Please adjust this to the\n                        density of your timepoints and use higher values for\n                        more noisy data.\n  --lag-method {abs,rel}\n                        Method to use for determining lag. \"abs\" will measure\n                        time until the defined biomass threshold is crossed.\n                        \"rel\" will fist determine the inital biomass and\n                        measure the time until the biomass has passed this\n                        value times the threshold. Defaults to \"rel\".\n  --lag-threshold LAG_THRESHOLD\n                        Threshold to use for determining lag. With method\n                        \"abs\", this will measure time until the defined\n                        biomass threshold is crossed. With \"rel\" will fist\n                        determine the inital biomass and measure the time\n                        until the biomass has passed this value times the\n                        threshold. Defaults to 2.0, so with method \"rel\", this\n                        will measure the time taken for the first doubling.\n  --t0-fitrange T0_FITRANGE\n                        Specify the number of timepoint to use at the\n                        beginning of the growth curve to determine the initial\n                        biomass by averaging them. Defaults to 3.\n  --plots               Set this option (no argument required) to produce a\n                        plot of all growthcurves as pdf.\n  --plot-ylim PLOT_YLIM\n                        Specify the upper limit of the y-axis of growth curve\n                        plots. Useful if you want curves to be directly\n                        comparable. If not set, the axis of each curve is\n                        scaled to the data.\n</code></pre>\n<h4>Interpreting results</h4>\n<p>Pyphe-growthcurves will produce a csv file with extracted growth parameters. The maximum slope is determined by fitting all possible linear regressions in sliding windows of length n and chosing the one with the highest slope. The lag phase is determined as the first timepoint which exceeds a settable relative or absolute threshold.</p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Explanation</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>initial biomass</td>\n<td>The average of the first n timepoints of the growth curve</td>\n</tr>\n<tr>\n<td>lag</td>\n<td>Lag phase</td>\n</tr>\n<tr>\n<td>max_slope</td>\n<td>The maximum slope of the growth curve</td>\n</tr>\n<tr>\n<td>r2</td>\n<td>The R2 parameter of the linear regression that produced the highest maximum slope</td>\n</tr>\n<tr>\n<td>t_max</td>\n<td>Time at which maximum growth slope is reached (center of the sliding window)</td>\n</tr>\n<tr>\n<td>y-intercept</td>\n<td>Y-intercept of the regression which produced the maximum slope</td>\n</tr>\n<tr>\n<td>x-intercept</td>\n<td>X-intercept of the regression which produced the maximum slope. This is interpreted as lag phase by some people</td>\n</tr></tbody></table>\n<h3>Pyphe-quantify</h3>\n<p>Pyphe quantify extracts colony parameters from images. In can operate in three distinct modes analysing colony sizes for each image individually (batch mode), analysing redness for each image individually (redness mode) or obtaining a growth curve from an image timeseries (timeseries mode).\nThe --grid parameter is required define the position of colonies on the plate. You can either use automatic grid detection, one of our preconfigured positions if you are using the pp3 fixture or define your own (see the manual below). Images can be in any format (e.g. jpg, tiff, png). Images should be cropped closely to the colonies (this is important for good thresholding and automatic grid detection), i.e. not contain parts of the plate edges or surroundings. In batch and timecourse mode, pyphe-quantify assumes that images were acquired using transmission scanning, where colonies appear darker then the surrounding agar. If this is not the case and you took images by reflective scanning or with a camera, use --negate False. In batch and timecourse mode, images are epxected to be grayscale. If they are not, they will be converted (by simply summing all channels) and a warning will be thrown.</p>\n<pre><code>usage: pyphe-quantify [-h] --grid GRID [--pattern PATTERN] [--t T] [--d D]\n                      [--s S] [--negate NEGATE] [--reportAll]\n                      [--reportFileNames]\n                      [--hardImageThreshold HARDIMAGETHRESHOLD]\n                      [--hardSizeThreshold HARDSIZETHRESHOLD] [--qc QC]\n                      [--out OUT]\n                      {batch,timecourse,redness}\n\npositional arguments:\n  {batch,timecourse,redness}\n                        Pyphe-quantify can be run in three different modes. In\n                        batch mode, it quantifies colony sizes for all images\n                        mathcing the pattern individually. A separate results\n                        table and qc image is produced for each. Redness mode\n                        is similar except that the redness of each colony is\n                        quantified. In timecourse mode, all images matching\n                        the pattern are analysed jointly. The final image\n                        matching the pattern is used to create a mask of where\n                        the colonies are and this mask is then applied to all\n                        previous images in the timeseries. A single output\n                        table, where the timepoints are the rows and each\n                        individual colony is a row.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --grid GRID           This option is required (all others have defaults set)\n                        and specifies the grid in which the colonies are\n                        arranged. The argument has to be in the form of 6\n                        integer numbers separated by \"-\": &lt;number of colony\n                        rows&gt;-&lt;number of colony columns&gt;-&lt;x-position of the\n                        top left colony&gt;-&lt;y-position of the top left\n                        colony&gt;-&lt;x-position of the bottom right\n                        colony&gt;-&lt;y-position of the bottom right colony&gt;.\n                        Positions must be integers and are the distance in\n                        number of pixels from the image origin in each\n                        dimension (x is width dimension, y is height\n                        dimension). The image origin is, in line with scikit-\n                        image, in the top left corner.\n  --pattern PATTERN     Pattern describing files to analyse. This follows\n                        standard unix convention and can be used to specify\n                        subfolders in which to look for images\n                        (&lt;subfolder&gt;/*.jpg) or the image format (*.tiff,\n                        *.png, etc.). By default, all jpg images in the\n                        working directory are analysed.\n  --t T                 By default the intensity threshold to distinguish\n                        colonies from the background is determined by the Otsu\n                        method. The determined value will be multiplied by\n                        this argument to give the final threshold. Useful for\n                        easily fine-tuning colony detection.\n  --d D                 The distance between two grid positions will be\n                        divided by this number to compute the maximum distance\n                        a putative colony can be away from its reference grid\n                        position. Decreasing this number towards 2 makes\n                        colony-to-grid-matching more permissive (might help\n                        when some of your plates are at a slight angle or out\n                        of position).\n  --s S                 Detected putative colonies will be filtered by size\n                        and small components (usually image noise) will be\n                        excluded. The default threshold is the image\n                        area*0.00005 and is therefore independent of scanning\n                        resolution. This default is then multiplied by this\n                        argument to give the final threshold. Useful for when\n                        colonies have unusual sizes.\n  --negate NEGATE       In images acquired by transmission scanning, the\n                        colonies are darker than the background. Before\n                        thresholding, the image needs to be inverted/negated.\n                        Ignored in redness mode.\n  --reportAll           Sometimes, two putative colonies are identified that\n                        are within the distance threshold of a grid position.\n                        By default, only the closest colony is reported. This\n                        can be changed by setting this option (without\n                        parameter). This option allows pyphe quantify to be\n                        used even if colonies are not arrayed in a regular\n                        grid (you still need to provide a grid parameter\n                        though that spans the colonies you are interested i).\n  --reportFileNames     Only for timecourse mode, otherwise ignored. Use\n                        filenames as index for output table instead of\n                        timepoints. Useful when the ordering of timepoints is\n                        not the same as returned by the pattern.\n  --hardImageThreshold HARDIMAGETHRESHOLD\n                        Allows a hard (fixed) intensity threshold in the range\n                        [0,1] to be used instead of Otsu thresholding. But\n                        images intensities are re-scaled to [0,1] before\n                        thresholding.\n  --hardSizeThreshold HARDSIZETHRESHOLD\n                        Allows a hard (fixed) size threshold [number of\n                        pixels] to be used for filtering small colonies.\n  --qc QC               Directory to save qc images in. Defaults to\n                        \"qc_images\".\n  --out OUT             Directory to save output files in. Defaults to\n                        \"pyphe_quant\".\n</code></pre>\n<h3>Pyphe-analyse</h3>\n<p><em>Pyphe-analyse</em> is a tool for spatial normalisation and data aggregation across many plates. It implements a grid normalisation based on the concept proposed by <a href=\"https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5015956/\" rel=\"nofollow\">Zackrisson et al. 2016</a> and row/column median normalisation. Please see our paper and the protocol in it to find out more. <em>Pyphe-analyse</em> can be run from the command line, with options below, or using the graphical user interface by running <em>pyphe-analyse-gui</em>.</p>\n<pre><code>usage: pyphe-analyse.txt [-h] --edt EDT --format\n                         {gitter,pyphe-redness,pyphe-growthcurves} [--out OUT]\n                         [--load_layouts]\n                         [--gridnorm {standard384,standard1536}]\n                         [--extrapolate_corners] [--rcmedian] [--check CHECK]\n                         [--qc_plots QC_PLOTS]\n\nWelcome to pyphe-analyse, part of the pyphe toolbox. Written by\nstephan.kamrad@crick.ac.uk and maintained at https://github.com/Bahler-\nLab/pyphe\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --edt EDT             Path to the Experimental Design Table (EDT) listing\n                        all plates of the experiment. The table must be in csv\n                        format, the first column must contain unique plate IDs\n                        and there must be a column named 'Data_path' that\n                        contains abolute or relative file paths to each\n                        plate's data file. A 'Layout_path' column can be\n                        included, see below. Any additional columns included\n                        in this file will bestored in each plate's meta-data\n                        and included in the final data output.\n  --format {gitter,pyphe-redness,pyphe-growthcurves}\n                        Type of inout data.\n  --out OUT             Specifies the path where to save the output data\n                        result. By default, the data report is saved in the\n                        working directory as \"pyphe-analyse_data_report.csv\"\n                        and will overwrite the file if it exists.\n  --load_layouts        Set this option (without parameters) to load layouts\n                        (requires Layout_path column in the EDT).\n  --gridnorm {standard384,standard1536}\n                        Perform reference grid normalisation. Standard384\n                        refers to plates which are in 384 (16x24) format with\n                        the reference grid in 96 format in the top left\n                        corner. Standard1536 refers to plates in 1536 format\n                        (32x48( with two 96 reference grids in the top left\n                        and bottom right corners.\n  --extrapolate_corners\n                        If working in standard1536 format, set this option to\n                        extrapolate the reference grid in the bottom left and\n                        top right corner. A linear regression will be trained\n                        across all top left and bottom right corners on plates\n                        in the experiment to predict hypothetical grid colony\n                        sizes in the other two corners.\n  --rcmedian            Perform row/column median normalisation. If --gridnorm\n                        will be performed first if both parameters are set.\n  --check CHECK         Check colony sizes after normalisation for negative\n                        and infinite colony sizes *(normalisation artefacts),\n                        throw a warning and set to NA.\n  --qc_plots QC_PLOTS   Specify a folder in which to save qc plots for each\n                        plate.\n\n</code></pre>\n<p>If you prefer to use the GUI, just run 'pyphe-analyse-gui'. You will need PySimpleGUI installed, which you can do by running 'pip install pysimplegui' in the terminal. It is deliberately not included in the package dependencies so 'pip install pyphe' won't install it for you.</p>\n<p><img alt=\"pyphe-analyse GUI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bd347e374e4bc51423d9b82bbb90a18cd7a239b8/68747470733a2f2f6769746875622e636f6d2f4261686c65722d4c61622f70797068652f626c6f622f6d61737465722f69636f6e732f6775692e706e67\"></p>\n<h3>Pyphe-interpret</h3>\n<p>Pyphe-interpret reports summary statistics and tests for differential fitness using t-tests. It is flexible and can in theory be used with any dataset in tidy format. Specifically, it was designed to answer two types of questions: (1) Check for each condition separately (--axis_column &lt;condition_column&gt;) if there is a significant difference in means between a mutant strain and a control strain (--grouping_column &lt;strain_id_column&gt;). Or (2) Check for each strain separately (--axis_column &lt;strain_id_column&gt;) if there is a significant difference in the means of the strain in the assay condition versus the control condition (--grouping_column &lt;condition_column&gt;). The second option tests for condition-specific growth effects (i.e. is does not return significant results if a strain is always faster or always slower growing than the grid strain).</p>\n<pre><code>usage: pyphe-interpret [-h] --ld LD [--out OUT] --axis_column AXIS_COLUMN\n                       --grouping_column GROUPING_COLUMN\n                       [--values_column VALUES_COLUMN] --control CONTROL\n                       [--ld_encoding LD_ENCODING]\n                       [--filter_circularity FILTER_CIRCULARITY]\n                       [--set_missing_na]\n\nWelcome to pyphe-interpret, part of the pyphe toolbox. Written by\nstephan.kamrad@crick.ac.uk and maintained at https://github.com/Bahler-\nLab/pyphe. Setting your column names correctly is crucial. Let us assume you\nhave measured many strains in many conditions. Now you would like to know for\neach strain-condition pair if it is significant. There are essentially two\nways of doing this. (1) Check for each condition separately (--axis_column\n&lt;condition_column&gt;) if there is a significant difference in means between a\nmutant strain and a control strain (--grouping_column &lt;strain_id_column&gt;). Or\n(2) Check for each strain separately (--axis_column &lt;strain_id_column&gt;) if\nthere is a significant difference in the means of the strain in the assay\ncondition versus the control condition (--grouping_column &lt;condition_column&gt;).\nThe second option tests for condition-specific growth effects (i.e. is does\nnot return significant results if a strain is always faster or always slower\ngrowing than the grid strain). In both cases you need to specify the control\nagainst which to test usiing --control and this has to be a value that appears\nin the axis column. You should define the dependent variable of the t-test\nusing --values_column.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --ld LD               Path to the Data Report Table produced by pyphe-\n                        analyse.\n  --out OUT             Specifies the path where to save the output data\n                        result. By default, a table with all replicates will\n                        be saved as pyphe-quantify-report_reps.csv and the\n                        statistic table will be saved as pyphe-quantify-\n                        report_summaryStats.csv in the current working\n                        directory. Existing files will be overwritten.\n  --axis_column AXIS_COLUMN\n                        Name of the column in the data report to repeat\n                        t-tests along. Data will be grouped by the\n                        grouping_column and differences between all unique\n                        values found in the axis column versus the specified\n                        control will be tested for.\n  --grouping_column GROUPING_COLUMN\n                        Name of the column in the data report to use as the\n                        grouping variable for t-tests.\n  --values_column VALUES_COLUMN\n                        Name of the column in the data report to use as\n                        fitness values. This will be the dependent variable\n                        for t-tests. Defaults to \"Colony_size_corr_checked\".\n  --control CONTROL     Name of the control to compare against. This must be a\n                        value found in the axis column.\n  --ld_encoding LD_ENCODING\n                        Encoding of the data report table to be passed to\n                        pandas.read_csv().\n  --filter_circularity FILTER_CIRCULARITY\n                        Exclude colonies from the analysis with a circularity\n                        below the one specified. A circularity of 1\n                        corresponds to a perfect circle. We recommend a\n                        threshold around 0.85.\n  --set_missing_na      Set 0-sized colonies to NA. This is recommended if you\n                        expect no missing colonies in your data, which means\n                        these are probably due to pinning errors.\n</code></pre>\n\n          </div>"}, "last_serial": 7012926, "releases": {"0.92.20200115": [{"comment_text": "", "digests": {"md5": "94d9a980e63a01589073e07c28f8e94c", "sha256": "ccf4705a6a334fa747d2c14a3d241dd76a9a25e75233b9dab51d9753555a2303"}, "downloads": -1, "filename": "pyphe-0.92.20200115-py3-none-any.whl", "has_sig": false, "md5_digest": "94d9a980e63a01589073e07c28f8e94c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 35588, "upload_time": "2020-01-15T22:37:13", "upload_time_iso_8601": "2020-01-15T22:37:13.716361Z", "url": "https://files.pythonhosted.org/packages/72/1c/5cf65d30a052d55f51e7b2ec118aa54761284b15e7b1a666ee5db8e81d60/pyphe-0.92.20200115-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1233ec5463e37fa52ad958fa09536e8e", "sha256": "6faf5df0bfa72df3dfdecd2e70d83f0c3da1773219516ed2a5ab0fdf845466e4"}, "downloads": -1, "filename": "pyphe-0.92.20200115.tar.gz", "has_sig": false, "md5_digest": "1233ec5463e37fa52ad958fa09536e8e", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 34724, "upload_time": "2020-01-15T22:37:18", "upload_time_iso_8601": "2020-01-15T22:37:18.764663Z", "url": "https://files.pythonhosted.org/packages/94/3b/3f5caae2d27cd14e61496bf821daafa977451a7366cca834c0d65835bebe/pyphe-0.92.20200115.tar.gz", "yanked": false}], "0.92.20200205": [{"comment_text": "", "digests": {"md5": "ddb882cd1c93a26087adee05d68a299e", "sha256": "11cbbd0ae63d296e940e5c5832e879b8f5ae14a131d9d19a924de9b81d465254"}, "downloads": -1, "filename": "pyphe-0.92.20200205-py3-none-any.whl", "has_sig": false, "md5_digest": "ddb882cd1c93a26087adee05d68a299e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 36043, "upload_time": "2020-02-05T12:57:48", "upload_time_iso_8601": "2020-02-05T12:57:48.959947Z", "url": "https://files.pythonhosted.org/packages/bf/be/330dadcb8a1e3ff80f54fb0e9038c590e485a6120e6d1dd7b526d303548b/pyphe-0.92.20200205-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "eb0f3b5709d98b169606e4efcad1dbf0", "sha256": "5952339a5bdedf7f0a94d4cf23c64a85967815af94efd462547a96f6c404f12f"}, "downloads": -1, "filename": "pyphe-0.92.20200205.tar.gz", "has_sig": false, "md5_digest": "eb0f3b5709d98b169606e4efcad1dbf0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 35298, "upload_time": "2020-02-05T12:57:50", "upload_time_iso_8601": "2020-02-05T12:57:50.259741Z", "url": "https://files.pythonhosted.org/packages/18/2e/1b042240aa6d684f4fb627e3ae09e2d3f0d4305e3477d785d19619024421/pyphe-0.92.20200205.tar.gz", "yanked": false}], "0.94.20200329": [{"comment_text": "", "digests": {"md5": "48faec7a0503bff0c851f45aaa0c1f1f", "sha256": "30303764b9f4e9174ccbc7107a1d84ad6d85c956d3bdbfa36f64a1048f983d1f"}, "downloads": -1, "filename": "pyphe-0.94.20200329-py3-none-any.whl", "has_sig": false, "md5_digest": "48faec7a0503bff0c851f45aaa0c1f1f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 41975, "upload_time": "2020-03-29T13:25:43", "upload_time_iso_8601": "2020-03-29T13:25:43.602670Z", "url": "https://files.pythonhosted.org/packages/31/f7/2852ef8fcc55bee85b735aa5f726ddf4857c4dc73f47222ade0b5011050c/pyphe-0.94.20200329-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "eeb565885b5ecbb941ee4e18e31ea3af", "sha256": "c460a117dbefe82851e66cbf4892a276af1abb483c95c50d1ff703a7ac6e1f12"}, "downloads": -1, "filename": "pyphe-0.94.20200329.tar.gz", "has_sig": false, "md5_digest": "eeb565885b5ecbb941ee4e18e31ea3af", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 39388, "upload_time": "2020-03-29T13:25:45", "upload_time_iso_8601": "2020-03-29T13:25:45.094463Z", "url": "https://files.pythonhosted.org/packages/49/64/c18955d03d9a169a52a44462c334960a8b49f22164ab9bab8bca534e0d6f/pyphe-0.94.20200329.tar.gz", "yanked": false}], "0.95": [{"comment_text": "", "digests": {"md5": "c3d6bbf24ad195f56dfb1bc05b305e46", "sha256": "6020097d83d20c2d2a843f40fdea17ac2c14128503904254dfe75f247e9c1b29"}, "downloads": -1, "filename": "pyphe-0.95-py3-none-any.whl", "has_sig": false, "md5_digest": "c3d6bbf24ad195f56dfb1bc05b305e46", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 43869, "upload_time": "2020-04-13T21:30:19", "upload_time_iso_8601": "2020-04-13T21:30:19.817159Z", "url": "https://files.pythonhosted.org/packages/e3/35/55cb4514309e9651f6df0be57699e70fdd7491a9b494510c39e60e15f837/pyphe-0.95-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b835b8266e842391248f8fb664780414", "sha256": "3d8225d8cfb0275fc64015a345238e687d57add68972770503f0595c7bae2cc8"}, "downloads": -1, "filename": "pyphe-0.95.tar.gz", "has_sig": false, "md5_digest": "b835b8266e842391248f8fb664780414", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 45170, "upload_time": "2020-04-13T21:30:21", "upload_time_iso_8601": "2020-04-13T21:30:21.184290Z", "url": "https://files.pythonhosted.org/packages/27/07/b25c1758c15a8f81068a271f211cd77e2593b6172465bec968a18160ae9a/pyphe-0.95.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c3d6bbf24ad195f56dfb1bc05b305e46", "sha256": "6020097d83d20c2d2a843f40fdea17ac2c14128503904254dfe75f247e9c1b29"}, "downloads": -1, "filename": "pyphe-0.95-py3-none-any.whl", "has_sig": false, "md5_digest": "c3d6bbf24ad195f56dfb1bc05b305e46", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 43869, "upload_time": "2020-04-13T21:30:19", "upload_time_iso_8601": "2020-04-13T21:30:19.817159Z", "url": "https://files.pythonhosted.org/packages/e3/35/55cb4514309e9651f6df0be57699e70fdd7491a9b494510c39e60e15f837/pyphe-0.95-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b835b8266e842391248f8fb664780414", "sha256": "3d8225d8cfb0275fc64015a345238e687d57add68972770503f0595c7bae2cc8"}, "downloads": -1, "filename": "pyphe-0.95.tar.gz", "has_sig": false, "md5_digest": "b835b8266e842391248f8fb664780414", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 45170, "upload_time": "2020-04-13T21:30:21", "upload_time_iso_8601": "2020-04-13T21:30:21.184290Z", "url": "https://files.pythonhosted.org/packages/27/07/b25c1758c15a8f81068a271f211cd77e2593b6172465bec968a18160ae9a/pyphe-0.95.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:59:40 2020"}