{"info": {"author": "Hayden Flinner", "author_email": "hayden@flinner.me", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "Welcome to cachepath's documentation!\n======================================\n\n.. image:: https://img.shields.io/pypi/v/cachepath.svg\n        :target: https://pypi.python.org/pypi/cachepath\n\n.. image:: https://img.shields.io/travis/haydenflinner/cachepath.svg\n        :target: https://travis-ci.org/haydenflinner/cachepath\n\n.. image:: https://readthedocs.org/projects/cachepath/badge/?version=latest\n        :target: https://cachepath.readthedocs.io/en/latest/?badge=latest\n        :alt: Documentation Status\n\nA small package for pythonic parameterized cache paths.\n\nGetting Started\n----------------\n\n**Install:** ``pip install cachepath``\n\n**Import:** ``from cachepath import CachePath, TempPath, Path``\n\n**Docs:** `ReadTheDocs`_ | `API doc is here`_\n\n**Why?**\n    1. Integrates ``pathlib`` with ``tempfile.gettempdir`` and ``shutil.rmtree`` by providing ``TempPath`` and ``Path.rm()``::\n\n          path = TempPath()\n          path.rm()\n          # or would you rather..\n          path = None\n          with tempfile.NamedTemporaryFile(delete=False) as f:\n              path = Path(f.name)\n          # Only now can we use Path. If we tried using it within the With\n          # (for example for path.read_text()), we'd break on Windows\n          path.unlink()  # only if file, doesn't work on folders\n\n    2. Wraps ``pathlib`` import for Py2/3 compat. (not in ``six``!)::\n\n          from cachepath import Path\n          # or\n          try: from pathlib import Path; except ImportError: from pathlib2 import Path\n\n    3. Provides `CachePath`_, which lets you quickly get a parameterized temp filename, with all folders automatically created::\n\n          r = CachePath(date, userid, 'expensive_results.txt')\n          assert (r == Path('/tmp/', date, userid, 'expensive_results.txt')\n                  and r.parent.exists())\n          r.rm()  # File remove\n          r.parent.rm()  # Symmetric with folder remove!\n\n          # Without cachepath\n          p = Path(tempfile.gettempdir(), date, userid, 'expensive_results.txt').\n          # Don't update timestamp if it already exists so that we don't cause\n          # Make-like tools to always think something's changed\n          if not p.parent.exists():\n              p.parent.mkdir(parents=True, exist_ok=True)\n\n          p.unlink()  # Why is it .unlink() instead of .remove()?\n          # Why .remove and .unlink, but mkdir instead of createdir?\n          p.parent.remove()\n          # .remove() might throw because there was another file in the folder,\n          # but we didn't care, they're tempfiles!\n          import shutil\n          shutil.rmtree(p.parent)\n\n**Why, but longer:**\n\nDo you need a temp path to pass to some random tool for its logfile?\nBehold, a gaping hole in ``pathlib``::\n\n    import tempfile\n    import os\n    try: from pathlib import Path; except ImportError: from pathlib2 import Path\n    def get_tempfile():\n        fd, loc = tempfile.mkstemp()\n        os.close(fd)  # If we forgot do this, it would stay open until process exit\n        return Path(loc)\n\n    # Easier way\n    from cachepath import TempPath\n    def get_tempfile():\n        return TempPath()  # Path('/tmp/213kjdsrandom')\n\n\nBut this module is called cachepath, not temppath, what gives?\n\nSuppose I'm running that same imaginary tool pretty often, but I'd like to skip running\nit if I already have results for a certain day. Just sticking some identifying info into a filename\nshould be good enough.\nSomething like ``Path('/tmp/20181204_toolresults.txt')`` ::\n\n    # try: from pathlib import Path; except ImportError: from pathlib2 import Path\n    # We'll cheat a little to get py2/3 compat without so much ugliness\n    from cachepath import Path\n    import tempfile\n    def get_tempfile(date):\n        filename = '{}_toolresults.txt'.format(date)\n        return Path(tempfile.gettempdir(), filename)\n\n    # Easier to do this...\n    from cachepath import CachePath\n    def get_tempfile(date):\n        return CachePath(date, suffix='.txt')\n\nNot bad, but not great. But our requirements changed, let's go a step further.\n\nNow I'm running this tool *a lot*, over a tree of data that looks\nlike this::\n\n    2018-12-23\n        person1\n        person2\n    2018-12-24\n        person1\n    2018-12-25\n        person1\n\nI want my logs to be structured the same way.  How hard can it be? ::\n\n    2018-12-23/\n        person1_output.txt\n        person2_output.txt\n    2018-12-24/\n        person1_output.txt\n    2018-12-25/\n        person1_output.txt\n\nLet's find out::\n\n    # Let's get the easy way out of the way first :)\n    def get_path(date, person):\n        return CachePath(date, person, suffix='_output.txt')\n        # Automatically ensures /tmp/date/ exists when we create the CachePath!\n\n    # Now the hard way\n    def get_path(date, person):\n        personfilename = '{p}_output.txt'.format(p=person)\n        returning = Path(tempfile.gettempdir())/date/personfilename\n        # Does this mkdir update the modified timestamp of the folders we're in?\n        # Might matter if we're part of a larger toolset...\n        returning.parent.mkdir(exist_ok=True, parents=True)\n        return returning\n\nSuppose we hadn't remembered to make the ``$date/`` folders. When we passed the\nPath out to another tool, or tried to .open it,\nwe may have gotten a Permission Denied\nerror on Unix systems rather than the \"File/Folder not found\" you might expect.\nWith CachePath, this can't happen. Creating a CachePath implicitly creates all\nof the preceding directories necessary for your file to exist.\n\nNow, suppose we found a bug in this external tool we were using and we're going\nto re-run it for a day.\nHow do we clear out that day's results so that we can be sure we're looking\nat fresh output from the tool? Well, with CachePath, it's just::\n\n  def easy_clear_date(date):\n      CachePath(date).clear()  # rm -r /tmp/date/*\n\nBut if you don't have cachepath, you'll find that most Python libs play it\npretty safe when it comes to files. Path.remove() requires the folder to be empty,\nand doesn't provide a way to empty the folder. Not to mention, what if our results\nfolders had special permissions, or was actually a symlink, and we had write access\nbut not delete? Oh well,\nlet's see what we can do::\n\n  def hard_clear_date(date):\n      # We happen to know that date is a folder and not a file (at least in our\n      # current design), so we know we need some form of .remove() rather than\n      # .unlink(). Unfortunately, pathlib doesn't offer one for folders with\n      # files still in them. If you google how to do it, you will find plenty of\n      # answers, one of which is a pure pathlib recursive solution! But we're lazy,\n      # so lets bring in yet another module:\n      p = Path(tempfile.gettempdir(), date)\n      import shutil\n      if p.exists():\n          shutil.rmtree(p)\n      p.mkdir(exist_ok=True, parents=True)\n      # This still isn't exactly equivalent to CachePath.clear(), because we've\n      # lost whatever permissions were set on the date folder, and if it were\n      # actually a symlink to somewhere else, that's gone now.\n\nConvinced yet? ``pip install cachepath`` or copy `the source`_ into your local\n``utils.py`` (you know you have one.)\n\n`API doc is here`_.\n\n\nBy the way, as a side effect of importing ``cachepath``, all Paths get the ability\nto do ``rm()`` and ``clear()``.\n\n\nShameless Promo\n----------------\nFind yourself working with paths a lot in cmd-line tools? You might like\n`invoke`_ and/or `magicinvoke`_!\n\n\n\n.. [*] The source for CachePath can be downloaded from the `Github repo`_.\n\n.. _Github repo: https://github.com/haydenflinner/cachepath\n.. [*] This package was created with Cookiecutter_ and the `audreyr/cookiecutter-pypackage`_ project template.\n\n.. _`the source`: https://github.com/haydenflinner/cachepath/blob/master/cachepath/__init__.py\n.. _Cookiecutter: https://github.com/audreyr/cookiecutter\n.. _`audreyr/cookiecutter-pypackage`: https://github.com/audreyr/cookiecutter-pypackage\n.. _`invoke`: https://www.pyinvoke.org\n.. _`magicinvoke`: https://magicinvoke.readthedocs.io/en/latest/\n.. _`ReadTheDocs`: https://cachepath.readthedocs.io/en/latest/\n.. _`API doc is here`: https://cachepath.readthedocs.io/en/latest/cachepath.html\n.. _`CachePath`: https://cachepath.readthedocs.io/en/latest/cachepath.html#cachepath.CachePath\n\n\n=======\nHistory\n=======\n\n1.0.0 (2018-12-08)\n------------------\n\n* Big doc updates. 1.0.0 to symbolize SemVer adherence.\n\n0.1.0 (2018-12-08)\n------------------\n\n* First release on PyPI. Adds CachePath, TempPath, Path.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/haydenflinner/cachepath", "keywords": "cachepath,paths,pathlib,cache,temp", "license": "MIT license", "maintainer": "", "maintainer_email": "", "name": "cachepath", "package_url": "https://pypi.org/project/cachepath/", "platform": "", "project_url": "https://pypi.org/project/cachepath/", "project_urls": {"Homepage": "https://github.com/haydenflinner/cachepath"}, "release_url": "https://pypi.org/project/cachepath/1.1.1/", "requires_dist": null, "requires_python": "", "summary": "Pythonic parameterized cache paths.", "version": "1.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://pypi.python.org/pypi/cachepath\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/cachepath.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7fcdf6e71bb6d5aaadf52227c3c29fa34b629cfa/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6361636865706174682e737667\"></a>\n<a href=\"https://travis-ci.org/haydenflinner/cachepath\" rel=\"nofollow\"><img alt=\"https://img.shields.io/travis/haydenflinner/cachepath.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3c81afbf8887c07176362f8b65e9f84be47098a2/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f68617964656e666c696e6e65722f6361636865706174682e737667\"></a>\n<a href=\"https://cachepath.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b798b6b571ddc1f3b02fcb2aab6fc554f04ee913/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f6361636865706174682f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<p>A small package for pythonic parameterized cache paths.</p>\n<div id=\"getting-started\">\n<h2>Getting Started</h2>\n<p><strong>Install:</strong> <tt>pip install cachepath</tt></p>\n<p><strong>Import:</strong> <tt>from cachepath import CachePath, TempPath, Path</tt></p>\n<p><strong>Docs:</strong> <a href=\"https://cachepath.readthedocs.io/en/latest/\" rel=\"nofollow\">ReadTheDocs</a> | <a href=\"https://cachepath.readthedocs.io/en/latest/cachepath.html\" rel=\"nofollow\">API doc is here</a></p>\n<dl>\n<dt><strong>Why?</strong></dt>\n<dd><ol>\n<li><p>Integrates <tt>pathlib</tt> with <tt>tempfile.gettempdir</tt> and <tt>shutil.rmtree</tt> by providing <tt>TempPath</tt> and <tt>Path.rm()</tt>:</p>\n<pre>path = TempPath()\npath.rm()\n# or would you rather..\npath = None\nwith tempfile.NamedTemporaryFile(delete=False) as f:\n    path = Path(f.name)\n# Only now can we use Path. If we tried using it within the With\n# (for example for path.read_text()), we'd break on Windows\npath.unlink()  # only if file, doesn't work on folders\n</pre>\n</li>\n<li><p>Wraps <tt>pathlib</tt> import for Py2/3 compat. (not in <tt>six</tt>!):</p>\n<pre>from cachepath import Path\n# or\ntry: from pathlib import Path; except ImportError: from pathlib2 import Path\n</pre>\n</li>\n<li><p>Provides <a href=\"https://cachepath.readthedocs.io/en/latest/cachepath.html#cachepath.CachePath\" rel=\"nofollow\">CachePath</a>, which lets you quickly get a parameterized temp filename, with all folders automatically created:</p>\n<pre>r = CachePath(date, userid, 'expensive_results.txt')\nassert (r == Path('/tmp/', date, userid, 'expensive_results.txt')\n        and r.parent.exists())\nr.rm()  # File remove\nr.parent.rm()  # Symmetric with folder remove!\n\n# Without cachepath\np = Path(tempfile.gettempdir(), date, userid, 'expensive_results.txt').\n# Don't update timestamp if it already exists so that we don't cause\n# Make-like tools to always think something's changed\nif not p.parent.exists():\n    p.parent.mkdir(parents=True, exist_ok=True)\n\np.unlink()  # Why is it .unlink() instead of .remove()?\n# Why .remove and .unlink, but mkdir instead of createdir?\np.parent.remove()\n# .remove() might throw because there was another file in the folder,\n# but we didn't care, they're tempfiles!\nimport shutil\nshutil.rmtree(p.parent)\n</pre>\n</li>\n</ol>\n</dd>\n</dl>\n<p><strong>Why, but longer:</strong></p>\n<p>Do you need a temp path to pass to some random tool for its logfile?\nBehold, a gaping hole in <tt>pathlib</tt>:</p>\n<pre>import tempfile\nimport os\ntry: from pathlib import Path; except ImportError: from pathlib2 import Path\ndef get_tempfile():\n    fd, loc = tempfile.mkstemp()\n    os.close(fd)  # If we forgot do this, it would stay open until process exit\n    return Path(loc)\n\n# Easier way\nfrom cachepath import TempPath\ndef get_tempfile():\n    return TempPath()  # Path('/tmp/213kjdsrandom')\n</pre>\n<p>But this module is called cachepath, not temppath, what gives?</p>\n<p>Suppose I\u2019m running that same imaginary tool pretty often, but I\u2019d like to skip running\nit if I already have results for a certain day. Just sticking some identifying info into a filename\nshould be good enough.\nSomething like <tt><span class=\"pre\">Path('/tmp/20181204_toolresults.txt')</span></tt></p>\n<pre># try: from pathlib import Path; except ImportError: from pathlib2 import Path\n# We'll cheat a little to get py2/3 compat without so much ugliness\nfrom cachepath import Path\nimport tempfile\ndef get_tempfile(date):\n    filename = '{}_toolresults.txt'.format(date)\n    return Path(tempfile.gettempdir(), filename)\n\n# Easier to do this...\nfrom cachepath import CachePath\ndef get_tempfile(date):\n    return CachePath(date, suffix='.txt')\n</pre>\n<p>Not bad, but not great. But our requirements changed, let\u2019s go a step further.</p>\n<p>Now I\u2019m running this tool <em>a lot</em>, over a tree of data that looks\nlike this:</p>\n<pre>2018-12-23\n    person1\n    person2\n2018-12-24\n    person1\n2018-12-25\n    person1\n</pre>\n<p>I want my logs to be structured the same way.  How hard can it be?</p>\n<pre>2018-12-23/\n    person1_output.txt\n    person2_output.txt\n2018-12-24/\n    person1_output.txt\n2018-12-25/\n    person1_output.txt\n</pre>\n<p>Let\u2019s find out:</p>\n<pre># Let's get the easy way out of the way first :)\ndef get_path(date, person):\n    return CachePath(date, person, suffix='_output.txt')\n    # Automatically ensures /tmp/date/ exists when we create the CachePath!\n\n# Now the hard way\ndef get_path(date, person):\n    personfilename = '{p}_output.txt'.format(p=person)\n    returning = Path(tempfile.gettempdir())/date/personfilename\n    # Does this mkdir update the modified timestamp of the folders we're in?\n    # Might matter if we're part of a larger toolset...\n    returning.parent.mkdir(exist_ok=True, parents=True)\n    return returning\n</pre>\n<p>Suppose we hadn\u2019t remembered to make the <tt>$date/</tt> folders. When we passed the\nPath out to another tool, or tried to .open it,\nwe may have gotten a Permission Denied\nerror on Unix systems rather than the \u201cFile/Folder not found\u201d you might expect.\nWith CachePath, this can\u2019t happen. Creating a CachePath implicitly creates all\nof the preceding directories necessary for your file to exist.</p>\n<p>Now, suppose we found a bug in this external tool we were using and we\u2019re going\nto re-run it for a day.\nHow do we clear out that day\u2019s results so that we can be sure we\u2019re looking\nat fresh output from the tool? Well, with CachePath, it\u2019s just:</p>\n<pre>def easy_clear_date(date):\n    CachePath(date).clear()  # rm -r /tmp/date/*\n</pre>\n<p>But if you don\u2019t have cachepath, you\u2019ll find that most Python libs play it\npretty safe when it comes to files. Path.remove() requires the folder to be empty,\nand doesn\u2019t provide a way to empty the folder. Not to mention, what if our results\nfolders had special permissions, or was actually a symlink, and we had write access\nbut not delete? Oh well,\nlet\u2019s see what we can do:</p>\n<pre>def hard_clear_date(date):\n    # We happen to know that date is a folder and not a file (at least in our\n    # current design), so we know we need some form of .remove() rather than\n    # .unlink(). Unfortunately, pathlib doesn't offer one for folders with\n    # files still in them. If you google how to do it, you will find plenty of\n    # answers, one of which is a pure pathlib recursive solution! But we're lazy,\n    # so lets bring in yet another module:\n    p = Path(tempfile.gettempdir(), date)\n    import shutil\n    if p.exists():\n        shutil.rmtree(p)\n    p.mkdir(exist_ok=True, parents=True)\n    # This still isn't exactly equivalent to CachePath.clear(), because we've\n    # lost whatever permissions were set on the date folder, and if it were\n    # actually a symlink to somewhere else, that's gone now.\n</pre>\n<p>Convinced yet? <tt>pip install cachepath</tt> or copy <a href=\"https://github.com/haydenflinner/cachepath/blob/master/cachepath/__init__.py\" rel=\"nofollow\">the source</a> into your local\n<tt>utils.py</tt> (you know you have one.)</p>\n<p><a href=\"https://cachepath.readthedocs.io/en/latest/cachepath.html\" rel=\"nofollow\">API doc is here</a>.</p>\n<p>By the way, as a side effect of importing <tt>cachepath</tt>, all Paths get the ability\nto do <tt>rm()</tt> and <tt>clear()</tt>.</p>\n</div>\n<div id=\"shameless-promo\">\n<h2>Shameless Promo</h2>\n<p>Find yourself working with paths a lot in cmd-line tools? You might like\n<a href=\"https://www.pyinvoke.org\" rel=\"nofollow\">invoke</a> and/or <a href=\"https://magicinvoke.readthedocs.io/en/latest/\" rel=\"nofollow\">magicinvoke</a>!</p>\n<table id=\"id1\">\n<col><col>\n<tbody>\n<tr><td>[*]</td><td>The source for CachePath can be downloaded from the <a href=\"https://github.com/haydenflinner/cachepath\" rel=\"nofollow\">Github repo</a>.</td></tr>\n</tbody>\n</table>\n<table id=\"id2\">\n<col><col>\n<tbody>\n<tr><td>[\u2020]</td><td>This package was created with <a href=\"https://github.com/audreyr/cookiecutter\" rel=\"nofollow\">Cookiecutter</a> and the <a href=\"https://github.com/audreyr/cookiecutter-pypackage\" rel=\"nofollow\">audreyr/cookiecutter-pypackage</a> project template.</td></tr>\n</tbody>\n</table>\n<div id=\"history\">\n<h3>History</h3>\n</div>\n</div>\n<div id=\"id3\">\n<h2>1.0.0 (2018-12-08)</h2>\n<ul>\n<li>Big doc updates. 1.0.0 to symbolize SemVer adherence.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h2>0.1.0 (2018-12-08)</h2>\n<ul>\n<li>First release on PyPI. Adds CachePath, TempPath, Path.</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 4577535, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "d798d226e86e67977174ae53d89c7a7a", "sha256": "b40d75a705ac533d85454c2c41a373e4bff23cbdbba0df4fb7c10cca9e4fb13f"}, "downloads": -1, "filename": "cachepath-0.1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d798d226e86e67977174ae53d89c7a7a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 6948, "upload_time": "2018-12-08T20:51:15", "upload_time_iso_8601": "2018-12-08T20:51:15.687965Z", "url": "https://files.pythonhosted.org/packages/0b/eb/3c85b64ce629bd8542153199c7a4b2484e93a085e236de13cf4a4a5b505f/cachepath-0.1.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "92ce22ee1c4690b9b0b15a43f833c280", "sha256": "6e312e55b799e3348b9b10829697be568d138d1a4880fe3373d5360535050965"}, "downloads": -1, "filename": "cachepath-0.1.1.tar.gz", "has_sig": false, "md5_digest": "92ce22ee1c4690b9b0b15a43f833c280", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11894, "upload_time": "2018-12-08T20:51:17", "upload_time_iso_8601": "2018-12-08T20:51:17.434685Z", "url": "https://files.pythonhosted.org/packages/c8/10/5bc0e19d589e5a2847ed0591d97811ad05a1008c39d449e203850ca1c648/cachepath-0.1.1.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "8075bc3ec2134756653e5f72e3645e17", "sha256": "1176c7923dfdb0d6c5244528875d3e5aada779611f1d4b2a6d8f388da5d11b2d"}, "downloads": -1, "filename": "cachepath-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "8075bc3ec2134756653e5f72e3645e17", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 6909, "upload_time": "2018-12-08T22:29:52", "upload_time_iso_8601": "2018-12-08T22:29:52.602786Z", "url": "https://files.pythonhosted.org/packages/85/db/7617f836d6b93a7051907cfd281bd6a55bc4e23afb77201179e52ffbeb1d/cachepath-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7b45d08076e379f5e609294fa9bfeee7", "sha256": "300c333732451daf65c832799259628b8f14e8441e53c5e442739f316b912892"}, "downloads": -1, "filename": "cachepath-1.0.0.tar.gz", "has_sig": false, "md5_digest": "7b45d08076e379f5e609294fa9bfeee7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12117, "upload_time": "2018-12-08T22:29:53", "upload_time_iso_8601": "2018-12-08T22:29:53.804628Z", "url": "https://files.pythonhosted.org/packages/7c/50/ce7b8003de738d6b2aecffcecfc467beb9e52e48f27dccc15bf51e42985d/cachepath-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "d1c5c225bb40c5fa9b5f3bc58dc0ee99", "sha256": "aac9d60fc27b62226eda1ffe212d6c1cac01847299327446018a61e742f06950"}, "downloads": -1, "filename": "cachepath-1.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d1c5c225bb40c5fa9b5f3bc58dc0ee99", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 6907, "upload_time": "2018-12-08T22:28:42", "upload_time_iso_8601": "2018-12-08T22:28:42.692156Z", "url": "https://files.pythonhosted.org/packages/aa/58/959ecefba0335e3769721ffdc490ced3f1a1bee3e76fb0e53e3e7244ad05/cachepath-1.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a8243c47cc05fabca1ac3295cbd94b4b", "sha256": "411a0ba053be144f16b7f5985e7ae17e3da3dbbec515132bf7125d4708713da5"}, "downloads": -1, "filename": "cachepath-1.0.1.tar.gz", "has_sig": false, "md5_digest": "a8243c47cc05fabca1ac3295cbd94b4b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12133, "upload_time": "2018-12-08T22:28:43", "upload_time_iso_8601": "2018-12-08T22:28:43.676806Z", "url": "https://files.pythonhosted.org/packages/70/73/f82fa27187005c4a77fbdab11f569835235b5514474682ad7b17b83654e3/cachepath-1.0.1.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "79e571db62652259e75fd5a85cc30b8e", "sha256": "9b7541ae9e2a4ef285c3b37ee010dd54283542df72f4df9dbc2f0d297bd7f12c"}, "downloads": -1, "filename": "cachepath-1.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "79e571db62652259e75fd5a85cc30b8e", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 6911, "upload_time": "2018-12-08T22:37:12", "upload_time_iso_8601": "2018-12-08T22:37:12.240983Z", "url": "https://files.pythonhosted.org/packages/59/46/5a4f116e284348e4bb836f33695cd160a750e17c7435820f9be95095dc28/cachepath-1.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a187948874530e68f5befce92b0c025a", "sha256": "0a904873ddfbb28cd7ea212f98ed782486b8d3b220791003cdf6b703db478740"}, "downloads": -1, "filename": "cachepath-1.1.0.tar.gz", "has_sig": false, "md5_digest": "a187948874530e68f5befce92b0c025a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12123, "upload_time": "2018-12-08T22:37:13", "upload_time_iso_8601": "2018-12-08T22:37:13.498992Z", "url": "https://files.pythonhosted.org/packages/2a/cd/4968309a462865f4e3bccce04f8972e7d30bb0567ab613c20124179ef0ea/cachepath-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "6b3a26605814ffbeaa4a7aaf1a581b73", "sha256": "8a92ec61cc2bc40401bda656b47bdb3b16234e500357ff66edd8f8a2c7524b7c"}, "downloads": -1, "filename": "cachepath-1.1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "6b3a26605814ffbeaa4a7aaf1a581b73", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8048, "upload_time": "2018-12-09T15:09:46", "upload_time_iso_8601": "2018-12-09T15:09:46.161877Z", "url": "https://files.pythonhosted.org/packages/fb/fd/24affbd7937f761c2b7e8afb587651907a191998d3ba1a7c28b6b1d03e02/cachepath-1.1.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ea7ba79bbccd06842a46d9717fe32375", "sha256": "a9a511a5c2e12f1b0ed53111446851e8843bd895a1055356a179a679a9f21bcc"}, "downloads": -1, "filename": "cachepath-1.1.1.tar.gz", "has_sig": false, "md5_digest": "ea7ba79bbccd06842a46d9717fe32375", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13470, "upload_time": "2018-12-09T15:09:47", "upload_time_iso_8601": "2018-12-09T15:09:47.610068Z", "url": "https://files.pythonhosted.org/packages/47/da/e1cf0731f9a5086e4278096093bab00d7754242394cb18e1bbedf31bf7aa/cachepath-1.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6b3a26605814ffbeaa4a7aaf1a581b73", "sha256": "8a92ec61cc2bc40401bda656b47bdb3b16234e500357ff66edd8f8a2c7524b7c"}, "downloads": -1, "filename": "cachepath-1.1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "6b3a26605814ffbeaa4a7aaf1a581b73", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8048, "upload_time": "2018-12-09T15:09:46", "upload_time_iso_8601": "2018-12-09T15:09:46.161877Z", "url": "https://files.pythonhosted.org/packages/fb/fd/24affbd7937f761c2b7e8afb587651907a191998d3ba1a7c28b6b1d03e02/cachepath-1.1.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ea7ba79bbccd06842a46d9717fe32375", "sha256": "a9a511a5c2e12f1b0ed53111446851e8843bd895a1055356a179a679a9f21bcc"}, "downloads": -1, "filename": "cachepath-1.1.1.tar.gz", "has_sig": false, "md5_digest": "ea7ba79bbccd06842a46d9717fe32375", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13470, "upload_time": "2018-12-09T15:09:47", "upload_time_iso_8601": "2018-12-09T15:09:47.610068Z", "url": "https://files.pythonhosted.org/packages/47/da/e1cf0731f9a5086e4278096093bab00d7754242394cb18e1bbedf31bf7aa/cachepath-1.1.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:35:43 2020"}