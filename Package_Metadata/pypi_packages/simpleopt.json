{"info": {"author": "Nilton Volpato", "author_email": "nilton dot volpato | gmail com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: User Interfaces", "Topic :: Terminals"], "description": "simpleopt - a simple parser for options in command line\n=======================================================\n\nUsage Example\n-------------\n\nYou just define a function, and optionally annotate the type of the\nparameters, the same arguments will be parsed on the command line::\n\n  @annotation(command=str, interval=float, differences=bool,\n              args=str, kwargs=str)\n  def watch(command, interval=2.0, differences=False, *args, **kwargs):\n      print (command, interval, differences, args, kwargs)\n\n  if __name__ == '__main__':\n      SimpleOpt(watch).run()\n\nThen you can call it like this, supposing you saved it on a file named\nwatch.py and made it executable::\n\n  $ watch.py \"df -h\"\n  ('df -h', 2.0, False, (), {})\n\n  $ watch.py --interval 1.0 \"df -h\"\n  ('df -h', 1.0, False, (), {})\n\n  $ watch.py --noverbose --differences \"df -h\"\n  ('df -h', 1.0, True, (), {})\n\n  $ watch.py --foo bar --bar baz \"df -h\" quux quuux\n  ('df -h', 2.0, False, ('quux', 'quuux'), {'foo': 'bar', 'bar': 'baz'})\n\nAnother example::\n\n  @annotation(foo={str:int})\n  def example(foo):\n      return foo\n\n  $ example.py --foo a:1,b:2,c:3\n  {'a': 1, 'c': 3, 'b': 2}\n\n  $ example.py a:1,b:2,c:3\n  {'a': 1, 'c': 3, 'b': 2}\n\n\nWorking details\n---------------\n\nThe command-line arguments are classified in one of two types: (i) option\narguments and (ii) positional arguments.\n\n  (i) option arguments have the form --OPTION or --OPTION=VALUE where\n      OPTION is the argument name and VALUE is an optional value given to\n      that argument.\n\n  (ii) positional arguments are those that are not option arguments.\n\nThe way that command-line arguments are assigned to the function's formal\nparameters differ from the way that python assigns input arguments in python\ncode.\n\nWhen a python script is run on the command line, the command-line arguments are\nassigned to the function's formal parameters as follows:\n\n  - For each formal parameter, there is a slot which will be used to contain\n    the value of the argument assigned to that parameter.\n\n  - Each slot is either 'empty' or 'filled'. Slots which had values assigned\n    to them are 'filled', otherwise they are 'empty'.\n\n  - Initially, all slots are marked 'empty'.\n\n  - Option arguments are assigned first, followed by positional arguments.\n\n  - For each option argument:\n\n     o If there is a parameter with the same name as the option argument, then\n       the argument value is assigned to that parameter slot. However, if the\n       parameter is already filled, then that is an error.\n\n     o Otherwise, if there is a 'keyword dictionary' argument, the argument is\n       added to the dictionary using the keyword name as the dictionary key,\n       unless there is already an entry with that key, in which case it is an\n       error.\n\n     o Otherwise, if there is no keyword dictionary, and no matching named\n       parameter, then it is an error.\n\n  - For each positional argument:\n\n     o Attempt to bind the argument to the first unfilled parameter slot that\n       has *no default value*. If the slot is not a vararg slot, then mark the\n       slot as 'filled'.\n\n     o Otherwise, if the next unfilled slot is a vararg slot then all remaining\n       positional arguments are placed into the vararg slot.\n\n  - Finally:\n\n     o If the vararg slot is not yet filled, assign an empty tuple as its\n       value.\n\n     o If the keyword dictionary argument is not yet filled, assign an empty\n       dicionary as its value.\n\n     o For each remaining empty slot: if there is a default value for that\n       slot, then fill the slot with the default value. If there is no default\n       value, then it is an error.\n\nWhen an error happens, a message is printed about the error.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "UNKNOWN", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "simpleopt", "package_url": "https://pypi.org/project/simpleopt/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/simpleopt/", "project_urls": {"Download": "UNKNOWN", "Homepage": "UNKNOWN"}, "release_url": "https://pypi.org/project/simpleopt/0.1.2a/", "requires_dist": null, "requires_python": null, "summary": "simpleopt - a simple parser for options in command line", "version": "0.1.2a", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"usage-example\">\n<h2>Usage Example</h2>\n<p>You just define a function, and optionally annotate the type of the\nparameters, the same arguments will be parsed on the command line:</p>\n<pre>@annotation(command=str, interval=float, differences=bool,\n            args=str, kwargs=str)\ndef watch(command, interval=2.0, differences=False, *args, **kwargs):\n    print (command, interval, differences, args, kwargs)\n\nif __name__ == '__main__':\n    SimpleOpt(watch).run()\n</pre>\n<p>Then you can call it like this, supposing you saved it on a file named\nwatch.py and made it executable:</p>\n<pre>$ watch.py \"df -h\"\n('df -h', 2.0, False, (), {})\n\n$ watch.py --interval 1.0 \"df -h\"\n('df -h', 1.0, False, (), {})\n\n$ watch.py --noverbose --differences \"df -h\"\n('df -h', 1.0, True, (), {})\n\n$ watch.py --foo bar --bar baz \"df -h\" quux quuux\n('df -h', 2.0, False, ('quux', 'quuux'), {'foo': 'bar', 'bar': 'baz'})\n</pre>\n<p>Another example:</p>\n<pre>@annotation(foo={str:int})\ndef example(foo):\n    return foo\n\n$ example.py --foo a:1,b:2,c:3\n{'a': 1, 'c': 3, 'b': 2}\n\n$ example.py a:1,b:2,c:3\n{'a': 1, 'c': 3, 'b': 2}\n</pre>\n</div>\n<div id=\"working-details\">\n<h2>Working details</h2>\n<p>The command-line arguments are classified in one of two types: (i) option\narguments and (ii) positional arguments.</p>\n<blockquote>\n<ol>\n<li>option arguments have the form \u2013OPTION or \u2013OPTION=VALUE where\nOPTION is the argument name and VALUE is an optional value given to\nthat argument.</li>\n<li>positional arguments are those that are not option arguments.</li>\n</ol>\n</blockquote>\n<p>The way that command-line arguments are assigned to the function\u2019s formal\nparameters differ from the way that python assigns input arguments in python\ncode.</p>\n<p>When a python script is run on the command line, the command-line arguments are\nassigned to the function\u2019s formal parameters as follows:</p>\n<blockquote>\n<ul>\n<li><p>For each formal parameter, there is a slot which will be used to contain\nthe value of the argument assigned to that parameter.</p>\n</li>\n<li><p>Each slot is either \u2018empty\u2019 or \u2018filled\u2019. Slots which had values assigned\nto them are \u2018filled\u2019, otherwise they are \u2018empty\u2019.</p>\n</li>\n<li><p>Initially, all slots are marked \u2018empty\u2019.</p>\n</li>\n<li><p>Option arguments are assigned first, followed by positional arguments.</p>\n</li>\n<li><p>For each option argument:</p>\n<blockquote>\n<dl>\n<dt>o If there is a parameter with the same name as the option argument, then</dt>\n<dd><p>the argument value is assigned to that parameter slot. However, if the\nparameter is already filled, then that is an error.</p>\n</dd>\n<dt>o Otherwise, if there is a \u2018keyword dictionary\u2019 argument, the argument is</dt>\n<dd><p>added to the dictionary using the keyword name as the dictionary key,\nunless there is already an entry with that key, in which case it is an\nerror.</p>\n</dd>\n<dt>o Otherwise, if there is no keyword dictionary, and no matching named</dt>\n<dd><p>parameter, then it is an error.</p>\n</dd>\n</dl>\n</blockquote>\n</li>\n<li><p>For each positional argument:</p>\n<blockquote>\n<dl>\n<dt>o Attempt to bind the argument to the first unfilled parameter slot that</dt>\n<dd><p>has <em>no default value</em>. If the slot is not a vararg slot, then mark the\nslot as \u2018filled\u2019.</p>\n</dd>\n<dt>o Otherwise, if the next unfilled slot is a vararg slot then all remaining</dt>\n<dd><p>positional arguments are placed into the vararg slot.</p>\n</dd>\n</dl>\n</blockquote>\n</li>\n<li><p>Finally:</p>\n<blockquote>\n<dl>\n<dt>o If the vararg slot is not yet filled, assign an empty tuple as its</dt>\n<dd><p>value.</p>\n</dd>\n<dt>o If the keyword dictionary argument is not yet filled, assign an empty</dt>\n<dd><p>dicionary as its value.</p>\n</dd>\n<dt>o For each remaining empty slot: if there is a default value for that</dt>\n<dd><p>slot, then fill the slot with the default value. If there is no default\nvalue, then it is an error.</p>\n</dd>\n</dl>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<p>When an error happens, a message is printed about the error.</p>\n</div>\n\n          </div>"}, "last_serial": 799590, "releases": {"0.1.1a": [{"comment_text": "", "digests": {"md5": "86ab412334c45970dea4d30f30b0e74c", "sha256": "299153ccfa612be406437143c08eabdabfcc46aa7860cc393450647945ae3e95"}, "downloads": -1, "filename": "simpleopt-0.1.1a.tar.gz", "has_sig": false, "md5_digest": "86ab412334c45970dea4d30f30b0e74c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10097, "upload_time": "2008-05-23T06:27:04", "upload_time_iso_8601": "2008-05-23T06:27:04Z", "url": "https://files.pythonhosted.org/packages/d3/fa/687942fb1f03ecbc2cff3a12c3a79a6bed74633a69dfcf13e543c95f6e38/simpleopt-0.1.1a.tar.gz", "yanked": false}], "0.1.2a": [{"comment_text": "", "digests": {"md5": "5d296f01d65ce5128ecfa86313c7061a", "sha256": "4005989219487e3eaddedcb533f3a8a862c90bc9e0f6a835719126f4fecee645"}, "downloads": -1, "filename": "simpleopt-0.1.2a.tar.gz", "has_sig": false, "md5_digest": "5d296f01d65ce5128ecfa86313c7061a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7426, "upload_time": "2008-05-27T03:55:16", "upload_time_iso_8601": "2008-05-27T03:55:16Z", "url": "https://files.pythonhosted.org/packages/84/d7/fc6c8775eb029ff56f1ed346939753df0d0baff6fac275caf9d006beef71/simpleopt-0.1.2a.tar.gz", "yanked": false}], "0.1a": [{"comment_text": "", "digests": {"md5": "78d5a0faebf073f019a20899c7b0ad3f", "sha256": "4d62b9310b28c53c30fcbddbb9deb38ad8b639c7700ec7022dafe1b3121ca5db"}, "downloads": -1, "filename": "simpleopt-0.1a.tar.gz", "has_sig": false, "md5_digest": "78d5a0faebf073f019a20899c7b0ad3f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7170, "upload_time": "2008-03-26T07:16:28", "upload_time_iso_8601": "2008-03-26T07:16:28Z", "url": "https://files.pythonhosted.org/packages/b7/06/3793a43b7068d4e75ba9af89097de9197f3973bef422e77d8ad2717dace9/simpleopt-0.1a.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5d296f01d65ce5128ecfa86313c7061a", "sha256": "4005989219487e3eaddedcb533f3a8a862c90bc9e0f6a835719126f4fecee645"}, "downloads": -1, "filename": "simpleopt-0.1.2a.tar.gz", "has_sig": false, "md5_digest": "5d296f01d65ce5128ecfa86313c7061a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7426, "upload_time": "2008-05-27T03:55:16", "upload_time_iso_8601": "2008-05-27T03:55:16Z", "url": "https://files.pythonhosted.org/packages/84/d7/fc6c8775eb029ff56f1ed346939753df0d0baff6fac275caf9d006beef71/simpleopt-0.1.2a.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:10:25 2020"}