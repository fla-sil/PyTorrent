{"info": {"author": "Richard Mathie", "author_email": "richard.mathie@cantab.net", "bugtrack_url": null, "classifiers": ["Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7"], "description": "Redis PubSub Dict\n=================\n\n|PyPI version|\n\nA python class for using redis, or other key value stores, as a\ndictionary and caching the values locally for read heavy workloads.\nHeavily inspired by `pylru <https://pypi.python.org/pypi/pylru>`__.\n\nUsage\n-----\n\nThe idea is that Deleting or Updating keys in an instance of\n``PubSubRedisDict`` or ``PubSubCacheManager`` will update the matching\ncached keys in all instances of ``PubSubCacheManager``.\n``PubSubCacheManager`` will therefor maintain a cache of recently used\nkeys using an ``lru`` or just a straight up ``dict()``. This will reduce\nthe round trip latency and network overhead for any reads of the cached\nkeys.\n\n``RedisDict`` and ``RedisDict`` should work with instances of\n``redis.StrictRedis`` or ``rediscluster.StrictRedisCluster``. Use the\n``prefix`` for managing redis key namespaces.\n\nRedisDict\n~~~~~~~~~\n\nJust like a normal dictionary, but networked. Initialisation wont take a\ndictionary or iterable for now as it need connection and namespace\ninformation.\n\n.. code:: python\n\n    rc = StrictRedisCluster(startup_nodes=[{\"host\": \"redis\", \"port\": \"6379\"}])\n    reddict = RedisDict(rc, 'namespace')\n\n    # you can set\n    reddict[1] = 1\n    reddict[2] = [1,2,3]\n    reddict['hello'] = 'world'\n    reddict[('complex',1)] = {'I': {'Am': {'Quite': ['a', 'complex', {'object': {} }]}}}\n\n    # get somewhere else\n    reddict[1]\n    reddict['1'] # note its the same as reddict[1]\n    reddict[('complex',1)]\n    reddict[\"('complex', 1)\"] # the key is str(('complex',1))\n\n    # delete\n    del reddict[1]\n    # .. ect\n\nPubSubRedisDict\n~~~~~~~~~~~~~~~\n\nLike ``RedisDict`` but will publish key update and delete events to a\n``<namespace>/[update|delete]`` channel.\n\n.. code:: python\n\n    redpubsub = PubSubRedisDict(rc, 'namespace')\n    # ect as before\n\nPubSubCacheManager\n~~~~~~~~~~~~~~~~~~\n\nLike ``pylry.WriteThroughCacheManager`` but updates cache keys from\nstore when it receives a message from the\n``<namespace>/[update|delete]`` channel.\n\n.. code:: python\n\n    cache = pylru.lrucache(10) # maybe more than 10\n    redstore = PubSubRedisDict(rc, 'namespace')\n    redcache = PubSubCacheManager(redstore, cache)\n    # ect as before\n    # see the cache\n    print dict(redcache.cache)\n\nFurther uses\n~~~~~~~~~~~~\n\nYou can hook up ``RedisDict`` or ``PubSubRedisDict`` to\n``pylru.WriteBackCacheManager`` to get a Redis backed dictionary which\nonly writes to Redis on 'flush' or when the item pops off the ``lru``\nfor write intensive workloads. However a lot more work would need to be\ndone to add the pubsub mechanism as there difficult cases to consider,\nsuch as what happens when the cache is dirty and we get notified that\nthe store key is updated?\n\nLimitations\n-----------\n\n-  all keys are strings.\n-  ``msgpack`` is used to marshal objects to redis, so ``msgpack``\n   object limitations apply. Though you can monkey patch the modules\n   ``loads`` and ``dumps`` method if you like.\n-  publish will publish to all consuming dictionary instances, there is\n   no partitioning, so writes and updates are expensive. You could come\n   up with a partitioning strategy to improve this.\n-  The published items eventually end up in the watched cash. There may\n   be a time lag between a client publishing a change and the key\n   updating in another clients cache.\n\nReferences\n----------\n\n-  `redis-py <http://redis-py.readthedocs.io/>`__\n-  `redis-py-cluster <http://redis-py-cluster.readthedocs.io/>`__\n-  `pylru <https://pypi.python.org/pypi/pylru>`__\n\n.. |PyPI version| image:: https://img.shields.io/pypi/v/redis-pubsub-dict.svg\n   :target: https://pypi.python.org/pypi/redis-pubsub-dict", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Richard-Mathie/py-redis-pubsub-dict", "keywords": "", "license": "GNU GPLv2", "maintainer": "", "maintainer_email": "", "name": "redis-pubsub-dict", "package_url": "https://pypi.org/project/redis-pubsub-dict/", "platform": "any", "project_url": "https://pypi.org/project/redis-pubsub-dict/", "project_urls": {"Homepage": "https://github.com/Richard-Mathie/py-redis-pubsub-dict"}, "release_url": "https://pypi.org/project/redis-pubsub-dict/0.0.2/", "requires_dist": null, "requires_python": "", "summary": "A python class for using redis, or other key value stores, and caching the values for read heavy workloads", "version": "0.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://pypi.python.org/pypi/redis-pubsub-dict\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/49614dbe7e7cf04abfd4227a90c8c9be70bd3415/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f72656469732d7075627375622d646963742e737667\"></a></p>\n<p>A python class for using redis, or other key value stores, as a\ndictionary and caching the values locally for read heavy workloads.\nHeavily inspired by <a href=\"https://pypi.python.org/pypi/pylru\" rel=\"nofollow\">pylru</a>.</p>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>The idea is that Deleting or Updating keys in an instance of\n<tt>PubSubRedisDict</tt> or <tt>PubSubCacheManager</tt> will update the matching\ncached keys in all instances of <tt>PubSubCacheManager</tt>.\n<tt>PubSubCacheManager</tt> will therefor maintain a cache of recently used\nkeys using an <tt>lru</tt> or just a straight up <tt>dict()</tt>. This will reduce\nthe round trip latency and network overhead for any reads of the cached\nkeys.</p>\n<p><tt>RedisDict</tt> and <tt>RedisDict</tt> should work with instances of\n<tt>redis.StrictRedis</tt> or <tt>rediscluster.StrictRedisCluster</tt>. Use the\n<tt>prefix</tt> for managing redis key namespaces.</p>\n<div id=\"redisdict\">\n<h3>RedisDict</h3>\n<p>Just like a normal dictionary, but networked. Initialisation wont take a\ndictionary or iterable for now as it need connection and namespace\ninformation.</p>\n<pre><span class=\"n\">rc</span> <span class=\"o\">=</span> <span class=\"n\">StrictRedisCluster</span><span class=\"p\">(</span><span class=\"n\">startup_nodes</span><span class=\"o\">=</span><span class=\"p\">[{</span><span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"redis\"</span><span class=\"p\">,</span> <span class=\"s2\">\"port\"</span><span class=\"p\">:</span> <span class=\"s2\">\"6379\"</span><span class=\"p\">}])</span>\n<span class=\"n\">reddict</span> <span class=\"o\">=</span> <span class=\"n\">RedisDict</span><span class=\"p\">(</span><span class=\"n\">rc</span><span class=\"p\">,</span> <span class=\"s1\">'namespace'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># you can set</span>\n<span class=\"n\">reddict</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">reddict</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">]</span>\n<span class=\"n\">reddict</span><span class=\"p\">[</span><span class=\"s1\">'hello'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'world'</span>\n<span class=\"n\">reddict</span><span class=\"p\">[(</span><span class=\"s1\">'complex'</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'I'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'Am'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'Quite'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'complex'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'object'</span><span class=\"p\">:</span> <span class=\"p\">{}</span> <span class=\"p\">}]}}}</span>\n\n<span class=\"c1\"># get somewhere else</span>\n<span class=\"n\">reddict</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"n\">reddict</span><span class=\"p\">[</span><span class=\"s1\">'1'</span><span class=\"p\">]</span> <span class=\"c1\"># note its the same as reddict[1]</span>\n<span class=\"n\">reddict</span><span class=\"p\">[(</span><span class=\"s1\">'complex'</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)]</span>\n<span class=\"n\">reddict</span><span class=\"p\">[</span><span class=\"s2\">\"('complex', 1)\"</span><span class=\"p\">]</span> <span class=\"c1\"># the key is str(('complex',1))</span>\n\n<span class=\"c1\"># delete</span>\n<span class=\"k\">del</span> <span class=\"n\">reddict</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"c1\"># .. ect</span>\n</pre>\n</div>\n<div id=\"pubsubredisdict\">\n<h3>PubSubRedisDict</h3>\n<p>Like <tt>RedisDict</tt> but will publish key update and delete events to a\n<tt><span class=\"pre\">&lt;namespace&gt;/[update|delete]</span></tt> channel.</p>\n<pre><span class=\"n\">redpubsub</span> <span class=\"o\">=</span> <span class=\"n\">PubSubRedisDict</span><span class=\"p\">(</span><span class=\"n\">rc</span><span class=\"p\">,</span> <span class=\"s1\">'namespace'</span><span class=\"p\">)</span>\n<span class=\"c1\"># ect as before</span>\n</pre>\n</div>\n<div id=\"pubsubcachemanager\">\n<h3>PubSubCacheManager</h3>\n<p>Like <tt>pylry.WriteThroughCacheManager</tt> but updates cache keys from\nstore when it receives a message from the\n<tt><span class=\"pre\">&lt;namespace&gt;/[update|delete]</span></tt> channel.</p>\n<pre><span class=\"n\">cache</span> <span class=\"o\">=</span> <span class=\"n\">pylru</span><span class=\"o\">.</span><span class=\"n\">lrucache</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"c1\"># maybe more than 10</span>\n<span class=\"n\">redstore</span> <span class=\"o\">=</span> <span class=\"n\">PubSubRedisDict</span><span class=\"p\">(</span><span class=\"n\">rc</span><span class=\"p\">,</span> <span class=\"s1\">'namespace'</span><span class=\"p\">)</span>\n<span class=\"n\">redcache</span> <span class=\"o\">=</span> <span class=\"n\">PubSubCacheManager</span><span class=\"p\">(</span><span class=\"n\">redstore</span><span class=\"p\">,</span> <span class=\"n\">cache</span><span class=\"p\">)</span>\n<span class=\"c1\"># ect as before</span>\n<span class=\"c1\"># see the cache</span>\n<span class=\"nb\">print</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">redcache</span><span class=\"o\">.</span><span class=\"n\">cache</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"further-uses\">\n<h3>Further uses</h3>\n<p>You can hook up <tt>RedisDict</tt> or <tt>PubSubRedisDict</tt> to\n<tt>pylru.WriteBackCacheManager</tt> to get a Redis backed dictionary which\nonly writes to Redis on \u2018flush\u2019 or when the item pops off the <tt>lru</tt>\nfor write intensive workloads. However a lot more work would need to be\ndone to add the pubsub mechanism as there difficult cases to consider,\nsuch as what happens when the cache is dirty and we get notified that\nthe store key is updated?</p>\n</div>\n</div>\n<div id=\"limitations\">\n<h2>Limitations</h2>\n<ul>\n<li>all keys are strings.</li>\n<li><tt>msgpack</tt> is used to marshal objects to redis, so <tt>msgpack</tt>\nobject limitations apply. Though you can monkey patch the modules\n<tt>loads</tt> and <tt>dumps</tt> method if you like.</li>\n<li>publish will publish to all consuming dictionary instances, there is\nno partitioning, so writes and updates are expensive. You could come\nup with a partitioning strategy to improve this.</li>\n<li>The published items eventually end up in the watched cash. There may\nbe a time lag between a client publishing a change and the key\nupdating in another clients cache.</li>\n</ul>\n</div>\n<div id=\"references\">\n<h2>References</h2>\n<ul>\n<li><a href=\"http://redis-py.readthedocs.io/\" rel=\"nofollow\">redis-py</a></li>\n<li><a href=\"http://redis-py-cluster.readthedocs.io/\" rel=\"nofollow\">redis-py-cluster</a></li>\n<li><a href=\"https://pypi.python.org/pypi/pylru\" rel=\"nofollow\">pylru</a></li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 3484393, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "1310200c213b339593e998258f0af63e", "sha256": "a2d21a6f514807e6bf4437a778217f6f17c2937a2734250839f68ce827cabc4a"}, "downloads": -1, "filename": "redis_pubsub_dict-0.0.1.tar.gz", "has_sig": false, "md5_digest": "1310200c213b339593e998258f0af63e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4764, "upload_time": "2018-01-11T19:18:47", "upload_time_iso_8601": "2018-01-11T19:18:47.897298Z", "url": "https://files.pythonhosted.org/packages/d4/f2/f8c032602de6c40bf1eff8cff1cdfba6eb15dfe3ab66660ed769ac9e4e1b/redis_pubsub_dict-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "762c421363b9852d58d9e8d66ce1c982", "sha256": "7229c21e8cb12838d66bc923dffdd54e15f009b0b8816f5ab7564b5d93b664c9"}, "downloads": -1, "filename": "redis_pubsub_dict-0.0.2.tar.gz", "has_sig": false, "md5_digest": "762c421363b9852d58d9e8d66ce1c982", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4934, "upload_time": "2018-01-12T14:52:29", "upload_time_iso_8601": "2018-01-12T14:52:29.410759Z", "url": "https://files.pythonhosted.org/packages/f9/27/369fd6f17c42b30443b32f57365ec4bc6463d00cf8abdb52aae49690eb9d/redis_pubsub_dict-0.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "762c421363b9852d58d9e8d66ce1c982", "sha256": "7229c21e8cb12838d66bc923dffdd54e15f009b0b8816f5ab7564b5d93b664c9"}, "downloads": -1, "filename": "redis_pubsub_dict-0.0.2.tar.gz", "has_sig": false, "md5_digest": "762c421363b9852d58d9e8d66ce1c982", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4934, "upload_time": "2018-01-12T14:52:29", "upload_time_iso_8601": "2018-01-12T14:52:29.410759Z", "url": "https://files.pythonhosted.org/packages/f9/27/369fd6f17c42b30443b32f57365ec4bc6463d00cf8abdb52aae49690eb9d/redis_pubsub_dict-0.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:05:47 2020"}