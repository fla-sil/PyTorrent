{"info": {"author": "Fabian Kueppers", "author_email": "fabian.kueppers@hs-ruhrwest.de", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering :: Artificial Intelligence"], "description": "Calibration Framework\n=====================\nCalibration framework in Python 3 for Neural Networks.\n\nCopyright (C) 2019 Ruhr West University of Applied Sciences, Bottrop, Germany\nAND Visteon Electronics Germany GmbH, Kerpen, Germany\n\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.\n\n.. contents:: Table of Contents\n   :depth: 2\n\nOverview\n===============\n\nThis framework is designed to calibrate the confidence estimates of classifiers like Neural Networks. Modern Neural Networks are likely to be overconfident with their predictions. However, reliable confidence estimates of such classifiers are crucial especially in safety-critical applications.\n\nFor example: given 100 predictions with a confidence of 80% of each prediction, the observed accuracy should also match 80% (neither more nor less). This behaviour is achievable with several calibration methods.\n\nThe framework is structured as follows::\n\n    netcal\n      .binning         # binning methods\n      .scaling         # scaling methods\n      .regularization  # regularization methods\n      .presentation    # presentation methods\n      .metrics         # metrics for measuring miscalibration\n\n    examples           # example code snippets\n\nInstallation\n===============\nThe installation of the calibration suite is quite easy with setuptools. You can either install this framework using PIP::\n\n    pip3 install netcal\n\nOr simply invoke the following command to install the calibration suite::\n\n    python3 setup.py install\n\nCalibration Metrics\n======================\nThe most common metric to determine miscalibration is the *Expected Calibration Error* (ECE) [1]_. This metric divides the confidence space into several bins and measures the observed accuracy in each bin. The bin gaps between observed accuracy and bin confidence are summed up and weighted by the amount of samples in each bin. The *Maximum Calibration Error* (MCE) denotes the highest gap over all bins. The *Average Calibration Error* (ACE) [11]_ denotes the average miscalibration where each bin gets weighted equally.\n\nAnother group are the regularization tools which are added to the loss during the training of a Neural Network.\n\nMethods\n==========\nThe calibration methods are separated into binning and scaling methods. The binning methods divide the confidence space into several bins (like ECE) and perform calibration on each bin. The scaling methods scale the confidence estimates or logits directly to calibrated confidence estimates.\n\nMost of the calibration methods are designed for binary classification tasks. Multi-class calibration is performed in \"one vs. all\" by default.\n\nSome methods like \"Isotonic Regression\" utilize methods from the scikit-learn API [9]_.\n\nBinning\n-------\nImplemented binning methods are:\n\n- Histogram Binning [3]_, [4]_\n- Isotonic Regression [4]_, [5]_\n- Bayesian Binning into Quantiles (BBQ) [1]_\n- Ensemble of Near Isotonic Regression (ENIR) [6]_\n\nScaling\n-------\nImplemented scaling methods are:\n\n- Logistic Calibration/Platt Scaling [10]_\n- Temperature Scaling [7]_\n- Beta Calibration [2]_\n\nRegularization\n--------------\nImplemented regularization methods are:\n\n- Confidence Penalty [8]_\n\nVisualization\n================\nFor visualization of miscalibration, one can use a Confidence Histograms & Reliability Diagrams. These diagrams are similar to ECE, the output space is divided into equally spaced bins. The calibration gap between bin accuracy and bin confidence is visualized as a histogram.\n\nExamples\n===========\nThe calibration methods work with the predicted confidence estimates of a Neural Network. This is a basic example which uses softmax predictions of a classification task with 10 classes and the given NumPy arrays::\n\n    ground_truth  # this is a NumPy 1-D array with ground truth digits between 0-9 - shape: (n_samples,)\n    confidences   # this is a NumPy 2-D array with confidence estimates between 0-1 - shape: (n_samples, n_classes)\n\nThis is an example for Temperature Scaling but also works for every calibration method (remind different constructor parameters)::\n\n    import numpy as np\n    from netcal.scaling import TemperatureScaling\n\n    temperature = TemperatureScaling()\n    temperature.fit(confidences, ground_truth)\n    calibrated = temperature.transform(confidences)\n\nThe miscalibration can be determined with the ECE::\n\n    from netcal.metrics import ECE\n\n    n_bins = 10\n\n    ece = ECE(n_bins)\n    uncalibrated_score = ece.measure(confidences)\n    calibrated_score = ece.measure(calibrated)\n\nThe miscalibration can be visualized with a Reliability Diagram::\n\n    from netcal.presentation import ReliabilityDiagram\n\n    n_bins = 10\n\n    diagram = ReliabilityDiagram(n_bins)\n    diagram.plot(confidences, ground_truth)  # visualize miscalibration of uncalibrated\n    diagram.plot(calibrated, ground_truth)   # visualize miscalibration of calibrated\n\nReferences\n==========\n.. [1] Naeini, Mahdi Pakdaman, Gregory Cooper, and Milos Hauskrecht: \"Obtaining well calibrated probabilities using bayesian binning.\" Twenty-Ninth AAAI Conference on Artificial Intelligence, 2015.\n.. [2] Kull, Meelis, Telmo Silva Filho, and Peter Flach: \"Beta calibration: a well-founded and easily implemented improvement on logistic calibration for binary classifiers.\" Artificial Intelligence and Statistics, PMLR 54:623-631, 2017.\n.. [3] Zadrozny, Bianca and Elkan, Charles: \"Obtaining calibrated probability estimates from decision trees and naive bayesian classifiers.\" In ICML, pp. 609\u2013616, 2001.\n.. [4] Zadrozny, Bianca and Elkan, Charles: \"Transforming classifier scores into accurate multiclass probability estimates.\" In KDD, pp. 694\u2013699, 2002.\n.. [5] Ryan J Tibshirani, Holger Hoefling, and Robert Tibshirani: \"Nearly-isotonic regression.\" Technometrics, 53(1):54\u201361, 2011.\n.. [6] Naeini, Mahdi Pakdaman, and Gregory F. Cooper: \"Binary classifier calibration using an ensemble of near isotonic regression models.\" 2016 IEEE 16th International Conference on Data Mining (ICDM). IEEE, 2016.\n.. [7] Chuan Guo, Geoff Pleiss, Yu Sun and Kilian Q. Weinberger: \"On Calibration of Modern Neural Networks.\" Proceedings of the 34th International Conference on Machine Learning, 2017.\n.. [8] Pereyra, G., Tucker, G., Chorowski, J., Kaiser, L. and Hinton, G.: \u201cRegularizing neural networks by penalizing confident output distributions.\u201d CoRR, 2017.\n.. [9] Pedregosa, F., Varoquaux, G., Gramfort, A., Michel, V., Thirion, B., Grisel, O., Blondel, M., Prettenhofer, P., Weiss, R., Dubourg, V., Vanderplas, J., Passos, A., Cournapeau, D., Brucher, M., Perrot, M. and Duchesnay, E.: \"Scikit-learn: Machine Learning in Python.\" In Journal of Machine Learning Research, volume 12 pp 2825-2830, 2011.\n.. [10] Platt, John: \"Probabilistic outputs for support vector machines and comparisons to regularized likelihood methods.\" Advances in large margin classifiers, 10(3): 61\u201374, 1999.\n.. [11] Neumann, Lukas, Andrew Zisserman, and Andrea Vedaldi: \"Relaxed Softmax: Efficient Confidence Auto-Calibration for Safe Pedestrian Detection.\" Conference on Neural Information Processing Systems (NIPS) Workshop MLITS, 2018.\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/fabiankueppers/calibration-framework", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "netcal", "package_url": "https://pypi.org/project/netcal/", "platform": "", "project_url": "https://pypi.org/project/netcal/", "project_urls": {"Homepage": "https://github.com/fabiankueppers/calibration-framework"}, "release_url": "https://pypi.org/project/netcal/1.0/", "requires_dist": ["numpy (>=1.15)", "scipy (>=1.2)", "matplotlib (>=3.1)", "scikit-learn (>=0.20.0)"], "requires_python": "", "summary": "Python Framework to calibrate confidence estimates of classifiers like Neural Networks", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"calibration-framework\">\n<h2><a href=\"#id25\" rel=\"nofollow\">Calibration Framework</a></h2>\n<p>Calibration framework in Python 3 for Neural Networks.</p>\n<p>Copyright (C) 2019 Ruhr West University of Applied Sciences, Bottrop, Germany\nAND Visteon Electronics Germany GmbH, Kerpen, Germany</p>\n<p>This Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at <a href=\"http://mozilla.org/MPL/2.0/\" rel=\"nofollow\">http://mozilla.org/MPL/2.0/</a>.</p>\n<div id=\"table-of-contents\">\n<p>Table of Contents</p>\n<ul>\n<li><a href=\"#calibration-framework\" id=\"id25\" rel=\"nofollow\">Calibration Framework</a></li>\n<li><a href=\"#overview\" id=\"id26\" rel=\"nofollow\">Overview</a></li>\n<li><a href=\"#installation\" id=\"id27\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#calibration-metrics\" id=\"id28\" rel=\"nofollow\">Calibration Metrics</a></li>\n<li><a href=\"#methods\" id=\"id29\" rel=\"nofollow\">Methods</a><ul>\n<li><a href=\"#binning\" id=\"id30\" rel=\"nofollow\">Binning</a></li>\n<li><a href=\"#scaling\" id=\"id31\" rel=\"nofollow\">Scaling</a></li>\n<li><a href=\"#regularization\" id=\"id32\" rel=\"nofollow\">Regularization</a></li>\n</ul>\n</li>\n<li><a href=\"#visualization\" id=\"id33\" rel=\"nofollow\">Visualization</a></li>\n<li><a href=\"#examples\" id=\"id34\" rel=\"nofollow\">Examples</a></li>\n<li><a href=\"#references\" id=\"id35\" rel=\"nofollow\">References</a></li>\n</ul>\n</div>\n</div>\n<div id=\"overview\">\n<h2><a href=\"#id26\" rel=\"nofollow\">Overview</a></h2>\n<p>This framework is designed to calibrate the confidence estimates of classifiers like Neural Networks. Modern Neural Networks are likely to be overconfident with their predictions. However, reliable confidence estimates of such classifiers are crucial especially in safety-critical applications.</p>\n<p>For example: given 100 predictions with a confidence of 80% of each prediction, the observed accuracy should also match 80% (neither more nor less). This behaviour is achievable with several calibration methods.</p>\n<p>The framework is structured as follows:</p>\n<pre>netcal\n  .binning         # binning methods\n  .scaling         # scaling methods\n  .regularization  # regularization methods\n  .presentation    # presentation methods\n  .metrics         # metrics for measuring miscalibration\n\nexamples           # example code snippets\n</pre>\n</div>\n<div id=\"installation\">\n<h2><a href=\"#id27\" rel=\"nofollow\">Installation</a></h2>\n<p>The installation of the calibration suite is quite easy with setuptools. You can either install this framework using PIP:</p>\n<pre>pip3 install netcal\n</pre>\n<p>Or simply invoke the following command to install the calibration suite:</p>\n<pre>python3 setup.py install\n</pre>\n</div>\n<div id=\"calibration-metrics\">\n<h2><a href=\"#id28\" rel=\"nofollow\">Calibration Metrics</a></h2>\n<p>The most common metric to determine miscalibration is the <em>Expected Calibration Error</em> (ECE) <a href=\"#id14\" id=\"id1\" rel=\"nofollow\">[1]</a>. This metric divides the confidence space into several bins and measures the observed accuracy in each bin. The bin gaps between observed accuracy and bin confidence are summed up and weighted by the amount of samples in each bin. The <em>Maximum Calibration Error</em> (MCE) denotes the highest gap over all bins. The <em>Average Calibration Error</em> (ACE) <a href=\"#id24\" id=\"id2\" rel=\"nofollow\">[11]</a> denotes the average miscalibration where each bin gets weighted equally.</p>\n<p>Another group are the regularization tools which are added to the loss during the training of a Neural Network.</p>\n</div>\n<div id=\"methods\">\n<h2><a href=\"#id29\" rel=\"nofollow\">Methods</a></h2>\n<p>The calibration methods are separated into binning and scaling methods. The binning methods divide the confidence space into several bins (like ECE) and perform calibration on each bin. The scaling methods scale the confidence estimates or logits directly to calibrated confidence estimates.</p>\n<p>Most of the calibration methods are designed for binary classification tasks. Multi-class calibration is performed in \u201cone vs. all\u201d by default.</p>\n<p>Some methods like \u201cIsotonic Regression\u201d utilize methods from the scikit-learn API <a href=\"#id22\" id=\"id3\" rel=\"nofollow\">[9]</a>.</p>\n<div id=\"binning\">\n<h3><a href=\"#id30\" rel=\"nofollow\">Binning</a></h3>\n<p>Implemented binning methods are:</p>\n<ul>\n<li>Histogram Binning <a href=\"#id16\" id=\"id4\" rel=\"nofollow\">[3]</a>, <a href=\"#id17\" id=\"id5\" rel=\"nofollow\">[4]</a></li>\n<li>Isotonic Regression <a href=\"#id17\" id=\"id6\" rel=\"nofollow\">[4]</a>, <a href=\"#id18\" id=\"id7\" rel=\"nofollow\">[5]</a></li>\n<li>Bayesian Binning into Quantiles (BBQ) <a href=\"#id14\" id=\"id8\" rel=\"nofollow\">[1]</a></li>\n<li>Ensemble of Near Isotonic Regression (ENIR) <a href=\"#id19\" id=\"id9\" rel=\"nofollow\">[6]</a></li>\n</ul>\n</div>\n<div id=\"scaling\">\n<h3><a href=\"#id31\" rel=\"nofollow\">Scaling</a></h3>\n<p>Implemented scaling methods are:</p>\n<ul>\n<li>Logistic Calibration/Platt Scaling <a href=\"#id23\" id=\"id10\" rel=\"nofollow\">[10]</a></li>\n<li>Temperature Scaling <a href=\"#id20\" id=\"id11\" rel=\"nofollow\">[7]</a></li>\n<li>Beta Calibration <a href=\"#id15\" id=\"id12\" rel=\"nofollow\">[2]</a></li>\n</ul>\n</div>\n<div id=\"regularization\">\n<h3><a href=\"#id32\" rel=\"nofollow\">Regularization</a></h3>\n<p>Implemented regularization methods are:</p>\n<ul>\n<li>Confidence Penalty <a href=\"#id21\" id=\"id13\" rel=\"nofollow\">[8]</a></li>\n</ul>\n</div>\n</div>\n<div id=\"visualization\">\n<h2><a href=\"#id33\" rel=\"nofollow\">Visualization</a></h2>\n<p>For visualization of miscalibration, one can use a Confidence Histograms &amp; Reliability Diagrams. These diagrams are similar to ECE, the output space is divided into equally spaced bins. The calibration gap between bin accuracy and bin confidence is visualized as a histogram.</p>\n</div>\n<div id=\"examples\">\n<h2><a href=\"#id34\" rel=\"nofollow\">Examples</a></h2>\n<p>The calibration methods work with the predicted confidence estimates of a Neural Network. This is a basic example which uses softmax predictions of a classification task with 10 classes and the given NumPy arrays:</p>\n<pre>ground_truth  # this is a NumPy 1-D array with ground truth digits between 0-9 - shape: (n_samples,)\nconfidences   # this is a NumPy 2-D array with confidence estimates between 0-1 - shape: (n_samples, n_classes)\n</pre>\n<p>This is an example for Temperature Scaling but also works for every calibration method (remind different constructor parameters):</p>\n<pre>import numpy as np\nfrom netcal.scaling import TemperatureScaling\n\ntemperature = TemperatureScaling()\ntemperature.fit(confidences, ground_truth)\ncalibrated = temperature.transform(confidences)\n</pre>\n<p>The miscalibration can be determined with the ECE:</p>\n<pre>from netcal.metrics import ECE\n\nn_bins = 10\n\nece = ECE(n_bins)\nuncalibrated_score = ece.measure(confidences)\ncalibrated_score = ece.measure(calibrated)\n</pre>\n<p>The miscalibration can be visualized with a Reliability Diagram:</p>\n<pre>from netcal.presentation import ReliabilityDiagram\n\nn_bins = 10\n\ndiagram = ReliabilityDiagram(n_bins)\ndiagram.plot(confidences, ground_truth)  # visualize miscalibration of uncalibrated\ndiagram.plot(calibrated, ground_truth)   # visualize miscalibration of calibrated\n</pre>\n</div>\n<div id=\"references\">\n<h2><a href=\"#id35\" rel=\"nofollow\">References</a></h2>\n<table id=\"id14\">\n<col><col>\n<tbody>\n<tr><td>[1]</td><td><em>(<a href=\"#id1\" rel=\"nofollow\">1</a>, <a href=\"#id8\" rel=\"nofollow\">2</a>)</em> Naeini, Mahdi Pakdaman, Gregory Cooper, and Milos Hauskrecht: \u201cObtaining well calibrated probabilities using bayesian binning.\u201d Twenty-Ninth AAAI Conference on Artificial Intelligence, 2015.</td></tr>\n</tbody>\n</table>\n<table id=\"id15\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id12\" rel=\"nofollow\">[2]</a></td><td>Kull, Meelis, Telmo Silva Filho, and Peter Flach: \u201cBeta calibration: a well-founded and easily implemented improvement on logistic calibration for binary classifiers.\u201d Artificial Intelligence and Statistics, PMLR 54:623-631, 2017.</td></tr>\n</tbody>\n</table>\n<table id=\"id16\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id4\" rel=\"nofollow\">[3]</a></td><td>Zadrozny, Bianca and Elkan, Charles: \u201cObtaining calibrated probability estimates from decision trees and naive bayesian classifiers.\u201d In ICML, pp. 609\u2013616, 2001.</td></tr>\n</tbody>\n</table>\n<table id=\"id17\">\n<col><col>\n<tbody>\n<tr><td>[4]</td><td><em>(<a href=\"#id5\" rel=\"nofollow\">1</a>, <a href=\"#id6\" rel=\"nofollow\">2</a>)</em> Zadrozny, Bianca and Elkan, Charles: \u201cTransforming classifier scores into accurate multiclass probability estimates.\u201d In KDD, pp. 694\u2013699, 2002.</td></tr>\n</tbody>\n</table>\n<table id=\"id18\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id7\" rel=\"nofollow\">[5]</a></td><td>Ryan J Tibshirani, Holger Hoefling, and Robert Tibshirani: \u201cNearly-isotonic regression.\u201d Technometrics, 53(1):54\u201361, 2011.</td></tr>\n</tbody>\n</table>\n<table id=\"id19\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id9\" rel=\"nofollow\">[6]</a></td><td>Naeini, Mahdi Pakdaman, and Gregory F. Cooper: \u201cBinary classifier calibration using an ensemble of near isotonic regression models.\u201d 2016 IEEE 16th International Conference on Data Mining (ICDM). IEEE, 2016.</td></tr>\n</tbody>\n</table>\n<table id=\"id20\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id11\" rel=\"nofollow\">[7]</a></td><td>Chuan Guo, Geoff Pleiss, Yu Sun and Kilian Q. Weinberger: \u201cOn Calibration of Modern Neural Networks.\u201d Proceedings of the 34th International Conference on Machine Learning, 2017.</td></tr>\n</tbody>\n</table>\n<table id=\"id21\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id13\" rel=\"nofollow\">[8]</a></td><td>Pereyra, G., Tucker, G., Chorowski, J., Kaiser, L. and Hinton, G.: \u201cRegularizing neural networks by penalizing confident output distributions.\u201d CoRR, 2017.</td></tr>\n</tbody>\n</table>\n<table id=\"id22\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id3\" rel=\"nofollow\">[9]</a></td><td>Pedregosa, F., Varoquaux, G., Gramfort, A., Michel, V., Thirion, B., Grisel, O., Blondel, M., Prettenhofer, P., Weiss, R., Dubourg, V., Vanderplas, J., Passos, A., Cournapeau, D., Brucher, M., Perrot, M. and Duchesnay, E.: \u201cScikit-learn: Machine Learning in Python.\u201d In Journal of Machine Learning Research, volume 12 pp 2825-2830, 2011.</td></tr>\n</tbody>\n</table>\n<table id=\"id23\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id10\" rel=\"nofollow\">[10]</a></td><td>Platt, John: \u201cProbabilistic outputs for support vector machines and comparisons to regularized likelihood methods.\u201d Advances in large margin classifiers, 10(3): 61\u201374, 1999.</td></tr>\n</tbody>\n</table>\n<table id=\"id24\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id2\" rel=\"nofollow\">[11]</a></td><td>Neumann, Lukas, Andrew Zisserman, and Andrea Vedaldi: \u201cRelaxed Softmax: Efficient Confidence Auto-Calibration for Safe Pedestrian Detection.\u201d Conference on Neural Information Processing Systems (NIPS) Workshop MLITS, 2018.</td></tr>\n</tbody>\n</table>\n</div>\n\n          </div>"}, "last_serial": 5785066, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "8fdd2d30d58a7e53b30e6eeb2b9196dc", "sha256": "50640a08ca48c9cbcf9163f709ea264caf1c3dfc6d1efb59c30a1b3d3bb7f56f"}, "downloads": -1, "filename": "netcal-1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "8fdd2d30d58a7e53b30e6eeb2b9196dc", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 55218, "upload_time": "2019-09-05T07:21:12", "upload_time_iso_8601": "2019-09-05T07:21:12.716382Z", "url": "https://files.pythonhosted.org/packages/d7/3c/e05c8dd950d856a81b48e88ceac1aef6dd5693f06fe52f6c9ceec2e6bf08/netcal-1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fa9eb394b70949b66b4e25aca7393f66", "sha256": "fcdc9594d327c78b3cbe4666179aa009dab36e2649b4765582dc30cf2309e82b"}, "downloads": -1, "filename": "netcal-1.0.tar.gz", "has_sig": false, "md5_digest": "fa9eb394b70949b66b4e25aca7393f66", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29173, "upload_time": "2019-09-05T07:21:15", "upload_time_iso_8601": "2019-09-05T07:21:15.399239Z", "url": "https://files.pythonhosted.org/packages/12/e3/3f6cc2af101ecc12c7f44116213a8763b31749fcc844089431eb5e9c1266/netcal-1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "8fdd2d30d58a7e53b30e6eeb2b9196dc", "sha256": "50640a08ca48c9cbcf9163f709ea264caf1c3dfc6d1efb59c30a1b3d3bb7f56f"}, "downloads": -1, "filename": "netcal-1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "8fdd2d30d58a7e53b30e6eeb2b9196dc", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 55218, "upload_time": "2019-09-05T07:21:12", "upload_time_iso_8601": "2019-09-05T07:21:12.716382Z", "url": "https://files.pythonhosted.org/packages/d7/3c/e05c8dd950d856a81b48e88ceac1aef6dd5693f06fe52f6c9ceec2e6bf08/netcal-1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fa9eb394b70949b66b4e25aca7393f66", "sha256": "fcdc9594d327c78b3cbe4666179aa009dab36e2649b4765582dc30cf2309e82b"}, "downloads": -1, "filename": "netcal-1.0.tar.gz", "has_sig": false, "md5_digest": "fa9eb394b70949b66b4e25aca7393f66", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29173, "upload_time": "2019-09-05T07:21:15", "upload_time_iso_8601": "2019-09-05T07:21:15.399239Z", "url": "https://files.pythonhosted.org/packages/12/e3/3f6cc2af101ecc12c7f44116213a8763b31749fcc844089431eb5e9c1266/netcal-1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:46:02 2020"}