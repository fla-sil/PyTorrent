{"info": {"author": "Martin Aspeli and contributors", "author_email": "optilude@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Framework :: Plone", "Framework :: Plone :: 5.2", "Framework :: Plone :: Core", "License :: OSI Approved :: BSD License", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "Introduction\n============\n\nThis package provides primitives for turning content objects described by ``zope.schema`` fields into RFC (2)822 style messages.\nIt utilizes the Python standard library's ``email`` module.\n\nIt consists of:\n\n* A marker interface ``IPrimaryField`` which can be used to indicate the primary field of a schema.\n  The primary field will be used as the message body.\n  If there are more than one field marked as primary, the body is turned in a MIME multipart message.\n* An interface ``IFieldMarshaler`` which describes marshalers that convert to and from strings suitable for encoding into an RFC 2822 style message.\n  These are multi-adapters on ``(context, field)``.\n  ``context`` is the content object and ``field`` is the schema field instance.\n* Default implementations of ``IFieldMarshaler`` for the standard fields in the ``zope.schema`` package.\n* Helper methods to construct messages from one or more schemata or a list of fields, and to parse a message and update a context object accordingly.\n\nThe helper methods are described by ``plone.rfc822.interfaces.IMessageAPI``.\nThey are importable directly from the ``plone.rfc822`` package::\n\n    def constructMessageFromSchema(context, schema, charset='utf-8'):\n        \"\"\"Convenience method which calls ``constructMessage()`` with all the\n        fields, in order, of the given schema interface\n        \"\"\"\n\n    def constructMessageFromSchemata(context, schemata, charset='utf-8'):\n        \"\"\"Convenience method which calls ``constructMessage()`` with all the\n        fields, in order, of all the given schemata (a sequence of schema\n        interfaces).\n        \"\"\"\n\n    def constructMessage(context, fields, charset='utf-8'):\n        \"\"\"Helper method to construct a message.\n\n        ``context`` is a content object.\n\n        ``fields`` is a sequence of (name, field) pairs for the fields which make\n        up the message. This can be obtained from zope.schema.getFieldsInOrder,\n        for example.\n\n        ``charset`` is the message charset.\n\n        The message body will be constructed from the primary field, i.e. the\n        field which is marked with ``IPrimaryField``. If no such field exists,\n        the message will have no body. If multiple fields exist, the message will\n        be a multipart message. Otherwise, it will contain a scalar string\n        payload.\n\n        A field will be ignored if ``(context, field)`` cannot be multi-adapted\n        to ``IFieldMarshaler``, or if the ``marshal()`` method returns None.\n        \"\"\"\n\n    def renderMessage(message, mangleFromHeader=False):\n        \"\"\"Render a message to a string\n        \"\"\"\n\n    def initializeObjectFromSchema(context, schema, message, defaultCharset='utf-8'):\n        \"\"\"Convenience method which calls ``initializeObject()`` with all the\n        fields, in order, of the given schema interface\n        \"\"\"\n\n    def initializeObjectFromSchemata(context, schemata, message, defaultCharset='utf-8'):\n        \"\"\"Convenience method which calls ``initializeObject()`` with all the\n        fields in order, of all the given schemata (a sequence of schema\n        interfaces).\n        \"\"\"\n\n    def initializeObject(context, fields, message, defaultCharset='utf-8'):\n        \"\"\"Initialise an object from a message.\n\n        ``context`` is the content object to initialise.\n\n        ``fields`` is a sequence of (name, field) pairs for the fields which make\n        up the message. This can be obtained from zope.schema.getFieldsInOrder,\n        for example.\n\n        ``message`` is a ``Message`` object.\n\n        ``defaultCharset`` is the default character set to use.\n\n        If the message is a multipart message, the primary fields will be read\n        in order.\n        \"\"\"\n\nThe message format used adheres to the following rules:\n\n* All non-primary fields are represented as headers.\n  The header name is taken from the field name.\n  The value is an encoded string as returned by the ``marshal()`` method of the appropriate ``IFieldMarshal`` multi-adapter.\n* If no ``IFieldMarshaler`` adapter can be found, the header is ignored.\n* Similarly, if no fields are found for a given header when parsing a message, the header is ignored.\n* If there is a single primary field, the message has a string payload, which is the marshalled value of the primary field.\n  In this case, the ``Content-Type`` header of the message will be obtained from the primary field's marshaler.\n* If there are multiple primary fields, each is encoded into its own message, each with its own ``Content-Type`` header.\n  The outer message will have a content type of ``multipart/mixed`` and headers for other fields.\n* A ``ValueError`` error is raised if a message is being parsed which has more or fewer parts than there are primary fields.\n* Duplicate field names are allowed, and will be encoded as duplicate headers.\n  When parsing a message, there needs to be one field per header.\n  That is, if a message contains two headers with the name 'foo',\n  the list of field name/ instance pairs passed to the ``initializeObject()`` method should contain two pairs with the name 'foo'.\n  The first field will be used for the first header value, the second field will be used for the second header value.\n  If a third 'foo' header appears, it will be ignored.\n* Since message headers are always lowercase, field names will be matched case-insensitively when parsing a message.\n\nSupermodel handler\n------------------\n\nIf ``plone.supermodel`` is installed, this package  will register a namespace handler for the ``marshal`` namespace, with the URI ``http://namespaces.plone.org/supermodel/marshal``.\nThis can be used to mark a field as the primary field::\n\n    <model xmlns=\"http://namespaces.plone.org/supermodel/schema\"\n           xmlns:marshal=\"http://namespaces.plone.org/supermodel/marshal\">\n        <schema>\n            <field type=\"zope.schema.Text\" name=\"test\" marshal:primary=\"true\">\n                <title>Test field</title>\n            </field>\n        </schema>\n    </model>\n\n``plone.supermodel`` may be installed as a dependency using the extra\n``[supermodel]``, but this is probably only useful for running the tests.\nIf the package is not installed, the handler will not be ignored.\n\nLicense note\n------------\n\nThis package is released under the BSD license.\nContributors, please do not add dependencies on GPL code.\n\nIssue tracker\n-------------\n\nPlease report issues via the `Plone issue tracker`_.\n\n.. _`Plone issue tracker`: https://github.com/plone/plone.rfc822/issues\n\nSupport\n-------\n\nDexterity use questions may be answered via `Plone's support channels`_.\n\n.. _`Plone's support channels`: http://plone.org/support\n\nContributing\n------------\n\nSources are at the `Plone code repository hosted at Github <https://github.com/plone/plone.rfc822>`_.\n\nContributors please read the document `Process for Plone core's development <https://docs.plone.org/develop/coredev/docs/index.html>`_\n\nChangelog\n=========\n\n.. You should *NOT* be adding new change log entries to this file.\n   You should create a file in the news directory instead.\n   For helpful instructions, please see:\n   https://github.com/plone/plone.releaser/blob/master/ADD-A-NEWS-ITEM.rst\n\n.. towncrier release notes start\n\n2.0.2 (2020-04-22)\n------------------\n\nBug fixes:\n\n\n- Minor packaging updates. (#1)\n\n\n2.0.1 (2019-05-21)\n------------------\n\nBug fixes:\n\n\n- Use a better type check in the payload parser.\n  [Rotonen] (#7)\n\n\n2.0.0 (2018-11-04)\n------------------\n\nBreaking changes:\n\n- Deprecate ``renderMessage(message)``,\n  use stdlibs ``message.as_string()`` from ``email.message.Message`` class instead.\n  [jensens]\n\n- Newline handling in MIME-headers: ``\\n`` are now escaped explicit.\n  This follows RFC2822 section 3.2.2.\n  [jensens]\n\n- Drop support of Python 2.6\n  [jensens]\n\nNew features:\n\n- ``constructMessage`` now handles base64 encoding automatically for all marshallers,\n  where ``marshaler.ascii`` is ``False`` and ``marshaler.getContentType`` is ``None``.\n  [jensens]\n\n- Support for Python 3+\n  Also big code overhaul included.\n  [jensens]\n\n\n1.1.4 (2018-06-20)\n------------------\n\nNew features:\n\n- Start basic Python 3 support.\n  [pbauer, dhavlik]\n\n\n1.1.3 (2016-08-09)\n------------------\n\nFixes:\n\n- code cleanup: pep8, isort, utf8 headers et al.\n  [jensens]\n\n- Use zope.interface decorator.\n  [gforcada]\n\n\n1.1.2 (2016-02-21)\n------------------\n\nFixes:\n\n- Fix test isolation problem.\n  [thet]\n\n- Replace deprecated ``zope.testing.doctest`` import with ``doctest`` module from stdlib.\n  [thet]\n\n\n1.1.1 (2015-03-21)\n------------------\n\n- Update test to reflect the change in the representation of the model namespaces by adding the 18n xml namespace.\n  [sneridagh]\n\n- Make sure the tests do not fail if messages contain a trailing blank line. This fixes test failures on Ubuntu 14.04.\n  [timo]\n\n\n1.1 (2013-08-14)\n----------------\n\n- Branch for Plone 4.2/4.3 compatibility changes.\n  [esteele]\n\n\n1.0.2 (2013-07-28)\n------------------\n\n- Marshall collections as ASCII when possible.\n  [davisagli]\n\n- Add support for marshalling decimal fields.\n  [davisagli]\n\n1.0.1 (2013-01-01)\n------------------\n\n1.0 (2011-05-20)\n----------------\n\n* Relicensed under the BSD license.\n  See http://plone.org/foundation/materials/foundation-resolutions/plone-framework-components-relicensing-policy\n  [davisagli]\n\n1.0b2 (2011-02-11)\n------------------\n\n* Add IPrimaryFieldInfo to look up primary field information on a content item.\n\n1.0b1 (2009-10-08)\n------------------\n\n* Initial release\n\nMessage construction and parsing\n================================\n\nThis package contains helper methods to construct an RFC 2822 style message\nfrom a list of schema fields, and to parse a message and initialise an object\nbased on its headers and body payload.\n\nBefore we begin, let's load the default field marshalers and configure\nannotations, which we will use later in this test::\n\n    >>> configuration = u\"\"\"\\\n    ... <configure\n    ...      xmlns=\"http://namespaces.zope.org/zope\"\n    ...      i18n_domain=\"plone.rfc822.tests\">\n    ...\n    ...     <include package=\"zope.component\" file=\"meta.zcml\" />\n    ...     <include package=\"zope.annotation\" />\n    ...\n    ...     <include package=\"plone.rfc822\" />\n    ...\n    ... </configure>\n    ... \"\"\"\n\n::\n\n    >>> from six import StringIO\n    >>> from zope.configuration import xmlconfig\n    >>> xmlconfig.xmlconfig(StringIO(configuration))\n\nThe primary field\n-----------------\n\nThe message body is assumed to originate from a \"primary\" field, which is\nindicated via a marker interface.\n\nTo illustrate the pattern, consider the following schema interface::\n\n    >>> from zope.interface import Interface, alsoProvides\n    >>> from plone.rfc822.interfaces import IPrimaryField\n    >>> from zope import schema\n\n    >>> class ITestContent(Interface):\n    ...\n    ...     title = schema.TextLine(title=u\"Title\")\n    ...     description = schema.Text(title=u\"Description\")\n    ...     body = schema.Text(title=u\"Body text\")\n    ...     emptyfield = schema.TextLine(title=u\"Empty field\", missing_value=u'missing')\n\nThe primary field instance is marked like this::\n\n    >>> alsoProvides(ITestContent['body'], IPrimaryField)\n\nConstructing a message\n----------------------\n\nLet's now say we have an instance providing this interface, which we want to\nmarshal to a message::\n\n    >>> from zope.interface import implementer\n    >>> @implementer(ITestContent)\n    ... class TestContent(object):\n    ...     title = \"\"\n    ...     description = \"\"\n    ...     body = \"\"\n    ...     emptyfield = None\n\n    >>> content = TestContent()\n    >>> content.title = \"Test title\"\n    >>> content.description = \"\"\"T\u00e4st description\n    ... with a newline\"\"\"\n    >>> content.body = \"<p>Test body</p>\"\n\nWe could create a message from this instance and schema like this::\n\n    >>> from plone.rfc822 import constructMessageFromSchema\n    >>> msg = constructMessageFromSchema(content, ITestContent)\n\nThe output looks like this::\n\n    >>> print(msg.as_string())\n    title: Test title\n    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n    emptyfield:\n    Content-Type: text/plain; charset=\"utf-8\"\n    <BLANKLINE>\n    <p>Test body</p>\n\nNotice how the non-ASCII header values are UTF-8 encoded.\nThe encoding algorithm is clever enough to only encode the value if it is necessary,\nleaving more readable field values otherwise.\n\nThe body here is of the default message type::\n\n    >>> msg.get_default_type()\n    'text/plain'\n\nThis is because none of the default field types manage a content type.\n\nThe body is also utf-8 encoded, because the primary field specified this\nencoding.\n\nIf we want to use a different content type, we could set it explicitly::\n\n    >>> msg.set_type('text/html')\n    >>> print(msg.as_string())\n    title: Test title\n    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n    emptyfield:\n    MIME-Version: 1.0\n    Content-Type: text/html; charset=\"utf-8\"\n    <BLANKLINE>\n    <p>Test body</p>\n\nAlternatively, if we know that any ``IText`` field on an object providing\nour ``ITestContent`` interface always stores HTML, could register a custom\n``IFieldMarshaler`` adapter which would indicate this to the message\nconstructor. Let's take a look at that now.\n\nCustom marshalers\n-----------------\n\nThe default marshaler can be obtained by multi-adapting the content object\nand the field instance to ``IFieldMarshaler``:\n\n    >>> from zope.component import getMultiAdapter\n    >>> from plone.rfc822.interfaces import IFieldMarshaler\n    >>> getMultiAdapter((content, ITestContent['body'],), IFieldMarshaler)\n    <plone.rfc822.defaultfields.UnicodeValueFieldMarshaler object at ...>\n\nLet's now create our own marshaler by extending this class and overriding\nthe ``getContentType()``:\n\n    >>> from plone.rfc822.defaultfields import UnicodeValueFieldMarshaler\n    >>> from zope.schema.interfaces import IText\n    >>> from zope.component import adapter\n\n    >>> @adapter(ITestContent, IText)\n    ... class TestBodyMarshaler(UnicodeValueFieldMarshaler):\n    ...     def getContentType(self):\n    ...         return 'text/html'\n\nOrdinarily, we'd register this with ZCML. For the purpose of the test, we'll\nregister it using the ``zope.component`` API.\n\n    >>> from zope.component import provideAdapter\n    >>> provideAdapter(TestBodyMarshaler)\n\nHint: If the schema contained multiple text fields, this adapter would apply\nto all of them. To avoid that, we could either mark the field with a custom\nmarker interface (similary to the way we marked a field with ``IPrimaryField``\nabove), or have the marshaler check the field name.\n\nLet's now try again:\n\n    >>> msg = constructMessageFromSchema(content, ITestContent)\n    >>> print(msg.as_string())\n    title: Test title\n    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n    emptyfield:\n    MIME-Version: 1.0\n    Content-Type: text/html; charset=\"utf-8\"\n    <BLANKLINE>\n    <p>Test body</p>\n\nNotice how the Content-Type has changed.\n\nConsuming a message\n-------------------\n\nA message can be used to initialise an object. The object has to be\nconstructed first:\n\n    >>> newContent = TestContent()\n\nWe then need to obtain a ``Message`` object. The ``email`` module contains\nhelper functions for this purpose.\n\n    >>> messageBody = \"\"\"\\\n    ... title: Test title\n    ... description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=\n    ... Content-Type: text/html\n    ...\n    ... <p>Test body</p>\"\"\"\n\n    >>> from email import message_from_string\n    >>> msg = message_from_string(messageBody)\n\nThe message can now be used to initialise the object according to the given\nschema. This should be the same schema as the one used to construct the\nmessage.\n\n    >>> from plone.rfc822 import initializeObjectFromSchema\n    >>> initializeObjectFromSchema(newContent, ITestContent, msg)\n\n    >>> newContent.title\n    'Test title'\n    >>> print(newContent.description)\n    Test description\n    with a newline\n\n    >>> newContent.body\n    '<p>Test body</p>'\n\nWe can also consume messages with a transfer encoding and a charset:\n\n    >>> messageBody = \"\"\"\\\n    ... title: =?utf-8?q?Test_title?=\n    ... description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=\n    ... emptyfield:\n    ... Content-Transfer-Encoding: base64\n    ... Content-Type: text/html; charset=\"utf-8\"\n    ... <BLANKLINE>\n    ... PHA+VGVzdCBib2R5PC9wPg==\n    ... <BLANKLINE>\"\"\"\n\n    >>> msg = message_from_string(messageBody)\n    >>> msg.get_content_type()\n    'text/html'\n    >>> msg.get_content_charset()\n    'utf-8'\n\n    >>> initializeObjectFromSchema(newContent, ITestContent, msg)\n\n    >>> newContent.title\n    'Test title'\n    >>> print(newContent.description)\n    Test description\n    with a newline\n    >>> newContent.body\n    '<p>Test body</p>'\n\nNote: Empty fields will result in the field's ``missing_value`` being used:\n\n    >>> newContent.emptyfield\n    'missing'\n\nHandling multiple primary fields and duplicate field names\n----------------------------------------------------------\n\nIt is possible that our type could have multiple primary fields or even\nduplicate field names.\n\nFor example, consider the following schema interface, intended to be used\nin an annotation adapter:\n\n    >>> class IPersonalDetails(Interface):\n    ...     description = schema.Text(title=u\"Personal description\")\n    ...     currentAge = schema.Int(title=u\"Age\", min=0)\n    ...     personalProfile = schema.Text(title=u\"Profile\")\n\n    >>> alsoProvides(IPersonalDetails['personalProfile'], IPrimaryField)\n\nThe annotation storage would look like this:\n\n    >>> from persistent import Persistent\n    >>> @implementer(IPersonalDetails)\n    ... @adapter(ITestContent)\n    ... class PersonalDetailsAnnotation(Persistent):\n    ...\n    ...     def __init__(self):\n    ...         self.description = None\n    ...         self.currentAge = None\n    ...         self.personalProfile = None\n\n    >>> from zope.annotation.factory import factory\n    >>> provideAdapter(factory(PersonalDetailsAnnotation))\n\nWe should now be able to adapt a content instance to IPersonalDetails,\nprovided it is annotatable.\n\n    >>> from zope.annotation.interfaces import IAttributeAnnotatable\n    >>> alsoProvides(content, IAttributeAnnotatable)\n\n    >>> personalDetails = IPersonalDetails(content)\n    >>> personalDetails.description = u\"<p>My description</p>\"\n    >>> personalDetails.currentAge = 21\n    >>> personalDetails.personalProfile = u\"<p>My profile</p>\"\n\nThe default marshalers will attempt to adapt the context to the schema of\na given field before getting or setting a value. If we pass multiple schemata\n(or a combined sequence of fields) to the message constructor, it will\nhandle both duplicate field names (as duplicate headers) and multiple primary\nfields (as multipart message attachments).\n\nHere are the fields it will see:\n\n    >>> from zope.schema import getFieldsInOrder\n    >>> allFields = getFieldsInOrder(ITestContent) + \\\n    ...             getFieldsInOrder(IPersonalDetails)\n\n    >>> [f[0] for f in allFields]\n    ['title', 'description', 'body', 'emptyfield', 'description', 'currentAge', 'personalProfile']\n\n    >>> [f[0] for f in allFields if IPrimaryField.providedBy(f[1])]\n    ['body', 'personalProfile']\n\nLet's now construct a message. Since we now have two fields called\n``description``, we will get two headers by that name. Since we have two\nprimary fields, we will get a multipart message with two attachments::\n\n    >>> from plone.rfc822 import constructMessageFromSchemata\n    >>> msg = constructMessageFromSchemata(content, (ITestContent, IPersonalDetails,))\n    >>> msgString = msg.as_string()\n    >>> print(msgString)\n    title: Test title\n    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n    emptyfield:\n    description: <p>My description</p>\n    currentAge: 21\n    MIME-Version: 1.0\n    Content-Type: multipart/mixed; boundary=\"===============...==\"\n    <BLANKLINE>\n    --===============...==\n    MIME-Version: 1.0\n    Content-Type: text/html; charset=\"utf-8\"\n    <BLANKLINE>\n    <p>Test body</p>\n    --===============...==\n    MIME-Version: 1.0\n    Content-Type: text/html; charset=\"utf-8\"\n    <BLANKLINE>\n    <p>My profile</p>\n    --===============...==--\n    <BLANKLINE>\n\n\n(Note that we've used ellipses here for the doctest to work with the generated\nboundary string).\n\nNotice how both messages have a MIME type of 'text/html' and no charset.\nThat is because of the custom adapter for ``(ITestContent, IText)`` which we\nregistered earlier.\n\nWe can obviously read this message as well. Note that in this case, the order\nof fields passed to ``initializeObject()`` is important, both to determine\nwhich field gets which ``description`` header, and to match the two\nattachments to the two primary fields:\n\n    >>> newContent = TestContent()\n    >>> alsoProvides(newContent, IAttributeAnnotatable)\n\n    >>> from plone.rfc822 import initializeObjectFromSchemata\n    >>> msg = message_from_string(msgString)\n    >>> initializeObjectFromSchemata(newContent, [ITestContent, IPersonalDetails], msg)\n\n    >>> newContent.title\n    'Test title'\n\n    >>> newContent.marker = True\n    >>> newContent.description\n    'T\\xe4st description\\nwith a newline'\n\n    >>> newContent.body\n    '<p>Test body</p>'\n\n    >>> newPersonalDetails = IPersonalDetails(newContent)\n    >>> newPersonalDetails.description\n    '<p>My description</p>'\n\n    >>> newPersonalDetails.currentAge\n    21\n\n    >>> newPersonalDetails.personalProfile\n    '<p>My profile</p>'\n\nAlternative ways to deal with multiple schemata\n-----------------------------------------------\n\nIn the example above, we created a single enveloping message with headers\ncorresponding to the fields in both our schemata, and only the primary fields\nseparated out into different attached payloads.\n\nAn alternative approach would be to separate each schema out into its\nown multipart message. To do that, we would simply use the\n``constructMessage()`` function multiple times.\n\n    >>> mainMessage = constructMessageFromSchema(content, ITestContent)\n    >>> personalDetailsMessage = constructMessageFromSchema(content, IPersonalDetails)\n\n    >>> from email.mime.multipart import MIMEMultipart\n    >>> envelope = MIMEMultipart()\n    >>> envelope.attach(mainMessage)\n    >>> envelope.attach(personalDetailsMessage)\n\n    >>> envelopeString = envelope.as_string()\n    >>> print(envelopeString)\n    Content-Type: multipart/mixed; boundary=\"===============...==\"\n    MIME-Version: 1.0\n    <BLANKLINE>\n    --===============...==\n    title: Test title\n    description: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\n    emptyfield:\n    MIME-Version: 1.0\n    Content-Type: text/html; charset=\"utf-8\"\n    <BLANKLINE>\n    <p>Test body</p>\n    --===============...==\n    description: <p>My description</p>\n    currentAge: 21\n    MIME-Version: 1.0\n    Content-Type: text/html; charset=\"utf-8\"\n    <BLANKLINE>\n    <p>My profile</p>\n    --===============...==--...\n\nWhich approach works best will depend largely on the intended recipient of\nthe message.\n\nEncoding the payload and handling filenames\n-------------------------------------------\n\nFinally, let's consider a more complex example, inspired by the field\nmarshaler in ``plone.namedfile``.\n\nLet's say we have a value type intended to represent a binary file with a\nfilename and content type:\n\n    >>> from zope.interface import Interface, implementer\n    >>> from zope import schema\n\n    >>> class IFileValue(Interface):\n    ...     data = schema.Bytes(title=u\"Raw data\")\n    ...     contentType = schema.ASCIILine(title=u\"MIME type\")\n    ...     filename = schema.ASCIILine(title=u\"Filename\")\n\n    >>> @implementer(IFileValue)\n    ... class FileValue(object):\n    ...\n    ...     def __init__(self, data, contentType, filename):\n    ...         self.data = data\n    ...         self.contentType = contentType\n    ...         self.filename = filename\n\nSuppose we had a custom field type to represent this:\n\n    >>> from zope.schema.interfaces import IObject\n    >>> class IFileField(IObject):\n    ...     pass\n\n    >>> @implementer(IFileField)\n    ... class FileField(schema.Object):\n    ...     schema = IFileValue\n    ...     def __init__(self, **kw):\n    ...         if 'schema' in kw:\n    ...             self.schema = kw.pop('schema')\n    ...         super(FileField, self).__init__(schema=self.schema, **kw)\n\nWe can register a field marshaler for this field which will do the following:\n\n* Insist that the field is only used as a primary field, since it makes\n  little sense to encode a binary file in a header.\n* Save the filename in a Content-Disposition header.\n* Be capable of reading the filename again from this header.\n* Encode the payload using base64\n\n    >>> from plone.rfc822.interfaces import IFieldMarshaler\n    >>> from email.encoders import encode_base64\n\n    >>> from zope.component import adapter\n    >>> from plone.rfc822.defaultfields import BaseFieldMarshaler\n\n    >>> @adapter(Interface, IFileField)\n    ... class FileFieldMarshaler(BaseFieldMarshaler):\n    ...\n    ...     ascii = False\n    ...\n    ...     def encode(self, value, charset='utf-8', primary=False):\n    ...         if not primary:\n    ...             raise ValueError(\"File field cannot be marshaled as a non-primary field\")\n    ...         if value is None:\n    ...             return None\n    ...         return value.data\n    ...\n    ...     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):\n    ...         filename = None\n    ...         # get the filename from the Content-Disposition header if possible\n    ...         if primary and message is not None:\n    ...             filename = message.get_filename(None)\n    ...         return FileValue(value, contentType, filename)\n    ...\n    ...     def getContentType(self):\n    ...         value = self._query()\n    ...         if value is None:\n    ...             return None\n    ...         return value.contentType\n    ...\n    ...     def getCharset(self, default='utf-8'):\n    ...         return None # this is not text data!\n    ...\n    ...     def postProcessMessage(self, message):\n    ...         value = self._query()\n    ...         if value is not None:\n    ...             filename = value.filename\n    ...             if filename:\n    ...                 # Add a new header storing the filename if we have one\n    ...                 message.add_header('Content-Disposition', 'attachment', filename=filename)\n\n    >>> from zope.component import provideAdapter\n    >>> provideAdapter(FileFieldMarshaler)\n\nTo illustrate marshaling, let's create a content object that contains two file\nfields.\n\n    >>> class IFileContent(Interface):\n    ...     file1 = FileField()\n    ...     file2 = FileField()\n\n    >>> @implementer(IFileContent)\n    ... class FileContent(object):\n    ...     file1 = None\n    ...     file2 = None\n\n    >>> fileContent = FileContent()\n    >>> fileContent.file1 = FileValue('dummy file', 'text/plain', 'dummy1.txt')\n    >>> fileContent.file2 = FileValue('<html><body>test</body></html>', 'text/html', 'dummy2.html')\n\nAt this point, neither of these fields is marked as a primary field. Let's see\nwhat happens when we attempt to construct a message from this schema.\n\n    >>> from plone.rfc822 import constructMessageFromSchema\n    >>> message = constructMessageFromSchema(fileContent, IFileContent)\n    >>> print(message.as_string())\n    <BLANKLINE>\n    <BLANKLINE>\n\nAs expected, we got no message headers and no message body. Let's now mark one\nfield as primary:\n\n    >>> from plone.rfc822.interfaces import IPrimaryField\n    >>> from zope.interface import alsoProvides\n    >>> alsoProvides(IFileContent['file1'], IPrimaryField)\n\n    >>> message = constructMessageFromSchema(fileContent, IFileContent)\n    >>> messageBody = message.as_string()\n    >>> print(messageBody)\n    MIME-Version: 1.0\n    Content-Type: text/plain\n    Content-Transfer-Encoding: base64\n    Content-Disposition: attachment; filename=\"dummy1.txt\"\n    <BLANKLINE>\n    ZHVtbXkgZmlsZQ==\n\nHere, we have a base64 encoded payload, a Content-Disposition header, and a\nContent-Type header according to the primary field.\n\nWe can also reconstruct the object from this message.\n\n    >>> from plone.rfc822 import initializeObjectFromSchema\n    >>> from email import message_from_string\n\n    >>> inputMessage = message_from_string(messageBody)\n    >>> newFileContent = FileContent()\n    >>> initializeObjectFromSchema(newFileContent, IFileContent, inputMessage)\n\n    >>> newFileContent.file1.data\n    'dummy file'\n    >>> newFileContent.file1.contentType\n    'text/plain'\n    >>> newFileContent.file1.filename\n    'dummy1.txt'\n\n    >>> newFileContent.file2 is None\n    True\n\nLet's now show what would happen if we encoded both files in the message.\nIn this case, we should get a multipart document with two payloads.\n\n    >>> alsoProvides(IFileContent['file2'], IPrimaryField)\n    >>> message = constructMessageFromSchema(fileContent, IFileContent)\n    >>> messageBody = message.as_string()\n    >>> print(messageBody) # doctest: +ELLIPSIS\n    MIME-Version: 1.0\n    Content-Type: multipart/mixed; boundary=\"===============...==\"\n    <BLANKLINE>\n    --===============...==\n    MIME-Version: 1.0\n    Content-Type: text/plain\n    Content-Transfer-Encoding: base64\n    Content-Disposition: attachment; filename=\"dummy1.txt\"\n    <BLANKLINE>\n    ZHVtbXkgZmlsZQ==\n    --===============...==\n    MIME-Version: 1.0\n    Content-Type: text/html\n    Content-Transfer-Encoding: base64\n    Content-Disposition: attachment; filename=\"dummy2.html\"\n    <BLANKLINE>\n    PGh0bWw+PGJvZHk+dGVzdDwvYm9keT48L2h0bWw+\n    --===============...==--...\n\nAnd again, we can reconstruct the object, this time with both fields:\n\n    >>> inputMessage = message_from_string(messageBody)\n    >>> newFileContent = FileContent()\n    >>> initializeObjectFromSchema(newFileContent, IFileContent, inputMessage)\n\n    >>> newFileContent.file1.data\n    'dummy file'\n    >>> newFileContent.file1.contentType\n    'text/plain'\n    >>> newFileContent.file1.filename\n    'dummy1.txt'\n\n    >>> newFileContent.file2.data\n    '<html><body>test</body></html>'\n    >>> newFileContent.file2.contentType\n    'text/html'\n    >>> newFileContent.file2.filename\n    'dummy2.html'\n\nSpecialities between Py2 and Py3\n--------------------------------\n\nTest a special behavior which is different between Python 2 and 3 stdlib:\nNewline handling in non-utf8 strings.\n\nPython 2.7 ``email.header`` keeps a line with an escaped value,\nwhile Python 3.6 turns it into RFC2047 encoded headers, see https://tools.ietf.org/html/rfc2047.html\nTechnical both is fine.\n\n::\n\n    >>> import six\n    >>> content.description = \"Test content\\nwith newline difference\"\n    >>> msg = constructMessageFromSchema(content, ITestContent)\n    >>> effective_output = msg.as_string()\n    >>> effective_output.split('\\n')[1]\n    'description: =?utf-8?q?Test_content=5Cnwith_newline_difference?='\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://pypi.org/project/plone.rfc822", "keywords": "zope schema rfc822", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "plone.rfc822", "package_url": "https://pypi.org/project/plone.rfc822/", "platform": "", "project_url": "https://pypi.org/project/plone.rfc822/", "project_urls": {"Homepage": "https://pypi.org/project/plone.rfc822"}, "release_url": "https://pypi.org/project/plone.rfc822/2.0.2/", "requires_dist": ["python-dateutil", "setuptools", "zope.component", "zope.deprecation", "zope.interface", "zope.schema", "plone.supermodel ; extra == 'supermodel'", "plone.testing ; extra == 'test'", "plone.supermodel ; extra == 'test'"], "requires_python": "", "summary": "RFC822 marshalling for zope.schema fields", "version": "2.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>This package provides primitives for turning content objects described by <tt>zope.schema</tt> fields into RFC (2)822 style messages.\nIt utilizes the Python standard library\u2019s <tt>email</tt> module.</p>\n<p>It consists of:</p>\n<ul>\n<li>A marker interface <tt>IPrimaryField</tt> which can be used to indicate the primary field of a schema.\nThe primary field will be used as the message body.\nIf there are more than one field marked as primary, the body is turned in a MIME multipart message.</li>\n<li>An interface <tt>IFieldMarshaler</tt> which describes marshalers that convert to and from strings suitable for encoding into an RFC 2822 style message.\nThese are multi-adapters on <tt>(context, field)</tt>.\n<tt>context</tt> is the content object and <tt>field</tt> is the schema field instance.</li>\n<li>Default implementations of <tt>IFieldMarshaler</tt> for the standard fields in the <tt>zope.schema</tt> package.</li>\n<li>Helper methods to construct messages from one or more schemata or a list of fields, and to parse a message and update a context object accordingly.</li>\n</ul>\n<p>The helper methods are described by <tt>plone.rfc822.interfaces.IMessageAPI</tt>.\nThey are importable directly from the <tt>plone.rfc822</tt> package:</p>\n<pre>def constructMessageFromSchema(context, schema, charset='utf-8'):\n    \"\"\"Convenience method which calls ``constructMessage()`` with all the\n    fields, in order, of the given schema interface\n    \"\"\"\n\ndef constructMessageFromSchemata(context, schemata, charset='utf-8'):\n    \"\"\"Convenience method which calls ``constructMessage()`` with all the\n    fields, in order, of all the given schemata (a sequence of schema\n    interfaces).\n    \"\"\"\n\ndef constructMessage(context, fields, charset='utf-8'):\n    \"\"\"Helper method to construct a message.\n\n    ``context`` is a content object.\n\n    ``fields`` is a sequence of (name, field) pairs for the fields which make\n    up the message. This can be obtained from zope.schema.getFieldsInOrder,\n    for example.\n\n    ``charset`` is the message charset.\n\n    The message body will be constructed from the primary field, i.e. the\n    field which is marked with ``IPrimaryField``. If no such field exists,\n    the message will have no body. If multiple fields exist, the message will\n    be a multipart message. Otherwise, it will contain a scalar string\n    payload.\n\n    A field will be ignored if ``(context, field)`` cannot be multi-adapted\n    to ``IFieldMarshaler``, or if the ``marshal()`` method returns None.\n    \"\"\"\n\ndef renderMessage(message, mangleFromHeader=False):\n    \"\"\"Render a message to a string\n    \"\"\"\n\ndef initializeObjectFromSchema(context, schema, message, defaultCharset='utf-8'):\n    \"\"\"Convenience method which calls ``initializeObject()`` with all the\n    fields, in order, of the given schema interface\n    \"\"\"\n\ndef initializeObjectFromSchemata(context, schemata, message, defaultCharset='utf-8'):\n    \"\"\"Convenience method which calls ``initializeObject()`` with all the\n    fields in order, of all the given schemata (a sequence of schema\n    interfaces).\n    \"\"\"\n\ndef initializeObject(context, fields, message, defaultCharset='utf-8'):\n    \"\"\"Initialise an object from a message.\n\n    ``context`` is the content object to initialise.\n\n    ``fields`` is a sequence of (name, field) pairs for the fields which make\n    up the message. This can be obtained from zope.schema.getFieldsInOrder,\n    for example.\n\n    ``message`` is a ``Message`` object.\n\n    ``defaultCharset`` is the default character set to use.\n\n    If the message is a multipart message, the primary fields will be read\n    in order.\n    \"\"\"\n</pre>\n<p>The message format used adheres to the following rules:</p>\n<ul>\n<li>All non-primary fields are represented as headers.\nThe header name is taken from the field name.\nThe value is an encoded string as returned by the <tt>marshal()</tt> method of the appropriate <tt>IFieldMarshal</tt> multi-adapter.</li>\n<li>If no <tt>IFieldMarshaler</tt> adapter can be found, the header is ignored.</li>\n<li>Similarly, if no fields are found for a given header when parsing a message, the header is ignored.</li>\n<li>If there is a single primary field, the message has a string payload, which is the marshalled value of the primary field.\nIn this case, the <tt><span class=\"pre\">Content-Type</span></tt> header of the message will be obtained from the primary field\u2019s marshaler.</li>\n<li>If there are multiple primary fields, each is encoded into its own message, each with its own <tt><span class=\"pre\">Content-Type</span></tt> header.\nThe outer message will have a content type of <tt>multipart/mixed</tt> and headers for other fields.</li>\n<li>A <tt>ValueError</tt> error is raised if a message is being parsed which has more or fewer parts than there are primary fields.</li>\n<li>Duplicate field names are allowed, and will be encoded as duplicate headers.\nWhen parsing a message, there needs to be one field per header.\nThat is, if a message contains two headers with the name \u2018foo\u2019,\nthe list of field name/ instance pairs passed to the <tt>initializeObject()</tt> method should contain two pairs with the name \u2018foo\u2019.\nThe first field will be used for the first header value, the second field will be used for the second header value.\nIf a third \u2018foo\u2019 header appears, it will be ignored.</li>\n<li>Since message headers are always lowercase, field names will be matched case-insensitively when parsing a message.</li>\n</ul>\n<div id=\"supermodel-handler\">\n<h3>Supermodel handler</h3>\n<p>If <tt>plone.supermodel</tt> is installed, this package  will register a namespace handler for the <tt>marshal</tt> namespace, with the URI <tt><span class=\"pre\">http://namespaces.plone.org/supermodel/marshal</span></tt>.\nThis can be used to mark a field as the primary field:</p>\n<pre>&lt;model xmlns=\"http://namespaces.plone.org/supermodel/schema\"\n       xmlns:marshal=\"http://namespaces.plone.org/supermodel/marshal\"&gt;\n    &lt;schema&gt;\n        &lt;field type=\"zope.schema.Text\" name=\"test\" marshal:primary=\"true\"&gt;\n            &lt;title&gt;Test field&lt;/title&gt;\n        &lt;/field&gt;\n    &lt;/schema&gt;\n&lt;/model&gt;\n</pre>\n<p><tt>plone.supermodel</tt> may be installed as a dependency using the extra\n<tt>[supermodel]</tt>, but this is probably only useful for running the tests.\nIf the package is not installed, the handler will not be ignored.</p>\n</div>\n<div id=\"license-note\">\n<h3>License note</h3>\n<p>This package is released under the BSD license.\nContributors, please do not add dependencies on GPL code.</p>\n</div>\n<div id=\"issue-tracker\">\n<h3>Issue tracker</h3>\n<p>Please report issues via the <a href=\"https://github.com/plone/plone.rfc822/issues\" rel=\"nofollow\">Plone issue tracker</a>.</p>\n</div>\n<div id=\"support\">\n<h3>Support</h3>\n<p>Dexterity use questions may be answered via <a href=\"http://plone.org/support\" rel=\"nofollow\">Plone\u2019s support channels</a>.</p>\n</div>\n<div id=\"contributing\">\n<h3>Contributing</h3>\n<p>Sources are at the <a href=\"https://github.com/plone/plone.rfc822\" rel=\"nofollow\">Plone code repository hosted at Github</a>.</p>\n<p>Contributors please read the document <a href=\"https://docs.plone.org/develop/coredev/docs/index.html\" rel=\"nofollow\">Process for Plone core\u2019s development</a></p>\n</div>\n</div>\n<div id=\"changelog\">\n<h2>Changelog</h2>\n<div id=\"id1\">\n<h3>2.0.2 (2020-04-22)</h3>\n<p>Bug fixes:</p>\n<ul>\n<li>Minor packaging updates. (#1)</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>2.0.1 (2019-05-21)</h3>\n<p>Bug fixes:</p>\n<ul>\n<li>Use a better type check in the payload parser.\n[Rotonen] (#7)</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>2.0.0 (2018-11-04)</h3>\n<p>Breaking changes:</p>\n<ul>\n<li>Deprecate <tt>renderMessage(message)</tt>,\nuse stdlibs <tt>message.as_string()</tt> from <tt>email.message.Message</tt> class instead.\n[jensens]</li>\n<li>Newline handling in MIME-headers: <tt>\\n</tt> are now escaped explicit.\nThis follows RFC2822 section 3.2.2.\n[jensens]</li>\n<li>Drop support of Python 2.6\n[jensens]</li>\n</ul>\n<p>New features:</p>\n<ul>\n<li><tt>constructMessage</tt> now handles base64 encoding automatically for all marshallers,\nwhere <tt>marshaler.ascii</tt> is <tt>False</tt> and <tt>marshaler.getContentType</tt> is <tt>None</tt>.\n[jensens]</li>\n<li>Support for Python 3+\nAlso big code overhaul included.\n[jensens]</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>1.1.4 (2018-06-20)</h3>\n<p>New features:</p>\n<ul>\n<li>Start basic Python 3 support.\n[pbauer, dhavlik]</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3>1.1.3 (2016-08-09)</h3>\n<p>Fixes:</p>\n<ul>\n<li>code cleanup: pep8, isort, utf8 headers et al.\n[jensens]</li>\n<li>Use zope.interface decorator.\n[gforcada]</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3>1.1.2 (2016-02-21)</h3>\n<p>Fixes:</p>\n<ul>\n<li>Fix test isolation problem.\n[thet]</li>\n<li>Replace deprecated <tt>zope.testing.doctest</tt> import with <tt>doctest</tt> module from stdlib.\n[thet]</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3>1.1.1 (2015-03-21)</h3>\n<ul>\n<li>Update test to reflect the change in the representation of the model namespaces by adding the 18n xml namespace.\n[sneridagh]</li>\n<li>Make sure the tests do not fail if messages contain a trailing blank line. This fixes test failures on Ubuntu 14.04.\n[timo]</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3>1.1 (2013-08-14)</h3>\n<ul>\n<li>Branch for Plone 4.2/4.3 compatibility changes.\n[esteele]</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3>1.0.2 (2013-07-28)</h3>\n<ul>\n<li>Marshall collections as ASCII when possible.\n[davisagli]</li>\n<li>Add support for marshalling decimal fields.\n[davisagli]</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3>1.0.1 (2013-01-01)</h3>\n</div>\n<div id=\"id11\">\n<h3>1.0 (2011-05-20)</h3>\n<ul>\n<li>Relicensed under the BSD license.\nSee <a href=\"http://plone.org/foundation/materials/foundation-resolutions/plone-framework-components-relicensing-policy\" rel=\"nofollow\">http://plone.org/foundation/materials/foundation-resolutions/plone-framework-components-relicensing-policy</a>\n[davisagli]</li>\n</ul>\n</div>\n<div id=\"b2-2011-02-11\">\n<h3>1.0b2 (2011-02-11)</h3>\n<ul>\n<li>Add IPrimaryFieldInfo to look up primary field information on a content item.</li>\n</ul>\n</div>\n<div id=\"b1-2009-10-08\">\n<h3>1.0b1 (2009-10-08)</h3>\n<ul>\n<li>Initial release</li>\n</ul>\n</div>\n</div>\n<div id=\"message-construction-and-parsing\">\n<h2>Message construction and parsing</h2>\n<p>This package contains helper methods to construct an RFC 2822 style message\nfrom a list of schema fields, and to parse a message and initialise an object\nbased on its headers and body payload.</p>\n<p>Before we begin, let\u2019s load the default field marshalers and configure\nannotations, which we will use later in this test:</p>\n<pre>&gt;&gt;&gt; configuration = u\"\"\"\\\n... &lt;configure\n...      xmlns=\"http://namespaces.zope.org/zope\"\n...      i18n_domain=\"plone.rfc822.tests\"&gt;\n...\n...     &lt;include package=\"zope.component\" file=\"meta.zcml\" /&gt;\n...     &lt;include package=\"zope.annotation\" /&gt;\n...\n...     &lt;include package=\"plone.rfc822\" /&gt;\n...\n... &lt;/configure&gt;\n... \"\"\"\n</pre>\n<pre>&gt;&gt;&gt; from six import StringIO\n&gt;&gt;&gt; from zope.configuration import xmlconfig\n&gt;&gt;&gt; xmlconfig.xmlconfig(StringIO(configuration))\n</pre>\n<div id=\"the-primary-field\">\n<h3>The primary field</h3>\n<p>The message body is assumed to originate from a \u201cprimary\u201d field, which is\nindicated via a marker interface.</p>\n<p>To illustrate the pattern, consider the following schema interface:</p>\n<pre>&gt;&gt;&gt; from zope.interface import Interface, alsoProvides\n&gt;&gt;&gt; from plone.rfc822.interfaces import IPrimaryField\n&gt;&gt;&gt; from zope import schema\n\n&gt;&gt;&gt; class ITestContent(Interface):\n...\n...     title = schema.TextLine(title=u\"Title\")\n...     description = schema.Text(title=u\"Description\")\n...     body = schema.Text(title=u\"Body text\")\n...     emptyfield = schema.TextLine(title=u\"Empty field\", missing_value=u'missing')\n</pre>\n<p>The primary field instance is marked like this:</p>\n<pre>&gt;&gt;&gt; alsoProvides(ITestContent['body'], IPrimaryField)\n</pre>\n</div>\n<div id=\"constructing-a-message\">\n<h3>Constructing a message</h3>\n<p>Let\u2019s now say we have an instance providing this interface, which we want to\nmarshal to a message:</p>\n<pre>&gt;&gt;&gt; from zope.interface import implementer\n&gt;&gt;&gt; @implementer(ITestContent)\n... class TestContent(object):\n...     title = \"\"\n...     description = \"\"\n...     body = \"\"\n...     emptyfield = None\n\n&gt;&gt;&gt; content = TestContent()\n&gt;&gt;&gt; content.title = \"Test title\"\n&gt;&gt;&gt; content.description = \"\"\"T\u00e4st description\n... with a newline\"\"\"\n&gt;&gt;&gt; content.body = \"&lt;p&gt;Test body&lt;/p&gt;\"\n</pre>\n<p>We could create a message from this instance and schema like this:</p>\n<pre>&gt;&gt;&gt; from plone.rfc822 import constructMessageFromSchema\n&gt;&gt;&gt; msg = constructMessageFromSchema(content, ITestContent)\n</pre>\n<p>The output looks like this:</p>\n<pre>&gt;&gt;&gt; print(msg.as_string())\ntitle: Test title\ndescription: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\nemptyfield:\nContent-Type: text/plain; charset=\"utf-8\"\n&lt;BLANKLINE&gt;\n&lt;p&gt;Test body&lt;/p&gt;\n</pre>\n<p>Notice how the non-ASCII header values are UTF-8 encoded.\nThe encoding algorithm is clever enough to only encode the value if it is necessary,\nleaving more readable field values otherwise.</p>\n<p>The body here is of the default message type:</p>\n<pre>&gt;&gt;&gt; msg.get_default_type()\n'text/plain'\n</pre>\n<p>This is because none of the default field types manage a content type.</p>\n<p>The body is also utf-8 encoded, because the primary field specified this\nencoding.</p>\n<p>If we want to use a different content type, we could set it explicitly:</p>\n<pre>&gt;&gt;&gt; msg.set_type('text/html')\n&gt;&gt;&gt; print(msg.as_string())\ntitle: Test title\ndescription: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\nemptyfield:\nMIME-Version: 1.0\nContent-Type: text/html; charset=\"utf-8\"\n&lt;BLANKLINE&gt;\n&lt;p&gt;Test body&lt;/p&gt;\n</pre>\n<p>Alternatively, if we know that any <tt>IText</tt> field on an object providing\nour <tt>ITestContent</tt> interface always stores HTML, could register a custom\n<tt>IFieldMarshaler</tt> adapter which would indicate this to the message\nconstructor. Let\u2019s take a look at that now.</p>\n</div>\n<div id=\"custom-marshalers\">\n<h3>Custom marshalers</h3>\n<p>The default marshaler can be obtained by multi-adapting the content object\nand the field instance to <tt>IFieldMarshaler</tt>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.component import getMultiAdapter\n&gt;&gt;&gt; from plone.rfc822.interfaces import IFieldMarshaler\n&gt;&gt;&gt; getMultiAdapter((content, ITestContent['body'],), IFieldMarshaler)\n&lt;plone.rfc822.defaultfields.UnicodeValueFieldMarshaler object at ...&gt;\n</pre>\n</blockquote>\n<p>Let\u2019s now create our own marshaler by extending this class and overriding\nthe <tt>getContentType()</tt>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from plone.rfc822.defaultfields import UnicodeValueFieldMarshaler\n&gt;&gt;&gt; from zope.schema.interfaces import IText\n&gt;&gt;&gt; from zope.component import adapter\n</pre>\n<pre>&gt;&gt;&gt; @adapter(ITestContent, IText)\n... class TestBodyMarshaler(UnicodeValueFieldMarshaler):\n...     def getContentType(self):\n...         return 'text/html'\n</pre>\n</blockquote>\n<p>Ordinarily, we\u2019d register this with ZCML. For the purpose of the test, we\u2019ll\nregister it using the <tt>zope.component</tt> API.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.component import provideAdapter\n&gt;&gt;&gt; provideAdapter(TestBodyMarshaler)\n</pre>\n</blockquote>\n<p>Hint: If the schema contained multiple text fields, this adapter would apply\nto all of them. To avoid that, we could either mark the field with a custom\nmarker interface (similary to the way we marked a field with <tt>IPrimaryField</tt>\nabove), or have the marshaler check the field name.</p>\n<p>Let\u2019s now try again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; msg = constructMessageFromSchema(content, ITestContent)\n&gt;&gt;&gt; print(msg.as_string())\ntitle: Test title\ndescription: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\nemptyfield:\nMIME-Version: 1.0\nContent-Type: text/html; charset=\"utf-8\"\n&lt;BLANKLINE&gt;\n&lt;p&gt;Test body&lt;/p&gt;\n</pre>\n</blockquote>\n<p>Notice how the Content-Type has changed.</p>\n</div>\n<div id=\"consuming-a-message\">\n<h3>Consuming a message</h3>\n<p>A message can be used to initialise an object. The object has to be\nconstructed first:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; newContent = TestContent()\n</pre>\n</blockquote>\n<p>We then need to obtain a <tt>Message</tt> object. The <tt>email</tt> module contains\nhelper functions for this purpose.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; messageBody = \"\"\"\\\n... title: Test title\n... description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=\n... Content-Type: text/html\n...\n... &lt;p&gt;Test body&lt;/p&gt;\"\"\"\n</pre>\n<pre>&gt;&gt;&gt; from email import message_from_string\n&gt;&gt;&gt; msg = message_from_string(messageBody)\n</pre>\n</blockquote>\n<p>The message can now be used to initialise the object according to the given\nschema. This should be the same schema as the one used to construct the\nmessage.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from plone.rfc822 import initializeObjectFromSchema\n&gt;&gt;&gt; initializeObjectFromSchema(newContent, ITestContent, msg)\n</pre>\n<pre>&gt;&gt;&gt; newContent.title\n'Test title'\n&gt;&gt;&gt; print(newContent.description)\nTest description\nwith a newline\n</pre>\n<pre>&gt;&gt;&gt; newContent.body\n'&lt;p&gt;Test body&lt;/p&gt;'\n</pre>\n</blockquote>\n<p>We can also consume messages with a transfer encoding and a charset:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; messageBody = \"\"\"\\\n... title: =?utf-8?q?Test_title?=\n... description: =?utf-8?q?Test_description=0D=0Awith_a_newline?=\n... emptyfield:\n... Content-Transfer-Encoding: base64\n... Content-Type: text/html; charset=\"utf-8\"\n... &lt;BLANKLINE&gt;\n... PHA+VGVzdCBib2R5PC9wPg==\n... &lt;BLANKLINE&gt;\"\"\"\n</pre>\n<pre>&gt;&gt;&gt; msg = message_from_string(messageBody)\n&gt;&gt;&gt; msg.get_content_type()\n'text/html'\n&gt;&gt;&gt; msg.get_content_charset()\n'utf-8'\n</pre>\n<pre>&gt;&gt;&gt; initializeObjectFromSchema(newContent, ITestContent, msg)\n</pre>\n<pre>&gt;&gt;&gt; newContent.title\n'Test title'\n&gt;&gt;&gt; print(newContent.description)\nTest description\nwith a newline\n&gt;&gt;&gt; newContent.body\n'&lt;p&gt;Test body&lt;/p&gt;'\n</pre>\n</blockquote>\n<p>Note: Empty fields will result in the field\u2019s <tt>missing_value</tt> being used:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; newContent.emptyfield\n'missing'\n</pre>\n</blockquote>\n</div>\n<div id=\"handling-multiple-primary-fields-and-duplicate-field-names\">\n<h3>Handling multiple primary fields and duplicate field names</h3>\n<p>It is possible that our type could have multiple primary fields or even\nduplicate field names.</p>\n<p>For example, consider the following schema interface, intended to be used\nin an annotation adapter:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class IPersonalDetails(Interface):\n...     description = schema.Text(title=u\"Personal description\")\n...     currentAge = schema.Int(title=u\"Age\", min=0)\n...     personalProfile = schema.Text(title=u\"Profile\")\n</pre>\n<pre>&gt;&gt;&gt; alsoProvides(IPersonalDetails['personalProfile'], IPrimaryField)\n</pre>\n</blockquote>\n<p>The annotation storage would look like this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from persistent import Persistent\n&gt;&gt;&gt; @implementer(IPersonalDetails)\n... @adapter(ITestContent)\n... class PersonalDetailsAnnotation(Persistent):\n...\n...     def __init__(self):\n...         self.description = None\n...         self.currentAge = None\n...         self.personalProfile = None\n</pre>\n<pre>&gt;&gt;&gt; from zope.annotation.factory import factory\n&gt;&gt;&gt; provideAdapter(factory(PersonalDetailsAnnotation))\n</pre>\n</blockquote>\n<p>We should now be able to adapt a content instance to IPersonalDetails,\nprovided it is annotatable.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.annotation.interfaces import IAttributeAnnotatable\n&gt;&gt;&gt; alsoProvides(content, IAttributeAnnotatable)\n</pre>\n<pre>&gt;&gt;&gt; personalDetails = IPersonalDetails(content)\n&gt;&gt;&gt; personalDetails.description = u\"&lt;p&gt;My description&lt;/p&gt;\"\n&gt;&gt;&gt; personalDetails.currentAge = 21\n&gt;&gt;&gt; personalDetails.personalProfile = u\"&lt;p&gt;My profile&lt;/p&gt;\"\n</pre>\n</blockquote>\n<p>The default marshalers will attempt to adapt the context to the schema of\na given field before getting or setting a value. If we pass multiple schemata\n(or a combined sequence of fields) to the message constructor, it will\nhandle both duplicate field names (as duplicate headers) and multiple primary\nfields (as multipart message attachments).</p>\n<p>Here are the fields it will see:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.schema import getFieldsInOrder\n&gt;&gt;&gt; allFields = getFieldsInOrder(ITestContent) + \\\n...             getFieldsInOrder(IPersonalDetails)\n</pre>\n<pre>&gt;&gt;&gt; [f[0] for f in allFields]\n['title', 'description', 'body', 'emptyfield', 'description', 'currentAge', 'personalProfile']\n</pre>\n<pre>&gt;&gt;&gt; [f[0] for f in allFields if IPrimaryField.providedBy(f[1])]\n['body', 'personalProfile']\n</pre>\n</blockquote>\n<p>Let\u2019s now construct a message. Since we now have two fields called\n<tt>description</tt>, we will get two headers by that name. Since we have two\nprimary fields, we will get a multipart message with two attachments:</p>\n<pre>&gt;&gt;&gt; from plone.rfc822 import constructMessageFromSchemata\n&gt;&gt;&gt; msg = constructMessageFromSchemata(content, (ITestContent, IPersonalDetails,))\n&gt;&gt;&gt; msgString = msg.as_string()\n&gt;&gt;&gt; print(msgString)\ntitle: Test title\ndescription: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\nemptyfield:\ndescription: &lt;p&gt;My description&lt;/p&gt;\ncurrentAge: 21\nMIME-Version: 1.0\nContent-Type: multipart/mixed; boundary=\"===============...==\"\n&lt;BLANKLINE&gt;\n--===============...==\nMIME-Version: 1.0\nContent-Type: text/html; charset=\"utf-8\"\n&lt;BLANKLINE&gt;\n&lt;p&gt;Test body&lt;/p&gt;\n--===============...==\nMIME-Version: 1.0\nContent-Type: text/html; charset=\"utf-8\"\n&lt;BLANKLINE&gt;\n&lt;p&gt;My profile&lt;/p&gt;\n--===============...==--\n&lt;BLANKLINE&gt;\n</pre>\n<p>(Note that we\u2019ve used ellipses here for the doctest to work with the generated\nboundary string).</p>\n<p>Notice how both messages have a MIME type of \u2018text/html\u2019 and no charset.\nThat is because of the custom adapter for <tt>(ITestContent, IText)</tt> which we\nregistered earlier.</p>\n<p>We can obviously read this message as well. Note that in this case, the order\nof fields passed to <tt>initializeObject()</tt> is important, both to determine\nwhich field gets which <tt>description</tt> header, and to match the two\nattachments to the two primary fields:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; newContent = TestContent()\n&gt;&gt;&gt; alsoProvides(newContent, IAttributeAnnotatable)\n</pre>\n<pre>&gt;&gt;&gt; from plone.rfc822 import initializeObjectFromSchemata\n&gt;&gt;&gt; msg = message_from_string(msgString)\n&gt;&gt;&gt; initializeObjectFromSchemata(newContent, [ITestContent, IPersonalDetails], msg)\n</pre>\n<pre>&gt;&gt;&gt; newContent.title\n'Test title'\n</pre>\n<pre>&gt;&gt;&gt; newContent.marker = True\n&gt;&gt;&gt; newContent.description\n'T\\xe4st description\\nwith a newline'\n</pre>\n<pre>&gt;&gt;&gt; newContent.body\n'&lt;p&gt;Test body&lt;/p&gt;'\n</pre>\n<pre>&gt;&gt;&gt; newPersonalDetails = IPersonalDetails(newContent)\n&gt;&gt;&gt; newPersonalDetails.description\n'&lt;p&gt;My description&lt;/p&gt;'\n</pre>\n<pre>&gt;&gt;&gt; newPersonalDetails.currentAge\n21\n</pre>\n<pre>&gt;&gt;&gt; newPersonalDetails.personalProfile\n'&lt;p&gt;My profile&lt;/p&gt;'\n</pre>\n</blockquote>\n</div>\n<div id=\"alternative-ways-to-deal-with-multiple-schemata\">\n<h3>Alternative ways to deal with multiple schemata</h3>\n<p>In the example above, we created a single enveloping message with headers\ncorresponding to the fields in both our schemata, and only the primary fields\nseparated out into different attached payloads.</p>\n<p>An alternative approach would be to separate each schema out into its\nown multipart message. To do that, we would simply use the\n<tt>constructMessage()</tt> function multiple times.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; mainMessage = constructMessageFromSchema(content, ITestContent)\n&gt;&gt;&gt; personalDetailsMessage = constructMessageFromSchema(content, IPersonalDetails)\n</pre>\n<pre>&gt;&gt;&gt; from email.mime.multipart import MIMEMultipart\n&gt;&gt;&gt; envelope = MIMEMultipart()\n&gt;&gt;&gt; envelope.attach(mainMessage)\n&gt;&gt;&gt; envelope.attach(personalDetailsMessage)\n</pre>\n<pre>&gt;&gt;&gt; envelopeString = envelope.as_string()\n&gt;&gt;&gt; print(envelopeString)\nContent-Type: multipart/mixed; boundary=\"===============...==\"\nMIME-Version: 1.0\n&lt;BLANKLINE&gt;\n--===============...==\ntitle: Test title\ndescription: =?utf-8?q?T=C3=A4st_description=5Cnwith_a_newline?=\nemptyfield:\nMIME-Version: 1.0\nContent-Type: text/html; charset=\"utf-8\"\n&lt;BLANKLINE&gt;\n&lt;p&gt;Test body&lt;/p&gt;\n--===============...==\ndescription: &lt;p&gt;My description&lt;/p&gt;\ncurrentAge: 21\nMIME-Version: 1.0\nContent-Type: text/html; charset=\"utf-8\"\n&lt;BLANKLINE&gt;\n&lt;p&gt;My profile&lt;/p&gt;\n--===============...==--...\n</pre>\n</blockquote>\n<p>Which approach works best will depend largely on the intended recipient of\nthe message.</p>\n</div>\n<div id=\"encoding-the-payload-and-handling-filenames\">\n<h3>Encoding the payload and handling filenames</h3>\n<p>Finally, let\u2019s consider a more complex example, inspired by the field\nmarshaler in <tt>plone.namedfile</tt>.</p>\n<p>Let\u2019s say we have a value type intended to represent a binary file with a\nfilename and content type:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.interface import Interface, implementer\n&gt;&gt;&gt; from zope import schema\n</pre>\n<pre>&gt;&gt;&gt; class IFileValue(Interface):\n...     data = schema.Bytes(title=u\"Raw data\")\n...     contentType = schema.ASCIILine(title=u\"MIME type\")\n...     filename = schema.ASCIILine(title=u\"Filename\")\n</pre>\n<pre>&gt;&gt;&gt; @implementer(IFileValue)\n... class FileValue(object):\n...\n...     def __init__(self, data, contentType, filename):\n...         self.data = data\n...         self.contentType = contentType\n...         self.filename = filename\n</pre>\n</blockquote>\n<p>Suppose we had a custom field type to represent this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.schema.interfaces import IObject\n&gt;&gt;&gt; class IFileField(IObject):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; @implementer(IFileField)\n... class FileField(schema.Object):\n...     schema = IFileValue\n...     def __init__(self, **kw):\n...         if 'schema' in kw:\n...             self.schema = kw.pop('schema')\n...         super(FileField, self).__init__(schema=self.schema, **kw)\n</pre>\n</blockquote>\n<p>We can register a field marshaler for this field which will do the following:</p>\n<ul>\n<li><p>Insist that the field is only used as a primary field, since it makes\nlittle sense to encode a binary file in a header.</p>\n</li>\n<li><p>Save the filename in a Content-Disposition header.</p>\n</li>\n<li><p>Be capable of reading the filename again from this header.</p>\n</li>\n<li><p>Encode the payload using base64</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from plone.rfc822.interfaces import IFieldMarshaler\n&gt;&gt;&gt; from email.encoders import encode_base64\n</pre>\n<pre>&gt;&gt;&gt; from zope.component import adapter\n&gt;&gt;&gt; from plone.rfc822.defaultfields import BaseFieldMarshaler\n</pre>\n<pre>&gt;&gt;&gt; @adapter(Interface, IFileField)\n... class FileFieldMarshaler(BaseFieldMarshaler):\n...\n...     ascii = False\n...\n...     def encode(self, value, charset='utf-8', primary=False):\n...         if not primary:\n...             raise ValueError(\"File field cannot be marshaled as a non-primary field\")\n...         if value is None:\n...             return None\n...         return value.data\n...\n...     def decode(self, value, message=None, charset='utf-8', contentType=None, primary=False):\n...         filename = None\n...         # get the filename from the Content-Disposition header if possible\n...         if primary and message is not None:\n...             filename = message.get_filename(None)\n...         return FileValue(value, contentType, filename)\n...\n...     def getContentType(self):\n...         value = self._query()\n...         if value is None:\n...             return None\n...         return value.contentType\n...\n...     def getCharset(self, default='utf-8'):\n...         return None # this is not text data!\n...\n...     def postProcessMessage(self, message):\n...         value = self._query()\n...         if value is not None:\n...             filename = value.filename\n...             if filename:\n...                 # Add a new header storing the filename if we have one\n...                 message.add_header('Content-Disposition', 'attachment', filename=filename)\n</pre>\n<pre>&gt;&gt;&gt; from zope.component import provideAdapter\n&gt;&gt;&gt; provideAdapter(FileFieldMarshaler)\n</pre>\n</blockquote>\n</li>\n</ul>\n<p>To illustrate marshaling, let\u2019s create a content object that contains two file\nfields.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class IFileContent(Interface):\n...     file1 = FileField()\n...     file2 = FileField()\n</pre>\n<pre>&gt;&gt;&gt; @implementer(IFileContent)\n... class FileContent(object):\n...     file1 = None\n...     file2 = None\n</pre>\n<pre>&gt;&gt;&gt; fileContent = FileContent()\n&gt;&gt;&gt; fileContent.file1 = FileValue('dummy file', 'text/plain', 'dummy1.txt')\n&gt;&gt;&gt; fileContent.file2 = FileValue('&lt;html&gt;&lt;body&gt;test&lt;/body&gt;&lt;/html&gt;', 'text/html', 'dummy2.html')\n</pre>\n</blockquote>\n<p>At this point, neither of these fields is marked as a primary field. Let\u2019s see\nwhat happens when we attempt to construct a message from this schema.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from plone.rfc822 import constructMessageFromSchema\n&gt;&gt;&gt; message = constructMessageFromSchema(fileContent, IFileContent)\n&gt;&gt;&gt; print(message.as_string())\n&lt;BLANKLINE&gt;\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n<p>As expected, we got no message headers and no message body. Let\u2019s now mark one\nfield as primary:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from plone.rfc822.interfaces import IPrimaryField\n&gt;&gt;&gt; from zope.interface import alsoProvides\n&gt;&gt;&gt; alsoProvides(IFileContent['file1'], IPrimaryField)\n</pre>\n<pre>&gt;&gt;&gt; message = constructMessageFromSchema(fileContent, IFileContent)\n&gt;&gt;&gt; messageBody = message.as_string()\n&gt;&gt;&gt; print(messageBody)\nMIME-Version: 1.0\nContent-Type: text/plain\nContent-Transfer-Encoding: base64\nContent-Disposition: attachment; filename=\"dummy1.txt\"\n&lt;BLANKLINE&gt;\nZHVtbXkgZmlsZQ==\n</pre>\n</blockquote>\n<p>Here, we have a base64 encoded payload, a Content-Disposition header, and a\nContent-Type header according to the primary field.</p>\n<p>We can also reconstruct the object from this message.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from plone.rfc822 import initializeObjectFromSchema\n&gt;&gt;&gt; from email import message_from_string\n</pre>\n<pre>&gt;&gt;&gt; inputMessage = message_from_string(messageBody)\n&gt;&gt;&gt; newFileContent = FileContent()\n&gt;&gt;&gt; initializeObjectFromSchema(newFileContent, IFileContent, inputMessage)\n</pre>\n<pre>&gt;&gt;&gt; newFileContent.file1.data\n'dummy file'\n&gt;&gt;&gt; newFileContent.file1.contentType\n'text/plain'\n&gt;&gt;&gt; newFileContent.file1.filename\n'dummy1.txt'\n</pre>\n<pre>&gt;&gt;&gt; newFileContent.file2 is None\nTrue\n</pre>\n</blockquote>\n<p>Let\u2019s now show what would happen if we encoded both files in the message.\nIn this case, we should get a multipart document with two payloads.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; alsoProvides(IFileContent['file2'], IPrimaryField)\n&gt;&gt;&gt; message = constructMessageFromSchema(fileContent, IFileContent)\n&gt;&gt;&gt; messageBody = message.as_string()\n&gt;&gt;&gt; print(messageBody) # doctest: +ELLIPSIS\nMIME-Version: 1.0\nContent-Type: multipart/mixed; boundary=\"===============...==\"\n&lt;BLANKLINE&gt;\n--===============...==\nMIME-Version: 1.0\nContent-Type: text/plain\nContent-Transfer-Encoding: base64\nContent-Disposition: attachment; filename=\"dummy1.txt\"\n&lt;BLANKLINE&gt;\nZHVtbXkgZmlsZQ==\n--===============...==\nMIME-Version: 1.0\nContent-Type: text/html\nContent-Transfer-Encoding: base64\nContent-Disposition: attachment; filename=\"dummy2.html\"\n&lt;BLANKLINE&gt;\nPGh0bWw+PGJvZHk+dGVzdDwvYm9keT48L2h0bWw+\n--===============...==--...\n</pre>\n</blockquote>\n<p>And again, we can reconstruct the object, this time with both fields:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; inputMessage = message_from_string(messageBody)\n&gt;&gt;&gt; newFileContent = FileContent()\n&gt;&gt;&gt; initializeObjectFromSchema(newFileContent, IFileContent, inputMessage)\n</pre>\n<pre>&gt;&gt;&gt; newFileContent.file1.data\n'dummy file'\n&gt;&gt;&gt; newFileContent.file1.contentType\n'text/plain'\n&gt;&gt;&gt; newFileContent.file1.filename\n'dummy1.txt'\n</pre>\n<pre>&gt;&gt;&gt; newFileContent.file2.data\n'&lt;html&gt;&lt;body&gt;test&lt;/body&gt;&lt;/html&gt;'\n&gt;&gt;&gt; newFileContent.file2.contentType\n'text/html'\n&gt;&gt;&gt; newFileContent.file2.filename\n'dummy2.html'\n</pre>\n</blockquote>\n</div>\n<div id=\"specialities-between-py2-and-py3\">\n<h3>Specialities between Py2 and Py3</h3>\n<p>Test a special behavior which is different between Python 2 and 3 stdlib:\nNewline handling in non-utf8 strings.</p>\n<p>Python 2.7 <tt>email.header</tt> keeps a line with an escaped value,\nwhile Python 3.6 turns it into RFC2047 encoded headers, see <a href=\"https://tools.ietf.org/html/rfc2047.html\" rel=\"nofollow\">https://tools.ietf.org/html/rfc2047.html</a>\nTechnical both is fine.</p>\n<pre>&gt;&gt;&gt; import six\n&gt;&gt;&gt; content.description = \"Test content\\nwith newline difference\"\n&gt;&gt;&gt; msg = constructMessageFromSchema(content, ITestContent)\n&gt;&gt;&gt; effective_output = msg.as_string()\n&gt;&gt;&gt; effective_output.split('\\n')[1]\n'description: =?utf-8?q?Test_content=5Cnwith_newline_difference?='\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 7080072, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "f3debe27f719f50f3cfc2e9ef018f973", "sha256": "d16e06513a92b77ec49308c578a6c3541a86e7089f3423d2c0a9002558b16439"}, "downloads": -1, "filename": "plone.rfc822-1.0.zip", "has_sig": false, "md5_digest": "f3debe27f719f50f3cfc2e9ef018f973", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39696, "upload_time": "2011-05-20T19:36:28", "upload_time_iso_8601": "2011-05-20T19:36:28.131013Z", "url": "https://files.pythonhosted.org/packages/30/84/044b7c87aa56ec6ffe1a673b8482011f55fb699b8e7afaf5edf1e47f8d17/plone.rfc822-1.0.zip", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "b5b79bb5a9181da624a7e88940a45424", "sha256": "8f48873bfb707942be0fe09548f64e2b1f7b699eb5be758e49b84d44980889ab"}, "downloads": -1, "filename": "plone.rfc822-1.0.1.zip", "has_sig": false, "md5_digest": "b5b79bb5a9181da624a7e88940a45424", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40211, "upload_time": "2013-01-02T02:59:44", "upload_time_iso_8601": "2013-01-02T02:59:44.840181Z", "url": "https://files.pythonhosted.org/packages/1c/38/385bae6b63e741a58081b608fbdcb66ca59056a6c451e68eeb4b42f0ac43/plone.rfc822-1.0.1.zip", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "2f7e9c1662c1f509b862428c6f099ce2", "sha256": "522a262f44063914e543a8c7c3f908c6f10a9ed248301b671e55181993b68297"}, "downloads": -1, "filename": "plone.rfc822-1.0.2.zip", "has_sig": false, "md5_digest": "2f7e9c1662c1f509b862428c6f099ce2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40511, "upload_time": "2013-07-28T14:10:12", "upload_time_iso_8601": "2013-07-28T14:10:12.045659Z", "url": "https://files.pythonhosted.org/packages/32/27/12585af2f7051acb881eaf60f80bdce8da31cc4764414a0b557bdb049f82/plone.rfc822-1.0.2.zip", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "7cdabfdf778f17f4167a27ad93f4e324", "sha256": "2939d0ec598f74f8cf4ff130c1bbe4be94dd9afb3c7261b8c26da24464623a11"}, "downloads": -1, "filename": "plone.rfc822-1.0.3.zip", "has_sig": false, "md5_digest": "7cdabfdf778f17f4167a27ad93f4e324", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40663, "upload_time": "2013-08-14T16:52:11", "upload_time_iso_8601": "2013-08-14T16:52:11.051315Z", "url": "https://files.pythonhosted.org/packages/4f/5f/60d295805e08429b949536cbcaa727fdf27cfce23cd543f255ed6855d319/plone.rfc822-1.0.3.zip", "yanked": false}], "1.0b1": [{"comment_text": "", "digests": {"md5": "126cdc1af1e0f16fce20332f2baf3b79", "sha256": "f4ed6234c9538a59b93539d002e9d101c9530f6916de057c5210353a347d4e1e"}, "downloads": -1, "filename": "plone.rfc822-1.0b1.tar.gz", "has_sig": false, "md5_digest": "126cdc1af1e0f16fce20332f2baf3b79", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34040, "upload_time": "2009-10-09T17:31:16", "upload_time_iso_8601": "2009-10-09T17:31:16.747256Z", "url": "https://files.pythonhosted.org/packages/4d/50/4f26a20aa89234cb59e70222dc86cfbc5e80fcc8f207223f430b8a37b95a/plone.rfc822-1.0b1.tar.gz", "yanked": false}], "1.0b2": [{"comment_text": "", "digests": {"md5": "7d2b84c83f289c87152f647787aa55e9", "sha256": "f4a8d2603a819b4c0cc37f71f79a2b1f528b42059d1da2deaae69b4c79ec0230"}, "downloads": -1, "filename": "plone.rfc822-1.0b2.zip", "has_sig": false, "md5_digest": "7d2b84c83f289c87152f647787aa55e9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 43634, "upload_time": "2011-02-11T17:59:38", "upload_time_iso_8601": "2011-02-11T17:59:38.260547Z", "url": "https://files.pythonhosted.org/packages/73/ff/3f66c43b23d6f4bbc5fe257e7ee5a1d9217414fbc9be8f3604206cb4b46b/plone.rfc822-1.0b2.zip", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "ba3e26cab9e751fb1cf40639d661d2f0", "sha256": "20d485a4a01d81255d2edd4bb5aef338fc0a50f33a1241e87d6851df6b722d77"}, "downloads": -1, "filename": "plone.rfc822-1.1.zip", "has_sig": false, "md5_digest": "ba3e26cab9e751fb1cf40639d661d2f0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40562, "upload_time": "2013-08-14T16:54:47", "upload_time_iso_8601": "2013-08-14T16:54:47.181277Z", "url": "https://files.pythonhosted.org/packages/d1/a1/d64da06bd8b438239469fa55810e92c82e275660394a0a08b0e7895c287c/plone.rfc822-1.1.zip", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "09d7ad2cb82a367f69ade4ab81bf63f8", "sha256": "25555fc59489e8ddaa1a37e4bd0be7b09ed403ce8090be2b3241302f07464259"}, "downloads": -1, "filename": "plone.rfc822-1.1.1.zip", "has_sig": false, "md5_digest": "09d7ad2cb82a367f69ade4ab81bf63f8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 41114, "upload_time": "2015-03-21T18:13:32", "upload_time_iso_8601": "2015-03-21T18:13:32.263674Z", "url": "https://files.pythonhosted.org/packages/cf/61/8fac6ae4172debf0e606802bdf36ae83d794f4cbf35609021f81d38a07c5/plone.rfc822-1.1.1.zip", "yanked": false}], "1.1.2": [{"comment_text": "", "digests": {"md5": "42582fa02c1716c27c3587cc75781dfd", "sha256": "2a027c807613c32c13449cb872d6f1e33c69bf87ff14bb423be9eced9b9be328"}, "downloads": -1, "filename": "plone.rfc822-1.1.2.tar.gz", "has_sig": false, "md5_digest": "42582fa02c1716c27c3587cc75781dfd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33242, "upload_time": "2016-02-21T18:51:14", "upload_time_iso_8601": "2016-02-21T18:51:14.516458Z", "url": "https://files.pythonhosted.org/packages/56/b4/d4876b4ac8fb8a1108515eaa647803a0dc45b0ea95496a8dfa737c431568/plone.rfc822-1.1.2.tar.gz", "yanked": false}], "1.1.3": [{"comment_text": "", "digests": {"md5": "ebca6849cc62ad304990b5795363df4f", "sha256": "54211a4855a2edb633c75e25884696c2582ffa160e7adaa6fad38d65821d0ca9"}, "downloads": -1, "filename": "plone.rfc822-1.1.3.tar.gz", "has_sig": false, "md5_digest": "ebca6849cc62ad304990b5795363df4f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33601, "upload_time": "2016-08-09T16:54:37", "upload_time_iso_8601": "2016-08-09T16:54:37.095754Z", "url": "https://files.pythonhosted.org/packages/4b/4a/3c795e2e47e34dff42abc3e41261984d89cca605b48d989127e4b2d5dcd7/plone.rfc822-1.1.3.tar.gz", "yanked": false}], "1.1.4": [{"comment_text": "", "digests": {"md5": "7d832d5c527add4bf6c74418ba9adc50", "sha256": "99a02755d278ad4520ae7a3887afee12d774bdf7363cd20f88230f3ee1e68994"}, "downloads": -1, "filename": "plone.rfc822-1.1.4-py2-none-any.whl", "has_sig": false, "md5_digest": "7d832d5c527add4bf6c74418ba9adc50", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 27733, "upload_time": "2018-06-20T12:30:26", "upload_time_iso_8601": "2018-06-20T12:30:26.395606Z", "url": "https://files.pythonhosted.org/packages/38/11/fa6ee8f59d9945ac8ddbb02a6bb1e246f99ec8a8fe9d7251f995495e6cdf/plone.rfc822-1.1.4-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fb17bbe3fefbd3b4aa73e79109d2ede1", "sha256": "8717f7928ff54307969b30f864d6068608667e7ffa39dd2240d62313f1bb2463"}, "downloads": -1, "filename": "plone.rfc822-1.1.4.tar.gz", "has_sig": false, "md5_digest": "fb17bbe3fefbd3b4aa73e79109d2ede1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34320, "upload_time": "2018-06-20T12:30:27", "upload_time_iso_8601": "2018-06-20T12:30:27.776258Z", "url": "https://files.pythonhosted.org/packages/7a/b4/ff66bb96346193ac193a62a38ac95ccdc61ac2f2d8100c91dadcff0d0449/plone.rfc822-1.1.4.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "539d4661ff3836da0fd1127f77df7aa9", "sha256": "66d916ef816adb6ad9873b2e1dfcf85f538a29ea44527bc7c9deb74d316fb2dc"}, "downloads": -1, "filename": "plone.rfc822-2.0.0-py2-none-any.whl", "has_sig": false, "md5_digest": "539d4661ff3836da0fd1127f77df7aa9", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 29554, "upload_time": "2018-11-04T12:17:02", "upload_time_iso_8601": "2018-11-04T12:17:02.982055Z", "url": "https://files.pythonhosted.org/packages/48/8d/28b2f8463b4feb2f50153cf2c80c73e5520a240dea0b010334157fc4799d/plone.rfc822-2.0.0-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bc7224619c2a67c69f32684e568d65bf", "sha256": "c9cd05ec84ca5ae974069216caddd5b013c8bdbfee6c98a6faf55d2e287c96af"}, "downloads": -1, "filename": "plone.rfc822-2.0.0.tar.gz", "has_sig": false, "md5_digest": "bc7224619c2a67c69f32684e568d65bf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37079, "upload_time": "2018-11-04T12:17:04", "upload_time_iso_8601": "2018-11-04T12:17:04.613355Z", "url": "https://files.pythonhosted.org/packages/45/8c/78c3643937f9ea1229598e617f008d7801ba36a8ecd3f6944123c8fb0334/plone.rfc822-2.0.0.tar.gz", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "c8a68d4844176005ffd2b684a8adc790", "sha256": "5b714a3f785bf247af12582e6984c9dd37a903a3046af7fe728e235496e8afe5"}, "downloads": -1, "filename": "plone.rfc822-2.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "c8a68d4844176005ffd2b684a8adc790", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 29752, "upload_time": "2019-05-21T18:56:03", "upload_time_iso_8601": "2019-05-21T18:56:03.490521Z", "url": "https://files.pythonhosted.org/packages/b0/84/588dd1679a7c33d6b58e88045d6d974dd555b9c58e0ea1a767b165c0217a/plone.rfc822-2.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2b0f9f419498e6d80ff2bc09c708e8ac", "sha256": "4b2524307b878c83a1c611f30b930e2e7e3aacc40e61b7d84958856bf44f756d"}, "downloads": -1, "filename": "plone.rfc822-2.0.1.tar.gz", "has_sig": false, "md5_digest": "2b0f9f419498e6d80ff2bc09c708e8ac", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37853, "upload_time": "2019-05-21T18:56:05", "upload_time_iso_8601": "2019-05-21T18:56:05.415237Z", "url": "https://files.pythonhosted.org/packages/91/1d/835dae1eaac3fea4a77663bcb312a8a905b311e50a2612975b0c32619ab6/plone.rfc822-2.0.1.tar.gz", "yanked": false}], "2.0.2": [{"comment_text": "", "digests": {"md5": "dcd108ef8eda4af7b7174212ff65139a", "sha256": "3de4961bc0aa04515b3b210afc6d28189f5a90c89018d1d0cecafabde8fe405e"}, "downloads": -1, "filename": "plone.rfc822-2.0.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "dcd108ef8eda4af7b7174212ff65139a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 29800, "upload_time": "2020-04-22T21:18:49", "upload_time_iso_8601": "2020-04-22T21:18:49.983925Z", "url": "https://files.pythonhosted.org/packages/3b/61/dfc5df85f270c4c26d523f86c04a79fdb8634247511025a921845809eda8/plone.rfc822-2.0.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9dd23ae53b7eff8fba4455fd2c544442", "sha256": "5d24390f1e4e3727cc8807afe22f3aac33e388e3be53657b081654abff80b8b5"}, "downloads": -1, "filename": "plone.rfc822-2.0.2.tar.gz", "has_sig": false, "md5_digest": "9dd23ae53b7eff8fba4455fd2c544442", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38007, "upload_time": "2020-04-22T21:18:51", "upload_time_iso_8601": "2020-04-22T21:18:51.606808Z", "url": "https://files.pythonhosted.org/packages/e1/49/93cd558b2294d9f9f50cb04d8ab8440ac6d942e73bdc0d40f21f3c08ceee/plone.rfc822-2.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "dcd108ef8eda4af7b7174212ff65139a", "sha256": "3de4961bc0aa04515b3b210afc6d28189f5a90c89018d1d0cecafabde8fe405e"}, "downloads": -1, "filename": "plone.rfc822-2.0.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "dcd108ef8eda4af7b7174212ff65139a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 29800, "upload_time": "2020-04-22T21:18:49", "upload_time_iso_8601": "2020-04-22T21:18:49.983925Z", "url": "https://files.pythonhosted.org/packages/3b/61/dfc5df85f270c4c26d523f86c04a79fdb8634247511025a921845809eda8/plone.rfc822-2.0.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9dd23ae53b7eff8fba4455fd2c544442", "sha256": "5d24390f1e4e3727cc8807afe22f3aac33e388e3be53657b081654abff80b8b5"}, "downloads": -1, "filename": "plone.rfc822-2.0.2.tar.gz", "has_sig": false, "md5_digest": "9dd23ae53b7eff8fba4455fd2c544442", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38007, "upload_time": "2020-04-22T21:18:51", "upload_time_iso_8601": "2020-04-22T21:18:51.606808Z", "url": "https://files.pythonhosted.org/packages/e1/49/93cd558b2294d9f9f50cb04d8ab8440ac6d942e73bdc0d40f21f3c08ceee/plone.rfc822-2.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:52:48 2020"}