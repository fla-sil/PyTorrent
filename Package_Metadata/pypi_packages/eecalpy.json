{"info": {"author": "Sebastian Werner", "author_email": "wese3112@startmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# eecalpy Python module\n\n[![pypi package](https://badge.fury.io/py/eecalpy.svg)](https://badge.fury.io/py/eecalpy)\n[![Build Status](https://travis-ci.org/wese3112/eecalpy.svg?branch=master)](https://travis-ci.org/wese3112/eecalpy)\n\nThe *Electrical Engineering Calculations for Python* module is a\ncollection of classes for simple to complex electrical calculations, with a\nspecial focus on handling tolerances.\n\n## Installation\n\nThe ``eecalpy`` package is available on the Python Package Index (PyPI). The package needs Python 3+, you can install it with:\n\n    $ pip install eecalpy\n\n\n## Introduction\n\nCheck out the voltage divider below. For both resistors their tolerance and the\ntemperature coefficient \u03b1 are given (\u03b1 in parts per million). \n\n![Simple voltage divider](img/vdiv.png?raw=true \"voltage divider\")\n\nLet's create two variables for them.\n\n    >>> r1 = R(resistance=1000, tolerance=0.05, alpha_ppm=250)\n    >>> r2 = R(2e3, 0.01, 100)\n    >>> r1; r2\n    1.0k\u03a9 \u00b1 5.0% (\u00b1 50.0\u03a9) [0.9500 .. 1.0500]k\u03a9 @ 20\u00b0C \u03b1=250ppm\n    2.0k\u03a9 \u00b1 1.0% (\u00b1 20.0\u03a9) [1.9800 .. 2.0200]k\u03a9 @ 20\u00b0C \u03b1=100ppm\n\nThe formula for the voltage divider factor is `r1 / (r1 + r2)`. To calculate it use `R.voltage_divider(other_resistor)`:\n\n    >>> r1.voltage_divider(r2)\n    0.33 \u00b1 4.0% [0.3199 .. 0.3465]\n\nYou can also use a shorthand notation:\n\n    >>> r1 // r2\n    0.33 \u00b1 4.0% [0.3199 .. 0.3465]\n\nAttention: Do not use the statement `r1 / (r1 + r2)` here, because it would use the tolerance limits\nof `r1` twice (addition and division) and therefore yield a false result.\n\nThe result above is an instance of the `Factor` class. Now only the voltage is missing.\nThese are created using `U(voltage, tolerance=0.0)`.\n\n\nLet's assume the input voltage is 24V with a 1% tolerance the output voltage of the\nvoltage divider then is:\n\n    >>> vin = U(24, 0.01)\n    >>> vout = r1 // r2 * vin\n    >>> vout\n    8.0V \u00b1 5.0% (\u00b1 400.0mV) [7.6000 .. 8.4000]V\n\nNote: the statement `vout = vin * r1 // r2` does not work. It's evaluated from left to right, so python first tries `vin * r1` which is not implemented (voltage times resistance), but you can always use parenthesis:\n\n    >>> vin * (r1 // r2)\n    8.0V \u00b1 5.0% (\u00b1 400.0mV) [7.6000 .. 8.4000]V\n\nFor demonstration, let's calculate some of the voltage divider parameters.\n\nCurrent through `R1` and `R2` (to GND):\n\n    >>> vin / (r1 + r2)\n    8.01mA \u00b1 3.33% (\u00b1 266.81\u00b5A) [7.7394 .. 8.2730]mA\n\nPower dissipation of the resistors:\n\n    >>> vout**2 / r1\n    65.46mW \u00b1 21.35% (\u00b1 13.97mW) [51.4842 .. 79.4301]mW\n    >>> (vin - vout)**2 / r2\n    128.26mW \u00b1 12.3% (\u00b1 15.78mW) [112.4776 .. 144.0351]mW\n\nLet's also see how `vout` changes when the ambient temperature is 200\u00b0C:\n\n    >>> r1.at_T(200) // r2.at_T(200) * vin\n    8.14V \u00b1 4.97% (\u00b1 404.16mV) [7.7359 .. 8.5443]V\n\n`R.at_T(temperature)` is the same as `R.at_temperature(temperature)`.\nIt returns a new resistor object at the given temperature (in \u00b0C).\n\nYou can of course also use perfect values, so without the tolerance and\ntemperature coefficient:\n\n    >>> r1 = R(1e3)\n    >>> r2 = R(2e3)\n    >>> vin = U(24)\n    >>> r1; r2; vin\n    1.0k\u03a9 @ 20\u00b0C\n    2.0k\u03a9 @ 20\u00b0C\n    24.0V\n    >>> vout = r1 / (r1 + r2) * vin\n    >>> vout\n    8.0V\n\nBy the way, you can get the series resistance using `+` and the parallel\nresistance using `|`:\n\n    >>> r1 + r2\n    3.0k\u03a9 @ 20\u00b0C\n    >>> r1 | r2\n    666.67\u03a9 @ 20\u00b0C\n    >>> r1 | (R(5e3) + R(3e3)) | r2  # complex statements allowed!\n    615.38\u03a9 @ 20\u00b0C\n\n## Classes\n\nThe available classes are:\n\n* Voltage `U(voltage, tolerance=0.0)`\n* Resistance `R(resistance, tolerance=0.0, alpha_ppm=None)`\n* Current `I(current, tolerance=0.0)`\n* Power `P(power, tolerance=0.0)`\n* Factor `Factor(factor, tolerance)` (unitless factor, example below)\n* squared Voltage (V\u00b2) `Usq(voltage, tolerance=0.0)`\n* squared Current (A\u00b2) `Isq(voltage, tolerance=0.0)`\n\nAll classes do have the following members (example when using a voltage):\n\n    >>> v1 = U(24, 0.04)\n    >>> v1\n    24.0V \u00b1 4.0% (\u00b1 960.0mV) [23.0400 .. 24.9600]V\n    >>> v1.value\n    24\n    >>> v1.min\n    23.04\n    >>> v1.max\n    24.96\n    >>> v1.unit\n    'V'\n\nA unit can also be created using the `.from_min_max(min, max)` classmethod when\nthe lower and upper limit is known (min/max):\n\n    >>> P.from_min_max(3, 4)\n    3.5W \u00b1 14.29% (\u00b1 500.0mW) [3.0000 .. 4.0000]W\n\nAll units feature the add, subtract, multiply and divide operators. The calculation\nonly works if the result's type is one of the classes above:\n\nThis works because the result type is one of the known classes:\n\n    >>> U(10) + U(20)\n    30.0V\n    >>> I(2e-3) - I(10e-3)\n    -8.0mA\n    >>> U(10) * I(2e-3)\n    20.0mW\n    >>> U(10) / I(2e-3)\n    5.0k\u03a9 @ 20\u00b0C\n    >>> U(10) * Factor(2)\n    20.0V\n    >>> I(10e-3) * R(150)\n    1.5V\n    >>> P(200) / U(5)\n    40.0A\n    >>> U(3) * U(3)\n    9.0V\u00b2\n    >>> U(3)**2  # U squared\n    9.0V\u00b2\n    >>> U(3)**2 / R(1e3)\n    9.0mW\n\nThis does not work because voltage divided by power is not a known class:\n\n    >>> U / P\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    TypeError: unsupported operand type(s) for /: 'type' and 'type'\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/wese3112/eecalpy.git", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "eecalpy", "package_url": "https://pypi.org/project/eecalpy/", "platform": "", "project_url": "https://pypi.org/project/eecalpy/", "project_urls": {"Homepage": "http://github.com/wese3112/eecalpy.git"}, "release_url": "https://pypi.org/project/eecalpy/0.9.0/", "requires_dist": ["lark-parser"], "requires_python": "", "summary": "collection of classes for simple to complex electrical calculations", "version": "0.9.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p># eecalpy Python module</p>\n<p>[![pypi package](<a href=\"https://badge.fury.io/py/eecalpy.svg)%5D(https://badge.fury.io/py/eecalpy\" rel=\"nofollow\">https://badge.fury.io/py/eecalpy.svg)](https://badge.fury.io/py/eecalpy</a>)\n[![Build Status](<a href=\"https://travis-ci.org/wese3112/eecalpy.svg?branch=master)%5D(https://travis-ci.org/wese3112/eecalpy\" rel=\"nofollow\">https://travis-ci.org/wese3112/eecalpy.svg?branch=master)](https://travis-ci.org/wese3112/eecalpy</a>)</p>\n<p>The <em>Electrical Engineering Calculations for Python</em> module is a\ncollection of classes for simple to complex electrical calculations, with a\nspecial focus on handling tolerances.</p>\n<p>## Installation</p>\n<p>The <tt>eecalpy</tt> package is available on the Python Package Index (PyPI). The package needs Python 3+, you can install it with:</p>\n<blockquote>\n$ pip install eecalpy</blockquote>\n<p>## Introduction</p>\n<p>Check out the voltage divider below. For both resistors their tolerance and the\ntemperature coefficient \u03b1 are given (\u03b1 in parts per million).</p>\n<p>![Simple voltage divider](img/vdiv.png?raw=true \u201cvoltage divider\u201d)</p>\n<p>Let\u2019s create two variables for them.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; r1 = R(resistance=1000, tolerance=0.05, alpha_ppm=250)\n&gt;&gt;&gt; r2 = R(2e3, 0.01, 100)\n&gt;&gt;&gt; r1; r2\n1.0k\u03a9 \u00b1 5.0% (\u00b1 50.0\u03a9) [0.9500 .. 1.0500]k\u03a9 @ 20\u00b0C \u03b1=250ppm\n2.0k\u03a9 \u00b1 1.0% (\u00b1 20.0\u03a9) [1.9800 .. 2.0200]k\u03a9 @ 20\u00b0C \u03b1=100ppm\n</pre>\n</blockquote>\n<p>The formula for the voltage divider factor is <cite>r1 / (r1 + r2)</cite>. To calculate it use <cite>R.voltage_divider(other_resistor)</cite>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; r1.voltage_divider(r2)\n0.33 \u00b1 4.0% [0.3199 .. 0.3465]\n</pre>\n</blockquote>\n<p>You can also use a shorthand notation:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; r1 // r2\n0.33 \u00b1 4.0% [0.3199 .. 0.3465]\n</pre>\n</blockquote>\n<p>Attention: Do not use the statement <cite>r1 / (r1 + r2)</cite> here, because it would use the tolerance limits\nof <cite>r1</cite> twice (addition and division) and therefore yield a false result.</p>\n<p>The result above is an instance of the <cite>Factor</cite> class. Now only the voltage is missing.\nThese are created using <cite>U(voltage, tolerance=0.0)</cite>.</p>\n<p>Let\u2019s assume the input voltage is 24V with a 1% tolerance the output voltage of the\nvoltage divider then is:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; vin = U(24, 0.01)\n&gt;&gt;&gt; vout = r1 // r2 * vin\n&gt;&gt;&gt; vout\n8.0V \u00b1 5.0% (\u00b1 400.0mV) [7.6000 .. 8.4000]V\n</pre>\n</blockquote>\n<p>Note: the statement <cite>vout = vin * r1 // r2</cite> does not work. It\u2019s evaluated from left to right, so python first tries <cite>vin * r1</cite> which is not implemented (voltage times resistance), but you can always use parenthesis:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; vin * (r1 // r2)\n8.0V \u00b1 5.0% (\u00b1 400.0mV) [7.6000 .. 8.4000]V\n</pre>\n</blockquote>\n<p>For demonstration, let\u2019s calculate some of the voltage divider parameters.</p>\n<p>Current through <cite>R1</cite> and <cite>R2</cite> (to GND):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; vin / (r1 + r2)\n8.01mA \u00b1 3.33% (\u00b1 266.81\u00b5A) [7.7394 .. 8.2730]mA\n</pre>\n</blockquote>\n<p>Power dissipation of the resistors:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; vout**2 / r1\n65.46mW \u00b1 21.35% (\u00b1 13.97mW) [51.4842 .. 79.4301]mW\n&gt;&gt;&gt; (vin - vout)**2 / r2\n128.26mW \u00b1 12.3% (\u00b1 15.78mW) [112.4776 .. 144.0351]mW\n</pre>\n</blockquote>\n<p>Let\u2019s also see how <cite>vout</cite> changes when the ambient temperature is 200\u00b0C:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; r1.at_T(200) // r2.at_T(200) * vin\n8.14V \u00b1 4.97% (\u00b1 404.16mV) [7.7359 .. 8.5443]V\n</pre>\n</blockquote>\n<p><cite>R.at_T(temperature)</cite> is the same as <cite>R.at_temperature(temperature)</cite>.\nIt returns a new resistor object at the given temperature (in \u00b0C).</p>\n<p>You can of course also use perfect values, so without the tolerance and\ntemperature coefficient:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; r1 = R(1e3)\n&gt;&gt;&gt; r2 = R(2e3)\n&gt;&gt;&gt; vin = U(24)\n&gt;&gt;&gt; r1; r2; vin\n1.0k\u03a9 @ 20\u00b0C\n2.0k\u03a9 @ 20\u00b0C\n24.0V\n&gt;&gt;&gt; vout = r1 / (r1 + r2) * vin\n&gt;&gt;&gt; vout\n8.0V\n</pre>\n</blockquote>\n<p>By the way, you can get the series resistance using <cite>+</cite> and the parallel\nresistance using <cite>|</cite>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; r1 + r2\n3.0k\u03a9 @ 20\u00b0C\n&gt;&gt;&gt; r1 | r2\n666.67\u03a9 @ 20\u00b0C\n&gt;&gt;&gt; r1 | (R(5e3) + R(3e3)) | r2  # complex statements allowed!\n615.38\u03a9 @ 20\u00b0C\n</pre>\n</blockquote>\n<p>## Classes</p>\n<p>The available classes are:</p>\n<ul>\n<li>Voltage <cite>U(voltage, tolerance=0.0)</cite></li>\n<li>Resistance <cite>R(resistance, tolerance=0.0, alpha_ppm=None)</cite></li>\n<li>Current <cite>I(current, tolerance=0.0)</cite></li>\n<li>Power <cite>P(power, tolerance=0.0)</cite></li>\n<li>Factor <cite>Factor(factor, tolerance)</cite> (unitless factor, example below)</li>\n<li>squared Voltage (V\u00b2) <cite>Usq(voltage, tolerance=0.0)</cite></li>\n<li>squared Current (A\u00b2) <cite>Isq(voltage, tolerance=0.0)</cite></li>\n</ul>\n<p>All classes do have the following members (example when using a voltage):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; v1 = U(24, 0.04)\n&gt;&gt;&gt; v1\n24.0V \u00b1 4.0% (\u00b1 960.0mV) [23.0400 .. 24.9600]V\n&gt;&gt;&gt; v1.value\n24\n&gt;&gt;&gt; v1.min\n23.04\n&gt;&gt;&gt; v1.max\n24.96\n&gt;&gt;&gt; v1.unit\n'V'\n</pre>\n</blockquote>\n<p>A unit can also be created using the <cite>.from_min_max(min, max)</cite> classmethod when\nthe lower and upper limit is known (min/max):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; P.from_min_max(3, 4)\n3.5W \u00b1 14.29% (\u00b1 500.0mW) [3.0000 .. 4.0000]W\n</pre>\n</blockquote>\n<p>All units feature the add, subtract, multiply and divide operators. The calculation\nonly works if the result\u2019s type is one of the classes above:</p>\n<p>This works because the result type is one of the known classes:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; U(10) + U(20)\n30.0V\n&gt;&gt;&gt; I(2e-3) - I(10e-3)\n-8.0mA\n&gt;&gt;&gt; U(10) * I(2e-3)\n20.0mW\n&gt;&gt;&gt; U(10) / I(2e-3)\n5.0k\u03a9 @ 20\u00b0C\n&gt;&gt;&gt; U(10) * Factor(2)\n20.0V\n&gt;&gt;&gt; I(10e-3) * R(150)\n1.5V\n&gt;&gt;&gt; P(200) / U(5)\n40.0A\n&gt;&gt;&gt; U(3) * U(3)\n9.0V\u00b2\n&gt;&gt;&gt; U(3)**2  # U squared\n9.0V\u00b2\n&gt;&gt;&gt; U(3)**2 / R(1e3)\n9.0mW\n</pre>\n</blockquote>\n<p>This does not work because voltage divided by power is not a known class:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; U / P\nTraceback (most recent call last):\nFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: unsupported operand type(s) for /: 'type' and 'type'\n</pre>\n</blockquote>\n\n          </div>"}, "last_serial": 5690940, "releases": {"0.8.0": [{"comment_text": "", "digests": {"md5": "df9497f1e851889126a1c8a2f6dc1e6a", "sha256": "3374d43535a3c4499ad6de55d8f96bffbcd6193ececc79871ff073b349eea422"}, "downloads": -1, "filename": "eecalpy-0.8.0-py3-none-any.whl", "has_sig": false, "md5_digest": "df9497f1e851889126a1c8a2f6dc1e6a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 18019, "upload_time": "2019-05-09T19:54:16", "upload_time_iso_8601": "2019-05-09T19:54:16.537013Z", "url": "https://files.pythonhosted.org/packages/16/3c/849ef1ed68134c46348238ae7e4662966f689927fdc5b5d74af97b6e0bbc/eecalpy-0.8.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9012632b314274e21fc3591016fd3fc0", "sha256": "60bda6ac0c73afc85f0756389ed9f682a75ab89d58ab7cf03b283d3927f6e65c"}, "downloads": -1, "filename": "eecalpy-0.8.0.tar.gz", "has_sig": false, "md5_digest": "9012632b314274e21fc3591016fd3fc0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5479, "upload_time": "2019-05-09T19:54:18", "upload_time_iso_8601": "2019-05-09T19:54:18.552884Z", "url": "https://files.pythonhosted.org/packages/81/26/6048d2fec6b6626776ed15006aa76cc30c6f6a62279f5dbd18bfcc59a174/eecalpy-0.8.0.tar.gz", "yanked": false}], "0.8.1": [{"comment_text": "", "digests": {"md5": "a24ba893259b8a86ab30c2af007f8a43", "sha256": "850c8c677f90abe95ed6f4d23e1205bb3c3c919fffa2f2648556631930fb1e77"}, "downloads": -1, "filename": "eecalpy-0.8.1-py3-none-any.whl", "has_sig": false, "md5_digest": "a24ba893259b8a86ab30c2af007f8a43", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 18089, "upload_time": "2019-06-03T16:17:27", "upload_time_iso_8601": "2019-06-03T16:17:27.006806Z", "url": "https://files.pythonhosted.org/packages/6a/e5/cffaf803011c7cff7580c17a14a2a4b8e9d95fde695fa1b056ba452a61b8/eecalpy-0.8.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6f948b8bd328daea0b2df07a958c563d", "sha256": "979b907526ec917f614d67e2f64c2048a74c0ff3d0deaffe32f8a16fa09daf77"}, "downloads": -1, "filename": "eecalpy-0.8.1.tar.gz", "has_sig": false, "md5_digest": "6f948b8bd328daea0b2df07a958c563d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5576, "upload_time": "2019-06-03T16:17:28", "upload_time_iso_8601": "2019-06-03T16:17:28.667734Z", "url": "https://files.pythonhosted.org/packages/07/a3/3830bbd1dc3a6e8a36592d3800f7e7e8f556e335febc784b0f94b0350611/eecalpy-0.8.1.tar.gz", "yanked": false}], "0.8.2": [{"comment_text": "", "digests": {"md5": "4417d9bc77f138f7ed941c799ef649ef", "sha256": "bc5e457d282b82cd6bca670a37af8ba3d6bdd44cc8266d40d581e39e6e6edfb8"}, "downloads": -1, "filename": "eecalpy-0.8.2-py3-none-any.whl", "has_sig": false, "md5_digest": "4417d9bc77f138f7ed941c799ef649ef", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 18998, "upload_time": "2019-06-21T14:36:19", "upload_time_iso_8601": "2019-06-21T14:36:19.231050Z", "url": "https://files.pythonhosted.org/packages/31/b7/8c8a173a54fec5698b6afcf219050c9770f2ae809aa681c7136d92dec082/eecalpy-0.8.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dfa18bc5536e6acbde736227c7c2320f", "sha256": "83be70c3c6db45a1d224f9de6771a3b7f18a3583aba9703ede95a9c1daa69a65"}, "downloads": -1, "filename": "eecalpy-0.8.2.tar.gz", "has_sig": false, "md5_digest": "dfa18bc5536e6acbde736227c7c2320f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6680, "upload_time": "2019-06-21T14:36:20", "upload_time_iso_8601": "2019-06-21T14:36:20.741520Z", "url": "https://files.pythonhosted.org/packages/02/4e/fadfaa3e1ff7f876fe6e5da7491de23644647be026ca1faa14975ff71693/eecalpy-0.8.2.tar.gz", "yanked": false}], "0.9.0": [{"comment_text": "", "digests": {"md5": "6298dc12a4195ad40356f69cb23f450b", "sha256": "caa65d4098c63b5c2b12a426f5b6d75979ebd4c8331da182d3cdb260bf141add"}, "downloads": -1, "filename": "eecalpy-0.9.0-py3-none-any.whl", "has_sig": false, "md5_digest": "6298dc12a4195ad40356f69cb23f450b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21836, "upload_time": "2019-08-17T08:14:13", "upload_time_iso_8601": "2019-08-17T08:14:13.292296Z", "url": "https://files.pythonhosted.org/packages/9e/da/ec9fd929136766ed034ec04c64ba450eb4a00461d11a5d242ccc9a361c92/eecalpy-0.9.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7e95bbe4e167a1bf01ea70ed6bb560f8", "sha256": "22c7ede81cf31e5a2d47b6cfa6cc8e316ef3788bbfa83c3617e8b1f81ca9f4d8"}, "downloads": -1, "filename": "eecalpy-0.9.0.tar.gz", "has_sig": false, "md5_digest": "7e95bbe4e167a1bf01ea70ed6bb560f8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9616, "upload_time": "2019-08-17T08:14:14", "upload_time_iso_8601": "2019-08-17T08:14:14.934414Z", "url": "https://files.pythonhosted.org/packages/85/91/a136dcbed0250f24bbb247fcebb782c8897139c8243cf87d8a5a5818f130/eecalpy-0.9.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6298dc12a4195ad40356f69cb23f450b", "sha256": "caa65d4098c63b5c2b12a426f5b6d75979ebd4c8331da182d3cdb260bf141add"}, "downloads": -1, "filename": "eecalpy-0.9.0-py3-none-any.whl", "has_sig": false, "md5_digest": "6298dc12a4195ad40356f69cb23f450b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21836, "upload_time": "2019-08-17T08:14:13", "upload_time_iso_8601": "2019-08-17T08:14:13.292296Z", "url": "https://files.pythonhosted.org/packages/9e/da/ec9fd929136766ed034ec04c64ba450eb4a00461d11a5d242ccc9a361c92/eecalpy-0.9.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7e95bbe4e167a1bf01ea70ed6bb560f8", "sha256": "22c7ede81cf31e5a2d47b6cfa6cc8e316ef3788bbfa83c3617e8b1f81ca9f4d8"}, "downloads": -1, "filename": "eecalpy-0.9.0.tar.gz", "has_sig": false, "md5_digest": "7e95bbe4e167a1bf01ea70ed6bb560f8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9616, "upload_time": "2019-08-17T08:14:14", "upload_time_iso_8601": "2019-08-17T08:14:14.934414Z", "url": "https://files.pythonhosted.org/packages/85/91/a136dcbed0250f24bbb247fcebb782c8897139c8243cf87d8a5a5818f130/eecalpy-0.9.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:47:27 2020"}