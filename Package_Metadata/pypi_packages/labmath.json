{"info": {"author": "lucasbrown.cit", "author_email": "lucasbrown.cit@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Console", "Intended Audience :: Education", "Intended Audience :: Science/Research", "License :: Free For Educational Use", "License :: Free For Home Use", "License :: Free for non-commercial use", "License :: Freely Distributable", "License :: Freeware", "License :: OSI Approved", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.0", "Programming Language :: Python :: 3.1", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Education", "Topic :: Scientific/Engineering", "Topic :: Scientific/Engineering :: Mathematics", "Topic :: Software Development :: Libraries"], "description": "labmath version 1.1.1\n=====================\n\nThis is a module for basic math in the general vicinity of computational number theory.  It includes functions associated with primality testing, integer factoring, prime counting, linear recurrences, modular square roots, generalized Pell equations, the classic arithmetical functions, continued fractions, partitions, St\u00f8rmer's theorem, smooth numbers, and Dirichlet convolution.  Integer arithmetic is used wherever feasible.\n\nFunctions\n=========\n\nWe make a few imports:\n\n.. code:: python\n\n    from multiprocessing import Process, Queue as mpQueue\n    from itertools import chain, count, groupby, islice, tee, cycle, takewhile, compress, product, zip_longest\n    from fractions import Fraction\n    from random import randrange\n    from math import log, sqrt; inf = float('inf')\n    from heapq import merge\n\n    try: from gmpy2 import mpz; mpzv, inttypes = 2, (int, type(mpz(1)))\n    except ImportError: mpz, mpzv, inttypes = int, 0, (int,)\n\n    labmathversion = \"1.1.0\"\n\nThe *new* functions provided by this module are as follows.  Further details, including examples and input details, are available in docstrings and accessible via the built-in ``help`` function.\n\n.. code:: python\n\n    primegen(limit=inf)\n\nGenerates primes less than the given limit (which may be infinite) lazily via a segmented sieve of Eratosthenes.  Uses O(\u221a\\ *p*) memory, where *p* is the most recently yielded prime.\n\n.. code:: python\n\n    rpn(instr)\n\nEvaluates a string in reverse Polish notation.  The acceptable binary operators are ``+ - * / // % **`` and correspond directly to those same operators in Python3 source code.  The acceptable unary operators are ``! #``.  They are the factorial and primorial, respectively.  There are three aliases: ``x`` for ``*`` , ``xx`` for ``**`` , and ``p!`` for ``#``.\n\n.. code:: python\n\n    iterprod(l)\n\nProduct of the elements of any iterable.  The product of an empty iterable is 1.\n\n.. code:: python\n\n    listprod(l)\n\nProduct of the elements of a list.  The product of the empty list is 1.  We use a binary algorithm because this can easily generate huge numbers, and calling ``reduce(lambda x,y: x*y, a)`` in such situations is quite a bit slower due to the time-complexity of multiplication.  However, the size of the problem required to make this superior to ``iterprod()`` is quite large, so ``iterprod()`` should usually be used instead.\n\n.. code:: python\n\n    polyval(f, x, m=None)\n\nEvaluates a polynomial at a particular point, optionally modulo something.\n\n.. code:: python\n\n    binomial(n,k)\n\nThe binomial coefficient nCr(``n``, ``k``).\n\n.. code:: python\n\n    powerset(l)\n\nGenerates the powerset of a list, tuple, or string.  The yielded objects are always lists.\n\n.. code:: python\n\n    primephi(x, a, ps, phicache={})\n\nLegendre's phi function.  Helper function for ``primepi``.\n\n.. code:: python\n\n    primepi(x, ps=[], picache={}, phicache={}, sqrts={})\n\nComputes the number of primes \u2264 ``x`` via the Meissel-Lehmer method.  The arguments ``ps``, ``pichache``, ``phicache``, and ``sqrts`` are for internal use only.\n\n.. code:: python\n\n    primesum(n)\n\nSum of primes \u2264 ``n``.\n\n.. code:: python\n\n    altseriesaccel(a, n)\n\nConvergence acceleration for alternating series.  This is algorithm 1 from *Convergence Acceleration of Alternating Series* by Cohen, Villegas, and Zagier `(pdf)`__, with a minor tweak so that the *d*-value isn't computed via floating point.\n\n__ https://people.mpim-bonn.mpg.de/zagier/files/exp-math-9/fulltext.pdf\n\n.. code:: python\n\n    riemannzeta(n, k=24)\n\nComputes the Riemann zeta function by applying ``altseriesaccel`` to the `Dirichlet eta function`__.  Should be rather accurate throughout the complex plane except near ``n`` such that 1 = 2\\ :sup:`n-1`.\n\n__ https://en.wikipedia.org/wiki/Dirichlet_eta_function\n\n.. code:: python\n\n    zetam1(n, k=24)\n\nComputes ``riemannzeta(n, k) - 1`` by applying ``altseriesaccel`` to the Dirichlet eta function.  Designed to be accurate even when ``riemannzeta(n)`` is machine-indistinguishable from 1.0 --- in particular, when ``n`` is a large real number.\n\n.. code:: python\n\n    riemannR(x, n=None, zc={})\n\nUses the `Gram series`__ to compute `Riemann's R function`__, which is a rather good approximation to ``primepi``.  The argument ``zc`` is a cache of zeta values.\n\n__ http://mathworld.wolfram.com/GramSeries.html\n__ http://mathworld.wolfram.com/RiemannPrimeCountingFunction.html\n\n.. code:: python\n\n    nthprimeapprox(n)\n\nProduces an integer that should be rather close to the ``n``\\ :sup:`th` prime by using binary splitting on Riemann's R function.\n\n.. code:: python\n\n    nthprime(n)\n\nReturns the ``n``\\ :sup:`th` prime (counting 2 as #1).  This is done with some efficiency by using ``nthprimeapprox`` as an initial estimate, computing ``primepi`` of that, and then sieving to remove the error.\n\n.. code:: python\n\n    gcd(a, *r)\n\nGreatest common divisor of any number of values.\n\n.. code:: python\n\n    xgcd(a, b)\n\nExtended Euclidean altorithm: returns a tuple (``g``, *x*, *y*) such that ``g`` = gcd(``a``, ``b``) and ``g`` = ``a``\u00b7*x* + ``b``\u00b7*y*.\n\n.. code:: python\n\n    modinv(a, m)\n\nReturns the inverse of ``a`` modulo ``m``, normalized to lie between ``0`` and ``m-1``.  If ``a`` is not coprime to ``m``, returns 1.\n\n.. code:: python\n\n    crt(rems, mods)\n\nReturns the unique integer *c* in ``range(iterprod(mods))`` such that *c* \u2261 *x* (mod *y*) for (*x*, *y*) in ``zip(rems, mods)``.  All elements of ``mods`` must be pairwise coprime.\n\n.. code:: python\n\n    lcm(a, *r)\n\nThe least common multiple of any number of values.\n\n.. code:: python\n\n    isqrt(n)\n\nGreatest integer whose square is \u2264 ``n``.\n\n.. code:: python\n\n    introot(n, r=2)\n\nFor non-negative ``n``, returns the greatest integer \u2264 the rth root of ``n``.  For negative ``n``, returns the least integer \u2265 the ``r``\\ :sup:`th` root of ``n``, or ``None`` if ``r`` is even.\n\n.. code:: python\n\n    ispower(n, r=0)\n\nIf ``r`` = 0: If ``n`` is a perfect power, return a tuple containing the largest integer that, when squares/cubed/etc, yields ``n`` as the first component and the relevant power as the second component.  If ``n`` is not a perfect power, return ``None``.\n\nIf ``r`` > 0: We check whether ``n`` is a perfect ``r``\\ :sup:`th` power; we return its ``r``\\ :sup:`th` root if it is and ``None`` if it isn't.\n\n.. code:: python\n\n    ilog(x, b)\n\nGreatest integer *k* such that ``b``\\ :sup:`k` \u2264 ``x``.\n\n.. code:: python\n\n    fibogen()\n\nGenerates the Fibonacci numbers, starting with 0 and 1.\n\n.. code:: python\n\n    fibo(n, f={0:0, 1:1, 2:1})\n\nEfficiently extracts the ``n``\\ :sup:`th` Fibonacci number, indexed so that ``fibo(0)`` = 0 and ``fibo(1)`` = ``fibo(2)`` = 1.  The argument ``f`` is used for memoization.  We compute O(log(``n``)) earlier Fibonaccis along the way.  This is, in the big-O sense, just about as fast as possible.\n\n.. code:: python\n\n    fibomod(n, m, f={0:0, 1:1, 2:1})\n\nEfficiently extracts the nth Fibonacci number modulo ``m``, indexed so that ``fibo(0)`` = 0 and ``fibo(1)`` == ``fibo(2)`` = 1.  The argument ``f`` is used for memoization.  We compute O(log(``n``)) earlier Fibonaccis along the way.  This is the asymptotically fastest algorithm.\n\n.. code:: python\n\n    lucaschain(n, x0, x1, op1, op2)\n\nAlgorithm 3.6.7 from *Prime Numbers: A Computational Perspective* by Crandall & Pomerance (2\\ :sup:`nd` edition): Evaluation of a binary Lucas chain.  To quote their description:\n\n    For a sequence *x*\\ :sub:`0`, *x*\\ :sub:`1`, ... with a rule for computing *x*\\ :sub:`2j` from *x*\\ :sub:`j` and a rule for computing *x*\\ :sub:`2j+1` from *x*\\ :sub:`j` and *x*\\ :sub:`j+1`, this algorithm computes (*x*\\ :sub:`n`, *x*\\ :sub:`n+1`) for a given positive integer *n*.  We have *n* in binary as (*n*\\ :sub:`0`, *n*\\ :sub:`1`, ..., *n*\\ :sub:`b-1`) with *n*\\ :sub:`0` being the low-order bit.  We write the rules as follows: *x*\\ :sub:`2j` = op1(*x*\\ :sub:`j`) and *x*\\ :sub:`2j+1` = op2(*x*\\ :sub:`j`, *x*\\ :sub:`j+1`).\n\n.. code:: python\n\n    lucasgen(P, Q):\n\nGenerates the Lucas U- and V-sequences with parameters (``P``, ``Q``).\n\n.. code:: python\n\n    lucas(k, P, Q)\n\nEfficiently computes the ``k``\\ :sup:`th` terms in the Lucas U- and V-sequences U(``P``, ``Q``) and V(``P``, ``Q``).  More explicitly, if\n\n    U\\ :sub:`0`, U\\ :sub:`1`, V\\ :sub:`0`, V\\ :sub:`1` = 0, 1, 2, ``P``\n\nand we have the recursions\n\n    U\\ :sub:`n` = ``P`` \u00b7 U\\ :sub:`n-1` - ``Q`` \u00b7 U\\ :sub:`n-2`\n\n    V\\ :sub:`n` = ``P`` \u00b7 V\\ :sub:`n-1` - ``Q`` \u00b7 V\\ :sub:`n-2`\n\nthen we compute U\\ :sub:`k` and V\\ :sub:`k` in O(ln(``k``)) arithmetic operations.  If ``P``\\ :sup:`2` \u2260 4\u00b7``Q``, then these sequences grow exponentially, so the number of bit operations is anywhere from O(``k`` \u00b7 ln(``k``)\\ :sup:`2` \u00b7 ln(ln(``k``))) to O(``k``\\ :sup:`2`) depending on how multiplication is handled.  We recommend using MPZs when ``k`` > 100 or so.  We divide by ``P``\\ :sup:`2` - 4\u00b7``Q`` at the end, so we handle separately the case where this is zero.\n\n.. code:: python\n\n    binlinrecgen(P, Q, a, b)\n\nThe general binary linear recursion.  Exactly like ``lucasgen``, except we only compute one sequence, and we supply the seeds.\n\n.. code:: python\n\n    binlinrec(k, P, Q, a, b)\n\nThe general binary linear recursion.  Exactly like ``lucas``, except we compute only one sequence, and we supply the seeds.\n\n.. code:: python\n\n    linrecgen(a, b, m=None)\n\nThe general homogenous linear recursion: we generate in order the sequence defined by\n\n    *x*\\ :sub:`n+1` = ``a``\\ :sub:`k` \u00b7 *x*\\ :sub:`n` + ``a``\\ :sub:`k-1` \u00b7 *x*\\ :sub:`n-1` + ... + ``a``\\ :sub:`0` \u00b7 *x*\\ :sub:`n-k`,\n\nwhere the initial values are [*x*\\ :sub:`0`, ..., *x*\\ :sub:`k`] = ``b``.  If ``m`` is supplied, then we compute the sequence modulo ``m``.  The terms of this sequence usually grow exponentially, so computing a distant term incrementally by plucking it out of this generator takes O(``n``\\ :sup:`2`) bit operations.  Extractions of distant terms should therefore be done via ``linrec``, which takes anywhere from O(``n`` \u00b7 ln(``n``)\\ :sup:`2` \u00b7 ln(ln(``n``))) to O(``n``\\ :sup:`2`) bit operations depending on how multiplication is handled.\n\n.. code:: python\n\n    linrec(n, a, b, m=None)\n\nThe general homogeneous linear recursion.  If ``m`` is supplied, terms are computed modulo ``m``.  We use matrix methods to efficiently compute the ``n``\\ :sup:`th` term of the recursion\n\n    *x*\\ :sub:`n+1` = ``a``\\ :sub:`k` \u00b7 *x*\\ :sub:`n` + ``a``\\ :sub:`k-1` \u00b7 *x*\\ :sub:`n-1` + ... + ``a``\\ :sub:`0` \u00b7 *x*\\ :sub:`n-k`,\n\nwhere the initial values are [*x*\\ :sub:`0`, ..., *x*\\ :sub:`k`] = ``b``.\n\n.. code:: python\n\n    legendre(a, p)\n\nLegendre symbol (``a`` | ``p``): 1 if ``a`` is a quadratic residue mod ``p``, -1 if it isn't, and 0 if ``a`` \u2261 0 (mod ``p``).  Not meaningful if ``p`` isn't prime.\n\n.. code:: python\n\n    jacobi(a, n)\n\nThe Jacobi symbol (``a`` | ``n``).\n\n.. code:: python\n\n    kronecker(a, n)\n\nThe Kronecker symbol (``a`` | ``n``).  Note that this is the generalization of the Jacobi symbol, *not* the Dirac-delta analogue.\n\n.. code:: python\n\n    fermat_prp(n, b)\n\nFermat's primality test.\n\n.. code:: python\n\n    sprp(n, b)\n\nThe strong probable primality test (aka single-round Miller-Rabin).\n\n.. code:: python\n\n    mrab(n, basis)\n\nMiller-Rabin probable primality test.\n\n.. code:: python\n\n    miller(n)\n\nMiller's primality test.  If the extended Riemann hypothesis (the one about Dirichlet L-functions) is true, then this test is deterministic.\n\n.. code:: python\n\n    lprp(n, a, b)\n\nLucas probable primality test as described in *Prime Numbers: A Computational Perspective* by Crandall & Pomerance (2\\ :sup:`nd` edition).\n\n.. code:: python\n\n    lucasmod(k, P, Q, m)\n\nEfficiently computed the ``k``\\ :sup:`th` terms of Lucas U- and V-sequences modulo ``m`` with parameters (``P``, ``Q``).  Currently just a helper function for ``slprp`` and ``xslprp``.  Will be upgraded to full status when the case ``gcd(D,m)!=1`` is handled properly.\n\n.. code:: python\n\n    slprp(n, a, b)\n\nStrong lucas probable primality test as described on Wikipedia.  Its false positives are a strict subset of those for ``lprp`` with the same parameters.\n\n.. code:: python\n\n    xslprp(n, a)\n\nExtra strong Lucas probable primality test as described on Wikipedia.  Its false positives are a strict subset of those for ``slprp`` (and therefore ``lprp``) with parameters (``a``, 1).\n\n.. code:: python\n\n    bpsw(n)\n\nThe Baille-Pomerance-Selfridge-Wagstaff probable primality test.  Infinitely many false positives are conjectured to exist, but none are known, and the test is known to be deterministic below 2\\ :sup:`64`.\n\n.. code:: python\n\n    qfprp(n, a, b)\n\nQuadratic Frobenius probable primality test as described in *Prime Numbers: A Computational Perspective* by Crandall & Pomerance (2\\ :sup:`nd` edition).\n\n.. code:: python\n\n    polyaddmodp(a, b, p)\n\nAdds two polynomials and reduces their coefficients mod ``p``.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is ``None``, we return ``None``.\n\n.. code:: python\n\n    polysubmodp(a, b, p)\n\nSubtracts the polynomial ``b`` from ``a`` and reduces their coefficients mod ``p``.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is ``None``, we return ``None``.\n\n.. code:: python\n\n    polymulmodp(a, b, p)\n\nMultiplies the polynomials ``a`` and ``b`` and reduces their coefficients mod ``p``.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is ``None``, we return ``None``.\n\n.. code:: python\n\n    polydivmodmodp(a, b, p)\n\nDivides the polynomial ``a`` by the polynomial ``b`` and returns the quotient and remainder.  The coefficients are interpreted mod ``p``.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is ``None``, we return ``None``.  The result is not guaranteed to exist; in such cases we return ``(None, None)``.\n\n.. code:: python\n\n    gcmd(f, g, p)\n\nComputes the greatest common monic divisor of the polynomials ``f`` and ``g``.  The coefficients are interpreted mod ``p``.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is ``None``, or if both input polynomials are ``[]``, we return ``None``.  The result is not guaranteed to exist; in such cases, we return ``None``.  Coded after algorithm 2.2.1 from *Prime Numbers: A Computational Perspective* by Crandall & Pomerance (2\\ :sup:`nd` edition).\n\n.. code:: python\n\n    polypowmodpmodpoly(a, e, p, f)\n\nComputes the remainder when the polynomial ``a`` is raised to the ``e``\\ :sup:`th` power and reduced modulo ``f``.  The coefficients are interpreted mod ``p``.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is ``None``, or if ``f == []``, we return ``None``.  The answer is not guaranteed to exist.  In such cases, we return ``None``.\n\n.. code:: python\n\n    frobenius_prp(n, poly, strong=False)\n\nGrantham's general Frobenius probable primality test, in both the strong and weak versions, as described in `his paper introducing the test`__.\n\n__ https://doi.org/10.1090/S0025-5718-00-01197-2\n\n.. code:: python\n\n    isprime(n, tb=(3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59))\n\nThe workhorse primality test.  It is a BPSW primality test variant: we use the strong Lucas PRP test and preface the computation with trial division for speed.  No composites are known to pass the test, though it is suspected that infinitely many will do so.  There are definitely no such errors below 2\\ :sup:`64`.  This function is mainly a streamlined version of ``bpsw``.\n\n.. code:: python\n\n    isprime_mersenne(p)\n\nThe Lucas-Lehmer test.  Deterministically and efficiently checks whether the Mersenne number 2\\ :sup:`p`-1 is prime.\n\n.. code:: python\n\n    nextprime(n)\n\nSmallest prime strictly greater than ``n``.\n\n.. code:: python\n\n    prevprime(n)\n\nLargest prime strictly less than ``n``, or ``None`` if no such prime exists.\n\n.. code:: python\n\n    randprime(digits, base=10, primetest=isprime)\n\nReturns a random prime with the specified number of digits when rendered in the specified base.\n\n.. code:: python\n\n    randomfactored(n, primetest=isprime)\n\nEfficiently generates an integer selected uniformly from the range [1, ``n``] with its factorization.  Uses Adam Kalai's algorithm, which uses in the average case O(log(``n``)\\ :sup:`2`) primality tests.  When called with the default primality test, this then uses O(log(``n``)\\ :sup:`3`) arithmetic operations, which in turn results in just over O(log(``n``)\\ :sup:`4`) to O(log(``n``)\\ :sup:`5`) bit operations, depending on how multiplication is handled.\n\n.. code:: python\n\n    sqrtmod_prime(a, p)\n\nFinds *x* such that *x*\\ :sup:`2` \u2261 ``a`` (mod ``p``).  We assume that ``p`` is a prime and ``a`` is a quadratic residue modulo ``p``.  If any of these conditions is false, then the return value is meaningless.\n\n.. code:: python\n\n    cbrtmod_prime(a, p)\n\nReturns in a sorted list all cube roots of a mod p.  There are a bunch of easily-computed special formulae for various cases with p != 1 (mod 9); we do those first, and then if p == 1 (mod 9) we use Algorithm 4.2 in `Taking Cube Roots in Zm`__ by Padro and Saez, which is essentially a variation on the Tonelli-Shanks algorithm for modular square roots.\n\n__ https://doi.org/10.1016/S0893-9659(02)00031-9\n\n.. code:: python\n\n    pollardrho_brent(n)\n\nFactors integers using Brent's variation of Pollard's rho algorithm.  If ``n`` is prime, we immediately return ``n``; if not, we keep chugging until a nontrivial factor is found.\n\n.. code:: python\n\n    pollard_pm1(n, B1=100, B2=1000)\n\nInteger factoring function.  Uses Pollard's p-1 algorithm.  Note that this is only efficient if the number to be factored has a prime factor *p* such that *p*-1's largest prime factor is \"small\".\n\n.. code:: python\n\n    mlucas(v, a, n)\n\nHelper function for ``williams_pp1``.  Multiplies along a Lucas sequence modulo ``n``.\n\n.. code:: python\n\n    williams_pp1(n)\n\nInteger factoring function.  Uses Williams' p+1 algorithm, single-stage variant.  Note that this is only efficient when the number to be factored has a prime factor *p* such that *p*\\ +1's largest prime factor is \"small\".\n\n.. code:: python\n\n    ecadd(p1, p2, p0, n)\n\nHelper function for ``ecm``.  Adds two points on a Montgomery curve modulo ``n``.\n\n.. code:: python\n\n    ecdub(p, A, n)\n\nHelper function for ``ecm``.  Doubles a point on a Montgomery curve modulo ``n``.\n\n.. code:: python\n\n    ecmul(m, p, A, n)\n\nHelper function for ``ecm``.  Multiplies a point on Montgomery curve by an integer modulo ``n``.\n\n.. code:: python\n\n    secm(n, B1, B2, seed)\n\nSeeded elliptic curve factoring using the two-phase algorithm on Montgomery curves.  Helper function for ``ecm``.  Returns a possibly-trivial divisor of ``n`` given two bounds and a seed.\n\n.. code:: python\n\n    ecmparams(n)\n\nGenerator of parameters to use for ``secm``.\n\n.. code:: python\n\n    ecm(n, paramseq=ecmparams, nprocs=1)\n\nInteger factoring via elliptic curves using the two-phase algorithm on Montgomery curves, and optionally uses multiple processes.  This is a shell function that repeatedly calls ``secm`` using parameters provided by ``ecmparams``; the actual factoring work is done there.  Multiprocessing incurs relatively significant overhead, so when ``nprocs==1`` (default), we don't call the multiprocessing functions.\n\n.. code:: python\n\n    modinv_mpqs(a, m)\n\nHelper function for ``mpqs``.  Returns a modular inverse normalized to minimize absolute value.\n\n.. code:: python\n\n    mpqs(n)\n\nFactors an integer via the multiple-polynomial quadratic sieve.  Most of this function is copied verbatim from https://codegolf.stackexchange.com/a/9088.\n\n.. code:: python\n\n    multifactor(n, methods)\n\nInteger factoring function.  Uses several methods in parallel.  Waits for one of them to return, kills the rest, and reports.\n\n.. code:: python\n\n    primefac(n, trial=1000, rho=42000, primetest=isprime, methods=(pollardrho_brent,))\n\nThe workhorse integer factorizer.  Generates the prime factors of the input.  Factors that appear *x* times are yielded *x* times.\n\n.. code:: python\n\n    factorint(n, trial=1000, rho=42000, primetest=isprime, methods=(pollardrho_brent,))\n\nCompiles the output of ``primefac`` into a dictionary with primes as keys and multiplicities as values.\n\n.. code:: python\n\n    factorsieve(stop)\n\nUses a sieve to compute the factorizations of all whole numbers strictly less than the input.  This uses a lot of memory; if you aren't after the factors directly, it's usually better to write a dedicated function for whatever it is that you actually want.\n\n.. code:: python\n\n    divisors(n)\n\nGenerates all natural numbers that evenly divide ``n``.  The output is not necessarily sorted.\n\n.. code:: python\n\n    divisors_factored(n)\n\nGenerates the divisors of ``n``, written as their prime factorizations in factorint format.\n\n.. code:: python\n\n    divcount(n)\n\nCounts the number of divisors of ``n``.\n\n.. code:: python\n\n    divsigma(n, x=1)\n\nSum of divisors of a natural number, raised to the *x*\\ :sup:`th` power.  The conventional notation for this in mathematical literature is \u03c3\\ :sub:`x`\\ (``n``), hence the name of this function.\n\n.. code:: python\n\n    divcountsieve(stop)\n\nUses a sieve to compute the number of divisors of all whole numbers strictly less than the input.\n\n.. code:: python\n\n    totient(n, k=1)\n\nJordan's totient function: the number of ``k``-tuples of positive integers all \u2264 ``n`` that form a coprime (``k``\\ +1)-tuple together with ``n``.  When ``k`` = 1, this is Euler's totient: the number of numbers less than a number that are relatively prime to that number.\n\n.. code:: python\n\n    totientsieve(n)\n\nUses a sieve to compute the totients up to (and including) ``n``.\n\n.. code:: python\n\n    totientsum(n)\n\nComputes ``sum(totient(n) for n in range(1, n+1))`` efficiently.\n\n.. code:: python\n\n    mobius(n)\n\nThe M\u00f6bius function of ``n``: 1 if ``n`` is squarefree with an even number of prime factors, -1 if ``n`` is squarefree with an odd number of prime factors, and 0 if ``n`` has a repeated prime factor.\n\n.. code:: python\n\n    mobiussieve(stop)\n\nUses a sieve to compute the M\u00f6bius function of all whole numbers strictly less than the input.\n\n.. code:: python\n\n    liouville(n)\n\nThe Liouville lambda function of ``n``: the strongly multiplicative function that is -1 on the primes.\n\n.. code:: python\n\n    polyroots_prime(g, p, sqfr=False)\n\nGenerates with some efficiency and without multiplicity the zeros of a polynomial modulo a prime.  Coded after algorithm 2.3.10 from *Prime Numbers: A Computational Perspective* by Crandall & Pomerance (2\\ :sup:`nd` edition), which is essentially Cantor-Zassenhaus.\n\n.. code:: python\n\n    hensel(f, p, k, given=None)\n\nUses Hensel lifting to generate with some efficiency all zeros of a polynomial modulo a prime power.\n\n.. code:: python\n\n    sqrtmod(a, n)\n\nComputes all square roots of ``a`` modulo ``n`` and returns them in a sorted list.\n\n.. code:: python\n\n    polyrootsmod(pol, n)\n\nComputes the zeros of a polynomial modulo an integer.  We do this by factoring the modulus, solving modulo the prime power factors, and putting the results back together via the Chinese Remainder Theorem.\n\n.. code:: python\n\n    PQa(P, Q, D)\n\nGenerates some sequences related to simple continued fractions of certain quadratic surds.  A helper function for ``pell``.  Let ``P``, ``Q``, and ``D`` be integers such that ``Q`` \u2260 0, ``D`` > 0 is a nonsquare, and ``P``\\ :sup:`2` \u2261 ``D`` (mod ``Q``). We yield a sequence of tuples (*B*\\ :sub:`i`, *G*\\ :sub:`i`, *P*\\ :sub:`i`, *Q*\\ :sub:`i`) where *i* is an index counting up from 0, *x* = (``P``\\ +\u221a\\ ``D``)/``Q`` = [*a*\\ :sub:`0`; *a*\\ :sub:`1`, *a*\\ :sub:`2`, ...], (*P*\\ :sub:`i`\\ +\u221a\\ ``D``))/*Q*\\ :sub:`i` is the *i*\\ :sup:`th` complete quotient of *x*, and *B*\\ :sub:`i` is the denominator of the *i*\\ :sup:`th` convergent to *x*.  For full details, see https://www.jpr2718.org/pell.pdf.\n\n.. code:: python\n\n    pell(D, N)\n\nThis function solves the generalized Pell equation: we find all non-negative integers (*x*, *y*) such that *x*\\ :sup:`2` - ``D`` \u00b7 *y*\\ :sup:`2` = ``N``.  We have several cases:\n\nCase 1: ``N`` = 0.  We solve *x*\\ :sup:`2` = ``D`` \u00b7 *y*\\ :sup:`2`.  (0,0) is always a solution.\n\n    Case 1a: If ``D`` is a nonsquare, then there are no further solutions.\n\n    Case 1b: If ``D`` is a square, then there are infinitely many solutions, parametrized by (*t*\u00b7\u221a\\ ``D``, *t*).\n\nCase 2: ``N`` \u2260 0 = ``D``.  We solve *x*\\ :sup:`2` = ``N``.\n\n    Case 2a: If ``N`` is a nonsquare, then there are no solutions.\n\n    Case 2b: If ``N`` is a square, then there are infinitely many solutions, parametrized by (\u221a\\ ``N``, *t*).\n\nCase 3: ``N`` \u2260 0 > ``D``.  We solve *x*\\ :sup:`2` + \\|\\ ``D``\\| \u00b7 *y*\\ :sup:`2` = ``N``.  The number of solutions will be finite.\n\nCase 4: ``N`` \u2260 0 < ``D``.  We find lattice points on a hyperbola.\n\n    Case 4a: If ``D`` is a square, then the number of solutions will be at most finite.  This case is solved by factoring.\n\n    Case 4b: If ``D`` is a nonsquare, then we run the PQa/LMM algorithms: we produce a set of primitive solutions; if this set is empty, there are no solutions; if this set has members, an ininite set of solutions can be produced by repeatedly composing them with the fundamental solution of *x*\\ :sup:`2` - ``D`` \u00b7 *y*\\ :sup:`2` = 1.\n\nReferences:\n\n* http://www.jpr2718.org/pell.pdf\n* http://www.offtonic.com/blog/?p=12\n* http://www.offtonic.com/blog/?p=18\n\nInput: ``D``, ``N`` -- integers\n\nOutput:\n\n    A 3-tuple.\n\n    If the number of solutions is finite, it is ``(None, z, None)``, where ``z`` is the sorted list of all solutions.\n\n    If the number of solutions is infinite and the equation is degenerate, it's ``(gen, None, None)``, where ``gen`` yields all solutions.\n\n    If the number of solutions if infinite and the equation is nondegenerate, it is ``(gen, z, f)``, where ``z`` is the set of primitive solutions, represented as a sorted list, and ``f`` is the fundamental solution --- i.e., ``f`` is the primitive solution of *x*\\ :sup:`2` - ``D`` \u00b7 *y*\\ :sup:`2` = 1.\n\n    Note that we can check the infinitude of solutions by calling ``bool(pell(D,N)[0])``.\n\n.. code:: python\n\n    simplepell(D, bail=inf)\n\nGenerates the positive solutions of *x*\\ :sup:`2` - ``D`` \u00b7 *y*\\ :sup:`2` = 1.  We use some optimizations specific to this case of the Pell equation that makes this more efficient than calling ``pell(D,1)[0]``.  Note that this function is not equivalent to calling ``pell(D,1)[0]``: ``pell`` is concerned with the general equation, which may or may not have trivial solutions, and as such yields all non-negative solutions, whereas this function is concerned only with the simple Pell equation, which always has an infinite family of positive solutions generated from a single primitive solution and always has the trivial solution (1,0).\n\nWe yield only those solutions with *x* \u2264 ``bail``.\n\n.. code:: python\n\n    carmichael(n)\n\nThe Carmichael lambda function: the smallest positive integer *m* such that *a*\\ :sup:`m` \u2261 1 (mod ``n``) for all *a* such that gcd(*a*, ``n``) = 1.  Also called the reduced totient or least universal exponent.\n\n.. code:: python\n\n    multord(b, n)\n\nComputes the multiplicative order of ``b`` modulo ``n``; i.e., finds the smallest *k* such that ``b``\\ :sup:`k` \u2261 1 (mod ``n``).\n\n.. code:: python\n\n    pythags_by_perimeter(p)\n\nGenerates all Pythagorean triples of a given perimeter by examining the perimeter's factors.\n\n.. code:: python\n\n    collatz(n)\n\nGenerates the Collatz sequence initiated by ``n``.  Stops after yielding 1.\n\n.. code:: python\n\n    sqrtcfrac(n)\n\nComputes the simple continued fraction for \u221a\\ ``n``.  We return the answer as ``(isqrt(n), [a,b,c,...,d])``, where ``[a,b,c,...,d]`` is the minimal reptend.\n\n.. code:: python\n\n    convergents(a)\n\nGenerates the convergents of a simple continued fraction.\n\n.. code:: python\n\n    contfrac_rat(n, d)\n\nReturns the simple continued fraction of the rational number ``n``/``d``.\n\n.. code:: python\n\n    ngonal(x, n)\n\nReturns the ``x``\\ :sup:`th` ``n``-gonal number.  Indexing begins with 1 so that ``ngonal(1, n)`` = 1 for all applicable ``n``.\n\n.. code:: python\n\n    is_ngonal(p, n)\n\nChecks whether ``p`` is an ``n``-gonal number.\n\n.. code:: python\n\n    partitions(n, parts=[1])\n\nComputes with some semblance of efficiency the number of additive partitions of an integer.  The ``parts`` argument is for memoization.\n\n.. code:: python\n\n    partgen(n)\n\nGenerates partitions of integers in ascending order via an iterative algorithm.  It is the fastest known algorithm as of June 2014.\n\n.. code:: python\n\n    partconj(p)\n\nComputes the conjugate of a partition.\n\n.. code:: python\n\n    farey(n)\n\nGenerates the Farey sequence of maximum denominator ``n``.  Includes 0/1 and 1/1.\n\n.. code:: python\n\n    fareyneighbors(n, p, q)\n\nReturns the neighbors of ``p``/``q``  in the Farey sequence of maximum denominator ``n``.\n\n.. code:: python\n\n    ispractical(n)\n\nTests whether ``n`` is a practical number -- i.e., whether every integer from 1 through ``n`` (inclusive) can be written as a sum of divisors of ``n``.  These are also called panarithmic numbers.\n\n.. code:: python\n\n    hamming(ps, *ps2)\n\nGenerates all ``ps``-smooth numbers, where ``ps`` is a list of primes.\n\n.. code:: python\n\n    arithmeticderivative(n)\n\nThe arithmetic derivative of ``n``: if ``n`` is prime, then ``n``' = 1; if -2 < ``n`` < 2, then ``n``' = 0; if ``n`` < 0, then ``n``' = -(-``n``)'; and (*ab*)' = *a*'\u00b7*b* + *b*'\u00b7*a*.\n\n.. code:: python\n\n    perfectpowers()\n\nGenerates the sequence of perfect powers without multiplicity.\n\n.. code:: python\n\n    sqfrgen(ps)\n\nGenerates the squarefree products of the elements of ``ps``.\n\n.. code:: python\n\n    sqfrgenb(ps, b, k=0, m=1)\n\nGenerates the squarefree products of elements of ``ps``.  Does not yield anything > ``b``.  For best performance, ``ps`` should be sorted in decreasing order.\n\n.. code:: python\n\n    stormer(ps, *ps2, abc=None)\n\nSt\u00f8rmer's theorem asserts that for any given set ``ps`` of prime numbers, there are only finitely many pairs of consecutive integers that are both ``ps``-smooth; the theorem also gives an effective algorithm for finding them.  We implement Lenstra's improvement to this theorem.\n\nThe ``abc`` argument indicates that we are to assume an effective abc conjecture of the form *c* < ``abc[0]`` \u00b7 rad(*a*\u00b7*b*\u00b7*c*)\\ :sup:`abc[1]`.  This enables major speedups.  If ``abc`` is ``None``, then we make no such assumptions.\n\n.. code:: python\n\n    quadintroots(a, b, c)\n\nGiven integers ``a``, ``b``, and ``c``, we return in a tuple all distinct integers *x* such that ``a``\u00b7*x*\\ :sup:`2` + ``b``\u00b7*x* + ``c`` = 0.  This is primarily a helper function for ``cubicintrootsgiven`` and ``cubicintroots``.\n\n.. code:: python\n\n    cubicintrootsgiven(a, b, c, d, r)\n\nGiven integers ``a``, ``b``, ``c``, ``d``, and ``r`` such that ``a``\u00b7``r``\\ :sup:`3` + ``b``\u00b7``r``\\ :sup:`2` + ``c``\u00b7``r`` + ``d`` = 0, we find the cubic's other two roots an return in a tuple all distinct integer roots (including ``r``).  This is primarily a helper function for ``cubicintroots``.\n\n.. code:: python\n\n    cubicintroots(a, b, c, d)\n\nGiven integers ``a``, ``b``, ``c``, ``d``, we return in a tuple all distinct integer roots of ``a``\u00b7*x*\\ :sup:`3` + ``b``\u00b7*x*\\ :sup:`2` + ``c``\u00b7*x* + ``d``.  This is primarily a helper function for ``isprime_nm1``.\n\n.. code:: python\n\n    isprime_nm1(n, fac=None)\n\nThe *n*-1 primality test: given an odd integer ``n`` > 214 and a fully-factored integer *F* such that *F* divides ``n``-1 and *F* > ``n``\\ :sup:`0.3`, we quickly determine without error whether ``n`` is prime.  If the provided (partial) factorization of ``n``-1 is insufficient, we compute the factorization ourselves.\n\n.. code:: python\n\n    isprime_np1(n, fac=None)\n\nThe *n*\\ +1 primality test: given an odd integer ``n`` > 214 and a fully-factored integer *F* such that *F* divides ``n``\\ +1 and *F* > ``n``\\ :sup:`0.3`, we quickly determine without error whether ``n`` is prime.  If the provided (partial) factorization of ``n``\\ +1 is insufficient, we compute the factorization ourselves.\n\n.. code:: python\n\n    mulparts(n, r=None, nfac=None)\n\nGenerates all ordered ``r``-tuples of positive integers whose product is ``n``.  If ``r`` is ``None``, then we generate all such tuples (regardless of size) that do not contain 1.\n\n.. code:: python\n\n    dirconv(f, g, ffac=False, gfac=False)\n\nThis returns a function that is the Dirichlet convolution of ``f`` and ``g``.  When called with the keyword arguments at their default values, this is equivalent to the expression ``lambda n: sum(f(d) * g(n//d) for d in divisors(n))``.  If ``f`` or ``g`` needs to factor its argument, such as ``f == totient`` or ``g == mobius`` or something like that, then that lambda expression calls the factorizer a lot more than it needs to --- we're already factoring ``n``, so instead of feeding those functions the integer forms of ``n``'s factors, we can instead pass ``ffac=True`` or ``gfac=True`` when ``dirconv`` is called and we will call ``divisors_factored(n)`` instead and feed those factored divisors into ``f`` or ``g`` as appropriate.  This optimization becomes more noticeable as the factoring becomes more difficult.\n\n.. code:: python\n\n    dirichletinverse(f)\n\nComputes the Dirichlet inverse of the input function ``f``.  Mathematically, functions *f* such that *f*\\ (1) = 0 have no Dirichlet inverses due to a division by zero.  This is reflected in this implementation by raising a ``ZeroDivisionError`` when attempting to evaluate ``dirichletinverse(f)(n)`` for any such ``f`` and any ``n``.  If ``f``\\ (1) is neither 1 nor -1, then ``dirichletinverse(f)`` will return ``Fraction`` objects (as imported from the ``fractions`` module).\n\n.. code:: python\n\n    dirichletroot(f, r, val1)\n\nComputes the ``r``\\ :sup:`th` Dirichlet root of the input function ``f`` whose value at 1 is ``val1``.  More precisely, let ``f`` be a function on the positive integers, let ``r`` be a positive integer, and let ``val1``\\ :sup:`r` = ``f``\\ (1).  Then we return the unique function ``g`` such that ``f`` = ``g`` * ``g`` * ... * ``g``, where ``g`` appears ``r`` times and * represents Dirichlet convolution.  The values returned will be ``Fraction`` objects (as imported from the ``fractions`` module).\n\n.. code:: python\n\n    determinant(M)\n\nComputes the determinant of a matrix via the Schur determinant identity.\n\n.. code:: python\n\n    discriminant(coefs)\n\nComputes the discriminant of a polynomial.  The input list is ordered from lowest degree to highest --- i.e., ``coefs[k]`` is the coefficient of the *x*\\ :sup:`k` term.  For low-degree polynomials, explicit formulae are used; for degrees 5 and higher, we compute it by taking the determinant (using this package's determinant() function) of the Sylvester matrix of the input and its derivative.  This in turn is calculated by the Schur determinant identity.  Note that this has the effect of setting the discriminant of a linear polynomial to 1 (which is conventional) and that of a constant to 0.\n\n.. code:: python\n\n    egypt_short(n, d, terms=0, minden=1)\n\nGenerates all shortest Egyptian fractions for ``n``/``d`` using at least the indicated number of terms and whose denominators are all \u2265 minden.  No algorithm is known for this problem that significantly improves upon brute force, so this can take impractically long times on even modest-seeming inputs.\n\n.. code:: python\n\n    egypt_greedy(n, d)\n\nThe greedy algorithm for Egyptian fraction expansion; also called the Fibonacci-Sylvester algorithm.\n\n\nDependencies\n------------\n\nThis package imports items from ``multiprocessing``, ``itertools``, ``fractions``, ``random``, ``math``, and ``heapq``.  These are all in the Python standard library.\n\nWe attempt to import ``mpz`` from ``gmpy2``, but this is purely for efficiency: if this import fails, we simply set ``mpz = int``.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://pypi.python.org/pypi/labmath", "keywords": "math mathematics computational number theory integer factoring factorization primes prime numbers legendre symbol jacobi symbol kronecker symbol elliptic curve method bpsw miller rabin quadratic frobenius prp sprp lprp slprp xslprp primality testing linear recurrences lucas sequences modular square root generalized Pell equations divisor counting function euler's totient function mobius function m\u00f6bius function continued fractions partitions stormer's theorem st\u00f8rmer's theorem smooth numbers Dirichlet convolution", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "labmath", "package_url": "https://pypi.org/project/labmath/", "platform": "", "project_url": "https://pypi.org/project/labmath/", "project_urls": {"Homepage": "https://pypi.python.org/pypi/labmath"}, "release_url": "https://pypi.org/project/labmath/1.2.0/", "requires_dist": null, "requires_python": "", "summary": "Module for basic math in the general vicinity of computational number theory", "version": "1.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"labmath-version-1-1-1\">\n<h2>labmath version 1.1.1</h2>\n<p>This is a module for basic math in the general vicinity of computational number theory.  It includes functions associated with primality testing, integer factoring, prime counting, linear recurrences, modular square roots, generalized Pell equations, the classic arithmetical functions, continued fractions, partitions, St\u00f8rmer\u2019s theorem, smooth numbers, and Dirichlet convolution.  Integer arithmetic is used wherever feasible.</p>\n</div>\n<div id=\"functions\">\n<h2>Functions</h2>\n<p>We make a few imports:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">multiprocessing</span> <span class=\"kn\">import</span> <span class=\"n\">Process</span><span class=\"p\">,</span> <span class=\"n\">Queue</span> <span class=\"k\">as</span> <span class=\"n\">mpQueue</span>\n<span class=\"kn\">from</span> <span class=\"nn\">itertools</span> <span class=\"kn\">import</span> <span class=\"n\">chain</span><span class=\"p\">,</span> <span class=\"n\">count</span><span class=\"p\">,</span> <span class=\"n\">groupby</span><span class=\"p\">,</span> <span class=\"n\">islice</span><span class=\"p\">,</span> <span class=\"n\">tee</span><span class=\"p\">,</span> <span class=\"n\">cycle</span><span class=\"p\">,</span> <span class=\"n\">takewhile</span><span class=\"p\">,</span> <span class=\"n\">compress</span><span class=\"p\">,</span> <span class=\"n\">product</span><span class=\"p\">,</span> <span class=\"n\">zip_longest</span>\n<span class=\"kn\">from</span> <span class=\"nn\">fractions</span> <span class=\"kn\">import</span> <span class=\"n\">Fraction</span>\n<span class=\"kn\">from</span> <span class=\"nn\">random</span> <span class=\"kn\">import</span> <span class=\"n\">randrange</span>\n<span class=\"kn\">from</span> <span class=\"nn\">math</span> <span class=\"kn\">import</span> <span class=\"n\">log</span><span class=\"p\">,</span> <span class=\"n\">sqrt</span><span class=\"p\">;</span> <span class=\"n\">inf</span> <span class=\"o\">=</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"s1\">'inf'</span><span class=\"p\">)</span>\n<span class=\"kn\">from</span> <span class=\"nn\">heapq</span> <span class=\"kn\">import</span> <span class=\"n\">merge</span>\n\n<span class=\"k\">try</span><span class=\"p\">:</span> <span class=\"kn\">from</span> <span class=\"nn\">gmpy2</span> <span class=\"kn\">import</span> <span class=\"n\">mpz</span><span class=\"p\">;</span> <span class=\"n\">mpzv</span><span class=\"p\">,</span> <span class=\"n\">inttypes</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">mpz</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)))</span>\n<span class=\"k\">except</span> <span class=\"ne\">ImportError</span><span class=\"p\">:</span> <span class=\"n\">mpz</span><span class=\"p\">,</span> <span class=\"n\">mpzv</span><span class=\"p\">,</span> <span class=\"n\">inttypes</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">,)</span>\n\n<span class=\"n\">labmathversion</span> <span class=\"o\">=</span> <span class=\"s2\">\"1.1.0\"</span>\n</pre>\n<p>The <em>new</em> functions provided by this module are as follows.  Further details, including examples and input details, are available in docstrings and accessible via the built-in <tt>help</tt> function.</p>\n<pre><span class=\"n\">primegen</span><span class=\"p\">(</span><span class=\"n\">limit</span><span class=\"o\">=</span><span class=\"n\">inf</span><span class=\"p\">)</span>\n</pre>\n<p>Generates primes less than the given limit (which may be infinite) lazily via a segmented sieve of Eratosthenes.  Uses O(\u221a<em>p</em>) memory, where <em>p</em> is the most recently yielded prime.</p>\n<pre><span class=\"n\">rpn</span><span class=\"p\">(</span><span class=\"n\">instr</span><span class=\"p\">)</span>\n</pre>\n<p>Evaluates a string in reverse Polish notation.  The acceptable binary operators are <tt>+ - * / // % **</tt> and correspond directly to those same operators in Python3 source code.  The acceptable unary operators are <tt>! #</tt>.  They are the factorial and primorial, respectively.  There are three aliases: <tt>x</tt> for <tt>*</tt> , <tt>xx</tt> for <tt>**</tt> , and <tt>p!</tt> for <tt>#</tt>.</p>\n<pre><span class=\"n\">iterprod</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">)</span>\n</pre>\n<p>Product of the elements of any iterable.  The product of an empty iterable is 1.</p>\n<pre><span class=\"n\">listprod</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">)</span>\n</pre>\n<p>Product of the elements of a list.  The product of the empty list is 1.  We use a binary algorithm because this can easily generate huge numbers, and calling <tt>reduce(lambda x,y: x*y, a)</tt> in such situations is quite a bit slower due to the time-complexity of multiplication.  However, the size of the problem required to make this superior to <tt>iterprod()</tt> is quite large, so <tt>iterprod()</tt> should usually be used instead.</p>\n<pre><span class=\"n\">polyval</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>Evaluates a polynomial at a particular point, optionally modulo something.</p>\n<pre><span class=\"n\">binomial</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"n\">k</span><span class=\"p\">)</span>\n</pre>\n<p>The binomial coefficient nCr(<tt>n</tt>, <tt>k</tt>).</p>\n<pre><span class=\"n\">powerset</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">)</span>\n</pre>\n<p>Generates the powerset of a list, tuple, or string.  The yielded objects are always lists.</p>\n<pre><span class=\"n\">primephi</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">ps</span><span class=\"p\">,</span> <span class=\"n\">phicache</span><span class=\"o\">=</span><span class=\"p\">{})</span>\n</pre>\n<p>Legendre\u2019s phi function.  Helper function for <tt>primepi</tt>.</p>\n<pre><span class=\"n\">primepi</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">ps</span><span class=\"o\">=</span><span class=\"p\">[],</span> <span class=\"n\">picache</span><span class=\"o\">=</span><span class=\"p\">{},</span> <span class=\"n\">phicache</span><span class=\"o\">=</span><span class=\"p\">{},</span> <span class=\"n\">sqrts</span><span class=\"o\">=</span><span class=\"p\">{})</span>\n</pre>\n<p>Computes the number of primes \u2264 <tt>x</tt> via the Meissel-Lehmer method.  The arguments <tt>ps</tt>, <tt>pichache</tt>, <tt>phicache</tt>, and <tt>sqrts</tt> are for internal use only.</p>\n<pre><span class=\"n\">primesum</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Sum of primes \u2264 <tt>n</tt>.</p>\n<pre><span class=\"n\">altseriesaccel</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Convergence acceleration for alternating series.  This is algorithm 1 from <em>Convergence Acceleration of Alternating Series</em> by Cohen, Villegas, and Zagier <a href=\"https://people.mpim-bonn.mpg.de/zagier/files/exp-math-9/fulltext.pdf\" rel=\"nofollow\">(pdf)</a>, with a minor tweak so that the <em>d</em>-value isn\u2019t computed via floating point.</p>\n<pre><span class=\"n\">riemannzeta</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">24</span><span class=\"p\">)</span>\n</pre>\n<p>Computes the Riemann zeta function by applying <tt>altseriesaccel</tt> to the <a href=\"https://en.wikipedia.org/wiki/Dirichlet_eta_function\" rel=\"nofollow\">Dirichlet eta function</a>.  Should be rather accurate throughout the complex plane except near <tt>n</tt> such that 1 = 2<sup>n-1</sup>.</p>\n<pre><span class=\"n\">zetam1</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">24</span><span class=\"p\">)</span>\n</pre>\n<p>Computes <tt>riemannzeta(n, k) - 1</tt> by applying <tt>altseriesaccel</tt> to the Dirichlet eta function.  Designed to be accurate even when <tt>riemannzeta(n)</tt> is machine-indistinguishable from 1.0 \u2014 in particular, when <tt>n</tt> is a large real number.</p>\n<pre><span class=\"n\">riemannR</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">zc</span><span class=\"o\">=</span><span class=\"p\">{})</span>\n</pre>\n<p>Uses the <a href=\"http://mathworld.wolfram.com/GramSeries.html\" rel=\"nofollow\">Gram series</a> to compute <a href=\"http://mathworld.wolfram.com/RiemannPrimeCountingFunction.html\" rel=\"nofollow\">Riemann\u2019s R function</a>, which is a rather good approximation to <tt>primepi</tt>.  The argument <tt>zc</tt> is a cache of zeta values.</p>\n<pre><span class=\"n\">nthprimeapprox</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Produces an integer that should be rather close to the <tt>n</tt><sup>th</sup> prime by using binary splitting on Riemann\u2019s R function.</p>\n<pre><span class=\"n\">nthprime</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Returns the <tt>n</tt><sup>th</sup> prime (counting 2 as #1).  This is done with some efficiency by using <tt>nthprimeapprox</tt> as an initial estimate, computing <tt>primepi</tt> of that, and then sieving to remove the error.</p>\n<pre><span class=\"n\">gcd</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">r</span><span class=\"p\">)</span>\n</pre>\n<p>Greatest common divisor of any number of values.</p>\n<pre><span class=\"n\">xgcd</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n</pre>\n<p>Extended Euclidean altorithm: returns a tuple (<tt>g</tt>, <em>x</em>, <em>y</em>) such that <tt>g</tt> = gcd(<tt>a</tt>, <tt>b</tt>) and <tt>g</tt> = <tt>a</tt>\u00b7<em>x</em> + <tt>b</tt>\u00b7<em>y</em>.</p>\n<pre><span class=\"n\">modinv</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"p\">)</span>\n</pre>\n<p>Returns the inverse of <tt>a</tt> modulo <tt>m</tt>, normalized to lie between <tt>0</tt> and <tt><span class=\"pre\">m-1</span></tt>.  If <tt>a</tt> is not coprime to <tt>m</tt>, returns 1.</p>\n<pre><span class=\"n\">crt</span><span class=\"p\">(</span><span class=\"n\">rems</span><span class=\"p\">,</span> <span class=\"n\">mods</span><span class=\"p\">)</span>\n</pre>\n<p>Returns the unique integer <em>c</em> in <tt>range(iterprod(mods))</tt> such that <em>c</em> \u2261 <em>x</em> (mod <em>y</em>) for (<em>x</em>, <em>y</em>) in <tt>zip(rems, mods)</tt>.  All elements of <tt>mods</tt> must be pairwise coprime.</p>\n<pre><span class=\"n\">lcm</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">r</span><span class=\"p\">)</span>\n</pre>\n<p>The least common multiple of any number of values.</p>\n<pre><span class=\"n\">isqrt</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Greatest integer whose square is \u2264 <tt>n</tt>.</p>\n<pre><span class=\"n\">introot</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre>\n<p>For non-negative <tt>n</tt>, returns the greatest integer \u2264 the rth root of <tt>n</tt>.  For negative <tt>n</tt>, returns the least integer \u2265 the <tt>r</tt><sup>th</sup> root of <tt>n</tt>, or <tt>None</tt> if <tt>r</tt> is even.</p>\n<pre><span class=\"n\">ispower</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n</pre>\n<p>If <tt>r</tt> = 0: If <tt>n</tt> is a perfect power, return a tuple containing the largest integer that, when squares/cubed/etc, yields <tt>n</tt> as the first component and the relevant power as the second component.  If <tt>n</tt> is not a perfect power, return <tt>None</tt>.</p>\n<p>If <tt>r</tt> &gt; 0: We check whether <tt>n</tt> is a perfect <tt>r</tt><sup>th</sup> power; we return its <tt>r</tt><sup>th</sup> root if it is and <tt>None</tt> if it isn\u2019t.</p>\n<pre><span class=\"n\">ilog</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n</pre>\n<p>Greatest integer <em>k</em> such that <tt>b</tt><sup>k</sup> \u2264 <tt>x</tt>.</p>\n<pre><span class=\"n\">fibogen</span><span class=\"p\">()</span>\n</pre>\n<p>Generates the Fibonacci numbers, starting with 0 and 1.</p>\n<pre><span class=\"n\">fibo</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">})</span>\n</pre>\n<p>Efficiently extracts the <tt>n</tt><sup>th</sup> Fibonacci number, indexed so that <tt>fibo(0)</tt> = 0 and <tt>fibo(1)</tt> = <tt>fibo(2)</tt> = 1.  The argument <tt>f</tt> is used for memoization.  We compute O(log(<tt>n</tt>)) earlier Fibonaccis along the way.  This is, in the big-O sense, just about as fast as possible.</p>\n<pre><span class=\"n\">fibomod</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">})</span>\n</pre>\n<p>Efficiently extracts the nth Fibonacci number modulo <tt>m</tt>, indexed so that <tt>fibo(0)</tt> = 0 and <tt>fibo(1)</tt> == <tt>fibo(2)</tt> = 1.  The argument <tt>f</tt> is used for memoization.  We compute O(log(<tt>n</tt>)) earlier Fibonaccis along the way.  This is the asymptotically fastest algorithm.</p>\n<pre><span class=\"n\">lucaschain</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">x1</span><span class=\"p\">,</span> <span class=\"n\">op1</span><span class=\"p\">,</span> <span class=\"n\">op2</span><span class=\"p\">)</span>\n</pre>\n<p>Algorithm 3.6.7 from <em>Prime Numbers: A Computational Perspective</em> by Crandall &amp; Pomerance (2<sup>nd</sup> edition): Evaluation of a binary Lucas chain.  To quote their description:</p>\n<blockquote>\nFor a sequence <em>x</em><sub>0</sub>, <em>x</em><sub>1</sub>, \u2026 with a rule for computing <em>x</em><sub>2j</sub> from <em>x</em><sub>j</sub> and a rule for computing <em>x</em><sub>2j+1</sub> from <em>x</em><sub>j</sub> and <em>x</em><sub>j+1</sub>, this algorithm computes (<em>x</em><sub>n</sub>, <em>x</em><sub>n+1</sub>) for a given positive integer <em>n</em>.  We have <em>n</em> in binary as (<em>n</em><sub>0</sub>, <em>n</em><sub>1</sub>, \u2026, <em>n</em><sub>b-1</sub>) with <em>n</em><sub>0</sub> being the low-order bit.  We write the rules as follows: <em>x</em><sub>2j</sub> = op1(<em>x</em><sub>j</sub>) and <em>x</em><sub>2j+1</sub> = op2(<em>x</em><sub>j</sub>, <em>x</em><sub>j+1</sub>).</blockquote>\n<pre><span class=\"n\">lucasgen</span><span class=\"p\">(</span><span class=\"n\">P</span><span class=\"p\">,</span> <span class=\"n\">Q</span><span class=\"p\">):</span>\n</pre>\n<p>Generates the Lucas U- and V-sequences with parameters (<tt>P</tt>, <tt>Q</tt>).</p>\n<pre><span class=\"n\">lucas</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">P</span><span class=\"p\">,</span> <span class=\"n\">Q</span><span class=\"p\">)</span>\n</pre>\n<p>Efficiently computes the <tt>k</tt><sup>th</sup> terms in the Lucas U- and V-sequences U(<tt>P</tt>, <tt>Q</tt>) and V(<tt>P</tt>, <tt>Q</tt>).  More explicitly, if</p>\n<blockquote>\nU<sub>0</sub>, U<sub>1</sub>, V<sub>0</sub>, V<sub>1</sub> = 0, 1, 2, <tt>P</tt></blockquote>\n<p>and we have the recursions</p>\n<blockquote>\n<p>U<sub>n</sub> = <tt>P</tt> \u00b7 U<sub>n-1</sub> - <tt>Q</tt> \u00b7 U<sub>n-2</sub></p>\n<p>V<sub>n</sub> = <tt>P</tt> \u00b7 V<sub>n-1</sub> - <tt>Q</tt> \u00b7 V<sub>n-2</sub></p>\n</blockquote>\n<p>then we compute U<sub>k</sub> and V<sub>k</sub> in O(ln(<tt>k</tt>)) arithmetic operations.  If <tt>P</tt><sup>2</sup> \u2260 4\u00b7<tt>Q</tt>, then these sequences grow exponentially, so the number of bit operations is anywhere from O(<tt>k</tt> \u00b7 ln(<tt>k</tt>)<sup>2</sup> \u00b7 ln(ln(<tt>k</tt>))) to O(<tt>k</tt><sup>2</sup>) depending on how multiplication is handled.  We recommend using MPZs when <tt>k</tt> &gt; 100 or so.  We divide by <tt>P</tt><sup>2</sup> - 4\u00b7<tt>Q</tt> at the end, so we handle separately the case where this is zero.</p>\n<pre><span class=\"n\">binlinrecgen</span><span class=\"p\">(</span><span class=\"n\">P</span><span class=\"p\">,</span> <span class=\"n\">Q</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n</pre>\n<p>The general binary linear recursion.  Exactly like <tt>lucasgen</tt>, except we only compute one sequence, and we supply the seeds.</p>\n<pre><span class=\"n\">binlinrec</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">P</span><span class=\"p\">,</span> <span class=\"n\">Q</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n</pre>\n<p>The general binary linear recursion.  Exactly like <tt>lucas</tt>, except we compute only one sequence, and we supply the seeds.</p>\n<pre><span class=\"n\">linrecgen</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>The general homogenous linear recursion: we generate in order the sequence defined by</p>\n<blockquote>\n<em>x</em><sub>n+1</sub> = <tt>a</tt><sub>k</sub> \u00b7 <em>x</em><sub>n</sub> + <tt>a</tt><sub>k-1</sub> \u00b7 <em>x</em><sub>n-1</sub> + \u2026 + <tt>a</tt><sub>0</sub> \u00b7 <em>x</em><sub>n-k</sub>,</blockquote>\n<p>where the initial values are [<em>x</em><sub>0</sub>, \u2026, <em>x</em><sub>k</sub>] = <tt>b</tt>.  If <tt>m</tt> is supplied, then we compute the sequence modulo <tt>m</tt>.  The terms of this sequence usually grow exponentially, so computing a distant term incrementally by plucking it out of this generator takes O(<tt>n</tt><sup>2</sup>) bit operations.  Extractions of distant terms should therefore be done via <tt>linrec</tt>, which takes anywhere from O(<tt>n</tt> \u00b7 ln(<tt>n</tt>)<sup>2</sup> \u00b7 ln(ln(<tt>n</tt>))) to O(<tt>n</tt><sup>2</sup>) bit operations depending on how multiplication is handled.</p>\n<pre><span class=\"n\">linrec</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>The general homogeneous linear recursion.  If <tt>m</tt> is supplied, terms are computed modulo <tt>m</tt>.  We use matrix methods to efficiently compute the <tt>n</tt><sup>th</sup> term of the recursion</p>\n<blockquote>\n<em>x</em><sub>n+1</sub> = <tt>a</tt><sub>k</sub> \u00b7 <em>x</em><sub>n</sub> + <tt>a</tt><sub>k-1</sub> \u00b7 <em>x</em><sub>n-1</sub> + \u2026 + <tt>a</tt><sub>0</sub> \u00b7 <em>x</em><sub>n-k</sub>,</blockquote>\n<p>where the initial values are [<em>x</em><sub>0</sub>, \u2026, <em>x</em><sub>k</sub>] = <tt>b</tt>.</p>\n<pre><span class=\"n\">legendre</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n</pre>\n<p>Legendre symbol (<tt>a</tt> | <tt>p</tt>): 1 if <tt>a</tt> is a quadratic residue mod <tt>p</tt>, -1 if it isn\u2019t, and 0 if <tt>a</tt> \u2261 0 (mod <tt>p</tt>).  Not meaningful if <tt>p</tt> isn\u2019t prime.</p>\n<pre><span class=\"n\">jacobi</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>The Jacobi symbol (<tt>a</tt> | <tt>n</tt>).</p>\n<pre><span class=\"n\">kronecker</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>The Kronecker symbol (<tt>a</tt> | <tt>n</tt>).  Note that this is the generalization of the Jacobi symbol, <em>not</em> the Dirac-delta analogue.</p>\n<pre><span class=\"n\">fermat_prp</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n</pre>\n<p>Fermat\u2019s primality test.</p>\n<pre><span class=\"n\">sprp</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n</pre>\n<p>The strong probable primality test (aka single-round Miller-Rabin).</p>\n<pre><span class=\"n\">mrab</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">basis</span><span class=\"p\">)</span>\n</pre>\n<p>Miller-Rabin probable primality test.</p>\n<pre><span class=\"n\">miller</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Miller\u2019s primality test.  If the extended Riemann hypothesis (the one about Dirichlet L-functions) is true, then this test is deterministic.</p>\n<pre><span class=\"n\">lprp</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n</pre>\n<p>Lucas probable primality test as described in <em>Prime Numbers: A Computational Perspective</em> by Crandall &amp; Pomerance (2<sup>nd</sup> edition).</p>\n<pre><span class=\"n\">lucasmod</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">P</span><span class=\"p\">,</span> <span class=\"n\">Q</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"p\">)</span>\n</pre>\n<p>Efficiently computed the <tt>k</tt><sup>th</sup> terms of Lucas U- and V-sequences modulo <tt>m</tt> with parameters (<tt>P</tt>, <tt>Q</tt>).  Currently just a helper function for <tt>slprp</tt> and <tt>xslprp</tt>.  Will be upgraded to full status when the case <tt><span class=\"pre\">gcd(D,m)!=1</span></tt> is handled properly.</p>\n<pre><span class=\"n\">slprp</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n</pre>\n<p>Strong lucas probable primality test as described on Wikipedia.  Its false positives are a strict subset of those for <tt>lprp</tt> with the same parameters.</p>\n<pre><span class=\"n\">xslprp</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n</pre>\n<p>Extra strong Lucas probable primality test as described on Wikipedia.  Its false positives are a strict subset of those for <tt>slprp</tt> (and therefore <tt>lprp</tt>) with parameters (<tt>a</tt>, 1).</p>\n<pre><span class=\"n\">bpsw</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>The Baille-Pomerance-Selfridge-Wagstaff probable primality test.  Infinitely many false positives are conjectured to exist, but none are known, and the test is known to be deterministic below 2<sup>64</sup>.</p>\n<pre><span class=\"n\">qfprp</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n</pre>\n<p>Quadratic Frobenius probable primality test as described in <em>Prime Numbers: A Computational Perspective</em> by Crandall &amp; Pomerance (2<sup>nd</sup> edition).</p>\n<pre><span class=\"n\">polyaddmodp</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n</pre>\n<p>Adds two polynomials and reduces their coefficients mod <tt>p</tt>.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is <tt>None</tt>, we return <tt>None</tt>.</p>\n<pre><span class=\"n\">polysubmodp</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n</pre>\n<p>Subtracts the polynomial <tt>b</tt> from <tt>a</tt> and reduces their coefficients mod <tt>p</tt>.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is <tt>None</tt>, we return <tt>None</tt>.</p>\n<pre><span class=\"n\">polymulmodp</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n</pre>\n<p>Multiplies the polynomials <tt>a</tt> and <tt>b</tt> and reduces their coefficients mod <tt>p</tt>.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is <tt>None</tt>, we return <tt>None</tt>.</p>\n<pre><span class=\"n\">polydivmodmodp</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n</pre>\n<p>Divides the polynomial <tt>a</tt> by the polynomial <tt>b</tt> and returns the quotient and remainder.  The coefficients are interpreted mod <tt>p</tt>.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is <tt>None</tt>, we return <tt>None</tt>.  The result is not guaranteed to exist; in such cases we return <tt>(None, None)</tt>.</p>\n<pre><span class=\"n\">gcmd</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n</pre>\n<p>Computes the greatest common monic divisor of the polynomials <tt>f</tt> and <tt>g</tt>.  The coefficients are interpreted mod <tt>p</tt>.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is <tt>None</tt>, or if both input polynomials are <tt>[]</tt>, we return <tt>None</tt>.  The result is not guaranteed to exist; in such cases, we return <tt>None</tt>.  Coded after algorithm 2.2.1 from <em>Prime Numbers: A Computational Perspective</em> by Crandall &amp; Pomerance (2<sup>nd</sup> edition).</p>\n<pre><span class=\"n\">polypowmodpmodpoly</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">)</span>\n</pre>\n<p>Computes the remainder when the polynomial <tt>a</tt> is raised to the <tt>e</tt><sup>th</sup> power and reduced modulo <tt>f</tt>.  The coefficients are interpreted mod <tt>p</tt>.  Polynomials are written as lists of integers with the constant terms first.  If the high-degree coefficients are zero, those terms will be deleted from the answer so that the highest-degree term is nonzero.  We assume that the inputs also satisfy this property.  The zero polynomial is represented by the empty list.  If one of the input polynomials is <tt>None</tt>, or if <tt>f == []</tt>, we return <tt>None</tt>.  The answer is not guaranteed to exist.  In such cases, we return <tt>None</tt>.</p>\n<pre><span class=\"n\">frobenius_prp</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">poly</span><span class=\"p\">,</span> <span class=\"n\">strong</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>Grantham\u2019s general Frobenius probable primality test, in both the strong and weak versions, as described in <a href=\"https://doi.org/10.1090/S0025-5718-00-01197-2\" rel=\"nofollow\">his paper introducing the test</a>.</p>\n<pre><span class=\"n\">isprime</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">tb</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">7</span><span class=\"p\">,</span><span class=\"mi\">11</span><span class=\"p\">,</span><span class=\"mi\">13</span><span class=\"p\">,</span><span class=\"mi\">17</span><span class=\"p\">,</span><span class=\"mi\">19</span><span class=\"p\">,</span><span class=\"mi\">23</span><span class=\"p\">,</span><span class=\"mi\">29</span><span class=\"p\">,</span><span class=\"mi\">31</span><span class=\"p\">,</span><span class=\"mi\">37</span><span class=\"p\">,</span><span class=\"mi\">41</span><span class=\"p\">,</span><span class=\"mi\">43</span><span class=\"p\">,</span><span class=\"mi\">47</span><span class=\"p\">,</span><span class=\"mi\">53</span><span class=\"p\">,</span><span class=\"mi\">59</span><span class=\"p\">))</span>\n</pre>\n<p>The workhorse primality test.  It is a BPSW primality test variant: we use the strong Lucas PRP test and preface the computation with trial division for speed.  No composites are known to pass the test, though it is suspected that infinitely many will do so.  There are definitely no such errors below 2<sup>64</sup>.  This function is mainly a streamlined version of <tt>bpsw</tt>.</p>\n<pre><span class=\"n\">isprime_mersenne</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n</pre>\n<p>The Lucas-Lehmer test.  Deterministically and efficiently checks whether the Mersenne number 2<sup>p</sup>-1 is prime.</p>\n<pre><span class=\"n\">nextprime</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Smallest prime strictly greater than <tt>n</tt>.</p>\n<pre><span class=\"n\">prevprime</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Largest prime strictly less than <tt>n</tt>, or <tt>None</tt> if no such prime exists.</p>\n<pre><span class=\"n\">randprime</span><span class=\"p\">(</span><span class=\"n\">digits</span><span class=\"p\">,</span> <span class=\"n\">base</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">primetest</span><span class=\"o\">=</span><span class=\"n\">isprime</span><span class=\"p\">)</span>\n</pre>\n<p>Returns a random prime with the specified number of digits when rendered in the specified base.</p>\n<pre><span class=\"n\">randomfactored</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">primetest</span><span class=\"o\">=</span><span class=\"n\">isprime</span><span class=\"p\">)</span>\n</pre>\n<p>Efficiently generates an integer selected uniformly from the range [1, <tt>n</tt>] with its factorization.  Uses Adam Kalai\u2019s algorithm, which uses in the average case O(log(<tt>n</tt>)<sup>2</sup>) primality tests.  When called with the default primality test, this then uses O(log(<tt>n</tt>)<sup>3</sup>) arithmetic operations, which in turn results in just over O(log(<tt>n</tt>)<sup>4</sup>) to O(log(<tt>n</tt>)<sup>5</sup>) bit operations, depending on how multiplication is handled.</p>\n<pre><span class=\"n\">sqrtmod_prime</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n</pre>\n<p>Finds <em>x</em> such that <em>x</em><sup>2</sup> \u2261 <tt>a</tt> (mod <tt>p</tt>).  We assume that <tt>p</tt> is a prime and <tt>a</tt> is a quadratic residue modulo <tt>p</tt>.  If any of these conditions is false, then the return value is meaningless.</p>\n<pre><span class=\"n\">cbrtmod_prime</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n</pre>\n<p>Returns in a sorted list all cube roots of a mod p.  There are a bunch of easily-computed special formulae for various cases with p != 1 (mod 9); we do those first, and then if p == 1 (mod 9) we use Algorithm 4.2 in <a href=\"https://doi.org/10.1016/S0893-9659(02)00031-9\" rel=\"nofollow\">Taking Cube Roots in Zm</a> by Padro and Saez, which is essentially a variation on the Tonelli-Shanks algorithm for modular square roots.</p>\n<pre><span class=\"n\">pollardrho_brent</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Factors integers using Brent\u2019s variation of Pollard\u2019s rho algorithm.  If <tt>n</tt> is prime, we immediately return <tt>n</tt>; if not, we keep chugging until a nontrivial factor is found.</p>\n<pre><span class=\"n\">pollard_pm1</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">B1</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">B2</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">)</span>\n</pre>\n<p>Integer factoring function.  Uses Pollard\u2019s p-1 algorithm.  Note that this is only efficient if the number to be factored has a prime factor <em>p</em> such that <em>p</em>-1\u2019s largest prime factor is \u201csmall\u201d.</p>\n<pre><span class=\"n\">mlucas</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Helper function for <tt>williams_pp1</tt>.  Multiplies along a Lucas sequence modulo <tt>n</tt>.</p>\n<pre><span class=\"n\">williams_pp1</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Integer factoring function.  Uses Williams\u2019 p+1 algorithm, single-stage variant.  Note that this is only efficient when the number to be factored has a prime factor <em>p</em> such that <em>p</em>+1\u2019s largest prime factor is \u201csmall\u201d.</p>\n<pre><span class=\"n\">ecadd</span><span class=\"p\">(</span><span class=\"n\">p1</span><span class=\"p\">,</span> <span class=\"n\">p2</span><span class=\"p\">,</span> <span class=\"n\">p0</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Helper function for <tt>ecm</tt>.  Adds two points on a Montgomery curve modulo <tt>n</tt>.</p>\n<pre><span class=\"n\">ecdub</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Helper function for <tt>ecm</tt>.  Doubles a point on a Montgomery curve modulo <tt>n</tt>.</p>\n<pre><span class=\"n\">ecmul</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Helper function for <tt>ecm</tt>.  Multiplies a point on Montgomery curve by an integer modulo <tt>n</tt>.</p>\n<pre><span class=\"n\">secm</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">B1</span><span class=\"p\">,</span> <span class=\"n\">B2</span><span class=\"p\">,</span> <span class=\"n\">seed</span><span class=\"p\">)</span>\n</pre>\n<p>Seeded elliptic curve factoring using the two-phase algorithm on Montgomery curves.  Helper function for <tt>ecm</tt>.  Returns a possibly-trivial divisor of <tt>n</tt> given two bounds and a seed.</p>\n<pre><span class=\"n\">ecmparams</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Generator of parameters to use for <tt>secm</tt>.</p>\n<pre><span class=\"n\">ecm</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">paramseq</span><span class=\"o\">=</span><span class=\"n\">ecmparams</span><span class=\"p\">,</span> <span class=\"n\">nprocs</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>Integer factoring via elliptic curves using the two-phase algorithm on Montgomery curves, and optionally uses multiple processes.  This is a shell function that repeatedly calls <tt>secm</tt> using parameters provided by <tt>ecmparams</tt>; the actual factoring work is done there.  Multiprocessing incurs relatively significant overhead, so when <tt><span class=\"pre\">nprocs==1</span></tt> (default), we don\u2019t call the multiprocessing functions.</p>\n<pre><span class=\"n\">modinv_mpqs</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"p\">)</span>\n</pre>\n<p>Helper function for <tt>mpqs</tt>.  Returns a modular inverse normalized to minimize absolute value.</p>\n<pre><span class=\"n\">mpqs</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Factors an integer via the multiple-polynomial quadratic sieve.  Most of this function is copied verbatim from <a href=\"https://codegolf.stackexchange.com/a/9088\" rel=\"nofollow\">https://codegolf.stackexchange.com/a/9088</a>.</p>\n<pre><span class=\"n\">multifactor</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"p\">)</span>\n</pre>\n<p>Integer factoring function.  Uses several methods in parallel.  Waits for one of them to return, kills the rest, and reports.</p>\n<pre><span class=\"n\">primefac</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">trial</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"n\">rho</span><span class=\"o\">=</span><span class=\"mi\">42000</span><span class=\"p\">,</span> <span class=\"n\">primetest</span><span class=\"o\">=</span><span class=\"n\">isprime</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">pollardrho_brent</span><span class=\"p\">,))</span>\n</pre>\n<p>The workhorse integer factorizer.  Generates the prime factors of the input.  Factors that appear <em>x</em> times are yielded <em>x</em> times.</p>\n<pre><span class=\"n\">factorint</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">trial</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"n\">rho</span><span class=\"o\">=</span><span class=\"mi\">42000</span><span class=\"p\">,</span> <span class=\"n\">primetest</span><span class=\"o\">=</span><span class=\"n\">isprime</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">pollardrho_brent</span><span class=\"p\">,))</span>\n</pre>\n<p>Compiles the output of <tt>primefac</tt> into a dictionary with primes as keys and multiplicities as values.</p>\n<pre><span class=\"n\">factorsieve</span><span class=\"p\">(</span><span class=\"n\">stop</span><span class=\"p\">)</span>\n</pre>\n<p>Uses a sieve to compute the factorizations of all whole numbers strictly less than the input.  This uses a lot of memory; if you aren\u2019t after the factors directly, it\u2019s usually better to write a dedicated function for whatever it is that you actually want.</p>\n<pre><span class=\"n\">divisors</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Generates all natural numbers that evenly divide <tt>n</tt>.  The output is not necessarily sorted.</p>\n<pre><span class=\"n\">divisors_factored</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Generates the divisors of <tt>n</tt>, written as their prime factorizations in factorint format.</p>\n<pre><span class=\"n\">divcount</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Counts the number of divisors of <tt>n</tt>.</p>\n<pre><span class=\"n\">divsigma</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>Sum of divisors of a natural number, raised to the <em>x</em><sup>th</sup> power.  The conventional notation for this in mathematical literature is \u03c3<sub>x</sub>(<tt>n</tt>), hence the name of this function.</p>\n<pre><span class=\"n\">divcountsieve</span><span class=\"p\">(</span><span class=\"n\">stop</span><span class=\"p\">)</span>\n</pre>\n<p>Uses a sieve to compute the number of divisors of all whole numbers strictly less than the input.</p>\n<pre><span class=\"n\">totient</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>Jordan\u2019s totient function: the number of <tt>k</tt>-tuples of positive integers all \u2264 <tt>n</tt> that form a coprime (<tt>k</tt>+1)-tuple together with <tt>n</tt>.  When <tt>k</tt> = 1, this is Euler\u2019s totient: the number of numbers less than a number that are relatively prime to that number.</p>\n<pre><span class=\"n\">totientsieve</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Uses a sieve to compute the totients up to (and including) <tt>n</tt>.</p>\n<pre><span class=\"n\">totientsum</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Computes <tt>sum(totient(n) for n in range(1, n+1))</tt> efficiently.</p>\n<pre><span class=\"n\">mobius</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>The M\u00f6bius function of <tt>n</tt>: 1 if <tt>n</tt> is squarefree with an even number of prime factors, -1 if <tt>n</tt> is squarefree with an odd number of prime factors, and 0 if <tt>n</tt> has a repeated prime factor.</p>\n<pre><span class=\"n\">mobiussieve</span><span class=\"p\">(</span><span class=\"n\">stop</span><span class=\"p\">)</span>\n</pre>\n<p>Uses a sieve to compute the M\u00f6bius function of all whole numbers strictly less than the input.</p>\n<pre><span class=\"n\">liouville</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>The Liouville lambda function of <tt>n</tt>: the strongly multiplicative function that is -1 on the primes.</p>\n<pre><span class=\"n\">polyroots_prime</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">sqfr</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>Generates with some efficiency and without multiplicity the zeros of a polynomial modulo a prime.  Coded after algorithm 2.3.10 from <em>Prime Numbers: A Computational Perspective</em> by Crandall &amp; Pomerance (2<sup>nd</sup> edition), which is essentially Cantor-Zassenhaus.</p>\n<pre><span class=\"n\">hensel</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">given</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>Uses Hensel lifting to generate with some efficiency all zeros of a polynomial modulo a prime power.</p>\n<pre><span class=\"n\">sqrtmod</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Computes all square roots of <tt>a</tt> modulo <tt>n</tt> and returns them in a sorted list.</p>\n<pre><span class=\"n\">polyrootsmod</span><span class=\"p\">(</span><span class=\"n\">pol</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Computes the zeros of a polynomial modulo an integer.  We do this by factoring the modulus, solving modulo the prime power factors, and putting the results back together via the Chinese Remainder Theorem.</p>\n<pre><span class=\"n\">PQa</span><span class=\"p\">(</span><span class=\"n\">P</span><span class=\"p\">,</span> <span class=\"n\">Q</span><span class=\"p\">,</span> <span class=\"n\">D</span><span class=\"p\">)</span>\n</pre>\n<p>Generates some sequences related to simple continued fractions of certain quadratic surds.  A helper function for <tt>pell</tt>.  Let <tt>P</tt>, <tt>Q</tt>, and <tt>D</tt> be integers such that <tt>Q</tt> \u2260 0, <tt>D</tt> &gt; 0 is a nonsquare, and <tt>P</tt><sup>2</sup> \u2261 <tt>D</tt> (mod <tt>Q</tt>). We yield a sequence of tuples (<em>B</em><sub>i</sub>, <em>G</em><sub>i</sub>, <em>P</em><sub>i</sub>, <em>Q</em><sub>i</sub>) where <em>i</em> is an index counting up from 0, <em>x</em> = (<tt>P</tt>+\u221a<tt>D</tt>)/<tt>Q</tt> = [<em>a</em><sub>0</sub>; <em>a</em><sub>1</sub>, <em>a</em><sub>2</sub>, \u2026], (<em>P</em><sub>i</sub>+\u221a<tt>D</tt>))/<em>Q</em><sub>i</sub> is the <em>i</em><sup>th</sup> complete quotient of <em>x</em>, and <em>B</em><sub>i</sub> is the denominator of the <em>i</em><sup>th</sup> convergent to <em>x</em>.  For full details, see <a href=\"https://www.jpr2718.org/pell.pdf\" rel=\"nofollow\">https://www.jpr2718.org/pell.pdf</a>.</p>\n<pre><span class=\"n\">pell</span><span class=\"p\">(</span><span class=\"n\">D</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">)</span>\n</pre>\n<p>This function solves the generalized Pell equation: we find all non-negative integers (<em>x</em>, <em>y</em>) such that <em>x</em><sup>2</sup> - <tt>D</tt> \u00b7 <em>y</em><sup>2</sup> = <tt>N</tt>.  We have several cases:</p>\n<p>Case 1: <tt>N</tt> = 0.  We solve <em>x</em><sup>2</sup> = <tt>D</tt> \u00b7 <em>y</em><sup>2</sup>.  (0,0) is always a solution.</p>\n<blockquote>\n<p>Case 1a: If <tt>D</tt> is a nonsquare, then there are no further solutions.</p>\n<p>Case 1b: If <tt>D</tt> is a square, then there are infinitely many solutions, parametrized by (<em>t</em>\u00b7\u221a<tt>D</tt>, <em>t</em>).</p>\n</blockquote>\n<p>Case 2: <tt>N</tt> \u2260 0 = <tt>D</tt>.  We solve <em>x</em><sup>2</sup> = <tt>N</tt>.</p>\n<blockquote>\n<p>Case 2a: If <tt>N</tt> is a nonsquare, then there are no solutions.</p>\n<p>Case 2b: If <tt>N</tt> is a square, then there are infinitely many solutions, parametrized by (\u221a<tt>N</tt>, <em>t</em>).</p>\n</blockquote>\n<p>Case 3: <tt>N</tt> \u2260 0 &gt; <tt>D</tt>.  We solve <em>x</em><sup>2</sup> + |<tt>D</tt>| \u00b7 <em>y</em><sup>2</sup> = <tt>N</tt>.  The number of solutions will be finite.</p>\n<p>Case 4: <tt>N</tt> \u2260 0 &lt; <tt>D</tt>.  We find lattice points on a hyperbola.</p>\n<blockquote>\n<p>Case 4a: If <tt>D</tt> is a square, then the number of solutions will be at most finite.  This case is solved by factoring.</p>\n<p>Case 4b: If <tt>D</tt> is a nonsquare, then we run the PQa/LMM algorithms: we produce a set of primitive solutions; if this set is empty, there are no solutions; if this set has members, an ininite set of solutions can be produced by repeatedly composing them with the fundamental solution of <em>x</em><sup>2</sup> - <tt>D</tt> \u00b7 <em>y</em><sup>2</sup> = 1.</p>\n</blockquote>\n<p>References:</p>\n<ul>\n<li><a href=\"http://www.jpr2718.org/pell.pdf\" rel=\"nofollow\">http://www.jpr2718.org/pell.pdf</a></li>\n<li><a href=\"http://www.offtonic.com/blog/?p=12\" rel=\"nofollow\">http://www.offtonic.com/blog/?p=12</a></li>\n<li><a href=\"http://www.offtonic.com/blog/?p=18\" rel=\"nofollow\">http://www.offtonic.com/blog/?p=18</a></li>\n</ul>\n<p>Input: <tt>D</tt>, <tt>N</tt> \u2013 integers</p>\n<p>Output:</p>\n<blockquote>\n<p>A 3-tuple.</p>\n<p>If the number of solutions is finite, it is <tt>(None, z, None)</tt>, where <tt>z</tt> is the sorted list of all solutions.</p>\n<p>If the number of solutions is infinite and the equation is degenerate, it\u2019s <tt>(gen, None, None)</tt>, where <tt>gen</tt> yields all solutions.</p>\n<p>If the number of solutions if infinite and the equation is nondegenerate, it is <tt>(gen, z, f)</tt>, where <tt>z</tt> is the set of primitive solutions, represented as a sorted list, and <tt>f</tt> is the fundamental solution \u2014 i.e., <tt>f</tt> is the primitive solution of <em>x</em><sup>2</sup> - <tt>D</tt> \u00b7 <em>y</em><sup>2</sup> = 1.</p>\n<p>Note that we can check the infinitude of solutions by calling <tt><span class=\"pre\">bool(pell(D,N)[0])</span></tt>.</p>\n</blockquote>\n<pre><span class=\"n\">simplepell</span><span class=\"p\">(</span><span class=\"n\">D</span><span class=\"p\">,</span> <span class=\"n\">bail</span><span class=\"o\">=</span><span class=\"n\">inf</span><span class=\"p\">)</span>\n</pre>\n<p>Generates the positive solutions of <em>x</em><sup>2</sup> - <tt>D</tt> \u00b7 <em>y</em><sup>2</sup> = 1.  We use some optimizations specific to this case of the Pell equation that makes this more efficient than calling <tt><span class=\"pre\">pell(D,1)[0]</span></tt>.  Note that this function is not equivalent to calling <tt><span class=\"pre\">pell(D,1)[0]</span></tt>: <tt>pell</tt> is concerned with the general equation, which may or may not have trivial solutions, and as such yields all non-negative solutions, whereas this function is concerned only with the simple Pell equation, which always has an infinite family of positive solutions generated from a single primitive solution and always has the trivial solution (1,0).</p>\n<p>We yield only those solutions with <em>x</em> \u2264 <tt>bail</tt>.</p>\n<pre><span class=\"n\">carmichael</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>The Carmichael lambda function: the smallest positive integer <em>m</em> such that <em>a</em><sup>m</sup> \u2261 1 (mod <tt>n</tt>) for all <em>a</em> such that gcd(<em>a</em>, <tt>n</tt>) = 1.  Also called the reduced totient or least universal exponent.</p>\n<pre><span class=\"n\">multord</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Computes the multiplicative order of <tt>b</tt> modulo <tt>n</tt>; i.e., finds the smallest <em>k</em> such that <tt>b</tt><sup>k</sup> \u2261 1 (mod <tt>n</tt>).</p>\n<pre><span class=\"n\">pythags_by_perimeter</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n</pre>\n<p>Generates all Pythagorean triples of a given perimeter by examining the perimeter\u2019s factors.</p>\n<pre><span class=\"n\">collatz</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Generates the Collatz sequence initiated by <tt>n</tt>.  Stops after yielding 1.</p>\n<pre><span class=\"n\">sqrtcfrac</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Computes the simple continued fraction for \u221a<tt>n</tt>.  We return the answer as <tt>(isqrt(n), <span class=\"pre\">[a,b,c,...,d])</span></tt>, where <tt><span class=\"pre\">[a,b,c,...,d]</span></tt> is the minimal reptend.</p>\n<pre><span class=\"n\">convergents</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n</pre>\n<p>Generates the convergents of a simple continued fraction.</p>\n<pre><span class=\"n\">contfrac_rat</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">)</span>\n</pre>\n<p>Returns the simple continued fraction of the rational number <tt>n</tt>/<tt>d</tt>.</p>\n<pre><span class=\"n\">ngonal</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Returns the <tt>x</tt><sup>th</sup> <tt>n</tt>-gonal number.  Indexing begins with 1 so that <tt>ngonal(1, n)</tt> = 1 for all applicable <tt>n</tt>.</p>\n<pre><span class=\"n\">is_ngonal</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Checks whether <tt>p</tt> is an <tt>n</tt>-gonal number.</p>\n<pre><span class=\"n\">partitions</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">parts</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n</pre>\n<p>Computes with some semblance of efficiency the number of additive partitions of an integer.  The <tt>parts</tt> argument is for memoization.</p>\n<pre><span class=\"n\">partgen</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Generates partitions of integers in ascending order via an iterative algorithm.  It is the fastest known algorithm as of June 2014.</p>\n<pre><span class=\"n\">partconj</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n</pre>\n<p>Computes the conjugate of a partition.</p>\n<pre><span class=\"n\">farey</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Generates the Farey sequence of maximum denominator <tt>n</tt>.  Includes 0/1 and 1/1.</p>\n<pre><span class=\"n\">fareyneighbors</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n</pre>\n<p>Returns the neighbors of <tt>p</tt>/<tt>q</tt>  in the Farey sequence of maximum denominator <tt>n</tt>.</p>\n<pre><span class=\"n\">ispractical</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>Tests whether <tt>n</tt> is a practical number \u2013 i.e., whether every integer from 1 through <tt>n</tt> (inclusive) can be written as a sum of divisors of <tt>n</tt>.  These are also called panarithmic numbers.</p>\n<pre><span class=\"n\">hamming</span><span class=\"p\">(</span><span class=\"n\">ps</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">ps2</span><span class=\"p\">)</span>\n</pre>\n<p>Generates all <tt>ps</tt>-smooth numbers, where <tt>ps</tt> is a list of primes.</p>\n<pre><span class=\"n\">arithmeticderivative</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n</pre>\n<p>The arithmetic derivative of <tt>n</tt>: if <tt>n</tt> is prime, then <tt>n</tt>\u2019 = 1; if -2 &lt; <tt>n</tt> &lt; 2, then <tt>n</tt>\u2019 = 0; if <tt>n</tt> &lt; 0, then <tt>n</tt>\u2019 = -(-<tt>n</tt>)\u2019; and (<em>ab</em>)\u2019 = <em>a</em>\u2019\u00b7<em>b</em> + <em>b</em>\u2019\u00b7<em>a</em>.</p>\n<pre><span class=\"n\">perfectpowers</span><span class=\"p\">()</span>\n</pre>\n<p>Generates the sequence of perfect powers without multiplicity.</p>\n<pre><span class=\"n\">sqfrgen</span><span class=\"p\">(</span><span class=\"n\">ps</span><span class=\"p\">)</span>\n</pre>\n<p>Generates the squarefree products of the elements of <tt>ps</tt>.</p>\n<pre><span class=\"n\">sqfrgenb</span><span class=\"p\">(</span><span class=\"n\">ps</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">m</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>Generates the squarefree products of elements of <tt>ps</tt>.  Does not yield anything &gt; <tt>b</tt>.  For best performance, <tt>ps</tt> should be sorted in decreasing order.</p>\n<pre><span class=\"n\">stormer</span><span class=\"p\">(</span><span class=\"n\">ps</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">ps2</span><span class=\"p\">,</span> <span class=\"n\">abc</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>St\u00f8rmer\u2019s theorem asserts that for any given set <tt>ps</tt> of prime numbers, there are only finitely many pairs of consecutive integers that are both <tt>ps</tt>-smooth; the theorem also gives an effective algorithm for finding them.  We implement Lenstra\u2019s improvement to this theorem.</p>\n<p>The <tt>abc</tt> argument indicates that we are to assume an effective abc conjecture of the form <em>c</em> &lt; <tt>abc[0]</tt> \u00b7 rad(<em>a</em>\u00b7<em>b</em>\u00b7<em>c</em>)<sup>abc[1]</sup>.  This enables major speedups.  If <tt>abc</tt> is <tt>None</tt>, then we make no such assumptions.</p>\n<pre><span class=\"n\">quadintroots</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">)</span>\n</pre>\n<p>Given integers <tt>a</tt>, <tt>b</tt>, and <tt>c</tt>, we return in a tuple all distinct integers <em>x</em> such that <tt>a</tt>\u00b7<em>x</em><sup>2</sup> + <tt>b</tt>\u00b7<em>x</em> + <tt>c</tt> = 0.  This is primarily a helper function for <tt>cubicintrootsgiven</tt> and <tt>cubicintroots</tt>.</p>\n<pre><span class=\"n\">cubicintrootsgiven</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n</pre>\n<p>Given integers <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, <tt>d</tt>, and <tt>r</tt> such that <tt>a</tt>\u00b7<tt>r</tt><sup>3</sup> + <tt>b</tt>\u00b7<tt>r</tt><sup>2</sup> + <tt>c</tt>\u00b7<tt>r</tt> + <tt>d</tt> = 0, we find the cubic\u2019s other two roots an return in a tuple all distinct integer roots (including <tt>r</tt>).  This is primarily a helper function for <tt>cubicintroots</tt>.</p>\n<pre><span class=\"n\">cubicintroots</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">)</span>\n</pre>\n<p>Given integers <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, <tt>d</tt>, we return in a tuple all distinct integer roots of <tt>a</tt>\u00b7<em>x</em><sup>3</sup> + <tt>b</tt>\u00b7<em>x</em><sup>2</sup> + <tt>c</tt>\u00b7<em>x</em> + <tt>d</tt>.  This is primarily a helper function for <tt>isprime_nm1</tt>.</p>\n<pre><span class=\"n\">isprime_nm1</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">fac</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>The <em>n</em>-1 primality test: given an odd integer <tt>n</tt> &gt; 214 and a fully-factored integer <em>F</em> such that <em>F</em> divides <tt>n</tt>-1 and <em>F</em> &gt; <tt>n</tt><sup>0.3</sup>, we quickly determine without error whether <tt>n</tt> is prime.  If the provided (partial) factorization of <tt>n</tt>-1 is insufficient, we compute the factorization ourselves.</p>\n<pre><span class=\"n\">isprime_np1</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">fac</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>The <em>n</em>+1 primality test: given an odd integer <tt>n</tt> &gt; 214 and a fully-factored integer <em>F</em> such that <em>F</em> divides <tt>n</tt>+1 and <em>F</em> &gt; <tt>n</tt><sup>0.3</sup>, we quickly determine without error whether <tt>n</tt> is prime.  If the provided (partial) factorization of <tt>n</tt>+1 is insufficient, we compute the factorization ourselves.</p>\n<pre><span class=\"n\">mulparts</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">nfac</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>Generates all ordered <tt>r</tt>-tuples of positive integers whose product is <tt>n</tt>.  If <tt>r</tt> is <tt>None</tt>, then we generate all such tuples (regardless of size) that do not contain 1.</p>\n<pre><span class=\"n\">dirconv</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">ffac</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">gfac</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>This returns a function that is the Dirichlet convolution of <tt>f</tt> and <tt>g</tt>.  When called with the keyword arguments at their default values, this is equivalent to the expression <tt>lambda n: sum(f(d) * <span class=\"pre\">g(n//d)</span> for d in divisors(n))</tt>.  If <tt>f</tt> or <tt>g</tt> needs to factor its argument, such as <tt>f == totient</tt> or <tt>g == mobius</tt> or something like that, then that lambda expression calls the factorizer a lot more than it needs to \u2014 we\u2019re already factoring <tt>n</tt>, so instead of feeding those functions the integer forms of <tt>n</tt>\u2019s factors, we can instead pass <tt>ffac=True</tt> or <tt>gfac=True</tt> when <tt>dirconv</tt> is called and we will call <tt>divisors_factored(n)</tt> instead and feed those factored divisors into <tt>f</tt> or <tt>g</tt> as appropriate.  This optimization becomes more noticeable as the factoring becomes more difficult.</p>\n<pre><span class=\"n\">dirichletinverse</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n</pre>\n<p>Computes the Dirichlet inverse of the input function <tt>f</tt>.  Mathematically, functions <em>f</em> such that <em>f</em>(1) = 0 have no Dirichlet inverses due to a division by zero.  This is reflected in this implementation by raising a <tt>ZeroDivisionError</tt> when attempting to evaluate <tt><span class=\"pre\">dirichletinverse(f)(n)</span></tt> for any such <tt>f</tt> and any <tt>n</tt>.  If <tt>f</tt>(1) is neither 1 nor -1, then <tt>dirichletinverse(f)</tt> will return <tt>Fraction</tt> objects (as imported from the <tt>fractions</tt> module).</p>\n<pre><span class=\"n\">dirichletroot</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">val1</span><span class=\"p\">)</span>\n</pre>\n<p>Computes the <tt>r</tt><sup>th</sup> Dirichlet root of the input function <tt>f</tt> whose value at 1 is <tt>val1</tt>.  More precisely, let <tt>f</tt> be a function on the positive integers, let <tt>r</tt> be a positive integer, and let <tt>val1</tt><sup>r</sup> = <tt>f</tt>(1).  Then we return the unique function <tt>g</tt> such that <tt>f</tt> = <tt>g</tt> * <tt>g</tt> * \u2026 * <tt>g</tt>, where <tt>g</tt> appears <tt>r</tt> times and * represents Dirichlet convolution.  The values returned will be <tt>Fraction</tt> objects (as imported from the <tt>fractions</tt> module).</p>\n<pre><span class=\"n\">determinant</span><span class=\"p\">(</span><span class=\"n\">M</span><span class=\"p\">)</span>\n</pre>\n<p>Computes the determinant of a matrix via the Schur determinant identity.</p>\n<pre><span class=\"n\">discriminant</span><span class=\"p\">(</span><span class=\"n\">coefs</span><span class=\"p\">)</span>\n</pre>\n<p>Computes the discriminant of a polynomial.  The input list is ordered from lowest degree to highest \u2014 i.e., <tt>coefs[k]</tt> is the coefficient of the <em>x</em><sup>k</sup> term.  For low-degree polynomials, explicit formulae are used; for degrees 5 and higher, we compute it by taking the determinant (using this package\u2019s determinant() function) of the Sylvester matrix of the input and its derivative.  This in turn is calculated by the Schur determinant identity.  Note that this has the effect of setting the discriminant of a linear polynomial to 1 (which is conventional) and that of a constant to 0.</p>\n<pre><span class=\"n\">egypt_short</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"n\">terms</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">minden</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>Generates all shortest Egyptian fractions for <tt>n</tt>/<tt>d</tt> using at least the indicated number of terms and whose denominators are all \u2265 minden.  No algorithm is known for this problem that significantly improves upon brute force, so this can take impractically long times on even modest-seeming inputs.</p>\n<pre><span class=\"n\">egypt_greedy</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">)</span>\n</pre>\n<p>The greedy algorithm for Egyptian fraction expansion; also called the Fibonacci-Sylvester algorithm.</p>\n<div id=\"dependencies\">\n<h3>Dependencies</h3>\n<p>This package imports items from <tt>multiprocessing</tt>, <tt>itertools</tt>, <tt>fractions</tt>, <tt>random</tt>, <tt>math</tt>, and <tt>heapq</tt>.  These are all in the Python standard library.</p>\n<p>We attempt to import <tt>mpz</tt> from <tt>gmpy2</tt>, but this is purely for efficiency: if this import fails, we simply set <tt>mpz = int</tt>.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4500731, "releases": {"1.0.7": [{"comment_text": "", "digests": {"md5": "3e71cb619688555eeb2219c8eef10871", "sha256": "761b46d330c5e794ee006f809ae08a7500da8f781da678b811f563169aed10fa"}, "downloads": -1, "filename": "labmath-1.0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "3e71cb619688555eeb2219c8eef10871", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 66663, "upload_time": "2018-03-01T22:37:55", "upload_time_iso_8601": "2018-03-01T22:37:55.661539Z", "url": "https://files.pythonhosted.org/packages/70/ad/7792a71775e5fa934e1a7f0e1f234b17e9a968a14b26bcace777e557aa5d/labmath-1.0.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "749f13faa8779b5597607aedad30886b", "sha256": "f519145f1ee7408ce6ecbfac9b06aaba10c7495eae44f4f49cc5124d7fd0e1bf"}, "downloads": -1, "filename": "labmath-1.0.7.tar.gz", "has_sig": false, "md5_digest": "749f13faa8779b5597607aedad30886b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 64937, "upload_time": "2018-03-01T22:37:57", "upload_time_iso_8601": "2018-03-01T22:37:57.397447Z", "url": "https://files.pythonhosted.org/packages/fa/d5/c22a3c4efdcf36c03f5e299ed6b9b1272d63fbb486849be7b607b2b9fe05/labmath-1.0.7.tar.gz", "yanked": false}], "1.0.8": [{"comment_text": "", "digests": {"md5": "7343347dafc2d6f28e7b7e9d637e2ea0", "sha256": "f4bf6b2b2bb9cd274a8a7b4917b3e3f6ad271ff71ec6cd40cb411e4ff8c8a097"}, "downloads": -1, "filename": "labmath-1.0.8-py3-none-any.whl", "has_sig": false, "md5_digest": "7343347dafc2d6f28e7b7e9d637e2ea0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 66476, "upload_time": "2018-03-29T01:16:35", "upload_time_iso_8601": "2018-03-29T01:16:35.086787Z", "url": "https://files.pythonhosted.org/packages/cd/87/65405f2d2bfe8dd65a221abd69803dab80e228084840769251680382c31d/labmath-1.0.8-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a88cd0fc2b8933e718819b69a3991144", "sha256": "2564ad2929d4898a7f93f0687a53f7e4c41009423a2545b26c429e662dacc862"}, "downloads": -1, "filename": "labmath-1.0.8.tar.gz", "has_sig": false, "md5_digest": "a88cd0fc2b8933e718819b69a3991144", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 66097, "upload_time": "2018-03-29T01:16:36", "upload_time_iso_8601": "2018-03-29T01:16:36.863359Z", "url": "https://files.pythonhosted.org/packages/9d/a1/652625c17238831fb0a0de1507f293825bcae1e148a0d2834e8bbcdc0e09/labmath-1.0.8.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "de2c567f7d2e52a5952f2d0349ebd887", "sha256": "8488c6fcf799936c07428ee5702f416558f8c8b38fc1bfee6ca8f014476e007a"}, "downloads": -1, "filename": "labmath-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "de2c567f7d2e52a5952f2d0349ebd887", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 69883, "upload_time": "2018-04-28T02:34:58", "upload_time_iso_8601": "2018-04-28T02:34:58.562275Z", "url": "https://files.pythonhosted.org/packages/4b/e1/30a305fdc97b5773d29f38868a1ec8f2a394ed34a21e87a64702a5b79831/labmath-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8c7be185dfab9cc84d4cd984aa2c89b0", "sha256": "5b48bcd7a20dd7c80349fb5562de1039c5bee17a48e9a5fc2a2a3b88992c0b68"}, "downloads": -1, "filename": "labmath-1.1.0.tar.gz", "has_sig": false, "md5_digest": "8c7be185dfab9cc84d4cd984aa2c89b0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 69716, "upload_time": "2018-04-28T02:35:00", "upload_time_iso_8601": "2018-04-28T02:35:00.474405Z", "url": "https://files.pythonhosted.org/packages/86/32/a8602105cbc82e8ff6e36b681bb76aac2be19d6de7197e8f4dd77ab04cf6/labmath-1.1.0.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "0df08d238a631400b2eb10d93c389c0e", "sha256": "8447d624dc72e9a3f1ef972edcd658eae9194d0fe330d23e0e5de43c68a3592e"}, "downloads": -1, "filename": "labmath-1.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "0df08d238a631400b2eb10d93c389c0e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 77219, "upload_time": "2018-11-18T21:23:30", "upload_time_iso_8601": "2018-11-18T21:23:30.598565Z", "url": "https://files.pythonhosted.org/packages/60/84/f7370af57b855c23c22475e2fefb1de9007892a77465a05efe0034e4a606/labmath-1.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a9a98d31b4a109998fe340c0a0f9ef44", "sha256": "fdf67ad6d27a3d566cb9baf739795b83f571cb22a29b3dfab8f57eaf7de4803d"}, "downloads": -1, "filename": "labmath-1.2.0.tar.gz", "has_sig": false, "md5_digest": "a9a98d31b4a109998fe340c0a0f9ef44", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 77159, "upload_time": "2018-11-18T21:23:32", "upload_time_iso_8601": "2018-11-18T21:23:32.843903Z", "url": "https://files.pythonhosted.org/packages/3d/ce/11a92988f04d645b82cf1789334149d7532ed263f78fbfb41dc37e85bf25/labmath-1.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0df08d238a631400b2eb10d93c389c0e", "sha256": "8447d624dc72e9a3f1ef972edcd658eae9194d0fe330d23e0e5de43c68a3592e"}, "downloads": -1, "filename": "labmath-1.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "0df08d238a631400b2eb10d93c389c0e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 77219, "upload_time": "2018-11-18T21:23:30", "upload_time_iso_8601": "2018-11-18T21:23:30.598565Z", "url": "https://files.pythonhosted.org/packages/60/84/f7370af57b855c23c22475e2fefb1de9007892a77465a05efe0034e4a606/labmath-1.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a9a98d31b4a109998fe340c0a0f9ef44", "sha256": "fdf67ad6d27a3d566cb9baf739795b83f571cb22a29b3dfab8f57eaf7de4803d"}, "downloads": -1, "filename": "labmath-1.2.0.tar.gz", "has_sig": false, "md5_digest": "a9a98d31b4a109998fe340c0a0f9ef44", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 77159, "upload_time": "2018-11-18T21:23:32", "upload_time_iso_8601": "2018-11-18T21:23:32.843903Z", "url": "https://files.pythonhosted.org/packages/3d/ce/11a92988f04d645b82cf1789334149d7532ed263f78fbfb41dc37e85bf25/labmath-1.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:48:20 2020"}