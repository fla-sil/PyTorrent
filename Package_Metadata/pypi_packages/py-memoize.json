{"info": {"author": "Michal Zmuda", "author_email": "zmu.michal@gmail.com", "bugtrack_url": null, "classifiers": ["Framework :: AsyncIO", "Intended Audience :: Developers", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: 3 :: Only", "Topic :: Software Development :: Libraries"], "description": ".. image:: https://img.shields.io/pypi/v/py-memoize.svg\n    :target: https://pypi.org/project/py-memoize\n\n.. image:: https://img.shields.io/pypi/pyversions/py-memoize.svg\n    :target: https://pypi.org/project/py-memoize\n\n.. image:: https://readthedocs.org/projects/memoize/badge/?version=latest\n    :target: https://memoize.readthedocs.io/en/latest/?badge=latest\n\n.. image:: https://travis-ci.com/DreamLab/memoize.svg?token=PCPPzZaRDc9FFFUfKaj9&branch=master\n    :target: https://travis-ci.com/DreamLab/memoize\n\nExtended docs (including API docs) available at `memoize.readthedocs.io <https://memoize.readthedocs.io>`_.\n\nWhat & Why\n==========\n\n**What:** Caching library for asynchronous Python applications.\n\n**Why:** Python deserves library that works in async world\n(for instance handles `dog-piling <https://en.wikipedia.org/wiki/Cache_stampede>`_ )\nand has a proper, extensible API.\n\nEtymology\n=========\n\n*In computing, memoization or memoisation is an optimization technique\nused primarily to speed up computer programs by storing the results of\nexpensive function calls and returning the cached result when the same\ninputs occur again. (\u2026) The term \u201cmemoization\u201d was coined by Donald\nMichie in 1968 and is derived from the Latin word \u201cmemorandum\u201d (\u201cto be\nremembered\u201d), usually truncated as \u201cmemo\u201d in the English language, and\nthus carries the meaning of \u201cturning [the results of] a function into\nsomething to be remembered.\u201d*\n~ `Wikipedia <https://en.wikipedia.org/wiki/Memoization>`_\n\nGetting Started\n===============\n\nInstallation\n------------\n\nBasic Installation\n~~~~~~~~~~~~~~~~~~\n\nTo get you up & running all you need is to install:\n\n.. code-block:: bash\n\n   pip install py-memoize\n\nInstallation of Extras\n~~~~~~~~~~~~~~~~~~~~~~\n\nIf you are going to use ``memoize`` with tornado add a dependency on extra:\n\n.. code-block:: bash\n\n   pip install py-memoize[tornado]\n\nTo harness the power of `ujson <https://pypi.org/project/ujson/>`_ (if JSON SerDe is used) install extra:\n\n.. code-block:: bash\n\n   pip install py-memoize[ujson]\n\nUsage\n-----\n\nProvided examples use default configuration to cache results in memory.\nFor configuration options see `Configurability`_.\n\nYou can use ``memoize`` with both `asyncio <https://docs.python.org/3/library/asyncio.html>`_\nand `Tornado <https://github.com/tornadoweb/tornado>`_ -  please see the appropriate example:\n\nasyncio\n~~~~~~~\n\nTo apply default caching configuration use:\n\n\n.. code-block:: python\n\n    import asyncio\n    import random\n    from memoize.wrapper import memoize\n\n\n    @memoize()\n    async def expensive_computation():\n        return 'expensive-computation-' + str(random.randint(1, 100))\n\n\n    async def main():\n        print(await expensive_computation())\n        print(await expensive_computation())\n        print(await expensive_computation())\n\n\n    if __name__ == \"__main__\":\n        asyncio.get_event_loop().run_until_complete(main())\n\n\nTornado\n~~~~~~~\n\nIf your project is based on Tornado use:\n\n.. code-block:: python\n\n    import random\n\n    from tornado import gen\n    from tornado.ioloop import IOLoop\n\n    from memoize.wrapper import memoize\n\n\n    @memoize()\n    @gen.coroutine\n    def expensive_computation():\n        return 'expensive-computation-' + str(random.randint(1, 100))\n\n\n    @gen.coroutine\n    def main():\n        result1 = yield expensive_computation()\n        print(result1)\n        result2 = yield expensive_computation()\n        print(result2)\n        result3 = yield expensive_computation()\n        print(result3)\n\n\n    if __name__ == \"__main__\":\n        IOLoop.current().run_sync(main)\n\n\n\nFeatures\n========\n\nAsync-first\n-----------\n\nAsynchronous programming is often seen as a huge performance boost in python programming.\nBut with all the benefits it brings there are also new concurrency-related caveats\nlike `dog-piling <https://en.wikipedia.org/wiki/Cache_stampede>`_.\n\nThis library is built async-oriented from the ground-up, what manifests in, for example,\nin `Dog-piling proofness`_ or `Async cache storage`_.\n\n\nTornado & asyncio support\n-------------------------\n\nNo matter what are you using, build-in `asyncio <https://docs.python.org/3/library/asyncio.html>`_\nor its predecessor `Tornado <https://github.com/tornadoweb/tornado>`_\n*memoize* has you covered as you can use it with both.\n**This may come handy if you are planning a migration from Tornado to asyncio.**\n\nUnder the hood *memoize* detects if you are using *Tornado* or *asyncio*\n(by checking if *Tornado* is installed and available to import).\n\nIf have *Tornado* installed but your application uses *asyncio* IO-loop,\nset ``MEMOIZE_FORCE_ASYNCIO=1`` environment variable to force using *asyncio* and ignore *Tornado* instalation.\n\n\nConfigurability\n---------------\n\nWith *memoize* you have under control:\n\n* timeout applied to the cached method;\n* key generation strategy (see `memoize.key.KeyExtractor`);\n  already provided strategies use arguments (both positional & keyword) and method name (or reference);\n* storage for cached entries/items (see `memoize.storage.CacheStorage`);\n  in-memory storage is already provided;\n  for convenience of implementing new storage adapters some SerDe (`memoize.serde.SerDe`) are provided;\n* eviction strategy (see `memoize.eviction.EvictionStrategy`);\n  least-recently-updated strategy is already provided;\n* entry builder (see `memoize.entrybuilder.CacheEntryBuilder`)\n  which has control over ``update_after``  & ``expires_after`` described in `Tunable eviction & async refreshing`_\n\nAll of these elements are open for extension (you can implement and plug-in your own).\nPlease contribute!\n\nExample how to customize default config (everything gets overridden):\n\n.. code-block:: python\n\n    from datetime import timedelta\n\n    from memoize.configuration import MutableCacheConfiguration, DefaultInMemoryCacheConfiguration\n    from memoize.entrybuilder import ProvidedLifeSpanCacheEntryBuilder\n    from memoize.eviction import LeastRecentlyUpdatedEvictionStrategy\n    from memoize.key import EncodedMethodNameAndArgsKeyExtractor\n    from memoize.storage import LocalInMemoryCacheStorage\n    from memoize.wrapper import memoize\n\n\n    @memoize(configuration=MutableCacheConfiguration\n             .initialized_with(DefaultInMemoryCacheConfiguration())\n             .set_method_timeout(value=timedelta(minutes=2))\n             .set_entry_builder(ProvidedLifeSpanCacheEntryBuilder(update_after=timedelta(minutes=2),\n                                                                  expire_after=timedelta(minutes=5)))\n             .set_eviction_strategy(LeastRecentlyUpdatedEvictionStrategy(capacity=2048))\n             .set_key_extractor(EncodedMethodNameAndArgsKeyExtractor(skip_first_arg_as_self=False))\n             .set_storage(LocalInMemoryCacheStorage())\n             )\n    async def cached():\n        return 'dummy'\n\n\nStill, you can use default configuration which:\n\n* sets timeout for underlying method to 2 minutes;\n* uses in-memory storage;\n* uses method instance & arguments to infer cache key;\n* stores up to 4096 elements in cache and evicts entries according to least recently updated policy;\n* refreshes elements after 10 minutes & ignores unrefreshed elements after 30 minutes.\n\nIf that satisfies you, just use default config:\n\n.. code-block:: python\n\n    from memoize.configuration import DefaultInMemoryCacheConfiguration\n    from memoize.wrapper import memoize\n\n\n    @memoize(configuration=DefaultInMemoryCacheConfiguration())\n    async def cached():\n        return 'dummy'\n\n\nTunable eviction & async refreshing\n-----------------------------------\n\nSometimes caching libraries allow providing TTL only. This may result in a scenario where when the cache entry expires\nlatency is increased as the new value needs to be recomputed.\nTo mitigate this periodic extra latency multiple delays are often used. In the case of *memoize* there are two\n(see `memoize.entrybuilder.ProvidedLifeSpanCacheEntryBuilder`):\n\n* ``update_after`` defines delay after which background/async update is executed;\n* ``expire_after`` defines delay after which entry is considered outdated and invalid.\n\nThis allows refreshing cached value in the background without any observable latency.\nMoreover, if some of those background refreshes fail they will be retried still in the background.\nDue to this beneficial feature, it is recommended to ``update_after`` be significantly shorter than ``expire_after``.\n\nDog-piling proofness\n--------------------\n\nIf some resource is accessed asynchronously `dog-piling <https://en.wikipedia.org/wiki/Cache_stampede>`_ may occur.\nCaches designed for synchronous python code\n(like built-in `LRU <https://docs.python.org/3.3/library/functools.html#lru_cache>`_)\nwill allow multiple concurrent tasks to observe a miss for the same resource and will proceed to flood underlying/cached\nbackend with requests for the same resource.\n\n\nAs it breaks the purpose of caching (as backend effectively sometimes is not protected with cache)\n*memoize* has built-in dog-piling protection.\n\nUnder the hood, concurrent requests for the same resource (cache key) get collapsed to a single request to the backend.\nWhen the resource is fetched all requesters obtain the result.\nOn failure, all requesters get an exception (same happens on timeout).\n\nAn example of what it all is about:\n\n.. code-block:: python\n\n    import asyncio\n    from datetime import timedelta\n\n    from aiocache import cached, SimpleMemoryCache  # version 0.11.1 (latest) used as example of other cache implementation\n\n    from memoize.configuration import MutableCacheConfiguration, DefaultInMemoryCacheConfiguration\n    from memoize.entrybuilder import ProvidedLifeSpanCacheEntryBuilder\n    from memoize.wrapper import memoize\n\n    # scenario configuration\n    concurrent_requests = 5\n    request_batches_execution_count = 50\n    cached_value_ttl_millis = 200\n    delay_between_request_batches_millis = 70\n\n    # results/statistics\n    unique_calls_under_memoize = 0\n    unique_calls_under_different_cache = 0\n\n\n    @memoize(configuration=MutableCacheConfiguration\n        .initialized_with(DefaultInMemoryCacheConfiguration())\n        .set_entry_builder(\n            ProvidedLifeSpanCacheEntryBuilder(update_after=timedelta(milliseconds=cached_value_ttl_millis))\n        ))\n    async def cached_with_memoize():\n        global unique_calls_under_memoize\n        unique_calls_under_memoize += 1\n        await asyncio.sleep(0.01)\n        return unique_calls_under_memoize\n\n\n    @cached(ttl=cached_value_ttl_millis / 1000, cache=SimpleMemoryCache)\n    async def cached_with_different_cache():\n        global unique_calls_under_different_cache\n        unique_calls_under_different_cache += 1\n        await asyncio.sleep(0.01)\n        return unique_calls_under_different_cache\n\n\n    async def main():\n        for i in range(request_batches_execution_count):\n            await asyncio.gather(*[x() for x in [cached_with_memoize] * concurrent_requests])\n            await asyncio.gather(*[x() for x in [cached_with_different_cache] * concurrent_requests])\n            await asyncio.sleep(delay_between_request_batches_millis / 1000)\n\n        print(\"Memoize generated {} unique backend calls\".format(unique_calls_under_memoize))\n        print(\"Other cache generated {} unique backend calls\".format(unique_calls_under_different_cache))\n        predicted = (delay_between_request_batches_millis * request_batches_execution_count) // cached_value_ttl_millis\n        print(\"Predicted (according to TTL) {} unique backend calls\".format(predicted))\n\n        # Printed:\n        # Memoize generated 17 unique backend calls\n        # Other cache generated 85 unique backend calls\n        # Predicted (according to TTL) 17 unique backend calls\n\n    if __name__ == \"__main__\":\n        asyncio.get_event_loop().run_until_complete(main())\n\n\nAsync cache storage\n-------------------\n\nInterface for cache storage allows you to fully harness benefits of asynchronous programming\n(see interface of `memoize.storage.CacheStorage`).\n\n\nCurrently *memoize* provides only in-memory storage for cache values (internally at *RASP* we have others).\nIf you want (for instance) Redis integration, you need to implement one (please contribute!)\nbut *memoize* will optimally use your async implementation from the start.\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/DreamLab/memoize", "keywords": "python cache tornado asyncio", "license": "Apache License 2.0", "maintainer": "DreamLab", "maintainer_email": "", "name": "py-memoize", "package_url": "https://pypi.org/project/py-memoize/", "platform": "Any", "project_url": "https://pypi.org/project/py-memoize/", "project_urls": {"Homepage": "https://github.com/DreamLab/memoize"}, "release_url": "https://pypi.org/project/py-memoize/1.0.3/", "requires_dist": ["tornado (<5,>4) ; extra == 'tornado'", "ujson (<2,>=1.35) ; extra == 'ujson'"], "requires_python": "", "summary": "Caching library for asynchronous Python applications (both based on asyncio and Tornado) that handles dogpiling properly and provides a configurable & extensible API.", "version": "1.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://pypi.org/project/py-memoize\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/py-memoize.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e962d0b99aa2d99bc42927f36c6e565bef52e498/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f70792d6d656d6f697a652e737667\"></a>\n<a href=\"https://pypi.org/project/py-memoize\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/pyversions/py-memoize.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c6e2aa1c008875b98ef77aca0783eb9c3948b9a5/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f70792d6d656d6f697a652e737667\"></a>\n<a href=\"https://memoize.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"https://readthedocs.org/projects/memoize/badge/?version=latest\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/37d5d0cb46762fdf5b01b1c80b7ad41d8d12e040/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f6d656d6f697a652f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<a href=\"https://travis-ci.com/DreamLab/memoize\" rel=\"nofollow\"><img alt=\"https://travis-ci.com/DreamLab/memoize.svg?token=PCPPzZaRDc9FFFUfKaj9&amp;branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/37739e81bcaaa9e3e29213e9bb2cb81ee3fca7f0/68747470733a2f2f7472617669732d63692e636f6d2f447265616d4c61622f6d656d6f697a652e7376673f746f6b656e3d504350507a5a615244633946464655664b616a39266272616e63683d6d6173746572\"></a>\n<p>Extended docs (including API docs) available at <a href=\"https://memoize.readthedocs.io\" rel=\"nofollow\">memoize.readthedocs.io</a>.</p>\n<div id=\"what-why\">\n<h2>What &amp; Why</h2>\n<p><strong>What:</strong> Caching library for asynchronous Python applications.</p>\n<p><strong>Why:</strong> Python deserves library that works in async world\n(for instance handles <a href=\"https://en.wikipedia.org/wiki/Cache_stampede\" rel=\"nofollow\">dog-piling</a> )\nand has a proper, extensible API.</p>\n</div>\n<div id=\"etymology\">\n<h2>Etymology</h2>\n<p><em>In computing, memoization or memoisation is an optimization technique\nused primarily to speed up computer programs by storing the results of\nexpensive function calls and returning the cached result when the same\ninputs occur again. (\u2026) The term \u201cmemoization\u201d was coined by Donald\nMichie in 1968 and is derived from the Latin word \u201cmemorandum\u201d (\u201cto be\nremembered\u201d), usually truncated as \u201cmemo\u201d in the English language, and\nthus carries the meaning of \u201cturning [the results of] a function into\nsomething to be remembered.\u201d</em>\n~ <a href=\"https://en.wikipedia.org/wiki/Memoization\" rel=\"nofollow\">Wikipedia</a></p>\n</div>\n<div id=\"getting-started\">\n<h2>Getting Started</h2>\n<div id=\"installation\">\n<h3>Installation</h3>\n<div id=\"basic-installation\">\n<h4>Basic Installation</h4>\n<p>To get you up &amp; running all you need is to install:</p>\n<pre>pip install py-memoize\n</pre>\n</div>\n<div id=\"installation-of-extras\">\n<h4>Installation of Extras</h4>\n<p>If you are going to use <tt>memoize</tt> with tornado add a dependency on extra:</p>\n<pre>pip install py-memoize<span class=\"o\">[</span>tornado<span class=\"o\">]</span>\n</pre>\n<p>To harness the power of <a href=\"https://pypi.org/project/ujson/\" rel=\"nofollow\">ujson</a> (if JSON SerDe is used) install extra:</p>\n<pre>pip install py-memoize<span class=\"o\">[</span>ujson<span class=\"o\">]</span>\n</pre>\n</div>\n</div>\n<div id=\"usage\">\n<h3>Usage</h3>\n<p>Provided examples use default configuration to cache results in memory.\nFor configuration options see <a href=\"#configurability\" rel=\"nofollow\">Configurability</a>.</p>\n<p>You can use <tt>memoize</tt> with both <a href=\"https://docs.python.org/3/library/asyncio.html\" rel=\"nofollow\">asyncio</a>\nand <a href=\"https://github.com/tornadoweb/tornado\" rel=\"nofollow\">Tornado</a> -  please see the appropriate example:</p>\n<div id=\"id1\">\n<h4>asyncio</h4>\n<p>To apply default caching configuration use:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">import</span> <span class=\"nn\">random</span>\n<span class=\"kn\">from</span> <span class=\"nn\">memoize.wrapper</span> <span class=\"kn\">import</span> <span class=\"n\">memoize</span>\n\n\n<span class=\"nd\">@memoize</span><span class=\"p\">()</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">expensive_computation</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"s1\">'expensive-computation-'</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">))</span>\n\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"k\">await</span> <span class=\"n\">expensive_computation</span><span class=\"p\">())</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"k\">await</span> <span class=\"n\">expensive_computation</span><span class=\"p\">())</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"k\">await</span> <span class=\"n\">expensive_computation</span><span class=\"p\">())</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">get_event_loop</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">run_until_complete</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n</div>\n<div id=\"id2\">\n<h4>Tornado</h4>\n<p>If your project is based on Tornado use:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">random</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">tornado</span> <span class=\"kn\">import</span> <span class=\"n\">gen</span>\n<span class=\"kn\">from</span> <span class=\"nn\">tornado.ioloop</span> <span class=\"kn\">import</span> <span class=\"n\">IOLoop</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">memoize.wrapper</span> <span class=\"kn\">import</span> <span class=\"n\">memoize</span>\n\n\n<span class=\"nd\">@memoize</span><span class=\"p\">()</span>\n<span class=\"nd\">@gen</span><span class=\"o\">.</span><span class=\"n\">coroutine</span>\n<span class=\"k\">def</span> <span class=\"nf\">expensive_computation</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"s1\">'expensive-computation-'</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">))</span>\n\n\n<span class=\"nd\">@gen</span><span class=\"o\">.</span><span class=\"n\">coroutine</span>\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">result1</span> <span class=\"o\">=</span> <span class=\"k\">yield</span> <span class=\"n\">expensive_computation</span><span class=\"p\">()</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result1</span><span class=\"p\">)</span>\n    <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"k\">yield</span> <span class=\"n\">expensive_computation</span><span class=\"p\">()</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result2</span><span class=\"p\">)</span>\n    <span class=\"n\">result3</span> <span class=\"o\">=</span> <span class=\"k\">yield</span> <span class=\"n\">expensive_computation</span><span class=\"p\">()</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result3</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">IOLoop</span><span class=\"o\">.</span><span class=\"n\">current</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">run_sync</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n</div>\n<div id=\"features\">\n<h2>Features</h2>\n<div id=\"async-first\">\n<h3>Async-first</h3>\n<p>Asynchronous programming is often seen as a huge performance boost in python programming.\nBut with all the benefits it brings there are also new concurrency-related caveats\nlike <a href=\"https://en.wikipedia.org/wiki/Cache_stampede\" rel=\"nofollow\">dog-piling</a>.</p>\n<p>This library is built async-oriented from the ground-up, what manifests in, for example,\nin <a href=\"#dog-piling-proofness\" rel=\"nofollow\">Dog-piling proofness</a> or <a href=\"#async-cache-storage\" rel=\"nofollow\">Async cache storage</a>.</p>\n</div>\n<div id=\"tornado-asyncio-support\">\n<h3>Tornado &amp; asyncio support</h3>\n<p>No matter what are you using, build-in <a href=\"https://docs.python.org/3/library/asyncio.html\" rel=\"nofollow\">asyncio</a>\nor its predecessor <a href=\"https://github.com/tornadoweb/tornado\" rel=\"nofollow\">Tornado</a>\n<em>memoize</em> has you covered as you can use it with both.\n<strong>This may come handy if you are planning a migration from Tornado to asyncio.</strong></p>\n<p>Under the hood <em>memoize</em> detects if you are using <em>Tornado</em> or <em>asyncio</em>\n(by checking if <em>Tornado</em> is installed and available to import).</p>\n<p>If have <em>Tornado</em> installed but your application uses <em>asyncio</em> IO-loop,\nset <tt>MEMOIZE_FORCE_ASYNCIO=1</tt> environment variable to force using <em>asyncio</em> and ignore <em>Tornado</em> instalation.</p>\n</div>\n<div id=\"configurability\">\n<h3>Configurability</h3>\n<p>With <em>memoize</em> you have under control:</p>\n<ul>\n<li>timeout applied to the cached method;</li>\n<li>key generation strategy (see <cite>memoize.key.KeyExtractor</cite>);\nalready provided strategies use arguments (both positional &amp; keyword) and method name (or reference);</li>\n<li>storage for cached entries/items (see <cite>memoize.storage.CacheStorage</cite>);\nin-memory storage is already provided;\nfor convenience of implementing new storage adapters some SerDe (<cite>memoize.serde.SerDe</cite>) are provided;</li>\n<li>eviction strategy (see <cite>memoize.eviction.EvictionStrategy</cite>);\nleast-recently-updated strategy is already provided;</li>\n<li>entry builder (see <cite>memoize.entrybuilder.CacheEntryBuilder</cite>)\nwhich has control over <tt>update_after</tt>  &amp; <tt>expires_after</tt> described in <a href=\"#tunable-eviction-async-refreshing\" rel=\"nofollow\">Tunable eviction &amp; async refreshing</a></li>\n</ul>\n<p>All of these elements are open for extension (you can implement and plug-in your own).\nPlease contribute!</p>\n<p>Example how to customize default config (everything gets overridden):</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">datetime</span> <span class=\"kn\">import</span> <span class=\"n\">timedelta</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">memoize.configuration</span> <span class=\"kn\">import</span> <span class=\"n\">MutableCacheConfiguration</span><span class=\"p\">,</span> <span class=\"n\">DefaultInMemoryCacheConfiguration</span>\n<span class=\"kn\">from</span> <span class=\"nn\">memoize.entrybuilder</span> <span class=\"kn\">import</span> <span class=\"n\">ProvidedLifeSpanCacheEntryBuilder</span>\n<span class=\"kn\">from</span> <span class=\"nn\">memoize.eviction</span> <span class=\"kn\">import</span> <span class=\"n\">LeastRecentlyUpdatedEvictionStrategy</span>\n<span class=\"kn\">from</span> <span class=\"nn\">memoize.key</span> <span class=\"kn\">import</span> <span class=\"n\">EncodedMethodNameAndArgsKeyExtractor</span>\n<span class=\"kn\">from</span> <span class=\"nn\">memoize.storage</span> <span class=\"kn\">import</span> <span class=\"n\">LocalInMemoryCacheStorage</span>\n<span class=\"kn\">from</span> <span class=\"nn\">memoize.wrapper</span> <span class=\"kn\">import</span> <span class=\"n\">memoize</span>\n\n\n<span class=\"nd\">@memoize</span><span class=\"p\">(</span><span class=\"n\">configuration</span><span class=\"o\">=</span><span class=\"n\">MutableCacheConfiguration</span>\n         <span class=\"o\">.</span><span class=\"n\">initialized_with</span><span class=\"p\">(</span><span class=\"n\">DefaultInMemoryCacheConfiguration</span><span class=\"p\">())</span>\n         <span class=\"o\">.</span><span class=\"n\">set_method_timeout</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">minutes</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n         <span class=\"o\">.</span><span class=\"n\">set_entry_builder</span><span class=\"p\">(</span><span class=\"n\">ProvidedLifeSpanCacheEntryBuilder</span><span class=\"p\">(</span><span class=\"n\">update_after</span><span class=\"o\">=</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">minutes</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">),</span>\n                                                              <span class=\"n\">expire_after</span><span class=\"o\">=</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">minutes</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)))</span>\n         <span class=\"o\">.</span><span class=\"n\">set_eviction_strategy</span><span class=\"p\">(</span><span class=\"n\">LeastRecentlyUpdatedEvictionStrategy</span><span class=\"p\">(</span><span class=\"n\">capacity</span><span class=\"o\">=</span><span class=\"mi\">2048</span><span class=\"p\">))</span>\n         <span class=\"o\">.</span><span class=\"n\">set_key_extractor</span><span class=\"p\">(</span><span class=\"n\">EncodedMethodNameAndArgsKeyExtractor</span><span class=\"p\">(</span><span class=\"n\">skip_first_arg_as_self</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">))</span>\n         <span class=\"o\">.</span><span class=\"n\">set_storage</span><span class=\"p\">(</span><span class=\"n\">LocalInMemoryCacheStorage</span><span class=\"p\">())</span>\n         <span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">cached</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"s1\">'dummy'</span>\n</pre>\n<p>Still, you can use default configuration which:</p>\n<ul>\n<li>sets timeout for underlying method to 2 minutes;</li>\n<li>uses in-memory storage;</li>\n<li>uses method instance &amp; arguments to infer cache key;</li>\n<li>stores up to 4096 elements in cache and evicts entries according to least recently updated policy;</li>\n<li>refreshes elements after 10 minutes &amp; ignores unrefreshed elements after 30 minutes.</li>\n</ul>\n<p>If that satisfies you, just use default config:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">memoize.configuration</span> <span class=\"kn\">import</span> <span class=\"n\">DefaultInMemoryCacheConfiguration</span>\n<span class=\"kn\">from</span> <span class=\"nn\">memoize.wrapper</span> <span class=\"kn\">import</span> <span class=\"n\">memoize</span>\n\n\n<span class=\"nd\">@memoize</span><span class=\"p\">(</span><span class=\"n\">configuration</span><span class=\"o\">=</span><span class=\"n\">DefaultInMemoryCacheConfiguration</span><span class=\"p\">())</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">cached</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"s1\">'dummy'</span>\n</pre>\n</div>\n<div id=\"tunable-eviction-async-refreshing\">\n<h3>Tunable eviction &amp; async refreshing</h3>\n<p>Sometimes caching libraries allow providing TTL only. This may result in a scenario where when the cache entry expires\nlatency is increased as the new value needs to be recomputed.\nTo mitigate this periodic extra latency multiple delays are often used. In the case of <em>memoize</em> there are two\n(see <cite>memoize.entrybuilder.ProvidedLifeSpanCacheEntryBuilder</cite>):</p>\n<ul>\n<li><tt>update_after</tt> defines delay after which background/async update is executed;</li>\n<li><tt>expire_after</tt> defines delay after which entry is considered outdated and invalid.</li>\n</ul>\n<p>This allows refreshing cached value in the background without any observable latency.\nMoreover, if some of those background refreshes fail they will be retried still in the background.\nDue to this beneficial feature, it is recommended to <tt>update_after</tt> be significantly shorter than <tt>expire_after</tt>.</p>\n</div>\n<div id=\"dog-piling-proofness\">\n<h3>Dog-piling proofness</h3>\n<p>If some resource is accessed asynchronously <a href=\"https://en.wikipedia.org/wiki/Cache_stampede\" rel=\"nofollow\">dog-piling</a> may occur.\nCaches designed for synchronous python code\n(like built-in <a href=\"https://docs.python.org/3.3/library/functools.html#lru_cache\" rel=\"nofollow\">LRU</a>)\nwill allow multiple concurrent tasks to observe a miss for the same resource and will proceed to flood underlying/cached\nbackend with requests for the same resource.</p>\n<p>As it breaks the purpose of caching (as backend effectively sometimes is not protected with cache)\n<em>memoize</em> has built-in dog-piling protection.</p>\n<p>Under the hood, concurrent requests for the same resource (cache key) get collapsed to a single request to the backend.\nWhen the resource is fetched all requesters obtain the result.\nOn failure, all requesters get an exception (same happens on timeout).</p>\n<p>An example of what it all is about:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">from</span> <span class=\"nn\">datetime</span> <span class=\"kn\">import</span> <span class=\"n\">timedelta</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">aiocache</span> <span class=\"kn\">import</span> <span class=\"n\">cached</span><span class=\"p\">,</span> <span class=\"n\">SimpleMemoryCache</span>  <span class=\"c1\"># version 0.11.1 (latest) used as example of other cache implementation</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">memoize.configuration</span> <span class=\"kn\">import</span> <span class=\"n\">MutableCacheConfiguration</span><span class=\"p\">,</span> <span class=\"n\">DefaultInMemoryCacheConfiguration</span>\n<span class=\"kn\">from</span> <span class=\"nn\">memoize.entrybuilder</span> <span class=\"kn\">import</span> <span class=\"n\">ProvidedLifeSpanCacheEntryBuilder</span>\n<span class=\"kn\">from</span> <span class=\"nn\">memoize.wrapper</span> <span class=\"kn\">import</span> <span class=\"n\">memoize</span>\n\n<span class=\"c1\"># scenario configuration</span>\n<span class=\"n\">concurrent_requests</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>\n<span class=\"n\">request_batches_execution_count</span> <span class=\"o\">=</span> <span class=\"mi\">50</span>\n<span class=\"n\">cached_value_ttl_millis</span> <span class=\"o\">=</span> <span class=\"mi\">200</span>\n<span class=\"n\">delay_between_request_batches_millis</span> <span class=\"o\">=</span> <span class=\"mi\">70</span>\n\n<span class=\"c1\"># results/statistics</span>\n<span class=\"n\">unique_calls_under_memoize</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">unique_calls_under_different_cache</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n\n<span class=\"nd\">@memoize</span><span class=\"p\">(</span><span class=\"n\">configuration</span><span class=\"o\">=</span><span class=\"n\">MutableCacheConfiguration</span>\n    <span class=\"o\">.</span><span class=\"n\">initialized_with</span><span class=\"p\">(</span><span class=\"n\">DefaultInMemoryCacheConfiguration</span><span class=\"p\">())</span>\n    <span class=\"o\">.</span><span class=\"n\">set_entry_builder</span><span class=\"p\">(</span>\n        <span class=\"n\">ProvidedLifeSpanCacheEntryBuilder</span><span class=\"p\">(</span><span class=\"n\">update_after</span><span class=\"o\">=</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">milliseconds</span><span class=\"o\">=</span><span class=\"n\">cached_value_ttl_millis</span><span class=\"p\">))</span>\n    <span class=\"p\">))</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">cached_with_memoize</span><span class=\"p\">():</span>\n    <span class=\"k\">global</span> <span class=\"n\">unique_calls_under_memoize</span>\n    <span class=\"n\">unique_calls_under_memoize</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">0.01</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">unique_calls_under_memoize</span>\n\n\n<span class=\"nd\">@cached</span><span class=\"p\">(</span><span class=\"n\">ttl</span><span class=\"o\">=</span><span class=\"n\">cached_value_ttl_millis</span> <span class=\"o\">/</span> <span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"n\">cache</span><span class=\"o\">=</span><span class=\"n\">SimpleMemoryCache</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">cached_with_different_cache</span><span class=\"p\">():</span>\n    <span class=\"k\">global</span> <span class=\"n\">unique_calls_under_different_cache</span>\n    <span class=\"n\">unique_calls_under_different_cache</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">0.01</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">unique_calls_under_different_cache</span>\n\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">request_batches_execution_count</span><span class=\"p\">):</span>\n        <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">gather</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">()</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"n\">cached_with_memoize</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">concurrent_requests</span><span class=\"p\">])</span>\n        <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">gather</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">[</span><span class=\"n\">x</span><span class=\"p\">()</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"p\">[</span><span class=\"n\">cached_with_different_cache</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">concurrent_requests</span><span class=\"p\">])</span>\n        <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"n\">delay_between_request_batches_millis</span> <span class=\"o\">/</span> <span class=\"mi\">1000</span><span class=\"p\">)</span>\n\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Memoize generated </span><span class=\"si\">{}</span><span class=\"s2\"> unique backend calls\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">unique_calls_under_memoize</span><span class=\"p\">))</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Other cache generated </span><span class=\"si\">{}</span><span class=\"s2\"> unique backend calls\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">unique_calls_under_different_cache</span><span class=\"p\">))</span>\n    <span class=\"n\">predicted</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">delay_between_request_batches_millis</span> <span class=\"o\">*</span> <span class=\"n\">request_batches_execution_count</span><span class=\"p\">)</span> <span class=\"o\">//</span> <span class=\"n\">cached_value_ttl_millis</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Predicted (according to TTL) </span><span class=\"si\">{}</span><span class=\"s2\"> unique backend calls\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">predicted</span><span class=\"p\">))</span>\n\n    <span class=\"c1\"># Printed:</span>\n    <span class=\"c1\"># Memoize generated 17 unique backend calls</span>\n    <span class=\"c1\"># Other cache generated 85 unique backend calls</span>\n    <span class=\"c1\"># Predicted (according to TTL) 17 unique backend calls</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">get_event_loop</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">run_until_complete</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n</div>\n<div id=\"async-cache-storage\">\n<h3>Async cache storage</h3>\n<p>Interface for cache storage allows you to fully harness benefits of asynchronous programming\n(see interface of <cite>memoize.storage.CacheStorage</cite>).</p>\n<p>Currently <em>memoize</em> provides only in-memory storage for cache values (internally at <em>RASP</em> we have others).\nIf you want (for instance) Redis integration, you need to implement one (please contribute!)\nbut <em>memoize</em> will optimally use your async implementation from the start.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6525769, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "76152f9ea69889a977af6e78e05a91f4", "sha256": "c7851814684e1295fb45b2fd7e18dd95d222dff7fd892efad96eb819954bd915"}, "downloads": -1, "filename": "py_memoize-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "76152f9ea69889a977af6e78e05a91f4", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21028, "upload_time": "2019-06-03T13:29:20", "upload_time_iso_8601": "2019-06-03T13:29:20.453421Z", "url": "https://files.pythonhosted.org/packages/b9/4f/5a9674ab1d0c084516eaae3dedc2466aeff89282d4f343a578eb5dd62c40/py_memoize-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "de13d9412e2d2d0daa5a69fa308e9a01", "sha256": "9baa78a6fd7c3ce2cc33a551660f3cf7f6eb7442ee41de698ae531d4826c059a"}, "downloads": -1, "filename": "py-memoize-1.0.0.tar.gz", "has_sig": false, "md5_digest": "de13d9412e2d2d0daa5a69fa308e9a01", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17280, "upload_time": "2019-06-03T13:29:22", "upload_time_iso_8601": "2019-06-03T13:29:22.974475Z", "url": "https://files.pythonhosted.org/packages/9c/97/9c8c4fe5780623c305ada2cbb7a28b7258c24c532ff546a31fb50a240025/py-memoize-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "3abb4bbe9de707110eba5c76fc4121ac", "sha256": "0d0e7fae294e5cd02b6b572f29021cffec2889ebc50cc17262124e6cf95dd3df"}, "downloads": -1, "filename": "py_memoize-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "3abb4bbe9de707110eba5c76fc4121ac", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21058, "upload_time": "2019-06-03T15:04:05", "upload_time_iso_8601": "2019-06-03T15:04:05.756073Z", "url": "https://files.pythonhosted.org/packages/f7/f3/ded05e96d70cef85deb0eb0ef457348d5f615ba868945fc59f485b8dc6e3/py_memoize-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ca3656dbe861bbb1e92f643b8ae589ae", "sha256": "4aad1d3ce52efce91778d18b8d31a4d935267e9f3756179b1d8a5339d961be4d"}, "downloads": -1, "filename": "py-memoize-1.0.1.tar.gz", "has_sig": false, "md5_digest": "ca3656dbe861bbb1e92f643b8ae589ae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17430, "upload_time": "2019-06-03T15:04:07", "upload_time_iso_8601": "2019-06-03T15:04:07.210266Z", "url": "https://files.pythonhosted.org/packages/31/4e/cbe4182d16f55e6ac9ac2b8ee0c4d50742573d83ac1548a9ad3173a4a46c/py-memoize-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "676e2b77b0c63e8e2c069ddcc3a812cf", "sha256": "3a522a2c77eaa8b5757bac2da07da5ab6eee97f2dc09b6ae629fd0f7e8b33e83"}, "downloads": -1, "filename": "py_memoize-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "676e2b77b0c63e8e2c069ddcc3a812cf", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21109, "upload_time": "2020-01-21T15:05:18", "upload_time_iso_8601": "2020-01-21T15:05:18.176118Z", "url": "https://files.pythonhosted.org/packages/e1/f1/b10c04f0d38a12c594646f24080892b7a4f185a56c88ac4f3528af4fd496/py_memoize-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "89fb90d2d783dcb2a5dc47d96a8fccd9", "sha256": "1b80f6c45ee44af9191b7340aff6e8f396a08e7928c980f151dd314534db0af8"}, "downloads": -1, "filename": "py-memoize-1.0.2.tar.gz", "has_sig": false, "md5_digest": "89fb90d2d783dcb2a5dc47d96a8fccd9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16616, "upload_time": "2020-01-21T15:05:19", "upload_time_iso_8601": "2020-01-21T15:05:19.464696Z", "url": "https://files.pythonhosted.org/packages/45/ff/5ef7f25f212efb264dc9cdfd3cb5c27fb8fa4a7d54077f662ca9abb5ed9e/py-memoize-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "157459531146e52f7733695a82a1f8d2", "sha256": "560d15cc477ede483147e374a83a642881677cd5444fb2fd148cd313aea960c3"}, "downloads": -1, "filename": "py_memoize-1.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "157459531146e52f7733695a82a1f8d2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21121, "upload_time": "2020-01-27T10:55:46", "upload_time_iso_8601": "2020-01-27T10:55:46.159881Z", "url": "https://files.pythonhosted.org/packages/e1/a1/b801ddb9d56d7de5331f121e40acf32d5ccc2ded31e5f2b28bce28ef4dd3/py_memoize-1.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ca6846cc5406c2b5e1e7d7fb583b2dc4", "sha256": "01ac1b208c852d3c8a9c7297de5dda373aa8347868b902938344fb60f0782bed"}, "downloads": -1, "filename": "py-memoize-1.0.3.tar.gz", "has_sig": false, "md5_digest": "ca6846cc5406c2b5e1e7d7fb583b2dc4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16615, "upload_time": "2020-01-27T10:55:47", "upload_time_iso_8601": "2020-01-27T10:55:47.736981Z", "url": "https://files.pythonhosted.org/packages/50/e6/436b0d2925d54ca60e3fbb01152edf5e5f514321804be740bc952cf32be6/py-memoize-1.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "157459531146e52f7733695a82a1f8d2", "sha256": "560d15cc477ede483147e374a83a642881677cd5444fb2fd148cd313aea960c3"}, "downloads": -1, "filename": "py_memoize-1.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "157459531146e52f7733695a82a1f8d2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21121, "upload_time": "2020-01-27T10:55:46", "upload_time_iso_8601": "2020-01-27T10:55:46.159881Z", "url": "https://files.pythonhosted.org/packages/e1/a1/b801ddb9d56d7de5331f121e40acf32d5ccc2ded31e5f2b28bce28ef4dd3/py_memoize-1.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ca6846cc5406c2b5e1e7d7fb583b2dc4", "sha256": "01ac1b208c852d3c8a9c7297de5dda373aa8347868b902938344fb60f0782bed"}, "downloads": -1, "filename": "py-memoize-1.0.3.tar.gz", "has_sig": false, "md5_digest": "ca6846cc5406c2b5e1e7d7fb583b2dc4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16615, "upload_time": "2020-01-27T10:55:47", "upload_time_iso_8601": "2020-01-27T10:55:47.736981Z", "url": "https://files.pythonhosted.org/packages/50/e6/436b0d2925d54ca60e3fbb01152edf5e5f514321804be740bc952cf32be6/py-memoize-1.0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:15 2020"}