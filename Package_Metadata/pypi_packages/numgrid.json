{"info": {"author": "Radovan Bast", "author_email": "radovan.bast@uit.no", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Science/Research", "Programming Language :: Python :: 3.6"], "description": ".. image:: https://travis-ci.org/dftlibs/numgrid.svg?branch=master\n   :target: https://travis-ci.org/dftlibs/numgrid/builds\n.. image:: https://coveralls.io/repos/dftlibs/numgrid/badge.png?branch=master\n   :target: https://coveralls.io/r/dftlibs/numgrid?branch=master\n.. image:: https://img.shields.io/badge/license-%20MPL--v2.0-blue.svg\n   :target: LICENSE\n.. image:: https://badge.fury.io/py/numgrid.svg\n   :target: https://badge.fury.io/py/numgrid\n.. image:: https://zenodo.org/badge/DOI/10.5281/zenodo.1470277.svg\n   :target: https://doi.org/10.5281/zenodo.1470277\n\n- `Changelog <CHANGES.rst>`__\n-  `Build and test\n   history <https://travis-ci.org/dftlibs/numgrid/builds>`__\n-  `Code coverage <https://coveralls.io/r/dftlibs/numgrid>`__\n-  Licensed under `MPL v2.0 <LICENSE>`__ (except John\n   Burkardt\u2019s Lebedev code which is redistributed under LGPL v3.0)\n-  Built with `Autocmake <https://github.com/coderefinery/autocmake>`__\n\n\nNumgrid\n=======\n\nNumgrid is a library that produces numerical integration grid for\nmolecules based on atom coordinates, atom types, and basis set\ninformation. This library can be built with C, Fortran, and Python bindings.\n\n\n.. contents:: Table of Contents\n\n\nWho are the people behind this code?\n====================================\n\nAuthors\n-------\n\n-  Radovan Bast\n\n\nContributors\n------------\n\n-  Roberto Di Remigio (OS X testing, streamlined Travis testing, better\n   C++, error handling)\n\nFor a list of all the contributions see\nhttps://github.com/dftlibs/numgrid/contributors.\n\n\nAcknowledgements\n----------------\n\n-  Simon Neville (reporting issues)\n-  Jaime Axel Rosal Sandberg (reporting issues)\n\nThis tool uses SPHERE_LEBEDEV_RULE, a C library written by John Burkardt which\ncomputes a Lebedev quadrature rule over the surface of the unit sphere in 3D,\nsee also:\nhttp://people.sc.fsu.edu/~jburkardt/c_src/sphere_lebedev_rule/sphere_lebedev_rule.html\n\nThis library uses and acknowledges the\nMolSSI BSE (https://molssi-bse.github.io/basis_set_exchange/),\nwhich is a rewrite of the Basis Set Exchange\n(https://bse.pnl.gov/bse/portal) and is a collaboration between the Molecular\nSciences Software Institute (http://www.molssi.org) and the Environmental\nMolecular Sciences Laboratory (https://www.emsl.pnl.gov).\n\n\nCitation\n--------\n\nIf you use this tool in a program or publication, please acknowledge its\nauthor(s). The metadata necessary for citing this tool can be found in the\n`CITATION.cff <CITATION.cff>`__ file. For more information CITATION.cff files, see\nhttps://citation-file-format.github.io.\n\n\nWould you like to contribute?\n-----------------------------\n\nYes please! Please follow `this excellent\nguide <http://www.contribution-guide.org>`__. We do not require any\nformal copyright assignment or contributor license agreement. Any\ncontributions intentionally sent upstream are presumed to be offered\nunder terms of the Mozilla Public License Version 2.0.\n\n\nRequirements\n============\n\n-  CMake\n-  C and C++ compiler\n-  Fortran compiler (to build the optional Fortran interface)\n-  `CFFI <https://cffi.readthedocs.org>`__ (to access the optional\n   Python interface)\n-  `pytest <http://pytest.org>`__ (to test the optional Python\n   interface)\n\n\nInstallation\n============\n\nInstalling via pip\n------------------\n\n::\n\n   pip install numgrid\n\n\nBuilding and testing from sources\n---------------------------------\n\nFetch the code::\n\n   git clone https://github.com/dftlibs/numgrid.git\n\nInstall Python dependencies (optional)::\n\n   pipenv install\n\nBuild the code::\n\n   cd numgrid\n   ./setup --fc=gfortran --cc=gcc --cxx=g++\n   cd build\n   make\n   make test\n\nThe Python interface is automatically tested by Travis CI:\nhttps://github.com/dftlibs/numgrid/blob/master/.travis.yml\n\n\nAPI\n===\n\nThe library provides a context-aware C interface. In addition it also\nprovides a Fortran and Python interfaces as thin layers on top of the C\ninterface::\n\n   Python: numgrid/__init__.py\n     \\\n      \\     Fortran: numgrid/numgrid.f90\n       \\   /\n     C interface: numgrid/numgrid.h\n         |\n   implementation\n\n\nUnits\n-----\n\nCoordinates are in bohr.\n\n\nOverview\n--------\n\nGrid computation is done per atom/basis type and proceeds in five steps:\n\n-  Create atom\n-  Get number of points (depends on basis set range)\n-  Allocate memory to hold the grid\n-  Compute grid on this atom in a molecular environment\n-  Free atom and its memory\n\nThe Python interface takes care of the allocation and deallocation part\nbut the essential point is that memory management is happening on the\nclient side.\n\nIf you have many atom centers that have the same atom type and same\nbasis set, it will make sense to create only one atom object and then\nreuse this object to compute the grid on all atoms with the same basis\ntype.\n\nIt is no problem to create several atom objects at the same time.\n\n\nPython example\n--------------\n\nThe Python interface is generated using\n`CFFI <https://cffi.readthedocs.org>`__.\n\nAs an example let us generate a grid for the water molecule:\n\n.. code:: python\n\n   import numgrid\n\n   radial_precision = 1.0e-12\n   min_num_angular_points = 86\n   max_num_angular_points = 302\n\n   num_centers = 3\n   proton_charges = [8, 1, 1]\n\n   x_coordinates_bohr = [0.0, 1.43, -1.43]\n   y_coordinates_bohr = [0.0, 0.0, 0.0]\n   z_coordinates_bohr = [0.0, 1.1, 1.1]\n\n   # cc-pVDZ basis\n   alpha_max = [11720.0, 13.01, 13.01]  # O, H, H\n   max_l_quantum_numbers = [2, 1, 1]  # O, H, H\n   alpha_min = [[0.3023, 0.2753, 1.185],  # O\n                [0.122, 0.727],  # H\n                [0.122, 0.727]]  # H\n\n   for center_index in range(num_centers):\n       context = numgrid.new_atom_grid(radial_precision,\n                                       min_num_angular_points,\n                                       max_num_angular_points,\n                                       proton_charges[center_index],\n                                       alpha_max[center_index],\n                                       max_l_quantum_numbers[center_index],\n                                       alpha_min[center_index])\n\n       num_points = numgrid.get_num_grid_points(context)\n\n       # generate an atomic grid in the molecular environment\n       x, y, z, w = numgrid.get_grid(context,\n                                     num_centers,\n                                     center_index,\n                                     x_coordinates_bohr,\n                                     y_coordinates_bohr,\n                                     z_coordinates_bohr,\n                                     proton_charges)\n\n       num_radial_points = numgrid.get_num_radial_grid_points(context)\n\n       # generate an isolated radial grid\n       r, w = numgrid.get_radial_grid(context)\n\n       numgrid.free_atom_grid(context)\n\n\n   # generate an isolated angular grid\n   x, y, z, w = numgrid.get_angular_grid(num_angular_grid_points=14)\n\n\nAvoiding explicit exponent ranges\n---------------------------------\n\nUsing the Python interface you can choose to not provide\nexplicit exponent ranges and instead specify the basis\nset which is then fetched directly from\nhttps://github.com/MolSSI-BSE/basis_set_exchange\nusing the wonderful\n`MolSSI BSE <https://molssi-bse.github.io/basis_set_exchange/>`__:\n\n.. code:: python\n\n   context = numgrid.new_atom_grid_bse(radial_precision=1.0e-12,\n                                       min_num_angular_points=86,\n                                       max_num_angular_points=302,\n                                       proton_charge=8,\n                                       basis_set='cc-pVDZ')\n\n\nSaving grid in Numpy format\n---------------------------\n\nThe current API makes is relatively easy to export the computed grid in Numpy format.\n\nIn this example we save the radial grid positions and weights to two separate files\nin Numpy format:\n\n.. code:: python\n\n   import numgrid\n   import numpy as np\n\n   # we assume the context is created\n   # ...\n   r, w = numgrid.get_radial_grid(context)\n\n   np.save('radial_grid_r.npy', r)\n   np.save('radial_grid_w.npy', w)\n\n\nC API\n-----\n\nTo see a real example, have a look at the `C++ test\ncase <test/test_explicit.cpp>`__.\n\n\nCreating a new atom grid\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: c\n\n   context_t *numgrid_new_atom_grid(const double radial_precision,\n                                    const int min_num_angular_points,\n                                    const int max_num_angular_points,\n                                    const int proton_charge,\n                                    const double alpha_max,\n                                    const int max_l_quantum_number,\n                                    const double alpha_min[]);\n\nThe smaller the ``radial_precision``, the better grid.\n\nFor ``min_num_angular_points`` and ``max_num_angular_points``, see\n\u201cAngular grid\u201d below.\n\n``alpha_max`` is the steepest basis set exponent.\n\n``alpha_min`` is an array of the size ``max_l_quantum_number`` + 1 and\nholds the smallest exponents for each angular momentum. If an angular\nmomentum set is missing \u201cin the middle\u201d, provide 0.0. In other words,\nimagine that you have a basis set which only contains *s* and *d*\nfunctions and no *p* functions and let us assume that the most diffuse\n*s* function has the exponent 0.1 and the most diffuse *d* function has\nthe exponent 0.2, then ``alpha_min`` would be an array of three numbers\nholding {0.1, 0.0, 0.2}.\n\n\nGet number of grid points on current atom\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe following two functions are probably self-explaining. We need to\nprovide the context which refers to a specific atom object.\n\n.. code:: c\n\n   int numgrid_get_num_grid_points(const context_t *context);\n\n   int numgrid_get_num_radial_grid_points(const context_t *context);\n\n\nGet grid on current atom, scaled by Becke partitioning\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWe assume that ``grid_x_bohr``, ``grid_y_bohr``, ``grid_z_bohr``, and\n``grid_w`` are allocated by the caller and have the length that equals\nthe number of grid points.\n\n``x_coordinates_bohr``, ``y_coordinates_bohr``, ``z_coordinates_bohr``,\nand ``proton_charges`` refer to the molecular environment and have the\nsize ``num_centers``.\n\nUsing ``center_index`` we tell the code which of the atom centers is the\none we have computed the grid for.\n\n.. code:: c\n\n   void numgrid_get_grid(const context_t *context,\n                         const int num_centers,\n                         const int center_index,\n                         const double x_coordinates_bohr[],\n                         const double y_coordinates_bohr[],\n                         const double z_coordinates_bohr[],\n                         const int proton_charges[],\n                         double grid_x_bohr[],\n                         double grid_y_bohr[],\n                         double grid_z_bohr[],\n                         double grid_w[]);\n\n\nGet radial grid on current atom\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWe assume that ``radial_grid_r_bohr`` and ``radial_grid_w`` are\nallocated by the caller and have both the length that equals the number\nof radial grid points.\n\n.. code:: c\n\n   void numgrid_get_radial_grid(const context_t *context,\n                                double radial_grid_r_bohr[],\n                                double radial_grid_w[]);\n\n\nGet angular grid\n~~~~~~~~~~~~~~~~\n\nThis does not refer to any specific atom and does not require any\ncontext.\n\n``num_angular_grid_points`` has to be one of the many supported Lebedev\ngrids (see table on the bottom of this page) and the code will assume\nthat the grid arrays are allocated by the caller and have at least the\nsize ``num_angular_grid_points``.\n\n.. code:: c\n\n   void numgrid_get_angular_grid(const int num_angular_grid_points,\n                                 double angular_grid_x_bohr[],\n                                 double angular_grid_y_bohr[],\n                                 double angular_grid_z_bohr[],\n                                 double angular_grid_w[]);\n\n\nDestroy the atom and deallocate all data\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: c\n\n   void numgrid_free_atom_grid(context_t *context);\n\n\nFortran API\n-----------\n\nClosely follows the C API. To see a real example, have a look at the\n`Fortran test case <test/test_explicit.f90>`__.\n\n\nParallelization\n===============\n\nThe design decision was to not parallelize the library but rather\nparallelize over the atom/basis types by the caller. This simplifies\nmodularity and code reuse.\n\n\nSpace partitioning\n==================\n\nThe molecular integration grid is generated from atom-centered grids by\nscaling the grid weights according to the Becke partitioning scheme,\n`JCP 88, 2547 (1988) <http://dx.doi.org/10.1063/1.454033>`__. The\ndefault Becke hardness is 3.\n\n\nRadial grid\n===========\n\nThe radial grid is generated according to Lindh, Malmqvist, and\nGagliardi, `TCA 106, 178\n(2001) <http://dx.doi.org/10.1007/s002140100263>`__.\n\nThe motivation for this choice is the nice feature of the above scheme\nthat the range of the radial grid is basis set dependent. The precision\ncan be tuned with one single radial precision parameter. The smaller the\nradial precision, the better quality grid you obtain.\n\nThe basis set (more precisely the Gaussian primitives/exponents) are\nused to generate the atomic radial grid range. This means that a more\ndiffuse basis set generates a more diffuse radial grid.\n\nIf you need a grid but you do not have a basis set or choose not to use\na specific one, then you can feed the library with a fantasy basis set\nconsisting of just two primitives. You can then adjust the range by\nmaking the exponents more steep or more diffuse.\n\n\nAngular grid\n============\n\nThe angular grid is generated according to Lebedev and Laikov [A\nquadrature formula for the sphere of the 131st algebraic order of\naccuracy, Russian Academy of Sciences Doklady Mathematics, Volume 59,\nNumber 3, 1999, pages 477-481].\n\nThe angular grid is pruned. The pruning is a primitive linear\ninterpolation between the minimum number and the maximum number of\nangular points per radial shell. The maximum number is reached at 0.2\ntimes the Bragg radius of the center.\n\nThe higher the values for minimum and maximum number of angular points,\nthe better.\n\nFor the minimum and maximum number of angular points the code will use\nthe following table and select the closest number with at least the\ndesired precision::\n\n   {6,    14,   26,   38,   50,   74,   86,   110,  146,\n    170,  194,  230,  266,  302,  350,  434,  590,  770,\n    974,  1202, 1454, 1730, 2030, 2354, 2702, 3074, 3470,\n    3890, 4334, 4802, 5294, 5810}\n\nTaking the same number for the minimum and maximum number of angular\npoints switches off pruning.\n\n\nHow to include Numgrid in a CMake project\n=========================================\n\nThere are multiple ways to achieve this. Here is how to include\nthe library using ``FetchContent``:\n\n.. code:: cmake\n\n  cmake_minimum_required(VERSION 3.11 FATAL_ERROR)\n\n  project(example LANGUAGES CXX)\n\n  include(FetchContent)\n\n  FetchContent_Declare(\n    numgrid\n    GIT_REPOSITORY https://github.com/dftlibs/numgrid.git\n    GIT_TAG        e14bf969d68e7847f5e40f36816f61f245211a9b\n  )\n\n  FetchContent_GetProperties(numgrid)\n\n  if(NOT numgrid_POPULATED)\n    FetchContent_Populate(numgrid)\n    add_subdirectory(\n      ${numgrid_SOURCE_DIR}\n      ${numgrid_BINARY_DIR}\n      )\n  endif()\n\n  add_executable(example \"\")\n\n  target_sources(\n    example\n    PRIVATE\n      main.cpp\n    )\n\n  target_link_libraries(\n    example\n    PRIVATE\n      numgrid-objects\n    )", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/dftlibs/numgrid", "keywords": "", "license": "MPL-v2.0", "maintainer": "", "maintainer_email": "", "name": "numgrid", "package_url": "https://pypi.org/project/numgrid/", "platform": "", "project_url": "https://pypi.org/project/numgrid/", "project_urls": {"Homepage": "https://github.com/dftlibs/numgrid"}, "release_url": "https://pypi.org/project/numgrid/1.1.1/", "requires_dist": null, "requires_python": "", "summary": "Numerical integration grid for molecules.", "version": "1.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/dftlibs/numgrid/builds\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/dftlibs/numgrid.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/84b1f1729c753b7148f700a0c3274c8f9a7b1608/68747470733a2f2f7472617669732d63692e6f72672f6466746c6962732f6e756d677269642e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/r/dftlibs/numgrid?branch=master\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/dftlibs/numgrid/badge.png?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/74b104aa01ad0ca6fd0383aa92bcba9643af53dc/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6466746c6962732f6e756d677269642f62616467652e706e673f6272616e63683d6d6173746572\"></a>\n<a href=\"LICENSE\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/license-%20MPL--v2.0-blue.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/21206f79e4a0a42a86cdc99c3c844e9867ddcdb1/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d2532304d504c2d2d76322e302d626c75652e737667\"></a>\n<a href=\"https://badge.fury.io/py/numgrid\" rel=\"nofollow\"><img alt=\"https://badge.fury.io/py/numgrid.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/add493c99e2dbfe45c9c2130389a0a391499d48c/68747470733a2f2f62616467652e667572792e696f2f70792f6e756d677269642e737667\"></a>\n<a href=\"https://doi.org/10.5281/zenodo.1470277\" rel=\"nofollow\"><img alt=\"https://zenodo.org/badge/DOI/10.5281/zenodo.1470277.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/459e860b89708809f9da3ca4811c725e6abefd5a/68747470733a2f2f7a656e6f646f2e6f72672f62616467652f444f492f31302e353238312f7a656e6f646f2e313437303237372e737667\"></a>\n<ul>\n<li><a href=\"CHANGES.rst\" rel=\"nofollow\">Changelog</a></li>\n<li><a href=\"https://travis-ci.org/dftlibs/numgrid/builds\" rel=\"nofollow\">Build and test\nhistory</a></li>\n<li><a href=\"https://coveralls.io/r/dftlibs/numgrid\" rel=\"nofollow\">Code coverage</a></li>\n<li>Licensed under <a href=\"LICENSE\" rel=\"nofollow\">MPL v2.0</a> (except John\nBurkardt\u2019s Lebedev code which is redistributed under LGPL v3.0)</li>\n<li>Built with <a href=\"https://github.com/coderefinery/autocmake\" rel=\"nofollow\">Autocmake</a></li>\n</ul>\n<div id=\"numgrid\">\n<h2><a href=\"#id1\" rel=\"nofollow\">Numgrid</a></h2>\n<p>Numgrid is a library that produces numerical integration grid for\nmolecules based on atom coordinates, atom types, and basis set\ninformation. This library can be built with C, Fortran, and Python bindings.</p>\n<div id=\"table-of-contents\">\n<p>Table of Contents</p>\n<ul>\n<li><a href=\"#numgrid\" id=\"id1\" rel=\"nofollow\">Numgrid</a></li>\n<li><a href=\"#who-are-the-people-behind-this-code\" id=\"id2\" rel=\"nofollow\">Who are the people behind this code?</a><ul>\n<li><a href=\"#authors\" id=\"id3\" rel=\"nofollow\">Authors</a></li>\n<li><a href=\"#contributors\" id=\"id4\" rel=\"nofollow\">Contributors</a></li>\n<li><a href=\"#acknowledgements\" id=\"id5\" rel=\"nofollow\">Acknowledgements</a></li>\n<li><a href=\"#citation\" id=\"id6\" rel=\"nofollow\">Citation</a></li>\n<li><a href=\"#would-you-like-to-contribute\" id=\"id7\" rel=\"nofollow\">Would you like to contribute?</a></li>\n</ul>\n</li>\n<li><a href=\"#requirements\" id=\"id8\" rel=\"nofollow\">Requirements</a></li>\n<li><a href=\"#installation\" id=\"id9\" rel=\"nofollow\">Installation</a><ul>\n<li><a href=\"#installing-via-pip\" id=\"id10\" rel=\"nofollow\">Installing via pip</a></li>\n<li><a href=\"#building-and-testing-from-sources\" id=\"id11\" rel=\"nofollow\">Building and testing from sources</a></li>\n</ul>\n</li>\n<li><a href=\"#api\" id=\"id12\" rel=\"nofollow\">API</a><ul>\n<li><a href=\"#units\" id=\"id13\" rel=\"nofollow\">Units</a></li>\n<li><a href=\"#overview\" id=\"id14\" rel=\"nofollow\">Overview</a></li>\n<li><a href=\"#python-example\" id=\"id15\" rel=\"nofollow\">Python example</a></li>\n<li><a href=\"#avoiding-explicit-exponent-ranges\" id=\"id16\" rel=\"nofollow\">Avoiding explicit exponent ranges</a></li>\n<li><a href=\"#saving-grid-in-numpy-format\" id=\"id17\" rel=\"nofollow\">Saving grid in Numpy format</a></li>\n<li><a href=\"#c-api\" id=\"id18\" rel=\"nofollow\">C API</a><ul>\n<li><a href=\"#creating-a-new-atom-grid\" id=\"id19\" rel=\"nofollow\">Creating a new atom grid</a></li>\n<li><a href=\"#get-number-of-grid-points-on-current-atom\" id=\"id20\" rel=\"nofollow\">Get number of grid points on current atom</a></li>\n<li><a href=\"#get-grid-on-current-atom-scaled-by-becke-partitioning\" id=\"id21\" rel=\"nofollow\">Get grid on current atom, scaled by Becke partitioning</a></li>\n<li><a href=\"#get-radial-grid-on-current-atom\" id=\"id22\" rel=\"nofollow\">Get radial grid on current atom</a></li>\n<li><a href=\"#get-angular-grid\" id=\"id23\" rel=\"nofollow\">Get angular grid</a></li>\n<li><a href=\"#destroy-the-atom-and-deallocate-all-data\" id=\"id24\" rel=\"nofollow\">Destroy the atom and deallocate all data</a></li>\n</ul>\n</li>\n<li><a href=\"#fortran-api\" id=\"id25\" rel=\"nofollow\">Fortran API</a></li>\n</ul>\n</li>\n<li><a href=\"#parallelization\" id=\"id26\" rel=\"nofollow\">Parallelization</a></li>\n<li><a href=\"#space-partitioning\" id=\"id27\" rel=\"nofollow\">Space partitioning</a></li>\n<li><a href=\"#radial-grid\" id=\"id28\" rel=\"nofollow\">Radial grid</a></li>\n<li><a href=\"#angular-grid\" id=\"id29\" rel=\"nofollow\">Angular grid</a></li>\n<li><a href=\"#how-to-include-numgrid-in-a-cmake-project\" id=\"id30\" rel=\"nofollow\">How to include Numgrid in a CMake project</a></li>\n</ul>\n</div>\n</div>\n<div id=\"who-are-the-people-behind-this-code\">\n<h2><a href=\"#id2\" rel=\"nofollow\">Who are the people behind this code?</a></h2>\n<div id=\"authors\">\n<h3><a href=\"#id3\" rel=\"nofollow\">Authors</a></h3>\n<ul>\n<li>Radovan Bast</li>\n</ul>\n</div>\n<div id=\"contributors\">\n<h3><a href=\"#id4\" rel=\"nofollow\">Contributors</a></h3>\n<ul>\n<li>Roberto Di Remigio (OS X testing, streamlined Travis testing, better\nC++, error handling)</li>\n</ul>\n<p>For a list of all the contributions see\n<a href=\"https://github.com/dftlibs/numgrid/contributors\" rel=\"nofollow\">https://github.com/dftlibs/numgrid/contributors</a>.</p>\n</div>\n<div id=\"acknowledgements\">\n<h3><a href=\"#id5\" rel=\"nofollow\">Acknowledgements</a></h3>\n<ul>\n<li>Simon Neville (reporting issues)</li>\n<li>Jaime Axel Rosal Sandberg (reporting issues)</li>\n</ul>\n<p>This tool uses SPHERE_LEBEDEV_RULE, a C library written by John Burkardt which\ncomputes a Lebedev quadrature rule over the surface of the unit sphere in 3D,\nsee also:\n<a href=\"http://people.sc.fsu.edu/~jburkardt/c_src/sphere_lebedev_rule/sphere_lebedev_rule.html\" rel=\"nofollow\">http://people.sc.fsu.edu/~jburkardt/c_src/sphere_lebedev_rule/sphere_lebedev_rule.html</a></p>\n<p>This library uses and acknowledges the\nMolSSI BSE (<a href=\"https://molssi-bse.github.io/basis_set_exchange/\" rel=\"nofollow\">https://molssi-bse.github.io/basis_set_exchange/</a>),\nwhich is a rewrite of the Basis Set Exchange\n(<a href=\"https://bse.pnl.gov/bse/portal\" rel=\"nofollow\">https://bse.pnl.gov/bse/portal</a>) and is a collaboration between the Molecular\nSciences Software Institute (<a href=\"http://www.molssi.org\" rel=\"nofollow\">http://www.molssi.org</a>) and the Environmental\nMolecular Sciences Laboratory (<a href=\"https://www.emsl.pnl.gov\" rel=\"nofollow\">https://www.emsl.pnl.gov</a>).</p>\n</div>\n<div id=\"citation\">\n<h3><a href=\"#id6\" rel=\"nofollow\">Citation</a></h3>\n<p>If you use this tool in a program or publication, please acknowledge its\nauthor(s). The metadata necessary for citing this tool can be found in the\n<a href=\"CITATION.cff\" rel=\"nofollow\">CITATION.cff</a> file. For more information CITATION.cff files, see\n<a href=\"https://citation-file-format.github.io\" rel=\"nofollow\">https://citation-file-format.github.io</a>.</p>\n</div>\n<div id=\"would-you-like-to-contribute\">\n<h3><a href=\"#id7\" rel=\"nofollow\">Would you like to contribute?</a></h3>\n<p>Yes please! Please follow <a href=\"http://www.contribution-guide.org\" rel=\"nofollow\">this excellent\nguide</a>. We do not require any\nformal copyright assignment or contributor license agreement. Any\ncontributions intentionally sent upstream are presumed to be offered\nunder terms of the Mozilla Public License Version 2.0.</p>\n</div>\n</div>\n<div id=\"requirements\">\n<h2><a href=\"#id8\" rel=\"nofollow\">Requirements</a></h2>\n<ul>\n<li>CMake</li>\n<li>C and C++ compiler</li>\n<li>Fortran compiler (to build the optional Fortran interface)</li>\n<li><a href=\"https://cffi.readthedocs.org\" rel=\"nofollow\">CFFI</a> (to access the optional\nPython interface)</li>\n<li><a href=\"http://pytest.org\" rel=\"nofollow\">pytest</a> (to test the optional Python\ninterface)</li>\n</ul>\n</div>\n<div id=\"installation\">\n<h2><a href=\"#id9\" rel=\"nofollow\">Installation</a></h2>\n<div id=\"installing-via-pip\">\n<h3><a href=\"#id10\" rel=\"nofollow\">Installing via pip</a></h3>\n<pre>pip install numgrid\n</pre>\n</div>\n<div id=\"building-and-testing-from-sources\">\n<h3><a href=\"#id11\" rel=\"nofollow\">Building and testing from sources</a></h3>\n<p>Fetch the code:</p>\n<pre>git clone https://github.com/dftlibs/numgrid.git\n</pre>\n<p>Install Python dependencies (optional):</p>\n<pre>pipenv install\n</pre>\n<p>Build the code:</p>\n<pre>cd numgrid\n./setup --fc=gfortran --cc=gcc --cxx=g++\ncd build\nmake\nmake test\n</pre>\n<p>The Python interface is automatically tested by Travis CI:\n<a href=\"https://github.com/dftlibs/numgrid/blob/master/.travis.yml\" rel=\"nofollow\">https://github.com/dftlibs/numgrid/blob/master/.travis.yml</a></p>\n</div>\n</div>\n<div id=\"api\">\n<h2><a href=\"#id12\" rel=\"nofollow\">API</a></h2>\n<p>The library provides a context-aware C interface. In addition it also\nprovides a Fortran and Python interfaces as thin layers on top of the C\ninterface:</p>\n<pre>Python: numgrid/__init__.py\n  \\\n   \\     Fortran: numgrid/numgrid.f90\n    \\   /\n  C interface: numgrid/numgrid.h\n      |\nimplementation\n</pre>\n<div id=\"units\">\n<h3><a href=\"#id13\" rel=\"nofollow\">Units</a></h3>\n<p>Coordinates are in bohr.</p>\n</div>\n<div id=\"overview\">\n<h3><a href=\"#id14\" rel=\"nofollow\">Overview</a></h3>\n<p>Grid computation is done per atom/basis type and proceeds in five steps:</p>\n<ul>\n<li>Create atom</li>\n<li>Get number of points (depends on basis set range)</li>\n<li>Allocate memory to hold the grid</li>\n<li>Compute grid on this atom in a molecular environment</li>\n<li>Free atom and its memory</li>\n</ul>\n<p>The Python interface takes care of the allocation and deallocation part\nbut the essential point is that memory management is happening on the\nclient side.</p>\n<p>If you have many atom centers that have the same atom type and same\nbasis set, it will make sense to create only one atom object and then\nreuse this object to compute the grid on all atoms with the same basis\ntype.</p>\n<p>It is no problem to create several atom objects at the same time.</p>\n</div>\n<div id=\"python-example\">\n<h3><a href=\"#id15\" rel=\"nofollow\">Python example</a></h3>\n<p>The Python interface is generated using\n<a href=\"https://cffi.readthedocs.org\" rel=\"nofollow\">CFFI</a>.</p>\n<p>As an example let us generate a grid for the water molecule:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numgrid</span>\n\n<span class=\"n\">radial_precision</span> <span class=\"o\">=</span> <span class=\"mf\">1.0e-12</span>\n<span class=\"n\">min_num_angular_points</span> <span class=\"o\">=</span> <span class=\"mi\">86</span>\n<span class=\"n\">max_num_angular_points</span> <span class=\"o\">=</span> <span class=\"mi\">302</span>\n\n<span class=\"n\">num_centers</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n<span class=\"n\">proton_charges</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n\n<span class=\"n\">x_coordinates_bohr</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">1.43</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.43</span><span class=\"p\">]</span>\n<span class=\"n\">y_coordinates_bohr</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">]</span>\n<span class=\"n\">z_coordinates_bohr</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"mf\">1.1</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># cc-pVDZ basis</span>\n<span class=\"n\">alpha_max</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">11720.0</span><span class=\"p\">,</span> <span class=\"mf\">13.01</span><span class=\"p\">,</span> <span class=\"mf\">13.01</span><span class=\"p\">]</span>  <span class=\"c1\"># O, H, H</span>\n<span class=\"n\">max_l_quantum_numbers</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>  <span class=\"c1\"># O, H, H</span>\n<span class=\"n\">alpha_min</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mf\">0.3023</span><span class=\"p\">,</span> <span class=\"mf\">0.2753</span><span class=\"p\">,</span> <span class=\"mf\">1.185</span><span class=\"p\">],</span>  <span class=\"c1\"># O</span>\n             <span class=\"p\">[</span><span class=\"mf\">0.122</span><span class=\"p\">,</span> <span class=\"mf\">0.727</span><span class=\"p\">],</span>  <span class=\"c1\"># H</span>\n             <span class=\"p\">[</span><span class=\"mf\">0.122</span><span class=\"p\">,</span> <span class=\"mf\">0.727</span><span class=\"p\">]]</span>  <span class=\"c1\"># H</span>\n\n<span class=\"k\">for</span> <span class=\"n\">center_index</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">num_centers</span><span class=\"p\">):</span>\n    <span class=\"n\">context</span> <span class=\"o\">=</span> <span class=\"n\">numgrid</span><span class=\"o\">.</span><span class=\"n\">new_atom_grid</span><span class=\"p\">(</span><span class=\"n\">radial_precision</span><span class=\"p\">,</span>\n                                    <span class=\"n\">min_num_angular_points</span><span class=\"p\">,</span>\n                                    <span class=\"n\">max_num_angular_points</span><span class=\"p\">,</span>\n                                    <span class=\"n\">proton_charges</span><span class=\"p\">[</span><span class=\"n\">center_index</span><span class=\"p\">],</span>\n                                    <span class=\"n\">alpha_max</span><span class=\"p\">[</span><span class=\"n\">center_index</span><span class=\"p\">],</span>\n                                    <span class=\"n\">max_l_quantum_numbers</span><span class=\"p\">[</span><span class=\"n\">center_index</span><span class=\"p\">],</span>\n                                    <span class=\"n\">alpha_min</span><span class=\"p\">[</span><span class=\"n\">center_index</span><span class=\"p\">])</span>\n\n    <span class=\"n\">num_points</span> <span class=\"o\">=</span> <span class=\"n\">numgrid</span><span class=\"o\">.</span><span class=\"n\">get_num_grid_points</span><span class=\"p\">(</span><span class=\"n\">context</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># generate an atomic grid in the molecular environment</span>\n    <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">,</span> <span class=\"n\">w</span> <span class=\"o\">=</span> <span class=\"n\">numgrid</span><span class=\"o\">.</span><span class=\"n\">get_grid</span><span class=\"p\">(</span><span class=\"n\">context</span><span class=\"p\">,</span>\n                                  <span class=\"n\">num_centers</span><span class=\"p\">,</span>\n                                  <span class=\"n\">center_index</span><span class=\"p\">,</span>\n                                  <span class=\"n\">x_coordinates_bohr</span><span class=\"p\">,</span>\n                                  <span class=\"n\">y_coordinates_bohr</span><span class=\"p\">,</span>\n                                  <span class=\"n\">z_coordinates_bohr</span><span class=\"p\">,</span>\n                                  <span class=\"n\">proton_charges</span><span class=\"p\">)</span>\n\n    <span class=\"n\">num_radial_points</span> <span class=\"o\">=</span> <span class=\"n\">numgrid</span><span class=\"o\">.</span><span class=\"n\">get_num_radial_grid_points</span><span class=\"p\">(</span><span class=\"n\">context</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># generate an isolated radial grid</span>\n    <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">w</span> <span class=\"o\">=</span> <span class=\"n\">numgrid</span><span class=\"o\">.</span><span class=\"n\">get_radial_grid</span><span class=\"p\">(</span><span class=\"n\">context</span><span class=\"p\">)</span>\n\n    <span class=\"n\">numgrid</span><span class=\"o\">.</span><span class=\"n\">free_atom_grid</span><span class=\"p\">(</span><span class=\"n\">context</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># generate an isolated angular grid</span>\n<span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">,</span> <span class=\"n\">w</span> <span class=\"o\">=</span> <span class=\"n\">numgrid</span><span class=\"o\">.</span><span class=\"n\">get_angular_grid</span><span class=\"p\">(</span><span class=\"n\">num_angular_grid_points</span><span class=\"o\">=</span><span class=\"mi\">14</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"avoiding-explicit-exponent-ranges\">\n<h3><a href=\"#id16\" rel=\"nofollow\">Avoiding explicit exponent ranges</a></h3>\n<p>Using the Python interface you can choose to not provide\nexplicit exponent ranges and instead specify the basis\nset which is then fetched directly from\n<a href=\"https://github.com/MolSSI-BSE/basis_set_exchange\" rel=\"nofollow\">https://github.com/MolSSI-BSE/basis_set_exchange</a>\nusing the wonderful\n<a href=\"https://molssi-bse.github.io/basis_set_exchange/\" rel=\"nofollow\">MolSSI BSE</a>:</p>\n<pre><span class=\"n\">context</span> <span class=\"o\">=</span> <span class=\"n\">numgrid</span><span class=\"o\">.</span><span class=\"n\">new_atom_grid_bse</span><span class=\"p\">(</span><span class=\"n\">radial_precision</span><span class=\"o\">=</span><span class=\"mf\">1.0e-12</span><span class=\"p\">,</span>\n                                    <span class=\"n\">min_num_angular_points</span><span class=\"o\">=</span><span class=\"mi\">86</span><span class=\"p\">,</span>\n                                    <span class=\"n\">max_num_angular_points</span><span class=\"o\">=</span><span class=\"mi\">302</span><span class=\"p\">,</span>\n                                    <span class=\"n\">proton_charge</span><span class=\"o\">=</span><span class=\"mi\">8</span><span class=\"p\">,</span>\n                                    <span class=\"n\">basis_set</span><span class=\"o\">=</span><span class=\"s1\">'cc-pVDZ'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"saving-grid-in-numpy-format\">\n<h3><a href=\"#id17\" rel=\"nofollow\">Saving grid in Numpy format</a></h3>\n<p>The current API makes is relatively easy to export the computed grid in Numpy format.</p>\n<p>In this example we save the radial grid positions and weights to two separate files\nin Numpy format:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numgrid</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"c1\"># we assume the context is created</span>\n<span class=\"c1\"># ...</span>\n<span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">w</span> <span class=\"o\">=</span> <span class=\"n\">numgrid</span><span class=\"o\">.</span><span class=\"n\">get_radial_grid</span><span class=\"p\">(</span><span class=\"n\">context</span><span class=\"p\">)</span>\n\n<span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">(</span><span class=\"s1\">'radial_grid_r.npy'</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n<span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">(</span><span class=\"s1\">'radial_grid_w.npy'</span><span class=\"p\">,</span> <span class=\"n\">w</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"c-api\">\n<h3><a href=\"#id18\" rel=\"nofollow\">C API</a></h3>\n<p>To see a real example, have a look at the <a href=\"test/test_explicit.cpp\" rel=\"nofollow\">C++ test\ncase</a>.</p>\n<div id=\"creating-a-new-atom-grid\">\n<h4><a href=\"#id19\" rel=\"nofollow\">Creating a new atom grid</a></h4>\n<pre><span class=\"n\">context_t</span> <span class=\"o\">*</span><span class=\"nf\">numgrid_new_atom_grid</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">double</span> <span class=\"n\">radial_precision</span><span class=\"p\">,</span>\n                                 <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">min_num_angular_points</span><span class=\"p\">,</span>\n                                 <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">max_num_angular_points</span><span class=\"p\">,</span>\n                                 <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">proton_charge</span><span class=\"p\">,</span>\n                                 <span class=\"k\">const</span> <span class=\"kt\">double</span> <span class=\"n\">alpha_max</span><span class=\"p\">,</span>\n                                 <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">max_l_quantum_number</span><span class=\"p\">,</span>\n                                 <span class=\"k\">const</span> <span class=\"kt\">double</span> <span class=\"n\">alpha_min</span><span class=\"p\">[]);</span>\n</pre>\n<p>The smaller the <tt>radial_precision</tt>, the better grid.</p>\n<p>For <tt>min_num_angular_points</tt> and <tt>max_num_angular_points</tt>, see\n\u201cAngular grid\u201d below.</p>\n<p><tt>alpha_max</tt> is the steepest basis set exponent.</p>\n<p><tt>alpha_min</tt> is an array of the size <tt>max_l_quantum_number</tt> + 1 and\nholds the smallest exponents for each angular momentum. If an angular\nmomentum set is missing \u201cin the middle\u201d, provide 0.0. In other words,\nimagine that you have a basis set which only contains <em>s</em> and <em>d</em>\nfunctions and no <em>p</em> functions and let us assume that the most diffuse\n<em>s</em> function has the exponent 0.1 and the most diffuse <em>d</em> function has\nthe exponent 0.2, then <tt>alpha_min</tt> would be an array of three numbers\nholding {0.1, 0.0, 0.2}.</p>\n</div>\n<div id=\"get-number-of-grid-points-on-current-atom\">\n<h4><a href=\"#id20\" rel=\"nofollow\">Get number of grid points on current atom</a></h4>\n<p>The following two functions are probably self-explaining. We need to\nprovide the context which refers to a specific atom object.</p>\n<pre><span class=\"kt\">int</span> <span class=\"nf\">numgrid_get_num_grid_points</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">context_t</span> <span class=\"o\">*</span><span class=\"n\">context</span><span class=\"p\">);</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">numgrid_get_num_radial_grid_points</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">context_t</span> <span class=\"o\">*</span><span class=\"n\">context</span><span class=\"p\">);</span>\n</pre>\n</div>\n<div id=\"get-grid-on-current-atom-scaled-by-becke-partitioning\">\n<h4><a href=\"#id21\" rel=\"nofollow\">Get grid on current atom, scaled by Becke partitioning</a></h4>\n<p>We assume that <tt>grid_x_bohr</tt>, <tt>grid_y_bohr</tt>, <tt>grid_z_bohr</tt>, and\n<tt>grid_w</tt> are allocated by the caller and have the length that equals\nthe number of grid points.</p>\n<p><tt>x_coordinates_bohr</tt>, <tt>y_coordinates_bohr</tt>, <tt>z_coordinates_bohr</tt>,\nand <tt>proton_charges</tt> refer to the molecular environment and have the\nsize <tt>num_centers</tt>.</p>\n<p>Using <tt>center_index</tt> we tell the code which of the atom centers is the\none we have computed the grid for.</p>\n<pre><span class=\"kt\">void</span> <span class=\"nf\">numgrid_get_grid</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">context_t</span> <span class=\"o\">*</span><span class=\"n\">context</span><span class=\"p\">,</span>\n                      <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">num_centers</span><span class=\"p\">,</span>\n                      <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">center_index</span><span class=\"p\">,</span>\n                      <span class=\"k\">const</span> <span class=\"kt\">double</span> <span class=\"n\">x_coordinates_bohr</span><span class=\"p\">[],</span>\n                      <span class=\"k\">const</span> <span class=\"kt\">double</span> <span class=\"n\">y_coordinates_bohr</span><span class=\"p\">[],</span>\n                      <span class=\"k\">const</span> <span class=\"kt\">double</span> <span class=\"n\">z_coordinates_bohr</span><span class=\"p\">[],</span>\n                      <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">proton_charges</span><span class=\"p\">[],</span>\n                      <span class=\"kt\">double</span> <span class=\"n\">grid_x_bohr</span><span class=\"p\">[],</span>\n                      <span class=\"kt\">double</span> <span class=\"n\">grid_y_bohr</span><span class=\"p\">[],</span>\n                      <span class=\"kt\">double</span> <span class=\"n\">grid_z_bohr</span><span class=\"p\">[],</span>\n                      <span class=\"kt\">double</span> <span class=\"n\">grid_w</span><span class=\"p\">[]);</span>\n</pre>\n</div>\n<div id=\"get-radial-grid-on-current-atom\">\n<h4><a href=\"#id22\" rel=\"nofollow\">Get radial grid on current atom</a></h4>\n<p>We assume that <tt>radial_grid_r_bohr</tt> and <tt>radial_grid_w</tt> are\nallocated by the caller and have both the length that equals the number\nof radial grid points.</p>\n<pre><span class=\"kt\">void</span> <span class=\"nf\">numgrid_get_radial_grid</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">context_t</span> <span class=\"o\">*</span><span class=\"n\">context</span><span class=\"p\">,</span>\n                             <span class=\"kt\">double</span> <span class=\"n\">radial_grid_r_bohr</span><span class=\"p\">[],</span>\n                             <span class=\"kt\">double</span> <span class=\"n\">radial_grid_w</span><span class=\"p\">[]);</span>\n</pre>\n</div>\n<div id=\"get-angular-grid\">\n<h4><a href=\"#id23\" rel=\"nofollow\">Get angular grid</a></h4>\n<p>This does not refer to any specific atom and does not require any\ncontext.</p>\n<p><tt>num_angular_grid_points</tt> has to be one of the many supported Lebedev\ngrids (see table on the bottom of this page) and the code will assume\nthat the grid arrays are allocated by the caller and have at least the\nsize <tt>num_angular_grid_points</tt>.</p>\n<pre><span class=\"kt\">void</span> <span class=\"nf\">numgrid_get_angular_grid</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">num_angular_grid_points</span><span class=\"p\">,</span>\n                              <span class=\"kt\">double</span> <span class=\"n\">angular_grid_x_bohr</span><span class=\"p\">[],</span>\n                              <span class=\"kt\">double</span> <span class=\"n\">angular_grid_y_bohr</span><span class=\"p\">[],</span>\n                              <span class=\"kt\">double</span> <span class=\"n\">angular_grid_z_bohr</span><span class=\"p\">[],</span>\n                              <span class=\"kt\">double</span> <span class=\"n\">angular_grid_w</span><span class=\"p\">[]);</span>\n</pre>\n</div>\n<div id=\"destroy-the-atom-and-deallocate-all-data\">\n<h4><a href=\"#id24\" rel=\"nofollow\">Destroy the atom and deallocate all data</a></h4>\n<pre><span class=\"kt\">void</span> <span class=\"nf\">numgrid_free_atom_grid</span><span class=\"p\">(</span><span class=\"n\">context_t</span> <span class=\"o\">*</span><span class=\"n\">context</span><span class=\"p\">);</span>\n</pre>\n</div>\n</div>\n<div id=\"fortran-api\">\n<h3><a href=\"#id25\" rel=\"nofollow\">Fortran API</a></h3>\n<p>Closely follows the C API. To see a real example, have a look at the\n<a href=\"test/test_explicit.f90\" rel=\"nofollow\">Fortran test case</a>.</p>\n</div>\n</div>\n<div id=\"parallelization\">\n<h2><a href=\"#id26\" rel=\"nofollow\">Parallelization</a></h2>\n<p>The design decision was to not parallelize the library but rather\nparallelize over the atom/basis types by the caller. This simplifies\nmodularity and code reuse.</p>\n</div>\n<div id=\"space-partitioning\">\n<h2><a href=\"#id27\" rel=\"nofollow\">Space partitioning</a></h2>\n<p>The molecular integration grid is generated from atom-centered grids by\nscaling the grid weights according to the Becke partitioning scheme,\n<a href=\"http://dx.doi.org/10.1063/1.454033\" rel=\"nofollow\">JCP 88, 2547 (1988)</a>. The\ndefault Becke hardness is 3.</p>\n</div>\n<div id=\"radial-grid\">\n<h2><a href=\"#id28\" rel=\"nofollow\">Radial grid</a></h2>\n<p>The radial grid is generated according to Lindh, Malmqvist, and\nGagliardi, <a href=\"http://dx.doi.org/10.1007/s002140100263\" rel=\"nofollow\">TCA 106, 178\n(2001)</a>.</p>\n<p>The motivation for this choice is the nice feature of the above scheme\nthat the range of the radial grid is basis set dependent. The precision\ncan be tuned with one single radial precision parameter. The smaller the\nradial precision, the better quality grid you obtain.</p>\n<p>The basis set (more precisely the Gaussian primitives/exponents) are\nused to generate the atomic radial grid range. This means that a more\ndiffuse basis set generates a more diffuse radial grid.</p>\n<p>If you need a grid but you do not have a basis set or choose not to use\na specific one, then you can feed the library with a fantasy basis set\nconsisting of just two primitives. You can then adjust the range by\nmaking the exponents more steep or more diffuse.</p>\n</div>\n<div id=\"angular-grid\">\n<h2><a href=\"#id29\" rel=\"nofollow\">Angular grid</a></h2>\n<p>The angular grid is generated according to Lebedev and Laikov [A\nquadrature formula for the sphere of the 131st algebraic order of\naccuracy, Russian Academy of Sciences Doklady Mathematics, Volume 59,\nNumber 3, 1999, pages 477-481].</p>\n<p>The angular grid is pruned. The pruning is a primitive linear\ninterpolation between the minimum number and the maximum number of\nangular points per radial shell. The maximum number is reached at 0.2\ntimes the Bragg radius of the center.</p>\n<p>The higher the values for minimum and maximum number of angular points,\nthe better.</p>\n<p>For the minimum and maximum number of angular points the code will use\nthe following table and select the closest number with at least the\ndesired precision:</p>\n<pre>{6,    14,   26,   38,   50,   74,   86,   110,  146,\n 170,  194,  230,  266,  302,  350,  434,  590,  770,\n 974,  1202, 1454, 1730, 2030, 2354, 2702, 3074, 3470,\n 3890, 4334, 4802, 5294, 5810}\n</pre>\n<p>Taking the same number for the minimum and maximum number of angular\npoints switches off pruning.</p>\n</div>\n<div id=\"how-to-include-numgrid-in-a-cmake-project\">\n<h2><a href=\"#id30\" rel=\"nofollow\">How to include Numgrid in a CMake project</a></h2>\n<p>There are multiple ways to achieve this. Here is how to include\nthe library using <tt>FetchContent</tt>:</p>\n<pre><span class=\"nb\">cmake_minimum_required</span><span class=\"p\">(</span><span class=\"s\">VERSION</span> <span class=\"s\">3.11</span> <span class=\"s\">FATAL_ERROR</span><span class=\"p\">)</span>\n\n<span class=\"nb\">project</span><span class=\"p\">(</span><span class=\"s\">example</span> <span class=\"s\">LANGUAGES</span> <span class=\"s\">CXX</span><span class=\"p\">)</span>\n\n<span class=\"nb\">include</span><span class=\"p\">(</span><span class=\"s\">FetchContent</span><span class=\"p\">)</span>\n\n<span class=\"nb\">FetchContent_Declare</span><span class=\"p\">(</span>\n  <span class=\"s\">numgrid</span>\n  <span class=\"s\">GIT_REPOSITORY</span> <span class=\"s\">https://github.com/dftlibs/numgrid.git</span>\n  <span class=\"s\">GIT_TAG</span>        <span class=\"s\">e14bf969d68e7847f5e40f36816f61f245211a9b</span>\n<span class=\"p\">)</span>\n\n<span class=\"nb\">FetchContent_GetProperties</span><span class=\"p\">(</span><span class=\"s\">numgrid</span><span class=\"p\">)</span>\n\n<span class=\"nb\">if</span><span class=\"p\">(</span><span class=\"s\">NOT</span> <span class=\"s\">numgrid_POPULATED</span><span class=\"p\">)</span>\n  <span class=\"nb\">FetchContent_Populate</span><span class=\"p\">(</span><span class=\"s\">numgrid</span><span class=\"p\">)</span>\n  <span class=\"nb\">add_subdirectory</span><span class=\"p\">(</span>\n    <span class=\"o\">${</span><span class=\"nv\">numgrid_SOURCE_DIR</span><span class=\"o\">}</span>\n    <span class=\"o\">${</span><span class=\"nv\">numgrid_BINARY_DIR</span><span class=\"o\">}</span>\n    <span class=\"p\">)</span>\n<span class=\"nb\">endif</span><span class=\"p\">()</span>\n\n<span class=\"nb\">add_executable</span><span class=\"p\">(</span><span class=\"s\">example</span> <span class=\"s2\">\"\"</span><span class=\"p\">)</span>\n\n<span class=\"nb\">target_sources</span><span class=\"p\">(</span>\n  <span class=\"s\">example</span>\n  <span class=\"s\">PRIVATE</span>\n    <span class=\"s\">main.cpp</span>\n  <span class=\"p\">)</span>\n\n<span class=\"nb\">target_link_libraries</span><span class=\"p\">(</span>\n  <span class=\"s\">example</span>\n  <span class=\"s\">PRIVATE</span>\n    <span class=\"s\">numgrid-objects</span>\n  <span class=\"p\">)</span>\n</pre>\n</div>\n\n          </div>"}, "last_serial": 6986956, "releases": {"1.0.2": [{"comment_text": "", "digests": {"md5": "0daf81c5e9273bc5edf1640e56c81c44", "sha256": "b51b8a71317c1cb9c7b64192051a8aa198ba38a8987575f42585b818a4219993"}, "downloads": -1, "filename": "numgrid-1.0.2.tar.gz", "has_sig": false, "md5_digest": "0daf81c5e9273bc5edf1640e56c81c44", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 87002, "upload_time": "2018-10-24T09:03:50", "upload_time_iso_8601": "2018-10-24T09:03:50.859075Z", "url": "https://files.pythonhosted.org/packages/3d/33/e1e6e49166ef5e52b4045819a5708c05c3e15022b0b134be2d86449b13b1/numgrid-1.0.2.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "29ad96312e49791c9523e5da45219284", "sha256": "ce6c359aee96ca3e544599e4662752185be8451a4c8708074e726edc9faad914"}, "downloads": -1, "filename": "numgrid-1.1.0.tar.gz", "has_sig": false, "md5_digest": "29ad96312e49791c9523e5da45219284", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 89130, "upload_time": "2019-05-03T08:51:59", "upload_time_iso_8601": "2019-05-03T08:51:59.106153Z", "url": "https://files.pythonhosted.org/packages/46/94/2099ab1ed4593c677f2fc0095704390001fc77d9943877074464d45a0d3f/numgrid-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "45d153f90e55a2994e8f5d873c0ddf9c", "sha256": "a420d164cfcd8458ae9b2c3f4668984682d9667644a97007215b36d43dd15659"}, "downloads": -1, "filename": "numgrid-1.1.1.tar.gz", "has_sig": false, "md5_digest": "45d153f90e55a2994e8f5d873c0ddf9c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 90739, "upload_time": "2020-04-09T15:08:53", "upload_time_iso_8601": "2020-04-09T15:08:53.686345Z", "url": "https://files.pythonhosted.org/packages/50/06/111d0b03d70b635a79f620e6c1aecfec5056f71f1a60f45d0d25e0f30f7d/numgrid-1.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "45d153f90e55a2994e8f5d873c0ddf9c", "sha256": "a420d164cfcd8458ae9b2c3f4668984682d9667644a97007215b36d43dd15659"}, "downloads": -1, "filename": "numgrid-1.1.1.tar.gz", "has_sig": false, "md5_digest": "45d153f90e55a2994e8f5d873c0ddf9c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 90739, "upload_time": "2020-04-09T15:08:53", "upload_time_iso_8601": "2020-04-09T15:08:53.686345Z", "url": "https://files.pythonhosted.org/packages/50/06/111d0b03d70b635a79f620e6c1aecfec5056f71f1a60f45d0d25e0f30f7d/numgrid-1.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:12 2020"}