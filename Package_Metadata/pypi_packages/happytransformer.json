{"info": {"author": "The Happy Transformer Development Team", "author_email": "happytransformer@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: Artificial Intelligence", "Topic :: Text Processing :: Linguistic"], "description": "[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0) [![Downloads](https://pepy.tech/badge/happytransformer)](https://pepy.tech/project/happytransformer)\n\n# Happy Transformer \n\n![HappyTransformer](img/HappyTransformer.png)\n\nHappy Transformer is an API built on top of [PyTorch's transformer library](https://pytorch.org/hub/huggingface_pytorch-transformers/) that makes it easy to utilize state-of-the-art NLP models. \n\n## Key Features\n  - **New: Finetuning Masked Language Models**\n  - Available language models: XLNET, BERT and ROBERTA.\n  - Predict a masked word within a sentence.\n  - Fine tune binary sequence classification models to solve problems like sentiment analysis.\n  - Predict the likelihood that sentence B follows sentence A within a paragraph. \n\n\n| Public Methods                     | HappyROBERTA | HappyXLNET | HappyBERT |\n|------------------------------------|--------------|------------|-----------|\n| Masked Word Prediction             | \u2714            | \u2714          | \u2714         |\n| Sequence Classification            | \u2714            | \u2714          | \u2714         |\n| Next Sentence Prediction           |              |            | \u2714         |\n| Question Answering                 |              |            | \u2714         |\n| Masked Word Prediction Finetuning  | \u2714            |            | \u2714         |\n\n## Installation\n\n```sh\npip install happytransformer\n```\n## Initialization \n\nBy default base models are used. They are smaller, faster and require significantly less training time\nto obtain decent results.\n\nLarge models are recommended for tasks that do not require fine tuning such as some word prediction tasks. \n\nBase models are recommended for tasks that require fine tuning with limited available training data. \n\nUncased models do not differentiate between cased and uncased words. For example, the words\n\"empire\" and \"Empire\" would be reduced to the same token. In comparison, cased models do differentiate between cased and uncased words. \n\n#### HappyXLNET:\n\n```sh\nfrom happytransformer import HappyXLNET\n#--------------------------------------#\nxl_base_cased = HappyXLNET(\"xlnet-base-cased\")\nxl_large_cased = HappyXLNET(\"xlnet-large-cased\")\n```\n#### HappyROBERTA:\n```sh\nfrom happytransformer import HappyROBERTA\n#--------------------------------------#\nhappy_roberta_base = HappyROBERTA(\"roberta-base\")\nhappy_roberta_large = HappyROBERTA(\"roberta-large\")\n\n```\n#### HappyBERT :\n```sh\nfrom happytransformer import HappyBERT\n#--------------------------------------#\nbert_base_uncased = HappyBERT(\"bert-base-uncased\")\nbert_base_cased = HappyBERT(\"bert-base-cased\")\nbert_large_uncased = HappyBERT(\"bert-large-uncased\")\nbert_large_cased = HappyBERT(\"bert-large-cased\")\n```\n## Word Prediction \n\nEach Happy Transformer has a public  method called \"predict_mask(text, options, num_results)\" with the following input arguments.\n1. Text: the text you wish to predict including a single masked token.\n2. options (default = every word): A limited set of words the model can return.\n3. num_results (default = 1): The number of returned predictions.\n\nFor all Happy Transformers, the masked token is **\"[MASK]\"**\n\n\"predict_mask(text, options, num_results)\" returns a list of dictionaries which is exemplified in Example 1 .\n\nIt is recommended that you use HappyROBERTA(\"roberta-large\") for masked word prediction.\nAvoid using HappyBERT for masked word prediction. \nIf you do decide to use HappyXLNET or HappyBERT, then also use their corresponding \"large cased model'. \n\n\n#### Example 1 :\n```sh\nfrom happytransformer import HappyROBERTA\n#--------------------------------------#\nhappy_roberta = HappyROBERTA(\"roberta-large\")\ntext = \"I think therefore I [MASK]\"\nresults = happy_roberta.predict_mask(text)\n\nprint(type(results)) # prints: <class 'list'>\nprint(results) # prints: [{'word': 'am', 'softmax': 0.24738965928554535}]\n\nprint(type(results[0])) # prints: <class 'dict'>\nprint(results[0]) # prints: {'word': 'am', 'softmax': 0.24738965928554535}\n\n\n```\n\n#### Example 2 :\n```sh\nfrom happytransformer import HappyROBERTA\n#--------------------------------------#\nhappy_roberta = HappROBERTA(\"roberta-large\")\ntext = \"To solve world poverty we must invest in [MASK]\"\nresults = happy_roberta.predict_mask(text, num_results = 2)\n\nprint(type(results)) # prints: <class 'list'>\nprint(results) # prints: [{'word': 'education', 'softmax': 0.34365904331207275}, {'word': 'children', 'softmax': 0.03996562585234642}]\n\nprint(type(results[0])) # prints: <class 'dict'>\nprint(results[0]) # prints: {'word': 'education', 'softmax': 0.34365904331207275}\n\n\n```\n\n#### Example 3 :\n```sh\nfrom happytransformer import HappyXLNET\n#--------------------------------------#\nhappy_xlnet = HappyXLNET(\"xlnet-large-cased\")\ntext = \"Can you please pass the [MASK] \"\noptions = [\"pizza\", \"rice\", \"tofu\", 'eggs', 'milk']\nresults = happy_xlnet.predict_mask(text, options=options, num_results=3)\n\nprint(type(results)) # prints: <class 'list'>\nprint(results) # prints: [{'word': 'tofu', 'softmax': 0.007073382}, {'word': 'pizza', 'softmax': 0.00017212195}, {'word': 'rice', 'softmax': 2.843065e-07}]\n\n\nprint(type(results[1])) # prints: <class 'dict'>\nprint(results[1]) # prints: {'word': 'pizza', 'softmax': 0.00017212195}\n\n```\n## Binary Sequence Classification \n\nBinary sequence classification (BSC) has many applications. For example, by using BSC, you can train a model to predict if a yelp review is positive or negative. \nAnother example includes determining if an email is spam or ham. \n\nEach Happy Transformer has four methods that are utilized for binary sequence classification:\n\n1. init_sequence_classifier()\n2. custom_init_sequence_classifier(args)\n3. train_sequence_classifier(train_csv_path)\n4. eval_sequence_classifier(eval_csv_path)\n\n\n### init_sequence_classifier()\nInitialize binary sequence classification for the HappyTransformer object with the default settings.\n\n\n### train_sequence_classifier(train_csv_path):\nTrains the HappyTransformer's sequence classifier.\n\nOne of the two init sequence classifier methods must be called before this method can be called.\n\nArgument:\n\n    1. train_csv_path: A string directory path to the csv that contains the training data.\n\n##### train_csv requirements: \n    1. The csv must contain *NO* header. \n    2. Each row contains a training case. \n    3. The first column contains either a 0 or a 1 to indicate whether the training case is for case \"0\" or case \"1\". \n    4. The second column contains the text for the training case\n#### Example 1\n|   |                                                              | \n|---|--------------------------------------------------------------| \n| 0 |  Terrible service and awful food                             | \n| 1 |  My new favourite Chinese restaurant!!!!                     | \n| 1 |  Amazing food and okay service. Overall a great place to eat | \n| 0 |  The restaurant smells horrible.                             | \n\nThis method does not return anything \n\n\n### eval_sequence_classifier(eval_csv_path):\nEvaluates the trained model against an input.\n\ntrain_sequence_classifier(train_csv_path): must be called before this method can be called.\n\nArgument:\n\n    1. eval_csv_path: A string directory path to the csv that contains the evaluating data.\n\n##### eval_csv requirements: (same as train_csv requirements) \n    1. The csv must contain *NO* header. \n    2. Each row contains a training case. \n    3. The first column contains either a 0 or a 1 to indicate whether the training case is for case \"0\" or case \"1\". \n    4. The second column contains the text for the training case\n\n**Returns** a python dictionary that contains a count for the following values\n\n*true_positive:* The model correctly predicted the value 1 .\n*true_negative:* The model correctly predicted the value 0.\n*false_positive':* The model incorrectly predicted the value 1.\n*false_negative* The model incorrectly predicted the value 0.\n\n\n### test_sequence_classifier(test_csv_path):\nTests the trained model against an input.\n\ntrain_sequence_classifier(train_csv_path): must be called before this method can be called.\n\nArgument:\n    1. test_csv_path: A string directory path to the csv that contains the testing data\n\n##### test_csv requirements: \n    1. The csv must contain *NO* header. \n    2. Each row contains a single test case. \n    3. The csv contains a single column with the text for each test case.\n\n#### Example 2:\n\n|                                           | \n|-------------------------------------------| \n| 5 stars!!!                                | \n| Cheap food at an expensive price          | \n| Great location and nice view of the ocean | \n| two thumbs down                           | \n\n**Returns** a list of integer values in ascending order by test case row index.\nFor example, for the csv file shown in Example 2, the result would be [1, 0, 1, 0]. \nWhere the first index in the list  corresponds to \"5 stars!!!\" \nand the last index corresponds to \"two thumbs down.\"\n\n\n#### Example 3:\n```sh\nfrom happytransformer import HappyROBERTA\n#------------------------------------------#\nhappy_roberta = HappyROBERTA()\nhappy_roberta.init_sequence_classifier()\n\ntrain_csv_path = \"data/train.csv\"\nhappy_roberta.train_sequence_classifier(train_csv_path)\n\neval_csv_path = \"data/eval.csv\"\neval_results = happy_roberta.eval_sequence_classifier(eval_csv_path)\nprint(type(eval_results)) # prints: <class 'dict'>\nprint(eval_results) # prints: {'true_positive': 300', 'true_negative': 250, 'false_positive': 40, 'false_negative': 55}\n\ntest_csv_path = \"data/test.csv\"\ntest_results = happy_roberta.test_sequence_classifier(test_csv_path)\nprint(type(test_results)) # prints: <class 'list'>\nprint(test_results) # prints: [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0 ]\n```\n\n\n### custom_init_sequence_classifier(args)\n\nInitializing the sequence classifier with custom settings. \nCalled instead of init_sequence_classifier(). \nargument:\n    1. args: a python dictionary that contains all of the same fields as the default arguments\n\n### default classifier arguments\n\n```\n# found under \"from happytransformer.classifier_args\"\nclassifier_args = {\n    # Basic fine tuning parameters\n    'learning_rate': 1e-5,\n    'num_epochs': 2,\n    'batch_size': 8,\n\n    # More advanced fine tuning parameters\n    'max_seq_length': 128,  #  Max number of tokens per input. Max value = 512\n    'adam_epsilon': 1e-5,\n    'gradient_accumulation_steps': 1,\n    'weight_decay': 0,\n    'warmup_ratio': 0.06,\n    'warmup_steps': 0,\n    'max_grad_norm': 1.0,\n\n    # More modes will become available in future releases\n    'task_mode': 'binary',\n    }\n ```\n#### Example 4:\n ```sh\nfrom happytransformer import HappyROBERTA\nfrom happytransformer import classifier_args\n#------------------------------------------#\nhappy_xlnet = HappyXLNET()\n\ncustom_args = classifier_args.copy()\ncustom_args[\"learning_rate\"] = 2e-5\ncustom_args['num_epochs'] = 4\ncustom_args[\"batch_size\"] = 3\n\nhappy_xlnet.custom_init_sequence_classifier(custom_args)\n# Continue from example 1 after \"happy_roberta.init_sequence_classifier()\"\"\n\n```\n\n\n## Next Sentence Prediction\n\n*Determine the likelihood that sentence B follows sentence A.*\n\n\n**HappyBERT** has a method called \"predict_next_sentence\" which is used for next sentence prediction tasks.\nThe method takes the following arguments:\n\n    1. sentence_a: A **single** sentence in a body of text\n    2. sentence_b: A **single** sentence that may or may not follow sentence sentence_a\n\nThis likelihood that sentence_b follows sentenced_a is returned as a boolean value that is either True or False indicating if it is true that sentence B follows sentence A.  \n\n###### Example 1:\n```sh\nfrom happytransformer import HappyBERT\n#--------------------------------------#\nhappy_bert = HappyBERT()\nsentence_a = \"How old are you?\"\nsentence_b = \"I am 93 years old.\"\nsentence_c = \"The Eiffel Tower is in Paris.\"\nresult = happy_bert.predict_next_sentence(sentence_a, sentence_b)\nprint(type(result)) # prints: <class 'bool'>\nprint(result) # prints: True\nresult = happy_bert.predict_next_sentence(sentence_a, sentence_c)\nprint(type(result)) # prints: <class 'bool'>\nprint(result) # prints: False\n```\n\n\n## Question Answering\n\n*Determine the answer to a given question using a body of supplied text.*\n\n\n**HappyBERT** has a method called \"answer_question\" which is used for question answering tasks.\nThe method takes the following arguments:\n\n    1. question: The question to be answered\n    2. text: The text containing the answer to the question\n\nThe output from the method is the answer to the question, returned as a string.\n\n###### Example 1:\n```sh\nfrom happytransformer import HappyBERT\n#--------------------------------------#\nhappy_bert = HappyBERT()\nquestion = \"Who does Ernie live with?\"\ntext = \"Ernie is an orange Muppet character on the long running PBS and HBO children's television show Sesame Street. He and his roommate Bert form the comic duo Bert and Ernie, one of the program's centerpieces, with Ernie acting the role of the na\u00efve troublemaker and Bert the world weary foil.\"  # Source: https://en.wikipedia.org/wiki/Ernie_(Sesame_Street)\nresult = happy_bert.answer_question(question, text)\nprint(type(result)) # prints: <class 'str'>\nprint(result) # prints: bert\n```\n\n\n## Masked Word Prediction Fine-Tuning\n\n*Fine-tune a state-of-the-art masked word prediction model with just a text file*\n\nEach HappyBERT and HappyROBERTA both have 4 methods that are associated with masked word prediction fine-tuning\nThey are:\n\n```\n1. init_mwp(args)\n2. train_mwp(training_path)\n3. eval_mwp(testing_path,batch_size)\n4. predict_mask(text, options, num_results)\n```\n\n### init_mwp(args)\n\n*Initialize the model for masked word prediction training.*\n\n#### Example 1 \n```python\nfrom happytransformer import HappyROBERTA\n#----------------------------------------#\n\nRoberta = HappyROBERTA()\n\nRoberta.init_train_mwp() # Initialize the training model with default settings\n\n```\n\nYou can also customize the training parameters by inputting a dictionary with specific training parameters.  The dictionary must have the same keys as the dictionary shown below. \n```python\nword_prediction_args = {\n\n\"batch_size\": 1,\n\n\"epochs\": 1,\n\n\"lr\": 5e-5,\n\n\"adam_epsilon\": 1e-8\n\n} \n```\nThe args are:\n\n- batch_size: How many sequences the model processes on one iteration.\n\n- epochs: This refers to how many times the model will train on the same dataset.\n\n-  lr (learning rate): How quickly the model learns.\n\n-  adam_epsilon: This is used to avoid diving by zero when gradient is almost zero.\n\n\nThe recommended for the parameters are:\n\n- lr: 1e-4 used in BERT and ROBERTA [1]\n\n- Adam Epsilon: 1e-6 used by Huggingface team [2]\n\n- batch_size: Depend on the user's vram, Typically 2 to 3\n\n\n#### Example 2 \n\n```python\nfrom happytransformer import HappyROBERTA\n#----------------------------------------#\n\nhappy_roberta = HappyROBERTA()\n\nword_prediction_args = {\n\"batch_size\": 4,\n\n\"epochs\": 2,\n\n\"lr\": 3e-5,\n\n\"adam_epsilon\": 1e-8\n\n} \n\nhappy_roberta.init_train_mwp(word_prediction_args)\n\n```\n\n\n### train_mwp(training_path)\n*Trains the model on Masked Language Modelling Loss.*\n\nArgument:\n1. testing_path: A string directory path to the .txt that contains the testing data.\n\nExample training.txt :\n```\nI want to get healthy in 2011 .\nI want to boost my immune system , cut that nasty dairy out , and start exercising on a regular basis .\nThat doesn 't seem to hard to follow does it ?\n```\n\n### eval_mwp(testing_path,batch_size) <br />\n*Evaluates the model on Masked Language Modelling loss and return both perplexity and masked language modelling loss.*\n\n\nPerplexity: Mathematicall it is ![equation](https://latex.codecogs.com/gif.latex?2^{Entropy}) where Entropy is the disorder in the system. Lower the perplexity the better the model is performing.\n\nMasked language modelling loss:\tsee [BERT Explained: State of the art language model for NLP](https://towardsdatascience.com/perplexity-intuition-and-derivation-105dd481c8f3) for the explanation.\n\nArguments:\n```\n1. testing_path: A string directory path to the .txt that contains the testing data.\n2. batch_size: An integer. Will default to 2.\n```\n\nExample testing.txt :\n```\nIn the few short months since Dan 's mother had moved to town , Saturday had gone from being my favourite day of the week to the one I looked forward to the least.\nAlthough she came when Dan was at work , she invariably stayed all day .\nIt was like living in a goldfish bowl and Dan was on edge the minute he came through the door.\n```\n\n\nNote 2: Evaluating on Cpu is not recommended as it will take considerably longer.\n\n## Example 3:\n\n```python\nfrom happytransformer import HappyROBERTA\n#----------------------------------------#\n\nhappy_roberta = HappyROBERTA()\nhappy_roberta.init_train_mwp(word_prediction_args)\n\ntrain_path = \"data/train.txt\"\nhappy_roberta.train_mwp(train_path)\n\neval_path = \"data/eval.txt\"\neval_results = happy_roberta.eval_mwp(eval_path)\n\nprint(type(eval_results)) # prints: <class 'dict'>\nprint(eval_results) # prints: {'perplexity': 7.863316059112549, 'eval_loss': 2.0622084404198864}\n\n```\n\n\n### Predicting masked word with fine-tuned model\n\n```python\ntext = \"Linear algebra is a branch of [MASK]\"\n\noptions = [\"music\", \"mathematics\", \"geography\"]\n\nresults = happy_roberta.predict_mask(text, options=options, num_results=3)\n\nprint(type(results)) # prints: <class 'list'>\n\nprint(results) # prints: [{'word': 'mathematics', 'softmax': 0.16551}, {'word': 'music', 'softmax': 3.91739e-05}, {'word': 'geography', 'softmax': 2.9731e-05}]\n\n```\n\n## Tech\n\n Happy Transformer uses a number of open source projects:\n\n* [transformers](https://github.com/huggingface/transformers/stargazers) - State-of-the-art Natural Language Processing for TensorFlow 2.0 and PyTorch!\n*  [pytorch](https://github.com/pytorch/pytorch) - Tensors and Dynamic neural networks in Python\n* [scikit-learn](https://github.com/scikit-learn/scikit-learn) - A set of python modules for machine learning and data mining\n* [numpy](https://github.com/numpy/numpy) - Array computation \n* [pandas](https://github.com/pandas-dev/pandas) - Powerful data structures for data analysis, time series, and statistics\n* [tqdm](https://github.com/tqdm/tqdm) - A Fast, Extensible Progress Bar for Python and CLI\n*  [pytorch-transformers-classification](https://github.com/ThilinaRajapakse/pytorch-transformers-classification) - Text classification for BERT, RoBERTa, XLNet and XLM\n\n HappyTransformer is also an open source project with this [public repository](https://github.com/EricFillion/happy-transformer)\n on GitHub. \n\n### Call for contributors \n Happy Transformer is a new and growing API. We're seeking more contributors to help accomplish our mission of making state-of-the-art AI easier to use.  \n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/EricFillion/happy-transformer", "keywords": "bert,roberta,xlnet,word,predictionmasked,transformer,happy,HappyTransformer,binary,sequence,classification,pytorch,nlp,nlu,natural,language,processing,understanding", "license": "Apache 2.0", "maintainer": "", "maintainer_email": "", "name": "happytransformer", "package_url": "https://pypi.org/project/happytransformer/", "platform": "", "project_url": "https://pypi.org/project/happytransformer/", "project_urls": {"Homepage": "https://github.com/EricFillion/happy-transformer"}, "release_url": "https://pypi.org/project/happytransformer/1.1.2/", "requires_dist": ["numpy", "torch", "pandas", "tqdm", "scikit-learn", "transformers"], "requires_python": "", "summary": "Happy Transformer is an API built on top of PyTorch's transformer library that makes it easy to utilize state-of-the-art NLP models.", "version": "1.1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://opensource.org/licenses/Apache-2.0\" rel=\"nofollow\"><img alt=\"License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b97ca76cf5d8fd16c7bc4731270e0bbe53df7aa1/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d417061636865253230322e302d626c75652e737667\"></a> <a href=\"https://pepy.tech/project/happytransformer\" rel=\"nofollow\"><img alt=\"Downloads\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/42e32ee4c21ad03222d5c6a7fda1bafad3dd54cb/68747470733a2f2f706570792e746563682f62616467652f68617070797472616e73666f726d6572\"></a></p>\n<h1>Happy Transformer</h1>\n<p><img alt=\"HappyTransformer\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3a6d2c44ec862202debe59ef1d1e4d63d16d42a7/696d672f48617070795472616e73666f726d65722e706e67\"></p>\n<p>Happy Transformer is an API built on top of <a href=\"https://pytorch.org/hub/huggingface_pytorch-transformers/\" rel=\"nofollow\">PyTorch's transformer library</a> that makes it easy to utilize state-of-the-art NLP models.</p>\n<h2>Key Features</h2>\n<ul>\n<li><strong>New: Finetuning Masked Language Models</strong></li>\n<li>Available language models: XLNET, BERT and ROBERTA.</li>\n<li>Predict a masked word within a sentence.</li>\n<li>Fine tune binary sequence classification models to solve problems like sentiment analysis.</li>\n<li>Predict the likelihood that sentence B follows sentence A within a paragraph.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Public Methods</th>\n<th>HappyROBERTA</th>\n<th>HappyXLNET</th>\n<th>HappyBERT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Masked Word Prediction</td>\n<td>\u2714</td>\n<td>\u2714</td>\n<td>\u2714</td>\n</tr>\n<tr>\n<td>Sequence Classification</td>\n<td>\u2714</td>\n<td>\u2714</td>\n<td>\u2714</td>\n</tr>\n<tr>\n<td>Next Sentence Prediction</td>\n<td></td>\n<td></td>\n<td>\u2714</td>\n</tr>\n<tr>\n<td>Question Answering</td>\n<td></td>\n<td></td>\n<td>\u2714</td>\n</tr>\n<tr>\n<td>Masked Word Prediction Finetuning</td>\n<td>\u2714</td>\n<td></td>\n<td>\u2714</td>\n</tr></tbody></table>\n<h2>Installation</h2>\n<pre>pip install happytransformer\n</pre>\n<h2>Initialization</h2>\n<p>By default base models are used. They are smaller, faster and require significantly less training time\nto obtain decent results.</p>\n<p>Large models are recommended for tasks that do not require fine tuning such as some word prediction tasks.</p>\n<p>Base models are recommended for tasks that require fine tuning with limited available training data.</p>\n<p>Uncased models do not differentiate between cased and uncased words. For example, the words\n\"empire\" and \"Empire\" would be reduced to the same token. In comparison, cased models do differentiate between cased and uncased words.</p>\n<h4>HappyXLNET:</h4>\n<pre>from happytransformer import HappyXLNET\n<span class=\"c1\">#--------------------------------------#</span>\n<span class=\"nv\">xl_base_cased</span> <span class=\"o\">=</span> HappyXLNET<span class=\"o\">(</span><span class=\"s2\">\"xlnet-base-cased\"</span><span class=\"o\">)</span>\n<span class=\"nv\">xl_large_cased</span> <span class=\"o\">=</span> HappyXLNET<span class=\"o\">(</span><span class=\"s2\">\"xlnet-large-cased\"</span><span class=\"o\">)</span>\n</pre>\n<h4>HappyROBERTA:</h4>\n<pre>from happytransformer import HappyROBERTA\n<span class=\"c1\">#--------------------------------------#</span>\n<span class=\"nv\">happy_roberta_base</span> <span class=\"o\">=</span> HappyROBERTA<span class=\"o\">(</span><span class=\"s2\">\"roberta-base\"</span><span class=\"o\">)</span>\n<span class=\"nv\">happy_roberta_large</span> <span class=\"o\">=</span> HappyROBERTA<span class=\"o\">(</span><span class=\"s2\">\"roberta-large\"</span><span class=\"o\">)</span>\n</pre>\n<h4>HappyBERT :</h4>\n<pre>from happytransformer import HappyBERT\n<span class=\"c1\">#--------------------------------------#</span>\n<span class=\"nv\">bert_base_uncased</span> <span class=\"o\">=</span> HappyBERT<span class=\"o\">(</span><span class=\"s2\">\"bert-base-uncased\"</span><span class=\"o\">)</span>\n<span class=\"nv\">bert_base_cased</span> <span class=\"o\">=</span> HappyBERT<span class=\"o\">(</span><span class=\"s2\">\"bert-base-cased\"</span><span class=\"o\">)</span>\n<span class=\"nv\">bert_large_uncased</span> <span class=\"o\">=</span> HappyBERT<span class=\"o\">(</span><span class=\"s2\">\"bert-large-uncased\"</span><span class=\"o\">)</span>\n<span class=\"nv\">bert_large_cased</span> <span class=\"o\">=</span> HappyBERT<span class=\"o\">(</span><span class=\"s2\">\"bert-large-cased\"</span><span class=\"o\">)</span>\n</pre>\n<h2>Word Prediction</h2>\n<p>Each Happy Transformer has a public  method called \"predict_mask(text, options, num_results)\" with the following input arguments.</p>\n<ol>\n<li>Text: the text you wish to predict including a single masked token.</li>\n<li>options (default = every word): A limited set of words the model can return.</li>\n<li>num_results (default = 1): The number of returned predictions.</li>\n</ol>\n<p>For all Happy Transformers, the masked token is <strong>\"[MASK]\"</strong></p>\n<p>\"predict_mask(text, options, num_results)\" returns a list of dictionaries which is exemplified in Example 1 .</p>\n<p>It is recommended that you use HappyROBERTA(\"roberta-large\") for masked word prediction.\nAvoid using HappyBERT for masked word prediction.\nIf you do decide to use HappyXLNET or HappyBERT, then also use their corresponding \"large cased model'.</p>\n<h4>Example 1 :</h4>\n<pre>from happytransformer import HappyROBERTA\n<span class=\"c1\">#--------------------------------------#</span>\n<span class=\"nv\">happy_roberta</span> <span class=\"o\">=</span> HappyROBERTA<span class=\"o\">(</span><span class=\"s2\">\"roberta-large\"</span><span class=\"o\">)</span>\n<span class=\"nv\">text</span> <span class=\"o\">=</span> <span class=\"s2\">\"I think therefore I [MASK]\"</span>\n<span class=\"nv\">results</span> <span class=\"o\">=</span> happy_roberta.predict_mask<span class=\"o\">(</span>text<span class=\"o\">)</span>\n\nprint<span class=\"o\">(</span>type<span class=\"o\">(</span>results<span class=\"o\">))</span> <span class=\"c1\"># prints: &lt;class 'list'&gt;</span>\nprint<span class=\"o\">(</span>results<span class=\"o\">)</span> <span class=\"c1\"># prints: [{'word': 'am', 'softmax': 0.24738965928554535}]</span>\n\nprint<span class=\"o\">(</span>type<span class=\"o\">(</span>results<span class=\"o\">[</span><span class=\"m\">0</span><span class=\"o\">]))</span> <span class=\"c1\"># prints: &lt;class 'dict'&gt;</span>\nprint<span class=\"o\">(</span>results<span class=\"o\">[</span><span class=\"m\">0</span><span class=\"o\">])</span> <span class=\"c1\"># prints: {'word': 'am', 'softmax': 0.24738965928554535}</span>\n</pre>\n<h4>Example 2 :</h4>\n<pre>from happytransformer import HappyROBERTA\n<span class=\"c1\">#--------------------------------------#</span>\n<span class=\"nv\">happy_roberta</span> <span class=\"o\">=</span> HappROBERTA<span class=\"o\">(</span><span class=\"s2\">\"roberta-large\"</span><span class=\"o\">)</span>\n<span class=\"nv\">text</span> <span class=\"o\">=</span> <span class=\"s2\">\"To solve world poverty we must invest in [MASK]\"</span>\n<span class=\"nv\">results</span> <span class=\"o\">=</span> happy_roberta.predict_mask<span class=\"o\">(</span>text, <span class=\"nv\">num_results</span> <span class=\"o\">=</span> <span class=\"m\">2</span><span class=\"o\">)</span>\n\nprint<span class=\"o\">(</span>type<span class=\"o\">(</span>results<span class=\"o\">))</span> <span class=\"c1\"># prints: &lt;class 'list'&gt;</span>\nprint<span class=\"o\">(</span>results<span class=\"o\">)</span> <span class=\"c1\"># prints: [{'word': 'education', 'softmax': 0.34365904331207275}, {'word': 'children', 'softmax': 0.03996562585234642}]</span>\n\nprint<span class=\"o\">(</span>type<span class=\"o\">(</span>results<span class=\"o\">[</span><span class=\"m\">0</span><span class=\"o\">]))</span> <span class=\"c1\"># prints: &lt;class 'dict'&gt;</span>\nprint<span class=\"o\">(</span>results<span class=\"o\">[</span><span class=\"m\">0</span><span class=\"o\">])</span> <span class=\"c1\"># prints: {'word': 'education', 'softmax': 0.34365904331207275}</span>\n</pre>\n<h4>Example 3 :</h4>\n<pre>from happytransformer import HappyXLNET\n<span class=\"c1\">#--------------------------------------#</span>\n<span class=\"nv\">happy_xlnet</span> <span class=\"o\">=</span> HappyXLNET<span class=\"o\">(</span><span class=\"s2\">\"xlnet-large-cased\"</span><span class=\"o\">)</span>\n<span class=\"nv\">text</span> <span class=\"o\">=</span> <span class=\"s2\">\"Can you please pass the [MASK] \"</span>\n<span class=\"nv\">options</span> <span class=\"o\">=</span> <span class=\"o\">[</span><span class=\"s2\">\"pizza\"</span>, <span class=\"s2\">\"rice\"</span>, <span class=\"s2\">\"tofu\"</span>, <span class=\"s1\">'eggs'</span>, <span class=\"s1\">'milk'</span><span class=\"o\">]</span>\n<span class=\"nv\">results</span> <span class=\"o\">=</span> happy_xlnet.predict_mask<span class=\"o\">(</span>text, <span class=\"nv\">options</span><span class=\"o\">=</span>options, <span class=\"nv\">num_results</span><span class=\"o\">=</span><span class=\"m\">3</span><span class=\"o\">)</span>\n\nprint<span class=\"o\">(</span>type<span class=\"o\">(</span>results<span class=\"o\">))</span> <span class=\"c1\"># prints: &lt;class 'list'&gt;</span>\nprint<span class=\"o\">(</span>results<span class=\"o\">)</span> <span class=\"c1\"># prints: [{'word': 'tofu', 'softmax': 0.007073382}, {'word': 'pizza', 'softmax': 0.00017212195}, {'word': 'rice', 'softmax': 2.843065e-07}]</span>\n\n\nprint<span class=\"o\">(</span>type<span class=\"o\">(</span>results<span class=\"o\">[</span><span class=\"m\">1</span><span class=\"o\">]))</span> <span class=\"c1\"># prints: &lt;class 'dict'&gt;</span>\nprint<span class=\"o\">(</span>results<span class=\"o\">[</span><span class=\"m\">1</span><span class=\"o\">])</span> <span class=\"c1\"># prints: {'word': 'pizza', 'softmax': 0.00017212195}</span>\n</pre>\n<h2>Binary Sequence Classification</h2>\n<p>Binary sequence classification (BSC) has many applications. For example, by using BSC, you can train a model to predict if a yelp review is positive or negative.\nAnother example includes determining if an email is spam or ham.</p>\n<p>Each Happy Transformer has four methods that are utilized for binary sequence classification:</p>\n<ol>\n<li>init_sequence_classifier()</li>\n<li>custom_init_sequence_classifier(args)</li>\n<li>train_sequence_classifier(train_csv_path)</li>\n<li>eval_sequence_classifier(eval_csv_path)</li>\n</ol>\n<h3>init_sequence_classifier()</h3>\n<p>Initialize binary sequence classification for the HappyTransformer object with the default settings.</p>\n<h3>train_sequence_classifier(train_csv_path):</h3>\n<p>Trains the HappyTransformer's sequence classifier.</p>\n<p>One of the two init sequence classifier methods must be called before this method can be called.</p>\n<p>Argument:</p>\n<pre><code>1. train_csv_path: A string directory path to the csv that contains the training data.\n</code></pre>\n<h5>train_csv requirements:</h5>\n<pre><code>1. The csv must contain *NO* header. \n2. Each row contains a training case. \n3. The first column contains either a 0 or a 1 to indicate whether the training case is for case \"0\" or case \"1\". \n4. The second column contains the text for the training case\n</code></pre>\n<h4>Example 1</h4>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>Terrible service and awful food</td>\n</tr>\n<tr>\n<td>1</td>\n<td>My new favourite Chinese restaurant!!!!</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Amazing food and okay service. Overall a great place to eat</td>\n</tr>\n<tr>\n<td>0</td>\n<td>The restaurant smells horrible.</td>\n</tr></tbody></table>\n<p>This method does not return anything</p>\n<h3>eval_sequence_classifier(eval_csv_path):</h3>\n<p>Evaluates the trained model against an input.</p>\n<p>train_sequence_classifier(train_csv_path): must be called before this method can be called.</p>\n<p>Argument:</p>\n<pre><code>1. eval_csv_path: A string directory path to the csv that contains the evaluating data.\n</code></pre>\n<h5>eval_csv requirements: (same as train_csv requirements)</h5>\n<pre><code>1. The csv must contain *NO* header. \n2. Each row contains a training case. \n3. The first column contains either a 0 or a 1 to indicate whether the training case is for case \"0\" or case \"1\". \n4. The second column contains the text for the training case\n</code></pre>\n<p><strong>Returns</strong> a python dictionary that contains a count for the following values</p>\n<p><em>true_positive:</em> The model correctly predicted the value 1 .\n<em>true_negative:</em> The model correctly predicted the value 0.\n<em>false_positive':</em> The model incorrectly predicted the value 1.\n<em>false_negative</em> The model incorrectly predicted the value 0.</p>\n<h3>test_sequence_classifier(test_csv_path):</h3>\n<p>Tests the trained model against an input.</p>\n<p>train_sequence_classifier(train_csv_path): must be called before this method can be called.</p>\n<p>Argument:\n1. test_csv_path: A string directory path to the csv that contains the testing data</p>\n<h5>test_csv requirements:</h5>\n<pre><code>1. The csv must contain *NO* header. \n2. Each row contains a single test case. \n3. The csv contains a single column with the text for each test case.\n</code></pre>\n<h4>Example 2:</h4>\n<table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5 stars!!!</td>\n</tr>\n<tr>\n<td>Cheap food at an expensive price</td>\n</tr>\n<tr>\n<td>Great location and nice view of the ocean</td>\n</tr>\n<tr>\n<td>two thumbs down</td>\n</tr></tbody></table>\n<p><strong>Returns</strong> a list of integer values in ascending order by test case row index.\nFor example, for the csv file shown in Example 2, the result would be [1, 0, 1, 0].\nWhere the first index in the list  corresponds to \"5 stars!!!\"\nand the last index corresponds to \"two thumbs down.\"</p>\n<h4>Example 3:</h4>\n<pre>from happytransformer import HappyROBERTA\n<span class=\"c1\">#------------------------------------------#</span>\n<span class=\"nv\">happy_roberta</span> <span class=\"o\">=</span> HappyROBERTA<span class=\"o\">()</span>\nhappy_roberta.init_sequence_classifier<span class=\"o\">()</span>\n\n<span class=\"nv\">train_csv_path</span> <span class=\"o\">=</span> <span class=\"s2\">\"data/train.csv\"</span>\nhappy_roberta.train_sequence_classifier<span class=\"o\">(</span>train_csv_path<span class=\"o\">)</span>\n\n<span class=\"nv\">eval_csv_path</span> <span class=\"o\">=</span> <span class=\"s2\">\"data/eval.csv\"</span>\n<span class=\"nv\">eval_results</span> <span class=\"o\">=</span> happy_roberta.eval_sequence_classifier<span class=\"o\">(</span>eval_csv_path<span class=\"o\">)</span>\nprint<span class=\"o\">(</span>type<span class=\"o\">(</span>eval_results<span class=\"o\">))</span> <span class=\"c1\"># prints: &lt;class 'dict'&gt;</span>\nprint<span class=\"o\">(</span>eval_results<span class=\"o\">)</span> <span class=\"c1\"># prints: {'true_positive': 300', 'true_negative': 250, 'false_positive': 40, 'false_negative': 55}</span>\n\n<span class=\"nv\">test_csv_path</span> <span class=\"o\">=</span> <span class=\"s2\">\"data/test.csv\"</span>\n<span class=\"nv\">test_results</span> <span class=\"o\">=</span> happy_roberta.test_sequence_classifier<span class=\"o\">(</span>test_csv_path<span class=\"o\">)</span>\nprint<span class=\"o\">(</span>type<span class=\"o\">(</span>test_results<span class=\"o\">))</span> <span class=\"c1\"># prints: &lt;class 'list'&gt;</span>\nprint<span class=\"o\">(</span>test_results<span class=\"o\">)</span> <span class=\"c1\"># prints: [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0 ]</span>\n</pre>\n<h3>custom_init_sequence_classifier(args)</h3>\n<p>Initializing the sequence classifier with custom settings.\nCalled instead of init_sequence_classifier().\nargument:\n1. args: a python dictionary that contains all of the same fields as the default arguments</p>\n<h3>default classifier arguments</h3>\n<pre><code># found under \"from happytransformer.classifier_args\"\nclassifier_args = {\n    # Basic fine tuning parameters\n    'learning_rate': 1e-5,\n    'num_epochs': 2,\n    'batch_size': 8,\n\n    # More advanced fine tuning parameters\n    'max_seq_length': 128,  #  Max number of tokens per input. Max value = 512\n    'adam_epsilon': 1e-5,\n    'gradient_accumulation_steps': 1,\n    'weight_decay': 0,\n    'warmup_ratio': 0.06,\n    'warmup_steps': 0,\n    'max_grad_norm': 1.0,\n\n    # More modes will become available in future releases\n    'task_mode': 'binary',\n    }\n</code></pre>\n<h4>Example 4:</h4>\n<pre>from happytransformer import HappyROBERTA\nfrom happytransformer import classifier_args\n<span class=\"c1\">#------------------------------------------#</span>\n<span class=\"nv\">happy_xlnet</span> <span class=\"o\">=</span> HappyXLNET<span class=\"o\">()</span>\n\n<span class=\"nv\">custom_args</span> <span class=\"o\">=</span> classifier_args.copy<span class=\"o\">()</span>\ncustom_args<span class=\"o\">[</span><span class=\"s2\">\"learning_rate\"</span><span class=\"o\">]</span> <span class=\"o\">=</span> 2e-5\ncustom_args<span class=\"o\">[</span><span class=\"s1\">'num_epochs'</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"m\">4</span>\ncustom_args<span class=\"o\">[</span><span class=\"s2\">\"batch_size\"</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"m\">3</span>\n\nhappy_xlnet.custom_init_sequence_classifier<span class=\"o\">(</span>custom_args<span class=\"o\">)</span>\n<span class=\"c1\"># Continue from example 1 after \"happy_roberta.init_sequence_classifier()\"\"</span>\n</pre>\n<h2>Next Sentence Prediction</h2>\n<p><em>Determine the likelihood that sentence B follows sentence A.</em></p>\n<p><strong>HappyBERT</strong> has a method called \"predict_next_sentence\" which is used for next sentence prediction tasks.\nThe method takes the following arguments:</p>\n<pre><code>1. sentence_a: A **single** sentence in a body of text\n2. sentence_b: A **single** sentence that may or may not follow sentence sentence_a\n</code></pre>\n<p>This likelihood that sentence_b follows sentenced_a is returned as a boolean value that is either True or False indicating if it is true that sentence B follows sentence A.</p>\n<h6>Example 1:</h6>\n<pre>from happytransformer import HappyBERT\n<span class=\"c1\">#--------------------------------------#</span>\n<span class=\"nv\">happy_bert</span> <span class=\"o\">=</span> HappyBERT<span class=\"o\">()</span>\n<span class=\"nv\">sentence_a</span> <span class=\"o\">=</span> <span class=\"s2\">\"How old are you?\"</span>\n<span class=\"nv\">sentence_b</span> <span class=\"o\">=</span> <span class=\"s2\">\"I am 93 years old.\"</span>\n<span class=\"nv\">sentence_c</span> <span class=\"o\">=</span> <span class=\"s2\">\"The Eiffel Tower is in Paris.\"</span>\n<span class=\"nv\">result</span> <span class=\"o\">=</span> happy_bert.predict_next_sentence<span class=\"o\">(</span>sentence_a, sentence_b<span class=\"o\">)</span>\nprint<span class=\"o\">(</span>type<span class=\"o\">(</span>result<span class=\"o\">))</span> <span class=\"c1\"># prints: &lt;class 'bool'&gt;</span>\nprint<span class=\"o\">(</span>result<span class=\"o\">)</span> <span class=\"c1\"># prints: True</span>\n<span class=\"nv\">result</span> <span class=\"o\">=</span> happy_bert.predict_next_sentence<span class=\"o\">(</span>sentence_a, sentence_c<span class=\"o\">)</span>\nprint<span class=\"o\">(</span>type<span class=\"o\">(</span>result<span class=\"o\">))</span> <span class=\"c1\"># prints: &lt;class 'bool'&gt;</span>\nprint<span class=\"o\">(</span>result<span class=\"o\">)</span> <span class=\"c1\"># prints: False</span>\n</pre>\n<h2>Question Answering</h2>\n<p><em>Determine the answer to a given question using a body of supplied text.</em></p>\n<p><strong>HappyBERT</strong> has a method called \"answer_question\" which is used for question answering tasks.\nThe method takes the following arguments:</p>\n<pre><code>1. question: The question to be answered\n2. text: The text containing the answer to the question\n</code></pre>\n<p>The output from the method is the answer to the question, returned as a string.</p>\n<h6>Example 1:</h6>\n<pre>from happytransformer import HappyBERT\n<span class=\"c1\">#--------------------------------------#</span>\n<span class=\"nv\">happy_bert</span> <span class=\"o\">=</span> HappyBERT<span class=\"o\">()</span>\n<span class=\"nv\">question</span> <span class=\"o\">=</span> <span class=\"s2\">\"Who does Ernie live with?\"</span>\n<span class=\"nv\">text</span> <span class=\"o\">=</span> <span class=\"s2\">\"Ernie is an orange Muppet character on the long running PBS and HBO children's television show Sesame Street. He and his roommate Bert form the comic duo Bert and Ernie, one of the program's centerpieces, with Ernie acting the role of the na\u00efve troublemaker and Bert the world weary foil.\"</span>  <span class=\"c1\"># Source: https://en.wikipedia.org/wiki/Ernie_(Sesame_Street)</span>\n<span class=\"nv\">result</span> <span class=\"o\">=</span> happy_bert.answer_question<span class=\"o\">(</span>question, text<span class=\"o\">)</span>\nprint<span class=\"o\">(</span>type<span class=\"o\">(</span>result<span class=\"o\">))</span> <span class=\"c1\"># prints: &lt;class 'str'&gt;</span>\nprint<span class=\"o\">(</span>result<span class=\"o\">)</span> <span class=\"c1\"># prints: bert</span>\n</pre>\n<h2>Masked Word Prediction Fine-Tuning</h2>\n<p><em>Fine-tune a state-of-the-art masked word prediction model with just a text file</em></p>\n<p>Each HappyBERT and HappyROBERTA both have 4 methods that are associated with masked word prediction fine-tuning\nThey are:</p>\n<pre><code>1. init_mwp(args)\n2. train_mwp(training_path)\n3. eval_mwp(testing_path,batch_size)\n4. predict_mask(text, options, num_results)\n</code></pre>\n<h3>init_mwp(args)</h3>\n<p><em>Initialize the model for masked word prediction training.</em></p>\n<h4>Example 1</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">happytransformer</span> <span class=\"kn\">import</span> <span class=\"n\">HappyROBERTA</span>\n<span class=\"c1\">#----------------------------------------#</span>\n\n<span class=\"n\">Roberta</span> <span class=\"o\">=</span> <span class=\"n\">HappyROBERTA</span><span class=\"p\">()</span>\n\n<span class=\"n\">Roberta</span><span class=\"o\">.</span><span class=\"n\">init_train_mwp</span><span class=\"p\">()</span> <span class=\"c1\"># Initialize the training model with default settings</span>\n</pre>\n<p>You can also customize the training parameters by inputting a dictionary with specific training parameters.  The dictionary must have the same keys as the dictionary shown below.</p>\n<pre><span class=\"n\">word_prediction_args</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n\n<span class=\"s2\">\"batch_size\"</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n\n<span class=\"s2\">\"epochs\"</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n\n<span class=\"s2\">\"lr\"</span><span class=\"p\">:</span> <span class=\"mf\">5e-5</span><span class=\"p\">,</span>\n\n<span class=\"s2\">\"adam_epsilon\"</span><span class=\"p\">:</span> <span class=\"mf\">1e-8</span>\n\n<span class=\"p\">}</span> \n</pre>\n<p>The args are:</p>\n<ul>\n<li>\n<p>batch_size: How many sequences the model processes on one iteration.</p>\n</li>\n<li>\n<p>epochs: This refers to how many times the model will train on the same dataset.</p>\n</li>\n<li>\n<p>lr (learning rate): How quickly the model learns.</p>\n</li>\n<li>\n<p>adam_epsilon: This is used to avoid diving by zero when gradient is almost zero.</p>\n</li>\n</ul>\n<p>The recommended for the parameters are:</p>\n<ul>\n<li>\n<p>lr: 1e-4 used in BERT and ROBERTA [1]</p>\n</li>\n<li>\n<p>Adam Epsilon: 1e-6 used by Huggingface team [2]</p>\n</li>\n<li>\n<p>batch_size: Depend on the user's vram, Typically 2 to 3</p>\n</li>\n</ul>\n<h4>Example 2</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">happytransformer</span> <span class=\"kn\">import</span> <span class=\"n\">HappyROBERTA</span>\n<span class=\"c1\">#----------------------------------------#</span>\n\n<span class=\"n\">happy_roberta</span> <span class=\"o\">=</span> <span class=\"n\">HappyROBERTA</span><span class=\"p\">()</span>\n\n<span class=\"n\">word_prediction_args</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n<span class=\"s2\">\"batch_size\"</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span>\n\n<span class=\"s2\">\"epochs\"</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span>\n\n<span class=\"s2\">\"lr\"</span><span class=\"p\">:</span> <span class=\"mf\">3e-5</span><span class=\"p\">,</span>\n\n<span class=\"s2\">\"adam_epsilon\"</span><span class=\"p\">:</span> <span class=\"mf\">1e-8</span>\n\n<span class=\"p\">}</span> \n\n<span class=\"n\">happy_roberta</span><span class=\"o\">.</span><span class=\"n\">init_train_mwp</span><span class=\"p\">(</span><span class=\"n\">word_prediction_args</span><span class=\"p\">)</span>\n</pre>\n<h3>train_mwp(training_path)</h3>\n<p><em>Trains the model on Masked Language Modelling Loss.</em></p>\n<p>Argument:</p>\n<ol>\n<li>testing_path: A string directory path to the .txt that contains the testing data.</li>\n</ol>\n<p>Example training.txt :</p>\n<pre><code>I want to get healthy in 2011 .\nI want to boost my immune system , cut that nasty dairy out , and start exercising on a regular basis .\nThat doesn 't seem to hard to follow does it ?\n</code></pre>\n<h3>eval_mwp(testing_path,batch_size) <br></h3>\n<p><em>Evaluates the model on Masked Language Modelling loss and return both perplexity and masked language modelling loss.</em></p>\n<p>Perplexity: Mathematicall it is <img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/995569d74f78986d633ef7046d570562dc67345c/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f32253545253742456e74726f7079253744\"> where Entropy is the disorder in the system. Lower the perplexity the better the model is performing.</p>\n<p>Masked language modelling loss:\tsee <a href=\"https://towardsdatascience.com/perplexity-intuition-and-derivation-105dd481c8f3\" rel=\"nofollow\">BERT Explained: State of the art language model for NLP</a> for the explanation.</p>\n<p>Arguments:</p>\n<pre><code>1. testing_path: A string directory path to the .txt that contains the testing data.\n2. batch_size: An integer. Will default to 2.\n</code></pre>\n<p>Example testing.txt :</p>\n<pre><code>In the few short months since Dan 's mother had moved to town , Saturday had gone from being my favourite day of the week to the one I looked forward to the least.\nAlthough she came when Dan was at work , she invariably stayed all day .\nIt was like living in a goldfish bowl and Dan was on edge the minute he came through the door.\n</code></pre>\n<p>Note 2: Evaluating on Cpu is not recommended as it will take considerably longer.</p>\n<h2>Example 3:</h2>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">happytransformer</span> <span class=\"kn\">import</span> <span class=\"n\">HappyROBERTA</span>\n<span class=\"c1\">#----------------------------------------#</span>\n\n<span class=\"n\">happy_roberta</span> <span class=\"o\">=</span> <span class=\"n\">HappyROBERTA</span><span class=\"p\">()</span>\n<span class=\"n\">happy_roberta</span><span class=\"o\">.</span><span class=\"n\">init_train_mwp</span><span class=\"p\">(</span><span class=\"n\">word_prediction_args</span><span class=\"p\">)</span>\n\n<span class=\"n\">train_path</span> <span class=\"o\">=</span> <span class=\"s2\">\"data/train.txt\"</span>\n<span class=\"n\">happy_roberta</span><span class=\"o\">.</span><span class=\"n\">train_mwp</span><span class=\"p\">(</span><span class=\"n\">train_path</span><span class=\"p\">)</span>\n\n<span class=\"n\">eval_path</span> <span class=\"o\">=</span> <span class=\"s2\">\"data/eval.txt\"</span>\n<span class=\"n\">eval_results</span> <span class=\"o\">=</span> <span class=\"n\">happy_roberta</span><span class=\"o\">.</span><span class=\"n\">eval_mwp</span><span class=\"p\">(</span><span class=\"n\">eval_path</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">eval_results</span><span class=\"p\">))</span> <span class=\"c1\"># prints: &lt;class 'dict'&gt;</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">eval_results</span><span class=\"p\">)</span> <span class=\"c1\"># prints: {'perplexity': 7.863316059112549, 'eval_loss': 2.0622084404198864}</span>\n</pre>\n<h3>Predicting masked word with fine-tuned model</h3>\n<pre><span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"s2\">\"Linear algebra is a branch of [MASK]\"</span>\n\n<span class=\"n\">options</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"music\"</span><span class=\"p\">,</span> <span class=\"s2\">\"mathematics\"</span><span class=\"p\">,</span> <span class=\"s2\">\"geography\"</span><span class=\"p\">]</span>\n\n<span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">happy_roberta</span><span class=\"o\">.</span><span class=\"n\">predict_mask</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">,</span> <span class=\"n\">options</span><span class=\"o\">=</span><span class=\"n\">options</span><span class=\"p\">,</span> <span class=\"n\">num_results</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">results</span><span class=\"p\">))</span> <span class=\"c1\"># prints: &lt;class 'list'&gt;</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">results</span><span class=\"p\">)</span> <span class=\"c1\"># prints: [{'word': 'mathematics', 'softmax': 0.16551}, {'word': 'music', 'softmax': 3.91739e-05}, {'word': 'geography', 'softmax': 2.9731e-05}]</span>\n</pre>\n<h2>Tech</h2>\n<p>Happy Transformer uses a number of open source projects:</p>\n<ul>\n<li><a href=\"https://github.com/huggingface/transformers/stargazers\" rel=\"nofollow\">transformers</a> - State-of-the-art Natural Language Processing for TensorFlow 2.0 and PyTorch!</li>\n<li><a href=\"https://github.com/pytorch/pytorch\" rel=\"nofollow\">pytorch</a> - Tensors and Dynamic neural networks in Python</li>\n<li><a href=\"https://github.com/scikit-learn/scikit-learn\" rel=\"nofollow\">scikit-learn</a> - A set of python modules for machine learning and data mining</li>\n<li><a href=\"https://github.com/numpy/numpy\" rel=\"nofollow\">numpy</a> - Array computation</li>\n<li><a href=\"https://github.com/pandas-dev/pandas\" rel=\"nofollow\">pandas</a> - Powerful data structures for data analysis, time series, and statistics</li>\n<li><a href=\"https://github.com/tqdm/tqdm\" rel=\"nofollow\">tqdm</a> - A Fast, Extensible Progress Bar for Python and CLI</li>\n<li><a href=\"https://github.com/ThilinaRajapakse/pytorch-transformers-classification\" rel=\"nofollow\">pytorch-transformers-classification</a> - Text classification for BERT, RoBERTa, XLNet and XLM</li>\n</ul>\n<p>HappyTransformer is also an open source project with this <a href=\"https://github.com/EricFillion/happy-transformer\" rel=\"nofollow\">public repository</a>\non GitHub.</p>\n<h3>Call for contributors</h3>\n<p>Happy Transformer is a new and growing API. We're seeking more contributors to help accomplish our mission of making state-of-the-art AI easier to use.</p>\n\n          </div>"}, "last_serial": 7122381, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "c969c00ea63495361458e40e3d2d5f1a", "sha256": "e3c3906b0d27372fbcb479dcc7518266c5cc9f869149ff864e932177ef36d75d"}, "downloads": -1, "filename": "happytransformer-1.0.0.tar.gz", "has_sig": false, "md5_digest": "c969c00ea63495361458e40e3d2d5f1a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22191, "upload_time": "2020-01-11T19:47:02", "upload_time_iso_8601": "2020-01-11T19:47:02.721033Z", "url": "https://files.pythonhosted.org/packages/c7/75/2de121bb521b51abd9f66c35d20a5d327d697a15acb8d2c03a5fda0bc012/happytransformer-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "56a3ba0c2c0533bac796a899d8af0fc8", "sha256": "b0b7617430a98ac88623c085f7f32f1c3a0ea27504a6e4b9dab82032aea0d78b"}, "downloads": -1, "filename": "happytransformer-1.0.1.tar.gz", "has_sig": false, "md5_digest": "56a3ba0c2c0533bac796a899d8af0fc8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22189, "upload_time": "2020-01-11T20:17:23", "upload_time_iso_8601": "2020-01-11T20:17:23.234710Z", "url": "https://files.pythonhosted.org/packages/2f/ec/00f29acc3e412473b5723b64733f45b070137f4d3aba256b1b2daead53ab/happytransformer-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "48ecc676a8e772a55504bad09625d59a", "sha256": "8bd0e96fdb7823e9160cc4219bfbffe52c59e7ec6cbef2d3cd708abb863b327b"}, "downloads": -1, "filename": "happytransformer-1.0.2.tar.gz", "has_sig": false, "md5_digest": "48ecc676a8e772a55504bad09625d59a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22411, "upload_time": "2020-01-24T23:39:39", "upload_time_iso_8601": "2020-01-24T23:39:39.020082Z", "url": "https://files.pythonhosted.org/packages/b9/f5/83c3f177b4bac8a895cb50583a9046d66b82434d45991568e636682ef5c5/happytransformer-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "e583f1c83ad927d3fa5f321706de18b8", "sha256": "06b1bff4eaf3552b3730c407355ba76d00315628cd33b5b81fdf5db544ce0fc8"}, "downloads": -1, "filename": "happytransformer-1.0.3.tar.gz", "has_sig": false, "md5_digest": "e583f1c83ad927d3fa5f321706de18b8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22424, "upload_time": "2020-01-25T00:20:06", "upload_time_iso_8601": "2020-01-25T00:20:06.590912Z", "url": "https://files.pythonhosted.org/packages/cb/02/1b0256dbc53ed30e39ba47554b3ff487ec27e25b1249f85d1adb30caf6a1/happytransformer-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "68d382b72428b818dadd4a4777232008", "sha256": "9b23e862c2c183f1608ba56eb078b6507c8d3b918f3091a24671a4087d5b3364"}, "downloads": -1, "filename": "happytransformer-1.0.4.tar.gz", "has_sig": false, "md5_digest": "68d382b72428b818dadd4a4777232008", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23539, "upload_time": "2020-01-27T01:00:24", "upload_time_iso_8601": "2020-01-27T01:00:24.898501Z", "url": "https://files.pythonhosted.org/packages/c1/49/b015e6ca91e52ff3140b8f87e0e7b1f8c83608369f18a23b16628eabb28f/happytransformer-1.0.4.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "1d0e70d01ff8fcbf48afa247f154f125", "sha256": "ddb91c42663144784015b869559cfc27af81a4e8a2f0a3fe21c31ada7faa30c9"}, "downloads": -1, "filename": "happytransformer-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "1d0e70d01ff8fcbf48afa247f154f125", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 32339, "upload_time": "2020-02-17T22:42:59", "upload_time_iso_8601": "2020-02-17T22:42:59.351443Z", "url": "https://files.pythonhosted.org/packages/09/d6/daac39fd9f20015be74f373990cd43275a3d7ef33dccf62e5d8d99c29fca/happytransformer-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "14f8a0a17307c902795b14ce4a03d119", "sha256": "9e912dbb6e39b0950b1e6ed4c4cb4ce67d9fa4958649fda1de650c76eaeb10aa"}, "downloads": -1, "filename": "happytransformer-1.1.0.tar.gz", "has_sig": false, "md5_digest": "14f8a0a17307c902795b14ce4a03d119", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30047, "upload_time": "2020-02-17T22:43:00", "upload_time_iso_8601": "2020-02-17T22:43:00.691472Z", "url": "https://files.pythonhosted.org/packages/c0/75/92d5ae8b00bc281e444086edaad6b808d7ba0ea732cde18327451cf522f4/happytransformer-1.1.0.tar.gz", "yanked": false}], "1.1.2": [{"comment_text": "", "digests": {"md5": "5c18fba70b2a45307ac39e172f959e85", "sha256": "55edcdda4465d3b9ea794f71ca4ecbd70e1a3e23890dc88b9d44773149274caf"}, "downloads": -1, "filename": "happytransformer-1.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "5c18fba70b2a45307ac39e172f959e85", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 32312, "upload_time": "2020-04-28T18:54:56", "upload_time_iso_8601": "2020-04-28T18:54:56.226465Z", "url": "https://files.pythonhosted.org/packages/e0/df/644b9878de6f2477813723d44ee6a32b9d25d88b3c80ddcad1492c9268c4/happytransformer-1.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d1e124fedbf25f7a6c4f11e66a413d9e", "sha256": "83d8cd31c056cc70ab9dc5793b4254c6bd5cec74de29d4cb6b769d6f16ea7070"}, "downloads": -1, "filename": "happytransformer-1.1.2.tar.gz", "has_sig": false, "md5_digest": "d1e124fedbf25f7a6c4f11e66a413d9e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29982, "upload_time": "2020-04-28T18:54:57", "upload_time_iso_8601": "2020-04-28T18:54:57.544409Z", "url": "https://files.pythonhosted.org/packages/59/2c/ddc5c8c423619e659453ae80017a02eef6933d34bebee83f3735fb95a580/happytransformer-1.1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5c18fba70b2a45307ac39e172f959e85", "sha256": "55edcdda4465d3b9ea794f71ca4ecbd70e1a3e23890dc88b9d44773149274caf"}, "downloads": -1, "filename": "happytransformer-1.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "5c18fba70b2a45307ac39e172f959e85", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 32312, "upload_time": "2020-04-28T18:54:56", "upload_time_iso_8601": "2020-04-28T18:54:56.226465Z", "url": "https://files.pythonhosted.org/packages/e0/df/644b9878de6f2477813723d44ee6a32b9d25d88b3c80ddcad1492c9268c4/happytransformer-1.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d1e124fedbf25f7a6c4f11e66a413d9e", "sha256": "83d8cd31c056cc70ab9dc5793b4254c6bd5cec74de29d4cb6b769d6f16ea7070"}, "downloads": -1, "filename": "happytransformer-1.1.2.tar.gz", "has_sig": false, "md5_digest": "d1e124fedbf25f7a6c4f11e66a413d9e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29982, "upload_time": "2020-04-28T18:54:57", "upload_time_iso_8601": "2020-04-28T18:54:57.544409Z", "url": "https://files.pythonhosted.org/packages/59/2c/ddc5c8c423619e659453ae80017a02eef6933d34bebee83f3735fb95a580/happytransformer-1.1.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:52:29 2020"}