{"info": {"author": "Phillip J. Eby", "author_email": "peak@eby-sarna.com", "bugtrack_url": null, "classifiers": [], "description": "========================================\nSeparating Concerns Using Object Add-Ons\n========================================\n\n(NEW in version 0.6: the``Registry`` base class, and the\n``ClassAddOn.for_frame()`` classmethod.)\n\nIn any sufficiently-sized application or framework, it's common to end up\nlumping a lot of different concerns into the same class.  For example, you\nmay have business logic, persistence code, and UI all jammed into a single\nclass.  Attribute and method names for all sorts of different operations get\nshoved into a single namespace -- even when using mixin classes.\n\nSeparating concerns into different objects, however, makes it easier to write\nreusable and separately-testable components.  The AddOns package\n(``peak.util.addons``) lets you manage concerns using ``AddOn`` classes.\n\n``AddOn`` classes are like dynamic mixins, but with their own private attribute\nand method namespaces.  A concern implemented using add-ons can be added at\nruntime to any object that either has a writable ``__dict__`` attribute, or\nis weak-referenceable.\n\n``AddOn`` classes are also like adapters, but rather than creating a new\ninstance each time you ask for one, an existing instance is returned if\npossible.  In this way, add-ons can keep track of ongoing state.  For example,\na ``Persistence`` add-on might keep track of whether its subject has been saved\nto disk yet::\n\n    >>> from peak.util.addons import AddOn\n\n    >>> class Persistence(AddOn):\n    ...     saved = True\n    ...     def changed(self):\n    ...         self.saved = False\n    ...     def save_if_needed(self):\n    ...         if not self.saved:\n    ...             print \"saving\"\n    ...             self.saved = True\n\n    >>> class Thing: pass\n    >>> aThing = Thing()\n\n    >>> Persistence(aThing).saved\n    True\n    >>> Persistence(aThing).changed()\n    >>> Persistence(aThing).saved\n    False\n    >>> Persistence(aThing).save_if_needed()\n    saving\n    >>> Persistence(aThing).save_if_needed() # no action taken\n\nThis makes it easy for us to, for example, write a loop that saves a bunch of\nobjects, because we don't need to concern ourselves with initializing the\nstate of the persistence add-on.  A class doesn't need to inherit from a\nspecial base in order to be able to have this state tracked, and it doesn't\nneed to know *how* to initialize it, either.\n\nOf course, in the case of persistence, a class does need to know *when* to call\nthe persistence methods, to indicate changedness and to request saving.\nHowever, a library providing such an add-on can also provide decorators and\nother tools to make this easier, while still remaining largely independent of\nthe objects involved.\n\nIndeed, the AddOns library was actually created to make it easier to implement\nfunctionality using function or method decorators.  For example, one can create\na ``@synchronized`` decorator that safely locks an object -- see the example\nbelow under `Threading Concerns`_.\n\nIn summary, the AddOns library provides you with a basic form of AOP, that lets\nyou attach (or \"introduce\", in AspectJ terminology) additional attributes and\nmethods to an object, using a private namespace.  (If you also want to do\nAspectJ-style \"advice\", the PEAK-Rules package can be used to do \"before\",\n\"after\", and \"around\" advice in combination with add-ons.)\n\n\n.. contents:: **Table of Contents**\n\n\nBasic API\n---------\n\nIf you need to, you can query for the existence of an add-on::\n\n    >>> Persistence.exists_for(aThing)\n    True\n\nAnd by default, it won't exist::\n\n    >>> anotherThing = Thing()\n    >>> Persistence.exists_for(anotherThing)\n    False\n\nUntil you refer to it directly, e.g.::\n\n    >>> Persistence(aThing) is Persistence(anotherThing)\n    False\n\nAt which point it will of course exist::\n\n    >>> Persistence.exists_for(anotherThing)\n    True\n\nAnd maintain its state, linked to its subject::\n\n    >>> Persistence(anotherThing) is Persistence(anotherThing)\n    True\n\nUntil/unless you delete it (or its subject is garbage collected)::\n\n    >>> Persistence.delete_from(anotherThing)\n    >>> Persistence.exists_for(anotherThing)\n    False\n\n\nAddOn Keys and Instances\n------------------------\n\nAdd-ons are stored either in their subject's ``__dict__``, or if it does not\nhave one (or is a type object with a read-only ``__dict__``), they are\nstored in a special dictionary linked to the subject via a weak reference.\n\nBy default, the dictionary key is the add-on class, so there is exactly one\nadd-on instance per subject::\n\n    >>> aThing.__dict__\n    {<class 'Persistence'>: <Persistence object at...>}\n\nBut in some cases, you may wish to have more than one instance of a given\nadd-on class for a subject.  (For example, PEAK-Rules uses add-ons to represent\nindexes on different expressions contained within rules.)  For this purpose,\nyou can redefine your AddOn's ``__init__`` method to accept additional\narguments besides its subject.  The additional arguments become part of the key\nthat instances are stored under, such that more than one add-on instance can\nexist for a given object::\n\n    >>> class Index(AddOn, dict):\n    ...     def __init__(self, subject, expression):\n    ...         self.expression = expression\n\n    >>> something = Thing()\n    >>> Index(something, \"x>y\")[\"a\"] = \"b\"\n    >>> dir(something)\n    ['__doc__', '__module__', (<class 'Index'>, 'x>y')]\n\n    >>> \"a\" in Index(something, \"z<22\")\n    False\n\n    >>> Index(something, \"x>y\")\n    {'a': 'b'}\n\n    >>> Index(something, \"x>y\").expression\n    'x>y'\n\n    >>> dir(something)\n    ['__doc__', '__module__', (<class 'Index'>, 'x>y'), (<class 'Index'>, 'z<22')]\n\n    >>> Index.exists_for(something, 'x>y')\n    True\n\n    >>> Index.exists_for(anotherThing, 'q==42')\n    False\n\nBy default, an add-on class' key is either the class by itself, or a tuple\ncontaining the class, followed by any arguments that appeared in the\nconstructor call after the add-on's subject.  However, you can redefine the\n``addon_key()`` classmethod in your subclass, and change it to do something\ndifferent.  For example, you could make different add-on classes generate\noverlapping keys, or you could use attributes of the arguments to generate the\nkey.  You could even generate a string key, to cause the add-on to be attached\nas an attribute!::\n\n    >>> class Leech(AddOn):\n    ...     def addon_key(cls):\n    ...         return \"__leech__\"\n    ...     addon_key = classmethod(addon_key)\n\n    >>> something = Thing()\n\n    >>> Leech(something) is something.__leech__\n    True\n\nThe ``addon_key`` method only receives the arguments that appear *after* the\nsubject in the constructor call.  So, in the case above, it receives no\narguments.  Had we called it with additional arguments, we'd have gotten an\nerror::\n\n    >>> Leech(something, 42)\n    Traceback (most recent call last):\n      ...\n    TypeError: addon_key() takes exactly 1 argument (2 given)\n\nNaturally, your ``addon_key()`` and ``__init__()`` (and/or ``__new__()``)\nmethods should also agree on how many arguments there can be, and what they\nmean!\n\nIn general, you should include your add-on class (or some add-on class) as part\nof your key, so as to make collisions with other people's add-on classes\nimpossible.  Keys should also be designed for thread-safety, where applicable.\n(See the section below on `Threading Concerns`_ for more details.)\n\n\nRole Storage and Garbage Collection\n-----------------------------------\n\nBy the way, the approach above of using an string as an add-on key won't always\nmake the add-on into an attribute of the subject!  If an object doesn't have a\n``__dict__``, or that ``__dict__`` isn't writable (as in the case of type\nobjects), then the add-on is stored in a weakly-keyed dictionary, maintained\nelsewhere::\n\n    >>> class NoDict(object):\n    ...     __slots__ = '__weakref__'\n\n    >>> dictless = NoDict()\n\n    >>> Leech(dictless)\n    <Leech object at ...>\n\n    >>> dictless.__leech__\n    Traceback (most recent call last):\n      ...\n    AttributeError: 'NoDict' object has no attribute '__leech__'\n\nOf course, if an object doesn't have a dictionary *and* isn't\nweak-referenceable, there's simply no way to store an add-on for it::\n\n    >>> ob = object()\n    >>> Leech(ob)\n    Traceback (most recent call last):\n      ...\n    TypeError: cannot create weak reference to 'object' object\n\nHowever, there is an ``addons_for()`` function in the ``peak.util.addons``\nmodule that you can extend using PEAK-Rules advice.  Once you add a method to\nsupport a type that otherwise can't be used with add-ons, you should be able to\nuse any and all kinds of add-on objects with that type.  (Assuming, of course,\nthat you can implement a suitable storage mechanism!)\n\nFinally, a few words regarding garbage collection.  If you don't want to create\na reference cycle, don't store a reference to your subject in your add-on. Even\nthough the ``__init__`` and ``__new__`` messages get the subject passed in, you\nare not under any obligation to *store* the subject, and often won't need to.\nUsually, the code that is accessing the add-on knows what subject is in use,\nand can pass the subject to the add-on's methods if needed.  It's rare that the\nadd-on really needs to keep a reference to the subject past the ``__new__()``\nand ``__init__()`` calls.\n\nAdd-on instances will usually be garbage collected at the same time as their\nsubject, unless there is some other reference to them.  If they keep a\nreference to their subject, their garbage collection may be delayed until\nPython's cycle collector is run.  But if they don't keep a reference, they will\nusually be deleted as soon as the subject is::\n\n    >>> def deleting(r):\n    ...     print \"deleting\", r\n\n    >>> from weakref import ref\n\n    >>> r = ref(Leech(something), deleting)\n    >>> del something\n    deleting <weakref at ...; dead>\n\n(Add-ons that are stored outside the instance dictionary of their subject,\nhowever, may take slightly longer, as Python processes weak reference\ncallbacks.)\n\nIt is also *not* recommended that you have ``__del__`` methods on your add-on\nobjects, especially if you keep a reference to your subject.  In such a case,\ngarbage collection may become impossible, and both the add-on and its subject\nwould \"leak\" (i.e., take up memory forever without being recoverable).\n\n\nClass Add-Ons\n-------------\n\nSometimes, it's useful to attach add-ons to classes instead of instances.  You\ncould use normal ``AddOn`` classes, of course, as they work just fine with both\nclassic classes and new-style types -- even built-ins::\n\n    >>> Persistence.exists_for(int)\n    False\n\n    >>> Persistence(int) is Persistence(int)\n    True\n\n    >>> Persistence.exists_for(int)\n    True\n\n    >>> class X: pass\n\n    >>> Persistence.exists_for(X)\n    False\n\n    >>> Persistence(X) is Persistence(X)\n    True\n\n    >>> Persistence.exists_for(X)\n    True\n\nBut, sometimes you have add-ons that are specifically intended for adding\nmetadata to classes -- perhaps by way of class or method decorators.  In such\na case, you need a way to access the add-on *before* its subject even exists!\n\nThe ``ClassAddOn`` base class provides a mechanism for this.  It adds an extra\nclassmethod, ``for_enclosing_class()``, that you can use to access the add-on\nfor the class that is currently being defined in the scope that invoked the\ncaller.  For example, suppose we want to have a method decorator that adds\nthe method to some class-level registry::\n\n    >>> from peak.util.addons import ClassAddOn\n\n    >>> class SpecialMethodRegistry(ClassAddOn):\n    ...     def __init__(self, subject):\n    ...         self.special_methods = {}\n    ...         super(SpecialMethodRegistry, self).__init__(subject)\n\n    >>> def specialmethod(func):\n    ...     smr = SpecialMethodRegistry.for_enclosing_class()\n    ...     smr.special_methods[func.__name__] = func\n    ...     return func\n\n    >>> class Demo:\n    ...     def dummy(self, foo):\n    ...         pass\n    ...     dummy = specialmethod(dummy)\n\n    >>> SpecialMethodRegistry(Demo).special_methods\n    {'dummy': <function dummy at ...>}\n\n    >>> class Demo2(object):\n    ...     def dummy(self, foo):\n    ...         pass\n    ...     dummy = specialmethod(dummy)\n\n    >>> SpecialMethodRegistry(Demo2).special_methods\n    {'dummy': <function dummy at ...>}\n\nYou can of course use the usual add-on API for class add-ons::\n\n    >>> SpecialMethodRegistry.exists_for(int)\n    False\n\n    >>> SpecialMethodRegistry(int).special_methods['x'] = 123\n\n    >>> SpecialMethodRegistry.exists_for(int)\n    True\n\nExcept that you cannot explicitly delete them, they must be garbage collected\nnaturally::\n\n    >>> SpecialMethodRegistry.delete_from(Demo)\n    Traceback (most recent call last):\n      ...\n    TypeError: ClassAddOns cannot be deleted\n\n\nDelayed Initialization\n~~~~~~~~~~~~~~~~~~~~~~\n\nWhen a class add-on is initialized, the class may not exist yet.  In this case,\n``None`` is passed as the first argument to the ``__new__`` and ``__init__``\nmethods.  You must be able to handle this case correctly, if your add-on will\nbe accessed inside a class definition with ``for_enclosing_class()``.\n\nYou can, however, define a ``created_for()`` instance method that will be\ncalled as soon as the actual class is available.  It is also called by the\ndefault ``__init__`` method, if the add-on is initially created for a class\nthat already exists.  Either way, the ``created_for()`` method should be called\nat most once for any given add-on instance.  For example::\n\n    >>> class SpecialMethodRegistry(ClassAddOn):\n    ...     def __init__(self, subject):\n    ...         print \"init called for\", subject\n    ...         self.special_methods = {}\n    ...         super(SpecialMethodRegistry, self).__init__(subject)\n    ...\n    ...     def created_for(self, cls):\n    ...         print \"created for\", cls.__name__\n\n    >>> class Demo:\n    ...     def dummy(self, foo):\n    ...         pass\n    ...     dummy = specialmethod(dummy)\n    init called for None\n    created for Demo\n\nAbove, ``__init__`` was called with ``None`` since the type didn't exist yet.\nHowever, accessing the add-on for an existing type (that doesn't have the add-\non yet) will call ``__init__`` with the type, and the default implementation of\n``ClassAddOn.__init__`` will also call ``created_for()`` for us, when it sees\nthe subject is not ``None``::\n\n    >>> SpecialMethodRegistry(float)\n    init called for <type 'float'>\n    created for float\n    <SpecialMethodRegistry object at ...>\n\n    >>> SpecialMethodRegistry(float)    # created_for doesn't get called again\n    <SpecialMethodRegistry object at ...>\n\nOne of the most useful features of having this ``created_for()`` method is\nthat it allows you to set up class-level metadata that involves inherited\nsettings from base classes.  In ``created_for()``, you have access to the\nclass' ``__bases__`` and or ``__mro__``, and you can just ask for an instance\nof the same add-on for those base classes, then incorporate their data into\nyour own instance as appropriate.  You are guaranteed that any such add-ons you\naccess will already be initialized, including having their ``created_for()``\nmethod called.\n\nSince this works recursively, and because class add-ons can be attached even to\nbuilt-in types like ``object``, the work of creating a correct class metadata\nregistry is immensely simplified, compared to having to special case such base\nclasses, check for bases where no metadata was added or defined, etc.\n\nInstead, classes that didn't define any metadata will just have an add-on\ninstance containing whatever was setup by your add-on's ``__init__()`` method,\nplus whatever additional data was added by its ``created_for()`` method.\n\nThus, metadata accumulation using class add-ons can actually be simpler than\ndoing the same things with metaclasses, since metaclasses can't be\nretroactively added to existing classes.  Of course, class add-ons can't\nentirely replace metaclasses or base class mixins, but for the things they\n*can* do, they are much easier to implement correctly.\n\n\nKeys, Decoration, and ``for_enclosing_class()``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nClass add-ons can have add-on keys, just like regular add-ons, and they're\nimplemented in the same way.  And, you can pass the extra arguments as\npositional arguments to ``for_enclosing_class()``.  For example::\n\n    >>> class Index(ClassAddOn):\n    ...     def __init__(self, subject, expr):\n    ...         self.expr = expr\n    ...         self.funcs = []\n    ...         super(Index, self).__init__(subject)\n\n    >>> def indexedmethod(expr):\n    ...     def decorate(func):\n    ...         Index.for_enclosing_class(expr).funcs.append(func)\n    ...         return func\n    ...     return decorate\n\n    >>> class Demo:\n    ...     def dummy(self, foo):\n    ...         pass\n    ...     dummy = indexedmethod(\"x*y\")(dummy)\n\n    >>> Index(Demo, \"x*y\").funcs\n    [<function dummy at ...>]\n\n    >>> Index(Demo, \"y+z\").funcs\n    []\n\nNote, by the way, that you do not need to use a function decorator to add\nmetadata to a class.  You just need to be calling ``for_enclosing_class()``\nin a function called directly from the class body::\n\n    >>> def special_methods(**kw):\n    ...     smr = SpecialMethodRegistry.for_enclosing_class()\n    ...     smr.special_methods.update(kw)\n\n    >>> class Demo:\n    ...     special_methods(x=23, y=55)\n    init called for None\n    created for Demo\n\n    >>> SpecialMethodRegistry(Demo).special_methods\n    {'y': 55, 'x': 23}\n\nBy default, the ``for_enclosing_class()`` method assumes is it being called by\na function that is being called directly from the class suite, such as a\nmethod decorator, or a standalone function call as shown above.  But if you\nmake a call from somewhere else, such as outside a class statement, you will\nget an error::\n\n    >>> special_methods(z=42)\n    Traceback (most recent call last):\n      ...\n    SyntaxError: Class decorators may only be used inside a class statement\n\nSimilarly, if you have a function that calls ``for_enclosing_class()``, but\nthen you call that function from another function, it will still fail::\n\n    >>> def sm(**kw):\n    ...     special_methods(**kw)\n\n    >>> class Demo:\n    ...     sm(x=23, y=55)\n    Traceback (most recent call last):\n      ...\n    SyntaxError: Class decorators may only be used inside a class statement\n\nThis is because ``for_enclosing_class()`` assumes the class is being defined\ntwo stack levels above its frame.  You can change this assumption, however,\nby using the ``level`` keyword argument::\n\n    >>> def special_methods(level=2, **kw):\n    ...     smr = SpecialMethodRegistry.for_enclosing_class(level=level)\n    ...     smr.special_methods.update(kw)\n\n    >>> def sm(**kw):\n    ...     special_methods(level=3, **kw)\n\n    >>> class Demo:\n    ...     sm(x=23)\n    ...     special_methods(y=55)\n    init called for None\n    created for Demo\n\n    >>> SpecialMethodRegistry(Demo).special_methods\n    {'y': 55, 'x': 23}\n\nAlternately, you can pass a specific Python frame object via the ``frame``\nkeyword argument to ``for_enclosing_class()``, or use the ``for_frame()``\nclassmethod instead.  ``for_frame()`` takes a Python stack frame, followed by\nany extra positional arguments needed to create the key.\n\n\nClass Registries (NEW in version 0.6)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor many of common class add-on use cases, you just want a dict-like object\nwith \"inheritance\" for the values in base classes.  The ``Registry`` base class\nprovides this behavior, by subclassing ``ClassAddOn`` and the Python ``dict``\nbuiltin type, to create a class add-on that's also a dictionary.  It then\noverrides the ``created_for()`` method to automatically populate itself with\nany inherited values from base classes.\n\nLet's define a ``MethodGoodness`` registry that will store a \"goodness\"\nrating for methods::\n\n    >>> from peak.util.addons import Registry\n\n    >>> class MethodGoodness(Registry):\n    ...     \"\"\"Dictionary of method goodness\"\"\"\n\n    >>> def goodness(value):\n    ...     def decorate(func):\n    ...         MethodGoodness.for_enclosing_class()[func.__name__]=value\n    ...         return func\n    ...     return decorate\n\n    >>> class Demo(object):\n    ...     def aMethod(self, foo):\n    ...         pass\n    ...     aMethod = goodness(17)(aMethod)\n    ...     def another_method(whinge, spam):\n    ...         woohoo\n    ...     another_method = goodness(-99)(another_method)\n\n    >>> MethodGoodness(Demo)\n    {'aMethod': 17, 'another_method': -99}\n\nSo far, so good.  Let's see what happens with a subclass::    \n\n    >>> class Demo2(Demo):\n    ...     def another_method(self, fixed):\n    ...         pass\n    ...     another_method = goodness(42)(another_method)\n\n    >>> MethodGoodness(Demo2)\n    {'another_method': 42, 'aMethod': 17}\n\nValues set in base class registries are automatically added to the current\nclass' registry of the same type and key, if the current class doesn't have\nan entry defined.  Python's new-style method resolution order is used to\ndetermine the precedence of inherited attributes.  (For classic classes, a\ntemporary new-style class is created that inherits from the classic class, in\norder to determine the resolution order, then discarded.)\n\nOnce the class in question has been created, the registry gets an extra\nattribute, ``defined_in_class``, which is a dictionary listing the entries that\nwere actually defined in the corresponding class, e.g.::\n\n    >>> MethodGoodness(Demo).defined_in_class\n    {'aMethod': 17, 'another_method': -99}\n    \n    >>> MethodGoodness(Demo2).defined_in_class\n    {'another_method': 42}\n\nAs you can see, this second dictionary contains only the values registered in\nthat class, and not any inherited values.\n\nFinally, note that ``Registry`` objects have one additional method that can\nbe useful to call from a decorator: ``set(key, value)``.  This method will\nraise an error if a different value already exists for the given key, and is\nuseful for catching errors in class definitions, e.g.:\n\n    >>> def goodness(value):\n    ...     def decorate(func):\n    ...         MethodGoodness.for_enclosing_class().set(func.__name__, value)\n    ...         return func\n    ...     return decorate\n\n    >>> class Demo3(object):\n    ...     def aMethod(self, foo):\n    ...         pass\n    ...     aMethod = goodness(17)(aMethod)\n    ...     def aMethod(self, foo):\n    ...         pass\n    ...     aMethod = goodness(27)(aMethod)\n    Traceback (most recent call last):\n      ...\n    ValueError: MethodGoodness['aMethod'] already contains 17; can't set to 27\n\n\nThreading Concerns\n------------------\n\nAdd-on lookup and creation is thread-safe (i.e. race-condition free), so long\nas the add-on key contains no objects with ``__hash__`` or ``__equals__``\nmethods involve any Python code (as opposed to being pure C code that doesn't\ncall any Python code).  So, unkeyed add-ons, or add-ons whose keys consist only\nof instances of built-in types (recursively, in the case of tuples) or types\nthat inherit their ``__hash__`` and ``__equals__`` methods from built-in types,\ncan be initialized in a thread-safe manner.\n\nThis does *not* mean, however, that two or more add-on instances can't be\ncreated for the same subject at the same time!  Code in an add-on class'\n``__new__`` or ``__init__`` methods **must not** assume that it will in fact be\nthe only add-on instance attached to its subject, if you wish the code to be\nthread-safe.\n\nThis is because the ``AddOn`` access machinery allows multiple threads to\n*create* an add-on instance at the same time, but only one of those objects\nwill *win* the race to become \"the\" add-on instance, and no thread can know in\nadvance whether it will win.  Thus, if you wish your ``AddOn`` instances to do\nsomething *to* their constructor arguments at initialization time, you must\neither give up on your add-on being thread-safe, or use some other locking\nmechanism.\n\nOf course, add-on initialization is only one small part of the overall thread-\nsafety puzzle.  Unless your add-on exists only to compute some immutable\nmetadata about its subject, the rest of your add-on's methods need to be\nthread-safe also.\n\nOne way to do that, is to use a ``@synchronized`` decorator, combined with a\n``Locking`` add-on::\n\n    >>> class Locking(AddOn):\n    ...     def __init__(self, subject):\n    ...         from threading import RLock\n    ...         self.lock = RLock()\n    ...     def acquire(self):\n    ...         print \"acquiring\"\n    ...         self.lock.acquire()\n    ...     def release(self):\n    ...         self.lock.release()\n    ...         print \"released\"\n\n    >>> def synchronized(func):\n    ...     def wrapper(self, *__args,**__kw):\n    ...         Locking(self).acquire()\n    ...         try:\n    ...             func(self, *__args,**__kw)\n    ...         finally:\n    ...             Locking(self).release()\n    ...\n    ...     from peak.util.decorators import rewrap\n    ...     return rewrap(func, wrapper)\n\n    >>> class AnotherThing:\n    ...     def ping(self):\n    ...         print \"ping\"\n    ...     ping = synchronized(ping)\n\n    >>> AnotherThing().ping()\n    acquiring\n    ping\n    released\n\nIf the ``Locking()`` add-on constructor were not thread-safe, this decorator\nwould not be able to do its job correctly, because two threads accessing an\nobject that didn't *have* the add-on yet, could end up locking two different\nlocks, and proceeding to run the supposedly-\"synchronized\" method at the same\ntime!\n\n(In general, thread-safety is harder than it looks.  But at least you don't have\nto worry about this one tiny part of correctly implementing it.)\n\nOf course, synchronized methods will be slower than normal methods, which is\nwhy AddOns doesn't do anything besides that one small part of the thread-safety\npuzzle, to avoid penalizing non-threaded code.  As the PEAK motto says,\nSTASCTAP! (Simple Things Are Simple, Complex Things Are Possible.)\n\n\nMailing List\n------------\n\nQuestions, discussion, and bug reports for this software should be directed to\nthe PEAK mailing list; see http://www.eby-sarna.com/mailman/listinfo/PEAK/\nfor details.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/AddOns", "keywords": null, "license": "PSF or ZPL", "maintainer": null, "maintainer_email": null, "name": "AddOns", "package_url": "https://pypi.org/project/AddOns/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/AddOns/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/AddOns"}, "release_url": "https://pypi.org/project/AddOns/0.7/", "requires_dist": null, "requires_python": null, "summary": "Dynamically extend other objects with AddOns (formerly ObjectRoles)", "version": "0.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>(NEW in version 0.6: the``Registry`` base class, and the\n<tt>ClassAddOn.for_frame()</tt> classmethod.)</p>\n<p>In any sufficiently-sized application or framework, it\u2019s common to end up\nlumping a lot of different concerns into the same class.  For example, you\nmay have business logic, persistence code, and UI all jammed into a single\nclass.  Attribute and method names for all sorts of different operations get\nshoved into a single namespace \u2013 even when using mixin classes.</p>\n<p>Separating concerns into different objects, however, makes it easier to write\nreusable and separately-testable components.  The AddOns package\n(<tt>peak.util.addons</tt>) lets you manage concerns using <tt>AddOn</tt> classes.</p>\n<p><tt>AddOn</tt> classes are like dynamic mixins, but with their own private attribute\nand method namespaces.  A concern implemented using add-ons can be added at\nruntime to any object that either has a writable <tt>__dict__</tt> attribute, or\nis weak-referenceable.</p>\n<p><tt>AddOn</tt> classes are also like adapters, but rather than creating a new\ninstance each time you ask for one, an existing instance is returned if\npossible.  In this way, add-ons can keep track of ongoing state.  For example,\na <tt>Persistence</tt> add-on might keep track of whether its subject has been saved\nto disk yet:</p>\n<pre>&gt;&gt;&gt; from peak.util.addons import AddOn\n\n&gt;&gt;&gt; class Persistence(AddOn):\n...     saved = True\n...     def changed(self):\n...         self.saved = False\n...     def save_if_needed(self):\n...         if not self.saved:\n...             print \"saving\"\n...             self.saved = True\n\n&gt;&gt;&gt; class Thing: pass\n&gt;&gt;&gt; aThing = Thing()\n\n&gt;&gt;&gt; Persistence(aThing).saved\nTrue\n&gt;&gt;&gt; Persistence(aThing).changed()\n&gt;&gt;&gt; Persistence(aThing).saved\nFalse\n&gt;&gt;&gt; Persistence(aThing).save_if_needed()\nsaving\n&gt;&gt;&gt; Persistence(aThing).save_if_needed() # no action taken\n</pre>\n<p>This makes it easy for us to, for example, write a loop that saves a bunch of\nobjects, because we don\u2019t need to concern ourselves with initializing the\nstate of the persistence add-on.  A class doesn\u2019t need to inherit from a\nspecial base in order to be able to have this state tracked, and it doesn\u2019t\nneed to know <em>how</em> to initialize it, either.</p>\n<p>Of course, in the case of persistence, a class does need to know <em>when</em> to call\nthe persistence methods, to indicate changedness and to request saving.\nHowever, a library providing such an add-on can also provide decorators and\nother tools to make this easier, while still remaining largely independent of\nthe objects involved.</p>\n<p>Indeed, the AddOns library was actually created to make it easier to implement\nfunctionality using function or method decorators.  For example, one can create\na <tt>@synchronized</tt> decorator that safely locks an object \u2013 see the example\nbelow under <a href=\"#threading-concerns\" rel=\"nofollow\">Threading Concerns</a>.</p>\n<p>In summary, the AddOns library provides you with a basic form of AOP, that lets\nyou attach (or \u201cintroduce\u201d, in AspectJ terminology) additional attributes and\nmethods to an object, using a private namespace.  (If you also want to do\nAspectJ-style \u201cadvice\u201d, the PEAK-Rules package can be used to do \u201cbefore\u201d,\n\u201cafter\u201d, and \u201caround\u201d advice in combination with add-ons.)</p>\n<div id=\"table-of-contents\">\n<p><strong>Table of Contents</strong></p>\n<ul>\n<li><a href=\"#basic-api\" id=\"id1\" rel=\"nofollow\">Basic API</a></li>\n<li><a href=\"#addon-keys-and-instances\" id=\"id2\" rel=\"nofollow\">AddOn Keys and Instances</a></li>\n<li><a href=\"#role-storage-and-garbage-collection\" id=\"id3\" rel=\"nofollow\">Role Storage and Garbage Collection</a></li>\n<li><a href=\"#class-add-ons\" id=\"id4\" rel=\"nofollow\">Class Add-Ons</a><ul>\n<li><a href=\"#delayed-initialization\" id=\"id5\" rel=\"nofollow\">Delayed Initialization</a></li>\n<li><a href=\"#keys-decoration-and-for-enclosing-class\" id=\"id6\" rel=\"nofollow\">Keys, Decoration, and <tt>for_enclosing_class()</tt></a></li>\n<li><a href=\"#class-registries-new-in-version-0-6\" id=\"id7\" rel=\"nofollow\">Class Registries (NEW in version 0.6)</a></li>\n</ul>\n</li>\n<li><a href=\"#threading-concerns\" id=\"id8\" rel=\"nofollow\">Threading Concerns</a></li>\n<li><a href=\"#mailing-list\" id=\"id9\" rel=\"nofollow\">Mailing List</a></li>\n</ul>\n</div>\n<div id=\"basic-api\">\n<h2><a href=\"#id1\" rel=\"nofollow\">Basic API</a></h2>\n<p>If you need to, you can query for the existence of an add-on:</p>\n<pre>&gt;&gt;&gt; Persistence.exists_for(aThing)\nTrue\n</pre>\n<p>And by default, it won\u2019t exist:</p>\n<pre>&gt;&gt;&gt; anotherThing = Thing()\n&gt;&gt;&gt; Persistence.exists_for(anotherThing)\nFalse\n</pre>\n<p>Until you refer to it directly, e.g.:</p>\n<pre>&gt;&gt;&gt; Persistence(aThing) is Persistence(anotherThing)\nFalse\n</pre>\n<p>At which point it will of course exist:</p>\n<pre>&gt;&gt;&gt; Persistence.exists_for(anotherThing)\nTrue\n</pre>\n<p>And maintain its state, linked to its subject:</p>\n<pre>&gt;&gt;&gt; Persistence(anotherThing) is Persistence(anotherThing)\nTrue\n</pre>\n<p>Until/unless you delete it (or its subject is garbage collected):</p>\n<pre>&gt;&gt;&gt; Persistence.delete_from(anotherThing)\n&gt;&gt;&gt; Persistence.exists_for(anotherThing)\nFalse\n</pre>\n</div>\n<div id=\"addon-keys-and-instances\">\n<h2><a href=\"#id2\" rel=\"nofollow\">AddOn Keys and Instances</a></h2>\n<p>Add-ons are stored either in their subject\u2019s <tt>__dict__</tt>, or if it does not\nhave one (or is a type object with a read-only <tt>__dict__</tt>), they are\nstored in a special dictionary linked to the subject via a weak reference.</p>\n<p>By default, the dictionary key is the add-on class, so there is exactly one\nadd-on instance per subject:</p>\n<pre>&gt;&gt;&gt; aThing.__dict__\n{&lt;class 'Persistence'&gt;: &lt;Persistence object at...&gt;}\n</pre>\n<p>But in some cases, you may wish to have more than one instance of a given\nadd-on class for a subject.  (For example, PEAK-Rules uses add-ons to represent\nindexes on different expressions contained within rules.)  For this purpose,\nyou can redefine your AddOn\u2019s <tt>__init__</tt> method to accept additional\narguments besides its subject.  The additional arguments become part of the key\nthat instances are stored under, such that more than one add-on instance can\nexist for a given object:</p>\n<pre>&gt;&gt;&gt; class Index(AddOn, dict):\n...     def __init__(self, subject, expression):\n...         self.expression = expression\n\n&gt;&gt;&gt; something = Thing()\n&gt;&gt;&gt; Index(something, \"x&gt;y\")[\"a\"] = \"b\"\n&gt;&gt;&gt; dir(something)\n['__doc__', '__module__', (&lt;class 'Index'&gt;, 'x&gt;y')]\n\n&gt;&gt;&gt; \"a\" in Index(something, \"z&lt;22\")\nFalse\n\n&gt;&gt;&gt; Index(something, \"x&gt;y\")\n{'a': 'b'}\n\n&gt;&gt;&gt; Index(something, \"x&gt;y\").expression\n'x&gt;y'\n\n&gt;&gt;&gt; dir(something)\n['__doc__', '__module__', (&lt;class 'Index'&gt;, 'x&gt;y'), (&lt;class 'Index'&gt;, 'z&lt;22')]\n\n&gt;&gt;&gt; Index.exists_for(something, 'x&gt;y')\nTrue\n\n&gt;&gt;&gt; Index.exists_for(anotherThing, 'q==42')\nFalse\n</pre>\n<p>By default, an add-on class\u2019 key is either the class by itself, or a tuple\ncontaining the class, followed by any arguments that appeared in the\nconstructor call after the add-on\u2019s subject.  However, you can redefine the\n<tt>addon_key()</tt> classmethod in your subclass, and change it to do something\ndifferent.  For example, you could make different add-on classes generate\noverlapping keys, or you could use attributes of the arguments to generate the\nkey.  You could even generate a string key, to cause the add-on to be attached\nas an attribute!:</p>\n<pre>&gt;&gt;&gt; class Leech(AddOn):\n...     def addon_key(cls):\n...         return \"__leech__\"\n...     addon_key = classmethod(addon_key)\n\n&gt;&gt;&gt; something = Thing()\n\n&gt;&gt;&gt; Leech(something) is something.__leech__\nTrue\n</pre>\n<p>The <tt>addon_key</tt> method only receives the arguments that appear <em>after</em> the\nsubject in the constructor call.  So, in the case above, it receives no\narguments.  Had we called it with additional arguments, we\u2019d have gotten an\nerror:</p>\n<pre>&gt;&gt;&gt; Leech(something, 42)\nTraceback (most recent call last):\n  ...\nTypeError: addon_key() takes exactly 1 argument (2 given)\n</pre>\n<p>Naturally, your <tt>addon_key()</tt> and <tt>__init__()</tt> (and/or <tt>__new__()</tt>)\nmethods should also agree on how many arguments there can be, and what they\nmean!</p>\n<p>In general, you should include your add-on class (or some add-on class) as part\nof your key, so as to make collisions with other people\u2019s add-on classes\nimpossible.  Keys should also be designed for thread-safety, where applicable.\n(See the section below on <a href=\"#threading-concerns\" rel=\"nofollow\">Threading Concerns</a> for more details.)</p>\n</div>\n<div id=\"role-storage-and-garbage-collection\">\n<h2><a href=\"#id3\" rel=\"nofollow\">Role Storage and Garbage Collection</a></h2>\n<p>By the way, the approach above of using an string as an add-on key won\u2019t always\nmake the add-on into an attribute of the subject!  If an object doesn\u2019t have a\n<tt>__dict__</tt>, or that <tt>__dict__</tt> isn\u2019t writable (as in the case of type\nobjects), then the add-on is stored in a weakly-keyed dictionary, maintained\nelsewhere:</p>\n<pre>&gt;&gt;&gt; class NoDict(object):\n...     __slots__ = '__weakref__'\n\n&gt;&gt;&gt; dictless = NoDict()\n\n&gt;&gt;&gt; Leech(dictless)\n&lt;Leech object at ...&gt;\n\n&gt;&gt;&gt; dictless.__leech__\nTraceback (most recent call last):\n  ...\nAttributeError: 'NoDict' object has no attribute '__leech__'\n</pre>\n<p>Of course, if an object doesn\u2019t have a dictionary <em>and</em> isn\u2019t\nweak-referenceable, there\u2019s simply no way to store an add-on for it:</p>\n<pre>&gt;&gt;&gt; ob = object()\n&gt;&gt;&gt; Leech(ob)\nTraceback (most recent call last):\n  ...\nTypeError: cannot create weak reference to 'object' object\n</pre>\n<p>However, there is an <tt>addons_for()</tt> function in the <tt>peak.util.addons</tt>\nmodule that you can extend using PEAK-Rules advice.  Once you add a method to\nsupport a type that otherwise can\u2019t be used with add-ons, you should be able to\nuse any and all kinds of add-on objects with that type.  (Assuming, of course,\nthat you can implement a suitable storage mechanism!)</p>\n<p>Finally, a few words regarding garbage collection.  If you don\u2019t want to create\na reference cycle, don\u2019t store a reference to your subject in your add-on. Even\nthough the <tt>__init__</tt> and <tt>__new__</tt> messages get the subject passed in, you\nare not under any obligation to <em>store</em> the subject, and often won\u2019t need to.\nUsually, the code that is accessing the add-on knows what subject is in use,\nand can pass the subject to the add-on\u2019s methods if needed.  It\u2019s rare that the\nadd-on really needs to keep a reference to the subject past the <tt>__new__()</tt>\nand <tt>__init__()</tt> calls.</p>\n<p>Add-on instances will usually be garbage collected at the same time as their\nsubject, unless there is some other reference to them.  If they keep a\nreference to their subject, their garbage collection may be delayed until\nPython\u2019s cycle collector is run.  But if they don\u2019t keep a reference, they will\nusually be deleted as soon as the subject is:</p>\n<pre>&gt;&gt;&gt; def deleting(r):\n...     print \"deleting\", r\n\n&gt;&gt;&gt; from weakref import ref\n\n&gt;&gt;&gt; r = ref(Leech(something), deleting)\n&gt;&gt;&gt; del something\ndeleting &lt;weakref at ...; dead&gt;\n</pre>\n<p>(Add-ons that are stored outside the instance dictionary of their subject,\nhowever, may take slightly longer, as Python processes weak reference\ncallbacks.)</p>\n<p>It is also <em>not</em> recommended that you have <tt>__del__</tt> methods on your add-on\nobjects, especially if you keep a reference to your subject.  In such a case,\ngarbage collection may become impossible, and both the add-on and its subject\nwould \u201cleak\u201d (i.e., take up memory forever without being recoverable).</p>\n</div>\n<div id=\"class-add-ons\">\n<h2><a href=\"#id4\" rel=\"nofollow\">Class Add-Ons</a></h2>\n<p>Sometimes, it\u2019s useful to attach add-ons to classes instead of instances.  You\ncould use normal <tt>AddOn</tt> classes, of course, as they work just fine with both\nclassic classes and new-style types \u2013 even built-ins:</p>\n<pre>&gt;&gt;&gt; Persistence.exists_for(int)\nFalse\n\n&gt;&gt;&gt; Persistence(int) is Persistence(int)\nTrue\n\n&gt;&gt;&gt; Persistence.exists_for(int)\nTrue\n\n&gt;&gt;&gt; class X: pass\n\n&gt;&gt;&gt; Persistence.exists_for(X)\nFalse\n\n&gt;&gt;&gt; Persistence(X) is Persistence(X)\nTrue\n\n&gt;&gt;&gt; Persistence.exists_for(X)\nTrue\n</pre>\n<p>But, sometimes you have add-ons that are specifically intended for adding\nmetadata to classes \u2013 perhaps by way of class or method decorators.  In such\na case, you need a way to access the add-on <em>before</em> its subject even exists!</p>\n<p>The <tt>ClassAddOn</tt> base class provides a mechanism for this.  It adds an extra\nclassmethod, <tt>for_enclosing_class()</tt>, that you can use to access the add-on\nfor the class that is currently being defined in the scope that invoked the\ncaller.  For example, suppose we want to have a method decorator that adds\nthe method to some class-level registry:</p>\n<pre>&gt;&gt;&gt; from peak.util.addons import ClassAddOn\n\n&gt;&gt;&gt; class SpecialMethodRegistry(ClassAddOn):\n...     def __init__(self, subject):\n...         self.special_methods = {}\n...         super(SpecialMethodRegistry, self).__init__(subject)\n\n&gt;&gt;&gt; def specialmethod(func):\n...     smr = SpecialMethodRegistry.for_enclosing_class()\n...     smr.special_methods[func.__name__] = func\n...     return func\n\n&gt;&gt;&gt; class Demo:\n...     def dummy(self, foo):\n...         pass\n...     dummy = specialmethod(dummy)\n\n&gt;&gt;&gt; SpecialMethodRegistry(Demo).special_methods\n{'dummy': &lt;function dummy at ...&gt;}\n\n&gt;&gt;&gt; class Demo2(object):\n...     def dummy(self, foo):\n...         pass\n...     dummy = specialmethod(dummy)\n\n&gt;&gt;&gt; SpecialMethodRegistry(Demo2).special_methods\n{'dummy': &lt;function dummy at ...&gt;}\n</pre>\n<p>You can of course use the usual add-on API for class add-ons:</p>\n<pre>&gt;&gt;&gt; SpecialMethodRegistry.exists_for(int)\nFalse\n\n&gt;&gt;&gt; SpecialMethodRegistry(int).special_methods['x'] = 123\n\n&gt;&gt;&gt; SpecialMethodRegistry.exists_for(int)\nTrue\n</pre>\n<p>Except that you cannot explicitly delete them, they must be garbage collected\nnaturally:</p>\n<pre>&gt;&gt;&gt; SpecialMethodRegistry.delete_from(Demo)\nTraceback (most recent call last):\n  ...\nTypeError: ClassAddOns cannot be deleted\n</pre>\n<div id=\"delayed-initialization\">\n<h3><a href=\"#id5\" rel=\"nofollow\">Delayed Initialization</a></h3>\n<p>When a class add-on is initialized, the class may not exist yet.  In this case,\n<tt>None</tt> is passed as the first argument to the <tt>__new__</tt> and <tt>__init__</tt>\nmethods.  You must be able to handle this case correctly, if your add-on will\nbe accessed inside a class definition with <tt>for_enclosing_class()</tt>.</p>\n<p>You can, however, define a <tt>created_for()</tt> instance method that will be\ncalled as soon as the actual class is available.  It is also called by the\ndefault <tt>__init__</tt> method, if the add-on is initially created for a class\nthat already exists.  Either way, the <tt>created_for()</tt> method should be called\nat most once for any given add-on instance.  For example:</p>\n<pre>&gt;&gt;&gt; class SpecialMethodRegistry(ClassAddOn):\n...     def __init__(self, subject):\n...         print \"init called for\", subject\n...         self.special_methods = {}\n...         super(SpecialMethodRegistry, self).__init__(subject)\n...\n...     def created_for(self, cls):\n...         print \"created for\", cls.__name__\n\n&gt;&gt;&gt; class Demo:\n...     def dummy(self, foo):\n...         pass\n...     dummy = specialmethod(dummy)\ninit called for None\ncreated for Demo\n</pre>\n<p>Above, <tt>__init__</tt> was called with <tt>None</tt> since the type didn\u2019t exist yet.\nHowever, accessing the add-on for an existing type (that doesn\u2019t have the add-\non yet) will call <tt>__init__</tt> with the type, and the default implementation of\n<tt>ClassAddOn.__init__</tt> will also call <tt>created_for()</tt> for us, when it sees\nthe subject is not <tt>None</tt>:</p>\n<pre>&gt;&gt;&gt; SpecialMethodRegistry(float)\ninit called for &lt;type 'float'&gt;\ncreated for float\n&lt;SpecialMethodRegistry object at ...&gt;\n\n&gt;&gt;&gt; SpecialMethodRegistry(float)    # created_for doesn't get called again\n&lt;SpecialMethodRegistry object at ...&gt;\n</pre>\n<p>One of the most useful features of having this <tt>created_for()</tt> method is\nthat it allows you to set up class-level metadata that involves inherited\nsettings from base classes.  In <tt>created_for()</tt>, you have access to the\nclass\u2019 <tt>__bases__</tt> and or <tt>__mro__</tt>, and you can just ask for an instance\nof the same add-on for those base classes, then incorporate their data into\nyour own instance as appropriate.  You are guaranteed that any such add-ons you\naccess will already be initialized, including having their <tt>created_for()</tt>\nmethod called.</p>\n<p>Since this works recursively, and because class add-ons can be attached even to\nbuilt-in types like <tt>object</tt>, the work of creating a correct class metadata\nregistry is immensely simplified, compared to having to special case such base\nclasses, check for bases where no metadata was added or defined, etc.</p>\n<p>Instead, classes that didn\u2019t define any metadata will just have an add-on\ninstance containing whatever was setup by your add-on\u2019s <tt>__init__()</tt> method,\nplus whatever additional data was added by its <tt>created_for()</tt> method.</p>\n<p>Thus, metadata accumulation using class add-ons can actually be simpler than\ndoing the same things with metaclasses, since metaclasses can\u2019t be\nretroactively added to existing classes.  Of course, class add-ons can\u2019t\nentirely replace metaclasses or base class mixins, but for the things they\n<em>can</em> do, they are much easier to implement correctly.</p>\n</div>\n<div id=\"keys-decoration-and-for-enclosing-class\">\n<h3><a href=\"#id6\" rel=\"nofollow\">Keys, Decoration, and <tt>for_enclosing_class()</tt></a></h3>\n<p>Class add-ons can have add-on keys, just like regular add-ons, and they\u2019re\nimplemented in the same way.  And, you can pass the extra arguments as\npositional arguments to <tt>for_enclosing_class()</tt>.  For example:</p>\n<pre>&gt;&gt;&gt; class Index(ClassAddOn):\n...     def __init__(self, subject, expr):\n...         self.expr = expr\n...         self.funcs = []\n...         super(Index, self).__init__(subject)\n\n&gt;&gt;&gt; def indexedmethod(expr):\n...     def decorate(func):\n...         Index.for_enclosing_class(expr).funcs.append(func)\n...         return func\n...     return decorate\n\n&gt;&gt;&gt; class Demo:\n...     def dummy(self, foo):\n...         pass\n...     dummy = indexedmethod(\"x*y\")(dummy)\n\n&gt;&gt;&gt; Index(Demo, \"x*y\").funcs\n[&lt;function dummy at ...&gt;]\n\n&gt;&gt;&gt; Index(Demo, \"y+z\").funcs\n[]\n</pre>\n<p>Note, by the way, that you do not need to use a function decorator to add\nmetadata to a class.  You just need to be calling <tt>for_enclosing_class()</tt>\nin a function called directly from the class body:</p>\n<pre>&gt;&gt;&gt; def special_methods(**kw):\n...     smr = SpecialMethodRegistry.for_enclosing_class()\n...     smr.special_methods.update(kw)\n\n&gt;&gt;&gt; class Demo:\n...     special_methods(x=23, y=55)\ninit called for None\ncreated for Demo\n\n&gt;&gt;&gt; SpecialMethodRegistry(Demo).special_methods\n{'y': 55, 'x': 23}\n</pre>\n<p>By default, the <tt>for_enclosing_class()</tt> method assumes is it being called by\na function that is being called directly from the class suite, such as a\nmethod decorator, or a standalone function call as shown above.  But if you\nmake a call from somewhere else, such as outside a class statement, you will\nget an error:</p>\n<pre>&gt;&gt;&gt; special_methods(z=42)\nTraceback (most recent call last):\n  ...\nSyntaxError: Class decorators may only be used inside a class statement\n</pre>\n<p>Similarly, if you have a function that calls <tt>for_enclosing_class()</tt>, but\nthen you call that function from another function, it will still fail:</p>\n<pre>&gt;&gt;&gt; def sm(**kw):\n...     special_methods(**kw)\n\n&gt;&gt;&gt; class Demo:\n...     sm(x=23, y=55)\nTraceback (most recent call last):\n  ...\nSyntaxError: Class decorators may only be used inside a class statement\n</pre>\n<p>This is because <tt>for_enclosing_class()</tt> assumes the class is being defined\ntwo stack levels above its frame.  You can change this assumption, however,\nby using the <tt>level</tt> keyword argument:</p>\n<pre>&gt;&gt;&gt; def special_methods(level=2, **kw):\n...     smr = SpecialMethodRegistry.for_enclosing_class(level=level)\n...     smr.special_methods.update(kw)\n\n&gt;&gt;&gt; def sm(**kw):\n...     special_methods(level=3, **kw)\n\n&gt;&gt;&gt; class Demo:\n...     sm(x=23)\n...     special_methods(y=55)\ninit called for None\ncreated for Demo\n\n&gt;&gt;&gt; SpecialMethodRegistry(Demo).special_methods\n{'y': 55, 'x': 23}\n</pre>\n<p>Alternately, you can pass a specific Python frame object via the <tt>frame</tt>\nkeyword argument to <tt>for_enclosing_class()</tt>, or use the <tt>for_frame()</tt>\nclassmethod instead.  <tt>for_frame()</tt> takes a Python stack frame, followed by\nany extra positional arguments needed to create the key.</p>\n</div>\n<div id=\"class-registries-new-in-version-0-6\">\n<h3><a href=\"#id7\" rel=\"nofollow\">Class Registries (NEW in version 0.6)</a></h3>\n<p>For many of common class add-on use cases, you just want a dict-like object\nwith \u201cinheritance\u201d for the values in base classes.  The <tt>Registry</tt> base class\nprovides this behavior, by subclassing <tt>ClassAddOn</tt> and the Python <tt>dict</tt>\nbuiltin type, to create a class add-on that\u2019s also a dictionary.  It then\noverrides the <tt>created_for()</tt> method to automatically populate itself with\nany inherited values from base classes.</p>\n<p>Let\u2019s define a <tt>MethodGoodness</tt> registry that will store a \u201cgoodness\u201d\nrating for methods:</p>\n<pre>&gt;&gt;&gt; from peak.util.addons import Registry\n\n&gt;&gt;&gt; class MethodGoodness(Registry):\n...     \"\"\"Dictionary of method goodness\"\"\"\n\n&gt;&gt;&gt; def goodness(value):\n...     def decorate(func):\n...         MethodGoodness.for_enclosing_class()[func.__name__]=value\n...         return func\n...     return decorate\n\n&gt;&gt;&gt; class Demo(object):\n...     def aMethod(self, foo):\n...         pass\n...     aMethod = goodness(17)(aMethod)\n...     def another_method(whinge, spam):\n...         woohoo\n...     another_method = goodness(-99)(another_method)\n\n&gt;&gt;&gt; MethodGoodness(Demo)\n{'aMethod': 17, 'another_method': -99}\n</pre>\n<p>So far, so good.  Let\u2019s see what happens with a subclass:</p>\n<pre>&gt;&gt;&gt; class Demo2(Demo):\n...     def another_method(self, fixed):\n...         pass\n...     another_method = goodness(42)(another_method)\n\n&gt;&gt;&gt; MethodGoodness(Demo2)\n{'another_method': 42, 'aMethod': 17}\n</pre>\n<p>Values set in base class registries are automatically added to the current\nclass\u2019 registry of the same type and key, if the current class doesn\u2019t have\nan entry defined.  Python\u2019s new-style method resolution order is used to\ndetermine the precedence of inherited attributes.  (For classic classes, a\ntemporary new-style class is created that inherits from the classic class, in\norder to determine the resolution order, then discarded.)</p>\n<p>Once the class in question has been created, the registry gets an extra\nattribute, <tt>defined_in_class</tt>, which is a dictionary listing the entries that\nwere actually defined in the corresponding class, e.g.:</p>\n<pre>&gt;&gt;&gt; MethodGoodness(Demo).defined_in_class\n{'aMethod': 17, 'another_method': -99}\n\n&gt;&gt;&gt; MethodGoodness(Demo2).defined_in_class\n{'another_method': 42}\n</pre>\n<p>As you can see, this second dictionary contains only the values registered in\nthat class, and not any inherited values.</p>\n<p>Finally, note that <tt>Registry</tt> objects have one additional method that can\nbe useful to call from a decorator: <tt>set(key, value)</tt>.  This method will\nraise an error if a different value already exists for the given key, and is\nuseful for catching errors in class definitions, e.g.:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def goodness(value):\n...     def decorate(func):\n...         MethodGoodness.for_enclosing_class().set(func.__name__, value)\n...         return func\n...     return decorate\n</pre>\n<pre>&gt;&gt;&gt; class Demo3(object):\n...     def aMethod(self, foo):\n...         pass\n...     aMethod = goodness(17)(aMethod)\n...     def aMethod(self, foo):\n...         pass\n...     aMethod = goodness(27)(aMethod)\nTraceback (most recent call last):\n  ...\nValueError: MethodGoodness['aMethod'] already contains 17; can't set to 27\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"threading-concerns\">\n<h2><a href=\"#id8\" rel=\"nofollow\">Threading Concerns</a></h2>\n<p>Add-on lookup and creation is thread-safe (i.e. race-condition free), so long\nas the add-on key contains no objects with <tt>__hash__</tt> or <tt>__equals__</tt>\nmethods involve any Python code (as opposed to being pure C code that doesn\u2019t\ncall any Python code).  So, unkeyed add-ons, or add-ons whose keys consist only\nof instances of built-in types (recursively, in the case of tuples) or types\nthat inherit their <tt>__hash__</tt> and <tt>__equals__</tt> methods from built-in types,\ncan be initialized in a thread-safe manner.</p>\n<p>This does <em>not</em> mean, however, that two or more add-on instances can\u2019t be\ncreated for the same subject at the same time!  Code in an add-on class\u2019\n<tt>__new__</tt> or <tt>__init__</tt> methods <strong>must not</strong> assume that it will in fact be\nthe only add-on instance attached to its subject, if you wish the code to be\nthread-safe.</p>\n<p>This is because the <tt>AddOn</tt> access machinery allows multiple threads to\n<em>create</em> an add-on instance at the same time, but only one of those objects\nwill <em>win</em> the race to become \u201cthe\u201d add-on instance, and no thread can know in\nadvance whether it will win.  Thus, if you wish your <tt>AddOn</tt> instances to do\nsomething <em>to</em> their constructor arguments at initialization time, you must\neither give up on your add-on being thread-safe, or use some other locking\nmechanism.</p>\n<p>Of course, add-on initialization is only one small part of the overall thread-\nsafety puzzle.  Unless your add-on exists only to compute some immutable\nmetadata about its subject, the rest of your add-on\u2019s methods need to be\nthread-safe also.</p>\n<p>One way to do that, is to use a <tt>@synchronized</tt> decorator, combined with a\n<tt>Locking</tt> add-on:</p>\n<pre>&gt;&gt;&gt; class Locking(AddOn):\n...     def __init__(self, subject):\n...         from threading import RLock\n...         self.lock = RLock()\n...     def acquire(self):\n...         print \"acquiring\"\n...         self.lock.acquire()\n...     def release(self):\n...         self.lock.release()\n...         print \"released\"\n\n&gt;&gt;&gt; def synchronized(func):\n...     def wrapper(self, *__args,**__kw):\n...         Locking(self).acquire()\n...         try:\n...             func(self, *__args,**__kw)\n...         finally:\n...             Locking(self).release()\n...\n...     from peak.util.decorators import rewrap\n...     return rewrap(func, wrapper)\n\n&gt;&gt;&gt; class AnotherThing:\n...     def ping(self):\n...         print \"ping\"\n...     ping = synchronized(ping)\n\n&gt;&gt;&gt; AnotherThing().ping()\nacquiring\nping\nreleased\n</pre>\n<p>If the <tt>Locking()</tt> add-on constructor were not thread-safe, this decorator\nwould not be able to do its job correctly, because two threads accessing an\nobject that didn\u2019t <em>have</em> the add-on yet, could end up locking two different\nlocks, and proceeding to run the supposedly-\u201csynchronized\u201d method at the same\ntime!</p>\n<p>(In general, thread-safety is harder than it looks.  But at least you don\u2019t have\nto worry about this one tiny part of correctly implementing it.)</p>\n<p>Of course, synchronized methods will be slower than normal methods, which is\nwhy AddOns doesn\u2019t do anything besides that one small part of the thread-safety\npuzzle, to avoid penalizing non-threaded code.  As the PEAK motto says,\nSTASCTAP! (Simple Things Are Simple, Complex Things Are Possible.)</p>\n</div>\n<div id=\"mailing-list\">\n<h2><a href=\"#id9\" rel=\"nofollow\">Mailing List</a></h2>\n<p>Questions, discussion, and bug reports for this software should be directed to\nthe PEAK mailing list; see <a href=\"http://www.eby-sarna.com/mailman/listinfo/PEAK/\" rel=\"nofollow\">http://www.eby-sarna.com/mailman/listinfo/PEAK/</a>\nfor details.</p>\n</div>\n\n          </div>"}, "last_serial": 3280255, "releases": {"0.6": [{"comment_text": "", "digests": {"md5": "912796a067554bc7d6953a8995a4506c", "sha256": "a98bd4cb512262dda51218d5cb2e33dce87993e7d0f742bf1377c1b8abde3f7c"}, "downloads": -1, "filename": "AddOns-0.6-py2.3.egg", "has_sig": false, "md5_digest": "912796a067554bc7d6953a8995a4506c", "packagetype": "bdist_egg", "python_version": "2.3", "requires_python": null, "size": 58353, "upload_time": "2007-10-26T14:07:50", "upload_time_iso_8601": "2007-10-26T14:07:50Z", "url": "https://files.pythonhosted.org/packages/45/5c/f152d408774e06c246af75cf420aa3e5315c05d5bc100fc950de0b2b5ab2/AddOns-0.6-py2.3.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "eafd8da4250a676e49d60cb518f4c4e7", "sha256": "f0fc4f57da793c8430baf5b4fda6b62845895ec3223a4c838afd4fd0c5ea0df7"}, "downloads": -1, "filename": "AddOns-0.6-py2.4.egg", "has_sig": false, "md5_digest": "eafd8da4250a676e49d60cb518f4c4e7", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 19001, "upload_time": "2007-10-26T14:10:47", "upload_time_iso_8601": "2007-10-26T14:10:47Z", "url": "https://files.pythonhosted.org/packages/b0/80/07a826be6bc85adab5ace9dde92be331445493baf11fe84f6aea194b7dd4/AddOns-0.6-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "dc12f67476299487b2d441def627d5f2", "sha256": "7b8fe0f269543d33f2601e7ba5a9b05a4a4ffe3a09967534db553903152ca4ce"}, "downloads": -1, "filename": "AddOns-0.6-py2.5.egg", "has_sig": false, "md5_digest": "dc12f67476299487b2d441def627d5f2", "packagetype": "bdist_egg", "python_version": "2.5", "requires_python": null, "size": 18945, "upload_time": "2007-10-26T14:08:38", "upload_time_iso_8601": "2007-10-26T14:08:38Z", "url": "https://files.pythonhosted.org/packages/fc/89/273ce3b46ffb449597fc3b9e32d6c6f4eeec82527eb693bbc12132e7713a/AddOns-0.6-py2.5.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "cce3b98e30aeee7e918649a18ba8f8b7", "sha256": "65999ce99aaf4ba263be3d25f138eab2bd471a74c5f6a1c8022629a149e7099a"}, "downloads": -1, "filename": "AddOns-0.6.zip", "has_sig": false, "md5_digest": "cce3b98e30aeee7e918649a18ba8f8b7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33893, "upload_time": "2007-10-26T14:07:49", "upload_time_iso_8601": "2007-10-26T14:07:49Z", "url": "https://files.pythonhosted.org/packages/ee/e9/03898d175ac65a5bddef523c130382a4cfef90e9628cb01de5e485222bb0/AddOns-0.6.zip", "yanked": false}], "0.7": [{"comment_text": "", "digests": {"md5": "dc53c20b7fad14954eee13c697328a98", "sha256": "527fdef77590f8320408f987cc99c4a1a689beae0dbc6ffe2523e4aa43c54557"}, "downloads": -1, "filename": "AddOns-0.7-py2.3.egg", "has_sig": false, "md5_digest": "dc53c20b7fad14954eee13c697328a98", "packagetype": "bdist_egg", "python_version": "2.3", "requires_python": null, "size": 57663, "upload_time": "2009-08-10T18:17:31", "upload_time_iso_8601": "2009-08-10T18:17:31.958544Z", "url": "https://files.pythonhosted.org/packages/e7/31/63cf170db0c55cbaf39c6a8698eb100e1c60e5b470a727c13daf7de35eab/AddOns-0.7-py2.3.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "5ec5f48457405373cacd9b0d0a80a680", "sha256": "3b0c11844c0ee0b0e134d021e8ea46d11ac11eb42c0c413b6297e3334cadd51c"}, "downloads": -1, "filename": "AddOns-0.7-py2.4.egg", "has_sig": false, "md5_digest": "5ec5f48457405373cacd9b0d0a80a680", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 18877, "upload_time": "2009-08-10T18:18:26", "upload_time_iso_8601": "2009-08-10T18:18:26.725782Z", "url": "https://files.pythonhosted.org/packages/8a/18/ef2f51e3e514e696b8ea6cf7312f3d6756fff7ec27845d98fcc1a551e194/AddOns-0.7-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "b7a9a5cab4b7221b55d02ba1af8e27f6", "sha256": "19715bda16d685b9d30dc64dd052c975e2039ee6efe8d733e57886234630abc8"}, "downloads": -1, "filename": "AddOns-0.7-py2.5.egg", "has_sig": false, "md5_digest": "b7a9a5cab4b7221b55d02ba1af8e27f6", "packagetype": "bdist_egg", "python_version": "2.5", "requires_python": null, "size": 18775, "upload_time": "2009-08-10T18:18:40", "upload_time_iso_8601": "2009-08-10T18:18:40.898484Z", "url": "https://files.pythonhosted.org/packages/5c/a1/8aa2c0c6919038fec41bc5a2fee41e7618cdafe4a99b1b52b7685a377c18/AddOns-0.7-py2.5.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "4f04e967d524e8f46600763f57493a37", "sha256": "9b7e8cce8c0a83b19ae751ff4c390abcaf38212123d65bcfb516f7a178bdc702"}, "downloads": -1, "filename": "AddOns-0.7-py2.7.egg", "has_sig": false, "md5_digest": "4f04e967d524e8f46600763f57493a37", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 15266, "upload_time": "2017-10-26T08:11:39", "upload_time_iso_8601": "2017-10-26T08:11:39.562769Z", "url": "https://files.pythonhosted.org/packages/65/98/d68c9a6822374217691a0f1d41286ace1e430676ccc465aa2f3c94db06da/AddOns-0.7-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "114e13ca0d81d870afad038d4bbd4f2f", "sha256": "4d5f248c31db312081a3d562d1de433971e6cd2e94aeb00c4ebc08e22ea8f15c"}, "downloads": -1, "filename": "AddOns-0.7.zip", "has_sig": false, "md5_digest": "114e13ca0d81d870afad038d4bbd4f2f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34220, "upload_time": "2009-08-10T18:17:31", "upload_time_iso_8601": "2009-08-10T18:17:31.027306Z", "url": "https://files.pythonhosted.org/packages/4c/ff/aa57125eaab21e8ea5107138c6fb79b7ff7b96c7475cbe9ce01a0a62b99f/AddOns-0.7.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "dc53c20b7fad14954eee13c697328a98", "sha256": "527fdef77590f8320408f987cc99c4a1a689beae0dbc6ffe2523e4aa43c54557"}, "downloads": -1, "filename": "AddOns-0.7-py2.3.egg", "has_sig": false, "md5_digest": "dc53c20b7fad14954eee13c697328a98", "packagetype": "bdist_egg", "python_version": "2.3", "requires_python": null, "size": 57663, "upload_time": "2009-08-10T18:17:31", "upload_time_iso_8601": "2009-08-10T18:17:31.958544Z", "url": "https://files.pythonhosted.org/packages/e7/31/63cf170db0c55cbaf39c6a8698eb100e1c60e5b470a727c13daf7de35eab/AddOns-0.7-py2.3.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "5ec5f48457405373cacd9b0d0a80a680", "sha256": "3b0c11844c0ee0b0e134d021e8ea46d11ac11eb42c0c413b6297e3334cadd51c"}, "downloads": -1, "filename": "AddOns-0.7-py2.4.egg", "has_sig": false, "md5_digest": "5ec5f48457405373cacd9b0d0a80a680", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 18877, "upload_time": "2009-08-10T18:18:26", "upload_time_iso_8601": "2009-08-10T18:18:26.725782Z", "url": "https://files.pythonhosted.org/packages/8a/18/ef2f51e3e514e696b8ea6cf7312f3d6756fff7ec27845d98fcc1a551e194/AddOns-0.7-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "b7a9a5cab4b7221b55d02ba1af8e27f6", "sha256": "19715bda16d685b9d30dc64dd052c975e2039ee6efe8d733e57886234630abc8"}, "downloads": -1, "filename": "AddOns-0.7-py2.5.egg", "has_sig": false, "md5_digest": "b7a9a5cab4b7221b55d02ba1af8e27f6", "packagetype": "bdist_egg", "python_version": "2.5", "requires_python": null, "size": 18775, "upload_time": "2009-08-10T18:18:40", "upload_time_iso_8601": "2009-08-10T18:18:40.898484Z", "url": "https://files.pythonhosted.org/packages/5c/a1/8aa2c0c6919038fec41bc5a2fee41e7618cdafe4a99b1b52b7685a377c18/AddOns-0.7-py2.5.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "4f04e967d524e8f46600763f57493a37", "sha256": "9b7e8cce8c0a83b19ae751ff4c390abcaf38212123d65bcfb516f7a178bdc702"}, "downloads": -1, "filename": "AddOns-0.7-py2.7.egg", "has_sig": false, "md5_digest": "4f04e967d524e8f46600763f57493a37", "packagetype": "bdist_egg", "python_version": "2.7", "requires_python": null, "size": 15266, "upload_time": "2017-10-26T08:11:39", "upload_time_iso_8601": "2017-10-26T08:11:39.562769Z", "url": "https://files.pythonhosted.org/packages/65/98/d68c9a6822374217691a0f1d41286ace1e430676ccc465aa2f3c94db06da/AddOns-0.7-py2.7.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "114e13ca0d81d870afad038d4bbd4f2f", "sha256": "4d5f248c31db312081a3d562d1de433971e6cd2e94aeb00c4ebc08e22ea8f15c"}, "downloads": -1, "filename": "AddOns-0.7.zip", "has_sig": false, "md5_digest": "114e13ca0d81d870afad038d4bbd4f2f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34220, "upload_time": "2009-08-10T18:17:31", "upload_time_iso_8601": "2009-08-10T18:17:31.027306Z", "url": "https://files.pythonhosted.org/packages/4c/ff/aa57125eaab21e8ea5107138c6fb79b7ff7b96c7475cbe9ce01a0a62b99f/AddOns-0.7.zip", "yanked": false}], "timestamp": "Thu May  7 16:23:30 2020"}