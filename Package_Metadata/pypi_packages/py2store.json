{"info": {"author": "Thor Whalen", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 3.7", "Topic :: Software Development"], "description": "* [py2store](#py2store)\n   * [Quickstart](#quickstart)\n   * [Use cases](#use-cases)\n      * [Interfacing reads](#interfacing-reads)\n      * [Changing where and how things are stored](#changing-where-and-how-things-are-stored)\n      * [Adapters: When the learning curve is in the way of learning](#adapters-when-the-learning-curve-is-in-the-way-of-learning)\n      * [Thinking about storage later, if ever](#thinking-about-storage-later-if-ever)\n   * [More examples](#more-examples)\n      * [Looks like a dict](#looks-like-a-dict)\n      * [Converting keys: Relative paths and absolute paths](#converting-keys-relative-paths-and-absolute-paths)\n      * [Serialization/Deserialization](#serializationdeserialization)\n      * [A pickle store](#a-pickle-store)\n      * [But how do you change the persister?](#but-how-do-you-change-the-persister)\n      * [Talk your own CRUD dialect](#talk-your-own-crud-dialect)\n      * [Transforming keys](#transforming-keys)\n   * [How it works](#how-it-works)\n   * [A few persisters you can use](#a-few-persisters-you-can-use)\n      * [Local Files](#local-files)\n      * [MongoDB](#mongodb)\n      * [S3, SQL, Zips, Dropbox](#s3-sql-zips-dropbox)\n   * [Philosophical FAQs](#philosophical-faqs)\n      * [Is a store an ORM? A DAO?](#is-a-store-an-orm-a-dao)\n      * [Should storage transform the data?](#should-storage-transform-the-data)\n   * [Some links](#some-links)\n   \n\n# py2store\nStorage CRUD how and where you want it.\n\nList, read, write, and delete data in a structured data source/target, \nas if manipulating simple python builtins (dicts, lists), or through the interface **you** want to interact with, \nwith configuration or physical particularities out of the way. \nAlso, being able to change these particularities without having to change the business-logic code. \n\nIf you're not a \"read from top to bottom\" kinda person, here are some tips: \n[Quickstart](#quickstart) will show you a simple example of how it looks and feels. \n[Use cases](#use-cases) will give you an idea of how py2store can be useful to you, if at all, \nand [How it works](#how-it-works) will give you a sense of how it works.\n[More examples](#more-examples) will give you a taste of how you can adapt the three main aspects of \nstorage (persistence, serialization, and indexing) to your needs.\n\n# Quickstart\n\nInstall it (e.g. `pip install py2store`).\n\nThink of type of storage you want to use and just go ahead, like you're using a dict.\nHere's an example for local storage (you must you string keys only here). \n\n```\n>>> from py2store import QuickStore\n>>>\n>>> store = QuickStore()  # will print what (tmp) rootdir it is choosing\n>>> # Write something and then read it out again\n>>> store['foo'] = 'baz'\n>>> 'foo' in store  # do you have the key 'foo' in your store?\nTrue\n>>> store['foo']  # what is the value for 'foo'?\n'baz'\n>>>\n>>> # Okay, it behaves like a dict, but go have a look in your file system,  \n>>> # and see that there is now a file in the rootdir, named 'foo'!\n>>> \n>>> # Write something more complicated\n>>> store['hello/world'] = [1, 'flew', {'over': 'a', \"cuckoo's\": map}]\n>>> stored_val = store['hello/world']\n>>> stored_val == [1, 'flew', {'over': 'a', \"cuckoo's\": map}]  # was it retrieved correctly?\nTrue\n>>>\n>>> # how many items do you have now?\n>>> assert len(store) >= 2  # can't be sure there were no elements before, so can't assert == 2\n>>> \n>>> # delete the stuff you've written\n>>> del store['foo']\n>>> del store['hello/world']\n```\n\n`QuickStore` will by default store things in local files, using pickle as the serializer.\nIf a root directory is not specified, \nit will use a tmp directory it will create (the first time you try to store something) \nIt will create any directories that need to be created to satisfy any/key/that/contains/slashes.\nOf course, everything is configurable.\n\n# Use cases\n\n## Interfacing reads\n\nHow many times did someone share some data with you in the form of a zip of some nested folders \nwhose structure and naming choices are fascinatingly obscure? And how much time do you then spend to write code \nto interface with that freak of nature? Well, one of the intents of py2store is to make that easier to do. \nYou still need to understand the structure of the data store and how to deserialize these datas into python \nobjects you can manipulate. But with the proper tool, you shouldn't have to do much more than that.\n\n## Changing where and how things are stored\n\nEver have to switch where you persist things (say from file system to S3), or change the way key into your data, \nor the way that data is serialized? If you use py2store tools to separate the different storage concerns, \nit'll be quite easy to change, since change will be localized. And if you're dealing with code that was already \nwritten, with concerns all mixed up, py2store should still be able to help since you'll be able to\nmore easily give the new system a facade that makes it look like the old one. \n\nAll of this can also be applied to data bases as well, in-so-far as the CRUD operations you're using \nare covered by the base methods.\n\n## Adapters: When the learning curve is in the way of learning\n\nShinny new storage mechanisms (DBs etc.) are born constantly, and some folks start using them, and we are eventually lead to use them \nas well if we need to work with those folks' systems. And though we'd love to learn the wonderful new \ncapabilities the new kid on the block has, sometimes we just don't have time for that. \n\nWouldn't it be nice if someone wrote an adapter to the new system that had an interface we were familiar with? \nTalking to SQL as if it were mongo (or visa versa). Talking to S3 as if it were a file system. \nNow it's not a long term solution: If we're really going to be using the new system intensively, we \nshould learn it. But when you just got to get stuff done, having a familiar facade to something new \nis a life saver. \n\npy2store would like to make it easier for you roll out an adapter to be able to talk \nto the new system in the way **you** are familiar with.\n \n## Thinking about storage later, if ever\n\nYou have a new project or need to write a new app. You'll need to store stuff and read stuff back. \nStuff: Different kinds of resources that your app will need to function. Some people enjoy thinking \nof how to optimize that aspect. I don't. I'll leave it to the experts to do so when the time comes. \nOften though, the time is later, if ever. Few proof of concepts and MVPs ever make it to prod. \n\nSo instead, I'd like to just get on with the business logic and write my program. \nSo what I need is an easy way to get some minimal storage functionality. \nBut when the time comes to optimize, I shouldn't have to change my code, but instead just change the way my \nDAO does things. What I need is py2store.\n\n# More examples\n\n## Looks like a dict\nBelow, we make a default store and demo a few basic operations on it.\nThe default store uses a dict as it's backend persister. \nA dict is neither really a backend, nor a persister. But it helps to try things out with no\nfootprint.\n\n```python\nfrom py2store.base import Store\n\ns = Store()\nassert list(s) == []\ns['foo'] = 'bar'  # put 'bar' in 'foo'\nassert 'foo' in s  # check that 'foo' is in (i.e. a key of) s\nassert s['foo'] == 'bar'  # see that the value that 'foo' contains is 'bar'\nassert list(s) == ['foo']  # list all the keys (there's only one)\nassert list(s.items()) == [('foo', 'bar')]  # list all the (key, value) pairs\nassert list(s.values()) == ['bar']  # list all the values\nassert len(s) == 1  # Number of items in my store\ns['another'] = 'item'  # store another item\nassert len(s) == 2  # Now I have two!\nassert list(s) == ['foo', 'another']  # here they are\n```\n\nThere's nothing fantastic in the above code. \nI've just demoed some operations on a dict.\nBut it's exactly this simplicity that py2store aims for. \nYou can now replace the `s = Store()` with `s = AnotherStore(...)` where `AnotherStore` \nnow uses some other backend that could be remote or local, could be a database, or any \nsystem that can store `something` (the value) `somewhere` (the key).\n\nYou can choose from an existing store (e.g. local files, for AWS S3, for MongoDB) or \nquite easily make your own (more on that later).\n\nAnd yet, it will still look like you're talking to a dict. This not only means that you can \ntalk to various storage systems without having to actually learn how to, but also means \nthat the same business logic code you've written can be reused with no modification. \n\nBut py2store offers more than just a simple consistent facade to **where** you store things, \nbut also provides means to define **how** you do it.\n\nIn the case of key-value storage, the \"how\" is defined on the basis of the keys (how you reference) \nthe objects you're storing and the values (how you serialize and deserialize those objects).\n \n\n## Converting keys: Relative paths and absolute paths\nTake a look at the following example, that adds a layer of key conversion to a store.\n\n```python\n# defining the store\nfrom py2store.base import Store\n\nclass PrefixedKeyStore(Store):\n    prefix = ''\n    def _id_of_key(self, key):\n        return self.prefix + key  # prepend prefix before passing on to store\n    def _key_of_id(self, _id):\n        if not _id.startswith(self.prefix):\n            raise ValueError(f\"_id {_id} wasn't prefixed with {self.prefix}\")\n        else:\n            return _id[len(self.prefix):]  # don't show the user the prefix\n            \n# trying the store out            \ns = PrefixedKeyStore()\ns.prefix = '/ROOT/'\nassert list(s) == []\ns['foo'] = 'bar'  # put 'bar' in 'foo'\nassert 'foo' in s  # check that 'foo' is in (i.e. a key of) s\nassert s['foo'] == 'bar'  # see that the value that 'foo' contains is 'bar'\nassert list(s) == ['foo']  # list all the keys (there's only one)\nassert list(s.items()) == [('foo', 'bar')]  # list all the (key, value) pairs\nassert list(s.values()) == ['bar']  # list all the values\nassert len(s) == 1  # Number of items in my store\ns['another'] = 'item'  # store another item\nassert len(s) == 2  # Now I have two!\nassert list(s) == ['foo', 'another']  # here they are      \n```\n\n\nQ: That wasn't impressive! It's just the same as the first Store. What's this prefix all about?\n\nA: The prefix thing is hidden, and that's the point. You want to talk the \"relative\" (i.e \"prefix-free\")\nlanguage, but may have the need for this prefix to be prepended to the key before persisting the data\nand that prefix to be removed before being displayed to the user. \nThink of working with files. Do you want to have to specify the root folder every time you store something\nor retrieve something?\n\nQ: Prove it!\n\nA: Okay, let's look under the hood at what the underlying store (a dict) is dealing with:\n\n```python\nassert list(s.store.items()) == [('/ROOT/foo', 'bar'), ('/ROOT/another', 'item')]\n```\n\nYou see? The keys that the \"backend\" is using are actually prefixed with `\"/ROOT/\"`\n\n## Serialization/Deserialization\n\nLet's now demo serialization and deserialization. \n\nSay we want to deserialize any text we stored by appending `\"hello \"` to everything stored.\n\n```python\n# defining the store\nfrom py2store.base import Store\n\nclass MyFunnyStore(Store):\n    def _obj_of_data(self, data):\n        return f'hello {data}'\n    \n# trying the store out            \ns = MyFunnyStore()\nassert list(s) == []\ns['foo'] = 'bar'  # put 'bar' in 'foo'\nassert 'foo' in s  # check that 'foo' is in (i.e. a key of) s\nassert s['foo'] == 'hello bar'  # the value that 'foo' contains SEEMS to be 'hello bar'\nassert list(s) == ['foo']  # list all the keys (there's only one)\nassert list(s.items()) == [('foo', 'hello bar')]  # list all the (key, value) pairs\nassert list(s.values()) == ['hello bar']  # list all the values    \n```\n\nNote: This is an easy example to demo on-load transformation of data (i.e. deserialization), \nbut wouldn't be considered \"deserialization\" by all. \nSee the [Should storage transform the data?](#should-storage-transform-the-data) discussion below.\n \nIn the following, we want to serialize our text by upper-casing it (and see it as such) \nwhen we retrieve the text.\n\n```python\n# defining the store\nfrom py2store.base import Store\n\nclass MyOtherFunnyStore(Store):\n    def _data_of_obj(self, obj):\n        return obj.upper()\n      \n# trying the store out              \ns = MyOtherFunnyStore()\nassert list(s) == []\ns['foo'] = 'bar'  # put 'bar' in 'foo'\nassert 'foo' in s  # check that 'foo' is in (i.e. a key of) s\nassert s['foo'] == 'BAR'  # see that the value that 'foo' contains is 'bar'\nassert list(s) == ['foo']  # list all the keys (there's only one)\nassert list(s.items()) == [('foo', 'BAR')]  # list all the (key, value) pairs\nassert list(s.values()) == ['BAR']  # list all the values\n``` \n\nIn the last to serialization examples, we only implemented one way transformations. \nThat's all fine if you just want to have a writer (so only need a serializer) or a reader (so only \nneed a deserializer). \nIn most cases though, you will need two way transformations, specifying how the object \nshould be serialized to be stored, and how it should be deserialized to get your object back. \n\n\n## A pickle store\n\nSay you wanted the store to pickle as your serializer. Here's how this could look like.\n\n```python\n# defining the store\nimport pickle\nfrom py2store.base import Store\n\n\nclass PickleStore(Store):\n    protocol = None\n    fix_imports = True\n    encoding = 'ASCII'\n    def _data_of_obj(self, obj):  # serializer\n        return pickle.dumps(obj, protocol=self.protocol, fix_imports=self.fix_imports)\n    def _obj_of_data(self, data):  # deserializer\n        return pickle.loads(data, fix_imports=self.fix_imports, encoding=self.encoding)\n\n# trying the store out              \ns = PickleStore()\nassert list(s) == []\ns['foo'] = 'bar'  # put 'bar' in 'foo'\nassert s['foo'] == 'bar'  # I can get 'bar' back\n# behind the scenes though, it's really a pickle that is stored:\nassert s.store['foo'] == b'\\x80\\x03X\\x03\\x00\\x00\\x00barq\\x00.'\n``` \n\nAgain, it doesn't seem that impressive that you can get back a string that you stored in a dict. \nFor two reasons: (1) you don't really need to serialize strings to store them and (2) you don't need to serialize python \nobjects to store them in a dict. \nBut if you (1) were trying to store more complex types and (2) were actually persisting them in a file system or database, \nthen you'll need to serialize.\nThe point here is that the serialization and persisting concerns are separated from the storage and retrieval concern. \nThe code still looks like you're working with a dict.\n\n## But how do you change the persister?\n\nBy using a persister that persists where you want. \nYou can also write your own. All a persister needs to work with py2store is that it follows the interface \npython's `collections.MutableMapping` (or a subset thereof). More on how to make your own persister later\nYou just need to follow the collections.MutableMapping interface. \n\nBelow a simple example of how to persist in files under a given folder.\n(Warning: If you want a local file store, don't use this, but one of the easier to use, robust and safe stores in the \nstores folder!)\n\n```python\nimport os\nfrom collections.abc import MutableMapping\n\nclass SimpleFilePersister(MutableMapping):\n    \"\"\"Read/write (text or binary) data to files under a given rootdir.\n    Keys must be absolute file paths.\n    Paths that don't start with rootdir will be raise a KeyValidationError\n    \"\"\"\n\n    def __init__(self, rootdir, mode='t'):\n        if not rootdir.endswith(os.path.sep):\n            rootdir = rootdir + os.path.sep\n        self.rootdir = rootdir\n        assert mode in {'t', 'b', ''}, f\"mode ({mode}) not valid: Must be 't' or 'b'\"\n        self.mode = mode\n\n    def __getitem__(self, k):\n        with open(k, 'r' + self.mode) as fp:\n            data = fp.read()\n        return data\n\n    def __setitem__(self, k, v):\n        with open(k, 'w' + self.mode) as fp:\n            fp.write(v)\n\n    def __delitem__(self, k):\n        os.remove(k)\n\n    def __contains__(self, k):\n        \"\"\" Implementation of \"k in self\" check.\n        Note: MutableMapping gives you this for free, using a try/except on __getitem__,\n        but the following uses faster os functionality.\"\"\"\n        return os.path.isfile(k)\n\n    def __iter__(self):\n        yield from filter(os.path.isfile, \n                          map(lambda x: os.path.join(self.rootdir, x), \n                              os.listdir(self.rootdir)))\n        \n    def __len__(self):\n        \"\"\"Note: There's system-specific faster ways to do this.\"\"\"\n        count = 0\n        for _ in self.__iter__():\n            count += 1\n        return count\n    \n    def clear(self):\n        \"\"\"MutableMapping creates a 'delete all' functionality by default. Better disable it!\"\"\"\n        raise NotImplementedError(\"If you really want to do that, loop on all keys and remove them one by one.\")\n```\n\nNow try this out:\n```python\nimport os\n# What folder you want to use. Defaulting to the home folder. You can choose another place, but make sure \nrootdir = os.path.expanduser('~/')  # Defaulting to the home folder. You can choose another place\n\npersister = SimpleFilePersister(rootdir)\nfoo_fullpath = os.path.join(rootdir, 'foo')\npersister[foo_fullpath] = 'bar'  # write 'bar' to a file named foo_fullpath\nassert persister[foo_fullpath] == 'bar'  # see that you can read the contents of that file to get your 'bar' back\nassert foo_fullpath in persister  # the full filepath indeed exists in (i.e. \"is a key of\") the persister\nassert foo_fullpath in list(persister)  # you can list all the contents of the rootdir and file foo_fullpath in it\n```\n\n## Talk your own CRUD dialect\n\nDon't like this dict-like interface? Want to talk **your own** CRUD words? \nWe got you covered! Just subclass `SimpleFilePersister` and make the changes you want to make:\n\n```python\nclass MySimpleFilePersister(SimpleFilePersister):    \n    # If it's just renaming, it's easy\n    read = SimpleFilePersister.__getitem__\n    exists = SimpleFilePersister.__contains__\n    n_files = SimpleFilePersister.__len__\n    \n    # here we want a new method that gives us an actual list of the filepaths in the rootdir\n    list_files = lambda self: list(self.__iter__())\n\n    # And for write we want val and key to be swapped in our interface, \n    def write(self, val, key):  # note that we wanted val to come first here (as with json.dump and pickle.dump interface)\n        return self.__setitem__(key, val)  \n\nmy_persister = MySimpleFilePersister(rootdir)\n\nfoo_fullpath = os.path.join(rootdir, 'foo1')\nmy_persister.write('bar1', foo_fullpath)  # write 'bar1' to a file named foo_fullpath\nassert my_persister.read(foo_fullpath) == 'bar1'  # see that you can read the contents of that file to get your 'bar1' back\nassert my_persister.exists(foo_fullpath)  # the full filepath indeed exists in (i.e. \"is a key of\") the persister\nassert foo_fullpath in my_persister.list_files()  # you can list all the contents of the rootdir and file foo_fullpath in it\n```\n\n## Transforming keys\n\nBut dealing with full paths can be annoying, and might couple code too tightly with a particular local system.\nWe'd like to use relative paths instead. \nEasy: Wrap the persister in the `PrefixedKeyStore` defined earlier. \n\n```python\ns = PrefixedKeyStore(store=persister)  # wrap your persister with the PrefixedKeyStore defined earlier\nif not rootdir.endswith(os.path.sep): \n    rootdir = rootdir + os.path.sep  # make sure the rootdir ends with slash\ns.prefix = rootdir  # use rootdir as prefix in keys\n\ns['foo2'] = 'bar2'  # write 'bar2' to a file \nassert s['foo2'] == 'bar2'  # see that you can read the contents of that file to get your 'bar2' back\nassert 'foo2' in s  \nassert 'foo2' in list(s)  \n```\n\n# How it works\n\npy2store offers three aspects that you can define or modify to store things where you like and how you like it:\n* **Persistence**: Where things are actually stored (memory, files, DBs, etc.)\n* **Serialization**: Value transformaton. \nHow python objects should be transformed before it is persisted, \nand how persisted data should be transformed into python objects.\n* **Indexing**: Key transformation. How you name/id/index your data. \nFull or relative paths. Unique combination of parameters (e.g. (country, city)). Etc.\n\nAll of this allows you to do operations such as \"store this (value) in there (persitence) as that (key)\", \nmoving the tedious particularities of the \"in there\" as well how the \"this\" and \"that\" are transformed to fit \nin there, all out of the way of the business logic code. The way it should be.\n\n![alt text](img/py2store_how_it_works.png)\n\nNote: Where data is actually persisted just depends on what the base CRUD methods \n(`__getitem__`, `__setitem__`, `__delitem__`, `__iter__`, etc.) define them to be. \n \n# A few persisters you can use\n\nWe'll go through a few basic persisters that are ready to use.\nThere are more in each category, and we'll be adding new categories, but \nthis should get you started.\n\nHere is a useful function to perform a basic test on a store, given a key and value.\nIt doesn't test all store method (see test modules for that), but demos \nthe basic functionality that pretty much every store should be able to do.\n\n```python\ndef basic_test(store, k='foo', v='bar'):\n    \"\"\" This test performs \n    Warning: Don't use on a key k that you don't want to loose!\"\"\"\n    if k in store:  # deleting all docs in tmp\n        del store[k]\n    assert (k in store) == False  # see that key is not in store (and testing __contains__)\n    orig_length = len(store)  # the length of the store before insertion\n    store[k] = v  # write v to k (testing __setitem__)\n    assert store[k] == v  # see that the value can be retrieved (testing __getitem__, and that __setitem__ worked)\n    assert len(store) == orig_length + 1  # see that the number of items in the store increased by 1\n    assert (k in store) == True  # see that key is in store now (and testing __contains__ again)\n    assert k in list(store)  # testing listing the (key) contents of a store (and seeing if )\n    assert store.get(k) == v  # the get method\n    _ = next(iter(store.keys()))  # get the first key (test keys method)\n    _ = next(iter(store.__iter__()))  # get the first key (through __iter__)\n    k in store.keys()  # test that the __contains__ of store.keys() works\n    \n    try: \n        _ = next(iter(store.values()))  # get the first value (test values method)\n        _ = next(iter(store.items()))  # get the first (key, val) pair (test items method)\n    except Exception:\n        print(\"values() (therefore items()) didn't work: Probably testing a persister that had other data in it that your persister doesn't like\")\n        \n    assert (k in store) == True # testing __contains__ again\n    del store[k]  # clean up (and test delete)\n```\n## Local Files\n\nThere are many choices of local file stores according to what you're trying to do. \nOne general (but not too general) purpose local file store is \n'py2store.stores.local_store.RelativePathFormatStoreEnforcingFormat'.\nIt can do a lot for you, like add a prefix to your keys (so you can talk in relative instead of absolute paths),\nlists all files in subdirectories as well recursively, \nonly show you files that have a given pattern when you list them, \nand not allow you to write to a key that doesn't fit the pattern. \nFurther, it also has what it takes to create parametrized paths or parse out the parameters of a path. \n\n```python\nfrom py2store.stores.local_store import RelativePathFormatStoreEnforcingFormat as LocalFileStore\nimport os\n\nrootdir = os.path.expanduser('~/pystore_tests/')  # or replace by the folder you want to use\nos.makedirs(rootdir, exist_ok=True)  # this will make all directories that don't exist. Don't use if you don't want that.\n\nstore = LocalFileStore(path_format=rootdir)\nbasic_test(store, k='foo', v='bar')\n```\n \nThe signature of LocalFileStore is:\n```python\nLocalFileStore(path_format, mode='',\n                buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)\n```\n\nOften path_format is just used to specify the rootdir, as above. \nBut you can specify the desired format further.\nFor example, the following will only yield .wav files, \nand only allow you to write to keys that end with .wav:\n```python\nstore = LocalFileStore(path_format='/THE/ROOT/DIR/{}.wav')\n```\n\nThe following will additional add the restriction that those .wav files have the format 'SOMESTRING_' \nfollowed by digits:\n```python\nstore = LocalFileStore(path_format='/THE/ROOT/DIR/{:s}_{:d}.wav')\n```\n\nYou get the point...\n\nThe other arguments of LocalFileStore or more or less those of python's `open` function.\nThe slight difference is that here the `mode` argument applies both to read and write. \nIf `mode='b'` for example, the file will be opened with `mode='rb'` when opened to read and\nwith `mode='wb'` when opened to write. For assymetrical read/write modes, the \nuser can specify a `read_mode` and `write_mode` (in this case the `mode` argument is ignored).\n\n## MongoDB\n\nA MongoDB collection is not as naturally a key-value storage as a file system is.\nMongoDB stores \"documents\", which are JSONs of data, having many (possibly nested) fields that are not \nby default enforced by a schema. So in order to talk to mongo as a key-value store, we need to \nspecify what fields should be considered as keys, and what fields should be considered as data. \n\nBy default, the `_id` field (the only field ensured by default to contain unique values) is the single key field, and \nall other fields are considered to be data fields.\n\n```python\nfrom py2store.stores.mongo_store import MongoStore\n# The following makes a default MongoStore, the default pymongo.MongoClient settings, \n# and db_name='py2store', collection_name='test', key_fields=('_id',)\nstore = MongoStore()\nbasic_test(store, k={'_id': 'foo'}, v={'val': 'bar', 'other_val': 3})\n```\n\nBut it can get annoying to specify the key as a dict every time.\nThe key schema is fixed, so you should be able to just specify the tuple of values making the keys.\nAnd you can, with MongoTupleKeyStore\n\n```python\nfrom py2store.stores.mongo_store import MongoTupleKeyStore\nstore = MongoTupleKeyStore(key_fields=('_id', 'name'))\nbasic_test(store, k=(1234, 'bob'), v={'age': 42, 'gender': 'unspecified'})\n```\n\n## S3, SQL, Zips, Dropbox\n\nS3 persister/stores work pretty much like LocalStores, but stores in S3. You'll need to have an account with \nAWS to use this. Find S3 stores in py2store.stores.s3_stores.\n\nSQL give you read and write access to SQL DBs and tables. \n\nZipReader (and other related stores) talks to one or several files, giving you the ability to operate as if the zips were uncompressed. \n\nDropbox will give you access to dropbox files through the same dict-like interface.\n\n\n# Philosophical FAQs\n\n## Is a store an ORM? A DAO?\n\nCall it what you want, really.\n\nIt would be tempting to coin py2store as ya(p)orm (yet another (python) object-relational mapping), \nbut that would be misleading. The intent of py2store is not to map objects to db entries, \nbut rather to offer a consistent interface for basic storage operations. \n\nIn that sense, py2store is more akin to an implementation of the data access object (DAO) pattern. \nOf course, the difference between ORM and DAO can be blurry, so all this should be taken with a grain of salt.\n\nAdvantages and disadvantages such abstractions are easy to search and find, but in most cases the \npros probably outweigh the cons. \n\nMost data interaction mechanisms can be satisfied by a subset of the collections.abc interfaces.\nFor example, one can use python's collections.Mapping interface for any key-value storage, making the data access \nobject have the look and feel of a dict, instead of using other popular method name choices such for \nsuch as read/write, load/dump, etc. \nOne of the dangers there is that, since the DAO looks and acts like a dict (but is not) a user might underestimate \nthe running-costs of some operations.\n\n## Should storage transform the data?\n\nWhen does \"storing data\" **not** transform data? The answer is that storage almost always transforms data in some way.\nBut some of these transformations are taken for granted, because there's so often \"attached\" \n(i.e. \"co-occur\") with the raw process of storing. In py2store, the data transformation is attached to (but not entangled with) the store object. \nThis means you have a specific place where you can check or change that aspect of storage.\n\nHaving a consistent and simple interface to storage is useful. Being able to attach key and value \ntransformations to this interface is also very useful. But though you get a lot for cheap, it's \nnot free: Mapping the many (storage systems operations) to the one (consistent interface) means \nthat, through habit, you might project some misaligned expectations. \nThis is one of the known disadvantages of Data Access Objects (DAOs))\n\nHave a look at this surreal behavior:\n\n```python\n# defining the store\nfrom py2store.base import Store\n\nclass MyFunnyStore(Store):\n    def _obj_of_data(self, data):\n        return f'hello {data}'\n    \n# trying the store out            \ns = MyFunnyStore()\ns['foo'] = 'bar'  # put 'bar' in 'foo'\nassert s['foo'] == 'hello bar'  # the value that 'foo' contains SEEMS to be 'hello bar'\n# so look how surreal that can be:\ns['foo'] = s['foo']  # retrieve what's under 'foo' and store it back into 'foo'\nassert s['foo'] == 'hello hello bar'  # what the...\ns['foo'] = s['foo']  # retrieve what's under 'foo' and store it back into 'foo'\nassert s['foo'] == 'hello hello hello bar'  # No no no! I do not like green eggs and ham!\n```\n\nThis happens, because though you've said `s['foo'] = 'bar'`, the value returned by `s['foo']` is \nactually `'hello bar'`. Why? Because though you've stored `'bar'`, you're transforming the data when you\nread it (that's what `_obj_of_data` does). \n\nIs that a desirable behavior? Transforming the stored data before handing it to the user? \nWell, this is such a common pattern that it has it's own acronym and tools named after the acronym: ETL.\nExtract, Transform, Load. \nWhat is happening here is that we composed extraction and transformation. Is that acceptable? \n\nSay I have a big store of tagged audio files of various formats but only want to work with \nfiles containing the 'gunshot' tag and lasting no more than 10s, and further get the data as a \nwaveform (a sequence of samples).   \n\nYou'd probably find this acceptable:\n\n```python\naudio_file_type=type_of(file)\nwith open(file, 'wb') as fp:\n    file_bytes = fp.read()\nwf = convert_to_waveform(file_bytes)\n```\n\nOr this:\n```python\nfilt = mk_file_filter(tag='gunshot', max_size_s=10)\nfor file in filter(filt, audio_source):\n    with open(file, 'wb') as fp:\n        file_bytes = fp.read()\n    wf = convert_to_waveform(file_bytes, audio_file_type=type_of(file))\n    send_wf_for_analysis(wf)\n```\n\nYou might even find it acceptable to put such code in a functions called `get_waveform_from_file`, \nor `generator_of_waveforms_of_filtered_files`. \n\nSo why is it harder to accept something where you make a store that encompasses your needs. \nYou do `s = WfStore(audio_source, filt)` and then\n\n```python\nwf = s[some_file]  # get a waveform\n```\n\nor\n\n```python\nfor wf in s.values():  # iterate over all waveforms\n    send_wf_for_analysis(wf)\n```\n\nIt's harder to accept precisely because of the simplicity and consistency (with dict operations). \nWe're used to `s[some_file]` meaning \"give me THE value stored in s, in the 'some_file' slot\". \nWe're not used to `s[some_file]` meaning \n\"go get the data stored in `some_file` and give it to me in a format more convenient for my use\".\n\nStores allow you to compose extraction and transformation, or transformation and loading, \nand further specifying filter, caching, indexing, and many other aspects related to storage. \nThose, py2store helps you create the perspective you want, or need. \n\nThat said, one needs to be careful that the simplicity thus created doesn't induce misuse. \nFor example, in the `MyFunnyStore` example above, we may want to use a different store to persist \nand to read, and perhaps reflect their function in their names. For example:\n\n```python\n# defining the store\nfrom py2store.base import Store\n\n\nclass ExtractAndTransform(Store):\n    def _obj_of_data(self, data):\n        return f'hello {data}'\n             \nstore = Store()\nextract_and_transform = ExtractAndTransform(store)\nstore['foo'] = 'bar'  # put 'bar' in 'foo'\nassert store['foo'] == 'bar'  # the value that store contains for 'foo' is 'bar'\nassert extract_and_transform['foo'] == 'hello bar'  # the value that extract_and_transform gives you is 'bar'\n```\n\n# Some links\n\nPresentation at PyBay 2019: https://www.youtube.com/watch?v=6lx0A6oVM5E\n\nETL: Extract, Transform, Load: https://en.wikipedia.org/wiki/Extract,_transform,_load\nORM: Object-relational mapping: https://en.wikipedia.org/wiki/Object-relational_mapping\n\nDAO: Data access object: https://en.wikipedia.org/wiki/Data_access_object\n\nDRY: https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\n\nSOC: Separation Of Concerns: https://en.wikipedia.org/wiki/Separation_of_concerns\n\nCOC: Convention Over Configuration: https://en.wikipedia.org/wiki/Convention_over_configuration", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/i2mint/py2store/archive/v0.0.6.zip", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/i2mint/py2store", "keywords": "storage,interface", "license": "Apache", "maintainer": "", "maintainer_email": "", "name": "py2store", "package_url": "https://pypi.org/project/py2store/", "platform": "", "project_url": "https://pypi.org/project/py2store/", "project_urls": {"Download": "https://github.com/i2mint/py2store/archive/v0.0.6.zip", "Homepage": "https://github.com/i2mint/py2store"}, "release_url": "https://pypi.org/project/py2store/0.0.7/", "requires_dist": null, "requires_python": "", "summary": "DAO for Python: Tools to create simple and consistent interfaces to complicated and varied data sources.", "version": "0.0.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <ul>\n<li><a href=\"#py2store\" rel=\"nofollow\">py2store</a>\n<ul>\n<li><a href=\"#quickstart\" rel=\"nofollow\">Quickstart</a></li>\n<li><a href=\"#use-cases\" rel=\"nofollow\">Use cases</a>\n<ul>\n<li><a href=\"#interfacing-reads\" rel=\"nofollow\">Interfacing reads</a></li>\n<li><a href=\"#changing-where-and-how-things-are-stored\" rel=\"nofollow\">Changing where and how things are stored</a></li>\n<li><a href=\"#adapters-when-the-learning-curve-is-in-the-way-of-learning\" rel=\"nofollow\">Adapters: When the learning curve is in the way of learning</a></li>\n<li><a href=\"#thinking-about-storage-later-if-ever\" rel=\"nofollow\">Thinking about storage later, if ever</a></li>\n</ul>\n</li>\n<li><a href=\"#more-examples\" rel=\"nofollow\">More examples</a>\n<ul>\n<li><a href=\"#looks-like-a-dict\" rel=\"nofollow\">Looks like a dict</a></li>\n<li><a href=\"#converting-keys-relative-paths-and-absolute-paths\" rel=\"nofollow\">Converting keys: Relative paths and absolute paths</a></li>\n<li><a href=\"#serializationdeserialization\" rel=\"nofollow\">Serialization/Deserialization</a></li>\n<li><a href=\"#a-pickle-store\" rel=\"nofollow\">A pickle store</a></li>\n<li><a href=\"#but-how-do-you-change-the-persister\" rel=\"nofollow\">But how do you change the persister?</a></li>\n<li><a href=\"#talk-your-own-crud-dialect\" rel=\"nofollow\">Talk your own CRUD dialect</a></li>\n<li><a href=\"#transforming-keys\" rel=\"nofollow\">Transforming keys</a></li>\n</ul>\n</li>\n<li><a href=\"#how-it-works\" rel=\"nofollow\">How it works</a></li>\n<li><a href=\"#a-few-persisters-you-can-use\" rel=\"nofollow\">A few persisters you can use</a>\n<ul>\n<li><a href=\"#local-files\" rel=\"nofollow\">Local Files</a></li>\n<li><a href=\"#mongodb\" rel=\"nofollow\">MongoDB</a></li>\n<li><a href=\"#s3-sql-zips-dropbox\" rel=\"nofollow\">S3, SQL, Zips, Dropbox</a></li>\n</ul>\n</li>\n<li><a href=\"#philosophical-faqs\" rel=\"nofollow\">Philosophical FAQs</a>\n<ul>\n<li><a href=\"#is-a-store-an-orm-a-dao\" rel=\"nofollow\">Is a store an ORM? A DAO?</a></li>\n<li><a href=\"#should-storage-transform-the-data\" rel=\"nofollow\">Should storage transform the data?</a></li>\n</ul>\n</li>\n<li><a href=\"#some-links\" rel=\"nofollow\">Some links</a></li>\n</ul>\n</li>\n</ul>\n<h1>py2store</h1>\n<p>Storage CRUD how and where you want it.</p>\n<p>List, read, write, and delete data in a structured data source/target,\nas if manipulating simple python builtins (dicts, lists), or through the interface <strong>you</strong> want to interact with,\nwith configuration or physical particularities out of the way.\nAlso, being able to change these particularities without having to change the business-logic code.</p>\n<p>If you're not a \"read from top to bottom\" kinda person, here are some tips:\n<a href=\"#quickstart\" rel=\"nofollow\">Quickstart</a> will show you a simple example of how it looks and feels.\n<a href=\"#use-cases\" rel=\"nofollow\">Use cases</a> will give you an idea of how py2store can be useful to you, if at all,\nand <a href=\"#how-it-works\" rel=\"nofollow\">How it works</a> will give you a sense of how it works.\n<a href=\"#more-examples\" rel=\"nofollow\">More examples</a> will give you a taste of how you can adapt the three main aspects of\nstorage (persistence, serialization, and indexing) to your needs.</p>\n<h1>Quickstart</h1>\n<p>Install it (e.g. <code>pip install py2store</code>).</p>\n<p>Think of type of storage you want to use and just go ahead, like you're using a dict.\nHere's an example for local storage (you must you string keys only here).</p>\n<pre><code>&gt;&gt;&gt; from py2store import QuickStore\n&gt;&gt;&gt;\n&gt;&gt;&gt; store = QuickStore()  # will print what (tmp) rootdir it is choosing\n&gt;&gt;&gt; # Write something and then read it out again\n&gt;&gt;&gt; store['foo'] = 'baz'\n&gt;&gt;&gt; 'foo' in store  # do you have the key 'foo' in your store?\nTrue\n&gt;&gt;&gt; store['foo']  # what is the value for 'foo'?\n'baz'\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Okay, it behaves like a dict, but go have a look in your file system,  \n&gt;&gt;&gt; # and see that there is now a file in the rootdir, named 'foo'!\n&gt;&gt;&gt; \n&gt;&gt;&gt; # Write something more complicated\n&gt;&gt;&gt; store['hello/world'] = [1, 'flew', {'over': 'a', \"cuckoo's\": map}]\n&gt;&gt;&gt; stored_val = store['hello/world']\n&gt;&gt;&gt; stored_val == [1, 'flew', {'over': 'a', \"cuckoo's\": map}]  # was it retrieved correctly?\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; # how many items do you have now?\n&gt;&gt;&gt; assert len(store) &gt;= 2  # can't be sure there were no elements before, so can't assert == 2\n&gt;&gt;&gt; \n&gt;&gt;&gt; # delete the stuff you've written\n&gt;&gt;&gt; del store['foo']\n&gt;&gt;&gt; del store['hello/world']\n</code></pre>\n<p><code>QuickStore</code> will by default store things in local files, using pickle as the serializer.\nIf a root directory is not specified,\nit will use a tmp directory it will create (the first time you try to store something)\nIt will create any directories that need to be created to satisfy any/key/that/contains/slashes.\nOf course, everything is configurable.</p>\n<h1>Use cases</h1>\n<h2>Interfacing reads</h2>\n<p>How many times did someone share some data with you in the form of a zip of some nested folders\nwhose structure and naming choices are fascinatingly obscure? And how much time do you then spend to write code\nto interface with that freak of nature? Well, one of the intents of py2store is to make that easier to do.\nYou still need to understand the structure of the data store and how to deserialize these datas into python\nobjects you can manipulate. But with the proper tool, you shouldn't have to do much more than that.</p>\n<h2>Changing where and how things are stored</h2>\n<p>Ever have to switch where you persist things (say from file system to S3), or change the way key into your data,\nor the way that data is serialized? If you use py2store tools to separate the different storage concerns,\nit'll be quite easy to change, since change will be localized. And if you're dealing with code that was already\nwritten, with concerns all mixed up, py2store should still be able to help since you'll be able to\nmore easily give the new system a facade that makes it look like the old one.</p>\n<p>All of this can also be applied to data bases as well, in-so-far as the CRUD operations you're using\nare covered by the base methods.</p>\n<h2>Adapters: When the learning curve is in the way of learning</h2>\n<p>Shinny new storage mechanisms (DBs etc.) are born constantly, and some folks start using them, and we are eventually lead to use them\nas well if we need to work with those folks' systems. And though we'd love to learn the wonderful new\ncapabilities the new kid on the block has, sometimes we just don't have time for that.</p>\n<p>Wouldn't it be nice if someone wrote an adapter to the new system that had an interface we were familiar with?\nTalking to SQL as if it were mongo (or visa versa). Talking to S3 as if it were a file system.\nNow it's not a long term solution: If we're really going to be using the new system intensively, we\nshould learn it. But when you just got to get stuff done, having a familiar facade to something new\nis a life saver.</p>\n<p>py2store would like to make it easier for you roll out an adapter to be able to talk\nto the new system in the way <strong>you</strong> are familiar with.</p>\n<h2>Thinking about storage later, if ever</h2>\n<p>You have a new project or need to write a new app. You'll need to store stuff and read stuff back.\nStuff: Different kinds of resources that your app will need to function. Some people enjoy thinking\nof how to optimize that aspect. I don't. I'll leave it to the experts to do so when the time comes.\nOften though, the time is later, if ever. Few proof of concepts and MVPs ever make it to prod.</p>\n<p>So instead, I'd like to just get on with the business logic and write my program.\nSo what I need is an easy way to get some minimal storage functionality.\nBut when the time comes to optimize, I shouldn't have to change my code, but instead just change the way my\nDAO does things. What I need is py2store.</p>\n<h1>More examples</h1>\n<h2>Looks like a dict</h2>\n<p>Below, we make a default store and demo a few basic operations on it.\nThe default store uses a dict as it's backend persister.\nA dict is neither really a backend, nor a persister. But it helps to try things out with no\nfootprint.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">py2store.base</span> <span class=\"kn\">import</span> <span class=\"n\">Store</span>\n\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">Store</span><span class=\"p\">()</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[]</span>\n<span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># put 'bar' in 'foo'</span>\n<span class=\"k\">assert</span> <span class=\"s1\">'foo'</span> <span class=\"ow\">in</span> <span class=\"n\">s</span>  <span class=\"c1\"># check that 'foo' is in (i.e. a key of) s</span>\n<span class=\"k\">assert</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># see that the value that 'foo' contains is 'bar'</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span>  <span class=\"c1\"># list all the keys (there's only one)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">())</span> <span class=\"o\">==</span> <span class=\"p\">[(</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"s1\">'bar'</span><span class=\"p\">)]</span>  <span class=\"c1\"># list all the (key, value) pairs</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'bar'</span><span class=\"p\">]</span>  <span class=\"c1\"># list all the values</span>\n<span class=\"k\">assert</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>  <span class=\"c1\"># Number of items in my store</span>\n<span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'another'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'item'</span>  <span class=\"c1\"># store another item</span>\n<span class=\"k\">assert</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span>  <span class=\"c1\"># Now I have two!</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"s1\">'another'</span><span class=\"p\">]</span>  <span class=\"c1\"># here they are</span>\n</pre>\n<p>There's nothing fantastic in the above code.\nI've just demoed some operations on a dict.\nBut it's exactly this simplicity that py2store aims for.\nYou can now replace the <code>s = Store()</code> with <code>s = AnotherStore(...)</code> where <code>AnotherStore</code>\nnow uses some other backend that could be remote or local, could be a database, or any\nsystem that can store <code>something</code> (the value) <code>somewhere</code> (the key).</p>\n<p>You can choose from an existing store (e.g. local files, for AWS S3, for MongoDB) or\nquite easily make your own (more on that later).</p>\n<p>And yet, it will still look like you're talking to a dict. This not only means that you can\ntalk to various storage systems without having to actually learn how to, but also means\nthat the same business logic code you've written can be reused with no modification.</p>\n<p>But py2store offers more than just a simple consistent facade to <strong>where</strong> you store things,\nbut also provides means to define <strong>how</strong> you do it.</p>\n<p>In the case of key-value storage, the \"how\" is defined on the basis of the keys (how you reference)\nthe objects you're storing and the values (how you serialize and deserialize those objects).</p>\n<h2>Converting keys: Relative paths and absolute paths</h2>\n<p>Take a look at the following example, that adds a layer of key conversion to a store.</p>\n<pre><span class=\"c1\"># defining the store</span>\n<span class=\"kn\">from</span> <span class=\"nn\">py2store.base</span> <span class=\"kn\">import</span> <span class=\"n\">Store</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">PrefixedKeyStore</span><span class=\"p\">(</span><span class=\"n\">Store</span><span class=\"p\">):</span>\n    <span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"s1\">''</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_id_of_key</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span> <span class=\"o\">+</span> <span class=\"n\">key</span>  <span class=\"c1\"># prepend prefix before passing on to store</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_key_of_id</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">_id</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">_id</span><span class=\"o\">.</span><span class=\"n\">startswith</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">):</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"_id </span><span class=\"si\">{</span><span class=\"n\">_id</span><span class=\"si\">}</span><span class=\"s2\"> wasn't prefixed with </span><span class=\"si\">{</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">_id</span><span class=\"p\">[</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">prefix</span><span class=\"p\">):]</span>  <span class=\"c1\"># don't show the user the prefix</span>\n            \n<span class=\"c1\"># trying the store out            </span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">PrefixedKeyStore</span><span class=\"p\">()</span>\n<span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"s1\">'/ROOT/'</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[]</span>\n<span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># put 'bar' in 'foo'</span>\n<span class=\"k\">assert</span> <span class=\"s1\">'foo'</span> <span class=\"ow\">in</span> <span class=\"n\">s</span>  <span class=\"c1\"># check that 'foo' is in (i.e. a key of) s</span>\n<span class=\"k\">assert</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># see that the value that 'foo' contains is 'bar'</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span>  <span class=\"c1\"># list all the keys (there's only one)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">())</span> <span class=\"o\">==</span> <span class=\"p\">[(</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"s1\">'bar'</span><span class=\"p\">)]</span>  <span class=\"c1\"># list all the (key, value) pairs</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'bar'</span><span class=\"p\">]</span>  <span class=\"c1\"># list all the values</span>\n<span class=\"k\">assert</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>  <span class=\"c1\"># Number of items in my store</span>\n<span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'another'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'item'</span>  <span class=\"c1\"># store another item</span>\n<span class=\"k\">assert</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span>  <span class=\"c1\"># Now I have two!</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"s1\">'another'</span><span class=\"p\">]</span>  <span class=\"c1\"># here they are      </span>\n</pre>\n<p>Q: That wasn't impressive! It's just the same as the first Store. What's this prefix all about?</p>\n<p>A: The prefix thing is hidden, and that's the point. You want to talk the \"relative\" (i.e \"prefix-free\")\nlanguage, but may have the need for this prefix to be prepended to the key before persisting the data\nand that prefix to be removed before being displayed to the user.\nThink of working with files. Do you want to have to specify the root folder every time you store something\nor retrieve something?</p>\n<p>Q: Prove it!</p>\n<p>A: Okay, let's look under the hood at what the underlying store (a dict) is dealing with:</p>\n<pre><span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">())</span> <span class=\"o\">==</span> <span class=\"p\">[(</span><span class=\"s1\">'/ROOT/foo'</span><span class=\"p\">,</span> <span class=\"s1\">'bar'</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"s1\">'/ROOT/another'</span><span class=\"p\">,</span> <span class=\"s1\">'item'</span><span class=\"p\">)]</span>\n</pre>\n<p>You see? The keys that the \"backend\" is using are actually prefixed with <code>\"/ROOT/\"</code></p>\n<h2>Serialization/Deserialization</h2>\n<p>Let's now demo serialization and deserialization.</p>\n<p>Say we want to deserialize any text we stored by appending <code>\"hello \"</code> to everything stored.</p>\n<pre><span class=\"c1\"># defining the store</span>\n<span class=\"kn\">from</span> <span class=\"nn\">py2store.base</span> <span class=\"kn\">import</span> <span class=\"n\">Store</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyFunnyStore</span><span class=\"p\">(</span><span class=\"n\">Store</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_obj_of_data</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"sa\">f</span><span class=\"s1\">'hello </span><span class=\"si\">{</span><span class=\"n\">data</span><span class=\"si\">}</span><span class=\"s1\">'</span>\n    \n<span class=\"c1\"># trying the store out            </span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">MyFunnyStore</span><span class=\"p\">()</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[]</span>\n<span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># put 'bar' in 'foo'</span>\n<span class=\"k\">assert</span> <span class=\"s1\">'foo'</span> <span class=\"ow\">in</span> <span class=\"n\">s</span>  <span class=\"c1\"># check that 'foo' is in (i.e. a key of) s</span>\n<span class=\"k\">assert</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'hello bar'</span>  <span class=\"c1\"># the value that 'foo' contains SEEMS to be 'hello bar'</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span>  <span class=\"c1\"># list all the keys (there's only one)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">())</span> <span class=\"o\">==</span> <span class=\"p\">[(</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"s1\">'hello bar'</span><span class=\"p\">)]</span>  <span class=\"c1\"># list all the (key, value) pairs</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'hello bar'</span><span class=\"p\">]</span>  <span class=\"c1\"># list all the values    </span>\n</pre>\n<p>Note: This is an easy example to demo on-load transformation of data (i.e. deserialization),\nbut wouldn't be considered \"deserialization\" by all.\nSee the <a href=\"#should-storage-transform-the-data\" rel=\"nofollow\">Should storage transform the data?</a> discussion below.</p>\n<p>In the following, we want to serialize our text by upper-casing it (and see it as such)\nwhen we retrieve the text.</p>\n<pre><span class=\"c1\"># defining the store</span>\n<span class=\"kn\">from</span> <span class=\"nn\">py2store.base</span> <span class=\"kn\">import</span> <span class=\"n\">Store</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyOtherFunnyStore</span><span class=\"p\">(</span><span class=\"n\">Store</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_data_of_obj</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">obj</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">upper</span><span class=\"p\">()</span>\n      \n<span class=\"c1\"># trying the store out              </span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">MyOtherFunnyStore</span><span class=\"p\">()</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[]</span>\n<span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># put 'bar' in 'foo'</span>\n<span class=\"k\">assert</span> <span class=\"s1\">'foo'</span> <span class=\"ow\">in</span> <span class=\"n\">s</span>  <span class=\"c1\"># check that 'foo' is in (i.e. a key of) s</span>\n<span class=\"k\">assert</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'BAR'</span>  <span class=\"c1\"># see that the value that 'foo' contains is 'bar'</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span>  <span class=\"c1\"># list all the keys (there's only one)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">())</span> <span class=\"o\">==</span> <span class=\"p\">[(</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"s1\">'BAR'</span><span class=\"p\">)]</span>  <span class=\"c1\"># list all the (key, value) pairs</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">())</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s1\">'BAR'</span><span class=\"p\">]</span>  <span class=\"c1\"># list all the values</span>\n</pre>\n<p>In the last to serialization examples, we only implemented one way transformations.\nThat's all fine if you just want to have a writer (so only need a serializer) or a reader (so only\nneed a deserializer).\nIn most cases though, you will need two way transformations, specifying how the object\nshould be serialized to be stored, and how it should be deserialized to get your object back.</p>\n<h2>A pickle store</h2>\n<p>Say you wanted the store to pickle as your serializer. Here's how this could look like.</p>\n<pre><span class=\"c1\"># defining the store</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pickle</span>\n<span class=\"kn\">from</span> <span class=\"nn\">py2store.base</span> <span class=\"kn\">import</span> <span class=\"n\">Store</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">PickleStore</span><span class=\"p\">(</span><span class=\"n\">Store</span><span class=\"p\">):</span>\n    <span class=\"n\">protocol</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n    <span class=\"n\">fix_imports</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n    <span class=\"n\">encoding</span> <span class=\"o\">=</span> <span class=\"s1\">'ASCII'</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_data_of_obj</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">obj</span><span class=\"p\">):</span>  <span class=\"c1\"># serializer</span>\n        <span class=\"k\">return</span> <span class=\"n\">pickle</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">protocol</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">protocol</span><span class=\"p\">,</span> <span class=\"n\">fix_imports</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fix_imports</span><span class=\"p\">)</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_obj_of_data</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>  <span class=\"c1\"># deserializer</span>\n        <span class=\"k\">return</span> <span class=\"n\">pickle</span><span class=\"o\">.</span><span class=\"n\">loads</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">fix_imports</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fix_imports</span><span class=\"p\">,</span> <span class=\"n\">encoding</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">encoding</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># trying the store out              </span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">PickleStore</span><span class=\"p\">()</span>\n<span class=\"k\">assert</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[]</span>\n<span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># put 'bar' in 'foo'</span>\n<span class=\"k\">assert</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># I can get 'bar' back</span>\n<span class=\"c1\"># behind the scenes though, it's really a pickle that is stored:</span>\n<span class=\"k\">assert</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">store</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"sa\">b</span><span class=\"s1\">'</span><span class=\"se\">\\x80\\x03</span><span class=\"s1\">X</span><span class=\"se\">\\x03\\x00\\x00\\x00</span><span class=\"s1\">barq</span><span class=\"se\">\\x00</span><span class=\"s1\">.'</span>\n</pre>\n<p>Again, it doesn't seem that impressive that you can get back a string that you stored in a dict.\nFor two reasons: (1) you don't really need to serialize strings to store them and (2) you don't need to serialize python\nobjects to store them in a dict.\nBut if you (1) were trying to store more complex types and (2) were actually persisting them in a file system or database,\nthen you'll need to serialize.\nThe point here is that the serialization and persisting concerns are separated from the storage and retrieval concern.\nThe code still looks like you're working with a dict.</p>\n<h2>But how do you change the persister?</h2>\n<p>By using a persister that persists where you want.\nYou can also write your own. All a persister needs to work with py2store is that it follows the interface\npython's <code>collections.MutableMapping</code> (or a subset thereof). More on how to make your own persister later\nYou just need to follow the collections.MutableMapping interface.</p>\n<p>Below a simple example of how to persist in files under a given folder.\n(Warning: If you want a local file store, don't use this, but one of the easier to use, robust and safe stores in the\nstores folder!)</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"kn\">from</span> <span class=\"nn\">collections.abc</span> <span class=\"kn\">import</span> <span class=\"n\">MutableMapping</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">SimpleFilePersister</span><span class=\"p\">(</span><span class=\"n\">MutableMapping</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Read/write (text or binary) data to files under a given rootdir.</span>\n<span class=\"sd\">    Keys must be absolute file paths.</span>\n<span class=\"sd\">    Paths that don't start with rootdir will be raise a KeyValidationError</span>\n<span class=\"sd\">    \"\"\"</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">rootdir</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">'t'</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">rootdir</span><span class=\"o\">.</span><span class=\"n\">endswith</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">sep</span><span class=\"p\">):</span>\n            <span class=\"n\">rootdir</span> <span class=\"o\">=</span> <span class=\"n\">rootdir</span> <span class=\"o\">+</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">sep</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">rootdir</span> <span class=\"o\">=</span> <span class=\"n\">rootdir</span>\n        <span class=\"k\">assert</span> <span class=\"n\">mode</span> <span class=\"ow\">in</span> <span class=\"p\">{</span><span class=\"s1\">'t'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"s1\">''</span><span class=\"p\">},</span> <span class=\"sa\">f</span><span class=\"s2\">\"mode (</span><span class=\"si\">{</span><span class=\"n\">mode</span><span class=\"si\">}</span><span class=\"s2\">) not valid: Must be 't' or 'b'\"</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">mode</span> <span class=\"o\">=</span> <span class=\"n\">mode</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__getitem__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"s1\">'r'</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">mode</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">fp</span><span class=\"p\">:</span>\n            <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">fp</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"n\">data</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__setitem__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">):</span>\n        <span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"s1\">'w'</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">mode</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">fp</span><span class=\"p\">:</span>\n            <span class=\"n\">fp</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__delitem__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__contains__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\" Implementation of \"k in self\" check.</span>\n<span class=\"sd\">        Note: MutableMapping gives you this for free, using a try/except on __getitem__,</span>\n<span class=\"sd\">        but the following uses faster os functionality.\"\"\"</span>\n        <span class=\"k\">return</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">isfile</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__iter__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">yield from</span> <span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">isfile</span><span class=\"p\">,</span> \n                          <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">rootdir</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">),</span> \n                              <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">listdir</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">rootdir</span><span class=\"p\">)))</span>\n        \n    <span class=\"k\">def</span> <span class=\"fm\">__len__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"Note: There's system-specific faster ways to do this.\"\"\"</span>\n        <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"fm\">__iter__</span><span class=\"p\">():</span>\n            <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">return</span> <span class=\"n\">count</span>\n    \n    <span class=\"k\">def</span> <span class=\"nf\">clear</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"MutableMapping creates a 'delete all' functionality by default. Better disable it!\"\"\"</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">NotImplementedError</span><span class=\"p\">(</span><span class=\"s2\">\"If you really want to do that, loop on all keys and remove them one by one.\"</span><span class=\"p\">)</span>\n</pre>\n<p>Now try this out:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"c1\"># What folder you want to use. Defaulting to the home folder. You can choose another place, but make sure </span>\n<span class=\"n\">rootdir</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">expanduser</span><span class=\"p\">(</span><span class=\"s1\">'~/'</span><span class=\"p\">)</span>  <span class=\"c1\"># Defaulting to the home folder. You can choose another place</span>\n\n<span class=\"n\">persister</span> <span class=\"o\">=</span> <span class=\"n\">SimpleFilePersister</span><span class=\"p\">(</span><span class=\"n\">rootdir</span><span class=\"p\">)</span>\n<span class=\"n\">foo_fullpath</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">rootdir</span><span class=\"p\">,</span> <span class=\"s1\">'foo'</span><span class=\"p\">)</span>\n<span class=\"n\">persister</span><span class=\"p\">[</span><span class=\"n\">foo_fullpath</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># write 'bar' to a file named foo_fullpath</span>\n<span class=\"k\">assert</span> <span class=\"n\">persister</span><span class=\"p\">[</span><span class=\"n\">foo_fullpath</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># see that you can read the contents of that file to get your 'bar' back</span>\n<span class=\"k\">assert</span> <span class=\"n\">foo_fullpath</span> <span class=\"ow\">in</span> <span class=\"n\">persister</span>  <span class=\"c1\"># the full filepath indeed exists in (i.e. \"is a key of\") the persister</span>\n<span class=\"k\">assert</span> <span class=\"n\">foo_fullpath</span> <span class=\"ow\">in</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">persister</span><span class=\"p\">)</span>  <span class=\"c1\"># you can list all the contents of the rootdir and file foo_fullpath in it</span>\n</pre>\n<h2>Talk your own CRUD dialect</h2>\n<p>Don't like this dict-like interface? Want to talk <strong>your own</strong> CRUD words?\nWe got you covered! Just subclass <code>SimpleFilePersister</code> and make the changes you want to make:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MySimpleFilePersister</span><span class=\"p\">(</span><span class=\"n\">SimpleFilePersister</span><span class=\"p\">):</span>    \n    <span class=\"c1\"># If it's just renaming, it's easy</span>\n    <span class=\"n\">read</span> <span class=\"o\">=</span> <span class=\"n\">SimpleFilePersister</span><span class=\"o\">.</span><span class=\"fm\">__getitem__</span>\n    <span class=\"n\">exists</span> <span class=\"o\">=</span> <span class=\"n\">SimpleFilePersister</span><span class=\"o\">.</span><span class=\"fm\">__contains__</span>\n    <span class=\"n\">n_files</span> <span class=\"o\">=</span> <span class=\"n\">SimpleFilePersister</span><span class=\"o\">.</span><span class=\"fm\">__len__</span>\n    \n    <span class=\"c1\"># here we want a new method that gives us an actual list of the filepaths in the rootdir</span>\n    <span class=\"n\">list_files</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"bp\">self</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"fm\">__iter__</span><span class=\"p\">())</span>\n\n    <span class=\"c1\"># And for write we want val and key to be swapped in our interface, </span>\n    <span class=\"k\">def</span> <span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">):</span>  <span class=\"c1\"># note that we wanted val to come first here (as with json.dump and pickle.dump interface)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"fm\">__setitem__</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">val</span><span class=\"p\">)</span>  \n\n<span class=\"n\">my_persister</span> <span class=\"o\">=</span> <span class=\"n\">MySimpleFilePersister</span><span class=\"p\">(</span><span class=\"n\">rootdir</span><span class=\"p\">)</span>\n\n<span class=\"n\">foo_fullpath</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">rootdir</span><span class=\"p\">,</span> <span class=\"s1\">'foo1'</span><span class=\"p\">)</span>\n<span class=\"n\">my_persister</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"s1\">'bar1'</span><span class=\"p\">,</span> <span class=\"n\">foo_fullpath</span><span class=\"p\">)</span>  <span class=\"c1\"># write 'bar1' to a file named foo_fullpath</span>\n<span class=\"k\">assert</span> <span class=\"n\">my_persister</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">foo_fullpath</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s1\">'bar1'</span>  <span class=\"c1\"># see that you can read the contents of that file to get your 'bar1' back</span>\n<span class=\"k\">assert</span> <span class=\"n\">my_persister</span><span class=\"o\">.</span><span class=\"n\">exists</span><span class=\"p\">(</span><span class=\"n\">foo_fullpath</span><span class=\"p\">)</span>  <span class=\"c1\"># the full filepath indeed exists in (i.e. \"is a key of\") the persister</span>\n<span class=\"k\">assert</span> <span class=\"n\">foo_fullpath</span> <span class=\"ow\">in</span> <span class=\"n\">my_persister</span><span class=\"o\">.</span><span class=\"n\">list_files</span><span class=\"p\">()</span>  <span class=\"c1\"># you can list all the contents of the rootdir and file foo_fullpath in it</span>\n</pre>\n<h2>Transforming keys</h2>\n<p>But dealing with full paths can be annoying, and might couple code too tightly with a particular local system.\nWe'd like to use relative paths instead.\nEasy: Wrap the persister in the <code>PrefixedKeyStore</code> defined earlier.</p>\n<pre><span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">PrefixedKeyStore</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"o\">=</span><span class=\"n\">persister</span><span class=\"p\">)</span>  <span class=\"c1\"># wrap your persister with the PrefixedKeyStore defined earlier</span>\n<span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">rootdir</span><span class=\"o\">.</span><span class=\"n\">endswith</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">sep</span><span class=\"p\">):</span> \n    <span class=\"n\">rootdir</span> <span class=\"o\">=</span> <span class=\"n\">rootdir</span> <span class=\"o\">+</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">sep</span>  <span class=\"c1\"># make sure the rootdir ends with slash</span>\n<span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">prefix</span> <span class=\"o\">=</span> <span class=\"n\">rootdir</span>  <span class=\"c1\"># use rootdir as prefix in keys</span>\n\n<span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo2'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'bar2'</span>  <span class=\"c1\"># write 'bar2' to a file </span>\n<span class=\"k\">assert</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo2'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'bar2'</span>  <span class=\"c1\"># see that you can read the contents of that file to get your 'bar2' back</span>\n<span class=\"k\">assert</span> <span class=\"s1\">'foo2'</span> <span class=\"ow\">in</span> <span class=\"n\">s</span>  \n<span class=\"k\">assert</span> <span class=\"s1\">'foo2'</span> <span class=\"ow\">in</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">)</span>  \n</pre>\n<h1>How it works</h1>\n<p>py2store offers three aspects that you can define or modify to store things where you like and how you like it:</p>\n<ul>\n<li><strong>Persistence</strong>: Where things are actually stored (memory, files, DBs, etc.)</li>\n<li><strong>Serialization</strong>: Value transformaton.\nHow python objects should be transformed before it is persisted,\nand how persisted data should be transformed into python objects.</li>\n<li><strong>Indexing</strong>: Key transformation. How you name/id/index your data.\nFull or relative paths. Unique combination of parameters (e.g. (country, city)). Etc.</li>\n</ul>\n<p>All of this allows you to do operations such as \"store this (value) in there (persitence) as that (key)\",\nmoving the tedious particularities of the \"in there\" as well how the \"this\" and \"that\" are transformed to fit\nin there, all out of the way of the business logic code. The way it should be.</p>\n<p><img alt=\"alt text\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6b7e50acc02a9da26f3c37398fcd81a0f4fb12fd/696d672f70793273746f72655f686f775f69745f776f726b732e706e67\"></p>\n<p>Note: Where data is actually persisted just depends on what the base CRUD methods\n(<code>__getitem__</code>, <code>__setitem__</code>, <code>__delitem__</code>, <code>__iter__</code>, etc.) define them to be.</p>\n<h1>A few persisters you can use</h1>\n<p>We'll go through a few basic persisters that are ready to use.\nThere are more in each category, and we'll be adding new categories, but\nthis should get you started.</p>\n<p>Here is a useful function to perform a basic test on a store, given a key and value.\nIt doesn't test all store method (see test modules for that), but demos\nthe basic functionality that pretty much every store should be able to do.</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">basic_test</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"o\">=</span><span class=\"s1\">'bar'</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\" This test performs </span>\n<span class=\"sd\">    Warning: Don't use on a key k that you don't want to loose!\"\"\"</span>\n    <span class=\"k\">if</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">store</span><span class=\"p\">:</span>  <span class=\"c1\"># deleting all docs in tmp</span>\n        <span class=\"k\">del</span> <span class=\"n\">store</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">]</span>\n    <span class=\"k\">assert</span> <span class=\"p\">(</span><span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">store</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>  <span class=\"c1\"># see that key is not in store (and testing __contains__)</span>\n    <span class=\"n\">orig_length</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>  <span class=\"c1\"># the length of the store before insertion</span>\n    <span class=\"n\">store</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">v</span>  <span class=\"c1\"># write v to k (testing __setitem__)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">store</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">v</span>  <span class=\"c1\"># see that the value can be retrieved (testing __getitem__, and that __setitem__ worked)</span>\n    <span class=\"k\">assert</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">orig_length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>  <span class=\"c1\"># see that the number of items in the store increased by 1</span>\n    <span class=\"k\">assert</span> <span class=\"p\">(</span><span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">store</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">True</span>  <span class=\"c1\"># see that key is in store now (and testing __contains__ again)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>  <span class=\"c1\"># testing listing the (key) contents of a store (and seeing if )</span>\n    <span class=\"k\">assert</span> <span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">v</span>  <span class=\"c1\"># the get method</span>\n    <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"nb\">iter</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">()))</span>  <span class=\"c1\"># get the first key (test keys method)</span>\n    <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"nb\">iter</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"o\">.</span><span class=\"fm\">__iter__</span><span class=\"p\">()))</span>  <span class=\"c1\"># get the first key (through __iter__)</span>\n    <span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">()</span>  <span class=\"c1\"># test that the __contains__ of store.keys() works</span>\n    \n    <span class=\"k\">try</span><span class=\"p\">:</span> \n        <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"nb\">iter</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">()))</span>  <span class=\"c1\"># get the first value (test values method)</span>\n        <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"nb\">iter</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()))</span>  <span class=\"c1\"># get the first (key, val) pair (test items method)</span>\n    <span class=\"k\">except</span> <span class=\"ne\">Exception</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"values() (therefore items()) didn't work: Probably testing a persister that had other data in it that your persister doesn't like\"</span><span class=\"p\">)</span>\n        \n    <span class=\"k\">assert</span> <span class=\"p\">(</span><span class=\"n\">k</span> <span class=\"ow\">in</span> <span class=\"n\">store</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">True</span> <span class=\"c1\"># testing __contains__ again</span>\n    <span class=\"k\">del</span> <span class=\"n\">store</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">]</span>  <span class=\"c1\"># clean up (and test delete)</span>\n</pre>\n<h2>Local Files</h2>\n<p>There are many choices of local file stores according to what you're trying to do.\nOne general (but not too general) purpose local file store is\n'py2store.stores.local_store.RelativePathFormatStoreEnforcingFormat'.\nIt can do a lot for you, like add a prefix to your keys (so you can talk in relative instead of absolute paths),\nlists all files in subdirectories as well recursively,\nonly show you files that have a given pattern when you list them,\nand not allow you to write to a key that doesn't fit the pattern.\nFurther, it also has what it takes to create parametrized paths or parse out the parameters of a path.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">py2store.stores.local_store</span> <span class=\"kn\">import</span> <span class=\"n\">RelativePathFormatStoreEnforcingFormat</span> <span class=\"k\">as</span> <span class=\"n\">LocalFileStore</span>\n<span class=\"kn\">import</span> <span class=\"nn\">os</span>\n\n<span class=\"n\">rootdir</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">expanduser</span><span class=\"p\">(</span><span class=\"s1\">'~/pystore_tests/'</span><span class=\"p\">)</span>  <span class=\"c1\"># or replace by the folder you want to use</span>\n<span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">makedirs</span><span class=\"p\">(</span><span class=\"n\">rootdir</span><span class=\"p\">,</span> <span class=\"n\">exist_ok</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># this will make all directories that don't exist. Don't use if you don't want that.</span>\n\n<span class=\"n\">store</span> <span class=\"o\">=</span> <span class=\"n\">LocalFileStore</span><span class=\"p\">(</span><span class=\"n\">path_format</span><span class=\"o\">=</span><span class=\"n\">rootdir</span><span class=\"p\">)</span>\n<span class=\"n\">basic_test</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"o\">=</span><span class=\"s1\">'bar'</span><span class=\"p\">)</span>\n</pre>\n<p>The signature of LocalFileStore is:</p>\n<pre><span class=\"n\">LocalFileStore</span><span class=\"p\">(</span><span class=\"n\">path_format</span><span class=\"p\">,</span> <span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">''</span><span class=\"p\">,</span>\n                <span class=\"n\">buffering</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">encoding</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">errors</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">newline</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">closefd</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">opener</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>Often path_format is just used to specify the rootdir, as above.\nBut you can specify the desired format further.\nFor example, the following will only yield .wav files,\nand only allow you to write to keys that end with .wav:</p>\n<pre><span class=\"n\">store</span> <span class=\"o\">=</span> <span class=\"n\">LocalFileStore</span><span class=\"p\">(</span><span class=\"n\">path_format</span><span class=\"o\">=</span><span class=\"s1\">'/THE/ROOT/DIR/</span><span class=\"si\">{}</span><span class=\"s1\">.wav'</span><span class=\"p\">)</span>\n</pre>\n<p>The following will additional add the restriction that those .wav files have the format 'SOMESTRING_'\nfollowed by digits:</p>\n<pre><span class=\"n\">store</span> <span class=\"o\">=</span> <span class=\"n\">LocalFileStore</span><span class=\"p\">(</span><span class=\"n\">path_format</span><span class=\"o\">=</span><span class=\"s1\">'/THE/ROOT/DIR/</span><span class=\"si\">{:s}</span><span class=\"s1\">_</span><span class=\"si\">{:d}</span><span class=\"s1\">.wav'</span><span class=\"p\">)</span>\n</pre>\n<p>You get the point...</p>\n<p>The other arguments of LocalFileStore or more or less those of python's <code>open</code> function.\nThe slight difference is that here the <code>mode</code> argument applies both to read and write.\nIf <code>mode='b'</code> for example, the file will be opened with <code>mode='rb'</code> when opened to read and\nwith <code>mode='wb'</code> when opened to write. For assymetrical read/write modes, the\nuser can specify a <code>read_mode</code> and <code>write_mode</code> (in this case the <code>mode</code> argument is ignored).</p>\n<h2>MongoDB</h2>\n<p>A MongoDB collection is not as naturally a key-value storage as a file system is.\nMongoDB stores \"documents\", which are JSONs of data, having many (possibly nested) fields that are not\nby default enforced by a schema. So in order to talk to mongo as a key-value store, we need to\nspecify what fields should be considered as keys, and what fields should be considered as data.</p>\n<p>By default, the <code>_id</code> field (the only field ensured by default to contain unique values) is the single key field, and\nall other fields are considered to be data fields.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">py2store.stores.mongo_store</span> <span class=\"kn\">import</span> <span class=\"n\">MongoStore</span>\n<span class=\"c1\"># The following makes a default MongoStore, the default pymongo.MongoClient settings, </span>\n<span class=\"c1\"># and db_name='py2store', collection_name='test', key_fields=('_id',)</span>\n<span class=\"n\">store</span> <span class=\"o\">=</span> <span class=\"n\">MongoStore</span><span class=\"p\">()</span>\n<span class=\"n\">basic_test</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'_id'</span><span class=\"p\">:</span> <span class=\"s1\">'foo'</span><span class=\"p\">},</span> <span class=\"n\">v</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'val'</span><span class=\"p\">:</span> <span class=\"s1\">'bar'</span><span class=\"p\">,</span> <span class=\"s1\">'other_val'</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">})</span>\n</pre>\n<p>But it can get annoying to specify the key as a dict every time.\nThe key schema is fixed, so you should be able to just specify the tuple of values making the keys.\nAnd you can, with MongoTupleKeyStore</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">py2store.stores.mongo_store</span> <span class=\"kn\">import</span> <span class=\"n\">MongoTupleKeyStore</span>\n<span class=\"n\">store</span> <span class=\"o\">=</span> <span class=\"n\">MongoTupleKeyStore</span><span class=\"p\">(</span><span class=\"n\">key_fields</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">'_id'</span><span class=\"p\">,</span> <span class=\"s1\">'name'</span><span class=\"p\">))</span>\n<span class=\"n\">basic_test</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1234</span><span class=\"p\">,</span> <span class=\"s1\">'bob'</span><span class=\"p\">),</span> <span class=\"n\">v</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">42</span><span class=\"p\">,</span> <span class=\"s1\">'gender'</span><span class=\"p\">:</span> <span class=\"s1\">'unspecified'</span><span class=\"p\">})</span>\n</pre>\n<h2>S3, SQL, Zips, Dropbox</h2>\n<p>S3 persister/stores work pretty much like LocalStores, but stores in S3. You'll need to have an account with\nAWS to use this. Find S3 stores in py2store.stores.s3_stores.</p>\n<p>SQL give you read and write access to SQL DBs and tables.</p>\n<p>ZipReader (and other related stores) talks to one or several files, giving you the ability to operate as if the zips were uncompressed.</p>\n<p>Dropbox will give you access to dropbox files through the same dict-like interface.</p>\n<h1>Philosophical FAQs</h1>\n<h2>Is a store an ORM? A DAO?</h2>\n<p>Call it what you want, really.</p>\n<p>It would be tempting to coin py2store as ya(p)orm (yet another (python) object-relational mapping),\nbut that would be misleading. The intent of py2store is not to map objects to db entries,\nbut rather to offer a consistent interface for basic storage operations.</p>\n<p>In that sense, py2store is more akin to an implementation of the data access object (DAO) pattern.\nOf course, the difference between ORM and DAO can be blurry, so all this should be taken with a grain of salt.</p>\n<p>Advantages and disadvantages such abstractions are easy to search and find, but in most cases the\npros probably outweigh the cons.</p>\n<p>Most data interaction mechanisms can be satisfied by a subset of the collections.abc interfaces.\nFor example, one can use python's collections.Mapping interface for any key-value storage, making the data access\nobject have the look and feel of a dict, instead of using other popular method name choices such for\nsuch as read/write, load/dump, etc.\nOne of the dangers there is that, since the DAO looks and acts like a dict (but is not) a user might underestimate\nthe running-costs of some operations.</p>\n<h2>Should storage transform the data?</h2>\n<p>When does \"storing data\" <strong>not</strong> transform data? The answer is that storage almost always transforms data in some way.\nBut some of these transformations are taken for granted, because there's so often \"attached\"\n(i.e. \"co-occur\") with the raw process of storing. In py2store, the data transformation is attached to (but not entangled with) the store object.\nThis means you have a specific place where you can check or change that aspect of storage.</p>\n<p>Having a consistent and simple interface to storage is useful. Being able to attach key and value\ntransformations to this interface is also very useful. But though you get a lot for cheap, it's\nnot free: Mapping the many (storage systems operations) to the one (consistent interface) means\nthat, through habit, you might project some misaligned expectations.\nThis is one of the known disadvantages of Data Access Objects (DAOs))</p>\n<p>Have a look at this surreal behavior:</p>\n<pre><span class=\"c1\"># defining the store</span>\n<span class=\"kn\">from</span> <span class=\"nn\">py2store.base</span> <span class=\"kn\">import</span> <span class=\"n\">Store</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyFunnyStore</span><span class=\"p\">(</span><span class=\"n\">Store</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_obj_of_data</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"sa\">f</span><span class=\"s1\">'hello </span><span class=\"si\">{</span><span class=\"n\">data</span><span class=\"si\">}</span><span class=\"s1\">'</span>\n    \n<span class=\"c1\"># trying the store out            </span>\n<span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">MyFunnyStore</span><span class=\"p\">()</span>\n<span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># put 'bar' in 'foo'</span>\n<span class=\"k\">assert</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'hello bar'</span>  <span class=\"c1\"># the value that 'foo' contains SEEMS to be 'hello bar'</span>\n<span class=\"c1\"># so look how surreal that can be:</span>\n<span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span>  <span class=\"c1\"># retrieve what's under 'foo' and store it back into 'foo'</span>\n<span class=\"k\">assert</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'hello hello bar'</span>  <span class=\"c1\"># what the...</span>\n<span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span>  <span class=\"c1\"># retrieve what's under 'foo' and store it back into 'foo'</span>\n<span class=\"k\">assert</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'hello hello hello bar'</span>  <span class=\"c1\"># No no no! I do not like green eggs and ham!</span>\n</pre>\n<p>This happens, because though you've said <code>s['foo'] = 'bar'</code>, the value returned by <code>s['foo']</code> is\nactually <code>'hello bar'</code>. Why? Because though you've stored <code>'bar'</code>, you're transforming the data when you\nread it (that's what <code>_obj_of_data</code> does).</p>\n<p>Is that a desirable behavior? Transforming the stored data before handing it to the user?\nWell, this is such a common pattern that it has it's own acronym and tools named after the acronym: ETL.\nExtract, Transform, Load.\nWhat is happening here is that we composed extraction and transformation. Is that acceptable?</p>\n<p>Say I have a big store of tagged audio files of various formats but only want to work with\nfiles containing the 'gunshot' tag and lasting no more than 10s, and further get the data as a\nwaveform (a sequence of samples).</p>\n<p>You'd probably find this acceptable:</p>\n<pre><span class=\"n\">audio_file_type</span><span class=\"o\">=</span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">)</span>\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">,</span> <span class=\"s1\">'wb'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">fp</span><span class=\"p\">:</span>\n    <span class=\"n\">file_bytes</span> <span class=\"o\">=</span> <span class=\"n\">fp</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()</span>\n<span class=\"n\">wf</span> <span class=\"o\">=</span> <span class=\"n\">convert_to_waveform</span><span class=\"p\">(</span><span class=\"n\">file_bytes</span><span class=\"p\">)</span>\n</pre>\n<p>Or this:</p>\n<pre><span class=\"n\">filt</span> <span class=\"o\">=</span> <span class=\"n\">mk_file_filter</span><span class=\"p\">(</span><span class=\"n\">tag</span><span class=\"o\">=</span><span class=\"s1\">'gunshot'</span><span class=\"p\">,</span> <span class=\"n\">max_size_s</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">file</span> <span class=\"ow\">in</span> <span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"n\">filt</span><span class=\"p\">,</span> <span class=\"n\">audio_source</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">,</span> <span class=\"s1\">'wb'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">fp</span><span class=\"p\">:</span>\n        <span class=\"n\">file_bytes</span> <span class=\"o\">=</span> <span class=\"n\">fp</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()</span>\n    <span class=\"n\">wf</span> <span class=\"o\">=</span> <span class=\"n\">convert_to_waveform</span><span class=\"p\">(</span><span class=\"n\">file_bytes</span><span class=\"p\">,</span> <span class=\"n\">audio_file_type</span><span class=\"o\">=</span><span class=\"n\">type_of</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">))</span>\n    <span class=\"n\">send_wf_for_analysis</span><span class=\"p\">(</span><span class=\"n\">wf</span><span class=\"p\">)</span>\n</pre>\n<p>You might even find it acceptable to put such code in a functions called <code>get_waveform_from_file</code>,\nor <code>generator_of_waveforms_of_filtered_files</code>.</p>\n<p>So why is it harder to accept something where you make a store that encompasses your needs.\nYou do <code>s = WfStore(audio_source, filt)</code> and then</p>\n<pre><span class=\"n\">wf</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">some_file</span><span class=\"p\">]</span>  <span class=\"c1\"># get a waveform</span>\n</pre>\n<p>or</p>\n<pre><span class=\"k\">for</span> <span class=\"n\">wf</span> <span class=\"ow\">in</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">():</span>  <span class=\"c1\"># iterate over all waveforms</span>\n    <span class=\"n\">send_wf_for_analysis</span><span class=\"p\">(</span><span class=\"n\">wf</span><span class=\"p\">)</span>\n</pre>\n<p>It's harder to accept precisely because of the simplicity and consistency (with dict operations).\nWe're used to <code>s[some_file]</code> meaning \"give me THE value stored in s, in the 'some_file' slot\".\nWe're not used to <code>s[some_file]</code> meaning\n\"go get the data stored in <code>some_file</code> and give it to me in a format more convenient for my use\".</p>\n<p>Stores allow you to compose extraction and transformation, or transformation and loading,\nand further specifying filter, caching, indexing, and many other aspects related to storage.\nThose, py2store helps you create the perspective you want, or need.</p>\n<p>That said, one needs to be careful that the simplicity thus created doesn't induce misuse.\nFor example, in the <code>MyFunnyStore</code> example above, we may want to use a different store to persist\nand to read, and perhaps reflect their function in their names. For example:</p>\n<pre><span class=\"c1\"># defining the store</span>\n<span class=\"kn\">from</span> <span class=\"nn\">py2store.base</span> <span class=\"kn\">import</span> <span class=\"n\">Store</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">ExtractAndTransform</span><span class=\"p\">(</span><span class=\"n\">Store</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">_obj_of_data</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"sa\">f</span><span class=\"s1\">'hello </span><span class=\"si\">{</span><span class=\"n\">data</span><span class=\"si\">}</span><span class=\"s1\">'</span>\n             \n<span class=\"n\">store</span> <span class=\"o\">=</span> <span class=\"n\">Store</span><span class=\"p\">()</span>\n<span class=\"n\">extract_and_transform</span> <span class=\"o\">=</span> <span class=\"n\">ExtractAndTransform</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"p\">)</span>\n<span class=\"n\">store</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># put 'bar' in 'foo'</span>\n<span class=\"k\">assert</span> <span class=\"n\">store</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'bar'</span>  <span class=\"c1\"># the value that store contains for 'foo' is 'bar'</span>\n<span class=\"k\">assert</span> <span class=\"n\">extract_and_transform</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s1\">'hello bar'</span>  <span class=\"c1\"># the value that extract_and_transform gives you is 'bar'</span>\n</pre>\n<h1>Some links</h1>\n<p>Presentation at PyBay 2019: <a href=\"https://www.youtube.com/watch?v=6lx0A6oVM5E\" rel=\"nofollow\">https://www.youtube.com/watch?v=6lx0A6oVM5E</a></p>\n<p>ETL: Extract, Transform, Load: <a href=\"https://en.wikipedia.org/wiki/Extract,_transform,_load\" rel=\"nofollow\">https://en.wikipedia.org/wiki/Extract,_transform,_load</a>\nORM: Object-relational mapping: <a href=\"https://en.wikipedia.org/wiki/Object-relational_mapping\" rel=\"nofollow\">https://en.wikipedia.org/wiki/Object-relational_mapping</a></p>\n<p>DAO: Data access object: <a href=\"https://en.wikipedia.org/wiki/Data_access_object\" rel=\"nofollow\">https://en.wikipedia.org/wiki/Data_access_object</a></p>\n<p>DRY: <a href=\"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\" rel=\"nofollow\">https://en.wikipedia.org/wiki/Don%27t_repeat_yourself</a></p>\n<p>SOC: Separation Of Concerns: <a href=\"https://en.wikipedia.org/wiki/Separation_of_concerns\" rel=\"nofollow\">https://en.wikipedia.org/wiki/Separation_of_concerns</a></p>\n<p>COC: Convention Over Configuration: <a href=\"https://en.wikipedia.org/wiki/Convention_over_configuration\" rel=\"nofollow\">https://en.wikipedia.org/wiki/Convention_over_configuration</a></p>\n\n          </div>"}, "last_serial": 7148826, "releases": {"0.0.2": [{"comment_text": "", "digests": {"md5": "e6d94e54421296894f5db060915eca17", "sha256": "5294eaf695758fdb4ee60d3022b2cb750e9967453c618ad7e848da719308aaad"}, "downloads": -1, "filename": "py2store-0.0.2.tar.gz", "has_sig": false, "md5_digest": "e6d94e54421296894f5db060915eca17", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 78406, "upload_time": "2019-08-15T17:01:35", "upload_time_iso_8601": "2019-08-15T17:01:35.737562Z", "url": "https://files.pythonhosted.org/packages/da/cd/647550fd4c49692a4d2c600f70d84ff303365460791e6a219a67950d9c4f/py2store-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "fa147201e55d5dc606f81c3fdedcbf87", "sha256": "d894c9cbb1a5dba1d72a89f951119fb5adf63c1b14e327edfe318ee7646e5cb0"}, "downloads": -1, "filename": "py2store-0.0.3.tar.gz", "has_sig": false, "md5_digest": "fa147201e55d5dc606f81c3fdedcbf87", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 82655, "upload_time": "2019-08-18T17:56:11", "upload_time_iso_8601": "2019-08-18T17:56:11.425513Z", "url": "https://files.pythonhosted.org/packages/36/2f/b1b35acc5c1d13e75a3ca64ac67bbb06c522bfb77cd9246be23444d69f16/py2store-0.0.3.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "5935d5e228f263968fc2999fb3ca8a89", "sha256": "e994cf758cf17084374b11c967705c4f26c9cd56004f9a40f7112dabe194c504"}, "downloads": -1, "filename": "py2store-0.0.4.tar.gz", "has_sig": false, "md5_digest": "5935d5e228f263968fc2999fb3ca8a89", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 126385, "upload_time": "2019-11-01T23:53:21", "upload_time_iso_8601": "2019-11-01T23:53:21.284244Z", "url": "https://files.pythonhosted.org/packages/5f/69/dc4ee6bb6af8fd5b81fae29d31434961d096436277ec0b462de801b4dd6b/py2store-0.0.4.tar.gz", "yanked": false}], "0.0.5": [{"comment_text": "", "digests": {"md5": "29c215e5ea6b24935218500df1b43b3a", "sha256": "0f8d664b715bfeffc93fbbb848207b1909d578cbbf7ea4d47bfea435efb72d3a"}, "downloads": -1, "filename": "py2store-0.0.5.tar.gz", "has_sig": false, "md5_digest": "29c215e5ea6b24935218500df1b43b3a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 126471, "upload_time": "2019-11-02T00:16:27", "upload_time_iso_8601": "2019-11-02T00:16:27.659287Z", "url": "https://files.pythonhosted.org/packages/24/98/35332f4deacf0f134bf0661dc057b230fc37dd6687a028081c9c384d0ac9/py2store-0.0.5.tar.gz", "yanked": false}], "0.0.6": [{"comment_text": "", "digests": {"md5": "f1feb50236ee0442aa47a7c9f9b7088c", "sha256": "895cc35b018eab531495f563beb42238783b4af6735887e8229031fc17e5ccec"}, "downloads": -1, "filename": "py2store-0.0.6.tar.gz", "has_sig": false, "md5_digest": "f1feb50236ee0442aa47a7c9f9b7088c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 159406, "upload_time": "2020-03-22T23:06:24", "upload_time_iso_8601": "2020-03-22T23:06:24.754606Z", "url": "https://files.pythonhosted.org/packages/d9/d8/991be1666eb851d853d9eba104ae991f1b382885ed7771d789dd396ad79b/py2store-0.0.6.tar.gz", "yanked": false}], "0.0.7": [{"comment_text": "", "digests": {"md5": "2f6dd8ffba77a6837d0940e359fe4cfc", "sha256": "97ff745a1c7ce66d0261fb53169aa7b7e0e66587bf719861eaeea873598d7827"}, "downloads": -1, "filename": "py2store-0.0.7.tar.gz", "has_sig": false, "md5_digest": "2f6dd8ffba77a6837d0940e359fe4cfc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 207859, "upload_time": "2020-05-01T23:09:22", "upload_time_iso_8601": "2020-05-01T23:09:22.876155Z", "url": "https://files.pythonhosted.org/packages/06/42/b43181997328f785c8c34a30c94376d3dbce7c5a31de61f269a7b29f1611/py2store-0.0.7.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2f6dd8ffba77a6837d0940e359fe4cfc", "sha256": "97ff745a1c7ce66d0261fb53169aa7b7e0e66587bf719861eaeea873598d7827"}, "downloads": -1, "filename": "py2store-0.0.7.tar.gz", "has_sig": false, "md5_digest": "2f6dd8ffba77a6837d0940e359fe4cfc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 207859, "upload_time": "2020-05-01T23:09:22", "upload_time_iso_8601": "2020-05-01T23:09:22.876155Z", "url": "https://files.pythonhosted.org/packages/06/42/b43181997328f785c8c34a30c94376d3dbce7c5a31de61f269a7b29f1611/py2store-0.0.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:12:28 2020"}