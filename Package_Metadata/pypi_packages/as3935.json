{"info": {"author": "Eloi Codina", "author_email": "eloi.codina@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "Welcome to python_as3935!\n=========================\n\nThis Python module let\u2019s you control the AS3935 lightning detector. The\nboard used is the MOD-1016 from\n`EmbeddedAdventures <http://www.embeddedadventures.com/as3935_lightning_sensor_module_mod-1016.html>`__.\n\n1. It works with `Pigpio <http://abyz.me.uk/rpi/pigpio/>`__ instead of\n   the common `RPi.GPIO <https://pypi.org/project/RPi.GPIO/>`__, in\n   order to be able to use it without being root.\n2. The communication with the device is done via I2C serial protocol.\n3. It allows you to perform every action described in the\n   `datasheet <http://www.embeddedadventures.com/datasheets/AS3935_Datasheet_EN_v2.pdf>`__.\n\nTo install it from Pypi:\n\n::\n\n   $ pip install as3935\n\n1. Connection of the device\n===========================\n\nIf using a `40-pin\nGPIO <https://www.raspberrypi.org/documentation/usage/gpio/>`__\nRaspberry Pi, the device should be connected as follows:\n\n+---------------+--------------------+------------------+\n| Pin on AS3935 | Pin name on RPi    | Pin number (BCM) |\n+===============+====================+==================+\n| Vcc           | 3.3V               | Any              |\n+---------------+--------------------+------------------+\n| IRQ           | Any available GPIO | e.g.\u00a04           |\n+---------------+--------------------+------------------+\n| SCL           | Clock              | 3                |\n+---------------+--------------------+------------------+\n| SDA           | Data               | 2                |\n+---------------+--------------------+------------------+\n| GND           | Ground             | Any              |\n+---------------+--------------------+------------------+\n\n2. Requisites\n=============\n\n2.1 Pigpio\n----------\n\nInstall the Pigpio daemon, either from source or via:\n\n::\n\n   $ sudo apt install pigpio\n\nConfigure *Remote GPIO* using (if on Raspbian):\n\n::\n\n   $ sudo raspi-config\n\nEnable the daemon and start it now:\n\n::\n\n   $ sudo systemctl enable pigpiod\n   $ sudo systemctl start pigpiod\n\nInstall the `Python interface <https://pypi.org/project/pigpio/>`__:\n\n::\n\n   $ pip install pigpio\n\nFor further information, visit\n`Pigpio\u2019s <http://abyz.me.uk/rpi/pigpio/pigpiod.html>`__ webpage.\n\n2.2 Python\n----------\n\nThis module has been tested on Python 3.7. It might work on other\nversions as well. The only library used, a part from *Pigpio*, is *time*\n\n3. Usage\n========\n\nIt is very simple to use. Just import it and create a new object with\nthe configuration you need.\n\n::\n\n   import as3935\n   import pigpio\n       \n   irq_pin_number = 4    # BCM number (code after GPIO)\n   bus = 1               # On newer Raspberrys is 1\n   address = 0x03        # If using MOD-1016 this is the address\n\n   sensor = as3935.AS3935(irq_pin_number, bus, address)\n\n   # We need to calibrate the sensor first. Use the tuning cap provided\n   # or calculate it using sensor.calculate_tuning_cap(*args)\n   sensor.full_calibration(12)\n\n   sensor.set_indoors(True)\n\n   # Every time you sense a pulse on IRQ it means there is an\n   # interruption request. You can read it like this:\n   def irq_callback(gpio, level, tick):\n       interruption = sensor.get_interrupt()\n       if interruption == as3935.INT_NH:\n           print(\"Noise floor too high\")\n       elif interruption == as3935.INT_D:\n           print(\"Disturbance detected. Mask it?\")\n       elif interruption == as3935.INT_L:\n           print(\"Lightning detected!\")\n           distance = sensor.get_distance()\n\n   try:\n       cb = sensor.pi.callback(irq_pin_number, pigpio.RISING_EDGE, irq_callback)\n       while True:\n           pass\n   finally:\n       cb.cancel()\n       sensor.pi.stop()\n\nThis above is a very simple example. Check the full documentation to\nlearn all the methods you can call.\n\n4. Credits\n==========\n\nCreated by Eloi Codina during December 2019. There are other Python\nmodules that allow you to use the AS3935 sensor. However, none of them\nuse Pigpio It is licensed under the GNU General Public License v3.0\n(please read LICENSE.txt)\n\n::\n\n       python_AS3935\n       Copyright (C) 2019  Eloi Codina Torras\n\n       This program is free software: you can redistribute it and/or modify\n       it under the terms of the GNU General Public License as published by\n       the Free Software Foundation, either version 3 of the License, or\n       (at your option) any later version.\n\n       This program is distributed in the hope that it will be useful,\n       but WITHOUT ANY WARRANTY; without even the implied warranty of\n       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n       GNU General Public License for more details.\n\n       You should have received a copy of the GNU General Public License\n       along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\n5. Full documentation\n=====================\n\n5.1 Constants (interruptions)\n-----------------------------\n\n-  *INT_NH*: noise level too high\n-  *INT_D*: man-made disturbance detected\n-  *INT_L*: lightning detected\n\n5.2 Class AS3935\n----------------\n\nIt provides an object to control the AS3935.\n\n-  **irq**: (int) GPIO pin number the IRQ is connected at (BCM number)\n-  **bus**: (int, optional) the bus the AS3935 is connected at. Default\n   = 1\n-  **address**: (int, optional) the address of the AS3935. Default =\n   0x03\n\nYou can access the following properties from this object:\n\n-  **address**: the address of the AS3935\n-  **bus**: the bus of the AS3935\n-  **irq**: the GPIO pin number the IRQ is connected at\n-  **pi**: pigpio.pi instance. You can communicate with the GPIO with\n   this.\n-  **i2c_device**: an integer representing the connection with the\n   AS3935\n\n5.2.1 Methods\n~~~~~~~~~~~~~\n\n5.2.1.1 Cross methods\n^^^^^^^^^^^^^^^^^^^^^\n\n::\n\n   read_byte(self, address)\n         \n        Returns the value of the byte stored at address.\n          \n         :param address: (int) the address to read from  \n         :return: (int) the value of the address  \n\n::\n\n   write_byte(self, address, value)\n         \n        Writes value at address. Raises ValueError if the value is not correct. It sleeps for 2 ms after writing the value\n          \n         :param address: (int) the address to write to  :param value: (int) the byte value (between 0x00 and 0xFF) \n\n::\n\n   full_calibration(self, tuning_cap):  \n       \n        Performs a full calibration: antenna and RCO  \n        \n         :param tuning_cap: int: tuning number for the antenna. Can be calculated with self.calculate_tuning_cap() \n\n5.2.1.3 Operating modes\n^^^^^^^^^^^^^^^^^^^^^^^\n\n::\n\n   power_down_mode(self):    \n     \n      Sets the AS3935 on power down mode (PWD) \n\n::\n\n   listening_mode(self) \n       \n        Sets the AS3935 on listening mode (PWD) \n\n5.2.1.3 Direct commands\n^^^^^^^^^^^^^^^^^^^^^^^\n\n::\n\n   set_default_values(self) \n       \n        Sends a direct command to 0x3C to reset to default values. \n\n::\n\n   calibrate_rco(self)  \n       \n        Sends a direct command to 0x3D to calibrate the RCO (CALIB_RCO) \n\n5.2.1.4 AFE and Watchdog\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n::\n\n   get_indoors(self)\n       \n        Checks whether the device is configured to be run indoors. (AFE_GB)  \n        \n         :return: (bool) whether the device is configured to be run indoors  \n\n::\n\n   set_indoors(self, indoors)\n       \n        Configures the device to be run indoors or outdoors. (AFE_GB)  \n        \n         :param indoors: (bool) configure the AS3935 to be run indoors \n\n::\n\n   get_watchdog_threshold(self)\n       \n        Returns the watchdog threshold (WDTH)  \n        \n         :return: (int) the current watchdog threshold  \n\n::\n\n   set_watchdog_threshold(self, value=0b0001):  \n         \n        Sets the watchdog threshold to value (WDTH). If called without parameters, it sets it to the default configuration. Can raise a ValueError if not 0 <= value <= 0b1111  \n        \n         :param value: (int, optional) The value to be set. From 0b0000 to 0b1111. Default=0b0001  \n\n5.2.1.5 Noise floor generator\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n::\n\n   get_noise_floor(self)\n         \n        Checks the current noise floor threshold (NF_LEV).  \n        \n         :return: (int) the current noise floor threshold  \n\n::\n\n   set_noise_floor(self, noise_floor=0b010) \n         \n        Sets a new noise floor threshold (NF_LEV). If called without parameters, it sets it to the default configuration. Can raise a ValueError if not 0 <= noise_floor <= 0b111  \n       \n         :param noise_floor: (int, optional) The value to be set. From 0b000 to 0b111\n\n::\n\n   lower_noise_floor(self, min_noise=0b000)  \n         \n        Lowers the noise floor threshold by one step (subtracts 1 to the current NF_LEV) if it is currently higher than min_noise. Can raise a ValueError if not 0 <= min_noise <= 0b111  \n        \n         :param min_noise: (int, optional) the minimum NF_LEV the device should be set at. Default = 0b000  :return: (int) the new noise floor threshold \n\n::\n\n   raise_noise_floor(self, max_noise=0b111) \n        \n        Raises the noise floor threshold by one step (adds 1 to the current NF_LEV) if it is currently lower than max_noise Can raise a ValueError if not 0 <= max_noise <= 0b111  \n        \n         :param max_noise: (int, optional) the maximum  NF_LEV the device should be set at. Default 0b111  :return: (int) the new noise floor threshold  \n\n#### 5.2.1.6 Signal validation\n\n::\n\n   get_spike_rejection(self) \n       \n        Checks the current spike rejection settings (SREJ)  \n        \n         :return: (int) the current spike rejection setting (SREJ)  \n\n::\n\n   set_spike_rejection(self, value=0b0010)  \n       \n        Sets a new setting for the spike rejection algorithm (SREJ). If the function is called without any parameter, it sets it to the default value of 0b0010 Can raise a ValueError if not 0 <= value <= 0b1111  \n        \n        :param value: (int, optional) the value to set SREJ. Default = 0b0010 \n\n5.2.1.7 Energy calculation\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n::\n\n   get_energy(self)  \n         \n        Checks the last lightning strike's energy calculation. It does not have any physical meaning. (Energy of the Single Lightning *SBYTE)  \n        \n         :return: (int) last strike's energy \n\n#### 5.2.1.8 Distance estimation\n\n::\n\n   def get_distance(self)  \n        \n        Checks the estimation of the last lightning strike's distance in km (DISTANCE).  \n        \n         :return: (int/None) last strike's distance in km. None if out of range, 0 if overhead  \n\n::\n\n   get_interrupt(self)  \n       \n        Checks the reason of the interruption (INT). To know what it is, use the constants: INT_NH: noise level too high INT_D: disturber detected INT_L: lightning strike detected  \n        \n        It sleeps for 2 ms before retrieving the value, as specified at the datasheet.  \n        \n         :return: (int) the interruption reason  \n\n::\n\n   set_mask_disturber(self, mask_dist)\n       \n        Sets whether disturbers should be masked (MASK_DIST).  \n        \n         :param mask_dist: (bool) whether disturbers should be masked \n\n::\n\n   get_mask_disturber(self)\n       \n        Checks whether disturbers are currently masked (MASK_DIST).  \n        \n         :return: (bool) whether disturbers are currently masked  \n\n::\n\n   get_min_strikes(self)\n       \n        Checks the current configuration of how many strikes AS3935 has to detect in 15 minutes to issue an interrupt (MIN_NUM_LIG). In case of an error, it raises a LookupError  \n        \n         :return: (int) number of strikes. Possible values: 1, 5, 9, 16\n\n::\n\n   set_min_strikes(self, min_strikes)  \n       \n        Sets the minumum number of lightning strikes the AS3935 has to detect in 15 minutes to issue an interrupt (MIN_NUM_LIG). Can raise a ValueError if min_strikes is not an accepted value.  \n        \n         :param min_strikes: (int) min number of strikes to issue an interrupt. Possible values: 1, 5, 9, 16 \n\n::\n\n   clear_lightning_stats(self)\n           \n        Clears the statistics built up by the lightning distance estimation algorithm (CL_STAT) \n\n#### 5.2.1.10 Antenna tunning\n\n::\n\n   get_display_lco(self)  \n       \n        Checks whether the antenna resonance frequency is currently displayed on the IRQ pin (DISP_LCO)  \n        \n         :return: (bool) whether the antenna resonance frequency is currently displayed\n\n::\n\n   set_display_lco(self, display_lco)  \n         \n        Sets whether the antenna resonance frequency should be displayed on the IRQ pin(DISP_LCO).  \n        \n         :param display_lco: (bool) whether the antenna resonance frequency should be displayed \n\n::\n\n   set_tune_antenna(self, tuning_cap) \n       \n        Sets the antenna calibration. It adds or removes internal capacitors according to tuning_cap (TUN_CAP). If tuning_cap is unknown, this could be calculated by calculate_tuning_cap(self, frequency_divisor, tries_frequency) Can raise a ValueError if not 0 <= tuning_cap <= 15  \n        \n         :param tuning_cap: (int) the number to calibrate the antenna \n\n::\n\n   calculate_tuning_cap(self, frequency_divisor=16, tries_frequency=3, seconds_try=4)  \n       \n        Measures the frequency of the LC resonator for every possible tuning_cap and returns the best value. If possible, use the default values for frequency_divisor, tries_frequency and seconds_try. This function takes a long time. It should take about tries_frequency*seconds_try*16 seconds given that there are 16 tuning possibilities.  \n        The ideal frequency is of 500 kHz  \n        Can raise ValueError if frequency_divisor is not a valid number.  \n        \n         :param frequency_divisor: (int) the divisor the AS3935 uses to divide the frequency before displaying it on the IRQ \n         :param tries_frequency: (int) number of times the current frequency is calculated during *seconds_try* seconds to calculate an average  \n         :param seconds_try: (float) seconds during which pulses on IRQ will be counted to calculate the internal frequency  \n         :return: (int) a tuning number between 0 and 15\n\n::\n\n   calculate_resonance_frequency(self, seconds)  \n        \n        Sets the AS3935 to display the antenna resonance frequency on the IRQ during *seconds* and counts the number of pulses in this time to calculate the internal frequency. To get the real frequency multiply this value by the frequency divisor ratio.\n          \n         :param seconds: (int) number of seconds while it should count spikes  :return: (int) internal frequency \n\n::\n\n   get_frequency_division_ratio(self)  \n       \n        Gets the current frequency division ratio. Number by which the real antenna resonance frequency is divided to display on the IRQ pin (LCO_FDIV). Can raise a LookupError if there is an error checkig the configuration.  \n        \n         :return: (int) frequency division ratio. Possible numbers: 16, 32, 64, 128  \n\n::\n\n   set_frequency_division_ratio(self, divisor=16)  \n       \n        Sets a new frequency division ration by which the antenna resonance frequency is divided to display on the IRQ pin (LCO_FDIV).If called with no parameter, it defaults to 16. Can raise a ValueError if *divisor* is not an accepted number.  \n        \n         :param divisor: (int, optional) frequency divisor ratio. Accepted values = (16, 32, 64, 128). Default = 16 \n\n5.2.1.11 Clock generation\n^^^^^^^^^^^^^^^^^^^^^^^^^\n\n::\n\n   get_display_srco(self) \n       \n        Checks whether the SRCO frequency is being displayed on the IRQ pin.  \n        \n         :return: (bool) whether the SRCO frequency is currently displayed \n\n::\n\n   set_display_srco(self, display_srco) \n       \n        Sets whether the SRCO frequency should be displayed on the IRQ pin.  \n        \n         :param display_srco: (bool) whether the SRCO frequency should be displayed \n\n::\n\n   get_display_trco(self)  \n       \n        Checks' whether the TRCO frequency is being displayed on the IRQ pin. \n         \n         :return: (bool) whether the TRCO frequency is currently displayed  \n\n::\n\n   set_display_trco(self, display_trco)  \n       \n        Sets whether the TRCO frequency should be displayed on the IRQ pin. \n    \n         :param display_srco: (bool) whether the TRCO frequency should be displayed  \n\n::\n\n   calibrate_trco(self)  \n       \n        Calibrates the TRCO by sending the direct command CALIB_RCO and toggling the DIS_TRCO bit (low-high-low)", "description_content_type": "", "docs_url": null, "download_url": "https://github.com/ecodina/python_as3935/archive/v0.1.4-beta.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ecodina/python_as3935", "keywords": "python,raspberry,gpio,lightning,sensor", "license": "gpl-3.0", "maintainer": "", "maintainer_email": "", "name": "as3935", "package_url": "https://pypi.org/project/as3935/", "platform": "", "project_url": "https://pypi.org/project/as3935/", "project_urls": {"Download": "https://github.com/ecodina/python_as3935/archive/v0.1.4-beta.tar.gz", "Homepage": "https://github.com/ecodina/python_as3935"}, "release_url": "https://pypi.org/project/as3935/0.1.4/", "requires_dist": null, "requires_python": "", "summary": "A Python3 module to control the lightning detector AS3935 chip", "version": "0.1.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"welcome-to-python-as3935\">\n<h2>Welcome to python_as3935!</h2>\n<p>This Python module let\u2019s you control the AS3935 lightning detector. The\nboard used is the MOD-1016 from\n<a href=\"http://www.embeddedadventures.com/as3935_lightning_sensor_module_mod-1016.html\" rel=\"nofollow\">EmbeddedAdventures</a>.</p>\n<ol>\n<li>It works with <a href=\"http://abyz.me.uk/rpi/pigpio/\" rel=\"nofollow\">Pigpio</a> instead of\nthe common <a href=\"https://pypi.org/project/RPi.GPIO/\" rel=\"nofollow\">RPi.GPIO</a>, in\norder to be able to use it without being root.</li>\n<li>The communication with the device is done via I2C serial protocol.</li>\n<li>It allows you to perform every action described in the\n<a href=\"http://www.embeddedadventures.com/datasheets/AS3935_Datasheet_EN_v2.pdf\" rel=\"nofollow\">datasheet</a>.</li>\n</ol>\n<p>To install it from Pypi:</p>\n<pre>$ pip install as3935\n</pre>\n</div>\n<div id=\"connection-of-the-device\">\n<h2>1. Connection of the device</h2>\n<p>If using a <a href=\"https://www.raspberrypi.org/documentation/usage/gpio/\" rel=\"nofollow\">40-pin\nGPIO</a>\nRaspberry Pi, the device should be connected as follows:</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Pin on AS3935</th>\n<th>Pin name on RPi</th>\n<th>Pin number (BCM)</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>Vcc</td>\n<td>3.3V</td>\n<td>Any</td>\n</tr>\n<tr><td>IRQ</td>\n<td>Any available GPIO</td>\n<td>e.g.\u00a04</td>\n</tr>\n<tr><td>SCL</td>\n<td>Clock</td>\n<td>3</td>\n</tr>\n<tr><td>SDA</td>\n<td>Data</td>\n<td>2</td>\n</tr>\n<tr><td>GND</td>\n<td>Ground</td>\n<td>Any</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"requisites\">\n<h2>2. Requisites</h2>\n<div id=\"pigpio\">\n<h3>2.1 Pigpio</h3>\n<p>Install the Pigpio daemon, either from source or via:</p>\n<pre>$ sudo apt install pigpio\n</pre>\n<p>Configure <em>Remote GPIO</em> using (if on Raspbian):</p>\n<pre>$ sudo raspi-config\n</pre>\n<p>Enable the daemon and start it now:</p>\n<pre>$ sudo systemctl enable pigpiod\n$ sudo systemctl start pigpiod\n</pre>\n<p>Install the <a href=\"https://pypi.org/project/pigpio/\" rel=\"nofollow\">Python interface</a>:</p>\n<pre>$ pip install pigpio\n</pre>\n<p>For further information, visit\n<a href=\"http://abyz.me.uk/rpi/pigpio/pigpiod.html\" rel=\"nofollow\">Pigpio\u2019s</a> webpage.</p>\n</div>\n<div id=\"python\">\n<h3>2.2 Python</h3>\n<p>This module has been tested on Python 3.7. It might work on other\nversions as well. The only library used, a part from <em>Pigpio</em>, is <em>time</em></p>\n</div>\n</div>\n<div id=\"usage\">\n<h2>3. Usage</h2>\n<p>It is very simple to use. Just import it and create a new object with\nthe configuration you need.</p>\n<pre>import as3935\nimport pigpio\n\nirq_pin_number = 4    # BCM number (code after GPIO)\nbus = 1               # On newer Raspberrys is 1\naddress = 0x03        # If using MOD-1016 this is the address\n\nsensor = as3935.AS3935(irq_pin_number, bus, address)\n\n# We need to calibrate the sensor first. Use the tuning cap provided\n# or calculate it using sensor.calculate_tuning_cap(*args)\nsensor.full_calibration(12)\n\nsensor.set_indoors(True)\n\n# Every time you sense a pulse on IRQ it means there is an\n# interruption request. You can read it like this:\ndef irq_callback(gpio, level, tick):\n    interruption = sensor.get_interrupt()\n    if interruption == as3935.INT_NH:\n        print(\"Noise floor too high\")\n    elif interruption == as3935.INT_D:\n        print(\"Disturbance detected. Mask it?\")\n    elif interruption == as3935.INT_L:\n        print(\"Lightning detected!\")\n        distance = sensor.get_distance()\n\ntry:\n    cb = sensor.pi.callback(irq_pin_number, pigpio.RISING_EDGE, irq_callback)\n    while True:\n        pass\nfinally:\n    cb.cancel()\n    sensor.pi.stop()\n</pre>\n<p>This above is a very simple example. Check the full documentation to\nlearn all the methods you can call.</p>\n</div>\n<div id=\"credits\">\n<h2>4. Credits</h2>\n<p>Created by Eloi Codina during December 2019. There are other Python\nmodules that allow you to use the AS3935 sensor. However, none of them\nuse Pigpio It is licensed under the GNU General Public License v3.0\n(please read LICENSE.txt)</p>\n<pre>python_AS3935\nCopyright (C) 2019  Eloi Codina Torras\n\nThis program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n</pre>\n</div>\n<div id=\"full-documentation\">\n<h2>5. Full documentation</h2>\n<div id=\"constants-interruptions\">\n<h3>5.1 Constants (interruptions)</h3>\n<ul>\n<li><em>INT_NH</em>: noise level too high</li>\n<li><em>INT_D</em>: man-made disturbance detected</li>\n<li><em>INT_L</em>: lightning detected</li>\n</ul>\n</div>\n<div id=\"class-as3935\">\n<h3>5.2 Class AS3935</h3>\n<p>It provides an object to control the AS3935.</p>\n<ul>\n<li><strong>irq</strong>: (int) GPIO pin number the IRQ is connected at (BCM number)</li>\n<li><strong>bus</strong>: (int, optional) the bus the AS3935 is connected at. Default\n= 1</li>\n<li><strong>address</strong>: (int, optional) the address of the AS3935. Default =\n0x03</li>\n</ul>\n<p>You can access the following properties from this object:</p>\n<ul>\n<li><strong>address</strong>: the address of the AS3935</li>\n<li><strong>bus</strong>: the bus of the AS3935</li>\n<li><strong>irq</strong>: the GPIO pin number the IRQ is connected at</li>\n<li><strong>pi</strong>: pigpio.pi instance. You can communicate with the GPIO with\nthis.</li>\n<li><strong>i2c_device</strong>: an integer representing the connection with the\nAS3935</li>\n</ul>\n<div id=\"methods\">\n<h4>5.2.1 Methods</h4>\n<div id=\"cross-methods\">\n<h5>5.2.1.1 Cross methods</h5>\n<pre>read_byte(self, address)\n\n     Returns the value of the byte stored at address.\n\n      :param address: (int) the address to read from\n      :return: (int) the value of the address\n</pre>\n<pre>write_byte(self, address, value)\n\n     Writes value at address. Raises ValueError if the value is not correct. It sleeps for 2 ms after writing the value\n\n      :param address: (int) the address to write to  :param value: (int) the byte value (between 0x00 and 0xFF)\n</pre>\n<pre>full_calibration(self, tuning_cap):\n\n     Performs a full calibration: antenna and RCO\n\n      :param tuning_cap: int: tuning number for the antenna. Can be calculated with self.calculate_tuning_cap()\n</pre>\n</div>\n<div id=\"operating-modes\">\n<h5>5.2.1.3 Operating modes</h5>\n<pre>power_down_mode(self):\n\n   Sets the AS3935 on power down mode (PWD)\n</pre>\n<pre>listening_mode(self)\n\n     Sets the AS3935 on listening mode (PWD)\n</pre>\n</div>\n<div id=\"direct-commands\">\n<h5>5.2.1.3 Direct commands</h5>\n<pre>set_default_values(self)\n\n     Sends a direct command to 0x3C to reset to default values.\n</pre>\n<pre>calibrate_rco(self)\n\n     Sends a direct command to 0x3D to calibrate the RCO (CALIB_RCO)\n</pre>\n</div>\n<div id=\"afe-and-watchdog\">\n<h5>5.2.1.4 AFE and Watchdog</h5>\n<pre>get_indoors(self)\n\n     Checks whether the device is configured to be run indoors. (AFE_GB)\n\n      :return: (bool) whether the device is configured to be run indoors\n</pre>\n<pre>set_indoors(self, indoors)\n\n     Configures the device to be run indoors or outdoors. (AFE_GB)\n\n      :param indoors: (bool) configure the AS3935 to be run indoors\n</pre>\n<pre>get_watchdog_threshold(self)\n\n     Returns the watchdog threshold (WDTH)\n\n      :return: (int) the current watchdog threshold\n</pre>\n<pre>set_watchdog_threshold(self, value=0b0001):\n\n     Sets the watchdog threshold to value (WDTH). If called without parameters, it sets it to the default configuration. Can raise a ValueError if not 0 &lt;= value &lt;= 0b1111\n\n      :param value: (int, optional) The value to be set. From 0b0000 to 0b1111. Default=0b0001\n</pre>\n</div>\n<div id=\"noise-floor-generator\">\n<h5>5.2.1.5 Noise floor generator</h5>\n<pre>get_noise_floor(self)\n\n     Checks the current noise floor threshold (NF_LEV).\n\n      :return: (int) the current noise floor threshold\n</pre>\n<pre>set_noise_floor(self, noise_floor=0b010)\n\n     Sets a new noise floor threshold (NF_LEV). If called without parameters, it sets it to the default configuration. Can raise a ValueError if not 0 &lt;= noise_floor &lt;= 0b111\n\n      :param noise_floor: (int, optional) The value to be set. From 0b000 to 0b111\n</pre>\n<pre>lower_noise_floor(self, min_noise=0b000)\n\n     Lowers the noise floor threshold by one step (subtracts 1 to the current NF_LEV) if it is currently higher than min_noise. Can raise a ValueError if not 0 &lt;= min_noise &lt;= 0b111\n\n      :param min_noise: (int, optional) the minimum NF_LEV the device should be set at. Default = 0b000  :return: (int) the new noise floor threshold\n</pre>\n<pre>raise_noise_floor(self, max_noise=0b111)\n\n     Raises the noise floor threshold by one step (adds 1 to the current NF_LEV) if it is currently lower than max_noise Can raise a ValueError if not 0 &lt;= max_noise &lt;= 0b111\n\n      :param max_noise: (int, optional) the maximum  NF_LEV the device should be set at. Default 0b111  :return: (int) the new noise floor threshold\n</pre>\n<p>#### 5.2.1.6 Signal validation</p>\n<pre>get_spike_rejection(self)\n\n     Checks the current spike rejection settings (SREJ)\n\n      :return: (int) the current spike rejection setting (SREJ)\n</pre>\n<pre>set_spike_rejection(self, value=0b0010)\n\n     Sets a new setting for the spike rejection algorithm (SREJ). If the function is called without any parameter, it sets it to the default value of 0b0010 Can raise a ValueError if not 0 &lt;= value &lt;= 0b1111\n\n     :param value: (int, optional) the value to set SREJ. Default = 0b0010\n</pre>\n</div>\n<div id=\"energy-calculation\">\n<h5>5.2.1.7 Energy calculation</h5>\n<pre>get_energy(self)\n\n     Checks the last lightning strike's energy calculation. It does not have any physical meaning. (Energy of the Single Lightning *SBYTE)\n\n      :return: (int) last strike's energy\n</pre>\n<p>#### 5.2.1.8 Distance estimation</p>\n<pre>def get_distance(self)\n\n     Checks the estimation of the last lightning strike's distance in km (DISTANCE).\n\n      :return: (int/None) last strike's distance in km. None if out of range, 0 if overhead\n</pre>\n<pre>get_interrupt(self)\n\n     Checks the reason of the interruption (INT). To know what it is, use the constants: INT_NH: noise level too high INT_D: disturber detected INT_L: lightning strike detected\n\n     It sleeps for 2 ms before retrieving the value, as specified at the datasheet.\n\n      :return: (int) the interruption reason\n</pre>\n<pre>set_mask_disturber(self, mask_dist)\n\n     Sets whether disturbers should be masked (MASK_DIST).\n\n      :param mask_dist: (bool) whether disturbers should be masked\n</pre>\n<pre>get_mask_disturber(self)\n\n     Checks whether disturbers are currently masked (MASK_DIST).\n\n      :return: (bool) whether disturbers are currently masked\n</pre>\n<pre>get_min_strikes(self)\n\n     Checks the current configuration of how many strikes AS3935 has to detect in 15 minutes to issue an interrupt (MIN_NUM_LIG). In case of an error, it raises a LookupError\n\n      :return: (int) number of strikes. Possible values: 1, 5, 9, 16\n</pre>\n<pre>set_min_strikes(self, min_strikes)\n\n     Sets the minumum number of lightning strikes the AS3935 has to detect in 15 minutes to issue an interrupt (MIN_NUM_LIG). Can raise a ValueError if min_strikes is not an accepted value.\n\n      :param min_strikes: (int) min number of strikes to issue an interrupt. Possible values: 1, 5, 9, 16\n</pre>\n<pre>clear_lightning_stats(self)\n\n     Clears the statistics built up by the lightning distance estimation algorithm (CL_STAT)\n</pre>\n<p>#### 5.2.1.10 Antenna tunning</p>\n<pre>get_display_lco(self)\n\n     Checks whether the antenna resonance frequency is currently displayed on the IRQ pin (DISP_LCO)\n\n      :return: (bool) whether the antenna resonance frequency is currently displayed\n</pre>\n<pre>set_display_lco(self, display_lco)\n\n     Sets whether the antenna resonance frequency should be displayed on the IRQ pin(DISP_LCO).\n\n      :param display_lco: (bool) whether the antenna resonance frequency should be displayed\n</pre>\n<pre>set_tune_antenna(self, tuning_cap)\n\n     Sets the antenna calibration. It adds or removes internal capacitors according to tuning_cap (TUN_CAP). If tuning_cap is unknown, this could be calculated by calculate_tuning_cap(self, frequency_divisor, tries_frequency) Can raise a ValueError if not 0 &lt;= tuning_cap &lt;= 15\n\n      :param tuning_cap: (int) the number to calibrate the antenna\n</pre>\n<pre>calculate_tuning_cap(self, frequency_divisor=16, tries_frequency=3, seconds_try=4)\n\n     Measures the frequency of the LC resonator for every possible tuning_cap and returns the best value. If possible, use the default values for frequency_divisor, tries_frequency and seconds_try. This function takes a long time. It should take about tries_frequency*seconds_try*16 seconds given that there are 16 tuning possibilities.\n     The ideal frequency is of 500 kHz\n     Can raise ValueError if frequency_divisor is not a valid number.\n\n      :param frequency_divisor: (int) the divisor the AS3935 uses to divide the frequency before displaying it on the IRQ\n      :param tries_frequency: (int) number of times the current frequency is calculated during *seconds_try* seconds to calculate an average\n      :param seconds_try: (float) seconds during which pulses on IRQ will be counted to calculate the internal frequency\n      :return: (int) a tuning number between 0 and 15\n</pre>\n<pre>calculate_resonance_frequency(self, seconds)\n\n     Sets the AS3935 to display the antenna resonance frequency on the IRQ during *seconds* and counts the number of pulses in this time to calculate the internal frequency. To get the real frequency multiply this value by the frequency divisor ratio.\n\n      :param seconds: (int) number of seconds while it should count spikes  :return: (int) internal frequency\n</pre>\n<pre>get_frequency_division_ratio(self)\n\n     Gets the current frequency division ratio. Number by which the real antenna resonance frequency is divided to display on the IRQ pin (LCO_FDIV). Can raise a LookupError if there is an error checkig the configuration.\n\n      :return: (int) frequency division ratio. Possible numbers: 16, 32, 64, 128\n</pre>\n<pre>set_frequency_division_ratio(self, divisor=16)\n\n     Sets a new frequency division ration by which the antenna resonance frequency is divided to display on the IRQ pin (LCO_FDIV).If called with no parameter, it defaults to 16. Can raise a ValueError if *divisor* is not an accepted number.\n\n      :param divisor: (int, optional) frequency divisor ratio. Accepted values = (16, 32, 64, 128). Default = 16\n</pre>\n</div>\n<div id=\"clock-generation\">\n<h5>5.2.1.11 Clock generation</h5>\n<pre>get_display_srco(self)\n\n     Checks whether the SRCO frequency is being displayed on the IRQ pin.\n\n      :return: (bool) whether the SRCO frequency is currently displayed\n</pre>\n<pre>set_display_srco(self, display_srco)\n\n     Sets whether the SRCO frequency should be displayed on the IRQ pin.\n\n      :param display_srco: (bool) whether the SRCO frequency should be displayed\n</pre>\n<pre>get_display_trco(self)\n\n     Checks' whether the TRCO frequency is being displayed on the IRQ pin.\n\n      :return: (bool) whether the TRCO frequency is currently displayed\n</pre>\n<pre>set_display_trco(self, display_trco)\n\n     Sets whether the TRCO frequency should be displayed on the IRQ pin.\n\n      :param display_srco: (bool) whether the TRCO frequency should be displayed\n</pre>\n<pre>calibrate_trco(self)\n\n     Calibrates the TRCO by sending the direct command CALIB_RCO and toggling the DIS_TRCO bit (low-high-low)\n</pre>\n</div>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6243870, "releases": {"0.1.4": [{"comment_text": "", "digests": {"md5": "cf28898f06ed46144c6893f036a6d2ba", "sha256": "ca5c1a496b655374f6f74816f428c2cf0702952534f356fd5375404998d67563"}, "downloads": -1, "filename": "as3935-0.1.4.tar.gz", "has_sig": false, "md5_digest": "cf28898f06ed46144c6893f036a6d2ba", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10154, "upload_time": "2019-12-04T21:40:11", "upload_time_iso_8601": "2019-12-04T21:40:11.737213Z", "url": "https://files.pythonhosted.org/packages/e9/93/1d0eba766888d51f8136bad3a5ab81581f86d9aa470f58e1b77e57482197/as3935-0.1.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "cf28898f06ed46144c6893f036a6d2ba", "sha256": "ca5c1a496b655374f6f74816f428c2cf0702952534f356fd5375404998d67563"}, "downloads": -1, "filename": "as3935-0.1.4.tar.gz", "has_sig": false, "md5_digest": "cf28898f06ed46144c6893f036a6d2ba", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10154, "upload_time": "2019-12-04T21:40:11", "upload_time_iso_8601": "2019-12-04T21:40:11.737213Z", "url": "https://files.pythonhosted.org/packages/e9/93/1d0eba766888d51f8136bad3a5ab81581f86d9aa470f58e1b77e57482197/as3935-0.1.4.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:17:04 2020"}