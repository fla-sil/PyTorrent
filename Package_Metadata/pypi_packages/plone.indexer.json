{"info": {"author": "Plone Foundation", "author_email": "plone-developers@lists.sourceforge.net", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Plone", "Framework :: Plone :: 4.3", "Framework :: Plone :: 5.0", "Framework :: Plone :: 5.1", "Framework :: Plone :: 5.2", "Framework :: Plone :: Core", "Framework :: Zope2", "Framework :: Zope :: 4", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "Introduction\n============\n\nThis package provides primitives to help delegate ZCatalog indexing operations\nto adapters. It doesn't do very much on its own, but can be used by catalog\nimplementations that want to allow individual index values to be provided\nnot by the object itself, but by separate adapters.\n\n\nChangelog\n=========\n\n.. You should *NOT* be adding new change log entries to this file.\n   You should create a file in the news directory instead.\n   For helpful instructions, please see:\n   https://github.com/plone/plone.releaser/blob/master/ADD-A-NEWS-ITEM.rst\n\n.. towncrier release notes start\n\n1.0.7 (2020-04-20)\n------------------\n\nBug fixes:\n\n\n- Minor packaging updates. (#1)\n\n\n1.0.6 (2019-04-29)\n------------------\n\nBug fixes:\n\n\n- Fixed: doctests on Python 2 were not correctly checked.  [maurits] (#7)\n\n\n1.0.5 (2018-09-26)\n------------------\n\nFixes:\n\n- fix https://github.com/plone/Products.CMFPlone/issues/2469:\n  \"Subobjects are indexing attributes of parent\".\n  Allow only direct attributes and acquired PythonScripts,\n  but not acquired attributes.\n  Indexers and PythonScripts are able to handle this explicitly,\n  because they get the acquisition-wrapped object.\n  [jensens]\n\n- Fix tests to work in Python 3\n  [pbauer]\n\n\n1.0.4 (2016-02-25)\n------------------\n\nFixes:\n\n- Replace deprecated ``zope.testing.doctestunit`` import with ``doctest``\n  module from stdlib.\n  [thet]\n\n- Reformat according to the Plone styleguide.\n  [thet]\n\n\n1.0.3 (2015-05-05)\n------------------\n\n- Add missing dependency on Products.ZCatalog.\n  [gforcada]\n\n\n1.0.2 (2013-01-13)\n------------------\n\n- Changed the @indexer decorator to maintain the information about the wrapped\n  function (__doc__, __module__, __name__, etc).\n  [dokai]\n\n\n1.0.1 (2012-12-14)\n------------------\n\n- Relicense under modified BSD license; per Plone Foundation board\n  approval on 2012-05-31.\n  See: http://plone.org/foundation/materials/foundation-resolutions/plone-framework-components-relicensing-policy\n  [supton]\n\n- Add MANIFEST.in.\n  [WouterVH]\n\n\n1.0 - 2010-07-18\n----------------\n\n- Fixed reSt markup in the changelog.\n  [hannosch]\n\n- Update license to GPL version 2 only.\n  [hannosch]\n\n\n1.0rc2 - 2009-04-05\n-------------------\n\n- Added _getWrappedObject() method to get hold of the underlying object.\n  Note that this means you can't have an index/metadata column with this name.\n  [optilude]\n\n- Corrected IZCatalog import location to point to the interfaces module.\n  [hannosch]\n\n\n1.0rc1 - 2009-03-26\n-------------------\n\n- Updated the interface to match the developments of similar functionality\n  on CMF trunk. This means that indexers are now multi-adapters on\n  (object, catalog), and the keyword arguments (including the implicit\n  'portal' parameter) are gone.\n  [optilude]\n\n\n1.0a1 - 2009-03-05\n------------------\n\n- Initial release\n\n\nWriting indexers\n================\n\nAn indexer is a named adapter that adapts the type of an object and provides a value to be indexed when the catalog attempts to index the attribute with that name.\n\nFor example, let's say we have two types, page and news item::\n\n    >>> from zope.interface import Interface\n    >>> from zope.interface import implementer\n    >>> from zope import schema\n\n    >>> class IPage(Interface):\n    ...     text = schema.Text(title=u\"Body text\")\n\n    >>> @implementer(IPage)\n    ... class Page(object):\n    ...     def __init__(self, text):\n    ...         self.text = text\n\n    >>> class INewsItem(Interface):\n    ...     summary = schema.TextLine(title=u\"Short summary\")\n    ...     story = schema.Text(title=u\"Body text\")\n    ...     audience = schema.TextLine(title=u\"Audience\")\n\n    >>> @implementer(INewsItem)\n    ... class NewsItem(object):\n    ...     def __init__(self, summary, story, audience):\n    ...         self.summary = summary\n    ...         self.story = story\n    ...         self.audience = audience\n\nNow, pretend that our catalog had an index 'description', which for a page should contain the first 10 characters from the body text, and for a news item should contain the contents of the 'summary' field.\nFurthermore, there is an index 'audience' that should contain the value of the corresponding field for news items, in all uppercase.\nIt should do nothing for pages.\n\nWe could write indexers for all of these like this::\n\n    >>> from plone.indexer import indexer\n\n    >>> @indexer(IPage)\n    ... def page_description(object):\n    ...     return object.text[:10]\n\n    >>> @indexer(INewsItem)\n    ... def newsitem_description(object):\n    ...     return object.summary\n\n    >>> @indexer(INewsItem)\n    ... def newsitem_audience(object):\n    ...     return object.audience.upper()\n\nThese need to be registered as named adapters, where the name corresponds to the index name.\nIn ZCML, that may be::\n\n    <adapter name=\"description\" factory=\".indexers.page_description\" />\n    <adapter name=\"description\" factory=\".indexers.newsitem_description\" />\n    <adapter name=\"audience\" factory=\".indexers.newsitem_audience\" />\n\nWe can omit the 'for' attribute because we passed this to the @indexer decorator, and we can omit the 'provides' attribute because the thing returned by the decorator is actually a class providing the required IIndexer interface.\n\nFor the purposes of the ensuing tests, we'll register these directly::\n\n    >>> from zope.component import provideAdapter\n    >>> provideAdapter(page_description, name='description')\n    >>> provideAdapter(newsitem_description, name='description')\n    >>> provideAdapter(newsitem_audience, name='audience')\n\n\nTesting your indexers (or calling them directly)\n------------------------------------------------\n\nIf you are writing tests for your indexers (as you should!), then you should be aware of the following:\n\nWhen the @indexer decorator returns, it turns your function into an instance of type DelegatingIndexerFactory.\nThis is an adapter factory that can create a DelegatingIndexer, which in turn will call your function when asked to perform indexing operations.\n\nThis means that you can't just call your function to test the indexer.\nInstead, you need to instantiate the adapter and then call the delegating indexer with the portal root as the first argument.\nFor example::\n\n    >>> test_page = Page(text=u\"My page with some text\")\n    >>> page_description(test_page)()\n    'My page wi'\n\nThis will suffice in most cases.\nNote that there is actually a second parameter, catalog, which defaults to None.\nIf you need to write an indexer that acts on catalog, you'll need to register a conventional adapter, as described in the next section.\n\n\nOther means of registering indexers\n-----------------------------------\n\nAt the end of the day, an indexer is just a named multi-adapter from the indexable object (e.g.\nINewsItem or IPage above) and the catalog (usually portal_catalog in a CMF application) to IIndexer, where the name is the name of the indexed attribute in the catalog.\nThus, you could register your indexers as more conventional adapters::\n\n    >>> from plone.indexer.interfaces import IIndexer\n    >>> from Products.ZCatalog.interfaces import IZCatalog\n    >>> from zope.component import adapter\n    >>> from zope.interface import implementer\n\n    >>> @implementer(IIndexer)\n    ... @adapter(IPage, IZCatalog)\n    ... class LengthIndexer(object):\n    ...     \"\"\"Index the length of the body text\n    ...     \"\"\"\n    ...     def __init__(self, context, catalog):\n    ...         self.context = context\n    ...         self.catalog = catalog\n    ...\n    ...     def __call__(self):\n    ...         return len(self.context.text)\n\nWe normally just use IZCatalog for the catalog adaptation, to apply to any catalog.\nHowever, if you want different indexers for different types of catalogs, there is an example later in this test.\n\nYou'd register this with ZCML like so::\n\n    <adapter factory=\".indexers.LengthIndexer\" name=\"length\" />\n\nOr in a test::\n\n    >>> provideAdapter(LengthIndexer, name=\"length\")\n\nIf you're only curious about how to write indexers, you can probably stop here.\nIf you want to know more about how they work and how they are wired into a framework, read on.\n\n\nHooking up indexers to the framework\n=====================================\n\nHere is a mock implementation of a ZCatalog.catalog_object() override, based on the one in Plone.\nWe'll use this for testing.\nWe won't bother with the full ZCatalog interface, only catalog_object(), and we'll stub out a few things.\nThis really is for illustration purposes only, to show the intended usage pattern.\n\nIn CMF 2.2, there is an IIndexableObject marker interface defined in Products.CMFCore.interfaces.\nWe have a compatibility alias in this package for use with CMF 2.1.\n\n::\n\n    >>> from OFS.interfaces import IItem\n    >>> from plone.indexer.interfaces import IIndexableObject\n    >>> from Products.ZCatalog.interfaces import IZCatalog\n    >>> from zope.component import queryMultiAdapter\n\n    >>> @implementer(IZCatalog, IItem)\n    ... class FauxCatalog(object):\n    ...\n    ...     def catalog_object(self, object, uid, idxs=[]):\n    ...         \"\"\"Pretend to index 'object' under the key 'uid'. We'll\n    ...         print the results of the indexing operation to the screen .\n    ...         \"\"\"\n    ...\n    ...         if not IIndexableObject.providedBy(object):\n    ...             wrapper = queryMultiAdapter((object, self,), IIndexableObject)\n    ...             if wrapper is not None:\n    ...                 object = wrapper\n    ...\n    ...         # Perform the actual indexing of attributes in the idxs list\n    ...         for idx in idxs:\n    ...             try:\n    ...                 indexed_value = getattr(object, idx)\n    ...                 if callable(indexed_value):\n    ...                     indexed_value = indexed_value()\n    ...                 print(\"{0} = {1}\".format(idx, indexed_value))\n    ...             except (AttributeError, TypeError,):\n    ...                 pass\n\nThe important things here are:\n\n    - We attempt to obtain an IIndexableObject for the object to be indexed.\n      This is just a way to get hold of an implementation of this interface (we'll register one in a moment) and allow some coarse-grained overrides.\n\n    - Cataloging involves looking up attributes on the indexable object wrapper matching the names of indexes (in the real ZCatalog, this is actually decoupled, but let's not get carried away).\n      If they are callable, they should be called.\n      This is just mimicking what ZCatalog's implementation does.\n\nThis package comes with an implementation of an IIndexableObject adapter that knows how to delegate to an IIndexer.\nLet's now register that as the default IIndexableObject wrapper adapter so that the code above will find it::\n\n    >>> from plone.indexer.interfaces import IIndexableObject\n    >>> from plone.indexer.wrapper import IndexableObjectWrapper\n    >>> provideAdapter(factory=IndexableObjectWrapper, adapts=(Interface, IZCatalog,), provides=IIndexableObject)\n\nSeeing it in action\n===================\n\nNow for the testing. First, we need a faux catalog::\n\n    >>> catalog = FauxCatalog()\n\nFinally, let's create some objects to index::\n\n    >>> page = Page(u\"The page body text here\")\n    >>> news = NewsItem(u\"News summary\", u\"News body text\", u\"Audience\")\n\nFirst of all, let's demonstrate that our indexers work and apply only to the types for which they are registered::\n\n    >>> catalog.catalog_object(page, 'p1', idxs=['description', 'audience', 'length'])\n    description = The page b\n    length = 23\n\n    >>> catalog.catalog_object(news, 'n1', idxs=['description', 'audience', 'length'])\n    description = News summary\n    audience = AUDIENCE\n\nOur custom indexable object wrapper is capable of looking up workflow variables if the portal_workflow tool is available.\nFor testing purposes, we'll create a fake minimal workflow tool and stash it onto the fake catalog so that it can be found by getToolByName.\nIn real life, it would of course be acquirable as normal::\n\n    >>> @implementer(IItem)\n    ... class FauxWorkflowTool(object):\n    ...     def getCatalogVariablesFor(self, object):\n    ...         return dict(review_state='published', audience='Somebody')\n    >>> catalog.portal_workflow = FauxWorkflowTool()\n\nIf we now index 'review_state', it will be obtained from the workflow variables.\nHowever, a custom indexer still overrides workflow variables::\n\n    >>> catalog.catalog_object(news, 'n1', idxs=['description', 'audience', 'review_state'])\n    description = News summary\n    audience = AUDIENCE\n    review_state = published\n\nFinally, if not adapter can be found, we fall back on getattr() on the object::\n\n    >>> catalog.catalog_object(page, 'p3', idxs=['description', 'text'])\n    description = The page b\n    text = The page body text here\n\n\nCustomising indexers based on the catalog type\n==============================================\n\nIt is possible to provide a custom indexer for a different type of catalog.\nTo test that, let's create a secondary catalog and mark it with a marker interface::\n\n    >>> from zope.interface import Interface\n    >>> class IAlternateCatalog(Interface):\n    ...     pass\n    >>> from zope.interface import alsoProvides\n    >>> catalog2 = FauxCatalog()\n    >>> alsoProvides(catalog2, IAlternateCatalog)\n\nLet's say that we did not want the news item audience uppercased here.\nWe could provide a custom indexer for just this catalog::\n\n    >>> @indexer(INewsItem, IAlternateCatalog)\n    ... def alternate_newsitem_audience(object):\n    ...     return object.audience.lower()\n    >>> provideAdapter(alternate_newsitem_audience, name='audience')\n\nThis does not affect the first catalog::\n\n    >>> catalog.catalog_object(news, 'n1', idxs=['description', 'audience', 'length'])\n    description = News summary\n    audience = AUDIENCE\n\nHowever, the second catalog gets the audience in lowercase::\n\n    >>> catalog2.catalog_object(news, 'n1', idxs=['description', 'audience', 'length'])\n    description = News summary\n    audience = audience\n\n\nInterfaces provided by the wrapper\n==================================\n\nThe indexable object wrapper has one particular feature: instances of the wrapper will provide the same interfaces as instances of the wrapped object.\nFor example::\n\n    >>> from plone.indexer.interfaces import IIndexableObject\n    >>> from plone.indexer.interfaces import IIndexableObjectWrapper\n\n    >>> wrapper = IndexableObjectWrapper(page, catalog)\n    >>> IIndexableObjectWrapper.providedBy(wrapper)\n    True\n    >>> IIndexableObject.providedBy(wrapper)\n    True\n    >>> IPage.providedBy(wrapper)\n    True\n    >>> INewsItem.providedBy(wrapper)\n    False\n\n    >>> wrapper = IndexableObjectWrapper(news, catalog)\n    >>> IIndexableObjectWrapper.providedBy(wrapper)\n    True\n    >>> IPage.providedBy(wrapper)\n    False\n    >>> INewsItem.providedBy(wrapper)\n    True\n\n\nUnboxing\n========\n\nIt is possible to obtain the wrapped object from the wrapper::\n\n    >>> wrapper = IndexableObjectWrapper(page, catalog)\n    >>> wrapper._getWrappedObject() is page\n    True\n\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://pypi.org/project/plone.indexer", "keywords": "plone cmf zope catalog index", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "plone.indexer", "package_url": "https://pypi.org/project/plone.indexer/", "platform": "", "project_url": "https://pypi.org/project/plone.indexer/", "project_urls": {"Homepage": "https://pypi.org/project/plone.indexer"}, "release_url": "https://pypi.org/project/plone.indexer/1.0.7/", "requires_dist": ["setuptools", "zope.interface", "zope.component", "Products.CMFCore", "Products.ZCatalog"], "requires_python": "", "summary": "Hooks to facilitate managing custom index values in Zope 2/CMF applications", "version": "1.0.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>This package provides primitives to help delegate ZCatalog indexing operations\nto adapters. It doesn\u2019t do very much on its own, but can be used by catalog\nimplementations that want to allow individual index values to be provided\nnot by the object itself, but by separate adapters.</p>\n</div>\n<div id=\"changelog\">\n<h2>Changelog</h2>\n<div id=\"id1\">\n<h3>1.0.7 (2020-04-20)</h3>\n<p>Bug fixes:</p>\n<ul>\n<li>Minor packaging updates. (#1)</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>1.0.6 (2019-04-29)</h3>\n<p>Bug fixes:</p>\n<ul>\n<li>Fixed: doctests on Python 2 were not correctly checked.  [maurits] (#7)</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>1.0.5 (2018-09-26)</h3>\n<p>Fixes:</p>\n<ul>\n<li>fix <a href=\"https://github.com/plone/Products.CMFPlone/issues/2469\" rel=\"nofollow\">https://github.com/plone/Products.CMFPlone/issues/2469</a>:\n\u201cSubobjects are indexing attributes of parent\u201d.\nAllow only direct attributes and acquired PythonScripts,\nbut not acquired attributes.\nIndexers and PythonScripts are able to handle this explicitly,\nbecause they get the acquisition-wrapped object.\n[jensens]</li>\n<li>Fix tests to work in Python 3\n[pbauer]</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>1.0.4 (2016-02-25)</h3>\n<p>Fixes:</p>\n<ul>\n<li>Replace deprecated <tt>zope.testing.doctestunit</tt> import with <tt>doctest</tt>\nmodule from stdlib.\n[thet]</li>\n<li>Reformat according to the Plone styleguide.\n[thet]</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3>1.0.3 (2015-05-05)</h3>\n<ul>\n<li>Add missing dependency on Products.ZCatalog.\n[gforcada]</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3>1.0.2 (2013-01-13)</h3>\n<ul>\n<li>Changed the @indexer decorator to maintain the information about the wrapped\nfunction (__doc__, __module__, __name__, etc).\n[dokai]</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3>1.0.1 (2012-12-14)</h3>\n<ul>\n<li>Relicense under modified BSD license; per Plone Foundation board\napproval on 2012-05-31.\nSee: <a href=\"http://plone.org/foundation/materials/foundation-resolutions/plone-framework-components-relicensing-policy\" rel=\"nofollow\">http://plone.org/foundation/materials/foundation-resolutions/plone-framework-components-relicensing-policy</a>\n[supton]</li>\n<li>Add MANIFEST.in.\n[WouterVH]</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3>1.0 - 2010-07-18</h3>\n<ul>\n<li>Fixed reSt markup in the changelog.\n[hannosch]</li>\n<li>Update license to GPL version 2 only.\n[hannosch]</li>\n</ul>\n</div>\n<div id=\"rc2-2009-04-05\">\n<h3>1.0rc2 - 2009-04-05</h3>\n<ul>\n<li>Added _getWrappedObject() method to get hold of the underlying object.\nNote that this means you can\u2019t have an index/metadata column with this name.\n[optilude]</li>\n<li>Corrected IZCatalog import location to point to the interfaces module.\n[hannosch]</li>\n</ul>\n</div>\n<div id=\"rc1-2009-03-26\">\n<h3>1.0rc1 - 2009-03-26</h3>\n<ul>\n<li>Updated the interface to match the developments of similar functionality\non CMF trunk. This means that indexers are now multi-adapters on\n(object, catalog), and the keyword arguments (including the implicit\n\u2018portal\u2019 parameter) are gone.\n[optilude]</li>\n</ul>\n</div>\n<div id=\"a1-2009-03-05\">\n<h3>1.0a1 - 2009-03-05</h3>\n<ul>\n<li>Initial release</li>\n</ul>\n</div>\n</div>\n<div id=\"writing-indexers\">\n<h2>Writing indexers</h2>\n<p>An indexer is a named adapter that adapts the type of an object and provides a value to be indexed when the catalog attempts to index the attribute with that name.</p>\n<p>For example, let\u2019s say we have two types, page and news item:</p>\n<pre>&gt;&gt;&gt; from zope.interface import Interface\n&gt;&gt;&gt; from zope.interface import implementer\n&gt;&gt;&gt; from zope import schema\n\n&gt;&gt;&gt; class IPage(Interface):\n...     text = schema.Text(title=u\"Body text\")\n\n&gt;&gt;&gt; @implementer(IPage)\n... class Page(object):\n...     def __init__(self, text):\n...         self.text = text\n\n&gt;&gt;&gt; class INewsItem(Interface):\n...     summary = schema.TextLine(title=u\"Short summary\")\n...     story = schema.Text(title=u\"Body text\")\n...     audience = schema.TextLine(title=u\"Audience\")\n\n&gt;&gt;&gt; @implementer(INewsItem)\n... class NewsItem(object):\n...     def __init__(self, summary, story, audience):\n...         self.summary = summary\n...         self.story = story\n...         self.audience = audience\n</pre>\n<p>Now, pretend that our catalog had an index \u2018description\u2019, which for a page should contain the first 10 characters from the body text, and for a news item should contain the contents of the \u2018summary\u2019 field.\nFurthermore, there is an index \u2018audience\u2019 that should contain the value of the corresponding field for news items, in all uppercase.\nIt should do nothing for pages.</p>\n<p>We could write indexers for all of these like this:</p>\n<pre>&gt;&gt;&gt; from plone.indexer import indexer\n\n&gt;&gt;&gt; @indexer(IPage)\n... def page_description(object):\n...     return object.text[:10]\n\n&gt;&gt;&gt; @indexer(INewsItem)\n... def newsitem_description(object):\n...     return object.summary\n\n&gt;&gt;&gt; @indexer(INewsItem)\n... def newsitem_audience(object):\n...     return object.audience.upper()\n</pre>\n<p>These need to be registered as named adapters, where the name corresponds to the index name.\nIn ZCML, that may be:</p>\n<pre>&lt;adapter name=\"description\" factory=\".indexers.page_description\" /&gt;\n&lt;adapter name=\"description\" factory=\".indexers.newsitem_description\" /&gt;\n&lt;adapter name=\"audience\" factory=\".indexers.newsitem_audience\" /&gt;\n</pre>\n<p>We can omit the \u2018for\u2019 attribute because we passed this to the @indexer decorator, and we can omit the \u2018provides\u2019 attribute because the thing returned by the decorator is actually a class providing the required IIndexer interface.</p>\n<p>For the purposes of the ensuing tests, we\u2019ll register these directly:</p>\n<pre>&gt;&gt;&gt; from zope.component import provideAdapter\n&gt;&gt;&gt; provideAdapter(page_description, name='description')\n&gt;&gt;&gt; provideAdapter(newsitem_description, name='description')\n&gt;&gt;&gt; provideAdapter(newsitem_audience, name='audience')\n</pre>\n<div id=\"testing-your-indexers-or-calling-them-directly\">\n<h3>Testing your indexers (or calling them directly)</h3>\n<p>If you are writing tests for your indexers (as you should!), then you should be aware of the following:</p>\n<p>When the @indexer decorator returns, it turns your function into an instance of type DelegatingIndexerFactory.\nThis is an adapter factory that can create a DelegatingIndexer, which in turn will call your function when asked to perform indexing operations.</p>\n<p>This means that you can\u2019t just call your function to test the indexer.\nInstead, you need to instantiate the adapter and then call the delegating indexer with the portal root as the first argument.\nFor example:</p>\n<pre>&gt;&gt;&gt; test_page = Page(text=u\"My page with some text\")\n&gt;&gt;&gt; page_description(test_page)()\n'My page wi'\n</pre>\n<p>This will suffice in most cases.\nNote that there is actually a second parameter, catalog, which defaults to None.\nIf you need to write an indexer that acts on catalog, you\u2019ll need to register a conventional adapter, as described in the next section.</p>\n</div>\n<div id=\"other-means-of-registering-indexers\">\n<h3>Other means of registering indexers</h3>\n<p>At the end of the day, an indexer is just a named multi-adapter from the indexable object (e.g.\nINewsItem or IPage above) and the catalog (usually portal_catalog in a CMF application) to IIndexer, where the name is the name of the indexed attribute in the catalog.\nThus, you could register your indexers as more conventional adapters:</p>\n<pre>&gt;&gt;&gt; from plone.indexer.interfaces import IIndexer\n&gt;&gt;&gt; from Products.ZCatalog.interfaces import IZCatalog\n&gt;&gt;&gt; from zope.component import adapter\n&gt;&gt;&gt; from zope.interface import implementer\n\n&gt;&gt;&gt; @implementer(IIndexer)\n... @adapter(IPage, IZCatalog)\n... class LengthIndexer(object):\n...     \"\"\"Index the length of the body text\n...     \"\"\"\n...     def __init__(self, context, catalog):\n...         self.context = context\n...         self.catalog = catalog\n...\n...     def __call__(self):\n...         return len(self.context.text)\n</pre>\n<p>We normally just use IZCatalog for the catalog adaptation, to apply to any catalog.\nHowever, if you want different indexers for different types of catalogs, there is an example later in this test.</p>\n<p>You\u2019d register this with ZCML like so:</p>\n<pre>&lt;adapter factory=\".indexers.LengthIndexer\" name=\"length\" /&gt;\n</pre>\n<p>Or in a test:</p>\n<pre>&gt;&gt;&gt; provideAdapter(LengthIndexer, name=\"length\")\n</pre>\n<p>If you\u2019re only curious about how to write indexers, you can probably stop here.\nIf you want to know more about how they work and how they are wired into a framework, read on.</p>\n</div>\n</div>\n<div id=\"hooking-up-indexers-to-the-framework\">\n<h2>Hooking up indexers to the framework</h2>\n<p>Here is a mock implementation of a ZCatalog.catalog_object() override, based on the one in Plone.\nWe\u2019ll use this for testing.\nWe won\u2019t bother with the full ZCatalog interface, only catalog_object(), and we\u2019ll stub out a few things.\nThis really is for illustration purposes only, to show the intended usage pattern.</p>\n<p>In CMF 2.2, there is an IIndexableObject marker interface defined in Products.CMFCore.interfaces.\nWe have a compatibility alias in this package for use with CMF 2.1.</p>\n<pre>&gt;&gt;&gt; from OFS.interfaces import IItem\n&gt;&gt;&gt; from plone.indexer.interfaces import IIndexableObject\n&gt;&gt;&gt; from Products.ZCatalog.interfaces import IZCatalog\n&gt;&gt;&gt; from zope.component import queryMultiAdapter\n\n&gt;&gt;&gt; @implementer(IZCatalog, IItem)\n... class FauxCatalog(object):\n...\n...     def catalog_object(self, object, uid, idxs=[]):\n...         \"\"\"Pretend to index 'object' under the key 'uid'. We'll\n...         print the results of the indexing operation to the screen .\n...         \"\"\"\n...\n...         if not IIndexableObject.providedBy(object):\n...             wrapper = queryMultiAdapter((object, self,), IIndexableObject)\n...             if wrapper is not None:\n...                 object = wrapper\n...\n...         # Perform the actual indexing of attributes in the idxs list\n...         for idx in idxs:\n...             try:\n...                 indexed_value = getattr(object, idx)\n...                 if callable(indexed_value):\n...                     indexed_value = indexed_value()\n...                 print(\"{0} = {1}\".format(idx, indexed_value))\n...             except (AttributeError, TypeError,):\n...                 pass\n</pre>\n<p>The important things here are:</p>\n<blockquote>\n<ul>\n<li>We attempt to obtain an IIndexableObject for the object to be indexed.\nThis is just a way to get hold of an implementation of this interface (we\u2019ll register one in a moment) and allow some coarse-grained overrides.</li>\n<li>Cataloging involves looking up attributes on the indexable object wrapper matching the names of indexes (in the real ZCatalog, this is actually decoupled, but let\u2019s not get carried away).\nIf they are callable, they should be called.\nThis is just mimicking what ZCatalog\u2019s implementation does.</li>\n</ul>\n</blockquote>\n<p>This package comes with an implementation of an IIndexableObject adapter that knows how to delegate to an IIndexer.\nLet\u2019s now register that as the default IIndexableObject wrapper adapter so that the code above will find it:</p>\n<pre>&gt;&gt;&gt; from plone.indexer.interfaces import IIndexableObject\n&gt;&gt;&gt; from plone.indexer.wrapper import IndexableObjectWrapper\n&gt;&gt;&gt; provideAdapter(factory=IndexableObjectWrapper, adapts=(Interface, IZCatalog,), provides=IIndexableObject)\n</pre>\n</div>\n<div id=\"seeing-it-in-action\">\n<h2>Seeing it in action</h2>\n<p>Now for the testing. First, we need a faux catalog:</p>\n<pre>&gt;&gt;&gt; catalog = FauxCatalog()\n</pre>\n<p>Finally, let\u2019s create some objects to index:</p>\n<pre>&gt;&gt;&gt; page = Page(u\"The page body text here\")\n&gt;&gt;&gt; news = NewsItem(u\"News summary\", u\"News body text\", u\"Audience\")\n</pre>\n<p>First of all, let\u2019s demonstrate that our indexers work and apply only to the types for which they are registered:</p>\n<pre>&gt;&gt;&gt; catalog.catalog_object(page, 'p1', idxs=['description', 'audience', 'length'])\ndescription = The page b\nlength = 23\n\n&gt;&gt;&gt; catalog.catalog_object(news, 'n1', idxs=['description', 'audience', 'length'])\ndescription = News summary\naudience = AUDIENCE\n</pre>\n<p>Our custom indexable object wrapper is capable of looking up workflow variables if the portal_workflow tool is available.\nFor testing purposes, we\u2019ll create a fake minimal workflow tool and stash it onto the fake catalog so that it can be found by getToolByName.\nIn real life, it would of course be acquirable as normal:</p>\n<pre>&gt;&gt;&gt; @implementer(IItem)\n... class FauxWorkflowTool(object):\n...     def getCatalogVariablesFor(self, object):\n...         return dict(review_state='published', audience='Somebody')\n&gt;&gt;&gt; catalog.portal_workflow = FauxWorkflowTool()\n</pre>\n<p>If we now index \u2018review_state\u2019, it will be obtained from the workflow variables.\nHowever, a custom indexer still overrides workflow variables:</p>\n<pre>&gt;&gt;&gt; catalog.catalog_object(news, 'n1', idxs=['description', 'audience', 'review_state'])\ndescription = News summary\naudience = AUDIENCE\nreview_state = published\n</pre>\n<p>Finally, if not adapter can be found, we fall back on getattr() on the object:</p>\n<pre>&gt;&gt;&gt; catalog.catalog_object(page, 'p3', idxs=['description', 'text'])\ndescription = The page b\ntext = The page body text here\n</pre>\n</div>\n<div id=\"customising-indexers-based-on-the-catalog-type\">\n<h2>Customising indexers based on the catalog type</h2>\n<p>It is possible to provide a custom indexer for a different type of catalog.\nTo test that, let\u2019s create a secondary catalog and mark it with a marker interface:</p>\n<pre>&gt;&gt;&gt; from zope.interface import Interface\n&gt;&gt;&gt; class IAlternateCatalog(Interface):\n...     pass\n&gt;&gt;&gt; from zope.interface import alsoProvides\n&gt;&gt;&gt; catalog2 = FauxCatalog()\n&gt;&gt;&gt; alsoProvides(catalog2, IAlternateCatalog)\n</pre>\n<p>Let\u2019s say that we did not want the news item audience uppercased here.\nWe could provide a custom indexer for just this catalog:</p>\n<pre>&gt;&gt;&gt; @indexer(INewsItem, IAlternateCatalog)\n... def alternate_newsitem_audience(object):\n...     return object.audience.lower()\n&gt;&gt;&gt; provideAdapter(alternate_newsitem_audience, name='audience')\n</pre>\n<p>This does not affect the first catalog:</p>\n<pre>&gt;&gt;&gt; catalog.catalog_object(news, 'n1', idxs=['description', 'audience', 'length'])\ndescription = News summary\naudience = AUDIENCE\n</pre>\n<p>However, the second catalog gets the audience in lowercase:</p>\n<pre>&gt;&gt;&gt; catalog2.catalog_object(news, 'n1', idxs=['description', 'audience', 'length'])\ndescription = News summary\naudience = audience\n</pre>\n</div>\n<div id=\"interfaces-provided-by-the-wrapper\">\n<h2>Interfaces provided by the wrapper</h2>\n<p>The indexable object wrapper has one particular feature: instances of the wrapper will provide the same interfaces as instances of the wrapped object.\nFor example:</p>\n<pre>&gt;&gt;&gt; from plone.indexer.interfaces import IIndexableObject\n&gt;&gt;&gt; from plone.indexer.interfaces import IIndexableObjectWrapper\n\n&gt;&gt;&gt; wrapper = IndexableObjectWrapper(page, catalog)\n&gt;&gt;&gt; IIndexableObjectWrapper.providedBy(wrapper)\nTrue\n&gt;&gt;&gt; IIndexableObject.providedBy(wrapper)\nTrue\n&gt;&gt;&gt; IPage.providedBy(wrapper)\nTrue\n&gt;&gt;&gt; INewsItem.providedBy(wrapper)\nFalse\n\n&gt;&gt;&gt; wrapper = IndexableObjectWrapper(news, catalog)\n&gt;&gt;&gt; IIndexableObjectWrapper.providedBy(wrapper)\nTrue\n&gt;&gt;&gt; IPage.providedBy(wrapper)\nFalse\n&gt;&gt;&gt; INewsItem.providedBy(wrapper)\nTrue\n</pre>\n</div>\n<div id=\"unboxing\">\n<h2>Unboxing</h2>\n<p>It is possible to obtain the wrapped object from the wrapper:</p>\n<pre>&gt;&gt;&gt; wrapper = IndexableObjectWrapper(page, catalog)\n&gt;&gt;&gt; wrapper._getWrappedObject() is page\nTrue\n</pre>\n</div>\n\n          </div>"}, "last_serial": 7063220, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "e8bd39276902647a35721c5845ec891e", "sha256": "b65d9a31b742f5ec31a031031982feb7245050f9a8962efb01bf44dfaf7d6441"}, "downloads": -1, "filename": "plone.indexer-1.0.zip", "has_sig": false, "md5_digest": "e8bd39276902647a35721c5845ec891e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19940, "upload_time": "2010-07-18T17:47:31", "upload_time_iso_8601": "2010-07-18T17:47:31.686627Z", "url": "https://files.pythonhosted.org/packages/64/01/0756eee19cb96cce87de1862ab021102e45a274829da7150fdc23c89acfa/plone.indexer-1.0.zip", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "f39b9b92845ae4f62de71dbbf6d05121", "sha256": "391a604e8dd6caa3a67dc41d9f68a7c6eb1b3ffdb1073ba8379738b181490e98"}, "downloads": -1, "filename": "plone.indexer-1.0.1.zip", "has_sig": false, "md5_digest": "f39b9b92845ae4f62de71dbbf6d05121", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22506, "upload_time": "2012-12-15T15:06:20", "upload_time_iso_8601": "2012-12-15T15:06:20.826261Z", "url": "https://files.pythonhosted.org/packages/4c/55/dd36b327d77d67b5416b8f3dc082af87ebd4248bf5a54a9dcd01ce48c301/plone.indexer-1.0.1.zip", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "538aeee1f9db78bc8c85ae1bcb0153ed", "sha256": "3be78722d274d6cc46bad0c4939584de365392bcdb1be0e184eeb3dd5c5516e7"}, "downloads": -1, "filename": "plone.indexer-1.0.2.zip", "has_sig": false, "md5_digest": "538aeee1f9db78bc8c85ae1bcb0153ed", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22909, "upload_time": "2013-01-13T18:19:37", "upload_time_iso_8601": "2013-01-13T18:19:37.655166Z", "url": "https://files.pythonhosted.org/packages/77/a9/6c0c0b095d23fd695f05e110833e981715c1b21a46be26b0ca234bb850a2/plone.indexer-1.0.2.zip", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "c0030cfcb51911926640105b1bf199d8", "sha256": "2d18c8e67546e24a909d88bdb57bf092f2abce10134861ac22a7c3f9d8641fba"}, "downloads": -1, "filename": "plone.indexer-1.0.3.tar.gz", "has_sig": false, "md5_digest": "c0030cfcb51911926640105b1bf199d8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12398, "upload_time": "2015-05-04T23:53:33", "upload_time_iso_8601": "2015-05-04T23:53:33.229048Z", "url": "https://files.pythonhosted.org/packages/6a/ee/19eb4d601e03106995307ea0c524cd20eaf6b0dfe078bd76b7dfa4bbf4a4/plone.indexer-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "6eb1b856a6be3c82b7659e3d3877ae69", "sha256": "56fd1479c4ea4221cb13d0188be1c57817c444690ed9e5931c3f9e0d772c4aea"}, "downloads": -1, "filename": "plone.indexer-1.0.4.tar.gz", "has_sig": false, "md5_digest": "6eb1b856a6be3c82b7659e3d3877ae69", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12462, "upload_time": "2016-02-25T22:09:15", "upload_time_iso_8601": "2016-02-25T22:09:15.426948Z", "url": "https://files.pythonhosted.org/packages/c0/7e/5d297081eb6373a142749d5dc506a82cc3ce5d9dc603f737048b2608ac2d/plone.indexer-1.0.4.tar.gz", "yanked": false}], "1.0.5": [{"comment_text": "", "digests": {"md5": "c16832b0a533d0014b194b4410513395", "sha256": "8fce459ff200d8ac8603402e8ee6de5cd7a2cc4537339befed200452b34f98ea"}, "downloads": -1, "filename": "plone.indexer-1.0.5-py2-none-any.whl", "has_sig": false, "md5_digest": "c16832b0a533d0014b194b4410513395", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 15052, "upload_time": "2018-09-26T16:27:58", "upload_time_iso_8601": "2018-09-26T16:27:58.343608Z", "url": "https://files.pythonhosted.org/packages/d5/4f/867599cafcfb838592936939f83ec11ace88feabc81dde02de74b554340f/plone.indexer-1.0.5-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f0a2952d6df7e73bff82684b0e1923fe", "sha256": "2a6ca8633c6efd727a406574aeb581ee070a00e96bdfa9a3003bdc4bb0d9fbed"}, "downloads": -1, "filename": "plone.indexer-1.0.5.tar.gz", "has_sig": false, "md5_digest": "f0a2952d6df7e73bff82684b0e1923fe", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14180, "upload_time": "2018-09-26T16:27:59", "upload_time_iso_8601": "2018-09-26T16:27:59.577088Z", "url": "https://files.pythonhosted.org/packages/9e/e1/d17f222352e299380ff5cc53d2a14af13ac050b9b4639332870edd86e080/plone.indexer-1.0.5.tar.gz", "yanked": false}], "1.0.6": [{"comment_text": "", "digests": {"md5": "0235e6703817089a34e44660612e9a7b", "sha256": "c0f1528fb739f7ae9a80f745558bd553586f96ad3fa919860e42fd1d2ec9df3a"}, "downloads": -1, "filename": "plone.indexer-1.0.6-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "0235e6703817089a34e44660612e9a7b", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15269, "upload_time": "2019-04-30T00:05:23", "upload_time_iso_8601": "2019-04-30T00:05:23.574872Z", "url": "https://files.pythonhosted.org/packages/50/d8/ccb5874b5d721e522d25061f26b770766bb62117e6299f38ef2deee7280e/plone.indexer-1.0.6-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "556b9fea466d731bc7cf8462d62a4f6e", "sha256": "99ea0a8e298a951af8a89e7551980d2ba9c8ba3c920f71fef3dd4d648aa1fcfc"}, "downloads": -1, "filename": "plone.indexer-1.0.6.tar.gz", "has_sig": false, "md5_digest": "556b9fea466d731bc7cf8462d62a4f6e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15569, "upload_time": "2019-04-30T00:05:26", "upload_time_iso_8601": "2019-04-30T00:05:26.867171Z", "url": "https://files.pythonhosted.org/packages/92/3c/43656b83e6efd991c19632814c9da5a9569bc0061433ce7cfb3ebfb59602/plone.indexer-1.0.6.tar.gz", "yanked": false}], "1.0.7": [{"comment_text": "", "digests": {"md5": "96916cebd6df047d95254177607077de", "sha256": "8d966dbcc288199c9f50c3d57e47dd8a8e622b01bd1cbe8a6d2116d0028270f2"}, "downloads": -1, "filename": "plone.indexer-1.0.7-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "96916cebd6df047d95254177607077de", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15323, "upload_time": "2020-04-20T20:31:45", "upload_time_iso_8601": "2020-04-20T20:31:45.404717Z", "url": "https://files.pythonhosted.org/packages/7d/9c/438da42bcadbb2696fa7844fbca556d55bf38529728beefafa215f7ad8e7/plone.indexer-1.0.7-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "98060d5b8d9f851fc1f2413012bbdf67", "sha256": "d8025bd6a7c09b966bae16131969048cc64f15c3c08231a9015d1d17b21dbf55"}, "downloads": -1, "filename": "plone.indexer-1.0.7.tar.gz", "has_sig": false, "md5_digest": "98060d5b8d9f851fc1f2413012bbdf67", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15006, "upload_time": "2020-04-20T20:31:47", "upload_time_iso_8601": "2020-04-20T20:31:47.109042Z", "url": "https://files.pythonhosted.org/packages/c9/45/0518e9c93a79fe9338f912645273e5dd583d414c35a216525dfbd9ac7980/plone.indexer-1.0.7.tar.gz", "yanked": false}], "1.0a1": [{"comment_text": "", "digests": {"md5": "bbed3c829a0faab337ef00bd41b3ed86", "sha256": "9f9f008745a7fa34c2e586251f006cc98fc6d61af2fe6c582a549b0e5669bcce"}, "downloads": -1, "filename": "plone.indexer-1.0a1.tar.gz", "has_sig": false, "md5_digest": "bbed3c829a0faab337ef00bd41b3ed86", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9320, "upload_time": "2009-03-05T06:16:17", "upload_time_iso_8601": "2009-03-05T06:16:17.030006Z", "url": "https://files.pythonhosted.org/packages/e1/b4/2eee52c3b2ba9de685d51104f303d0dfd7389032d74e4303f6f3007ab0bb/plone.indexer-1.0a1.tar.gz", "yanked": false}], "1.0rc1": [{"comment_text": "", "digests": {"md5": "4c5b12ce567d7e532720ccdb03033940", "sha256": "dea7a25a0115be1b2c9446142a771591dabdc0da37c962843cd39160cb3de2af"}, "downloads": -1, "filename": "plone.indexer-1.0rc1.tar.gz", "has_sig": false, "md5_digest": "4c5b12ce567d7e532720ccdb03033940", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10381, "upload_time": "2009-03-27T12:47:11", "upload_time_iso_8601": "2009-03-27T12:47:11.077956Z", "url": "https://files.pythonhosted.org/packages/4d/d3/347a7594a4e818d8c44db4c466e536d0e14a6a2745a9aeb8b67455b276f9/plone.indexer-1.0rc1.tar.gz", "yanked": false}], "1.0rc2": [{"comment_text": "", "digests": {"md5": "d802912043cb1212fd405c34f3ada838", "sha256": "2857917a060d3623878c418e672b12d02e5a1039712825679ac45fa3a242a08b"}, "downloads": -1, "filename": "plone.indexer-1.0rc2.tar.gz", "has_sig": false, "md5_digest": "d802912043cb1212fd405c34f3ada838", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10768, "upload_time": "2009-04-05T12:16:19", "upload_time_iso_8601": "2009-04-05T12:16:19.254044Z", "url": "https://files.pythonhosted.org/packages/cf/eb/171f090fe0958283edb96a4dc0adbf53616acafadee875d8dbf9b38a310f/plone.indexer-1.0rc2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "96916cebd6df047d95254177607077de", "sha256": "8d966dbcc288199c9f50c3d57e47dd8a8e622b01bd1cbe8a6d2116d0028270f2"}, "downloads": -1, "filename": "plone.indexer-1.0.7-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "96916cebd6df047d95254177607077de", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15323, "upload_time": "2020-04-20T20:31:45", "upload_time_iso_8601": "2020-04-20T20:31:45.404717Z", "url": "https://files.pythonhosted.org/packages/7d/9c/438da42bcadbb2696fa7844fbca556d55bf38529728beefafa215f7ad8e7/plone.indexer-1.0.7-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "98060d5b8d9f851fc1f2413012bbdf67", "sha256": "d8025bd6a7c09b966bae16131969048cc64f15c3c08231a9015d1d17b21dbf55"}, "downloads": -1, "filename": "plone.indexer-1.0.7.tar.gz", "has_sig": false, "md5_digest": "98060d5b8d9f851fc1f2413012bbdf67", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15006, "upload_time": "2020-04-20T20:31:47", "upload_time_iso_8601": "2020-04-20T20:31:47.109042Z", "url": "https://files.pythonhosted.org/packages/c9/45/0518e9c93a79fe9338f912645273e5dd583d414c35a216525dfbd9ac7980/plone.indexer-1.0.7.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:52:58 2020"}