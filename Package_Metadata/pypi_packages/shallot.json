{"info": {"author": "Peter Peter", "author_email": "dev.peterpeter5@gmail.com", "bugtrack_url": null, "classifiers": ["Programming Language :: Python :: 3"], "description": "# shallot - a plugable \"webframework\"\n[![Documentation Status](https://readthedocs.org/projects/shallot/badge/?version=latest)](https://shallot.readthedocs.io/en/latest/?badge=latest)\n![](https://github.com/peterpeter5/shallot/workflows/Python%20package/badge.svg)\n[![PyPI version](https://badge.fury.io/py/shallot.svg)](https://pypi.org/project/shallot/)\n\n## What is a shallot?\n\nIt is a small onion. It has only small and few layers. When you use it (cut it for cooking), it does not make \nyou cry (that much).\n\nThe above description of the vegetable, is a good mission-statement for what `shallot` (the [micro-] \"webframework\") tries to be. \n\n`shallot` is a small layer on top of an ASGI - compatible server, like: uvicorn, hypercorn, ... It is haveliy inspired \nby [ring](https://github.com/ring-clojure/ring). The main difference to other webframeworks is, that `shallot` is easily plug able and extensible. Every component can be switched and new features can be added without touching `shallot`s source-code. That is accomplished by using middlewares for nearly every functionality in `shallot`.\n\n`shallot` tries hard, to provide a *simple* API. For that, only standard-types and functions (and one decorator) are used. The goal is, that a user can\nfreely choose her / his tools for testing, documentation and so on. Another benefit, extending `shallot`s functionality requires you to understand the\nmiddleware-concept and that is all. No class-hierarchies or plugin-frameworks are needed.    \n\n## Architecture\n\n`shallot` is an [ASGI](https://asgi.readthedocs.io/en/latest/index.html) - compatible webframework. \n\n### Basic-Concepts\n\n`shallot` models a http-request-response-cycle as single function call. It treats `request` and `response` as `dict`s. The request get passed to a `handler` (which itself can be \"middleware-decorated\") and the `handler` produces a response.\nBasically `shallot` works like this:\n1. take the ASGI [connection-scope](https://asgi.readthedocs.io/en/latest/specs/www.html#connection-scope) (`dict`)\n2. read the body of the request and attach the body (`bytes`) to scope-dict \n3. pass the request-`dict` (scope + attached body) to a user-defined function (called `handler`)\n4. the result (`response`) of a handler has to be a `dict`. The response must at least provide a `status`-key with an integer. If provided a `body`-key for the response is provided, than the value must be of type `bytes` and to will be transferred to the client. \n\n### data-flow\n\n```\n+----------+           +----------+             +------------+\n|          |           |          |             |            |\n|          +-----------> request  +-------------> middlewares+-----------+\n|          |           |          |             | (enter)    |           |\n|          |           +----------+             +------------+           |\n|    A     |                                                             |\n|    S     |                                                             |\n|    G     |                                                             |\n|    I     |                                                             |\n|          |                                                   +---------v--------+\n|    |     |                                                   |                  |\n|          |                                                   |    handler       |\n|    S     |                                                   |                  |\n|    E     |                                                   +---------+--------+\n|    R     |                                                             |\n|    V     |                                                             |\n|    E     |                                                             |\n|    R     |           +----------+             +------------+           |\n|          |           |          |             |            |           |\n|          <-----------+ response <-------------+ middlewares<-----------+\n|          |           |          |             | (leave)    |\n+----------+           +----------+             +------------+\n```\n\n### request\n\nThe `request` is always the first argument that gets passed to your `handler`-function. It is of type `dict`. It has basically the same content as the [ASGI-connection-scope](https://asgi.readthedocs.io/en/latest/specs/www.html#connection-scope). \n\nA request will at least have the following structure:\n\n- `type`: http [string]\n- `method`: the http-verb in uppercase (for example: \"GET\", \"PUT\", \"POST\", ...) [`string`]\n- `headers`: a `dict` with all header-names as `keys` and the corresponding-values as `values` of the dict.\n- `body`: The body of the http-request as `bytes`. `shallot` always read the entire body and then calls the `handler`-function. [`bytes`] \n\n- **note**: many fields are missing! please refer to the documentation  \n\n### response\n\nThe `response` is the result of the function-call to the handler (with the `request` as first argument). The `response` has to be a `dict`. The reponse must have the following structure:\n\n- `status`: the http-return-code [`int`]\n- `body` [optional]: the body of the http-response [`bytes`]\n- `headers` [optional]: the http-response-headers to be used. The value is a `dict` (for example: `{\"header1-name\": \"header1-value\", ...}`)\n- `stream` [optional]: this must be an `async-iterable` yielding `bytes`. When the `response` contains a key named `stream`, than `shallot` will consume the `iterable` and will stream the provided data to the client. This is specially useful for large response-bodies.\n\n### handler\n\n`shallot` assembles a request-dict and calls a user-provided handler. A `handler` is an async-function that takes a request and returns a response (`dict`).  \n\n```python\nasync def handler(request):\n    return {\"status\": 200}\n```\n\n### middleware\n\nMost of `shallot`s  functionality is implemented via middlewares. That makes it possible to easily extend, configure or change `shallot`s behaviour. In fact: if you don't like the implementation of a certain middleware, just write your own and use it instead (or better: enhance `shallot` via PR)!\n\nThe general functionality of a middleware is, that it wraps a handler-function-call. Middlewares are designed that way, that they can be composed / chained together. So for a middleware-chain with 3 different middlewares, a call chain might look like:\n\n```\n|-> middleware 1 (enter)\n    |-> middleware 2 (enter)\n        |-> middleware 3 (enter)\n            |-> handler (execute)\n        |<- middleware 3 (leave)\n    |<- middleware 2 (leave)\n|<- middleware 1 (leave)\n```\n\nA good analogy for a middleware is a python-decorator. A decorator wraps a function and returns another function to provide extended functionality.\n\n\n### application\n\nthe minimal deployable thing, one can build is this:\n\n```python\nasync def minimal(request):\n    \"\"\"\n    answer EVERY request with 200 and NO body \n    \"\"\"\n    return {\"status\": 200}\n\nserver = build_server(minimal)\n\nif __name__ == \"__main__\":\n    import uvicorn  # shallot is not tied to uvicorn, its just fast\n    uvicorn.run(server)\n```\n\n\nto configure/run a real application, one would typically chain/apply a pile of middlewares and a handler:\n\n```python\n\nmiddleware_pile = apply_middleware(\n    wrap_content_type(),\n    wrap_static(\"/static/data\"),\n    wrap_routes(routes),\n    wrap_parameters(),\n    wrap_cookies,\n    wrap_json,\n)\n\nserver = build_server(middleware_pile(standard_not_found))\n```\n## Features\n\nNothing is enabled by default. Every functionality has its own middleware.  \n\n### Routing\nTo include `shallot`s builtin routing functionality, use the routing-middleware: `wrap_routes`.\n\nrouting is one essential and by far, the most opinionated part of any webframeworks-api. `shallot` is no exception there. Routing is defined completely via a data-structure:\n\n```python\nasync def hello_world(request):\n    return text(\"hi user!\")\n\n# is attached to a \"dynamic\"-route with one parseable url-part\nasync def handle_index(request, idx):\n    return text(f\"hi user number: {idx}\")\n\n\nroutes = [\n    (\"/\", [\"GET\"], hello_world),\n    (\"/hello\", [\"GET\"], hello_world),\n    (\"/hello/{index}\", [\"GET\"], handle_index),\n    (\"/echo\", [\"GET\", \"PUT\", \"POST\"], post_echo),\n    (\"/json\", [\"GET\", \"PUT\"], show_and_accept_json),\n]\n\n```\nas shown above, `routes` is a list of tuples with:\n\n    1. the (potentially dynamic) route\n    2. the allowed methods\n    3. the handler\n\nRoutes with an `{tag}` in it, are considered dynamic-routes. The router will parse the value from the url and transfered it (as string) to the handler-function. Therfore the handler function must accept the `request` and as many arguments as there are `{tag}`s.\n\n### JSON\nto easily work with json-data, use the json-middleware `wrap_json`:\n\nevery request, that contains a content-type `application/json` will be parsed and the result will be attached to the request under the key `json`. \nWhen data body is not parseable as json, the middleware will respond with `{\"status\": 400, \"body\": \"Malformed JSON\"}`.\n\nwhen you want to return json-data as your response, use the `shallot.response` - function `json`:\n\n```python\nfrom shallot.response import json\n\nasync def json_handler(request):\n    client_json_data = request.get(\"json\")\n    assert isinstance(client_json_data, dict)\n\n    return json({\"hello\": \"world\"})\n```\n\n### Static-Files\n\n`shallot` is not optimized to work as static-file-server. Although it goes to great lengths, to provide a solid experience for serving static content.\n\nTo work with static-files use the `wrap_static` - middleware.\n\nThis middleware depends on `aiofiles`.\n\n```python\nimport os\nhere = os.path.dirname(__file__)\nwrap_static(\"/static/data\", root_path=here)  # will always assume the folder is located : <this_file>.py/static/data\n```\nBrowser-caches will be honored. For that, `last-modified` and `etag` - headers will be sent accordingly. \nRequests with a path containing \"../\" will be automatically responded with `404-Not Found`.\n\n### Websockets\n\nIn shallot, websockets are modeled as async-generators. Except that, websockets-handlers are more or less equal to http-handlers.\nThey receive data, `str` or `bytes` from the generator (`receiver`) and a `dict` from the opening http-request (`request`). As a\nresult a websocket-handler yields back data (`dict`), in the example below, constructed via `ws_send`\n\n\n```python\n@websocket\nasync def echo_server(request, receiver):\n    async for message in receiver:\n        yield ws_send(f\"@echo: {message}\")\n\n```\n\n\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/peterpeter5/shallot", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "shallot", "package_url": "https://pypi.org/project/shallot/", "platform": "", "project_url": "https://pypi.org/project/shallot/", "project_urls": {"Homepage": "https://github.com/peterpeter5/shallot"}, "release_url": "https://pypi.org/project/shallot/0.2.0/", "requires_dist": ["aiofiles", "recommonmark ; extra == 'docs'", "sphinx ; extra == 'docs'", "uvicorn ; extra == 'full'", "hypothesis ; extra == 'test'", "pytest ; extra == 'test'", "pytest-asyncio ; extra == 'test'", "pytest-cov ; extra == 'test'", "requests ; extra == 'test'", "uvicorn ; extra == 'test'"], "requires_python": ">=3.6", "summary": "Fast, small ASGI-compliant webframework", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>shallot - a plugable \"webframework\"</h1>\n<p><a href=\"https://shallot.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/dd0c97d5bca4831fecd74b94b196a4fe006e46bf/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f7368616c6c6f742f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0bcaa59b8e7224758400c997e8107d25222add36/68747470733a2f2f6769746875622e636f6d2f70657465727065746572352f7368616c6c6f742f776f726b666c6f77732f507974686f6e2532307061636b6167652f62616467652e737667\">\n<a href=\"https://pypi.org/project/shallot/\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/78062bcabc7625ccc8e2abb699ddb1a17ec96834/68747470733a2f2f62616467652e667572792e696f2f70792f7368616c6c6f742e737667\"></a></p>\n<h2>What is a shallot?</h2>\n<p>It is a small onion. It has only small and few layers. When you use it (cut it for cooking), it does not make\nyou cry (that much).</p>\n<p>The above description of the vegetable, is a good mission-statement for what <code>shallot</code> (the [micro-] \"webframework\") tries to be.</p>\n<p><code>shallot</code> is a small layer on top of an ASGI - compatible server, like: uvicorn, hypercorn, ... It is haveliy inspired\nby <a href=\"https://github.com/ring-clojure/ring\" rel=\"nofollow\">ring</a>. The main difference to other webframeworks is, that <code>shallot</code> is easily plug able and extensible. Every component can be switched and new features can be added without touching <code>shallot</code>s source-code. That is accomplished by using middlewares for nearly every functionality in <code>shallot</code>.</p>\n<p><code>shallot</code> tries hard, to provide a <em>simple</em> API. For that, only standard-types and functions (and one decorator) are used. The goal is, that a user can\nfreely choose her / his tools for testing, documentation and so on. Another benefit, extending <code>shallot</code>s functionality requires you to understand the\nmiddleware-concept and that is all. No class-hierarchies or plugin-frameworks are needed.</p>\n<h2>Architecture</h2>\n<p><code>shallot</code> is an <a href=\"https://asgi.readthedocs.io/en/latest/index.html\" rel=\"nofollow\">ASGI</a> - compatible webframework.</p>\n<h3>Basic-Concepts</h3>\n<p><code>shallot</code> models a http-request-response-cycle as single function call. It treats <code>request</code> and <code>response</code> as <code>dict</code>s. The request get passed to a <code>handler</code> (which itself can be \"middleware-decorated\") and the <code>handler</code> produces a response.\nBasically <code>shallot</code> works like this:</p>\n<ol>\n<li>take the ASGI <a href=\"https://asgi.readthedocs.io/en/latest/specs/www.html#connection-scope\" rel=\"nofollow\">connection-scope</a> (<code>dict</code>)</li>\n<li>read the body of the request and attach the body (<code>bytes</code>) to scope-dict</li>\n<li>pass the request-<code>dict</code> (scope + attached body) to a user-defined function (called <code>handler</code>)</li>\n<li>the result (<code>response</code>) of a handler has to be a <code>dict</code>. The response must at least provide a <code>status</code>-key with an integer. If provided a <code>body</code>-key for the response is provided, than the value must be of type <code>bytes</code> and to will be transferred to the client.</li>\n</ol>\n<h3>data-flow</h3>\n<pre><code>+----------+           +----------+             +------------+\n|          |           |          |             |            |\n|          +-----------&gt; request  +-------------&gt; middlewares+-----------+\n|          |           |          |             | (enter)    |           |\n|          |           +----------+             +------------+           |\n|    A     |                                                             |\n|    S     |                                                             |\n|    G     |                                                             |\n|    I     |                                                             |\n|          |                                                   +---------v--------+\n|    |     |                                                   |                  |\n|          |                                                   |    handler       |\n|    S     |                                                   |                  |\n|    E     |                                                   +---------+--------+\n|    R     |                                                             |\n|    V     |                                                             |\n|    E     |                                                             |\n|    R     |           +----------+             +------------+           |\n|          |           |          |             |            |           |\n|          &lt;-----------+ response &lt;-------------+ middlewares&lt;-----------+\n|          |           |          |             | (leave)    |\n+----------+           +----------+             +------------+\n</code></pre>\n<h3>request</h3>\n<p>The <code>request</code> is always the first argument that gets passed to your <code>handler</code>-function. It is of type <code>dict</code>. It has basically the same content as the <a href=\"https://asgi.readthedocs.io/en/latest/specs/www.html#connection-scope\" rel=\"nofollow\">ASGI-connection-scope</a>.</p>\n<p>A request will at least have the following structure:</p>\n<ul>\n<li>\n<p><code>type</code>: http [string]</p>\n</li>\n<li>\n<p><code>method</code>: the http-verb in uppercase (for example: \"GET\", \"PUT\", \"POST\", ...) [<code>string</code>]</p>\n</li>\n<li>\n<p><code>headers</code>: a <code>dict</code> with all header-names as <code>keys</code> and the corresponding-values as <code>values</code> of the dict.</p>\n</li>\n<li>\n<p><code>body</code>: The body of the http-request as <code>bytes</code>. <code>shallot</code> always read the entire body and then calls the <code>handler</code>-function. [<code>bytes</code>]</p>\n</li>\n<li>\n<p><strong>note</strong>: many fields are missing! please refer to the documentation</p>\n</li>\n</ul>\n<h3>response</h3>\n<p>The <code>response</code> is the result of the function-call to the handler (with the <code>request</code> as first argument). The <code>response</code> has to be a <code>dict</code>. The reponse must have the following structure:</p>\n<ul>\n<li><code>status</code>: the http-return-code [<code>int</code>]</li>\n<li><code>body</code> [optional]: the body of the http-response [<code>bytes</code>]</li>\n<li><code>headers</code> [optional]: the http-response-headers to be used. The value is a <code>dict</code> (for example: <code>{\"header1-name\": \"header1-value\", ...}</code>)</li>\n<li><code>stream</code> [optional]: this must be an <code>async-iterable</code> yielding <code>bytes</code>. When the <code>response</code> contains a key named <code>stream</code>, than <code>shallot</code> will consume the <code>iterable</code> and will stream the provided data to the client. This is specially useful for large response-bodies.</li>\n</ul>\n<h3>handler</h3>\n<p><code>shallot</code> assembles a request-dict and calls a user-provided handler. A <code>handler</code> is an async-function that takes a request and returns a response (<code>dict</code>).</p>\n<pre><span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s2\">\"status\"</span><span class=\"p\">:</span> <span class=\"mi\">200</span><span class=\"p\">}</span>\n</pre>\n<h3>middleware</h3>\n<p>Most of <code>shallot</code>s  functionality is implemented via middlewares. That makes it possible to easily extend, configure or change <code>shallot</code>s behaviour. In fact: if you don't like the implementation of a certain middleware, just write your own and use it instead (or better: enhance <code>shallot</code> via PR)!</p>\n<p>The general functionality of a middleware is, that it wraps a handler-function-call. Middlewares are designed that way, that they can be composed / chained together. So for a middleware-chain with 3 different middlewares, a call chain might look like:</p>\n<pre><code>|-&gt; middleware 1 (enter)\n    |-&gt; middleware 2 (enter)\n        |-&gt; middleware 3 (enter)\n            |-&gt; handler (execute)\n        |&lt;- middleware 3 (leave)\n    |&lt;- middleware 2 (leave)\n|&lt;- middleware 1 (leave)\n</code></pre>\n<p>A good analogy for a middleware is a python-decorator. A decorator wraps a function and returns another function to provide extended functionality.</p>\n<h3>application</h3>\n<p>the minimal deployable thing, one can build is this:</p>\n<pre><span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">minimal</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">    answer EVERY request with 200 and NO body </span>\n<span class=\"sd\">    \"\"\"</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s2\">\"status\"</span><span class=\"p\">:</span> <span class=\"mi\">200</span><span class=\"p\">}</span>\n\n<span class=\"n\">server</span> <span class=\"o\">=</span> <span class=\"n\">build_server</span><span class=\"p\">(</span><span class=\"n\">minimal</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">uvicorn</span>  <span class=\"c1\"># shallot is not tied to uvicorn, its just fast</span>\n    <span class=\"n\">uvicorn</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">server</span><span class=\"p\">)</span>\n</pre>\n<p>to configure/run a real application, one would typically chain/apply a pile of middlewares and a handler:</p>\n<pre><span class=\"n\">middleware_pile</span> <span class=\"o\">=</span> <span class=\"n\">apply_middleware</span><span class=\"p\">(</span>\n    <span class=\"n\">wrap_content_type</span><span class=\"p\">(),</span>\n    <span class=\"n\">wrap_static</span><span class=\"p\">(</span><span class=\"s2\">\"/static/data\"</span><span class=\"p\">),</span>\n    <span class=\"n\">wrap_routes</span><span class=\"p\">(</span><span class=\"n\">routes</span><span class=\"p\">),</span>\n    <span class=\"n\">wrap_parameters</span><span class=\"p\">(),</span>\n    <span class=\"n\">wrap_cookies</span><span class=\"p\">,</span>\n    <span class=\"n\">wrap_json</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">server</span> <span class=\"o\">=</span> <span class=\"n\">build_server</span><span class=\"p\">(</span><span class=\"n\">middleware_pile</span><span class=\"p\">(</span><span class=\"n\">standard_not_found</span><span class=\"p\">))</span>\n</pre>\n<h2>Features</h2>\n<p>Nothing is enabled by default. Every functionality has its own middleware.</p>\n<h3>Routing</h3>\n<p>To include <code>shallot</code>s builtin routing functionality, use the routing-middleware: <code>wrap_routes</code>.</p>\n<p>routing is one essential and by far, the most opinionated part of any webframeworks-api. <code>shallot</code> is no exception there. Routing is defined completely via a data-structure:</p>\n<pre><span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">hello_world</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">text</span><span class=\"p\">(</span><span class=\"s2\">\"hi user!\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># is attached to a \"dynamic\"-route with one parseable url-part</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handle_index</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"n\">idx</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">text</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"hi user number: </span><span class=\"si\">{</span><span class=\"n\">idx</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">routes</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"p\">(</span><span class=\"s2\">\"/\"</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s2\">\"GET\"</span><span class=\"p\">],</span> <span class=\"n\">hello_world</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s2\">\"/hello\"</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s2\">\"GET\"</span><span class=\"p\">],</span> <span class=\"n\">hello_world</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s2\">\"/hello/</span><span class=\"si\">{index}</span><span class=\"s2\">\"</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s2\">\"GET\"</span><span class=\"p\">],</span> <span class=\"n\">handle_index</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s2\">\"/echo\"</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s2\">\"GET\"</span><span class=\"p\">,</span> <span class=\"s2\">\"PUT\"</span><span class=\"p\">,</span> <span class=\"s2\">\"POST\"</span><span class=\"p\">],</span> <span class=\"n\">post_echo</span><span class=\"p\">),</span>\n    <span class=\"p\">(</span><span class=\"s2\">\"/json\"</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s2\">\"GET\"</span><span class=\"p\">,</span> <span class=\"s2\">\"PUT\"</span><span class=\"p\">],</span> <span class=\"n\">show_and_accept_json</span><span class=\"p\">),</span>\n<span class=\"p\">]</span>\n</pre>\n<p>as shown above, <code>routes</code> is a list of tuples with:</p>\n<pre><code>1. the (potentially dynamic) route\n2. the allowed methods\n3. the handler\n</code></pre>\n<p>Routes with an <code>{tag}</code> in it, are considered dynamic-routes. The router will parse the value from the url and transfered it (as string) to the handler-function. Therfore the handler function must accept the <code>request</code> and as many arguments as there are <code>{tag}</code>s.</p>\n<h3>JSON</h3>\n<p>to easily work with json-data, use the json-middleware <code>wrap_json</code>:</p>\n<p>every request, that contains a content-type <code>application/json</code> will be parsed and the result will be attached to the request under the key <code>json</code>.\nWhen data body is not parseable as json, the middleware will respond with <code>{\"status\": 400, \"body\": \"Malformed JSON\"}</code>.</p>\n<p>when you want to return json-data as your response, use the <code>shallot.response</code> - function <code>json</code>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">shallot.response</span> <span class=\"kn\">import</span> <span class=\"n\">json</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">json_handler</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"n\">client_json_data</span> <span class=\"o\">=</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"json\"</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">client_json_data</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">)</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">json</span><span class=\"p\">({</span><span class=\"s2\">\"hello\"</span><span class=\"p\">:</span> <span class=\"s2\">\"world\"</span><span class=\"p\">})</span>\n</pre>\n<h3>Static-Files</h3>\n<p><code>shallot</code> is not optimized to work as static-file-server. Although it goes to great lengths, to provide a solid experience for serving static content.</p>\n<p>To work with static-files use the <code>wrap_static</code> - middleware.</p>\n<p>This middleware depends on <code>aiofiles</code>.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"n\">here</span> <span class=\"o\">=</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">dirname</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">)</span>\n<span class=\"n\">wrap_static</span><span class=\"p\">(</span><span class=\"s2\">\"/static/data\"</span><span class=\"p\">,</span> <span class=\"n\">root_path</span><span class=\"o\">=</span><span class=\"n\">here</span><span class=\"p\">)</span>  <span class=\"c1\"># will always assume the folder is located : &lt;this_file&gt;.py/static/data</span>\n</pre>\n<p>Browser-caches will be honored. For that, <code>last-modified</code> and <code>etag</code> - headers will be sent accordingly.\nRequests with a path containing \"../\" will be automatically responded with <code>404-Not Found</code>.</p>\n<h3>Websockets</h3>\n<p>In shallot, websockets are modeled as async-generators. Except that, websockets-handlers are more or less equal to http-handlers.\nThey receive data, <code>str</code> or <code>bytes</code> from the generator (<code>receiver</code>) and a <code>dict</code> from the opening http-request (<code>request</code>). As a\nresult a websocket-handler yields back data (<code>dict</code>), in the example below, constructed via <code>ws_send</code></p>\n<pre><span class=\"nd\">@websocket</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">echo_server</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"n\">receiver</span><span class=\"p\">):</span>\n    <span class=\"k\">async</span> <span class=\"k\">for</span> <span class=\"n\">message</span> <span class=\"ow\">in</span> <span class=\"n\">receiver</span><span class=\"p\">:</span>\n        <span class=\"k\">yield</span> <span class=\"n\">ws_send</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"@echo: </span><span class=\"si\">{</span><span class=\"n\">message</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n</pre>\n\n          </div>"}, "last_serial": 7046742, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "c59abbee24e5446b97b53ce25b86663e", "sha256": "4f5b8b5226cfe2c4c356824283e641ea4d2fe7ab4c6f834c1f00200daa27cd27"}, "downloads": -1, "filename": "shallot-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "c59abbee24e5446b97b53ce25b86663e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 19304, "upload_time": "2019-01-05T16:09:00", "upload_time_iso_8601": "2019-01-05T16:09:00.825537Z", "url": "https://files.pythonhosted.org/packages/56/0e/2279fcc54fae4eb2339712e7d82db8a37afd7943f9c57325839554a529b5/shallot-0.0.1-py3-none-any.whl", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "f761773f2ce753c2fbe6d9abf7820a44", "sha256": "dc55131c140e09b7870c68ef28f4cbe1b68a8c7c362a5b7814f0435fca50070c"}, "downloads": -1, "filename": "shallot-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "f761773f2ce753c2fbe6d9abf7820a44", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 19318, "upload_time": "2019-01-07T17:34:09", "upload_time_iso_8601": "2019-01-07T17:34:09.867509Z", "url": "https://files.pythonhosted.org/packages/42/98/bfbead1a6435b1a1f869f462a9fce641067d12acfa013925398db7b1178a/shallot-0.1.0-py3-none-any.whl", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "6841d2e9d61cd58c4f8f79f313ebfe50", "sha256": "ea9320ba154b16ef4949dcb5c1a20616688550c402ff89510ec79856da23a26b"}, "downloads": -1, "filename": "shallot-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "6841d2e9d61cd58c4f8f79f313ebfe50", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 31119, "upload_time": "2020-04-18T09:44:39", "upload_time_iso_8601": "2020-04-18T09:44:39.140236Z", "url": "https://files.pythonhosted.org/packages/c1/cf/8c83d5541055b2f892051f48d2d5e28d5e31b7f06f09dfad632b3849fdb1/shallot-0.2.0-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6841d2e9d61cd58c4f8f79f313ebfe50", "sha256": "ea9320ba154b16ef4949dcb5c1a20616688550c402ff89510ec79856da23a26b"}, "downloads": -1, "filename": "shallot-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "6841d2e9d61cd58c4f8f79f313ebfe50", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 31119, "upload_time": "2020-04-18T09:44:39", "upload_time_iso_8601": "2020-04-18T09:44:39.140236Z", "url": "https://files.pythonhosted.org/packages/c1/cf/8c83d5541055b2f892051f48d2d5e28d5e31b7f06f09dfad632b3849fdb1/shallot-0.2.0-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 03:13:50 2020"}