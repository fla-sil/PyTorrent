{"info": {"author": "Milan Suk", "author_email": "Milansuk@email.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# Inseminator\n\n[![codecov](https://codecov.io/gh/sukovanej/container/branch/master/graph/badge.svg)](https://codecov.io/gh/sukovanej/container)\n[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n\n*(definition from dictionary.com)*\n\n> a technician who introduces prepared ~semen~ **dependencies** into the ~genital tract \n> of breeding animals~ python classes, especially ~cows and mares~ pure classes with \n> proper IoC, for ~artificial insemination~ well coupled components and clear classes \n> signatures.\n\nPython library for type-based dependency injection. Write code without global state\nand noisy boilerplate. Inseminator is meant to be used in an entry-point layer of your\napplication and the only thing it requires is properly type-hinted classes \ndependencies.\n\n*(Under development)*\n\n## Usage\n\nYou start by defining the *container* of your dependencies. Whenever you want the container\nto resolve a dependency, it uses the container to search for existing objects and a \nresolver automatically creates desired dependencies.\n\n```Python\nfrom inseminator import Container\n\n\nclass DomainModel:\n    def __init__(self):\n        self.__logic_constant = 1\n\n    def domain_logic(self, input_value: int) -> int:\n        return input_value + self.__logic_constant\n\n\nclass Controller:\n    def __init__(self, domain_model: DomainModel):\n        self.__domain_model = domain_model\n\n    def handler(self, input_value: int) -> int:\n        return self.__domain_model.domain_logic(input_value)\n\n\n# entry-point of your application\n\ncontainer = Container()\n\n# view layer handling\n\ncontroller = container.resolve(Controller)\nresult = controller.handler(1)\nprint(result)\n```\n\nThe strategy for resolving `Controller` is its constructor signature. The resolver works as follows.\n\n  1) We ask the `container` to resolve a dependency `Controller` -> `container.resolve(Controller)`.\n  2) Resolver inside the `container` checks the `Controller`'s constructor signature, i.e. **type hints**\n     of `__init__` method and sees `domain_models: DomainModel`.\n  3) If an instance of `DomainModel` class is already known by the `container` it uses that instance.\n     In the opposite case, the container starts the same resolving machinery for `DomainModel` - which\n     is the exact case we are facing now.\n  4) Because `DomainModel` doesn't have any dependencies it can construct it directly.\n  5) Now the resolver has all the dependencies for `Controller` constructor and can instantiate it.\n\nIf we programmed against an interface instead of implementation the example is modified like this.\n\n```Python\nfrom inseminator import Container\n\nfrom typing import Protocol\n\nclass DomainModel(Protocol):\n    def domain_logic(self, input_value: int) -> int:\n        ...\n\nclass Controller:\n    def __init__(self, domain_model: DomainModel):\n        self.__domain_model = domain_model\n\n    def handler(self, input_value: int) -> int:\n        return self.__domain_model.domain_logic(input_value)\n\n\n# domain model implementation\n\n\nclass ConcreteDomainModel:\n    def __init__(self):\n        self.__logic_constant = 1\n\n    def domain_logic(self, input_value: int) -> int:\n        return input_value + self.__logic_constant\n\n\n# entry point of your application\n\ncontainer = Container()\ncontainer.register(DomainModel, value=ConcreateDomainModel())\n\n# view layer handling\n\ncontroller = container.resolve(Controller)\nresult = controller.handler(1)\nprint(result)\n```\n\nIn this situation, protocol `DomainModel` doesn't hold implementation details, only interface.\nUsing \n\n```\ncontainer.register(DomainModel, value=ConcreateDomainModel())\n```\n\nwe're guiding the resolver to use instance of `ConcreateDomainModel` in case someone asks\nfor `DomainModel`.\n\n### Enforced parameters\n\nIf it is not desired to provide a single concrete implementation for abstract or protocol dependency\none can enforce the resolver to use concrete types for specified parameters. Simply call `container.resolve`\nalso with keywords and tell the resolve how it should resolve some particular parameters.\n\n```Python\ncontainer = Container()\ncontroller = container.resolve(Controller, domain_model=ConcreteDomainModel)\n```\n\nMoreover, using this approach `ConcreteDomainModel` is not evaluated and saved in the container but\nrather in a sub-container which exists only during the resolving. Therefore, if we want to create\nanother instance that depends on `DomainModel` we must either use `register` or again specify\nthe parameter during resolving.\n\n\n### Injecting functions\n\n\nIt might be convinient to specify funcion's dependencies in-place. The great example is Flask\nhandler function. It should live in the same layer the DI container lives because it provides\nonly infrastructure functionality and desirably the only thing it does it calling domain layer's\nfunctions. For this purpose, there is `injector` decorator on the `Container` object. You just\ntell which dependency to provide using `Depends` type constructor.\n\n\n```Python\nfrom inseminator import Container, Depends\n\n\nclass Dependency:\n    def __init__(self):\n        self.x = 1\n\n\ncontainer = Container()\n\n\n@container.inject\ndef my_handler(input_value: int, dependency: Depends(Dependency)):\n    return input_value + dependency.x\n```\n\nUsed like that, `my_handler` takes a single argument and thanks to closure it has `dependency` \nprepared with the right instance of `Dependency`.\n\n\n```\n>>> my_handler(1)\n2\n```\n\n\n## Docs\n\n - [Clean architecture introduction (draft version)](docs/introduction.md)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://www.github.com/sukovanej/inseminator/", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "inseminator", "package_url": "https://pypi.org/project/inseminator/", "platform": "", "project_url": "https://pypi.org/project/inseminator/", "project_urls": {"Homepage": "https://www.github.com/sukovanej/inseminator/"}, "release_url": "https://pypi.org/project/inseminator/0.1/", "requires_dist": null, "requires_python": ">=3.8", "summary": "Python dependency injection library based on type hints", "version": "0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Inseminator</h1>\n<p><a href=\"https://codecov.io/gh/sukovanej/container\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f2faa33660e8661e7b207c0515e97fa682ab4bd5/68747470733a2f2f636f6465636f762e696f2f67682f73756b6f76616e656a2f636f6e7461696e65722f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://github.com/psf/black\" rel=\"nofollow\"><img alt=\"Code style: black\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fbfdc7754183ecf079bc71ddeabaf88f6cbc5c00/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e737667\"></a></p>\n<p><em>(definition from dictionary.com)</em></p>\n<blockquote>\n<p>a technician who introduces prepared <del>semen</del> <strong>dependencies</strong> into the <del>genital tract\nof breeding animals</del> python classes, especially <del>cows and mares</del> pure classes with\nproper IoC, for <del>artificial insemination</del> well coupled components and clear classes\nsignatures.</p>\n</blockquote>\n<p>Python library for type-based dependency injection. Write code without global state\nand noisy boilerplate. Inseminator is meant to be used in an entry-point layer of your\napplication and the only thing it requires is properly type-hinted classes\ndependencies.</p>\n<p><em>(Under development)</em></p>\n<h2>Usage</h2>\n<p>You start by defining the <em>container</em> of your dependencies. Whenever you want the container\nto resolve a dependency, it uses the container to search for existing objects and a\nresolver automatically creates desired dependencies.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">inseminator</span> <span class=\"kn\">import</span> <span class=\"n\">Container</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">DomainModel</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__logic_constant</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">domain_logic</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">input_value</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">input_value</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__logic_constant</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Controller</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">domain_model</span><span class=\"p\">:</span> <span class=\"n\">DomainModel</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__domain_model</span> <span class=\"o\">=</span> <span class=\"n\">domain_model</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">input_value</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__domain_model</span><span class=\"o\">.</span><span class=\"n\">domain_logic</span><span class=\"p\">(</span><span class=\"n\">input_value</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># entry-point of your application</span>\n\n<span class=\"n\">container</span> <span class=\"o\">=</span> <span class=\"n\">Container</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># view layer handling</span>\n\n<span class=\"n\">controller</span> <span class=\"o\">=</span> <span class=\"n\">container</span><span class=\"o\">.</span><span class=\"n\">resolve</span><span class=\"p\">(</span><span class=\"n\">Controller</span><span class=\"p\">)</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">handler</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<p>The strategy for resolving <code>Controller</code> is its constructor signature. The resolver works as follows.</p>\n<ol>\n<li>We ask the <code>container</code> to resolve a dependency <code>Controller</code> -&gt; <code>container.resolve(Controller)</code>.</li>\n<li>Resolver inside the <code>container</code> checks the <code>Controller</code>'s constructor signature, i.e. <strong>type hints</strong>\nof <code>__init__</code> method and sees <code>domain_models: DomainModel</code>.</li>\n<li>If an instance of <code>DomainModel</code> class is already known by the <code>container</code> it uses that instance.\nIn the opposite case, the container starts the same resolving machinery for <code>DomainModel</code> - which\nis the exact case we are facing now.</li>\n<li>Because <code>DomainModel</code> doesn't have any dependencies it can construct it directly.</li>\n<li>Now the resolver has all the dependencies for <code>Controller</code> constructor and can instantiate it.</li>\n</ol>\n<p>If we programmed against an interface instead of implementation the example is modified like this.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">inseminator</span> <span class=\"kn\">import</span> <span class=\"n\">Container</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">typing</span> <span class=\"kn\">import</span> <span class=\"n\">Protocol</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">DomainModel</span><span class=\"p\">(</span><span class=\"n\">Protocol</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">domain_logic</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">input_value</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"o\">...</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Controller</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">domain_model</span><span class=\"p\">:</span> <span class=\"n\">DomainModel</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__domain_model</span> <span class=\"o\">=</span> <span class=\"n\">domain_model</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">input_value</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__domain_model</span><span class=\"o\">.</span><span class=\"n\">domain_logic</span><span class=\"p\">(</span><span class=\"n\">input_value</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># domain model implementation</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">ConcreteDomainModel</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__logic_constant</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">domain_logic</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">input_value</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">input_value</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">__logic_constant</span>\n\n\n<span class=\"c1\"># entry point of your application</span>\n\n<span class=\"n\">container</span> <span class=\"o\">=</span> <span class=\"n\">Container</span><span class=\"p\">()</span>\n<span class=\"n\">container</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"n\">DomainModel</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">ConcreateDomainModel</span><span class=\"p\">())</span>\n\n<span class=\"c1\"># view layer handling</span>\n\n<span class=\"n\">controller</span> <span class=\"o\">=</span> <span class=\"n\">container</span><span class=\"o\">.</span><span class=\"n\">resolve</span><span class=\"p\">(</span><span class=\"n\">Controller</span><span class=\"p\">)</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"n\">handler</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<p>In this situation, protocol <code>DomainModel</code> doesn't hold implementation details, only interface.\nUsing</p>\n<pre><code>container.register(DomainModel, value=ConcreateDomainModel())\n</code></pre>\n<p>we're guiding the resolver to use instance of <code>ConcreateDomainModel</code> in case someone asks\nfor <code>DomainModel</code>.</p>\n<h3>Enforced parameters</h3>\n<p>If it is not desired to provide a single concrete implementation for abstract or protocol dependency\none can enforce the resolver to use concrete types for specified parameters. Simply call <code>container.resolve</code>\nalso with keywords and tell the resolve how it should resolve some particular parameters.</p>\n<pre><span class=\"n\">container</span> <span class=\"o\">=</span> <span class=\"n\">Container</span><span class=\"p\">()</span>\n<span class=\"n\">controller</span> <span class=\"o\">=</span> <span class=\"n\">container</span><span class=\"o\">.</span><span class=\"n\">resolve</span><span class=\"p\">(</span><span class=\"n\">Controller</span><span class=\"p\">,</span> <span class=\"n\">domain_model</span><span class=\"o\">=</span><span class=\"n\">ConcreteDomainModel</span><span class=\"p\">)</span>\n</pre>\n<p>Moreover, using this approach <code>ConcreteDomainModel</code> is not evaluated and saved in the container but\nrather in a sub-container which exists only during the resolving. Therefore, if we want to create\nanother instance that depends on <code>DomainModel</code> we must either use <code>register</code> or again specify\nthe parameter during resolving.</p>\n<h3>Injecting functions</h3>\n<p>It might be convinient to specify funcion's dependencies in-place. The great example is Flask\nhandler function. It should live in the same layer the DI container lives because it provides\nonly infrastructure functionality and desirably the only thing it does it calling domain layer's\nfunctions. For this purpose, there is <code>injector</code> decorator on the <code>Container</code> object. You just\ntell which dependency to provide using <code>Depends</code> type constructor.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">inseminator</span> <span class=\"kn\">import</span> <span class=\"n\">Container</span><span class=\"p\">,</span> <span class=\"n\">Depends</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Dependency</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n\n<span class=\"n\">container</span> <span class=\"o\">=</span> <span class=\"n\">Container</span><span class=\"p\">()</span>\n\n\n<span class=\"nd\">@container</span><span class=\"o\">.</span><span class=\"n\">inject</span>\n<span class=\"k\">def</span> <span class=\"nf\">my_handler</span><span class=\"p\">(</span><span class=\"n\">input_value</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">dependency</span><span class=\"p\">:</span> <span class=\"n\">Depends</span><span class=\"p\">(</span><span class=\"n\">Dependency</span><span class=\"p\">)):</span>\n    <span class=\"k\">return</span> <span class=\"n\">input_value</span> <span class=\"o\">+</span> <span class=\"n\">dependency</span><span class=\"o\">.</span><span class=\"n\">x</span>\n</pre>\n<p>Used like that, <code>my_handler</code> takes a single argument and thanks to closure it has <code>dependency</code>\nprepared with the right instance of <code>Dependency</code>.</p>\n<pre><code>&gt;&gt;&gt; my_handler(1)\n2\n</code></pre>\n<h2>Docs</h2>\n<ul>\n<li><a href=\"docs/introduction.md\" rel=\"nofollow\">Clean architecture introduction (draft version)</a></li>\n</ul>\n\n          </div>"}, "last_serial": 6681776, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "82817892c944cbbe1a6be141d266534a", "sha256": "7c335e92a05fb102cefd24b0e1f972582d42d6b3f74b4cfcd1df0ee4f3099777"}, "downloads": -1, "filename": "inseminator-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "82817892c944cbbe1a6be141d266534a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.8", "size": 7502, "upload_time": "2020-02-22T20:12:43", "upload_time_iso_8601": "2020-02-22T20:12:43.503785Z", "url": "https://files.pythonhosted.org/packages/3f/4b/ae9a9f4deeb4d0bda7f74bdf3aa1e7f7770103ff5fe1af34057608ade6a5/inseminator-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a569e2db3a70069261f7ac9f520fa062", "sha256": "4cd97a83b90be8159a82e9012607d3147e10b7196c14a4dd5086f5b7942a4629"}, "downloads": -1, "filename": "inseminator-0.1.tar.gz", "has_sig": false, "md5_digest": "a569e2db3a70069261f7ac9f520fa062", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.8", "size": 13621, "upload_time": "2020-02-22T20:12:45", "upload_time_iso_8601": "2020-02-22T20:12:45.748721Z", "url": "https://files.pythonhosted.org/packages/0f/d8/ee64f3a09ea552fcbaca0f75d30b239587ef04f3cd58712ba7cf8353d8e6/inseminator-0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "82817892c944cbbe1a6be141d266534a", "sha256": "7c335e92a05fb102cefd24b0e1f972582d42d6b3f74b4cfcd1df0ee4f3099777"}, "downloads": -1, "filename": "inseminator-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "82817892c944cbbe1a6be141d266534a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.8", "size": 7502, "upload_time": "2020-02-22T20:12:43", "upload_time_iso_8601": "2020-02-22T20:12:43.503785Z", "url": "https://files.pythonhosted.org/packages/3f/4b/ae9a9f4deeb4d0bda7f74bdf3aa1e7f7770103ff5fe1af34057608ade6a5/inseminator-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a569e2db3a70069261f7ac9f520fa062", "sha256": "4cd97a83b90be8159a82e9012607d3147e10b7196c14a4dd5086f5b7942a4629"}, "downloads": -1, "filename": "inseminator-0.1.tar.gz", "has_sig": false, "md5_digest": "a569e2db3a70069261f7ac9f520fa062", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.8", "size": 13621, "upload_time": "2020-02-22T20:12:45", "upload_time_iso_8601": "2020-02-22T20:12:45.748721Z", "url": "https://files.pythonhosted.org/packages/0f/d8/ee64f3a09ea552fcbaca0f75d30b239587ef04f3cd58712ba7cf8353d8e6/inseminator-0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:55:49 2020"}