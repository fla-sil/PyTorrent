{"info": {"author": "Oliver Cope", "author_email": "oliver@redgecko.org", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6"], "description": ".. Copyright 2013-2014 Oliver Cope\n..\n.. Licensed under the Apache License, Version 2.0 (the \"License\");\n.. you may not use this file except in compliance with the License.\n.. You may obtain a copy of the License at\n..\n..     http://www.apache.org/licenses/LICENSE-2.0\n..\n.. Unless required by applicable law or agreed to in writing, software\n.. distributed under the License is distributed on an \"AS IS\" BASIS,\n.. WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n.. See the License for the specific language governing permissions and\n.. limitations under the License.\n\n\nMorf - HTML form validation and rendering\n=========================================\n\nWhy use morf?\n-------------\n\nBecause you want to express simple forms concisely::\n\n    from morf import HTMLForm, fields, validators\n\n    class ContactForm(HTMLForm):\n        name = fields.Str(message='Please fill in your name')\n        email = fields.Str(validators=[validators.is_email])\n        message = fields.Str(validators=[validators.minwords(10)])\n\nBecause you want to be able to express custom validation logic::\n\n    class BookingForm(HTMLForm):\n        name = fields.Str(message='Please fill in your name')\n        arrival_date = fields.Date()\n        leaving_date = fields.Date()\n\n        @validates(arrival_date, leaving_date)\n        def check_name(self, arrival_date, leaving_date):\n\n            # No minimum booking duration at weekends\n            if arrival_date.weekday() in (SAT, SUN):\n                return\n\n            if (leaving_date - arrival_date).days < 3:\n                self.fail('Sorry, the minimum booking is for 3 days')\n\nBecause you want a simple API to work with::\n\n    def my_view(request):\n        form = BookingForm(request.POST)\n        if form.isvalid:\n            make_booking(form.data)\n            ...\n        else:\n            show_error_page(errors=form.errors)\n\n\nDocumentation for morf is available at https://ollycope.com/software/morf/\n\nMorf's source code is available at https://bitbucket.org/ollyc/morf/\n\n\nRendering forms with widgets\n============================\n\nMorf separates form processing - taking user input and validating it, and\nhandling any ensuing application logic - from the business of rendering HTML\nforms and parsing HTML form encoded data.\n\nIf your form is always going to be rendered as an HTML form, just\nsubclass HTMLForm, and you can use the rendering methods directly::\n\n    class BookingForm(HTMLForm):\n        name = fields.Str(message='Please fill in your name')\n        email = fields.Str(validators=[is_email])\n        arrival_date = fields.Date()\n        leaving_date = fields.Date()\n\n    bookingform = BookingForm()\n    bookingform.as_p().render()\n\nForms processing data coming from sources other than HTML form submissions\nshould subclass ``morf.Form``.\n\nIf you also want your form to be rendered or submitted in HTML,\nuse ``HTMLForm.adapt``::\n\n    from morf import Form, HTMLForm\n\n    class BookingForm(Form):\n        name = fields.Str(message='Please fill in your name')\n        email = fields.Str(validators=[is_email])\n        arrival_date = fields.Date()\n        leaving_date = fields.Date()\n\n    HTMLBookingForm = HTMLForm.adapt(BookingForm)\n    HTMLBookingForm().as_p().render()\n\nRendering field groups\n-----------------------\n\n\nSelect groups of fields for rendering\nusing the ``select\u2026`` methods on any\nFormRenderer object.\n\n**``select``** returns just the named fields, eg::\n\n    <h1>Personal details</h1>\n    {% for field in form.select(['firstname', 'lastname', 'email']) %}\n        {{ field.render() }}\n    {% endfor %}\n\n    <h1>Address</h1>\n    {% for field in form.select(['housenumber', 'street', 'city', 'zip']) %}\n        {{ field.render() }}\n    {% endfor %}\n\nNote that ``select`` won't raise an exception\nif you pass it an invalid field name,\nit will just skip that field.\nUse ``select([\u2026], strict=True)`` if you want strict fieldname checking.\n\n**``select_except``** returns all the fields except those listed, eg::\n\n    {% for field in form.select_except(['account_type']) %}\n        {{ field.render() }}\n    {% endfor %}\n\n\n**``select_to``** returns all the fields up to\n(but not including) the named field::\n\n    {% for field in form.select_to(['housenumber']) %}\n        {{ field.render() }}\n    {% endfor %}\n\n**``select_match``** returns all fields matching a given regular expression::\n\n    <h1>Shipping</h1>\n    {% for field in form.select_match(r'shipping_.*') %}\n        {{ field.render() }}\n    {% endfor %}\n\n    <h1>Billing details</h1>\n    {% for field in form.select_match(r'billing_.*') %}\n        {{ field.render() }}\n    {% endfor %}\n\n\n\nHTMLForm\n--------\n\nThe ``HTMLForm`` class has two important differences over ``Form``.\n\nFirstly,\n**HTMLForm has preconfigured rendering options for generating HTML**.\nThese can be used to render the whole form with fields being wrapped in\n``<p>...</p>`` elements, ``<ul>``, ``<ol>`` or as a table::\n\n    form.as_p().render()\n\n    form.as_ul().render()\n\n    form.as_ol().render()\n\n    form.as_table().render()\n\nThe ``HTMLForm.renderer`` method lets you customize the rendering templates::\n\n    form.renderer(row_template='<div>{{ field }}</div>')\n\nSecondly,\n**HTMLForm adapts nested forms to work with flat HTML forms**.\nIf you have a form like this, which expects nested data::\n\n    class PlayerForm(HTMLForm):\n        last_name = fields.Str()\n        first_name = fields.Str()\n\n    class TeamForm(HTMLForm):\n        team_name = fields.Str()\n        players = fields.ListOf(PlayerForm(), label='Players', spare=2, max=5)\n\nHTMLForm knows how to render this to create HTML inputs like this::\n\n    <input name=\"team_name\" type=\"text\" />\n    <input name=\"players#0.name\" type=\"text\" />\n    <input name=\"players#0.age\" type=\"text\" />\n    <input name=\"players#1.name\" type=\"text\" />\n    <input name=\"players#1.age\" type=\"text\" />\n    \u2026\n\nAnd can then convert the corresponding form submission values into the required\ndata structure, eg::\n\n    {'team_name': 'Surprise!',\n     'players': [\n        {'name': 'alice',  'age': 8},\n        {'name': 'bob', 'age': 7},\n        \u2026\n    ]}\n\n\nWidgets\n-------\n\nMorf defines various widgets for rendering different HTML field controls.\nSpecify the widget you want when constructing the field::\n\n    class ContactForm(Form):\n\n        message = field.Str(widget=widgets.Textarea())\n\nIf you don't specify a widget, the default widget type for that field will be\nused.\n\nRead the source code for ``morf.widgets`` to see the full list of available\nwidgets.\n\n\nFields\n======\n\nMorf offers various builtin field types:\n\n- ``morf.fields.Str``\n- ``morf.fields.Int``\n- ``morf.fields.Decimal``\n- ``morf.fields.Date``\n- ``morf.fields.DateTime``\n- ``morf.fields.Bool``\n- ``morf.fields.MultipleChoice``\n- ``morf.fields.ListOf``, a container for creating lists of other fields\n\nAdditionally, ``morf.form.Form`` can also be used as a field. Typically\nyou would use this to generate nested structures, eg::\n\n\n    class PlayerForm(HTMLForm):\n        last_name = fields.Str()\n        first_name = fields.Str()\n\n    class TeamForm(HTMLForm):\n        team_name = fields.Str()\n        players = fields.ListOf(PlayerForm(), label='Players', spare=2, max=5)\n\n\nField classes take the following standard constructor arguments:\n\nname\n    The name of the field (eg 'last_name')\n\ndisplayname\n    The name to display to the user (eg 'last name')\n    when referencing the field.\n    If not specified this will be generated from ``name``\n\nlabel\n    The label to show for the field\n    (eg 'Please enter your last name').\n    If not specified ``displayname`` will be used.\n\nempty_message\n    The error to display when the field has not been filled in\n\ninvalid_message\n    The error to display when the field contains invalid data\n\ndefault\n    A default value for the field\n\nprocessors\n    A list of processors. See the `Processors`_ section below\n\nvalidators\n    A list of validators. See the `Validators`_ section below\n\nwidget\n    The widget to use when rendering as HTML\n\nchoices\n    A list of choices that the value must be selected from.\n    See the `Choices`_ section below.\n\nvalidate_choices\n    If ``choices`` has been set, the submitted value is tested\n    to ensure it is a valid item from the list of choices.\n    Defaults to ``True``, set this to ``False`` to disable this check.\n\nChoices\n-------\n\nFields can require a value to be selected from a list of valid choices.\nTypically this might be represented as radio buttons or a select control.\nChoices can be supplied in a variety of ways::\n\n    class UserPreferencesForm(HTMLForm):\n\n        # Choices can be a list of (value, label) tuples\n        favorite_color = fields.Str(choices=[('#ff0000', 'Red'),\n                                             ('#0000ff', 'Blue')],\n                                     widget=widgets.RadioGroup())\n\n        # ...or a list of values doubling as labels\n        current_mood = fields.Str(choices=['happy', 'frustrated'],\n                                  widget=widgets.RadioGroup())\n\n        # ...or a callable returning either of the two above formats\n        shoe_size = fields.Str(choices=range(1, 13),\n                            widget=widgets.Select)\n\n        # ...or the name of a method on the form object\n        preferred_vegetable = fields.Str(choices='get_vegetables',\n                                        widget=widgets.RadioGroup())\n\n        def get_vegetables(self):\n            return ['turnip', 'leek', 'potato']\n\n\nChoices and optgroups\n---------------------\n\nChoices can be hierarchical, for example::\n\n    from morf import choices\n\n    soups = [(0, 'Minestrone'), (1, 'French onion')]\n    salads = [(2, 'Tomato salad'), (3, 'Greek salad')]]\n\n    class MenuForm(HTMLForm):\n\n        lunch = fields.Choice(choices=[('Soups', choices.OptGroup(soups)),\n                                       ('Salads', choices.OptGroup(soups))])\n\nWhen rendered, the lunch field will be displayed as\nan HTML ``<select>`` element containing ``<optgroup>`` elements, eg::\n\n    <select name=\"lunch\">\n        <optgroup label=\"Soups\">\n            <option value=\"0\">Minestrone</option>\n            <option value=\"1\">French onion</option>\n        </optgroup>\n        <optgroup label=\"Salads\">\n            <option value=\"0\">Tomato salad</option>\n            <option value=\"1\">Greek salad</option>\n        </optgroup>\n    </select>\n\n\nWhen using radio buttons or checkbox widgets,\n``OptGroups`` are rendered inside a ``<fieldset>`` element.\n\nDynamic fields\n--------------\n\nFields can be added dynamically using ``@property``::\n\n    class FormWithDynamicFields(HTMLForm):\n\n        @property\n        def milk_and_sugar(self):\n            from datetime import datetime\n            beverage = 'coffee' if (datetime.now().hour < 13) else 'tea'\n            return fields.Choice(\n                    label='How would you like your {}?'.format(beverage),\n                    choices=['With milk', 'With sugar', 'With milk and sugar'])\n\nIf you need more flexibility use the ``add_fields`` and ``remove_fields``\nmethods to manipulate the ``fields`` dict.\nThe ``before`` or ``after`` arguments\nallow you to control the ordering of added fields::\n\n    class FormWithDynamicFields(HTMLForm):\n\n        def __init__(self, *args, **kwargs):\n            beverage = kwargs.pop('beverage')\n            super(FormWithDynamicFields, self).__init__(*args, **kwargs)\n            self.add_field('milk_and_sugar',\n                            fields.Choice(\n                            label='How would you like your {}?'.format(\n                                                                  beverage),\n                            choices=['with milk',\n                                     'with sugar',\n                                     'with milk and sugar']),\n                            before='biscuit_preference')\n\n\nError messages\n--------------\n\nFields can have separate messages specified for empty or invalid data::\n\n    field.Str(empty_message='Choose your new password ',\n              invalid_message='Passwords must be at least 8 characters')\n\nYou can specify both at once::\n\n    field.Str(message='Choose a new password of at least 8 characters')\n\nValidators can also have error messages::\n\n    field.Str(message='Please enter your length of stay',\n              validators=[gt(1, 'You must stay at least one night'),\n                          lte(28, 'Rooms cannot be booked for over 28 days')])\n\n\nProcessors\n==========\n\nValue processors are run after type conversion but before validation and can\nbe used for normalizing data input before validation::\n\n    def foldcase(s):\n        return s.lower()\n\n    def strip_non_digits(s):\n        return re.sub(r'[^\\d]', '', s)\n\n    username = field.Str(processors=[foldcase])\n    account_no = field.Str(processors=[strip_non_digits])\n\nWhen writing processors remember that you these should not perform any\nvalidation, so you should never raise ValidationError or any other exception\ninside a processor function.\n\n\nValidators\n==========\n\nA validator can be any function or callable object taking the submitted field\nvalue and raising a ValidationError if it fails.\n\nTo allow the validation parameters to be varied, the usual pattern is to\ndefine a factory function::\n\n    from morf.validation import assert_true\n\n    def contains(word, message='Invalid value'):\n        def validate_contains(value):\n            assert_true(word in value.lower(), message)\n        return validate_contains\n\n\nNotice the use of assert_true.\nThis is exactly equivalent to::\n\n    if word not in value.lower():\n        raise ValidationError(message)\n\nYou can then use your validator by passing it in the ``validators`` list when\nconstructing a field::\n\n    field.Str(validators=[contains('please',\n                                   message=\"What's the magic word?\")])\n\n\nUse the ``@validates`` decorator to define a one-off custom validation\ncondition.\nThis takes one or more field names,\nand each named field is passed as an argument\nto the decorated validation function::\n\n\n        class BookingForm(Form):\n\n            ...\n\n            @validates(arrival_date, leaving_date)\n            def check_name(self, arrival_date, leaving_date):\n\n                # No minimum booking duration at weekends\n                if arrival_date.weekday() in (SAT, SUN):\n                    return\n\n                if (leaving_date - arrival_date).days < 3:\n                    self.fail('Sorry, the minimum booking is for 3 days')\n\nYou can also use ``@validates`` without arguments,\nin which case the validation function is called without arguments\nand any errors raised are deemed to apply to the form as a whole::\n\n            @validates\n            def validate_entire_form(self, data):\n                ...\n\n\nA variant of ``@validates`` is ``@cleans``,\nwhich replaces the value of the first named field with\nthe return value of the function::\n\n        class BookingForm(Form):\n\n            ...\n\n            @cleans(card_number)\n            def normalize_card_number(self, card_number):\n\n                return card_number\\\n                    .replace(' ', '')\n                    .replace('-', '')\n                    .strip()\n\nYou can specify multiple field names in the ``@cleans`` decorator,\nin which case you must return a tuple of the cleaned values.\n\nLike ``@validates``,\n``@cleans`` functions may raise ``ValidationErrors``\n(usually by calling ``self.fail``).\n\nYou may also use ``@cleans`` without any arguments.\nIn this case the function will be passed a single argument,\nthe current value of ``self.data``,\nwhich it may mutate,\nor return a new dict of values\nto be merged into ``self.data``\n\nValidation running order\n------------------------\n\n- Validators bound to field objects are run first.\n\n- Then validation/cleaner functions declared with the\n  ``@validates``/``@cleans`` decorators.\n  These are run in the order they are declared,\n  with the exception that those any form-scope validators\n  are pushed to the end\n  and only run if all previous validation has passed.\n\nAny ``@validates``/``@cleans`` decorators take optional ``before`` or ``after``\narguments to force a particular run order.\n\n\nAn example::\n\n    class AForm(Form):\n\n        # The minlen validator is the first to be run\n        name = fields.Str(validators=[minlen(4)])\n\n        # Validator/cleaner functions are run next\n        # in the order they are declared\n        @validates(name)\n        def validate_name(self, name):\n            ...\n\n        @cleans(name)\n        def clean_name(self, name):\n            return name.strip()\n\n        # This is a form-scoped validator function, which will be run only\n        # after all field-scoped validators have been successfully passed\n        @validates\n        def validate_form(self, data):\n            ...\n\n        # This form-scoped validator will be run even if previous validation\n        # has failed. Failed fields will not have an entry in the ``data`` dict,\n        # so care should be taken not to raise KeyErrors.\n        @validates(run_always=True)\n        def validate_form2(self, data):\n            ...\n\n        # Thie ``before`` argument means this validator will run before\n        #  ``validate_form``, even though it was declared later in the file\n        @validates(before=validate_form)\n        def validate_form3(self, data):\n            ...\n\n\n\nBinding objects\n===============\n\nIf you have a form for editing an object\nand you want to prepopulate the form\nwith the existing values\nyou call ``bind_object``::\n\n    class UserEditForm(Form)\n\n        name = fields.Str()\n        email = fields.Str()\n\n    editform = UserEditForm()\n\n    # Binds existing values from `currentuser` to the form fields\n    editform.bind_object(currentuser())\n\nYou can override the binding of individual fields using keyword arguments.\nSuppose that the email address is not an attribute of the user\nobject, but needs to be accessed from a separate profile object::\n\n    editform.bind_object(currentuser(), email=currentuser().profile.email)\n\n\nAlternatively you could put this logic in the form class by overriding the\n``bind_object`` method::\n\n    class UserEditForm(Form)\n\n        name = fields.Str()\n        email = fields.Str()\n\n        def bind_object(self, user, *args, **kwargs):\n            super(UserEditForm, self).bind_object(\n                    user, email=user.profile.email, *args, **kwargs)\n\n\nA common pattern is for forms to know how to update model objects, which you\nmight think of as the inverse of bind_object.\n\n``update_object`` is used for this, for example::\n\n    form = BookingForm(request.POST)\n    if form.isvalid:\n        booking = Booking()\n        form.update_object(booking)\n        session.add(booking)\n\n\nThe default implementation of bind_object is very naive, and just copies the\nsubmitted field data over to correspondingly named properties on the model\nobject. You will probably need to override this.\n\nBinding submitted data\n======================\n\nWhen a user has submits a form, you need to validate it and extract the\nprocessed information. The easiest way is to pass the submitted data in the\nconstructor::\n\n\n    form = BookingForm(request.POST)\n\nAny dict like object can be passed here. You can also pass keyword\narguments, which will also be bound to fields::\n\n    form = BookingForm(request.POST, booked_by=currentuser().id)\n\nYou can also call ``Form.bind_input`` explicitly::\n\n    form = BookingForm()\n    form.bind_input(request.POST)\n\nCalling ``Form.bind_input`` (or passing form data to the constructor)\nautomatically triggers all validation rules to be run.\nOverride this by specifying ``validate=False``::\n\n    form = BookingForm()\n    form.bind_input(request.POST, validate=False)\n\n\n1.0.0 (released 2020-02-28)\n---------------------------\n\n- Dropped support for Python <3.6\n- Added support for Python 3.7, 3.8\n- Added ``RenderOptions.control_template`` for wrapping / extending rendering\n  of widgets\n- Keyword arguments to Fields beginning with ``widget_`` are used to set\n  corresponding keys in the widget's ``attr`` dict, so you can now do\n  ``fields.Str(widget_placeholder='blah')``.\n- Keyword arguments to ``Form.__init__`` are now passed through to ``Form.bind_input``\n\n0.2.9 (released 2018-09-12)\n---------------------------\n\n- ``Form.bind_object`` and ``Form.bind_input`` now return the form object\n\n0.2.8 (released 2018-02-17)\n---------------------------\n\n- Added support for html 5 input required attribute\n\n0.2.7 (released 2015-08-11)\n---------------------------\n\n- Added caching of the Jinja2 templates used for generating HTML,\n  improving form rendering performance.\n\n0.2.6\n-----\n\n- Added widgets.HiddenJSON, allowing hidden fields to contain\n  structured data\n\n0.2.5\n-----\n\n- fields now have a 'hidden' argument in the constructor, eg\n  ``myfield = fields.Int(hidden=True)``.\n- fields.Int and fields.Decimal are now rendered by a <input type=\"number\">\n  control by default.\n- Bugfix: calling copy() on a form object copies over all fields, including\n  those added at runtime via Form.add_field.\n\n0.2.4\n-----\n\n- Widgets now have access to the ``field.value``, not just the string\n  representation in ``field.raw``.\n- Removed the ``**kwargs`` argument from Form.__init__. If you need to\n  call bind_input with keyword arguments you must now do so explicitly\n  in a separate call to bind_input.\n\n0.2.3\n-----\n\n- The HTML rendering for radio and checkbox widgets has been changed to make\n  it possible to target the label of checked inputs in CSS.\n- Bugfix: calling ``FormRenderer.visible()`` after ``FormRenderer.pop()``\n  no longer causes an error.\n\n0.2.2\n-----\n\n- An ``after`` argument was added to the @cleans and @validates decorators\n  to force a validation/cleaning function to run after another has already\n  completed.\n- @cleans and @validates functions are no longer called if associated with\n  fields that have failed a previous validation check.\n- Added ``Form.add_field`` and ``Form.remove_field`` for manipulating fields\n  dynamically\n\n0.2.1\n-----\n\n- Bound form fields are now only accessible via the ``Form.fields`` dictionary.\n  This removes the need to maintain two synchronized mapppings of form fields.\n- Form.bind_object no longer requires a positional argument and can now also\n  accept dictionaries as arguments\n- Bugfix: Choice fields no longer raise ``ValidationError``\\s if ``None`` or\n  the empty string are used as choice values\n\n\n0.2\n---\n\n- All ``render_*`` methods now return ``markupsafe.Markup`` objects\n- An ``exclude`` argument was added to the default ``Form.update_object``\n  implementation, allowing subclasses to more easily override the updating of\n  specific attributes, and allowing ``Form.update_object`` to manage the\n  remainder.\n\n\n0.1\n---\n\n- Initial release\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://ollycope.com/software/morf/", "keywords": "form,forms,validation,schema,html", "license": "Apache", "maintainer": "", "maintainer_email": "", "name": "morf", "package_url": "https://pypi.org/project/morf/", "platform": "", "project_url": "https://pypi.org/project/morf/", "project_urls": {"Homepage": "https://ollycope.com/software/morf/"}, "release_url": "https://pypi.org/project/morf/1.0.0/", "requires_dist": ["python-dateutil", "markupsafe", "jinja2"], "requires_python": "", "summary": "HTML Form Validation and Rendering", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"morf-html-form-validation-and-rendering\">\n<h2>Morf - HTML form validation and rendering</h2>\n<h2 id=\"why-use-morf\"><span class=\"section-subtitle\">Why use morf?</span></h2>\n<p>Because you want to express simple forms concisely:</p>\n<pre>from morf import HTMLForm, fields, validators\n\nclass ContactForm(HTMLForm):\n    name = fields.Str(message='Please fill in your name')\n    email = fields.Str(validators=[validators.is_email])\n    message = fields.Str(validators=[validators.minwords(10)])\n</pre>\n<p>Because you want to be able to express custom validation logic:</p>\n<pre>class BookingForm(HTMLForm):\n    name = fields.Str(message='Please fill in your name')\n    arrival_date = fields.Date()\n    leaving_date = fields.Date()\n\n    @validates(arrival_date, leaving_date)\n    def check_name(self, arrival_date, leaving_date):\n\n        # No minimum booking duration at weekends\n        if arrival_date.weekday() in (SAT, SUN):\n            return\n\n        if (leaving_date - arrival_date).days &lt; 3:\n            self.fail('Sorry, the minimum booking is for 3 days')\n</pre>\n<p>Because you want a simple API to work with:</p>\n<pre>def my_view(request):\n    form = BookingForm(request.POST)\n    if form.isvalid:\n        make_booking(form.data)\n        ...\n    else:\n        show_error_page(errors=form.errors)\n</pre>\n<p>Documentation for morf is available at <a href=\"https://ollycope.com/software/morf/\" rel=\"nofollow\">https://ollycope.com/software/morf/</a></p>\n<p>Morf\u2019s source code is available at <a href=\"https://bitbucket.org/ollyc/morf/\" rel=\"nofollow\">https://bitbucket.org/ollyc/morf/</a></p>\n</div>\n<div id=\"rendering-forms-with-widgets\">\n<h2>Rendering forms with widgets</h2>\n<p>Morf separates form processing - taking user input and validating it, and\nhandling any ensuing application logic - from the business of rendering HTML\nforms and parsing HTML form encoded data.</p>\n<p>If your form is always going to be rendered as an HTML form, just\nsubclass HTMLForm, and you can use the rendering methods directly:</p>\n<pre>class BookingForm(HTMLForm):\n    name = fields.Str(message='Please fill in your name')\n    email = fields.Str(validators=[is_email])\n    arrival_date = fields.Date()\n    leaving_date = fields.Date()\n\nbookingform = BookingForm()\nbookingform.as_p().render()\n</pre>\n<p>Forms processing data coming from sources other than HTML form submissions\nshould subclass <tt>morf.Form</tt>.</p>\n<p>If you also want your form to be rendered or submitted in HTML,\nuse <tt>HTMLForm.adapt</tt>:</p>\n<pre>from morf import Form, HTMLForm\n\nclass BookingForm(Form):\n    name = fields.Str(message='Please fill in your name')\n    email = fields.Str(validators=[is_email])\n    arrival_date = fields.Date()\n    leaving_date = fields.Date()\n\nHTMLBookingForm = HTMLForm.adapt(BookingForm)\nHTMLBookingForm().as_p().render()\n</pre>\n<div id=\"rendering-field-groups\">\n<h3>Rendering field groups</h3>\n<p>Select groups of fields for rendering\nusing the <tt>select\u2026</tt> methods on any\nFormRenderer object.</p>\n<p><strong>``select``</strong> returns just the named fields, eg:</p>\n<pre>&lt;h1&gt;Personal details&lt;/h1&gt;\n{% for field in form.select(['firstname', 'lastname', 'email']) %}\n    {{ field.render() }}\n{% endfor %}\n\n&lt;h1&gt;Address&lt;/h1&gt;\n{% for field in form.select(['housenumber', 'street', 'city', 'zip']) %}\n    {{ field.render() }}\n{% endfor %}\n</pre>\n<p>Note that <tt>select</tt> won\u2019t raise an exception\nif you pass it an invalid field name,\nit will just skip that field.\nUse <tt><span class=\"pre\">select([\u2026],</span> strict=True)</tt> if you want strict fieldname checking.</p>\n<p><strong>``select_except``</strong> returns all the fields except those listed, eg:</p>\n<pre>{% for field in form.select_except(['account_type']) %}\n    {{ field.render() }}\n{% endfor %}\n</pre>\n<p><strong>``select_to``</strong> returns all the fields up to\n(but not including) the named field:</p>\n<pre>{% for field in form.select_to(['housenumber']) %}\n    {{ field.render() }}\n{% endfor %}\n</pre>\n<p><strong>``select_match``</strong> returns all fields matching a given regular expression:</p>\n<pre>&lt;h1&gt;Shipping&lt;/h1&gt;\n{% for field in form.select_match(r'shipping_.*') %}\n    {{ field.render() }}\n{% endfor %}\n\n&lt;h1&gt;Billing details&lt;/h1&gt;\n{% for field in form.select_match(r'billing_.*') %}\n    {{ field.render() }}\n{% endfor %}\n</pre>\n</div>\n<div id=\"htmlform\">\n<h3>HTMLForm</h3>\n<p>The <tt>HTMLForm</tt> class has two important differences over <tt>Form</tt>.</p>\n<p>Firstly,\n<strong>HTMLForm has preconfigured rendering options for generating HTML</strong>.\nThese can be used to render the whole form with fields being wrapped in\n<tt><span class=\"pre\">&lt;p&gt;...&lt;/p&gt;</span></tt> elements, <tt>&lt;ul&gt;</tt>, <tt>&lt;ol&gt;</tt> or as a table:</p>\n<pre>form.as_p().render()\n\nform.as_ul().render()\n\nform.as_ol().render()\n\nform.as_table().render()\n</pre>\n<p>The <tt>HTMLForm.renderer</tt> method lets you customize the rendering templates:</p>\n<pre>form.renderer(row_template='&lt;div&gt;{{ field }}&lt;/div&gt;')\n</pre>\n<p>Secondly,\n<strong>HTMLForm adapts nested forms to work with flat HTML forms</strong>.\nIf you have a form like this, which expects nested data:</p>\n<pre>class PlayerForm(HTMLForm):\n    last_name = fields.Str()\n    first_name = fields.Str()\n\nclass TeamForm(HTMLForm):\n    team_name = fields.Str()\n    players = fields.ListOf(PlayerForm(), label='Players', spare=2, max=5)\n</pre>\n<p>HTMLForm knows how to render this to create HTML inputs like this:</p>\n<pre>&lt;input name=\"team_name\" type=\"text\" /&gt;\n&lt;input name=\"players#0.name\" type=\"text\" /&gt;\n&lt;input name=\"players#0.age\" type=\"text\" /&gt;\n&lt;input name=\"players#1.name\" type=\"text\" /&gt;\n&lt;input name=\"players#1.age\" type=\"text\" /&gt;\n\u2026\n</pre>\n<p>And can then convert the corresponding form submission values into the required\ndata structure, eg:</p>\n<pre>{'team_name': 'Surprise!',\n 'players': [\n    {'name': 'alice',  'age': 8},\n    {'name': 'bob', 'age': 7},\n    \u2026\n]}\n</pre>\n</div>\n<div id=\"widgets\">\n<h3>Widgets</h3>\n<p>Morf defines various widgets for rendering different HTML field controls.\nSpecify the widget you want when constructing the field:</p>\n<pre>class ContactForm(Form):\n\n    message = field.Str(widget=widgets.Textarea())\n</pre>\n<p>If you don\u2019t specify a widget, the default widget type for that field will be\nused.</p>\n<p>Read the source code for <tt>morf.widgets</tt> to see the full list of available\nwidgets.</p>\n</div>\n</div>\n<div id=\"fields\">\n<h2>Fields</h2>\n<p>Morf offers various builtin field types:</p>\n<ul>\n<li><tt>morf.fields.Str</tt></li>\n<li><tt>morf.fields.Int</tt></li>\n<li><tt>morf.fields.Decimal</tt></li>\n<li><tt>morf.fields.Date</tt></li>\n<li><tt>morf.fields.DateTime</tt></li>\n<li><tt>morf.fields.Bool</tt></li>\n<li><tt>morf.fields.MultipleChoice</tt></li>\n<li><tt>morf.fields.ListOf</tt>, a container for creating lists of other fields</li>\n</ul>\n<p>Additionally, <tt>morf.form.Form</tt> can also be used as a field. Typically\nyou would use this to generate nested structures, eg:</p>\n<pre>class PlayerForm(HTMLForm):\n    last_name = fields.Str()\n    first_name = fields.Str()\n\nclass TeamForm(HTMLForm):\n    team_name = fields.Str()\n    players = fields.ListOf(PlayerForm(), label='Players', spare=2, max=5)\n</pre>\n<p>Field classes take the following standard constructor arguments:</p>\n<dl>\n<dt>name</dt>\n<dd>The name of the field (eg \u2018last_name\u2019)</dd>\n<dt>displayname</dt>\n<dd>The name to display to the user (eg \u2018last name\u2019)\nwhen referencing the field.\nIf not specified this will be generated from <tt>name</tt></dd>\n<dt>label</dt>\n<dd>The label to show for the field\n(eg \u2018Please enter your last name\u2019).\nIf not specified <tt>displayname</tt> will be used.</dd>\n<dt>empty_message</dt>\n<dd>The error to display when the field has not been filled in</dd>\n<dt>invalid_message</dt>\n<dd>The error to display when the field contains invalid data</dd>\n<dt>default</dt>\n<dd>A default value for the field</dd>\n<dt>processors</dt>\n<dd>A list of processors. See the <a href=\"#processors\" rel=\"nofollow\">Processors</a> section below</dd>\n<dt>validators</dt>\n<dd>A list of validators. See the <a href=\"#validators\" rel=\"nofollow\">Validators</a> section below</dd>\n<dt>widget</dt>\n<dd>The widget to use when rendering as HTML</dd>\n<dt>choices</dt>\n<dd>A list of choices that the value must be selected from.\nSee the <a href=\"#choices\" rel=\"nofollow\">Choices</a> section below.</dd>\n<dt>validate_choices</dt>\n<dd>If <tt>choices</tt> has been set, the submitted value is tested\nto ensure it is a valid item from the list of choices.\nDefaults to <tt>True</tt>, set this to <tt>False</tt> to disable this check.</dd>\n</dl>\n<div id=\"choices\">\n<h3>Choices</h3>\n<p>Fields can require a value to be selected from a list of valid choices.\nTypically this might be represented as radio buttons or a select control.\nChoices can be supplied in a variety of ways:</p>\n<pre>class UserPreferencesForm(HTMLForm):\n\n    # Choices can be a list of (value, label) tuples\n    favorite_color = fields.Str(choices=[('#ff0000', 'Red'),\n                                         ('#0000ff', 'Blue')],\n                                 widget=widgets.RadioGroup())\n\n    # ...or a list of values doubling as labels\n    current_mood = fields.Str(choices=['happy', 'frustrated'],\n                              widget=widgets.RadioGroup())\n\n    # ...or a callable returning either of the two above formats\n    shoe_size = fields.Str(choices=range(1, 13),\n                        widget=widgets.Select)\n\n    # ...or the name of a method on the form object\n    preferred_vegetable = fields.Str(choices='get_vegetables',\n                                    widget=widgets.RadioGroup())\n\n    def get_vegetables(self):\n        return ['turnip', 'leek', 'potato']\n</pre>\n</div>\n<div id=\"choices-and-optgroups\">\n<h3>Choices and optgroups</h3>\n<p>Choices can be hierarchical, for example:</p>\n<pre>from morf import choices\n\nsoups = [(0, 'Minestrone'), (1, 'French onion')]\nsalads = [(2, 'Tomato salad'), (3, 'Greek salad')]]\n\nclass MenuForm(HTMLForm):\n\n    lunch = fields.Choice(choices=[('Soups', choices.OptGroup(soups)),\n                                   ('Salads', choices.OptGroup(soups))])\n</pre>\n<p>When rendered, the lunch field will be displayed as\nan HTML <tt>&lt;select&gt;</tt> element containing <tt>&lt;optgroup&gt;</tt> elements, eg:</p>\n<pre>&lt;select name=\"lunch\"&gt;\n    &lt;optgroup label=\"Soups\"&gt;\n        &lt;option value=\"0\"&gt;Minestrone&lt;/option&gt;\n        &lt;option value=\"1\"&gt;French onion&lt;/option&gt;\n    &lt;/optgroup&gt;\n    &lt;optgroup label=\"Salads\"&gt;\n        &lt;option value=\"0\"&gt;Tomato salad&lt;/option&gt;\n        &lt;option value=\"1\"&gt;Greek salad&lt;/option&gt;\n    &lt;/optgroup&gt;\n&lt;/select&gt;\n</pre>\n<p>When using radio buttons or checkbox widgets,\n<tt>OptGroups</tt> are rendered inside a <tt>&lt;fieldset&gt;</tt> element.</p>\n</div>\n<div id=\"dynamic-fields\">\n<h3>Dynamic fields</h3>\n<p>Fields can be added dynamically using <tt>@property</tt>:</p>\n<pre>class FormWithDynamicFields(HTMLForm):\n\n    @property\n    def milk_and_sugar(self):\n        from datetime import datetime\n        beverage = 'coffee' if (datetime.now().hour &lt; 13) else 'tea'\n        return fields.Choice(\n                label='How would you like your {}?'.format(beverage),\n                choices=['With milk', 'With sugar', 'With milk and sugar'])\n</pre>\n<p>If you need more flexibility use the <tt>add_fields</tt> and <tt>remove_fields</tt>\nmethods to manipulate the <tt>fields</tt> dict.\nThe <tt>before</tt> or <tt>after</tt> arguments\nallow you to control the ordering of added fields:</p>\n<pre>class FormWithDynamicFields(HTMLForm):\n\n    def __init__(self, *args, **kwargs):\n        beverage = kwargs.pop('beverage')\n        super(FormWithDynamicFields, self).__init__(*args, **kwargs)\n        self.add_field('milk_and_sugar',\n                        fields.Choice(\n                        label='How would you like your {}?'.format(\n                                                              beverage),\n                        choices=['with milk',\n                                 'with sugar',\n                                 'with milk and sugar']),\n                        before='biscuit_preference')\n</pre>\n</div>\n<div id=\"error-messages\">\n<h3>Error messages</h3>\n<p>Fields can have separate messages specified for empty or invalid data:</p>\n<pre>field.Str(empty_message='Choose your new password ',\n          invalid_message='Passwords must be at least 8 characters')\n</pre>\n<p>You can specify both at once:</p>\n<pre>field.Str(message='Choose a new password of at least 8 characters')\n</pre>\n<p>Validators can also have error messages:</p>\n<pre>field.Str(message='Please enter your length of stay',\n          validators=[gt(1, 'You must stay at least one night'),\n                      lte(28, 'Rooms cannot be booked for over 28 days')])\n</pre>\n</div>\n</div>\n<div id=\"processors\">\n<h2>Processors</h2>\n<p>Value processors are run after type conversion but before validation and can\nbe used for normalizing data input before validation:</p>\n<pre>def foldcase(s):\n    return s.lower()\n\ndef strip_non_digits(s):\n    return re.sub(r'[^\\d]', '', s)\n\nusername = field.Str(processors=[foldcase])\naccount_no = field.Str(processors=[strip_non_digits])\n</pre>\n<p>When writing processors remember that you these should not perform any\nvalidation, so you should never raise ValidationError or any other exception\ninside a processor function.</p>\n</div>\n<div id=\"validators\">\n<h2>Validators</h2>\n<p>A validator can be any function or callable object taking the submitted field\nvalue and raising a ValidationError if it fails.</p>\n<p>To allow the validation parameters to be varied, the usual pattern is to\ndefine a factory function:</p>\n<pre>from morf.validation import assert_true\n\ndef contains(word, message='Invalid value'):\n    def validate_contains(value):\n        assert_true(word in value.lower(), message)\n    return validate_contains\n</pre>\n<p>Notice the use of assert_true.\nThis is exactly equivalent to:</p>\n<pre>if word not in value.lower():\n    raise ValidationError(message)\n</pre>\n<p>You can then use your validator by passing it in the <tt>validators</tt> list when\nconstructing a field:</p>\n<pre>field.Str(validators=[contains('please',\n                               message=\"What's the magic word?\")])\n</pre>\n<p>Use the <tt>@validates</tt> decorator to define a one-off custom validation\ncondition.\nThis takes one or more field names,\nand each named field is passed as an argument\nto the decorated validation function:</p>\n<pre>class BookingForm(Form):\n\n    ...\n\n    @validates(arrival_date, leaving_date)\n    def check_name(self, arrival_date, leaving_date):\n\n        # No minimum booking duration at weekends\n        if arrival_date.weekday() in (SAT, SUN):\n            return\n\n        if (leaving_date - arrival_date).days &lt; 3:\n            self.fail('Sorry, the minimum booking is for 3 days')\n</pre>\n<p>You can also use <tt>@validates</tt> without arguments,\nin which case the validation function is called without arguments\nand any errors raised are deemed to apply to the form as a whole:</p>\n<pre>@validates\ndef validate_entire_form(self, data):\n    ...\n</pre>\n<p>A variant of <tt>@validates</tt> is <tt>@cleans</tt>,\nwhich replaces the value of the first named field with\nthe return value of the function:</p>\n<pre>class BookingForm(Form):\n\n    ...\n\n    @cleans(card_number)\n    def normalize_card_number(self, card_number):\n\n        return card_number\\\n            .replace(' ', '')\n            .replace('-', '')\n            .strip()\n</pre>\n<p>You can specify multiple field names in the <tt>@cleans</tt> decorator,\nin which case you must return a tuple of the cleaned values.</p>\n<p>Like <tt>@validates</tt>,\n<tt>@cleans</tt> functions may raise <tt>ValidationErrors</tt>\n(usually by calling <tt>self.fail</tt>).</p>\n<p>You may also use <tt>@cleans</tt> without any arguments.\nIn this case the function will be passed a single argument,\nthe current value of <tt>self.data</tt>,\nwhich it may mutate,\nor return a new dict of values\nto be merged into <tt>self.data</tt></p>\n<div id=\"validation-running-order\">\n<h3>Validation running order</h3>\n<ul>\n<li>Validators bound to field objects are run first.</li>\n<li>Then validation/cleaner functions declared with the\n<tt>@validates</tt>/<tt>@cleans</tt> decorators.\nThese are run in the order they are declared,\nwith the exception that those any form-scope validators\nare pushed to the end\nand only run if all previous validation has passed.</li>\n</ul>\n<p>Any <tt>@validates</tt>/<tt>@cleans</tt> decorators take optional <tt>before</tt> or <tt>after</tt>\narguments to force a particular run order.</p>\n<p>An example:</p>\n<pre>class AForm(Form):\n\n    # The minlen validator is the first to be run\n    name = fields.Str(validators=[minlen(4)])\n\n    # Validator/cleaner functions are run next\n    # in the order they are declared\n    @validates(name)\n    def validate_name(self, name):\n        ...\n\n    @cleans(name)\n    def clean_name(self, name):\n        return name.strip()\n\n    # This is a form-scoped validator function, which will be run only\n    # after all field-scoped validators have been successfully passed\n    @validates\n    def validate_form(self, data):\n        ...\n\n    # This form-scoped validator will be run even if previous validation\n    # has failed. Failed fields will not have an entry in the ``data`` dict,\n    # so care should be taken not to raise KeyErrors.\n    @validates(run_always=True)\n    def validate_form2(self, data):\n        ...\n\n    # Thie ``before`` argument means this validator will run before\n    #  ``validate_form``, even though it was declared later in the file\n    @validates(before=validate_form)\n    def validate_form3(self, data):\n        ...\n</pre>\n</div>\n</div>\n<div id=\"binding-objects\">\n<h2>Binding objects</h2>\n<p>If you have a form for editing an object\nand you want to prepopulate the form\nwith the existing values\nyou call <tt>bind_object</tt>:</p>\n<pre>class UserEditForm(Form)\n\n    name = fields.Str()\n    email = fields.Str()\n\neditform = UserEditForm()\n\n# Binds existing values from `currentuser` to the form fields\neditform.bind_object(currentuser())\n</pre>\n<p>You can override the binding of individual fields using keyword arguments.\nSuppose that the email address is not an attribute of the user\nobject, but needs to be accessed from a separate profile object:</p>\n<pre>editform.bind_object(currentuser(), email=currentuser().profile.email)\n</pre>\n<p>Alternatively you could put this logic in the form class by overriding the\n<tt>bind_object</tt> method:</p>\n<pre>class UserEditForm(Form)\n\n    name = fields.Str()\n    email = fields.Str()\n\n    def bind_object(self, user, *args, **kwargs):\n        super(UserEditForm, self).bind_object(\n                user, email=user.profile.email, *args, **kwargs)\n</pre>\n<p>A common pattern is for forms to know how to update model objects, which you\nmight think of as the inverse of bind_object.</p>\n<p><tt>update_object</tt> is used for this, for example:</p>\n<pre>form = BookingForm(request.POST)\nif form.isvalid:\n    booking = Booking()\n    form.update_object(booking)\n    session.add(booking)\n</pre>\n<p>The default implementation of bind_object is very naive, and just copies the\nsubmitted field data over to correspondingly named properties on the model\nobject. You will probably need to override this.</p>\n</div>\n<div id=\"binding-submitted-data\">\n<h2>Binding submitted data</h2>\n<p>When a user has submits a form, you need to validate it and extract the\nprocessed information. The easiest way is to pass the submitted data in the\nconstructor:</p>\n<pre>form = BookingForm(request.POST)\n</pre>\n<p>Any dict like object can be passed here. You can also pass keyword\narguments, which will also be bound to fields:</p>\n<pre>form = BookingForm(request.POST, booked_by=currentuser().id)\n</pre>\n<p>You can also call <tt>Form.bind_input</tt> explicitly:</p>\n<pre>form = BookingForm()\nform.bind_input(request.POST)\n</pre>\n<p>Calling <tt>Form.bind_input</tt> (or passing form data to the constructor)\nautomatically triggers all validation rules to be run.\nOverride this by specifying <tt>validate=False</tt>:</p>\n<pre>form = BookingForm()\nform.bind_input(request.POST, validate=False)\n</pre>\n<div id=\"released-2020-02-28\">\n<h3>1.0.0 (released 2020-02-28)</h3>\n<ul>\n<li>Dropped support for Python &lt;3.6</li>\n<li>Added support for Python 3.7, 3.8</li>\n<li>Added <tt>RenderOptions.control_template</tt> for wrapping / extending rendering\nof widgets</li>\n<li>Keyword arguments to Fields beginning with <tt>widget_</tt> are used to set\ncorresponding keys in the widget\u2019s <tt>attr</tt> dict, so you can now do\n<tt><span class=\"pre\">fields.Str(widget_placeholder='blah')</span></tt>.</li>\n<li>Keyword arguments to <tt>Form.__init__</tt> are now passed through to <tt>Form.bind_input</tt></li>\n</ul>\n</div>\n<div id=\"released-2018-09-12\">\n<h3>0.2.9 (released 2018-09-12)</h3>\n<ul>\n<li><tt>Form.bind_object</tt> and <tt>Form.bind_input</tt> now return the form object</li>\n</ul>\n</div>\n<div id=\"released-2018-02-17\">\n<h3>0.2.8 (released 2018-02-17)</h3>\n<ul>\n<li>Added support for html 5 input required attribute</li>\n</ul>\n</div>\n<div id=\"released-2015-08-11\">\n<h3>0.2.7 (released 2015-08-11)</h3>\n<ul>\n<li>Added caching of the Jinja2 templates used for generating HTML,\nimproving form rendering performance.</li>\n</ul>\n</div>\n<div id=\"id1\">\n<h3>0.2.6</h3>\n<ul>\n<li>Added widgets.HiddenJSON, allowing hidden fields to contain\nstructured data</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>0.2.5</h3>\n<ul>\n<li>fields now have a \u2018hidden\u2019 argument in the constructor, eg\n<tt>myfield = fields.Int(hidden=True)</tt>.</li>\n<li>fields.Int and fields.Decimal are now rendered by a &lt;input type=\u201dnumber\u201d&gt;\ncontrol by default.</li>\n<li>Bugfix: calling copy() on a form object copies over all fields, including\nthose added at runtime via Form.add_field.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>0.2.4</h3>\n<ul>\n<li>Widgets now have access to the <tt>field.value</tt>, not just the string\nrepresentation in <tt>field.raw</tt>.</li>\n<li>Removed the <tt>**kwargs</tt> argument from Form.__init__. If you need to\ncall bind_input with keyword arguments you must now do so explicitly\nin a separate call to bind_input.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>0.2.3</h3>\n<ul>\n<li>The HTML rendering for radio and checkbox widgets has been changed to make\nit possible to target the label of checked inputs in CSS.</li>\n<li>Bugfix: calling <tt>FormRenderer.visible()</tt> after <tt>FormRenderer.pop()</tt>\nno longer causes an error.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3>0.2.2</h3>\n<ul>\n<li>An <tt>after</tt> argument was added to the @cleans and @validates decorators\nto force a validation/cleaning function to run after another has already\ncompleted.</li>\n<li>@cleans and @validates functions are no longer called if associated with\nfields that have failed a previous validation check.</li>\n<li>Added <tt>Form.add_field</tt> and <tt>Form.remove_field</tt> for manipulating fields\ndynamically</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3>0.2.1</h3>\n<ul>\n<li>Bound form fields are now only accessible via the <tt>Form.fields</tt> dictionary.\nThis removes the need to maintain two synchronized mapppings of form fields.</li>\n<li>Form.bind_object no longer requires a positional argument and can now also\naccept dictionaries as arguments</li>\n<li>Bugfix: Choice fields no longer raise <tt>ValidationError</tt>s if <tt>None</tt> or\nthe empty string are used as choice values</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3>0.2</h3>\n<ul>\n<li>All <tt>render_*</tt> methods now return <tt>markupsafe.Markup</tt> objects</li>\n<li>An <tt>exclude</tt> argument was added to the default <tt>Form.update_object</tt>\nimplementation, allowing subclasses to more easily override the updating of\nspecific attributes, and allowing <tt>Form.update_object</tt> to manage the\nremainder.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3>0.1</h3>\n<ul>\n<li>Initial release</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6717139, "releases": {"0": [], "0.1": [{"comment_text": "", "digests": {"md5": "60d384344bfd291a773eb126fa0c3940", "sha256": "e8f74546671082acee476a77714b78daf2c1996c20cb973aa9528d155e5c26f6"}, "downloads": -1, "filename": "morf-0.1.tar.gz", "has_sig": false, "md5_digest": "60d384344bfd291a773eb126fa0c3940", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36198, "upload_time": "2014-07-09T12:38:59", "upload_time_iso_8601": "2014-07-09T12:38:59.366539Z", "url": "https://files.pythonhosted.org/packages/10/55/efa912a3c131fc99dad5060afdc81c85622cefd6cf126d45e72e18c77e93/morf-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "a57e2c5934994ca3877fc44b081aece9", "sha256": "2f938ed4aa051ccb2bfebec33ec9eae288f77d40ab379511c07a37c3dbf15630"}, "downloads": -1, "filename": "morf-0.2.tar.gz", "has_sig": false, "md5_digest": "a57e2c5934994ca3877fc44b081aece9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36457, "upload_time": "2014-07-14T15:25:52", "upload_time_iso_8601": "2014-07-14T15:25:52.579827Z", "url": "https://files.pythonhosted.org/packages/2f/ef/a005dc7ae82e06ce4570176edc524224ec920ba66a6096ae2baff7b1ca86/morf-0.2.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "854acef5a332bde9676aca9133510f83", "sha256": "cf5b0654651ca129dac9800a2653aac4276cdd9a50fc5b64ffd0a8f483edc278"}, "downloads": -1, "filename": "morf-0.2.1.tar.gz", "has_sig": false, "md5_digest": "854acef5a332bde9676aca9133510f83", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37554, "upload_time": "2014-09-20T14:20:37", "upload_time_iso_8601": "2014-09-20T14:20:37.874101Z", "url": "https://files.pythonhosted.org/packages/70/89/e6fca4e3219f17d85f6d58b6c44d7af00daed84b7a240880f16c718fa7a2/morf-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "78e5c984a68855eef25743e6723b46f1", "sha256": "a1075b2dba1b2bbe858abda95acc931f4536970b6fb071ee24e5f3baac8235a1"}, "downloads": -1, "filename": "morf-0.2.2.tar.gz", "has_sig": false, "md5_digest": "78e5c984a68855eef25743e6723b46f1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38769, "upload_time": "2014-11-09T13:34:51", "upload_time_iso_8601": "2014-11-09T13:34:51.503492Z", "url": "https://files.pythonhosted.org/packages/54/8b/523074557b9eafa8c0e6f1c86ef7517380499a987878aaeada2e01c17ad8/morf-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "ccfa3c7afe92faa099c8147fae4cb2f5", "sha256": "8ebcb2c307054308270f016e46cc9d054b0ded472c366ea20d2013ae8a7bf808"}, "downloads": -1, "filename": "morf-0.2.3.tar.gz", "has_sig": false, "md5_digest": "ccfa3c7afe92faa099c8147fae4cb2f5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38938, "upload_time": "2014-11-27T10:52:37", "upload_time_iso_8601": "2014-11-27T10:52:37.419178Z", "url": "https://files.pythonhosted.org/packages/7b/e6/22819fc4fde3a73adda5eb541485bcb03a8d77386403a08f793ed9a6ada7/morf-0.2.3.tar.gz", "yanked": false}], "0.2.4": [{"comment_text": "", "digests": {"md5": "fd374115bc72ee7bf83d3b6aaeeba972", "sha256": "d905bb5e531511a84b6e1ee3d328424fb61bf160ce84aea27e07e3e29b2e8826"}, "downloads": -1, "filename": "morf-0.2.4.tar.gz", "has_sig": false, "md5_digest": "fd374115bc72ee7bf83d3b6aaeeba972", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39481, "upload_time": "2015-02-16T19:30:17", "upload_time_iso_8601": "2015-02-16T19:30:17.850768Z", "url": "https://files.pythonhosted.org/packages/90/99/44f7cef7d145e9deca590f7e1a437f7130184839a487f201d606623b9f62/morf-0.2.4.tar.gz", "yanked": false}], "0.2.5": [{"comment_text": "", "digests": {"md5": "3fd13d3a0382c801a98d057258ffbc68", "sha256": "e1d241fd109ad146f47d1a57cb030b39e6c60bd8d76cfe2860467c5d627d0f77"}, "downloads": -1, "filename": "morf-0.2.5.tar.gz", "has_sig": false, "md5_digest": "3fd13d3a0382c801a98d057258ffbc68", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40043, "upload_time": "2015-02-26T22:31:57", "upload_time_iso_8601": "2015-02-26T22:31:57.633547Z", "url": "https://files.pythonhosted.org/packages/52/d3/0600ce7c44641b2263f3a93d461e771a2db215ec833c42c4403c92dafd6d/morf-0.2.5.tar.gz", "yanked": false}], "0.2.6": [{"comment_text": "", "digests": {"md5": "d7ed0fe77e3ba1caf835ceb7acaab1b2", "sha256": "5eabf71f89ee7a7d6586d8928542cb013212fd689e352570cc61ec6ccb3e5055"}, "downloads": -1, "filename": "morf-0.2.6.tar.gz", "has_sig": false, "md5_digest": "d7ed0fe77e3ba1caf835ceb7acaab1b2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40384, "upload_time": "2015-06-22T11:05:05", "upload_time_iso_8601": "2015-06-22T11:05:05.168457Z", "url": "https://files.pythonhosted.org/packages/ac/e1/deedac9859ed945012f5720a8d49ac6bac08cd19403ead8e7931f33aab38/morf-0.2.6.tar.gz", "yanked": false}], "0.2.7": [{"comment_text": "", "digests": {"md5": "993b2d97f3d9bd97c61c49eb40a787c8", "sha256": "048e8963b5d8fb4232354ec5f78872f2b2f64693301a6d8b1f0a1e6a5eb69453"}, "downloads": -1, "filename": "morf-0.2.7.tar.gz", "has_sig": false, "md5_digest": "993b2d97f3d9bd97c61c49eb40a787c8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40548, "upload_time": "2015-08-11T11:01:02", "upload_time_iso_8601": "2015-08-11T11:01:02.667152Z", "url": "https://files.pythonhosted.org/packages/07/ac/fbf54824d811e2f71696458d5ca7fbfa88561d3d17ae9ad3d48e1458b5c0/morf-0.2.7.tar.gz", "yanked": false}], "0.2.8": [{"comment_text": "", "digests": {"md5": "a758f5e0abc8bb091250b0b3adbb6c9f", "sha256": "1061e430bd71587541ac325de1bc8c62266c79152c1d9e8435900cad8773d77c"}, "downloads": -1, "filename": "morf-0.2.8-py2-none-any.whl", "has_sig": false, "md5_digest": "a758f5e0abc8bb091250b0b3adbb6c9f", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 45579, "upload_time": "2018-02-17T19:22:31", "upload_time_iso_8601": "2018-02-17T19:22:31.684512Z", "url": "https://files.pythonhosted.org/packages/47/6d/b3adb288d967f3145a280eca7b3f50802818465ac8cffc5ed38e72c22ac0/morf-0.2.8-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1dfebe10954b2103bb33f0d60a68d09e", "sha256": "2af84a4f09e6af24fcae6e1fe77f431d229ba2cbe711f3c53da682e42bea3a5b"}, "downloads": -1, "filename": "morf-0.2.8.tar.gz", "has_sig": false, "md5_digest": "1dfebe10954b2103bb33f0d60a68d09e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34629, "upload_time": "2018-02-17T19:22:33", "upload_time_iso_8601": "2018-02-17T19:22:33.381986Z", "url": "https://files.pythonhosted.org/packages/2d/f2/5605ed3f16be67d5090520da57ca53284234f007e101cac3cfa490fe2743/morf-0.2.8.tar.gz", "yanked": false}], "0.2.9": [{"comment_text": "", "digests": {"md5": "937697dc1e5aa826058c4a9353df1211", "sha256": "d83c73474cb9d4faf5c264b307affddf38d3dc55e1bf5c135169669534ae4b85"}, "downloads": -1, "filename": "morf-0.2.9-py3-none-any.whl", "has_sig": false, "md5_digest": "937697dc1e5aa826058c4a9353df1211", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 45581, "upload_time": "2018-09-12T08:02:33", "upload_time_iso_8601": "2018-09-12T08:02:33.884752Z", "url": "https://files.pythonhosted.org/packages/da/9b/27f6982e2d6d2756aeddaeb7b649dca1e0bd6af9ab9a1ee0376728e603ad/morf-0.2.9-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "55eb3ad28fc447b4d371f1762aacab1c", "sha256": "54debef01810f869ab63608c672e745773e80f6b2bc0c558798da774588c50df"}, "downloads": -1, "filename": "morf-0.2.9.tar.gz", "has_sig": false, "md5_digest": "55eb3ad28fc447b4d371f1762aacab1c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36832, "upload_time": "2018-09-12T08:02:35", "upload_time_iso_8601": "2018-09-12T08:02:35.675679Z", "url": "https://files.pythonhosted.org/packages/56/d6/c338b2fa63451e2037d890f50a1cf4cdbf0fcb10c9b90493cd8093c1eac0/morf-0.2.9.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "b2685b2e470fcc2ac262c8bd246d095e", "sha256": "db788e5d39fab3f7e0785be9751e972b1591d704bc1d87116f3c1a1bde74073f"}, "downloads": -1, "filename": "morf-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b2685b2e470fcc2ac262c8bd246d095e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 46156, "upload_time": "2020-02-28T13:09:26", "upload_time_iso_8601": "2020-02-28T13:09:26.302074Z", "url": "https://files.pythonhosted.org/packages/87/75/3302bb96059ded5b90be0849194c2864635eeb060ea1d72a7401eaf8bc3c/morf-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6aaf67ea5cb32e2ab8c1e93d53953b9d", "sha256": "dadfe6dbe2c731c09ef98de58991407be6a62780a8abeca4eb6489d8942884f2"}, "downloads": -1, "filename": "morf-1.0.0.tar.gz", "has_sig": false, "md5_digest": "6aaf67ea5cb32e2ab8c1e93d53953b9d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42192, "upload_time": "2020-02-28T13:09:28", "upload_time_iso_8601": "2020-02-28T13:09:28.200036Z", "url": "https://files.pythonhosted.org/packages/d0/3d/230febd2009fe0fe2e28652f2955e2b9a3c28cdeb38044b7e747aa52d661/morf-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b2685b2e470fcc2ac262c8bd246d095e", "sha256": "db788e5d39fab3f7e0785be9751e972b1591d704bc1d87116f3c1a1bde74073f"}, "downloads": -1, "filename": "morf-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b2685b2e470fcc2ac262c8bd246d095e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 46156, "upload_time": "2020-02-28T13:09:26", "upload_time_iso_8601": "2020-02-28T13:09:26.302074Z", "url": "https://files.pythonhosted.org/packages/87/75/3302bb96059ded5b90be0849194c2864635eeb060ea1d72a7401eaf8bc3c/morf-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6aaf67ea5cb32e2ab8c1e93d53953b9d", "sha256": "dadfe6dbe2c731c09ef98de58991407be6a62780a8abeca4eb6489d8942884f2"}, "downloads": -1, "filename": "morf-1.0.0.tar.gz", "has_sig": false, "md5_digest": "6aaf67ea5cb32e2ab8c1e93d53953b9d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42192, "upload_time": "2020-02-28T13:09:28", "upload_time_iso_8601": "2020-02-28T13:09:28.200036Z", "url": "https://files.pythonhosted.org/packages/d0/3d/230febd2009fe0fe2e28652f2955e2b9a3c28cdeb38044b7e747aa52d661/morf-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:48 2020"}