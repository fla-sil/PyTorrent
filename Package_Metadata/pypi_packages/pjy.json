{"info": {"author": "Hg", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Intended Audience :: Developers", "Intended Audience :: System Administrators", "License :: Public Domain", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3 :: Only", "Topic :: Text Processing :: Filters", "Topic :: Utilities"], "description": "pjy - JSON Python processor\n===========================\n\n``pjy`` is a command-line tool to process JSON data and execute queries on it.\nIt is a bit like `jq <https://stedolan.github.io/jq/>`_ but with a Python syntax for queries.\n\nUsage\n+++++\n\n    pjy [EXPR] [FILES]\n\n``pjy`` will read JSON data from ``FILES`` and print the evaluation result of the Python expression ``EXPR``.\n\nIf ``FILES`` is missing or is \"``-``\", pjy will use stdin.\n\nThe simplest expression to use, which outputs the input unchanged is \"``d``\" (for data).\n\nIt's possible to use multiple input files.\n\nExamples\n++++++++\n\nIn ``pjy``, expressions are also called \"filters\", as in ``jq``.\n\nJust pretty-print\n-----------------\n\n``d`` (short for \"data\") is the most basic filter, it represents the whole input::\n\n    pjy 'd'\n        {\"foo\":\"bar\",\"baz\":[1,2,3]}\n\nPrints::\n\n    {\n      \"foo\": \"bar\",\n      \"baz\": [\n        1,\n        2,\n        3\n      ]\n    }\n\nSelect a dict key\n-----------------\n\nThe filters are Python expressions, hence we can select a dict key::\n\n    pjy 'd[\"baz\"]'\n        {\"foo\":\"bar\",\"baz\":[1,2,3]}\n\nAlternatively, in ``pjy``, dicts keys are also attributes::\n\n    pjy 'd.baz'\n        {\"foo\":\"bar\",\"baz\":[1,2,3]}\n\nBoth filters will print::\n\n    [\n      1,\n      2,\n      3\n    ]\n\nIn case a key has a reserved name, like ``import`` (keyword) or ``keys`` (dict method), simply use the bracket form.\n\nDo a basic operation\n--------------------\n\nIt's possible to use everything that a Python expression can contain::\n\n    pjy '[i + 1 for i in d[\"baz\"]]'\n        {\"foo\":\"bar\",\"baz\":[1,2,3]}\n\nPrints::\n\n    [\n      2,\n      3,\n      4\n    ]\n\nLambda-placeholder\n------------------\n\nA special identifier, ``_`` can be used to create lambdas. This identifier will absorb most operations done to it and return a lambda applying them.\nThen, the returned lambda can be applied::\n\n    pjy 'map(_ + 1, d.baz)'\n        {\"foo\":\"bar\",\"baz\":[1,2,3]}\n\nIs equivalent to::\n\n    pjy 'map((lambda x: x + 1), d.baz)'\n        {\"foo\":\"bar\",\"baz\":[1,2,3]}\n\nWhich will print::\n\n    [\n      2,\n      3,\n      4\n    ]\n\nThe lambda-placeholder will absorb chained operations::\n\n    pjy 'map((_ + 1) * 2, d.baz)'\n        {\"foo\":\"bar\",\"baz\":[1,2,3]}\n\n\nWill result in::\n\n    [\n      4,\n      6,\n      8\n    ]\n\nAnd::\n\n    pjy 'map(_[1:3] * 2, d)'\n        {\"foo\":\"bar\",\"baz\":[1,2,3]}\n\nWill return::\n\n    {\n      \"foo\": \"arar\",\n      \"baz\": [\n        2,\n        3,\n        2,\n        3\n      ]\n    }\n\nPipe-like iteration\n-------------------\n\nThe pipe (``|``) can be used to iterate on a list, it accepts a function as right operand::\n\n    pjy 'd.baz | _ + 1'\n        {\"foo\":\"bar\",\"baz\":[1,2,3]}\n\nWhich prints::\n\n    [\n      2,\n      3,\n      4\n    ]\n\nIt also operates on a dict's values, and returns a dict::\n\n    pjy 'd | (lambda x: repr(x))'\n        {\"foo\":\"bar\",\"baz\":[1,2,3]}\n\nThe values are replaced by the right operand value, the keys are unchanged::\n\n    {\n      \"foo\": \"'bar'\",\n      \"baz\": \"[1, 2, 3]\"\n    }\n\nPartial placeholder\n-------------------\n\nIt's not possible to call a function on a placeholder, for example, ``len(_)`` will not work.\nHowever, it's possible to use the ``partial`` helper to prepare the function call::\n\n    pjy 'd | partial(len, _)'\n        {\"foo\":\"bar\",\"baz\":[1,2,3]}\n\nPrints::\n\n    {\n      \"foo\": 3,\n      \"baz\": 3\n    }\n\n``partial`` ressembles the ``functools.partial`` function: it returns a function wrapping the function passed as first argument.\nThe returned function will call the original function with the fixed arguments passed.\nThe difference is that lambda-placeholders can be passed, and they will be replaced by the wrapper's argument.\n\n``p`` is a short alias for the ``partial`` function which can be used in pjy expressions.\n\nImports\n-------\n\nIt's possible to import modules with the ``imp`` function::\n\n   pjy 'filter(p(imp(\"fnmatch\").fnmatch, _, \"f*\"), d.keys())'\n        {\"foo\":\"bar\",\"baz\":[1,2,3]}\n\nWill print::\n\n    [\n      \"foo\"\n    ]\n\nThe ``math`` and ``re`` modules are already imported and available directly without having to call ``imp``.\n\nMultiple inputs\n---------------\n\nIn ``pjy``, an ``inputs`` variable exists, which is a list containing the JSON data of each input file passed on the command line.\nThe ``d`` variable is simply an alias to ``inputs[0]``.\n\nFor example::\n\n    pjy 'filter(_[0] != _[1], zip(inputs[0], inputs[1]))' before.json after.json\n\nwill read 2 files ``before.json`` and ``after.json``, which consist in a list of objects, and ``pjy`` will compare each zipped-pair of objects together.\nThen it will print the list of differing pairs.\n\n\nSecurity\n++++++++\n\n``pjy`` by itself does not write files (except stdout/stderr) or sockets, or run external commands.\nHowever, ``pjy`` runs the given expressions passed as argument, in the Python interpreter, without a sandbox.\nHence, do NOT pass dangerous or untrusted Python expressions to ``pjy``.\n\nDependencies\n++++++++++++\n\n``pjy`` is written in Python 3. Its ``setup.py`` requires ``setuptools``.\n\nIf ``pygments`` is installed, ``pjy``'s output will be colorized, but it's entirely optional.\n\nVersion and license\n+++++++++++++++++++\n\n.. $version\n\n``pjy`` is at version 0.10.0, it uses `semantic versioning <http://semver.org/>`_.\nIt is licensed under the WTFPLv2, see COPYING.WTFPL for license text.\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/hydrargyrum/pjy", "keywords": "json processor query filter jq", "license": "WTFPLv2", "maintainer": "", "maintainer_email": "", "name": "pjy", "package_url": "https://pypi.org/project/pjy/", "platform": "", "project_url": "https://pypi.org/project/pjy/", "project_urls": {"Homepage": "https://github.com/hydrargyrum/pjy"}, "release_url": "https://pypi.org/project/pjy/0.10.0/", "requires_dist": null, "requires_python": ">=3", "summary": "pjy - command-line JSON processor", "version": "0.10.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><tt>pjy</tt> is a command-line tool to process JSON data and execute queries on it.\nIt is a bit like <a href=\"https://stedolan.github.io/jq/\" rel=\"nofollow\">jq</a> but with a Python syntax for queries.</p>\n<div id=\"usage\">\n<h2>Usage</h2>\n<blockquote>\npjy [EXPR] [FILES]</blockquote>\n<p><tt>pjy</tt> will read JSON data from <tt>FILES</tt> and print the evaluation result of the Python expression <tt>EXPR</tt>.</p>\n<p>If <tt>FILES</tt> is missing or is \u201c<tt>-</tt>\u201c, pjy will use stdin.</p>\n<p>The simplest expression to use, which outputs the input unchanged is \u201c<tt>d</tt>\u201d (for data).</p>\n<p>It\u2019s possible to use multiple input files.</p>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<p>In <tt>pjy</tt>, expressions are also called \u201cfilters\u201d, as in <tt>jq</tt>.</p>\n<div id=\"just-pretty-print\">\n<h3>Just pretty-print</h3>\n<p><tt>d</tt> (short for \u201cdata\u201d) is the most basic filter, it represents the whole input:</p>\n<pre>pjy 'd'\n    {\"foo\":\"bar\",\"baz\":[1,2,3]}\n</pre>\n<p>Prints:</p>\n<pre>{\n  \"foo\": \"bar\",\n  \"baz\": [\n    1,\n    2,\n    3\n  ]\n}\n</pre>\n</div>\n<div id=\"select-a-dict-key\">\n<h3>Select a dict key</h3>\n<p>The filters are Python expressions, hence we can select a dict key:</p>\n<pre>pjy 'd[\"baz\"]'\n    {\"foo\":\"bar\",\"baz\":[1,2,3]}\n</pre>\n<p>Alternatively, in <tt>pjy</tt>, dicts keys are also attributes:</p>\n<pre>pjy 'd.baz'\n    {\"foo\":\"bar\",\"baz\":[1,2,3]}\n</pre>\n<p>Both filters will print:</p>\n<pre>[\n  1,\n  2,\n  3\n]\n</pre>\n<p>In case a key has a reserved name, like <tt>import</tt> (keyword) or <tt>keys</tt> (dict method), simply use the bracket form.</p>\n</div>\n<div id=\"do-a-basic-operation\">\n<h3>Do a basic operation</h3>\n<p>It\u2019s possible to use everything that a Python expression can contain:</p>\n<pre>pjy '[i + 1 for i in d[\"baz\"]]'\n    {\"foo\":\"bar\",\"baz\":[1,2,3]}\n</pre>\n<p>Prints:</p>\n<pre>[\n  2,\n  3,\n  4\n]\n</pre>\n</div>\n<div id=\"lambda-placeholder\">\n<h3>Lambda-placeholder</h3>\n<p>A special identifier, <tt>_</tt> can be used to create lambdas. This identifier will absorb most operations done to it and return a lambda applying them.\nThen, the returned lambda can be applied:</p>\n<pre>pjy 'map(_ + 1, d.baz)'\n    {\"foo\":\"bar\",\"baz\":[1,2,3]}\n</pre>\n<p>Is equivalent to:</p>\n<pre>pjy 'map((lambda x: x + 1), d.baz)'\n    {\"foo\":\"bar\",\"baz\":[1,2,3]}\n</pre>\n<p>Which will print:</p>\n<pre>[\n  2,\n  3,\n  4\n]\n</pre>\n<p>The lambda-placeholder will absorb chained operations:</p>\n<pre>pjy 'map((_ + 1) * 2, d.baz)'\n    {\"foo\":\"bar\",\"baz\":[1,2,3]}\n</pre>\n<p>Will result in:</p>\n<pre>[\n  4,\n  6,\n  8\n]\n</pre>\n<p>And:</p>\n<pre>pjy 'map(_[1:3] * 2, d)'\n    {\"foo\":\"bar\",\"baz\":[1,2,3]}\n</pre>\n<p>Will return:</p>\n<pre>{\n  \"foo\": \"arar\",\n  \"baz\": [\n    2,\n    3,\n    2,\n    3\n  ]\n}\n</pre>\n</div>\n<div id=\"pipe-like-iteration\">\n<h3>Pipe-like iteration</h3>\n<p>The pipe (<tt>|</tt>) can be used to iterate on a list, it accepts a function as right operand:</p>\n<pre>pjy 'd.baz | _ + 1'\n    {\"foo\":\"bar\",\"baz\":[1,2,3]}\n</pre>\n<p>Which prints:</p>\n<pre>[\n  2,\n  3,\n  4\n]\n</pre>\n<p>It also operates on a dict\u2019s values, and returns a dict:</p>\n<pre>pjy 'd | (lambda x: repr(x))'\n    {\"foo\":\"bar\",\"baz\":[1,2,3]}\n</pre>\n<p>The values are replaced by the right operand value, the keys are unchanged:</p>\n<pre>{\n  \"foo\": \"'bar'\",\n  \"baz\": \"[1, 2, 3]\"\n}\n</pre>\n</div>\n<div id=\"partial-placeholder\">\n<h3>Partial placeholder</h3>\n<p>It\u2019s not possible to call a function on a placeholder, for example, <tt>len(_)</tt> will not work.\nHowever, it\u2019s possible to use the <tt>partial</tt> helper to prepare the function call:</p>\n<pre>pjy 'd | partial(len, _)'\n    {\"foo\":\"bar\",\"baz\":[1,2,3]}\n</pre>\n<p>Prints:</p>\n<pre>{\n  \"foo\": 3,\n  \"baz\": 3\n}\n</pre>\n<p><tt>partial</tt> ressembles the <tt>functools.partial</tt> function: it returns a function wrapping the function passed as first argument.\nThe returned function will call the original function with the fixed arguments passed.\nThe difference is that lambda-placeholders can be passed, and they will be replaced by the wrapper\u2019s argument.</p>\n<p><tt>p</tt> is a short alias for the <tt>partial</tt> function which can be used in pjy expressions.</p>\n</div>\n<div id=\"imports\">\n<h3>Imports</h3>\n<p>It\u2019s possible to import modules with the <tt>imp</tt> function:</p>\n<pre>pjy 'filter(p(imp(\"fnmatch\").fnmatch, _, \"f*\"), d.keys())'\n     {\"foo\":\"bar\",\"baz\":[1,2,3]}\n</pre>\n<p>Will print:</p>\n<pre>[\n  \"foo\"\n]\n</pre>\n<p>The <tt>math</tt> and <tt>re</tt> modules are already imported and available directly without having to call <tt>imp</tt>.</p>\n</div>\n<div id=\"multiple-inputs\">\n<h3>Multiple inputs</h3>\n<p>In <tt>pjy</tt>, an <tt>inputs</tt> variable exists, which is a list containing the JSON data of each input file passed on the command line.\nThe <tt>d</tt> variable is simply an alias to <tt>inputs[0]</tt>.</p>\n<p>For example:</p>\n<pre>pjy 'filter(_[0] != _[1], zip(inputs[0], inputs[1]))' before.json after.json\n</pre>\n<p>will read 2 files <tt>before.json</tt> and <tt>after.json</tt>, which consist in a list of objects, and <tt>pjy</tt> will compare each zipped-pair of objects together.\nThen it will print the list of differing pairs.</p>\n</div>\n</div>\n<div id=\"security\">\n<h2>Security</h2>\n<p><tt>pjy</tt> by itself does not write files (except stdout/stderr) or sockets, or run external commands.\nHowever, <tt>pjy</tt> runs the given expressions passed as argument, in the Python interpreter, without a sandbox.\nHence, do NOT pass dangerous or untrusted Python expressions to <tt>pjy</tt>.</p>\n</div>\n<div id=\"dependencies\">\n<h2>Dependencies</h2>\n<p><tt>pjy</tt> is written in Python 3. Its <tt>setup.py</tt> requires <tt>setuptools</tt>.</p>\n<p>If <tt>pygments</tt> is installed, <tt>pjy</tt>\u2019s output will be colorized, but it\u2019s entirely optional.</p>\n</div>\n<div id=\"version-and-license\">\n<h2>Version and license</h2>\n<p><tt>pjy</tt> is at version 0.10.0, it uses <a href=\"http://semver.org/\" rel=\"nofollow\">semantic versioning</a>.\nIt is licensed under the WTFPLv2, see COPYING.WTFPL for license text.</p>\n</div>\n\n          </div>"}, "last_serial": 3572053, "releases": {"0.10.0": [{"comment_text": "", "digests": {"md5": "826e4ae01fa500653f242e16bbc762a9", "sha256": "b47c086c2b289da70a1f77b0a7fd657673f7612a1adf00f0b27177576fd8c16b"}, "downloads": -1, "filename": "pjy-0.10.0-py3-none-any.whl", "has_sig": false, "md5_digest": "826e4ae01fa500653f242e16bbc762a9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 10608, "upload_time": "2017-09-10T13:47:13", "upload_time_iso_8601": "2017-09-10T13:47:13.460356Z", "url": "https://files.pythonhosted.org/packages/03/5a/9af38abaad187ac4e37d4f83e9d73a0ae78b71a047b5ea6b1d04fd14fdc9/pjy-0.10.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ea16b5c7c8465eae3dede20e08fc4edc", "sha256": "9fc78ef8c9f2e20f650c2abc60f94e0303e9b4746f80f8d224ae1a9ed36e1a04"}, "downloads": -1, "filename": "pjy-0.10.0.tar.gz", "has_sig": false, "md5_digest": "ea16b5c7c8465eae3dede20e08fc4edc", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3", "size": 5749, "upload_time": "2017-09-10T13:47:16", "upload_time_iso_8601": "2017-09-10T13:47:16.406984Z", "url": "https://files.pythonhosted.org/packages/da/22/2825523c378be1b5dfb1367010afa7627cc99f5b1b6284e36af79f3e77d7/pjy-0.10.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "826e4ae01fa500653f242e16bbc762a9", "sha256": "b47c086c2b289da70a1f77b0a7fd657673f7612a1adf00f0b27177576fd8c16b"}, "downloads": -1, "filename": "pjy-0.10.0-py3-none-any.whl", "has_sig": false, "md5_digest": "826e4ae01fa500653f242e16bbc762a9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 10608, "upload_time": "2017-09-10T13:47:13", "upload_time_iso_8601": "2017-09-10T13:47:13.460356Z", "url": "https://files.pythonhosted.org/packages/03/5a/9af38abaad187ac4e37d4f83e9d73a0ae78b71a047b5ea6b1d04fd14fdc9/pjy-0.10.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ea16b5c7c8465eae3dede20e08fc4edc", "sha256": "9fc78ef8c9f2e20f650c2abc60f94e0303e9b4746f80f8d224ae1a9ed36e1a04"}, "downloads": -1, "filename": "pjy-0.10.0.tar.gz", "has_sig": false, "md5_digest": "ea16b5c7c8465eae3dede20e08fc4edc", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3", "size": 5749, "upload_time": "2017-09-10T13:47:16", "upload_time_iso_8601": "2017-09-10T13:47:16.406984Z", "url": "https://files.pythonhosted.org/packages/da/22/2825523c378be1b5dfb1367010afa7627cc99f5b1b6284e36af79f3e77d7/pjy-0.10.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:53:51 2020"}