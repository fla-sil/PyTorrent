{"info": {"author": "Chia Network, Inc.", "author_email": "kiss@chia.net", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Security :: Cryptography"], "description": "# Introduction\n\nThis is the in-development version of `clvm_tools` for clvm, which implements, a LISP-like language for encumbering and releasing funds with smart-contract capabilities.\n\n\n# Set up\n\nSet up your virtual environments\n\n    $ python3 -m venv env\n    $ ln -s env/bin/activate\n    $ . ./activate\n    $ pip install -r requirements.txt\n    $ pip install -e .\n\nOptionally, run unit tests for a sanity check.\n\n    $ pip install pytest\n    $ py.test tests\n\n\n# Quick examples\n\nThe language has two components: the higher level language and the compiled lower level language which runs on the clvm.\nTo compile the higher level language into the lower level language use:\n\n    $ run -s2 '(mod ARGUMENT (+ ARGUMENT 3))'\n    (+ (a) (q 3))\n\nTo execute this code:\n\n    $ brun '(+ (a) (q 3))' '2'\n    5\n\n\n# The Compiler\n\n\n## Basic example\n\nThe high level language is a superset of [clvm](https://github.com/Chia-Network/clvm), adding several operators. The main supported operator is `mod` which lets you define a set of macros and functions, and an entry point that calls them. Here's an example.\n\n    (mod (INDEX)\n         (defun factorial (VALUE) (if (= VALUE 1) 1 (* VALUE (factorial (- VALUE 1)))))\n         (factorial INDEX)\n         )\n\nYou can copy this to a file `fact.clvm`, then compile it with `run fact.clvm` and you'll see output like\n\n`((c (q ((c (f (a)) (c (f (a)) (c (f (r (a))) (q ())))))) (c (q ((c (i (= (f (r (a))) (q 1)) (q (q 1)) (q (* (f (r (a))) ((c (f (a)) (c (f (a)) (c (- (f (r (a))) (q 1)) (q ())))))))) (a)))) (a))))`\n\nYou can then run this code with `brun`, passing in a parameter. Or pipe it using this `bash` quoting trick:\n\n    $ brun \"`run fact.clvm`\" \"(5)\"\n    120\n\nThis affirms that 5! = 120.\n\n\n### Auto-quoting of literals\n\nNote that the `1` is not quoted. The compiler recognizes and auto-quotes constant values.\n\n    $ run 15\n    15\n    $ brun 15\n    FAIL: not a list 15\n\n\n## Known operators\n\nBesides `mod` and `defun`, the compiler has a few more built-in operators:\n\n\n### if\n\n`(if A B C)`\nThis operator is similar to lone condition in clvm `i`, except it actually does a lazy evaluation of either B or C (depending upon A). This allows you to put expensive or failing (like `x`) operator within branches, knowing they won't be executed unless required.\n\nThis is implemented as a macro, and expands out to `((c (i A (q B) (q C)) (a)))`.\n\n\n### qq\n\n`(qq EXPR)` for expanding templates. This is generally for creating your own operators that end up being inline functions.\n\nEverything in `EXPR` is quoted literally, unless it's wrapped by a unary `unquote` operator, in which case, it's evaluated. So\n\n`(qq (+ 5 (a)))` would expand to `(+ 5 (a))`\n\nBut `(qq (+ 5 (unquote (+ 9 10))))` would expand to `(+ 5 19)` because `(+ 9 10)` is `19`.\n\nAnd `(qq (+ 5 (unquote (+ 1 (a)))))` expands to something that depends on what `(a)` is in the context it's evaluated. (It'd better be a number so 1 can be added to it!)\n\nIf you have a template expression and you want to substitute values into it, this is what you use.\n\n\n## Macros\n\nYou can also define macros within a module, which act as inline functions. When a previously defined macro operator is encoutered, it \"rewrites\" the existing statement using the macro, passing along the arguments as literals (ie. they are not evaluated).\n\n\n### A Simple Example\n\n    (mod (VALUE1 VALUE2)\n         (defmacro sum (A B) (qq (+ (unquote A) (unquote B))))\n         (sum VALUE1 VALUE2)\n         )\n\nWhen `run`, this produces the following output:\n\n`(+ (f (a)) (f (r (a))))`\n\nCompare to the function version:\n\n    (mod (VALUE1 VALUE2)\n         (defun sum (A B) (+ A B))\n         (sum VALUE1 VALUE2)\n         )\n\nwhich produces\n\n`((c (q ((c (f (a)) (c (f (a)) (c (f (r (a))) (c (f (r (r (a)))) (q ()))))))) (c (q (+ (f (r (a))) (f (r (r (a)))))) (a))))`\n\nThere's a lot more going on here, setting up an environment where sum would be allowed to call itself recursively.\n\n\n### A More Complex Example\n\nHere's an example, demonstrating how `if` is defined.\n\n    (mod (VALUE1 VALUE2)\n         (defmacro my_if (A B C)\n           (qq ((c\n    \t    (i (unquote A)\n    \t       (function (unquote B))\n    \t       (function (unquote C)))\n    \t    (a)))))\n         (my_if (= (+ VALUE1 VALUE2) 10) \"the sum is 10\" \"the sum is not 10\")\n         )\n\nThis produces\n\n`((c (i (= (+ (f (a)) (f (r (a)))) (q 10)) (q (q \"the sum is 10\")) (q (q \"the sum is not 10\"))) (a)))`\n\nwhich is not much code, for how much source there is. This also demonstrates the general notion that macros cause much less code bloat than functions. The main disadvantages is that macros are not recursive (since they run at compile time) and they're messier to write.\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Chia-Network", "keywords": "", "license": "https://opensource.org/licenses/Apache-2.0", "maintainer": "", "maintainer_email": "", "name": "clvm-tools", "package_url": "https://pypi.org/project/clvm-tools/", "platform": "", "project_url": "https://pypi.org/project/clvm-tools/", "project_urls": {"Bug Reports": "https://github.com/Chia-Network/clvm_tools", "Homepage": "https://github.com/Chia-Network", "Source": "https://github.com/Chia-Network/clvm_tools"}, "release_url": "https://pypi.org/project/clvm-tools/0.1.1/", "requires_dist": null, "requires_python": "", "summary": "CLVM compiler.", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Introduction</h1>\n<p>This is the in-development version of <code>clvm_tools</code> for clvm, which implements, a LISP-like language for encumbering and releasing funds with smart-contract capabilities.</p>\n<h1>Set up</h1>\n<p>Set up your virtual environments</p>\n<pre><code>$ python3 -m venv env\n$ ln -s env/bin/activate\n$ . ./activate\n$ pip install -r requirements.txt\n$ pip install -e .\n</code></pre>\n<p>Optionally, run unit tests for a sanity check.</p>\n<pre><code>$ pip install pytest\n$ py.test tests\n</code></pre>\n<h1>Quick examples</h1>\n<p>The language has two components: the higher level language and the compiled lower level language which runs on the clvm.\nTo compile the higher level language into the lower level language use:</p>\n<pre><code>$ run -s2 '(mod ARGUMENT (+ ARGUMENT 3))'\n(+ (a) (q 3))\n</code></pre>\n<p>To execute this code:</p>\n<pre><code>$ brun '(+ (a) (q 3))' '2'\n5\n</code></pre>\n<h1>The Compiler</h1>\n<h2>Basic example</h2>\n<p>The high level language is a superset of <a href=\"https://github.com/Chia-Network/clvm\" rel=\"nofollow\">clvm</a>, adding several operators. The main supported operator is <code>mod</code> which lets you define a set of macros and functions, and an entry point that calls them. Here's an example.</p>\n<pre><code>(mod (INDEX)\n     (defun factorial (VALUE) (if (= VALUE 1) 1 (* VALUE (factorial (- VALUE 1)))))\n     (factorial INDEX)\n     )\n</code></pre>\n<p>You can copy this to a file <code>fact.clvm</code>, then compile it with <code>run fact.clvm</code> and you'll see output like</p>\n<p><code>((c (q ((c (f (a)) (c (f (a)) (c (f (r (a))) (q ())))))) (c (q ((c (i (= (f (r (a))) (q 1)) (q (q 1)) (q (* (f (r (a))) ((c (f (a)) (c (f (a)) (c (- (f (r (a))) (q 1)) (q ())))))))) (a)))) (a))))</code></p>\n<p>You can then run this code with <code>brun</code>, passing in a parameter. Or pipe it using this <code>bash</code> quoting trick:</p>\n<pre><code>$ brun \"`run fact.clvm`\" \"(5)\"\n120\n</code></pre>\n<p>This affirms that 5! = 120.</p>\n<h3>Auto-quoting of literals</h3>\n<p>Note that the <code>1</code> is not quoted. The compiler recognizes and auto-quotes constant values.</p>\n<pre><code>$ run 15\n15\n$ brun 15\nFAIL: not a list 15\n</code></pre>\n<h2>Known operators</h2>\n<p>Besides <code>mod</code> and <code>defun</code>, the compiler has a few more built-in operators:</p>\n<h3>if</h3>\n<p><code>(if A B C)</code>\nThis operator is similar to lone condition in clvm <code>i</code>, except it actually does a lazy evaluation of either B or C (depending upon A). This allows you to put expensive or failing (like <code>x</code>) operator within branches, knowing they won't be executed unless required.</p>\n<p>This is implemented as a macro, and expands out to <code>((c (i A (q B) (q C)) (a)))</code>.</p>\n<h3>qq</h3>\n<p><code>(qq EXPR)</code> for expanding templates. This is generally for creating your own operators that end up being inline functions.</p>\n<p>Everything in <code>EXPR</code> is quoted literally, unless it's wrapped by a unary <code>unquote</code> operator, in which case, it's evaluated. So</p>\n<p><code>(qq (+ 5 (a)))</code> would expand to <code>(+ 5 (a))</code></p>\n<p>But <code>(qq (+ 5 (unquote (+ 9 10))))</code> would expand to <code>(+ 5 19)</code> because <code>(+ 9 10)</code> is <code>19</code>.</p>\n<p>And <code>(qq (+ 5 (unquote (+ 1 (a)))))</code> expands to something that depends on what <code>(a)</code> is in the context it's evaluated. (It'd better be a number so 1 can be added to it!)</p>\n<p>If you have a template expression and you want to substitute values into it, this is what you use.</p>\n<h2>Macros</h2>\n<p>You can also define macros within a module, which act as inline functions. When a previously defined macro operator is encoutered, it \"rewrites\" the existing statement using the macro, passing along the arguments as literals (ie. they are not evaluated).</p>\n<h3>A Simple Example</h3>\n<pre><code>(mod (VALUE1 VALUE2)\n     (defmacro sum (A B) (qq (+ (unquote A) (unquote B))))\n     (sum VALUE1 VALUE2)\n     )\n</code></pre>\n<p>When <code>run</code>, this produces the following output:</p>\n<p><code>(+ (f (a)) (f (r (a))))</code></p>\n<p>Compare to the function version:</p>\n<pre><code>(mod (VALUE1 VALUE2)\n     (defun sum (A B) (+ A B))\n     (sum VALUE1 VALUE2)\n     )\n</code></pre>\n<p>which produces</p>\n<p><code>((c (q ((c (f (a)) (c (f (a)) (c (f (r (a))) (c (f (r (r (a)))) (q ()))))))) (c (q (+ (f (r (a))) (f (r (r (a)))))) (a))))</code></p>\n<p>There's a lot more going on here, setting up an environment where sum would be allowed to call itself recursively.</p>\n<h3>A More Complex Example</h3>\n<p>Here's an example, demonstrating how <code>if</code> is defined.</p>\n<pre><code>(mod (VALUE1 VALUE2)\n     (defmacro my_if (A B C)\n       (qq ((c\n\t    (i (unquote A)\n\t       (function (unquote B))\n\t       (function (unquote C)))\n\t    (a)))))\n     (my_if (= (+ VALUE1 VALUE2) 10) \"the sum is 10\" \"the sum is not 10\")\n     )\n</code></pre>\n<p>This produces</p>\n<p><code>((c (i (= (+ (f (a)) (f (r (a)))) (q 10)) (q (q \"the sum is 10\")) (q (q \"the sum is not 10\"))) (a)))</code></p>\n<p>which is not much code, for how much source there is. This also demonstrates the general notion that macros cause much less code bloat than functions. The main disadvantages is that macros are not recursive (since they run at compile time) and they're messier to write.</p>\n\n          </div>"}, "last_serial": 6924442, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "958f225ead48dc0e89b968366b4463ba", "sha256": "eade17c46eb4b4b8445979ecc71cd24294cfa746f7d5b1dc65f6e4ccf6f6d704"}, "downloads": -1, "filename": "clvm_tools-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "958f225ead48dc0e89b968366b4463ba", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 30352, "upload_time": "2020-04-01T00:44:05", "upload_time_iso_8601": "2020-04-01T00:44:05.894336Z", "url": "https://files.pythonhosted.org/packages/00/13/4a4a8c4de06b2ffc454eb57ff41a886e3185c3f5cfac41896079684082f0/clvm_tools-0.1.1-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "958f225ead48dc0e89b968366b4463ba", "sha256": "eade17c46eb4b4b8445979ecc71cd24294cfa746f7d5b1dc65f6e4ccf6f6d704"}, "downloads": -1, "filename": "clvm_tools-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "958f225ead48dc0e89b968366b4463ba", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 30352, "upload_time": "2020-04-01T00:44:05", "upload_time_iso_8601": "2020-04-01T00:44:05.894336Z", "url": "https://files.pythonhosted.org/packages/00/13/4a4a8c4de06b2ffc454eb57ff41a886e3185c3f5cfac41896079684082f0/clvm_tools-0.1.1-py3-none-any.whl", "yanked": false}], "timestamp": "Thu May  7 22:18:38 2020"}