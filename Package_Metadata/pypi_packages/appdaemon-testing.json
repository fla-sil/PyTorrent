{"info": {"author": "Nick Whyte", "author_email": "nick@nickwhyte.com", "bugtrack_url": null, "classifiers": ["Framework :: Pytest"], "description": "# appdaemon-testing\nErgonomic and pythonic unit testing for AppDaemon apps. Utilities to allow you to test your AppDaemon home automation apps using all the _pythonic_ testing patterns you are already familiar with.\n\n## Install\n\n```sh\npip install appdaemon-testing\n``` \n\n## Full Documentation\n\nAn enhanced, source-linked version of the documentation below as well as complete [API documentation](https://nickwhyte.com/appdaemon-testing/#header-submodules) is available [here](https://nickwhyte.com/appdaemon-testing/)\n\n## Writing your first test\n\nThis demo assumes you will use [`pytest`](https://docs.pytest.org/en/latest/) as your test runner. Install the `appdaemon-testing` and [`pytest`](https://docs.pytest.org/en/latest/) packages:\n\n```sh\npip install appdaemon-testing pytest\n``` \n\nIn your `appdaemon` configuration directory, introduce a new `tests` directory. This is where we are going to write the tests for your apps.\n\nAdditionally we also need to introduce an `__init__.py` file to `tests` and `apps` directories to make them an importable package. You should have a tree that looks something like this:\n\n```\n\u251c\u2500\u2500 appdaemon.yaml\n\u251c\u2500\u2500 apps\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 apps.yaml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 living_room_motion.py\n\u251c\u2500\u2500 dashboards\n\u251c\u2500\u2500 namespaces\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 test_living_room_motion.py\n```\n\nWe have an automation, `apps/living_room_motion.py` that we wish to test. It looks like this:\n\n```py\nimport appdaemon.plugins.hass.hassapi as hass\n\n\nclass LivingRoomMotion(hass.Hass):\n    def initialize(self):\n        self.listen_state(self.on_motion_detected, self.args[\"motion_entity\"])\n\n    def on_motion_detected(self, entity, attribute, old, new, kwargs):\n        if old == \"off\" and new == \"on\":\n            for light in self.args[\"light_entities\"]:\n                self.turn_on(light)\n```\n\nCreate a new file, `tests/test_living_room_motion.py`. This is where we will write the tests for our automation.\n\nFirst we will declare an _`appdaemon_testing.pytest.automation_fixture`_:\n\n```py\n@automation_fixture(\n    LivingRoomMotion,\n    args={\n        \"motion_entity\": \"binary_sensor.motion_detected\",\n        \"light_entities\": [\"light.1\", \"light.2\", \"light.3\"],\n    },\n)\ndef living_room_motion() -> LivingRoomMotion:\n    pass\n```\n\n\nWith this fixture, it's now possible to write some tests. We will first write a test to check the state listener callbacks are registered:\n\n```py\ndef test_callbacks_are_registered(hass_driver, living_room_motion: LivingRoomMotion):\n    listen_state = hass_driver.get_mock(\"listen_state\")\n    listen_state.assert_called_once_with(\n        living_room_motion.on_motion_detected, \"binary_sensor.motion_detected\")\n```\n\nWe use the `appdaemon_testing.pytest.hass_driver` fixture to obtain mock implementations of methods that exist on the AppDaemon Hass API. We can query these mocks and make assertions on their values. In this test we make an assertion that `listen_state` is called once with the specified parameters.\n\nWe will next write a test to make an assertion that the lights are turned on when motion is detected:\n\n```py\ndef test_lights_are_turned_on_when_motion_detected(\n    hass_driver, living_room_motion: LivingRoomMotion\n):\n    with hass_driver.setup():\n        hass_driver.set_state(\"binary_sensor.motion_detected\", \"off\")\n\n    hass_driver.set_state(\"binary_sensor.motion_detected\", \"on\")\n\n    turn_on = hass_driver.get_mock(\"turn_on\")\n    assert turn_on.call_count == 3\n    turn_on.assert_has_calls(\n        [mock.call(\"light.1\"), mock.call(\"light.2\"), mock.call(\"light.3\")]\n    )\n```\n\nThis test uses the `HassDriver.setup()` context manager to set the initial state for testing. When execution is within `HassDriver.setup()` all state updates will not be triggered.\n\nWith the initial state configured, we can now proceed to triggering the state change (`HassDriver.set_state`). After the state change has occured, we can then begin to make assertions about calls made to the underlying API. In this test we wish to make assertions that `turn_on` is called. We obtain the `turn_on` mock implementation and make assertions about its calls and call count.  \n\nYou can see this full example and example directory structure within the [`example`](https://github.com/nickw444/appdaemon-testing/tree/master/example) directory in this repo.\n\n\n## [`pytest`](https://docs.pytest.org/en/latest/) plugin\n\nThe `appdaemon_testing.pytest` package provides a handy `appdaemon_testing.pytest.hass_driver` fixture to allow you easy access to the global `HassDriver` instance. This fixture takes care of ensuring AppDaemon base class methods are patched.\n\nAdditionally, it provides a decorator, `appdaemon_testing.pytest.automation_fixture` which can be used to declare automation fixtures. It can be used like so:\n\n```py\nfrom appdaemon_testing.pytest import automation_fixture\nfrom apps.living_room_motion import LivingRoomMotion\n\n\n@automation_fixture(\n    LivingRoomMotion,\n    args={\n        \"motion_entity\": \"binary_sensor.motion_detected\",\n        \"light_entities\": [\"light.1\", \"light.2\", \"light.3\"],\n    },\n)\ndef living_room_motion() -> LivingRoomMotion:\n    pass\n```\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/nickw444/appdaemon-testing", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "appdaemon-testing", "package_url": "https://pypi.org/project/appdaemon-testing/", "platform": "", "project_url": "https://pypi.org/project/appdaemon-testing/", "project_urls": {"Homepage": "https://github.com/nickw444/appdaemon-testing"}, "release_url": "https://pypi.org/project/appdaemon-testing/0.1.2/", "requires_dist": ["appdaemon", "pytest ; extra == 'pytest'", "pytest ; extra == 'test'"], "requires_python": "", "summary": "Utilities for testing AppDaemon applications", "version": "0.1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>appdaemon-testing</h1>\n<p>Ergonomic and pythonic unit testing for AppDaemon apps. Utilities to allow you to test your AppDaemon home automation apps using all the <em>pythonic</em> testing patterns you are already familiar with.</p>\n<h2>Install</h2>\n<pre>pip install appdaemon-testing\n</pre>\n<h2>Full Documentation</h2>\n<p>An enhanced, source-linked version of the documentation below as well as complete <a href=\"https://nickwhyte.com/appdaemon-testing/#header-submodules\" rel=\"nofollow\">API documentation</a> is available <a href=\"https://nickwhyte.com/appdaemon-testing/\" rel=\"nofollow\">here</a></p>\n<h2>Writing your first test</h2>\n<p>This demo assumes you will use <a href=\"https://docs.pytest.org/en/latest/\" rel=\"nofollow\"><code>pytest</code></a> as your test runner. Install the <code>appdaemon-testing</code> and <a href=\"https://docs.pytest.org/en/latest/\" rel=\"nofollow\"><code>pytest</code></a> packages:</p>\n<pre>pip install appdaemon-testing pytest\n</pre>\n<p>In your <code>appdaemon</code> configuration directory, introduce a new <code>tests</code> directory. This is where we are going to write the tests for your apps.</p>\n<p>Additionally we also need to introduce an <code>__init__.py</code> file to <code>tests</code> and <code>apps</code> directories to make them an importable package. You should have a tree that looks something like this:</p>\n<pre><code>\u251c\u2500\u2500 appdaemon.yaml\n\u251c\u2500\u2500 apps\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 apps.yaml\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 living_room_motion.py\n\u251c\u2500\u2500 dashboards\n\u251c\u2500\u2500 namespaces\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 __init__.py\n    \u2514\u2500\u2500 test_living_room_motion.py\n</code></pre>\n<p>We have an automation, <code>apps/living_room_motion.py</code> that we wish to test. It looks like this:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">appdaemon.plugins.hass.hassapi</span> <span class=\"k\">as</span> <span class=\"nn\">hass</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">LivingRoomMotion</span><span class=\"p\">(</span><span class=\"n\">hass</span><span class=\"o\">.</span><span class=\"n\">Hass</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">initialize</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">listen_state</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">on_motion_detected</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"s2\">\"motion_entity\"</span><span class=\"p\">])</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">on_motion_detected</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">entity</span><span class=\"p\">,</span> <span class=\"n\">attribute</span><span class=\"p\">,</span> <span class=\"n\">old</span><span class=\"p\">,</span> <span class=\"n\">new</span><span class=\"p\">,</span> <span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">old</span> <span class=\"o\">==</span> <span class=\"s2\">\"off\"</span> <span class=\"ow\">and</span> <span class=\"n\">new</span> <span class=\"o\">==</span> <span class=\"s2\">\"on\"</span><span class=\"p\">:</span>\n            <span class=\"k\">for</span> <span class=\"n\">light</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">args</span><span class=\"p\">[</span><span class=\"s2\">\"light_entities\"</span><span class=\"p\">]:</span>\n                <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">turn_on</span><span class=\"p\">(</span><span class=\"n\">light</span><span class=\"p\">)</span>\n</pre>\n<p>Create a new file, <code>tests/test_living_room_motion.py</code>. This is where we will write the tests for our automation.</p>\n<p>First we will declare an <em><code>appdaemon_testing.pytest.automation_fixture</code></em>:</p>\n<pre><span class=\"nd\">@automation_fixture</span><span class=\"p\">(</span>\n    <span class=\"n\">LivingRoomMotion</span><span class=\"p\">,</span>\n    <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">{</span>\n        <span class=\"s2\">\"motion_entity\"</span><span class=\"p\">:</span> <span class=\"s2\">\"binary_sensor.motion_detected\"</span><span class=\"p\">,</span>\n        <span class=\"s2\">\"light_entities\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"light.1\"</span><span class=\"p\">,</span> <span class=\"s2\">\"light.2\"</span><span class=\"p\">,</span> <span class=\"s2\">\"light.3\"</span><span class=\"p\">],</span>\n    <span class=\"p\">},</span>\n<span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">living_room_motion</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">LivingRoomMotion</span><span class=\"p\">:</span>\n    <span class=\"k\">pass</span>\n</pre>\n<p>With this fixture, it's now possible to write some tests. We will first write a test to check the state listener callbacks are registered:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">test_callbacks_are_registered</span><span class=\"p\">(</span><span class=\"n\">hass_driver</span><span class=\"p\">,</span> <span class=\"n\">living_room_motion</span><span class=\"p\">:</span> <span class=\"n\">LivingRoomMotion</span><span class=\"p\">):</span>\n    <span class=\"n\">listen_state</span> <span class=\"o\">=</span> <span class=\"n\">hass_driver</span><span class=\"o\">.</span><span class=\"n\">get_mock</span><span class=\"p\">(</span><span class=\"s2\">\"listen_state\"</span><span class=\"p\">)</span>\n    <span class=\"n\">listen_state</span><span class=\"o\">.</span><span class=\"n\">assert_called_once_with</span><span class=\"p\">(</span>\n        <span class=\"n\">living_room_motion</span><span class=\"o\">.</span><span class=\"n\">on_motion_detected</span><span class=\"p\">,</span> <span class=\"s2\">\"binary_sensor.motion_detected\"</span><span class=\"p\">)</span>\n</pre>\n<p>We use the <code>appdaemon_testing.pytest.hass_driver</code> fixture to obtain mock implementations of methods that exist on the AppDaemon Hass API. We can query these mocks and make assertions on their values. In this test we make an assertion that <code>listen_state</code> is called once with the specified parameters.</p>\n<p>We will next write a test to make an assertion that the lights are turned on when motion is detected:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">test_lights_are_turned_on_when_motion_detected</span><span class=\"p\">(</span>\n    <span class=\"n\">hass_driver</span><span class=\"p\">,</span> <span class=\"n\">living_room_motion</span><span class=\"p\">:</span> <span class=\"n\">LivingRoomMotion</span>\n<span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">hass_driver</span><span class=\"o\">.</span><span class=\"n\">setup</span><span class=\"p\">():</span>\n        <span class=\"n\">hass_driver</span><span class=\"o\">.</span><span class=\"n\">set_state</span><span class=\"p\">(</span><span class=\"s2\">\"binary_sensor.motion_detected\"</span><span class=\"p\">,</span> <span class=\"s2\">\"off\"</span><span class=\"p\">)</span>\n\n    <span class=\"n\">hass_driver</span><span class=\"o\">.</span><span class=\"n\">set_state</span><span class=\"p\">(</span><span class=\"s2\">\"binary_sensor.motion_detected\"</span><span class=\"p\">,</span> <span class=\"s2\">\"on\"</span><span class=\"p\">)</span>\n\n    <span class=\"n\">turn_on</span> <span class=\"o\">=</span> <span class=\"n\">hass_driver</span><span class=\"o\">.</span><span class=\"n\">get_mock</span><span class=\"p\">(</span><span class=\"s2\">\"turn_on\"</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">turn_on</span><span class=\"o\">.</span><span class=\"n\">call_count</span> <span class=\"o\">==</span> <span class=\"mi\">3</span>\n    <span class=\"n\">turn_on</span><span class=\"o\">.</span><span class=\"n\">assert_has_calls</span><span class=\"p\">(</span>\n        <span class=\"p\">[</span><span class=\"n\">mock</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"s2\">\"light.1\"</span><span class=\"p\">),</span> <span class=\"n\">mock</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"s2\">\"light.2\"</span><span class=\"p\">),</span> <span class=\"n\">mock</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"s2\">\"light.3\"</span><span class=\"p\">)]</span>\n    <span class=\"p\">)</span>\n</pre>\n<p>This test uses the <code>HassDriver.setup()</code> context manager to set the initial state for testing. When execution is within <code>HassDriver.setup()</code> all state updates will not be triggered.</p>\n<p>With the initial state configured, we can now proceed to triggering the state change (<code>HassDriver.set_state</code>). After the state change has occured, we can then begin to make assertions about calls made to the underlying API. In this test we wish to make assertions that <code>turn_on</code> is called. We obtain the <code>turn_on</code> mock implementation and make assertions about its calls and call count.</p>\n<p>You can see this full example and example directory structure within the <a href=\"https://github.com/nickw444/appdaemon-testing/tree/master/example\" rel=\"nofollow\"><code>example</code></a> directory in this repo.</p>\n<h2><a href=\"https://docs.pytest.org/en/latest/\" rel=\"nofollow\"><code>pytest</code></a> plugin</h2>\n<p>The <code>appdaemon_testing.pytest</code> package provides a handy <code>appdaemon_testing.pytest.hass_driver</code> fixture to allow you easy access to the global <code>HassDriver</code> instance. This fixture takes care of ensuring AppDaemon base class methods are patched.</p>\n<p>Additionally, it provides a decorator, <code>appdaemon_testing.pytest.automation_fixture</code> which can be used to declare automation fixtures. It can be used like so:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">appdaemon_testing.pytest</span> <span class=\"kn\">import</span> <span class=\"n\">automation_fixture</span>\n<span class=\"kn\">from</span> <span class=\"nn\">apps.living_room_motion</span> <span class=\"kn\">import</span> <span class=\"n\">LivingRoomMotion</span>\n\n\n<span class=\"nd\">@automation_fixture</span><span class=\"p\">(</span>\n    <span class=\"n\">LivingRoomMotion</span><span class=\"p\">,</span>\n    <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">{</span>\n        <span class=\"s2\">\"motion_entity\"</span><span class=\"p\">:</span> <span class=\"s2\">\"binary_sensor.motion_detected\"</span><span class=\"p\">,</span>\n        <span class=\"s2\">\"light_entities\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"light.1\"</span><span class=\"p\">,</span> <span class=\"s2\">\"light.2\"</span><span class=\"p\">,</span> <span class=\"s2\">\"light.3\"</span><span class=\"p\">],</span>\n    <span class=\"p\">},</span>\n<span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">living_room_motion</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">LivingRoomMotion</span><span class=\"p\">:</span>\n    <span class=\"k\">pass</span>\n</pre>\n\n          </div>"}, "last_serial": 6906306, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "829eafe9dbf9d86a82922e5f5356c129", "sha256": "c93844eb8e12abe7859ce09f9871e806e15bef49197a712fb9cbb73dd4e9a0e1"}, "downloads": -1, "filename": "appdaemon_testing-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "829eafe9dbf9d86a82922e5f5356c129", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 6583, "upload_time": "2020-03-29T10:20:21", "upload_time_iso_8601": "2020-03-29T10:20:21.179610Z", "url": "https://files.pythonhosted.org/packages/92/c6/70e92e9911b769f81d8628e66e5494ec189bbc606dc9a93ce607b5747769/appdaemon_testing-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6aa2c45002a1cf1a3299dc49c6ba59af", "sha256": "65f2420da110fccd49805bc4cb485d910b95c3b7e611800047e797d3a1c28ea0"}, "downloads": -1, "filename": "appdaemon-testing-0.1.1.tar.gz", "has_sig": false, "md5_digest": "6aa2c45002a1cf1a3299dc49c6ba59af", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6432, "upload_time": "2020-03-29T10:20:23", "upload_time_iso_8601": "2020-03-29T10:20:23.944226Z", "url": "https://files.pythonhosted.org/packages/65/18/0e273921e774218458a49d1951eb6238bfb1b46a2da976f5167c3722886b/appdaemon-testing-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "ff371a1ddc388de6c3cc960d1c6110a2", "sha256": "571c540b33ed836622f0c02dab808a1b4511e1232f05a8d8d500a3ca2206c86b"}, "downloads": -1, "filename": "appdaemon_testing-0.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "ff371a1ddc388de6c3cc960d1c6110a2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 6624, "upload_time": "2020-03-29T12:13:39", "upload_time_iso_8601": "2020-03-29T12:13:39.143963Z", "url": "https://files.pythonhosted.org/packages/ec/1a/f02e624266503e346fae20211493189a86041e70848648235e55a3b62006/appdaemon_testing-0.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a5317a92582d0be038559f56ccfc663a", "sha256": "c0649f7f4482e51e5aba7b7ed523e0ac4b37d520c4d0322958d6ffc107e4b279"}, "downloads": -1, "filename": "appdaemon-testing-0.1.2.tar.gz", "has_sig": false, "md5_digest": "a5317a92582d0be038559f56ccfc663a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6459, "upload_time": "2020-03-29T12:13:40", "upload_time_iso_8601": "2020-03-29T12:13:40.377455Z", "url": "https://files.pythonhosted.org/packages/d8/71/12a3a7ba85d64ac43e5ab9a4d94753acb2d1dcaa2f9b19b26bae43933f38/appdaemon-testing-0.1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ff371a1ddc388de6c3cc960d1c6110a2", "sha256": "571c540b33ed836622f0c02dab808a1b4511e1232f05a8d8d500a3ca2206c86b"}, "downloads": -1, "filename": "appdaemon_testing-0.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "ff371a1ddc388de6c3cc960d1c6110a2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 6624, "upload_time": "2020-03-29T12:13:39", "upload_time_iso_8601": "2020-03-29T12:13:39.143963Z", "url": "https://files.pythonhosted.org/packages/ec/1a/f02e624266503e346fae20211493189a86041e70848648235e55a3b62006/appdaemon_testing-0.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a5317a92582d0be038559f56ccfc663a", "sha256": "c0649f7f4482e51e5aba7b7ed523e0ac4b37d520c4d0322958d6ffc107e4b279"}, "downloads": -1, "filename": "appdaemon-testing-0.1.2.tar.gz", "has_sig": false, "md5_digest": "a5317a92582d0be038559f56ccfc663a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6459, "upload_time": "2020-03-29T12:13:40", "upload_time_iso_8601": "2020-03-29T12:13:40.377455Z", "url": "https://files.pythonhosted.org/packages/d8/71/12a3a7ba85d64ac43e5ab9a4d94753acb2d1dcaa2f9b19b26bae43933f38/appdaemon-testing-0.1.2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:17:41 2020"}