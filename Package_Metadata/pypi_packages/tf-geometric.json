{"info": {"author": "Jun Hu", "author_email": "hujunxianligong@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "tf_geometric\n============\n\nEfficient and Friendly Graph Neural Network Library for TensorFlow 1.x and 2.x.\n\nInspired by **rusty1s/pytorch_geometric**\\ , we build a GNN library for TensorFlow.\n\nHomepage and Documentation\n--------------------------\n\n\n* Homepage: `https://github.com/CrawlScript/tf_geometric <https://github.com/CrawlScript/tf_geometric>`_\n* Documentation: `https://tf-geometric.readthedocs.io <https://tf-geometric.readthedocs.io>`_\n\nEfficient and Friendly\n----------------------\n\nWe use Message Passing mechanism to implement graph neural networks, which is way efficient than the dense matrix based implementations and more friendly than the sparse matrix based ones.\nIn addition, we provide easy and elegant APIs for complex GNN operations.\nThe following example constructs a graph and applies a Multi-head Graph Attention Network (GAT) on it:\n\n.. code-block:: python\n\n   # coding=utf-8\n   import numpy as np\n   import tf_geometric as tfg\n   import tensorflow as tf\n\n   graph = tfg.Graph(\n       x=np.random.randn(5, 20),  # 5 nodes, 20 features,\n       edge_index=[[0, 0, 1, 3],\n                   [1, 2, 2, 1]]  # 4 undirected edges\n   )\n\n   print(\"Graph Desc: \\n\", graph)\n\n   graph.convert_edge_to_directed()  # pre-process edges\n   print(\"Processed Graph Desc: \\n\", graph)\n   print(\"Processed Edge Index:\\n\", graph.edge_index)\n\n   # Multi-head Graph Attention Network (GAT)\n   gat_layer = tfg.layers.GAT(units=4, num_heads=4, activation=tf.nn.relu)\n   output = gat_layer([graph.x, graph.edge_index])\n   print(\"Output of GAT: \\n\", output)\n\nOutput:\n\n.. code-block::\n\n   Graph Desc:\n    Graph Shape: x => (5, 20)  edge_index => (2, 4)    y => None\n\n   Processed Graph Desc:\n    Graph Shape: x => (5, 20)  edge_index => (2, 8)    y => None\n\n   Processed Edge Index:\n    [[0 0 1 1 1 2 2 3]\n    [1 2 0 2 3 0 1 1]]\n\n   Output of GAT:\n    tf.Tensor(\n   [[0.22443159 0.         0.58263206 0.32468423]\n    [0.29810357 0.         0.19403605 0.35630274]\n    [0.18071976 0.         0.58263206 0.32468423]\n    [0.36123228 0.         0.88897204 0.450244  ]\n    [0.         0.         0.8013462  0.        ]], shape=(5, 4), dtype=float32)\n\nDEMO\n----\n\nWe recommend you to get started with some demo.\n\nNode Classification\n^^^^^^^^^^^^^^^^^^^\n\n\n* `Graph Convolutional Network (GCN) <demo/demo_gcn.py>`_\n* `Multi-head Graph Attention Network (GAT) <demo/demo_gat.py>`_\n\nLink Prediction\n^^^^^^^^^^^^^^^\n\n\n* `MeanPooling <demo/demo_mean_pool.py>`_\n* `SAGPooling <demo/demo_sag_pool_h.py>`_\n\nGraph Classification\n^^^^^^^^^^^^^^^^^^^^\n\n\n* `Graph Auto-Encoder (GAE) <demo/demo_gae.py>`_\n\nInstallation\n------------\n\nRequirements:\n\n\n* Operation System: Windows / Linux / Mac OS\n* Python: version >= 3.5\n* Python Packages:\n\n  * tensorflow/tensorflow-gpu: >= 1.14.0 or >= 2.0.0b1\n  * numpy >= 1.17.4\n  * networkx >= 2.1\n  * scipy >= 1.1.0\n\nUse one of the following commands below:\n\n.. code-block:: bash\n\n   pip install -U tf_geometric # this will not install the tensorflow/tensorflow-gpu package\n\n   pip install -U tf_geometric[tf1-cpu] # this will install TensorFlow 1.x CPU version\n\n   pip install -U tf_geometric[tf1-gpu] # this will install TensorFlow 1.x GPU version\n\n   pip install -U tf_geometric[tf2-cpu] # this will install TensorFlow 2.x CPU version\n\n   pip install -U tf_geometric[tf2-gpu] # this will install TensorFlow 2.x GPU version\n\nOOP and Functional API\n----------------------\n\nWe provide both OOP and Functional API, with which you can make some cool things.\n\n.. code-block:: python\n\n   # coding=utf-8\n   import os\n\n   # Enable GPU 0\n   os.environ[\"CUDA_VISIBLE_DEVICES\"] = \"0\"\n\n   import tf_geometric as tfg\n   import tensorflow as tf\n   import numpy as np\n   from tf_geometric.utils.graph_utils import convert_edge_to_directed\n\n   # ==================================== Graph Data Structure ====================================\n   # In tf_geometric, graph data can be either individual Tensors or Graph objects\n   # A graph usually consists of x(node features), edge_index and edge_weight(optional)\n\n   # Node Features => (num_nodes, num_features)\n   x = np.random.randn(5, 20).astype(np.float32) # 5 nodes, 20 features\n\n   # Edge Index => (2, num_edges)\n   # Each column of edge_index (u, v) represents an directed edge from u to v.\n   # Note that it does not cover the edge from v to u. You should provide (v, u) to cover it.\n   # This is not convenient for users.\n   # Thus, we allow users to provide edge_index in undirected form and convert it later.\n   # That is, we can only provide (u, v) and convert it to (u, v) and (v, u) with `convert_edge_to_directed` method.\n   edge_index = np.array([\n       [0, 0, 1, 3],\n       [1, 2, 2, 1]\n   ])\n\n   # Edge Weight => (num_edges)\n   edge_weight = np.array([0.9, 0.8, 0.1, 0.2]).astype(np.float32)\n\n   # Make the edge_index directed such that we can use it as the input of GCN\n   edge_index, [edge_weight] = convert_edge_to_directed(edge_index, [edge_weight])\n\n\n   # We can convert these numpy array as TensorFlow Tensors and pass them to gnn functions\n   outputs = tfg.nn.gcn(\n       tf.Variable(x),\n       tf.constant(edge_index),\n       tf.constant(edge_weight),\n       tf.Variable(tf.random.truncated_normal([20, 2])) # GCN Weight\n   )\n   print(outputs)\n\n   # Usually, we use a graph object to manager these information\n   # edge_weight is optional, we can set it to None if you don't need it\n   graph = tfg.Graph(x=x, edge_index=edge_index, edge_weight=edge_weight)\n\n   # You can easily convert these numpy arrays as Tensors with the Graph Object API\n   graph.convert_data_to_tensor()\n\n   # Then, we can use them without too many manual conversion\n   outputs = tfg.nn.gcn(\n       graph.x,\n       graph.edge_index,\n       graph.edge_weight,\n       tf.Variable(tf.random.truncated_normal([20, 2])),  # GCN Weight\n       cache=graph.cache  # GCN use caches to avoid re-computing of the normed edge information\n   )\n   print(outputs)\n\n\n   # For algorithms that deal with batches of graphs, we can pack a batch of graph into a BatchGraph object\n   # Batch graph wrap a batch of graphs into a single graph, where each nodes has an unique index and a graph index.\n   # The node_graph_index is the index of the corresponding graph for each node in the batch.\n   # The edge_graph_index is the index of the corresponding edge for each node in the batch.\n   batch_graph = tfg.BatchGraph.from_graphs([graph, graph, graph, graph])\n\n   # We can reversely split a BatchGraph object into Graphs objects\n   graphs = batch_graph.to_graphs()\n\n   # Graph Pooling algorithms often rely on such batch data structure\n   # Most of them accept a BatchGraph's data as input and output a feature vector for each graph in the batch\n   outputs = tfg.nn.mean_pool(batch_graph.x, batch_graph.node_graph_index, num_graphs=batch_graph.num_graphs)\n   print(outputs)\n\n   # We provide some advanced graph pooling operations such as topk_pool\n   node_score = tfg.nn.gcn(\n       batch_graph.x,\n       batch_graph.edge_index,\n       batch_graph.edge_weight,\n       tf.Variable(tf.random.truncated_normal([20, 1])),  # GCN Weight\n       cache=graph.cache  # GCN use caches to avoid re-computing of the normed edge information\n   )\n   node_score = tf.reshape(node_score, [-1])\n   topk_node_index = tfg.nn.topk_pool(batch_graph.node_graph_index, node_score, ratio=0.6)\n   print(topk_node_index)\n\n\n\n\n   # ==================================== Built-in Datasets ====================================\n   # all graph data are in numpy format\n   train_data, valid_data, test_data = tfg.datasets.PPIDataset().load_data()\n\n   # we can convert them into tensorflow format\n   test_data = [graph.convert_data_to_tensor() for graph in test_data]\n\n\n\n\n\n   # ==================================== Basic OOP API ====================================\n   # OOP Style GCN (Graph Convolutional Network)\n   gcn_layer = tfg.layers.GCN(units=20, activation=tf.nn.relu)\n\n   for graph in test_data:\n       # Cache can speed-up GCN by caching the normed edge information\n       outputs = gcn_layer([graph.x, graph.edge_index, graph.edge_weight], cache=graph.cache)\n       print(outputs)\n\n\n   # OOP Style GAT (Multi-head Graph Attention Network)\n   gat_layer = tfg.layers.GAT(units=20, activation=tf.nn.relu, num_heads=4)\n   for graph in test_data:\n       outputs = gat_layer([graph.x, graph.edge_index])\n       print(outputs)\n\n\n\n   # ==================================== Basic Functional API ====================================\n   # Functional Style GCN\n   # Functional API is more flexible for advanced algorithms\n   # You can pass both data and parameters to functional APIs\n\n   gcn_w = tf.Variable(tf.random.truncated_normal([test_data[0].num_features, 20]))\n   for graph in test_data:\n       outputs = tfg.nn.gcn(graph.x, edge_index, edge_weight, gcn_w, activation=tf.nn.relu)\n       print(outputs)\n\n\n   # ==================================== Advanced OOP API ====================================\n   # All APIs are implemented with Map-Reduce Style\n   # This is a gcn without weight normalization and transformation.\n   # Create your own GNN Layer by subclassing the MapReduceGNN class\n   class NaiveGCN(tfg.layers.MapReduceGNN):\n\n       def map(self, repeated_x, neighbor_x, edge_weight=None):\n           return tfg.nn.identity_mapper(repeated_x, neighbor_x, edge_weight)\n\n       def reduce(self, neighbor_msg, node_index, num_nodes=None):\n           return tfg.nn.sum_reducer(neighbor_msg, node_index, num_nodes)\n\n       def update(self, x, reduced_neighbor_msg):\n           return tfg.nn.sum_updater(x, reduced_neighbor_msg)\n\n\n   naive_gcn = NaiveGCN()\n\n   for graph in test_data:\n       print(naive_gcn([graph.x, graph.edge_index, graph.edge_weight]))\n\n\n   # ==================================== Advanced Functional API ====================================\n   # All APIs are implemented with Map-Reduce Style\n   # This is a gcn without without weight normalization and transformation\n   # Just pass the mapper/reducer/updater functions to the Functional API\n\n   for graph in test_data:\n       outputs = tfg.nn.aggregate_neighbors(\n           x=graph.x,\n           edge_index=graph.edge_index,\n           edge_weight=graph.edge_weight,\n           mapper=tfg.nn.identity_mapper,\n           reducer=tfg.nn.sum_reducer,\n           updater=tfg.nn.sum_updater\n       )\n       print(outputs)", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/CrawlScript/tf_geometric", "keywords": "", "license": "GNU General Public License v3.0 (See LICENSE)", "maintainer": "", "maintainer_email": "", "name": "tf-geometric", "package_url": "https://pypi.org/project/tf-geometric/", "platform": "", "project_url": "https://pypi.org/project/tf-geometric/", "project_urls": {"Homepage": "https://github.com/CrawlScript/tf_geometric"}, "release_url": "https://pypi.org/project/tf-geometric/0.0.23/", "requires_dist": null, "requires_python": ">3.5.0", "summary": " Efficient and Friendly Graph Neural Network Library for TensorFlow 1.x and 2.x. ", "version": "0.0.23", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Efficient and Friendly Graph Neural Network Library for TensorFlow 1.x and 2.x.</p>\n<p>Inspired by <strong>rusty1s/pytorch_geometric</strong>, we build a GNN library for TensorFlow.</p>\n<div id=\"homepage-and-documentation\">\n<h2>Homepage and Documentation</h2>\n<ul>\n<li>Homepage: <a href=\"https://github.com/CrawlScript/tf_geometric\" rel=\"nofollow\">https://github.com/CrawlScript/tf_geometric</a></li>\n<li>Documentation: <a href=\"https://tf-geometric.readthedocs.io\" rel=\"nofollow\">https://tf-geometric.readthedocs.io</a></li>\n</ul>\n</div>\n<div id=\"efficient-and-friendly\">\n<h2>Efficient and Friendly</h2>\n<p>We use Message Passing mechanism to implement graph neural networks, which is way efficient than the dense matrix based implementations and more friendly than the sparse matrix based ones.\nIn addition, we provide easy and elegant APIs for complex GNN operations.\nThe following example constructs a graph and applies a Multi-head Graph Attention Network (GAT) on it:</p>\n<pre><span class=\"c1\"># coding=utf-8</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">tf_geometric</span> <span class=\"k\">as</span> <span class=\"nn\">tfg</span>\n<span class=\"kn\">import</span> <span class=\"nn\">tensorflow</span> <span class=\"k\">as</span> <span class=\"nn\">tf</span>\n\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">Graph</span><span class=\"p\">(</span>\n    <span class=\"n\">x</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">),</span>  <span class=\"c1\"># 5 nodes, 20 features,</span>\n    <span class=\"n\">edge_index</span><span class=\"o\">=</span><span class=\"p\">[[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">],</span>\n                <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]]</span>  <span class=\"c1\"># 4 undirected edges</span>\n<span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Graph Desc: </span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"p\">)</span>\n\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">convert_edge_to_directed</span><span class=\"p\">()</span>  <span class=\"c1\"># pre-process edges</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Processed Graph Desc: </span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Processed Edge Index:</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edge_index</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Multi-head Graph Attention Network (GAT)</span>\n<span class=\"n\">gat_layer</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">layers</span><span class=\"o\">.</span><span class=\"n\">GAT</span><span class=\"p\">(</span><span class=\"n\">units</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">num_heads</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">activation</span><span class=\"o\">=</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">relu</span><span class=\"p\">)</span>\n<span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">gat_layer</span><span class=\"p\">([</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edge_index</span><span class=\"p\">])</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Output of GAT: </span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">,</span> <span class=\"n\">output</span><span class=\"p\">)</span>\n</pre>\n<p>Output:</p>\n<pre>Graph Desc:\n Graph Shape: x =&gt; (5, 20)  edge_index =&gt; (2, 4)    y =&gt; None\n\nProcessed Graph Desc:\n Graph Shape: x =&gt; (5, 20)  edge_index =&gt; (2, 8)    y =&gt; None\n\nProcessed Edge Index:\n [[0 0 1 1 1 2 2 3]\n [1 2 0 2 3 0 1 1]]\n\nOutput of GAT:\n tf.Tensor(\n[[0.22443159 0.         0.58263206 0.32468423]\n [0.29810357 0.         0.19403605 0.35630274]\n [0.18071976 0.         0.58263206 0.32468423]\n [0.36123228 0.         0.88897204 0.450244  ]\n [0.         0.         0.8013462  0.        ]], shape=(5, 4), dtype=float32)\n</pre>\n</div>\n<div id=\"demo\">\n<h2>DEMO</h2>\n<p>We recommend you to get started with some demo.</p>\n<div id=\"node-classification\">\n<h3>Node Classification</h3>\n<ul>\n<li><a href=\"demo/demo_gcn.py\" rel=\"nofollow\">Graph Convolutional Network (GCN)</a></li>\n<li><a href=\"demo/demo_gat.py\" rel=\"nofollow\">Multi-head Graph Attention Network (GAT)</a></li>\n</ul>\n</div>\n<div id=\"link-prediction\">\n<h3>Link Prediction</h3>\n<ul>\n<li><a href=\"demo/demo_mean_pool.py\" rel=\"nofollow\">MeanPooling</a></li>\n<li><a href=\"demo/demo_sag_pool_h.py\" rel=\"nofollow\">SAGPooling</a></li>\n</ul>\n</div>\n<div id=\"graph-classification\">\n<h3>Graph Classification</h3>\n<ul>\n<li><a href=\"demo/demo_gae.py\" rel=\"nofollow\">Graph Auto-Encoder (GAE)</a></li>\n</ul>\n</div>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>Requirements:</p>\n<ul>\n<li>Operation System: Windows / Linux / Mac OS</li>\n<li>Python: version &gt;= 3.5</li>\n<li>Python Packages:<ul>\n<li>tensorflow/tensorflow-gpu: &gt;= 1.14.0 or &gt;= 2.0.0b1</li>\n<li>numpy &gt;= 1.17.4</li>\n<li>networkx &gt;= 2.1</li>\n<li>scipy &gt;= 1.1.0</li>\n</ul>\n</li>\n</ul>\n<p>Use one of the following commands below:</p>\n<pre>pip install -U tf_geometric <span class=\"c1\"># this will not install the tensorflow/tensorflow-gpu package\n</span>\npip install -U tf_geometric<span class=\"o\">[</span>tf1-cpu<span class=\"o\">]</span> <span class=\"c1\"># this will install TensorFlow 1.x CPU version\n</span>\npip install -U tf_geometric<span class=\"o\">[</span>tf1-gpu<span class=\"o\">]</span> <span class=\"c1\"># this will install TensorFlow 1.x GPU version\n</span>\npip install -U tf_geometric<span class=\"o\">[</span>tf2-cpu<span class=\"o\">]</span> <span class=\"c1\"># this will install TensorFlow 2.x CPU version\n</span>\npip install -U tf_geometric<span class=\"o\">[</span>tf2-gpu<span class=\"o\">]</span> <span class=\"c1\"># this will install TensorFlow 2.x GPU version</span>\n</pre>\n</div>\n<div id=\"oop-and-functional-api\">\n<h2>OOP and Functional API</h2>\n<p>We provide both OOP and Functional API, with which you can make some cool things.</p>\n<pre><span class=\"c1\"># coding=utf-8</span>\n<span class=\"kn\">import</span> <span class=\"nn\">os</span>\n\n<span class=\"c1\"># Enable GPU 0</span>\n<span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">environ</span><span class=\"p\">[</span><span class=\"s2\">\"CUDA_VISIBLE_DEVICES\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s2\">\"0\"</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">tf_geometric</span> <span class=\"k\">as</span> <span class=\"nn\">tfg</span>\n<span class=\"kn\">import</span> <span class=\"nn\">tensorflow</span> <span class=\"k\">as</span> <span class=\"nn\">tf</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">tf_geometric.utils.graph_utils</span> <span class=\"kn\">import</span> <span class=\"n\">convert_edge_to_directed</span>\n\n<span class=\"c1\"># ==================================== Graph Data Structure ====================================</span>\n<span class=\"c1\"># In tf_geometric, graph data can be either individual Tensors or Graph objects</span>\n<span class=\"c1\"># A graph usually consists of x(node features), edge_index and edge_weight(optional)</span>\n\n<span class=\"c1\"># Node Features =&gt; (num_nodes, num_features)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randn</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">astype</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">)</span> <span class=\"c1\"># 5 nodes, 20 features</span>\n\n<span class=\"c1\"># Edge Index =&gt; (2, num_edges)</span>\n<span class=\"c1\"># Each column of edge_index (u, v) represents an directed edge from u to v.</span>\n<span class=\"c1\"># Note that it does not cover the edge from v to u. You should provide (v, u) to cover it.</span>\n<span class=\"c1\"># This is not convenient for users.</span>\n<span class=\"c1\"># Thus, we allow users to provide edge_index in undirected form and convert it later.</span>\n<span class=\"c1\"># That is, we can only provide (u, v) and convert it to (u, v) and (v, u) with `convert_edge_to_directed` method.</span>\n<span class=\"n\">edge_index</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span>\n    <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">],</span>\n    <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"p\">])</span>\n\n<span class=\"c1\"># Edge Weight =&gt; (num_edges)</span>\n<span class=\"n\">edge_weight</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">astype</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Make the edge_index directed such that we can use it as the input of GCN</span>\n<span class=\"n\">edge_index</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">edge_weight</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">convert_edge_to_directed</span><span class=\"p\">(</span><span class=\"n\">edge_index</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">edge_weight</span><span class=\"p\">])</span>\n\n\n<span class=\"c1\"># We can convert these numpy array as TensorFlow Tensors and pass them to gnn functions</span>\n<span class=\"n\">outputs</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">gcn</span><span class=\"p\">(</span>\n    <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Variable</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">),</span>\n    <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"n\">edge_index</span><span class=\"p\">),</span>\n    <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"n\">edge_weight</span><span class=\"p\">),</span>\n    <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Variable</span><span class=\"p\">(</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">truncated_normal</span><span class=\"p\">([</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]))</span> <span class=\"c1\"># GCN Weight</span>\n<span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">outputs</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Usually, we use a graph object to manager these information</span>\n<span class=\"c1\"># edge_weight is optional, we can set it to None if you don't need it</span>\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">Graph</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">edge_index</span><span class=\"o\">=</span><span class=\"n\">edge_index</span><span class=\"p\">,</span> <span class=\"n\">edge_weight</span><span class=\"o\">=</span><span class=\"n\">edge_weight</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># You can easily convert these numpy arrays as Tensors with the Graph Object API</span>\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">convert_data_to_tensor</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Then, we can use them without too many manual conversion</span>\n<span class=\"n\">outputs</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">gcn</span><span class=\"p\">(</span>\n    <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span>\n    <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edge_index</span><span class=\"p\">,</span>\n    <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edge_weight</span><span class=\"p\">,</span>\n    <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Variable</span><span class=\"p\">(</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">truncated_normal</span><span class=\"p\">([</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])),</span>  <span class=\"c1\"># GCN Weight</span>\n    <span class=\"n\">cache</span><span class=\"o\">=</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">cache</span>  <span class=\"c1\"># GCN use caches to avoid re-computing of the normed edge information</span>\n<span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">outputs</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># For algorithms that deal with batches of graphs, we can pack a batch of graph into a BatchGraph object</span>\n<span class=\"c1\"># Batch graph wrap a batch of graphs into a single graph, where each nodes has an unique index and a graph index.</span>\n<span class=\"c1\"># The node_graph_index is the index of the corresponding graph for each node in the batch.</span>\n<span class=\"c1\"># The edge_graph_index is the index of the corresponding edge for each node in the batch.</span>\n<span class=\"n\">batch_graph</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">BatchGraph</span><span class=\"o\">.</span><span class=\"n\">from_graphs</span><span class=\"p\">([</span><span class=\"n\">graph</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># We can reversely split a BatchGraph object into Graphs objects</span>\n<span class=\"n\">graphs</span> <span class=\"o\">=</span> <span class=\"n\">batch_graph</span><span class=\"o\">.</span><span class=\"n\">to_graphs</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Graph Pooling algorithms often rely on such batch data structure</span>\n<span class=\"c1\"># Most of them accept a BatchGraph's data as input and output a feature vector for each graph in the batch</span>\n<span class=\"n\">outputs</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">mean_pool</span><span class=\"p\">(</span><span class=\"n\">batch_graph</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">batch_graph</span><span class=\"o\">.</span><span class=\"n\">node_graph_index</span><span class=\"p\">,</span> <span class=\"n\">num_graphs</span><span class=\"o\">=</span><span class=\"n\">batch_graph</span><span class=\"o\">.</span><span class=\"n\">num_graphs</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">outputs</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># We provide some advanced graph pooling operations such as topk_pool</span>\n<span class=\"n\">node_score</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">gcn</span><span class=\"p\">(</span>\n    <span class=\"n\">batch_graph</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span>\n    <span class=\"n\">batch_graph</span><span class=\"o\">.</span><span class=\"n\">edge_index</span><span class=\"p\">,</span>\n    <span class=\"n\">batch_graph</span><span class=\"o\">.</span><span class=\"n\">edge_weight</span><span class=\"p\">,</span>\n    <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Variable</span><span class=\"p\">(</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">truncated_normal</span><span class=\"p\">([</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])),</span>  <span class=\"c1\"># GCN Weight</span>\n    <span class=\"n\">cache</span><span class=\"o\">=</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">cache</span>  <span class=\"c1\"># GCN use caches to avoid re-computing of the normed edge information</span>\n<span class=\"p\">)</span>\n<span class=\"n\">node_score</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">node_score</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"n\">topk_node_index</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">topk_pool</span><span class=\"p\">(</span><span class=\"n\">batch_graph</span><span class=\"o\">.</span><span class=\"n\">node_graph_index</span><span class=\"p\">,</span> <span class=\"n\">node_score</span><span class=\"p\">,</span> <span class=\"n\">ratio</span><span class=\"o\">=</span><span class=\"mf\">0.6</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">topk_node_index</span><span class=\"p\">)</span>\n\n\n\n\n<span class=\"c1\"># ==================================== Built-in Datasets ====================================</span>\n<span class=\"c1\"># all graph data are in numpy format</span>\n<span class=\"n\">train_data</span><span class=\"p\">,</span> <span class=\"n\">valid_data</span><span class=\"p\">,</span> <span class=\"n\">test_data</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">datasets</span><span class=\"o\">.</span><span class=\"n\">PPIDataset</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">load_data</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># we can convert them into tensorflow format</span>\n<span class=\"n\">test_data</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">convert_data_to_tensor</span><span class=\"p\">()</span> <span class=\"k\">for</span> <span class=\"n\">graph</span> <span class=\"ow\">in</span> <span class=\"n\">test_data</span><span class=\"p\">]</span>\n\n\n\n\n\n<span class=\"c1\"># ==================================== Basic OOP API ====================================</span>\n<span class=\"c1\"># OOP Style GCN (Graph Convolutional Network)</span>\n<span class=\"n\">gcn_layer</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">layers</span><span class=\"o\">.</span><span class=\"n\">GCN</span><span class=\"p\">(</span><span class=\"n\">units</span><span class=\"o\">=</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"n\">activation</span><span class=\"o\">=</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">relu</span><span class=\"p\">)</span>\n\n<span class=\"k\">for</span> <span class=\"n\">graph</span> <span class=\"ow\">in</span> <span class=\"n\">test_data</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Cache can speed-up GCN by caching the normed edge information</span>\n    <span class=\"n\">outputs</span> <span class=\"o\">=</span> <span class=\"n\">gcn_layer</span><span class=\"p\">([</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edge_index</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edge_weight</span><span class=\"p\">],</span> <span class=\"n\">cache</span><span class=\"o\">=</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">cache</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">outputs</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># OOP Style GAT (Multi-head Graph Attention Network)</span>\n<span class=\"n\">gat_layer</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">layers</span><span class=\"o\">.</span><span class=\"n\">GAT</span><span class=\"p\">(</span><span class=\"n\">units</span><span class=\"o\">=</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"n\">activation</span><span class=\"o\">=</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">relu</span><span class=\"p\">,</span> <span class=\"n\">num_heads</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">graph</span> <span class=\"ow\">in</span> <span class=\"n\">test_data</span><span class=\"p\">:</span>\n    <span class=\"n\">outputs</span> <span class=\"o\">=</span> <span class=\"n\">gat_layer</span><span class=\"p\">([</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edge_index</span><span class=\"p\">])</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">outputs</span><span class=\"p\">)</span>\n\n\n\n<span class=\"c1\"># ==================================== Basic Functional API ====================================</span>\n<span class=\"c1\"># Functional Style GCN</span>\n<span class=\"c1\"># Functional API is more flexible for advanced algorithms</span>\n<span class=\"c1\"># You can pass both data and parameters to functional APIs</span>\n\n<span class=\"n\">gcn_w</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Variable</span><span class=\"p\">(</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">truncated_normal</span><span class=\"p\">([</span><span class=\"n\">test_data</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">num_features</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">]))</span>\n<span class=\"k\">for</span> <span class=\"n\">graph</span> <span class=\"ow\">in</span> <span class=\"n\">test_data</span><span class=\"p\">:</span>\n    <span class=\"n\">outputs</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">gcn</span><span class=\"p\">(</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">edge_index</span><span class=\"p\">,</span> <span class=\"n\">edge_weight</span><span class=\"p\">,</span> <span class=\"n\">gcn_w</span><span class=\"p\">,</span> <span class=\"n\">activation</span><span class=\"o\">=</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">relu</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">outputs</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># ==================================== Advanced OOP API ====================================</span>\n<span class=\"c1\"># All APIs are implemented with Map-Reduce Style</span>\n<span class=\"c1\"># This is a gcn without weight normalization and transformation.</span>\n<span class=\"c1\"># Create your own GNN Layer by subclassing the MapReduceGNN class</span>\n<span class=\"k\">class</span> <span class=\"nc\">NaiveGCN</span><span class=\"p\">(</span><span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">layers</span><span class=\"o\">.</span><span class=\"n\">MapReduceGNN</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">map</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">repeated_x</span><span class=\"p\">,</span> <span class=\"n\">neighbor_x</span><span class=\"p\">,</span> <span class=\"n\">edge_weight</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">identity_mapper</span><span class=\"p\">(</span><span class=\"n\">repeated_x</span><span class=\"p\">,</span> <span class=\"n\">neighbor_x</span><span class=\"p\">,</span> <span class=\"n\">edge_weight</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">reduce</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">neighbor_msg</span><span class=\"p\">,</span> <span class=\"n\">node_index</span><span class=\"p\">,</span> <span class=\"n\">num_nodes</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">sum_reducer</span><span class=\"p\">(</span><span class=\"n\">neighbor_msg</span><span class=\"p\">,</span> <span class=\"n\">node_index</span><span class=\"p\">,</span> <span class=\"n\">num_nodes</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">reduced_neighbor_msg</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">sum_updater</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">reduced_neighbor_msg</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">naive_gcn</span> <span class=\"o\">=</span> <span class=\"n\">NaiveGCN</span><span class=\"p\">()</span>\n\n<span class=\"k\">for</span> <span class=\"n\">graph</span> <span class=\"ow\">in</span> <span class=\"n\">test_data</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">naive_gcn</span><span class=\"p\">([</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edge_index</span><span class=\"p\">,</span> <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edge_weight</span><span class=\"p\">]))</span>\n\n\n<span class=\"c1\"># ==================================== Advanced Functional API ====================================</span>\n<span class=\"c1\"># All APIs are implemented with Map-Reduce Style</span>\n<span class=\"c1\"># This is a gcn without without weight normalization and transformation</span>\n<span class=\"c1\"># Just pass the mapper/reducer/updater functions to the Functional API</span>\n\n<span class=\"k\">for</span> <span class=\"n\">graph</span> <span class=\"ow\">in</span> <span class=\"n\">test_data</span><span class=\"p\">:</span>\n    <span class=\"n\">outputs</span> <span class=\"o\">=</span> <span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">aggregate_neighbors</span><span class=\"p\">(</span>\n        <span class=\"n\">x</span><span class=\"o\">=</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">x</span><span class=\"p\">,</span>\n        <span class=\"n\">edge_index</span><span class=\"o\">=</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edge_index</span><span class=\"p\">,</span>\n        <span class=\"n\">edge_weight</span><span class=\"o\">=</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edge_weight</span><span class=\"p\">,</span>\n        <span class=\"n\">mapper</span><span class=\"o\">=</span><span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">identity_mapper</span><span class=\"p\">,</span>\n        <span class=\"n\">reducer</span><span class=\"o\">=</span><span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">sum_reducer</span><span class=\"p\">,</span>\n        <span class=\"n\">updater</span><span class=\"o\">=</span><span class=\"n\">tfg</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">sum_updater</span>\n    <span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">outputs</span><span class=\"p\">)</span>\n</pre>\n</div>\n\n          </div>"}, "last_serial": 6920470, "releases": {"0.0.17": [{"comment_text": "", "digests": {"md5": "6cc4d6c9fff17386a720139c960a849a", "sha256": "2130bd2cc3143af603b54cdcfc5160c834a8a4b53b926ed83f371fbb5706d710"}, "downloads": -1, "filename": "tf_geometric-0.0.17.tar.gz", "has_sig": false, "md5_digest": "6cc4d6c9fff17386a720139c960a849a", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.5.0", "size": 19533, "upload_time": "2020-02-03T18:03:54", "upload_time_iso_8601": "2020-02-03T18:03:54.213686Z", "url": "https://files.pythonhosted.org/packages/dd/25/6033cab03e406575ef30b769a96631f998d0a6e730caff42fde9fdfa3a63/tf_geometric-0.0.17.tar.gz", "yanked": false}], "0.0.18": [{"comment_text": "", "digests": {"md5": "80d1ceea58b96f7e4de5c9f5927247b1", "sha256": "dd75087c70a71dbacf4a49ab47228738aa9ffe1101afe3011fa895b10b02f345"}, "downloads": -1, "filename": "tf_geometric-0.0.18.tar.gz", "has_sig": false, "md5_digest": "80d1ceea58b96f7e4de5c9f5927247b1", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.5.0", "size": 21353, "upload_time": "2020-02-04T16:57:08", "upload_time_iso_8601": "2020-02-04T16:57:08.985578Z", "url": "https://files.pythonhosted.org/packages/86/e4/c4945d401166cdbc8676b6c361f960d18b8e57d981f0526067b0740e60d7/tf_geometric-0.0.18.tar.gz", "yanked": false}], "0.0.19": [{"comment_text": "", "digests": {"md5": "4eac39893d916b47e0acb11c24999edb", "sha256": "7dc7616b584b1ad8375378da2e92777af247afd8d3916be39aaa88f4f9b0d2b2"}, "downloads": -1, "filename": "tf_geometric-0.0.19.tar.gz", "has_sig": false, "md5_digest": "4eac39893d916b47e0acb11c24999edb", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.5.0", "size": 21386, "upload_time": "2020-03-16T06:39:14", "upload_time_iso_8601": "2020-03-16T06:39:14.584658Z", "url": "https://files.pythonhosted.org/packages/9f/bd/4bf61002fc058806609ca92b5d6a0880da5ff6d5cd2ce3c15ff423aafb0a/tf_geometric-0.0.19.tar.gz", "yanked": false}], "0.0.20": [{"comment_text": "", "digests": {"md5": "c73589ce6fe47604595886b9724c0c99", "sha256": "833899cf85f499e41ce8468e6e3d57fe71dca674a51ca649f1cc76519775f629"}, "downloads": -1, "filename": "tf_geometric-0.0.20.tar.gz", "has_sig": false, "md5_digest": "c73589ce6fe47604595886b9724c0c99", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.5.0", "size": 21890, "upload_time": "2020-03-17T16:06:39", "upload_time_iso_8601": "2020-03-17T16:06:39.578231Z", "url": "https://files.pythonhosted.org/packages/6f/07/3dc9ed0eee34c82de6b56d6d93a5b63a72022b0f9c5a684b1ff3b0ae22a4/tf_geometric-0.0.20.tar.gz", "yanked": false}], "0.0.21": [{"comment_text": "", "digests": {"md5": "3f18f8a7630a561d3ba5112cd91bb8af", "sha256": "fcb9cd5dd32d4920da122013da2fb7a7266c133f345e2631b93cb544e75574fe"}, "downloads": -1, "filename": "tf_geometric-0.0.21.tar.gz", "has_sig": false, "md5_digest": "3f18f8a7630a561d3ba5112cd91bb8af", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.5.0", "size": 22077, "upload_time": "2020-03-22T07:16:53", "upload_time_iso_8601": "2020-03-22T07:16:53.178299Z", "url": "https://files.pythonhosted.org/packages/dd/da/88158e2f05c0f2d1827a3fec40ecaa9dbccc9055e8569ffc28621eb1a728/tf_geometric-0.0.21.tar.gz", "yanked": false}], "0.0.22": [{"comment_text": "", "digests": {"md5": "d1089ea18d5ae32c833f323dd8ea7e60", "sha256": "b1e02d29f6e8644444a41b101a9a99abb54324a02c5052e83044b8dcf20bdbb6"}, "downloads": -1, "filename": "tf_geometric-0.0.22.tar.gz", "has_sig": false, "md5_digest": "d1089ea18d5ae32c833f323dd8ea7e60", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.5.0", "size": 22127, "upload_time": "2020-03-22T07:32:31", "upload_time_iso_8601": "2020-03-22T07:32:31.602383Z", "url": "https://files.pythonhosted.org/packages/be/76/f5b55b15e6bdd9d217eb725b6fc92835b8f1485697fa75f33122c6b68af3/tf_geometric-0.0.22.tar.gz", "yanked": false}], "0.0.23": [{"comment_text": "", "digests": {"md5": "d9c6dc937d7cada89a48191f79e223ba", "sha256": "1853d17507369046386c1712f0cb25e922be1b0b70d26f2b8129e1c125c0d72c"}, "downloads": -1, "filename": "tf_geometric-0.0.23.tar.gz", "has_sig": false, "md5_digest": "d9c6dc937d7cada89a48191f79e223ba", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.5.0", "size": 22153, "upload_time": "2020-03-31T14:15:15", "upload_time_iso_8601": "2020-03-31T14:15:15.843408Z", "url": "https://files.pythonhosted.org/packages/ab/7b/7c4de6791ca59c83f5ef62dcca2a4669e237e87468c03fb1bc3f9426b979/tf_geometric-0.0.23.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d9c6dc937d7cada89a48191f79e223ba", "sha256": "1853d17507369046386c1712f0cb25e922be1b0b70d26f2b8129e1c125c0d72c"}, "downloads": -1, "filename": "tf_geometric-0.0.23.tar.gz", "has_sig": false, "md5_digest": "d9c6dc937d7cada89a48191f79e223ba", "packagetype": "sdist", "python_version": "source", "requires_python": ">3.5.0", "size": 22153, "upload_time": "2020-03-31T14:15:15", "upload_time_iso_8601": "2020-03-31T14:15:15.843408Z", "url": "https://files.pythonhosted.org/packages/ab/7b/7c4de6791ca59c83f5ef62dcca2a4669e237e87468c03fb1bc3f9426b979/tf_geometric-0.0.23.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:54:34 2020"}