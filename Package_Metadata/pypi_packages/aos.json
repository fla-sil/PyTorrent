{"info": {"author": "Nishant Sinha", "author_email": "nishant@offnote.co", "bugtrack_url": null, "classifiers": ["Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Operating System :: OS Independent", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: Artificial Intelligence", "Topic :: Software Development"], "description": "![experimental](https://img.shields.io/badge/stability-experimental-orange.svg)\n\n# And-Or Shape (aos) Language\n\n\nWriting data pipelines involves complex data transformations over nested data, e.g., list of dictionaries or dictionary of tensors. \n\n- The *shape* of nested data is not explicit in code and hence not accessible readily to the developer.\n- Leads to cognitive burden (guessing shapes), technical debt and inadvertent programming errors.\n- Data pipelines are very opaque to examination and comprehension.\n\n---\n\n`aos` is a compact, regex-like language for describing the shapes (schemas) of both homogeneous (tensors) and heterogeneous (dictionaries, tables) data, and combinations, independent of the specific data library. \n\n* Based on an intuitive **regex-like** algebra of data shapes.\n* **Infer** `aos` shape from a data instance: `aos.infer.infer_aos`.\n* **Validate** data against `aos` shapes anywhere: `aos.checker.instanceof`.\n* **Transform** data using `aos` shapes, declaratively: `aos.tfm.do_tfm`.\n* Allows writing explicit data shapes, **inline** in code. In Python, use type annotations.\n* Write shapes for a variety of data conveniently -- Python native objects (`dict`, `list`, scalars), tensors (`numpy`,` pytorch`, `tf`), `pandas`,`hdf5`,`tiledb`,`xarray`,`struct-tensor`, etc.\n\n### Installation\n\n```pip install aos```\n\n## Shape of Data ?\n\nConsider a few quick examples.\n\n- the shape of scalar data is simply its type, e.g., `int`, ` float`, `str`, ...\n- for nested data, eg.  list of `int`s:  `(int)*`\n- for a dictionary of form `{'a': 3, b: 'hi'}` : shape is  `(a & int) | (b & str)`.\n\nNow, we can describe the shape of *arbitrary, nested* data with these `&`(and)- `|`(or) expressions. Intuitively, a list is an `or`-structure, a dictionary is an `or` of `and`s, a tensor is an `and`-structure, and so on.\n\n* Why is a `list` an or-structure? Ask: how do we *access* any value `v` in the `list`? Choose **some** index of the list, corresponding to the value `v`. \n* Similarly, a `dictionary` is an or-and structure: we pick **one** of the *key*s, together (**and**) with its *value*.\n* In contrast, an n-dimensional `tensor` has an `and`-shape: we must choose indices from *all* the dimensions of the tensor to access a scalar value. \n* In general, for a data structure, we *ask*: what choices must we make to access a scalar value?\n\nThinking in terms of `and`-`or` shapes takes a bit of practice initially. Read more about the and-or expressions [here](docs/and-or-thinking.md).\n\n#### More complex `aos` examples\n\n* Lists over shape `s` are denoted as `(s)*`.  Shorthand for `(s|..|s)`.\n* Dictionary: `(k1 & v1) | (k2 & v2) | ... | (kn & vn)` where `ki` and `vi` is the `i`th key and value.\n* Pandas tables: `(n & ( (c1&int)| (c2&str) | ... | (cn&str) )` where `n` is the row dimension (the number of rows) and `c1,...,cn` are column names.\n\nThe `aos` expressions are very *compact*. For example, consider a highly nested Python object `X` of type\n\n `Sequence[Tuple[Tuple[str, int], Dict[str, str]]]`  \n\nThis is both verbose and hard to interpret. Instead, `X`'s `aos` is written compactly as\n `((str|int) | (str : str))* `.\n\n> The full data shape may be irrelevant in many cases. To keep it brief, the language supports wildcards: `_` and `...` to allow writing partial shapes. \n>\n> So, we could write a dictionary's shape as `(k1 & ...)| ... | (kn & ...)`.\n\n\n\n## Shape Inference\n\nUnearthing the shape of opaque data instances, e.g., returned from a web request, or passed into a function call, is a major pain. \n\n* Use `aos.infer.infer_aos` to obtain compact shapes of arbitrary data instances.\n* From command line, run `aos-infer <filename.json>`\n\n```python\nfrom aos.infer import infer_aos\n\ndef test_infer():\n\n  d = {\n      \"checked\": False,\n      \"dimensions\": { \"width\": 5, \"height\": 10},\n      \"id\": 1,\n      \"name\": \"A green door\",\n      \"price\": 12.5,\n      \"tags\": [\"home\",\"green\"]\n  }\n\n  infer_aos(d) \n\n  # ((checked & bool) \n  # | (dimensions & ((width & int) | (height & int)))\n  # | (id & int) | (name & str) | (price & float) | (tags & (str *)))\n\n  dlist = []\n  for i in range(100):\n      d['id'] = i\n      dlist.append(d.copy())\n\n  infer_aos(dlist) \n\n  # ((checked & bool) \n  # | (dimensions & ((width & int) | (height & int)))\n  # | (id & int) | (name & str) | (price & float) | (tags & (str *)))*\n\n\n```\n\n\n\n## Shape/Schema Validation\n\nUsing `aos.checker.instanceof`, we can \n\n* write `aos` assertions to validate data shapes (schemas). \n* validate data structure partially using placeholders:  `_` matches a scalar, `...` matches an arbitrary object (sub-tree).\n* works with python objects, pandas, numpy, ..., extensible to other data types (libraries).\n\n```python\nfrom aos.checker import instanceof\n\ndef test_pyobj():\n    d = {'city': 'New York', 'country': 'USA'}\n    t1 = ('Google', 2001)\n    t2 = (t1, d)\n\n    instanceof(t2, '(str | int) | (str & str)') #valid\n    instanceof(t2, '... | (str & _)') #valid\n    instanceof(t2, '(_ | _) | (str & int)') #error\n\n    tlist = [('a', 1), ('b', 2)]\n    instanceof(tlist, '(str | int)*') #valid\n\ndef test_pandas():\n    d =  {'id': 'CS2_056', 'cost': 2, 'name': 'Tap'}\n    df = pd.DataFrame([d.items()], columns=list(d.keys()) )\n\n    instanceof(df, '1 & (id | cost | name)')\n\ndef test_numpy():\n    #arr = np.array()\n    arr = np.array([[1,2,3],[4,5,6]]) \n    instanceof(arr, '2 & 3')\n\ndef test_pytorch():\n    #arr = np.array()\n    arr = torch.tensor([[1,2,3],[4,5,6]])\n    instanceof(arr, '2 & 3')\n```\n\n\n\n## Transformations with AOS\n\nBecause `aos` expressions can both *match* and *specify* heterogeneous data shapes, we can write `aos` **rules** to **transform** data. \n\nThe rules are written as `lhs -> rhs`, where both `lhs` and `rhs` are `aos` expressions:\n\n* `lhs` *matches* a part (sub-tree) of the input data instance *I*. \n* `query` variables in the `lhs` *capture* (bind with) parts of *I*.\n* `rhs` specifies the expected shape (aos) of the output data instance *O*.\n\nTo write rules, ask: which *parts* of *I*, do we need to construct *O* ?\n\n```python\nfrom aos.tfm import do_tfm\ndef tfm_example():\n    # input data\n    I = {'items': [{'k': 1}, {'k': 2}, {'k': 3}],\n        'names': ['A', 'B', 'C']}\n\n    # specify transformation (left aos -> right aos)\n    # using `query` variables `k` and `v`\n\n    # here `k` binds with each of the keys in the list and \n    # `v` binds with the corresponding value\n    # the `lhs` automatically ignores parts of I, which are irrelevant to O\n\n    tfm = 'items & (k & v)* -> values & (v)*'\n\n    O = do_tfm(I, tfm)\n    print(O) # {'values': [1, 2, 3]}\n```\n\n\n\nThe above example illustrates a simple JSON transformation using `aos` rules. Rules can be more complex, e.g., include *conditions*, *function* application on query variables. They work not only with JSON data, but also apply to heterogeneous nested objects.\n\nSee more examples [here](tests/test_tfm_json.py) and [here](tests/test_tfm_spark_json.py). \n\n\n\n## And-Or Shape Dimensions\n\nThe above examples of use strings or type names (`str`) or integer values (`2`,`3`) in shape expressions. A more principled approach is to first declare **dimension names** and define shape over these names. \n\nData is defined over two kinds of dimensions:\n\n* **Continuous**. A range of values, e.g., a numpy array of shape (5, 200) is defined over two continuous dimensions, say `n` and `d`, where `n` ranges over values `0-4` and `d` ranges over `0-199`.\n* **Categorical**. A set of names, e.g., a dictionary `{'a': 4, 'b': 5}` is defined over *keys*  (dim names) `['a', 'b']`. One can also view each key, e.g., `a` or `b` , as a **Singleton** dimension.\n\n\n\n**Programmatic API**. The library provides an API to declare both type of dimensions and `aos` expressions over these dimensions, e.g., declare `n` and `d` as two continuous dimensions and then define shape `n & d`.\n\n\n\n## Status\n\n*The library is under active development. More documentation coming soon..*\n\n\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ofnote/aos", "keywords": "", "license": "Apache 2.0", "maintainer": "", "maintainer_email": "", "name": "aos", "package_url": "https://pypi.org/project/aos/", "platform": "POSIX", "project_url": "https://pypi.org/project/aos/", "project_urls": {"Homepage": "https://github.com/ofnote/aos"}, "release_url": "https://pypi.org/project/aos/0.1.2/", "requires_dist": null, "requires_python": "", "summary": "A shape language for arbitrary data", "version": "0.1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><img alt=\"experimental\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6dde6f958579c153d24bcb2f66de81207d4d9217/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f73746162696c6974792d6578706572696d656e74616c2d6f72616e67652e737667\"></p>\n<h1>And-Or Shape (aos) Language</h1>\n<p>Writing data pipelines involves complex data transformations over nested data, e.g., list of dictionaries or dictionary of tensors.</p>\n<ul>\n<li>The <em>shape</em> of nested data is not explicit in code and hence not accessible readily to the developer.</li>\n<li>Leads to cognitive burden (guessing shapes), technical debt and inadvertent programming errors.</li>\n<li>Data pipelines are very opaque to examination and comprehension.</li>\n</ul>\n<hr>\n<p><code>aos</code> is a compact, regex-like language for describing the shapes (schemas) of both homogeneous (tensors) and heterogeneous (dictionaries, tables) data, and combinations, independent of the specific data library.</p>\n<ul>\n<li>Based on an intuitive <strong>regex-like</strong> algebra of data shapes.</li>\n<li><strong>Infer</strong> <code>aos</code> shape from a data instance: <code>aos.infer.infer_aos</code>.</li>\n<li><strong>Validate</strong> data against <code>aos</code> shapes anywhere: <code>aos.checker.instanceof</code>.</li>\n<li><strong>Transform</strong> data using <code>aos</code> shapes, declaratively: <code>aos.tfm.do_tfm</code>.</li>\n<li>Allows writing explicit data shapes, <strong>inline</strong> in code. In Python, use type annotations.</li>\n<li>Write shapes for a variety of data conveniently -- Python native objects (<code>dict</code>, <code>list</code>, scalars), tensors (<code>numpy</code>,<code>pytorch</code>, <code>tf</code>), <code>pandas</code>,<code>hdf5</code>,<code>tiledb</code>,<code>xarray</code>,<code>struct-tensor</code>, etc.</li>\n</ul>\n<h3>Installation</h3>\n<p><code>pip install aos</code></p>\n<h2>Shape of Data ?</h2>\n<p>Consider a few quick examples.</p>\n<ul>\n<li>the shape of scalar data is simply its type, e.g., <code>int</code>, <code>float</code>, <code>str</code>, ...</li>\n<li>for nested data, eg.  list of <code>int</code>s:  <code>(int)*</code></li>\n<li>for a dictionary of form <code>{'a': 3, b: 'hi'}</code> : shape is  <code>(a &amp; int) | (b &amp; str)</code>.</li>\n</ul>\n<p>Now, we can describe the shape of <em>arbitrary, nested</em> data with these <code>&amp;</code>(and)- <code>|</code>(or) expressions. Intuitively, a list is an <code>or</code>-structure, a dictionary is an <code>or</code> of <code>and</code>s, a tensor is an <code>and</code>-structure, and so on.</p>\n<ul>\n<li>Why is a <code>list</code> an or-structure? Ask: how do we <em>access</em> any value <code>v</code> in the <code>list</code>? Choose <strong>some</strong> index of the list, corresponding to the value <code>v</code>.</li>\n<li>Similarly, a <code>dictionary</code> is an or-and structure: we pick <strong>one</strong> of the <em>key</em>s, together (<strong>and</strong>) with its <em>value</em>.</li>\n<li>In contrast, an n-dimensional <code>tensor</code> has an <code>and</code>-shape: we must choose indices from <em>all</em> the dimensions of the tensor to access a scalar value.</li>\n<li>In general, for a data structure, we <em>ask</em>: what choices must we make to access a scalar value?</li>\n</ul>\n<p>Thinking in terms of <code>and</code>-<code>or</code> shapes takes a bit of practice initially. Read more about the and-or expressions <a href=\"docs/and-or-thinking.md\" rel=\"nofollow\">here</a>.</p>\n<h4>More complex <code>aos</code> examples</h4>\n<ul>\n<li>Lists over shape <code>s</code> are denoted as <code>(s)*</code>.  Shorthand for <code>(s|..|s)</code>.</li>\n<li>Dictionary: <code>(k1 &amp; v1) | (k2 &amp; v2) | ... | (kn &amp; vn)</code> where <code>ki</code> and <code>vi</code> is the <code>i</code>th key and value.</li>\n<li>Pandas tables: <code>(n &amp; ( (c1&amp;int)| (c2&amp;str) | ... | (cn&amp;str) )</code> where <code>n</code> is the row dimension (the number of rows) and <code>c1,...,cn</code> are column names.</li>\n</ul>\n<p>The <code>aos</code> expressions are very <em>compact</em>. For example, consider a highly nested Python object <code>X</code> of type</p>\n<p><code>Sequence[Tuple[Tuple[str, int], Dict[str, str]]]</code></p>\n<p>This is both verbose and hard to interpret. Instead, <code>X</code>'s <code>aos</code> is written compactly as\n<code>((str|int) | (str : str))*</code>.</p>\n<blockquote>\n<p>The full data shape may be irrelevant in many cases. To keep it brief, the language supports wildcards: <code>_</code> and <code>...</code> to allow writing partial shapes.</p>\n<p>So, we could write a dictionary's shape as <code>(k1 &amp; ...)| ... | (kn &amp; ...)</code>.</p>\n</blockquote>\n<h2>Shape Inference</h2>\n<p>Unearthing the shape of opaque data instances, e.g., returned from a web request, or passed into a function call, is a major pain.</p>\n<ul>\n<li>Use <code>aos.infer.infer_aos</code> to obtain compact shapes of arbitrary data instances.</li>\n<li>From command line, run <code>aos-infer &lt;filename.json&gt;</code></li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">aos.infer</span> <span class=\"kn\">import</span> <span class=\"n\">infer_aos</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_infer</span><span class=\"p\">():</span>\n\n  <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n      <span class=\"s2\">\"checked\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n      <span class=\"s2\">\"dimensions\"</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"s2\">\"width\"</span><span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"s2\">\"height\"</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">},</span>\n      <span class=\"s2\">\"id\"</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n      <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"A green door\"</span><span class=\"p\">,</span>\n      <span class=\"s2\">\"price\"</span><span class=\"p\">:</span> <span class=\"mf\">12.5</span><span class=\"p\">,</span>\n      <span class=\"s2\">\"tags\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"home\"</span><span class=\"p\">,</span><span class=\"s2\">\"green\"</span><span class=\"p\">]</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">infer_aos</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">)</span> \n\n  <span class=\"c1\"># ((checked &amp; bool) </span>\n  <span class=\"c1\"># | (dimensions &amp; ((width &amp; int) | (height &amp; int)))</span>\n  <span class=\"c1\"># | (id &amp; int) | (name &amp; str) | (price &amp; float) | (tags &amp; (str *)))</span>\n\n  <span class=\"n\">dlist</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n  <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">):</span>\n      <span class=\"n\">d</span><span class=\"p\">[</span><span class=\"s1\">'id'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span>\n      <span class=\"n\">dlist</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">())</span>\n\n  <span class=\"n\">infer_aos</span><span class=\"p\">(</span><span class=\"n\">dlist</span><span class=\"p\">)</span> \n\n  <span class=\"c1\"># ((checked &amp; bool) </span>\n  <span class=\"c1\"># | (dimensions &amp; ((width &amp; int) | (height &amp; int)))</span>\n  <span class=\"c1\"># | (id &amp; int) | (name &amp; str) | (price &amp; float) | (tags &amp; (str *)))*</span>\n</pre>\n<h2>Shape/Schema Validation</h2>\n<p>Using <code>aos.checker.instanceof</code>, we can</p>\n<ul>\n<li>write <code>aos</code> assertions to validate data shapes (schemas).</li>\n<li>validate data structure partially using placeholders:  <code>_</code> matches a scalar, <code>...</code> matches an arbitrary object (sub-tree).</li>\n<li>works with python objects, pandas, numpy, ..., extensible to other data types (libraries).</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">aos.checker</span> <span class=\"kn\">import</span> <span class=\"n\">instanceof</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_pyobj</span><span class=\"p\">():</span>\n    <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'city'</span><span class=\"p\">:</span> <span class=\"s1\">'New York'</span><span class=\"p\">,</span> <span class=\"s1\">'country'</span><span class=\"p\">:</span> <span class=\"s1\">'USA'</span><span class=\"p\">}</span>\n    <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'Google'</span><span class=\"p\">,</span> <span class=\"mi\">2001</span><span class=\"p\">)</span>\n    <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">t1</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">)</span>\n\n    <span class=\"n\">instanceof</span><span class=\"p\">(</span><span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"s1\">'(str | int) | (str &amp; str)'</span><span class=\"p\">)</span> <span class=\"c1\">#valid</span>\n    <span class=\"n\">instanceof</span><span class=\"p\">(</span><span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"s1\">'... | (str &amp; _)'</span><span class=\"p\">)</span> <span class=\"c1\">#valid</span>\n    <span class=\"n\">instanceof</span><span class=\"p\">(</span><span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"s1\">'(_ | _) | (str &amp; int)'</span><span class=\"p\">)</span> <span class=\"c1\">#error</span>\n\n    <span class=\"n\">tlist</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)]</span>\n    <span class=\"n\">instanceof</span><span class=\"p\">(</span><span class=\"n\">tlist</span><span class=\"p\">,</span> <span class=\"s1\">'(str | int)*'</span><span class=\"p\">)</span> <span class=\"c1\">#valid</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_pandas</span><span class=\"p\">():</span>\n    <span class=\"n\">d</span> <span class=\"o\">=</span>  <span class=\"p\">{</span><span class=\"s1\">'id'</span><span class=\"p\">:</span> <span class=\"s1\">'CS2_056'</span><span class=\"p\">,</span> <span class=\"s1\">'cost'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'Tap'</span><span class=\"p\">}</span>\n    <span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">([</span><span class=\"n\">d</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()],</span> <span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())</span> <span class=\"p\">)</span>\n\n    <span class=\"n\">instanceof</span><span class=\"p\">(</span><span class=\"n\">df</span><span class=\"p\">,</span> <span class=\"s1\">'1 &amp; (id | cost | name)'</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_numpy</span><span class=\"p\">():</span>\n    <span class=\"c1\">#arr = np.array()</span>\n    <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">],[</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">]])</span> \n    <span class=\"n\">instanceof</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">,</span> <span class=\"s1\">'2 &amp; 3'</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_pytorch</span><span class=\"p\">():</span>\n    <span class=\"c1\">#arr = np.array()</span>\n    <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">([[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">],[</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">6</span><span class=\"p\">]])</span>\n    <span class=\"n\">instanceof</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">,</span> <span class=\"s1\">'2 &amp; 3'</span><span class=\"p\">)</span>\n</pre>\n<h2>Transformations with AOS</h2>\n<p>Because <code>aos</code> expressions can both <em>match</em> and <em>specify</em> heterogeneous data shapes, we can write <code>aos</code> <strong>rules</strong> to <strong>transform</strong> data.</p>\n<p>The rules are written as <code>lhs -&gt; rhs</code>, where both <code>lhs</code> and <code>rhs</code> are <code>aos</code> expressions:</p>\n<ul>\n<li><code>lhs</code> <em>matches</em> a part (sub-tree) of the input data instance <em>I</em>.</li>\n<li><code>query</code> variables in the <code>lhs</code> <em>capture</em> (bind with) parts of <em>I</em>.</li>\n<li><code>rhs</code> specifies the expected shape (aos) of the output data instance <em>O</em>.</li>\n</ul>\n<p>To write rules, ask: which <em>parts</em> of <em>I</em>, do we need to construct <em>O</em> ?</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">aos.tfm</span> <span class=\"kn\">import</span> <span class=\"n\">do_tfm</span>\n<span class=\"k\">def</span> <span class=\"nf\">tfm_example</span><span class=\"p\">():</span>\n    <span class=\"c1\"># input data</span>\n    <span class=\"n\">I</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'items'</span><span class=\"p\">:</span> <span class=\"p\">[{</span><span class=\"s1\">'k'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"s1\">'k'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"s1\">'k'</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">}],</span>\n        <span class=\"s1\">'names'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'A'</span><span class=\"p\">,</span> <span class=\"s1\">'B'</span><span class=\"p\">,</span> <span class=\"s1\">'C'</span><span class=\"p\">]}</span>\n\n    <span class=\"c1\"># specify transformation (left aos -&gt; right aos)</span>\n    <span class=\"c1\"># using `query` variables `k` and `v`</span>\n\n    <span class=\"c1\"># here `k` binds with each of the keys in the list and </span>\n    <span class=\"c1\"># `v` binds with the corresponding value</span>\n    <span class=\"c1\"># the `lhs` automatically ignores parts of I, which are irrelevant to O</span>\n\n    <span class=\"n\">tfm</span> <span class=\"o\">=</span> <span class=\"s1\">'items &amp; (k &amp; v)* -&gt; values &amp; (v)*'</span>\n\n    <span class=\"n\">O</span> <span class=\"o\">=</span> <span class=\"n\">do_tfm</span><span class=\"p\">(</span><span class=\"n\">I</span><span class=\"p\">,</span> <span class=\"n\">tfm</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">O</span><span class=\"p\">)</span> <span class=\"c1\"># {'values': [1, 2, 3]}</span>\n</pre>\n<p>The above example illustrates a simple JSON transformation using <code>aos</code> rules. Rules can be more complex, e.g., include <em>conditions</em>, <em>function</em> application on query variables. They work not only with JSON data, but also apply to heterogeneous nested objects.</p>\n<p>See more examples <a href=\"tests/test_tfm_json.py\" rel=\"nofollow\">here</a> and <a href=\"tests/test_tfm_spark_json.py\" rel=\"nofollow\">here</a>.</p>\n<h2>And-Or Shape Dimensions</h2>\n<p>The above examples of use strings or type names (<code>str</code>) or integer values (<code>2</code>,<code>3</code>) in shape expressions. A more principled approach is to first declare <strong>dimension names</strong> and define shape over these names.</p>\n<p>Data is defined over two kinds of dimensions:</p>\n<ul>\n<li><strong>Continuous</strong>. A range of values, e.g., a numpy array of shape (5, 200) is defined over two continuous dimensions, say <code>n</code> and <code>d</code>, where <code>n</code> ranges over values <code>0-4</code> and <code>d</code> ranges over <code>0-199</code>.</li>\n<li><strong>Categorical</strong>. A set of names, e.g., a dictionary <code>{'a': 4, 'b': 5}</code> is defined over <em>keys</em>  (dim names) <code>['a', 'b']</code>. One can also view each key, e.g., <code>a</code> or <code>b</code> , as a <strong>Singleton</strong> dimension.</li>\n</ul>\n<p><strong>Programmatic API</strong>. The library provides an API to declare both type of dimensions and <code>aos</code> expressions over these dimensions, e.g., declare <code>n</code> and <code>d</code> as two continuous dimensions and then define shape <code>n &amp; d</code>.</p>\n<h2>Status</h2>\n<p><em>The library is under active development. More documentation coming soon..</em></p>\n\n          </div>"}, "last_serial": 7046844, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "2ef8f6ad2fa44849c723f219da1ca1df", "sha256": "1a5d0a0870775462b1aa51cc95d87b8e645f68e364fefe10665cd2f5b4c48a30"}, "downloads": -1, "filename": "aos-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "2ef8f6ad2fa44849c723f219da1ca1df", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15159, "upload_time": "2020-01-22T07:28:50", "upload_time_iso_8601": "2020-01-22T07:28:50.012358Z", "url": "https://files.pythonhosted.org/packages/4a/74/1955fdfe7e97e0229b17727d3d7ba12c2c0a018652bb17ebafafba6753bc/aos-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d79a7baa168d1a0718aed1875e23be2e", "sha256": "e97168ff78d6e236014f172cc123e3de47135caaefefdc7ab5c309159f68ade3"}, "downloads": -1, "filename": "aos-0.0.1.tar.gz", "has_sig": false, "md5_digest": "d79a7baa168d1a0718aed1875e23be2e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9966, "upload_time": "2020-01-22T07:28:53", "upload_time_iso_8601": "2020-01-22T07:28:53.404484Z", "url": "https://files.pythonhosted.org/packages/92/2e/e4e49d3c5db50897f31ea8bf306d49c8c83a9dfb024e8a46fbe92d432945/aos-0.0.1.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "0262b2d24eeda72386790776b61c5d41", "sha256": "83d49542515dbe6d459d628c696341af40daf7225852097b0a878c6f9be87585"}, "downloads": -1, "filename": "aos-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "0262b2d24eeda72386790776b61c5d41", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 19339, "upload_time": "2020-02-19T09:27:23", "upload_time_iso_8601": "2020-02-19T09:27:23.838491Z", "url": "https://files.pythonhosted.org/packages/49/24/20b75b0e9f83eb8979a6da88d9f431bda91510cc48850f7628542fbedc7e/aos-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a2288ee23fba0132c8c8f83def09c330", "sha256": "f48118afe612e7b34a78dc333e0748a956161b5c234dac535e876fb211fa4369"}, "downloads": -1, "filename": "aos-0.1.0.tar.gz", "has_sig": false, "md5_digest": "a2288ee23fba0132c8c8f83def09c330", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12903, "upload_time": "2020-02-19T09:27:25", "upload_time_iso_8601": "2020-02-19T09:27:25.779930Z", "url": "https://files.pythonhosted.org/packages/5f/44/f8b738b3e2813e02d5329da53c0d21c4102de7eb641b83597cc5d1a55852/aos-0.1.0.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "2ee8a50a4dd19f9b9e452effc8e665c5", "sha256": "11716e05ca4fa3c841437837fd42ded3a203db404c0df7b046e1aba773af9c5e"}, "downloads": -1, "filename": "aos-0.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "2ee8a50a4dd19f9b9e452effc8e665c5", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 22852, "upload_time": "2020-04-18T10:14:28", "upload_time_iso_8601": "2020-04-18T10:14:28.823937Z", "url": "https://files.pythonhosted.org/packages/92/c9/4146b882149a9319f9350303a041bd9ccef49283cd09e51f7dd88ae3fea7/aos-0.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d57c00ad77c85a15d86860c5109e6564", "sha256": "791058728ca3eddb83ace0b6d30557c7cb466de7ac3ab76bdd45dcf63a02189b"}, "downloads": -1, "filename": "aos-0.1.2.tar.gz", "has_sig": false, "md5_digest": "d57c00ad77c85a15d86860c5109e6564", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15396, "upload_time": "2020-04-18T10:14:30", "upload_time_iso_8601": "2020-04-18T10:14:30.685579Z", "url": "https://files.pythonhosted.org/packages/32/df/d00187838460d30ddb3b1cd59da357578d4cfb8f65b4b7227861d8783db3/aos-0.1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2ee8a50a4dd19f9b9e452effc8e665c5", "sha256": "11716e05ca4fa3c841437837fd42ded3a203db404c0df7b046e1aba773af9c5e"}, "downloads": -1, "filename": "aos-0.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "2ee8a50a4dd19f9b9e452effc8e665c5", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 22852, "upload_time": "2020-04-18T10:14:28", "upload_time_iso_8601": "2020-04-18T10:14:28.823937Z", "url": "https://files.pythonhosted.org/packages/92/c9/4146b882149a9319f9350303a041bd9ccef49283cd09e51f7dd88ae3fea7/aos-0.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d57c00ad77c85a15d86860c5109e6564", "sha256": "791058728ca3eddb83ace0b6d30557c7cb466de7ac3ab76bdd45dcf63a02189b"}, "downloads": -1, "filename": "aos-0.1.2.tar.gz", "has_sig": false, "md5_digest": "d57c00ad77c85a15d86860c5109e6564", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15396, "upload_time": "2020-04-18T10:14:30", "upload_time_iso_8601": "2020-04-18T10:14:30.685579Z", "url": "https://files.pythonhosted.org/packages/32/df/d00187838460d30ddb3b1cd59da357578d4cfb8f65b4b7227861d8783db3/aos-0.1.2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:17:54 2020"}