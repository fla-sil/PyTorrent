{"info": {"author": "Fran\u00e7ois Wautier, Max Isom et al.", "author_email": "francois@wautier.eu", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: System Administrators", "License :: OSI Approved :: MIT License", "Operating System :: MacOS :: MacOS X", "Operating System :: POSIX", "Operating System :: POSIX :: Linux", "Programming Language :: Python", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation :: CPython", "Topic :: Software Development :: Libraries"], "description": "# aiotuya\n\naiotuya ia a Python library for LAN control of Tuya devices. It can detect, provision\nand control devices that connect to the [Tuya Cloud](https://www.tuya.com).\n\nTo make things easy to the user, aiotuya comes with an application key and secret\nthat were provided by [Tuya Cloud](https://www.tuya.com). We request that you\ndo not use these key and secret for any other purpose.\n\n# Acknowledgement\n\nAll credits for figuring out how those device communicate goes to [codetheweb](https://github.com/codetheweb/tuyapi)\nand all the participants to this [conversation](https://github.com/codetheweb/tuyapi/issues/5). All I did is\nport their work to Python with asyncio and added bugs.\n\n# Installation\n\nComing soon... we will upload to Pypi\n\nIn the meantime....\n\n``` shell\npython3 setup.py install\n```\n\n# Usage\n\nThe easiest way to start is running the module\n\n``` shell\npython3 -m aiotuya\n```\n\nWhich, the first time around, will give you absolutely nothing. You want to\nstart with\n\n``` shell\npython3 -m aiotuya -e me@myself.com -p mypass -s WIFISSID -P WIFISECRET\n```\n\nAfter you hit the \"Enter\" you should get\n\n``` shell\nHit \"Enter\" to start\nUse Ctrl-C to quit\n\nSelect Device:\n\n            [0]     Provision new devices\n```\n\n\nReady you devices for configuration and hit 0 followed by enter.\n\nThen wait, hiting the \"Enter\" key from time to time.\n\nYou can also use the '-d' option to get debug messages. These are not suitable for human consumption and are\nknown to cause cancer in rats.\n\n## Provisioning Caveat\n\nFor provisioning to work, you must be able to send broadcast packets over WiFi.\nIn my case, I was only able to use provisioning on a laptop connected to my\nhouse WiFi. Trying from a wired computer did not work. Apparently my router (Asus RT-AC5300)\ndid not relay the packets. Your milage may vary.\n\nProvisioning is also working on a RPi3 connected through WiFi (Note that I use a USB WiFi dongle to\nconnect, not the RPi3 WiFi module)\n\nProvisioning is NOT YET working from a RPi2 (wire connected) with a WiFi dongle.\n\n\n## Remembering devices keys\n\nDuring the provisioning process, the device will register with the [Tuya Cloud](https://www.tuya.com).\nOnce the registration has succeeded, the provisioning system will receive a key to be used\nwhen communicating with the device. By default, aiotuya will save the pairs (device id, key) in a CSV file\nin your home directory. The default file name is .aiotuya\n\n# The devices\n\nAt this time (Feb '19) aiotuya will handle 3 types of devices\n\n## Switch\n\nA simple On/Off switch is provided by ``` TuyaSwitch ``` . It has 2 methods:\n\n* on()\n* off()\n\nAnd the status will be reported as\n\n``` python\n{'state': 'on'}\n{'state': 'off'}\n```\n\n## Open/Close/Idle Switch\n\nThis is the kind of switch that can be used for curtains, garage doors and so on. It is\nprovided with ``` TuyaOCSwitch ```.  It has 3 methods:\n\n* open()\n* close()\n* idle()\n\nAnd the state value can be one of:\n\n* closing\n* opening\n* idling\n\n## LED lights\n\nThis is a colour LED light. It is provided by  ``` TuyaLight ``` and offers the following methods:\n\n* on()\n* off()\n* set_white( brightness, K)\n* set_colour([hue, saturation, value])\n* set_colour_rgb([pred, green, blue])\n* transition_white([bright, K], duration)\n* transition_colour([h, s, v], duration)\n* fadein_white(bright, K, duration)\n* fadeout_white(duration)\n* fadein_colour([h, s, v], duration)\n* fadeout_colour(duration)\n\n## Other Devices\n\nOther devices can be added, but I do not have the information needed to add them.\n\n## Devices caveat\n\naiotuya keeps a connection to the device, and send a heartbeat status request every timout secs\n(10 secs by default). This allows it to receive real time status messages upon changes in the device status\n(e.g. button pressed on a switch). The downside is that Tuya devices seem to only accept one such a\nconnection, so aiotuya has exclusive control of the device via LAN. Fortunately, the devices stop broacasting their presence\nwhen they have a network connection, so other application should not be able to find them. I have not tried to see if the\ncloud API was still working in that case.\n\n# How to use aiotuya\n\nCreate a class to manage your devices. The class should have at least 4 methods:\n\n* register(self, device)\n  This will be used to report when a new device has been found.\n* unregister(self,device)\n  This is called when connection to a device is lost.\n* got_data(self, data)\n  This is called when a device receive data. The data should be a dictionary. The 'devId' can be used to iscriminate which device received the data\n* got_error(self, device, data)\n  This is called when an error is received. The device is passed as parameter.\n\n\nSubclass TuyaManager, if you want to persists the device keys, by overloading 2 methods:\n\n* load_keys(self)\n  Loading the known keys in the dictionary self.known_devices. called in __init__\n* persist_keys(self)\n  Save the keys, called when new keys are reported.\n\nAfter that\n\n``` python\nMyDevs= Devices()\nloop = aio.get_event_loop()\nmanager = DevManager(dev_parent=MyDevs)\nscanner = tuya.TuyaScanner(parent=manager)\nscanner.start(loop)\n```\n## How does it work\n\nTuya devices, when they are not connected, broadcast their presence on the network, TuyaScanner listen\nfor those broadcasts and pass them on to TuyaManager.\n\nIf the key is known, TuyaManager will create a TuyaDevice generic instance with raw_dps set, using itself as device manager.\nUpon receiving the device status data, Tuyamanager will try to figure out the type of device and create the proper instance\nusing the application device manager to control the device.\n\nTuyaManager figures out the type of device it is dealing with by issuing a status request and inspecting the returned value.\nIf an error is returned, ot will try sending a command. The reason for this is that my OC Switch, after powering up, will return\na \"json struct data unvalid\" error to any status request until either, a button is pressed or a valid command is issued. The behaviour\nof Tuyamanager is meant to circumvent this problem.\n\n# Status\n\n0.1.0b1: Initial version. Works for me with a LED lightbulb and a Open/Close switch\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/frawau/aiotuya", "keywords": "Tuya,IoT,WiFi,Home Automation,asyncio", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "aiotuya", "package_url": "https://pypi.org/project/aiotuya/", "platform": "unix", "project_url": "https://pypi.org/project/aiotuya/", "project_urls": {"Homepage": "https://github.com/frawau/aiotuya"}, "release_url": "https://pypi.org/project/aiotuya/0.1.0b2/", "requires_dist": null, "requires_python": "", "summary": "Pure Python library to control/provision Tuya devices", "version": "0.1.0b2", "yanked": false, "html_description": "<div class=\"project-description\">\n            # aiotuya<br><br>aiotuya ia a Python library for LAN control of Tuya devices. It can detect, provision<br>and control devices that connect to the [Tuya Cloud](https://www.tuya.com).<br><br>To make things easy to the user, aiotuya comes with an application key and secret<br>that were provided by [Tuya Cloud](https://www.tuya.com). We request that you<br>do not use these key and secret for any other purpose.<br><br># Acknowledgement<br><br>All credits for figuring out how those device communicate goes to [codetheweb](https://github.com/codetheweb/tuyapi)<br>and all the participants to this [conversation](https://github.com/codetheweb/tuyapi/issues/5). All I did is<br>port their work to Python with asyncio and added bugs.<br><br># Installation<br><br>Coming soon... we will upload to Pypi<br><br>In the meantime....<br><br>``` shell<br>python3 setup.py install<br>```<br><br># Usage<br><br>The easiest way to start is running the module<br><br>``` shell<br>python3 -m aiotuya<br>```<br><br>Which, the first time around, will give you absolutely nothing. You want to<br>start with<br><br>``` shell<br>python3 -m aiotuya -e me@myself.com -p mypass -s WIFISSID -P WIFISECRET<br>```<br><br>After you hit the \"Enter\" you should get<br><br>``` shell<br>Hit \"Enter\" to start<br>Use Ctrl-C to quit<br><br>Select Device:<br><br>            [0]     Provision new devices<br>```<br><br><br>Ready you devices for configuration and hit 0 followed by enter.<br><br>Then wait, hiting the \"Enter\" key from time to time.<br><br>You can also use the '-d' option to get debug messages. These are not suitable for human consumption and are<br>known to cause cancer in rats.<br><br>## Provisioning Caveat<br><br>For provisioning to work, you must be able to send broadcast packets over WiFi.<br>In my case, I was only able to use provisioning on a laptop connected to my<br>house WiFi. Trying from a wired computer did not work. Apparently my router (Asus RT-AC5300)<br>did not relay the packets. Your milage may vary.<br><br>Provisioning is also working on a RPi3 connected through WiFi (Note that I use a USB WiFi dongle to<br>connect, not the RPi3 WiFi module)<br><br>Provisioning is NOT YET working from a RPi2 (wire connected) with a WiFi dongle.<br><br><br>## Remembering devices keys<br><br>During the provisioning process, the device will register with the [Tuya Cloud](https://www.tuya.com).<br>Once the registration has succeeded, the provisioning system will receive a key to be used<br>when communicating with the device. By default, aiotuya will save the pairs (device id, key) in a CSV file<br>in your home directory. The default file name is .aiotuya<br><br># The devices<br><br>At this time (Feb '19) aiotuya will handle 3 types of devices<br><br>## Switch<br><br>A simple On/Off switch is provided by ``` TuyaSwitch ``` . It has 2 methods:<br><br>* on()<br>* off()<br><br>And the status will be reported as<br><br>``` python<br>{'state': 'on'}<br>{'state': 'off'}<br>```<br><br>## Open/Close/Idle Switch<br><br>This is the kind of switch that can be used for curtains, garage doors and so on. It is<br>provided with ``` TuyaOCSwitch ```.  It has 3 methods:<br><br>* open()<br>* close()<br>* idle()<br><br>And the state value can be one of:<br><br>* closing<br>* opening<br>* idling<br><br>## LED lights<br><br>This is a colour LED light. It is provided by  ``` TuyaLight ``` and offers the following methods:<br><br>* on()<br>* off()<br>* set_white( brightness, K)<br>* set_colour([hue, saturation, value])<br>* set_colour_rgb([pred, green, blue])<br>* transition_white([bright, K], duration)<br>* transition_colour([h, s, v], duration)<br>* fadein_white(bright, K, duration)<br>* fadeout_white(duration)<br>* fadein_colour([h, s, v], duration)<br>* fadeout_colour(duration)<br><br>## Other Devices<br><br>Other devices can be added, but I do not have the information needed to add them.<br><br>## Devices caveat<br><br>aiotuya keeps a connection to the device, and send a heartbeat status request every timout secs<br>(10 secs by default). This allows it to receive real time status messages upon changes in the device status<br>(e.g. button pressed on a switch). The downside is that Tuya devices seem to only accept one such a<br>connection, so aiotuya has exclusive control of the device via LAN. Fortunately, the devices stop broacasting their presence<br>when they have a network connection, so other application should not be able to find them. I have not tried to see if the<br>cloud API was still working in that case.<br><br># How to use aiotuya<br><br>Create a class to manage your devices. The class should have at least 4 methods:<br><br>* register(self, device)<br>  This will be used to report when a new device has been found.<br>* unregister(self,device)<br>  This is called when connection to a device is lost.<br>* got_data(self, data)<br>  This is called when a device receive data. The data should be a dictionary. The 'devId' can be used to iscriminate which device received the data<br>* got_error(self, device, data)<br>  This is called when an error is received. The device is passed as parameter.<br><br><br>Subclass TuyaManager, if you want to persists the device keys, by overloading 2 methods:<br><br>* load_keys(self)<br>  Loading the known keys in the dictionary self.known_devices. called in __init__<br>* persist_keys(self)<br>  Save the keys, called when new keys are reported.<br><br>After that<br><br>``` python<br>MyDevs= Devices()<br>loop = aio.get_event_loop()<br>manager = DevManager(dev_parent=MyDevs)<br>scanner = tuya.TuyaScanner(parent=manager)<br>scanner.start(loop)<br>```<br>## How does it work<br><br>Tuya devices, when they are not connected, broadcast their presence on the network, TuyaScanner listen<br>for those broadcasts and pass them on to TuyaManager.<br><br>If the key is known, TuyaManager will create a TuyaDevice generic instance with raw_dps set, using itself as device manager.<br>Upon receiving the device status data, Tuyamanager will try to figure out the type of device and create the proper instance<br>using the application device manager to control the device.<br><br>TuyaManager figures out the type of device it is dealing with by issuing a status request and inspecting the returned value.<br>If an error is returned, ot will try sending a command. The reason for this is that my OC Switch, after powering up, will return<br>a \"json struct data unvalid\" error to any status request until either, a button is pressed or a valid command is issued. The behaviour<br>of Tuyamanager is meant to circumvent this problem.<br><br># Status<br><br>0.1.0b1: Initial version. Works for me with a LED lightbulb and a Open/Close switch<br><br><br>\n          </div>"}, "last_serial": 4953924, "releases": {"0.1.0b2": [{"comment_text": "", "digests": {"md5": "9817d74ee7129b03053a8c35c23fba92", "sha256": "a21dea864c26a08b76094812272ee0b2caa67e11b1fc47c629496d8b5bd63867"}, "downloads": -1, "filename": "aiotuya-0.1.0b2-py3-none-any.whl", "has_sig": false, "md5_digest": "9817d74ee7129b03053a8c35c23fba92", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21832, "upload_time": "2019-03-18T13:36:50", "upload_time_iso_8601": "2019-03-18T13:36:50.200747Z", "url": "https://files.pythonhosted.org/packages/46/30/74ccec457be29df74051386360eb169801e2c300df7a0ae4b03e89de1257/aiotuya-0.1.0b2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1e0cfe43b7491d5c65c1c31a758b1fa6", "sha256": "01236dad4d15bd082f8669da83499066a1e9b282d00d4c3d0a2060c7b0fe0e6b"}, "downloads": -1, "filename": "aiotuya-0.1.0b2.tar.gz", "has_sig": false, "md5_digest": "1e0cfe43b7491d5c65c1c31a758b1fa6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19211, "upload_time": "2019-03-18T13:36:52", "upload_time_iso_8601": "2019-03-18T13:36:52.534256Z", "url": "https://files.pythonhosted.org/packages/16/66/45d73b254619d4580d9cb5fd05b52c73f40fcfede9e4ab67a84ceea797fb/aiotuya-0.1.0b2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9817d74ee7129b03053a8c35c23fba92", "sha256": "a21dea864c26a08b76094812272ee0b2caa67e11b1fc47c629496d8b5bd63867"}, "downloads": -1, "filename": "aiotuya-0.1.0b2-py3-none-any.whl", "has_sig": false, "md5_digest": "9817d74ee7129b03053a8c35c23fba92", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21832, "upload_time": "2019-03-18T13:36:50", "upload_time_iso_8601": "2019-03-18T13:36:50.200747Z", "url": "https://files.pythonhosted.org/packages/46/30/74ccec457be29df74051386360eb169801e2c300df7a0ae4b03e89de1257/aiotuya-0.1.0b2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1e0cfe43b7491d5c65c1c31a758b1fa6", "sha256": "01236dad4d15bd082f8669da83499066a1e9b282d00d4c3d0a2060c7b0fe0e6b"}, "downloads": -1, "filename": "aiotuya-0.1.0b2.tar.gz", "has_sig": false, "md5_digest": "1e0cfe43b7491d5c65c1c31a758b1fa6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19211, "upload_time": "2019-03-18T13:36:52", "upload_time_iso_8601": "2019-03-18T13:36:52.534256Z", "url": "https://files.pythonhosted.org/packages/16/66/45d73b254619d4580d9cb5fd05b52c73f40fcfede9e4ab67a84ceea797fb/aiotuya-0.1.0b2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:20:39 2020"}