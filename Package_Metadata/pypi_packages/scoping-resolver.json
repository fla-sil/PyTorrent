{"info": {"author": "thautwarm", "author_email": "twshere@outlook.com", "bugtrack_url": null, "classifiers": ["Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: Implementation :: CPython"], "description": "About\n==============\n\nThis repo brings about a strong analysis of scoping for Python language,\nwhich could tell a symbol inside a context is a `freevar`, `bounded var` or `cell var`, and many other details\nlike, \"is this closure a coroutine/generator/async generator?\" and so on.\n\nMore about Python's scoping, check [code object](https://github.com/Xython/YAPyPy/blob/master/python-internals/code-object.md).\n\n`Symbol-Resolver` could be leveraged to implement transpilers from Python to another language with hygienic scopes,\nlike [Tensorflow AutoGraph](https://www.tensorflow.org/guide/autograph) and [Numba AutoJit](http://numba.pydata.org/numba-doc/latest/reference/jit-compilation.html#jit-functions):\n\n```python\nfrom utranspiler import transpile, func\n# The `func` might not be a valid python function,\n# but it can be used to denote some external function.\n\n@transpile\ndef ufunc(x):\n    func(x)\n```\n\nIn above codes, `func` is resolved to be a `global` variable, in other words,\nyou can then search the name `func` from global context from current module,\nand make sure it's exactly the `func` object that is the expected external function.\n\nIf you're still confused about the power of **Symbol-Resolver**, there is also an example for you:\n\n```python\nfrom utranspiler import transpile, func\n\n@transpile\ndef ufunc(x):\n    func = lambda x: x + 1\n    func(x)\n```\n\nOr\n\n```python\nfrom utranspiler import transpile, func\nfunc = lambda x: x + 1\n@transpile\ndef ufunc(x):\n    func(x)\n```\n\nNow you cannot expect `func` as an external function, but you might not want to check the symbol manually by implementing\nyour specific symbol analyzer.\n\nTensorflow team is still struggling with above problem, you can something unhygienic in following link:\n\nhttps://github.com/tensorflow/tensorflow/blob/3ae375aa92fbb6155f82393735d0b98d8fb9c1b2/tensorflow/python/autograph/converters/lists.py#L129\n\nUsage\n=======\n\nCheck `test/test_simple.py`.\n\nThe `ScopeTagger` converts any AST that lead to a new context into a wrapped node named `ScopedAst`, where all\nthe information about current context is held.\n\n```python\nimport unittest\nimport ast\nfrom scoping_resolver import to_scoped_ast, ScopedAst, SymTable, ScopeTagger\n\nmod_code = \"\"\"\nc = lambda x: x\ndef f(x):\n    g(x)\n    c = 2\n    g(c)\n\"\"\"\nclass TestSimple(unittest.TestCase):\n    def test(self):\n        mod = ast.parse(mod_code)\n\n        # Make a new symbol table object for global context.\n        # Of course, symbol tables for sub-contexts would be created\n        # when analyzing the whole module AST.\n        g = SymTable.global_context()\n\n        # Get raw information of AST.\n        ScopeTagger(g).visit(mod)\n\n        # Peform analysis.\n        g.analyze()\n\n        # You can directly use `to_scoped_ast(mod)`\n        # instead when you don't need a top level `g`.\n\n        # Show representations of nested scopes:\n        print(g.show_resolution())\n        # [AnalyzedSymTable(bounds=set(), freevars=set(), cellvars=set()),\n        #  [[AnalyzedSymTable(bounds={'x'}, freevars=set(), cellvars=set()), []],\n        #   [AnalyzedSymTable(bounds={'x', 'c'}, freevars=set(), cellvars=set()), []]]]\n\n        body = mod.body\n        def_f: ScopedAst = body[1]\n\n        # `FunctionDef` creates a new context, so it'll be wrapped inside a ScopedAst\n\n        self.assertEqual(type(def_f), ScopedAst)\n        self.assertEqual(type(def_f.node), ast.FunctionDef)\n        self.assertIn('c', def_f.scope.analyzed.bounds)\n```\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/thautwarm/symbol-resolver", "keywords": "", "license": "mit", "maintainer": "", "maintainer_email": "", "name": "scoping-resolver", "package_url": "https://pypi.org/project/scoping-resolver/", "platform": "", "project_url": "https://pypi.org/project/scoping-resolver/", "project_urls": {"Homepage": "https://github.com/thautwarm/symbol-resolver"}, "release_url": "https://pypi.org/project/scoping-resolver/0.0.5/", "requires_dist": null, "requires_python": ">=3.6.0", "summary": "", "version": "0.0.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>About</h1>\n<p>This repo brings about a strong analysis of scoping for Python language,\nwhich could tell a symbol inside a context is a <code>freevar</code>, <code>bounded var</code> or <code>cell var</code>, and many other details\nlike, \"is this closure a coroutine/generator/async generator?\" and so on.</p>\n<p>More about Python's scoping, check <a href=\"https://github.com/Xython/YAPyPy/blob/master/python-internals/code-object.md\" rel=\"nofollow\">code object</a>.</p>\n<p><code>Symbol-Resolver</code> could be leveraged to implement transpilers from Python to another language with hygienic scopes,\nlike <a href=\"https://www.tensorflow.org/guide/autograph\" rel=\"nofollow\">Tensorflow AutoGraph</a> and <a href=\"http://numba.pydata.org/numba-doc/latest/reference/jit-compilation.html#jit-functions\" rel=\"nofollow\">Numba AutoJit</a>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">utranspiler</span> <span class=\"kn\">import</span> <span class=\"n\">transpile</span><span class=\"p\">,</span> <span class=\"n\">func</span>\n<span class=\"c1\"># The `func` might not be a valid python function,</span>\n<span class=\"c1\"># but it can be used to denote some external function.</span>\n\n<span class=\"nd\">@transpile</span>\n<span class=\"k\">def</span> <span class=\"nf\">ufunc</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n</pre>\n<p>In above codes, <code>func</code> is resolved to be a <code>global</code> variable, in other words,\nyou can then search the name <code>func</code> from global context from current module,\nand make sure it's exactly the <code>func</code> object that is the expected external function.</p>\n<p>If you're still confused about the power of <strong>Symbol-Resolver</strong>, there is also an example for you:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">utranspiler</span> <span class=\"kn\">import</span> <span class=\"n\">transpile</span><span class=\"p\">,</span> <span class=\"n\">func</span>\n\n<span class=\"nd\">@transpile</span>\n<span class=\"k\">def</span> <span class=\"nf\">ufunc</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n    <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n</pre>\n<p>Or</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">utranspiler</span> <span class=\"kn\">import</span> <span class=\"n\">transpile</span><span class=\"p\">,</span> <span class=\"n\">func</span>\n<span class=\"n\">func</span> <span class=\"o\">=</span> <span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n<span class=\"nd\">@transpile</span>\n<span class=\"k\">def</span> <span class=\"nf\">ufunc</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n</pre>\n<p>Now you cannot expect <code>func</code> as an external function, but you might not want to check the symbol manually by implementing\nyour specific symbol analyzer.</p>\n<p>Tensorflow team is still struggling with above problem, you can something unhygienic in following link:</p>\n<p><a href=\"https://github.com/tensorflow/tensorflow/blob/3ae375aa92fbb6155f82393735d0b98d8fb9c1b2/tensorflow/python/autograph/converters/lists.py#L129\" rel=\"nofollow\">https://github.com/tensorflow/tensorflow/blob/3ae375aa92fbb6155f82393735d0b98d8fb9c1b2/tensorflow/python/autograph/converters/lists.py#L129</a></p>\n<h1>Usage</h1>\n<p>Check <code>test/test_simple.py</code>.</p>\n<p>The <code>ScopeTagger</code> converts any AST that lead to a new context into a wrapped node named <code>ScopedAst</code>, where all\nthe information about current context is held.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">unittest</span>\n<span class=\"kn\">import</span> <span class=\"nn\">ast</span>\n<span class=\"kn\">from</span> <span class=\"nn\">scoping_resolver</span> <span class=\"kn\">import</span> <span class=\"n\">to_scoped_ast</span><span class=\"p\">,</span> <span class=\"n\">ScopedAst</span><span class=\"p\">,</span> <span class=\"n\">SymTable</span><span class=\"p\">,</span> <span class=\"n\">ScopeTagger</span>\n\n<span class=\"n\">mod_code</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">c = lambda x: x</span>\n<span class=\"s2\">def f(x):</span>\n<span class=\"s2\">    g(x)</span>\n<span class=\"s2\">    c = 2</span>\n<span class=\"s2\">    g(c)</span>\n<span class=\"s2\">\"\"\"</span>\n<span class=\"k\">class</span> <span class=\"nc\">TestSimple</span><span class=\"p\">(</span><span class=\"n\">unittest</span><span class=\"o\">.</span><span class=\"n\">TestCase</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">test</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">mod</span> <span class=\"o\">=</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">mod_code</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># Make a new symbol table object for global context.</span>\n        <span class=\"c1\"># Of course, symbol tables for sub-contexts would be created</span>\n        <span class=\"c1\"># when analyzing the whole module AST.</span>\n        <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">SymTable</span><span class=\"o\">.</span><span class=\"n\">global_context</span><span class=\"p\">()</span>\n\n        <span class=\"c1\"># Get raw information of AST.</span>\n        <span class=\"n\">ScopeTagger</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">visit</span><span class=\"p\">(</span><span class=\"n\">mod</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># Peform analysis.</span>\n        <span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">analyze</span><span class=\"p\">()</span>\n\n        <span class=\"c1\"># You can directly use `to_scoped_ast(mod)`</span>\n        <span class=\"c1\"># instead when you don't need a top level `g`.</span>\n\n        <span class=\"c1\"># Show representations of nested scopes:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"o\">.</span><span class=\"n\">show_resolution</span><span class=\"p\">())</span>\n        <span class=\"c1\"># [AnalyzedSymTable(bounds=set(), freevars=set(), cellvars=set()),</span>\n        <span class=\"c1\">#  [[AnalyzedSymTable(bounds={'x'}, freevars=set(), cellvars=set()), []],</span>\n        <span class=\"c1\">#   [AnalyzedSymTable(bounds={'x', 'c'}, freevars=set(), cellvars=set()), []]]]</span>\n\n        <span class=\"n\">body</span> <span class=\"o\">=</span> <span class=\"n\">mod</span><span class=\"o\">.</span><span class=\"n\">body</span>\n        <span class=\"n\">def_f</span><span class=\"p\">:</span> <span class=\"n\">ScopedAst</span> <span class=\"o\">=</span> <span class=\"n\">body</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n\n        <span class=\"c1\"># `FunctionDef` creates a new context, so it'll be wrapped inside a ScopedAst</span>\n\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">assertEqual</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">def_f</span><span class=\"p\">),</span> <span class=\"n\">ScopedAst</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">assertEqual</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">def_f</span><span class=\"o\">.</span><span class=\"n\">node</span><span class=\"p\">),</span> <span class=\"n\">ast</span><span class=\"o\">.</span><span class=\"n\">FunctionDef</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">assertIn</span><span class=\"p\">(</span><span class=\"s1\">'c'</span><span class=\"p\">,</span> <span class=\"n\">def_f</span><span class=\"o\">.</span><span class=\"n\">scope</span><span class=\"o\">.</span><span class=\"n\">analyzed</span><span class=\"o\">.</span><span class=\"n\">bounds</span><span class=\"p\">)</span>\n</pre>\n\n          </div>"}, "last_serial": 4650705, "releases": {"0.0.4": [{"comment_text": "", "digests": {"md5": "52a55b01d759ba3452a37d6aba2b699c", "sha256": "5bd570d509dce393cb896a714ad2b0946b16f3577d13edbc693a5126825165eb"}, "downloads": -1, "filename": "scoping_resolver-0.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "52a55b01d759ba3452a37d6aba2b699c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 6435, "upload_time": "2019-01-01T08:47:23", "upload_time_iso_8601": "2019-01-01T08:47:23.021501Z", "url": "https://files.pythonhosted.org/packages/6d/42/42c8cb61afbec64c94c5347656b2c883f683ce583cee4961738520f547e6/scoping_resolver-0.0.4-py3-none-any.whl", "yanked": false}], "0.0.5": [{"comment_text": "", "digests": {"md5": "558b73630efbb94dc2aa8826e2603398", "sha256": "f0ff1470a4bc6815eecb4399f56a013a222b776869a872d98b8d3e9292eb9cde"}, "downloads": -1, "filename": "scoping_resolver-0.0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "558b73630efbb94dc2aa8826e2603398", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 6437, "upload_time": "2019-01-01T18:07:17", "upload_time_iso_8601": "2019-01-01T18:07:17.718683Z", "url": "https://files.pythonhosted.org/packages/61/a2/7200b94a172b201fcb52d7fc63f07183e0bd6853d9870bce0450e848399b/scoping_resolver-0.0.5-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "558b73630efbb94dc2aa8826e2603398", "sha256": "f0ff1470a4bc6815eecb4399f56a013a222b776869a872d98b8d3e9292eb9cde"}, "downloads": -1, "filename": "scoping_resolver-0.0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "558b73630efbb94dc2aa8826e2603398", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 6437, "upload_time": "2019-01-01T18:07:17", "upload_time_iso_8601": "2019-01-01T18:07:17.718683Z", "url": "https://files.pythonhosted.org/packages/61/a2/7200b94a172b201fcb52d7fc63f07183e0bd6853d9870bce0450e848399b/scoping_resolver-0.0.5-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 02:57:06 2020"}