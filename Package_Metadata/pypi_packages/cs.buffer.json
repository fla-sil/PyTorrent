{"info": {"author": "Cameron Simpson", "author_email": "cs@cskk.id.au", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "*Latest release 20200328*:\nCornuCopyBuffer.takev: bugfix adjustment of buf.offset, was not always done.\nCornuCopyBuffer.__getitem__: add slice support, note how expensive it is to use.\n\nFacilities to do with buffers, particularly CornuCopyBuffer,\nan automatically refilling buffer to support parsing of data streams.\n\n## Function `chunky(bfr_func)`\n\nDecorator for a function accepting a leading `CornuCopyBuffer`\nparameter.\nReturns a function accepting a leading data chunks parameter\n(bytes instances) and optional `offset` and 'copy_offsets`\nkeywords parameters.\n\nExample::\n\n    @chunky\n    def func(bfr, ...):\n\n## Class `CopyingIterator`\n\nWrapper for an iterator that copies every item retrieved to a callable.\n\n### Method `CopyingIterator.__init__(self, I, copy_to)`\n\nInitialise with the iterator `I` and the callable `copy_to`.\n\n## Class `CornuCopyBuffer`\n\nAn automatically refilling buffer intended to support parsing\nof data streams.\n\nIts purpose is to aid binary parsers\nwhich do not themselves need to handle sources specially;\n`CornuCopyBuffer`s are trivially made from `bytes`,\niterables of `bytes` and file-like objects.\nSee `cs.binary` for convenient parsing classes\nwhich work against `CornuCopyBuffer`s.\n\nAttributes:\n* `buf`: the first of any buffered leading chunks\n  buffer of unparsed data from the input, available\n  for direct inspection by parsers;\n  normally however parsers will use `.extend` and `.take`.\n* `offset`: the logical offset of the buffer; this excludes\n  buffered data and unconsumed input data\n\nThe primary methods supporting parsing of data streams are\n`.extend()` and `take()`.\nCalling `.extend(min_size)` arranges that `.buf` contains at least\n`min_size` bytes.\nCalling `.take(size)` fetches exactly `size` bytes from `.buf` and the\ninput source if necessary and returns them, adjusting `.buf`.\n\nlen(`CornuCopyBuffer`) returns the length of any buffered data.\n\nbool(`CornuCopyBuffer`) tests whether len() > 0.\n\nIndexing a `CornuCopyBuffer` accesses the buffered data only,\nreturning an individual byte's value (an `int`).\n\nA `CornuCopyBuffer` is also iterable, yielding data in whatever\nsizes come from its `input_data` source, preceeded by the\ncurrent `.buf` if not empty.\n\nA `CornuCopyBuffer` also supports the file methods `.read`,\n`.tell` and `.seek` supporting drop in use of the buffer in\nmany file contexts. Backward seeks are not supported. `.seek`\nwill take advantage of the `input_data`'s .seek method if it\nhas one, otherwise it will use reads.\n\n### Method `CornuCopyBuffer.__init__(self, input_data, buf=None, offset=0, seekable=None, copy_offsets=None, copy_chunks=None)`\n\nPrepare the buffer.\n\nParameters:\n* `input_data`: an iterable of data chunks (bytes-like instances);\n  if your data source is a file see the .from_file factory;\n  if your data source is a file descriptor see the .from_fd\n  factory.\n* `buf`: if not `None`, the initial state of the parse buffer\n* `offset`: logical offset of the start of the buffer, default 0\n* `seekable`: whether `input_data` has a working `.seek` method;\n  the default is None meaning that it will be attempted on\n  the first skip or seek\n* `copy_offsets`: if not `None`, a callable for parsers to\n  report pertinent offsets via the buffer's .report_offset\n  method\n* `copy_chunks`: if not `None`, every fetched data chunk is\n  copied to this callable\n\nThe `input_data` is an iterable whose iterator may have\nsome optional additional properties:\n* `seek`: if present, this is a seek method after the fashion\n  of `file.seek`; the buffer's `seek`, `skip` and `skipto`\n  methods will take advantage of this if available.\n* `offset`: the current byte offset of the iterator; this\n  is used during the buffer initialisation to compute\n  `input_data_displacement`, the difference between the\n  buffer's logical offset and the input data's logical offset;\n  if unavailable during initialisation this is presumed to\n  be `0`.\n* `end_offset`: the end offset of the iterator if known.\n\n## Class `FDIterator(_Iterator)`\n\nAn iterator over the data of a file descriptor.\n\n*Note*: the iterator works with an os.dup() of the file\ndescriptor so that it can close it with impunity; this requires\nthe caller to close their descriptor.\n\n### Method `FDIterator.__init__(self, fd, offset=None, readsize=None, align=True)`\n\nInitialise the iterator.\n\nParameters:\n* `fd`: file descriptor\n* `offset`: the initial logical offset, kept up to date by\n  iteration; the default is the current file position.\n* `readsize`: a preferred read size; if omitted then\n  `DEFAULT_READSIZE` will be stored\n* `align`: whether to align reads by default: if true then\n  the iterator will do a short read to bring the `offset`\n  into alignment with `readsize`; the default is `True`\n\n## Class `FileIterator(_Iterator,SeekableIteratorMixin)`\n\nAn iterator over the data of a file object.\n\n*Note*: the iterator closes the file on `__del__` or if its\n`.close` method is called.\n\n### Method `FileIterator.__init__(self, fp, offset=None, readsize=None, align=False)`\n\nInitialise the iterator.\n\nParameters:\n* `fp`: file object\n* `offset`: the initial logical offset, kept up to date by\n  iteration; the default is 0.\n* `readsize`: a preferred read size; if omitted then\n  `DEFAULT_READSIZE` will be stored\n* `align`: whether to align reads by default: if true then\n  the iterator will do a short read to bring the `offset`\n  into alignment with `readsize`; the default is `False`\n\n## Class `SeekableFDIterator(FDIterator,_Iterator,SeekableIteratorMixin)`\n\nAn iterator over the data of a seekable file descriptor.\n\n*Note*: the iterator works with an `os.dup()` of the file\ndescriptor so that it can close it with impunity; this requires\nthe caller to close their descriptor.\n\n## Class `SeekableFileIterator(FileIterator,_Iterator,SeekableIteratorMixin)`\n\nAn iterator over the data of a seekable file object.\n\n*Note*: the iterator closes the file on __del__ or if its\n.close method is called.\n\n### Method `SeekableFileIterator.__init__(self, fp, offset=None, **kw)`\n\nInitialise the iterator.\n\nParameters:\n* `fp`: file object\n* `offset`: the initial logical offset, kept up to date by\n  iteration; the default is the current file position.\n* `readsize`: a preferred read size; if omitted then\n  `DEFAULT_READSIZE` will be stored\n* `align`: whether to align reads by default: if true then\n  the iterator will do a short read to bring the `offset`\n  into alignment with `readsize`; the default is `False`\n\n## Class `SeekableIteratorMixin`\n\nMixin supplying a logical with a `seek` method.\n\n## Class `SeekableMMapIterator(_Iterator,SeekableIteratorMixin)`\n\nAn iterator over the data of a mappable file descriptor.\n\n*Note*: the iterator works with an `mmap` of an `os.dup()` of the\nfile descriptor so that it can close it with impunity; this\nrequires the caller to close their descriptor.\n\n### Method `SeekableMMapIterator.__init__(self, fd, offset=None, readsize=None, align=True)`\n\nInitialise the iterator.\n\nParameters:\n* `offset`: the initial logical offset, kept up to date by\n  iteration; the default is the current file position.\n* `readsize`: a preferred read size; if omitted then\n  `DEFAULT_READSIZE` will be stored\n* `align`: whether to align reads by default: if true then\n  the iterator will do a short read to bring the `offset`\n  into alignment with `readsize`; the default is `True`\n\n\n\n# Release Log\n\n*Release 20200328*:\nCornuCopyBuffer.takev: bugfix adjustment of buf.offset, was not always done.\nCornuCopyBuffer.__getitem__: add slice support, note how expensive it is to use.\n\n*Release 20200229*:\nNew CornuCopyBuffer.byte0() method consuming the next byte and returning it as an int.\nCornuCopyBuffer.takev: bugfix for size=0, logic refactor.\nCornuCopyBuffer: new .selfcheck method.\n\n*Release 20200130*:\nCornuCopyBuffer.skip: bugfix adjustment of skipto for already buffered data.\n\n*Release 20191230.1*:\nDocstring updates. Semantic changes were in the previous release.\n\n*Release 20191230*:\nCornuCopyBuffer: accept a size of Ellipsis in .take and .extend methods, indicating \"all the remaining data\".\nCornuCopyBuffer: refactor the buffering, replacing .buf with .bufs as an array of chunks;\nthis enables support for the new .push method and reduces memory copying.\n\n*Release 20181231*:\nSmall bugfix.\n\n*Release 20181108*:\nNew at_eof() method. Python 2 tweak to support incidental import by python 2 even if unused.\n\n*Release 20180823*:\nBetter handling of seekable and unseekable input data. Tiny bugfix for from_bytes sanity check.\n\n*Release 20180810*:\nRefactor SeekableFDIterator and SeekableFileIterator to subclass new SeekableIterator.\nNew SeekableMMapIterator to process a memory mapped file descriptor, intended for large files.\nNew CornuCopyBuffer.hint method to pass a length hint through to the input_data iterator\nif it has a `hint` method, causing it possibly to make a differently sized fetch.\nSeekableIterator: new __del__ method calling self.close() - subclasses must provide\na .close, which should be safe to call multiple times.\nCornuCopyBuffer: add support for .offset and .end_offset optional attributes on the input_data iterator.\n_BoundedBufferIterator: add .offset property plumbed to the underlying buffer offset.\nNew CornuCopyBuffer.from_mmap to make a mmap backed buffer so that large data can be returned without penalty.\nAssorted fixes and doc improvements.\n\n*Release 20180805*:\nBugfixes for at_eof method and end_offset initialisation.\n\n*Release 20180726.1*:\nImprove docstrings and release with better long_description.\n\n*Release 20180726*:\nFirst PyPI release: CornuCopyBuffer and friends.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/cameron_simpson/css/commits/all", "keywords": "python3", "license": "GNU General Public License v3 or later (GPLv3+)", "maintainer": "", "maintainer_email": "", "name": "cs.buffer", "package_url": "https://pypi.org/project/cs.buffer/", "platform": "", "project_url": "https://pypi.org/project/cs.buffer/", "project_urls": {"Homepage": "https://bitbucket.org/cameron_simpson/css/commits/all"}, "release_url": "https://pypi.org/project/cs.buffer/20200328/", "requires_dist": null, "requires_python": "", "summary": "Facilities to do with buffers, particularly CornuCopyBuffer, an automatically refilling buffer to support parsing of data streams.", "version": "20200328", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><em>Latest release 20200328</em>:\nCornuCopyBuffer.takev: bugfix adjustment of buf.offset, was not always done.\nCornuCopyBuffer.<strong>getitem</strong>: add slice support, note how expensive it is to use.</p>\n<p>Facilities to do with buffers, particularly CornuCopyBuffer,\nan automatically refilling buffer to support parsing of data streams.</p>\n<h2>Function <code>chunky(bfr_func)</code></h2>\n<p>Decorator for a function accepting a leading <code>CornuCopyBuffer</code>\nparameter.\nReturns a function accepting a leading data chunks parameter\n(bytes instances) and optional <code>offset</code> and 'copy_offsets`\nkeywords parameters.</p>\n<p>Example::</p>\n<pre><code>@chunky\ndef func(bfr, ...):\n</code></pre>\n<h2>Class <code>CopyingIterator</code></h2>\n<p>Wrapper for an iterator that copies every item retrieved to a callable.</p>\n<h3>Method <code>CopyingIterator.__init__(self, I, copy_to)</code></h3>\n<p>Initialise with the iterator <code>I</code> and the callable <code>copy_to</code>.</p>\n<h2>Class <code>CornuCopyBuffer</code></h2>\n<p>An automatically refilling buffer intended to support parsing\nof data streams.</p>\n<p>Its purpose is to aid binary parsers\nwhich do not themselves need to handle sources specially;\n<code>CornuCopyBuffer</code>s are trivially made from <code>bytes</code>,\niterables of <code>bytes</code> and file-like objects.\nSee <code>cs.binary</code> for convenient parsing classes\nwhich work against <code>CornuCopyBuffer</code>s.</p>\n<p>Attributes:</p>\n<ul>\n<li><code>buf</code>: the first of any buffered leading chunks\nbuffer of unparsed data from the input, available\nfor direct inspection by parsers;\nnormally however parsers will use <code>.extend</code> and <code>.take</code>.</li>\n<li><code>offset</code>: the logical offset of the buffer; this excludes\nbuffered data and unconsumed input data</li>\n</ul>\n<p>The primary methods supporting parsing of data streams are\n<code>.extend()</code> and <code>take()</code>.\nCalling <code>.extend(min_size)</code> arranges that <code>.buf</code> contains at least\n<code>min_size</code> bytes.\nCalling <code>.take(size)</code> fetches exactly <code>size</code> bytes from <code>.buf</code> and the\ninput source if necessary and returns them, adjusting <code>.buf</code>.</p>\n<p>len(<code>CornuCopyBuffer</code>) returns the length of any buffered data.</p>\n<p>bool(<code>CornuCopyBuffer</code>) tests whether len() &gt; 0.</p>\n<p>Indexing a <code>CornuCopyBuffer</code> accesses the buffered data only,\nreturning an individual byte's value (an <code>int</code>).</p>\n<p>A <code>CornuCopyBuffer</code> is also iterable, yielding data in whatever\nsizes come from its <code>input_data</code> source, preceeded by the\ncurrent <code>.buf</code> if not empty.</p>\n<p>A <code>CornuCopyBuffer</code> also supports the file methods <code>.read</code>,\n<code>.tell</code> and <code>.seek</code> supporting drop in use of the buffer in\nmany file contexts. Backward seeks are not supported. <code>.seek</code>\nwill take advantage of the <code>input_data</code>'s .seek method if it\nhas one, otherwise it will use reads.</p>\n<h3>Method <code>CornuCopyBuffer.__init__(self, input_data, buf=None, offset=0, seekable=None, copy_offsets=None, copy_chunks=None)</code></h3>\n<p>Prepare the buffer.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>input_data</code>: an iterable of data chunks (bytes-like instances);\nif your data source is a file see the .from_file factory;\nif your data source is a file descriptor see the .from_fd\nfactory.</li>\n<li><code>buf</code>: if not <code>None</code>, the initial state of the parse buffer</li>\n<li><code>offset</code>: logical offset of the start of the buffer, default 0</li>\n<li><code>seekable</code>: whether <code>input_data</code> has a working <code>.seek</code> method;\nthe default is None meaning that it will be attempted on\nthe first skip or seek</li>\n<li><code>copy_offsets</code>: if not <code>None</code>, a callable for parsers to\nreport pertinent offsets via the buffer's .report_offset\nmethod</li>\n<li><code>copy_chunks</code>: if not <code>None</code>, every fetched data chunk is\ncopied to this callable</li>\n</ul>\n<p>The <code>input_data</code> is an iterable whose iterator may have\nsome optional additional properties:</p>\n<ul>\n<li><code>seek</code>: if present, this is a seek method after the fashion\nof <code>file.seek</code>; the buffer's <code>seek</code>, <code>skip</code> and <code>skipto</code>\nmethods will take advantage of this if available.</li>\n<li><code>offset</code>: the current byte offset of the iterator; this\nis used during the buffer initialisation to compute\n<code>input_data_displacement</code>, the difference between the\nbuffer's logical offset and the input data's logical offset;\nif unavailable during initialisation this is presumed to\nbe <code>0</code>.</li>\n<li><code>end_offset</code>: the end offset of the iterator if known.</li>\n</ul>\n<h2>Class <code>FDIterator(_Iterator)</code></h2>\n<p>An iterator over the data of a file descriptor.</p>\n<p><em>Note</em>: the iterator works with an os.dup() of the file\ndescriptor so that it can close it with impunity; this requires\nthe caller to close their descriptor.</p>\n<h3>Method <code>FDIterator.__init__(self, fd, offset=None, readsize=None, align=True)</code></h3>\n<p>Initialise the iterator.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>fd</code>: file descriptor</li>\n<li><code>offset</code>: the initial logical offset, kept up to date by\niteration; the default is the current file position.</li>\n<li><code>readsize</code>: a preferred read size; if omitted then\n<code>DEFAULT_READSIZE</code> will be stored</li>\n<li><code>align</code>: whether to align reads by default: if true then\nthe iterator will do a short read to bring the <code>offset</code>\ninto alignment with <code>readsize</code>; the default is <code>True</code></li>\n</ul>\n<h2>Class <code>FileIterator(_Iterator,SeekableIteratorMixin)</code></h2>\n<p>An iterator over the data of a file object.</p>\n<p><em>Note</em>: the iterator closes the file on <code>__del__</code> or if its\n<code>.close</code> method is called.</p>\n<h3>Method <code>FileIterator.__init__(self, fp, offset=None, readsize=None, align=False)</code></h3>\n<p>Initialise the iterator.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>fp</code>: file object</li>\n<li><code>offset</code>: the initial logical offset, kept up to date by\niteration; the default is 0.</li>\n<li><code>readsize</code>: a preferred read size; if omitted then\n<code>DEFAULT_READSIZE</code> will be stored</li>\n<li><code>align</code>: whether to align reads by default: if true then\nthe iterator will do a short read to bring the <code>offset</code>\ninto alignment with <code>readsize</code>; the default is <code>False</code></li>\n</ul>\n<h2>Class <code>SeekableFDIterator(FDIterator,_Iterator,SeekableIteratorMixin)</code></h2>\n<p>An iterator over the data of a seekable file descriptor.</p>\n<p><em>Note</em>: the iterator works with an <code>os.dup()</code> of the file\ndescriptor so that it can close it with impunity; this requires\nthe caller to close their descriptor.</p>\n<h2>Class <code>SeekableFileIterator(FileIterator,_Iterator,SeekableIteratorMixin)</code></h2>\n<p>An iterator over the data of a seekable file object.</p>\n<p><em>Note</em>: the iterator closes the file on <strong>del</strong> or if its\n.close method is called.</p>\n<h3>Method <code>SeekableFileIterator.__init__(self, fp, offset=None, **kw)</code></h3>\n<p>Initialise the iterator.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>fp</code>: file object</li>\n<li><code>offset</code>: the initial logical offset, kept up to date by\niteration; the default is the current file position.</li>\n<li><code>readsize</code>: a preferred read size; if omitted then\n<code>DEFAULT_READSIZE</code> will be stored</li>\n<li><code>align</code>: whether to align reads by default: if true then\nthe iterator will do a short read to bring the <code>offset</code>\ninto alignment with <code>readsize</code>; the default is <code>False</code></li>\n</ul>\n<h2>Class <code>SeekableIteratorMixin</code></h2>\n<p>Mixin supplying a logical with a <code>seek</code> method.</p>\n<h2>Class <code>SeekableMMapIterator(_Iterator,SeekableIteratorMixin)</code></h2>\n<p>An iterator over the data of a mappable file descriptor.</p>\n<p><em>Note</em>: the iterator works with an <code>mmap</code> of an <code>os.dup()</code> of the\nfile descriptor so that it can close it with impunity; this\nrequires the caller to close their descriptor.</p>\n<h3>Method <code>SeekableMMapIterator.__init__(self, fd, offset=None, readsize=None, align=True)</code></h3>\n<p>Initialise the iterator.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>offset</code>: the initial logical offset, kept up to date by\niteration; the default is the current file position.</li>\n<li><code>readsize</code>: a preferred read size; if omitted then\n<code>DEFAULT_READSIZE</code> will be stored</li>\n<li><code>align</code>: whether to align reads by default: if true then\nthe iterator will do a short read to bring the <code>offset</code>\ninto alignment with <code>readsize</code>; the default is <code>True</code></li>\n</ul>\n<h1>Release Log</h1>\n<p><em>Release 20200328</em>:\nCornuCopyBuffer.takev: bugfix adjustment of buf.offset, was not always done.\nCornuCopyBuffer.<strong>getitem</strong>: add slice support, note how expensive it is to use.</p>\n<p><em>Release 20200229</em>:\nNew CornuCopyBuffer.byte0() method consuming the next byte and returning it as an int.\nCornuCopyBuffer.takev: bugfix for size=0, logic refactor.\nCornuCopyBuffer: new .selfcheck method.</p>\n<p><em>Release 20200130</em>:\nCornuCopyBuffer.skip: bugfix adjustment of skipto for already buffered data.</p>\n<p><em>Release 20191230.1</em>:\nDocstring updates. Semantic changes were in the previous release.</p>\n<p><em>Release 20191230</em>:\nCornuCopyBuffer: accept a size of Ellipsis in .take and .extend methods, indicating \"all the remaining data\".\nCornuCopyBuffer: refactor the buffering, replacing .buf with .bufs as an array of chunks;\nthis enables support for the new .push method and reduces memory copying.</p>\n<p><em>Release 20181231</em>:\nSmall bugfix.</p>\n<p><em>Release 20181108</em>:\nNew at_eof() method. Python 2 tweak to support incidental import by python 2 even if unused.</p>\n<p><em>Release 20180823</em>:\nBetter handling of seekable and unseekable input data. Tiny bugfix for from_bytes sanity check.</p>\n<p><em>Release 20180810</em>:\nRefactor SeekableFDIterator and SeekableFileIterator to subclass new SeekableIterator.\nNew SeekableMMapIterator to process a memory mapped file descriptor, intended for large files.\nNew CornuCopyBuffer.hint method to pass a length hint through to the input_data iterator\nif it has a <code>hint</code> method, causing it possibly to make a differently sized fetch.\nSeekableIterator: new <strong>del</strong> method calling self.close() - subclasses must provide\na .close, which should be safe to call multiple times.\nCornuCopyBuffer: add support for .offset and .end_offset optional attributes on the input_data iterator.\n_BoundedBufferIterator: add .offset property plumbed to the underlying buffer offset.\nNew CornuCopyBuffer.from_mmap to make a mmap backed buffer so that large data can be returned without penalty.\nAssorted fixes and doc improvements.</p>\n<p><em>Release 20180805</em>:\nBugfixes for at_eof method and end_offset initialisation.</p>\n<p><em>Release 20180726.1</em>:\nImprove docstrings and release with better long_description.</p>\n<p><em>Release 20180726</em>:\nFirst PyPI release: CornuCopyBuffer and friends.</p>\n\n          </div>"}, "last_serial": 6901203, "releases": {"20180726": [{"comment_text": "", "digests": {"md5": "37c65e45ee38e73bd95607b4ff552f39", "sha256": "54d39dbc51c667dd553496a4632a7318bdac7d659dc8ca156c8f659b1b12145b"}, "downloads": -1, "filename": "cs.buffer-20180726.tar.gz", "has_sig": false, "md5_digest": "37c65e45ee38e73bd95607b4ff552f39", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7216, "upload_time": "2018-07-26T02:11:57", "upload_time_iso_8601": "2018-07-26T02:11:57.002626Z", "url": "https://files.pythonhosted.org/packages/f0/fd/0a4d2437b33af366e76f01652cc42900be884c18eb4ec3f6ff939e00ed30/cs.buffer-20180726.tar.gz", "yanked": false}], "20180726.1": [{"comment_text": "", "digests": {"md5": "56e492e00b3a0182986d7b37e5e6cdad", "sha256": "459d0dbd584751ce3c4ec501b53e7001f55f8d0f27202be2e00a50848ee26d98"}, "downloads": -1, "filename": "cs.buffer-20180726.1.tar.gz", "has_sig": false, "md5_digest": "56e492e00b3a0182986d7b37e5e6cdad", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7615, "upload_time": "2018-07-26T02:18:15", "upload_time_iso_8601": "2018-07-26T02:18:15.467012Z", "url": "https://files.pythonhosted.org/packages/f7/ba/ca82f1ba1f6d0ecae52fbb202f4afcd6393df357a7277df939771f0cab4b/cs.buffer-20180726.1.tar.gz", "yanked": false}], "20180805": [{"comment_text": "", "digests": {"md5": "a576c2ba32084764549157f6f6ba882b", "sha256": "77346047c0a0cdabe4569a7baa43b2fded7c1fef3a541d7e9efcdd07fd0f242d"}, "downloads": -1, "filename": "cs.buffer-20180805.tar.gz", "has_sig": false, "md5_digest": "a576c2ba32084764549157f6f6ba882b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7606, "upload_time": "2018-08-04T23:37:15", "upload_time_iso_8601": "2018-08-04T23:37:15.500945Z", "url": "https://files.pythonhosted.org/packages/40/d5/ceffdbe3bdb6ea5ddafcc6820a82e595864c0556dd62bb6b9d90b0e73a06/cs.buffer-20180805.tar.gz", "yanked": false}], "20180810": [{"comment_text": "", "digests": {"md5": "36d4a8c1843cc92a5d0639bc0e80af63", "sha256": "92e587de7472c4b2f757b4f953332f29ffafcbc29416ce5089ff7a4215b19ba5"}, "downloads": -1, "filename": "cs.buffer-20180810.tar.gz", "has_sig": false, "md5_digest": "36d4a8c1843cc92a5d0639bc0e80af63", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10410, "upload_time": "2018-08-09T23:13:41", "upload_time_iso_8601": "2018-08-09T23:13:41.321612Z", "url": "https://files.pythonhosted.org/packages/51/db/f9974703a0a5db04a20dadcc3d9ce64b0520d647c50784947a6eeb874bbf/cs.buffer-20180810.tar.gz", "yanked": false}], "20180823": [{"comment_text": "", "digests": {"md5": "229b1e721d86fac63da6c42c5a61d2b5", "sha256": "cbfafc0257ea9eaaf91744a9e022f46e3c11782932ff5c12db13613282c9fe67"}, "downloads": -1, "filename": "cs.buffer-20180823.tar.gz", "has_sig": false, "md5_digest": "229b1e721d86fac63da6c42c5a61d2b5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11120, "upload_time": "2018-08-23T02:16:14", "upload_time_iso_8601": "2018-08-23T02:16:14.415891Z", "url": "https://files.pythonhosted.org/packages/1b/0f/65bc5f8c4bf7e5149f8765f50998b700e652cc8918b41efe0b2bc49f9bc4/cs.buffer-20180823.tar.gz", "yanked": false}], "20181108": [{"comment_text": "", "digests": {"md5": "e3aed9e08aecbdd5f49d04e86a6c5859", "sha256": "f46874de49f45cd2e73577972bb53a656f2f251b71a5f4808e0227cc10b417d8"}, "downloads": -1, "filename": "cs.buffer-20181108.tar.gz", "has_sig": false, "md5_digest": "e3aed9e08aecbdd5f49d04e86a6c5859", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11132, "upload_time": "2018-11-08T03:51:34", "upload_time_iso_8601": "2018-11-08T03:51:34.052772Z", "url": "https://files.pythonhosted.org/packages/9e/e3/fd7631bc792752b9d6f8584add81bf90db9ca721e16125a169748bfcc224/cs.buffer-20181108.tar.gz", "yanked": false}], "20181231": [{"comment_text": "", "digests": {"md5": "3d667843ecee2bb392132728ed896eec", "sha256": "2eda809e7bc22f8efe8b7385a276ed0fb5c524c4111141626eba491ed70ab123"}, "downloads": -1, "filename": "cs.buffer-20181231.tar.gz", "has_sig": false, "md5_digest": "3d667843ecee2bb392132728ed896eec", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11133, "upload_time": "2018-12-31T10:11:28", "upload_time_iso_8601": "2018-12-31T10:11:28.970905Z", "url": "https://files.pythonhosted.org/packages/ae/83/5fd1a62471838cdc401bd9bc6c88e00009b8e49cbb640eba94197c6ebd35/cs.buffer-20181231.tar.gz", "yanked": false}], "20191230": [{"comment_text": "", "digests": {"md5": "bbebda28aa7da3e501049356ad3e8b5c", "sha256": "95fb940cc7b648e176071263b0f8ee16f819be1e561eda843df6d6bc17a0a88a"}, "downloads": -1, "filename": "cs.buffer-20191230.tar.gz", "has_sig": false, "md5_digest": "bbebda28aa7da3e501049356ad3e8b5c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15821, "upload_time": "2019-12-30T02:29:10", "upload_time_iso_8601": "2019-12-30T02:29:10.535949Z", "url": "https://files.pythonhosted.org/packages/34/6b/c7521efbe6f0c57763c84b7b2972d2d620f446fecb9832fce92096af7fce/cs.buffer-20191230.tar.gz", "yanked": false}], "20191230.1": [{"comment_text": "", "digests": {"md5": "25042ac437d3056eb1f8fe8878ca1033", "sha256": "c14ea311b797f1a2c672c0315a9859ff567adcbc963aa581692bd0859c186898"}, "downloads": -1, "filename": "cs.buffer-20191230.1.tar.gz", "has_sig": false, "md5_digest": "25042ac437d3056eb1f8fe8878ca1033", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16459, "upload_time": "2019-12-30T02:47:45", "upload_time_iso_8601": "2019-12-30T02:47:45.478229Z", "url": "https://files.pythonhosted.org/packages/3f/71/ccf387eeb0aeef5b289061d938faa3c918cb44de0c697fe1812dc03946d8/cs.buffer-20191230.1.tar.gz", "yanked": false}], "20200130": [{"comment_text": "", "digests": {"md5": "1462295b9fe58dcb780b1561256f9562", "sha256": "932d50e018f29900554c95d56d69b12bb224446e57718f4b4e30d5675149d9a3"}, "downloads": -1, "filename": "cs.buffer-20200130.tar.gz", "has_sig": false, "md5_digest": "1462295b9fe58dcb780b1561256f9562", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16462, "upload_time": "2020-01-30T06:17:18", "upload_time_iso_8601": "2020-01-30T06:17:18.536094Z", "url": "https://files.pythonhosted.org/packages/fb/0d/0f50c10549d7e5feda4726e45b77c6dbcd0c5ba28800c8c5845ec2a4cf7b/cs.buffer-20200130.tar.gz", "yanked": false}], "20200229": [{"comment_text": "", "digests": {"md5": "c4834a0650278e19bfb8ce7e4d1305aa", "sha256": "3ee2ae7d30a6edac9de1b39616566579a1523603f4253ca095f2a7fb8e17d59c"}, "downloads": -1, "filename": "cs.buffer-20200229.tar.gz", "has_sig": false, "md5_digest": "c4834a0650278e19bfb8ce7e4d1305aa", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16922, "upload_time": "2020-02-29T06:32:39", "upload_time_iso_8601": "2020-02-29T06:32:39.304600Z", "url": "https://files.pythonhosted.org/packages/33/80/3ad7e75882c8892f9e5f006522d7b898986b0b7fe894484ffbbe6b0f7607/cs.buffer-20200229.tar.gz", "yanked": false}], "20200328": [{"comment_text": "", "digests": {"md5": "2f458c6ee38766aa87fbc4a2b6414e98", "sha256": "de378f2d6e7edfe8aaf1718ad57a2ecc45dc9d1271599a79b35ed8357c427a6b"}, "downloads": -1, "filename": "cs.buffer-20200328.tar.gz", "has_sig": false, "md5_digest": "2f458c6ee38766aa87fbc4a2b6414e98", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17328, "upload_time": "2020-03-28T10:12:27", "upload_time_iso_8601": "2020-03-28T10:12:27.562004Z", "url": "https://files.pythonhosted.org/packages/1a/7f/19dc2ce594df81009c38b98de93fd6508d2fe71a1974f504ac032a491b2f/cs.buffer-20200328.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2f458c6ee38766aa87fbc4a2b6414e98", "sha256": "de378f2d6e7edfe8aaf1718ad57a2ecc45dc9d1271599a79b35ed8357c427a6b"}, "downloads": -1, "filename": "cs.buffer-20200328.tar.gz", "has_sig": false, "md5_digest": "2f458c6ee38766aa87fbc4a2b6414e98", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17328, "upload_time": "2020-03-28T10:12:27", "upload_time_iso_8601": "2020-03-28T10:12:27.562004Z", "url": "https://files.pythonhosted.org/packages/1a/7f/19dc2ce594df81009c38b98de93fd6508d2fe71a1974f504ac032a491b2f/cs.buffer-20200328.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:41:52 2020"}