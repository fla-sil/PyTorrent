{"info": {"author": "Danish Prakash", "author_email": "danishprakash@outlook.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Operating System :: POSIX :: Linux", "Programming Language :: C", "Programming Language :: Python :: 3.0", "Programming Language :: Python :: 3.1", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: System :: Filesystems", "Topic :: System :: Operating System", "Topic :: System :: Operating System Kernels :: Linux"], "description": "splice\n======\n\nA Python interface to splice(2) system call.\n\nAbout\n-----\n`splice(2) <http://man7.org/linux/man-pages/man2/splice.2.html>`__ moves\ndata between two file descriptors without copying between kernel\naddress space and user address space.  It transfers up to ``nbytes`` bytes\nof data from the file descriptor ``in`` to the file descriptor ``out``.\n\nzero-copy\n---------\nNormally when you copy data from one data stream to another, the data\nto be copied is first stored in a buffer in userspace and is then\ncopied back to the target data stream from the user space which\nintroduces a certain overhead.\n\nzero-copy allows us to operate on data without the use of copying \ndata to userspace. It essentialy transfers the data by remapping pages\nand not actually performing the copying of data, resulting in \nimproved performance.\n\nIllustrated below is a simple example of copying data from one file\nto another using the ``splice(2)`` system call. For the complete documentation\nsee `API Documentation`_.\n\n.. code-block:: python\n\n    # copy data from one file to another using splice\n\n    from splice import splice\n\n    to_read = open(\"read.txt\")\n    to_write = open(\"write.txt\", \"w+\")\n\n    splice(to_read.fileno(), to_write.fileno())\n\n\nThis copying of the data twice (once into the userland buffer, and once out\nfrom that userland buffer) imposes some performance and resource penalties.\n`splice(2) <http://linux.die.net/man/2/splice>`__ syscall avoids these\npenalties by avoiding any use of userland buffers; it also results in a single\nsystem call (and thus only one context switch), rather than the series of\n`read(2) <http://linux.die.net/man/2/read>`__ /\n`write(2) <http://linux.die.net/man/2/write>`__ system calls (each system call\nrequiring a context switch) used internally for the data copying.\n\n\nAPI Documentation\n-----------------\n\nsendfile module provides a single function: sendfile().\n\n* ``splice.splice(out, in, offset, nbytes, flags)``\n\n  Copy *nbytes* bytes from file descriptor *in* (a regular file) to file\n  descriptor *out* (a regular file) starting at *offset*. Return the number of\n  bytes just being sent. When the end of file is reached return 0.\n  If *offset* is not specified, the bytes are read from the current\n  position of *in* and the position of *in* is updated. If *nbytes* is\n  not specified, the whole of *in* is copied over to *out*.\n\n  **Required arguments**\n  \n  - ``in``: file descriptor of the file from which data is to be read.\n  - ``out``: file descriptor of the file to which data is to be transferred.\n\n  **Positional optional arguments**\n  \n  - ``offset``: offset from where the input file is read from.\n  - ``nbytes``: number of bytes to be copied in total, default value\n  - ``flags``: a bit mask which can be composed by ORing together the following.\n  \n      + ``splice.SPLICE_F_MOVE``\n      + ``splice.SPLICE_F_NONBLOCK``\n      + ``splice.SPLICE_F_MORE``\n      + ``splice.SPLICE_F_GIFT``\n\n  More information on what each of the flag means can be found on the splice(2)\n  man page `here <http://man7.org/linux/man-pages/man2/splice.2.html>`__.\n\n\nUsage\n-----\n\n.. code-block:: python\n\n    >>> from splice import splice\n\n    # init file objects\n    >>> to_read = open(\"read.txt\") # file to read from\n    >>> to_write = open(\"write.txt\", \"w+\") # file to write to\n\n    >>> len(to_read.read())\n    50\n\n    # copying whole file\n    >>> splice(to_read.fileno(), to_write.fileno())\n    50  # bytes copied\n\n    # copying file starting from an offset\n    >>> splice(to_read.fileno(), to_write.fileno(), offset=10)\n    40\n\n    # copying certain amount of bytes\n    >>> splice(to_read.fileno(), to_write.fileno(), nbytes=20)\n    20\n\n    # copying certain amount of bytes beginning from an offset\n    >>> splice(to_read.fileno(), to_write.fileno(), offset=10, nbytes=20)\n    20\n\n    # specifying flags\n    >>> import splice\n    >>> splice(to_read.fileno(), to_write.fileno(), flags=splice.SPLICE_F_MORE)\n    50\n\n\nWhy would I use this?\n---------------------\n``splice(2)`` is supposed to be better in terms of performance when compared\nto traditional read/write methods since it avoids overhead of copying the\ndata to user address space and instead, does the transfer by remapping pages\nin kernel address space.\n\n\nSupported platforms\n-------------------\nThe ``splice(2)`` system call is (GNU)Linux-specific.\n\n\nSupport\n-------\nFeel free to add improvements, report issues or contact me about anything related to the project.\n\n\nLICENSE\n-------\nGNU GPL", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/danishprakash/py-splice", "keywords": "splice,python,performance,zero-copy", "license": "GPL", "maintainer": "", "maintainer_email": "", "name": "py-splice", "package_url": "https://pypi.org/project/py-splice/", "platform": "UNIX", "project_url": "https://pypi.org/project/py-splice/", "project_urls": {"Homepage": "https://github.com/danishprakash/py-splice"}, "release_url": "https://pypi.org/project/py-splice/1.0.2/", "requires_dist": null, "requires_python": "", "summary": "A Python interface to splice(2)", "version": "1.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>A Python interface to splice(2) system call.</p>\n<div id=\"about\">\n<h2>About</h2>\n<p><a href=\"http://man7.org/linux/man-pages/man2/splice.2.html\" rel=\"nofollow\">splice(2)</a> moves\ndata between two file descriptors without copying between kernel\naddress space and user address space.  It transfers up to <tt>nbytes</tt> bytes\nof data from the file descriptor <tt>in</tt> to the file descriptor <tt>out</tt>.</p>\n</div>\n<div id=\"zero-copy\">\n<h2>zero-copy</h2>\n<p>Normally when you copy data from one data stream to another, the data\nto be copied is first stored in a buffer in userspace and is then\ncopied back to the target data stream from the user space which\nintroduces a certain overhead.</p>\n<p>zero-copy allows us to operate on data without the use of copying\ndata to userspace. It essentialy transfers the data by remapping pages\nand not actually performing the copying of data, resulting in\nimproved performance.</p>\n<p>Illustrated below is a simple example of copying data from one file\nto another using the <tt>splice(2)</tt> system call. For the complete documentation\nsee <a href=\"#api-documentation\" rel=\"nofollow\">API Documentation</a>.</p>\n<pre><span class=\"c1\"># copy data from one file to another using splice</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">splice</span> <span class=\"kn\">import</span> <span class=\"n\">splice</span>\n\n<span class=\"n\">to_read</span> <span class=\"o\">=</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"read.txt\"</span><span class=\"p\">)</span>\n<span class=\"n\">to_write</span> <span class=\"o\">=</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"write.txt\"</span><span class=\"p\">,</span> <span class=\"s2\">\"w+\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">splice</span><span class=\"p\">(</span><span class=\"n\">to_read</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"n\">to_write</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">())</span>\n</pre>\n<p>This copying of the data twice (once into the userland buffer, and once out\nfrom that userland buffer) imposes some performance and resource penalties.\n<a href=\"http://linux.die.net/man/2/splice\" rel=\"nofollow\">splice(2)</a> syscall avoids these\npenalties by avoiding any use of userland buffers; it also results in a single\nsystem call (and thus only one context switch), rather than the series of\n<a href=\"http://linux.die.net/man/2/read\" rel=\"nofollow\">read(2)</a> /\n<a href=\"http://linux.die.net/man/2/write\" rel=\"nofollow\">write(2)</a> system calls (each system call\nrequiring a context switch) used internally for the data copying.</p>\n</div>\n<div id=\"api-documentation\">\n<h2>API Documentation</h2>\n<p>sendfile module provides a single function: sendfile().</p>\n<ul>\n<li><p><tt>splice.splice(out, in, offset, nbytes, flags)</tt></p>\n<p>Copy <em>nbytes</em> bytes from file descriptor <em>in</em> (a regular file) to file\ndescriptor <em>out</em> (a regular file) starting at <em>offset</em>. Return the number of\nbytes just being sent. When the end of file is reached return 0.\nIf <em>offset</em> is not specified, the bytes are read from the current\nposition of <em>in</em> and the position of <em>in</em> is updated. If <em>nbytes</em> is\nnot specified, the whole of <em>in</em> is copied over to <em>out</em>.</p>\n<p><strong>Required arguments</strong></p>\n<ul>\n<li><tt>in</tt>: file descriptor of the file from which data is to be read.</li>\n<li><tt>out</tt>: file descriptor of the file to which data is to be transferred.</li>\n</ul>\n<p><strong>Positional optional arguments</strong></p>\n<ul>\n<li><p><tt>offset</tt>: offset from where the input file is read from.</p>\n</li>\n<li><p><tt>nbytes</tt>: number of bytes to be copied in total, default value</p>\n</li>\n<li><p><tt>flags</tt>: a bit mask which can be composed by ORing together the following.</p>\n<blockquote>\n<ul>\n<li><tt>splice.SPLICE_F_MOVE</tt></li>\n<li><tt>splice.SPLICE_F_NONBLOCK</tt></li>\n<li><tt>splice.SPLICE_F_MORE</tt></li>\n<li><tt>splice.SPLICE_F_GIFT</tt></li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>More information on what each of the flag means can be found on the splice(2)\nman page <a href=\"http://man7.org/linux/man-pages/man2/splice.2.html\" rel=\"nofollow\">here</a>.</p>\n</li>\n</ul>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">splice</span> <span class=\"kn\">import</span> <span class=\"n\">splice</span>\n\n<span class=\"c1\"># init file objects</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">to_read</span> <span class=\"o\">=</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"read.txt\"</span><span class=\"p\">)</span> <span class=\"c1\"># file to read from</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">to_write</span> <span class=\"o\">=</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"write.txt\"</span><span class=\"p\">,</span> <span class=\"s2\">\"w+\"</span><span class=\"p\">)</span> <span class=\"c1\"># file to write to</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">to_read</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">())</span>\n<span class=\"mi\">50</span>\n\n<span class=\"c1\"># copying whole file</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">splice</span><span class=\"p\">(</span><span class=\"n\">to_read</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"n\">to_write</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">())</span>\n<span class=\"mi\">50</span>  <span class=\"c1\"># bytes copied</span>\n\n<span class=\"c1\"># copying file starting from an offset</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">splice</span><span class=\"p\">(</span><span class=\"n\">to_read</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"n\">to_write</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"n\">offset</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"mi\">40</span>\n\n<span class=\"c1\"># copying certain amount of bytes</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">splice</span><span class=\"p\">(</span><span class=\"n\">to_read</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"n\">to_write</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"n\">nbytes</span><span class=\"o\">=</span><span class=\"mi\">20</span><span class=\"p\">)</span>\n<span class=\"mi\">20</span>\n\n<span class=\"c1\"># copying certain amount of bytes beginning from an offset</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">splice</span><span class=\"p\">(</span><span class=\"n\">to_read</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"n\">to_write</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"n\">offset</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">nbytes</span><span class=\"o\">=</span><span class=\"mi\">20</span><span class=\"p\">)</span>\n<span class=\"mi\">20</span>\n\n<span class=\"c1\"># specifying flags</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">splice</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">splice</span><span class=\"p\">(</span><span class=\"n\">to_read</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"n\">to_write</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"n\">flags</span><span class=\"o\">=</span><span class=\"n\">splice</span><span class=\"o\">.</span><span class=\"n\">SPLICE_F_MORE</span><span class=\"p\">)</span>\n<span class=\"mi\">50</span>\n</pre>\n</div>\n<div id=\"why-would-i-use-this\">\n<h2>Why would I use this?</h2>\n<p><tt>splice(2)</tt> is supposed to be better in terms of performance when compared\nto traditional read/write methods since it avoids overhead of copying the\ndata to user address space and instead, does the transfer by remapping pages\nin kernel address space.</p>\n</div>\n<div id=\"supported-platforms\">\n<h2>Supported platforms</h2>\n<p>The <tt>splice(2)</tt> system call is (GNU)Linux-specific.</p>\n</div>\n<div id=\"support\">\n<h2>Support</h2>\n<p>Feel free to add improvements, report issues or contact me about anything related to the project.</p>\n</div>\n<div id=\"license\">\n<h2>LICENSE</h2>\n<p>GNU GPL</p>\n</div>\n\n          </div>"}, "last_serial": 4548204, "releases": {"1.0.1": [{"comment_text": "", "digests": {"md5": "402fc6945e5dac1c16cd51e3daf8056b", "sha256": "bb5432c403c292fcf25b864bd5c00cefaa09c2245bd2fc6dc25968d3540e921d"}, "downloads": -1, "filename": "py-splice-1.0.1.tar.gz", "has_sig": false, "md5_digest": "402fc6945e5dac1c16cd51e3daf8056b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4286, "upload_time": "2018-11-30T15:15:25", "upload_time_iso_8601": "2018-11-30T15:15:25.241922Z", "url": "https://files.pythonhosted.org/packages/68/63/6defa90cb4d26fc66faeeddc852b0645f488718abb3e19efd1dd6abd2b03/py-splice-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "8e56813b3aaa8f860ea2c6f1595c944a", "sha256": "5d08b4c0ba8e6bf77eaa8fb7d8932d6538c38e83f4a2722035f0ac9c2e3a82fe"}, "downloads": -1, "filename": "py-splice-1.0.2.tar.gz", "has_sig": false, "md5_digest": "8e56813b3aaa8f860ea2c6f1595c944a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16770, "upload_time": "2018-11-30T18:39:41", "upload_time_iso_8601": "2018-11-30T18:39:41.468052Z", "url": "https://files.pythonhosted.org/packages/e5/e0/7fb9972011e9462a5fbd6692c62fad9d10e603159b4adf8c1a8774ff874b/py-splice-1.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "8e56813b3aaa8f860ea2c6f1595c944a", "sha256": "5d08b4c0ba8e6bf77eaa8fb7d8932d6538c38e83f4a2722035f0ac9c2e3a82fe"}, "downloads": -1, "filename": "py-splice-1.0.2.tar.gz", "has_sig": false, "md5_digest": "8e56813b3aaa8f860ea2c6f1595c944a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16770, "upload_time": "2018-11-30T18:39:41", "upload_time_iso_8601": "2018-11-30T18:39:41.468052Z", "url": "https://files.pythonhosted.org/packages/e5/e0/7fb9972011e9462a5fbd6692c62fad9d10e603159b4adf8c1a8774ff874b/py-splice-1.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:56:12 2020"}