{"info": {"author": "Kale Kundert", "author_email": "kale@thekunderts.net", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Programming Language :: Python :: 2", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries"], "description": "``autoprop`` --- Infer properties from accessor methods\n=======================================================\n.. image:: https://img.shields.io/pypi/v/autoprop.svg\n   :target: https://pypi.python.org/pypi/autoprop\n\n.. image:: https://img.shields.io/pypi/pyversions/autoprop.svg\n   :target: https://pypi.python.org/pypi/autoprop\n\n.. image:: https://img.shields.io/travis/kalekundert/autoprop.svg\n   :target: https://travis-ci.org/kalekundert/autoprop\n\n.. image:: https://img.shields.io/coveralls/kalekundert/autoprop.svg\n   :target: https://coveralls.io/github/kalekundert/autoprop?branch=master\n\nProperties are a feature in python that allow accessor functions (i.e. getters \nand setters) to masquerade as regular attributes.  This makes it possible to \nprovide transparent APIs for classes that need to cache results, lazily load \ndata, maintain invariants, or react in any other way to attribute access.\n\nUnfortunately, making a property requires an annoying amount of boilerplate \ncode.  There are a few ways to do it, but the most common and most succinct \nrequires you to decorate two functions (with two different decorators) and to \ntype the name of the attribute three times::\n\n    class RegularProperty:\n        \n        @property\n        def attr(self):\n            return self._attr\n\n        @attr.setter\n        def attr(self, new_value):\n            self._attr = new_value\n\nThe ``autoprop`` module simplifies this process by searching your class for \naccessor methods and adding properties corresponding to any such methods it \nfinds.  For example, the code below defines the same property as the code \nabove::\n\n    @autoprop\n    class AutoProperty:\n        \n        def get_attr(self):\n            return self._attr\n\n        def set_attr(self, new_value):\n            self._attr = new_value\n\nInstallation\n------------\n``autoprop`` is available on PyPI, so you can install it using ``pip``::\n\n    pip install autoprop\n\nUsage\n-----\nTo use ``autoprop``, import the ``autoprop`` module and use it directly as a \nclass decorator::\n\n    import autoprop\n\n    @autoprop\n    class Vector2D:\n       \n        def __init__(self, x, y):\n            self._x = x\n            self._y = y\n\n        def get_x(self):\n            return self._x\n\n        def set_x(self, x):\n            self._x = x\n\n        def get_y(self):\n            return self._y\n\n        def set_y(self, y):\n            self._y = y\n\nThe decorator searches your class for methods beginning with ``get_``, \n``set_``, or ``del_`` and uses them to create properties.  The names of the \nproperties are taken from whatever comes after the underscore.  For example, \nthe method ``get_x`` would be used to make a property called ``x``.  Any \ncombination of getter, setter, and deleter methods is allowed for each \nproperty.\n\nIf you have properties that are expensive to calculate, you can indicate that \nthey should be cached::\n\n    @autoprop\n    class Vector2D:\n        \n        ...\n\n        @autoprop.cache\n        def get_magnitude(self):\n            return math.sqrt(self._x**2 + self._y**2)\n\nCached properties will only be calculated when they are accessed either for the \nfirst time ever, or for the first time after calls to the corresponding setter \nor deleter (if any are defined).\n\nDetails\n=======\nBesides having the right prefix, there are two other criteria methods must meet \nin order to be made into properties.  The first is that they must take the \nright number of required arguments.  Getters and deleters can't have any \nrequired arguments (other than self).  Setters must have exactly one required \nargument (other than self), which is the value to set.  Default, variable, and \nkeyword arguments are all ok; only the number of required arguments matters.\n\nAny methods that have the right name but the wrong arguments are silently \nignored.  This can be nice for getters that require, for example, an index.  \nEven though such a getter can't be made into a property, ``autoprop`` allows it \nto follow the same naming conventions as any getters that can be::\n\n    @autoprop\n    class Vector2D:\n        \n        ...\n\n        def get_coord(self, i):\n            if i == 0: return self._x\n            if i == 1: return self._y\n\n        def set_coord(self, i, new_coord):\n            if i == 0: self.x = new_coord\n            if i == 1: self.y = new_coord\n\nIn this way, users of your class can always expect to find accessors named \n``get_*`` and ``set_*``, and properties corresponding to those accessors for \nbasic attributes that don't need any extra information.\n\nThe second criterion is that the property must have a name which is not already \nin use.  This guarantees that nothing you explicitly add to your class will be \noverwritten, and it gives you the ability to customize how certain properties \nare defined if you'd so like.  Note that this criterion does not apply to \nproperties that ``autoprop`` itself created.  This really just means that if \nyou overwrite some accessors defined in a superclass, you'll get new properties \nthat refer to the overridden accessors and not be left with stale references to \nthe superclass accessors.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kalekundert/autoprop", "keywords": "property,properties,accessor,accessors,getter,setter", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "autoprop", "package_url": "https://pypi.org/project/autoprop/", "platform": "", "project_url": "https://pypi.org/project/autoprop/", "project_urls": {"Homepage": "https://github.com/kalekundert/autoprop"}, "release_url": "https://pypi.org/project/autoprop/1.0.1/", "requires_dist": null, "requires_python": "", "summary": "", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"autoprop-infer-properties-from-accessor-methods\">\n<h2><tt>autoprop</tt> \u2014 Infer properties from accessor methods</h2>\n<a href=\"https://pypi.python.org/pypi/autoprop\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/autoprop.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/aaaeafdf51148412258d8d2fff61695811faecea/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6175746f70726f702e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/autoprop\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/pyversions/autoprop.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2ff5fdbe0d3b4e139836d98b3b3645aea2a27676/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f6175746f70726f702e737667\"></a>\n<a href=\"https://travis-ci.org/kalekundert/autoprop\" rel=\"nofollow\"><img alt=\"https://img.shields.io/travis/kalekundert/autoprop.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1eb9333629a9c9d5e5ef01ce16c98f7ad66b85b0/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f6b616c656b756e646572742f6175746f70726f702e737667\"></a>\n<a href=\"https://coveralls.io/github/kalekundert/autoprop?branch=master\" rel=\"nofollow\"><img alt=\"https://img.shields.io/coveralls/kalekundert/autoprop.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4232caa00eabaeee75a9f6ca3b4d36175234ef70/68747470733a2f2f696d672e736869656c64732e696f2f636f766572616c6c732f6b616c656b756e646572742f6175746f70726f702e737667\"></a>\n<p>Properties are a feature in python that allow accessor functions (i.e. getters\nand setters) to masquerade as regular attributes.  This makes it possible to\nprovide transparent APIs for classes that need to cache results, lazily load\ndata, maintain invariants, or react in any other way to attribute access.</p>\n<p>Unfortunately, making a property requires an annoying amount of boilerplate\ncode.  There are a few ways to do it, but the most common and most succinct\nrequires you to decorate two functions (with two different decorators) and to\ntype the name of the attribute three times:</p>\n<pre>class RegularProperty:\n\n    @property\n    def attr(self):\n        return self._attr\n\n    @attr.setter\n    def attr(self, new_value):\n        self._attr = new_value\n</pre>\n<p>The <tt>autoprop</tt> module simplifies this process by searching your class for\naccessor methods and adding properties corresponding to any such methods it\nfinds.  For example, the code below defines the same property as the code\nabove:</p>\n<pre>@autoprop\nclass AutoProperty:\n\n    def get_attr(self):\n        return self._attr\n\n    def set_attr(self, new_value):\n        self._attr = new_value\n</pre>\n<div id=\"installation\">\n<h3>Installation</h3>\n<p><tt>autoprop</tt> is available on PyPI, so you can install it using <tt>pip</tt>:</p>\n<pre>pip install autoprop\n</pre>\n</div>\n<div id=\"usage\">\n<h3>Usage</h3>\n<p>To use <tt>autoprop</tt>, import the <tt>autoprop</tt> module and use it directly as a\nclass decorator:</p>\n<pre>import autoprop\n\n@autoprop\nclass Vector2D:\n\n    def __init__(self, x, y):\n        self._x = x\n        self._y = y\n\n    def get_x(self):\n        return self._x\n\n    def set_x(self, x):\n        self._x = x\n\n    def get_y(self):\n        return self._y\n\n    def set_y(self, y):\n        self._y = y\n</pre>\n<p>The decorator searches your class for methods beginning with <tt>get_</tt>,\n<tt>set_</tt>, or <tt>del_</tt> and uses them to create properties.  The names of the\nproperties are taken from whatever comes after the underscore.  For example,\nthe method <tt>get_x</tt> would be used to make a property called <tt>x</tt>.  Any\ncombination of getter, setter, and deleter methods is allowed for each\nproperty.</p>\n<p>If you have properties that are expensive to calculate, you can indicate that\nthey should be cached:</p>\n<pre>@autoprop\nclass Vector2D:\n\n    ...\n\n    @autoprop.cache\n    def get_magnitude(self):\n        return math.sqrt(self._x**2 + self._y**2)\n</pre>\n<p>Cached properties will only be calculated when they are accessed either for the\nfirst time ever, or for the first time after calls to the corresponding setter\nor deleter (if any are defined).</p>\n</div>\n</div>\n<div id=\"details\">\n<h2>Details</h2>\n<p>Besides having the right prefix, there are two other criteria methods must meet\nin order to be made into properties.  The first is that they must take the\nright number of required arguments.  Getters and deleters can\u2019t have any\nrequired arguments (other than self).  Setters must have exactly one required\nargument (other than self), which is the value to set.  Default, variable, and\nkeyword arguments are all ok; only the number of required arguments matters.</p>\n<p>Any methods that have the right name but the wrong arguments are silently\nignored.  This can be nice for getters that require, for example, an index.\nEven though such a getter can\u2019t be made into a property, <tt>autoprop</tt> allows it\nto follow the same naming conventions as any getters that can be:</p>\n<pre>@autoprop\nclass Vector2D:\n\n    ...\n\n    def get_coord(self, i):\n        if i == 0: return self._x\n        if i == 1: return self._y\n\n    def set_coord(self, i, new_coord):\n        if i == 0: self.x = new_coord\n        if i == 1: self.y = new_coord\n</pre>\n<p>In this way, users of your class can always expect to find accessors named\n<tt>get_*</tt> and <tt>set_*</tt>, and properties corresponding to those accessors for\nbasic attributes that don\u2019t need any extra information.</p>\n<p>The second criterion is that the property must have a name which is not already\nin use.  This guarantees that nothing you explicitly add to your class will be\noverwritten, and it gives you the ability to customize how certain properties\nare defined if you\u2019d so like.  Note that this criterion does not apply to\nproperties that <tt>autoprop</tt> itself created.  This really just means that if\nyou overwrite some accessors defined in a superclass, you\u2019ll get new properties\nthat refer to the overridden accessors and not be left with stale references to\nthe superclass accessors.</p>\n</div>\n\n          </div>"}, "last_serial": 6578198, "releases": {"0.0.0": [{"comment_text": "", "digests": {"md5": "47fd7cd486802c68ec02791a2d52b5b2", "sha256": "adf4801988949027404b9da05dc5346dc8d735b7e8f4877f9b2d23004b50138d"}, "downloads": -1, "filename": "autoprop-0.0.0.tar.gz", "has_sig": false, "md5_digest": "47fd7cd486802c68ec02791a2d52b5b2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11517, "upload_time": "2016-12-29T18:56:12", "upload_time_iso_8601": "2016-12-29T18:56:12.457714Z", "url": "https://files.pythonhosted.org/packages/67/a5/9ce9ff16011645f6ab09216ef3c6e64c8203052f34bab867cf95f2f172f3/autoprop-0.0.0.tar.gz", "yanked": false}], "0.0.1": [{"comment_text": "", "digests": {"md5": "7561fab4cb855c17ce9d3d38480fe22b", "sha256": "38536dfafb55ff8172dfeee242cc2a071a2d7916904c38b3cdf9483132b3a9ac"}, "downloads": -1, "filename": "autoprop-0.0.1.tar.gz", "has_sig": false, "md5_digest": "7561fab4cb855c17ce9d3d38480fe22b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11925, "upload_time": "2016-12-29T21:09:18", "upload_time_iso_8601": "2016-12-29T21:09:18.137192Z", "url": "https://files.pythonhosted.org/packages/5c/4e/b32157c5bc1cfe7428f3368b2a70bf50541f01f49a838c5251c21f5e12bb/autoprop-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "2694dcccc21369829005142be1d54cc1", "sha256": "bc6388ee6d00ea6188ca91617a07d967fd48e7c1e677abe7f1fc2b26f2ae223d"}, "downloads": -1, "filename": "autoprop-0.0.2.tar.gz", "has_sig": false, "md5_digest": "2694dcccc21369829005142be1d54cc1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12397, "upload_time": "2017-01-02T16:24:53", "upload_time_iso_8601": "2017-01-02T16:24:53.164203Z", "url": "https://files.pythonhosted.org/packages/3c/7f/5deb942922bd023c2eabb14d112b87c08b9f5d6913ad924f1e930d3f46ef/autoprop-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "8447cc58232ca122d866c8784fac391e", "sha256": "ab3990546a3ddea4ecae63a9378779d679ac291bd0d2be7fcf99f64b9eb60dc1"}, "downloads": -1, "filename": "autoprop-0.0.3.tar.gz", "has_sig": false, "md5_digest": "8447cc58232ca122d866c8784fac391e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10899, "upload_time": "2017-02-05T07:21:55", "upload_time_iso_8601": "2017-02-05T07:21:55.711918Z", "url": "https://files.pythonhosted.org/packages/12/10/c9770bfc1bdfd8a001bd3677b9a80c3603f1b3236dc862e4b7c7ca620945/autoprop-0.0.3.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "9dc8a1864658413f2e64802a716ca7ef", "sha256": "e65d0ccd9d31df9de7b3d422730328f54976860c37e4c13d4cb0fc1d1882adc0"}, "downloads": -1, "filename": "autoprop-1.0.0.tar.gz", "has_sig": false, "md5_digest": "9dc8a1864658413f2e64802a716ca7ef", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14245, "upload_time": "2020-02-04T20:05:33", "upload_time_iso_8601": "2020-02-04T20:05:33.114213Z", "url": "https://files.pythonhosted.org/packages/7c/d2/64f6999c69339b3abaf3d80e75533c93ca8d329528255914044c4e8c97af/autoprop-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "477d31f19359b8e79db459d8a19ab87d", "sha256": "012b74405dc02c7527366d351bb85397b8964446b601c956594e4eae405837da"}, "downloads": -1, "filename": "autoprop-1.0.1.tar.gz", "has_sig": false, "md5_digest": "477d31f19359b8e79db459d8a19ab87d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14685, "upload_time": "2020-02-05T21:02:11", "upload_time_iso_8601": "2020-02-05T21:02:11.513120Z", "url": "https://files.pythonhosted.org/packages/3d/06/0e6db76b2880d4e4a7b78df1e5c16b4d0450cf3f57936583f0f107bdf000/autoprop-1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "477d31f19359b8e79db459d8a19ab87d", "sha256": "012b74405dc02c7527366d351bb85397b8964446b601c956594e4eae405837da"}, "downloads": -1, "filename": "autoprop-1.0.1.tar.gz", "has_sig": false, "md5_digest": "477d31f19359b8e79db459d8a19ab87d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14685, "upload_time": "2020-02-05T21:02:11", "upload_time_iso_8601": "2020-02-05T21:02:11.513120Z", "url": "https://files.pythonhosted.org/packages/3d/06/0e6db76b2880d4e4a7b78df1e5c16b4d0450cf3f57936583f0f107bdf000/autoprop-1.0.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:16:11 2020"}