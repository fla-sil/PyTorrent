{"info": {"author": "Quansight", "author_email": "", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# ndindex\n\nA Python library for manipulating indices of ndarrays.\n\nndindex is a library that allows representing and manipulating objects that\ncan be valid indices to numpy arrays, i.e., slices, integers, ellipses,\nNone, integer and boolean arrays, and tuples thereof. The goals of the library\nare\n\n- Provide a uniform API to manipulate these objects. Unlike the standard index\n  objects themselves like `slice`, `int`, and `tuple`, which do not share any\n  methods in common related to being indices, ndindex classes can all be\n  manipulated uniformly. For example, `idx.args` always gives the arguments\n  used to construct `idx`.\n\n- Give 100% correct semantics as defined by numpy's ndarray. This means that\n  ndindex will not make a transformation on an index object unless it is\n  correct for all possible input array shapes. The only exception to this rule\n  is that ndindex assumes that any given index will not raise IndexError (for\n  instance, from an out of bounds integer index or from too few dimensions).\n  For those operations where the array shape is known, there is a `reduce`\n  method to reduce an index to a simpler index that is equivalent for the\n  given shape.\n\n- Enable useful transformation and manipulation functions on index objects.\n\n## Motivation\n\nIf you've ever worked with Python's `slice` objects, you will quickly discover\ntheir limitations:\n\n- Extracting the arguments of a `slice` is cumbersome. You have to write\n  `start, stop, step = s.start, s.stop, s.step`. With ndindex you can write\n  `start, stop, step = s.args`\n\n- `slice` objects are not hashable. If you want to use them as dictionary\n  keys, you have to use cumbersome translation back and forth to a hashable\n  type such as `tuple`.\n\n- `slice` makes no assumptions about what they are slicing. As a result,\n  invalid slices like `slice(0.5)` or `slice(0, 10, 0)` are allowed. Also\n  slices that would always be equivalent like `slice(None, 10)` and `slice(0,\n  10)` are unequal. To contrast, ndindex objects always assume they are\n  indices to numpy arrays and type check their input. The `reduce` method can\n  be used to put the arguments into canonical form.\n\n- Once you generalizing `slice` objects to more general indices, it is\n  difficult to work with them in a uniform way. For example, `a[i]` and\n  `a[(i,)]` are always equivalent for numpy arrays, but `tuple`, `slice`,\n  `int`, etc. are not related to one another. To contrast, all ndindex types\n  have a uniform API, and all relevant operations on them produce ndindex\n  objects.\n\n- The above limitations can be annoying, but you might consider them worth\n  living with. The real pain comes when you start trying to do slice\n  arithmetic. Slices in Python behave fundamentally differently depending on\n  whether the step is positive or negative and the start and stop are\n  positive, negative, or None. Consider, for example, the meaning of the slice\n  `a[4:-2:-2]`, where `a` is a one-dimensional array. This slices every other\n  element from the third element to the second from the last. The resulting\n  array will have shape `(0,)` if the original shape is less than 1 or greater\n  than 5, and shape `(1,)` otherwise.\n\n  ndindex pre-codes common slice arithmetic into useful abstractions so you\n  don't have to try to figure out all the different cases yourself. And due to\n  extensive testing (see below), you can be assured that ndindex is correct.\n\n## Features\n\nndindex is still a work in progress. The following things are currently\nimplemented:\n\n- `Slice`, `Integer`, and `Tuple`\n\n- Classes do not canonicalize by default (the constructor only does basic type\n  checking). Objects can be put into canonical form by calling `reduce()`.\n\n      >>> from ndindex import Slice\n      >>> Slice(None, 12)\n      Slice(None, 12, None)\n      >>> Slice(None, 12).reduce()\n      Slice(0, 12, 1)\n\n- Object arguments can be accessed with `idx.args`\n\n      >>> Slice(1, 3).args\n      (1, 3, None)\n\n- All ndindex objects are hashable and can be used as dictionary keys.\n\n- A real index object can be accessed with `idx.raw`. Use this to use an\n  ndindex to index an array.\n\n      >>> s = Slice(0, 2)\n      >>> from numpy import arange\n      >>> arange(4)[s.raw]\n      array([0, 1])\n\n- `len()` computes the maximum length of an index over a given axis.\n\n      >>> len(Slice(2, 10, 3))\n      3\n      >>> len(arange(10)[2:10:3])\n      3\n\n- `idx.reduce(shape)` reduces an index to an equivalent index over an array\n  with the given shape.\n\n      >>> Slice(2, -1).reduce((10,))\n      Slice(2, 9, 1)\n      >>> arange(10)[2:-1]\n      array([2, 3, 4, 5, 6, 7, 8])\n      >>> arange(10)[2:9:1]\n      array([2, 3, 4, 5, 6, 7, 8])\n\n\nThe following things are not yet implemented, but are planned.\n\n- `idx.newshape(shape)` returns the shape of `a[idx]`, assuming `a` has shape\n  `shape`.\n\n- `ellipsis`, `Newaxis`, `IntegerArray`, and `BooleanArray` types, so that all\n  types of indexing are support.\n\n- `i1[i2]` will create a new ndindex `i3` (when possible) so that\n  `a[i1][i2] == a[i3]`.\n\n- `split(i0, [i1, i2, ...])` will return a list of indices `[j1, j2, ...]`\n  such that `a[i0] = concat(a[i1][j1], a[i2][j2], ...)`\n\n- `i1 + i2` will produce a single index so that `a[i1 + i2]` gives all the\n  elements of `a[i1]` and `a[i2]`.\n\n- Support [NEP 21 advanced\n  indexing](https://numpy.org/neps/nep-0021-advanced-indexing.html).\n\nAnd more. If there is something you would like to see this library be able to\ndo, please [open an issue](https://github.com/quansight/ndindex/issues). Pull\nrequests are welcome as well.\n\n## Testing and correctness\n\nThe most important priority for a library like this is correctness. Index\nmanipulations, and especially slice manipulations, are complicated to code\ncorrectly, and the code for them typically involves dozens of different\nbranches for different cases.\n\nIn order to assure correctness, all operations are tested extensively against\nnumpy itself to ensure they give the same results. The basic idea is to take\nthe pure Python `index` and the `ndindex(index).raw`, or in the case of a\ntransformation, the before and after raw index, and index a `numpy.arange`\nwith them (the input array itself doesn't matter, so long as its values are\ndistinct). If they do not give the same output array, or do not both produce\nthe same error (like an `IndexError`), the code is not correct. For example,\nthe `reduce` method can be verified by checking that `a[idx.raw]` and\n`a[idx.reduce(a.shape).raw]` produce the same sub-arrays for all possible\ninput arrays `a` and ndindex objects `idx`.\n\nThere are two primary types of tests that we employ to verify this:\n\n- Exhaustive tests. These test every possible value in some range. For\n  example, slice tests test all possible `start`, `stop`, and `step` values in\n  the range [-10, 10], as well as `None`, on `numpy.arange(n)` for `n` in the\n  range [0, 10]. This is the best type of test, because it checks every\n  possible case. Unfortunately, it is often impossible to do full exhaustive\n  testing due to combinatorial explosion.\n\n- Hypothesis tests. Hypothesis is a library that can intelligently check a\n  combinatorial search space of inputs. This requires writing hypothesis\n  strategies that can generate all the relevant types of indices (see\n  ndindex/tests/helpers.py). For more information on hypothesis, see\n  https://hypothesis.readthedocs.io/en/latest/index.html. All tests have\n  hypothesis tests, even if they are also tested exhaustively.\n\nWhy bother with hypothesis if the same thing is already tested exhaustively?\nThe main reason is that hypothesis is much better at producing human-readable\nfailure examples. When an exhaustive test fails, the failure will always be\nfrom the first set of inputs in the loop that produces a failure. Hypothesis\non the other hand attempts to \"shrink\" the failure input to smallest input\nthat still fails. For example, a failing exhaustive slice test might give\n`Slice(-10, -9, -10)` as a the failing example, but hypothesis would shrink it\nto `Slice(-2, -1, -1)`. Another reason for the duplication is that hypothesis\ncan sometimes test a slightly expanded test space without any additional\nconsequences. For example, `test_slice_reduce_hypothesis()` in\nndindex/tests/test_ndindex.py tests all types of array shapes, whereas\n`test_slice_reduce_exhaustive()` tests only 1-dimensional shapes. This doesn't\naffect things because hypotheses will always shrink large shapes to a\n1-dimensional shape in the case of a failure. Consequently every exhaustive\ntest will also have a corresponding hypothesis test.\n\n## License\n\nMIT License\n\n## Table of Contents\n\n* [ndindex Docs Main Page](index.md)\n* [ndindex API](api.md)\n* [Changelog](changelog.md)", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://quansight.github.io/ndindex/", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "ndindex", "package_url": "https://pypi.org/project/ndindex/", "platform": "", "project_url": "https://pypi.org/project/ndindex/", "project_urls": {"Homepage": "https://quansight.github.io/ndindex/"}, "release_url": "https://pypi.org/project/ndindex/1.2/", "requires_dist": null, "requires_python": ">=3.6", "summary": "A Python library for manipulating indices of ndarrays.", "version": "1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>ndindex</h1>\n<p>A Python library for manipulating indices of ndarrays.</p>\n<p>ndindex is a library that allows representing and manipulating objects that\ncan be valid indices to numpy arrays, i.e., slices, integers, ellipses,\nNone, integer and boolean arrays, and tuples thereof. The goals of the library\nare</p>\n<ul>\n<li>\n<p>Provide a uniform API to manipulate these objects. Unlike the standard index\nobjects themselves like <code>slice</code>, <code>int</code>, and <code>tuple</code>, which do not share any\nmethods in common related to being indices, ndindex classes can all be\nmanipulated uniformly. For example, <code>idx.args</code> always gives the arguments\nused to construct <code>idx</code>.</p>\n</li>\n<li>\n<p>Give 100% correct semantics as defined by numpy's ndarray. This means that\nndindex will not make a transformation on an index object unless it is\ncorrect for all possible input array shapes. The only exception to this rule\nis that ndindex assumes that any given index will not raise IndexError (for\ninstance, from an out of bounds integer index or from too few dimensions).\nFor those operations where the array shape is known, there is a <code>reduce</code>\nmethod to reduce an index to a simpler index that is equivalent for the\ngiven shape.</p>\n</li>\n<li>\n<p>Enable useful transformation and manipulation functions on index objects.</p>\n</li>\n</ul>\n<h2>Motivation</h2>\n<p>If you've ever worked with Python's <code>slice</code> objects, you will quickly discover\ntheir limitations:</p>\n<ul>\n<li>\n<p>Extracting the arguments of a <code>slice</code> is cumbersome. You have to write\n<code>start, stop, step = s.start, s.stop, s.step</code>. With ndindex you can write\n<code>start, stop, step = s.args</code></p>\n</li>\n<li>\n<p><code>slice</code> objects are not hashable. If you want to use them as dictionary\nkeys, you have to use cumbersome translation back and forth to a hashable\ntype such as <code>tuple</code>.</p>\n</li>\n<li>\n<p><code>slice</code> makes no assumptions about what they are slicing. As a result,\ninvalid slices like <code>slice(0.5)</code> or <code>slice(0, 10, 0)</code> are allowed. Also\nslices that would always be equivalent like <code>slice(None, 10)</code> and <code>slice(0, 10)</code> are unequal. To contrast, ndindex objects always assume they are\nindices to numpy arrays and type check their input. The <code>reduce</code> method can\nbe used to put the arguments into canonical form.</p>\n</li>\n<li>\n<p>Once you generalizing <code>slice</code> objects to more general indices, it is\ndifficult to work with them in a uniform way. For example, <code>a[i]</code> and\n<code>a[(i,)]</code> are always equivalent for numpy arrays, but <code>tuple</code>, <code>slice</code>,\n<code>int</code>, etc. are not related to one another. To contrast, all ndindex types\nhave a uniform API, and all relevant operations on them produce ndindex\nobjects.</p>\n</li>\n<li>\n<p>The above limitations can be annoying, but you might consider them worth\nliving with. The real pain comes when you start trying to do slice\narithmetic. Slices in Python behave fundamentally differently depending on\nwhether the step is positive or negative and the start and stop are\npositive, negative, or None. Consider, for example, the meaning of the slice\n<code>a[4:-2:-2]</code>, where <code>a</code> is a one-dimensional array. This slices every other\nelement from the third element to the second from the last. The resulting\narray will have shape <code>(0,)</code> if the original shape is less than 1 or greater\nthan 5, and shape <code>(1,)</code> otherwise.</p>\n<p>ndindex pre-codes common slice arithmetic into useful abstractions so you\ndon't have to try to figure out all the different cases yourself. And due to\nextensive testing (see below), you can be assured that ndindex is correct.</p>\n</li>\n</ul>\n<h2>Features</h2>\n<p>ndindex is still a work in progress. The following things are currently\nimplemented:</p>\n<ul>\n<li>\n<p><code>Slice</code>, <code>Integer</code>, and <code>Tuple</code></p>\n</li>\n<li>\n<p>Classes do not canonicalize by default (the constructor only does basic type\nchecking). Objects can be put into canonical form by calling <code>reduce()</code>.</p>\n<pre><code>&gt;&gt;&gt; from ndindex import Slice\n&gt;&gt;&gt; Slice(None, 12)\nSlice(None, 12, None)\n&gt;&gt;&gt; Slice(None, 12).reduce()\nSlice(0, 12, 1)\n</code></pre>\n</li>\n<li>\n<p>Object arguments can be accessed with <code>idx.args</code></p>\n<pre><code>&gt;&gt;&gt; Slice(1, 3).args\n(1, 3, None)\n</code></pre>\n</li>\n<li>\n<p>All ndindex objects are hashable and can be used as dictionary keys.</p>\n</li>\n<li>\n<p>A real index object can be accessed with <code>idx.raw</code>. Use this to use an\nndindex to index an array.</p>\n<pre><code>&gt;&gt;&gt; s = Slice(0, 2)\n&gt;&gt;&gt; from numpy import arange\n&gt;&gt;&gt; arange(4)[s.raw]\narray([0, 1])\n</code></pre>\n</li>\n<li>\n<p><code>len()</code> computes the maximum length of an index over a given axis.</p>\n<pre><code>&gt;&gt;&gt; len(Slice(2, 10, 3))\n3\n&gt;&gt;&gt; len(arange(10)[2:10:3])\n3\n</code></pre>\n</li>\n<li>\n<p><code>idx.reduce(shape)</code> reduces an index to an equivalent index over an array\nwith the given shape.</p>\n<pre><code>&gt;&gt;&gt; Slice(2, -1).reduce((10,))\nSlice(2, 9, 1)\n&gt;&gt;&gt; arange(10)[2:-1]\narray([2, 3, 4, 5, 6, 7, 8])\n&gt;&gt;&gt; arange(10)[2:9:1]\narray([2, 3, 4, 5, 6, 7, 8])\n</code></pre>\n</li>\n</ul>\n<p>The following things are not yet implemented, but are planned.</p>\n<ul>\n<li>\n<p><code>idx.newshape(shape)</code> returns the shape of <code>a[idx]</code>, assuming <code>a</code> has shape\n<code>shape</code>.</p>\n</li>\n<li>\n<p><code>ellipsis</code>, <code>Newaxis</code>, <code>IntegerArray</code>, and <code>BooleanArray</code> types, so that all\ntypes of indexing are support.</p>\n</li>\n<li>\n<p><code>i1[i2]</code> will create a new ndindex <code>i3</code> (when possible) so that\n<code>a[i1][i2] == a[i3]</code>.</p>\n</li>\n<li>\n<p><code>split(i0, [i1, i2, ...])</code> will return a list of indices <code>[j1, j2, ...]</code>\nsuch that <code>a[i0] = concat(a[i1][j1], a[i2][j2], ...)</code></p>\n</li>\n<li>\n<p><code>i1 + i2</code> will produce a single index so that <code>a[i1 + i2]</code> gives all the\nelements of <code>a[i1]</code> and <code>a[i2]</code>.</p>\n</li>\n<li>\n<p>Support <a href=\"https://numpy.org/neps/nep-0021-advanced-indexing.html\" rel=\"nofollow\">NEP 21 advanced\nindexing</a>.</p>\n</li>\n</ul>\n<p>And more. If there is something you would like to see this library be able to\ndo, please <a href=\"https://github.com/quansight/ndindex/issues\" rel=\"nofollow\">open an issue</a>. Pull\nrequests are welcome as well.</p>\n<h2>Testing and correctness</h2>\n<p>The most important priority for a library like this is correctness. Index\nmanipulations, and especially slice manipulations, are complicated to code\ncorrectly, and the code for them typically involves dozens of different\nbranches for different cases.</p>\n<p>In order to assure correctness, all operations are tested extensively against\nnumpy itself to ensure they give the same results. The basic idea is to take\nthe pure Python <code>index</code> and the <code>ndindex(index).raw</code>, or in the case of a\ntransformation, the before and after raw index, and index a <code>numpy.arange</code>\nwith them (the input array itself doesn't matter, so long as its values are\ndistinct). If they do not give the same output array, or do not both produce\nthe same error (like an <code>IndexError</code>), the code is not correct. For example,\nthe <code>reduce</code> method can be verified by checking that <code>a[idx.raw]</code> and\n<code>a[idx.reduce(a.shape).raw]</code> produce the same sub-arrays for all possible\ninput arrays <code>a</code> and ndindex objects <code>idx</code>.</p>\n<p>There are two primary types of tests that we employ to verify this:</p>\n<ul>\n<li>\n<p>Exhaustive tests. These test every possible value in some range. For\nexample, slice tests test all possible <code>start</code>, <code>stop</code>, and <code>step</code> values in\nthe range [-10, 10], as well as <code>None</code>, on <code>numpy.arange(n)</code> for <code>n</code> in the\nrange [0, 10]. This is the best type of test, because it checks every\npossible case. Unfortunately, it is often impossible to do full exhaustive\ntesting due to combinatorial explosion.</p>\n</li>\n<li>\n<p>Hypothesis tests. Hypothesis is a library that can intelligently check a\ncombinatorial search space of inputs. This requires writing hypothesis\nstrategies that can generate all the relevant types of indices (see\nndindex/tests/helpers.py). For more information on hypothesis, see\n<a href=\"https://hypothesis.readthedocs.io/en/latest/index.html\" rel=\"nofollow\">https://hypothesis.readthedocs.io/en/latest/index.html</a>. All tests have\nhypothesis tests, even if they are also tested exhaustively.</p>\n</li>\n</ul>\n<p>Why bother with hypothesis if the same thing is already tested exhaustively?\nThe main reason is that hypothesis is much better at producing human-readable\nfailure examples. When an exhaustive test fails, the failure will always be\nfrom the first set of inputs in the loop that produces a failure. Hypothesis\non the other hand attempts to \"shrink\" the failure input to smallest input\nthat still fails. For example, a failing exhaustive slice test might give\n<code>Slice(-10, -9, -10)</code> as a the failing example, but hypothesis would shrink it\nto <code>Slice(-2, -1, -1)</code>. Another reason for the duplication is that hypothesis\ncan sometimes test a slightly expanded test space without any additional\nconsequences. For example, <code>test_slice_reduce_hypothesis()</code> in\nndindex/tests/test_ndindex.py tests all types of array shapes, whereas\n<code>test_slice_reduce_exhaustive()</code> tests only 1-dimensional shapes. This doesn't\naffect things because hypotheses will always shrink large shapes to a\n1-dimensional shape in the case of a failure. Consequently every exhaustive\ntest will also have a corresponding hypothesis test.</p>\n<h2>License</h2>\n<p>MIT License</p>\n<h2>Table of Contents</h2>\n<ul>\n<li><a href=\"index.md\" rel=\"nofollow\">ndindex Docs Main Page</a></li>\n<li><a href=\"api.md\" rel=\"nofollow\">ndindex API</a></li>\n<li><a href=\"changelog.md\" rel=\"nofollow\">Changelog</a></li>\n</ul>\n\n          </div>"}, "last_serial": 7148449, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "91c10a2def91d06e2c783c0c798f86c2", "sha256": "c309efa54b1a21f18bfd1c9e28aa81456b2c2d6cdf4d7496de4f45f46ff2244f"}, "downloads": -1, "filename": "ndindex-1.0.tar.gz", "has_sig": true, "md5_digest": "91c10a2def91d06e2c783c0c798f86c2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 31585, "upload_time": "2020-04-09T19:02:55", "upload_time_iso_8601": "2020-04-09T19:02:55.531090Z", "url": "https://files.pythonhosted.org/packages/59/bf/fff5e30990e51b15788c06438f691066f0fb40b0b6e2efd5b61efce75f75/ndindex-1.0.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "bf1d9e13564f0c98bb34424ce8931bc5", "sha256": "74d9859193ee3308e170bd0ee2f94e10b2377d526a98e826a801b1498000efe0"}, "downloads": -1, "filename": "ndindex-1.1.tar.gz", "has_sig": true, "md5_digest": "bf1d9e13564f0c98bb34424ce8931bc5", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 33294, "upload_time": "2020-04-23T21:24:30", "upload_time_iso_8601": "2020-04-23T21:24:30.130825Z", "url": "https://files.pythonhosted.org/packages/6c/42/27b40279a1488942cf93e8a8035901c4fb48556e56a65e5ae1b250d17b24/ndindex-1.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "2f35419260c1a860a49f6578e70ac9e9", "sha256": "89d8d3d8ae13c06ee62efc94b63a0fc24f56b2f21221c0d019b4d852ae862245"}, "downloads": -1, "filename": "ndindex-1.2.tar.gz", "has_sig": true, "md5_digest": "2f35419260c1a860a49f6578e70ac9e9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 36703, "upload_time": "2020-05-01T21:47:35", "upload_time_iso_8601": "2020-05-01T21:47:35.743542Z", "url": "https://files.pythonhosted.org/packages/70/5c/d8fc642064c221cbb9a17a98e551dbf7df073def55e467b141f4f9b7c3ac/ndindex-1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2f35419260c1a860a49f6578e70ac9e9", "sha256": "89d8d3d8ae13c06ee62efc94b63a0fc24f56b2f21221c0d019b4d852ae862245"}, "downloads": -1, "filename": "ndindex-1.2.tar.gz", "has_sig": true, "md5_digest": "2f35419260c1a860a49f6578e70ac9e9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 36703, "upload_time": "2020-05-01T21:47:35", "upload_time_iso_8601": "2020-05-01T21:47:35.743542Z", "url": "https://files.pythonhosted.org/packages/70/5c/d8fc642064c221cbb9a17a98e551dbf7df073def55e467b141f4f9b7c3ac/ndindex-1.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:46:41 2020"}