{"info": {"author": "Luiza Labs", "author_email": "pypi@luizalabs.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# Lasier\nA sync/async circuit breaker implementation\n\n[![Build Status](https://travis-ci.org/luizalabs/lasier.svg?branch=master)](https://travis-ci.org/luizalabs/lasier)\n\nAccording to Nygard on your masterpiece book [Release It!](http://pragprog.com/titles/mnee/release-it):\n\n> [...] circuit breakers protect overeager gadget hounds from burning their houses down. The principle is the same: detect excess usage, fail first, and open the circuit. More abstractly, the circuit breaker exists to allow one subsystem (an electrical circuit) to fail (excessive current draw, possibly from a short circuit) without destroying the entire system (the house). Furthermore, once the danger has passed, the circuit breaker can be reset to restore full function to the system.\n\n## Requirements\n* Python >= 3.7\n\n## Instalation\nUsing `pip`:\n\n```\npip install lasier\n```\n\n## Usage\nTo use lasier circuit breaker you'll need a `rule` and a `cache` (the circuit state storage) instance\n\n### Rule\nA `Rule` is the mechanism that define where circuit will open or close.\n\n#### MaxFailuresRule\nRule to open circuit based on maximum number of failures\n\n```python\nfrom lasier.circuit_breaker.rules import MaxFailuresRule\n\nrule = MaxFailuresRule(\n    max_failures=500,\n    failure_cache_key='my_cb'\n)\n```\n\n##### Arguments\n| Argument | Definition |\n|----------|------------|\n| max\\_failures | Maximum number of errors |\n| failure\\_cache\\_key | Cache key where the number of errors is incremented |\n\n#### PercentageFailuresRule\nRule to open circuit based on a percentage of failures\n\n```python\nfrom lasier.circuit_breaker.rules import PercentageFailuresRule\n\nrule = PercentageFailuresRule(\n    max_failures_percentage=60,\n    failure_cache_key='my_cb',\n    min_accepted_requests=100,\n    request_cache_key='my_cb_request'\n)\n```\n\n##### Arguments\n| Argument | Definition |\n|----------|------------|\n| max\\_failures\\_percentage | Maximum percentage of errors |\n| failure\\_cache\\_key | Cache key where the number of errors is incremented |\n| min\\_accepted\\_requests | Minimum number of requests accepted to not open circuit breaker |\n| request\\_cache\\_key | Cache key where the number of requests is incremented |\n\n### Circuit Breaker\nYou can use the Lasier circuit breaker with a *context\\_manager* f.ex:\n\n```python\nfrom lasier.circuit_breaker.sync import CircuitBreaker\n\n...\n\ndef some_protected_func():\n    with CircuitBreaker(\n        rule=rule,\n        cache=cache,\n        failure_exception=ValueError,\n        catch_exceptions=(KeyError, TypeError)\n    ):\n        # some process\n```\nOr a _decorator_, f.ex:\n\n```python\nfrom lasier.circuit_breaker.asyncio import circuit_breaker\n\n...\n\n@circuit_breaker(\n    rule=rule,\n    cache=cache,\n    failure_exception=ValueError,\n    catch_exceptions=(KeyError, TypeError)\n)\nasync def some_protected_func():\n    # some process\n```\n\nThe **sync** and **async** implementations follow the same interface, so you only need to change the import path:\n\n* `lasier.circuit_breaker.sync`: for sync implementataion\n* `lasier.circuit_breaker.asyncio`: for async implementataion\n\n##### Arguments\n| Argument | Definition |\n|----------|------------|\n| rule | Instance of class [rule](https://github.com/luizalabs/lasier#rule). |\n| cache | Instance of the circuit breaker [state storage](https://github.com/luizalabs/lasier#circuit-state-storage). |\n| failure\\_exception | Exception to be raised when it exceeds the maximum number of errors and when the circuit is open. |\n| failure\\_timeout | This value is set on first error. It is used to validate the number of errors by time. |\n| circuit\\_timeout | Time that the circuit will be open. |\n| catch\\_exceptions | List of exceptions catched to increase the number of errors. |\n\n## Circuit state storage\nLasier works with a storage to register the current state of the circuit, number of failures, etc. That storage respects the follow interface:\n\n```python\nclass Storage:\n\n    def add(self, key: str, value: int, timeout: Optional[int] = None) -> None:\n        pass\n\n    def set(self, key: str, value: int, timeout: Optional[int] = None) -> None:\n        pass\n\n    def incr(self, key: str) -> int:\n        pass\n\n    def get(self, key: str) -> int:\n        pass\n\n    def delete(self, key: str) -> None:\n        pass\n\n    def flushdb(self) -> None:\n        pass\n```\n\n> For `async` circuit breaker, lasier works with that same interface however with async syntax, f.ex: `async def set(self, key=str, value=int, timeout=Optional[int])`\n\nSo you can use any cache/storage that respects that interface, f.ex the [django caches object](https://docs.djangoproject.com/en/3.0/topics/cache/)\n\n### Adapters\nIf you'll use Lasier with [redis-py](https://github.com/andymccurdy/redis-py) as cache, you can use `lasier.adapters.caches.redis.RedisAdapter`\n\n```python\nfrom lasier.adapters.cache import RedisAdapter\nfrom redis import Redis\n\ncache = RedisAdapter(Redis(host='localhost', port=6479, db=0))\n```\n\n#### Implemented Adapters\n| Lib | Adapter |\n| --- | --- |\n| redis-py | `lasier.adapters.caches.RedisAdapter`|\n| aiocache | `lasier.adapters.caches.AiocacheAdapter`|\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/luizalabs/lasier/tarball/master", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/luizalabs/lasier", "keywords": "circuit breaker sync async", "license": "", "maintainer": "", "maintainer_email": "", "name": "lasier", "package_url": "https://pypi.org/project/lasier/", "platform": "", "project_url": "https://pypi.org/project/lasier/", "project_urls": {"Download": "https://github.com/luizalabs/lasier/tarball/master", "Homepage": "https://github.com/luizalabs/lasier"}, "release_url": "https://pypi.org/project/lasier/0.0.2/", "requires_dist": null, "requires_python": "", "summary": "A sync/async circuit breaker implementation", "version": "0.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Lasier</h1>\n<p>A sync/async circuit breaker implementation</p>\n<p><a href=\"https://travis-ci.org/luizalabs/lasier\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e82183edb9244ce49857b556b30715b7e66f86da/68747470733a2f2f7472617669732d63692e6f72672f6c75697a616c6162732f6c61736965722e7376673f6272616e63683d6d6173746572\"></a></p>\n<p>According to Nygard on your masterpiece book <a href=\"http://pragprog.com/titles/mnee/release-it\" rel=\"nofollow\">Release It!</a>:</p>\n<blockquote>\n<p>[...] circuit breakers protect overeager gadget hounds from burning their houses down. The principle is the same: detect excess usage, fail first, and open the circuit. More abstractly, the circuit breaker exists to allow one subsystem (an electrical circuit) to fail (excessive current draw, possibly from a short circuit) without destroying the entire system (the house). Furthermore, once the danger has passed, the circuit breaker can be reset to restore full function to the system.</p>\n</blockquote>\n<h2>Requirements</h2>\n<ul>\n<li>Python &gt;= 3.7</li>\n</ul>\n<h2>Instalation</h2>\n<p>Using <code>pip</code>:</p>\n<pre><code>pip install lasier\n</code></pre>\n<h2>Usage</h2>\n<p>To use lasier circuit breaker you'll need a <code>rule</code> and a <code>cache</code> (the circuit state storage) instance</p>\n<h3>Rule</h3>\n<p>A <code>Rule</code> is the mechanism that define where circuit will open or close.</p>\n<h4>MaxFailuresRule</h4>\n<p>Rule to open circuit based on maximum number of failures</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">lasier.circuit_breaker.rules</span> <span class=\"kn\">import</span> <span class=\"n\">MaxFailuresRule</span>\n\n<span class=\"n\">rule</span> <span class=\"o\">=</span> <span class=\"n\">MaxFailuresRule</span><span class=\"p\">(</span>\n    <span class=\"n\">max_failures</span><span class=\"o\">=</span><span class=\"mi\">500</span><span class=\"p\">,</span>\n    <span class=\"n\">failure_cache_key</span><span class=\"o\">=</span><span class=\"s1\">'my_cb'</span>\n<span class=\"p\">)</span>\n</pre>\n<h5>Arguments</h5>\n<table>\n<thead>\n<tr>\n<th>Argument</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>max_failures</td>\n<td>Maximum number of errors</td>\n</tr>\n<tr>\n<td>failure_cache_key</td>\n<td>Cache key where the number of errors is incremented</td>\n</tr></tbody></table>\n<h4>PercentageFailuresRule</h4>\n<p>Rule to open circuit based on a percentage of failures</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">lasier.circuit_breaker.rules</span> <span class=\"kn\">import</span> <span class=\"n\">PercentageFailuresRule</span>\n\n<span class=\"n\">rule</span> <span class=\"o\">=</span> <span class=\"n\">PercentageFailuresRule</span><span class=\"p\">(</span>\n    <span class=\"n\">max_failures_percentage</span><span class=\"o\">=</span><span class=\"mi\">60</span><span class=\"p\">,</span>\n    <span class=\"n\">failure_cache_key</span><span class=\"o\">=</span><span class=\"s1\">'my_cb'</span><span class=\"p\">,</span>\n    <span class=\"n\">min_accepted_requests</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span>\n    <span class=\"n\">request_cache_key</span><span class=\"o\">=</span><span class=\"s1\">'my_cb_request'</span>\n<span class=\"p\">)</span>\n</pre>\n<h5>Arguments</h5>\n<table>\n<thead>\n<tr>\n<th>Argument</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>max_failures_percentage</td>\n<td>Maximum percentage of errors</td>\n</tr>\n<tr>\n<td>failure_cache_key</td>\n<td>Cache key where the number of errors is incremented</td>\n</tr>\n<tr>\n<td>min_accepted_requests</td>\n<td>Minimum number of requests accepted to not open circuit breaker</td>\n</tr>\n<tr>\n<td>request_cache_key</td>\n<td>Cache key where the number of requests is incremented</td>\n</tr></tbody></table>\n<h3>Circuit Breaker</h3>\n<p>You can use the Lasier circuit breaker with a <em>context_manager</em> f.ex:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">lasier.circuit_breaker.sync</span> <span class=\"kn\">import</span> <span class=\"n\">CircuitBreaker</span>\n\n<span class=\"o\">...</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">some_protected_func</span><span class=\"p\">():</span>\n    <span class=\"k\">with</span> <span class=\"n\">CircuitBreaker</span><span class=\"p\">(</span>\n        <span class=\"n\">rule</span><span class=\"o\">=</span><span class=\"n\">rule</span><span class=\"p\">,</span>\n        <span class=\"n\">cache</span><span class=\"o\">=</span><span class=\"n\">cache</span><span class=\"p\">,</span>\n        <span class=\"n\">failure_exception</span><span class=\"o\">=</span><span class=\"ne\">ValueError</span><span class=\"p\">,</span>\n        <span class=\"n\">catch_exceptions</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"ne\">KeyError</span><span class=\"p\">,</span> <span class=\"ne\">TypeError</span><span class=\"p\">)</span>\n    <span class=\"p\">):</span>\n        <span class=\"c1\"># some process</span>\n</pre>\n<p>Or a <em>decorator</em>, f.ex:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">lasier.circuit_breaker.asyncio</span> <span class=\"kn\">import</span> <span class=\"n\">circuit_breaker</span>\n\n<span class=\"o\">...</span>\n\n<span class=\"nd\">@circuit_breaker</span><span class=\"p\">(</span>\n    <span class=\"n\">rule</span><span class=\"o\">=</span><span class=\"n\">rule</span><span class=\"p\">,</span>\n    <span class=\"n\">cache</span><span class=\"o\">=</span><span class=\"n\">cache</span><span class=\"p\">,</span>\n    <span class=\"n\">failure_exception</span><span class=\"o\">=</span><span class=\"ne\">ValueError</span><span class=\"p\">,</span>\n    <span class=\"n\">catch_exceptions</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"ne\">KeyError</span><span class=\"p\">,</span> <span class=\"ne\">TypeError</span><span class=\"p\">)</span>\n<span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">some_protected_func</span><span class=\"p\">():</span>\n    <span class=\"c1\"># some process</span>\n</pre>\n<p>The <strong>sync</strong> and <strong>async</strong> implementations follow the same interface, so you only need to change the import path:</p>\n<ul>\n<li><code>lasier.circuit_breaker.sync</code>: for sync implementataion</li>\n<li><code>lasier.circuit_breaker.asyncio</code>: for async implementataion</li>\n</ul>\n<h5>Arguments</h5>\n<table>\n<thead>\n<tr>\n<th>Argument</th>\n<th>Definition</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>rule</td>\n<td>Instance of class <a href=\"https://github.com/luizalabs/lasier#rule\" rel=\"nofollow\">rule</a>.</td>\n</tr>\n<tr>\n<td>cache</td>\n<td>Instance of the circuit breaker <a href=\"https://github.com/luizalabs/lasier#circuit-state-storage\" rel=\"nofollow\">state storage</a>.</td>\n</tr>\n<tr>\n<td>failure_exception</td>\n<td>Exception to be raised when it exceeds the maximum number of errors and when the circuit is open.</td>\n</tr>\n<tr>\n<td>failure_timeout</td>\n<td>This value is set on first error. It is used to validate the number of errors by time.</td>\n</tr>\n<tr>\n<td>circuit_timeout</td>\n<td>Time that the circuit will be open.</td>\n</tr>\n<tr>\n<td>catch_exceptions</td>\n<td>List of exceptions catched to increase the number of errors.</td>\n</tr></tbody></table>\n<h2>Circuit state storage</h2>\n<p>Lasier works with a storage to register the current state of the circuit, number of failures, etc. That storage respects the follow interface:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Storage</span><span class=\"p\">:</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">set</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">incr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">get</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">delete</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">flushdb</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">pass</span>\n</pre>\n<blockquote>\n<p>For <code>async</code> circuit breaker, lasier works with that same interface however with async syntax, f.ex: <code>async def set(self, key=str, value=int, timeout=Optional[int])</code></p>\n</blockquote>\n<p>So you can use any cache/storage that respects that interface, f.ex the <a href=\"https://docs.djangoproject.com/en/3.0/topics/cache/\" rel=\"nofollow\">django caches object</a></p>\n<h3>Adapters</h3>\n<p>If you'll use Lasier with <a href=\"https://github.com/andymccurdy/redis-py\" rel=\"nofollow\">redis-py</a> as cache, you can use <code>lasier.adapters.caches.redis.RedisAdapter</code></p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">lasier.adapters.cache</span> <span class=\"kn\">import</span> <span class=\"n\">RedisAdapter</span>\n<span class=\"kn\">from</span> <span class=\"nn\">redis</span> <span class=\"kn\">import</span> <span class=\"n\">Redis</span>\n\n<span class=\"n\">cache</span> <span class=\"o\">=</span> <span class=\"n\">RedisAdapter</span><span class=\"p\">(</span><span class=\"n\">Redis</span><span class=\"p\">(</span><span class=\"n\">host</span><span class=\"o\">=</span><span class=\"s1\">'localhost'</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">6479</span><span class=\"p\">,</span> <span class=\"n\">db</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">))</span>\n</pre>\n<h4>Implemented Adapters</h4>\n<table>\n<thead>\n<tr>\n<th>Lib</th>\n<th>Adapter</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>redis-py</td>\n<td><code>lasier.adapters.caches.RedisAdapter</code></td>\n</tr>\n<tr>\n<td>aiocache</td>\n<td><code>lasier.adapters.caches.AiocacheAdapter</code></td>\n</tr></tbody></table>\n\n          </div>"}, "last_serial": 7120997, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "9228a1421513c788985fab308f917a45", "sha256": "6c74b79d8f6389014add4c5a44e1aa0e8c57a6543c9b8fb5515923e98fbe64bd"}, "downloads": -1, "filename": "lasier-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "9228a1421513c788985fab308f917a45", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 9220, "upload_time": "2020-04-08T14:54:27", "upload_time_iso_8601": "2020-04-08T14:54:27.869244Z", "url": "https://files.pythonhosted.org/packages/50/db/6c816680e8af0eb0551749fc3e19e3291f0cdb74af6aff5ee9ce475163e2/lasier-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c67adbd1a6bd99a60b36e5de4f36690c", "sha256": "16e72a04d8d1e32725406a7d6b697874383c2d34a3dd7827ee3ad4fd36040e85"}, "downloads": -1, "filename": "lasier-0.0.1.tar.gz", "has_sig": false, "md5_digest": "c67adbd1a6bd99a60b36e5de4f36690c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7651, "upload_time": "2020-04-08T14:54:30", "upload_time_iso_8601": "2020-04-08T14:54:30.281176Z", "url": "https://files.pythonhosted.org/packages/f0/ec/8356703c53bde8ac02f628fc0af6d98e30aa433f050eb56081d13b679f3f/lasier-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "a7a56b978e3425f4995dd615ba0a41fc", "sha256": "33929eedb7b138762b76cbe310e15d339ffa5f21501cc5d5a1f14a8fb01cc454"}, "downloads": -1, "filename": "lasier-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "a7a56b978e3425f4995dd615ba0a41fc", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10449, "upload_time": "2020-04-28T15:05:12", "upload_time_iso_8601": "2020-04-28T15:05:12.420002Z", "url": "https://files.pythonhosted.org/packages/59/50/523662402b66ea608ab55d178de189e043a35ce37229ca0908d525152c56/lasier-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "746d76eee7564211d89b9adfa83675e3", "sha256": "5ab0632b01ce036e73d54953404ff3eaffe998cd7b8fc8225188a819cde0b8b2"}, "downloads": -1, "filename": "lasier-0.0.2.tar.gz", "has_sig": false, "md5_digest": "746d76eee7564211d89b9adfa83675e3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7824, "upload_time": "2020-04-28T15:05:14", "upload_time_iso_8601": "2020-04-28T15:05:14.757682Z", "url": "https://files.pythonhosted.org/packages/cd/e5/801cf07cba9bf549213dbacc914352df1e3635a9c835cedc1cc1db3f5b86/lasier-0.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a7a56b978e3425f4995dd615ba0a41fc", "sha256": "33929eedb7b138762b76cbe310e15d339ffa5f21501cc5d5a1f14a8fb01cc454"}, "downloads": -1, "filename": "lasier-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "a7a56b978e3425f4995dd615ba0a41fc", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10449, "upload_time": "2020-04-28T15:05:12", "upload_time_iso_8601": "2020-04-28T15:05:12.420002Z", "url": "https://files.pythonhosted.org/packages/59/50/523662402b66ea608ab55d178de189e043a35ce37229ca0908d525152c56/lasier-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "746d76eee7564211d89b9adfa83675e3", "sha256": "5ab0632b01ce036e73d54953404ff3eaffe998cd7b8fc8225188a819cde0b8b2"}, "downloads": -1, "filename": "lasier-0.0.2.tar.gz", "has_sig": false, "md5_digest": "746d76eee7564211d89b9adfa83675e3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7824, "upload_time": "2020-04-28T15:05:14", "upload_time_iso_8601": "2020-04-28T15:05:14.757682Z", "url": "https://files.pythonhosted.org/packages/cd/e5/801cf07cba9bf549213dbacc914352df1e3635a9c835cedc1cc1db3f5b86/lasier-0.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:47:49 2020"}