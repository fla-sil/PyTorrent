{"info": {"author": "Swall0w", "author_email": "", "bugtrack_url": null, "classifiers": ["Intended Audience :: Science/Research", "License :: OSI Approved :: Apache Software License", "Operating System :: OS Independent", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering :: Artificial Intelligence"], "description": "## TACS\n\n**__str__** method is not supported yet.\n### Introduction\n\nTACS was created as a lightweight library to define and manage\nsystem configurations, such as those commonly found in software\ndesigned for scientific experimentation. These \"configurations\"\ntypically cover concepts like hyperparameters used in training a\nmachine learning model or configurable model hyperparameters, such\nas the depth of a convolutional neural network. Since you're doing\nscience, **reproducibility is paramount** and thus you need a reliable\nway to serialize experimental configurations. TACS\nuses TOML as a simple, human readable serialization format.\nThe paradigm is: `your code + a TACS config for experiment E (+\nexternal dependencies + hardware + other nuisance terms ...) =\nreproducible experiment E`. While you might not be able to control\neverything, at least you can control your code and your experimental\nconfiguration. YACS is here to help you with that.\n\nTACS grew out of the experimental configuration systems used in:\n[py-faster-rcnn](https://github.com/rbgirshick/py-faster-rcnn) and\n[Detectron](https://github.com/facebookresearch/Detectron).\n\n### Usage\n\nTACS can be used in a variety of flexible ways. There are two main\nparadigms:\n\n- Configuration as *local variable*\n- Configuration as a *global singleton*\n\nIt's up to you which you prefer to use, though the local variable\nroute is recommended.\n\nTo use TACS in your project, you first create a project config\nfile, typically called `config.py` or `defaults.py`. *This file\nis the one-stop reference point for all configurable options.\nIt should be very well documented and provide sensible defaults\nfor all options.*\n\n```python\n# my_project/config.py\nfrom tacs.config import CfgNode as CN\n\n\n_C = CN()\n\n_C.SYSTEM = CN()\n# Number of GPUS to use in the experiment\n_C.SYSTEM.NUM_GPUS = 8\n# Number of workers for doing things\n_C.SYSTEM.NUM_WORKERS = 4\n\n_C.TRAIN = CN()\n# A very important hyperparameter\n_C.TRAIN.HYPERPARAMETER_1 = 0.1\n# The all important scales for the stuff\n_C.TRAIN.SCALES = (2, 4, 8, 16)\n\n\ndef get_cfg_defaults():\n  \"\"\"Get a yacs CfgNode object with default values for my_project.\"\"\"\n  # Return a clone so that the defaults will not be altered\n  # This is for the \"local variable\" use pattern\n  return _C.clone()\n\n# Alternatively, provide a way to import the defaults as\n# a global singleton:\n# cfg = _C  # users can `from config import cfg`\n```\n\nNext, you'll create TOML configuration files; typically you'll make\none for each experiment. Each configuration file only overrides the\noptions that are changing in that experiment.\n\n```toml\n# my_project/experiment.toml\n[SYSTEM]\n  NUM_GPUS = 2\n[TRAIN]\n  SCALES = [1, 2]\n```\n\nFinally, you'll have your actual project code that uses the config\nsystem. After any initial setup it's a good idea to freeze it to\nprevent further modification by calling the `freeze()` method. As\nillustrated below, the config options can either be used a global\nset of options by importing `cfg` and accessing it directly, or\nthe `cfg` can be copied and passed as an argument.\n\n```python\n# my_project/main.py\n\nimport my_project\nfrom config import get_cfg_defaults  # local variable usage pattern, or:\n# from config import cfg  # global singleton usage pattern\n\n\nif __name__ == \"__main__\":\n  cfg = get_cfg_defaults()\n  cfg.merge_from_file(\"experiment.toml\")\n  cfg.freeze()\n  print(cfg)\n\n  # Example of using the cfg as global access to options\n  if cfg.SYSTEM.NUM_GPUS > 0:\n    my_project.setup_multi_gpu_support()\n\n  model = my_project.create_model(cfg)\n```\n\n#### Command line overrides\n\nYou can update a `CfgNode` using a list of fully-qualified key, value pairs.\nThis makes it easy to consume override options from the command line. For example:\n\n```python\ncfg.merge_from_file(\"experiment.toml\")\n# Now override from a list (opts could come from the command line)\nopts = [\"SYSTEM.NUM_GPUS\", 8, \"TRAIN.SCALES\", \"[1, 2, 3, 4]\"]\ncfg.merge_from_list(opts)\n```\n\nThe following principle is recommended: \"There is only one way to\nconfigure the same thing.\" This principle means that if an option\nis defined in a TACS config object, then your program should set\nthat configuration option using `cfg.merge_from_list(opts)` and\nnot by defining, for example, `--train-scales` as a command line\nargument that is then used to set `cfg.TRAIN.SCALES`.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Swall0w/tacs", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "tacs", "package_url": "https://pypi.org/project/tacs/", "platform": "", "project_url": "https://pypi.org/project/tacs/", "project_urls": {"Homepage": "https://github.com/Swall0w/tacs"}, "release_url": "https://pypi.org/project/tacs/0.0.1/", "requires_dist": ["toml"], "requires_python": "", "summary": "TOML yet Another Configuration System", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h2>TACS</h2>\n<p><strong><strong>str</strong></strong> method is not supported yet.</p>\n<h3>Introduction</h3>\n<p>TACS was created as a lightweight library to define and manage\nsystem configurations, such as those commonly found in software\ndesigned for scientific experimentation. These \"configurations\"\ntypically cover concepts like hyperparameters used in training a\nmachine learning model or configurable model hyperparameters, such\nas the depth of a convolutional neural network. Since you're doing\nscience, <strong>reproducibility is paramount</strong> and thus you need a reliable\nway to serialize experimental configurations. TACS\nuses TOML as a simple, human readable serialization format.\nThe paradigm is: <code>your code + a TACS config for experiment E (+ external dependencies + hardware + other nuisance terms ...) = reproducible experiment E</code>. While you might not be able to control\neverything, at least you can control your code and your experimental\nconfiguration. YACS is here to help you with that.</p>\n<p>TACS grew out of the experimental configuration systems used in:\n<a href=\"https://github.com/rbgirshick/py-faster-rcnn\" rel=\"nofollow\">py-faster-rcnn</a> and\n<a href=\"https://github.com/facebookresearch/Detectron\" rel=\"nofollow\">Detectron</a>.</p>\n<h3>Usage</h3>\n<p>TACS can be used in a variety of flexible ways. There are two main\nparadigms:</p>\n<ul>\n<li>Configuration as <em>local variable</em></li>\n<li>Configuration as a <em>global singleton</em></li>\n</ul>\n<p>It's up to you which you prefer to use, though the local variable\nroute is recommended.</p>\n<p>To use TACS in your project, you first create a project config\nfile, typically called <code>config.py</code> or <code>defaults.py</code>. <em>This file\nis the one-stop reference point for all configurable options.\nIt should be very well documented and provide sensible defaults\nfor all options.</em></p>\n<pre><span class=\"c1\"># my_project/config.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">tacs.config</span> <span class=\"kn\">import</span> <span class=\"n\">CfgNode</span> <span class=\"k\">as</span> <span class=\"n\">CN</span>\n\n\n<span class=\"n\">_C</span> <span class=\"o\">=</span> <span class=\"n\">CN</span><span class=\"p\">()</span>\n\n<span class=\"n\">_C</span><span class=\"o\">.</span><span class=\"n\">SYSTEM</span> <span class=\"o\">=</span> <span class=\"n\">CN</span><span class=\"p\">()</span>\n<span class=\"c1\"># Number of GPUS to use in the experiment</span>\n<span class=\"n\">_C</span><span class=\"o\">.</span><span class=\"n\">SYSTEM</span><span class=\"o\">.</span><span class=\"n\">NUM_GPUS</span> <span class=\"o\">=</span> <span class=\"mi\">8</span>\n<span class=\"c1\"># Number of workers for doing things</span>\n<span class=\"n\">_C</span><span class=\"o\">.</span><span class=\"n\">SYSTEM</span><span class=\"o\">.</span><span class=\"n\">NUM_WORKERS</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>\n\n<span class=\"n\">_C</span><span class=\"o\">.</span><span class=\"n\">TRAIN</span> <span class=\"o\">=</span> <span class=\"n\">CN</span><span class=\"p\">()</span>\n<span class=\"c1\"># A very important hyperparameter</span>\n<span class=\"n\">_C</span><span class=\"o\">.</span><span class=\"n\">TRAIN</span><span class=\"o\">.</span><span class=\"n\">HYPERPARAMETER_1</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>\n<span class=\"c1\"># The all important scales for the stuff</span>\n<span class=\"n\">_C</span><span class=\"o\">.</span><span class=\"n\">TRAIN</span><span class=\"o\">.</span><span class=\"n\">SCALES</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">get_cfg_defaults</span><span class=\"p\">():</span>\n  <span class=\"sd\">\"\"\"Get a yacs CfgNode object with default values for my_project.\"\"\"</span>\n  <span class=\"c1\"># Return a clone so that the defaults will not be altered</span>\n  <span class=\"c1\"># This is for the \"local variable\" use pattern</span>\n  <span class=\"k\">return</span> <span class=\"n\">_C</span><span class=\"o\">.</span><span class=\"n\">clone</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Alternatively, provide a way to import the defaults as</span>\n<span class=\"c1\"># a global singleton:</span>\n<span class=\"c1\"># cfg = _C  # users can `from config import cfg`</span>\n</pre>\n<p>Next, you'll create TOML configuration files; typically you'll make\none for each experiment. Each configuration file only overrides the\noptions that are changing in that experiment.</p>\n<pre><span class=\"c1\"># my_project/experiment.toml</span>\n<span class=\"k\">[SYSTEM]</span>\n  <span class=\"n\">NUM_GPUS</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"k\">[TRAIN]</span>\n  <span class=\"n\">SCALES</span> <span class=\"o\">=</span> <span class=\"k\">[1, 2]</span>\n</pre>\n<p>Finally, you'll have your actual project code that uses the config\nsystem. After any initial setup it's a good idea to freeze it to\nprevent further modification by calling the <code>freeze()</code> method. As\nillustrated below, the config options can either be used a global\nset of options by importing <code>cfg</code> and accessing it directly, or\nthe <code>cfg</code> can be copied and passed as an argument.</p>\n<pre><span class=\"c1\"># my_project/main.py</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">my_project</span>\n<span class=\"kn\">from</span> <span class=\"nn\">config</span> <span class=\"kn\">import</span> <span class=\"n\">get_cfg_defaults</span>  <span class=\"c1\"># local variable usage pattern, or:</span>\n<span class=\"c1\"># from config import cfg  # global singleton usage pattern</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n  <span class=\"n\">cfg</span> <span class=\"o\">=</span> <span class=\"n\">get_cfg_defaults</span><span class=\"p\">()</span>\n  <span class=\"n\">cfg</span><span class=\"o\">.</span><span class=\"n\">merge_from_file</span><span class=\"p\">(</span><span class=\"s2\">\"experiment.toml\"</span><span class=\"p\">)</span>\n  <span class=\"n\">cfg</span><span class=\"o\">.</span><span class=\"n\">freeze</span><span class=\"p\">()</span>\n  <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">cfg</span><span class=\"p\">)</span>\n\n  <span class=\"c1\"># Example of using the cfg as global access to options</span>\n  <span class=\"k\">if</span> <span class=\"n\">cfg</span><span class=\"o\">.</span><span class=\"n\">SYSTEM</span><span class=\"o\">.</span><span class=\"n\">NUM_GPUS</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n    <span class=\"n\">my_project</span><span class=\"o\">.</span><span class=\"n\">setup_multi_gpu_support</span><span class=\"p\">()</span>\n\n  <span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">my_project</span><span class=\"o\">.</span><span class=\"n\">create_model</span><span class=\"p\">(</span><span class=\"n\">cfg</span><span class=\"p\">)</span>\n</pre>\n<h4>Command line overrides</h4>\n<p>You can update a <code>CfgNode</code> using a list of fully-qualified key, value pairs.\nThis makes it easy to consume override options from the command line. For example:</p>\n<pre><span class=\"n\">cfg</span><span class=\"o\">.</span><span class=\"n\">merge_from_file</span><span class=\"p\">(</span><span class=\"s2\">\"experiment.toml\"</span><span class=\"p\">)</span>\n<span class=\"c1\"># Now override from a list (opts could come from the command line)</span>\n<span class=\"n\">opts</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"SYSTEM.NUM_GPUS\"</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"s2\">\"TRAIN.SCALES\"</span><span class=\"p\">,</span> <span class=\"s2\">\"[1, 2, 3, 4]\"</span><span class=\"p\">]</span>\n<span class=\"n\">cfg</span><span class=\"o\">.</span><span class=\"n\">merge_from_list</span><span class=\"p\">(</span><span class=\"n\">opts</span><span class=\"p\">)</span>\n</pre>\n<p>The following principle is recommended: \"There is only one way to\nconfigure the same thing.\" This principle means that if an option\nis defined in a TACS config object, then your program should set\nthat configuration option using <code>cfg.merge_from_list(opts)</code> and\nnot by defining, for example, <code>--train-scales</code> as a command line\nargument that is then used to set <code>cfg.TRAIN.SCALES</code>.</p>\n\n          </div>"}, "last_serial": 6329745, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "efba63ec82bc6d91f78e58b6f92ab460", "sha256": "f930a300836530f9e8497fbeebda677366a651c1e9ec8e911224d97c036af392"}, "downloads": -1, "filename": "tacs-0.0.1-py3.6.egg", "has_sig": false, "md5_digest": "efba63ec82bc6d91f78e58b6f92ab460", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": null, "size": 20749, "upload_time": "2019-12-19T05:22:16", "upload_time_iso_8601": "2019-12-19T05:22:16.274618Z", "url": "https://files.pythonhosted.org/packages/8f/c3/fad2ca6018ec256dcef346021ebabcdbb5685daf003654bddc14b6c7ef7f/tacs-0.0.1-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "9c3059d97170f0ed051ae5def2588284", "sha256": "7d0c786eec5ee8e7dc5939eadbb6f531c041a879d69432326012a65283ca198d"}, "downloads": -1, "filename": "tacs-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "9c3059d97170f0ed051ae5def2588284", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 16482, "upload_time": "2019-12-19T05:22:13", "upload_time_iso_8601": "2019-12-19T05:22:13.176984Z", "url": "https://files.pythonhosted.org/packages/a0/ed/d0c55f71226311770019c186b4ae724816d910316eaf3d1abe918a3cc00e/tacs-0.0.1-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "efba63ec82bc6d91f78e58b6f92ab460", "sha256": "f930a300836530f9e8497fbeebda677366a651c1e9ec8e911224d97c036af392"}, "downloads": -1, "filename": "tacs-0.0.1-py3.6.egg", "has_sig": false, "md5_digest": "efba63ec82bc6d91f78e58b6f92ab460", "packagetype": "bdist_egg", "python_version": "3.6", "requires_python": null, "size": 20749, "upload_time": "2019-12-19T05:22:16", "upload_time_iso_8601": "2019-12-19T05:22:16.274618Z", "url": "https://files.pythonhosted.org/packages/8f/c3/fad2ca6018ec256dcef346021ebabcdbb5685daf003654bddc14b6c7ef7f/tacs-0.0.1-py3.6.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "9c3059d97170f0ed051ae5def2588284", "sha256": "7d0c786eec5ee8e7dc5939eadbb6f531c041a879d69432326012a65283ca198d"}, "downloads": -1, "filename": "tacs-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "9c3059d97170f0ed051ae5def2588284", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 16482, "upload_time": "2019-12-19T05:22:13", "upload_time_iso_8601": "2019-12-19T05:22:13.176984Z", "url": "https://files.pythonhosted.org/packages/a0/ed/d0c55f71226311770019c186b4ae724816d910316eaf3d1abe918a3cc00e/tacs-0.0.1-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 02:58:31 2020"}