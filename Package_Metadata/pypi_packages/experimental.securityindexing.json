{"info": {"author": "Netsight Internet Solutions", "author_email": "dev@netsight.co.uk", "bugtrack_url": null, "classifiers": ["Framework :: Plone :: 4.0", "Framework :: Plone :: 4.1", "Framework :: Plone :: 4.2", "Framework :: Plone :: 4.3", "Programming Language :: Python :: 2.7"], "description": ".. image:: https://api.travis-ci.org/ploneintranet/experimental.securityindexing.png\n  :target: https://travis-ci.org/ploneintranet/experimental.securityindexing\n\n.. image:: https://coveralls.io/repos/ploneintranet/experimental.securityindexing/badge.png\n  :target: https://coveralls.io/r/ploneintranet/experimental.securityindexing\n\n=============================\nexperimental.securityindexing\n=============================\n\nDescription\n===========\nThis package aims to address a long-standing performance issue in Plone: \n\n    Under circumstances which require security for an object to be re-indexed, \n    for example, when adding roles to users or groups via the @@sharing view,\n    the object for which the sharing form is being used and all of its decendant objects\n    in the content tree are unconditionally fetched from the database (ZODB) and\n    their security attributes (allowedRolesAndUsers) are re-indexed.\n\n    This can yield terrible performance for some sites, depending upon the size (number of objects),\n    and workflow complexity.\n\n\nInstallation\n============\nTo install this package, add ``experimental.securityindexing`` to your Plone sites'\neggs and re-run buildout:\n\n.. code-block: ini\n\n  [buildout]\n  ...\n  eggs += experimental.securityindexing\n\n\nTesting it out\n--------------\nThis package provides some rudementry benchmarks which are aimed to be a sanity test\nanswering the question:\n\n    \"Are we at least faster than the previous implementation by default?\"\n\nThese benchmarks should not be treated as authorative, nor indicative of the performance\nyou should expect on a real site.\n\nTo do so, the best way to ascertain results is to install the package in a development/staging \nversions of your site aginst some realistic data.\n\n\nInstallation is as above, but add the extras ``[benchmarks,tests]``:\n\n.. code-block: ini\n\n  [buildout]\n  ...\n  eggs += experimental.securityindexing [benchmarks,test]\n\nPlease read the `benchmark docs`_ for details.\n\n\nExisting behaviour in Plone 4.x sites\n=====================================\nWhen local roles are assigned to user on a given folderish content item, \nthe folder will be indexed and all of it's descendants (child folders) -\nunconditionally.\n\nDepending upon the combination of:\n\n  * The structure of the tree\n\n  * The number of descendant content items (depth and breath of the sub-tree\n    \"beneath\" the object being edited)\n\nThis behaviour is currently implemented twice (Dexterity and Archetypes),\nby the method `reindexObjectSecurity`. This method invoked on the context \nthat local roles are being manipulated upon, in order to reflect the changes in the \n`allowedRolesAndUsers` `Keywordindex` in the `ZCatalog`.\n\nThe `allowedRolesAndUsers` index is used in Plone to determine which content a user can see.\ne.g: \n\n    In the site search\n  \nWithin a Plone 4.x site, the two implementations of the `reindexObjectSecurity` API are: \n\n  - Products.CMFCore.CMFCatalogAware.CatalogAware.reindexObjectSecuity(skip_self=False):\n    Indexes the content item (self). The keyword parameter skip_self \n    will be False when invoked from the @@sharing action.\n    For each child node in the content tree \"beneath\" this content item, \n    fetch that object, ultimately via the ZCatalog.unrestrictedTraverse API, \n    and re-index each one, unconditionally.\n     \n  - Products.Archetypes.CatalogMultiplex.CatalogMultiplex    \n    The archetypes tool is used to look up all catalogs that have \n    been registered for the `meta_type` of the content item (self).\n\nN.B Both these implementations implement the Products.CMFCore.interfaces.ICatalogAware\n    interface.\n\nThe expensive operations seem to be:\n\n   1. \"Waking up\" each child node via `unrestrictedTraverse`\n\n   2. When any local roles of significance are assigned to the object,\n      the indexer for local roles (Products.CMFPlone.CatalogTool.allowedRolesAndUsers) \n      invokes Products.PlonePAS.plugins.local_roles.LocalRolesManager.getAllLocalRolesInContext API,\n      which performs the following algorithm for each object to be indexed:\n       \n      1. Acquire the inner context.\n\n      2. acquire the content object and it's parent.\n         and calculate the unique set of local roles for the content object.\n\n      3. If __ac_block_local_roles__ is not set,  exit and returns the local roles calculated.\n\n      4. Repeats 2. until a parent is None (root of the tree).\n      \n\nThe goals of any solution to address the previously described performance issue(s) are:\n \n  1. Wake up as few objects as possible.\n\n  2. Where local roles information has not changed, avoid re-indexing.\n\nThe following scheme was envisioned to optimise the above algorithm:\n\n  1. When an object is indexed for the first time `CatalogTool.indexObject`,\n     persist a unique token representing the unique set of local roles and the __ac_local_roles_block__\n     flag, along with the object's id and physical path in a \"shadow tree\" which has\n     the same form as the main content tree (ZODB).\n   \n  2. Avoid re-indexing where possible, avoid waking up content objects:\n   \n    2.1 Given an item of content `obj`, determine the set of child objects that need to be re-indexed,\n        retrieve the node corresponding to the `obj` from the shadow tree, and each node representing \n        `obj`'s corresponding descendants, and group these nodes by the unique local roles. \n    \n    2.2 For each group of nodes, retrieve the content object corresponding to the first node in the group.\n    \n    2.3 Ask the first object for it's `allowedRolesAndUsers` (aka local roles)\n    \n    2.4 Index each node in group, supplying a faux object (either the shadow node or some other \n        object standing-in for the content object)\n\nCredit\n======\nThis work has been done as part of the `Plone Intranet project`_. \nWork sponsored by `Netsight Internet Solutions`_.\n\n\n.. _`Netsight Internet Solutions`: http://www.netsight.co.uk\n.. _`Plone Intranet project`: http://github.com/ploneintranet\n.. _`benchmark docs`: docs/benchmarks.rst\n\n\n=========\nChangelog\n=========\n\n0.6 (2014-06-04)\n================\n\n- Nothing changed yet.\n\n\n0.5 (2014-06-04)\n================\n\n- Nothing changed yet.\n\n\n0.4 (2014-06-04)\n================\n - Fix versioning metadata, bumped version for new release.\n\n0.2 (2014-06-04)\n================\n - Corrected package metadata.\n - Update README.rst to remove wrongly named branch in badge urls.\n - Control panel configlet for synchronising/view state of shadowtree.\n - Use itertools to group nodes\n - The shadowtree tool is now a site-local tool (but managed by a global utility)\n - Add functional tests\n\n0.2dev (unreleasd)\n==================\n\n0.1dev (unreleasd)\n==================\n\n0.1 (2014-05-16)\n================\n - Initial pypi release.\n\n0.1 (2014-05-16)\n================\n - Initial pypi release.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ploneintranet/experimental.securityindexing", "keywords": null, "license": "GPLv2", "maintainer": null, "maintainer_email": null, "name": "experimental.securityindexing", "package_url": "https://pypi.org/project/experimental.securityindexing/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/experimental.securityindexing/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/ploneintranet/experimental.securityindexing"}, "release_url": "https://pypi.org/project/experimental.securityindexing/0.6/", "requires_dist": null, "requires_python": null, "summary": "Optimises indexing of object security for a Plone site.", "version": "0.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/ploneintranet/experimental.securityindexing\" rel=\"nofollow\"><img alt=\"https://api.travis-ci.org/ploneintranet/experimental.securityindexing.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d2fc6943358f7c17f51cc44322e8d4d881d9db34/68747470733a2f2f6170692e7472617669732d63692e6f72672f706c6f6e65696e7472616e65742f6578706572696d656e74616c2e7365637572697479696e646578696e672e706e67\"></a>\n<a href=\"https://coveralls.io/r/ploneintranet/experimental.securityindexing\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/ploneintranet/experimental.securityindexing/badge.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a4f8a21628e025d78348b1d242757914412e751e/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f706c6f6e65696e7472616e65742f6578706572696d656e74616c2e7365637572697479696e646578696e672f62616467652e706e67\"></a>\n<div id=\"experimental-securityindexing\">\n<h2>experimental.securityindexing</h2>\n<div id=\"description\">\n<h3>Description</h3>\n<p>This package aims to address a long-standing performance issue in Plone:</p>\n<blockquote>\n<p>Under circumstances which require security for an object to be re-indexed,\nfor example, when adding roles to users or groups via the @@sharing view,\nthe object for which the sharing form is being used and all of its decendant objects\nin the content tree are unconditionally fetched from the database (ZODB) and\ntheir security attributes (allowedRolesAndUsers) are re-indexed.</p>\n<p>This can yield terrible performance for some sites, depending upon the size (number of objects),\nand workflow complexity.</p>\n</blockquote>\n</div>\n<div id=\"installation\">\n<h3>Installation</h3>\n<p>To install this package, add <tt>experimental.securityindexing</tt> to your Plone sites\u2019\neggs and re-run buildout:</p>\n<div id=\"testing-it-out\">\n<h4>Testing it out</h4>\n<p>This package provides some rudementry benchmarks which are aimed to be a sanity test\nanswering the question:</p>\n<blockquote>\n\u201cAre we at least faster than the previous implementation by default?\u201d</blockquote>\n<p>These benchmarks should not be treated as authorative, nor indicative of the performance\nyou should expect on a real site.</p>\n<p>To do so, the best way to ascertain results is to install the package in a development/staging\nversions of your site aginst some realistic data.</p>\n<p>Installation is as above, but add the extras <tt>[benchmarks,tests]</tt>:</p>\n<p>Please read the <a href=\"docs/benchmarks.rst\" rel=\"nofollow\">benchmark docs</a> for details.</p>\n</div>\n</div>\n<div id=\"existing-behaviour-in-plone-4-x-sites\">\n<h3>Existing behaviour in Plone 4.x sites</h3>\n<p>When local roles are assigned to user on a given folderish content item,\nthe folder will be indexed and all of it\u2019s descendants (child folders) -\nunconditionally.</p>\n<p>Depending upon the combination of:</p>\n<blockquote>\n<ul>\n<li>The structure of the tree</li>\n<li>The number of descendant content items (depth and breath of the sub-tree\n\u201cbeneath\u201d the object being edited)</li>\n</ul>\n</blockquote>\n<p>This behaviour is currently implemented twice (Dexterity and Archetypes),\nby the method <cite>reindexObjectSecurity</cite>. This method invoked on the context\nthat local roles are being manipulated upon, in order to reflect the changes in the\n<cite>allowedRolesAndUsers</cite> <cite>Keywordindex</cite> in the <cite>ZCatalog</cite>.</p>\n<p>The <cite>allowedRolesAndUsers</cite> index is used in Plone to determine which content a user can see.\ne.g:</p>\n<blockquote>\nIn the site search</blockquote>\n<p>Within a Plone 4.x site, the two implementations of the <cite>reindexObjectSecurity</cite> API are:</p>\n<blockquote>\n<ul>\n<li>Products.CMFCore.CMFCatalogAware.CatalogAware.reindexObjectSecuity(skip_self=False):\nIndexes the content item (self). The keyword parameter skip_self\nwill be False when invoked from the @@sharing action.\nFor each child node in the content tree \u201cbeneath\u201d this content item,\nfetch that object, ultimately via the ZCatalog.unrestrictedTraverse API,\nand re-index each one, unconditionally.</li>\n<li>Products.Archetypes.CatalogMultiplex.CatalogMultiplex\nThe archetypes tool is used to look up all catalogs that have\nbeen registered for the <cite>meta_type</cite> of the content item (self).</li>\n</ul>\n</blockquote>\n<dl>\n<dt>N.B Both these implementations implement the Products.CMFCore.interfaces.ICatalogAware</dt>\n<dd>interface.</dd>\n</dl>\n<p>The expensive operations seem to be:</p>\n<blockquote>\n<ol>\n<li>\u201cWaking up\u201d each child node via <cite>unrestrictedTraverse</cite></li>\n<li>When any local roles of significance are assigned to the object,\nthe indexer for local roles (Products.CMFPlone.CatalogTool.allowedRolesAndUsers)\ninvokes Products.PlonePAS.plugins.local_roles.LocalRolesManager.getAllLocalRolesInContext API,\nwhich performs the following algorithm for each object to be indexed:<ol>\n<li>Acquire the inner context.</li>\n<li>acquire the content object and it\u2019s parent.\nand calculate the unique set of local roles for the content object.</li>\n<li>If __ac_block_local_roles__ is not set,  exit and returns the local roles calculated.</li>\n<li>Repeats 2. until a parent is None (root of the tree).</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<p>The goals of any solution to address the previously described performance issue(s) are:</p>\n<blockquote>\n<ol>\n<li>Wake up as few objects as possible.</li>\n<li>Where local roles information has not changed, avoid re-indexing.</li>\n</ol>\n</blockquote>\n<p>The following scheme was envisioned to optimise the above algorithm:</p>\n<blockquote>\n<ol>\n<li>When an object is indexed for the first time <cite>CatalogTool.indexObject</cite>,\npersist a unique token representing the unique set of local roles and the __ac_local_roles_block__\nflag, along with the object\u2019s id and physical path in a \u201cshadow tree\u201d which has\nthe same form as the main content tree (ZODB).</li>\n<li>Avoid re-indexing where possible, avoid waking up content objects:</li>\n</ol>\n<blockquote>\n<dl>\n<dt>2.1 Given an item of content <cite>obj</cite>, determine the set of child objects that need to be re-indexed,</dt>\n<dd>retrieve the node corresponding to the <cite>obj</cite> from the shadow tree, and each node representing\n<cite>obj</cite>\u2019s corresponding descendants, and group these nodes by the unique local roles.</dd>\n</dl>\n<p>2.2 For each group of nodes, retrieve the content object corresponding to the first node in the group.</p>\n<p>2.3 Ask the first object for it\u2019s <cite>allowedRolesAndUsers</cite> (aka local roles)</p>\n<dl>\n<dt>2.4 Index each node in group, supplying a faux object (either the shadow node or some other</dt>\n<dd>object standing-in for the content object)</dd>\n</dl>\n</blockquote>\n</blockquote>\n</div>\n<div id=\"credit\">\n<h3>Credit</h3>\n<p>This work has been done as part of the <a href=\"http://github.com/ploneintranet\" rel=\"nofollow\">Plone Intranet project</a>.\nWork sponsored by <a href=\"http://www.netsight.co.uk\" rel=\"nofollow\">Netsight Internet Solutions</a>.</p>\n</div>\n</div>\n<div id=\"changelog\">\n<h2>Changelog</h2>\n<div id=\"id1\">\n<h3>0.6 (2014-06-04)</h3>\n<ul>\n<li>Nothing changed yet.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>0.5 (2014-06-04)</h3>\n<ul>\n<li>Nothing changed yet.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>0.4 (2014-06-04)</h3>\n<blockquote>\n<ul>\n<li>Fix versioning metadata, bumped version for new release.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id4\">\n<h3>0.2 (2014-06-04)</h3>\n<blockquote>\n<ul>\n<li>Corrected package metadata.</li>\n<li>Update README.rst to remove wrongly named branch in badge urls.</li>\n<li>Control panel configlet for synchronising/view state of shadowtree.</li>\n<li>Use itertools to group nodes</li>\n<li>The shadowtree tool is now a site-local tool (but managed by a global utility)</li>\n<li>Add functional tests</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"dev-unreleasd\">\n<h3>0.2dev (unreleasd)</h3>\n</div>\n<div id=\"id5\">\n<h3>0.1dev (unreleasd)</h3>\n</div>\n<div id=\"id6\">\n<h3>0.1 (2014-05-16)</h3>\n<blockquote>\n<ul>\n<li>Initial pypi release.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"id7\">\n<h3>0.1 (2014-05-16)</h3>\n<blockquote>\n<ul>\n<li>Initial pypi release.</li>\n</ul>\n</blockquote>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1113682, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "9f9ba6578f2e9a3f97ad09659cd730d7", "sha256": "2693a000585558f5f7fabe3da38a9733164b4fc49543fd6498bcf712d12c069b"}, "downloads": -1, "filename": "experimental.securityindexing-0.1.zip", "has_sig": false, "md5_digest": "9f9ba6578f2e9a3f97ad09659cd730d7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 41091, "upload_time": "2014-05-16T14:28:10", "upload_time_iso_8601": "2014-05-16T14:28:10.437983Z", "url": "https://files.pythonhosted.org/packages/0e/f6/2ebd0b4d06e8d54603d5b3e51e2e773ddfeb9aeeee69173153c5d18e7466/experimental.securityindexing-0.1.zip", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "bd47b363c749c3e10a1c261020270720", "sha256": "4c2149a504edc2fd197047879ebac88ff4b5b88fc86480840661e2a76a230284"}, "downloads": -1, "filename": "experimental.securityindexing-0.2.zip", "has_sig": false, "md5_digest": "bd47b363c749c3e10a1c261020270720", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 192560, "upload_time": "2014-06-03T15:18:41", "upload_time_iso_8601": "2014-06-03T15:18:41.213025Z", "url": "https://files.pythonhosted.org/packages/ef/91/dd8a97550f8809c648b97cf4080e7bf673a8e180a849fecfa8e8fe257b31/experimental.securityindexing-0.2.zip", "yanked": false}], "0.2dev": [], "0.3": [], "0.4": [{"comment_text": "", "digests": {"md5": "b805470d2151a954df8c2c9ec8288c1f", "sha256": "9989f19961f146cea8f140068765bbe9a04b08755f1f7e1a22509b8fb670bb57"}, "downloads": -1, "filename": "experimental.securityindexing-0.4.zip", "has_sig": false, "md5_digest": "b805470d2151a954df8c2c9ec8288c1f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 161510, "upload_time": "2014-06-04T10:54:20", "upload_time_iso_8601": "2014-06-04T10:54:20.552968Z", "url": "https://files.pythonhosted.org/packages/68/61/76ca0b04d17107397386e2cc2b57c19e5638dd287b0f07aba65bf9bf7a8f/experimental.securityindexing-0.4.zip", "yanked": false}], "0.5": [], "0.6": [{"comment_text": "", "digests": {"md5": "bcda09e8993fbcb6a5488d86dec8141b", "sha256": "899450c4abb0ad2f80cbdfceef7f089a80ee1ee7fbc4ba706f01817b06a833e5"}, "downloads": -1, "filename": "experimental.securityindexing-0.6.zip", "has_sig": false, "md5_digest": "bcda09e8993fbcb6a5488d86dec8141b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51859, "upload_time": "2014-06-04T13:20:57", "upload_time_iso_8601": "2014-06-04T13:20:57.670366Z", "url": "https://files.pythonhosted.org/packages/19/35/14e52eaa8ff714b62c741fa8ba0dd66b871a6f2f80666c84933572fc042d/experimental.securityindexing-0.6.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bcda09e8993fbcb6a5488d86dec8141b", "sha256": "899450c4abb0ad2f80cbdfceef7f089a80ee1ee7fbc4ba706f01817b06a833e5"}, "downloads": -1, "filename": "experimental.securityindexing-0.6.zip", "has_sig": false, "md5_digest": "bcda09e8993fbcb6a5488d86dec8141b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51859, "upload_time": "2014-06-04T13:20:57", "upload_time_iso_8601": "2014-06-04T13:20:57.670366Z", "url": "https://files.pythonhosted.org/packages/19/35/14e52eaa8ff714b62c741fa8ba0dd66b871a6f2f80666c84933572fc042d/experimental.securityindexing-0.6.zip", "yanked": false}], "timestamp": "Fri May  8 00:44:40 2020"}