{"info": {"author": "Emanuele Bellocchia", "author_email": "ebellocchia@gmail.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# BIP utility library\n[![PyPI version](https://badge.fury.io/py/bip-utils.svg)](https://badge.fury.io/py/bip-utils)\n[![Build Status](https://travis-ci.com/ebellocchia/bip_utils.svg?branch=master)](https://travis-ci.com/ebellocchia/bip_utils)\n[![codecov](https://codecov.io/gh/ebellocchia/bip_utils/branch/master/graph/badge.svg)](https://codecov.io/gh/ebellocchia/bip_utils)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://raw.githubusercontent.com/ebellocchia/bip_utils/master/LICENSE)\n\n## Introduction\n\nThis package contains an implementation of some BIP (Bitcoin Improvement Proposal) specifications, allowing to:\n- Generate a mnemonic string from a random entropy\n- Generate a secure seed from the mnemonic string\n- Use the seed to generate the master key of the wallet and derive the children keys, including address encoding\n\nThe implemented BIP specifications are the following:\n- [BIP-0039](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) for mnemonic and seed generation\n- [BIP-0032](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) for master key generation (from the secure seed) and children keys derivation\n- [BIP-0044](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki), [BIP-0049](https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki) and [BIP-0084](https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki) for the hierarchy of deterministic wallets, based on BIP-0032 specification\n\nIn addition to this, the package allows to:\n- Parse BIP-0032 derivation paths\n- Generate P2PKH addresses (included in BIP-0044)\n- Generate P2SH addresses (included in BIP-0049)\n- Generate P2WPKH addresses (included in BIP-0084)\n- Generate Ethereum addresses\n- Generate Ripple addresses\n- Encode/Decode [WIF](https://en.bitcoin.it/wiki/Wallet_import_format)\n- Encode/Decode [base58](https://en.bitcoin.it/wiki/Base58Check_encoding#Background)\n- Encode/Decode [bech32](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)\n\nThe currently supported coins are:\n- Bitcoin (and related test net)\n- Litecoin (and related test net)\n- Dogecoin (and related test net)\n- Dash (and related test net)\n- Ethereum\n- Ripple\n\n## Install the package\n\nThe package requires Python 3, it is not compatible with Python 2.\nTo install it:\n- Using *setuptools*:\n\n        python setup.py install\n\n- Using *pip*:\n\n        pip install bip_utils\n\nTo run the tests:\n\n- Without code coverage\n\n        python setup.py test\n\n- With code coverage and report:\n\n        pip install coverage\n        coverage run -m unittest discover\n        coverage report\n\n## BIP-0039 library\n\n### Mnemonic generation\n\nA mnemonic string can be generated by specifying the words number (in this case a random entropy will be used) or directly the entropy bytes.\\\nSupported words number:\n- 12: *Bip39WordsNum.WORDS_NUM_12*\n- 15: *Bip39WordsNum.WORDS_NUM_15*\n- 18: *Bip39WordsNum.WORDS_NUM_18*\n- 21: *Bip39WordsNum.WORDS_NUM_21*\n- 24: *Bip39WordsNum.WORDS_NUM_24*\n\nSupported entropy bits:\n- 128: *Bip39EntropyBitLen.BIT_LEN_128*\n- 160: *Bip39EntropyBitLen.BIT_LEN_160*\n- 192: *Bip39EntropyBitLen.BIT_LEN_192*\n- 224: *Bip39EntropyBitLen.BIT_LEN_224*\n- 256: *Bip39EntropyBitLen.BIT_LEN_256*\n\n**NOTE:** only the English words list is currently supported.\n\n**Code example**\n\n    import binascii\n    from bip_utils import EntropyGenerator, Bip39MnemonicGenerator, Bip39WordsNum\n\n    # Generate a random mnemonic string of 15 words\n    mnemonic = Bip39MnemonicGenerator.FromWordsNumber(Bip39WordsNum.WORDS_NUM_15)\n\n    # Generate the mnemonic string from entropy bytes:\n    entropy_bytes_hex = b\"00000000000000000000000000000000\"\n    mnemonic = Bip39MnemonicGenerator.FromEntropy(binascii.unhexlify(entropy_bytes_hex))\n\n    # Generate mnemonic from random 192-bit entropy\n    entropy_bytes = EntropyGenerator(Bip39EntropyBitLen.BIT_LEN_192).Generate()\n    mnemonic = Bip39MnemonicGenerator.FromEntropy(entropy_bytes)\n\n### Mnemonic validation\n\nA mnemonic string can be validated by verifying its checksum.\nIt is also possible to get back the entropy bytes from a mnemonic.\n\n**Code example**\n\n     from bip_utils import Bip39MnemonicValidator\n\n     # Get back the original entropy from a mnemonic string\n     entropy_bytes = Bip39MnemonicValidator(mnemonic).GetEntropy()\n     # Validate a mnemonic string by verifying its checksum\n     is_valid = Bip39MnemonicValidator(mnemonic).Validate()\n\n### Seed generation\n\nA secure 64-byte seed is generated from a mnemonic and can be protected by a passphrase.\\\nThis seed can be used to contruct a Bip class.\n\n**Code example**\n\n    from bip_utils import Bip39SeedGenerator\n\n    # If not specified, the passphrase will be empty\n    passphrase = \"my_passphrase\"\n    seed_bytes = Bip39SeedGenerator(mnemonic).Generate(passphrase)\n\n## BIP-0032 library\n\nThe BIP-0032 library is wrapped inside the BIP-0044, BIP-0049 and BIP-0084 libraries, so there is no need to use it alone unless you need to derive some non-standard paths.\n\n### Construction from a seed\n\nThe class can be constructed from a seed. The seed can be specified manually or generated by *Bip39SeedGenerator*.\\\nThe constructed class is the master path, so printing the private key will result in printing the master key.\n\n**Code example**\n\n    import binascii\n    from bip_utils import Bip32\n\n    # Seed bytes\n    seed_bytes = binascii.unhexlify(b\"5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4\")\n    # Construct from seed. In case it's a test net, pass True as second parameter. Derivation path returned: m\n    bip32_ctx = Bip32.FromSeed(seed_bytes)\n    # Print master key in extended format\n    print(bip32_ctx.PrivateKey().ToExtended())\n\nIn addition to a seed, it's also possible to specify a derivation path.\n\n**Code example**\n\n    # Derivation path returned: m/0'/1'/2\n    bip32_ctx = Bip32.FromSeedAndPath(seed_bytes, \"m/0'/1'/2\")\n    # Print private key for derivation path m/0'/1'/2 in extended format\n    print(bip32_ctx.PrivateKey().ToExtended())\n\n### Construction from an extended key\n\nAlternatively, the class can be constructed directly from an extended key.\\\nThe object returned will be at the same depth of the specified key.\n\n**Code example**\n\n    from bip_utils import Bip32\n\n    # Private extended key from derivation path m/0'/1 (depth 2)\n    key_str = \"xprv9wTYmMFdV23N2TdNG573QoEsfRrWKQgWeibmLntzniatZvR9BmLnvSxqu53Kw1UmYPxLgboyZQaXwTCg8MSY3H2EU4pWcQDnRnrVA1xe8fs\"\n    # Construct from key (return object has depth 2)\n    bip32_ctx = Bip32.FromExtendedKey(key_str)\n    # Print keys\n    print(bip32_ctx.PrivateKey().ToExtended())\n    print(bip32_ctx.PublicKey().ToExtended())\n\n    # Public extended key from derivation path m/0'/1 (depth 2)\n    key_str = \"xpub6ASuArnXKPbfEwhqN6e3mwBcDTgzisQN1wXN9BJcM47sSikHjJf3UFHKkNAWbWMiGj7Wf5uMash7SyYq527Hqck2AxYysAA7xmALppuCkwQ\"\n    # Construct from key (return object has depth 2)\n    bip32_ctx = Bip32.FromExtendedKey(key_str)\n    # Print key\n    print(bip32_ctx.PublicKey().ToExtended())\n    # Getting private key from a public-only object triggers a Bip32KeyError exception\n\n### Keys derivation\n\nEach time a key is derived, a new instance of the Bip32 class is returned. This allows to chain the methods call or save a specific key pair for future derivation.\\\nThe *Bip32Utils.HardenIndex* method can be used to make an index hardened.\n\n**Code example**\n\n    import binascii\n    from bip_utils import Bip32, Bip32Utils\n\n    # Seed bytes\n    seed_bytes = binascii.unhexlify(b\"5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4\")\n    # Path: m\n    bip32_ctx = Bip32.FromSeed(seed_bytes)\n    # Derivation path: m/0'/1'/2/3\n    bip32_ctx = bip32_ctx.ChildKey(Bip32Utils.HardenIndex(0)) \\\n                         .ChildKey(Bip32Utils.HardenIndex(1)) \\\n                         .ChildKey(2)                         \\\n                         .ChildKey(3)\n    # Print keys in extended format\n    print(bip32_ctx.PrivateKey().ToExtended())\n    print(bip32_ctx.PublicKey().ToExtended())\n    # Print keys in hex format\n    print(bip32_ctx.PrivateKey().Raw().ToHex())\n    print(bip32_ctx.PublicKey().RawCompressed().ToHex())\n    print(bip32_ctx.PublicKey().RawUncompressed().ToHex())\n    # Print private key in WIF format\n    print(bip32_ctx.PrivateKey().ToWif())\n    # Print public key converted to address\n    print(bip32_ctx.PublicKey().ToAddress())\n\n    # Alternative: use DerivePath method\n    bip32_ctx = Bip32.FromSeed(seed_bytes)\n    bip32_ctx = bip32_ctx.DerivePath(\"0'/1'/2/3\")\n\n    # DerivePath derives from the current depth, so it can be split\n    bip32_ctx = Bip32.FromSeed(seed_bytes)\n    bip32_ctx = bip32_ctx.DerivePath(\"0'/1'\")   # Derivation path: m/0'/1'\n    bip32_ctx = bip32_ctx.DerivePath(\"2/3\")     # Derivation path: m/0'/1'/2/3\n\n### Parse path\n\nThe Bip32 module allows also to parse derivation paths by returning the list of indexes in the path.\\\nIn case of error, an empty list is returned.\n\n**Code example**\n\n    from bip_utils import Bip32PathParser\n\n    # Print: [\"m\", 2147483648, 2147483649, 2]\n    print(Bip32PathParser.Parse(\"m/0'/1'/2\"))\n    # Same but skipping the master. Print: [2147483648, 2147483649, 2]\n    print(Bip32PathParser.Parse(\"0'/1'/2\", True))\n    # 'p' can be used as an alternative character instead of '\n    print(Bip32PathParser.Parse(\"m/0p/1p/2\"))\n    # Error path: empty list returned. Print: []\n    print(Bip32PathParser.Parse(\"m/0'/abc/2\"))\n\n## Bip-0044, BIP-0049, BIP-0084 libraries\n\nThese libraries derives all from the same base class, so they are used exactly in the same way.\\\nTherefore, the following code examples can be used with the Bip44, Bip49 or Bip84 class.\n\n### Construction from a seed\n\nA Bip class can be constructed from a seed, like Bip32. The seed can be specified manually or generated by *Bip39SeedGenerator*.\n\n**Code example**\n\n    import binascii\n    from bip_utils import Bip44, Bip44Coins\n\n    # Seed bytes\n    seed_bytes = binascii.unhexlify(b\"5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4\")\n    # Derivation path returned: m\n    # In case it's a test net, pass True as second parameter\n    bip44_ctx = Bip44.FromSeed(seed_bytes, Bip44Coins.BITCOIN)\n\n### Construction from an extended key\n\nAlternatively, a Bip class can be constructed directly from an extended key.\\\nThe Bip object returned will be at the same depth of the specified key.\n\n**Code example**\n\n    from bip_utils import Bip44, Bip44Coins\n\n    # Private extended key\n    key_str = \"xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi\"\n    # Construct from extended key\n    bip44_ctx = Bip44.FromExtendedKey(key_str, Bip44Coins.BITCOIN)\n\n### Keys derivation\n\nLike Bip32, each time a key is derived a new instance of the Bip class is returned.\\\nThe keys must be derived with the levels specified by BIP-0044:\n\n    m / purpose' / coin_type' / account' / change / address_index\n\nusing the correspondent methods. If keys are derived in the wrong level, a *RuntimeError* will be raised.\\\nThe private and public extended keys can be printed at any level.\n\nCurrently supported coins enumerative:\n- Bitcoin (and related test net) : *Bip44Coins.BITCOIN, Bip44Coins.BITCOIN_TESTNET*\n- Litecoin (and related test net) : *Bip44Coins.LITECOIN, Bip44Coins.LITECOIN_TESTNET*\n- Dogecoin (and related test net) : *Bip44Coins.DOGECOIN, Bip44Coins.DOGECOIN_TESTNET*\n- Dash (and related test net) : *Bip44Coins.DASH, Bip44Coins.DASH_TESTNET*\n- Ethereum : *Bip44Coins.ETHEREUM*\n- Ripple : *Bip44Coins.RIPPLE*\n\nThe library can be easily extended with other coins anyway.\n\n**Code example**\n\n    import binascii\n    from bip_utils import Bip44, Bip44Coins, Bip44Changes\n\n    # Seed bytes\n    seed_bytes = binascii.unhexlify(b\"5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4\")\n    # Create from seed\n    bip44_mst = Bip44.FromSeed(seed_bytes, Bip44Coins.BITCOIN)\n\n    # Print master key in extended format\n    print(bip44_mst.PrivateKey().ToExtended())\n    # Print master key in hex format\n    print(bip44_mst.PrivateKey().Raw().ToHex())\n\n    # Print public key in extended format (default: Bip44PubKeyTypes.EXT_KEY)\n    print(bip44_mst.PublicKey())\n    # Print public key in raw uncompressed format\n    print(bip44_mst.PublicKey().RawUncompressed().ToHex())\n    # Print public key in raw compressed format\n    print(bip44_mst.PublicKey().RawCompressed().ToHex())\n\n    # Print the master key in WIF\n    print(bip44_mst.IsMasterLevel())\n    print(bip44_mst.PrivateKey().ToWif())\n\n    # Derive account 0 for Bitcoin: m/44'/0'/0'\n    bip44_acc = bip44_mst.Purpose() \\\n                         .Coin()    \\\n                         .Account(0)\n    # Print keys in extended format\n    print(bip44_acc.IsAccountLevel())\n    print(bip44_acc.PrivateKey().ToExtended())\n    print(bip44_acc.PublicKey().ToExtended())\n\n    # Derive the external chain: m/44'/0'/0'/0\n    bip44_change = bip44_acc.Change(Bip44Changes.CHAIN_EXT)\n    # Print again keys in extended format\n    print(bip44_change.IsChangeLevel())\n    print(bip44_change.PrivateKey().ToExtended())\n    print(bip44_change.PublicKey().ToExtended())\n\n    # Derive the first 20 addresses of the external chain: m/44'/0'/0'/0/i\n    for i in range(20):\n        bip44_addr = bip44_change.AddressIndex(i)\n        # Print extended keys and address\n        print(bip44_addr.PrivateKey().ToExtended())\n        print(bip44_addr.PublicKey().ToExtended())\n        print(bip44_addr.PublicKey().ToAddress())\n\nIn the example above, Bip44 can be substituted with Bip49 or Bip84 without changing the code.\n\n## Ethereum/Ripple addresses\n\nThese libraries are used internally by the other libraries, but they are available also for external use.\n\n**Code example**\n\n    from bip_utils import EthAddr, XrpAddr\n\n    # Ethereum needs the uncompressed public key\n    addr = EthAddr.ToAddress(pub_key_bytes)\n    # Ripple needs the compressed public key\n    addr = XrpAddr.ToAddress(pub_key_bytes)\n\n## P2PKH/P2SH/P2WPKH addresses\n\nThese libraries are used internally by the other libraries, but they are available also for external use.\n\n**Code example**\n\n    from bip_utils import P2PKH, P2SH, P2WPKH\n\n    # P2PKH addresses (the default uses Bitcoin network address version, you can pass a different one as second parameter)\n    addr = P2PKH.ToAddress(pub_key_bytes)\n    # P2SH addresses (the default uses Bitcoin network address version, you can pass a different one as second parameter)\n    addr = P2SH.ToAddress(pub_key_bytes)\n    # P2WPKH addresses (the default uses Bitcoin network address version, you can pass a different one as second parameter)\n    addr = P2WPKH.ToAddress(pub_key_bytes)\n\n## WIF\n\nThis library is used internally by the other libraries, but it's available also for external use.\n\n**Code example**\n\n    import binascii\n    from bip_utils import WifDecoder, WifEncoder\n\n    key_bytes = binascii.unhexlify(b'1837c1be8e2995ec11cda2b066151be2cfb48adf9e47b151d46adab3a21cdf67')\n\n    # Encode\n    enc = WifEncoder.Encode(key_bytes)\n    # Decode\n    dec = WifDecoder.Decode(enc)\n\n## Base58\n\nThis library is used internally by the other libraries, but it's available also for external use.\\\nIt supports both normal encode/decode and check_encode/check_decode with Bitcoin and Ripple alphabets (if not specified, the Bitcoin one will be used by default).\n\n**Code example**\n\n    import binascii\n    from bip_utils import Base58Decoder, Base58Encoder, Base58Alphabets\n\n    data_bytes = binascii.unhexlify(b\"636363\")\n\n    # Normal encode\n    enc     = Base58Encoder.Encode(data_bytes)\n    # Check encode\n    chk_enc = Base58Encoder.CheckEncode(data_bytes)\n\n    # Normal decode\n    dec     = Base58Decoder.Decode(enc)\n    # Check decode, RuntimeError is raised if checksum verification fails\n    chk_dec = Base58Decoder.CheckDecode(chk_enc)\n\n    # Same as before with Ripple alphabet\n    enc     = Base58Encoder.Encode(data_bytes, Base58Alphabets.RIPPLE)\n    chk_enc = Base58Encoder.CheckEncode(data_bytes, Base58Alphabets.RIPPLE)\n    dec     = Base58Decoder.Decode(enc, Base58Alphabets.RIPPLE)\n    chk_dec = Base58Decoder.CheckDecode(chk_enc, Base58Alphabets.RIPPLE)\n\n\n## Bech32\n\nThis library is used internally by the other libraries, but it's available also for external use.\n\n**Code example**\n\n    import binascii\n    from bip_utils import Bech32Decoder, Bech32Encoder\n\n    data_bytes = binascii.unhexlify(b'9c90f934ea51fa0f6504177043e0908da6929983')\n\n    # Encode\n    enc = Bech32Encoder.EncodeAddr(\"bc\", 0, data_bytes)\n    # Decode\n    dec = Bech32Decoder.DecodeAddr(\"bc\", enc)\n\n## Complete code example\n\nExample from mnemonic generation to wallet addresses.\n\n    from bip_utils import Bip39MnemonicGenerator, Bip39SeedGenerator, Bip44, Bip44Coins, Bip44Changes\n\n    # Generate random mnemonic\n    mnemonic = Bip39MnemonicGenerator.FromWordsNumber(12)\n    print(\"Mnemonic string: %s\" % mnemonic)\n    # Generate seed from mnemonic\n    seed_bytes = Bip39SeedGenerator(mnemonic).Generate()\n\n    # Generate BIP44 master keys\n    bip_obj_mst = Bip44.FromSeed(seed_bytes, Bip44Coins.BITCOIN)\n    # Print master key\n    print(\"Master key (bytes): %s\" % bip_obj_mst.PrivateKey().Raw().ToHex())\n    print(\"Master key (extended): %s\" % bip_obj_mst.PrivateKey().ToExtended())\n    print(\"Master key (WIF): %s\" % bip_obj_mst.PrivateKey().ToWif())\n\n    # Generate BIP44 account keys: m/44'/0'/0'\n    bip_obj_acc = bip_obj_mst.Purpose().Coin().Account(0)\n    # Generate BIP44 chain keys: m/44'/0'/0'/0\n    bip_obj_chain = bip_obj_acc.Change(Bip44Changes.CHAIN_EXT)\n\n    # Generate the address pool (first 20 addresses): m/44'/0'/0'/0/i\n    for i in range(20):\n        bip_obj_addr = bip_obj_chain.AddressIndex(i)\n        print(\"%d. Address public key (extended): %s\" % (i, bip_obj_addr.PublicKey().ToExtended()))\n        print(\"%d. Address private key (extended): %s\" % (i, bip_obj_addr.PrivateKey().ToExtended()))\n        print(\"%d. Address: %s\" % (i, bip_obj_addr.PublicKey().ToAddress()))\n\n# License\n\nThis software is available under the MIT license.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/ebellocchia/bip_utils/archive/v1.0.5.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ebellocchia/bip_utils", "keywords": "bitcoin,litecoin,dogecoin,dash,ethereum,ripple,wallet,hd-wallet,bip39,bip32,bip44,bip49,bip84,python", "license": "MIT", "maintainer": "Emanuele Bellocchia", "maintainer_email": "ebellocchia@gmail.com", "name": "bip-utils", "package_url": "https://pypi.org/project/bip-utils/", "platform": "any", "project_url": "https://pypi.org/project/bip-utils/", "project_urls": {"Download": "https://github.com/ebellocchia/bip_utils/archive/v1.0.5.tar.gz", "Homepage": "https://github.com/ebellocchia/bip_utils"}, "release_url": "https://pypi.org/project/bip-utils/1.0.5/", "requires_dist": null, "requires_python": ">=3.6", "summary": "Implementation of BIP39, BIP32, BIP44, BIP49 and BIP84 for wallet seeds, keys and addresses generation. Supported coins: Bitcoin, Litecoin, Dogecoin, Ethereum.", "version": "1.0.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>BIP utility library</h1>\n<p><a href=\"https://badge.fury.io/py/bip-utils\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3b8f9ac55efdaa308b39adf92726c8719b9db99e/68747470733a2f2f62616467652e667572792e696f2f70792f6269702d7574696c732e737667\"></a>\n<a href=\"https://travis-ci.com/ebellocchia/bip_utils\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/faad2269add9d9ff75c21f871630947888113c24/68747470733a2f2f7472617669732d63692e636f6d2f6562656c6c6f63636869612f6269705f7574696c732e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/ebellocchia/bip_utils\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2eaacb63a363fe806343be95e8125a95f0cf329a/68747470733a2f2f636f6465636f762e696f2f67682f6562656c6c6f63636869612f6269705f7574696c732f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://raw.githubusercontent.com/ebellocchia/bip_utils/master/LICENSE\" rel=\"nofollow\"><img alt=\"License: MIT\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8645b002dd7ec1b54275a80574942e7a318e03c6/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d79656c6c6f772e737667\"></a></p>\n<h2>Introduction</h2>\n<p>This package contains an implementation of some BIP (Bitcoin Improvement Proposal) specifications, allowing to:</p>\n<ul>\n<li>Generate a mnemonic string from a random entropy</li>\n<li>Generate a secure seed from the mnemonic string</li>\n<li>Use the seed to generate the master key of the wallet and derive the children keys, including address encoding</li>\n</ul>\n<p>The implemented BIP specifications are the following:</p>\n<ul>\n<li><a href=\"https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\" rel=\"nofollow\">BIP-0039</a> for mnemonic and seed generation</li>\n<li><a href=\"https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\" rel=\"nofollow\">BIP-0032</a> for master key generation (from the secure seed) and children keys derivation</li>\n<li><a href=\"https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki\" rel=\"nofollow\">BIP-0044</a>, <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki\" rel=\"nofollow\">BIP-0049</a> and <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki\" rel=\"nofollow\">BIP-0084</a> for the hierarchy of deterministic wallets, based on BIP-0032 specification</li>\n</ul>\n<p>In addition to this, the package allows to:</p>\n<ul>\n<li>Parse BIP-0032 derivation paths</li>\n<li>Generate P2PKH addresses (included in BIP-0044)</li>\n<li>Generate P2SH addresses (included in BIP-0049)</li>\n<li>Generate P2WPKH addresses (included in BIP-0084)</li>\n<li>Generate Ethereum addresses</li>\n<li>Generate Ripple addresses</li>\n<li>Encode/Decode <a href=\"https://en.bitcoin.it/wiki/Wallet_import_format\" rel=\"nofollow\">WIF</a></li>\n<li>Encode/Decode <a href=\"https://en.bitcoin.it/wiki/Base58Check_encoding#Background\" rel=\"nofollow\">base58</a></li>\n<li>Encode/Decode <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki\" rel=\"nofollow\">bech32</a></li>\n</ul>\n<p>The currently supported coins are:</p>\n<ul>\n<li>Bitcoin (and related test net)</li>\n<li>Litecoin (and related test net)</li>\n<li>Dogecoin (and related test net)</li>\n<li>Dash (and related test net)</li>\n<li>Ethereum</li>\n<li>Ripple</li>\n</ul>\n<h2>Install the package</h2>\n<p>The package requires Python 3, it is not compatible with Python 2.\nTo install it:</p>\n<ul>\n<li>\n<p>Using <em>setuptools</em>:</p>\n<pre><code>  python setup.py install\n</code></pre>\n</li>\n<li>\n<p>Using <em>pip</em>:</p>\n<pre><code>  pip install bip_utils\n</code></pre>\n</li>\n</ul>\n<p>To run the tests:</p>\n<ul>\n<li>\n<p>Without code coverage</p>\n<pre><code>  python setup.py test\n</code></pre>\n</li>\n<li>\n<p>With code coverage and report:</p>\n<pre><code>  pip install coverage\n  coverage run -m unittest discover\n  coverage report\n</code></pre>\n</li>\n</ul>\n<h2>BIP-0039 library</h2>\n<h3>Mnemonic generation</h3>\n<p>A mnemonic string can be generated by specifying the words number (in this case a random entropy will be used) or directly the entropy bytes.<br>\nSupported words number:</p>\n<ul>\n<li>12: <em>Bip39WordsNum.WORDS_NUM_12</em></li>\n<li>15: <em>Bip39WordsNum.WORDS_NUM_15</em></li>\n<li>18: <em>Bip39WordsNum.WORDS_NUM_18</em></li>\n<li>21: <em>Bip39WordsNum.WORDS_NUM_21</em></li>\n<li>24: <em>Bip39WordsNum.WORDS_NUM_24</em></li>\n</ul>\n<p>Supported entropy bits:</p>\n<ul>\n<li>128: <em>Bip39EntropyBitLen.BIT_LEN_128</em></li>\n<li>160: <em>Bip39EntropyBitLen.BIT_LEN_160</em></li>\n<li>192: <em>Bip39EntropyBitLen.BIT_LEN_192</em></li>\n<li>224: <em>Bip39EntropyBitLen.BIT_LEN_224</em></li>\n<li>256: <em>Bip39EntropyBitLen.BIT_LEN_256</em></li>\n</ul>\n<p><strong>NOTE:</strong> only the English words list is currently supported.</p>\n<p><strong>Code example</strong></p>\n<pre><code>import binascii\nfrom bip_utils import EntropyGenerator, Bip39MnemonicGenerator, Bip39WordsNum\n\n# Generate a random mnemonic string of 15 words\nmnemonic = Bip39MnemonicGenerator.FromWordsNumber(Bip39WordsNum.WORDS_NUM_15)\n\n# Generate the mnemonic string from entropy bytes:\nentropy_bytes_hex = b\"00000000000000000000000000000000\"\nmnemonic = Bip39MnemonicGenerator.FromEntropy(binascii.unhexlify(entropy_bytes_hex))\n\n# Generate mnemonic from random 192-bit entropy\nentropy_bytes = EntropyGenerator(Bip39EntropyBitLen.BIT_LEN_192).Generate()\nmnemonic = Bip39MnemonicGenerator.FromEntropy(entropy_bytes)\n</code></pre>\n<h3>Mnemonic validation</h3>\n<p>A mnemonic string can be validated by verifying its checksum.\nIt is also possible to get back the entropy bytes from a mnemonic.</p>\n<p><strong>Code example</strong></p>\n<pre><code> from bip_utils import Bip39MnemonicValidator\n\n # Get back the original entropy from a mnemonic string\n entropy_bytes = Bip39MnemonicValidator(mnemonic).GetEntropy()\n # Validate a mnemonic string by verifying its checksum\n is_valid = Bip39MnemonicValidator(mnemonic).Validate()\n</code></pre>\n<h3>Seed generation</h3>\n<p>A secure 64-byte seed is generated from a mnemonic and can be protected by a passphrase.<br>\nThis seed can be used to contruct a Bip class.</p>\n<p><strong>Code example</strong></p>\n<pre><code>from bip_utils import Bip39SeedGenerator\n\n# If not specified, the passphrase will be empty\npassphrase = \"my_passphrase\"\nseed_bytes = Bip39SeedGenerator(mnemonic).Generate(passphrase)\n</code></pre>\n<h2>BIP-0032 library</h2>\n<p>The BIP-0032 library is wrapped inside the BIP-0044, BIP-0049 and BIP-0084 libraries, so there is no need to use it alone unless you need to derive some non-standard paths.</p>\n<h3>Construction from a seed</h3>\n<p>The class can be constructed from a seed. The seed can be specified manually or generated by <em>Bip39SeedGenerator</em>.<br>\nThe constructed class is the master path, so printing the private key will result in printing the master key.</p>\n<p><strong>Code example</strong></p>\n<pre><code>import binascii\nfrom bip_utils import Bip32\n\n# Seed bytes\nseed_bytes = binascii.unhexlify(b\"5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4\")\n# Construct from seed. In case it's a test net, pass True as second parameter. Derivation path returned: m\nbip32_ctx = Bip32.FromSeed(seed_bytes)\n# Print master key in extended format\nprint(bip32_ctx.PrivateKey().ToExtended())\n</code></pre>\n<p>In addition to a seed, it's also possible to specify a derivation path.</p>\n<p><strong>Code example</strong></p>\n<pre><code># Derivation path returned: m/0'/1'/2\nbip32_ctx = Bip32.FromSeedAndPath(seed_bytes, \"m/0'/1'/2\")\n# Print private key for derivation path m/0'/1'/2 in extended format\nprint(bip32_ctx.PrivateKey().ToExtended())\n</code></pre>\n<h3>Construction from an extended key</h3>\n<p>Alternatively, the class can be constructed directly from an extended key.<br>\nThe object returned will be at the same depth of the specified key.</p>\n<p><strong>Code example</strong></p>\n<pre><code>from bip_utils import Bip32\n\n# Private extended key from derivation path m/0'/1 (depth 2)\nkey_str = \"xprv9wTYmMFdV23N2TdNG573QoEsfRrWKQgWeibmLntzniatZvR9BmLnvSxqu53Kw1UmYPxLgboyZQaXwTCg8MSY3H2EU4pWcQDnRnrVA1xe8fs\"\n# Construct from key (return object has depth 2)\nbip32_ctx = Bip32.FromExtendedKey(key_str)\n# Print keys\nprint(bip32_ctx.PrivateKey().ToExtended())\nprint(bip32_ctx.PublicKey().ToExtended())\n\n# Public extended key from derivation path m/0'/1 (depth 2)\nkey_str = \"xpub6ASuArnXKPbfEwhqN6e3mwBcDTgzisQN1wXN9BJcM47sSikHjJf3UFHKkNAWbWMiGj7Wf5uMash7SyYq527Hqck2AxYysAA7xmALppuCkwQ\"\n# Construct from key (return object has depth 2)\nbip32_ctx = Bip32.FromExtendedKey(key_str)\n# Print key\nprint(bip32_ctx.PublicKey().ToExtended())\n# Getting private key from a public-only object triggers a Bip32KeyError exception\n</code></pre>\n<h3>Keys derivation</h3>\n<p>Each time a key is derived, a new instance of the Bip32 class is returned. This allows to chain the methods call or save a specific key pair for future derivation.<br>\nThe <em>Bip32Utils.HardenIndex</em> method can be used to make an index hardened.</p>\n<p><strong>Code example</strong></p>\n<pre><code>import binascii\nfrom bip_utils import Bip32, Bip32Utils\n\n# Seed bytes\nseed_bytes = binascii.unhexlify(b\"5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4\")\n# Path: m\nbip32_ctx = Bip32.FromSeed(seed_bytes)\n# Derivation path: m/0'/1'/2/3\nbip32_ctx = bip32_ctx.ChildKey(Bip32Utils.HardenIndex(0)) \\\n                     .ChildKey(Bip32Utils.HardenIndex(1)) \\\n                     .ChildKey(2)                         \\\n                     .ChildKey(3)\n# Print keys in extended format\nprint(bip32_ctx.PrivateKey().ToExtended())\nprint(bip32_ctx.PublicKey().ToExtended())\n# Print keys in hex format\nprint(bip32_ctx.PrivateKey().Raw().ToHex())\nprint(bip32_ctx.PublicKey().RawCompressed().ToHex())\nprint(bip32_ctx.PublicKey().RawUncompressed().ToHex())\n# Print private key in WIF format\nprint(bip32_ctx.PrivateKey().ToWif())\n# Print public key converted to address\nprint(bip32_ctx.PublicKey().ToAddress())\n\n# Alternative: use DerivePath method\nbip32_ctx = Bip32.FromSeed(seed_bytes)\nbip32_ctx = bip32_ctx.DerivePath(\"0'/1'/2/3\")\n\n# DerivePath derives from the current depth, so it can be split\nbip32_ctx = Bip32.FromSeed(seed_bytes)\nbip32_ctx = bip32_ctx.DerivePath(\"0'/1'\")   # Derivation path: m/0'/1'\nbip32_ctx = bip32_ctx.DerivePath(\"2/3\")     # Derivation path: m/0'/1'/2/3\n</code></pre>\n<h3>Parse path</h3>\n<p>The Bip32 module allows also to parse derivation paths by returning the list of indexes in the path.<br>\nIn case of error, an empty list is returned.</p>\n<p><strong>Code example</strong></p>\n<pre><code>from bip_utils import Bip32PathParser\n\n# Print: [\"m\", 2147483648, 2147483649, 2]\nprint(Bip32PathParser.Parse(\"m/0'/1'/2\"))\n# Same but skipping the master. Print: [2147483648, 2147483649, 2]\nprint(Bip32PathParser.Parse(\"0'/1'/2\", True))\n# 'p' can be used as an alternative character instead of '\nprint(Bip32PathParser.Parse(\"m/0p/1p/2\"))\n# Error path: empty list returned. Print: []\nprint(Bip32PathParser.Parse(\"m/0'/abc/2\"))\n</code></pre>\n<h2>Bip-0044, BIP-0049, BIP-0084 libraries</h2>\n<p>These libraries derives all from the same base class, so they are used exactly in the same way.<br>\nTherefore, the following code examples can be used with the Bip44, Bip49 or Bip84 class.</p>\n<h3>Construction from a seed</h3>\n<p>A Bip class can be constructed from a seed, like Bip32. The seed can be specified manually or generated by <em>Bip39SeedGenerator</em>.</p>\n<p><strong>Code example</strong></p>\n<pre><code>import binascii\nfrom bip_utils import Bip44, Bip44Coins\n\n# Seed bytes\nseed_bytes = binascii.unhexlify(b\"5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4\")\n# Derivation path returned: m\n# In case it's a test net, pass True as second parameter\nbip44_ctx = Bip44.FromSeed(seed_bytes, Bip44Coins.BITCOIN)\n</code></pre>\n<h3>Construction from an extended key</h3>\n<p>Alternatively, a Bip class can be constructed directly from an extended key.<br>\nThe Bip object returned will be at the same depth of the specified key.</p>\n<p><strong>Code example</strong></p>\n<pre><code>from bip_utils import Bip44, Bip44Coins\n\n# Private extended key\nkey_str = \"xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHi\"\n# Construct from extended key\nbip44_ctx = Bip44.FromExtendedKey(key_str, Bip44Coins.BITCOIN)\n</code></pre>\n<h3>Keys derivation</h3>\n<p>Like Bip32, each time a key is derived a new instance of the Bip class is returned.<br>\nThe keys must be derived with the levels specified by BIP-0044:</p>\n<pre><code>m / purpose' / coin_type' / account' / change / address_index\n</code></pre>\n<p>using the correspondent methods. If keys are derived in the wrong level, a <em>RuntimeError</em> will be raised.<br>\nThe private and public extended keys can be printed at any level.</p>\n<p>Currently supported coins enumerative:</p>\n<ul>\n<li>Bitcoin (and related test net) : <em>Bip44Coins.BITCOIN, Bip44Coins.BITCOIN_TESTNET</em></li>\n<li>Litecoin (and related test net) : <em>Bip44Coins.LITECOIN, Bip44Coins.LITECOIN_TESTNET</em></li>\n<li>Dogecoin (and related test net) : <em>Bip44Coins.DOGECOIN, Bip44Coins.DOGECOIN_TESTNET</em></li>\n<li>Dash (and related test net) : <em>Bip44Coins.DASH, Bip44Coins.DASH_TESTNET</em></li>\n<li>Ethereum : <em>Bip44Coins.ETHEREUM</em></li>\n<li>Ripple : <em>Bip44Coins.RIPPLE</em></li>\n</ul>\n<p>The library can be easily extended with other coins anyway.</p>\n<p><strong>Code example</strong></p>\n<pre><code>import binascii\nfrom bip_utils import Bip44, Bip44Coins, Bip44Changes\n\n# Seed bytes\nseed_bytes = binascii.unhexlify(b\"5eb00bbddcf069084889a8ab9155568165f5c453ccb85e70811aaed6f6da5fc19a5ac40b389cd370d086206dec8aa6c43daea6690f20ad3d8d48b2d2ce9e38e4\")\n# Create from seed\nbip44_mst = Bip44.FromSeed(seed_bytes, Bip44Coins.BITCOIN)\n\n# Print master key in extended format\nprint(bip44_mst.PrivateKey().ToExtended())\n# Print master key in hex format\nprint(bip44_mst.PrivateKey().Raw().ToHex())\n\n# Print public key in extended format (default: Bip44PubKeyTypes.EXT_KEY)\nprint(bip44_mst.PublicKey())\n# Print public key in raw uncompressed format\nprint(bip44_mst.PublicKey().RawUncompressed().ToHex())\n# Print public key in raw compressed format\nprint(bip44_mst.PublicKey().RawCompressed().ToHex())\n\n# Print the master key in WIF\nprint(bip44_mst.IsMasterLevel())\nprint(bip44_mst.PrivateKey().ToWif())\n\n# Derive account 0 for Bitcoin: m/44'/0'/0'\nbip44_acc = bip44_mst.Purpose() \\\n                     .Coin()    \\\n                     .Account(0)\n# Print keys in extended format\nprint(bip44_acc.IsAccountLevel())\nprint(bip44_acc.PrivateKey().ToExtended())\nprint(bip44_acc.PublicKey().ToExtended())\n\n# Derive the external chain: m/44'/0'/0'/0\nbip44_change = bip44_acc.Change(Bip44Changes.CHAIN_EXT)\n# Print again keys in extended format\nprint(bip44_change.IsChangeLevel())\nprint(bip44_change.PrivateKey().ToExtended())\nprint(bip44_change.PublicKey().ToExtended())\n\n# Derive the first 20 addresses of the external chain: m/44'/0'/0'/0/i\nfor i in range(20):\n    bip44_addr = bip44_change.AddressIndex(i)\n    # Print extended keys and address\n    print(bip44_addr.PrivateKey().ToExtended())\n    print(bip44_addr.PublicKey().ToExtended())\n    print(bip44_addr.PublicKey().ToAddress())\n</code></pre>\n<p>In the example above, Bip44 can be substituted with Bip49 or Bip84 without changing the code.</p>\n<h2>Ethereum/Ripple addresses</h2>\n<p>These libraries are used internally by the other libraries, but they are available also for external use.</p>\n<p><strong>Code example</strong></p>\n<pre><code>from bip_utils import EthAddr, XrpAddr\n\n# Ethereum needs the uncompressed public key\naddr = EthAddr.ToAddress(pub_key_bytes)\n# Ripple needs the compressed public key\naddr = XrpAddr.ToAddress(pub_key_bytes)\n</code></pre>\n<h2>P2PKH/P2SH/P2WPKH addresses</h2>\n<p>These libraries are used internally by the other libraries, but they are available also for external use.</p>\n<p><strong>Code example</strong></p>\n<pre><code>from bip_utils import P2PKH, P2SH, P2WPKH\n\n# P2PKH addresses (the default uses Bitcoin network address version, you can pass a different one as second parameter)\naddr = P2PKH.ToAddress(pub_key_bytes)\n# P2SH addresses (the default uses Bitcoin network address version, you can pass a different one as second parameter)\naddr = P2SH.ToAddress(pub_key_bytes)\n# P2WPKH addresses (the default uses Bitcoin network address version, you can pass a different one as second parameter)\naddr = P2WPKH.ToAddress(pub_key_bytes)\n</code></pre>\n<h2>WIF</h2>\n<p>This library is used internally by the other libraries, but it's available also for external use.</p>\n<p><strong>Code example</strong></p>\n<pre><code>import binascii\nfrom bip_utils import WifDecoder, WifEncoder\n\nkey_bytes = binascii.unhexlify(b'1837c1be8e2995ec11cda2b066151be2cfb48adf9e47b151d46adab3a21cdf67')\n\n# Encode\nenc = WifEncoder.Encode(key_bytes)\n# Decode\ndec = WifDecoder.Decode(enc)\n</code></pre>\n<h2>Base58</h2>\n<p>This library is used internally by the other libraries, but it's available also for external use.<br>\nIt supports both normal encode/decode and check_encode/check_decode with Bitcoin and Ripple alphabets (if not specified, the Bitcoin one will be used by default).</p>\n<p><strong>Code example</strong></p>\n<pre><code>import binascii\nfrom bip_utils import Base58Decoder, Base58Encoder, Base58Alphabets\n\ndata_bytes = binascii.unhexlify(b\"636363\")\n\n# Normal encode\nenc     = Base58Encoder.Encode(data_bytes)\n# Check encode\nchk_enc = Base58Encoder.CheckEncode(data_bytes)\n\n# Normal decode\ndec     = Base58Decoder.Decode(enc)\n# Check decode, RuntimeError is raised if checksum verification fails\nchk_dec = Base58Decoder.CheckDecode(chk_enc)\n\n# Same as before with Ripple alphabet\nenc     = Base58Encoder.Encode(data_bytes, Base58Alphabets.RIPPLE)\nchk_enc = Base58Encoder.CheckEncode(data_bytes, Base58Alphabets.RIPPLE)\ndec     = Base58Decoder.Decode(enc, Base58Alphabets.RIPPLE)\nchk_dec = Base58Decoder.CheckDecode(chk_enc, Base58Alphabets.RIPPLE)\n</code></pre>\n<h2>Bech32</h2>\n<p>This library is used internally by the other libraries, but it's available also for external use.</p>\n<p><strong>Code example</strong></p>\n<pre><code>import binascii\nfrom bip_utils import Bech32Decoder, Bech32Encoder\n\ndata_bytes = binascii.unhexlify(b'9c90f934ea51fa0f6504177043e0908da6929983')\n\n# Encode\nenc = Bech32Encoder.EncodeAddr(\"bc\", 0, data_bytes)\n# Decode\ndec = Bech32Decoder.DecodeAddr(\"bc\", enc)\n</code></pre>\n<h2>Complete code example</h2>\n<p>Example from mnemonic generation to wallet addresses.</p>\n<pre><code>from bip_utils import Bip39MnemonicGenerator, Bip39SeedGenerator, Bip44, Bip44Coins, Bip44Changes\n\n# Generate random mnemonic\nmnemonic = Bip39MnemonicGenerator.FromWordsNumber(12)\nprint(\"Mnemonic string: %s\" % mnemonic)\n# Generate seed from mnemonic\nseed_bytes = Bip39SeedGenerator(mnemonic).Generate()\n\n# Generate BIP44 master keys\nbip_obj_mst = Bip44.FromSeed(seed_bytes, Bip44Coins.BITCOIN)\n# Print master key\nprint(\"Master key (bytes): %s\" % bip_obj_mst.PrivateKey().Raw().ToHex())\nprint(\"Master key (extended): %s\" % bip_obj_mst.PrivateKey().ToExtended())\nprint(\"Master key (WIF): %s\" % bip_obj_mst.PrivateKey().ToWif())\n\n# Generate BIP44 account keys: m/44'/0'/0'\nbip_obj_acc = bip_obj_mst.Purpose().Coin().Account(0)\n# Generate BIP44 chain keys: m/44'/0'/0'/0\nbip_obj_chain = bip_obj_acc.Change(Bip44Changes.CHAIN_EXT)\n\n# Generate the address pool (first 20 addresses): m/44'/0'/0'/0/i\nfor i in range(20):\n    bip_obj_addr = bip_obj_chain.AddressIndex(i)\n    print(\"%d. Address public key (extended): %s\" % (i, bip_obj_addr.PublicKey().ToExtended()))\n    print(\"%d. Address private key (extended): %s\" % (i, bip_obj_addr.PrivateKey().ToExtended()))\n    print(\"%d. Address: %s\" % (i, bip_obj_addr.PublicKey().ToAddress()))\n</code></pre>\n<h1>License</h1>\n<p>This software is available under the MIT license.</p>\n\n          </div>"}, "last_serial": 7119099, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "8ef3daacc0a727f54ec6950541d0cad5", "sha256": "b88917ef7eb077a3434df9d54e4b07fa0a619396bdee8ce4bb38ea839ec4734d"}, "downloads": -1, "filename": "bip_utils-0.1.0-py3.8.egg", "has_sig": false, "md5_digest": "8ef3daacc0a727f54ec6950541d0cad5", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": ">=3.6", "size": 65762, "upload_time": "2020-03-29T20:54:30", "upload_time_iso_8601": "2020-03-29T20:54:30.700610Z", "url": "https://files.pythonhosted.org/packages/e9/43/7117bbb470fd85932cfe4033987500e1dfd616e39df634e2ffae3c6eccd4/bip_utils-0.1.0-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "b52133a8a140f00856d31962b8ce244b", "sha256": "0847d5b63272f2ac2df309701674f4287825eed36387540cbd8ab5672888233d"}, "downloads": -1, "filename": "bip_utils-0.1.0.tar.gz", "has_sig": false, "md5_digest": "b52133a8a140f00856d31962b8ce244b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 30340, "upload_time": "2020-03-29T20:45:26", "upload_time_iso_8601": "2020-03-29T20:45:26.954290Z", "url": "https://files.pythonhosted.org/packages/50/0b/97fb73670ec30de73cdbc596e2694df3a0851e540f63a99ff6602f6fd091/bip_utils-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "643cc2752f3c5d2ec6b80fac64575ffe", "sha256": "be8ef3513aa92c3786e2362d0034c7de0ade357810b54367e62162d417949925"}, "downloads": -1, "filename": "bip_utils-0.1.1.tar.gz", "has_sig": false, "md5_digest": "643cc2752f3c5d2ec6b80fac64575ffe", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 30359, "upload_time": "2020-03-29T20:54:32", "upload_time_iso_8601": "2020-03-29T20:54:32.858781Z", "url": "https://files.pythonhosted.org/packages/4a/8e/76090b6211714d63544103b9c89fd242a7d33c5e371c546fc0a17b902c13/bip_utils-0.1.1.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "a403f65f1f759dc75c99bc38d57704e5", "sha256": "4bb82ba6986430867bef717e8d486b920019160e0e36d5db02b6ee490abba0b6"}, "downloads": -1, "filename": "bip_utils-0.2.0-py3.8.egg", "has_sig": false, "md5_digest": "a403f65f1f759dc75c99bc38d57704e5", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": ">=3.6", "size": 68416, "upload_time": "2020-03-31T17:41:35", "upload_time_iso_8601": "2020-03-31T17:41:35.465399Z", "url": "https://files.pythonhosted.org/packages/fa/90/2fa3c7ab7789cb7c937edd67ba12b210782fe396cf8becb22f5ba6184a23/bip_utils-0.2.0-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "8cb91e5fd1ae6604878bd171596be19a", "sha256": "74c2ce8a8c0f70d125698f4e5e0f64030dddb3c76acf0bdaa116374d6f4d3bea"}, "downloads": -1, "filename": "bip_utils-0.2.0.tar.gz", "has_sig": false, "md5_digest": "8cb91e5fd1ae6604878bd171596be19a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 33148, "upload_time": "2020-03-31T17:41:36", "upload_time_iso_8601": "2020-03-31T17:41:36.486721Z", "url": "https://files.pythonhosted.org/packages/bd/b5/e80eb9bf9597b3a9a6bc576623eb156572719576487c3523731ca64fc214/bip_utils-0.2.0.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "2fb66f371b6a8764091055ab8a19ca31", "sha256": "39448e141872e2d7f274bcf41ff7d5a148c075709b06062dc93eea33d2a2fe00"}, "downloads": -1, "filename": "bip_utils-0.3.0-py3.8.egg", "has_sig": false, "md5_digest": "2fb66f371b6a8764091055ab8a19ca31", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": ">=3.6", "size": 88996, "upload_time": "2020-04-06T18:51:54", "upload_time_iso_8601": "2020-04-06T18:51:54.792369Z", "url": "https://files.pythonhosted.org/packages/cd/a0/04f7f0bf5096512ef7453f7e55a43ededbc37b0fc1e86c3cf83b27415e7a/bip_utils-0.3.0-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "0b01eb5b4086df6e7aaf8d1c5a562241", "sha256": "eb34de3636db20504a6601f372aeec5f991bb8c04d462a8af12bc91425c5a64a"}, "downloads": -1, "filename": "bip_utils-0.3.0.tar.gz", "has_sig": false, "md5_digest": "0b01eb5b4086df6e7aaf8d1c5a562241", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 37068, "upload_time": "2020-04-06T18:51:56", "upload_time_iso_8601": "2020-04-06T18:51:56.509108Z", "url": "https://files.pythonhosted.org/packages/d4/eb/d73af0d4a6b93f7791b71d66b69404d8864d0ae6a40da9bc92d70a6e18c9/bip_utils-0.3.0.tar.gz", "yanked": false}], "0.3.0a0": [{"comment_text": "", "digests": {"md5": "ac198d38f11a0d5464a1990ad37c1e31", "sha256": "76ae62741d0af475f0394a69c0aaf6c711baa65e2c84d134c32d319d55dae5d3"}, "downloads": -1, "filename": "bip_utils-0.3.0a0-py3.8.egg", "has_sig": false, "md5_digest": "ac198d38f11a0d5464a1990ad37c1e31", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": ">=3.6", "size": 82635, "upload_time": "2020-04-06T18:51:57", "upload_time_iso_8601": "2020-04-06T18:51:57.832226Z", "url": "https://files.pythonhosted.org/packages/c1/a9/8695b2f337b32de7b853496f033e074c6b231af50ece6efe5144400ef382/bip_utils-0.3.0a0-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "6e6fb1e6f43d7d84bf9de36cd3741fad", "sha256": "722cffcfc1ba5a7e134bfacf37ffee3b9e409184a7f76c0839b5cb6e1344791d"}, "downloads": -1, "filename": "bip_utils-0.3.0a0.tar.gz", "has_sig": false, "md5_digest": "6e6fb1e6f43d7d84bf9de36cd3741fad", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 35664, "upload_time": "2020-04-06T18:51:59", "upload_time_iso_8601": "2020-04-06T18:51:59.370516Z", "url": "https://files.pythonhosted.org/packages/ce/43/01df2a5d24a48b6e7f2b605e5810108b65cfcd8ab946b6aa695e486a1491/bip_utils-0.3.0a0.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "1422cc0497b60bf1882c082c2df12e71", "sha256": "1d55a7156221f4d545d6f7a5de5ffb7685197a38352156046963dc1f92adc8f3"}, "downloads": -1, "filename": "bip_utils-0.4.0.tar.gz", "has_sig": false, "md5_digest": "1422cc0497b60bf1882c082c2df12e71", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 39057, "upload_time": "2020-04-08T12:08:47", "upload_time_iso_8601": "2020-04-08T12:08:47.003458Z", "url": "https://files.pythonhosted.org/packages/76/e1/3c063d1056757cc68e4af70f501528d74ab632f3aaa4847b53ec96b3f356/bip_utils-0.4.0.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "e6cc670fd1a7bda3c9b53b1c15b499f5", "sha256": "1751641f4af71f4aba7d07c4f4ca6cc9bf2a05d83a253b9d9ea9ba626a575eba"}, "downloads": -1, "filename": "bip_utils-0.5.0.tar.gz", "has_sig": false, "md5_digest": "e6cc670fd1a7bda3c9b53b1c15b499f5", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 40354, "upload_time": "2020-04-10T13:16:09", "upload_time_iso_8601": "2020-04-10T13:16:09.911580Z", "url": "https://files.pythonhosted.org/packages/e9/7d/9d13e769621cb1fb6612bf650f96e42b2cb741ed216c21659a54c0dc0cbc/bip_utils-0.5.0.tar.gz", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "acc602c2a65afc760bfff2fa6e5269f0", "sha256": "46fc17c7f79caee96fff878bc536d61c5b5fb4e137f21ef0811977f085298676"}, "downloads": -1, "filename": "bip_utils-0.5.1.tar.gz", "has_sig": false, "md5_digest": "acc602c2a65afc760bfff2fa6e5269f0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 40981, "upload_time": "2020-04-10T17:20:07", "upload_time_iso_8601": "2020-04-10T17:20:07.314782Z", "url": "https://files.pythonhosted.org/packages/a3/4d/5dcc9e2be47c29f22d4adda078f949b1c29f552d9c01cb6b91ab9a3cea86/bip_utils-0.5.1.tar.gz", "yanked": false}], "0.5.2": [{"comment_text": "", "digests": {"md5": "77fadbf7aa5e7fdd33395df4e9d90119", "sha256": "096530f43d2e458cb29d6244a4712d77a236e61654d7345ff45660f95c811403"}, "downloads": -1, "filename": "bip_utils-0.5.2.tar.gz", "has_sig": false, "md5_digest": "77fadbf7aa5e7fdd33395df4e9d90119", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 41109, "upload_time": "2020-04-11T18:54:55", "upload_time_iso_8601": "2020-04-11T18:54:55.039030Z", "url": "https://files.pythonhosted.org/packages/19/a9/7dd3c27a620c690ce3c2a0a15cb887398f952ff60bbbacb2f95deb5eeccb/bip_utils-0.5.2.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "1d94eb28cd164a4b1e7f8a9d36f21ef2", "sha256": "23a00e22407aff3de45d67857da9f1c87cb7227f45e661d45f7f22383521366a"}, "downloads": -1, "filename": "bip_utils-1.0.0.tar.gz", "has_sig": false, "md5_digest": "1d94eb28cd164a4b1e7f8a9d36f21ef2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 43318, "upload_time": "2020-04-16T20:07:36", "upload_time_iso_8601": "2020-04-16T20:07:36.764034Z", "url": "https://files.pythonhosted.org/packages/f1/32/7dd61201c6defc1ab9b6d9a8ed51cb674452e3a10cdecf644a4e3dbb3847/bip_utils-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "d9c57a18adf2b0e6bf0091fea9e30e30", "sha256": "ec883f96529d5fc333bf85975418b005bb175579aec35d97dd944e1dd15cbd04"}, "downloads": -1, "filename": "bip_utils-1.0.1.tar.gz", "has_sig": false, "md5_digest": "d9c57a18adf2b0e6bf0091fea9e30e30", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 43397, "upload_time": "2020-04-17T13:03:31", "upload_time_iso_8601": "2020-04-17T13:03:31.898053Z", "url": "https://files.pythonhosted.org/packages/17/d2/a275cea79a4dd83ff29ace9e6a09053a06d93651c4f452dae94e4aa69d32/bip_utils-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "fca7ed45d40408e0bd82c5372c1fa2c9", "sha256": "8b4e544a7ff8fc0efa5bbd5758004a18c40ded7e6905c36b682b48f6d4d53f0e"}, "downloads": -1, "filename": "bip_utils-1.0.2.tar.gz", "has_sig": false, "md5_digest": "fca7ed45d40408e0bd82c5372c1fa2c9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 43512, "upload_time": "2020-04-18T09:31:32", "upload_time_iso_8601": "2020-04-18T09:31:32.147310Z", "url": "https://files.pythonhosted.org/packages/b6/5a/e7fe9f6d1030cb2b466f42a1049bf06ad8259272c9726f9bc7fac59aaea2/bip_utils-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "230501ec51cb6de8323c8d183cbc4e29", "sha256": "23b1f15d0a7ad013cb91eaae6e8cd5dd737d73a4bb3b1bc5391de720452e1c43"}, "downloads": -1, "filename": "bip_utils-1.0.3.tar.gz", "has_sig": false, "md5_digest": "230501ec51cb6de8323c8d183cbc4e29", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 43803, "upload_time": "2020-04-21T06:43:34", "upload_time_iso_8601": "2020-04-21T06:43:34.214027Z", "url": "https://files.pythonhosted.org/packages/1d/7a/1270d2ccec35d9e26683a89d711bc3fcfcdeda502225c71442a1dab6c1f6/bip_utils-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "6907c6c56df2315282c58ccf73da10b6", "sha256": "3e5a0b4d7df26a560fa8690da774c094388b3a3eb6c503fa32a27d63f5ac27b5"}, "downloads": -1, "filename": "bip_utils-1.0.4.tar.gz", "has_sig": false, "md5_digest": "6907c6c56df2315282c58ccf73da10b6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 44509, "upload_time": "2020-04-27T20:29:46", "upload_time_iso_8601": "2020-04-27T20:29:46.074543Z", "url": "https://files.pythonhosted.org/packages/68/f3/acebfeb55e5911806000cf6589103fbb920fdacd5c521dee8ad45a3e726f/bip_utils-1.0.4.tar.gz", "yanked": false}], "1.0.5": [{"comment_text": "", "digests": {"md5": "6bf6636c25e91948a6617cc938c6e875", "sha256": "12acb0f802ad513cfa965a71ed88e041cae042eeb9fab3e61902b2a79b056198"}, "downloads": -1, "filename": "bip_utils-1.0.5-py3.8.egg", "has_sig": false, "md5_digest": "6bf6636c25e91948a6617cc938c6e875", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": ">=3.6", "size": 117186, "upload_time": "2020-04-28T10:46:51", "upload_time_iso_8601": "2020-04-28T10:46:51.012257Z", "url": "https://files.pythonhosted.org/packages/f8/15/d013976f19527521f5284f9d89307d839e20b428ec31cbb4fcbe6b4e42f6/bip_utils-1.0.5-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "3a84e3253da4009f406d38a2445c352f", "sha256": "e8397a315c2f656ccf37ff1c43f5e0d496a10ea692c614fdf9bae1a3d5de3558"}, "downloads": -1, "filename": "bip_utils-1.0.5.tar.gz", "has_sig": false, "md5_digest": "3a84e3253da4009f406d38a2445c352f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 44827, "upload_time": "2020-04-28T10:46:52", "upload_time_iso_8601": "2020-04-28T10:46:52.222519Z", "url": "https://files.pythonhosted.org/packages/7e/8e/f2218e9939da2687f68bf4e52a3714c933cd95d2468d0106d78552ac24f4/bip_utils-1.0.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6bf6636c25e91948a6617cc938c6e875", "sha256": "12acb0f802ad513cfa965a71ed88e041cae042eeb9fab3e61902b2a79b056198"}, "downloads": -1, "filename": "bip_utils-1.0.5-py3.8.egg", "has_sig": false, "md5_digest": "6bf6636c25e91948a6617cc938c6e875", "packagetype": "bdist_egg", "python_version": "3.8", "requires_python": ">=3.6", "size": 117186, "upload_time": "2020-04-28T10:46:51", "upload_time_iso_8601": "2020-04-28T10:46:51.012257Z", "url": "https://files.pythonhosted.org/packages/f8/15/d013976f19527521f5284f9d89307d839e20b428ec31cbb4fcbe6b4e42f6/bip_utils-1.0.5-py3.8.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "3a84e3253da4009f406d38a2445c352f", "sha256": "e8397a315c2f656ccf37ff1c43f5e0d496a10ea692c614fdf9bae1a3d5de3558"}, "downloads": -1, "filename": "bip_utils-1.0.5.tar.gz", "has_sig": false, "md5_digest": "3a84e3253da4009f406d38a2445c352f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 44827, "upload_time": "2020-04-28T10:46:52", "upload_time_iso_8601": "2020-04-28T10:46:52.222519Z", "url": "https://files.pythonhosted.org/packages/7e/8e/f2218e9939da2687f68bf4e52a3714c933cd95d2468d0106d78552ac24f4/bip_utils-1.0.5.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:37:22 2020"}