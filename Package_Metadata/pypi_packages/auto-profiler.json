{"info": {"author": "modaresi mr", "author_email": "modaresimr+git@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# auto_profiler\n\nA timer for profiling a Python function or snippet.\n\n## Features\n- Filtering external libraries profiling.\n- Filtering very short time functions-> threshold\n- Allow depth: you can easily find the time consuming function\n- Allow loop or multiple function call\n- Allow recursive function call\n- Disable it globaly by Profiler.GlobalDisable=True to save time :)\n## Installation\n\nRelease version:\n\n```bash\n$ pip install auto_profiler\n```\n\nDevelopment version:\n\n```bash\n$ pip install -e git+https://github.com/modaresimr/auto_profiler.git#egg=auto_profiler\n```\n\n\n## Quick start\n\n### Auto profiling\nMore commonly, chances are that we want to measure the execution time of an entry function and all its subfunctions. In this case, it's too tedious to do it manually, and we can leverage `Profiler` to inject all the timing points for us automatically:\n\n```python\nimport time # line number 1\nimport random\n\nfrom auto_profiler import Profiler, Tree\n\ndef f1():\n    mysleep(.6+random.random())\n\ndef mysleep(t):\n    time.sleep(t)\n\ndef fact(i):\n    f1()\n    if(i==1):\n        return 1\n    return i*fact(i-1)\n\n\ndef show(p):\n    print('Time   [Hits * PerHit] Function name [Called from] [Function Location]\\n'+\\\n          '-----------------------------------------------------------------------')\n    print(Tree(p.root, threshold=0.5))\n\n@Profiler(depth=4, on_disable=show)\ndef main():\n    for i in range(5):\n        f1()\n\n    fact(3)\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n#### Example Output\n```\n\nTime   [Hits * PerHit] Function name [Called from] [function location]\n-----------------------------------------------------------------------\n8.974s [1 * 8.974]  main  [auto-profiler/profiler.py:267]  [/test/t2.py:30]\n\u251c\u2500\u2500 5.954s [5 * 1.191]  f1  [/test/t2.py:34]  [/test/t2.py:14]\n\u2502   \u2514\u2500\u2500 5.954s [5 * 1.191]  mysleep  [/test/t2.py:15]  [/test/t2.py:17]\n\u2502       \u2514\u2500\u2500 5.954s [5 * 1.191]  <time.sleep>\n|\n|\n|   # The rest is for the example recursive function call fact\n\u2514\u2500\u2500 3.020s [1 * 3.020]  fact  [/test/t2.py:36]  [/test/t2.py:20]\n    \u251c\u2500\u2500 0.849s [1 * 0.849]  f1  [/test/t2.py:21]  [/test/t2.py:14]\n    \u2502   \u2514\u2500\u2500 0.849s [1 * 0.849]  mysleep  [/test/t2.py:15]  [/test/t2.py:17]\n    \u2502       \u2514\u2500\u2500 0.849s [1 * 0.849]  <time.sleep>\n    \u2514\u2500\u2500 2.171s [1 * 2.171]  fact  [/test/t2.py:24]  [/test/t2.py:20]\n        \u251c\u2500\u2500 1.552s [1 * 1.552]  f1  [/test/t2.py:21]  [/test/t2.py:14]\n        \u2502   \u2514\u2500\u2500 1.552s [1 * 1.552]  mysleep  [/test/t2.py:15]  [/test/t2.py:17]\n        \u2514\u2500\u2500 0.619s [1 * 0.619]  fact  [/test/t2.py:24]  [/test/t2.py:20]\n            \u2514\u2500\u2500 0.619s [1 * 0.619]  f1  [/test/t2.py:21]  [/test/t2.py:14]\n```\n\n### Manual profiling\n\nSometimes, we only want to measure the execution time of partial snippets or a few functions, then we can inject all timing points into our code manually by leveraging `Timer`:\n\n```python\n\n# manual_example.py\n\nimport time\n\nfrom auto_profiler import Timer, Tree\n\n\ndef main():\n    t = Timer('sleep1', parent_name='main').start()\n    time.sleep(1)\n    t.stop()\n\n    t = Timer('sleep2', parent_name='main').start()\n    time.sleep(1.5)\n    t.stop()\n\n    print(Tree(Timer.root))\n\n\nif __name__ == '__main__':\n    main()\n```\n\nRun the example code:\n\n```bash\n$ python manual_example.py\n```\n\nand it will show you the profiling result:\n\n```\n2.503s  main\n\u251c\u2500\u2500 1.001s  sleep1\n\u2514\u2500\u2500 1.501s  sleep2\n\n```\n\n## Supported frameworks\n\nWhile you can do profiling on normal Python code, as a web developer, chances are that you will usually do profiling on web service code.\n\nCurrently supported web frameworks:\n\n- [Flask](http://flask.pocoo.org/)\n\n\n## Examples\n\nFor profiling web service code (involving web requests), check out [examples](examples).\n\n\n## License\n\n[MIT](http://opensource.org/licenses/MIT)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/modaresimr/auto_profiler", "keywords": "Profiling,Timer,Python,Auto prfiling,line profiler", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "auto-profiler", "package_url": "https://pypi.org/project/auto-profiler/", "platform": "", "project_url": "https://pypi.org/project/auto-profiler/", "project_urls": {"Homepage": "https://github.com/modaresimr/auto_profiler"}, "release_url": "https://pypi.org/project/auto-profiler/1.4/", "requires_dist": ["monotonic (>=1.3)", "six (>=1.10.0)", "tree-format (==0.1.1)"], "requires_python": "", "summary": "A timer for profiling a Python function or snippet.", "version": "1.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>auto_profiler</h1>\n<p>A timer for profiling a Python function or snippet.</p>\n<h2>Features</h2>\n<ul>\n<li>Filtering external libraries profiling.</li>\n<li>Filtering very short time functions-&gt; threshold</li>\n<li>Allow depth: you can easily find the time consuming function</li>\n<li>Allow loop or multiple function call</li>\n<li>Allow recursive function call</li>\n<li>Disable it globaly by Profiler.GlobalDisable=True to save time :)</li>\n</ul>\n<h2>Installation</h2>\n<p>Release version:</p>\n<pre>$ pip install auto_profiler\n</pre>\n<p>Development version:</p>\n<pre>$ pip install -e git+https://github.com/modaresimr/auto_profiler.git#egg<span class=\"o\">=</span>auto_profiler\n</pre>\n<h2>Quick start</h2>\n<h3>Auto profiling</h3>\n<p>More commonly, chances are that we want to measure the execution time of an entry function and all its subfunctions. In this case, it's too tedious to do it manually, and we can leverage <code>Profiler</code> to inject all the timing points for us automatically:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">time</span> <span class=\"c1\"># line number 1</span>\n<span class=\"kn\">import</span> <span class=\"nn\">random</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">auto_profiler</span> <span class=\"kn\">import</span> <span class=\"n\">Profiler</span><span class=\"p\">,</span> <span class=\"n\">Tree</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">f1</span><span class=\"p\">():</span>\n    <span class=\"n\">mysleep</span><span class=\"p\">(</span><span class=\"o\">.</span><span class=\"mi\">6</span><span class=\"o\">+</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">())</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">mysleep</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">):</span>\n    <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">fact</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">):</span>\n    <span class=\"n\">f1</span><span class=\"p\">()</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">==</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span>\n    <span class=\"k\">return</span> <span class=\"n\">i</span><span class=\"o\">*</span><span class=\"n\">fact</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">show</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Time   [Hits * PerHit] Function name [Called from] [Function Location]</span><span class=\"se\">\\n</span><span class=\"s1\">'</span><span class=\"o\">+</span>\\\n          <span class=\"s1\">'-----------------------------------------------------------------------'</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">Tree</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"p\">,</span> <span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">))</span>\n\n<span class=\"nd\">@Profiler</span><span class=\"p\">(</span><span class=\"n\">depth</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">on_disable</span><span class=\"o\">=</span><span class=\"n\">show</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">):</span>\n        <span class=\"n\">f1</span><span class=\"p\">()</span>\n\n    <span class=\"n\">fact</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n<h4>Example Output</h4>\n<pre><code>\nTime   [Hits * PerHit] Function name [Called from] [function location]\n-----------------------------------------------------------------------\n8.974s [1 * 8.974]  main  [auto-profiler/profiler.py:267]  [/test/t2.py:30]\n\u251c\u2500\u2500 5.954s [5 * 1.191]  f1  [/test/t2.py:34]  [/test/t2.py:14]\n\u2502   \u2514\u2500\u2500 5.954s [5 * 1.191]  mysleep  [/test/t2.py:15]  [/test/t2.py:17]\n\u2502       \u2514\u2500\u2500 5.954s [5 * 1.191]  &lt;time.sleep&gt;\n|\n|\n|   # The rest is for the example recursive function call fact\n\u2514\u2500\u2500 3.020s [1 * 3.020]  fact  [/test/t2.py:36]  [/test/t2.py:20]\n    \u251c\u2500\u2500 0.849s [1 * 0.849]  f1  [/test/t2.py:21]  [/test/t2.py:14]\n    \u2502   \u2514\u2500\u2500 0.849s [1 * 0.849]  mysleep  [/test/t2.py:15]  [/test/t2.py:17]\n    \u2502       \u2514\u2500\u2500 0.849s [1 * 0.849]  &lt;time.sleep&gt;\n    \u2514\u2500\u2500 2.171s [1 * 2.171]  fact  [/test/t2.py:24]  [/test/t2.py:20]\n        \u251c\u2500\u2500 1.552s [1 * 1.552]  f1  [/test/t2.py:21]  [/test/t2.py:14]\n        \u2502   \u2514\u2500\u2500 1.552s [1 * 1.552]  mysleep  [/test/t2.py:15]  [/test/t2.py:17]\n        \u2514\u2500\u2500 0.619s [1 * 0.619]  fact  [/test/t2.py:24]  [/test/t2.py:20]\n            \u2514\u2500\u2500 0.619s [1 * 0.619]  f1  [/test/t2.py:21]  [/test/t2.py:14]\n</code></pre>\n<h3>Manual profiling</h3>\n<p>Sometimes, we only want to measure the execution time of partial snippets or a few functions, then we can inject all timing points into our code manually by leveraging <code>Timer</code>:</p>\n<pre><span class=\"c1\"># manual_example.py</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">auto_profiler</span> <span class=\"kn\">import</span> <span class=\"n\">Timer</span><span class=\"p\">,</span> <span class=\"n\">Tree</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">Timer</span><span class=\"p\">(</span><span class=\"s1\">'sleep1'</span><span class=\"p\">,</span> <span class=\"n\">parent_name</span><span class=\"o\">=</span><span class=\"s1\">'main'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n    <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">stop</span><span class=\"p\">()</span>\n\n    <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">Timer</span><span class=\"p\">(</span><span class=\"s1\">'sleep2'</span><span class=\"p\">,</span> <span class=\"n\">parent_name</span><span class=\"o\">=</span><span class=\"s1\">'main'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n    <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">1.5</span><span class=\"p\">)</span>\n    <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">stop</span><span class=\"p\">()</span>\n\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">Tree</span><span class=\"p\">(</span><span class=\"n\">Timer</span><span class=\"o\">.</span><span class=\"n\">root</span><span class=\"p\">))</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n<p>Run the example code:</p>\n<pre>$ python manual_example.py\n</pre>\n<p>and it will show you the profiling result:</p>\n<pre><code>2.503s  main\n\u251c\u2500\u2500 1.001s  sleep1\n\u2514\u2500\u2500 1.501s  sleep2\n\n</code></pre>\n<h2>Supported frameworks</h2>\n<p>While you can do profiling on normal Python code, as a web developer, chances are that you will usually do profiling on web service code.</p>\n<p>Currently supported web frameworks:</p>\n<ul>\n<li><a href=\"http://flask.pocoo.org/\" rel=\"nofollow\">Flask</a></li>\n</ul>\n<h2>Examples</h2>\n<p>For profiling web service code (involving web requests), check out <a href=\"examples\" rel=\"nofollow\">examples</a>.</p>\n<h2>License</h2>\n<p><a href=\"http://opensource.org/licenses/MIT\" rel=\"nofollow\">MIT</a></p>\n\n          </div>"}, "last_serial": 6616281, "releases": {"1.3": [{"comment_text": "", "digests": {"md5": "0f58a61eea91ebf39bc33d29f02a86c3", "sha256": "2e55c3e60907fb0ce900ddd4f1030324970c1bdca093293a531478e29406f74c"}, "downloads": -1, "filename": "auto_profiler-1.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "0f58a61eea91ebf39bc33d29f02a86c3", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15301, "upload_time": "2020-02-12T11:22:36", "upload_time_iso_8601": "2020-02-12T11:22:36.983164Z", "url": "https://files.pythonhosted.org/packages/49/68/b7fd8e0d73009ae238e670d9cdc68ed1ab54226c2f6744d936f1e998b961/auto_profiler-1.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b06529e4376315820534f4a4bac60da1", "sha256": "74998fc55f973f891988d69768ae789c20eeef073aa7ba1830435fca9a1881cd"}, "downloads": -1, "filename": "auto_profiler-1.3-py3-none-any.whl", "has_sig": false, "md5_digest": "b06529e4376315820534f4a4bac60da1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15298, "upload_time": "2020-02-12T11:22:39", "upload_time_iso_8601": "2020-02-12T11:22:39.367185Z", "url": "https://files.pythonhosted.org/packages/3a/cb/df6258af0ac54e53feeacbc2b26a2d5562d71cb04a2a96655ca48ef4a86f/auto_profiler-1.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ec9bf4895aae7fe9c908d20cc4482eed", "sha256": "27b620041f5b26b32d967113d77d1b3b7e566ca9f4a74cfd3df936dffabb1e18"}, "downloads": -1, "filename": "auto_profiler-1.3.tar.gz", "has_sig": false, "md5_digest": "ec9bf4895aae7fe9c908d20cc4482eed", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8436, "upload_time": "2020-02-12T11:22:40", "upload_time_iso_8601": "2020-02-12T11:22:40.972190Z", "url": "https://files.pythonhosted.org/packages/8b/61/61ecd146db2d9fb82db1f3e48c77fbfdded95995c28a20a054f0b66e5a47/auto_profiler-1.3.tar.gz", "yanked": false}], "1.4": [{"comment_text": "", "digests": {"md5": "1cc42360026c716c5255c5486efd7f92", "sha256": "ef17d9955c7af6da58ad6658cde776c1fb6cab8921d2c03a452e96bee404b04c"}, "downloads": -1, "filename": "auto_profiler-1.4-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "1cc42360026c716c5255c5486efd7f92", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15514, "upload_time": "2020-02-12T13:43:59", "upload_time_iso_8601": "2020-02-12T13:43:59.908828Z", "url": "https://files.pythonhosted.org/packages/77/78/c22ea3a9094ffcb3ac0424339389790a461abfc28ef526786b18fb22a12b/auto_profiler-1.4-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f17e2fc63809af8d50215ff2a738f941", "sha256": "91183fd53cf12ba8f42d57d34e0daaabe32de816ca34d3f03bcf617e31248126"}, "downloads": -1, "filename": "auto_profiler-1.4-py3-none-any.whl", "has_sig": false, "md5_digest": "f17e2fc63809af8d50215ff2a738f941", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15511, "upload_time": "2020-02-12T13:44:01", "upload_time_iso_8601": "2020-02-12T13:44:01.065579Z", "url": "https://files.pythonhosted.org/packages/ee/d2/e5f0a5ce34825ce3555f231a4242779f1c8f60ecb84cdffb1cd4da3ddcb2/auto_profiler-1.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "eca64f3624686375124ea2510413e192", "sha256": "e79511f1ac4e7147e3900cb1aac4ddd518ba1167501c3f80aebeac9ff7f8d203"}, "downloads": -1, "filename": "auto_profiler-1.4.tar.gz", "has_sig": false, "md5_digest": "eca64f3624686375124ea2510413e192", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8848, "upload_time": "2020-02-12T13:44:02", "upload_time_iso_8601": "2020-02-12T13:44:02.317514Z", "url": "https://files.pythonhosted.org/packages/d6/9d/888c6b4b27cb31b832a9789e792738451bd99eddb4e1fc9c22cbce5dc79f/auto_profiler-1.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1cc42360026c716c5255c5486efd7f92", "sha256": "ef17d9955c7af6da58ad6658cde776c1fb6cab8921d2c03a452e96bee404b04c"}, "downloads": -1, "filename": "auto_profiler-1.4-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "1cc42360026c716c5255c5486efd7f92", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15514, "upload_time": "2020-02-12T13:43:59", "upload_time_iso_8601": "2020-02-12T13:43:59.908828Z", "url": "https://files.pythonhosted.org/packages/77/78/c22ea3a9094ffcb3ac0424339389790a461abfc28ef526786b18fb22a12b/auto_profiler-1.4-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f17e2fc63809af8d50215ff2a738f941", "sha256": "91183fd53cf12ba8f42d57d34e0daaabe32de816ca34d3f03bcf617e31248126"}, "downloads": -1, "filename": "auto_profiler-1.4-py3-none-any.whl", "has_sig": false, "md5_digest": "f17e2fc63809af8d50215ff2a738f941", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 15511, "upload_time": "2020-02-12T13:44:01", "upload_time_iso_8601": "2020-02-12T13:44:01.065579Z", "url": "https://files.pythonhosted.org/packages/ee/d2/e5f0a5ce34825ce3555f231a4242779f1c8f60ecb84cdffb1cd4da3ddcb2/auto_profiler-1.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "eca64f3624686375124ea2510413e192", "sha256": "e79511f1ac4e7147e3900cb1aac4ddd518ba1167501c3f80aebeac9ff7f8d203"}, "downloads": -1, "filename": "auto_profiler-1.4.tar.gz", "has_sig": false, "md5_digest": "eca64f3624686375124ea2510413e192", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8848, "upload_time": "2020-02-12T13:44:02", "upload_time_iso_8601": "2020-02-12T13:44:02.317514Z", "url": "https://files.pythonhosted.org/packages/d6/9d/888c6b4b27cb31b832a9789e792738451bd99eddb4e1fc9c22cbce5dc79f/auto_profiler-1.4.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:16:11 2020"}