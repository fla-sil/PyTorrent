{"info": {"author": "Fabrica Inc.", "author_email": "info@fabrica.city", "bugtrack_url": null, "classifiers": [], "description": "## installation\n\nThe Fabrica SDK can be installed directly from PyPi with:\n\n```\npip install fabricasdk\n```\n\n## configuration\n\nThe Fabrica SDK uses a config file to determine which network, network settings and accounts should be used when calling the SDK's methods.\n\nBelow is an example of a config file that uses the Rinkeby test network.\n\n```\n#rinkeby-config.json\n\n{\n  \"private_key\":\"<user_private_key>\",\n  \"cosigner_address\": \"<cosigner_address\",\n  \"fabrica_api_url\": \"https://4hcsqf7aw0.execute-api.us-west-1.amazonaws.com/production\",\n  \"fabrica_api_key\": \"hMieYmc2ewr@#E2!c8==3evb\",\n  \"ipfs_endpoint\": null,\n  \"ipfs_port\": null,\n  \"network_url\": \"https://rinkeby.infura.io/j0RAOpI99Wf54yIYxNB6\",\n  \"local_state_path\": null\n}\n```\n\n**Config Arguments**\n\n`private_key:` defaults to None, represents the private key of the sender; if this parameter is None all contract functions will be called with the transact method instead of a signed sendRawTransaction. This address/private key should be thought of as the primary user of the SDK.\n\n`cosigner_address:`\ndefaults to None, represents the public eth address of the cosigner. This address should be different than the address associated with the private_key above.\n\n`fabrica_api_url:` defaults to None, represents the Fabrica API url\n\n`fabrica_api_key:` defaults to None, represents the Fabrica API key\n\n`ipfs_endpoint:` defaults to  https://ipfs.infura.io\n\n`ipfs_port:` defaults to  5001\n\n`network_url:` defaults to http://localhost:8545 represents the blockchain network to use;\n\n`local_state_path:` defaults to ~/fabrica-state.db, represents the path to the local state file and will be used if no state plugins are provided to the SDK constructor\n`\nTo instantiate the SDK with the above config file you can do the following:\n\n```\nfrom fabricasdk import FabricaSdk\n\nfabrica = FabricaSdk(os.path.join(dirname, \"rinkeby-config.json\"))\n```\n\n## Multisig Wallet Overview\n\nThe Fabrica SDK can be used with either a single ethereum account private/public key pair or with a multisig wallet that is generated by the SDK. The multisig wallet requires signing from 2 of 3 ethereum accounts before a transaction is executed.  \n\nA typical multisig wallet will consist of the following three signers:\n\n1) The `user_address` which is best thought of as the SDK user address.\n\n2) The `cosigner_address` which initially will be Fabrica's address.\n\n3) The `customer_address` which represents the account address of the end user.\n\nThe `sender_address` and `cosigner_address` are specified in the above mentioned config file.\n\nTo generate a multisig wallet for a new user you must do the following:\n\n```\nfrom fabricasdk import FabricaSdk\n\nfabrica = FabricaSdk(os.path.join(dirname, \"rinkeby-config.json\"))\n\ncustomer_address = \"0x94bebe960a5de83911e901b309bd7dfb1cd7a679\"\n\n# multisig wallet created here\n\nreceipt = fabrica.factory.create(customer_address)\n\nprint(receipt)\n```\n\n\n## Multisig Transaction vs Non-Multisig Transaction\n\nAll core methods in the Fabrica SDK can be called either via a multisig wallet or with a \"non-multisig\" wallet. In the case that you choose not to use a multisig wallet the SDK will atempt to execute the transaction using the `sender_address` and `private_key` specified the config file.\n\nAll core methods in the Fabrica SDK accept optional parameters `cosign` and `customer_address`. By default `cosign=True`. When `cosign=True` you must also include the `customer_address` which is the public account associated with the user that is 1 of the 3 signers of the multsig wallet.\n\nExample:\n\n```\nfrom fabricasdk import FabricaSdk\n\nfabrica = FabricaSdk(os.path.join(dirname, \"rinkeby-config.json\"))\n\ntoken_id = int(time.time())\n\ncustomer_address = \"0x94bebe960a5de83911e901b309bd7dfb1cd7a679\"\n\n# mints a token using a multisig wallet associated with the customer_address\n\nfabrica.token.mint(token_id, \"geoHash\", \"holdingEntity\", \"ipfs:/ipfs/whatever\", customer_address=customer_address)\n\n# mints a token using the sender_address and private_key specified in the config file\n\nfabrica.token.mint(token_id, \"geoHash\", \"holdingEntity\", \"ipfs:/ipfs/whatever\", cosign=False)\n```\n\n## Creating Token Metadata with the mint method\n\nMetadata associated with a Fabrica Token is stored in a json object. The Fabrica SDK mint function allows you to either pass a dictionary of values that are used to create a metadata object which is stored on IPFS and referenced from the token or pass a URL to the method which points to an existing metadata object or.\n\nBelow is an example of minting a token using a) a dictionary of values and b) a metadata URL\n\n\n```\nfrom fabricasdk import FabricaSdk\n\nfabrica = FabricaSdk(os.path.join(dirname, \"rinkeby-config.json\"))\n\ntoken_id = int(time.time())\n\n# mint a token passing a dictionary of values to create a metadata object\n\nreceipt = fabrica.token.mint(\n      token_id,\n      \"geoHash\",\n      \"holdingEntity\",\n      {\"name\": \"this is the name\", \"description\": \"this is the description\"},\n      cosign=bool(customer_address),\n      customer_address=customer_address\n  )\n\n# mint a token passing a dictionary of values to create a metadata object including legal document creation (final legal document values TBD)\n\nreceipt = fabrica.token.mint(\n      token_id,\n      \"geoHash\",\n      \"holdingEntity\",\n      {\n          \"name\": \"this is the name\",\n          \"description\": \"this is the description\",\n          \"document\": {\n              \"day\": \"19\",\n              \"month\": \"08\",\n              \"year\": \"2018\",\n              \"grantor\": \"Steven Smith\",\n              \"entity_id\": \"321123\",\n              \"smartcontract_address\": \"0x00202020202\",\n              \"property_legal_description\": \"this is a cool house\",\n              \"trustee\": \"John Smith\",\n              \"county\": \"Orange\"\n          }\n\n      },\n      cosign=bool(customer_address),\n      customer_address=customer_address\n  )\n\n\n\n\n# mint a token using a URL that points to an existing metadata object\n\nreceipt = fabrica.token.mint(token_id, \"geoHash\", \"holdingEntity\", \"ipfs:/ipfs/QmaFWUrRKHbNqKcZfUmnVMB38sb8XWJiJ27S5vH1NsaEai\", customer_address=customer_address)\n```\n\nThe get_token() method can be used to verify and view the token that you just created\n\nexample:\n\n```\nfrom fabricasdk import FabricaSdk\n\nfabrica = FabricaSdk(os.path.join(dirname, \"rinkeby-config.json\"))\n\nprint(fabrica.token.get_token(\"1\"))\n```\n\nthe return value should include both the core token data stored in the smart contract and the associated metadata.\n\nexample:\n\n```\n{'token_id': 1, 'geohash': '9q8zn2ez3uev', 'holding_entity': 'Fabrica 1', 'token_uri': 'https://ipfs.io/ipfs/Qmbh7EHR9EfPdWfwWB6tuKXjSGHWzVX36kp6e3TNmMfX3M', 'metadata': {'name': '1707 Jones Street', 'description': 'awesome property', 'formationDocURI': 'https://ipfs.io/ipfs/QmRnE2rQqKdE2Zus59ourBuEKy3BtHg7SYf9wyi9QdTnN8'}}\n```\n\n\n\n## Usage non-multisig\n\nBelow are examples of how do perform the following basic functions with the sdk: minting a token, updating a token and transferring a token without a multisig wallet.\n\n```\n#minting a token\n\n#create a unique token id\ntoken_id = int(time.time())\n\ncustomer_address = \"0x94bebe960a5de83911e901b309bd7dfb1cd7a679\"\n\n\n#call the mint method of the SDK with a token id, geohash(string), holding entity(string), tokenuri (string)\n\n#NOTE: the tokenURI points to a metadata object for the property(address, legal description and link to the formation legal document). Creation of the metadata object will be included in the next version of the SDK, along with conversion of lat/lng geocords to geohash.\n\nreceipt = fabrica.token.mint(token_id, \"geoHash\", \"holdingEntity\", \"ipfs:/ipfs/whatever\", cosign=False)\n\n#verify that the token was successfully minted\ntoken = fabrica.get_token(token_id)\nprint(\"token: {}\".format(token))\n\n#call the update method of the SDK with a token id, holding entity (string), and tokenuri (string)\n\nreceipt = fabrica.token.update_token(token_id, \"otherEntity\", \"otherUri\", cosign=False)\nprint(receipt)\n\n#verify that the token was successfully updated\ntoken = fabrica.token.get_token(token_id)\nprint(\"token: {}\".format(token))\n\n#call the transfer_from method of the SDK with the address of the existing token holder(your address), the address that you are sending the token to and the token_idself.\n\nreceipt = fabrica.token.transfer_from(<from_address>, <to_address>, token_id, cosign=False)\nprint(receipt)\n\ntoken=fabrica.token.get_token(token_id)\nprint(\"token: {}\".format(token))\n```\n\n## Usage multisig\n\nBelow are examples of how do perform the following basic functions with the sdk: minting a token, updating a token and transferring a token with a multisig wallet (including creation of the multisig wallet).\n\n```\n#minting a token\n\n#create a unique token id\ntoken_id = int(time.time())\n\n#set customer address. note: this should be a valid ethereum address\n\ncustomer_address = \"0x94bebe960a5de83911e901b309bd7dfb1cd7a679\"\n\n#create multisig wallet\n\nreceipt = fabrica.factory.create(customer_address)\n\nprint(receipt)\n\n\n#call the mint method of the SDK using cosign with a token id, geohash(string), holding entity(string), tokenuri (string)\n\n#NOTE: the tokenURI points to a metadata object for the property(address, legal description and link to the formation legal document). Creation of the metadata object will be included in the next version of the SDK, along with conversion of lat/lng geocords to geohash.\n\nreceipt = fabrica.token.mint(token_id, \"geoHash\", \"holdingEntity\", \"ipfs:/ipfs/whatever\", customer_address=customer_address )\n\n#verify that the token was successfully minted\ntoken = fabrica.get_token(token_id)\nprint(\"token: {}\".format(token))\n\n#call the update method of the SDK using cosign with a token id, holding entity (string), and tokenuri (string)\n\nreceipt = fabrica.token.update_token(token_id, \"otherEntity\", \"otherUri\", customer_address=customer_address)\nprint(receipt)\n\n#verify that the token was successfully updated\ntoken = fabrica.token.get_token(token_id)\nprint(\"token: {}\".format(token))\n\n#call the transfer_from method of the SDK using cosign with the address of the existing token holder(your address), the address that you are sending the token to and the token_idself.\n\nreceipt = fabrica.token.transfer_from(<from_address>, <to_address>, token_id, customer_address=customer_address)\nprint(receipt)\n\ntoken=fabrica.token.get_token(token_id)\nprint(\"token: {}\".format(token))\n```\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "fabricasdk", "package_url": "https://pypi.org/project/fabricasdk/", "platform": "", "project_url": "https://pypi.org/project/fabricasdk/", "project_urls": null, "release_url": "https://pypi.org/project/fabricasdk/0.2.0/", "requires_dist": ["ecdsa (==0.13)", "ipfsapi (==0.4.3)", "requests (==2.19.1)", "rfc3986 (==1.1.0)", "web3 (==4.6.0)"], "requires_python": "", "summary": "fabrica sdk", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h2>installation</h2>\n<p>The Fabrica SDK can be installed directly from PyPi with:</p>\n<pre><code>pip install fabricasdk\n</code></pre>\n<h2>configuration</h2>\n<p>The Fabrica SDK uses a config file to determine which network, network settings and accounts should be used when calling the SDK's methods.</p>\n<p>Below is an example of a config file that uses the Rinkeby test network.</p>\n<pre><code>#rinkeby-config.json\n\n{\n  \"private_key\":\"&lt;user_private_key&gt;\",\n  \"cosigner_address\": \"&lt;cosigner_address\",\n  \"fabrica_api_url\": \"https://4hcsqf7aw0.execute-api.us-west-1.amazonaws.com/production\",\n  \"fabrica_api_key\": \"hMieYmc2ewr@#E2!c8==3evb\",\n  \"ipfs_endpoint\": null,\n  \"ipfs_port\": null,\n  \"network_url\": \"https://rinkeby.infura.io/j0RAOpI99Wf54yIYxNB6\",\n  \"local_state_path\": null\n}\n</code></pre>\n<p><strong>Config Arguments</strong></p>\n<p><code>private_key:</code> defaults to None, represents the private key of the sender; if this parameter is None all contract functions will be called with the transact method instead of a signed sendRawTransaction. This address/private key should be thought of as the primary user of the SDK.</p>\n<p><code>cosigner_address:</code>\ndefaults to None, represents the public eth address of the cosigner. This address should be different than the address associated with the private_key above.</p>\n<p><code>fabrica_api_url:</code> defaults to None, represents the Fabrica API url</p>\n<p><code>fabrica_api_key:</code> defaults to None, represents the Fabrica API key</p>\n<p><code>ipfs_endpoint:</code> defaults to  <a href=\"https://ipfs.infura.io\" rel=\"nofollow\">https://ipfs.infura.io</a></p>\n<p><code>ipfs_port:</code> defaults to  5001</p>\n<p><code>network_url:</code> defaults to <a href=\"http://localhost:8545\" rel=\"nofollow\">http://localhost:8545</a> represents the blockchain network to use;</p>\n<p><code>local_state_path:</code> defaults to ~/fabrica-state.db, represents the path to the local state file and will be used if no state plugins are provided to the SDK constructor\n`\nTo instantiate the SDK with the above config file you can do the following:</p>\n<pre><code>from fabricasdk import FabricaSdk\n\nfabrica = FabricaSdk(os.path.join(dirname, \"rinkeby-config.json\"))\n</code></pre>\n<h2>Multisig Wallet Overview</h2>\n<p>The Fabrica SDK can be used with either a single ethereum account private/public key pair or with a multisig wallet that is generated by the SDK. The multisig wallet requires signing from 2 of 3 ethereum accounts before a transaction is executed.</p>\n<p>A typical multisig wallet will consist of the following three signers:</p>\n<ol>\n<li>\n<p>The <code>user_address</code> which is best thought of as the SDK user address.</p>\n</li>\n<li>\n<p>The <code>cosigner_address</code> which initially will be Fabrica's address.</p>\n</li>\n<li>\n<p>The <code>customer_address</code> which represents the account address of the end user.</p>\n</li>\n</ol>\n<p>The <code>sender_address</code> and <code>cosigner_address</code> are specified in the above mentioned config file.</p>\n<p>To generate a multisig wallet for a new user you must do the following:</p>\n<pre><code>from fabricasdk import FabricaSdk\n\nfabrica = FabricaSdk(os.path.join(dirname, \"rinkeby-config.json\"))\n\ncustomer_address = \"0x94bebe960a5de83911e901b309bd7dfb1cd7a679\"\n\n# multisig wallet created here\n\nreceipt = fabrica.factory.create(customer_address)\n\nprint(receipt)\n</code></pre>\n<h2>Multisig Transaction vs Non-Multisig Transaction</h2>\n<p>All core methods in the Fabrica SDK can be called either via a multisig wallet or with a \"non-multisig\" wallet. In the case that you choose not to use a multisig wallet the SDK will atempt to execute the transaction using the <code>sender_address</code> and <code>private_key</code> specified the config file.</p>\n<p>All core methods in the Fabrica SDK accept optional parameters <code>cosign</code> and <code>customer_address</code>. By default <code>cosign=True</code>. When <code>cosign=True</code> you must also include the <code>customer_address</code> which is the public account associated with the user that is 1 of the 3 signers of the multsig wallet.</p>\n<p>Example:</p>\n<pre><code>from fabricasdk import FabricaSdk\n\nfabrica = FabricaSdk(os.path.join(dirname, \"rinkeby-config.json\"))\n\ntoken_id = int(time.time())\n\ncustomer_address = \"0x94bebe960a5de83911e901b309bd7dfb1cd7a679\"\n\n# mints a token using a multisig wallet associated with the customer_address\n\nfabrica.token.mint(token_id, \"geoHash\", \"holdingEntity\", \"ipfs:/ipfs/whatever\", customer_address=customer_address)\n\n# mints a token using the sender_address and private_key specified in the config file\n\nfabrica.token.mint(token_id, \"geoHash\", \"holdingEntity\", \"ipfs:/ipfs/whatever\", cosign=False)\n</code></pre>\n<h2>Creating Token Metadata with the mint method</h2>\n<p>Metadata associated with a Fabrica Token is stored in a json object. The Fabrica SDK mint function allows you to either pass a dictionary of values that are used to create a metadata object which is stored on IPFS and referenced from the token or pass a URL to the method which points to an existing metadata object or.</p>\n<p>Below is an example of minting a token using a) a dictionary of values and b) a metadata URL</p>\n<pre><code>from fabricasdk import FabricaSdk\n\nfabrica = FabricaSdk(os.path.join(dirname, \"rinkeby-config.json\"))\n\ntoken_id = int(time.time())\n\n# mint a token passing a dictionary of values to create a metadata object\n\nreceipt = fabrica.token.mint(\n      token_id,\n      \"geoHash\",\n      \"holdingEntity\",\n      {\"name\": \"this is the name\", \"description\": \"this is the description\"},\n      cosign=bool(customer_address),\n      customer_address=customer_address\n  )\n\n# mint a token passing a dictionary of values to create a metadata object including legal document creation (final legal document values TBD)\n\nreceipt = fabrica.token.mint(\n      token_id,\n      \"geoHash\",\n      \"holdingEntity\",\n      {\n          \"name\": \"this is the name\",\n          \"description\": \"this is the description\",\n          \"document\": {\n              \"day\": \"19\",\n              \"month\": \"08\",\n              \"year\": \"2018\",\n              \"grantor\": \"Steven Smith\",\n              \"entity_id\": \"321123\",\n              \"smartcontract_address\": \"0x00202020202\",\n              \"property_legal_description\": \"this is a cool house\",\n              \"trustee\": \"John Smith\",\n              \"county\": \"Orange\"\n          }\n\n      },\n      cosign=bool(customer_address),\n      customer_address=customer_address\n  )\n\n\n\n\n# mint a token using a URL that points to an existing metadata object\n\nreceipt = fabrica.token.mint(token_id, \"geoHash\", \"holdingEntity\", \"ipfs:/ipfs/QmaFWUrRKHbNqKcZfUmnVMB38sb8XWJiJ27S5vH1NsaEai\", customer_address=customer_address)\n</code></pre>\n<p>The get_token() method can be used to verify and view the token that you just created</p>\n<p>example:</p>\n<pre><code>from fabricasdk import FabricaSdk\n\nfabrica = FabricaSdk(os.path.join(dirname, \"rinkeby-config.json\"))\n\nprint(fabrica.token.get_token(\"1\"))\n</code></pre>\n<p>the return value should include both the core token data stored in the smart contract and the associated metadata.</p>\n<p>example:</p>\n<pre><code>{'token_id': 1, 'geohash': '9q8zn2ez3uev', 'holding_entity': 'Fabrica 1', 'token_uri': 'https://ipfs.io/ipfs/Qmbh7EHR9EfPdWfwWB6tuKXjSGHWzVX36kp6e3TNmMfX3M', 'metadata': {'name': '1707 Jones Street', 'description': 'awesome property', 'formationDocURI': 'https://ipfs.io/ipfs/QmRnE2rQqKdE2Zus59ourBuEKy3BtHg7SYf9wyi9QdTnN8'}}\n</code></pre>\n<h2>Usage non-multisig</h2>\n<p>Below are examples of how do perform the following basic functions with the sdk: minting a token, updating a token and transferring a token without a multisig wallet.</p>\n<pre><code>#minting a token\n\n#create a unique token id\ntoken_id = int(time.time())\n\ncustomer_address = \"0x94bebe960a5de83911e901b309bd7dfb1cd7a679\"\n\n\n#call the mint method of the SDK with a token id, geohash(string), holding entity(string), tokenuri (string)\n\n#NOTE: the tokenURI points to a metadata object for the property(address, legal description and link to the formation legal document). Creation of the metadata object will be included in the next version of the SDK, along with conversion of lat/lng geocords to geohash.\n\nreceipt = fabrica.token.mint(token_id, \"geoHash\", \"holdingEntity\", \"ipfs:/ipfs/whatever\", cosign=False)\n\n#verify that the token was successfully minted\ntoken = fabrica.get_token(token_id)\nprint(\"token: {}\".format(token))\n\n#call the update method of the SDK with a token id, holding entity (string), and tokenuri (string)\n\nreceipt = fabrica.token.update_token(token_id, \"otherEntity\", \"otherUri\", cosign=False)\nprint(receipt)\n\n#verify that the token was successfully updated\ntoken = fabrica.token.get_token(token_id)\nprint(\"token: {}\".format(token))\n\n#call the transfer_from method of the SDK with the address of the existing token holder(your address), the address that you are sending the token to and the token_idself.\n\nreceipt = fabrica.token.transfer_from(&lt;from_address&gt;, &lt;to_address&gt;, token_id, cosign=False)\nprint(receipt)\n\ntoken=fabrica.token.get_token(token_id)\nprint(\"token: {}\".format(token))\n</code></pre>\n<h2>Usage multisig</h2>\n<p>Below are examples of how do perform the following basic functions with the sdk: minting a token, updating a token and transferring a token with a multisig wallet (including creation of the multisig wallet).</p>\n<pre><code>#minting a token\n\n#create a unique token id\ntoken_id = int(time.time())\n\n#set customer address. note: this should be a valid ethereum address\n\ncustomer_address = \"0x94bebe960a5de83911e901b309bd7dfb1cd7a679\"\n\n#create multisig wallet\n\nreceipt = fabrica.factory.create(customer_address)\n\nprint(receipt)\n\n\n#call the mint method of the SDK using cosign with a token id, geohash(string), holding entity(string), tokenuri (string)\n\n#NOTE: the tokenURI points to a metadata object for the property(address, legal description and link to the formation legal document). Creation of the metadata object will be included in the next version of the SDK, along with conversion of lat/lng geocords to geohash.\n\nreceipt = fabrica.token.mint(token_id, \"geoHash\", \"holdingEntity\", \"ipfs:/ipfs/whatever\", customer_address=customer_address )\n\n#verify that the token was successfully minted\ntoken = fabrica.get_token(token_id)\nprint(\"token: {}\".format(token))\n\n#call the update method of the SDK using cosign with a token id, holding entity (string), and tokenuri (string)\n\nreceipt = fabrica.token.update_token(token_id, \"otherEntity\", \"otherUri\", customer_address=customer_address)\nprint(receipt)\n\n#verify that the token was successfully updated\ntoken = fabrica.token.get_token(token_id)\nprint(\"token: {}\".format(token))\n\n#call the transfer_from method of the SDK using cosign with the address of the existing token holder(your address), the address that you are sending the token to and the token_idself.\n\nreceipt = fabrica.token.transfer_from(&lt;from_address&gt;, &lt;to_address&gt;, token_id, customer_address=customer_address)\nprint(receipt)\n\ntoken=fabrica.token.get_token(token_id)\nprint(\"token: {}\".format(token))\n</code></pre>\n\n          </div>"}, "last_serial": 4419959, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "558dcb33ae6bfb0b29e831d631e9e43d", "sha256": "d1317d10b2df213300fa1d12b6d55a36e6344e5e7726b91837d2fc841504465d"}, "downloads": -1, "filename": "fabricasdk-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "558dcb33ae6bfb0b29e831d631e9e43d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21595, "upload_time": "2018-10-17T18:22:46", "upload_time_iso_8601": "2018-10-17T18:22:46.496589Z", "url": "https://files.pythonhosted.org/packages/02/e9/b18a85884ee8f40d1415816bb386cfc893bb3bece7a73c26603eaa82def3/fabricasdk-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "39aaf4e20214a4575056283d01f8e8fe", "sha256": "22f641586cf1e162f629972af121a9fcefc15c41897dce863541a87d3dac8284"}, "downloads": -1, "filename": "fabricasdk-0.1.0.tar.gz", "has_sig": false, "md5_digest": "39aaf4e20214a4575056283d01f8e8fe", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19907, "upload_time": "2018-10-17T18:22:48", "upload_time_iso_8601": "2018-10-17T18:22:48.018824Z", "url": "https://files.pythonhosted.org/packages/3a/c3/38b09ea3c2a7d47ed7b32d0b4a1248506ac91be52bdd98afdbc02ad09c03/fabricasdk-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "027aeb489d90ed64b54a15478f657f4b", "sha256": "8baa988958191511e4b65887db1291571395232e777bdd3d1d4f642bf54e55cd"}, "downloads": -1, "filename": "fabricasdk-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "027aeb489d90ed64b54a15478f657f4b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 22129, "upload_time": "2018-10-17T18:25:31", "upload_time_iso_8601": "2018-10-17T18:25:31.231755Z", "url": "https://files.pythonhosted.org/packages/c3/1e/503b40f4ecee146a944a0ef17a92b600d9a20f4297120f6c0eabb715247d/fabricasdk-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c587a54edc378358b8f832cf64e84121", "sha256": "e383c4b5fe08b2bc9e9f6c5457bbc4f04349d34084ec51a4f7ffc9cbbbd6432a"}, "downloads": -1, "filename": "fabricasdk-0.1.1.tar.gz", "has_sig": false, "md5_digest": "c587a54edc378358b8f832cf64e84121", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21076, "upload_time": "2018-10-17T18:25:33", "upload_time_iso_8601": "2018-10-17T18:25:33.300986Z", "url": "https://files.pythonhosted.org/packages/1b/10/6be68725eaa38d28b3fd56ac14316685067cafc778d6621a43a0dde9ebbf/fabricasdk-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "0cf78c39de48f6655bdea48257b99ecf", "sha256": "674f4af6d6938320a8d03e1520287c7644a2e6b6636c81a5ce82bcf6bb3853fb"}, "downloads": -1, "filename": "fabricasdk-0.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "0cf78c39de48f6655bdea48257b99ecf", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 22132, "upload_time": "2018-10-17T18:39:47", "upload_time_iso_8601": "2018-10-17T18:39:47.483042Z", "url": "https://files.pythonhosted.org/packages/70/94/a6ff65a23322acf8a77f375a89381ab917ba3a6b03740541de71f6e42c03/fabricasdk-0.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "509a1a8f9c3f37130b1811754d58c576", "sha256": "825823a4655f6d45273ae9c0905cbdc373f27fd9e4fa8da1f8b4f890fb381184"}, "downloads": -1, "filename": "fabricasdk-0.1.2.tar.gz", "has_sig": false, "md5_digest": "509a1a8f9c3f37130b1811754d58c576", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21087, "upload_time": "2018-10-17T18:39:49", "upload_time_iso_8601": "2018-10-17T18:39:49.588988Z", "url": "https://files.pythonhosted.org/packages/85/54/04d9486e1ada6fb92da6f98e59287884c17d2abbaee436aab0a351031bb1/fabricasdk-0.1.2.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "5e925bf099e2fd2f3a29e5de7d8a9a8d", "sha256": "40ce963f5c9443402170a87d902fb15baf3f87ea98bffd2482214d91a4c537f9"}, "downloads": -1, "filename": "fabricasdk-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "5e925bf099e2fd2f3a29e5de7d8a9a8d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 24610, "upload_time": "2018-10-26T16:33:23", "upload_time_iso_8601": "2018-10-26T16:33:23.289876Z", "url": "https://files.pythonhosted.org/packages/3f/e2/660344054cf989385260cac63d36a906d95e4c4d696c1da9b809ffeaa959/fabricasdk-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5ebf3f7a08e7247f5fe3713aa9fa07a3", "sha256": "dfb738ce48839af8ec86784b80afd3e1014907e98e5c8c523b5db936be6349c5"}, "downloads": -1, "filename": "fabricasdk-0.2.0.tar.gz", "has_sig": false, "md5_digest": "5ebf3f7a08e7247f5fe3713aa9fa07a3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22374, "upload_time": "2018-10-26T16:33:24", "upload_time_iso_8601": "2018-10-26T16:33:24.790164Z", "url": "https://files.pythonhosted.org/packages/c9/8c/9fe3f44367fc4b2fb816c5147825131594377ee9fe8b4d376897a3d4a8fd/fabricasdk-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5e925bf099e2fd2f3a29e5de7d8a9a8d", "sha256": "40ce963f5c9443402170a87d902fb15baf3f87ea98bffd2482214d91a4c537f9"}, "downloads": -1, "filename": "fabricasdk-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "5e925bf099e2fd2f3a29e5de7d8a9a8d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 24610, "upload_time": "2018-10-26T16:33:23", "upload_time_iso_8601": "2018-10-26T16:33:23.289876Z", "url": "https://files.pythonhosted.org/packages/3f/e2/660344054cf989385260cac63d36a906d95e4c4d696c1da9b809ffeaa959/fabricasdk-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5ebf3f7a08e7247f5fe3713aa9fa07a3", "sha256": "dfb738ce48839af8ec86784b80afd3e1014907e98e5c8c523b5db936be6349c5"}, "downloads": -1, "filename": "fabricasdk-0.2.0.tar.gz", "has_sig": false, "md5_digest": "5ebf3f7a08e7247f5fe3713aa9fa07a3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22374, "upload_time": "2018-10-26T16:33:24", "upload_time_iso_8601": "2018-10-26T16:33:24.790164Z", "url": "https://files.pythonhosted.org/packages/c9/8c/9fe3f44367fc4b2fb816c5147825131594377ee9fe8b4d376897a3d4a8fd/fabricasdk-0.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:12 2020"}