{"info": {"author": "Nuno Preguica", "author_email": "nuno.preguica@fct.unl.pt", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: Apache Software License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "\n# Antidote Python Client\n\nThe repository contains classes for using Antidote Database service in Python. It provides the \nclient implementation to use Antidote Database.\n\nYou can learn more about Antidote Database [here](http://antidotedb.eu/)\n\n## Installation\n\nFor installing the Python AntidoteDB client, just use pip installer.\n\n    pip antidotedb\n\n\n## Documentation\n\nThe classes for accessing AntidoteDB are in package **antidotedb**.\n\nFor accessing AntidoteDB, you should start by creating an **AntidoteClient** object, as in the following\nexample.\n\n    from antidotedb import *\n\n    server = 'locahost'\n    port = 8087\n\n    clt = AntidoteClient(server, port)\n\n### Interactive transactions\n\n_start_transaction_ starts an interactive transactions. On failure,\n_start_transaction_ method raises an _AntidoteException_.\n\n    tx = clt.start_transaction()\n\n_commit_ method commits a sequence of operations executed in a transaction. On success, \nthe _commit_ method returns _True_.\n\n    ok = tx.commit()\n\n_abot_ method rollbacks the transactions.\n\n    tx.abort()\n\n### Operations on objects\n\nThe **Key** class allows to specify the AntidoteDB key for an object.\n\n    Key( bucket_name, key_name, type_name)\n\n_read_objects_ method allows to read the contents of one (or more) objects. On success, _read_objects_\nreturns a list of typed objects (more information next). On failure, \n_read_objects_ returns _None_. \n\n    key = Key( \"some_bucket\", \"some_key_counter\", \"COUNTER\")\n    res = tx.read_objects( key)\n    print( res[0].value())\n\nIt is also possible to read more than one object.\n\n    key1 = Key( \"some_bucket\", \"some_key\", \"COUNTER\")\n    key2 = Key( \"some_bucket\", \"some_other_key\", \"MVREG\")\n    res = tx.read_objects( [key1,key2])\n    print( res[0].value())\n    print( res[1].values())\n\n_update_objects_ method allows to update one (or more) objects. On success/failure, _update_objects_ returns _True_/_False_.\n\n    key1 = Key( \"some_bucket\", \"some_key\", \"COUNTER\")\n    res = tx.update_objects( Counter.IncOp(key1, 2))\n\n#### Counters\n\nThe data type name for the Counter data type is: **COUNTER**.\n\n    key = Key( \"some_bucket\", \"some_key\", \"COUNTER\")\n\nThe following **read only** operations are available in a **Counter** object\nreturned by _read_objects_ method:\n\n* **value()**, for accessing the value of an object.\n\n      res = tx.read_objects( key)\n      print( res[0].value())\n\nThe following **update** operations are available:\n\n* **Counter.IncOp(key, value)**, for incrementing a counter.\n\n      res = tx.update_objects( Counter.IncOp(key, 2))\n\nThe other counter data type supported by AntidoteDB, _FATCounter_ can be used\nusing **FATCOUNTER** data type name.\n\n#### Last-writer-wins register\n\nThe data type name for the Last-write-wins Register data type is: **LWWREG**.\n\n    key = Key( \"some_bucket\", \"some_key\", \"LWWREG\")\n\nThe following **read only** operations are available in a **Register** object\nreturned by _read_objects_ method:\n\n* **value()**, for accessing the value of an object.\n\n      res = tx.read_objects( key)\n      print( res[0].value())\n\nThe following **update** operations are available:\n\n* **Register.AssignOp( key, val)**, for assigning a new value to the register.\n\n      val = bytes(\"lightkone\",'utf-8')\n\n      res = tx.update_objects( Register.AssignOp( key, val))\n\n#### Multi-value register\n\nThe data type name for the multi-value Register data type is: **MVREG**.\n\n    key = Key( \"some_bucket\", \"some_key\", \"MVREG\")\n\nThe following **read only** operations are available in a **MVRegister** object\nreturned by _read_objects_ method:\n\n* **values()**, for accessing the values of an object. The multiple values are returned in a list.\n\n      res = tx.read_objects( key)\n      print( res[0].values())\n\nThe following **update** operations are available:\n\n* **Register.AssignOp( key, val)**, for assigning a new value to the register.\n\n      val = bytes(\"lightkone\",'utf-8')\n\n      res = tx.update_objects( Register.AssignOp( key, val))\n\n#### Sets\n\nThe data type name for the **add-wins set** data type is: **ORSET**.\n\n    key = Key( \"some_bucket\", \"some_key\", \"ORSET\")\n\nThe data type name for the **remove-wins set** data type is: **RWSET**.\n\n    key = Key( \"some_bucket\", \"some_key\", \"RWSET\")\n\nThe following **read only** operations are available in a **Set** object\nreturned by _read_objects_ method:\n\n* **values()**, for accessing the value of the set. The multiple values are returned in a list.\n\n      res = tx.read_objects( key)\n      print( res[0].values())\n\nThe following **update** operations are available:\n\n* **Set.AddOp( key, val)**, for adding values to the set.\n\n      val1 = bytes(\"lightkone\",'utf-8')\n      val2 = bytes(\"syncfree\",'utf-8')\n\n      res = tx.update_objects( Set.AddOp( key, [val1,val2]))\n\n* **Set.RemoveOp( key, val)**, for removing values from the set.\n\n      val1 = bytes(\"lightkone\",'utf-8')\n      val2 = bytes(\"syncfree\",'utf-8')\n\n      res = tx.update_objects( Set.RemoveOp( key, [val1,val2]))\n\n\n#### Flags\n\nThe data type name for the **enable-wins flag** data type is: **FLAG_EW**.\n\n    key = Key( \"some_bucket\", \"some_key\", \"FLAG_EW\")\n\nThe data type name for the **disable-wins flag** data type is: **FLAG_DW**.\n\n    key = Key( \"some_bucket\", \"some_key\", \"FLAG_DW\")\n\nThe following **read only** operations are available in a **Flag** object\nreturned by _read_objects_ method:\n\n* **value()**, for accessing the value of the flag.\n\n      res = tx.read_objects( key)\n      print( res[0].value())\n\nThe following **update** operations are available:\n\n* **Flag.UpdateOp( key, val)**, for setting a value to the flag.\n\n      res = tx.update_objects( Flag.UpdateOp( key, True))\n\n\n#### Maps\n\nThe data type name for the **grow-only map** data type is: **GMAP**.\n\n    key = Key( \"some_bucket\", \"some_key\", \"GMAP\")\n\nThe data type name for the **recursive-remove map** data type is: **RRMAP**.\n\n    key = Key( \"some_bucket\", \"some_key\", \"RRMAP\")\n\nThe following **read only** operations are available in a **Map** object\nreturned by _read_objects_ method:\n\n* **value()**, for accessing the contents of the map. The map is represented by a Python\ndictionary that maps a key to the object.\n\n      res = tx.read_objects( key)\n      print( res[0].value())\n\nThe following **update** operations are available:\n\n* **Map.UpdateOp(key,ops)**, for removing a key from the map.\n\n      k1 = bytes(\"k1\",'utf-8')\n      k2 = bytes(\"k2\",'utf-8')\n      val = bytes(\"lightkone\",'utf-8')\n\n      res = tx.update_objects( Map.RemoveOp( key, [Key( \"\", k1, \"COUNTER\")]))\n\n* **Map.RemoveOp(key,ops)**, for executing a set of operations in the objects stored in the map.\n\n      k1 = bytes(\"k1\",'utf-8')\n\n      res = tx.update_objects( Map.RemoveOp( key, [Key( \"\", k1, \"COUNTER\")]))\n\n### Generic operations\n\nThe following **update** operations are available in all data types:\n\n* **Type.ResetOp(key)**, for resetting the value.\n\n      res = tx.update_objects( Flag.ResetOp(key))\n\n# Development / Contributing\n\nAny help on developing this code is welcome. Feel free to open pull requests or open issues.\n\nTesting the AntidoteDB client required an Antidote instance running. \nYou can use Docker to start an instance in your local machine:\n\n    docker run -d -p \"8087:8087\" antidotedb/antidote\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/AntidoteDB/antidote-python-client/tree/master/src/main/python/antidotedb", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "antidotedb", "package_url": "https://pypi.org/project/antidotedb/", "platform": "", "project_url": "https://pypi.org/project/antidotedb/", "project_urls": {"Homepage": "https://github.com/AntidoteDB/antidote-python-client/tree/master/src/main/python/antidotedb"}, "release_url": "https://pypi.org/project/antidotedb/0.1.1/", "requires_dist": ["protobuf"], "requires_python": "", "summary": "AntidoteDB Python clients", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Antidote Python Client</h1>\n<p>The repository contains classes for using Antidote Database service in Python. It provides the\nclient implementation to use Antidote Database.</p>\n<p>You can learn more about Antidote Database <a href=\"http://antidotedb.eu/\" rel=\"nofollow\">here</a></p>\n<h2>Installation</h2>\n<p>For installing the Python AntidoteDB client, just use pip installer.</p>\n<pre><code>pip antidotedb\n</code></pre>\n<h2>Documentation</h2>\n<p>The classes for accessing AntidoteDB are in package <strong>antidotedb</strong>.</p>\n<p>For accessing AntidoteDB, you should start by creating an <strong>AntidoteClient</strong> object, as in the following\nexample.</p>\n<pre><code>from antidotedb import *\n\nserver = 'locahost'\nport = 8087\n\nclt = AntidoteClient(server, port)\n</code></pre>\n<h3>Interactive transactions</h3>\n<p><em>start_transaction</em> starts an interactive transactions. On failure,\n<em>start_transaction</em> method raises an <em>AntidoteException</em>.</p>\n<pre><code>tx = clt.start_transaction()\n</code></pre>\n<p><em>commit</em> method commits a sequence of operations executed in a transaction. On success,\nthe <em>commit</em> method returns <em>True</em>.</p>\n<pre><code>ok = tx.commit()\n</code></pre>\n<p><em>abot</em> method rollbacks the transactions.</p>\n<pre><code>tx.abort()\n</code></pre>\n<h3>Operations on objects</h3>\n<p>The <strong>Key</strong> class allows to specify the AntidoteDB key for an object.</p>\n<pre><code>Key( bucket_name, key_name, type_name)\n</code></pre>\n<p><em>read_objects</em> method allows to read the contents of one (or more) objects. On success, <em>read_objects</em>\nreturns a list of typed objects (more information next). On failure,\n<em>read_objects</em> returns <em>None</em>.</p>\n<pre><code>key = Key( \"some_bucket\", \"some_key_counter\", \"COUNTER\")\nres = tx.read_objects( key)\nprint( res[0].value())\n</code></pre>\n<p>It is also possible to read more than one object.</p>\n<pre><code>key1 = Key( \"some_bucket\", \"some_key\", \"COUNTER\")\nkey2 = Key( \"some_bucket\", \"some_other_key\", \"MVREG\")\nres = tx.read_objects( [key1,key2])\nprint( res[0].value())\nprint( res[1].values())\n</code></pre>\n<p><em>update_objects</em> method allows to update one (or more) objects. On success/failure, <em>update_objects</em> returns <em>True</em>/<em>False</em>.</p>\n<pre><code>key1 = Key( \"some_bucket\", \"some_key\", \"COUNTER\")\nres = tx.update_objects( Counter.IncOp(key1, 2))\n</code></pre>\n<h4>Counters</h4>\n<p>The data type name for the Counter data type is: <strong>COUNTER</strong>.</p>\n<pre><code>key = Key( \"some_bucket\", \"some_key\", \"COUNTER\")\n</code></pre>\n<p>The following <strong>read only</strong> operations are available in a <strong>Counter</strong> object\nreturned by <em>read_objects</em> method:</p>\n<ul>\n<li>\n<p><strong>value()</strong>, for accessing the value of an object.</p>\n<pre><code>res = tx.read_objects( key)\nprint( res[0].value())\n</code></pre>\n</li>\n</ul>\n<p>The following <strong>update</strong> operations are available:</p>\n<ul>\n<li>\n<p><strong>Counter.IncOp(key, value)</strong>, for incrementing a counter.</p>\n<pre><code>res = tx.update_objects( Counter.IncOp(key, 2))\n</code></pre>\n</li>\n</ul>\n<p>The other counter data type supported by AntidoteDB, <em>FATCounter</em> can be used\nusing <strong>FATCOUNTER</strong> data type name.</p>\n<h4>Last-writer-wins register</h4>\n<p>The data type name for the Last-write-wins Register data type is: <strong>LWWREG</strong>.</p>\n<pre><code>key = Key( \"some_bucket\", \"some_key\", \"LWWREG\")\n</code></pre>\n<p>The following <strong>read only</strong> operations are available in a <strong>Register</strong> object\nreturned by <em>read_objects</em> method:</p>\n<ul>\n<li>\n<p><strong>value()</strong>, for accessing the value of an object.</p>\n<pre><code>res = tx.read_objects( key)\nprint( res[0].value())\n</code></pre>\n</li>\n</ul>\n<p>The following <strong>update</strong> operations are available:</p>\n<ul>\n<li>\n<p><strong>Register.AssignOp( key, val)</strong>, for assigning a new value to the register.</p>\n<pre><code>val = bytes(\"lightkone\",'utf-8')\n\nres = tx.update_objects( Register.AssignOp( key, val))\n</code></pre>\n</li>\n</ul>\n<h4>Multi-value register</h4>\n<p>The data type name for the multi-value Register data type is: <strong>MVREG</strong>.</p>\n<pre><code>key = Key( \"some_bucket\", \"some_key\", \"MVREG\")\n</code></pre>\n<p>The following <strong>read only</strong> operations are available in a <strong>MVRegister</strong> object\nreturned by <em>read_objects</em> method:</p>\n<ul>\n<li>\n<p><strong>values()</strong>, for accessing the values of an object. The multiple values are returned in a list.</p>\n<pre><code>res = tx.read_objects( key)\nprint( res[0].values())\n</code></pre>\n</li>\n</ul>\n<p>The following <strong>update</strong> operations are available:</p>\n<ul>\n<li>\n<p><strong>Register.AssignOp( key, val)</strong>, for assigning a new value to the register.</p>\n<pre><code>val = bytes(\"lightkone\",'utf-8')\n\nres = tx.update_objects( Register.AssignOp( key, val))\n</code></pre>\n</li>\n</ul>\n<h4>Sets</h4>\n<p>The data type name for the <strong>add-wins set</strong> data type is: <strong>ORSET</strong>.</p>\n<pre><code>key = Key( \"some_bucket\", \"some_key\", \"ORSET\")\n</code></pre>\n<p>The data type name for the <strong>remove-wins set</strong> data type is: <strong>RWSET</strong>.</p>\n<pre><code>key = Key( \"some_bucket\", \"some_key\", \"RWSET\")\n</code></pre>\n<p>The following <strong>read only</strong> operations are available in a <strong>Set</strong> object\nreturned by <em>read_objects</em> method:</p>\n<ul>\n<li>\n<p><strong>values()</strong>, for accessing the value of the set. The multiple values are returned in a list.</p>\n<pre><code>res = tx.read_objects( key)\nprint( res[0].values())\n</code></pre>\n</li>\n</ul>\n<p>The following <strong>update</strong> operations are available:</p>\n<ul>\n<li>\n<p><strong>Set.AddOp( key, val)</strong>, for adding values to the set.</p>\n<pre><code>val1 = bytes(\"lightkone\",'utf-8')\nval2 = bytes(\"syncfree\",'utf-8')\n\nres = tx.update_objects( Set.AddOp( key, [val1,val2]))\n</code></pre>\n</li>\n<li>\n<p><strong>Set.RemoveOp( key, val)</strong>, for removing values from the set.</p>\n<pre><code>val1 = bytes(\"lightkone\",'utf-8')\nval2 = bytes(\"syncfree\",'utf-8')\n\nres = tx.update_objects( Set.RemoveOp( key, [val1,val2]))\n</code></pre>\n</li>\n</ul>\n<h4>Flags</h4>\n<p>The data type name for the <strong>enable-wins flag</strong> data type is: <strong>FLAG_EW</strong>.</p>\n<pre><code>key = Key( \"some_bucket\", \"some_key\", \"FLAG_EW\")\n</code></pre>\n<p>The data type name for the <strong>disable-wins flag</strong> data type is: <strong>FLAG_DW</strong>.</p>\n<pre><code>key = Key( \"some_bucket\", \"some_key\", \"FLAG_DW\")\n</code></pre>\n<p>The following <strong>read only</strong> operations are available in a <strong>Flag</strong> object\nreturned by <em>read_objects</em> method:</p>\n<ul>\n<li>\n<p><strong>value()</strong>, for accessing the value of the flag.</p>\n<pre><code>res = tx.read_objects( key)\nprint( res[0].value())\n</code></pre>\n</li>\n</ul>\n<p>The following <strong>update</strong> operations are available:</p>\n<ul>\n<li>\n<p><strong>Flag.UpdateOp( key, val)</strong>, for setting a value to the flag.</p>\n<pre><code>res = tx.update_objects( Flag.UpdateOp( key, True))\n</code></pre>\n</li>\n</ul>\n<h4>Maps</h4>\n<p>The data type name for the <strong>grow-only map</strong> data type is: <strong>GMAP</strong>.</p>\n<pre><code>key = Key( \"some_bucket\", \"some_key\", \"GMAP\")\n</code></pre>\n<p>The data type name for the <strong>recursive-remove map</strong> data type is: <strong>RRMAP</strong>.</p>\n<pre><code>key = Key( \"some_bucket\", \"some_key\", \"RRMAP\")\n</code></pre>\n<p>The following <strong>read only</strong> operations are available in a <strong>Map</strong> object\nreturned by <em>read_objects</em> method:</p>\n<ul>\n<li>\n<p><strong>value()</strong>, for accessing the contents of the map. The map is represented by a Python\ndictionary that maps a key to the object.</p>\n<pre><code>res = tx.read_objects( key)\nprint( res[0].value())\n</code></pre>\n</li>\n</ul>\n<p>The following <strong>update</strong> operations are available:</p>\n<ul>\n<li>\n<p><strong>Map.UpdateOp(key,ops)</strong>, for removing a key from the map.</p>\n<pre><code>k1 = bytes(\"k1\",'utf-8')\nk2 = bytes(\"k2\",'utf-8')\nval = bytes(\"lightkone\",'utf-8')\n\nres = tx.update_objects( Map.RemoveOp( key, [Key( \"\", k1, \"COUNTER\")]))\n</code></pre>\n</li>\n<li>\n<p><strong>Map.RemoveOp(key,ops)</strong>, for executing a set of operations in the objects stored in the map.</p>\n<pre><code>k1 = bytes(\"k1\",'utf-8')\n\nres = tx.update_objects( Map.RemoveOp( key, [Key( \"\", k1, \"COUNTER\")]))\n</code></pre>\n</li>\n</ul>\n<h3>Generic operations</h3>\n<p>The following <strong>update</strong> operations are available in all data types:</p>\n<ul>\n<li>\n<p><strong>Type.ResetOp(key)</strong>, for resetting the value.</p>\n<pre><code>res = tx.update_objects( Flag.ResetOp(key))\n</code></pre>\n</li>\n</ul>\n<h1>Development / Contributing</h1>\n<p>Any help on developing this code is welcome. Feel free to open pull requests or open issues.</p>\n<p>Testing the AntidoteDB client required an Antidote instance running.\nYou can use Docker to start an instance in your local machine:</p>\n<pre><code>docker run -d -p \"8087:8087\" antidotedb/antidote\n</code></pre>\n\n          </div>"}, "last_serial": 4749304, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "b4d73ec044c5c3514054fe239e648478", "sha256": "4126b463cf92e8df19641a644b536fa38ca988dbfb0a9939147579cfc579871c"}, "downloads": -1, "filename": "antidotedb-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "b4d73ec044c5c3514054fe239e648478", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 16996, "upload_time": "2019-01-28T09:44:13", "upload_time_iso_8601": "2019-01-28T09:44:13.906658Z", "url": "https://files.pythonhosted.org/packages/31/de/13a55054e802a028c177e8453614c6e3ee3b7fbe298b5bb60e87c5fe3200/antidotedb-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "080973b1656fe733932e7be65291209f", "sha256": "c38d97efcd3ec76528fe24df4a3f31bf1ddfcfae07f4c90066b41a54b0289899"}, "downloads": -1, "filename": "antidotedb-0.1.1.tar.gz", "has_sig": false, "md5_digest": "080973b1656fe733932e7be65291209f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14214, "upload_time": "2019-01-28T09:44:15", "upload_time_iso_8601": "2019-01-28T09:44:15.404625Z", "url": "https://files.pythonhosted.org/packages/fc/c7/6da867c559eaa30633d2ec3d19a199ebfa33a3c99f79306d67d4eed5782f/antidotedb-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b4d73ec044c5c3514054fe239e648478", "sha256": "4126b463cf92e8df19641a644b536fa38ca988dbfb0a9939147579cfc579871c"}, "downloads": -1, "filename": "antidotedb-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "b4d73ec044c5c3514054fe239e648478", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 16996, "upload_time": "2019-01-28T09:44:13", "upload_time_iso_8601": "2019-01-28T09:44:13.906658Z", "url": "https://files.pythonhosted.org/packages/31/de/13a55054e802a028c177e8453614c6e3ee3b7fbe298b5bb60e87c5fe3200/antidotedb-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "080973b1656fe733932e7be65291209f", "sha256": "c38d97efcd3ec76528fe24df4a3f31bf1ddfcfae07f4c90066b41a54b0289899"}, "downloads": -1, "filename": "antidotedb-0.1.1.tar.gz", "has_sig": false, "md5_digest": "080973b1656fe733932e7be65291209f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14214, "upload_time": "2019-01-28T09:44:15", "upload_time_iso_8601": "2019-01-28T09:44:15.404625Z", "url": "https://files.pythonhosted.org/packages/fc/c7/6da867c559eaa30633d2ec3d19a199ebfa33a3c99f79306d67d4eed5782f/antidotedb-0.1.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:18:00 2020"}