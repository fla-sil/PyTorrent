{"info": {"author": "James Gardner", "author_email": "james at pythonweb dot org", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Framework :: Buildout", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Topic :: Software Development :: Build Tools", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "***********************\nBuildout Sandbox Recipe\n***********************\n\n.. contents ::\n\nThis is a recipe for use with Buildout. It is identical to Buildout's\nzc.recipe.egg but has the following extra features:\n\n* Can install the scripts from any dependent package\n* Can setup an executable interpreter if you provide a suitable\n  application for your platform\n\n.. warning ::\n\n    This is very much alpha software and has only been tested on Debian Etch.\n    There are probably bugs on other platforms such as Windows. It is designed\n    more as a proof-of-concept than a production-ready recipe.\n\nTo get started first download the Buildout bootstrap::\n\n    wget \"http://svn.zope.org/*checkout*/zc.buildout/trunk/bootstrap/bootstrap.py\"\n\nThen create a ``buildout.cfg`` file, replacing ``/path/to/pylons/app/src`` with\nthe path to your Pylons application and replacing ``PylonsApp`` with the name\nof your application::\n\n    [buildout]\n    develop = /path/to/pylons/app/src\n    parts = python\n\n    [python]\n    recipe = pylons_sandbox\n    interpreter = python\n    eggs = PylonsApp\n\nYou can now buildout your application::\n\n    $ python bootstrap.py\n    $ bin/buildout\n\nSo far the ``pylons_sandbox`` recipe has behaved *exaclty* the same as the\ndefault ``zc.buildout.egg`` recipe, installing all the required dependencies\nfor your Pylons app to the local buildout sandbox. It has also set you up with\na ``bin/python`` script and a ``bin/buildout`` script which you can use to\nbuildout any future changes.\n\nFor Pylons use you should set the option ``dependent_scripts=True`` so that\nscripts from packages such as ``Nose`` and ``PasteScript`` get created in the\n``bin`` directoy::\n\n    [buildout]\n    develop = /path/to/pylons/app/src\n    parts = python\n\n    [python]\n    recipe = pylons_sandbox\n    interpreter = python\n    eggs = PylonsApp\n    dependent_scripts = True\n\nNow run the following to re-buildout the directory::\n\n    $ bin/buildout -N\n\nThe ``-N`` option means that buildout doesn't look for new dependencies if it\ncan meet them from files it already has installed. This means it is a bit\nquicker to re-buildout the directory.\n\nYou should now have a ``bin/paster`` command you can use to serve your Pylons\napplication.\n\nFor the majority of users this set up will be fine but the ``pylons_sandbox``\nrecipe has one more feature, the ``launcher`` option.\n\nIf you want to treat your buildout setup as a true sandbox you will need a\nPython interpreter which is an actual executable so that other scripts can use\nyour sandboxed Python interpreter in a #! line of in a script such as a CGI\nscript used by Apache. The ``python`` file generated by Buildout is actually\njust a Python script itself so can't be used in this manner.\n\nIf you set the ``launcher`` option, the ``pylons_sandbox`` recipe will create a\nnew interpreter by appending ``.buildout`` to the name specified in the\n``interpreter`` option and it will add a facility so that the directory of the\ncalling script is on sys.path. It will then copy the application specified by\nthe ``launcher`` option to the name specified in the ``interpreter`` option. In\nour exampls so far this means the buildout ``python`` script would be in\n``bin/python.buildout`` and the application to lauch it would be in\n``bin/python`` and could now be used in a ``#!`` line.\n\nThis is all well and good but you need the application itself. Here is some C++\ncode which when compiled will create a suitable application. It has been\ndescribed as \"gruesome\" so I'm happy to accept a patch with some neater C++. \nCreate a ``launcher.cc`` file with this content::\n\n    /*\n     * Buildout Launcher \n     * +++++++++++++++++\n     *\n     * This application excutes a python script in the same directory as the\n     * application. This is useful because it effectively turns a Python script\n     * into a real executable which you can use on the #! line of other scripts. \n     *\n     * The script to be executed should have the same name as the the filename of\n     * this compiled program but with a .py extension added to the end. The real\n     * Python interpreter used to execute the script is dermined from the script's\n     * #! line or /usr/bin/python is used as a fallback if no Python interpreter\n     * can be found. \n     *\n     * The Python interpreters generated by Buildout are actually just Python\n     * scripts so this application allows them to be run from a real executable.\n     *\n     * Compile this file with the following command:\n     *\n     *     g++ launcher.cc -o launcher\n     *\n     * Copyright James Gardner. MIT license. No warranty to the maximum extent\n     * possible under the law.\n     *\n     */\n    \n    #include <vector>\n    #include <string>\n    #include <unistd.h>\n    #include <fstream>\n    \n    using namespace std;\n    int main(int argc,char *argv[])\n    {\n        vector<string> args;\n        int i;\n        args.push_back(\"python\");\n        for (i=0;i<argc;i++) \n            args.push_back(argv[i]);\n        args[1] = strcat(argv[0], \".buildout\");\n        char *new_argv[argc+1];\n        for (int i=0 ; i<argc+1 ; i++)  {\n            new_argv[i] = (char *)args[i].c_str();\n        }\n        new_argv[argc+1] = NULL;\n        vector<string> text_file;\n        ifstream ifs(new_argv[1]);\n        string temp;\n        string temp_short;\n        getline(ifs, temp);\n        if (strncmp((char *)temp.c_str(), \"#!\", 2)) {\n            /* default to /usr/bin/python if no #! header */\n            temp_short = \"/usr/bin/python\";\n        } else {\n            temp_short = temp.substr(2,(temp.length()-2));\n        }\n        char python[temp_short.length()];\n        strcpy(python, (char *)temp_short.c_str());\n        return execv(python, new_argv);\n    }\n\n\nCompile this with::\n\n    $ g++ launcher.cc -o launcher\n\nand place the ``launcher`` application in the same directory as your\n``buildout.cfg``. You can then update your ``buildout.cfg`` to look like this::\n\n    [buildout]\n    develop = /path/to/pylons/app/src\n    parts = python\n\n    [python]\n    recipe = pylons_sandbox\n    interpreter = python\n    eggs = PylonsApp\n    dependent_scripts = True\n    launcher = launcher\n\nNow re-buildout again::\n\n    $ bin/buildout -N\n    \nYou should have a nicely working sandbox with a real Python executable as well\nas all the other benefits of deploying using the Buildout system.\n\nTest it out::\n\n    $ bin/python\n    >>> import pylons\n    >>> \n\nAs you can see all the module dependencies are present.\n\n\nChanges\n=======\n\n0.1.0\n\n* First release\n\n\nDownload\n========", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "UNKNOWN", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "pylons_sandbox", "package_url": "https://pypi.org/project/pylons_sandbox/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/pylons_sandbox/", "project_urls": {"Download": "UNKNOWN", "Homepage": "UNKNOWN"}, "release_url": "https://pypi.org/project/pylons_sandbox/0.1.0/", "requires_dist": null, "requires_python": null, "summary": "An experimental Buildout recipe backwards-compatible with zc.buildout.egg but with extra features for Pylons users.", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#changes\" id=\"id1\" rel=\"nofollow\">Changes</a></li>\n<li><a href=\"#download\" id=\"id2\" rel=\"nofollow\">Download</a></li>\n</ul>\n</div>\n<p>This is a recipe for use with Buildout. It is identical to Buildout\u2019s\nzc.recipe.egg but has the following extra features:</p>\n<ul>\n<li>Can install the scripts from any dependent package</li>\n<li>Can setup an executable interpreter if you provide a suitable\napplication for your platform</li>\n</ul>\n<div>\n<p>Warning</p>\n<p>This is very much alpha software and has only been tested on Debian Etch.\nThere are probably bugs on other platforms such as Windows. It is designed\nmore as a proof-of-concept than a production-ready recipe.</p>\n</div>\n<p>To get started first download the Buildout bootstrap:</p>\n<pre>wget \"http://svn.zope.org/*checkout*/zc.buildout/trunk/bootstrap/bootstrap.py\"\n</pre>\n<p>Then create a <tt>buildout.cfg</tt> file, replacing <tt>/path/to/pylons/app/src</tt> with\nthe path to your Pylons application and replacing <tt>PylonsApp</tt> with the name\nof your application:</p>\n<pre>[buildout]\ndevelop = /path/to/pylons/app/src\nparts = python\n\n[python]\nrecipe = pylons_sandbox\ninterpreter = python\neggs = PylonsApp\n</pre>\n<p>You can now buildout your application:</p>\n<pre>$ python bootstrap.py\n$ bin/buildout\n</pre>\n<p>So far the <tt>pylons_sandbox</tt> recipe has behaved <em>exaclty</em> the same as the\ndefault <tt>zc.buildout.egg</tt> recipe, installing all the required dependencies\nfor your Pylons app to the local buildout sandbox. It has also set you up with\na <tt>bin/python</tt> script and a <tt>bin/buildout</tt> script which you can use to\nbuildout any future changes.</p>\n<p>For Pylons use you should set the option <tt>dependent_scripts=True</tt> so that\nscripts from packages such as <tt>Nose</tt> and <tt>PasteScript</tt> get created in the\n<tt>bin</tt> directoy:</p>\n<pre>[buildout]\ndevelop = /path/to/pylons/app/src\nparts = python\n\n[python]\nrecipe = pylons_sandbox\ninterpreter = python\neggs = PylonsApp\ndependent_scripts = True\n</pre>\n<p>Now run the following to re-buildout the directory:</p>\n<pre>$ bin/buildout -N\n</pre>\n<p>The <tt><span class=\"pre\">-N</span></tt> option means that buildout doesn\u2019t look for new dependencies if it\ncan meet them from files it already has installed. This means it is a bit\nquicker to re-buildout the directory.</p>\n<p>You should now have a <tt>bin/paster</tt> command you can use to serve your Pylons\napplication.</p>\n<p>For the majority of users this set up will be fine but the <tt>pylons_sandbox</tt>\nrecipe has one more feature, the <tt>launcher</tt> option.</p>\n<p>If you want to treat your buildout setup as a true sandbox you will need a\nPython interpreter which is an actual executable so that other scripts can use\nyour sandboxed Python interpreter in a #! line of in a script such as a CGI\nscript used by Apache. The <tt>python</tt> file generated by Buildout is actually\njust a Python script itself so can\u2019t be used in this manner.</p>\n<p>If you set the <tt>launcher</tt> option, the <tt>pylons_sandbox</tt> recipe will create a\nnew interpreter by appending <tt>.buildout</tt> to the name specified in the\n<tt>interpreter</tt> option and it will add a facility so that the directory of the\ncalling script is on sys.path. It will then copy the application specified by\nthe <tt>launcher</tt> option to the name specified in the <tt>interpreter</tt> option. In\nour exampls so far this means the buildout <tt>python</tt> script would be in\n<tt>bin/python.buildout</tt> and the application to lauch it would be in\n<tt>bin/python</tt> and could now be used in a <tt>#!</tt> line.</p>\n<p>This is all well and good but you need the application itself. Here is some C++\ncode which when compiled will create a suitable application. It has been\ndescribed as \u201cgruesome\u201d so I\u2019m happy to accept a patch with some neater C++.\nCreate a <tt>launcher.cc</tt> file with this content:</p>\n<pre>/*\n * Buildout Launcher\n * +++++++++++++++++\n *\n * This application excutes a python script in the same directory as the\n * application. This is useful because it effectively turns a Python script\n * into a real executable which you can use on the #! line of other scripts.\n *\n * The script to be executed should have the same name as the the filename of\n * this compiled program but with a .py extension added to the end. The real\n * Python interpreter used to execute the script is dermined from the script's\n * #! line or /usr/bin/python is used as a fallback if no Python interpreter\n * can be found.\n *\n * The Python interpreters generated by Buildout are actually just Python\n * scripts so this application allows them to be run from a real executable.\n *\n * Compile this file with the following command:\n *\n *     g++ launcher.cc -o launcher\n *\n * Copyright James Gardner. MIT license. No warranty to the maximum extent\n * possible under the law.\n *\n */\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fstream&gt;\n\nusing namespace std;\nint main(int argc,char *argv[])\n{\n    vector&lt;string&gt; args;\n    int i;\n    args.push_back(\"python\");\n    for (i=0;i&lt;argc;i++)\n        args.push_back(argv[i]);\n    args[1] = strcat(argv[0], \".buildout\");\n    char *new_argv[argc+1];\n    for (int i=0 ; i&lt;argc+1 ; i++)  {\n        new_argv[i] = (char *)args[i].c_str();\n    }\n    new_argv[argc+1] = NULL;\n    vector&lt;string&gt; text_file;\n    ifstream ifs(new_argv[1]);\n    string temp;\n    string temp_short;\n    getline(ifs, temp);\n    if (strncmp((char *)temp.c_str(), \"#!\", 2)) {\n        /* default to /usr/bin/python if no #! header */\n        temp_short = \"/usr/bin/python\";\n    } else {\n        temp_short = temp.substr(2,(temp.length()-2));\n    }\n    char python[temp_short.length()];\n    strcpy(python, (char *)temp_short.c_str());\n    return execv(python, new_argv);\n}\n</pre>\n<p>Compile this with:</p>\n<pre>$ g++ launcher.cc -o launcher\n</pre>\n<p>and place the <tt>launcher</tt> application in the same directory as your\n<tt>buildout.cfg</tt>. You can then update your <tt>buildout.cfg</tt> to look like this:</p>\n<pre>[buildout]\ndevelop = /path/to/pylons/app/src\nparts = python\n\n[python]\nrecipe = pylons_sandbox\ninterpreter = python\neggs = PylonsApp\ndependent_scripts = True\nlauncher = launcher\n</pre>\n<p>Now re-buildout again:</p>\n<pre>$ bin/buildout -N\n</pre>\n<p>You should have a nicely working sandbox with a real Python executable as well\nas all the other benefits of deploying using the Buildout system.</p>\n<p>Test it out:</p>\n<pre>$ bin/python\n&gt;&gt;&gt; import pylons\n&gt;&gt;&gt;\n</pre>\n<p>As you can see all the module dependencies are present.</p>\n<div id=\"changes\">\n<h2><a href=\"#id1\" rel=\"nofollow\">Changes</a></h2>\n<p>0.1.0</p>\n<ul>\n<li>First release</li>\n</ul>\n</div>\n<div id=\"download\">\n<h2><a href=\"#id2\" rel=\"nofollow\">Download</a></h2>\n</div>\n\n          </div>"}, "last_serial": 797382, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "8b63874a2aed021d4798f6cc86edec14", "sha256": "9e98f61c62368de41ac8d7326d6dc1434878f5b3ba2d59fc691188132ece25be"}, "downloads": -1, "filename": "pylons_sandbox-0.1.0-py2.4.egg", "has_sig": false, "md5_digest": "8b63874a2aed021d4798f6cc86edec14", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 9658, "upload_time": "2007-09-30T15:36:28", "upload_time_iso_8601": "2007-09-30T15:36:28Z", "url": "https://files.pythonhosted.org/packages/d2/0c/41981833651ada022386ce20e348daec636921a7ce71d3c11ebb4dead9b1/pylons_sandbox-0.1.0-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "7844ddeac3fa6d693e07a8e5d2ab194a", "sha256": "3ada9645979fd29418fc5ab1ae3b1dfb5f6696a1ea737f63e8978bdfb14a878a"}, "downloads": -1, "filename": "pylons_sandbox-0.1.0.tar.gz", "has_sig": false, "md5_digest": "7844ddeac3fa6d693e07a8e5d2ab194a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6291, "upload_time": "2007-09-30T15:36:29", "upload_time_iso_8601": "2007-09-30T15:36:29Z", "url": "https://files.pythonhosted.org/packages/2b/10/51ca5fa6c976ed97f9c130f73a4e2fd52e39b29f7b7f6e381e536c28053f/pylons_sandbox-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "8b63874a2aed021d4798f6cc86edec14", "sha256": "9e98f61c62368de41ac8d7326d6dc1434878f5b3ba2d59fc691188132ece25be"}, "downloads": -1, "filename": "pylons_sandbox-0.1.0-py2.4.egg", "has_sig": false, "md5_digest": "8b63874a2aed021d4798f6cc86edec14", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 9658, "upload_time": "2007-09-30T15:36:28", "upload_time_iso_8601": "2007-09-30T15:36:28Z", "url": "https://files.pythonhosted.org/packages/d2/0c/41981833651ada022386ce20e348daec636921a7ce71d3c11ebb4dead9b1/pylons_sandbox-0.1.0-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "7844ddeac3fa6d693e07a8e5d2ab194a", "sha256": "3ada9645979fd29418fc5ab1ae3b1dfb5f6696a1ea737f63e8978bdfb14a878a"}, "downloads": -1, "filename": "pylons_sandbox-0.1.0.tar.gz", "has_sig": false, "md5_digest": "7844ddeac3fa6d693e07a8e5d2ab194a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6291, "upload_time": "2007-09-30T15:36:29", "upload_time_iso_8601": "2007-09-30T15:36:29Z", "url": "https://files.pythonhosted.org/packages/2b/10/51ca5fa6c976ed97f9c130f73a4e2fd52e39b29f7b7f6e381e536c28053f/pylons_sandbox-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:48 2020"}