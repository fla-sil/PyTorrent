{"info": {"author": "Tiarles Guterres", "author_email": "tiarlesmoralles@hotmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# Statistical Processing: A Python Statistical Signal Processing Package\n\nA package that construct an interface for filtering wavelet coefficients (using PyWavelets) with statistical methods\n## Getting started\n\nFirst you can import some modules like:\n``` python\n    import pywt\n    import numpy as np\n\n    import statsWaveletFilt.filtration as fil\n    import statsWaveletFilt.signals as sig\n    import statsWaveletFilt.miscellaneous as misc\n```\nAnd follow some steps to make your filtrations:\n\n### First step: Signal modelling\n\nIn many test for filtration and/or estimation of error, showed in articles, are supose an known ideal signal, how show the code above:\n``` python\n    import matplotlib.pyplot as plt\n\n    dimension = 1024\n\n    t, idealSignal = sig.dopplerFunction(dimension)\n    plt.plot(t, idealSignal, 'k-')\n    plt.show()\n```\n\nThis package also gives a support for anothers three ideal signal: the **heavsine** (``sig.heavsineFunction()``), **bump** (``sig.bumpFunction()``) and **block** (``sig.blockFunction()``).\n\nAnd add to this a kind of noise, generally *gaussian* or, also called, *normal*.\n``` python\n    noise = np.random.normal(0, .02, size=dimension)\n    noisySignal = idealSignal + noise\n\n    plt.plot(t, noisySignal, 'k-')\n    plt.show()\n```\n\n### Second step: Wavelet transformation\n\nLet's do this using the ``pywt.wavedec`` function. With this you can 1) make a wavelet transform of your noisy signal, 2) choice wich wavelet function is used (``'haar', 'db', 'gaus', 'mexh'`` among others) and 3) choice any levels you want to evaluate the transform.\n``` python\n    noisyCoeff = pywt.wavedec(noisySignal, 'db8', level=5)\n```\nThe first position ``= noiseCoeff[0]`` has the scale coefficents of the last n\u00edvel. The consecutive elements `` = noiseCoeff[1:]`` has the wavelet coefficients of the last to the first level of transform.\n\nUsing ``misc.showWaveletCoeff`` function you can show all coefficients returned of the transform.\n\n``` python\n    misc.showWaveletCoeff(noisyCoeff, title='Noisy Coefficients')\n```\n\n### Thirth step: Filtration\n\nWith the ``fil.filtration`` function you can put yours 1) coefficients for filtration, 2) choice the method (``'visu', 'sure', 'bayes', 'spc'``) and, if necessary, 3) set method own parameters (more details in documentation).\n``` python\n    filtrateCoeff, limiars = fil.filtration(noisyCoeff, method='visu')\n```\nAnd, again, you can show the wavelet coefficients before and after the filtration, with the limiar used using the ``misc.showWaveletCoeff`` function.\n\n``` python\n    misc.showWaveletCoeff(noisyCoeff, threshold_value=limiars, title='Noisy Coefficients')\n    print('==============================================================')\n    misc.showWaveletCoeff(filtrateCoeff, threshold_value=limiars, title='Filtered Coefficients')\n```\n\n### Fourth step: Recovery wavelet transformation\n\nUsing the ``pywt.waverec`` function we can revovery the signal.\n\n``` python\n    filtrateSignal = pywt.waverec(filtrateCoeff, 'db8')\n\n    plt.plot(t, filtrateSignal, 'k-')\n    plt.show()\n```\n\n### Fifth step: Figures of merith\nUsing ``sig.differential_snr_dB`` we can avaliate the filtration using some figures of merith of different forms of evaluate the snr or cnr (see more in Documentation) of the signal.\n``` python\n    sig.differential_snr_dB(noisySignal, filtratedSignal, method='variances', idealSignal=idealSignal)\n```\n### Appendix: Miscelaneous\n\n* The ``misc.generateData`` function generate data using the signals showed here with different variances of noise and save in format ``.npy``.\n* The ``misc.normalizeData`` function normalize a data between a min and max value, this function is used in all signals modeled in sig module.\n\n### References\n\n* [DONOHO, JOHNSTONE (1992), Ideal Spatial Adaptation by Wavelet Shrinkage](http://statweb.stanford.edu/~imj/WEBLIST/1994/isaws.pdf)\n* [DONOHO, JOHNSTONE (1994), Adapting to Unknown Smoothness via Wavelet Shrinkage](http://statweb.stanford.edu/~imj/WEBLIST/1995/ausws.pdf)\n* [CHANG, YU, VETTERLI (2000),Adaptive Wavelet Thresholding for Image Denoisingand Compression](https://core.ac.uk/download/pdf/147900624.pdf)\n* [BAYER, KOZAKEVICIUS (2010), SPC-Threshold: Uma Proposta de Limiariza\u00e7\u00e3o para Filtragem Adaptativa de Sinais](https://tema.sbmac.org.br/tema/article/download/96/43)\n* [KOZAKEVICIUS, BAYER (2014), Filtragem de sinais via limiariza\u00e7\u00e3o de coeficientes wavelet](http://oaji.net/articles/2017/1602-1487163088.pdf)\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Tiarles/Statistical-Wavelet-Filtering", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "statsWaveletFilt", "package_url": "https://pypi.org/project/statsWaveletFilt/", "platform": "", "project_url": "https://pypi.org/project/statsWaveletFilt/", "project_urls": {"Documentation": "https://statistical-wavelet-filtering.readthedocs.io/en/master/", "Homepage": "https://github.com/Tiarles/Statistical-Wavelet-Filtering", "Source": "https://github.com/Tiarles/Statistical-Wavelet-Filtering"}, "release_url": "https://pypi.org/project/statsWaveletFilt/0.0.4/", "requires_dist": null, "requires_python": "", "summary": "A statistical signal processing package", "version": "0.0.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Statistical Processing: A Python Statistical Signal Processing Package</h1>\n<p>A package that construct an interface for filtering wavelet coefficients (using PyWavelets) with statistical methods</p>\n<h2>Getting started</h2>\n<p>First you can import some modules like:</p>\n<pre>    <span class=\"kn\">import</span> <span class=\"nn\">pywt</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n    <span class=\"kn\">import</span> <span class=\"nn\">statsWaveletFilt.filtration</span> <span class=\"k\">as</span> <span class=\"nn\">fil</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">statsWaveletFilt.signals</span> <span class=\"k\">as</span> <span class=\"nn\">sig</span>\n    <span class=\"kn\">import</span> <span class=\"nn\">statsWaveletFilt.miscellaneous</span> <span class=\"k\">as</span> <span class=\"nn\">misc</span>\n</pre>\n<p>And follow some steps to make your filtrations:</p>\n<h3>First step: Signal modelling</h3>\n<p>In many test for filtration and/or estimation of error, showed in articles, are supose an known ideal signal, how show the code above:</p>\n<pre>    <span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n\n    <span class=\"n\">dimension</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span>\n\n    <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">idealSignal</span> <span class=\"o\">=</span> <span class=\"n\">sig</span><span class=\"o\">.</span><span class=\"n\">dopplerFunction</span><span class=\"p\">(</span><span class=\"n\">dimension</span><span class=\"p\">)</span>\n    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">idealSignal</span><span class=\"p\">,</span> <span class=\"s1\">'k-'</span><span class=\"p\">)</span>\n    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p>This package also gives a support for anothers three ideal signal: the <strong>heavsine</strong> (<code>sig.heavsineFunction()</code>), <strong>bump</strong> (<code>sig.bumpFunction()</code>) and <strong>block</strong> (<code>sig.blockFunction()</code>).</p>\n<p>And add to this a kind of noise, generally <em>gaussian</em> or, also called, <em>normal</em>.</p>\n<pre>    <span class=\"n\">noise</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">normal</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">.</span><span class=\"mi\">02</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"n\">dimension</span><span class=\"p\">)</span>\n    <span class=\"n\">noisySignal</span> <span class=\"o\">=</span> <span class=\"n\">idealSignal</span> <span class=\"o\">+</span> <span class=\"n\">noise</span>\n\n    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">noisySignal</span><span class=\"p\">,</span> <span class=\"s1\">'k-'</span><span class=\"p\">)</span>\n    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<h3>Second step: Wavelet transformation</h3>\n<p>Let's do this using the <code>pywt.wavedec</code> function. With this you can 1) make a wavelet transform of your noisy signal, 2) choice wich wavelet function is used (<code>'haar', 'db', 'gaus', 'mexh'</code> among others) and 3) choice any levels you want to evaluate the transform.</p>\n<pre>    <span class=\"n\">noisyCoeff</span> <span class=\"o\">=</span> <span class=\"n\">pywt</span><span class=\"o\">.</span><span class=\"n\">wavedec</span><span class=\"p\">(</span><span class=\"n\">noisySignal</span><span class=\"p\">,</span> <span class=\"s1\">'db8'</span><span class=\"p\">,</span> <span class=\"n\">level</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n</pre>\n<p>The first position <code>= noiseCoeff[0]</code> has the scale coefficents of the last n\u00edvel. The consecutive elements <code>= noiseCoeff[1:]</code> has the wavelet coefficients of the last to the first level of transform.</p>\n<p>Using <code>misc.showWaveletCoeff</code> function you can show all coefficients returned of the transform.</p>\n<pre>    <span class=\"n\">misc</span><span class=\"o\">.</span><span class=\"n\">showWaveletCoeff</span><span class=\"p\">(</span><span class=\"n\">noisyCoeff</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"s1\">'Noisy Coefficients'</span><span class=\"p\">)</span>\n</pre>\n<h3>Thirth step: Filtration</h3>\n<p>With the <code>fil.filtration</code> function you can put yours 1) coefficients for filtration, 2) choice the method (<code>'visu', 'sure', 'bayes', 'spc'</code>) and, if necessary, 3) set method own parameters (more details in documentation).</p>\n<pre>    <span class=\"n\">filtrateCoeff</span><span class=\"p\">,</span> <span class=\"n\">limiars</span> <span class=\"o\">=</span> <span class=\"n\">fil</span><span class=\"o\">.</span><span class=\"n\">filtration</span><span class=\"p\">(</span><span class=\"n\">noisyCoeff</span><span class=\"p\">,</span> <span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">'visu'</span><span class=\"p\">)</span>\n</pre>\n<p>And, again, you can show the wavelet coefficients before and after the filtration, with the limiar used using the <code>misc.showWaveletCoeff</code> function.</p>\n<pre>    <span class=\"n\">misc</span><span class=\"o\">.</span><span class=\"n\">showWaveletCoeff</span><span class=\"p\">(</span><span class=\"n\">noisyCoeff</span><span class=\"p\">,</span> <span class=\"n\">threshold_value</span><span class=\"o\">=</span><span class=\"n\">limiars</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"s1\">'Noisy Coefficients'</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'=============================================================='</span><span class=\"p\">)</span>\n    <span class=\"n\">misc</span><span class=\"o\">.</span><span class=\"n\">showWaveletCoeff</span><span class=\"p\">(</span><span class=\"n\">filtrateCoeff</span><span class=\"p\">,</span> <span class=\"n\">threshold_value</span><span class=\"o\">=</span><span class=\"n\">limiars</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"s1\">'Filtered Coefficients'</span><span class=\"p\">)</span>\n</pre>\n<h3>Fourth step: Recovery wavelet transformation</h3>\n<p>Using the <code>pywt.waverec</code> function we can revovery the signal.</p>\n<pre>    <span class=\"n\">filtrateSignal</span> <span class=\"o\">=</span> <span class=\"n\">pywt</span><span class=\"o\">.</span><span class=\"n\">waverec</span><span class=\"p\">(</span><span class=\"n\">filtrateCoeff</span><span class=\"p\">,</span> <span class=\"s1\">'db8'</span><span class=\"p\">)</span>\n\n    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">filtrateSignal</span><span class=\"p\">,</span> <span class=\"s1\">'k-'</span><span class=\"p\">)</span>\n    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<h3>Fifth step: Figures of merith</h3>\n<p>Using <code>sig.differential_snr_dB</code> we can avaliate the filtration using some figures of merith of different forms of evaluate the snr or cnr (see more in Documentation) of the signal.</p>\n<pre>    <span class=\"n\">sig</span><span class=\"o\">.</span><span class=\"n\">differential_snr_dB</span><span class=\"p\">(</span><span class=\"n\">noisySignal</span><span class=\"p\">,</span> <span class=\"n\">filtratedSignal</span><span class=\"p\">,</span> <span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">'variances'</span><span class=\"p\">,</span> <span class=\"n\">idealSignal</span><span class=\"o\">=</span><span class=\"n\">idealSignal</span><span class=\"p\">)</span>\n</pre>\n<h3>Appendix: Miscelaneous</h3>\n<ul>\n<li>The <code>misc.generateData</code> function generate data using the signals showed here with different variances of noise and save in format <code>.npy</code>.</li>\n<li>The <code>misc.normalizeData</code> function normalize a data between a min and max value, this function is used in all signals modeled in sig module.</li>\n</ul>\n<h3>References</h3>\n<ul>\n<li><a href=\"http://statweb.stanford.edu/%7Eimj/WEBLIST/1994/isaws.pdf\" rel=\"nofollow\">DONOHO, JOHNSTONE (1992), Ideal Spatial Adaptation by Wavelet Shrinkage</a></li>\n<li><a href=\"http://statweb.stanford.edu/%7Eimj/WEBLIST/1995/ausws.pdf\" rel=\"nofollow\">DONOHO, JOHNSTONE (1994), Adapting to Unknown Smoothness via Wavelet Shrinkage</a></li>\n<li><a href=\"https://core.ac.uk/download/pdf/147900624.pdf\" rel=\"nofollow\">CHANG, YU, VETTERLI (2000),Adaptive Wavelet Thresholding for Image Denoisingand Compression</a></li>\n<li><a href=\"https://tema.sbmac.org.br/tema/article/download/96/43\" rel=\"nofollow\">BAYER, KOZAKEVICIUS (2010), SPC-Threshold: Uma Proposta de Limiariza\u00e7\u00e3o para Filtragem Adaptativa de Sinais</a></li>\n<li><a href=\"http://oaji.net/articles/2017/1602-1487163088.pdf\" rel=\"nofollow\">KOZAKEVICIUS, BAYER (2014), Filtragem de sinais via limiariza\u00e7\u00e3o de coeficientes wavelet</a></li>\n</ul>\n\n          </div>"}, "last_serial": 5126704, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "ed2db4106662218d47773e701326b8ba", "sha256": "4645478b135ee38703988c01bcd32c970c825bb8f74b82bac97146e273b260ca"}, "downloads": -1, "filename": "statsWaveletFilt-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "ed2db4106662218d47773e701326b8ba", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 28046, "upload_time": "2019-04-11T00:27:10", "upload_time_iso_8601": "2019-04-11T00:27:10.151393Z", "url": "https://files.pythonhosted.org/packages/53/60/bd803c752bb44cdd1ab1042f25396922ae82df18547e1e205fcbfb854261/statsWaveletFilt-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "783ab91366532a43e1ea2bf3d2303136", "sha256": "cbb8f118edb9e4ecbded1ad58baa88fc87d7b91498c6a24b60c7c96795819894"}, "downloads": -1, "filename": "statsWaveletFilt-0.0.1.tar.gz", "has_sig": false, "md5_digest": "783ab91366532a43e1ea2bf3d2303136", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13761, "upload_time": "2019-04-11T00:27:12", "upload_time_iso_8601": "2019-04-11T00:27:12.386816Z", "url": "https://files.pythonhosted.org/packages/29/69/b067468a96dbde0280435aae3b2197202b4f0d0a999318e1e6b748e40020/statsWaveletFilt-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "f62997aedc88464846f1dd02ce6ace06", "sha256": "08f9d201db5579471f7845de76aa7fd595e574366ed3e45db15cd64f3b9dd9dc"}, "downloads": -1, "filename": "statsWaveletFilt-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "f62997aedc88464846f1dd02ce6ace06", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 28043, "upload_time": "2019-04-11T00:28:31", "upload_time_iso_8601": "2019-04-11T00:28:31.866625Z", "url": "https://files.pythonhosted.org/packages/4f/d0/dc7ec90fcc59af64fe085c5bd1cda77f93189256ce6080aaa411cb3e9764/statsWaveletFilt-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a09b6b661403c7141e0ebfc68df724d2", "sha256": "3a2b6c5b5027f85dcac3120d6e2304f99d3fbc00cce467ea5518356a58c931fb"}, "downloads": -1, "filename": "statsWaveletFilt-0.0.2.tar.gz", "has_sig": false, "md5_digest": "a09b6b661403c7141e0ebfc68df724d2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13744, "upload_time": "2019-04-11T00:28:34", "upload_time_iso_8601": "2019-04-11T00:28:34.257047Z", "url": "https://files.pythonhosted.org/packages/3d/26/88f54159787fae3db7c8a6c51bd5608183d7bafb80e592cd2b2b0e75941c/statsWaveletFilt-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "bd59ca84d7fdfa4a69407a7e17a20e40", "sha256": "5613933c7ec532d5503a7dfc8da6a783f76120e201f67ce392c1f275734b5f87"}, "downloads": -1, "filename": "statsWaveletFilt-0.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "bd59ca84d7fdfa4a69407a7e17a20e40", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 28094, "upload_time": "2019-04-11T00:44:30", "upload_time_iso_8601": "2019-04-11T00:44:30.404714Z", "url": "https://files.pythonhosted.org/packages/48/15/7c8375d8f534c9aa7751c564827c55b0d4ac1317e5e73da308e2c3243e8a/statsWaveletFilt-0.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "60370c7192d7433b5344ee737b181db2", "sha256": "f43e1646e1ce09effe6787ff9c36efa57e72699e473aabaaf33eef9ea695d4cb"}, "downloads": -1, "filename": "statsWaveletFilt-0.0.3.tar.gz", "has_sig": false, "md5_digest": "60370c7192d7433b5344ee737b181db2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13892, "upload_time": "2019-04-11T00:44:33", "upload_time_iso_8601": "2019-04-11T00:44:33.536446Z", "url": "https://files.pythonhosted.org/packages/a7/8b/d80caf778e4dd32b93a79b939c084ea05a61167ac4dfb1511b31761d6dba/statsWaveletFilt-0.0.3.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "9b19c53d3931125cf87ffd58a0aae927", "sha256": "866c63e6d4c62a3db8d2382a7fdc0eb755347c38e3490091fecc3d9ab2237627"}, "downloads": -1, "filename": "statsWaveletFilt-0.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "9b19c53d3931125cf87ffd58a0aae927", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 28092, "upload_time": "2019-04-11T01:22:24", "upload_time_iso_8601": "2019-04-11T01:22:24.084805Z", "url": "https://files.pythonhosted.org/packages/8e/c8/80b9782b36253b883c1b1b4099cf2e3c97b4d176bd27c83e6cc5866e9faf/statsWaveletFilt-0.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "106c8da5c8f0169e60ecb8cd734d42a7", "sha256": "09bae509851962537f100a6cbe1178f1009d3b00abbd13eae7837dff4e773e1a"}, "downloads": -1, "filename": "statsWaveletFilt-0.0.4.tar.gz", "has_sig": false, "md5_digest": "106c8da5c8f0169e60ecb8cd734d42a7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13891, "upload_time": "2019-04-11T01:22:28", "upload_time_iso_8601": "2019-04-11T01:22:28.028603Z", "url": "https://files.pythonhosted.org/packages/85/f9/2d2b9d4c0d95dc54ca4cc1e6f9829bb39ec4440f2425a3b4a62647adcfa0/statsWaveletFilt-0.0.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9b19c53d3931125cf87ffd58a0aae927", "sha256": "866c63e6d4c62a3db8d2382a7fdc0eb755347c38e3490091fecc3d9ab2237627"}, "downloads": -1, "filename": "statsWaveletFilt-0.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "9b19c53d3931125cf87ffd58a0aae927", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 28092, "upload_time": "2019-04-11T01:22:24", "upload_time_iso_8601": "2019-04-11T01:22:24.084805Z", "url": "https://files.pythonhosted.org/packages/8e/c8/80b9782b36253b883c1b1b4099cf2e3c97b4d176bd27c83e6cc5866e9faf/statsWaveletFilt-0.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "106c8da5c8f0169e60ecb8cd734d42a7", "sha256": "09bae509851962537f100a6cbe1178f1009d3b00abbd13eae7837dff4e773e1a"}, "downloads": -1, "filename": "statsWaveletFilt-0.0.4.tar.gz", "has_sig": false, "md5_digest": "106c8da5c8f0169e60ecb8cd734d42a7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13891, "upload_time": "2019-04-11T01:22:28", "upload_time_iso_8601": "2019-04-11T01:22:28.028603Z", "url": "https://files.pythonhosted.org/packages/85/f9/2d2b9d4c0d95dc54ca4cc1e6f9829bb39ec4440f2425a3b4a62647adcfa0/statsWaveletFilt-0.0.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:20 2020"}