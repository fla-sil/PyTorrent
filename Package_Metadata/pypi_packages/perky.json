{"info": {"author": "Larry Hastings", "author_email": "larry@hastings.org", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Programming Language :: Python :: 3 :: Only"], "description": "# perky\n\n## A friendly, easy, Pythonic text file format\n\n##### Copyright 2018-2020 by Larry Hastings\n\n\n### Overview\n\nPerky is a new, simple \"rcfile\" text file format for Python programs.\n\nThe following are Perky features:\n\n#### Perky syntax\n\nPerky configuration files look something like JSON without the\nquoting.\n\n    example name = value\n    example dict = {\n        name = 3\n        another name = 5.0\n        }\n    example list = [\n        a\n        b\n        c\n        ]\n    # lines starting with hash are ignored\n\n    # blank lines are ignored\n\n    \" quoted name \" = \" quoted value \"\n\n    triple quoted string = \"\"\"\n\n        indenting\n            is preserved\n\n        the string is automatically outdented\n        to the leftmost character of the ending\n        triple-quote\n\n        <-- aka here\n        \"\"\"\n\n    =pragma argument\n\n#### Explicit transformation is better than implicit\n\nOne possibly-surprising design choice of Perky: the only\nnatively supported values for the Perky parser are dicts,\nlists, and strings.  Other commonly-used types (ints, floats,\netc) are handled using a different mechanism: _transformation._\n\nA Perky transformation takes a dict as input, and transforms\nthe contents of the dict based on a _schema_.  A Perky schema\nis a dict with the same general shape as the dict produced\nby the Perky parse, but it contains dicts, lists,\nand *transformation functions*.\nIf you want *myvalue* in `{'myvalue':'3'}` to be a real integer,\ntransform it with the schema `{'myvalue': int}`.\n\nNote that Perky doesn't care how or if you transform your\ndata.  You can use it as-is, or transform it, or transform\nit with multiple passes, or use an external transformation technology like\n[Marshmallow.](https://marshmallow.readthedocs.io/en/3.0/)\n\n### Pragmas\n\nA *pragma* is a metadata directive for the Perky parser.\nIt's a way of sending instructions to the Perky parser from\ninside a bit of Perky text.\n\nHere's an example pragma directive:\n\n`=foo bar bat`\n\nThe first word after the equals sign is the name of the pragma, in this case `\"foo\"`.\nEverything after the name of the pragma is an argument, with all leading\nand trailing whitespace removed, in this case `\"bar bat\"`.\n\nBy default, Perky doesn't have any pragma handlers.  And invoking a pragma\nwhen Perky doesn't have a handler for it is a runtime error.\nBut you can define your own pragma handlers when you call `perky.load()`\nor `perky.loads()`, using a named parameter called `pragmas`.\nIf you pass in a value for `pragmas`, it must be a mapping\nof strings to functions.\nThe string name should be the name of the pragma (and must be lowercase).\nThe function it maps to will \"handle\" that pragma, and should look like this:\n\n`def pragma_fn(parser, argument)`\n\n`parser` is the internal Perky `Parser` object.  `argument` is the\nrest of the relevant line, with leading & trailing whitespace stripped.\n\nThere's currently one predefined pragma handler, a function called\n`perky.pragma_include()`.  This adds \"include statement\" functionality\nto Perky.  If you call this:\n\n`perky.load(filename, pragmas={'include': perky.pragma_include})`\n\nthen Perky will interpret lines inside `filename` starting with `=include`\nas include statements, using the rest of the line as the name of a file.\nFor more information, see `pragma_include()` below.\n\nThe rules of pragmas:\n* To invoke a pragma, use `=` as the first non-whitespace character\n  on a line.\n* pragmas must always be lowercase.\n* pragmas are always global.  You can call pragmas\n  inside a nested dict or list but, if they change data,\n  they'll always operate on the outermost dict.\n* You can't invoke a pragma inside a triple-quoted string.\n* It's best to have all your pragmas at the top of your Perky text.\n\n### API\n\n`perky.loads(s, *, pragmas=None) -> d`\n\nParses a string containing Perky-file-format settings.\nReturns a dict.\n\n`perky.load(filename, *, pragmas=None, encoding=\"utf-8\") -> d`\n\nParses a file containing Perky-file-format settings.\nReturns a dict.\n\n`perky.dumps(d) -> s`\n\nConverts a dictionary to a Perky-file-format string.\nKeys in the dictionary must all be strings.  Values\nthat are not dicts, lists, or strings will be converted\nto strings using str.\nReturns a string.\n\n`perky.dump(filename, d, *, encoding=\"utf-8\")`\n\nConverts a dictionary to a Perky-file-format string\nusing `perky.dump`, then writes it to *filename*.\n\n`perky.include(d, recursive=True, encoding=\"utf-8\") -> d`\n\nProcesses an `include` directive inside a dictionary.  The first\nargument `d` must be a dictionary.\n\nIf `d[\"include\"]` is set, that value is used as a filename.\n`perky.include()` will execute `perky.load(filename)` using the encoding\npassed in, then merge dictionary into `d`--however existing values in `d`\ntake precedence.  If `recursive` is set, then `perky.include()` will\nrecursively process includes in those dictionaries.\n\nReturns this final merged dictionary.\n\n`perky.includes(d, recursive=True, encoding=\"utf-8\") -> d`\n\nSimilar to `perky.include`, except the name of the key\nis `d[\"includes\"]`, and it must contain a *list* of filenames\nrather than simply one filename.  `perky.includes()` will then\nread in all those filenames, merge them together, then merge\nthat with the `d` passed in.\n\n`pragma_include(...)`\n\nA pre-written pragma handler for you.  If you use this function\nto handle `\"include\"` pragmas, then the pragma `=include foo` will\n`perky.load()` the file `foo` into the current (top-level) dictionary\nbeing loaded.  `pragma_include()` will pass in the current pragma\nhandlers into `perky.load()`, allowing for (for example) recursive\nincldues.\n\n`perky.map(d, fn) -> o`\n\nIterates over a dictionary.  Returns a new dictionary where,\nfor every *value*:\n  * if it is a dict, replace with a new dict.\n  * if it is a list, replace with a new list.\n  * if it is neither a dict nor a list, replace with\n    `fn(value)`.\n\nThe function passed in is called a *conversion function*.\n\n`perky.transform(d, schema, default=None) -> o`\n\nRecursively transforms a Perky dict into some other\nobject (usually a dict) using the provided schema.\nReturns a new dict.\n\nA *schema* is a data structure matching the general expected\nshape of *d*, where the values are dicts, lists, and\ncallables.  The transformation is similar to `perky.map()`\nexcept that individual values will have individual conversion\nfunctions.  Also, a schema conversion function can be specified\nfor any value in *d*, even dicts or lists.\n\n*default* is a default conversion function.  If there is a\nvalue *v* in *d* that doesn't have an equivalent entry in *schema*,\nand *v* is neither a list nor a dict, and if *default* is\na callable, *v* will be replaced with `default(v)` in the\noutput.\n\n`perky.Required`\n\nExperimental.\n\n`perky.nullable(fn) -> fn`\n\nExperimental.\n\n`perky.const(fn) -> o`\n\nExperimental.\n\n\n### TODO\n\n* Backslash quoting currently does \"whatever your version of Python does\".  Perhaps this should be explicit, and parsed by Perky itself?\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/larryhastings/perky/", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "perky", "package_url": "https://pypi.org/project/perky/", "platform": "", "project_url": "https://pypi.org/project/perky/", "project_urls": {"Homepage": "https://github.com/larryhastings/perky/"}, "release_url": "https://pypi.org/project/perky/0.1.3/", "requires_dist": null, "requires_python": ">=3.5", "summary": "A simple, Pythonic file format.  Same interface as the", "version": "0.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>perky</h1>\n<h2>A friendly, easy, Pythonic text file format</h2>\n<h5>Copyright 2018-2020 by Larry Hastings</h5>\n<h3>Overview</h3>\n<p>Perky is a new, simple \"rcfile\" text file format for Python programs.</p>\n<p>The following are Perky features:</p>\n<h4>Perky syntax</h4>\n<p>Perky configuration files look something like JSON without the\nquoting.</p>\n<pre><code>example name = value\nexample dict = {\n    name = 3\n    another name = 5.0\n    }\nexample list = [\n    a\n    b\n    c\n    ]\n# lines starting with hash are ignored\n\n# blank lines are ignored\n\n\" quoted name \" = \" quoted value \"\n\ntriple quoted string = \"\"\"\n\n    indenting\n        is preserved\n\n    the string is automatically outdented\n    to the leftmost character of the ending\n    triple-quote\n\n    &lt;-- aka here\n    \"\"\"\n\n=pragma argument\n</code></pre>\n<h4>Explicit transformation is better than implicit</h4>\n<p>One possibly-surprising design choice of Perky: the only\nnatively supported values for the Perky parser are dicts,\nlists, and strings.  Other commonly-used types (ints, floats,\netc) are handled using a different mechanism: <em>transformation.</em></p>\n<p>A Perky transformation takes a dict as input, and transforms\nthe contents of the dict based on a <em>schema</em>.  A Perky schema\nis a dict with the same general shape as the dict produced\nby the Perky parse, but it contains dicts, lists,\nand <em>transformation functions</em>.\nIf you want <em>myvalue</em> in <code>{'myvalue':'3'}</code> to be a real integer,\ntransform it with the schema <code>{'myvalue': int}</code>.</p>\n<p>Note that Perky doesn't care how or if you transform your\ndata.  You can use it as-is, or transform it, or transform\nit with multiple passes, or use an external transformation technology like\n<a href=\"https://marshmallow.readthedocs.io/en/3.0/\" rel=\"nofollow\">Marshmallow.</a></p>\n<h3>Pragmas</h3>\n<p>A <em>pragma</em> is a metadata directive for the Perky parser.\nIt's a way of sending instructions to the Perky parser from\ninside a bit of Perky text.</p>\n<p>Here's an example pragma directive:</p>\n<p><code>=foo bar bat</code></p>\n<p>The first word after the equals sign is the name of the pragma, in this case <code>\"foo\"</code>.\nEverything after the name of the pragma is an argument, with all leading\nand trailing whitespace removed, in this case <code>\"bar bat\"</code>.</p>\n<p>By default, Perky doesn't have any pragma handlers.  And invoking a pragma\nwhen Perky doesn't have a handler for it is a runtime error.\nBut you can define your own pragma handlers when you call <code>perky.load()</code>\nor <code>perky.loads()</code>, using a named parameter called <code>pragmas</code>.\nIf you pass in a value for <code>pragmas</code>, it must be a mapping\nof strings to functions.\nThe string name should be the name of the pragma (and must be lowercase).\nThe function it maps to will \"handle\" that pragma, and should look like this:</p>\n<p><code>def pragma_fn(parser, argument)</code></p>\n<p><code>parser</code> is the internal Perky <code>Parser</code> object.  <code>argument</code> is the\nrest of the relevant line, with leading &amp; trailing whitespace stripped.</p>\n<p>There's currently one predefined pragma handler, a function called\n<code>perky.pragma_include()</code>.  This adds \"include statement\" functionality\nto Perky.  If you call this:</p>\n<p><code>perky.load(filename, pragmas={'include': perky.pragma_include})</code></p>\n<p>then Perky will interpret lines inside <code>filename</code> starting with <code>=include</code>\nas include statements, using the rest of the line as the name of a file.\nFor more information, see <code>pragma_include()</code> below.</p>\n<p>The rules of pragmas:</p>\n<ul>\n<li>To invoke a pragma, use <code>=</code> as the first non-whitespace character\non a line.</li>\n<li>pragmas must always be lowercase.</li>\n<li>pragmas are always global.  You can call pragmas\ninside a nested dict or list but, if they change data,\nthey'll always operate on the outermost dict.</li>\n<li>You can't invoke a pragma inside a triple-quoted string.</li>\n<li>It's best to have all your pragmas at the top of your Perky text.</li>\n</ul>\n<h3>API</h3>\n<p><code>perky.loads(s, *, pragmas=None) -&gt; d</code></p>\n<p>Parses a string containing Perky-file-format settings.\nReturns a dict.</p>\n<p><code>perky.load(filename, *, pragmas=None, encoding=\"utf-8\") -&gt; d</code></p>\n<p>Parses a file containing Perky-file-format settings.\nReturns a dict.</p>\n<p><code>perky.dumps(d) -&gt; s</code></p>\n<p>Converts a dictionary to a Perky-file-format string.\nKeys in the dictionary must all be strings.  Values\nthat are not dicts, lists, or strings will be converted\nto strings using str.\nReturns a string.</p>\n<p><code>perky.dump(filename, d, *, encoding=\"utf-8\")</code></p>\n<p>Converts a dictionary to a Perky-file-format string\nusing <code>perky.dump</code>, then writes it to <em>filename</em>.</p>\n<p><code>perky.include(d, recursive=True, encoding=\"utf-8\") -&gt; d</code></p>\n<p>Processes an <code>include</code> directive inside a dictionary.  The first\nargument <code>d</code> must be a dictionary.</p>\n<p>If <code>d[\"include\"]</code> is set, that value is used as a filename.\n<code>perky.include()</code> will execute <code>perky.load(filename)</code> using the encoding\npassed in, then merge dictionary into <code>d</code>--however existing values in <code>d</code>\ntake precedence.  If <code>recursive</code> is set, then <code>perky.include()</code> will\nrecursively process includes in those dictionaries.</p>\n<p>Returns this final merged dictionary.</p>\n<p><code>perky.includes(d, recursive=True, encoding=\"utf-8\") -&gt; d</code></p>\n<p>Similar to <code>perky.include</code>, except the name of the key\nis <code>d[\"includes\"]</code>, and it must contain a <em>list</em> of filenames\nrather than simply one filename.  <code>perky.includes()</code> will then\nread in all those filenames, merge them together, then merge\nthat with the <code>d</code> passed in.</p>\n<p><code>pragma_include(...)</code></p>\n<p>A pre-written pragma handler for you.  If you use this function\nto handle <code>\"include\"</code> pragmas, then the pragma <code>=include foo</code> will\n<code>perky.load()</code> the file <code>foo</code> into the current (top-level) dictionary\nbeing loaded.  <code>pragma_include()</code> will pass in the current pragma\nhandlers into <code>perky.load()</code>, allowing for (for example) recursive\nincldues.</p>\n<p><code>perky.map(d, fn) -&gt; o</code></p>\n<p>Iterates over a dictionary.  Returns a new dictionary where,\nfor every <em>value</em>:</p>\n<ul>\n<li>if it is a dict, replace with a new dict.</li>\n<li>if it is a list, replace with a new list.</li>\n<li>if it is neither a dict nor a list, replace with\n<code>fn(value)</code>.</li>\n</ul>\n<p>The function passed in is called a <em>conversion function</em>.</p>\n<p><code>perky.transform(d, schema, default=None) -&gt; o</code></p>\n<p>Recursively transforms a Perky dict into some other\nobject (usually a dict) using the provided schema.\nReturns a new dict.</p>\n<p>A <em>schema</em> is a data structure matching the general expected\nshape of <em>d</em>, where the values are dicts, lists, and\ncallables.  The transformation is similar to <code>perky.map()</code>\nexcept that individual values will have individual conversion\nfunctions.  Also, a schema conversion function can be specified\nfor any value in <em>d</em>, even dicts or lists.</p>\n<p><em>default</em> is a default conversion function.  If there is a\nvalue <em>v</em> in <em>d</em> that doesn't have an equivalent entry in <em>schema</em>,\nand <em>v</em> is neither a list nor a dict, and if <em>default</em> is\na callable, <em>v</em> will be replaced with <code>default(v)</code> in the\noutput.</p>\n<p><code>perky.Required</code></p>\n<p>Experimental.</p>\n<p><code>perky.nullable(fn) -&gt; fn</code></p>\n<p>Experimental.</p>\n<p><code>perky.const(fn) -&gt; o</code></p>\n<p>Experimental.</p>\n<h3>TODO</h3>\n<ul>\n<li>Backslash quoting currently does \"whatever your version of Python does\".  Perhaps this should be explicit, and parsed by Perky itself?</li>\n</ul>\n\n          </div>"}, "last_serial": 6607508, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "28873a9c0cd66a515ed5334a4f692600", "sha256": "0f895c74c3c1e3acd96a45b7f63def4df934cf786a53d950067b2e9b7bf8da4d"}, "downloads": -1, "filename": "perky-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "28873a9c0cd66a515ed5334a4f692600", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 26502, "upload_time": "2018-07-02T06:31:33", "upload_time_iso_8601": "2018-07-02T06:31:33.909029Z", "url": "https://files.pythonhosted.org/packages/6a/58/ea119f7d0faf09927e40e696242e63e8627763bc795f3cbbf74691f1d51f/perky-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5d261bfa392721980e6b81bedaae8f91", "sha256": "7e36837bcb2357caf792aa057f221e8987e55e19f80ea967b7e2a999af63b3b3"}, "downloads": -1, "filename": "perky-0.1.tar.gz", "has_sig": false, "md5_digest": "5d261bfa392721980e6b81bedaae8f91", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 9667, "upload_time": "2018-07-02T06:31:35", "upload_time_iso_8601": "2018-07-02T06:31:35.680020Z", "url": "https://files.pythonhosted.org/packages/23/60/3f9663a44fe4d74f380f7d5e976bed4e7367a6190fc6bb5f6383be778007/perky-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "d3e85c0a985305634b6d8a380deb387d", "sha256": "96f39538a6482417d2a40d5beacdcef556abcf765485b218e2f014534b5f1ee3"}, "downloads": -1, "filename": "perky-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "d3e85c0a985305634b6d8a380deb387d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 28205, "upload_time": "2018-07-02T07:08:20", "upload_time_iso_8601": "2018-07-02T07:08:20.428449Z", "url": "https://files.pythonhosted.org/packages/c9/24/ec6f0d5a45f2aca233cdcd8fe1f6524964059ba75a6705b9c14dbd0b1343/perky-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ebb66569739a92f80733c830d9bb9863", "sha256": "82c8002e2447b53b157ac222882302d2b6b5a2d93a03f78179dc4fc459c21334"}, "downloads": -1, "filename": "perky-0.1.1.tar.gz", "has_sig": false, "md5_digest": "ebb66569739a92f80733c830d9bb9863", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 10458, "upload_time": "2018-07-02T07:08:21", "upload_time_iso_8601": "2018-07-02T07:08:21.755904Z", "url": "https://files.pythonhosted.org/packages/5f/e6/18da8322e7197a1511cb57bc636a63487f12a541841b3d39383695e36aac/perky-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "d7392c5b99c7a9fd1b52c4a128465bb3", "sha256": "62f3f497f3b1cc32cc93941b2ab047d319b263e7c179e138b31445ae17fa6bac"}, "downloads": -1, "filename": "perky-0.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "d7392c5b99c7a9fd1b52c4a128465bb3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 28830, "upload_time": "2019-05-05T20:23:01", "upload_time_iso_8601": "2019-05-05T20:23:01.183639Z", "url": "https://files.pythonhosted.org/packages/02/5a/4c30b87f8046e1a455f93661da80c22cd486308daddd0d824cb53ce2c57b/perky-0.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a7f332e809bd339fcfbc53961c676707", "sha256": "98d5b57ce7de0b3e457ae67d3cef9b3780f36efaf084d5b4f151c4ebba006e48"}, "downloads": -1, "filename": "perky-0.1.2.tar.gz", "has_sig": false, "md5_digest": "a7f332e809bd339fcfbc53961c676707", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 10750, "upload_time": "2019-05-05T20:23:03", "upload_time_iso_8601": "2019-05-05T20:23:03.063955Z", "url": "https://files.pythonhosted.org/packages/db/fe/ebb9e2e161059e55114f439059f5561b324591291cd2f772ecc5a4923373/perky-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "17b9fe8b2c5128b7e3a63d931aeb438e", "sha256": "ac191626f4de6b4b0504f279929ec8fe8affa63c6642b6aedd5a28a341562bfc"}, "downloads": -1, "filename": "perky-0.1.3-py3-none-any.whl", "has_sig": false, "md5_digest": "17b9fe8b2c5128b7e3a63d931aeb438e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 12885, "upload_time": "2020-02-11T07:08:07", "upload_time_iso_8601": "2020-02-11T07:08:07.387312Z", "url": "https://files.pythonhosted.org/packages/df/64/3b0403cf6c0ba10f975e213526ecf6d56941d938398231219a0b7efeaa3e/perky-0.1.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0626b8dde3699d21b971437071d91459", "sha256": "eb60e6dd28ef5f964fe39da61a3c26f835378bdda3399d058ee0a61e3416e8ea"}, "downloads": -1, "filename": "perky-0.1.3.tar.gz", "has_sig": false, "md5_digest": "0626b8dde3699d21b971437071d91459", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 12873, "upload_time": "2020-02-11T07:08:09", "upload_time_iso_8601": "2020-02-11T07:08:09.238487Z", "url": "https://files.pythonhosted.org/packages/1b/1e/66bde5c6632790fa52e2b0a8870ba239ab7ba80ad1e59fcf30749132ae57/perky-0.1.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "17b9fe8b2c5128b7e3a63d931aeb438e", "sha256": "ac191626f4de6b4b0504f279929ec8fe8affa63c6642b6aedd5a28a341562bfc"}, "downloads": -1, "filename": "perky-0.1.3-py3-none-any.whl", "has_sig": false, "md5_digest": "17b9fe8b2c5128b7e3a63d931aeb438e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 12885, "upload_time": "2020-02-11T07:08:07", "upload_time_iso_8601": "2020-02-11T07:08:07.387312Z", "url": "https://files.pythonhosted.org/packages/df/64/3b0403cf6c0ba10f975e213526ecf6d56941d938398231219a0b7efeaa3e/perky-0.1.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0626b8dde3699d21b971437071d91459", "sha256": "eb60e6dd28ef5f964fe39da61a3c26f835378bdda3399d058ee0a61e3416e8ea"}, "downloads": -1, "filename": "perky-0.1.3.tar.gz", "has_sig": false, "md5_digest": "0626b8dde3699d21b971437071d91459", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 12873, "upload_time": "2020-02-11T07:08:09", "upload_time_iso_8601": "2020-02-11T07:08:09.238487Z", "url": "https://files.pythonhosted.org/packages/1b/1e/66bde5c6632790fa52e2b0a8870ba239ab7ba80ad1e59fcf30749132ae57/perky-0.1.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:56:16 2020"}