{"info": {"author": "Harry Zhang", "author_email": "zhanghar@iu.edu", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Framework :: Trio", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3 :: Only", "Topic :: Scientific/Engineering", "Topic :: System :: Distributed Computing"], "description": "# Grain\n\nA scheduler built with `trio` for resource-aware parallel computing on clusters.\n\n### TL;DR\n\nThree core functions for you to run async jobs in an arbitary mix of parallel and sequential manner.\n\n```python\n# Jobs/subtasks inside a waitgroup run parallelly\nasync with grain.open_waitgroup() as wg:\n\n    # Put a job onto the waitgroup to be executed\n    wg.submit(resource, fn, *args, **kwargs)\n\n    # Put a subtask onto the waitgroup. Submit jobs / \n    # start other subtasks inside the subtask.\n    wg.start_subtask(vfn, *args, **kwargs)\n\n# Waitgroup blocks here until all of its jobs are done,\n# so outside a waitgroup is essentially sequencial.\n\nresults = wg.results # sorted in the order of submission\n\n\n# Execute one job sequentially\nresult = await grain.exec1(resource, fn, *args, **kwargs)\n```\n\nEntrypoint:\n\n```python\nasync def main(): # top-level subtask\n    # Submit jobs / start subtasks here\ngrain.run_combine(main, [worker1_addr, worker2_addr, ...], resource_per_worker)\n# ... Or for top-level parallelism, ...\n#grain.run_combine([main1, main2, ...], ...)\n```\n\nCheck out [example](example) for complete demos / more patterns and configuration sample.\n\n### Resource-awareness\n\nEvery job in the job queue has a resource request infomation along with the job to run. Before the executor run each job, it queries each worker for resource availability. If resource is insufficient, the job queue is suspended until completed jobs return resources. Resources can be CPU cores, virtual memory, both, (or anything user defined following interface `grain.resource.Resource`).\n\nEvery time a job function runs, it has access to `grain.GVAR.res`, a [context-local variable](https://trio.readthedocs.io/en/stable/reference-core.html#task-local-storage) giving the information of specific resource dedicated to the job. (e.g. if a job is submitted with `CPU(3)`, asking for 3 cores, it might receive allocation like `CPU([6,7,9])`.)\n\n### Executor, Workers and communication\n\nThe top-level APIs (i.e. \"combine\") are built upon an [executor](https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor)-like backend called `grain.GrainExecutor`. It schedules and dispatches jobs to workers, and it maintains a single job queue and a result queue. The executor usually runs on the head node in a cluster.\n\nWorkers, one per node, simply receive async functions (i.e. jobs) from the executor and run them. Executor and workers use socket for communication, and [`dill`](https://dill.readthedocs.io/en/latest/) serializes the functions to byte payloads.\n\n### Acknowledgement\n\nThe API of Grain is largely insipred by [structured concurrency](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful), a major design principle behind [Trio](https://trio.readthedocs.io), and it is specifically inspired by the API of Trio. And of course, Grain uses Trio internally.\n\n### Caveat\n\nRelative import (import not on Python package path) should be within the job function. Global reference fails in this case.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.iu.edu/zhanghar/grain", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "grain-scheduler", "package_url": "https://pypi.org/project/grain-scheduler/", "platform": "", "project_url": "https://pypi.org/project/grain-scheduler/", "project_urls": {"Homepage": "https://github.iu.edu/zhanghar/grain"}, "release_url": "https://pypi.org/project/grain-scheduler/0.12.0/", "requires_dist": ["trio", "dill", "toml", "click", "psutil"], "requires_python": ">=3.6", "summary": "A scheduler for resource-aware parallel computing on clusters.", "version": "0.12.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Grain</h1>\n<p>A scheduler built with <code>trio</code> for resource-aware parallel computing on clusters.</p>\n<h3>TL;DR</h3>\n<p>Three core functions for you to run async jobs in an arbitary mix of parallel and sequential manner.</p>\n<pre><span class=\"c1\"># Jobs/subtasks inside a waitgroup run parallelly</span>\n<span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">grain</span><span class=\"o\">.</span><span class=\"n\">open_waitgroup</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">wg</span><span class=\"p\">:</span>\n\n    <span class=\"c1\"># Put a job onto the waitgroup to be executed</span>\n    <span class=\"n\">wg</span><span class=\"o\">.</span><span class=\"n\">submit</span><span class=\"p\">(</span><span class=\"n\">resource</span><span class=\"p\">,</span> <span class=\"n\">fn</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Put a subtask onto the waitgroup. Submit jobs / </span>\n    <span class=\"c1\"># start other subtasks inside the subtask.</span>\n    <span class=\"n\">wg</span><span class=\"o\">.</span><span class=\"n\">start_subtask</span><span class=\"p\">(</span><span class=\"n\">vfn</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Waitgroup blocks here until all of its jobs are done,</span>\n<span class=\"c1\"># so outside a waitgroup is essentially sequencial.</span>\n\n<span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">wg</span><span class=\"o\">.</span><span class=\"n\">results</span> <span class=\"c1\"># sorted in the order of submission</span>\n\n\n<span class=\"c1\"># Execute one job sequentially</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">grain</span><span class=\"o\">.</span><span class=\"n\">exec1</span><span class=\"p\">(</span><span class=\"n\">resource</span><span class=\"p\">,</span> <span class=\"n\">fn</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n</pre>\n<p>Entrypoint:</p>\n<pre><span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span> <span class=\"c1\"># top-level subtask</span>\n    <span class=\"c1\"># Submit jobs / start subtasks here</span>\n<span class=\"n\">grain</span><span class=\"o\">.</span><span class=\"n\">run_combine</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">worker1_addr</span><span class=\"p\">,</span> <span class=\"n\">worker2_addr</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">],</span> <span class=\"n\">resource_per_worker</span><span class=\"p\">)</span>\n<span class=\"c1\"># ... Or for top-level parallelism, ...</span>\n<span class=\"c1\">#grain.run_combine([main1, main2, ...], ...)</span>\n</pre>\n<p>Check out <a href=\"example\" rel=\"nofollow\">example</a> for complete demos / more patterns and configuration sample.</p>\n<h3>Resource-awareness</h3>\n<p>Every job in the job queue has a resource request infomation along with the job to run. Before the executor run each job, it queries each worker for resource availability. If resource is insufficient, the job queue is suspended until completed jobs return resources. Resources can be CPU cores, virtual memory, both, (or anything user defined following interface <code>grain.resource.Resource</code>).</p>\n<p>Every time a job function runs, it has access to <code>grain.GVAR.res</code>, a <a href=\"https://trio.readthedocs.io/en/stable/reference-core.html#task-local-storage\" rel=\"nofollow\">context-local variable</a> giving the information of specific resource dedicated to the job. (e.g. if a job is submitted with <code>CPU(3)</code>, asking for 3 cores, it might receive allocation like <code>CPU([6,7,9])</code>.)</p>\n<h3>Executor, Workers and communication</h3>\n<p>The top-level APIs (i.e. \"combine\") are built upon an <a href=\"https://docs.python.org/3/library/concurrent.futures.html#concurrent.futures.Executor\" rel=\"nofollow\">executor</a>-like backend called <code>grain.GrainExecutor</code>. It schedules and dispatches jobs to workers, and it maintains a single job queue and a result queue. The executor usually runs on the head node in a cluster.</p>\n<p>Workers, one per node, simply receive async functions (i.e. jobs) from the executor and run them. Executor and workers use socket for communication, and <a href=\"https://dill.readthedocs.io/en/latest/\" rel=\"nofollow\"><code>dill</code></a> serializes the functions to byte payloads.</p>\n<h3>Acknowledgement</h3>\n<p>The API of Grain is largely insipred by <a href=\"https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful\" rel=\"nofollow\">structured concurrency</a>, a major design principle behind <a href=\"https://trio.readthedocs.io\" rel=\"nofollow\">Trio</a>, and it is specifically inspired by the API of Trio. And of course, Grain uses Trio internally.</p>\n<h3>Caveat</h3>\n<p>Relative import (import not on Python package path) should be within the job function. Global reference fails in this case.</p>\n\n          </div>"}, "last_serial": 7071018, "releases": {"0.11.0": [{"comment_text": "", "digests": {"md5": "851618663e53369912f33d2f513e7fb9", "sha256": "9eeb45e29bcd322378121431ffefb67f42d5ae2ff882b344735d2ea3ce6659f8"}, "downloads": -1, "filename": "grain_scheduler-0.11.0-py3-none-any.whl", "has_sig": false, "md5_digest": "851618663e53369912f33d2f513e7fb9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 25917, "upload_time": "2020-04-01T19:05:19", "upload_time_iso_8601": "2020-04-01T19:05:19.804165Z", "url": "https://files.pythonhosted.org/packages/76/1a/cc309b3f46561028e4fc7433d95b08469b431bcf2160d6071a2804f5fbd1/grain_scheduler-0.11.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "879832f1a2e0bf9ed6ee076708677f3d", "sha256": "3b19af8f40a824c0f38cd3bac187a60bb16acbee009a211dc461d49b9a69ec87"}, "downloads": -1, "filename": "grain-scheduler-0.11.0.tar.gz", "has_sig": false, "md5_digest": "879832f1a2e0bf9ed6ee076708677f3d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 21476, "upload_time": "2020-04-01T19:05:21", "upload_time_iso_8601": "2020-04-01T19:05:21.688072Z", "url": "https://files.pythonhosted.org/packages/5c/82/bd6d7d46a6c31324d3e61f0e66d521b9f33b8a82e7fcd611147c30a05b05/grain-scheduler-0.11.0.tar.gz", "yanked": false}], "0.12.0": [{"comment_text": "", "digests": {"md5": "115d32ec114dec1970a12d6840073c61", "sha256": "94f14633bd41671c04eedf7cb8f4fe1fdd3ddbc1bcd024f34876b67ec3cb106f"}, "downloads": -1, "filename": "grain_scheduler-0.12.0-py3-none-any.whl", "has_sig": false, "md5_digest": "115d32ec114dec1970a12d6840073c61", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 32450, "upload_time": "2020-04-21T20:29:03", "upload_time_iso_8601": "2020-04-21T20:29:03.717079Z", "url": "https://files.pythonhosted.org/packages/73/96/312e88fcc55f388239c618b5f614981a8bed90406fd757f91ad19a6c9f60/grain_scheduler-0.12.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "09c47ed4a124d68326ef3df32217e9c4", "sha256": "984b6c068a51e880d65db9124031c39b64e25aa45501a0916fca3381263c4a83"}, "downloads": -1, "filename": "grain-scheduler-0.12.0.tar.gz", "has_sig": false, "md5_digest": "09c47ed4a124d68326ef3df32217e9c4", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 26942, "upload_time": "2020-04-21T20:29:04", "upload_time_iso_8601": "2020-04-21T20:29:04.697934Z", "url": "https://files.pythonhosted.org/packages/5c/75/b62096caa8ed0dc196dc81ec9035d070219141c1a8b2f495903a84379787/grain-scheduler-0.12.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "115d32ec114dec1970a12d6840073c61", "sha256": "94f14633bd41671c04eedf7cb8f4fe1fdd3ddbc1bcd024f34876b67ec3cb106f"}, "downloads": -1, "filename": "grain_scheduler-0.12.0-py3-none-any.whl", "has_sig": false, "md5_digest": "115d32ec114dec1970a12d6840073c61", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 32450, "upload_time": "2020-04-21T20:29:03", "upload_time_iso_8601": "2020-04-21T20:29:03.717079Z", "url": "https://files.pythonhosted.org/packages/73/96/312e88fcc55f388239c618b5f614981a8bed90406fd757f91ad19a6c9f60/grain_scheduler-0.12.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "09c47ed4a124d68326ef3df32217e9c4", "sha256": "984b6c068a51e880d65db9124031c39b64e25aa45501a0916fca3381263c4a83"}, "downloads": -1, "filename": "grain-scheduler-0.12.0.tar.gz", "has_sig": false, "md5_digest": "09c47ed4a124d68326ef3df32217e9c4", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 26942, "upload_time": "2020-04-21T20:29:04", "upload_time_iso_8601": "2020-04-21T20:29:04.697934Z", "url": "https://files.pythonhosted.org/packages/5c/75/b62096caa8ed0dc196dc81ec9035d070219141c1a8b2f495903a84379787/grain-scheduler-0.12.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:54 2020"}