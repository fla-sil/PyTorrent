{"info": {"author": "Yauhen Yakimovich", "author_email": "eugeny.yakimovitch@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "Mlab is a high-level python to Matlab bridge that lets Matlab look like a normal python library.\nThis python library is based on the work of original mlabwrap project\nhttp://mlabwrap.sourceforge.net/\nand Dani Valevski (from Dana Pe'er's lab):\nhttp://code.google.com/p/danapeerlab/source/browse/trunk/freecell/depends/common/python/matlabpipe.py\nPrimer\n\nQuick installation:\n\npip install mlab\n\nStart working with the library by picking a MATLAB release that you have locally installed:\n\nfrom mlab.releases import latest_release\nfrom matlab import matlabroot\n\nprint matlabroot()\n\nwhere latest_release is a MlabWrap instance, matlabroot is wrapper around MATLAB function.\nPlease note that matlab module is dynamically created instance, which is in this case referencing\nlatest_release object.\n\nMATLAB installation discovery mechanism is implemented by mlab.releases module in such a way, that\nyou have to specify the release version you want to use first, by importing it. Only then you can\nimport from matlab module:\n\nfrom mlab.releases import R2010b\nfrom matlab import matlabroot\n\nAlso see mlab.releases.get_available_releases().\n\nContents\n\nPrimer\n\nDescription\n\nRelated\n\nNews\n\nLicense\n\nDownload\n\nInstallation\n\nLinux\n\nWindows\n\nDocumentation\n\nTutorial\n\nComparison to other existing modules\n\nWhat's Missing?\n\nImplementation Notes\n\nTroubleshooting\n\nStrange hangs under Matlab R2008a\n\nmatlab not in path\n\n\"Can't open engine\"\n\n\"`GLIBCXX_3.4.9' not found\" on importing mlab (or similar)\n\nOld Matlab version\n\nOS X\n\nNotes on running\n\nWindows\n\nFunction Handles and callbacks into python\n\nDirectly manipulating variables in Matlab space\n\nSupport and Feedback\n\nCredits\nDescription\n\nMlabwrap is a high-level python to Matlab bridge that lets Matlab look\nlike a normal python library.\n\nThanks for your terrific work on this very-useful Python tool!\n\nGeorge A. Blaha, Senior Systems Engineer,\nRaytheon Integrated Defense Systems\n\nmlab is a repackaging effort to make things up-to-date.\n\n\nRelated\n\nThereis is a copy of mlabwrap v1.1-pre (http://mlabwrap.sourceforge.net/) patched\nas described here:\nhttp://sourceforge.net/mailarchive/message.php?msg_id=27312822\n\nwith a patch fixing the error:\n\nmlabraw.cpp:225: *error*: invalid conversion from const mwSize* to const int*\n\nAlso note that in Ubuntu you need to sudo apt-get install csh\n\nFor details see\nhttp://github.com/aweinstein/mlabwrap\nNews\n\n2014-08-26 1.1.3 Applying patch to add support for Windows via COM.\nCredits to Sergey Matyunin, Amro@stackoverflow\n\n2013-07-26 1.1.1 Repacking a library as mlab project. Including code\nfor Windows (matlabraw.cpp is off for now).\n\n2009-10-26 1.1 fixes an incorrect declaration in mlabraw.cpp\nthat caused compilation problems for some users and incorporates a\nsetup.py fix for windows suggested by Alan Brooks. More significantly\nthere is a new spiffy logo!\n\n2009-09-14 1.1-pre finally brings N-D array support, thanks to Vivek\nRathod who joined the project! Also fixed a missing import for saveVarsInMat\n(thanks to Nicolas Pinto).\n\nSince a few people have run into problems that appear to relate to compiling\nMatlab C-extensions in general and aren't mlabwrap-specific, I should probably\nstress that in case of any problems that look C-related, verifying whether\nengdemo.c works is a great litmus test (see Troubleshooting ).\n\n2009-03-23 1.0.1 is finally out. This is a minor release that fixes some\nannoying but mostly minor bugs in mlabwrap (it also slightly improves the\nindexing support for proxy-objects, but the exact semantics are still subject\nto change.)\n\ninstallation is now easier, in particularly LD_LIBRARY_PATH no longer\nneeds to be set and some quoting issues with the matlab call during\ninstallation have been addressed.\n\nsparse Matlab matrices are now handled correctly\n(mlab.sparse([0,0,0,0]) will now return a proxy for a sparse double\nmatrix, rather than incorrectly treat at as plain double array and return\njunk or crash).\n\nreplaced the (optional) use of the outdated netcdf package for the\nunit-tests with homegrown matlab helper class.\n\nseveral bugs squashed (length of mlabraw.eval'ed strings is checked, better\nerror-messages etc.) and some small documentation improvements and quite a\nfew code clean-ups.\n\nMany thanks to Iain Murray at Toronto and Nicolas Pinto at MIT for letting\nthemselves be roped into helping me test my stupidly broken release\ncandidates.\nLicense\n\nmlab (and mlabwrap) is under MIT license, see LICENSE.txt. mlabraw is under a BSD-style\nlicense, see the mlabraw.cpp.\nDownload\n\n<http://github.com/ewiger/mlab>\nInstallation\n\nmlab should work with python>=2.7 (downto python 2.2, with minor coaxing) and\neither numpy (recommended) or Numeric (obsolete) installed and Matlab 6, 6.5,\n7.x and 8.x under Linux, OS X and Windows (see OS X) on 32- or 64-bit\nmachines.\n\nLinux\n\nIf you're lucky (linux, Matlab binary in PATH):\n\npython setup.py install\n\n(As usual, if you want to install just in your homedir add --prefix=$HOME;\nand make sure your PYTHONPATH is set accordingly.)\n\nIf things do go awry, see Troubleshooting.\n\nWindows\n\nAssuming you have python 2.7.5 (e.g. C:Python27) and setuptools\n(\"easy_install.exe\") installed and on your PATH.\n\n1) Download and install numpy package. You can use packages provided by\nChristoph Gohlke: http://www.lfd.uci.edu/~gohlke/pythonlibs/ Also see official\nSciPy website for latest status, it might that:\n\neasy_install.exe numpy\n\nwould do the trick.\n\nYou would also need The PyWin32 module by Mark Hammond:\n\n<string>:175: (WARNING/2) Literal block expected; none found.\n\n<string>:5: (INFO/1) Enumerated list start value not ordinal-1: \"2\" (ordinal 2)\n\neasy_install.exe pywin32\n\nalso see Windows in Troubleshooting.\nDocumentation\n\nfor lazy people\n\n>>> from mlab.releases import latest_release as matlab\n>>> matlab.plot([1,2,3],'-o')\n\nugly-plot\n\na slightly prettier example\n\n>>> from mlab.releases import latest_release as matlab\n>>> from numpy import *\n>>> xx = arange(-2*pi, 2*pi, 0.2)\n>>> mlab.surf(subtract.outer(sin(xx),cos(xx)))\n\nsurface-plot\n\nfor a complete description:\nJust run pydoc mlab.\n\nfor people who like tutorials:\nsee below\n\nTutorial\n\n[This is adapted from an email I wrote someone who asked me about mlabwrap.\nCompatibility Note: Since matlab is becoming increasingly less\ndouble-centric, the default conversion rules might change in post 1.0\nmlabwrap; so whilst using mlab.plot([1,2,3]) rather than\nmlab.plot(array([1.,2.,3.])) is fine for interactive use as in the\ntutorial below, the latter is recommended for production code.]\n\nLegend: [...] = omitted output\n\nLet's say you want to do use Matlab to calculate the singular value\ndecomposition of a matrix.  So first you import the mlab pseudo-module and\nNumeric:\n\n>>> from mlab import mlab\n>>> import numpy\n\nNow you want to find out what the right function is, so you simply do:\n\n>>> mlab.lookfor('singular value')\nGSVD   Generalized Singular Value Decompostion.\nSVD    Singular value decomposition.\n[...]\n\nThen you look up what svd actually does, just as you'd look up the\ndocstring of a python function:\n\n>>> help(mlab.svd)\nmlab_command(*args, **kwargs)\n SVD    Singular value decomposition.\n    [U,S,V] = SVD(X) produces a diagonal matrix S, of the same\n    dimension as X and with nonnegative diagonal elements in\n[...]\n\nThen you try it out:\n\n>>> mlab.svd(array([[1,2], [1,3]]))\narray([[ 3.86432845],\n      [ 0.25877718]])\n\nNotice that we only got 'U' back -- that's because python hasn't got something\nlike Matlab's multiple value return. Since Matlab functions can have\ncompletely different behavior depending on how many output parameters are\nrequested, you have to specify explicitly if you want more than 1. So to get\n'U' and also 'S' and 'V' you'd do:\n\n>>> U, S, V = mlab.svd([[1,2],[1,3]], nout=3)\n\nThe only other possible catch is that Matlab (to a good approximation)\nbasically represents everything as a double matrix. So there are no\nscalars, or 'flat' vectors. They correspond to 1x1 and 1xN matrices\nrespectively. So, when you pass a flat vector or a scalar to a\nmlab-function, it is autoconverted. Also, integer values are automatically\nconverted to double floats. Here is an example:\n\n>>> mlab.abs(-1)\narray([       [ 1.]])\n\nStrings also work as expected:\n\n>>> mlab.upper('abcde')\n'ABCDE'\n\nHowever, although matrices and strings should cover most needs and can be\ndirectly converted, Matlab functions can also return structs or indeed\nclasses and other types that cannot be converted into python\nequivalents. However, rather than just giving up, mlabwrap just hides\nthis fact from the user by using proxies:\nE.g. to create a netlab neural net with 2 input, 3 hidden and 1 output node:\n\n>>> net = mlab.mlp(2,3,1,'logistic')\n\nLooking at net reveals that is a proxy:\n\n>>> net\n<MLabObjectProxy of matlab-class: 'struct'; internal name: 'PROXY_VAL0__';\nhas parent: no>\n    type: 'mlp'\n     nin: 3\n nhidden: 3\n    nout: 3\n    nwts: 24\n   outfn: 'linear'\n      w1: [3x3 double]\n      b1: [0.0873 -0.0934 0.3629]\n      w2: [3x3 double]\n      b2: [-0.6681 0.3572 0.8118]\n\nWhen net or other proxy objects a passed to mlab functions, they are\nautomatically converted into the corresponding Matlab-objects. So to obtain\na trained network on the 'xor'-problem, one can simply do:\n\n>>> net = mlab.mlptrain(net, [[1,1], [0,0], [1,0], [0,1]], [0,0,1,1], 1000)\n\nAnd test with:\n\n>>> mlab.mlpfwd(net2, [[1,0]])\narray([       [ 1.]])\n>>> mlab.mlpfwd(net2, [[1,1]])\narray([       [  7.53175454e-09]])\n\nAs previously mentioned, normally you shouldn't notice at all when you are\nworking with proxy objects; they can even be pickled (!), although that is\nstill somewhat experimental.\n\nmlabwrap also offers proper error handling and exceptions! So trying to\npass only one input to a net with 2 input nodes raises an Exception:\n\n>>> mlab.mlpfwd(net2, 1)\nTraceback (most recent call last):\n[...]\nmlabraw.error: Error using ==> mlpfwd\nDimension of inputs 1 does not match number of model inputs 2\n\nWarning messages (and messages to stdout) are also displayed:\n\n>>> mlab.log(0)\nWarning: Log of zero.\narray([       [             -inf]])\n\nComparison to other existing modules\n\nTo get a vague impression just how high-level all this, consider attempting to\ndo something similar to the first example with pymat (upon which the\nunderlying mlabraw interface to Matlab is based).\n\nthis:\n\n>>> A, B, C = mlab.svd([[1,2],[1,3]], 0, nout=3)\n\nbecomes this:\n\n>>> session = pymat.open()\n>>> pymat.put(session, \"X\", [[1,2], [1,3]])\n>>> pymat.put(session, \"cheap\", 0)\n>>> pymat.eval(session, '[A, B, C] = svd(X, cheap)')\n>>> A = pymat.get(session, 'A')\n>>> B = pymat.get(session, 'B')\n>>> C = pymat.get(session, 'C')\n\nPlus, there is virtually no error-reporting at all, if something goes wrong in\nthe eval step, you'll only notice because the subsequent get mysteriously\nfails. And of course something more fancy like the netlab example above (which\nuses proxies to represent matlab class instances in python) would be\nimpossible to accomplish in pymat in a similar manner.\n\nHowever should you need low-level access, then that is equally available\n(and with error reporting); basically just replace pymat with\nmlabraw above and use mlab._session as session), i.e\n\n>>> from mlab import mlab\n>>> import mlabraw\n>>> mlabraw.put(mlab._session, \"X\", [[1,2], [1,3]])\n[...]\n\nBefore you resort to this you should ask yourself if it's really a good idea;\nthe inherent overhead associated with Matlab's C interface appears to be quite\nhigh, so the additional python overhead shouldn't normally matter much -- if\nefficiency becomes an issue it's probably better to try to chunk together\nseveral matlab commands in an .m-file in order to reduce the number of\nmatlab calls. If you're looking for a way to execute \"raw\" matlab for specific\npurposes, mlab._do is probably a better idea. The low-level mlabraw\nAPI is much more likely to change in completely backwards incompatible ways in\nfuture versions of mlabwrap. You've been warned.\n\nWhat's Missing?\n\nHandling of as arrays of (array) rank 3 or more as well as\nnon-double/complex arrays (currently everything is converted to\ndouble/complex for passing to Matlab and passing non-double/complex from\nMatlab is not not supported). Both should be reasonably easy to implement,\nbut not that many people have asked for it and I haven't got around to it\nyet.\n\nBetter support for cells.\n\nThread-safety. If you think there's a need please let me know (on the\nStackOverflow tagged query); at the moment you can /probably/ get away with\nusing one seperate MlabWrap object per thread without implementing your own\nlocking, but even that hasn't been tested.\n\nImplementation Notes\n\nSo how does it all work?\n\nI've got a C extension module (a heavily bug-fixed and somewhat modified\nversion of pymat, an open-source, low-level python-matlab interface) to take\ncare of opening Matlab sessions, sending Matlab commands as strings to a\nrunning Matlab session and and converting Numeric arrays (and sequences and\nstrings...) to Matlab matrices and vice versa. On top of this I then built a\npure python module that with various bells and whistles gives the impression\nof providing a Matlab \"module\".\n\nThis is done by a class that manages a single Matlab session (of which mlab\nis an instance) and creates methods with docstrings on-the-fly. Thus, on the\nfirst call of mlab.abs(1), the wrapper looks whether there already is a\nmatching function in the cache. If not, the docstring for abs is looked up\nin Matlab and Matlab's flimsy introspection abilities are used to determine\nthe number of output arguments (0 or more), then a function with the right\ndocstring is dynamically created and assigned to mlab.abs. This function\ntakes care of the conversion of all input parameters and the return values,\nusing proxies where necessary. Proxy are a bit more involved and the proxy\npickling scheme uses Matlab's save command to create a binary version of\nthe proxy's contents which is then pickled, together with the proxy object by\npython itself. Hope that gives a vague idea, for more info study the source.\n\nTroubleshooting\n\nStrange hangs under Matlab R2008a\n\nIt looks like this particular version of matlab might be broken (I was able to\nreproduced the problem with just a stripped down engdemo.c under 64-bit\nlinux). R2008b is reported to be working correctly (as are several earlier\nversions).\n\nmatlab not in path\n\nsetup.py will call matlab in an attempt to query the version and other\ninformation relevant for installation, so it has to be in your PATH\nunless you specify everything by hand in setup.py. Of course to be able\nto use mlabwrap in any way matlab will have to be in your path anyway\n(unless that is you set the environment variable MLABRAW_CMD_STR that\nspecifies how exactly Matlab should be called).\n\n\"Can't open engine\"\n\nIf you see something like mlabraw.error: Unable to start MATLAB(TM) engine\nthen you may be using an incompatible C++ compiler (or version), or if you're\nusing unix you might not have csh installed under /bin/csh, see below.\nTry if you can get the engdemo.c file to work that comes with your Matlab\ninstallation -- engdemo provides detailed instructions, but in a nutshell:\ncopy it to a directory where you have write access and do\n(assuming Matlab is installed in /opt/MatlabR14 and you're running unix,\notherwise modify as requird):\n\nmex -f /opt/MatlabR14/bin/engopts.sh engdemo.c\n./engdemo\n\nif you get Can't start MATLAB engine chances are you're trying to use a\ncompiler version that's not in Mathworks's list of compatible compilers or\nsomething else with your compiler/Matlab installation is broken that needs to\nbe resolved before you can successfully build mlabwrap. Chances are that you\nor you institution pays a lot of money to the Mathworks, so they should be\nhappy to give you some tech support. Here's what some user who recently\n(2007-02-04) got Matlab 7.04's mex support to work under Ubuntu Edgy after an\nexchange with support reported back; apart from installing gcc-3.2.3, he did\nthe following:\n\nThe code I'd run (from within Matlab) is...\n> mex -setup;     # then select: 2 - gcc Mex options\n> optsfile = [matlabroot '/bin/engopts.sh'];\n> mex -v -f optsfile 'engdemo.c';\n> !./engdemo;\n\nUpdate John Bender reports that under unix csh needs to be installed in\n/bin/csh for the matlab external engine to work -- since many linux\ndistros don't install csh by default, you might have to do something like\nsudo apt-get install csh (e.g. under ubuntu or other debian-based\nsystems). He also pointed out this helpful engdemo troubleshooting page at\nthe Mathworks(tm) site.\n\n\"`GLIBCXX_3.4.9' not found\" on importing mlab (or similar)\n\nAs above, first try to see if you can get engdemo.c to work, because\nas long as even the examples that come with Matlab don't compile,\nchances of mlabwrap compiling are rather slim. On the plus-side\nif the problem isn't mlabwrap specific, The Mathworks and/or\nMatlab-specific support forums should be able to help.\n\nOld Matlab version\n\nIf you get something like this on python setup.py install:\n\nmlabraw.cpp:634: `engGetVariable' undeclared (first use this function)\n\nThen you're presumably using an old version of Matlab (i.e. < 6.5);\nsetup.py ought to have detected this though (try adjusting\nMATLAB_VERSION by hand and write me a bug report).\n\nOS X\n\nJosh Marshall tried it under OS X and sent me the following notes (thanks!).\n\nNotes on running\n\nBefore running python, run:\n\nexport  DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH$:/Applications/MATLAB701/bin/mac/\nexport MLABRAW_CMD_STR=/Applications/MATLAB701/bin/matlab\n\n[Edit: I'm not sure DYLD_LIBRARY_PATH modification is still necessary.]\n\nAs far as graphics commands go, the python interpreter will need to  be run\nfrom within the X11 xterm to be able to display anything to the  screen.\nie, the command for lazy people\n\n>>> from mlabwrap import mlab; mlab.plot([1,2,3],'-o')\n\nwon't work unless python is run from an xterm, and the matlab startup\nstring is\nchanged to:\n\nexport MLABRAW_CMD_STR=\"/Applications/MATLAB701/bin/matlab -nodesktop\"\n\nWindows\n\n<string>:529: (INFO/1) Duplicate implicit target name: \"windows\".\n\nI'm thankfully not using windows myself, but I try to keep mlabwrap working\nunder windows, for which I depend on the feedback from windows users.\n\nSince there are several popular C++ compilers under windows, you might have to\ntell setup.py which one you'd like to use (unless it's VC 7).\n\nGeorge A. Blaha sent me a patch for Borland C++ support; search for \"Borland\nC++\" in setup.py and follow the instructions.\n\nDylan T Walker writes mingw32 will also work fine, but for some reason\n(distuils glitch?) the following invocation is required:\n\n> setup.py build --compiler=mingw32\n> setup.py install --skip-build\n\nFunction Handles and callbacks into python\n\nPeople sometimes try to pass a python function to a matlab function (e.g.\nmlab.fzero(lambda x: x**2-2, 0)) which will result in an error messages\nbecause callbacks into python are not implemented (I'm not even it would even\nbe feasible). Whilst there is no general workaround, in some cases you can\njust create an equivalent matlab function on the fly, e.g. do something like\nthis: mlab.fzero(mlab.eval('@(x) x^2-2', 0)).\n\nDirectly manipulating variables in Matlab space\n\nIn certain (rare!) certain cases it might be necessary to directly access or\nset a global variable in matlab. In these cases you can use mlab._get('SOME_VAR')\nand mlab._set('SOME_VAR', somevalue).\nSupport and Feedback\n\nPost your questions directly on Stack overflow with tags matlab, mlab\nand python\n\n\nCredits\n\nAlejandro Weinstein for patches of 1.1pre\nhttps://github.com/aweinstein/mlabwrap\n\nAlexander Schmolck and Vivek Rathod for mlabwrap:\nhttp://mlabwrap.sourceforge.net/\n\nAndrew Sterian for writing pymat without which this module would never have\nexisted.\n\nMatthew Brett contributed numpy compatibility and nice setup.py improvements\n(which I adapted a bit) to further reduce the need for manual user\nintervention for installation.\n\nI'm only using linux myself -- so I gratefully acknowledge the help of Windows\nand OS X users to get things running smoothly under these OSes as well;\nparticularly those who provided patches to setup.py or mlabraw.cpp (Joris van\nZwieten, George A. Blaha and others).\n\nMatlab is a registered trademark of The Mathworks.", "description_content_type": null, "docs_url": null, "download_url": "https://github.com/ewiger/mlab/tarball/master", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ewiger/mlab", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "mlab", "package_url": "https://pypi.org/project/mlab/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/mlab/", "project_urls": {"Download": "https://github.com/ewiger/mlab/tarball/master", "Homepage": "https://github.com/ewiger/mlab"}, "release_url": "https://pypi.org/project/mlab/1.1.4/", "requires_dist": null, "requires_python": null, "summary": "Mlab is a high-level python to Matlab bridge that lets Matlab look like a normal python library", "version": "1.1.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            Mlab is a high-level python to Matlab bridge that lets Matlab look like a normal python library.<br>This python library is based on the work of original mlabwrap project<br>http://mlabwrap.sourceforge.net/<br>and Dani Valevski (from Dana Pe'er's lab):<br>http://code.google.com/p/danapeerlab/source/browse/trunk/freecell/depends/common/python/matlabpipe.py<br>Primer<br><br>Quick installation:<br><br>pip install mlab<br><br>Start working with the library by picking a MATLAB release that you have locally installed:<br><br>from mlab.releases import latest_release<br>from matlab import matlabroot<br><br>print matlabroot()<br><br>where latest_release is a MlabWrap instance, matlabroot is wrapper around MATLAB function.<br>Please note that matlab module is dynamically created instance, which is in this case referencing<br>latest_release object.<br><br>MATLAB installation discovery mechanism is implemented by mlab.releases module in such a way, that<br>you have to specify the release version you want to use first, by importing it. Only then you can<br>import from matlab module:<br><br>from mlab.releases import R2010b<br>from matlab import matlabroot<br><br>Also see mlab.releases.get_available_releases().<br><br>Contents<br><br>Primer<br><br>Description<br><br>Related<br><br>News<br><br>License<br><br>Download<br><br>Installation<br><br>Linux<br><br>Windows<br><br>Documentation<br><br>Tutorial<br><br>Comparison to other existing modules<br><br>What's Missing?<br><br>Implementation Notes<br><br>Troubleshooting<br><br>Strange hangs under Matlab R2008a<br><br>matlab not in path<br><br>\"Can't open engine\"<br><br>\"`GLIBCXX_3.4.9' not found\" on importing mlab (or similar)<br><br>Old Matlab version<br><br>OS X<br><br>Notes on running<br><br>Windows<br><br>Function Handles and callbacks into python<br><br>Directly manipulating variables in Matlab space<br><br>Support and Feedback<br><br>Credits<br>Description<br><br>Mlabwrap is a high-level python to Matlab bridge that lets Matlab look<br>like a normal python library.<br><br>Thanks for your terrific work on this very-useful Python tool!<br><br>George A. Blaha, Senior Systems Engineer,<br>Raytheon Integrated Defense Systems<br><br>mlab is a repackaging effort to make things up-to-date.<br><br><br>Related<br><br>Thereis is a copy of mlabwrap v1.1-pre (http://mlabwrap.sourceforge.net/) patched<br>as described here:<br>http://sourceforge.net/mailarchive/message.php?msg_id=27312822<br><br>with a patch fixing the error:<br><br>mlabraw.cpp:225: *error*: invalid conversion from const mwSize* to const int*<br><br>Also note that in Ubuntu you need to sudo apt-get install csh<br><br>For details see<br>http://github.com/aweinstein/mlabwrap<br>News<br><br>2014-08-26 1.1.3 Applying patch to add support for Windows via COM.<br>Credits to Sergey Matyunin, Amro@stackoverflow<br><br>2013-07-26 1.1.1 Repacking a library as mlab project. Including code<br>for Windows (matlabraw.cpp is off for now).<br><br>2009-10-26 1.1 fixes an incorrect declaration in mlabraw.cpp<br>that caused compilation problems for some users and incorporates a<br>setup.py fix for windows suggested by Alan Brooks. More significantly<br>there is a new spiffy logo!<br><br>2009-09-14 1.1-pre finally brings N-D array support, thanks to Vivek<br>Rathod who joined the project! Also fixed a missing import for saveVarsInMat<br>(thanks to Nicolas Pinto).<br><br>Since a few people have run into problems that appear to relate to compiling<br>Matlab C-extensions in general and aren't mlabwrap-specific, I should probably<br>stress that in case of any problems that look C-related, verifying whether<br>engdemo.c works is a great litmus test (see Troubleshooting ).<br><br>2009-03-23 1.0.1 is finally out. This is a minor release that fixes some<br>annoying but mostly minor bugs in mlabwrap (it also slightly improves the<br>indexing support for proxy-objects, but the exact semantics are still subject<br>to change.)<br><br>installation is now easier, in particularly LD_LIBRARY_PATH no longer<br>needs to be set and some quoting issues with the matlab call during<br>installation have been addressed.<br><br>sparse Matlab matrices are now handled correctly<br>(mlab.sparse([0,0,0,0]) will now return a proxy for a sparse double<br>matrix, rather than incorrectly treat at as plain double array and return<br>junk or crash).<br><br>replaced the (optional) use of the outdated netcdf package for the<br>unit-tests with homegrown matlab helper class.<br><br>several bugs squashed (length of mlabraw.eval'ed strings is checked, better<br>error-messages etc.) and some small documentation improvements and quite a<br>few code clean-ups.<br><br>Many thanks to Iain Murray at Toronto and Nicolas Pinto at MIT for letting<br>themselves be roped into helping me test my stupidly broken release<br>candidates.<br>License<br><br>mlab (and mlabwrap) is under MIT license, see LICENSE.txt. mlabraw is under a BSD-style<br>license, see the mlabraw.cpp.<br>Download<br><br>&lt;http://github.com/ewiger/mlab&gt;<br>Installation<br><br>mlab should work with python&gt;=2.7 (downto python 2.2, with minor coaxing) and<br>either numpy (recommended) or Numeric (obsolete) installed and Matlab 6, 6.5,<br>7.x and 8.x under Linux, OS X and Windows (see OS X) on 32- or 64-bit<br>machines.<br><br>Linux<br><br>If you're lucky (linux, Matlab binary in PATH):<br><br>python setup.py install<br><br>(As usual, if you want to install just in your homedir add --prefix=$HOME;<br>and make sure your PYTHONPATH is set accordingly.)<br><br>If things do go awry, see Troubleshooting.<br><br>Windows<br><br>Assuming you have python 2.7.5 (e.g. C:Python27) and setuptools<br>(\"easy_install.exe\") installed and on your PATH.<br><br>1) Download and install numpy package. You can use packages provided by<br>Christoph Gohlke: http://www.lfd.uci.edu/~gohlke/pythonlibs/ Also see official<br>SciPy website for latest status, it might that:<br><br>easy_install.exe numpy<br><br>would do the trick.<br><br>You would also need The PyWin32 module by Mark Hammond:<br><br>&lt;string&gt;:175: (WARNING/2) Literal block expected; none found.<br><br>&lt;string&gt;:5: (INFO/1) Enumerated list start value not ordinal-1: \"2\" (ordinal 2)<br><br>easy_install.exe pywin32<br><br>also see Windows in Troubleshooting.<br>Documentation<br><br>for lazy people<br><br>&gt;&gt;&gt; from mlab.releases import latest_release as matlab<br>&gt;&gt;&gt; matlab.plot([1,2,3],'-o')<br><br>ugly-plot<br><br>a slightly prettier example<br><br>&gt;&gt;&gt; from mlab.releases import latest_release as matlab<br>&gt;&gt;&gt; from numpy import *<br>&gt;&gt;&gt; xx = arange(-2*pi, 2*pi, 0.2)<br>&gt;&gt;&gt; mlab.surf(subtract.outer(sin(xx),cos(xx)))<br><br>surface-plot<br><br>for a complete description:<br>Just run pydoc mlab.<br><br>for people who like tutorials:<br>see below<br><br>Tutorial<br><br>[This is adapted from an email I wrote someone who asked me about mlabwrap.<br>Compatibility Note: Since matlab is becoming increasingly less<br>double-centric, the default conversion rules might change in post 1.0<br>mlabwrap; so whilst using mlab.plot([1,2,3]) rather than<br>mlab.plot(array([1.,2.,3.])) is fine for interactive use as in the<br>tutorial below, the latter is recommended for production code.]<br><br>Legend: [...] = omitted output<br><br>Let's say you want to do use Matlab to calculate the singular value<br>decomposition of a matrix.  So first you import the mlab pseudo-module and<br>Numeric:<br><br>&gt;&gt;&gt; from mlab import mlab<br>&gt;&gt;&gt; import numpy<br><br>Now you want to find out what the right function is, so you simply do:<br><br>&gt;&gt;&gt; mlab.lookfor('singular value')<br>GSVD   Generalized Singular Value Decompostion.<br>SVD    Singular value decomposition.<br>[...]<br><br>Then you look up what svd actually does, just as you'd look up the<br>docstring of a python function:<br><br>&gt;&gt;&gt; help(mlab.svd)<br>mlab_command(*args, **kwargs)<br> SVD    Singular value decomposition.<br>    [U,S,V] = SVD(X) produces a diagonal matrix S, of the same<br>    dimension as X and with nonnegative diagonal elements in<br>[...]<br><br>Then you try it out:<br><br>&gt;&gt;&gt; mlab.svd(array([[1,2], [1,3]]))<br>array([[ 3.86432845],<br>      [ 0.25877718]])<br><br>Notice that we only got 'U' back -- that's because python hasn't got something<br>like Matlab's multiple value return. Since Matlab functions can have<br>completely different behavior depending on how many output parameters are<br>requested, you have to specify explicitly if you want more than 1. So to get<br>'U' and also 'S' and 'V' you'd do:<br><br>&gt;&gt;&gt; U, S, V = mlab.svd([[1,2],[1,3]], nout=3)<br><br>The only other possible catch is that Matlab (to a good approximation)<br>basically represents everything as a double matrix. So there are no<br>scalars, or 'flat' vectors. They correspond to 1x1 and 1xN matrices<br>respectively. So, when you pass a flat vector or a scalar to a<br>mlab-function, it is autoconverted. Also, integer values are automatically<br>converted to double floats. Here is an example:<br><br>&gt;&gt;&gt; mlab.abs(-1)<br>array([       [ 1.]])<br><br>Strings also work as expected:<br><br>&gt;&gt;&gt; mlab.upper('abcde')<br>'ABCDE'<br><br>However, although matrices and strings should cover most needs and can be<br>directly converted, Matlab functions can also return structs or indeed<br>classes and other types that cannot be converted into python<br>equivalents. However, rather than just giving up, mlabwrap just hides<br>this fact from the user by using proxies:<br>E.g. to create a netlab neural net with 2 input, 3 hidden and 1 output node:<br><br>&gt;&gt;&gt; net = mlab.mlp(2,3,1,'logistic')<br><br>Looking at net reveals that is a proxy:<br><br>&gt;&gt;&gt; net<br>&lt;MLabObjectProxy of matlab-class: 'struct'; internal name: 'PROXY_VAL0__';<br>has parent: no&gt;<br>    type: 'mlp'<br>     nin: 3<br> nhidden: 3<br>    nout: 3<br>    nwts: 24<br>   outfn: 'linear'<br>      w1: [3x3 double]<br>      b1: [0.0873 -0.0934 0.3629]<br>      w2: [3x3 double]<br>      b2: [-0.6681 0.3572 0.8118]<br><br>When net or other proxy objects a passed to mlab functions, they are<br>automatically converted into the corresponding Matlab-objects. So to obtain<br>a trained network on the 'xor'-problem, one can simply do:<br><br>&gt;&gt;&gt; net = mlab.mlptrain(net, [[1,1], [0,0], [1,0], [0,1]], [0,0,1,1], 1000)<br><br>And test with:<br><br>&gt;&gt;&gt; mlab.mlpfwd(net2, [[1,0]])<br>array([       [ 1.]])<br>&gt;&gt;&gt; mlab.mlpfwd(net2, [[1,1]])<br>array([       [  7.53175454e-09]])<br><br>As previously mentioned, normally you shouldn't notice at all when you are<br>working with proxy objects; they can even be pickled (!), although that is<br>still somewhat experimental.<br><br>mlabwrap also offers proper error handling and exceptions! So trying to<br>pass only one input to a net with 2 input nodes raises an Exception:<br><br>&gt;&gt;&gt; mlab.mlpfwd(net2, 1)<br>Traceback (most recent call last):<br>[...]<br>mlabraw.error: Error using ==&gt; mlpfwd<br>Dimension of inputs 1 does not match number of model inputs 2<br><br>Warning messages (and messages to stdout) are also displayed:<br><br>&gt;&gt;&gt; mlab.log(0)<br>Warning: Log of zero.<br>array([       [             -inf]])<br><br>Comparison to other existing modules<br><br>To get a vague impression just how high-level all this, consider attempting to<br>do something similar to the first example with pymat (upon which the<br>underlying mlabraw interface to Matlab is based).<br><br>this:<br><br>&gt;&gt;&gt; A, B, C = mlab.svd([[1,2],[1,3]], 0, nout=3)<br><br>becomes this:<br><br>&gt;&gt;&gt; session = pymat.open()<br>&gt;&gt;&gt; pymat.put(session, \"X\", [[1,2], [1,3]])<br>&gt;&gt;&gt; pymat.put(session, \"cheap\", 0)<br>&gt;&gt;&gt; pymat.eval(session, '[A, B, C] = svd(X, cheap)')<br>&gt;&gt;&gt; A = pymat.get(session, 'A')<br>&gt;&gt;&gt; B = pymat.get(session, 'B')<br>&gt;&gt;&gt; C = pymat.get(session, 'C')<br><br>Plus, there is virtually no error-reporting at all, if something goes wrong in<br>the eval step, you'll only notice because the subsequent get mysteriously<br>fails. And of course something more fancy like the netlab example above (which<br>uses proxies to represent matlab class instances in python) would be<br>impossible to accomplish in pymat in a similar manner.<br><br>However should you need low-level access, then that is equally available<br>(and with error reporting); basically just replace pymat with<br>mlabraw above and use mlab._session as session), i.e<br><br>&gt;&gt;&gt; from mlab import mlab<br>&gt;&gt;&gt; import mlabraw<br>&gt;&gt;&gt; mlabraw.put(mlab._session, \"X\", [[1,2], [1,3]])<br>[...]<br><br>Before you resort to this you should ask yourself if it's really a good idea;<br>the inherent overhead associated with Matlab's C interface appears to be quite<br>high, so the additional python overhead shouldn't normally matter much -- if<br>efficiency becomes an issue it's probably better to try to chunk together<br>several matlab commands in an .m-file in order to reduce the number of<br>matlab calls. If you're looking for a way to execute \"raw\" matlab for specific<br>purposes, mlab._do is probably a better idea. The low-level mlabraw<br>API is much more likely to change in completely backwards incompatible ways in<br>future versions of mlabwrap. You've been warned.<br><br>What's Missing?<br><br>Handling of as arrays of (array) rank 3 or more as well as<br>non-double/complex arrays (currently everything is converted to<br>double/complex for passing to Matlab and passing non-double/complex from<br>Matlab is not not supported). Both should be reasonably easy to implement,<br>but not that many people have asked for it and I haven't got around to it<br>yet.<br><br>Better support for cells.<br><br>Thread-safety. If you think there's a need please let me know (on the<br>StackOverflow tagged query); at the moment you can /probably/ get away with<br>using one seperate MlabWrap object per thread without implementing your own<br>locking, but even that hasn't been tested.<br><br>Implementation Notes<br><br>So how does it all work?<br><br>I've got a C extension module (a heavily bug-fixed and somewhat modified<br>version of pymat, an open-source, low-level python-matlab interface) to take<br>care of opening Matlab sessions, sending Matlab commands as strings to a<br>running Matlab session and and converting Numeric arrays (and sequences and<br>strings...) to Matlab matrices and vice versa. On top of this I then built a<br>pure python module that with various bells and whistles gives the impression<br>of providing a Matlab \"module\".<br><br>This is done by a class that manages a single Matlab session (of which mlab<br>is an instance) and creates methods with docstrings on-the-fly. Thus, on the<br>first call of mlab.abs(1), the wrapper looks whether there already is a<br>matching function in the cache. If not, the docstring for abs is looked up<br>in Matlab and Matlab's flimsy introspection abilities are used to determine<br>the number of output arguments (0 or more), then a function with the right<br>docstring is dynamically created and assigned to mlab.abs. This function<br>takes care of the conversion of all input parameters and the return values,<br>using proxies where necessary. Proxy are a bit more involved and the proxy<br>pickling scheme uses Matlab's save command to create a binary version of<br>the proxy's contents which is then pickled, together with the proxy object by<br>python itself. Hope that gives a vague idea, for more info study the source.<br><br>Troubleshooting<br><br>Strange hangs under Matlab R2008a<br><br>It looks like this particular version of matlab might be broken (I was able to<br>reproduced the problem with just a stripped down engdemo.c under 64-bit<br>linux). R2008b is reported to be working correctly (as are several earlier<br>versions).<br><br>matlab not in path<br><br>setup.py will call matlab in an attempt to query the version and other<br>information relevant for installation, so it has to be in your PATH<br>unless you specify everything by hand in setup.py. Of course to be able<br>to use mlabwrap in any way matlab will have to be in your path anyway<br>(unless that is you set the environment variable MLABRAW_CMD_STR that<br>specifies how exactly Matlab should be called).<br><br>\"Can't open engine\"<br><br>If you see something like mlabraw.error: Unable to start MATLAB(TM) engine<br>then you may be using an incompatible C++ compiler (or version), or if you're<br>using unix you might not have csh installed under /bin/csh, see below.<br>Try if you can get the engdemo.c file to work that comes with your Matlab<br>installation -- engdemo provides detailed instructions, but in a nutshell:<br>copy it to a directory where you have write access and do<br>(assuming Matlab is installed in /opt/MatlabR14 and you're running unix,<br>otherwise modify as requird):<br><br>mex -f /opt/MatlabR14/bin/engopts.sh engdemo.c<br>./engdemo<br><br>if you get Can't start MATLAB engine chances are you're trying to use a<br>compiler version that's not in Mathworks's list of compatible compilers or<br>something else with your compiler/Matlab installation is broken that needs to<br>be resolved before you can successfully build mlabwrap. Chances are that you<br>or you institution pays a lot of money to the Mathworks, so they should be<br>happy to give you some tech support. Here's what some user who recently<br>(2007-02-04) got Matlab 7.04's mex support to work under Ubuntu Edgy after an<br>exchange with support reported back; apart from installing gcc-3.2.3, he did<br>the following:<br><br>The code I'd run (from within Matlab) is...<br>&gt; mex -setup;     # then select: 2 - gcc Mex options<br>&gt; optsfile = [matlabroot '/bin/engopts.sh'];<br>&gt; mex -v -f optsfile 'engdemo.c';<br>&gt; !./engdemo;<br><br>Update John Bender reports that under unix csh needs to be installed in<br>/bin/csh for the matlab external engine to work -- since many linux<br>distros don't install csh by default, you might have to do something like<br>sudo apt-get install csh (e.g. under ubuntu or other debian-based<br>systems). He also pointed out this helpful engdemo troubleshooting page at<br>the Mathworks(tm) site.<br><br>\"`GLIBCXX_3.4.9' not found\" on importing mlab (or similar)<br><br>As above, first try to see if you can get engdemo.c to work, because<br>as long as even the examples that come with Matlab don't compile,<br>chances of mlabwrap compiling are rather slim. On the plus-side<br>if the problem isn't mlabwrap specific, The Mathworks and/or<br>Matlab-specific support forums should be able to help.<br><br>Old Matlab version<br><br>If you get something like this on python setup.py install:<br><br>mlabraw.cpp:634: `engGetVariable' undeclared (first use this function)<br><br>Then you're presumably using an old version of Matlab (i.e. &lt; 6.5);<br>setup.py ought to have detected this though (try adjusting<br>MATLAB_VERSION by hand and write me a bug report).<br><br>OS X<br><br>Josh Marshall tried it under OS X and sent me the following notes (thanks!).<br><br>Notes on running<br><br>Before running python, run:<br><br>export  DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH$:/Applications/MATLAB701/bin/mac/<br>export MLABRAW_CMD_STR=/Applications/MATLAB701/bin/matlab<br><br>[Edit: I'm not sure DYLD_LIBRARY_PATH modification is still necessary.]<br><br>As far as graphics commands go, the python interpreter will need to  be run<br>from within the X11 xterm to be able to display anything to the  screen.<br>ie, the command for lazy people<br><br>&gt;&gt;&gt; from mlabwrap import mlab; mlab.plot([1,2,3],'-o')<br><br>won't work unless python is run from an xterm, and the matlab startup<br>string is<br>changed to:<br><br>export MLABRAW_CMD_STR=\"/Applications/MATLAB701/bin/matlab -nodesktop\"<br><br>Windows<br><br>&lt;string&gt;:529: (INFO/1) Duplicate implicit target name: \"windows\".<br><br>I'm thankfully not using windows myself, but I try to keep mlabwrap working<br>under windows, for which I depend on the feedback from windows users.<br><br>Since there are several popular C++ compilers under windows, you might have to<br>tell setup.py which one you'd like to use (unless it's VC 7).<br><br>George A. Blaha sent me a patch for Borland C++ support; search for \"Borland<br>C++\" in setup.py and follow the instructions.<br><br>Dylan T Walker writes mingw32 will also work fine, but for some reason<br>(distuils glitch?) the following invocation is required:<br><br>&gt; setup.py build --compiler=mingw32<br>&gt; setup.py install --skip-build<br><br>Function Handles and callbacks into python<br><br>People sometimes try to pass a python function to a matlab function (e.g.<br>mlab.fzero(lambda x: x**2-2, 0)) which will result in an error messages<br>because callbacks into python are not implemented (I'm not even it would even<br>be feasible). Whilst there is no general workaround, in some cases you can<br>just create an equivalent matlab function on the fly, e.g. do something like<br>this: mlab.fzero(mlab.eval('@(x) x^2-2', 0)).<br><br>Directly manipulating variables in Matlab space<br><br>In certain (rare!) certain cases it might be necessary to directly access or<br>set a global variable in matlab. In these cases you can use mlab._get('SOME_VAR')<br>and mlab._set('SOME_VAR', somevalue).<br>Support and Feedback<br><br>Post your questions directly on Stack overflow with tags matlab, mlab<br>and python<br><br><br>Credits<br><br>Alejandro Weinstein for patches of 1.1pre<br>https://github.com/aweinstein/mlabwrap<br><br>Alexander Schmolck and Vivek Rathod for mlabwrap:<br>http://mlabwrap.sourceforge.net/<br><br>Andrew Sterian for writing pymat without which this module would never have<br>existed.<br><br>Matthew Brett contributed numpy compatibility and nice setup.py improvements<br>(which I adapted a bit) to further reduce the need for manual user<br>intervention for installation.<br><br>I'm only using linux myself -- so I gratefully acknowledge the help of Windows<br>and OS X users to get things running smoothly under these OSes as well;<br>particularly those who provided patches to setup.py or mlabraw.cpp (Joris van<br>Zwieten, George A. Blaha and others).<br><br>Matlab is a registered trademark of The Mathworks.\n          </div>"}, "last_serial": 1203073, "releases": {"1.1.1": [{"comment_text": "", "digests": {"md5": "7f89c87131774e55fdbec2e6f570284c", "sha256": "2d335255337fa43c64526b8cce7f6b9ca12ca3226c6d72bd8e83da2bfae0c950"}, "downloads": -1, "filename": "mlab-1.1.1.tar.gz", "has_sig": false, "md5_digest": "7f89c87131774e55fdbec2e6f570284c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 44515, "upload_time": "2013-07-26T16:24:40", "upload_time_iso_8601": "2013-07-26T16:24:40.865955Z", "url": "https://files.pythonhosted.org/packages/7d/74/69480097cdf9a02eb7dc520dae0f8651f91ec37f0c8fe6806830841353a8/mlab-1.1.1.tar.gz", "yanked": false}], "1.1.2": [{"comment_text": "", "digests": {"md5": "597eceab3219b9c4aa339fd57896c599", "sha256": "ebfbe5d31925c34ae904da7b3d1a6dd0fadf73c944bd793428ffedc41d989b03"}, "downloads": -1, "filename": "mlab-1.1.2.tar.gz", "has_sig": false, "md5_digest": "597eceab3219b9c4aa339fd57896c599", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58237, "upload_time": "2013-08-18T23:54:25", "upload_time_iso_8601": "2013-08-18T23:54:25.965692Z", "url": "https://files.pythonhosted.org/packages/b9/fb/146276a9a7444e1984724948cbfcfd4a846ca10d7630e98a63ed08261701/mlab-1.1.2.tar.gz", "yanked": false}], "1.1.3": [{"comment_text": "", "digests": {"md5": "46ab6dd06c9d69168d68ffc27b583ff5", "sha256": "df24db65fe33a03407ee6f42f62f2857cbde18d0dddc70ef5667f93a8ba7dd3f"}, "downloads": -1, "filename": "mlab-1.1.3.tar.gz", "has_sig": false, "md5_digest": "46ab6dd06c9d69168d68ffc27b583ff5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49159, "upload_time": "2014-08-26T16:03:55", "upload_time_iso_8601": "2014-08-26T16:03:55.471967Z", "url": "https://files.pythonhosted.org/packages/a8/04/4d6f83be96dd5286c3f72b1b81adbd0c89d74f08ae88da68998856a014f6/mlab-1.1.3.tar.gz", "yanked": false}], "1.1.4": [{"comment_text": "", "digests": {"md5": "5dcdf0653cb8a2734f3815a215155633", "sha256": "cd44ccf794e79e0c9c0ae1aafd4dea805c677b208e45222484feb025f691c000"}, "downloads": -1, "filename": "mlab-1.1.4.tar.gz", "has_sig": false, "md5_digest": "5dcdf0653cb8a2734f3815a215155633", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49175, "upload_time": "2014-08-26T16:19:43", "upload_time_iso_8601": "2014-08-26T16:19:43.697052Z", "url": "https://files.pythonhosted.org/packages/84/44/c2bc56f1628299282c53717a8791ee2912e1e329343ef964fb723d760b46/mlab-1.1.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5dcdf0653cb8a2734f3815a215155633", "sha256": "cd44ccf794e79e0c9c0ae1aafd4dea805c677b208e45222484feb025f691c000"}, "downloads": -1, "filename": "mlab-1.1.4.tar.gz", "has_sig": false, "md5_digest": "5dcdf0653cb8a2734f3815a215155633", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49175, "upload_time": "2014-08-26T16:19:43", "upload_time_iso_8601": "2014-08-26T16:19:43.697052Z", "url": "https://files.pythonhosted.org/packages/84/44/c2bc56f1628299282c53717a8791ee2912e1e329343ef964fb723d760b46/mlab-1.1.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:53:39 2020"}