{"info": {"author": "Michal Cokina, Miroslav Fedurco", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Programming Language :: Python :: 3.6", "Topic :: Scientific/Engineering :: Astronomy"], "description": "STellAr Surface MAker\n=====================\n\nstasma\n------\n\n\n**Stasma** is python package created to make binary and single star systems modeling easier.\nInside the package, Roche potential is implemented as a generalized implicit description of binary star surface and\nsimple potential for single rotating star.\n\nStasma is a precursor for **elisa** package that is currently in development, and it is intended\nto be application with full implementation of eclipsing binary star and single star physics including light curve\nmodeling including pulsations.\n\nRequirements\n------------\n\n**Stasma** is a python package which requires ``python v3.6+`` and has following dependencies::\n\n    cycler==0.10.0\n    matplotlib==2.1.0\n    numpy==1.13.3\n    pandas==0.23.0\n    pyparsing==2.2.0\n    pytest==3.2.3\n    python-dateutil==2.6.1\n    pytz==2017.2\n    py==1.4.34\n    astropy==2.0.2\n    scipy==1.0.0\n    six==1.11.0\n\nNevertheless, versions are specified precisely, it doesn't mean that stasma won't work with higher versions,\nit just was not tested with other versions of mentioned python packages.\n\n``stasma`` is multiplatform library fully supported on Linux and Windows operating systems.\n\nHow to\n------\n\nThe following guide describes all capabilities and features of this package.\n\nInstall\n-------\n\nAs an any python package, ``stasma`` the easiest and safer way to install is to create python virtual\nenvironment and install all requirements into it. Here is a simple guide, how to od it. Details of installation differ\nin dependence on the selected operating system.\n\nUbuntu [or similar]\n~~~~~~~~~~~~~~~~~~~\n\nFirst, you have to install Python 3.6 or higher. In newest stable version ``Ubuntu 18.04`` there is already preinstalled\npython `3.6.x`. In older versions, you will have to add repository and install it manually.\n\nInstall ``pip3`` python package manager if is not already installed on your system, usually by execution of command::\n\n    apt install -y python3-pip\n\nInstall virtual environment by command::\n\n    pip3 install virtualenv\n\nTo create virtual environment, create directory where python virtual environment will be stored, e.g. ``/<any>/<path>/env36``\nand run following command::\n\n    virtualenv /<any>/<path>/env36 --python=python3.6\n\nAfter few moments you virtual environment is created and ready for use. In terminal window, activate virtual environment::\n\n    . /<any>/<path>/env36/bin/activate\n\nWhen virtual environment is activated, install ``stasma`` by::\n\n    pip3 install stasma\n\n\nWindows\n~~~~~~~\n\nTo install python in windows, download ``python 3.6.x`` installation package from official python web site.\nInstallation package will create all necessary dependencies with exception of virtual environment.\nInstall virtual environment by execution of following command in command line::\n\n    pip3 install virtualenv\n\nMake sure a proper version of  python and pip is used. When done, create directory where virtual environment will be\nstored and run::\n\n    virtualenv /<any>/<path>/env36 --python=python3.6\n\nNow, when virtual environment is prepared, run::\n\n    . /<any>/<path>/env36/Scripts/activate\n\nAnd finally install ``stasma``::\n\n    pip3 install stasma\n\nConfiguration\n-------------\n\nCurrently, you have a possibility to configure logging level and logging structure.\nBy default, logging level is specified by ``json`` logging  definition deployed in site-packages\n(installation directory of all python packages). If you want to enable logging,\njust import configuration module and run setup logging function\n\n.. code:: python\n\n    from stasma.conf import config\n\n    def main():\n        config.set_up_logging()\n        ...\n\n    if __name__ == \"__main__\":\n        main()\n\nIf you wish to change a logging, define your own ``json`` configuration and setup path in stasma configuration ini file\n\n.. code:: ini\n\n    [general]\n    log_config=/<path>/<to>/<logging>/<json>\n\nConfiguration ini file has to be supplied either as environment variable ``STASMA_CONFIG`` or  stored in your\nvirtual environment directory as ``conf/stasma_conf.ini``.\n\nImportant api docs\n------------------\n\n``stasma.base.star.Star:``\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    class define Star instance\n\n    :param name: char; name of instance\n    :param suppress_logger: bool; enable/disable logger\n    :param kwargs:\n        :**kwargs options**:\n            * **mass** * --  float or astropy.units.Quantity;\n                    mass of Start object\n\n            * **surface_potential** * --  float;\n                    unit-less Roche surface potential of Star\n\n            * **synchronicity** * --  float;\n                    synchronicity of Star defined in generalized Roche potential as ratio of rotational angular\n                    velocity to orbital angular velocity\n\n            * **discretization_factor** * --  float;\n                    average angular distance of two nearest points on Star surface\n\n            * **spots** * --  list of dicts;\n                    list of spots definition (see ``from stasma.base.Spot``)\n\n            * **mass** * --  float or astropy.units.Quantity;\n                    mass of Start object\n\n            * **polar_log_g** * --  float;\n                    polar gravity acceleration in log10 of cgs units\n\n            * **color** * -- list; [<0-255>, <0-255>, <0-255>]\n                    color definition for plotting\n\n\n*important accessible properties computed on fly:*\n\n    - critical_surface_potential\n    - backward_radius\n    - forward_radius\n    - polar_radius\n    - side_radius\n\n``stasma.base.star.Spot:``\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    :note: instances of this class are used as a container for individual spot defined for each Star; it is not intended to be used stand alone\n\n    :param kwargs:\n        :**kwargs options**:\n            * **longitude** * --  float;\n                    longitude of spot center\n\n            * **latitude** * --  float;\n                    latitude of spot center\n\n            * **angular_diameter** * --  float;\n                    angular diameter of spot\n\n            * **discretization_factor** * --  float;\n                    discretization factor of spor, if not specified, discretization of parent Star will be used\n\n            * **color** * -- list; [<0-255>, <0-255>, <0-255>]\n                color definition for plotting for given spot\n\n``stasma.single_system.system.SingleSystem:``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    :param name: char; name of instance\n    :param suppress_logger: bool; enable/disable loggerd\n    :param kwargs:\n        :**kwargs options**:\n            * **period** * --  stasma.base.star.Star;;\n                    instance of Star\n            * **inclination** * --  float or astropy.units.Quantity;\n                    inclination of binary system; default unit is `degree`\n            * **rotation_period** * --  float or astropy.units.Quantity;\n                    rotation period of star; default unit is `day`\n\n\n``stasma.single_system.system.SingleSystem.build_mesh(self, return_mesh=False):``\n.................................................................................\n\nuser face method for building mesh; as mesh we define a set of points on surface of star objects.\n\n    :param return_mesh: bool; if True, return surface points of object (spots included); return value of method will be numpy.arrays like numpy.array(<points>)\n    :return: numpy.array or None\n\n``stasma.single_system.system.SingleSystem.build_surface(self, return_surface=False):``\n.......................................................................................\n\n    user face method to build surface; there is assumption that build_mesh() was called before this method, otherwise calling this method will lead to crash\n\n    :param return_surface: bool; if True, return value of method will be tuple like (points, faces)\n    :return: Tuple or None\n\n``stasma.single_system.system.SingleSystem.plot.equipotential(self, **kwargs):``\n................................................................................\n\n    :param kwargs:\n        :**kwargs options**:\n            * **axis_unit** * --  any astropy.unit lenght unit, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc. if empty astropy.units.solRad is assumed;\n\n``stasma.single_system.system.SingleSystem.plot.mesh(self, **kwargs):``\n.......................................................................\n\n    :param kwargs:\n        :**kwargs options**:\n            * **axis_unit** * --  any astropy.unit lenght unit, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc. if empty astropy.units.solRad is assumed;\n            * **plot_axis** * --  enable/disable axis in resulting plot, deafault is True;\n            * **inclination** * --  angle between rotational axis and line of sight;\n            * **azimuth** * --  angle between 0 latitude meridian and line of sight;\n\n``stasma.single_system.system.SingleSystem.plot.wireframe(self, **kwargs):``\n............................................................................\n\n    :param kwargs:\n        :**kwargs options**:\n            * **axis_unit** * --  any astropy.unit lenght unit, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc. if empty astropy.units.solRad is assumed;\n            * **plot_axis** * --  enable/disable axis in resulting plot, deafault is True;\n            * **inclination** * --  angle between rotational axis and line of sight;\n            * **azimuth** * --  angle between 0 latitude meridian and line of sight;\n\n``stasma.single_system.system.SingleSystem.plot.surface(self, **kwargs)``:\n..........................................................................\n\n    :param kwargs:\n        :**kwargs options**:\n            * **axis_unit** * --  any astropy.unit lenght unit, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc. if empty astropy.units.solRad is assumed;\n            * **edges** * --  enable/disable edge highlight of faces, default is True;\n            * **normals** * --  enable/disable normal vector of faces, default is False;\n            * **inclination** * --  angle between rotational axis and line of sight;\n            * **azimuth** * --  angle between 0 latitude meridian and line of sight;\n            * **units** * --  any astropy.unit lenght unit, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc. if empty astropy.units.solRad is assumed;\n\n``stasma.binary_system.system.BinarySystem:``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    :param name: char; name of instance\n    :param primary: stasma.base.star.Star; instance of primary Star\n    :param secondary: stasma.base.star.Star; instance of secondary Star\n    :param suppress_logger: bool; enable/disable logger\n    :param kwargs:\n        :**kwargs options**:\n            * **period** * --  float or astropy.units.Quantity; period of binary system, default unit is `day`\n\n            * **eccentricity** * --  float; eccentricity of binary system\n\n            * **inclination** * --  float or astropy.units.Quantity; inclination of binary system; default unit is `radian`\n\n            * **argument_of_periastron** * --  float or astropy.units.Quantity; argument_of_periastron of binary system; default unit is `radian`\n\n*user face methods:*\n\n``stasma.binary_system.system.BinarySystem.build_mesh(self, component=None, components_distance=None, return_mesh=False):``\n...........................................................................................................................\n\n    user face method for building mesh; as mesh we define a points surface of star objects.\n\n    :param component: str or list; define component to build surface for; if None, surface for both components will be evaluated\n    :param components_distance: float;\n    :param return_surface: bool; if True, return points of objects (spots included); return value of method will be dictionary of numpy.arrays like {\"primary\": numpy.array(<points>), \"secondary\": numpy.array(<points>)}\n    :return: Dict or None\n\n\n``stasma.binary_system.system.BinarySystem.build_surface(self, component=None, components_distance=None, return_surface=False):``\n.................................................................................................................................\n\n    user face method to build surface.;There is assumption that build_mesh() was called before this method, otherwise calling this method will lead to crash\n\n    :param component: str or list; define component to build surface for; if None, surface for both components will be evaluated\n    :param components_distance: float;\n    :param return_surface: bool; if True, return value of method will be tuple like (points, faces)\n    :return: Tuple or None\n\n``stasma.binary_system.system.BinarySystem.plot.orbit(self, **kwargs):``\n........................................................................\n\n    :param kwargs:\n        :**kwargs options**:\n            * **start_phase** * --  float;\n            * **stop_phase** * --  float;\n            * **number_of_points** * --  int;\n            * **axis_unit** * --  any astropy.unit lenght unit or `dimensionless`, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc., if empty `dimensionless` is assumed where semi major axis is set to 1;\n            * **frame_of_reference** * --  str; `primary` or `barycenter`\n\n``stasma.binary_system.system.BinarySystem.plot.equipotential(self, **kwargs):``\n................................................................................\n\n    :param kwargs:\n        :**kwargs options**:\n            * **plane** * --  str; `xy`, `yz`, `zy`\n            * **phase** * --  float;\n\n``stasma.binary_system.system.BinarySystem.plot.mesh(self, **kwargs):``\n.......................................................................\n\n    :param kwargs:\n        :**kwargs options**:\n            * **phase** * --  float;\n            * **components_to_plot** * --  str; `primary`, `secondary` or `both`\n            * **plot_axis** * --  bool;\n            * **inclination** * --  angle between orbital axis and line of sight;\n            * **azimuth** * --  photometric phase of the system;\n\n``stasma.binary_system.system.BinarySystem.plot.wireframe(self, **kwargs):``\n............................................................................\n\n    :param kwargs:\n        :**kwargs options**:\n            * **phase** * --  float;\n            * **components_to_plot** * --  str; `primary`, `secondary` or `both`\n            * **plot_axis** * --  bool;\n            * **inclination** * --  angle between orbital axis and line of sight;\n            * **azimuth** * --  photometric phase of the system;\n\n``stasma.binary_system.system.BinarySystem.plot.surface(self, **kwargs):``\n..........................................................................\n\n    :param kwargs:\n        :**kwargs options**:\n            * **phase** * --  float;\n            * **components_to_plot** * --  str; `primary`, `secondary` or `both`\n            * **normals** * --  bool;\n            * **edges** * --  bool;\n            * **plot_axis** * --  bool;\n            * **inclination** * -- float or wtf;\n            * **azimuth** * -- float;\n            * **units** * -- any astropy.unit lenght unit or `dimensionless`, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc., if empty `dimensionless` is assumed where semi major axis is set to 1;\n\n*important accessible properties computed on fly:*\n\n    - semi_major_axis\n    - morphology\n    - mass_ratio\n    - orbit\n\n``stasma.binary_system.orbit.Orbit:``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    :param suppress_logger: bool; enable/disable logger\n    :param kwargs:\n        :**kwargs options**:\n            * **period** * --  float or astropy.units.Quantity; period of binary system, default unit is `day`\n\n            * **eccentricity** * --  float; eccentricity of binary system\n\n            * **inclination** * --  float or astropy.units.Quantity; inclination of binary system; default unit is `degree`\n\n            * **argument_of_periastron** * --  float or astropy.units.Quantity; argument_of_periastron of binary system; default unit is `radian`\n\n*user face methods:*\n\n``stasma.binary_system.orbit.Orbit.orbital_motion(self, phase=None):``\n......................................................................\n\n    function takes photometric phase of the binary system as input and calculates positions of the secondary\n    component in the frame of reference of primary component\n\n    :param phase: numpy.array or numpy.float\n    :return: numpy.array: matrix consisting of column stacked vectors distance, azimut angle, true anomaly and phase\n\n    ::\n\n                       numpy.array((r1, az1, ni1, phs1),\n                                   (r2, az2, ni2, phs2),\n                                   ...\n                                   (rN, azN, niN, phsN))\n\n*important accessible properties computed on fly:*\n\n    - periastron_distance\n    - periastron_phase\n\nBasic examples and usage\n------------------------\n\nCreate binary sytem\n~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    from astropy import units\n    from stasma.base.star import Star\n    from stasma.binary_system.system import BinarySystem\n\n\n    def main():\n\n         primary = Star(\n            mass=2.0 * units.solMass,\n            surface_potential=2.6,\n            synchronicity=1.0,\n            discretization_factor=5,\n            color=[0, 255, 0]\n        )\n        secondary = Star(\n            mass=1.0 * units.solMass,\n            surface_potential=2.6,\n            synchronicity=1.0,\n            discretization_factor=5,\n            color=[255, 0, 0]\n        )\n\n        bs = BinarySystem(\n            primary=primary,\n            secondary=secondary,\n            argument_of_periastron=90 * units.deg,\n            period=1 * units.d,\n            eccentricity=0.0,\n            inclination=90 * units.deg\n        )\n\n    if __name__ == \"__main__\":\n        main()\n\nCreate single system\n~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    from astropy import units\n    from stasma.base.star import Star\n    from stasma.single_system.system import SingleSystem\n\n\n    def main():\n\n        star = Star(\n            mass=1.0 * units.solMass,\n            discretization_factor=3,\n            polar_log_g=4.1 * units.dex(units.cm / units.s ** 2),\n            color=[255, 0, 0]\n        )\n\n        single = SingleSystem(\n            star=star,\n            inclination=90 * units.deg,\n            rotation_period=0.5 * units.d\n        )\n\n    if __name__ == \"__main__\":\n        main()\n\nCreate binary sytem with three spots on primary and one spot on secondary component\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    from astropy import units\n    from stasma.base.star import Star\n    from stasma.binary_system.system import BinarySystem\n\n    def main():\n\n        spots_metadata = {\n        \"primary\":\n            [\n                {\"longitude\": 90,\n                 \"latitude\": 58,\n                 \"angular_diameter\": 15},\n                {\"longitude\": 85,\n                 \"latitude\": 80,\n                 \"angular_diameter\": 30},\n                {\"longitude\": 45,\n                 \"latitude\": 90,\n                 \"angular_diameter\": 30},\n            ],\n\n        \"secondary\":\n            [\n                {\"longitude\": 90,\n                 \"latitude\": 0,\n                 \"angular_diameter\": 40},\n            ]\n        }\n\n        primary = Star(\n            mass=2.0 * units.solMass,\n            surface_potential=2.6,\n            synchronicity=1.0,\n            discretization_factor=4,\n            spots=spots_metadata['primary'],\n            color=[0, 255, 0]\n        )\n        secondary = Star(\n            mass=1.0 * units.solMass,\n            surface_potential=2.6,\n            synchronicity=1.0,\n            discretization_factor=4,\n            spots=spots_metadata['secondary'],\n            color=[255, 0, 0]\n        )\n\n        bs = BinarySystem(\n            primary=primary,\n            secondary=secondary,\n            argument_of_periastron=90 * units.deg,\n            period=1 * units.d,\n            eccentricity=0.0,\n            inclination=90 * units.deg,\n        )\n\n    if __name__ == \"__main__\":\n        main()\n\nBuild mesh and surface of objects in binary system\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n:note: parameter `componetn_distance` is driven parameter to involve capability to compute and create system in different part of eccentric orbit\n\n**After computation, properties like ``points`` or ``faces`` are available from Star class instaces.**\n\n.. code-block:: python\n\n    def main():\n        ...\n        # definitions\n\n        bs.build_mesh(components_distance=1.0)\n        bs.build_surface(components_distance=1.0)\n\n        print(primary.points)\n        print(primary.faces)\n        print(primary.spots)\n\n        print(primary.spots[#index].points)\n        print(primary.spots[#index].faces)\n\n    if __name__ == \"__main__\":\n        main()\n\nBuild mesh and surface of objects in single system\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**After computation, properties like ``points`` or ``faces`` are available from Star class instace.**\n\n.. code-block:: python\n\n    def main():\n        ...\n        # definitions\n\n        single.build_mesh()\n        single.build_surface()\n\n        print(star.points)\n        print(star.faces)\n        print(star.spots)\n\n        print(star.spots[#index].points)\n        print(star.spots[#index].faces)\n\n    if __name__ == \"__main__\":\n        main()\n\n\nPlot binary star system wireframe\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    def main():\n        ...\n        # definitions\n\n        bs.build_mesh(components_distance=1.0)\n        bs.build_surface(components_distance=1.0)\n\n        bs.plot.wireframe()\n\n    if __name__ == \"__main__\":\n        main()\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/mikecokina/stasma.git", "keywords": "eclipsing binaries astronomy analysis physic", "license": "", "maintainer": "", "maintainer_email": "", "name": "stasma", "package_url": "https://pypi.org/project/stasma/", "platform": "", "project_url": "https://pypi.org/project/stasma/", "project_urls": {"Homepage": "https://github.com/mikecokina/stasma.git"}, "release_url": "https://pypi.org/project/stasma/0.1.2/", "requires_dist": ["astropy (==2.0.2)", "cycler (==0.10.0)", "matplotlib (==2.1.0)", "numpy (==1.13.3)", "pandas (==0.23.0)", "py (==1.4.34)", "pyparsing (==2.2.0)", "pytest (==3.2.3)", "python-dateutil (==2.6.1)", "pytz (==2017.2)", "scipy (==1.0.0)", "six (==1.11.0)"], "requires_python": "", "summary": "Stellar surface maker", "version": "0.1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"stasma\">\n<h2>stasma</h2>\n<p><strong>Stasma</strong> is python package created to make binary and single star systems modeling easier.\nInside the package, Roche potential is implemented as a generalized implicit description of binary star surface and\nsimple potential for single rotating star.</p>\n<p>Stasma is a precursor for <strong>elisa</strong> package that is currently in development, and it is intended\nto be application with full implementation of eclipsing binary star and single star physics including light curve\nmodeling including pulsations.</p>\n</div>\n<div id=\"requirements\">\n<h2>Requirements</h2>\n<p><strong>Stasma</strong> is a python package which requires <tt>python v3.6+</tt> and has following dependencies:</p>\n<pre>cycler==0.10.0\nmatplotlib==2.1.0\nnumpy==1.13.3\npandas==0.23.0\npyparsing==2.2.0\npytest==3.2.3\npython-dateutil==2.6.1\npytz==2017.2\npy==1.4.34\nastropy==2.0.2\nscipy==1.0.0\nsix==1.11.0\n</pre>\n<p>Nevertheless, versions are specified precisely, it doesn\u2019t mean that stasma won\u2019t work with higher versions,\nit just was not tested with other versions of mentioned python packages.</p>\n<p><tt>stasma</tt> is multiplatform library fully supported on Linux and Windows operating systems.</p>\n</div>\n<div id=\"how-to\">\n<h2>How to</h2>\n<p>The following guide describes all capabilities and features of this package.</p>\n</div>\n<div id=\"install\">\n<h2>Install</h2>\n<p>As an any python package, <tt>stasma</tt> the easiest and safer way to install is to create python virtual\nenvironment and install all requirements into it. Here is a simple guide, how to od it. Details of installation differ\nin dependence on the selected operating system.</p>\n<div id=\"ubuntu-or-similar\">\n<h3>Ubuntu [or similar]</h3>\n<p>First, you have to install Python 3.6 or higher. In newest stable version <tt>Ubuntu 18.04</tt> there is already preinstalled\npython <cite>3.6.x</cite>. In older versions, you will have to add repository and install it manually.</p>\n<p>Install <tt>pip3</tt> python package manager if is not already installed on your system, usually by execution of command:</p>\n<pre>apt install -y python3-pip\n</pre>\n<p>Install virtual environment by command:</p>\n<pre>pip3 install virtualenv\n</pre>\n<p>To create virtual environment, create directory where python virtual environment will be stored, e.g. <tt><span class=\"pre\">/&lt;any&gt;/&lt;path&gt;/env36</span></tt>\nand run following command:</p>\n<pre>virtualenv /&lt;any&gt;/&lt;path&gt;/env36 --python=python3.6\n</pre>\n<p>After few moments you virtual environment is created and ready for use. In terminal window, activate virtual environment:</p>\n<pre>. /&lt;any&gt;/&lt;path&gt;/env36/bin/activate\n</pre>\n<p>When virtual environment is activated, install <tt>stasma</tt> by:</p>\n<pre>pip3 install stasma\n</pre>\n</div>\n<div id=\"windows\">\n<h3>Windows</h3>\n<p>To install python in windows, download <tt>python 3.6.x</tt> installation package from official python web site.\nInstallation package will create all necessary dependencies with exception of virtual environment.\nInstall virtual environment by execution of following command in command line:</p>\n<pre>pip3 install virtualenv\n</pre>\n<p>Make sure a proper version of  python and pip is used. When done, create directory where virtual environment will be\nstored and run:</p>\n<pre>virtualenv /&lt;any&gt;/&lt;path&gt;/env36 --python=python3.6\n</pre>\n<p>Now, when virtual environment is prepared, run:</p>\n<pre>. /&lt;any&gt;/&lt;path&gt;/env36/Scripts/activate\n</pre>\n<p>And finally install <tt>stasma</tt>:</p>\n<pre>pip3 install stasma\n</pre>\n</div>\n</div>\n<div id=\"configuration\">\n<h2>Configuration</h2>\n<p>Currently, you have a possibility to configure logging level and logging structure.\nBy default, logging level is specified by <tt>json</tt> logging  definition deployed in site-packages\n(installation directory of all python packages). If you want to enable logging,\njust import configuration module and run setup logging function</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">stasma.conf</span> <span class=\"kn\">import</span> <span class=\"n\">config</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">set_up_logging</span><span class=\"p\">()</span>\n    <span class=\"o\">...</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n<p>If you wish to change a logging, define your own <tt>json</tt> configuration and setup path in stasma configuration ini file</p>\n<pre><span class=\"k\">[general]</span>\n<span class=\"na\">log_config</span><span class=\"o\">=</span><span class=\"s\">/&lt;path&gt;/&lt;to&gt;/&lt;logging&gt;/&lt;json&gt;</span>\n</pre>\n<p>Configuration ini file has to be supplied either as environment variable <tt>STASMA_CONFIG</tt> or  stored in your\nvirtual environment directory as <tt>conf/stasma_conf.ini</tt>.</p>\n</div>\n<div id=\"important-api-docs\">\n<h2>Important api docs</h2>\n<div id=\"stasma-base-star-star\">\n<h3><tt>stasma.base.star.Star:</tt></h3>\n<blockquote>\n<p>class define Star instance</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param name:</th><td><p>char; name of instance</p>\n</td>\n</tr>\n<tr><th>param suppress_logger:</th></tr>\n<tr><td>\u00a0</td><td><p>bool; enable/disable logger</p>\n</td>\n</tr>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><dl>\n<dt><strong>mass</strong> * \u2013  float or astropy.units.Quantity;</dt>\n<dd>mass of Start object</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>surface_potential</strong> * \u2013  float;</dt>\n<dd>unit-less Roche surface potential of Star</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>synchronicity</strong> * \u2013  float;</dt>\n<dd>synchronicity of Star defined in generalized Roche potential as ratio of rotational angular\nvelocity to orbital angular velocity</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>discretization_factor</strong> * \u2013  float;</dt>\n<dd>average angular distance of two nearest points on Star surface</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>spots</strong> * \u2013  list of dicts;</dt>\n<dd>list of spots definition (see <tt>from stasma.base.Spot</tt>)</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>mass</strong> * \u2013  float or astropy.units.Quantity;</dt>\n<dd>mass of Start object</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>polar_log_g</strong> * \u2013  float;</dt>\n<dd>polar gravity acceleration in log10 of cgs units</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>color</strong> * \u2013 list; [&lt;0-255&gt;, &lt;0-255&gt;, &lt;0-255&gt;]</dt>\n<dd>color definition for plotting</dd>\n</dl>\n</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><em>important accessible properties computed on fly:</em></p>\n<blockquote>\n<ul>\n<li>critical_surface_potential</li>\n<li>backward_radius</li>\n<li>forward_radius</li>\n<li>polar_radius</li>\n<li>side_radius</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"stasma-base-star-spot\">\n<h3><tt>stasma.base.star.Spot:</tt></h3>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>note:</th><td><p>instances of this class are used as a container for individual spot defined for each Star; it is not intended to be used stand alone</p>\n</td>\n</tr>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><dl>\n<dt><strong>longitude</strong> * \u2013  float;</dt>\n<dd>longitude of spot center</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>latitude</strong> * \u2013  float;</dt>\n<dd>latitude of spot center</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>angular_diameter</strong> * \u2013  float;</dt>\n<dd>angular diameter of spot</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>discretization_factor</strong> * \u2013  float;</dt>\n<dd>discretization factor of spor, if not specified, discretization of parent Star will be used</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>color</strong> * \u2013 list; [&lt;0-255&gt;, &lt;0-255&gt;, &lt;0-255&gt;]</dt>\n<dd>color definition for plotting for given spot</dd>\n</dl>\n</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"stasma-single-system-system-singlesystem\">\n<h3><tt>stasma.single_system.system.SingleSystem:</tt></h3>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param name:</th><td><p>char; name of instance</p>\n</td>\n</tr>\n<tr><th>param suppress_logger:</th></tr>\n<tr><td>\u00a0</td><td><p>bool; enable/disable loggerd</p>\n</td>\n</tr>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><dl>\n<dt><strong>period</strong> * \u2013  stasma.base.star.Star;;</dt>\n<dd>instance of Star</dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>inclination</strong> * \u2013  float or astropy.units.Quantity;</dt>\n<dd>inclination of binary system; default unit is <cite>degree</cite></dd>\n</dl>\n</li>\n<li><dl>\n<dt><strong>rotation_period</strong> * \u2013  float or astropy.units.Quantity;</dt>\n<dd>rotation period of star; default unit is <cite>day</cite></dd>\n</dl>\n</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<div id=\"stasma-single-system-system-singlesystem-build-mesh-self-return-mesh-false\">\n<h4><tt>stasma.single_system.system.SingleSystem.build_mesh(self, return_mesh=False):</tt></h4>\n<p>user face method for building mesh; as mesh we define a set of points on surface of star objects.</p>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param return_mesh:</th></tr>\n<tr><td>\u00a0</td><td>bool; if True, return surface points of object (spots included); return value of method will be numpy.arrays like numpy.array(&lt;points&gt;)</td>\n</tr>\n<tr><th>return:</th><td>numpy.array or None</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"stasma-single-system-system-singlesystem-build-surface-self-return-surface-false\">\n<h4><tt>stasma.single_system.system.SingleSystem.build_surface(self, return_surface=False):</tt></h4>\n<blockquote>\n<p>user face method to build surface; there is assumption that build_mesh() was called before this method, otherwise calling this method will lead to crash</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param return_surface:</th></tr>\n<tr><td>\u00a0</td><td>bool; if True, return value of method will be tuple like (points, faces)</td>\n</tr>\n<tr><th>return:</th><td>Tuple or None</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"stasma-single-system-system-singlesystem-plot-equipotential-self-kwargs\">\n<h4><tt>stasma.single_system.system.SingleSystem.plot.equipotential(self, **kwargs):</tt></h4>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><strong>axis_unit</strong> * \u2013  any astropy.unit lenght unit, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc. if empty astropy.units.solRad is assumed;</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"stasma-single-system-system-singlesystem-plot-mesh-self-kwargs\">\n<h4><tt>stasma.single_system.system.SingleSystem.plot.mesh(self, **kwargs):</tt></h4>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><strong>axis_unit</strong> * \u2013  any astropy.unit lenght unit, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc. if empty astropy.units.solRad is assumed;</li>\n<li><strong>plot_axis</strong> * \u2013  enable/disable axis in resulting plot, deafault is True;</li>\n<li><strong>inclination</strong> * \u2013  angle between rotational axis and line of sight;</li>\n<li><strong>azimuth</strong> * \u2013  angle between 0 latitude meridian and line of sight;</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"stasma-single-system-system-singlesystem-plot-wireframe-self-kwargs\">\n<h4><tt>stasma.single_system.system.SingleSystem.plot.wireframe(self, **kwargs):</tt></h4>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><strong>axis_unit</strong> * \u2013  any astropy.unit lenght unit, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc. if empty astropy.units.solRad is assumed;</li>\n<li><strong>plot_axis</strong> * \u2013  enable/disable axis in resulting plot, deafault is True;</li>\n<li><strong>inclination</strong> * \u2013  angle between rotational axis and line of sight;</li>\n<li><strong>azimuth</strong> * \u2013  angle between 0 latitude meridian and line of sight;</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"stasma-single-system-system-singlesystem-plot-surface-self-kwargs\">\n<h4><tt>stasma.single_system.system.SingleSystem.plot.surface(self, **kwargs)</tt>:</h4>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><strong>axis_unit</strong> * \u2013  any astropy.unit lenght unit, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc. if empty astropy.units.solRad is assumed;</li>\n<li><strong>edges</strong> * \u2013  enable/disable edge highlight of faces, default is True;</li>\n<li><strong>normals</strong> * \u2013  enable/disable normal vector of faces, default is False;</li>\n<li><strong>inclination</strong> * \u2013  angle between rotational axis and line of sight;</li>\n<li><strong>azimuth</strong> * \u2013  angle between 0 latitude meridian and line of sight;</li>\n<li><strong>units</strong> * \u2013  any astropy.unit lenght unit, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc. if empty astropy.units.solRad is assumed;</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n</div>\n<div id=\"stasma-binary-system-system-binarysystem\">\n<h3><tt>stasma.binary_system.system.BinarySystem:</tt></h3>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param name:</th><td><p>char; name of instance</p>\n</td>\n</tr>\n<tr><th>param primary:</th><td><p>stasma.base.star.Star; instance of primary Star</p>\n</td>\n</tr>\n<tr><th>param secondary:</th></tr>\n<tr><td>\u00a0</td><td><p>stasma.base.star.Star; instance of secondary Star</p>\n</td>\n</tr>\n<tr><th>param suppress_logger:</th></tr>\n<tr><td>\u00a0</td><td><p>bool; enable/disable logger</p>\n</td>\n</tr>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><strong>period</strong> * \u2013  float or astropy.units.Quantity; period of binary system, default unit is <cite>day</cite></li>\n<li><strong>eccentricity</strong> * \u2013  float; eccentricity of binary system</li>\n<li><strong>inclination</strong> * \u2013  float or astropy.units.Quantity; inclination of binary system; default unit is <cite>radian</cite></li>\n<li><strong>argument_of_periastron</strong> * \u2013  float or astropy.units.Quantity; argument_of_periastron of binary system; default unit is <cite>radian</cite></li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><em>user face methods:</em></p>\n<div id=\"stasma-binary-system-system-binarysystem-build-mesh-self-component-none-components-distance-none-return-mesh-false\">\n<h4><tt>stasma.binary_system.system.BinarySystem.build_mesh(self, component=None, components_distance=None, return_mesh=False):</tt></h4>\n<blockquote>\n<p>user face method for building mesh; as mesh we define a points surface of star objects.</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param component:</th></tr>\n<tr><td>\u00a0</td><td>str or list; define component to build surface for; if None, surface for both components will be evaluated</td>\n</tr>\n<tr><th>param components_distance:</th></tr>\n<tr><td>\u00a0</td><td>float;</td>\n</tr>\n<tr><th>param return_surface:</th></tr>\n<tr><td>\u00a0</td><td>bool; if True, return points of objects (spots included); return value of method will be dictionary of numpy.arrays like {\u201cprimary\u201d: numpy.array(&lt;points&gt;), \u201csecondary\u201d: numpy.array(&lt;points&gt;)}</td>\n</tr>\n<tr><th>return:</th><td>Dict or None</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"stasma-binary-system-system-binarysystem-build-surface-self-component-none-components-distance-none-return-surface-false\">\n<h4><tt>stasma.binary_system.system.BinarySystem.build_surface(self, component=None, components_distance=None, return_surface=False):</tt></h4>\n<blockquote>\n<p>user face method to build surface.;There is assumption that build_mesh() was called before this method, otherwise calling this method will lead to crash</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param component:</th></tr>\n<tr><td>\u00a0</td><td>str or list; define component to build surface for; if None, surface for both components will be evaluated</td>\n</tr>\n<tr><th>param components_distance:</th></tr>\n<tr><td>\u00a0</td><td>float;</td>\n</tr>\n<tr><th>param return_surface:</th></tr>\n<tr><td>\u00a0</td><td>bool; if True, return value of method will be tuple like (points, faces)</td>\n</tr>\n<tr><th>return:</th><td>Tuple or None</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"stasma-binary-system-system-binarysystem-plot-orbit-self-kwargs\">\n<h4><tt>stasma.binary_system.system.BinarySystem.plot.orbit(self, **kwargs):</tt></h4>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><strong>start_phase</strong> * \u2013  float;</li>\n<li><strong>stop_phase</strong> * \u2013  float;</li>\n<li><strong>number_of_points</strong> * \u2013  int;</li>\n<li><strong>axis_unit</strong> * \u2013  any astropy.unit lenght unit or <cite>dimensionless</cite>, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc., if empty <cite>dimensionless</cite> is assumed where semi major axis is set to 1;</li>\n<li><strong>frame_of_reference</strong> * \u2013  str; <cite>primary</cite> or <cite>barycenter</cite></li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"stasma-binary-system-system-binarysystem-plot-equipotential-self-kwargs\">\n<h4><tt>stasma.binary_system.system.BinarySystem.plot.equipotential(self, **kwargs):</tt></h4>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><strong>plane</strong> * \u2013  str; <cite>xy</cite>, <cite>yz</cite>, <cite>zy</cite></li>\n<li><strong>phase</strong> * \u2013  float;</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"stasma-binary-system-system-binarysystem-plot-mesh-self-kwargs\">\n<h4><tt>stasma.binary_system.system.BinarySystem.plot.mesh(self, **kwargs):</tt></h4>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><strong>phase</strong> * \u2013  float;</li>\n<li><strong>components_to_plot</strong> * \u2013  str; <cite>primary</cite>, <cite>secondary</cite> or <cite>both</cite></li>\n<li><strong>plot_axis</strong> * \u2013  bool;</li>\n<li><strong>inclination</strong> * \u2013  angle between orbital axis and line of sight;</li>\n<li><strong>azimuth</strong> * \u2013  photometric phase of the system;</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"stasma-binary-system-system-binarysystem-plot-wireframe-self-kwargs\">\n<h4><tt>stasma.binary_system.system.BinarySystem.plot.wireframe(self, **kwargs):</tt></h4>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><strong>phase</strong> * \u2013  float;</li>\n<li><strong>components_to_plot</strong> * \u2013  str; <cite>primary</cite>, <cite>secondary</cite> or <cite>both</cite></li>\n<li><strong>plot_axis</strong> * \u2013  bool;</li>\n<li><strong>inclination</strong> * \u2013  angle between orbital axis and line of sight;</li>\n<li><strong>azimuth</strong> * \u2013  photometric phase of the system;</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"stasma-binary-system-system-binarysystem-plot-surface-self-kwargs\">\n<h4><tt>stasma.binary_system.system.BinarySystem.plot.surface(self, **kwargs):</tt></h4>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><strong>phase</strong> * \u2013  float;</li>\n<li><strong>components_to_plot</strong> * \u2013  str; <cite>primary</cite>, <cite>secondary</cite> or <cite>both</cite></li>\n<li><strong>normals</strong> * \u2013  bool;</li>\n<li><strong>edges</strong> * \u2013  bool;</li>\n<li><strong>plot_axis</strong> * \u2013  bool;</li>\n<li><strong>inclination</strong> * \u2013 float or wtf;</li>\n<li><strong>azimuth</strong> * \u2013 float;</li>\n<li><strong>units</strong> * \u2013 any astropy.unit lenght unit or <cite>dimensionless</cite>, eg. astropy.units.solRad, astropy.units.AU, astropy.units.m, etc., if empty <cite>dimensionless</cite> is assumed where semi major axis is set to 1;</li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><em>important accessible properties computed on fly:</em></p>\n<blockquote>\n<ul>\n<li>semi_major_axis</li>\n<li>morphology</li>\n<li>mass_ratio</li>\n<li>orbit</li>\n</ul>\n</blockquote>\n</div>\n</div>\n<div id=\"stasma-binary-system-orbit-orbit\">\n<h3><tt>stasma.binary_system.orbit.Orbit:</tt></h3>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param suppress_logger:</th></tr>\n<tr><td>\u00a0</td><td><p>bool; enable/disable logger</p>\n</td>\n</tr>\n<tr><th>param kwargs:</th><td><table>\n<col>\n<col>\n<tbody>\n<tr><th><strong>kwargs options</strong>:</th><td><ul>\n<li><strong>period</strong> * \u2013  float or astropy.units.Quantity; period of binary system, default unit is <cite>day</cite></li>\n<li><strong>eccentricity</strong> * \u2013  float; eccentricity of binary system</li>\n<li><strong>inclination</strong> * \u2013  float or astropy.units.Quantity; inclination of binary system; default unit is <cite>degree</cite></li>\n<li><strong>argument_of_periastron</strong> * \u2013  float or astropy.units.Quantity; argument_of_periastron of binary system; default unit is <cite>radian</cite></li>\n</ul>\n</td>\n</tr>\n</tbody>\n</table>\n</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p><em>user face methods:</em></p>\n<div id=\"stasma-binary-system-orbit-orbit-orbital-motion-self-phase-none\">\n<h4><tt>stasma.binary_system.orbit.Orbit.orbital_motion(self, phase=None):</tt></h4>\n<blockquote>\n<p>function takes photometric phase of the binary system as input and calculates positions of the secondary\ncomponent in the frame of reference of primary component</p>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>param phase:</th><td>numpy.array or numpy.float</td>\n</tr>\n<tr><th>return:</th><td>numpy.array: matrix consisting of column stacked vectors distance, azimut angle, true anomaly and phase</td>\n</tr>\n</tbody>\n</table>\n<pre>numpy.array((r1, az1, ni1, phs1),\n            (r2, az2, ni2, phs2),\n            ...\n            (rN, azN, niN, phsN))\n</pre>\n</blockquote>\n<p><em>important accessible properties computed on fly:</em></p>\n<blockquote>\n<ul>\n<li>periastron_distance</li>\n<li>periastron_phase</li>\n</ul>\n</blockquote>\n</div>\n</div>\n</div>\n<div id=\"basic-examples-and-usage\">\n<h2>Basic examples and usage</h2>\n<div id=\"create-binary-sytem\">\n<h3>Create binary sytem</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">astropy</span> <span class=\"kn\">import</span> <span class=\"n\">units</span>\n<span class=\"kn\">from</span> <span class=\"nn\">stasma.base.star</span> <span class=\"kn\">import</span> <span class=\"n\">Star</span>\n<span class=\"kn\">from</span> <span class=\"nn\">stasma.binary_system.system</span> <span class=\"kn\">import</span> <span class=\"n\">BinarySystem</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n\n     <span class=\"n\">primary</span> <span class=\"o\">=</span> <span class=\"n\">Star</span><span class=\"p\">(</span>\n        <span class=\"n\">mass</span><span class=\"o\">=</span><span class=\"mf\">2.0</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">solMass</span><span class=\"p\">,</span>\n        <span class=\"n\">surface_potential</span><span class=\"o\">=</span><span class=\"mf\">2.6</span><span class=\"p\">,</span>\n        <span class=\"n\">synchronicity</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span>\n        <span class=\"n\">discretization_factor</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span>\n        <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"p\">)</span>\n    <span class=\"n\">secondary</span> <span class=\"o\">=</span> <span class=\"n\">Star</span><span class=\"p\">(</span>\n        <span class=\"n\">mass</span><span class=\"o\">=</span><span class=\"mf\">1.0</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">solMass</span><span class=\"p\">,</span>\n        <span class=\"n\">surface_potential</span><span class=\"o\">=</span><span class=\"mf\">2.6</span><span class=\"p\">,</span>\n        <span class=\"n\">synchronicity</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span>\n        <span class=\"n\">discretization_factor</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span>\n        <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"p\">)</span>\n\n    <span class=\"n\">bs</span> <span class=\"o\">=</span> <span class=\"n\">BinarySystem</span><span class=\"p\">(</span>\n        <span class=\"n\">primary</span><span class=\"o\">=</span><span class=\"n\">primary</span><span class=\"p\">,</span>\n        <span class=\"n\">secondary</span><span class=\"o\">=</span><span class=\"n\">secondary</span><span class=\"p\">,</span>\n        <span class=\"n\">argument_of_periastron</span><span class=\"o\">=</span><span class=\"mi\">90</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">deg</span><span class=\"p\">,</span>\n        <span class=\"n\">period</span><span class=\"o\">=</span><span class=\"mi\">1</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">d</span><span class=\"p\">,</span>\n        <span class=\"n\">eccentricity</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">,</span>\n        <span class=\"n\">inclination</span><span class=\"o\">=</span><span class=\"mi\">90</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">deg</span>\n    <span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"create-single-system\">\n<h3>Create single system</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">astropy</span> <span class=\"kn\">import</span> <span class=\"n\">units</span>\n<span class=\"kn\">from</span> <span class=\"nn\">stasma.base.star</span> <span class=\"kn\">import</span> <span class=\"n\">Star</span>\n<span class=\"kn\">from</span> <span class=\"nn\">stasma.single_system.system</span> <span class=\"kn\">import</span> <span class=\"n\">SingleSystem</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n\n    <span class=\"n\">star</span> <span class=\"o\">=</span> <span class=\"n\">Star</span><span class=\"p\">(</span>\n        <span class=\"n\">mass</span><span class=\"o\">=</span><span class=\"mf\">1.0</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">solMass</span><span class=\"p\">,</span>\n        <span class=\"n\">discretization_factor</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span>\n        <span class=\"n\">polar_log_g</span><span class=\"o\">=</span><span class=\"mf\">4.1</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">dex</span><span class=\"p\">(</span><span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">cm</span> <span class=\"o\">/</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">s</span> <span class=\"o\">**</span> <span class=\"mi\">2</span><span class=\"p\">),</span>\n        <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"p\">)</span>\n\n    <span class=\"n\">single</span> <span class=\"o\">=</span> <span class=\"n\">SingleSystem</span><span class=\"p\">(</span>\n        <span class=\"n\">star</span><span class=\"o\">=</span><span class=\"n\">star</span><span class=\"p\">,</span>\n        <span class=\"n\">inclination</span><span class=\"o\">=</span><span class=\"mi\">90</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">deg</span><span class=\"p\">,</span>\n        <span class=\"n\">rotation_period</span><span class=\"o\">=</span><span class=\"mf\">0.5</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">d</span>\n    <span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"create-binary-sytem-with-three-spots-on-primary-and-one-spot-on-secondary-component\">\n<h3>Create binary sytem with three spots on primary and one spot on secondary component</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">astropy</span> <span class=\"kn\">import</span> <span class=\"n\">units</span>\n<span class=\"kn\">from</span> <span class=\"nn\">stasma.base.star</span> <span class=\"kn\">import</span> <span class=\"n\">Star</span>\n<span class=\"kn\">from</span> <span class=\"nn\">stasma.binary_system.system</span> <span class=\"kn\">import</span> <span class=\"n\">BinarySystem</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n\n    <span class=\"n\">spots_metadata</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"primary\"</span><span class=\"p\">:</span>\n        <span class=\"p\">[</span>\n            <span class=\"p\">{</span><span class=\"s2\">\"longitude\"</span><span class=\"p\">:</span> <span class=\"mi\">90</span><span class=\"p\">,</span>\n             <span class=\"s2\">\"latitude\"</span><span class=\"p\">:</span> <span class=\"mi\">58</span><span class=\"p\">,</span>\n             <span class=\"s2\">\"angular_diameter\"</span><span class=\"p\">:</span> <span class=\"mi\">15</span><span class=\"p\">},</span>\n            <span class=\"p\">{</span><span class=\"s2\">\"longitude\"</span><span class=\"p\">:</span> <span class=\"mi\">85</span><span class=\"p\">,</span>\n             <span class=\"s2\">\"latitude\"</span><span class=\"p\">:</span> <span class=\"mi\">80</span><span class=\"p\">,</span>\n             <span class=\"s2\">\"angular_diameter\"</span><span class=\"p\">:</span> <span class=\"mi\">30</span><span class=\"p\">},</span>\n            <span class=\"p\">{</span><span class=\"s2\">\"longitude\"</span><span class=\"p\">:</span> <span class=\"mi\">45</span><span class=\"p\">,</span>\n             <span class=\"s2\">\"latitude\"</span><span class=\"p\">:</span> <span class=\"mi\">90</span><span class=\"p\">,</span>\n             <span class=\"s2\">\"angular_diameter\"</span><span class=\"p\">:</span> <span class=\"mi\">30</span><span class=\"p\">},</span>\n        <span class=\"p\">],</span>\n\n    <span class=\"s2\">\"secondary\"</span><span class=\"p\">:</span>\n        <span class=\"p\">[</span>\n            <span class=\"p\">{</span><span class=\"s2\">\"longitude\"</span><span class=\"p\">:</span> <span class=\"mi\">90</span><span class=\"p\">,</span>\n             <span class=\"s2\">\"latitude\"</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n             <span class=\"s2\">\"angular_diameter\"</span><span class=\"p\">:</span> <span class=\"mi\">40</span><span class=\"p\">},</span>\n        <span class=\"p\">]</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">primary</span> <span class=\"o\">=</span> <span class=\"n\">Star</span><span class=\"p\">(</span>\n        <span class=\"n\">mass</span><span class=\"o\">=</span><span class=\"mf\">2.0</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">solMass</span><span class=\"p\">,</span>\n        <span class=\"n\">surface_potential</span><span class=\"o\">=</span><span class=\"mf\">2.6</span><span class=\"p\">,</span>\n        <span class=\"n\">synchronicity</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span>\n        <span class=\"n\">discretization_factor</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span>\n        <span class=\"n\">spots</span><span class=\"o\">=</span><span class=\"n\">spots_metadata</span><span class=\"p\">[</span><span class=\"s1\">'primary'</span><span class=\"p\">],</span>\n        <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"p\">)</span>\n    <span class=\"n\">secondary</span> <span class=\"o\">=</span> <span class=\"n\">Star</span><span class=\"p\">(</span>\n        <span class=\"n\">mass</span><span class=\"o\">=</span><span class=\"mf\">1.0</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">solMass</span><span class=\"p\">,</span>\n        <span class=\"n\">surface_potential</span><span class=\"o\">=</span><span class=\"mf\">2.6</span><span class=\"p\">,</span>\n        <span class=\"n\">synchronicity</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span>\n        <span class=\"n\">discretization_factor</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span>\n        <span class=\"n\">spots</span><span class=\"o\">=</span><span class=\"n\">spots_metadata</span><span class=\"p\">[</span><span class=\"s1\">'secondary'</span><span class=\"p\">],</span>\n        <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"p\">)</span>\n\n    <span class=\"n\">bs</span> <span class=\"o\">=</span> <span class=\"n\">BinarySystem</span><span class=\"p\">(</span>\n        <span class=\"n\">primary</span><span class=\"o\">=</span><span class=\"n\">primary</span><span class=\"p\">,</span>\n        <span class=\"n\">secondary</span><span class=\"o\">=</span><span class=\"n\">secondary</span><span class=\"p\">,</span>\n        <span class=\"n\">argument_of_periastron</span><span class=\"o\">=</span><span class=\"mi\">90</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">deg</span><span class=\"p\">,</span>\n        <span class=\"n\">period</span><span class=\"o\">=</span><span class=\"mi\">1</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">d</span><span class=\"p\">,</span>\n        <span class=\"n\">eccentricity</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">,</span>\n        <span class=\"n\">inclination</span><span class=\"o\">=</span><span class=\"mi\">90</span> <span class=\"o\">*</span> <span class=\"n\">units</span><span class=\"o\">.</span><span class=\"n\">deg</span><span class=\"p\">,</span>\n    <span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"build-mesh-and-surface-of-objects-in-binary-system\">\n<h3>Build mesh and surface of objects in binary system</h3>\n<table>\n<col>\n<col>\n<tbody>\n<tr><th>note:</th><td>parameter <cite>componetn_distance</cite> is driven parameter to involve capability to compute and create system in different part of eccentric orbit</td>\n</tr>\n</tbody>\n</table>\n<p><strong>After computation, properties like ``points`` or ``faces`` are available from Star class instaces.</strong></p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"o\">...</span>\n    <span class=\"c1\"># definitions</span>\n\n    <span class=\"n\">bs</span><span class=\"o\">.</span><span class=\"n\">build_mesh</span><span class=\"p\">(</span><span class=\"n\">components_distance</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n    <span class=\"n\">bs</span><span class=\"o\">.</span><span class=\"n\">build_surface</span><span class=\"p\">(</span><span class=\"n\">components_distance</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">primary</span><span class=\"o\">.</span><span class=\"n\">points</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">primary</span><span class=\"o\">.</span><span class=\"n\">faces</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">primary</span><span class=\"o\">.</span><span class=\"n\">spots</span><span class=\"p\">)</span>\n\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">primary</span><span class=\"o\">.</span><span class=\"n\">spots</span><span class=\"p\">[</span><span class=\"c1\">#index].points)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">primary</span><span class=\"o\">.</span><span class=\"n\">spots</span><span class=\"p\">[</span><span class=\"c1\">#index].faces)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"build-mesh-and-surface-of-objects-in-single-system\">\n<h3>Build mesh and surface of objects in single system</h3>\n<p><strong>After computation, properties like ``points`` or ``faces`` are available from Star class instace.</strong></p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"o\">...</span>\n    <span class=\"c1\"># definitions</span>\n\n    <span class=\"n\">single</span><span class=\"o\">.</span><span class=\"n\">build_mesh</span><span class=\"p\">()</span>\n    <span class=\"n\">single</span><span class=\"o\">.</span><span class=\"n\">build_surface</span><span class=\"p\">()</span>\n\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">star</span><span class=\"o\">.</span><span class=\"n\">points</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">star</span><span class=\"o\">.</span><span class=\"n\">faces</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">star</span><span class=\"o\">.</span><span class=\"n\">spots</span><span class=\"p\">)</span>\n\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">star</span><span class=\"o\">.</span><span class=\"n\">spots</span><span class=\"p\">[</span><span class=\"c1\">#index].points)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">star</span><span class=\"o\">.</span><span class=\"n\">spots</span><span class=\"p\">[</span><span class=\"c1\">#index].faces)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"plot-binary-star-system-wireframe\">\n<h3>Plot binary star system wireframe</h3>\n<pre><span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"o\">...</span>\n    <span class=\"c1\"># definitions</span>\n\n    <span class=\"n\">bs</span><span class=\"o\">.</span><span class=\"n\">build_mesh</span><span class=\"p\">(</span><span class=\"n\">components_distance</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n    <span class=\"n\">bs</span><span class=\"o\">.</span><span class=\"n\">build_surface</span><span class=\"p\">(</span><span class=\"n\">components_distance</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n\n    <span class=\"n\">bs</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"o\">.</span><span class=\"n\">wireframe</span><span class=\"p\">()</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 5512599, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "2b6e690b7cf457b95ef525522def046c", "sha256": "96f24b38ab6b058904485cb71489735881bd981dd1f955a592306239a67aaae3"}, "downloads": -1, "filename": "stasma-0.1.0-py36-none-any.whl", "has_sig": false, "md5_digest": "2b6e690b7cf457b95ef525522def046c", "packagetype": "bdist_wheel", "python_version": "py36", "requires_python": null, "size": 56954, "upload_time": "2019-02-06T23:33:32", "upload_time_iso_8601": "2019-02-06T23:33:32.129257Z", "url": "https://files.pythonhosted.org/packages/97/1d/3546922833984cf370bbcd4c3641511a515c97340de0c63f517db5f1d326/stasma-0.1.0-py36-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b0c65e8cda0891ab37aab8b43207804d", "sha256": "78528b437a38111005876eed90b649c07bf05a82a83c7951244a63cd4f8b19ca"}, "downloads": -1, "filename": "stasma-0.1.0.tar.gz", "has_sig": false, "md5_digest": "b0c65e8cda0891ab37aab8b43207804d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 57098, "upload_time": "2019-02-06T23:33:34", "upload_time_iso_8601": "2019-02-06T23:33:34.399713Z", "url": "https://files.pythonhosted.org/packages/69/0a/4cdd9ae17cabbc2cf2523fc99b478bdeed279b3950803fefab89715a2ebf/stasma-0.1.0.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "98f1e675f83cab2ef5343cafe09f985b", "sha256": "0341fa8129c4b14a56d8bd7a50929c414b8f361b31bff6b930528d3fc56653b2"}, "downloads": -1, "filename": "stasma-0.1.2-py36-none-any.whl", "has_sig": false, "md5_digest": "98f1e675f83cab2ef5343cafe09f985b", "packagetype": "bdist_wheel", "python_version": "py36", "requires_python": null, "size": 57769, "upload_time": "2019-07-10T15:11:38", "upload_time_iso_8601": "2019-07-10T15:11:38.121365Z", "url": "https://files.pythonhosted.org/packages/57/99/105d79edf529a9e5eddae4643f86049e7fe31925d36cb6b812c92434c062/stasma-0.1.2-py36-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "daebe6a0a547fc042a8a0631012494fb", "sha256": "6fa982cc0dfea62987bccc785731d606e70f6cac714dfe13d4e1f63280767acd"}, "downloads": -1, "filename": "stasma-0.1.2.tar.gz", "has_sig": false, "md5_digest": "daebe6a0a547fc042a8a0631012494fb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 56656, "upload_time": "2019-07-10T15:11:40", "upload_time_iso_8601": "2019-07-10T15:11:40.408588Z", "url": "https://files.pythonhosted.org/packages/47/70/324d8c62bd6c33f1d7ae4159cca07bdc3757f155272d7e2c1a891e5bbdd7/stasma-0.1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "98f1e675f83cab2ef5343cafe09f985b", "sha256": "0341fa8129c4b14a56d8bd7a50929c414b8f361b31bff6b930528d3fc56653b2"}, "downloads": -1, "filename": "stasma-0.1.2-py36-none-any.whl", "has_sig": false, "md5_digest": "98f1e675f83cab2ef5343cafe09f985b", "packagetype": "bdist_wheel", "python_version": "py36", "requires_python": null, "size": 57769, "upload_time": "2019-07-10T15:11:38", "upload_time_iso_8601": "2019-07-10T15:11:38.121365Z", "url": "https://files.pythonhosted.org/packages/57/99/105d79edf529a9e5eddae4643f86049e7fe31925d36cb6b812c92434c062/stasma-0.1.2-py36-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "daebe6a0a547fc042a8a0631012494fb", "sha256": "6fa982cc0dfea62987bccc785731d606e70f6cac714dfe13d4e1f63280767acd"}, "downloads": -1, "filename": "stasma-0.1.2.tar.gz", "has_sig": false, "md5_digest": "daebe6a0a547fc042a8a0631012494fb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 56656, "upload_time": "2019-07-10T15:11:40", "upload_time_iso_8601": "2019-07-10T15:11:40.408588Z", "url": "https://files.pythonhosted.org/packages/47/70/324d8c62bd6c33f1d7ae4159cca07bdc3757f155272d7e2c1a891e5bbdd7/stasma-0.1.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:31 2020"}