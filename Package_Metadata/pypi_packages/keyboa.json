{"info": {"author": "torrua", "author_email": "torrua@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Software Development :: Build Tools"], "description": "# Keyboa\n[![Download Keyboa](https://img.shields.io/pypi/v/keyboa.svg)](https://pypi.python.org/pypi/keyboa) [![Build Status](https://travis-ci.com/torrua/keyboa.svg?branch=master)](https://travis-ci.com/torrua/keyboa)\n\nThis is a simple but flexible inline keyboard generator that works as an add-on to PyTelegramBotAPI package. With **keyboa** you can:\n- quickly create buttons with complex callback, \n- create keyboards directly from lists,\n- easily combine multiple keyboards into one,\n- many other cool things...\n\n# How it works\n## Installation\nKeyboa is compatible with Python 3.5 and higher. You can install this package with pip as usual:\n```sh\n$ pip install keyboa\n```\nAfter that, just import the necessary functions:\n```python\nfrom keyboa.keyboards import button_maker, keyboa_maker, keyboa_combiner\n```\n\n## Usage\nThere are **three main functions** which return ```InlineKeyboardButton``` or ```InlineKeyboardMarkup``` objects as a result:\n- ```button_maker()``` returns ```InlineKeyboardButton```\n- ```keyboa_maker()``` returns ```InlineKeyboardMarkup```\n- ```keyboa_combiner()``` returns ```InlineKeyboardMarkup```\n\nLet's take it in detail.\n### How to create Button\nThe ```button_maker()``` function creates an ```InlineKeyboardButton``` object from various data types, such as ```str```, ```int```, ```tuple```, ```dict```. You can also pass the ```InlineKeyboardButton``` object itself, which will return unchanged.\n\nAll acceptable types combined into ```InlineButtonData``` type:\n```python\nInlineButtonData = Union[str, int, tuple, dict, InlineKeyboardButton]\n```\nAlso there is a ```CallbackDataMarker``` type for callback data:\n```python\nCallbackDataMarker = Optional[Union[str, int]]\n```\nThe function has following input parameters:\n\nParameter | Type | Description\n--------- | ---- | -----------\n```button_data``` | InlineButtonData | An object from which the button will be created.<br>_See detailed explanation below._\n```front_marker``` | CallbackDataMarker | _Optional_. An object to be added to the **left** side of callback.\n```back_marker``` | CallbackDataMarker | _Optional_. An object to be added to the **right** side of callback.\n```copy_text_to_callback``` | Boolean | If ```True```, and ```button_data``` is a ```str``` or an ```int```, function will copy button text to callback data (and add other markers if they exist).<br>The default value is ```False```.\n\nFor ```button_data``` object --\n* If it is a ```str``` or an ```int```, it will be used for text (and callback, if ```copy_text_to_callback``` enabled).\n* If it is a ```tuple```, the zero element [0] will be the text, and the first [1] will be the callback. \n* If it is a ```dict```, there are two options:\n   * if there is **no \"text\" key** in dictionary and only one key exists, the key will be the text, and the value will be the callback.<br>In this case no verification of the dictionary's contents is performed!\n  * if the **\"text\" key exists**, function passes the whole dictionary to ```InlineKeyboardButton```, where dictionary's keys represent object's parameters and dictionary's values represent parameters' values accordingly.\nIn all other cases the ```ValueError``` will be raised.\n\nLet's look at a few examples:\n\n#### button from ```str``` or ```int```\n```python\nspam = button_maker(button_data=\"spam\", copy_text_to_callback=True)\n```\n```python\nspam = button_maker(button_data=\"spam\", front_marker=\"spam\")\n```\n```python\nspam = button_maker(button_data=\"spam\", front_marker=\"sp\", back_marker=\"am\")\n```\nIn all examples above the```spam``` variable will contain an ```InlineKeyboardButton``` object with the following data:\n```sh\n{'text': 'spam', 'callback_data': 'spam'}\n```\n\u2757 You cannot use this method with ```copy_text_to_callback``` disabled and unfilled both ```front_marker``` and```back_marker```, because callback_data cannot be empty:\n\n```python\nspam = button_maker(button_data=\"spam\")\n```\n```sh\nValueError: The callback data cannot be empty.\n```\n\n#### button from ```tuple```\n```python\nspam = button_maker(button_data=(\"spam\", \"eggs\"), front_marker=\"ham_\", back_marker=\"_spam\")\n```\n```sh\n{'text': 'spam', 'callback_data': 'ham_eggs_spam'}\n```\n\ud83d\udca1 Notice that in this example we also used ```front_marker``` and ```back_marker``` to add some data to button's callback_data.\n\n#### button from ```dict``` without \"text\" key\n```python\nspam = button_maker(button_data={\"spam\": \"ham_eggs_spam\"})\n```\n```sh\n{'text': 'spam', 'callback_data': 'ham_eggs_spam'}\n```\n\n#### button from ```dict``` with \"text\" key\n```python\nspam = button_maker(button_data={\"text\": \"spam\", \"url\": \"https://ya.ru/\", \"callback_data\": \"eggs\"})\n```\n```sh\n{\"text\": \"spam\", \"url\": \"https://ya.ru/\", \"callback_data\": \"eggs\"}\n```\n\n### How to create Keyboard\nThe ```keyboa_maker()``` function creates an ```InlineKeyboardMarkup``` object from a list of ```BlockItems``` elements. A shot explanation of this type is given below:\n```python\n# structureless sequence of InlineButtonData objects\nFlatSequence = List[InlineButtonData]\n\n# structured sequence of InlineButtonData objects\nStructuredSequence = List[Union[FlatSequence, InlineButtonData]]\n\n# unified type that allows you to use any available data types for the keyboard\nBlockItems = Union[StructuredSequence, InlineButtonData]\n```\nThe function has following input parameters:\n\nParameter | Type | Description\n--------- | ---- | -----------\n```items``` | BlockItems | _Optional_.\n```front_marker``` | CallbackDataMarker | _Optional_. Front part of callback data, which is common for all buttons.\n```back_marker``` | CallbackDataMarker | _Optional_. Back part of callback data, which is common for all buttons.\n```items_in_row``` | Integer | _Optional_. The number of buttons in one keyboard row. Must be **from one to eight** due to the Telegram Bot API limitation.<br>The default value is ```None```, which means that by default the keyboard structure depends on the grouping of  ```items``` elements.\n```auto_alignment``` | Boolean or Iterable | If ```True```, will try to split all items into **equal rows in a range of 3 to 5**.<br>If ```Iterable``` (with any ```int``` in the range from 1 to 8), will try to use it.<br>This enabled option replaces the action of ```items_in_row``` variable, but if a suitable divisor cannot be found, function will use the ```items_in_row``` value.<br>The default value is ```False```.\n```reverse_alignment_range``` | Boolean | If ```True```, will try to find the divisor starting from the end of the ```auto_alignment``` variable (if defined) or from the default range.<br>This enabled option works only if ```auto_alignment``` is enabled.<br>The default value is ```False```.\n```slice_start``` | Integer | _Optional_. Refers to the index of the element which is used as a start of the slice.\n```slice_stop``` | Integer | _Optional_. Refers to the index of the element we should stop just before to finish slice.\n```slice_step``` | Integer | _Optional_. It allows you to take each nth-element within a ```[start:stop]``` range.\n```copy_text_to_callback``` | Boolean | If ```True```, and ```button_data``` is a ```str``` or an ```int```, function will copy button text to callback data (and add other markers if they exist).<br>The default value is ```False```.\n```add_to_keyboard``` | InlineKeyboardMarkup | _Optional_. You may pass the keyboard to which the specified items will be added.\n\nLet's start with a simple example!\n#### keyboard from ```list``` of ```str```\nThe easiest way to create a keyboard is to pass a list of items to a function.\n```python\nmenu = [\"spam\", \"eggs\", \"ham\"]\nkeyboard = keyboa_maker(items=menu, copy_text_to_callback=True)\nbot.send_message(chat_id=chat_id, text=text, reply_markup=keyboard)\n```\n![keyboard from list of str](https://telegra.ph/file/d9280b11ed11ec13e6f56.png)\n\nBy default, each item in the list becomes a separate row, but it's easy to change by combining the items into groups.\n```python\nmenu = [[\"spam\", \"eggs\"], [\"ham\", \"bread\"], \"spam\"]\nkeyboard = keyboa_maker(items=menu, copy_text_to_callback=True)\nbot.send_message(chat_id=chat_id, text=text, reply_markup=keyboard)\n```\n![keyboard from list of str](https://telegra.ph/file/2eb6752324fa196cae4ac.png)\n\nNow you see that the keyboard buttons are arranged according to how we grouped them in the list. \nAnd of course you can create more complex structures, for example:\n```python\nmenu = [[\"spam\", \"eggs\", \"ham\"], [\"ham\", \"eggs\"], \"spam\", [\"sausages\", \"spam\"], [\"eggs\", \"spam\", \"spam\"]]\nkeyboard = keyboa_maker(items=menu, copy_text_to_callback=True)\nbot.send_message(chat_id=chat_id, text=text, reply_markup=keyboard)\n```\n![keyboard from list of str](https://telegra.ph/file/faff37512c626845c5524.png)\n\n>Due to Telegram API limitation you can add **up to 8 buttons per row** and **up to 100 for the entire keyboard**.\n\nLet's go deeper. Suppose you have a list of 24 items, and you would like to divide it into rows of 6 buttons each. Here is what you need to do:\n```python\nnumbers = list(range(1, 25))\nkeyboard = keyboa_maker(items=numbers, items_in_row=6, copy_text_to_callback=True)\nbot.send_message(chat_id=chat_id, text=text, reply_markup=keyboard)\n```\n![keyboard with 6 items_in_row](https://telegra.ph/file/2122cb9f50938b39b4439.png)\n\n\ud83d\udca1 You can easily make 3, 4 or even 8 buttons in a row, changing the ```items_in_row``` parameter only.\n\nNow we will try to use more parameters to see how they will affect the result:\n```python\nkeyboard = keyboa_maker(\n    items=list(range(0, 48)),\n    auto_alignment=True,\n    slice_start=5,\n    slice_stop=37,\n    copy_text_to_callback=True\n)\nbot.send_message(chat_id=chat_id, text=text, reply_markup=keyboard)\n```\n![keyboard slice with auto_alignment](https://telegra.ph/file/cc41513058a2b3d9f83ba.png)\n\nAs you can see, this keyboard consists of a ```[5:37]``` slice. In addition, although we did not specify the ```items_in_row``` parameter, the function divided list into equal rows, because of enabled ```auto_alignment``` parameter.\n\n### Combine Keyboards\nSometimes it is necessary to combine several separate keyboard blocks  into the big one. The ```keyboa_combiner()``` function does just that!\n\nThe function has only one input parameter - ```keyboards```. It should be a sequence of ```InlineKeyboardMarkup``` objects. Also could be presented as a standalone ```InlineKeyboardMarkup```.\n\nHere is how it works:\n```python\ncontrols = [[\"\u23f9\ufe0f\", \"\u23ea\ufe0f\", \"\u23cf\ufe0f\", \"\u23e9\ufe0f\", \"\u25b6\ufe0f\"], ]\ntracks = list(range(1, 13))\n\nkeyboard_controls = keyboa_maker(items=controls, copy_text_to_callback=True)\nkeyboard_tracks = keyboa_maker(items=tracks, items_in_row=4, copy_text_to_callback=True)\n\nkeyboard = keyboa_combiner(keyboards=(keyboard_tracks, keyboard_controls))\nbot.send_message(chat_id=user_id, text=text_tracks, reply_markup=keyboard)\n```\n![keyboard combo](https://telegra.ph/file/342c06d783faeb786f242.png)\n\nAs you see, we merged two keyboards into one.\n\n### Complex callbacks\nA few words about how to create complex callbacks for buttons. \n\nOften it is necessary to read and pass through the callback options that the user has sequentially selected. For example, determining the address: city, street, house, apartment number.\n\nSuppose we offer the user several cities to choose from. Create a simple keyboard:\n```python\nkb_cities = keyboa_maker(\n    items=[\"Moscow\", \"London\", \"Tokyo\", ],\n    copy_text_to_callback=True,\n    front_marker=\"&city=\",\n    back_marker=\"$\"\n)\nbot.send_message(chat_id=user_id, text=\"Select your city:\", reply_markup=kb_cities)\n```\n![keyboard cities](https://telegra.ph/file/dcd011c72e43aefd8d00d.png)\n\nBy doing so, we get the following inside the keyboard:\n```sh\n{'inline_keyboard': [\n    [{'text': 'Moscow', 'callback_data': '&city=Moscow$'}],\n    [{'text': 'London', 'callback_data': '&city=London$'}],\n    [{'text': 'Tokyo', 'callback_data': '&city=Tokyo$'}]\n]}\n```\nSuppose a user selects ```London```. We would like to remember this, and let him choose from several streets:\n```python\nreceived_callback = call.data  # \"&city=London$\"\nstreets = [\"Baker Street\", \"Oxford Street\", \"Abbey Road\", ]\nkb_streets = keyboa_maker(\n    items=streets, \n    copy_text_to_callback=True, \n    front_marker=\"&street=\", \n    back_marker=received_callback)  # we added existing data to the end\nbot.send_message(chat_id=user_id, text=\"Select your street:\", reply_markup=kb_streets)\n```\n![keyboard streets](https://telegra.ph/file/cf06e3bc0adece894535d.png)\n\n```sh\n{'inline_keyboard': [\n    [{\n        'text': 'Baker Street',\n        'callback_data': '&street=Baker Street&city=London$'}],\n    [{\n        'text': 'Oxford Street',\n        'callback_data': '&street=Oxford Street&city=London$'}],\n    [{\n        'text': 'Abbey Road',\n        'callback_data': '&street=Abbey Road&city=London$'}]\n]}\n```\n\ud83d\udca1 Notice that we used a ```front_marker``` to specify the type of current items, and a ```back_marker``` to attach existing information.\n\nAs you can see, the variant selected by the user in the previous step was also saved.\nIf the user selects a street, for example, ```Baker Street```, we will receive the ```call.data``` as ```'&street=Oxford Street&city=London$'```. Of course we are able to parse it easily.\n\nFinally, let him to choose an apartment:\n```python\nreceived_callback = call.data  # '&street=Oxford Street&city=London$'\napartments = [\"221a\", \"221b\", \"221c\", ]\nkb_apartments = keyboa_maker(\n    items=apartments, \n    copy_text_to_callback=True, \n    front_marker=\"&apartments=\", \n    back_marker=received_callback)  # we added existing data to the end\nbot.send_message(chat_id=user_id, text=\"Select your apartments:\", reply_markup=kb_apartments)\n```\n![keyboard streets](https://telegra.ph/file/0eec50498f2a68955c81c.png)\n\n```sh\n{'inline_keyboard': [[\n        {'text': '221a',\n        'callback_data': '&apartments=221a&street=Oxford Street&city=London$'}, \n        {'text': '221b', \n        'callback_data': '&apartments=221b&street=Oxford Street&city=London$'},\n        {'text': '221c', \n        'callback_data': '&apartments=221c&street=Oxford Street&city=London$'}\n    ]]\n}\n```\nAnd if the user selects button ```221b```, we will assume that \ud83d\udd75\ud83c\udffb\u200d\u2642\ufe0f Mr. Sherlock Holmes uses our bot too!", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/torrua/keyboa/archive/v2.2.3.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/torrua/keyboa", "keywords": "Generate,Inline,Keyboard,Telegram", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "keyboa", "package_url": "https://pypi.org/project/keyboa/", "platform": "", "project_url": "https://pypi.org/project/keyboa/", "project_urls": {"Download": "https://github.com/torrua/keyboa/archive/v2.2.3.tar.gz", "Homepage": "https://github.com/torrua/keyboa"}, "release_url": "https://pypi.org/project/keyboa/2.2.3/", "requires_dist": null, "requires_python": "", "summary": "Telegram Inline Keyboards Generator", "version": "2.2.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Keyboa</h1>\n<p><a href=\"https://pypi.python.org/pypi/keyboa\" rel=\"nofollow\"><img alt=\"Download Keyboa\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/47e13deb98287ca5b4295d8383959eee3617f774/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6b6579626f612e737667\"></a> <a href=\"https://travis-ci.com/torrua/keyboa\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/75ae2f46ff690ee188bd9d6b3a517f0afe7ae8ba/68747470733a2f2f7472617669732d63692e636f6d2f746f727275612f6b6579626f612e7376673f6272616e63683d6d6173746572\"></a></p>\n<p>This is a simple but flexible inline keyboard generator that works as an add-on to PyTelegramBotAPI package. With <strong>keyboa</strong> you can:</p>\n<ul>\n<li>quickly create buttons with complex callback,</li>\n<li>create keyboards directly from lists,</li>\n<li>easily combine multiple keyboards into one,</li>\n<li>many other cool things...</li>\n</ul>\n<h1>How it works</h1>\n<h2>Installation</h2>\n<p>Keyboa is compatible with Python 3.5 and higher. You can install this package with pip as usual:</p>\n<pre>$ pip install keyboa\n</pre>\n<p>After that, just import the necessary functions:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">keyboa.keyboards</span> <span class=\"kn\">import</span> <span class=\"n\">button_maker</span><span class=\"p\">,</span> <span class=\"n\">keyboa_maker</span><span class=\"p\">,</span> <span class=\"n\">keyboa_combiner</span>\n</pre>\n<h2>Usage</h2>\n<p>There are <strong>three main functions</strong> which return <code>InlineKeyboardButton</code> or <code>InlineKeyboardMarkup</code> objects as a result:</p>\n<ul>\n<li><code>button_maker()</code> returns <code>InlineKeyboardButton</code></li>\n<li><code>keyboa_maker()</code> returns <code>InlineKeyboardMarkup</code></li>\n<li><code>keyboa_combiner()</code> returns <code>InlineKeyboardMarkup</code></li>\n</ul>\n<p>Let's take it in detail.</p>\n<h3>How to create Button</h3>\n<p>The <code>button_maker()</code> function creates an <code>InlineKeyboardButton</code> object from various data types, such as <code>str</code>, <code>int</code>, <code>tuple</code>, <code>dict</code>. You can also pass the <code>InlineKeyboardButton</code> object itself, which will return unchanged.</p>\n<p>All acceptable types combined into <code>InlineButtonData</code> type:</p>\n<pre><span class=\"n\">InlineButtonData</span> <span class=\"o\">=</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">tuple</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">,</span> <span class=\"n\">InlineKeyboardButton</span><span class=\"p\">]</span>\n</pre>\n<p>Also there is a <code>CallbackDataMarker</code> type for callback data:</p>\n<pre><span class=\"n\">CallbackDataMarker</span> <span class=\"o\">=</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>\n</pre>\n<p>The function has following input parameters:</p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>button_data</code></td>\n<td>InlineButtonData</td>\n<td>An object from which the button will be created.<br><em>See detailed explanation below.</em></td>\n</tr>\n<tr>\n<td><code>front_marker</code></td>\n<td>CallbackDataMarker</td>\n<td><em>Optional</em>. An object to be added to the <strong>left</strong> side of callback.</td>\n</tr>\n<tr>\n<td><code>back_marker</code></td>\n<td>CallbackDataMarker</td>\n<td><em>Optional</em>. An object to be added to the <strong>right</strong> side of callback.</td>\n</tr>\n<tr>\n<td><code>copy_text_to_callback</code></td>\n<td>Boolean</td>\n<td>If <code>True</code>, and <code>button_data</code> is a <code>str</code> or an <code>int</code>, function will copy button text to callback data (and add other markers if they exist).<br>The default value is <code>False</code>.</td>\n</tr></tbody></table>\n<p>For <code>button_data</code> object --</p>\n<ul>\n<li>If it is a <code>str</code> or an <code>int</code>, it will be used for text (and callback, if <code>copy_text_to_callback</code> enabled).</li>\n<li>If it is a <code>tuple</code>, the zero element [0] will be the text, and the first [1] will be the callback.</li>\n<li>If it is a <code>dict</code>, there are two options:\n<ul>\n<li>if there is <strong>no \"text\" key</strong> in dictionary and only one key exists, the key will be the text, and the value will be the callback.<br>In this case no verification of the dictionary's contents is performed!</li>\n<li>if the <strong>\"text\" key exists</strong>, function passes the whole dictionary to <code>InlineKeyboardButton</code>, where dictionary's keys represent object's parameters and dictionary's values represent parameters' values accordingly.\nIn all other cases the <code>ValueError</code> will be raised.</li>\n</ul>\n</li>\n</ul>\n<p>Let's look at a few examples:</p>\n<h4>button from <code>str</code> or <code>int</code></h4>\n<pre><span class=\"n\">spam</span> <span class=\"o\">=</span> <span class=\"n\">button_maker</span><span class=\"p\">(</span><span class=\"n\">button_data</span><span class=\"o\">=</span><span class=\"s2\">\"spam\"</span><span class=\"p\">,</span> <span class=\"n\">copy_text_to_callback</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"n\">spam</span> <span class=\"o\">=</span> <span class=\"n\">button_maker</span><span class=\"p\">(</span><span class=\"n\">button_data</span><span class=\"o\">=</span><span class=\"s2\">\"spam\"</span><span class=\"p\">,</span> <span class=\"n\">front_marker</span><span class=\"o\">=</span><span class=\"s2\">\"spam\"</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"n\">spam</span> <span class=\"o\">=</span> <span class=\"n\">button_maker</span><span class=\"p\">(</span><span class=\"n\">button_data</span><span class=\"o\">=</span><span class=\"s2\">\"spam\"</span><span class=\"p\">,</span> <span class=\"n\">front_marker</span><span class=\"o\">=</span><span class=\"s2\">\"sp\"</span><span class=\"p\">,</span> <span class=\"n\">back_marker</span><span class=\"o\">=</span><span class=\"s2\">\"am\"</span><span class=\"p\">)</span>\n</pre>\n<p>In all examples above the<code>spam</code> variable will contain an <code>InlineKeyboardButton</code> object with the following data:</p>\n<pre><span class=\"o\">{</span><span class=\"s1\">'text'</span>: <span class=\"s1\">'spam'</span>, <span class=\"s1\">'callback_data'</span>: <span class=\"s1\">'spam'</span><span class=\"o\">}</span>\n</pre>\n<p>\u2757 You cannot use this method with <code>copy_text_to_callback</code> disabled and unfilled both <code>front_marker</code> and<code>back_marker</code>, because callback_data cannot be empty:</p>\n<pre><span class=\"n\">spam</span> <span class=\"o\">=</span> <span class=\"n\">button_maker</span><span class=\"p\">(</span><span class=\"n\">button_data</span><span class=\"o\">=</span><span class=\"s2\">\"spam\"</span><span class=\"p\">)</span>\n</pre>\n<pre>ValueError: The callback data cannot be empty.\n</pre>\n<h4>button from <code>tuple</code></h4>\n<pre><span class=\"n\">spam</span> <span class=\"o\">=</span> <span class=\"n\">button_maker</span><span class=\"p\">(</span><span class=\"n\">button_data</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s2\">\"spam\"</span><span class=\"p\">,</span> <span class=\"s2\">\"eggs\"</span><span class=\"p\">),</span> <span class=\"n\">front_marker</span><span class=\"o\">=</span><span class=\"s2\">\"ham_\"</span><span class=\"p\">,</span> <span class=\"n\">back_marker</span><span class=\"o\">=</span><span class=\"s2\">\"_spam\"</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"o\">{</span><span class=\"s1\">'text'</span>: <span class=\"s1\">'spam'</span>, <span class=\"s1\">'callback_data'</span>: <span class=\"s1\">'ham_eggs_spam'</span><span class=\"o\">}</span>\n</pre>\n<p>\ud83d\udca1 Notice that in this example we also used <code>front_marker</code> and <code>back_marker</code> to add some data to button's callback_data.</p>\n<h4>button from <code>dict</code> without \"text\" key</h4>\n<pre><span class=\"n\">spam</span> <span class=\"o\">=</span> <span class=\"n\">button_maker</span><span class=\"p\">(</span><span class=\"n\">button_data</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s2\">\"spam\"</span><span class=\"p\">:</span> <span class=\"s2\">\"ham_eggs_spam\"</span><span class=\"p\">})</span>\n</pre>\n<pre><span class=\"o\">{</span><span class=\"s1\">'text'</span>: <span class=\"s1\">'spam'</span>, <span class=\"s1\">'callback_data'</span>: <span class=\"s1\">'ham_eggs_spam'</span><span class=\"o\">}</span>\n</pre>\n<h4>button from <code>dict</code> with \"text\" key</h4>\n<pre><span class=\"n\">spam</span> <span class=\"o\">=</span> <span class=\"n\">button_maker</span><span class=\"p\">(</span><span class=\"n\">button_data</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s2\">\"text\"</span><span class=\"p\">:</span> <span class=\"s2\">\"spam\"</span><span class=\"p\">,</span> <span class=\"s2\">\"url\"</span><span class=\"p\">:</span> <span class=\"s2\">\"https://ya.ru/\"</span><span class=\"p\">,</span> <span class=\"s2\">\"callback_data\"</span><span class=\"p\">:</span> <span class=\"s2\">\"eggs\"</span><span class=\"p\">})</span>\n</pre>\n<pre><span class=\"o\">{</span><span class=\"s2\">\"text\"</span>: <span class=\"s2\">\"spam\"</span>, <span class=\"s2\">\"url\"</span>: <span class=\"s2\">\"https://ya.ru/\"</span>, <span class=\"s2\">\"callback_data\"</span>: <span class=\"s2\">\"eggs\"</span><span class=\"o\">}</span>\n</pre>\n<h3>How to create Keyboard</h3>\n<p>The <code>keyboa_maker()</code> function creates an <code>InlineKeyboardMarkup</code> object from a list of <code>BlockItems</code> elements. A shot explanation of this type is given below:</p>\n<pre><span class=\"c1\"># structureless sequence of InlineButtonData objects</span>\n<span class=\"n\">FlatSequence</span> <span class=\"o\">=</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">InlineButtonData</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># structured sequence of InlineButtonData objects</span>\n<span class=\"n\">StructuredSequence</span> <span class=\"o\">=</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">FlatSequence</span><span class=\"p\">,</span> <span class=\"n\">InlineButtonData</span><span class=\"p\">]]</span>\n\n<span class=\"c1\"># unified type that allows you to use any available data types for the keyboard</span>\n<span class=\"n\">BlockItems</span> <span class=\"o\">=</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">StructuredSequence</span><span class=\"p\">,</span> <span class=\"n\">InlineButtonData</span><span class=\"p\">]</span>\n</pre>\n<p>The function has following input parameters:</p>\n<table>\n<thead>\n<tr>\n<th>Parameter</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>items</code></td>\n<td>BlockItems</td>\n<td><em>Optional</em>.</td>\n</tr>\n<tr>\n<td><code>front_marker</code></td>\n<td>CallbackDataMarker</td>\n<td><em>Optional</em>. Front part of callback data, which is common for all buttons.</td>\n</tr>\n<tr>\n<td><code>back_marker</code></td>\n<td>CallbackDataMarker</td>\n<td><em>Optional</em>. Back part of callback data, which is common for all buttons.</td>\n</tr>\n<tr>\n<td><code>items_in_row</code></td>\n<td>Integer</td>\n<td><em>Optional</em>. The number of buttons in one keyboard row. Must be <strong>from one to eight</strong> due to the Telegram Bot API limitation.<br>The default value is <code>None</code>, which means that by default the keyboard structure depends on the grouping of  <code>items</code> elements.</td>\n</tr>\n<tr>\n<td><code>auto_alignment</code></td>\n<td>Boolean or Iterable</td>\n<td>If <code>True</code>, will try to split all items into <strong>equal rows in a range of 3 to 5</strong>.<br>If <code>Iterable</code> (with any <code>int</code> in the range from 1 to 8), will try to use it.<br>This enabled option replaces the action of <code>items_in_row</code> variable, but if a suitable divisor cannot be found, function will use the <code>items_in_row</code> value.<br>The default value is <code>False</code>.</td>\n</tr>\n<tr>\n<td><code>reverse_alignment_range</code></td>\n<td>Boolean</td>\n<td>If <code>True</code>, will try to find the divisor starting from the end of the <code>auto_alignment</code> variable (if defined) or from the default range.<br>This enabled option works only if <code>auto_alignment</code> is enabled.<br>The default value is <code>False</code>.</td>\n</tr>\n<tr>\n<td><code>slice_start</code></td>\n<td>Integer</td>\n<td><em>Optional</em>. Refers to the index of the element which is used as a start of the slice.</td>\n</tr>\n<tr>\n<td><code>slice_stop</code></td>\n<td>Integer</td>\n<td><em>Optional</em>. Refers to the index of the element we should stop just before to finish slice.</td>\n</tr>\n<tr>\n<td><code>slice_step</code></td>\n<td>Integer</td>\n<td><em>Optional</em>. It allows you to take each nth-element within a <code>[start:stop]</code> range.</td>\n</tr>\n<tr>\n<td><code>copy_text_to_callback</code></td>\n<td>Boolean</td>\n<td>If <code>True</code>, and <code>button_data</code> is a <code>str</code> or an <code>int</code>, function will copy button text to callback data (and add other markers if they exist).<br>The default value is <code>False</code>.</td>\n</tr>\n<tr>\n<td><code>add_to_keyboard</code></td>\n<td>InlineKeyboardMarkup</td>\n<td><em>Optional</em>. You may pass the keyboard to which the specified items will be added.</td>\n</tr></tbody></table>\n<p>Let's start with a simple example!</p>\n<h4>keyboard from <code>list</code> of <code>str</code></h4>\n<p>The easiest way to create a keyboard is to pass a list of items to a function.</p>\n<pre><span class=\"n\">menu</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"spam\"</span><span class=\"p\">,</span> <span class=\"s2\">\"eggs\"</span><span class=\"p\">,</span> <span class=\"s2\">\"ham\"</span><span class=\"p\">]</span>\n<span class=\"n\">keyboard</span> <span class=\"o\">=</span> <span class=\"n\">keyboa_maker</span><span class=\"p\">(</span><span class=\"n\">items</span><span class=\"o\">=</span><span class=\"n\">menu</span><span class=\"p\">,</span> <span class=\"n\">copy_text_to_callback</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">send_message</span><span class=\"p\">(</span><span class=\"n\">chat_id</span><span class=\"o\">=</span><span class=\"n\">chat_id</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"o\">=</span><span class=\"n\">text</span><span class=\"p\">,</span> <span class=\"n\">reply_markup</span><span class=\"o\">=</span><span class=\"n\">keyboard</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"keyboard from list of str\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/78fdb35e64912762de37b24eeed9744c31b6620d/68747470733a2f2f74656c656772612e70682f66696c652f6439323830623131656431316563313365366635362e706e67\"></p>\n<p>By default, each item in the list becomes a separate row, but it's easy to change by combining the items into groups.</p>\n<pre><span class=\"n\">menu</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"s2\">\"spam\"</span><span class=\"p\">,</span> <span class=\"s2\">\"eggs\"</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"s2\">\"ham\"</span><span class=\"p\">,</span> <span class=\"s2\">\"bread\"</span><span class=\"p\">],</span> <span class=\"s2\">\"spam\"</span><span class=\"p\">]</span>\n<span class=\"n\">keyboard</span> <span class=\"o\">=</span> <span class=\"n\">keyboa_maker</span><span class=\"p\">(</span><span class=\"n\">items</span><span class=\"o\">=</span><span class=\"n\">menu</span><span class=\"p\">,</span> <span class=\"n\">copy_text_to_callback</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">send_message</span><span class=\"p\">(</span><span class=\"n\">chat_id</span><span class=\"o\">=</span><span class=\"n\">chat_id</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"o\">=</span><span class=\"n\">text</span><span class=\"p\">,</span> <span class=\"n\">reply_markup</span><span class=\"o\">=</span><span class=\"n\">keyboard</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"keyboard from list of str\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cb160993f42f540d92eeb55aa2d06c8bbffc48d6/68747470733a2f2f74656c656772612e70682f66696c652f3265623637353233323466613139366361653461632e706e67\"></p>\n<p>Now you see that the keyboard buttons are arranged according to how we grouped them in the list.\nAnd of course you can create more complex structures, for example:</p>\n<pre><span class=\"n\">menu</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"s2\">\"spam\"</span><span class=\"p\">,</span> <span class=\"s2\">\"eggs\"</span><span class=\"p\">,</span> <span class=\"s2\">\"ham\"</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"s2\">\"ham\"</span><span class=\"p\">,</span> <span class=\"s2\">\"eggs\"</span><span class=\"p\">],</span> <span class=\"s2\">\"spam\"</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s2\">\"sausages\"</span><span class=\"p\">,</span> <span class=\"s2\">\"spam\"</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"s2\">\"eggs\"</span><span class=\"p\">,</span> <span class=\"s2\">\"spam\"</span><span class=\"p\">,</span> <span class=\"s2\">\"spam\"</span><span class=\"p\">]]</span>\n<span class=\"n\">keyboard</span> <span class=\"o\">=</span> <span class=\"n\">keyboa_maker</span><span class=\"p\">(</span><span class=\"n\">items</span><span class=\"o\">=</span><span class=\"n\">menu</span><span class=\"p\">,</span> <span class=\"n\">copy_text_to_callback</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">send_message</span><span class=\"p\">(</span><span class=\"n\">chat_id</span><span class=\"o\">=</span><span class=\"n\">chat_id</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"o\">=</span><span class=\"n\">text</span><span class=\"p\">,</span> <span class=\"n\">reply_markup</span><span class=\"o\">=</span><span class=\"n\">keyboard</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"keyboard from list of str\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f9180a2ab8f21eea71705582100bcecde345e39f/68747470733a2f2f74656c656772612e70682f66696c652f6661666633373531326336323638343563353532342e706e67\"></p>\n<blockquote>\n<p>Due to Telegram API limitation you can add <strong>up to 8 buttons per row</strong> and <strong>up to 100 for the entire keyboard</strong>.</p>\n</blockquote>\n<p>Let's go deeper. Suppose you have a list of 24 items, and you would like to divide it into rows of 6 buttons each. Here is what you need to do:</p>\n<pre><span class=\"n\">numbers</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">25</span><span class=\"p\">))</span>\n<span class=\"n\">keyboard</span> <span class=\"o\">=</span> <span class=\"n\">keyboa_maker</span><span class=\"p\">(</span><span class=\"n\">items</span><span class=\"o\">=</span><span class=\"n\">numbers</span><span class=\"p\">,</span> <span class=\"n\">items_in_row</span><span class=\"o\">=</span><span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"n\">copy_text_to_callback</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">send_message</span><span class=\"p\">(</span><span class=\"n\">chat_id</span><span class=\"o\">=</span><span class=\"n\">chat_id</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"o\">=</span><span class=\"n\">text</span><span class=\"p\">,</span> <span class=\"n\">reply_markup</span><span class=\"o\">=</span><span class=\"n\">keyboard</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"keyboard with 6 items_in_row\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bd9d11b5c2b88f3a44cfc3c1d39cb26d06328dd0/68747470733a2f2f74656c656772612e70682f66696c652f3231323263623966353039333862333962343433392e706e67\"></p>\n<p>\ud83d\udca1 You can easily make 3, 4 or even 8 buttons in a row, changing the <code>items_in_row</code> parameter only.</p>\n<p>Now we will try to use more parameters to see how they will affect the result:</p>\n<pre><span class=\"n\">keyboard</span> <span class=\"o\">=</span> <span class=\"n\">keyboa_maker</span><span class=\"p\">(</span>\n    <span class=\"n\">items</span><span class=\"o\">=</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">48</span><span class=\"p\">)),</span>\n    <span class=\"n\">auto_alignment</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n    <span class=\"n\">slice_start</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span>\n    <span class=\"n\">slice_stop</span><span class=\"o\">=</span><span class=\"mi\">37</span><span class=\"p\">,</span>\n    <span class=\"n\">copy_text_to_callback</span><span class=\"o\">=</span><span class=\"kc\">True</span>\n<span class=\"p\">)</span>\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">send_message</span><span class=\"p\">(</span><span class=\"n\">chat_id</span><span class=\"o\">=</span><span class=\"n\">chat_id</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"o\">=</span><span class=\"n\">text</span><span class=\"p\">,</span> <span class=\"n\">reply_markup</span><span class=\"o\">=</span><span class=\"n\">keyboard</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"keyboard slice with auto_alignment\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/627caee64e6a8de8b92d862cc1e02d08a5282a3d/68747470733a2f2f74656c656772612e70682f66696c652f6363343135313330353861326233643966383362612e706e67\"></p>\n<p>As you can see, this keyboard consists of a <code>[5:37]</code> slice. In addition, although we did not specify the <code>items_in_row</code> parameter, the function divided list into equal rows, because of enabled <code>auto_alignment</code> parameter.</p>\n<h3>Combine Keyboards</h3>\n<p>Sometimes it is necessary to combine several separate keyboard blocks  into the big one. The <code>keyboa_combiner()</code> function does just that!</p>\n<p>The function has only one input parameter - <code>keyboards</code>. It should be a sequence of <code>InlineKeyboardMarkup</code> objects. Also could be presented as a standalone <code>InlineKeyboardMarkup</code>.</p>\n<p>Here is how it works:</p>\n<pre><span class=\"n\">controls</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"s2\">\"\u23f9\ufe0f\"</span><span class=\"p\">,</span> <span class=\"s2\">\"\u23ea\ufe0f\"</span><span class=\"p\">,</span> <span class=\"s2\">\"\u23cf\ufe0f\"</span><span class=\"p\">,</span> <span class=\"s2\">\"\u23e9\ufe0f\"</span><span class=\"p\">,</span> <span class=\"s2\">\"\u25b6\ufe0f\"</span><span class=\"p\">],</span> <span class=\"p\">]</span>\n<span class=\"n\">tracks</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">13</span><span class=\"p\">))</span>\n\n<span class=\"n\">keyboard_controls</span> <span class=\"o\">=</span> <span class=\"n\">keyboa_maker</span><span class=\"p\">(</span><span class=\"n\">items</span><span class=\"o\">=</span><span class=\"n\">controls</span><span class=\"p\">,</span> <span class=\"n\">copy_text_to_callback</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">keyboard_tracks</span> <span class=\"o\">=</span> <span class=\"n\">keyboa_maker</span><span class=\"p\">(</span><span class=\"n\">items</span><span class=\"o\">=</span><span class=\"n\">tracks</span><span class=\"p\">,</span> <span class=\"n\">items_in_row</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"n\">copy_text_to_callback</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"n\">keyboard</span> <span class=\"o\">=</span> <span class=\"n\">keyboa_combiner</span><span class=\"p\">(</span><span class=\"n\">keyboards</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">keyboard_tracks</span><span class=\"p\">,</span> <span class=\"n\">keyboard_controls</span><span class=\"p\">))</span>\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">send_message</span><span class=\"p\">(</span><span class=\"n\">chat_id</span><span class=\"o\">=</span><span class=\"n\">user_id</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"o\">=</span><span class=\"n\">text_tracks</span><span class=\"p\">,</span> <span class=\"n\">reply_markup</span><span class=\"o\">=</span><span class=\"n\">keyboard</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"keyboard combo\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cf402395aa28423e920bc09f04dc1557a6ea7f11/68747470733a2f2f74656c656772612e70682f66696c652f3334326330366437383366616562373836663234322e706e67\"></p>\n<p>As you see, we merged two keyboards into one.</p>\n<h3>Complex callbacks</h3>\n<p>A few words about how to create complex callbacks for buttons.</p>\n<p>Often it is necessary to read and pass through the callback options that the user has sequentially selected. For example, determining the address: city, street, house, apartment number.</p>\n<p>Suppose we offer the user several cities to choose from. Create a simple keyboard:</p>\n<pre><span class=\"n\">kb_cities</span> <span class=\"o\">=</span> <span class=\"n\">keyboa_maker</span><span class=\"p\">(</span>\n    <span class=\"n\">items</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s2\">\"Moscow\"</span><span class=\"p\">,</span> <span class=\"s2\">\"London\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Tokyo\"</span><span class=\"p\">,</span> <span class=\"p\">],</span>\n    <span class=\"n\">copy_text_to_callback</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n    <span class=\"n\">front_marker</span><span class=\"o\">=</span><span class=\"s2\">\"&amp;city=\"</span><span class=\"p\">,</span>\n    <span class=\"n\">back_marker</span><span class=\"o\">=</span><span class=\"s2\">\"$\"</span>\n<span class=\"p\">)</span>\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">send_message</span><span class=\"p\">(</span><span class=\"n\">chat_id</span><span class=\"o\">=</span><span class=\"n\">user_id</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"o\">=</span><span class=\"s2\">\"Select your city:\"</span><span class=\"p\">,</span> <span class=\"n\">reply_markup</span><span class=\"o\">=</span><span class=\"n\">kb_cities</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"keyboard cities\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/255b57a5926ace0d27f9b28d3fa55159e0571d74/68747470733a2f2f74656c656772612e70682f66696c652f6463643031316337326534336165666438643030642e706e67\"></p>\n<p>By doing so, we get the following inside the keyboard:</p>\n<pre><span class=\"o\">{</span><span class=\"s1\">'inline_keyboard'</span>: <span class=\"o\">[</span>\n    <span class=\"o\">[{</span><span class=\"s1\">'text'</span>: <span class=\"s1\">'Moscow'</span>, <span class=\"s1\">'callback_data'</span>: <span class=\"s1\">'&amp;city=Moscow$'</span><span class=\"o\">}]</span>,\n    <span class=\"o\">[{</span><span class=\"s1\">'text'</span>: <span class=\"s1\">'London'</span>, <span class=\"s1\">'callback_data'</span>: <span class=\"s1\">'&amp;city=London$'</span><span class=\"o\">}]</span>,\n    <span class=\"o\">[{</span><span class=\"s1\">'text'</span>: <span class=\"s1\">'Tokyo'</span>, <span class=\"s1\">'callback_data'</span>: <span class=\"s1\">'&amp;city=Tokyo$'</span><span class=\"o\">}]</span>\n<span class=\"o\">]}</span>\n</pre>\n<p>Suppose a user selects <code>London</code>. We would like to remember this, and let him choose from several streets:</p>\n<pre><span class=\"n\">received_callback</span> <span class=\"o\">=</span> <span class=\"n\">call</span><span class=\"o\">.</span><span class=\"n\">data</span>  <span class=\"c1\"># \"&amp;city=London$\"</span>\n<span class=\"n\">streets</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"Baker Street\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Oxford Street\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Abbey Road\"</span><span class=\"p\">,</span> <span class=\"p\">]</span>\n<span class=\"n\">kb_streets</span> <span class=\"o\">=</span> <span class=\"n\">keyboa_maker</span><span class=\"p\">(</span>\n    <span class=\"n\">items</span><span class=\"o\">=</span><span class=\"n\">streets</span><span class=\"p\">,</span> \n    <span class=\"n\">copy_text_to_callback</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> \n    <span class=\"n\">front_marker</span><span class=\"o\">=</span><span class=\"s2\">\"&amp;street=\"</span><span class=\"p\">,</span> \n    <span class=\"n\">back_marker</span><span class=\"o\">=</span><span class=\"n\">received_callback</span><span class=\"p\">)</span>  <span class=\"c1\"># we added existing data to the end</span>\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">send_message</span><span class=\"p\">(</span><span class=\"n\">chat_id</span><span class=\"o\">=</span><span class=\"n\">user_id</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"o\">=</span><span class=\"s2\">\"Select your street:\"</span><span class=\"p\">,</span> <span class=\"n\">reply_markup</span><span class=\"o\">=</span><span class=\"n\">kb_streets</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"keyboard streets\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7e00b685f655b084cd872e348c3b78dbdb2378b3/68747470733a2f2f74656c656772612e70682f66696c652f6366303665336263306164656365383934353335642e706e67\"></p>\n<pre><span class=\"o\">{</span><span class=\"s1\">'inline_keyboard'</span>: <span class=\"o\">[</span>\n    <span class=\"o\">[{</span>\n        <span class=\"s1\">'text'</span>: <span class=\"s1\">'Baker Street'</span>,\n        <span class=\"s1\">'callback_data'</span>: <span class=\"s1\">'&amp;street=Baker Street&amp;city=London$'</span><span class=\"o\">}]</span>,\n    <span class=\"o\">[{</span>\n        <span class=\"s1\">'text'</span>: <span class=\"s1\">'Oxford Street'</span>,\n        <span class=\"s1\">'callback_data'</span>: <span class=\"s1\">'&amp;street=Oxford Street&amp;city=London$'</span><span class=\"o\">}]</span>,\n    <span class=\"o\">[{</span>\n        <span class=\"s1\">'text'</span>: <span class=\"s1\">'Abbey Road'</span>,\n        <span class=\"s1\">'callback_data'</span>: <span class=\"s1\">'&amp;street=Abbey Road&amp;city=London$'</span><span class=\"o\">}]</span>\n<span class=\"o\">]}</span>\n</pre>\n<p>\ud83d\udca1 Notice that we used a <code>front_marker</code> to specify the type of current items, and a <code>back_marker</code> to attach existing information.</p>\n<p>As you can see, the variant selected by the user in the previous step was also saved.\nIf the user selects a street, for example, <code>Baker Street</code>, we will receive the <code>call.data</code> as <code>'&amp;street=Oxford Street&amp;city=London$'</code>. Of course we are able to parse it easily.</p>\n<p>Finally, let him to choose an apartment:</p>\n<pre><span class=\"n\">received_callback</span> <span class=\"o\">=</span> <span class=\"n\">call</span><span class=\"o\">.</span><span class=\"n\">data</span>  <span class=\"c1\"># '&amp;street=Oxford Street&amp;city=London$'</span>\n<span class=\"n\">apartments</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"221a\"</span><span class=\"p\">,</span> <span class=\"s2\">\"221b\"</span><span class=\"p\">,</span> <span class=\"s2\">\"221c\"</span><span class=\"p\">,</span> <span class=\"p\">]</span>\n<span class=\"n\">kb_apartments</span> <span class=\"o\">=</span> <span class=\"n\">keyboa_maker</span><span class=\"p\">(</span>\n    <span class=\"n\">items</span><span class=\"o\">=</span><span class=\"n\">apartments</span><span class=\"p\">,</span> \n    <span class=\"n\">copy_text_to_callback</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> \n    <span class=\"n\">front_marker</span><span class=\"o\">=</span><span class=\"s2\">\"&amp;apartments=\"</span><span class=\"p\">,</span> \n    <span class=\"n\">back_marker</span><span class=\"o\">=</span><span class=\"n\">received_callback</span><span class=\"p\">)</span>  <span class=\"c1\"># we added existing data to the end</span>\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">send_message</span><span class=\"p\">(</span><span class=\"n\">chat_id</span><span class=\"o\">=</span><span class=\"n\">user_id</span><span class=\"p\">,</span> <span class=\"n\">text</span><span class=\"o\">=</span><span class=\"s2\">\"Select your apartments:\"</span><span class=\"p\">,</span> <span class=\"n\">reply_markup</span><span class=\"o\">=</span><span class=\"n\">kb_apartments</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"keyboard streets\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6b2a40a27b21f710fd2037f02108d83a76656f53/68747470733a2f2f74656c656772612e70682f66696c652f3065656335303439386632613638393535633831632e706e67\"></p>\n<pre><span class=\"o\">{</span><span class=\"s1\">'inline_keyboard'</span>: <span class=\"o\">[[</span>\n        <span class=\"o\">{</span><span class=\"s1\">'text'</span>: <span class=\"s1\">'221a'</span>,\n        <span class=\"s1\">'callback_data'</span>: <span class=\"s1\">'&amp;apartments=221a&amp;street=Oxford Street&amp;city=London$'</span><span class=\"o\">}</span>, \n        <span class=\"o\">{</span><span class=\"s1\">'text'</span>: <span class=\"s1\">'221b'</span>, \n        <span class=\"s1\">'callback_data'</span>: <span class=\"s1\">'&amp;apartments=221b&amp;street=Oxford Street&amp;city=London$'</span><span class=\"o\">}</span>,\n        <span class=\"o\">{</span><span class=\"s1\">'text'</span>: <span class=\"s1\">'221c'</span>, \n        <span class=\"s1\">'callback_data'</span>: <span class=\"s1\">'&amp;apartments=221c&amp;street=Oxford Street&amp;city=London$'</span><span class=\"o\">}</span>\n    <span class=\"o\">]]</span>\n<span class=\"o\">}</span>\n</pre>\n<p>And if the user selects button <code>221b</code>, we will assume that \ud83d\udd75\ud83c\udffb\u200d\u2642\ufe0f Mr. Sherlock Holmes uses our bot too!</p>\n\n          </div>"}, "last_serial": 7156946, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "f863d9af5fe7a5628693cf69d2a149a6", "sha256": "3b6183a0fc0b32ce7f420be5cfe96e67463db37a7b8f3db534b82158e6fc83b1"}, "downloads": -1, "filename": "keyboa-1.0.0.tar.gz", "has_sig": false, "md5_digest": "f863d9af5fe7a5628693cf69d2a149a6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4579, "upload_time": "2020-01-30T14:31:33", "upload_time_iso_8601": "2020-01-30T14:31:33.113032Z", "url": "https://files.pythonhosted.org/packages/b7/1c/604364488bdf086a59e869d52e19cb382d1e8f822d5a6010abd466c32d6e/keyboa-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "e678d32a64e9ac1a6ca88232449dd8f2", "sha256": "58be8b3cfb89632bd1217e19c5a6f6712c04e7f3e27fa822d55f124c1bc845a1"}, "downloads": -1, "filename": "keyboa-1.0.1.tar.gz", "has_sig": false, "md5_digest": "e678d32a64e9ac1a6ca88232449dd8f2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4465, "upload_time": "2020-01-31T00:08:11", "upload_time_iso_8601": "2020-01-31T00:08:11.069577Z", "url": "https://files.pythonhosted.org/packages/92/22/58ce744cbfefd62f8745cf3ce6babf11f1290910a2f6eca88c41e2401b43/keyboa-1.0.1.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "ee4f4c8868c82d630b97f5c9a9367a0a", "sha256": "195c839756a4ba9c931158d514179d8c548154ef4a38fb3a41de67122a771d4f"}, "downloads": -1, "filename": "keyboa-1.0.4.tar.gz", "has_sig": false, "md5_digest": "ee4f4c8868c82d630b97f5c9a9367a0a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4497, "upload_time": "2020-01-31T01:11:04", "upload_time_iso_8601": "2020-01-31T01:11:04.181145Z", "url": "https://files.pythonhosted.org/packages/ac/94/44e7084f593ff2e97d6c38e651968cc66674f45430d372c46d9b1758ebf1/keyboa-1.0.4.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "28f1a0a36f66372acde1f44d9876c0b7", "sha256": "83ca12edf27035cd899a02f9c6b9a0e21ad7d0fe50f5071d71b7320292533934"}, "downloads": -1, "filename": "keyboa-2.0.0.tar.gz", "has_sig": false, "md5_digest": "28f1a0a36f66372acde1f44d9876c0b7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3931, "upload_time": "2020-02-01T15:30:43", "upload_time_iso_8601": "2020-02-01T15:30:43.102786Z", "url": "https://files.pythonhosted.org/packages/13/f0/b0475ee772326efbdb30c1642d944e70773240ee68eb4ef0b02e841512f6/keyboa-2.0.0.tar.gz", "yanked": false}], "2.1.0": [{"comment_text": "", "digests": {"md5": "fc1771f0eb0ff1267f5da3a742e6e337", "sha256": "208594ac2b3bb99d0355d9cf470d358e5f53bfc97331b3234eab38f44f1475fa"}, "downloads": -1, "filename": "keyboa-2.1.0.tar.gz", "has_sig": false, "md5_digest": "fc1771f0eb0ff1267f5da3a742e6e337", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3935, "upload_time": "2020-02-04T14:37:08", "upload_time_iso_8601": "2020-02-04T14:37:08.734676Z", "url": "https://files.pythonhosted.org/packages/46/b7/18fb5c2cd165b85cbcfdf494021da21e6e44c1750d7153400cf9cf3ac0e0/keyboa-2.1.0.tar.gz", "yanked": false}], "2.2.0": [{"comment_text": "", "digests": {"md5": "c0b35e009247272d0b9e65cecc452299", "sha256": "d6390fb1fb355c4ae26eb1860a24189e25ec515fb5e300d58797b5dd3c0a329e"}, "downloads": -1, "filename": "keyboa-2.2.0.tar.gz", "has_sig": false, "md5_digest": "c0b35e009247272d0b9e65cecc452299", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4297, "upload_time": "2020-03-15T12:26:55", "upload_time_iso_8601": "2020-03-15T12:26:55.702179Z", "url": "https://files.pythonhosted.org/packages/02/a9/ad5008822df47998fe15d34a304810eebfd66d501f3435ee33dda2979fba/keyboa-2.2.0.tar.gz", "yanked": false}], "2.2.2": [{"comment_text": "", "digests": {"md5": "10d180073f955f31f62141b16da6465d", "sha256": "2fb8377edc8b695c33b72f792e1cc68288edc57259cf308a9af8cfafa06d85a8"}, "downloads": -1, "filename": "keyboa-2.2.2.tar.gz", "has_sig": false, "md5_digest": "10d180073f955f31f62141b16da6465d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4296, "upload_time": "2020-03-15T12:51:19", "upload_time_iso_8601": "2020-03-15T12:51:19.673234Z", "url": "https://files.pythonhosted.org/packages/ed/22/7c205e70e85a33125c32d7f8ad7cab5f953890e21f34f7179a0ffd2a8e24/keyboa-2.2.2.tar.gz", "yanked": false}], "2.2.3": [{"comment_text": "", "digests": {"md5": "1776b1d9e4869280857268707bfa01af", "sha256": "d9a79ecd30cbcb12df30fc460f1b648889238afcc16dabc45a5ce8409cb68899"}, "downloads": -1, "filename": "keyboa-2.2.3.tar.gz", "has_sig": false, "md5_digest": "1776b1d9e4869280857268707bfa01af", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12650, "upload_time": "2020-05-03T13:51:28", "upload_time_iso_8601": "2020-05-03T13:51:28.532174Z", "url": "https://files.pythonhosted.org/packages/12/8c/b98ffe8711c0661305ab3a2b76fb349f8b7e6478f3e6fcb693d368dd5569/keyboa-2.2.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1776b1d9e4869280857268707bfa01af", "sha256": "d9a79ecd30cbcb12df30fc460f1b648889238afcc16dabc45a5ce8409cb68899"}, "downloads": -1, "filename": "keyboa-2.2.3.tar.gz", "has_sig": false, "md5_digest": "1776b1d9e4869280857268707bfa01af", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12650, "upload_time": "2020-05-03T13:51:28", "upload_time_iso_8601": "2020-05-03T13:51:28.532174Z", "url": "https://files.pythonhosted.org/packages/12/8c/b98ffe8711c0661305ab3a2b76fb349f8b7e6478f3e6fcb693d368dd5569/keyboa-2.2.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:50:00 2020"}