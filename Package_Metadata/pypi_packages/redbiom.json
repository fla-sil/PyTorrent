{"info": {"author": "Daniel McDonald", "author_email": "wasade@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "# ![redbiom](https://raw.githubusercontent.com/biocore/redbiom/master/logo.png)\n# ![build-status](https://travis-ci.org/biocore/redbiom.svg?branch=master)\n\n# What is this?\n\nRedbiom is a cache service for sample metadata and sample data. It allows for rapidly:\n\n* finding samples by the features they contain\n* finding samples by arbitrary metadata searches\n* summarizing samples over metadata\n* retrieval of sample data into BIOM\n* discovering metadata categories\n* pulling out sample data from different processing types (e.g., search over 16S, retrieve WGS)\n\nredbiom is designed to handle biological and technical replicates. Specifically, it allows for a one to many relationship between a sample's metadata and its data, both within and between preparation types. Additional information about `redbiom` can be found in our [mSystems](https://msystems.asm.org/content/4/4/e00215-19) article.  \n\nThis repository defines the de facto redbiom data representation, and one possible interface into the resource. Other interfaces (e.g., Javascript) are possible to define. Please see the Design section below for details about how other interfaces can be written.\n\nBy default, redbiom will search against `qiita.ucsd.edu:7329`. This can be changed at runtime by setting the `REDBIOM_HOST` environmental variable, e.g., `export REDBIOM_HOST=http://qiita.ucsd.edu:7329`. The default host is **read-only** and administrative functions like loading data will not work against it.\n\nIf you intend to **load** your own data, you must setup a local instance (please see the server installation instructions below). In addition, you must explicitly set the `REDBIOM_HOST` environment variable.\n\n# Citation\n\nTo cite `redbiom`, please refer to:\n\nredbiom: a Rapid Sample Discovery and Feature Characterization System. Daniel McDonald, Benjamin Kaehler, Antonio Gonzalez, Jeff DeReus, Gail Ackermann, Clarisse Marotz, Gavin Huttley, Rob Knight. *mSystems* Jun 2019, 4 (4) e00215-19; DOI: 10.1128/mSystems.00215-19\n\n# Very brief examples\n\nA few quick examples of what can be done. More complex and detailed examples can be found later in the document.\n\nGet all the samples in which the word \"beer\" is found:\n\n    $ redbiom search metadata beer | head\n    10105.Ingredient.18\n    1976.Beer.286\n    1689.261\n    10105.Ingredient.19\n    1976.Beer.262\n    10105.Ingredient.23\n    1976.Beer.228\n    10105.Ingredient.17\n    10395.000041066\n    10105.Ingredient.24\n\nGet the closed reference OTU picking 16S V4 data for those samples (more on what `ctx` and `context` is in the longer examples below):\n\n    $ export ctx=Pick_closed-reference_OTUs-illumina-16S-v4-66f541\n    $ redbiom search metadata beer | head | redbiom fetch samples --context $ctx --output beer_example.biom\n    $ redbiom search metadata beer | head | redbiom fetch sample-metadata --context $ctx --output beer_example.txt\n\nFind the feature IDs (Greengenes OTU IDs in this case) associated with S. aureus (and for example purposes, an arbitrary 10):\n\n    $ redbiom search taxon --context $ctx s__aureus | head\n    943389\n    1023241\n    862312\n    1102743\n    870118\n    969777\n    1086805\n    976010\n    951488\n    951136\n\n...and then find samples which contain those 10 S. aureus features:\n\n    $ redbiom search taxon --context $ctx s__aureus | head | redbiom search features --context $ctx | wc -l\n       40164\n\n# Installation\n\n### General requirements\n\nRedbiom depends on [BIOM](http://biom-format.org/) (tested on >= 2.1.5), [Pandas](http://pandas.pydata.org/) (tested on 0.19.0), [Click](http://click.pocoo.org/5/) (required >= 6.7), [nltk](http://www.nltk.org/) (tested on 3.2.2), [joblib](https://pythonhosted.org/joblib/) (tested on 0.9.3), and [scipy](https://www.scipy.org/) (whatever BIOM is happy with).\n\n### Client\n\nIf you would like to use redbiom as only a client (which is the general case), then the following instructions apply. Note that we need to install numpy separately as one of the dependencies, BIOM-Format, imports numpy within its installation process.\n\n    $ pip install numpy\n    $ pip install redbiom\n    \nAlternatively, you can install `redbiom` through conda:\n\n    $ conda install -c conda-forge redbiom\n\n### Server\n\nIf you would like to run your own resource, and load data locally or private data, then the following instructions apply.\n\nIn addition to the general requirements, redbiom server needs [Redis](https://redis.io/) (tested with 2.8.17 and 3.2.6) and [Webdis](http://webd.is/) (just clone the repo). It is not necessary to have super user access to establish a redbiom server.\n\nFor Redis, the following has worked on OSX and multiple flavors of Linux without issue.\n\n    $ wget http://download.redis.io/releases/redis-3.2.6.tar.gz\n    $ tar xzf redis-3.2.6.tar.gz\n    $ pushd redis-3.2.6\n    $ make\n    $ ./src/redis-server --daemonize\n    $ popd\n\nWebdis packages its dependencies with the exception of libevent. It is entirely likely that libevent is already available on your system. If so, the following should work. If libevent is not available, compilation will die quickly. However, libevent is in all the common repositories (e.g., yum, apt, brew, etc), and compiling by source is straight forward. \n\n    $ git clone https://github.com/nicolasff/webdis.git\n    $ pushd webdis\n    $ make\n    $ ./webdis &\n    $ popd\n\nLast, redbiom itself can be installed as a normal Python package.\n\n    $ pip install numpy\n    $ pip install redbiom\n\n### Testing\n\nThe test framework is setup to by default only execute tests against `localhost`, specifically, `127.0.0.1:7379`. However, the repository, by default, is setup to communicate with a remote Webdis server. If you wish to execute the test suite, please `export REDBIOM_HOST=http://127.0.0.1:7379`.\n\n# Terminology and notation\n\nIn redbiom, the word \"context\" refers to a way in which the sample data were processed. Data are loaded into contexts and searches for samples by feature happen within contexts.\n\nTo support the one to many relationship between a sample's metadata and its data, within a context, a sample's IDs are prefixed by a \"tag\" which can be specified at load. Internally, within a context, these IDs are of the form `<tag>_<sample-id>`. The use of the `_` character ensures that they are not valid QIIME sample IDs, and is necessary so we can appropriately differentiate these IDs. Methods which write data will coerce these invalid QIIME IDs into valid IDs of the form `<sample-id>.<tag>`. **IMPORTANT**: if you run your own resource, it is important to specify `--tag` on load of sample data to differentiate BIOM tables in which the sample IDs between the tables may not be mutually exclusive. \n\nCommands which write data will notify the user if there were ambiguities. An ambiguitiy means that there was a sample ID which mapped to multiple redbiom IDs within the output. The IDs written are unique because of the reasons noted above.  \n\n# Command structure\n\nRedbiom relies on `Click` to provide a tiered command line interface. An example of the first tier is below, and with the exception of `admin`, are composed of verbs:\n\n    $ redbiom --help\n    Usage: redbiom [OPTIONS] COMMAND [ARGS]...\n\n    Options:\n      --version  Show the version and exit.\n      --help     Show this message and exit.\n\n    Commands:\n      admin      Update database, etc.\n      fetch      Sample data and metadata retrieval.\n      search     Feature and sample search support.\n      select     Select items based on metadata\n      summarize  Summarize things.\n\nThe actual commands to execute are contained within a submodule. For instance, below are the commands associated with \"search\":\n\n    $ redbiom search --help\n    Usage: redbiom search [OPTIONS] COMMAND [ARGS]...\n\n      Feature and sample search support.\n\n    Options:\n      --help  Show this message and exit.\n\n    Commands:\n      metadata      Find samples or categories.\n      features      Find samples containing features.\n      taxon         Find features associated with a taxon\n\nThe intention is for commands to make sense in English. The general command form is \"redbiom <verb> <noun>\", however this form is not strictly enforced. \n\nIn general, these commands are intended to be composable via Unix pipes. For example:\n\n    redbiom search metadata antibiotics | redbiom fetch samples --context <foo> --output my_table.biom\n\n# Examples\n\n### Search for samples by metadata\n\nBy default, redbiom is setup to query against [Qiita](https://qiita.ucsd.edu). First, let's search for some samples by metadata. Specifically, what we're going to do is identify what samples exist in Qiita in which any of their sample metadata contains the [stem](https://en.wikipedia.org/wiki/Stemming) of the word beer. This returns quite a few samples, so for the sake of the example, we're only going to show the first 10 using `head`: \n\n    $ redbiom search metadata beer | head\n    10105.Ingredient.18\n    1976.Beer.286\n    1689.261\n    10105.Ingredient.19\n    1976.Beer.262\n    10105.Ingredient.23\n    1976.Beer.228\n    10105.Ingredient.17\n    10395.000041066\n    10105.Ingredient.24\n\n    $ redbiom search metadata beer | wc -l\n      70\n\nNow that we have some samples, let's pull out their sample data. Qiita contains a huge amount of data, which are logically partitioned by the sample preparations and processing parameters -- these partitions are denoted as **contexts** in redbiom. In order to pull out the data, we need to specify the context to operate in. There are a lot of contexts, so let's filter to only those which are 16S and V4 using `grep`. We're also going to `cut` the first three columns of data as the fourth one is a voluminous description of the processing parameters. And last, let's `sort` the results by the number of samples represented in the context. Unfortunately, the `grep` removes the column headers, so we'll run a second summarize command and just grab the header:\n\n    $ redbiom summarize contexts | cut -f 1,2,3 | grep 16S-v4 | grep Greengenes-illumina |  sort -k 2 -n\n    Pick_closed-reference_OTUs-Greengenes-illumina-16S-v45-100nt-a243a1 22  8178\n    Pick_closed-reference_OTUs-Greengenes-illumina-16S-v45-90nt-44feac  22  8471\n    Pick_closed-reference_OTUs-Greengenes-illumina-16S-v4-41ebc6    100 14434\n    Pick_closed-reference_OTUs-Greengenes-illumina-16S-v45-5c6506   102 29598\n    Pick_closed-reference_OTUs-Greengenes-illumina-16S-v4-125nt-65468f  1122    13277\n    Pick_closed-reference_OTUs-Greengenes-illumina-16S-v4-150nt-bd7d4d  90500   69304\n    Pick_closed-reference_OTUs-Greengenes-illumina-16S-v4-90nt-44feac   125354  73083\n    Pick_closed-reference_OTUs-Greengenes-illumina-16S-v4-5c6506    128222  82492\n    Pick_closed-reference_OTUs-Greengenes-illumina-16S-v4-100nt-a243a1  129596  74983\n\n    $ redbiom summarize contexts | head -n 1\n    ContextName SamplesWithData FeaturesWithData    Description\n\nTo reduce typing later, let's just pick a context and store it as an environment variable:\n\n    $ export ctx=Pick_closed-reference_OTUs-Greengenes-illumina-16S-v4-5c6506\n\n...and now we can grab some data:\n\n    $ redbiom search metadata beer | redbiom fetch samples --context $ctx --output example.biom\n    $ biom summarize-table -i example.biom | head\n    Num samples: 37\n    Num observations: 3653\n    Total count: 2205617\n    Table density (fraction of non-zero values): 0.091\n\n    Counts/sample summary:\n     Min: 1717.0\n     Max: 208223.0\n     Median: 59224.000\n     Mean: 59611.270\n    \nWe probably also want to get the sample metadata:\n\n    $ redbiom search metadata beer | redbiom fetch sample-metadata --output example.txt --context $ctx\n\nYou might note that the total number of samples found by the metadata search is not the same as the number of samples found by the sample data fetch. The sample information is distinct from the sample preparation, and data processing: just because there is sample information does not mean a given sample has (for instance) 16S V4 sequence data associated with it.\n\nThe query structures for metadata are fairly permissive, and there are actually two types of queries that can be performed. The structure is as follows: `<set operations> where <value restrictions>`. The `<set operations>` work by finding all samples with that contain a given word, which can be combined together. For the set queries, `&` performs an intersection of the sample IDs, `|` a union, and `-` a difference:\n\n    $ redbiom search metadata \"soil & europe where ph < 7\" | wc -l\n    5521\n\n**IMPORTANT**: just because a sample may have a word associated with it, does not mean that word is used as you may expect. In the example below, we're counting the number of samples by their described `sample_type` value. We are working to improve the search functionality, and it is important for users to scrutinize their results:\n\n    $ redbiom search metadata \"soil & europe where ph < 7\" | redbiom summarize samples --category sample_type  | head\n    soil    1978\n    XXQIITAXX   1686\n    Soil    612\n    fresh water 519\n    peat    192\n    sebum   99\n    bodily fluid    81\n    belly   41\n    biofilm 39\n    ab_liq  38\n\n### Search by feature\n\nWe can also use redbiom to search for samples containing features of interest. Let's operate off our example table from the metadata search above. What we're going to do is find all samples in Qiita that contain any of the a handful of the feature IDs. In this particular example, let's just grab 10 arbitrary IDs:\n\n    $ biom table-ids -i example.biom --observations | head\n    4449525\n    4420570\n    471180\n    815819\n    4235445\n    1108951\n    519367\n    12364\n    4454153\n    4227110\n\n...and then let's pipe them back into redbiom to search for other samples in our context which contain those same features:\n\n    $ biom table-ids -i example.biom --observations | head | redbiom search features --context $ctx | wc -l\n       43133\n\n    $ biom table-ids -i example.biom --observations | head | redbiom search features --context $ctx | head\n    3759_10172.3338\n    2923_10317.000017653\n    2096_1716.McG.PAPrS17\n    2015_1034.CHB1\n    2150_755.SSFA.L1.D30.07.06.11.lane1.NoIndex.L001\n    2150_755.LSSF.ALPHA.D20.14.07.11.lane1.NoIndex.L001\n    26483_10317.000007237\n    3788_10119.MT.741\n    2112_1774.527.Skin.Puer\n    2102_1734.BD.ERD510\n\n### Search by taxon\n\nOne thing you might want to do is find features based on taxonomy. We can do this by searching for a taxon:\n\n    $ redbiom search taxon g__Roseburia --context $ctx | wc -l\n         108\n\nWhat we get back are the feature IDs that are of that taxon. We can then take those feature IDs and feed them back into redbiom. So for instance, let's say we wanted to find all samples which contain a Roseburia feature:\n\n    $ redbiom search taxon g__Roseburia --context $ctx | redbiom search features --context $ctx | wc -l\n       37539\n\n**IMPORTANT** not all contexts necessarily have taxonomy, and taxonomy may not make sense for a context (e.g., if it contains KEGG Orthologous group features).\n\n### Retrieving pre-selected samples\n\nIn additional to allowing you to search based on specific metadata or features, you can also retrieve a list of samples based on the sample ID. For instance, we might want to get a list of all the samples with cider associated with them, and then potentially access only these samples later, after a database update. \n\nTo do this, we can pulldown a list of the first five samples with cider associated.\n\n    $ redbiom search metadata cider | head -5 > cider.txt\n    $ head cider.txt\n        11261.CW91.R1.T7\n        11261.CW130.S.F2.T7\n        11261.CW120.F1.T4\n        11261.CW75.R3.T1\n        11261.CW125.F3.T5 \n    \nThen, we can use this list of samples to retrieve the biom table. The text file simply needs to be a list of sample IDs in the databse, one per line.\n\n    $ redbiom fetch samples --from cider.txt --context $ctx --output cider.biom\n    $ biom summarize-table -i cider.biom | head\n    Num samples: 5\n    Num observations: 281\n    Total count: 173,579\n    Table density (fraction of non-zero values): 0.396\n    \n    Counts/sample summary:\n     Min: 25,936.000\n     Max: 38,900.000\n     Median: 36,602.000\n     Mean: 34,715.800\n\n\n### Summarizations\n\nWe found a lot of samples that contain Roseburia. That isn't too surprising since Qiita contains a lot of fecal samples. How many? In this next example, we're taking all of the feature IDs associated with Roseburia, then finding all of the samples which contain that taxon, followed by binning each sample by their `sample_type` category value, and finally we're taking just the top 10 entries. You can see that the metadata are a bit noisy.\n\n    $ redbiom search taxon g__Roseburia --context $ctx | redbiom search features --context $ctx | redbiom summarize samples --category sample_type | head\n    Stool   13251\n    stool   11416\n    XXQIITAXX   1029\n    tanker milk 984\n    biopsy  930\n    Floor   622\n    skin    615\n    Stool_Stabilizer    566\n    control blank   520\n    Mouth   420\n\nWe can still work through the noise though. Let's take our samples we found that contain Roseburia, and only select the ones that appear to obviously be fecal. Instead of summarizing as we did in our last example, we're going to \"select\" the samples in which `sample_type` is either \"Stool\" or \"stool\". (as this command is getting long, we'll break it up with \\\\):\n\n    $ redbiom search taxon g__Roseburia --context $ctx | \\\n        redbiom search features --context $ctx | \\\n        redbiom select samples-from-metadata --context $ctx \"where sample_type in ('Stool', 'stool')\" | \\\n        wc -l\n       24667\n\nAnd last, we can grab the data for those samples. Fetching data for 24,667 samples can take a few minutes, so for the purpose of the example, let's just grab the ones associated with skin. Please note the \"ambiguity\" on the output, more in a second on that:\n\n    $ redbiom search taxon g__Roseburia --context $ctx | \\\n        redbiom search features --context $ctx | \\\n        redbiom select samples-from-metadata --context $ctx \"where sample_type=='skin'\" | \\\n        redbiom fetch samples --context $ctx --output roseburia_example.biom\n    16 sample ambiguities observed. Writing ambiguity mappings to: roseburia_example.biom.ambiguities\n\nAmbiguities can arise if the same sample was processed multiple times as might happen with a technical replicate. It is the same physical sample, but it may have been processed multiple times. The `.ambiguities` file is in JSON and contains a mapping of what IDs map to the same sample.\n\n### Load some data (i.e., if you are running your own server)\n\nTo make use of this cache, we need to load things. Loading can be done in parallel. First, we'll load up metadata. This will create keys in Redis which describe all of the columns associated with a sample (e.g., `metadata:categories:<sample_id>`, hash buckets for each category and sample combination (e.g., `metadata:category:<category_name>` as the hash and `<sample_id>` as the field), a set of all known categories (e.g., `metadata:categories-represented`), and a set of all known sample IDs (e.g., `metadata:samples-represented`):\n\n    $ redbiom admin load-sample-metadata --metadata path/to/qiime/compat/mapping.txt\n\nredbiom supports one to many mappings between sample metadata and actual sample data. This is done as there may be multiple types of processing performed on the same data (e.g., different nucleotide trims). Or, a physical sample may have been run through multiple protocols (e.g., 16S, WGS, etc). So before we load any data, we need to create a context for the data to be placed. The following action will add an entry into the `state:contexts` hash bucket keyed by `name` and valued by `description`:\n\n    $ redbiom admin create-context --name deblur-100nt --description \"16S V4 Caporaso et al data deblurred at 100nt\"\n\nNext, we'll load up associations between every single feature in a BIOM table to all the samples its found in. This will create Redis sets and can be accessed using keys of the form `<context_name>:samples:<feature_id>`. Note that we specify the context we're loading into.\n\n    $ redbiom admin load-features --context deblur-100nt --table /path/to/biom/table.biom\n\nLast, let's load up all of the BIOM table data. We'll only store the non-zero values, and we'll encode the sample data into something simple so that it goes in as just a string to Redis. Important: we only support storing count data right now, not floating point. The keys created are of the form `<context_name>:sample:<redbiom_id>`. To reduce space, we reindex the feature IDs as things like sOTUs tend to be very long in name. The mapping is stable over all tables loaded (ie the same feature has the same index), and is stored under `<context_name>:feature-index`. Because we need to update the index, this operation cannot be done in parallel however the code is setup with a redis-based mutex so it's okay to queue up multiple loads.\n\n    $ redbiom load-sample-data --context deblur-100nt --table /path/to/biom/table.biom\n\n# Caveats\n\nRedbiom is still in heavy active development. At this time, there are still some important caveats. \n\n* Metadata values containing `/` characters cannot be represented the forward slash is used to denote arguments with Webdis. At present, these values are omitted. This is more generally a problem for dates which have not been normalized into an ISO standard. See issue #9.\n* Metadata values which appear to be null are not stored. The set of values currently considered nulls are: \n    \n    {'Not applicable', 'Unknown', 'Unspecified', 'Missing: Not collected',\n     'Missing: Not provided', 'Missing: Restricted access',\n     'null', 'NULL', 'no_data', 'None', 'nan'}\n     \n* Sample IDs must be QIIME compatible.\n\n# Design\n\n### Python and testing\nThere are a few design decisions in place which deviate from some other typical Python projects. First off, the majority of `import`s are deferred. The motivating force here is to minimize overhead on load as to provide a responsive user interface -- deferred imports are the most straight forward way to accomplish that goal. \n\nThe test harness is broken into multiple components, and are driven by a `Makefile`. This was done initially to be pragmatic as it was easier to write integration tests than unit tests for the `click` commands. These tests can be found in `test.sh` which is composed of \"positive\" tests and `test_failures.sh` which is composed of \"negative\" tests. The difference being that the positive tests will fail if any command results in a nonzero exit status, whereas the negative tests expect a nonzero exit status (and really, the decision was to avoid unsetting \"-e\"). Additional tests which validate some of the Redis contents can be found in `redbiom/tests/test_rest.py`. These are neither unit tests nor integration tests, but simply exercise the behind-the-scenes REST interface. Last, there are a suite of unit tests placed under `redbiom/tests/`. \n\n### Redis data organization\n\nBecause redbiom is currently in alpha, and its data model is subject to change, we are holding off an indepth description of it. That being said, the API methods in general outline the Redis commands issued within their docstrings and can be used to guide interaction. \n\nThe key structures used are in the following forms:\n\n* `state:*` redbiom state information such as context details\n* `metadata:category:<category>` the samples and metadata values for the category\n* `metadata:categories:<sample-id>` the metadata categories known to exist for a given sample\n* `metadata:text-search:<stem>` the samples associated with a given metadata value stem\n* `metadata:category-search:<stem>` the categories associated with a given stem\n* `metadata:samples-represented` the samples that are represented by the metadata\n* `<context>:sample:<redbiom-id>` the sample data within a context\n* `<context>:feature:<feature-id>` the feature data within a context\n* `<context>:samples-represented` the samples within the context which contain BIOM data\n* `<context>:sample-index` a mapping between a sample ID and a context-unique stable integer\n* `<context>:sample-index-inverted` a mapping between a context-unique stable integer and its associated sample ID \n* `<context>:features-represented` the reatures represented within the context \n* `<context>:feature-index` a mapping between a feature ID and a context-unique stable integer\n* `<context>:feature-index-inverted` a mapping between a context-unique stable integer and its associated feature ID\n* `<context>:taxonomy-children:<taxon>` the children of a taxon\n* `<context>:taxonomy-parents` child to parent taxon mappings", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/biocore/redbiom", "keywords": "", "license": "BSD-3-Clause", "maintainer": "", "maintainer_email": "", "name": "redbiom", "package_url": "https://pypi.org/project/redbiom/", "platform": "", "project_url": "https://pypi.org/project/redbiom/", "project_urls": {"Homepage": "https://github.com/biocore/redbiom"}, "release_url": "https://pypi.org/project/redbiom/0.3.5/", "requires_dist": null, "requires_python": "", "summary": "", "version": "0.3.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1><img alt=\"redbiom\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ee97a207084123223deace18a3ff6bad2ca7fb19/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f62696f636f72652f72656462696f6d2f6d61737465722f6c6f676f2e706e67\"></h1>\n<h1><img alt=\"build-status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f69ab4548b1a64f5bad357792f83a78633fe9bc2/68747470733a2f2f7472617669732d63692e6f72672f62696f636f72652f72656462696f6d2e7376673f6272616e63683d6d6173746572\"></h1>\n<h1>What is this?</h1>\n<p>Redbiom is a cache service for sample metadata and sample data. It allows for rapidly:</p>\n<ul>\n<li>finding samples by the features they contain</li>\n<li>finding samples by arbitrary metadata searches</li>\n<li>summarizing samples over metadata</li>\n<li>retrieval of sample data into BIOM</li>\n<li>discovering metadata categories</li>\n<li>pulling out sample data from different processing types (e.g., search over 16S, retrieve WGS)</li>\n</ul>\n<p>redbiom is designed to handle biological and technical replicates. Specifically, it allows for a one to many relationship between a sample's metadata and its data, both within and between preparation types. Additional information about <code>redbiom</code> can be found in our <a href=\"https://msystems.asm.org/content/4/4/e00215-19\" rel=\"nofollow\">mSystems</a> article.</p>\n<p>This repository defines the de facto redbiom data representation, and one possible interface into the resource. Other interfaces (e.g., Javascript) are possible to define. Please see the Design section below for details about how other interfaces can be written.</p>\n<p>By default, redbiom will search against <code>qiita.ucsd.edu:7329</code>. This can be changed at runtime by setting the <code>REDBIOM_HOST</code> environmental variable, e.g., <code>export REDBIOM_HOST=http://qiita.ucsd.edu:7329</code>. The default host is <strong>read-only</strong> and administrative functions like loading data will not work against it.</p>\n<p>If you intend to <strong>load</strong> your own data, you must setup a local instance (please see the server installation instructions below). In addition, you must explicitly set the <code>REDBIOM_HOST</code> environment variable.</p>\n<h1>Citation</h1>\n<p>To cite <code>redbiom</code>, please refer to:</p>\n<p>redbiom: a Rapid Sample Discovery and Feature Characterization System. Daniel McDonald, Benjamin Kaehler, Antonio Gonzalez, Jeff DeReus, Gail Ackermann, Clarisse Marotz, Gavin Huttley, Rob Knight. <em>mSystems</em> Jun 2019, 4 (4) e00215-19; DOI: 10.1128/mSystems.00215-19</p>\n<h1>Very brief examples</h1>\n<p>A few quick examples of what can be done. More complex and detailed examples can be found later in the document.</p>\n<p>Get all the samples in which the word \"beer\" is found:</p>\n<pre><code>$ redbiom search metadata beer | head\n10105.Ingredient.18\n1976.Beer.286\n1689.261\n10105.Ingredient.19\n1976.Beer.262\n10105.Ingredient.23\n1976.Beer.228\n10105.Ingredient.17\n10395.000041066\n10105.Ingredient.24\n</code></pre>\n<p>Get the closed reference OTU picking 16S V4 data for those samples (more on what <code>ctx</code> and <code>context</code> is in the longer examples below):</p>\n<pre><code>$ export ctx=Pick_closed-reference_OTUs-illumina-16S-v4-66f541\n$ redbiom search metadata beer | head | redbiom fetch samples --context $ctx --output beer_example.biom\n$ redbiom search metadata beer | head | redbiom fetch sample-metadata --context $ctx --output beer_example.txt\n</code></pre>\n<p>Find the feature IDs (Greengenes OTU IDs in this case) associated with S. aureus (and for example purposes, an arbitrary 10):</p>\n<pre><code>$ redbiom search taxon --context $ctx s__aureus | head\n943389\n1023241\n862312\n1102743\n870118\n969777\n1086805\n976010\n951488\n951136\n</code></pre>\n<p>...and then find samples which contain those 10 S. aureus features:</p>\n<pre><code>$ redbiom search taxon --context $ctx s__aureus | head | redbiom search features --context $ctx | wc -l\n   40164\n</code></pre>\n<h1>Installation</h1>\n<h3>General requirements</h3>\n<p>Redbiom depends on <a href=\"http://biom-format.org/\" rel=\"nofollow\">BIOM</a> (tested on &gt;= 2.1.5), <a href=\"http://pandas.pydata.org/\" rel=\"nofollow\">Pandas</a> (tested on 0.19.0), <a href=\"http://click.pocoo.org/5/\" rel=\"nofollow\">Click</a> (required &gt;= 6.7), <a href=\"http://www.nltk.org/\" rel=\"nofollow\">nltk</a> (tested on 3.2.2), <a href=\"https://pythonhosted.org/joblib/\" rel=\"nofollow\">joblib</a> (tested on 0.9.3), and <a href=\"https://www.scipy.org/\" rel=\"nofollow\">scipy</a> (whatever BIOM is happy with).</p>\n<h3>Client</h3>\n<p>If you would like to use redbiom as only a client (which is the general case), then the following instructions apply. Note that we need to install numpy separately as one of the dependencies, BIOM-Format, imports numpy within its installation process.</p>\n<pre><code>$ pip install numpy\n$ pip install redbiom\n</code></pre>\n<p>Alternatively, you can install <code>redbiom</code> through conda:</p>\n<pre><code>$ conda install -c conda-forge redbiom\n</code></pre>\n<h3>Server</h3>\n<p>If you would like to run your own resource, and load data locally or private data, then the following instructions apply.</p>\n<p>In addition to the general requirements, redbiom server needs <a href=\"https://redis.io/\" rel=\"nofollow\">Redis</a> (tested with 2.8.17 and 3.2.6) and <a href=\"http://webd.is/\" rel=\"nofollow\">Webdis</a> (just clone the repo). It is not necessary to have super user access to establish a redbiom server.</p>\n<p>For Redis, the following has worked on OSX and multiple flavors of Linux without issue.</p>\n<pre><code>$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz\n$ tar xzf redis-3.2.6.tar.gz\n$ pushd redis-3.2.6\n$ make\n$ ./src/redis-server --daemonize\n$ popd\n</code></pre>\n<p>Webdis packages its dependencies with the exception of libevent. It is entirely likely that libevent is already available on your system. If so, the following should work. If libevent is not available, compilation will die quickly. However, libevent is in all the common repositories (e.g., yum, apt, brew, etc), and compiling by source is straight forward.</p>\n<pre><code>$ git clone https://github.com/nicolasff/webdis.git\n$ pushd webdis\n$ make\n$ ./webdis &amp;\n$ popd\n</code></pre>\n<p>Last, redbiom itself can be installed as a normal Python package.</p>\n<pre><code>$ pip install numpy\n$ pip install redbiom\n</code></pre>\n<h3>Testing</h3>\n<p>The test framework is setup to by default only execute tests against <code>localhost</code>, specifically, <code>127.0.0.1:7379</code>. However, the repository, by default, is setup to communicate with a remote Webdis server. If you wish to execute the test suite, please <code>export REDBIOM_HOST=http://127.0.0.1:7379</code>.</p>\n<h1>Terminology and notation</h1>\n<p>In redbiom, the word \"context\" refers to a way in which the sample data were processed. Data are loaded into contexts and searches for samples by feature happen within contexts.</p>\n<p>To support the one to many relationship between a sample's metadata and its data, within a context, a sample's IDs are prefixed by a \"tag\" which can be specified at load. Internally, within a context, these IDs are of the form <code>&lt;tag&gt;_&lt;sample-id&gt;</code>. The use of the <code>_</code> character ensures that they are not valid QIIME sample IDs, and is necessary so we can appropriately differentiate these IDs. Methods which write data will coerce these invalid QIIME IDs into valid IDs of the form <code>&lt;sample-id&gt;.&lt;tag&gt;</code>. <strong>IMPORTANT</strong>: if you run your own resource, it is important to specify <code>--tag</code> on load of sample data to differentiate BIOM tables in which the sample IDs between the tables may not be mutually exclusive.</p>\n<p>Commands which write data will notify the user if there were ambiguities. An ambiguitiy means that there was a sample ID which mapped to multiple redbiom IDs within the output. The IDs written are unique because of the reasons noted above.</p>\n<h1>Command structure</h1>\n<p>Redbiom relies on <code>Click</code> to provide a tiered command line interface. An example of the first tier is below, and with the exception of <code>admin</code>, are composed of verbs:</p>\n<pre><code>$ redbiom --help\nUsage: redbiom [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --version  Show the version and exit.\n  --help     Show this message and exit.\n\nCommands:\n  admin      Update database, etc.\n  fetch      Sample data and metadata retrieval.\n  search     Feature and sample search support.\n  select     Select items based on metadata\n  summarize  Summarize things.\n</code></pre>\n<p>The actual commands to execute are contained within a submodule. For instance, below are the commands associated with \"search\":</p>\n<pre><code>$ redbiom search --help\nUsage: redbiom search [OPTIONS] COMMAND [ARGS]...\n\n  Feature and sample search support.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  metadata      Find samples or categories.\n  features      Find samples containing features.\n  taxon         Find features associated with a taxon\n</code></pre>\n<p>The intention is for commands to make sense in English. The general command form is \"redbiom &lt;verb&gt; &lt;noun&gt;\", however this form is not strictly enforced.</p>\n<p>In general, these commands are intended to be composable via Unix pipes. For example:</p>\n<pre><code>redbiom search metadata antibiotics | redbiom fetch samples --context &lt;foo&gt; --output my_table.biom\n</code></pre>\n<h1>Examples</h1>\n<h3>Search for samples by metadata</h3>\n<p>By default, redbiom is setup to query against <a href=\"https://qiita.ucsd.edu\" rel=\"nofollow\">Qiita</a>. First, let's search for some samples by metadata. Specifically, what we're going to do is identify what samples exist in Qiita in which any of their sample metadata contains the <a href=\"https://en.wikipedia.org/wiki/Stemming\" rel=\"nofollow\">stem</a> of the word beer. This returns quite a few samples, so for the sake of the example, we're only going to show the first 10 using <code>head</code>:</p>\n<pre><code>$ redbiom search metadata beer | head\n10105.Ingredient.18\n1976.Beer.286\n1689.261\n10105.Ingredient.19\n1976.Beer.262\n10105.Ingredient.23\n1976.Beer.228\n10105.Ingredient.17\n10395.000041066\n10105.Ingredient.24\n\n$ redbiom search metadata beer | wc -l\n  70\n</code></pre>\n<p>Now that we have some samples, let's pull out their sample data. Qiita contains a huge amount of data, which are logically partitioned by the sample preparations and processing parameters -- these partitions are denoted as <strong>contexts</strong> in redbiom. In order to pull out the data, we need to specify the context to operate in. There are a lot of contexts, so let's filter to only those which are 16S and V4 using <code>grep</code>. We're also going to <code>cut</code> the first three columns of data as the fourth one is a voluminous description of the processing parameters. And last, let's <code>sort</code> the results by the number of samples represented in the context. Unfortunately, the <code>grep</code> removes the column headers, so we'll run a second summarize command and just grab the header:</p>\n<pre><code>$ redbiom summarize contexts | cut -f 1,2,3 | grep 16S-v4 | grep Greengenes-illumina |  sort -k 2 -n\nPick_closed-reference_OTUs-Greengenes-illumina-16S-v45-100nt-a243a1 22  8178\nPick_closed-reference_OTUs-Greengenes-illumina-16S-v45-90nt-44feac  22  8471\nPick_closed-reference_OTUs-Greengenes-illumina-16S-v4-41ebc6    100 14434\nPick_closed-reference_OTUs-Greengenes-illumina-16S-v45-5c6506   102 29598\nPick_closed-reference_OTUs-Greengenes-illumina-16S-v4-125nt-65468f  1122    13277\nPick_closed-reference_OTUs-Greengenes-illumina-16S-v4-150nt-bd7d4d  90500   69304\nPick_closed-reference_OTUs-Greengenes-illumina-16S-v4-90nt-44feac   125354  73083\nPick_closed-reference_OTUs-Greengenes-illumina-16S-v4-5c6506    128222  82492\nPick_closed-reference_OTUs-Greengenes-illumina-16S-v4-100nt-a243a1  129596  74983\n\n$ redbiom summarize contexts | head -n 1\nContextName SamplesWithData FeaturesWithData    Description\n</code></pre>\n<p>To reduce typing later, let's just pick a context and store it as an environment variable:</p>\n<pre><code>$ export ctx=Pick_closed-reference_OTUs-Greengenes-illumina-16S-v4-5c6506\n</code></pre>\n<p>...and now we can grab some data:</p>\n<pre><code>$ redbiom search metadata beer | redbiom fetch samples --context $ctx --output example.biom\n$ biom summarize-table -i example.biom | head\nNum samples: 37\nNum observations: 3653\nTotal count: 2205617\nTable density (fraction of non-zero values): 0.091\n\nCounts/sample summary:\n Min: 1717.0\n Max: 208223.0\n Median: 59224.000\n Mean: 59611.270\n</code></pre>\n<p>We probably also want to get the sample metadata:</p>\n<pre><code>$ redbiom search metadata beer | redbiom fetch sample-metadata --output example.txt --context $ctx\n</code></pre>\n<p>You might note that the total number of samples found by the metadata search is not the same as the number of samples found by the sample data fetch. The sample information is distinct from the sample preparation, and data processing: just because there is sample information does not mean a given sample has (for instance) 16S V4 sequence data associated with it.</p>\n<p>The query structures for metadata are fairly permissive, and there are actually two types of queries that can be performed. The structure is as follows: <code>&lt;set operations&gt; where &lt;value restrictions&gt;</code>. The <code>&lt;set operations&gt;</code> work by finding all samples with that contain a given word, which can be combined together. For the set queries, <code>&amp;</code> performs an intersection of the sample IDs, <code>|</code> a union, and <code>-</code> a difference:</p>\n<pre><code>$ redbiom search metadata \"soil &amp; europe where ph &lt; 7\" | wc -l\n5521\n</code></pre>\n<p><strong>IMPORTANT</strong>: just because a sample may have a word associated with it, does not mean that word is used as you may expect. In the example below, we're counting the number of samples by their described <code>sample_type</code> value. We are working to improve the search functionality, and it is important for users to scrutinize their results:</p>\n<pre><code>$ redbiom search metadata \"soil &amp; europe where ph &lt; 7\" | redbiom summarize samples --category sample_type  | head\nsoil    1978\nXXQIITAXX   1686\nSoil    612\nfresh water 519\npeat    192\nsebum   99\nbodily fluid    81\nbelly   41\nbiofilm 39\nab_liq  38\n</code></pre>\n<h3>Search by feature</h3>\n<p>We can also use redbiom to search for samples containing features of interest. Let's operate off our example table from the metadata search above. What we're going to do is find all samples in Qiita that contain any of the a handful of the feature IDs. In this particular example, let's just grab 10 arbitrary IDs:</p>\n<pre><code>$ biom table-ids -i example.biom --observations | head\n4449525\n4420570\n471180\n815819\n4235445\n1108951\n519367\n12364\n4454153\n4227110\n</code></pre>\n<p>...and then let's pipe them back into redbiom to search for other samples in our context which contain those same features:</p>\n<pre><code>$ biom table-ids -i example.biom --observations | head | redbiom search features --context $ctx | wc -l\n   43133\n\n$ biom table-ids -i example.biom --observations | head | redbiom search features --context $ctx | head\n3759_10172.3338\n2923_10317.000017653\n2096_1716.McG.PAPrS17\n2015_1034.CHB1\n2150_755.SSFA.L1.D30.07.06.11.lane1.NoIndex.L001\n2150_755.LSSF.ALPHA.D20.14.07.11.lane1.NoIndex.L001\n26483_10317.000007237\n3788_10119.MT.741\n2112_1774.527.Skin.Puer\n2102_1734.BD.ERD510\n</code></pre>\n<h3>Search by taxon</h3>\n<p>One thing you might want to do is find features based on taxonomy. We can do this by searching for a taxon:</p>\n<pre><code>$ redbiom search taxon g__Roseburia --context $ctx | wc -l\n     108\n</code></pre>\n<p>What we get back are the feature IDs that are of that taxon. We can then take those feature IDs and feed them back into redbiom. So for instance, let's say we wanted to find all samples which contain a Roseburia feature:</p>\n<pre><code>$ redbiom search taxon g__Roseburia --context $ctx | redbiom search features --context $ctx | wc -l\n   37539\n</code></pre>\n<p><strong>IMPORTANT</strong> not all contexts necessarily have taxonomy, and taxonomy may not make sense for a context (e.g., if it contains KEGG Orthologous group features).</p>\n<h3>Retrieving pre-selected samples</h3>\n<p>In additional to allowing you to search based on specific metadata or features, you can also retrieve a list of samples based on the sample ID. For instance, we might want to get a list of all the samples with cider associated with them, and then potentially access only these samples later, after a database update.</p>\n<p>To do this, we can pulldown a list of the first five samples with cider associated.</p>\n<pre><code>$ redbiom search metadata cider | head -5 &gt; cider.txt\n$ head cider.txt\n    11261.CW91.R1.T7\n    11261.CW130.S.F2.T7\n    11261.CW120.F1.T4\n    11261.CW75.R3.T1\n    11261.CW125.F3.T5 \n</code></pre>\n<p>Then, we can use this list of samples to retrieve the biom table. The text file simply needs to be a list of sample IDs in the databse, one per line.</p>\n<pre><code>$ redbiom fetch samples --from cider.txt --context $ctx --output cider.biom\n$ biom summarize-table -i cider.biom | head\nNum samples: 5\nNum observations: 281\nTotal count: 173,579\nTable density (fraction of non-zero values): 0.396\n\nCounts/sample summary:\n Min: 25,936.000\n Max: 38,900.000\n Median: 36,602.000\n Mean: 34,715.800\n</code></pre>\n<h3>Summarizations</h3>\n<p>We found a lot of samples that contain Roseburia. That isn't too surprising since Qiita contains a lot of fecal samples. How many? In this next example, we're taking all of the feature IDs associated with Roseburia, then finding all of the samples which contain that taxon, followed by binning each sample by their <code>sample_type</code> category value, and finally we're taking just the top 10 entries. You can see that the metadata are a bit noisy.</p>\n<pre><code>$ redbiom search taxon g__Roseburia --context $ctx | redbiom search features --context $ctx | redbiom summarize samples --category sample_type | head\nStool   13251\nstool   11416\nXXQIITAXX   1029\ntanker milk 984\nbiopsy  930\nFloor   622\nskin    615\nStool_Stabilizer    566\ncontrol blank   520\nMouth   420\n</code></pre>\n<p>We can still work through the noise though. Let's take our samples we found that contain Roseburia, and only select the ones that appear to obviously be fecal. Instead of summarizing as we did in our last example, we're going to \"select\" the samples in which <code>sample_type</code> is either \"Stool\" or \"stool\". (as this command is getting long, we'll break it up with \\):</p>\n<pre><code>$ redbiom search taxon g__Roseburia --context $ctx | \\\n    redbiom search features --context $ctx | \\\n    redbiom select samples-from-metadata --context $ctx \"where sample_type in ('Stool', 'stool')\" | \\\n    wc -l\n   24667\n</code></pre>\n<p>And last, we can grab the data for those samples. Fetching data for 24,667 samples can take a few minutes, so for the purpose of the example, let's just grab the ones associated with skin. Please note the \"ambiguity\" on the output, more in a second on that:</p>\n<pre><code>$ redbiom search taxon g__Roseburia --context $ctx | \\\n    redbiom search features --context $ctx | \\\n    redbiom select samples-from-metadata --context $ctx \"where sample_type=='skin'\" | \\\n    redbiom fetch samples --context $ctx --output roseburia_example.biom\n16 sample ambiguities observed. Writing ambiguity mappings to: roseburia_example.biom.ambiguities\n</code></pre>\n<p>Ambiguities can arise if the same sample was processed multiple times as might happen with a technical replicate. It is the same physical sample, but it may have been processed multiple times. The <code>.ambiguities</code> file is in JSON and contains a mapping of what IDs map to the same sample.</p>\n<h3>Load some data (i.e., if you are running your own server)</h3>\n<p>To make use of this cache, we need to load things. Loading can be done in parallel. First, we'll load up metadata. This will create keys in Redis which describe all of the columns associated with a sample (e.g., <code>metadata:categories:&lt;sample_id&gt;</code>, hash buckets for each category and sample combination (e.g., <code>metadata:category:&lt;category_name&gt;</code> as the hash and <code>&lt;sample_id&gt;</code> as the field), a set of all known categories (e.g., <code>metadata:categories-represented</code>), and a set of all known sample IDs (e.g., <code>metadata:samples-represented</code>):</p>\n<pre><code>$ redbiom admin load-sample-metadata --metadata path/to/qiime/compat/mapping.txt\n</code></pre>\n<p>redbiom supports one to many mappings between sample metadata and actual sample data. This is done as there may be multiple types of processing performed on the same data (e.g., different nucleotide trims). Or, a physical sample may have been run through multiple protocols (e.g., 16S, WGS, etc). So before we load any data, we need to create a context for the data to be placed. The following action will add an entry into the <code>state:contexts</code> hash bucket keyed by <code>name</code> and valued by <code>description</code>:</p>\n<pre><code>$ redbiom admin create-context --name deblur-100nt --description \"16S V4 Caporaso et al data deblurred at 100nt\"\n</code></pre>\n<p>Next, we'll load up associations between every single feature in a BIOM table to all the samples its found in. This will create Redis sets and can be accessed using keys of the form <code>&lt;context_name&gt;:samples:&lt;feature_id&gt;</code>. Note that we specify the context we're loading into.</p>\n<pre><code>$ redbiom admin load-features --context deblur-100nt --table /path/to/biom/table.biom\n</code></pre>\n<p>Last, let's load up all of the BIOM table data. We'll only store the non-zero values, and we'll encode the sample data into something simple so that it goes in as just a string to Redis. Important: we only support storing count data right now, not floating point. The keys created are of the form <code>&lt;context_name&gt;:sample:&lt;redbiom_id&gt;</code>. To reduce space, we reindex the feature IDs as things like sOTUs tend to be very long in name. The mapping is stable over all tables loaded (ie the same feature has the same index), and is stored under <code>&lt;context_name&gt;:feature-index</code>. Because we need to update the index, this operation cannot be done in parallel however the code is setup with a redis-based mutex so it's okay to queue up multiple loads.</p>\n<pre><code>$ redbiom load-sample-data --context deblur-100nt --table /path/to/biom/table.biom\n</code></pre>\n<h1>Caveats</h1>\n<p>Redbiom is still in heavy active development. At this time, there are still some important caveats.</p>\n<ul>\n<li>\n<p>Metadata values containing <code>/</code> characters cannot be represented the forward slash is used to denote arguments with Webdis. At present, these values are omitted. This is more generally a problem for dates which have not been normalized into an ISO standard. See issue #9.</p>\n</li>\n<li>\n<p>Metadata values which appear to be null are not stored. The set of values currently considered nulls are:</p>\n<p>{'Not applicable', 'Unknown', 'Unspecified', 'Missing: Not collected',\n'Missing: Not provided', 'Missing: Restricted access',\n'null', 'NULL', 'no_data', 'None', 'nan'}</p>\n</li>\n<li>\n<p>Sample IDs must be QIIME compatible.</p>\n</li>\n</ul>\n<h1>Design</h1>\n<h3>Python and testing</h3>\n<p>There are a few design decisions in place which deviate from some other typical Python projects. First off, the majority of <code>import</code>s are deferred. The motivating force here is to minimize overhead on load as to provide a responsive user interface -- deferred imports are the most straight forward way to accomplish that goal.</p>\n<p>The test harness is broken into multiple components, and are driven by a <code>Makefile</code>. This was done initially to be pragmatic as it was easier to write integration tests than unit tests for the <code>click</code> commands. These tests can be found in <code>test.sh</code> which is composed of \"positive\" tests and <code>test_failures.sh</code> which is composed of \"negative\" tests. The difference being that the positive tests will fail if any command results in a nonzero exit status, whereas the negative tests expect a nonzero exit status (and really, the decision was to avoid unsetting \"-e\"). Additional tests which validate some of the Redis contents can be found in <code>redbiom/tests/test_rest.py</code>. These are neither unit tests nor integration tests, but simply exercise the behind-the-scenes REST interface. Last, there are a suite of unit tests placed under <code>redbiom/tests/</code>.</p>\n<h3>Redis data organization</h3>\n<p>Because redbiom is currently in alpha, and its data model is subject to change, we are holding off an indepth description of it. That being said, the API methods in general outline the Redis commands issued within their docstrings and can be used to guide interaction.</p>\n<p>The key structures used are in the following forms:</p>\n<ul>\n<li><code>state:*</code> redbiom state information such as context details</li>\n<li><code>metadata:category:&lt;category&gt;</code> the samples and metadata values for the category</li>\n<li><code>metadata:categories:&lt;sample-id&gt;</code> the metadata categories known to exist for a given sample</li>\n<li><code>metadata:text-search:&lt;stem&gt;</code> the samples associated with a given metadata value stem</li>\n<li><code>metadata:category-search:&lt;stem&gt;</code> the categories associated with a given stem</li>\n<li><code>metadata:samples-represented</code> the samples that are represented by the metadata</li>\n<li><code>&lt;context&gt;:sample:&lt;redbiom-id&gt;</code> the sample data within a context</li>\n<li><code>&lt;context&gt;:feature:&lt;feature-id&gt;</code> the feature data within a context</li>\n<li><code>&lt;context&gt;:samples-represented</code> the samples within the context which contain BIOM data</li>\n<li><code>&lt;context&gt;:sample-index</code> a mapping between a sample ID and a context-unique stable integer</li>\n<li><code>&lt;context&gt;:sample-index-inverted</code> a mapping between a context-unique stable integer and its associated sample ID</li>\n<li><code>&lt;context&gt;:features-represented</code> the reatures represented within the context</li>\n<li><code>&lt;context&gt;:feature-index</code> a mapping between a feature ID and a context-unique stable integer</li>\n<li><code>&lt;context&gt;:feature-index-inverted</code> a mapping between a context-unique stable integer and its associated feature ID</li>\n<li><code>&lt;context&gt;:taxonomy-children:&lt;taxon&gt;</code> the children of a taxon</li>\n<li><code>&lt;context&gt;:taxonomy-parents</code> child to parent taxon mappings</li>\n</ul>\n\n          </div>"}, "last_serial": 6100785, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "9af6b21ae4879e6d78f8632e16502a0c", "sha256": "23677f724b32821352f732ddc0571e4ecd445e27a51d9228c4877129a02d9e50"}, "downloads": -1, "filename": "redbiom-0.1.0.tar.gz", "has_sig": false, "md5_digest": "9af6b21ae4879e6d78f8632e16502a0c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 65482, "upload_time": "2017-06-08T01:24:52", "upload_time_iso_8601": "2017-06-08T01:24:52.903414Z", "url": "https://files.pythonhosted.org/packages/0d/a8/73ee12e7f0674a827bdc2b9c124021852d4d526ba1f07d8f76210ca63545/redbiom-0.1.0.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "a65e9cde6c63d0a1cf6c706f97015c40", "sha256": "ec2d7397efc127fadf9dc34b046d161d8a05ee6202094e78350c9f243ab4e3d9"}, "downloads": -1, "filename": "redbiom-0.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "a65e9cde6c63d0a1cf6c706f97015c40", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 60506, "upload_time": "2019-02-19T23:38:37", "upload_time_iso_8601": "2019-02-19T23:38:37.459040Z", "url": "https://files.pythonhosted.org/packages/9b/48/8ee0f03e1c3c9caf1e881b1b932177aff6b86ef3ace564fd318aa31dfdf0/redbiom-0.3.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6627a3c62965310d5ab9004e2f86701a", "sha256": "e7f27d11555c73abad9413e5985ce1144a0cc78ac30054fc4ce3815c45f9bc9a"}, "downloads": -1, "filename": "redbiom-0.3.0.tar.gz", "has_sig": false, "md5_digest": "6627a3c62965310d5ab9004e2f86701a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 71240, "upload_time": "2019-02-19T23:38:38", "upload_time_iso_8601": "2019-02-19T23:38:38.962811Z", "url": "https://files.pythonhosted.org/packages/c2/e6/90f74dd48077ecc65d5b8913851da31cff80373a897918c86989ce3d5394/redbiom-0.3.0.tar.gz", "yanked": false}], "0.3.1": [{"comment_text": "", "digests": {"md5": "1b58d865f3ec9dff478a56515d5cbe92", "sha256": "9a4ae82cbd56430e1a7e24b2845e45a8036bc402655d0c97b45a8c54762628d5"}, "downloads": -1, "filename": "redbiom-0.3.1-py3-none-any.whl", "has_sig": false, "md5_digest": "1b58d865f3ec9dff478a56515d5cbe92", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 60882, "upload_time": "2019-02-19T23:56:27", "upload_time_iso_8601": "2019-02-19T23:56:27.457713Z", "url": "https://files.pythonhosted.org/packages/b1/c6/c4eeddd5d2d14acf3ea83bac6c7befe9d94286b29d09632e940075629096/redbiom-0.3.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "54e565743c678ace0928f3100d3a41ba", "sha256": "f265467c76d6211148fa1a1423d6fc9b398da294d0c93249bb8398302ff309f4"}, "downloads": -1, "filename": "redbiom-0.3.1.tar.gz", "has_sig": false, "md5_digest": "54e565743c678ace0928f3100d3a41ba", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 72311, "upload_time": "2019-02-19T23:56:28", "upload_time_iso_8601": "2019-02-19T23:56:28.802285Z", "url": "https://files.pythonhosted.org/packages/62/f7/ef44b20300e00dc2c1ecc22958a329f1dc5070d2b6b4716c8cc75b672aa7/redbiom-0.3.1.tar.gz", "yanked": false}], "0.3.2": [{"comment_text": "", "digests": {"md5": "ad25979153a8fb1294fe3c8bd086c7d5", "sha256": "a8e52780024441f3e750aed6cb9f9e557460c1dc7c5bf846aebd81925709abd7"}, "downloads": -1, "filename": "redbiom-0.3.2.tar.gz", "has_sig": false, "md5_digest": "ad25979153a8fb1294fe3c8bd086c7d5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 412738, "upload_time": "2019-03-28T17:51:13", "upload_time_iso_8601": "2019-03-28T17:51:13.738463Z", "url": "https://files.pythonhosted.org/packages/08/e5/40a0ec34cc31d7bc48e64eb9645fb42630d67345e0b4c2949793cbb376de/redbiom-0.3.2.tar.gz", "yanked": false}], "0.3.4": [{"comment_text": "", "digests": {"md5": "1b8167a95e02f946d22ac4e18927a627", "sha256": "d7d45684b679b107bc3ca978022fbf4852ff138eb6e5e1a66fc42583693957d3"}, "downloads": -1, "filename": "redbiom-0.3.4.tar.gz", "has_sig": false, "md5_digest": "1b8167a95e02f946d22ac4e18927a627", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36197749, "upload_time": "2019-10-18T20:55:16", "upload_time_iso_8601": "2019-10-18T20:55:16.999415Z", "url": "https://files.pythonhosted.org/packages/d1/77/98a05beb4a0df25f73e547425228639534e6dc3aa8f68f7a11af17c4e49f/redbiom-0.3.4.tar.gz", "yanked": false}], "0.3.5": [{"comment_text": "", "digests": {"md5": "47a6ce1df1ac131af57b7a7c023d7b0f", "sha256": "bbbb45c066f4d2ff185d4cff2b681d96a6fb3e4a84c85b75c372f82563e166b4"}, "downloads": -1, "filename": "redbiom-0.3.5.tar.gz", "has_sig": false, "md5_digest": "47a6ce1df1ac131af57b7a7c023d7b0f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36198918, "upload_time": "2019-11-08T18:32:49", "upload_time_iso_8601": "2019-11-08T18:32:49.740309Z", "url": "https://files.pythonhosted.org/packages/63/d5/a73a2b8b48fca4e00cb2969bb6cfd8fb36aab2c0584e2d137eb82b5fbc24/redbiom-0.3.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "47a6ce1df1ac131af57b7a7c023d7b0f", "sha256": "bbbb45c066f4d2ff185d4cff2b681d96a6fb3e4a84c85b75c372f82563e166b4"}, "downloads": -1, "filename": "redbiom-0.3.5.tar.gz", "has_sig": false, "md5_digest": "47a6ce1df1ac131af57b7a7c023d7b0f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36198918, "upload_time": "2019-11-08T18:32:49", "upload_time_iso_8601": "2019-11-08T18:32:49.740309Z", "url": "https://files.pythonhosted.org/packages/63/d5/a73a2b8b48fca4e00cb2969bb6cfd8fb36aab2c0584e2d137eb82b5fbc24/redbiom-0.3.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:06:00 2020"}