{"info": {"author": "Roman Neuhauser", "author_email": "neuhauser@sigpipe.cz", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Plugins", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Operating System :: OS Independent", "Operating System :: POSIX", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.4", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Software Development :: Testing"], "description": ".. vim: ft=rst sts=2 sw=2 tw=70\n.. default-role:: literal\n\n.. This file is marked up using reStructuredText.\n   Lines beginning with \"..\" are reST directives.\n   \"foo_\" or \"`foo bar`_\" is a link, defined at \".. _foo\" or\n   \".. _foo bar\".\n   \"::\" introduces a literal block (usually some form of code).\n   \"`foo`\" is some kind of identifier.\n   Suspicious backslashes in the text (\"`std::string`\\s\") are required\n   for reST to recognize the preceding character as syntax.\n\n======================================================================\n                              py-impala\n======================================================================\n----------------------------------------------------------------------\n   Import packages and modules from arbitrary directories and files\n----------------------------------------------------------------------\n\n:Author: Roman Neuhauser\n:Contact: neuhauser@sigpipe.cz\n:Copyright: This document is in the public domain.\n\n\nOverview\n========\n\nImpala is a PEP302_ protocol (`sys.meta_path` hook for the `import`\nstatement) implementation allowing the user to import packages and\nmodules from arbitrarily named directories and files.\n\n.. _PEP302: http://www.python.org/dev/peps/pep-0302/\n\n\nMotivation\n==========\n\n* Comfort and freedom in development\n* Installed interface available without installation\n\nLet's say I'm developing a Python package called `pyoneer`.  I want to\nlay the source code out like this: ::\n\n  README.txt\n  src/\n    __init__.py\n    some.py\n    more.py\n  tests/\n    ...\n\nThe question then is, how do I `import pyoneer` in the test files\n(`<workdir>/tests/...`) and have it load `<workdir>/src/__init__.py`?\nThe default `import` mechanism requires packages to live in eponymous\ndirectories.\n\nWhat's the fuss about, you ask?  I should simply rename the `src`\ndirectory to `pyoneer` or maybe `src/pyoneer`, no?\n\nIndeed, this would be tolerable, at least with top-level packages.\nHowever, if I'm working on something that will be available as\n`foo.bar.baz` after installation, I certainly don't want to wade\nthrough the desolate `src/foo/bar` to get to the source code.\n\nMaybe I could `import src` in the tests instead?  Well, tests are\na form of documentation, and doubly so with `doctest`_.  \"Proper\"\ndocumentation (README.txt, etc) can also contain snippets which\nshould be verifiable without the CUT being installed.\n\n*Impala* to the rescue!\n\n::\n\n  from os.path import abspath, dirname\n  import impala\n\n  root = abspath(dirname(__file__))\n\n  impala.register(dict(\n    pyoneer = '%s/src' % root\n  ))\n\n  import pyoneer\n\n.. _doctest: http://docs.python.org/2/library/doctest.html\n\n\nDescription\n===========\n\n`impala.register(aliases)`\n++++++++++++++++++++++++++\n\n`aliases` is a `dict` mapping from fully-qualified module/package\nnames to paths to load from.  To import a package `p` from path\n`/a/b/c`, `aliases` must include the key `p` with associated value\n`/a/b/c`, and `/a/b/c/__init__.py` must be a valid package entry\npoint.  To import a module `m` from path `/f/g/h.py`, `aliases` must\ninclude the key `m` with associated value `/f/g/h.py`.\n\nExample: ::\n\n  from os.path import abspath, dirname\n  import impala\n\n  r = dirname(abspath(__file__))\n\n  impala.register({\n    'p': '%s/a/b/c' % r,\n    'p.q': '%s/f/g/h' % r,\n    'p.q.m': '%s/k.py' % r,\n  })\n\n  import p\n  import p.q\n  import p.q.m\n\n\nLicense\n=======\n\n*py-impala* is distributed under the `MIT license`_.  See `LICENSE`\nfor details.\n\n.. _MIT license: http://opensource.org/licenses/MIT\n\n\nInstallation\n============\n\nUsing `pip` from PyPI_, the Python Package Index: ::\n\n  pip install impala\n\nFrom a checkout_ or extracted tarball: ::\n\n  python setup.py install\n\n.. _PyPI:     http://pypi.python.org/pypi\n.. _checkout: https://github.com/roman-neuhauser/py-impala.git\n\n\nDevelopment\n===========\n\nSource code and issue tracker are at Github:\n\n  https://github.com/roman-neuhauser/py-impala", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/roman-neuhauser/py-impala", "keywords": "PEP302 import", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "impala", "package_url": "https://pypi.org/project/impala/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/impala/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/roman-neuhauser/py-impala"}, "release_url": "https://pypi.org/project/impala/0.2/", "requires_dist": null, "requires_python": null, "summary": "Import packages from \"wrongly\" named directories", "version": "0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <table>\n<col>\n<col>\n<tbody>\n<tr><th>Author:</th>\n<td>Roman Neuhauser</td></tr>\n<tr><th>Contact:</th>\n<td><a href=\"mailto:neuhauser%40sigpipe.cz\">neuhauser<span>@</span>sigpipe<span>.</span>cz</a></td></tr>\n<tr><th>Copyright:</th>\n<td>This document is in the public domain.</td></tr>\n</tbody>\n</table>\n<div id=\"overview\">\n<h2>Overview</h2>\n<p>Impala is a <a href=\"http://www.python.org/dev/peps/pep-0302/\" rel=\"nofollow\">PEP302</a> protocol (<tt>sys.meta_path</tt> hook for the <tt>import</tt>\nstatement) implementation allowing the user to import packages and\nmodules from arbitrarily named directories and files.</p>\n</div>\n<div id=\"motivation\">\n<h2>Motivation</h2>\n<ul>\n<li>Comfort and freedom in development</li>\n<li>Installed interface available without installation</li>\n</ul>\n<p>Let\u2019s say I\u2019m developing a Python package called <tt>pyoneer</tt>.  I want to\nlay the source code out like this:</p>\n<pre>README.txt\nsrc/\n  __init__.py\n  some.py\n  more.py\ntests/\n  ...\n</pre>\n<p>The question then is, how do I <tt>import pyoneer</tt> in the test files\n(<tt><span class=\"pre\">&lt;workdir&gt;/tests/...</span></tt>) and have it load <tt><span class=\"pre\">&lt;workdir&gt;/src/__init__.py</span></tt>?\nThe default <tt>import</tt> mechanism requires packages to live in eponymous\ndirectories.</p>\n<p>What\u2019s the fuss about, you ask?  I should simply rename the <tt>src</tt>\ndirectory to <tt>pyoneer</tt> or maybe <tt>src/pyoneer</tt>, no?</p>\n<p>Indeed, this would be tolerable, at least with top-level packages.\nHowever, if I\u2019m working on something that will be available as\n<tt>foo.bar.baz</tt> after installation, I certainly don\u2019t want to wade\nthrough the desolate <tt>src/foo/bar</tt> to get to the source code.</p>\n<p>Maybe I could <tt>import src</tt> in the tests instead?  Well, tests are\na form of documentation, and doubly so with <a href=\"http://docs.python.org/2/library/doctest.html\" rel=\"nofollow\">doctest</a>.  \u201cProper\u201d\ndocumentation (README.txt, etc) can also contain snippets which\nshould be verifiable without the CUT being installed.</p>\n<p><em>Impala</em> to the rescue!</p>\n<pre>from os.path import abspath, dirname\nimport impala\n\nroot = abspath(dirname(__file__))\n\nimpala.register(dict(\n  pyoneer = '%s/src' % root\n))\n\nimport pyoneer\n</pre>\n</div>\n<div id=\"description\">\n<h2>Description</h2>\n<h2 id=\"impala-register-aliases\"><span class=\"section-subtitle\"><tt>impala.register(aliases)</tt></span></h2>\n<p><tt>aliases</tt> is a <tt>dict</tt> mapping from fully-qualified module/package\nnames to paths to load from.  To import a package <tt>p</tt> from path\n<tt>/a/b/c</tt>, <tt>aliases</tt> must include the key <tt>p</tt> with associated value\n<tt>/a/b/c</tt>, and <tt>/a/b/c/__init__.py</tt> must be a valid package entry\npoint.  To import a module <tt>m</tt> from path <tt>/f/g/h.py</tt>, <tt>aliases</tt> must\ninclude the key <tt>m</tt> with associated value <tt>/f/g/h.py</tt>.</p>\n<p>Example:</p>\n<pre>from os.path import abspath, dirname\nimport impala\n\nr = dirname(abspath(__file__))\n\nimpala.register({\n  'p': '%s/a/b/c' % r,\n  'p.q': '%s/f/g/h' % r,\n  'p.q.m': '%s/k.py' % r,\n})\n\nimport p\nimport p.q\nimport p.q.m\n</pre>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p><em>py-impala</em> is distributed under the <a href=\"http://opensource.org/licenses/MIT\" rel=\"nofollow\">MIT license</a>.  See <tt>LICENSE</tt>\nfor details.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>Using <tt>pip</tt> from <a href=\"http://pypi.python.org/pypi\" rel=\"nofollow\">PyPI</a>, the Python Package Index:</p>\n<pre>pip install impala\n</pre>\n<p>From a <a href=\"https://github.com/roman-neuhauser/py-impala.git\" rel=\"nofollow\">checkout</a> or extracted tarball:</p>\n<pre>python setup.py install\n</pre>\n</div>\n<div id=\"development\">\n<h2>Development</h2>\n<p>Source code and issue tracker are at Github:</p>\n<blockquote>\n<a href=\"https://github.com/roman-neuhauser/py-impala\" rel=\"nofollow\">https://github.com/roman-neuhauser/py-impala</a></blockquote>\n</div>\n\n          </div>"}, "last_serial": 1271329, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "2975fcfb27ba3fb8a7cd899cd7706b5f", "sha256": "1d76e7a6c114818109f0d9fc1cf996dbfc5a0de50b73accbed3cad74d3639456"}, "downloads": -1, "filename": "impala-0.1.1.tar.gz", "has_sig": false, "md5_digest": "2975fcfb27ba3fb8a7cd899cd7706b5f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8786, "upload_time": "2013-10-17T16:07:08", "upload_time_iso_8601": "2013-10-17T16:07:08.553736Z", "url": "https://files.pythonhosted.org/packages/5c/fb/2cded2b842fb1a518fe0873269b93dfedbb0891d13e963a5d4249dac7ed1/impala-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "df91ac35e0f5b0dbf7b0af04d7258995", "sha256": "744033b19b091a1e3b853dbfc25425d728ff1ab6d6390d0cc38b476190f349ca"}, "downloads": -1, "filename": "impala-0.1.2.tar.gz", "has_sig": false, "md5_digest": "df91ac35e0f5b0dbf7b0af04d7258995", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8589, "upload_time": "2014-03-03T12:16:25", "upload_time_iso_8601": "2014-03-03T12:16:25.626240Z", "url": "https://files.pythonhosted.org/packages/17/9d/9d50d68051cb9f373972ec2b3c553a7c1eb5252f8d6e6ef09a84f5d25c1e/impala-0.1.2.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "7dc7cf9158de5626a3ec06d7954939df", "sha256": "f7b1f7f34af30ea9912c4afd65dc0c76c0ab30aa1fe64d0c81f72f31f5720523"}, "downloads": -1, "filename": "impala-0.2.tar.gz", "has_sig": false, "md5_digest": "7dc7cf9158de5626a3ec06d7954939df", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8827, "upload_time": "2014-10-15T14:24:01", "upload_time_iso_8601": "2014-10-15T14:24:01.980770Z", "url": "https://files.pythonhosted.org/packages/eb/0b/bd4f93aecc6c09f00085678f98d386f9a09ce5d8f8206110c1e549e35b0a/impala-0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7dc7cf9158de5626a3ec06d7954939df", "sha256": "f7b1f7f34af30ea9912c4afd65dc0c76c0ab30aa1fe64d0c81f72f31f5720523"}, "downloads": -1, "filename": "impala-0.2.tar.gz", "has_sig": false, "md5_digest": "7dc7cf9158de5626a3ec06d7954939df", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8827, "upload_time": "2014-10-15T14:24:01", "upload_time_iso_8601": "2014-10-15T14:24:01.980770Z", "url": "https://files.pythonhosted.org/packages/eb/0b/bd4f93aecc6c09f00085678f98d386f9a09ce5d8f8206110c1e549e35b0a/impala-0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:56:35 2020"}