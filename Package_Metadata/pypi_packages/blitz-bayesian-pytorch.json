{"info": {"author": "Pi Esposito", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "Programming Language :: Python :: 3.7"], "description": "# Blitz - Bayesian Layers in Torch Zoo\nBLiTZ is a simple and extensible library to create Bayesian Neural Network Layers (based on whats proposed in [Weight Uncertainty in Neural Networks paper](https://arxiv.org/abs/1505.05424)) on PyTorch. By using BLiTZ layers and utils, you can add uncertanity and gather the complexity cost of your model in a simple way that does not affect the interaction between your layers, as if you were using standard PyTorch.\n\nBy using our core weight sampler classes, you can extend and improve this library to add uncertanity to a bigger scope of layers as you will in a well-integrated to PyTorch way. Also pull requests are welcome.\n\nOur objective is empower people to apply Bayesian Deep Learning by focusing rather on their idea, and not the hard-coding part. \n\n# Index\n * [Install](#Install)\n * [Documentation](#Documentation)\n * [A simple example for regression](#A-simple-example-for-regression)\n   * [Importing the necessary modules](#Importing-the-necessary-modules)\n   * [Loading and scaling data](#Loading-and-scaling-data)\n   * [Creating our variational regressor class](#Creating-our-variational-regressor-class)\n   * [Defining a confidence interval evaluating function](#Defining-a-confidence-interval-evaluating-function)\n   * [Creating our regressor and loading data](#Creating-our-regressor-and-loading-data)\n   * [Our main training and evaluating loop](#Our-main-training-and-evaluating-loop)\n * [Bayesian Deep Learning in a Nutshell](#Bayesian-Deep-Learning-in-a-Nutshell)\n   * [First of all, a deterministic NN layer linear-transformation](#First-of-all,-a-deterministic-NN-layer-linear-transformation)\n   * [The purpose of Bayesian Layers](#The-purpose-of-Bayesian-Layers)\n   * [Weight sampling on Bayesian Layers](#Weight-sampling-on-Bayesian-Layers)\n   * [It is possible to optimize our trainable weights](#It-is-possible-to-optimize-our-trainable-weights)\n   * [It is also true that there is complexity cost function differentiable along its variables](#It-is-also-true-that-there-is-complexity-cost-function-differentiable-along-its-variables)\n   * [To get the whole cost function at the nth sample](#To-get-the-whole-cost-function-at-the-nth-sample)\n   * [Some notes and wrap up](#Some-notes-and-wrap-up)\n * [References](#References)\n\n\n## Install\n\n\nTo install it, just git-clone it and pip-install it locally:\n\n```\nconda create -n blitz python=3.6\nconda activate blitz\ngit clone https://github.com/piEsposito/blitz-bayesian-deep-learning.git\ncd blitz-bayesian-deep-learning\npip install .\n```\n\nLater on, we will submit it to **Pypi**.\n\n## Documentation\n\nDocumentation for our layers, weight (and prior distribution) sampler and utils:\n * [Bayesian Layers](doc/layers.md)\n * [Weight and prior distribution samplers](doc/samplers.md)\n * [Utils (for easy integration with PyTorch)](doc/utils.md)\n * [Losses](doc/losses.md)\n\n## A simple example for regression\n\n(You can see it for your self by running [this example](blitz/examples/bayesian_regression_boston.py) on your machine).\n\nWe will now see how can Bayesian Deep Learning be used for regression in order to gather confidence interval over our datapoint rather than a pontual continuous value prediction. Gathering a confidence interval for your prediction may be even a more useful information than a low-error estimation. \n\nI sustain my argumentation on the fact that, with good/high prob a confidence interval, you can make a more reliable decision than with a very proximal estimation on some contexts: if you are trying to get profit from a trading operation, for example, having a good confidence interval may lead you to know if, at least, the value on which the operation wil procees will be lower (or higher) than some determinate X.\n\nKnowing if a value will be, surely (or with good probability) on a determinate interval can help people on sensible decision more than a very proximal estimation that, if lower or higher than some limit value, may cause loss on a transaction. The point is that, sometimes, knowing if there will be profit may be more useful than measuring it.\n\nIn order to demonstrate that, we will create a Bayesian Neural Network Regressor for the Boston-house-data toy dataset, trying to create confidence interval (CI) for the houses of which the price we are trying to predict. We will perform some scaling and the CI will be about 75%. It will be interesting to see that about 90% of the CIs predicted are lower than the high limit OR (inclusive) higher than the lower one.\n\n## Importing the necessary modules\nDespite from the known modules, we will bring from BLiTZ athe `variational_estimator`decorator, which helps us to handle the BayesianLinear layers on the module keeping it fully integrated with the rest of Torch, and, of course, `BayesianLinear`, which is our layer that features weight uncertanity.\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nimport numpy as np\n\nfrom blitz.modules import BayesianLinear\nfrom blitz.utils import variational_estimator\n\nfrom sklearn.datasets import load_boston\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\n```\n\n## Loading and scaling data\n\nNothing new under the sun here, we are importing and standard-scaling the data to help with the training.\n\n```python\nX, y = load_boston(return_X_y=True)\nX = StandardScaler().fit_transform(X)\ny = StandardScaler().fit_transform(np.expand_dims(y, -1))\n\nX_train, X_test, y_train, y_test = train_test_split(X,\n                                                    y,\n                                                    test_size=.25,\n                                                    random_state=42)\n\n\nX_train, y_train = torch.tensor(X_train).float(), torch.tensor(y_train).float()\nX_test, y_test = torch.tensor(X_test).float(), torch.tensor(y_test).float()\n```\n\n# Creating our variational regressor class\n\nWe can create our class with inhreiting from nn.Module, as we would do with any Torch network. Our decorator introduces the methods to handle the bayesian features, as calculating the complexity cost of the Bayesian Layers and doing many feedforwards (sampling different weights on each one) in order to sample our loss.\n\n```python\n@variational_estimator\nclass BayesianRegressor(nn.Module):\n    def __init__(self, input_dim, output_dim):\n        super().__init__()\n        #self.linear = nn.Linear(input_dim, output_dim)\n        self.blinear1 = BayesianLinear(input_dim, 512)\n        self.blinear2 = BayesianLinear(512, output_dim)\n\n    def forward(self, x):\n        x_ = self.blinear1(x)\n        return self.blinear2(x_)\n```\n\n# Defining a confidence interval evaluating function\n\nThis function does create a confidence interval for each prediction on the batch on which we are trying to sample the label value. We then can measure the accuracy of our predictions by seeking how much of the prediciton distributions did actually include the correct label for the datapoint.\n\n\n```python\ndef evaluate_regression(regressor,\n                        X,\n                        y,\n                        samples = 100,\n                        std_multiplier = 2):\n    preds = [regressor(X) for i in range(samples)]\n    preds = torch.stack(preds)\n    means = preds.mean(axis=0)\n    stds = preds.std(axis=0)\n    ci_upper = means + (std_multiplier * stds)\n    ci_lower = means - (std_multiplier * stds)\n    ic_acc = (ci_lower <= y) * (ci_upper >= y)\n    ic_acc = ic_acc.float().mean()\n    return ic_acc, (ci_upper >= y).float().mean(), (ci_lower <= y).float().mean()\n```\n\n# Creating our regressor and loading data\n\nNotice here that we create our `BayesianRegressor` as we would do with other neural networks.\n\n```python\nregressor = BayesianRegressor(13, 1)\noptimizer = optim.SGD(regressor.parameters(), lr=0.001)\ncriterion = torch.nn.MSELoss()\n\nds_train = torch.utils.data.TensorDataset(X_train, y_train)\ndataloader_train = torch.utils.data.DataLoader(ds_train, batch_size=16, shuffle=True)\n\nds_test = torch.utils.data.TensorDataset(X_test, y_test)\ndataloader_test = torch.utils.data.DataLoader(ds_test, batch_size=16, shuffle=True)\n```\n\n## Our main training and evaluating loop\n\nWe do a training loop that only differs from a common torch training by having its loss sampled by its sample_elbo method. All the other stuff can be done normally, as our purpose with BLiTZ is to ease your life on iterating on your data with different Bayesian NNs without trouble.\n\nHere is our very simple training loop:\n\n```python\niteration = 0\nfor epoch in range(100):\n    for i, (datapoints, labels) in enumerate(dataloader_train):\n        optimizer.zero_grad()\n\n        loss = regressor.sample_elbo(inputs=datapoints,\n                           labels=labels,\n                           criterion=criterion,\n                           sample_nbr=3)\n        loss.backward()\n        optimizer.step()\n\n        iteration += 1\n        if iteration%100==0:\n            ic_acc, under_ci_upper, over_ci_lower = evaluate_regression(regressor,\n                                                                        X_test,\n                                                                        y_test,\n                                                                        samples=25,\n                                                                        std_multiplier=3)\n\n            print(\"CI acc: {:.2f}, CI upper acc: {:.2f}, CI lower acc: {:.2f}\".format(ic_acc, under_ci_upper, over_ci_lower))\n            print(\"Loss: {:.4f}\".format(loss))\n```\n\n## Bayesian Deep Learning in a Nutshell\nA very fast explanation of how is uncertainity introduced in Bayesian Neural Networks and how we model its loss in order to objectively improve the confidence over its prediction and reduce the variance without dropout. \n\n## First of all, a deterministic NN layer linear transformation\n\nAs we know, on deterministic (non bayesian) neural network layers, the trainable parameters correspond directly to the weights used on its linear transformation of the previous one (or the input, if it is the case). It corresponds to the following equation:\n\n\n![equation](https://latex.codecogs.com/gif.latex?a^{(i&plus;1)}&space;=&space;W^{(i&plus;1)}\\cdot&space;z^{(i)}&space;&plus;&space;b^{(i&plus;1)}) \n\n*(Z correspond to the activated-output of the layer i)*\n\n## The purpose of Bayesian Layers\n\nBayesian layers seek to introduce uncertainity on its weights by sampling them from a distribution parametrized by trainable variables on each feedforward operation. \n\nThis allows we not just to optimize the performance metrics of the model, but also gather the uncertainity of the network predictions over a specific datapoint (by sampling it much times and measuring the dispersion) and aimingly reduce as much as possible the variance of the network over the prediction, making possible to know how much of incertainity we still have over the label if we try to model it in function of our specific datapoint.\n\n## Weight sampling on Bayesian Layers\nTo do so, on each feedforward operation we sample the parameters of the linear transformation with the following equations (where **\u03c1** parametrizes the standard deviation and **\u03bc** parametrizes the mean for the samples linear transformation parameters) :\n\nFor the weights:\n\n![equation](https://latex.codecogs.com/gif.latex?W^{(i)}_{(n)}&space;=&space;\\mathcal{N}(0,1)&space;*&space;log(1&space;&plus;&space;\\rho^{(i)}&space;)&space;&plus;&space;\\mu^{(i)})\n\n*Where the sampled W corresponds to the weights used on the linear transformation for the ith layer on the nth sample.*\n\nFor the biases:\n\n![equation](https://latex.codecogs.com/gif.latex?b^{(i)}_{(n)}&space;=&space;\\mathcal{N}(0,1)&space;*&space;log(1&space;&plus;&space;\\rho^{(i)}&space;)&space;&plus;&space;\\mu^{(i)})\n\n*Where the sampled b corresponds to the biases used on the linear transformation for the ith layer on the nth sample.*\n\n## It is possible to optimize our trainable weights\n\nEven tough we have a random multiplier for our weights and biases, it is possible to optimize them by, given some differentiable function of the weights sampled and trainable parameters (in our case, the loss), summing the derivative of the function relative to both of them:\n\n1. Let ![equation](https://latex.codecogs.com/gif.latex?\\epsilon&space;=&space;\\mathcal{N}(0,1))\n2. Let ![equation](https://latex.codecogs.com/gif.latex?\\theta&space;=&space;(\\rho,&space;\\mu))\n3. Let ![equation](https://latex.codecogs.com/gif.latex?w&space;=&space;\\mu&space;&plus;&space;\\log({1&space;&plus;&space;e^{\\rho}})&space;*&space;\\epsilon)\n4. Let ![equation](https://latex.codecogs.com/gif.latex?f(w,&space;\\theta)) be differentiable relative to its variables\n\nTherefore:\n\n5. ![equation](https://latex.codecogs.com/gif.latex?\\Delta_{\\mu}&space;=&space;\\frac{\\delta&space;f(w,&space;\\theta)}{\\delta&space;w}&space;&plus;&space;\\frac{\\delta&space;f(w,&space;\\theta)}{\\delta&space;\\mu})\n\nand\n\n\n6. ![equation](https://latex.codecogs.com/gif.latex?\\Delta_{\\rho}&space;=&space;\\frac{\\delta&space;f(w,&space;\\theta)}{\\delta&space;w}&space;\\frac{\\epsilon}{1&space;&plus;&space;e^\\rho&space;}&space;&plus;&space;\\frac{\\delta&space;f(w,&space;\\theta)}{\\delta&space;\\rho})\n\n## It is also true that there is complexity cost function differentiable along its variables\n\nIt is known that the crossentropy loss (and MSE) are differentiable. Therefore if we prove that there is a complexity-cost function that is differentiable, we can leave it to our framework take the derivatives and compute the gradients on the optimization step.\n\n**The complexity cost is calculated, on the feedforward operation, by each of the Bayesian Layers, (with the layers pre-defined-simpler apriori distribution and its empirical distribution). The sum of the complexity cost of each layer is summed to the loss.**\n\nAs proposed in [Weight Uncertainty in Neural Networks paper](https://arxiv.org/abs/1505.05424), we can gather the complexity cost of a distribution by taking the [Kullback-Leibler Divergence](https://jhui.github.io/2017/01/05/Deep-learning-Information-theory/) from it to a much simpler distribution, and by making some approximation, we will can differentiate this function relative to its variables (the distributions):\n\n1. Let ![equation](https://latex.codecogs.com/gif.latex?\\mathcall{P}(w)) be a low-entropy distribution pdf set by hand, which will be assumed as an \"a priori\" distribution for the weights\n\n2. Let ![equation](https://latex.codecogs.com/gif.latex?\\mathcall{Q}(w&space;|&space;\\theta)) be the a posteriori empirical distribution pdf for our sampled weights, given its parameters.\n\n\n\n\nTherefore, for each scalar on the W sampled matrix:\n\n\n\n\n3. ![equation](https://latex.codecogs.com/gif.latex?\\mathcall{D}_{KL}(&space;\\mathcall{Q}(w&space;|&space;\\theta)&space;\\lVert&space;\\mathcall{P}(w)&space;)&space;=&space;\\lim_{n\\to\\infty}1/n\\sum_{i=0}^{n}&space;{Q}(w^{(i)}&space;|&space;\\theta)*&space;(\\log{\\mathcall{Q}(w^{(i)}&space;|&space;\\theta)}&space;-&space;\\log{\\mathcall{P}(w^{(i)})}&space;))\n\n\nBy assuming a very large n, we could approximate:\n\n4. ![equation](https://latex.codecogs.com/gif.latex?\\mathcall{D}_{KL}(&space;\\mathcall{Q}(w&space;|&space;\\theta)&space;\\lVert&space;\\mathcall{P}(w)&space;)&space;=&space;1/n\\sum_{i=0}^{n}&space;{Q}(w^{(i)}&space;|&space;\\theta)*&space;(\\log{\\mathcall{Q}(w^{(i)}&space;|&space;\\theta)}&space;-&space;\\log{\\mathcall{P}(w^{(i)})}&space;))\n\n\nand therefore:\n\n\n5. ![equation](https://latex.codecogs.com/gif.latex?\\mathcall{D}_{KL}(&space;\\mathcall{Q}(w&space;|&space;\\theta)&space;\\lVert&space;\\mathcall{P}(w)&space;)&space;=&space;\\mu_Q&space;*\\sum_{i=0}^{n}&space;(\\log{\\mathcall{Q}(w^{(i)}&space;|&space;\\theta)}&space;-&space;\\log{\\mathcall{P}(w^{(i)})}&space;))\n\n\nAs the expected (mean) of the Q distribution ends up by just scaling the values, we can take it out of the equation (as there will be no framework-tracing). Have a complexity cost of the nth sample as:\n\n6. ![equation](https://latex.codecogs.com/gif.latex?\\mathcall{C^{(n)}&space;(w^{(n)},&space;\\theta)&space;}&space;=&space;(\\log{\\mathcall{Q}(w^{(n)}&space;|&space;\\theta)}&space;-&space;\\log{\\mathcall{P}(w^{(n)})}&space;))\n\nWhich is differentiable relative to all of its parameters. \n\n## To get the whole cost function at the nth sample:\n\n1. Let a performance (fit to data) function be: ![equation](https://latex.codecogs.com/gif.latex?\\mathcall{P^{(n)}&space;(w^{(n)},&space;\\theta)})\n\n\nTherefore the whole cost function on the nth sample of weights will be:\n\n2. ![equation](https://latex.codecogs.com/gif.latex?\\mathcall{L^{(n)}&space;(w^{(n)},&space;\\theta)&space;}&space;=&space;\\mathcall{C^{(n)}&space;(w^{(n)},&space;\\theta)&space;}&space;&plus;&space;\\mathcall{P^{(n)}&space;(w^{(n)},&space;\\theta)&space;})\n\nWe can estimate the true full Cost function by Monte Carlo sampling it (feedforwarding the netwok X times and taking the mean over full loss) and then backpropagate using our estimated value. It works for a low number of experiments per backprop and even for unitary experiments.\n\n## Some notes and wrap up\nWe came to the and of a Bayesian Deep Learning in a Nutshell tutorial. By knowing what is being done here, you can implement your bnn model as you wish. \n\nMaybe you can optimize by doing one optimize step per sample, or by using this Monte-Carlo-ish method to gather the loss some times, take its mean and then optimizer. Your move.\n\nFYI: **Our Bayesian Layers and utils help to calculate the complexity cost along the layers on each feedforward operation, so don't mind it to much.**\n\n## References:\n * [Charles Blundell, Julien Cornebise, Koray Kavukcuoglu, and Daan Wierstra. Weight uncertainty in neural networks. arXiv preprint arXiv:1505.05424, 2015.](https://arxiv.org/abs/1505.05424)\n\n\n###### Special thanks to Intel Student Ambassador program\n\n###### Made by Pi Esposito\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/piEsposito/blitz-bayesian-deep-learning", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "blitz-bayesian-pytorch", "package_url": "https://pypi.org/project/blitz-bayesian-pytorch/", "platform": "", "project_url": "https://pypi.org/project/blitz-bayesian-pytorch/", "project_urls": {"Homepage": "https://github.com/piEsposito/blitz-bayesian-deep-learning"}, "release_url": "https://pypi.org/project/blitz-bayesian-pytorch/0.2/", "requires_dist": ["torch (==1.3.1)", "torchvision (==0.4.2)", "numpy (==1.18.1)", "scikit-learn (==0.22.2)", "pillow (==6.2.2)"], "requires_python": "", "summary": "A simple and extensible library to create Bayesian Neural Network Layers on PyTorch without trouble and with full integration with nn.Module and nn.Sequential.", "version": "0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Blitz - Bayesian Layers in Torch Zoo</h1>\n<p>BLiTZ is a simple and extensible library to create Bayesian Neural Network Layers (based on whats proposed in <a href=\"https://arxiv.org/abs/1505.05424\" rel=\"nofollow\">Weight Uncertainty in Neural Networks paper</a>) on PyTorch. By using BLiTZ layers and utils, you can add uncertanity and gather the complexity cost of your model in a simple way that does not affect the interaction between your layers, as if you were using standard PyTorch.</p>\n<p>By using our core weight sampler classes, you can extend and improve this library to add uncertanity to a bigger scope of layers as you will in a well-integrated to PyTorch way. Also pull requests are welcome.</p>\n<p>Our objective is empower people to apply Bayesian Deep Learning by focusing rather on their idea, and not the hard-coding part.</p>\n<h1>Index</h1>\n<ul>\n<li><a href=\"#Install\" rel=\"nofollow\">Install</a></li>\n<li><a href=\"#Documentation\" rel=\"nofollow\">Documentation</a></li>\n<li><a href=\"#A-simple-example-for-regression\" rel=\"nofollow\">A simple example for regression</a>\n<ul>\n<li><a href=\"#Importing-the-necessary-modules\" rel=\"nofollow\">Importing the necessary modules</a></li>\n<li><a href=\"#Loading-and-scaling-data\" rel=\"nofollow\">Loading and scaling data</a></li>\n<li><a href=\"#Creating-our-variational-regressor-class\" rel=\"nofollow\">Creating our variational regressor class</a></li>\n<li><a href=\"#Defining-a-confidence-interval-evaluating-function\" rel=\"nofollow\">Defining a confidence interval evaluating function</a></li>\n<li><a href=\"#Creating-our-regressor-and-loading-data\" rel=\"nofollow\">Creating our regressor and loading data</a></li>\n<li><a href=\"#Our-main-training-and-evaluating-loop\" rel=\"nofollow\">Our main training and evaluating loop</a></li>\n</ul>\n</li>\n<li><a href=\"#Bayesian-Deep-Learning-in-a-Nutshell\" rel=\"nofollow\">Bayesian Deep Learning in a Nutshell</a>\n<ul>\n<li><a href=\"#First-of-all,-a-deterministic-NN-layer-linear-transformation\" rel=\"nofollow\">First of all, a deterministic NN layer linear-transformation</a></li>\n<li><a href=\"#The-purpose-of-Bayesian-Layers\" rel=\"nofollow\">The purpose of Bayesian Layers</a></li>\n<li><a href=\"#Weight-sampling-on-Bayesian-Layers\" rel=\"nofollow\">Weight sampling on Bayesian Layers</a></li>\n<li><a href=\"#It-is-possible-to-optimize-our-trainable-weights\" rel=\"nofollow\">It is possible to optimize our trainable weights</a></li>\n<li><a href=\"#It-is-also-true-that-there-is-complexity-cost-function-differentiable-along-its-variables\" rel=\"nofollow\">It is also true that there is complexity cost function differentiable along its variables</a></li>\n<li><a href=\"#To-get-the-whole-cost-function-at-the-nth-sample\" rel=\"nofollow\">To get the whole cost function at the nth sample</a></li>\n<li><a href=\"#Some-notes-and-wrap-up\" rel=\"nofollow\">Some notes and wrap up</a></li>\n</ul>\n</li>\n<li><a href=\"#References\" rel=\"nofollow\">References</a></li>\n</ul>\n<h2>Install</h2>\n<p>To install it, just git-clone it and pip-install it locally:</p>\n<pre><code>conda create -n blitz python=3.6\nconda activate blitz\ngit clone https://github.com/piEsposito/blitz-bayesian-deep-learning.git\ncd blitz-bayesian-deep-learning\npip install .\n</code></pre>\n<p>Later on, we will submit it to <strong>Pypi</strong>.</p>\n<h2>Documentation</h2>\n<p>Documentation for our layers, weight (and prior distribution) sampler and utils:</p>\n<ul>\n<li><a href=\"doc/layers.md\" rel=\"nofollow\">Bayesian Layers</a></li>\n<li><a href=\"doc/samplers.md\" rel=\"nofollow\">Weight and prior distribution samplers</a></li>\n<li><a href=\"doc/utils.md\" rel=\"nofollow\">Utils (for easy integration with PyTorch)</a></li>\n<li><a href=\"doc/losses.md\" rel=\"nofollow\">Losses</a></li>\n</ul>\n<h2>A simple example for regression</h2>\n<p>(You can see it for your self by running <a href=\"blitz/examples/bayesian_regression_boston.py\" rel=\"nofollow\">this example</a> on your machine).</p>\n<p>We will now see how can Bayesian Deep Learning be used for regression in order to gather confidence interval over our datapoint rather than a pontual continuous value prediction. Gathering a confidence interval for your prediction may be even a more useful information than a low-error estimation.</p>\n<p>I sustain my argumentation on the fact that, with good/high prob a confidence interval, you can make a more reliable decision than with a very proximal estimation on some contexts: if you are trying to get profit from a trading operation, for example, having a good confidence interval may lead you to know if, at least, the value on which the operation wil procees will be lower (or higher) than some determinate X.</p>\n<p>Knowing if a value will be, surely (or with good probability) on a determinate interval can help people on sensible decision more than a very proximal estimation that, if lower or higher than some limit value, may cause loss on a transaction. The point is that, sometimes, knowing if there will be profit may be more useful than measuring it.</p>\n<p>In order to demonstrate that, we will create a Bayesian Neural Network Regressor for the Boston-house-data toy dataset, trying to create confidence interval (CI) for the houses of which the price we are trying to predict. We will perform some scaling and the CI will be about 75%. It will be interesting to see that about 90% of the CIs predicted are lower than the high limit OR (inclusive) higher than the lower one.</p>\n<h2>Importing the necessary modules</h2>\n<p>Despite from the known modules, we will bring from BLiTZ athe <code>variational_estimator</code>decorator, which helps us to handle the BayesianLinear layers on the module keeping it fully integrated with the rest of Torch, and, of course, <code>BayesianLinear</code>, which is our layer that features weight uncertanity.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">torch</span>\n<span class=\"kn\">import</span> <span class=\"nn\">torch.nn</span> <span class=\"k\">as</span> <span class=\"nn\">nn</span>\n<span class=\"kn\">import</span> <span class=\"nn\">torch.nn.functional</span> <span class=\"k\">as</span> <span class=\"nn\">F</span>\n<span class=\"kn\">import</span> <span class=\"nn\">torch.optim</span> <span class=\"k\">as</span> <span class=\"nn\">optim</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">blitz.modules</span> <span class=\"kn\">import</span> <span class=\"n\">BayesianLinear</span>\n<span class=\"kn\">from</span> <span class=\"nn\">blitz.utils</span> <span class=\"kn\">import</span> <span class=\"n\">variational_estimator</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">sklearn.datasets</span> <span class=\"kn\">import</span> <span class=\"n\">load_boston</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sklearn.preprocessing</span> <span class=\"kn\">import</span> <span class=\"n\">StandardScaler</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sklearn.model_selection</span> <span class=\"kn\">import</span> <span class=\"n\">train_test_split</span>\n</pre>\n<h2>Loading and scaling data</h2>\n<p>Nothing new under the sun here, we are importing and standard-scaling the data to help with the training.</p>\n<pre><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">load_boston</span><span class=\"p\">(</span><span class=\"n\">return_X_y</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">StandardScaler</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">fit_transform</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span>\n<span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">StandardScaler</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">fit_transform</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">expand_dims</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n\n<span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">X_test</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">,</span> <span class=\"n\">y_test</span> <span class=\"o\">=</span> <span class=\"n\">train_test_split</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span>\n                                                    <span class=\"n\">y</span><span class=\"p\">,</span>\n                                                    <span class=\"n\">test_size</span><span class=\"o\">=.</span><span class=\"mi\">25</span><span class=\"p\">,</span>\n                                                    <span class=\"n\">random_state</span><span class=\"o\">=</span><span class=\"mi\">42</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">(</span><span class=\"n\">X_train</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">float</span><span class=\"p\">(),</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">(</span><span class=\"n\">y_train</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">float</span><span class=\"p\">()</span>\n<span class=\"n\">X_test</span><span class=\"p\">,</span> <span class=\"n\">y_test</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">(</span><span class=\"n\">X_test</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">float</span><span class=\"p\">(),</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">tensor</span><span class=\"p\">(</span><span class=\"n\">y_test</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">float</span><span class=\"p\">()</span>\n</pre>\n<h1>Creating our variational regressor class</h1>\n<p>We can create our class with inhreiting from nn.Module, as we would do with any Torch network. Our decorator introduces the methods to handle the bayesian features, as calculating the complexity cost of the Bayesian Layers and doing many feedforwards (sampling different weights on each one) in order to sample our loss.</p>\n<pre><span class=\"nd\">@variational_estimator</span>\n<span class=\"k\">class</span> <span class=\"nc\">BayesianRegressor</span><span class=\"p\">(</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Module</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">input_dim</span><span class=\"p\">,</span> <span class=\"n\">output_dim</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">()</span>\n        <span class=\"c1\">#self.linear = nn.Linear(input_dim, output_dim)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">blinear1</span> <span class=\"o\">=</span> <span class=\"n\">BayesianLinear</span><span class=\"p\">(</span><span class=\"n\">input_dim</span><span class=\"p\">,</span> <span class=\"mi\">512</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">blinear2</span> <span class=\"o\">=</span> <span class=\"n\">BayesianLinear</span><span class=\"p\">(</span><span class=\"mi\">512</span><span class=\"p\">,</span> <span class=\"n\">output_dim</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">forward</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">):</span>\n        <span class=\"n\">x_</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">blinear1</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">blinear2</span><span class=\"p\">(</span><span class=\"n\">x_</span><span class=\"p\">)</span>\n</pre>\n<h1>Defining a confidence interval evaluating function</h1>\n<p>This function does create a confidence interval for each prediction on the batch on which we are trying to sample the label value. We then can measure the accuracy of our predictions by seeking how much of the prediciton distributions did actually include the correct label for the datapoint.</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">evaluate_regression</span><span class=\"p\">(</span><span class=\"n\">regressor</span><span class=\"p\">,</span>\n                        <span class=\"n\">X</span><span class=\"p\">,</span>\n                        <span class=\"n\">y</span><span class=\"p\">,</span>\n                        <span class=\"n\">samples</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"p\">,</span>\n                        <span class=\"n\">std_multiplier</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">):</span>\n    <span class=\"n\">preds</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">regressor</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">samples</span><span class=\"p\">)]</span>\n    <span class=\"n\">preds</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"p\">(</span><span class=\"n\">preds</span><span class=\"p\">)</span>\n    <span class=\"n\">means</span> <span class=\"o\">=</span> <span class=\"n\">preds</span><span class=\"o\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">stds</span> <span class=\"o\">=</span> <span class=\"n\">preds</span><span class=\"o\">.</span><span class=\"n\">std</span><span class=\"p\">(</span><span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">ci_upper</span> <span class=\"o\">=</span> <span class=\"n\">means</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">std_multiplier</span> <span class=\"o\">*</span> <span class=\"n\">stds</span><span class=\"p\">)</span>\n    <span class=\"n\">ci_lower</span> <span class=\"o\">=</span> <span class=\"n\">means</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"n\">std_multiplier</span> <span class=\"o\">*</span> <span class=\"n\">stds</span><span class=\"p\">)</span>\n    <span class=\"n\">ic_acc</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">ci_lower</span> <span class=\"o\">&lt;=</span> <span class=\"n\">y</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">ci_upper</span> <span class=\"o\">&gt;=</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n    <span class=\"n\">ic_acc</span> <span class=\"o\">=</span> <span class=\"n\">ic_acc</span><span class=\"o\">.</span><span class=\"n\">float</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">mean</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span> <span class=\"n\">ic_acc</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">ci_upper</span> <span class=\"o\">&gt;=</span> <span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">float</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">mean</span><span class=\"p\">(),</span> <span class=\"p\">(</span><span class=\"n\">ci_lower</span> <span class=\"o\">&lt;=</span> <span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">float</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">mean</span><span class=\"p\">()</span>\n</pre>\n<h1>Creating our regressor and loading data</h1>\n<p>Notice here that we create our <code>BayesianRegressor</code> as we would do with other neural networks.</p>\n<pre><span class=\"n\">regressor</span> <span class=\"o\">=</span> <span class=\"n\">BayesianRegressor</span><span class=\"p\">(</span><span class=\"mi\">13</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">optimizer</span> <span class=\"o\">=</span> <span class=\"n\">optim</span><span class=\"o\">.</span><span class=\"n\">SGD</span><span class=\"p\">(</span><span class=\"n\">regressor</span><span class=\"o\">.</span><span class=\"n\">parameters</span><span class=\"p\">(),</span> <span class=\"n\">lr</span><span class=\"o\">=</span><span class=\"mf\">0.001</span><span class=\"p\">)</span>\n<span class=\"n\">criterion</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">MSELoss</span><span class=\"p\">()</span>\n\n<span class=\"n\">ds_train</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">TensorDataset</span><span class=\"p\">(</span><span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">)</span>\n<span class=\"n\">dataloader_train</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">DataLoader</span><span class=\"p\">(</span><span class=\"n\">ds_train</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"n\">ds_test</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">TensorDataset</span><span class=\"p\">(</span><span class=\"n\">X_test</span><span class=\"p\">,</span> <span class=\"n\">y_test</span><span class=\"p\">)</span>\n<span class=\"n\">dataloader_test</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">DataLoader</span><span class=\"p\">(</span><span class=\"n\">ds_test</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<h2>Our main training and evaluating loop</h2>\n<p>We do a training loop that only differs from a common torch training by having its loss sampled by its sample_elbo method. All the other stuff can be done normally, as our purpose with BLiTZ is to ease your life on iterating on your data with different Bayesian NNs without trouble.</p>\n<p>Here is our very simple training loop:</p>\n<pre><span class=\"n\">iteration</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"k\">for</span> <span class=\"n\">epoch</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">):</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">datapoints</span><span class=\"p\">,</span> <span class=\"n\">labels</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">dataloader_train</span><span class=\"p\">):</span>\n        <span class=\"n\">optimizer</span><span class=\"o\">.</span><span class=\"n\">zero_grad</span><span class=\"p\">()</span>\n\n        <span class=\"n\">loss</span> <span class=\"o\">=</span> <span class=\"n\">regressor</span><span class=\"o\">.</span><span class=\"n\">sample_elbo</span><span class=\"p\">(</span><span class=\"n\">inputs</span><span class=\"o\">=</span><span class=\"n\">datapoints</span><span class=\"p\">,</span>\n                           <span class=\"n\">labels</span><span class=\"o\">=</span><span class=\"n\">labels</span><span class=\"p\">,</span>\n                           <span class=\"n\">criterion</span><span class=\"o\">=</span><span class=\"n\">criterion</span><span class=\"p\">,</span>\n                           <span class=\"n\">sample_nbr</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n        <span class=\"n\">loss</span><span class=\"o\">.</span><span class=\"n\">backward</span><span class=\"p\">()</span>\n        <span class=\"n\">optimizer</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">()</span>\n\n        <span class=\"n\">iteration</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">if</span> <span class=\"n\">iteration</span><span class=\"o\">%</span><span class=\"mi\">100</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"n\">ic_acc</span><span class=\"p\">,</span> <span class=\"n\">under_ci_upper</span><span class=\"p\">,</span> <span class=\"n\">over_ci_lower</span> <span class=\"o\">=</span> <span class=\"n\">evaluate_regression</span><span class=\"p\">(</span><span class=\"n\">regressor</span><span class=\"p\">,</span>\n                                                                        <span class=\"n\">X_test</span><span class=\"p\">,</span>\n                                                                        <span class=\"n\">y_test</span><span class=\"p\">,</span>\n                                                                        <span class=\"n\">samples</span><span class=\"o\">=</span><span class=\"mi\">25</span><span class=\"p\">,</span>\n                                                                        <span class=\"n\">std_multiplier</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"CI acc: </span><span class=\"si\">{:.2f}</span><span class=\"s2\">, CI upper acc: </span><span class=\"si\">{:.2f}</span><span class=\"s2\">, CI lower acc: </span><span class=\"si\">{:.2f}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">ic_acc</span><span class=\"p\">,</span> <span class=\"n\">under_ci_upper</span><span class=\"p\">,</span> <span class=\"n\">over_ci_lower</span><span class=\"p\">))</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Loss: </span><span class=\"si\">{:.4f}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">loss</span><span class=\"p\">))</span>\n</pre>\n<h2>Bayesian Deep Learning in a Nutshell</h2>\n<p>A very fast explanation of how is uncertainity introduced in Bayesian Neural Networks and how we model its loss in order to objectively improve the confidence over its prediction and reduce the variance without dropout.</p>\n<h2>First of all, a deterministic NN layer linear transformation</h2>\n<p>As we know, on deterministic (non bayesian) neural network layers, the trainable parameters correspond directly to the weights used on its linear transformation of the previous one (or the input, if it is the case). It corresponds to the following equation:</p>\n<p><img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f45e01edb56f87a5f23adbce3be675a61d84a977/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f6125354525374228692b31292537442673706163653b3d2673706163653b5725354525374228692b312925374425354363646f742673706163653b7a2535452537422869292537442673706163653b2b2673706163653b6225354525374228692b3129253744\"></p>\n<p><em>(Z correspond to the activated-output of the layer i)</em></p>\n<h2>The purpose of Bayesian Layers</h2>\n<p>Bayesian layers seek to introduce uncertainity on its weights by sampling them from a distribution parametrized by trainable variables on each feedforward operation.</p>\n<p>This allows we not just to optimize the performance metrics of the model, but also gather the uncertainity of the network predictions over a specific datapoint (by sampling it much times and measuring the dispersion) and aimingly reduce as much as possible the variance of the network over the prediction, making possible to know how much of incertainity we still have over the label if we try to model it in function of our specific datapoint.</p>\n<h2>Weight sampling on Bayesian Layers</h2>\n<p>To do so, on each feedforward operation we sample the parameters of the linear transformation with the following equations (where <strong>\u03c1</strong> parametrizes the standard deviation and <strong>\u03bc</strong> parametrizes the mean for the samples linear transformation parameters) :</p>\n<p>For the weights:</p>\n<p><img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fa12835e356d87dc44e97536116f40e7cb27491c/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f572535452537422869292537445f253742286e292537442673706163653b3d2673706163653b2535436d61746863616c2537424e25374428302c31292673706163653b2a2673706163653b6c6f6728312673706163653b2b2673706163653b25354372686f2535452537422869292537442673706163653b292673706163653b2b2673706163653b2535436d75253545253742286929253744\"></p>\n<p><em>Where the sampled W corresponds to the weights used on the linear transformation for the ith layer on the nth sample.</em></p>\n<p>For the biases:</p>\n<p><img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/af1492a2a3f05d265105fcf1dd5790e0f9db99a9/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f622535452537422869292537445f253742286e292537442673706163653b3d2673706163653b2535436d61746863616c2537424e25374428302c31292673706163653b2a2673706163653b6c6f6728312673706163653b2b2673706163653b25354372686f2535452537422869292537442673706163653b292673706163653b2b2673706163653b2535436d75253545253742286929253744\"></p>\n<p><em>Where the sampled b corresponds to the biases used on the linear transformation for the ith layer on the nth sample.</em></p>\n<h2>It is possible to optimize our trainable weights</h2>\n<p>Even tough we have a random multiplier for our weights and biases, it is possible to optimize them by, given some differentiable function of the weights sampled and trainable parameters (in our case, the loss), summing the derivative of the function relative to both of them:</p>\n<ol>\n<li>Let <img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/50c0df8763f62d89fb7f53d729939bec954ae512/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f253543657073696c6f6e2673706163653b3d2673706163653b2535436d61746863616c2537424e25374428302c3129\"></li>\n<li>Let <img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7d183dee0b54c7bf266826baf7d1090d4d666d54/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f25354374686574612673706163653b3d2673706163653b2825354372686f2c2673706163653b2535436d7529\"></li>\n<li>Let <img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c2aa6a984ece110456840a7a8b3dc6a303ddc9fa/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f772673706163653b3d2673706163653b2535436d752673706163653b2b2673706163653b2535436c6f6728253742312673706163653b2b2673706163653b6525354525374225354372686f253744253744292673706163653b2a2673706163653b253543657073696c6f6e\"></li>\n<li>Let <img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4f65ff9a7474dc153b83322a51b9103ee408b099/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f6628772c2673706163653b253543746865746129\"> be differentiable relative to its variables</li>\n</ol>\n<p>Therefore:</p>\n<ol>\n<li><img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/90eeb50dddacedbc00fbf12b99b71def5d0fb1a7/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f25354344656c74615f2537422535436d752537442673706163653b3d2673706163653b2535436672616325374225354364656c74612673706163653b6628772c2673706163653b25354374686574612925374425374225354364656c74612673706163653b772537442673706163653b2b2673706163653b2535436672616325374225354364656c74612673706163653b6628772c2673706163653b25354374686574612925374425374225354364656c74612673706163653b2535436d75253744\"></li>\n</ol>\n<p>and</p>\n<ol>\n<li><img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/79eadf460d7000cdde5eef3f46de68e88fe72374/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f25354344656c74615f25374225354372686f2537442673706163653b3d2673706163653b2535436672616325374225354364656c74612673706163653b6628772c2673706163653b25354374686574612925374425374225354364656c74612673706163653b772537442673706163653b25354366726163253742253543657073696c6f6e253744253742312673706163653b2b2673706163653b6525354525354372686f2673706163653b2537442673706163653b2b2673706163653b2535436672616325374225354364656c74612673706163653b6628772c2673706163653b25354374686574612925374425374225354364656c74612673706163653b25354372686f253744\"></li>\n</ol>\n<h2>It is also true that there is complexity cost function differentiable along its variables</h2>\n<p>It is known that the crossentropy loss (and MSE) are differentiable. Therefore if we prove that there is a complexity-cost function that is differentiable, we can leave it to our framework take the derivatives and compute the gradients on the optimization step.</p>\n<p><strong>The complexity cost is calculated, on the feedforward operation, by each of the Bayesian Layers, (with the layers pre-defined-simpler apriori distribution and its empirical distribution). The sum of the complexity cost of each layer is summed to the loss.</strong></p>\n<p>As proposed in <a href=\"https://arxiv.org/abs/1505.05424\" rel=\"nofollow\">Weight Uncertainty in Neural Networks paper</a>, we can gather the complexity cost of a distribution by taking the <a href=\"https://jhui.github.io/2017/01/05/Deep-learning-Information-theory/\" rel=\"nofollow\">Kullback-Leibler Divergence</a> from it to a much simpler distribution, and by making some approximation, we will can differentiate this function relative to its variables (the distributions):</p>\n<ol>\n<li>\n<p>Let <img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ab11d6784b5de9f7a38612510a4fe01c30503aab/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2535436d61746863616c6c25374250253744287729\"> be a low-entropy distribution pdf set by hand, which will be assumed as an \"a priori\" distribution for the weights</p>\n</li>\n<li>\n<p>Let <img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/33fe7c54fc9ad7afd6c0b5818af9fa290da3092a/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2535436d61746863616c6c2537425125374428772673706163653b2537432673706163653b253543746865746129\"> be the a posteriori empirical distribution pdf for our sampled weights, given its parameters.</p>\n</li>\n</ol>\n<p>Therefore, for each scalar on the W sampled matrix:</p>\n<ol>\n<li><img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/37089a15a3beeaf7d107867db01c1d52f4a75afc/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2535436d61746863616c6c253742442537445f2537424b4c253744282673706163653b2535436d61746863616c6c2537425125374428772673706163653b2537432673706163653b2535437468657461292673706163653b2535436c566572742673706163653b2535436d61746863616c6c253742502537442877292673706163653b292673706163653b3d2673706163653b2535436c696d5f2537426e253543746f253543696e667479253744312f6e25354373756d5f253742693d302537442535452537426e2537442673706163653b2537425125374428772535452537422869292537442673706163653b2537432673706163653b2535437468657461292a2673706163653b282535436c6f672537422535436d61746863616c6c2537425125374428772535452537422869292537442673706163653b2537432673706163653b2535437468657461292537442673706163653b2d2673706163653b2535436c6f672537422535436d61746863616c6c253742502537442877253545253742286929253744292537442673706163653b29\"></li>\n</ol>\n<p>By assuming a very large n, we could approximate:</p>\n<ol>\n<li><img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/05bc596a9c39e92b66835e5aba108897c52dce05/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2535436d61746863616c6c253742442537445f2537424b4c253744282673706163653b2535436d61746863616c6c2537425125374428772673706163653b2537432673706163653b2535437468657461292673706163653b2535436c566572742673706163653b2535436d61746863616c6c253742502537442877292673706163653b292673706163653b3d2673706163653b312f6e25354373756d5f253742693d302537442535452537426e2537442673706163653b2537425125374428772535452537422869292537442673706163653b2537432673706163653b2535437468657461292a2673706163653b282535436c6f672537422535436d61746863616c6c2537425125374428772535452537422869292537442673706163653b2537432673706163653b2535437468657461292537442673706163653b2d2673706163653b2535436c6f672537422535436d61746863616c6c253742502537442877253545253742286929253744292537442673706163653b29\"></li>\n</ol>\n<p>and therefore:</p>\n<ol>\n<li><img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9174b8fd4a2d41f85baf188ed1605ab614b78b47/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2535436d61746863616c6c253742442537445f2537424b4c253744282673706163653b2535436d61746863616c6c2537425125374428772673706163653b2537432673706163653b2535437468657461292673706163653b2535436c566572742673706163653b2535436d61746863616c6c253742502537442877292673706163653b292673706163653b3d2673706163653b2535436d755f512673706163653b2a25354373756d5f253742693d302537442535452537426e2537442673706163653b282535436c6f672537422535436d61746863616c6c2537425125374428772535452537422869292537442673706163653b2537432673706163653b2535437468657461292537442673706163653b2d2673706163653b2535436c6f672537422535436d61746863616c6c253742502537442877253545253742286929253744292537442673706163653b29\"></li>\n</ol>\n<p>As the expected (mean) of the Q distribution ends up by just scaling the values, we can take it out of the equation (as there will be no framework-tracing). Have a complexity cost of the nth sample as:</p>\n<ol>\n<li><img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3ab842e2f7890bc8354deaaee78bfe25391f835d/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2535436d61746863616c6c25374243253545253742286e292537442673706163653b2877253545253742286e292537442c2673706163653b2535437468657461292673706163653b2537442673706163653b3d2673706163653b282535436c6f672537422535436d61746863616c6c253742512537442877253545253742286e292537442673706163653b2537432673706163653b2535437468657461292537442673706163653b2d2673706163653b2535436c6f672537422535436d61746863616c6c253742502537442877253545253742286e29253744292537442673706163653b29\"></li>\n</ol>\n<p>Which is differentiable relative to all of its parameters.</p>\n<h2>To get the whole cost function at the nth sample:</h2>\n<ol>\n<li>Let a performance (fit to data) function be: <img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2e485b12eb5003abecea5950e016039a04d9e213/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2535436d61746863616c6c25374250253545253742286e292537442673706163653b2877253545253742286e292537442c2673706163653b253543746865746129253744\"></li>\n</ol>\n<p>Therefore the whole cost function on the nth sample of weights will be:</p>\n<ol>\n<li><img alt=\"equation\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/10d805e2949e1e8c6493234104dde9569f4e770b/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f2535436d61746863616c6c2537424c253545253742286e292537442673706163653b2877253545253742286e292537442c2673706163653b2535437468657461292673706163653b2537442673706163653b3d2673706163653b2535436d61746863616c6c25374243253545253742286e292537442673706163653b2877253545253742286e292537442c2673706163653b2535437468657461292673706163653b2537442673706163653b2b2673706163653b2535436d61746863616c6c25374250253545253742286e292537442673706163653b2877253545253742286e292537442c2673706163653b2535437468657461292673706163653b253744\"></li>\n</ol>\n<p>We can estimate the true full Cost function by Monte Carlo sampling it (feedforwarding the netwok X times and taking the mean over full loss) and then backpropagate using our estimated value. It works for a low number of experiments per backprop and even for unitary experiments.</p>\n<h2>Some notes and wrap up</h2>\n<p>We came to the and of a Bayesian Deep Learning in a Nutshell tutorial. By knowing what is being done here, you can implement your bnn model as you wish.</p>\n<p>Maybe you can optimize by doing one optimize step per sample, or by using this Monte-Carlo-ish method to gather the loss some times, take its mean and then optimizer. Your move.</p>\n<p>FYI: <strong>Our Bayesian Layers and utils help to calculate the complexity cost along the layers on each feedforward operation, so don't mind it to much.</strong></p>\n<h2>References:</h2>\n<ul>\n<li><a href=\"https://arxiv.org/abs/1505.05424\" rel=\"nofollow\">Charles Blundell, Julien Cornebise, Koray Kavukcuoglu, and Daan Wierstra. Weight uncertainty in neural networks. arXiv preprint arXiv:1505.05424, 2015.</a></li>\n</ul>\n<h6>Special thanks to Intel Student Ambassador program</h6>\n<h6>Made by Pi Esposito</h6>\n\n          </div>"}, "last_serial": 7133117, "releases": {"0.2": [{"comment_text": "", "digests": {"md5": "1cf8e685798ee449840f9251c5a7bea3", "sha256": "ff347262ae9f630a924782c8309a1d1f3a1e743a68039145a9088daa81d33744"}, "downloads": -1, "filename": "blitz_bayesian_pytorch-0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "1cf8e685798ee449840f9251c5a7bea3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 22730, "upload_time": "2020-04-29T22:46:41", "upload_time_iso_8601": "2020-04-29T22:46:41.386498Z", "url": "https://files.pythonhosted.org/packages/0b/6a/916d2c429905ff15338ee96ae81a7e4b04e3f9a949b19d81d62e7f95e166/blitz_bayesian_pytorch-0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "262d4f75569b63b6a21afed8530941fa", "sha256": "29cef38150638c1f61243701cabb4a9d89b3617e883514cd7a239a109e840f2e"}, "downloads": -1, "filename": "blitz-bayesian-pytorch-0.2.tar.gz", "has_sig": false, "md5_digest": "262d4f75569b63b6a21afed8530941fa", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16207, "upload_time": "2020-04-29T22:46:43", "upload_time_iso_8601": "2020-04-29T22:46:43.885641Z", "url": "https://files.pythonhosted.org/packages/2b/8e/a88580635d830d07c31631de33dbf65de532c708465e33c0e81bb28751b2/blitz-bayesian-pytorch-0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1cf8e685798ee449840f9251c5a7bea3", "sha256": "ff347262ae9f630a924782c8309a1d1f3a1e743a68039145a9088daa81d33744"}, "downloads": -1, "filename": "blitz_bayesian_pytorch-0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "1cf8e685798ee449840f9251c5a7bea3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 22730, "upload_time": "2020-04-29T22:46:41", "upload_time_iso_8601": "2020-04-29T22:46:41.386498Z", "url": "https://files.pythonhosted.org/packages/0b/6a/916d2c429905ff15338ee96ae81a7e4b04e3f9a949b19d81d62e7f95e166/blitz_bayesian_pytorch-0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "262d4f75569b63b6a21afed8530941fa", "sha256": "29cef38150638c1f61243701cabb4a9d89b3617e883514cd7a239a109e840f2e"}, "downloads": -1, "filename": "blitz-bayesian-pytorch-0.2.tar.gz", "has_sig": false, "md5_digest": "262d4f75569b63b6a21afed8530941fa", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16207, "upload_time": "2020-04-29T22:46:43", "upload_time_iso_8601": "2020-04-29T22:46:43.885641Z", "url": "https://files.pythonhosted.org/packages/2b/8e/a88580635d830d07c31631de33dbf65de532c708465e33c0e81bb28751b2/blitz-bayesian-pytorch-0.2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:37:05 2020"}