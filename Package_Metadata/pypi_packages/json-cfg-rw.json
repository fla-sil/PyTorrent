{"info": {"author": "Istv\u00e1n P\u00e1sztor", "author_email": "pasztorpisti@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "========\njson-cfg\n========\n\n.. image:: https://img.shields.io/travis/pasztorpisti/json-cfg.svg?style=flat\n    :target: https://travis-ci.org/pasztorpisti/json-cfg\n    :alt: build\n\n.. image:: https://img.shields.io/codacy/25854a088e89472f9fbf2bd5c1633834.svg?style=flat\n    :target: https://www.codacy.com/app/pasztorpisti/json-cfg\n    :alt: code quality\n\n.. image:: https://landscape.io/github/pasztorpisti/json-cfg/master/landscape.svg?style=flat\n    :target: https://landscape.io/github/pasztorpisti/json-cfg/master\n    :alt: code health\n\n.. image:: https://img.shields.io/coveralls/pasztorpisti/json-cfg/master.svg?style=flat\n    :target: https://coveralls.io/r/pasztorpisti/json-cfg?branch=master\n    :alt: coverage\n\n.. image:: https://img.shields.io/pypi/v/json-cfg.svg?style=flat\n    :target: https://pypi.python.org/pypi/json-cfg\n    :alt: pypi\n\n.. image:: https://img.shields.io/github/tag/pasztorpisti/json-cfg.svg?style=flat\n    :target: https://github.com/pasztorpisti/json-cfg\n    :alt: github\n\n.. image:: https://img.shields.io/github/license/pasztorpisti/json-cfg.svg?style=flat\n    :target: https://github.com/pasztorpisti/json-cfg/blob/master/LICENSE.txt\n    :alt: license: MIT\n\n.. contents::\n\n------------\nIntroduction\n------------\n\nThe goal of this library is providing a json config file loader that has\nthe following extras compared to the standard ``json.load()``:\n\n- A larger subset of javascript (and not some weird/exotic extension to json that\n  would turn it into something that has nothing to do with json/javascript):\n\n    - backward compatible with json so you can still load standard json files too\n    - single and multi-line comments - this is more useful then you would think:\n      it is good not only for documentation but also for temporarily disabling\n      a block in your config without actually deleting entries\n    - object (dictionary) keys without quotes: less quotation marks, less noise\n    - trailing commas (allowing a comma after the last item of objects and arrays)\n\n- Providing line number information for each element of the loaded config file\n  and using this to display useful error messages that help locating errors not\n  only while parsing the file but also when processing/interpreting it.\n- A simple config query syntax that handles default values, required elements and\n  automatically raises an exception in case of error (with useful info including\n  the location of the error in the config file).\n\n\nConfig file examples\n--------------------\n\nA traditional json config file:\n\n.. code-block:: javascript\n\n    {\n        \"servers\": [\n            {\n                \"ip_address\": \"127.0.0.1\",\n                \"port\": 8080\n            },\n            {\n                \"ip_address\": \"127.0.0.1\",\n                \"port\": 8081\n            }\n        ],\n        \"superuser_name\": \"tron\"\n    }\n\nSomething similar but better with json-cfg:\n\n.. code-block:: javascript\n    \n    {\n        // Note that we can get rid of most quotation marks.\n        servers: [\n            {\n                ip_address: \"127.0.0.1\",\n                port: 8080\n            },\n            // We have commented out the block of the second server below.\n            // Trailing commas are allowed so the comma after the\n            // first block (above) doesn't cause any problems.\n            /*\n            {\n                ip_address: \"127.0.0.1\",\n                port: 8081\n            },  // <-- optional trailing comma\n            /**/\n        ],\n        superuser_name: \"tron\",  // <-- optional trailing comma\n    }\n\nNote that json-cfg can load both config files because standard json is a subset of the extended\nsyntax allowed by json-cfg.\n\n.. tip::\n\n    Use javascript syntax highlight in your text editor for json config files\n    whenever possible - this makes reading config files much easier especially\n    when you have a lot of comments or large commented config blocks.\n\n-----\nUsage\n-----\n\nInstallation\n------------\n\n.. code-block:: sh\n\n    pip install json-cfg\n\nAlternatively you can download the zipped library from https://pypi.python.org/pypi/json-cfg\n\nQuick-starter\n-------------\n\nThe json-cfg library provides two modes when it comes to loading config files: One that is very\nsimilar to the standard ``json.loads()`` and another one that returns the json wrapped into special\nconfig nodes that make handling the config file much easier:\n\n- ``jsoncfg.load()`` and ``jsoncfg.loads()`` are very similar to the standard ``json.loads()``.\n  These functions allow you to load config files into bare python representation of the json\n  data (dictionaries, lists, numbers, etc...).\n- ``jsoncfg.load_config()`` and ``jsoncfg.loads_config()`` load the json data into special wrapper\n  objects that help you to query the config with much nicer syntax. At the same time if you\n  are looking for a value that doesn't exist in the config then these problems are handled with\n  exceptions that contain line/column number info about the location of the error.\n\nOne of the biggest problems with loading the config into bare python objects with a simple json\nlibrary is that the loaded json data doesn't contain the line/column numbers for the loaded json\nnodes/elements. This means that by using a simple json library you can report the location of errors\nwith config file line/column numbers only in case of json syntax errors (in best case).\nBy loading the json nodes/elements into our wrapper objects we can retain the line/column numbers\nfor the json nodes/elements and we can use them in our error messages in case of semantic errors.\n\nI assume that you have already installed json-cfg and you have the previously shown server config\nexample in a ``server.cfg`` file in the current directory.\n\nThis is how to load and process the above server configuration with a simple json library:\n\n.. code-block:: python\n\n    import json\n\n    with open('server.cfg') as f:\n        config = json.load(f)\n    for server in config['servers']:\n        listen_on_interface(server['ip_address'], server.get('port', 8000))\n    superuser_name = config['superuser_name']\n\nThe same with json-cfg:\n\n.. code-block:: python\n\n    import jsoncfg\n\n    config = jsoncfg.load_config('server.cfg')\n    for server in config.servers:\n        listen_on_interface(server.ip_address(), server.port(8000))\n    superuser_name = config.superuser_name()\n\nSeemingly the difference isn't that big. With json-cfg you can use extended syntax in the config\nfile and the code that loads/processes the config is also somewhat nicer but real difference is\nwhat happens when you encounter an error. With json-cfg you get an exception with a message that\npoints to the problematic part of the json config file while the pure-json example can't tell you\nline/column numbers in the config file. In case of larger configs this can cause headaches.\n\nOpen your ``server.cfg`` file and remove the required ``ip_address`` attribute from one of the server\nconfig blocks. This will cause an error when we try to load the config file with the above code\nexamples. The above code snippets report the following error messages in this scenario:\n\njson:\n\n.. code-block::\n\n    KeyError: 'ip_address'\n\njson-cfg:\n\n.. code-block::\n\n    jsoncfg.config_classes.JSONConfigValueNotFoundError: Required config node not found. Missing query path: .ip_address (relative to error location) [line=3;col=9]\n\nDetailed explanation of the library interface\n---------------------------------------------\n\nWhen you load your json with ``jsoncfg.load_config()`` or ``jsoncfg.loads_config()`` the returned json\ndata - the hierarchy - is a tree of wrapper objects provided by this library. These wrapper objects\nmake it possible to store the column/line numbers for each json node/element (for error reporting)\nand these wrappers allow you to query the config with the nice syntax you've seen above.\n\nThis library differentiates 3 types of json nodes/elements and each of these have their own wrapper\nclasses:\n\n- json object (dictionary like stuff)\n- json array (list like stuff)\n- json scalar (I use \"scalar\" to refer any json value that isn't a container)\n\nI use *json value* to refer to any json node/element whose type is unknown or unimportant.\nThe public API of the wrapper classes is very simple: they have no public methods. All they provide\nis a few magic methods that you can use to read/query the loaded json data. (These magic methods\nare ``__contains__``, ``__getattr__``, ``__getitem__``, ``__len__``, ``__iter__`` and ``__call__`` but don't\nworry if you don't know about these magic methods as I will demonstrate the usage with simple code\nexamples that don't assume that you know them.)\nThe reason for having no public methods is simple: We allow querying json object keys with\n``__getattr__`` (with the dot or member access operator like ``config.myvalue``) and we don't want any\npublic methods to conflict with the key values in your config file.\n\nAfter loading the config you have a tree of wrapper object nodes and you have to perform these two\noperations to get values from the config:\n\n1. querying/reading/traversing the json hierarchy: the result of querying is a wrapper object\n2. fetching the python value from the selected wrapper object: this can be done by calling the\n   queried wrapper object.\n\nThe following sections explain these two operations in detail.\n\nQuerying the json config hierarchy\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nTo read and query the json hierarchy and the wrapper object nodes that build up the tree you have\nto exploit the ``__contains__``, ``__getattr__``, ``__getitem__``, ``__len__``, ``__iter__`` magic methods\nof the wrapper objects. We will use the previously shown server config for the following examples.\n\n.. code-block:: python\n\n    import jsoncfg\n\n    config = jsoncfg.load_config('server.cfg')\n\n    # Using __getattr__ to get the servers key from the config json object.\n    # The result of this expression is a wrapper object that wraps the servers array/list.\n    server_array = config.servers\n\n    # The equivalent of the previous expression using __getitem__:\n    server_array = config['servers']\n\n    # Note that querying a non-existing key from an object doesn't raise an error. Instead\n    # it returns a special ValueNotFoundNode instance that you can continue using as a\n    # wrapper object. The error happens only if you try to fetch the value of this key\n    # without specifying a default value - but more on this later in the section where we\n    # discuss value fetching from wrapper objects.\n    special_value_not_found_node = config.non_existing_key\n\n    # Checking whether a key exists in a json object:\n    servers_exists = 'servers' in config\n\n    # Using __getitem__ to index into json array wrapper objects:\n    # Over-indexing the array would raise an exception with useful error message\n    # containing the location of the servers_array in the config file.\n    first_item_wrapper_object = servers_array[0]\n\n    # Getting the length of json object and json array wrappers:\n    num_config_key_value_pairs = len(config)\n    servers_array_len = len(servers_array)\n\n    # Iterating the items of a json object or array:\n    for key_string, value_wrapper_object in config:\n        pass\n    for value_wrapper_object in config.servers:\n        pass\n\nNot all node types (object, array, scalar) support all operations. For example a scalar json value\ndoesn't support ``len()`` and you can not iterate it. What happens if someone puts a scalar value\ninto the config in place of the servers array? In that case the config loader code sooner or\nlater performs an array-specific operation on that scalar value (for example iteration) and this\nraises an exception with a useful error message pointing the the loader code with the stack trace\nand pointing to the scalar value in the config file with line/column numbers. You can find more info\nabout json-node-type related checks and error handling mechanisms in the following sections (value\nfetching and error handling).\n\nFetching python values from the queried wrapper objects\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nAfter selecting any of the wrapper object nodes from the json config hierarchy you can fetch its\nwrapped value by using its ``__call__`` magic method. This works on all json node types: objects,\narrays and scalars. If you fetch a container (object or array) then this fetch is recursive: it\nfetches the whole subtree whose root node is the fetched wrapper object. In most cases it is a\ngood practice to fetch only leaf nodes of the config. Leaving the containers (objects, arrays) in\nwrappers helps getting better error messages if something goes wrong while you are processing the\nconfig data.\n\n.. code-block:: python\n\n    import jsoncfg\n\n    config = jsoncfg.load_config('server.cfg')\n\n    # Fetching the value of the whole json object hierarchy.\n    # python_hierarchy now looks like something you normally\n    # get as a result of a standard ``json.load()``.\n    python_hierarchy = config()\n\n    # Converting only the servers array into python-object format:\n    python_server_list = config.servers()\n\n    # Getting the ip_address of the first server.\n    server_0_ip_address_str = config.servers[0].ip_address()\n\n\nFetching optional config values (by specifying a default value)\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe value fetcher call has some optional parameters. You can call it with an optional default value\nfollowed by zero or more ``jsoncfg.JSONValueMapper`` instances. The default value comes in handy when\nyou are querying an **optional** item from a json object:\n\n.. code-block:: python\n\n    # If \"optional_value\" isn't in the config then return the default value (50).\n    v0 = config.optional_value(50)\n\n    # This raises an exception if \"required_value\" isn't in the config.\n    v1 = config.required_value()\n\n\nUsing value mappers to validate and/or transform fetched values\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWhether you are using a default value or not you can specify zero or more ``jsoncfg.JSONValueMapper``\ninstances too in the parameter list of the fetcher function call. These instances have to be\ncallable, they have to have a ``__call__`` method that receives one parameter - the fetched value -\nand they have to return the transformed (or untouched) value. If you specify more than one value\nmapper instances then these value mappers are applied to the fetched value in left-to-right order\nas you specify them in the argument list. You can use these value mapper instances not only to\ntransform the fetched value, but also to perform (type) checks on them. The ``jsoncfg.value_mappers``\nmodule contains a few predefined type-checkers but you can create your own value mappers.\n\n.. warning::\n\n    If you specify both a default value and one or more value mapper instances in your value fetcher\n    call then the value mappers are never applied to the default value. The value mappers are used\n    only when you fetch a value that exists in the config. json-cfg uses either the default value\n    or the list of value mapper instances but not both.\n\n.. code-block:: python\n\n    from jsoncfg.value_mappers import RequireType\n    from jsoncfg.value_mappers import require_list, require_string, require_integer, require_number\n\n    # require_list is a jsoncfg.JSONValueMapper instance that checks if the fetched value is a list.\n    # If the \"servers\" key is missing form the config or its type isn't list then an exception is\n    # raised because we haven't specified a default value.\n    python_server_list = config.servers(require_list)\n\n    # If the \"servers\" key is missing from the config then the return value is None. If \"servers\"\n    # is in the config and it isn't a list instance then an exception is raised otherwise the\n    # return value is the servers list.\n    python_server_list = config.servers(None, require_list)\n\n    # Querying the required ip_address parameter with required string type.\n    ip_address = config.servers[0].ip_address(require_string)\n\n    # Querying the optional port parameter with a default value of 8000.\n    # If the optional port parameter is specified in the config then it has to be an integer.\n    ip_address = config.servers[0].port(8000, require_integer)\n\n    # An optional timeout parameter with a default value of 5. If the timeout parameter is in\n    # the config then it has to be a number (int, long, or float).\n    timeout = config.timeout(5, require_number)\n\n    # Getting a required guest_name parameter from the config. The parameter has to be either\n    # None (null in the json file) or a string.\n    guest_name = config.guest_name(RequireType(type(None), str))\n\n\nWriting a custom value mapper (or validator)\n````````````````````````````````````````````\n\n- Derive your own value mapper class from ``jsoncfg.JSONValueMapper``.\n- Implement the ``__call__`` method that receives one value and returns one value:\n\n    - Your ``__call__`` method can return the received value intact but it is allowed to\n      return a completely different transformed value.\n    - Your ``__call__`` implementation can perform validation. If the validation fails then\n      you have to raise an exception. This exception can be anything but if you don't have\n      a better idea then simply use the standard ``ValueError`` or ``TypeError``. This exception\n      is caught by the value fetcher call and re-raised as another json-cfg specific\n      exception that contains useful error message with the location of the error and that\n      exception also contains the exception you raised while validating.\n\nCustom value mapper example code:\n\n.. code-block:: python\n\n    import datetime\n    import jsoncfg\n    from jsoncfg import JSONValueMapper\n    from jsoncfg.value_mappers import require_integer\n\n    class OneOf(JSONValueMapper):\n        def __init__(self, *enum_members):\n            self.enum_members = set(enum_members)\n\n        def __call__(self, v):\n            if v not in self.enum_members:\n                raise ValueError('%r is not one of these: %r' % (v, self.enum_members))\n            return v\n\n    class RangeCheck(JSONValueMapper):\n        def __init__(self, min_, max_):\n            self.min = min_\n            self.max = max_\n\n        def __call__(self, v):\n            if self.min <= v < self.max:\n                return v\n            raise ValueError('%r is not in range [%r, %r)' % (v, self.min, self.max))\n\n    class ToDateTime(JSONValueMapper):\n        def __call__(self, v):\n            if not isinstance(v, str):\n                raise TypeError('Expected a naive iso8601 datetime string but found %r' % (v,))\n            return datetime.datetime.strptime(v, '%Y-%m-%dT%H:%M:%S')\n\n    config = jsoncfg.load_config('server.cfg')\n\n    # Creating a value mapper instance for reuse.\n    require_cool_superuser_name = OneOf('tron', 'neo')\n    superuser_name = config.superuser_name(None, require_cool_superuser_name)\n\n    check_http_port_range = RangeCheck(8000, 9000)\n    port = config.servers[0].port(8000, check_http_port_range)\n\n    # Chaining value mappers. First require_integer receives the value of the port\n    # attribute, checks/transforms it and the output of require_integer goes\n    # to the check_http_port_range value mapper. What you receive as a result of\n    # value fetching is the output of check_http_port_range.\n    port = config.servers[0].port(require_integer, check_http_port_range)\n\n    # to_datetime converts a naive iso8601 datetime string into a datetime instance.\n    to_datetime = ToDateTime()\n    superuser_birthday = config.superuser_birthday(None, to_datetime)\n\n\nSetting python values to the wrapper objects and saving the config\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\njsoncfg can also be used to write back the json config file. However, the file will be\nwritten using json.dump, and all comments will be lost.\n\n.. code-block:: python\n\n    # TODO : Unit tests based on this example\n\n    import jsoncfg\n\n    server_file_name = 'server.cfg'\n\n    config = jsoncfg.load_config(server_file_name)\n\n    # Create some values and store them\n    arr = [1, 2, \"three\"]\n    config.example_arr = arr\n\n    # As \"subobj1\" doesn't exist, it will be created as a json object, and then \"val1\"\n    # will be assigned to it\n    val1 = \"This is a string value\"\n    config.subobj1.val1 = val1\n\n    # The assignment is clever enough to accept json compatible structures\n    obj = {\"key1\":1,\n           \"key2\":\"two\",\n           \"subobj1\": {} }\n    c.obj1 = obj\n\n    # Now that we've created some data, we can save it.\n    jsoncfg.save_config(server_file_name, config)\n\n    # Now lets load it up again and check that the values match\n    config = jsoncfg.load_config(server_file_name)\n    assert config.example_arr == arr\n    assert config.subobj1.val1 == val1\n    assert str(config.obj1) == str(obj) # This comparison may not work\n\n\nSaving the config with a with block\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\njsoncfg has a wrapper class and a with block, taking much of the burdon away from\ndeciding if you need to save or not\n\n.. code-block:: python\n\n    # TODO : Unit tests based on this example\n\n    import jsoncfg\n\n    server_file_name = 'server.cfg'\n    obj = {\"key1\":1,\n           \"key2\":\"two\",\n           \"subobj1\": {} }\n    arr = [1, 2, \"three\"]\n    val1 = \"This is a string value\"\n\n    config = jsoncfg.ConfigWithWrapper('server.cfg')\n\n    with config as c:\n        # This will store an array as a property of the root config object\n        c.example_arr = arr\n\n        # As \"subobj1\" doesn't exist, it will be created as a json object, and then \"val1\"\n        # will be assigned to it\n        c.subobj1.val1 = val1\n\n        # The assignment is clever enough to accept json compatible structures\n        c.obj1 = obj\n\n    # The config file is automatically saved when we left the with block\n\n    # Now lets load it up again and check that the values match\n    config = jsoncfg.load_config(server_file_name)\n    assert config.example_arr == arr\n    assert config.subobj1.val1 == val1\n    assert str(config.obj1) == str(obj) # This comparison may not work\n\n\nError handling: exceptions\n--------------------------\n\nThe base of all library exceptions is ``jsoncfg.JSONConfigException``. If the parsed json contains a\nsyntax error then you receive a ``jsoncfg.JSONConfigParserException`` - this exception has no\nsubclasses. In case of config query errors you receive a ``jsoncfg.JSONConfigQueryError`` - this\nexception has several subclasses.\n\n.. code-block::\n\n                         +---------------------+\n                         | JSONConfigException |\n                         +---------------------+\n                            ^               ^\n                            |               |\n        +-------------------+-------+       |\n        | JSONConfigParserException |       |\n        +---------------------------+       |\n                                      +-----+----------------+\n              +---------------------->| JSONConfigQueryError |<------------------------+\n              |                       +----------------------+                         |\n              |                          ^                ^                            |\n              |                          |                |                            |\n              |   +----------------------+-----+    +-----+------------------------+   |\n              |   | JSONConfigValueMapperError |    | JSONConfigValueNotFoundError |   |\n              |   +----------------------------+    +------------------------------+   |\n              |                                                                        |\n        +-----+-------------------+                                   +----------------+-----+\n        | JSONConfigNodeTypeError |                                   | JSONConfigIndexError |\n        +-------------------------+                                   +----------------------+\n\njsoncfg.\\ **JSONConfigException**\n\n    This is the mother of all exceptions raised by the library (aside from some some ``ValueError``s\n    and ``TypeErrors`` that are raised in case of trivial programming mistakes). Note that this\n    exception is never raised directly - the library raises only exceptions that are derived from\n    this.\n\njsoncfg.\\ **JSONConfigParserException**\n\n    You receive this exception if there is a syntax error in the parsed json.\n\n    - ``error_message``: The error message without the line/column number\n      info. The standard ``Exception.message`` field contains this very same message but with the\n      line/column info formatted into it as a postfix.\n    - ``line``, ``column``: line and column information to locate the error easily in the parsed json.\n\njsoncfg.\\ **JSONConfigQueryError**\n\n    You receive this exception in case of errors you make while processing the parsed json. This\n    exception class is never instantiated directly, only its subclasses are used.\n\n    - ``config_node``: The json node/element that was processed when the error happened.\n    - ``line``, ``column``: line and column information to locate the error easily in the parsed json.\n\njsoncfg.\\ **JSONConfigValueMapperError**\n\n    Raised when you query and fetch a value by specifying a value mapper but the value mapper\n    instance raises an exception during while fetching the value.\n\n    - ``mapper_exception``: The exception instance raised by the value mapper.\n\njsoncfg.\\ **JSONConfigValueNotFoundError**\n\n    This is raised when you try to fetch a required (non-optional) value that doesn't exist in the\n    config file.\n\njsoncfg.\\ **JSONConfigNodeTypeError**\n\n    You get this exception if you try to perform an operation on a node that is not allowed for\n    that node type (object, array or scalar), for example indexing into an array with a string.\n\njsoncfg.\\ **JSONConfigIndexError**\n\n    Over-indexing a json array results in this exception.\n\n    - ``index``: The index used to over-index the array.\n\nUtility functions\n-----------------\n\nThe config wrapper objects have no public methods but in some cases you may want to extract some info from them\n(for example line/column number, type of node). You can do that with utility functions that can be imported from\nthe ``jsoncfg`` module.\n\n\njsoncfg.\\ **node_location**\\ *(config_node)*\n\n    Returns the location of the specified config node in the file it was parsed from. The returned location is a\n    named tuple ``NodeLocation(line, column)`` containing the 1-based line and column numbers.\n\njsoncfg.\\ **node_exists**\\ *(config_node)*\n\n    The library doesn't raise an error if you query a non-existing key. It raises error only when you try to fetch\n    a value from it. Querying a non-existing key returns a special ``ValueNotFoundNode`` instance and this function\n    actually checks whether the node is something else than a ``ValueNotFoundNode`` instance. A node can be\n    any part of the json: an object/dict, a list, or any other json value. Before trying to fetch a value from the\n    queried node you can test the result of a query with ``node_exists()`` whether it is an existing or non-existing\n    node in order to handle missing/optional config blocks gracefully without exceptions.\n\n    .. code-block:: python\n\n        from jsoncfg import load_config, node_exists\n\n        config = load_config('my_config.cfg')\n        if node_exists(config.whatever1.whatever2.whatever3):\n            ...\n\n        # OR an equivalent piece of code:\n\n        node = config.whatever1.whatever2.whatever3\n        if node_exists(node):\n            ...\n\n        # This node_exists() call returns True:\n        exists_1 = node_exists(config.existing_key1.existing_key2.existing_key3)\n\n        # This node_exists() call returns False:\n        exists_2 = node_exists(config.non_existing_key1.non_existing_key2)\n\n\njsoncfg.\\ **node_is_object**\\ *(config_node)*\n\n    Returns ``True`` if the specified ``config_node`` is a json object/dict.\n\n\njsoncfg.\\ **node_is_array**\\ *(config_node)*\n\n    Returns ``True`` if the specified ``config_node`` is a json array/list.\n\n\njsoncfg.\\ **node_is_scalar**\\ *(config_node)*\n\n    Returns ``True`` if the specified ``config_node`` is a json value other than an object or array - if it isn't a\n    container.\n\n\njsoncfg.\\ **ensure_exists**\\ *(config_node)*\n\n    Returns the specified ``config_node`` if it is an existing node, otherwise it raises a config error (with\n    config file location info when possible).\n\n\njsoncfg.\\ **expect_object**\\ *(config_node)*\n\n    Returns the specified ``config_node`` if it is a json object/dict, otherwise it raises a config error (with\n    config file location info when possible).\n\n    In many cases you can just query and fetch objects using jsoncfg without doing explicit error handling and\n    jsoncfg provides useful error messages when an error occurs (like trying the fetch the value from a non-existing\n    node, trying to map a non-integer value to an integer, etc...). There is however at least one exception when\n    jsoncfg can't really auto-detect problems in a smart way: When you iterate over a json object or array. A json\n    object returns `(key, value)` pairs during iteration while an array returns simple items. If you just assume\n    (without actually checking) that a config node is a json object/dict and you iterate over it with auto-unpacking\n    the returned `(key, value)` pairs into two variables then you might get into trouble if your assumption is\n    incorrect and the actual config node is a json array. If it is an array then it will return simple items and\n    python fails to unpack it into two variables. The result is an ugly python runtime error and not a nice jsoncfg\n    error that says that the config node is an array and not an object/dict that your code expected. To overcome this\n    problem you can use this ``jsoncfg.expect_object()`` function to ensure that the node you iterate is a json\n    object. The same is recommended in case of json arrays: it is recommended to check them with\n    ``jsoncfg.expect_array()`` before iteration:\n\n    .. code-block:: python\n\n        from jsoncfg import load_config, expect_object, expect_array\n\n        config = load_config('server.cfg')\n        for server in expect_array(config.servers):\n            print('------------')\n            for key, value in expect_object(server):\n                print('%s: %r' % (key, value))\n\n\njsoncfg.\\ **expect_array**\\ *(config_node)*\n\n    Returns the specified ``config_node`` if it is a json array/list, otherwise it raises a config error (with\n    config file location info when possible).\n\n\njsoncfg.\\ **expect_scalar**\\ *(config_node)*\n\n    Returns the specified ``config_node`` if it isn't a json object or array, otherwise it raises a config error (with\n    config file location info when possible).", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pasztorpisti/json-cfg", "keywords": "json config file parser configuration comment", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "json-cfg-rw", "package_url": "https://pypi.org/project/json-cfg-rw/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/json-cfg-rw/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/pasztorpisti/json-cfg"}, "release_url": "https://pypi.org/project/json-cfg-rw/0.5.0/", "requires_dist": null, "requires_python": null, "summary": "JSON config file parser with extended syntax (e.g.: comments), line/column numbers in error messages, etc...", "version": "0.5.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/pasztorpisti/json-cfg\" rel=\"nofollow\"><img alt=\"build\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5ab6e56b79caca3af4ee23ab86bb43e4a4dcd85d/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f7061737a746f7270697374692f6a736f6e2d6366672e7376673f7374796c653d666c6174\"></a>\n<a href=\"https://www.codacy.com/app/pasztorpisti/json-cfg\" rel=\"nofollow\"><img alt=\"code quality\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/974ab6f9f8aad0afd301b6ac62ff9cde9924c548/68747470733a2f2f696d672e736869656c64732e696f2f636f646163792f32353835346130383865383934373266396662663262643563313633333833342e7376673f7374796c653d666c6174\"></a>\n<a href=\"https://landscape.io/github/pasztorpisti/json-cfg/master\" rel=\"nofollow\"><img alt=\"code health\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/46bbfd3276544f56ea373eea558e050600e49a11/68747470733a2f2f6c616e6473636170652e696f2f6769746875622f7061737a746f7270697374692f6a736f6e2d6366672f6d61737465722f6c616e6473636170652e7376673f7374796c653d666c6174\"></a>\n<a href=\"https://coveralls.io/r/pasztorpisti/json-cfg?branch=master\" rel=\"nofollow\"><img alt=\"coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6ad43bc4dc3cc2bec0d6b91db970e468fc147c50/68747470733a2f2f696d672e736869656c64732e696f2f636f766572616c6c732f7061737a746f7270697374692f6a736f6e2d6366672f6d61737465722e7376673f7374796c653d666c6174\"></a>\n<a href=\"https://pypi.python.org/pypi/json-cfg\" rel=\"nofollow\"><img alt=\"pypi\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8bed0d9d27bc46a37f35d93a9cab9747ce7ca05b/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6a736f6e2d6366672e7376673f7374796c653d666c6174\"></a>\n<a href=\"https://github.com/pasztorpisti/json-cfg\" rel=\"nofollow\"><img alt=\"github\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c266ced2e6a079e377cafdf47e4ec1d2a7670112/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f7461672f7061737a746f7270697374692f6a736f6e2d6366672e7376673f7374796c653d666c6174\"></a>\n<a href=\"https://github.com/pasztorpisti/json-cfg/blob/master/LICENSE.txt\" rel=\"nofollow\"><img alt=\"license: MIT\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2e9cbcef65b461812838db7b9e269ba668a6bc37/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f7061737a746f7270697374692f6a736f6e2d6366672e7376673f7374796c653d666c6174\"></a>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#introduction\" id=\"id1\" rel=\"nofollow\">Introduction</a><ul>\n<li><a href=\"#config-file-examples\" id=\"id2\" rel=\"nofollow\">Config file examples</a></li>\n</ul>\n</li>\n<li><a href=\"#usage\" id=\"id3\" rel=\"nofollow\">Usage</a><ul>\n<li><a href=\"#installation\" id=\"id4\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#quick-starter\" id=\"id5\" rel=\"nofollow\">Quick-starter</a></li>\n<li><a href=\"#detailed-explanation-of-the-library-interface\" id=\"id6\" rel=\"nofollow\">Detailed explanation of the library interface</a><ul>\n<li><a href=\"#querying-the-json-config-hierarchy\" id=\"id7\" rel=\"nofollow\">Querying the json config hierarchy</a></li>\n<li><a href=\"#fetching-python-values-from-the-queried-wrapper-objects\" id=\"id8\" rel=\"nofollow\">Fetching python values from the queried wrapper objects</a><ul>\n<li><a href=\"#fetching-optional-config-values-by-specifying-a-default-value\" id=\"id9\" rel=\"nofollow\">Fetching optional config values (by specifying a default value)</a></li>\n<li><a href=\"#using-value-mappers-to-validate-and-or-transform-fetched-values\" id=\"id10\" rel=\"nofollow\">Using value mappers to validate and/or transform fetched values</a><ul>\n<li><a href=\"#writing-a-custom-value-mapper-or-validator\" id=\"id11\" rel=\"nofollow\">Writing a custom value mapper (or validator)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#setting-python-values-to-the-wrapper-objects-and-saving-the-config\" id=\"id12\" rel=\"nofollow\">Setting python values to the wrapper objects and saving the config</a></li>\n<li><a href=\"#saving-the-config-with-a-with-block\" id=\"id13\" rel=\"nofollow\">Saving the config with a with block</a></li>\n</ul>\n</li>\n<li><a href=\"#error-handling-exceptions\" id=\"id14\" rel=\"nofollow\">Error handling: exceptions</a></li>\n<li><a href=\"#utility-functions\" id=\"id15\" rel=\"nofollow\">Utility functions</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"introduction\">\n<h2><a href=\"#id1\" rel=\"nofollow\">Introduction</a></h2>\n<p>The goal of this library is providing a json config file loader that has\nthe following extras compared to the standard <tt>json.load()</tt>:</p>\n<ul>\n<li><p>A larger subset of javascript (and not some weird/exotic extension to json that\nwould turn it into something that has nothing to do with json/javascript):</p>\n<blockquote>\n<ul>\n<li>backward compatible with json so you can still load standard json files too</li>\n<li>single and multi-line comments - this is more useful then you would think:\nit is good not only for documentation but also for temporarily disabling\na block in your config without actually deleting entries</li>\n<li>object (dictionary) keys without quotes: less quotation marks, less noise</li>\n<li>trailing commas (allowing a comma after the last item of objects and arrays)</li>\n</ul>\n</blockquote>\n</li>\n<li><p>Providing line number information for each element of the loaded config file\nand using this to display useful error messages that help locating errors not\nonly while parsing the file but also when processing/interpreting it.</p>\n</li>\n<li><p>A simple config query syntax that handles default values, required elements and\nautomatically raises an exception in case of error (with useful info including\nthe location of the error in the config file).</p>\n</li>\n</ul>\n<div id=\"config-file-examples\">\n<h3><a href=\"#id2\" rel=\"nofollow\">Config file examples</a></h3>\n<p>A traditional json config file:</p>\n<pre><span class=\"p\">{</span>\n    <span class=\"s2\">\"servers\"</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n        <span class=\"p\">{</span>\n            <span class=\"s2\">\"ip_address\"</span><span class=\"o\">:</span> <span class=\"s2\">\"127.0.0.1\"</span><span class=\"p\">,</span>\n            <span class=\"s2\">\"port\"</span><span class=\"o\">:</span> <span class=\"mi\">8080</span>\n        <span class=\"p\">},</span>\n        <span class=\"p\">{</span>\n            <span class=\"s2\">\"ip_address\"</span><span class=\"o\">:</span> <span class=\"s2\">\"127.0.0.1\"</span><span class=\"p\">,</span>\n            <span class=\"s2\">\"port\"</span><span class=\"o\">:</span> <span class=\"mi\">8081</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">],</span>\n    <span class=\"s2\">\"superuser_name\"</span><span class=\"o\">:</span> <span class=\"s2\">\"tron\"</span>\n<span class=\"p\">}</span>\n</pre>\n<p>Something similar but better with json-cfg:</p>\n<pre><span class=\"p\">{</span>\n    <span class=\"c1\">// Note that we can get rid of most quotation marks.\n</span>    <span class=\"nx\">servers</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n        <span class=\"p\">{</span>\n            <span class=\"nx\">ip_address</span><span class=\"o\">:</span> <span class=\"s2\">\"127.0.0.1\"</span><span class=\"p\">,</span>\n            <span class=\"nx\">port</span><span class=\"o\">:</span> <span class=\"mi\">8080</span>\n        <span class=\"p\">},</span>\n        <span class=\"c1\">// We have commented out the block of the second server below.\n</span>        <span class=\"c1\">// Trailing commas are allowed so the comma after the\n</span>        <span class=\"c1\">// first block (above) doesn't cause any problems.\n</span>        <span class=\"cm\">/*\n        {\n            ip_address: \"127.0.0.1\",\n            port: 8081\n        },  // &lt;-- optional trailing comma\n        /**/</span>\n    <span class=\"p\">],</span>\n    <span class=\"nx\">superuser_name</span><span class=\"o\">:</span> <span class=\"s2\">\"tron\"</span><span class=\"p\">,</span>  <span class=\"c1\">// &lt;-- optional trailing comma\n</span><span class=\"p\">}</span>\n</pre>\n<p>Note that json-cfg can load both config files because standard json is a subset of the extended\nsyntax allowed by json-cfg.</p>\n<div>\n<p>Tip</p>\n<p>Use javascript syntax highlight in your text editor for json config files\nwhenever possible - this makes reading config files much easier especially\nwhen you have a lot of comments or large commented config blocks.</p>\n</div>\n</div>\n</div>\n<div id=\"usage\">\n<h2><a href=\"#id3\" rel=\"nofollow\">Usage</a></h2>\n<div id=\"installation\">\n<h3><a href=\"#id4\" rel=\"nofollow\">Installation</a></h3>\n<pre>pip install json-cfg\n</pre>\n<p>Alternatively you can download the zipped library from <a href=\"https://pypi.python.org/pypi/json-cfg\" rel=\"nofollow\">https://pypi.python.org/pypi/json-cfg</a></p>\n</div>\n<div id=\"quick-starter\">\n<h3><a href=\"#id5\" rel=\"nofollow\">Quick-starter</a></h3>\n<p>The json-cfg library provides two modes when it comes to loading config files: One that is very\nsimilar to the standard <tt>json.loads()</tt> and another one that returns the json wrapped into special\nconfig nodes that make handling the config file much easier:</p>\n<ul>\n<li><tt>jsoncfg.load()</tt> and <tt>jsoncfg.loads()</tt> are very similar to the standard <tt>json.loads()</tt>.\nThese functions allow you to load config files into bare python representation of the json\ndata (dictionaries, lists, numbers, etc\u2026).</li>\n<li><tt>jsoncfg.load_config()</tt> and <tt>jsoncfg.loads_config()</tt> load the json data into special wrapper\nobjects that help you to query the config with much nicer syntax. At the same time if you\nare looking for a value that doesn\u2019t exist in the config then these problems are handled with\nexceptions that contain line/column number info about the location of the error.</li>\n</ul>\n<p>One of the biggest problems with loading the config into bare python objects with a simple json\nlibrary is that the loaded json data doesn\u2019t contain the line/column numbers for the loaded json\nnodes/elements. This means that by using a simple json library you can report the location of errors\nwith config file line/column numbers only in case of json syntax errors (in best case).\nBy loading the json nodes/elements into our wrapper objects we can retain the line/column numbers\nfor the json nodes/elements and we can use them in our error messages in case of semantic errors.</p>\n<p>I assume that you have already installed json-cfg and you have the previously shown server config\nexample in a <tt>server.cfg</tt> file in the current directory.</p>\n<p>This is how to load and process the above server configuration with a simple json library:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">json</span>\n\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'server.cfg'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">f</span><span class=\"p\">:</span>\n    <span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">server</span> <span class=\"ow\">in</span> <span class=\"n\">config</span><span class=\"p\">[</span><span class=\"s1\">'servers'</span><span class=\"p\">]:</span>\n    <span class=\"n\">listen_on_interface</span><span class=\"p\">(</span><span class=\"n\">server</span><span class=\"p\">[</span><span class=\"s1\">'ip_address'</span><span class=\"p\">],</span> <span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'port'</span><span class=\"p\">,</span> <span class=\"mi\">8000</span><span class=\"p\">))</span>\n<span class=\"n\">superuser_name</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"p\">[</span><span class=\"s1\">'superuser_name'</span><span class=\"p\">]</span>\n</pre>\n<p>The same with json-cfg:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">jsoncfg</span>\n\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">jsoncfg</span><span class=\"o\">.</span><span class=\"n\">load_config</span><span class=\"p\">(</span><span class=\"s1\">'server.cfg'</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">server</span> <span class=\"ow\">in</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">servers</span><span class=\"p\">:</span>\n    <span class=\"n\">listen_on_interface</span><span class=\"p\">(</span><span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">ip_address</span><span class=\"p\">(),</span> <span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">port</span><span class=\"p\">(</span><span class=\"mi\">8000</span><span class=\"p\">))</span>\n<span class=\"n\">superuser_name</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">superuser_name</span><span class=\"p\">()</span>\n</pre>\n<p>Seemingly the difference isn\u2019t that big. With json-cfg you can use extended syntax in the config\nfile and the code that loads/processes the config is also somewhat nicer but real difference is\nwhat happens when you encounter an error. With json-cfg you get an exception with a message that\npoints to the problematic part of the json config file while the pure-json example can\u2019t tell you\nline/column numbers in the config file. In case of larger configs this can cause headaches.</p>\n<p>Open your <tt>server.cfg</tt> file and remove the required <tt>ip_address</tt> attribute from one of the server\nconfig blocks. This will cause an error when we try to load the config file with the above code\nexamples. The above code snippets report the following error messages in this scenario:</p>\n<p>json:</p>\n<pre>KeyError: 'ip_address'\n</pre>\n<p>json-cfg:</p>\n<pre>jsoncfg.config_classes.JSONConfigValueNotFoundError: Required config node not found. Missing query path: .ip_address (relative to error location) [line=3;col=9]\n</pre>\n</div>\n<div id=\"detailed-explanation-of-the-library-interface\">\n<h3><a href=\"#id6\" rel=\"nofollow\">Detailed explanation of the library interface</a></h3>\n<p>When you load your json with <tt>jsoncfg.load_config()</tt> or <tt>jsoncfg.loads_config()</tt> the returned json\ndata - the hierarchy - is a tree of wrapper objects provided by this library. These wrapper objects\nmake it possible to store the column/line numbers for each json node/element (for error reporting)\nand these wrappers allow you to query the config with the nice syntax you\u2019ve seen above.</p>\n<p>This library differentiates 3 types of json nodes/elements and each of these have their own wrapper\nclasses:</p>\n<ul>\n<li>json object (dictionary like stuff)</li>\n<li>json array (list like stuff)</li>\n<li>json scalar (I use \u201cscalar\u201d to refer any json value that isn\u2019t a container)</li>\n</ul>\n<p>I use <em>json value</em> to refer to any json node/element whose type is unknown or unimportant.\nThe public API of the wrapper classes is very simple: they have no public methods. All they provide\nis a few magic methods that you can use to read/query the loaded json data. (These magic methods\nare <tt>__contains__</tt>, <tt>__getattr__</tt>, <tt>__getitem__</tt>, <tt>__len__</tt>, <tt>__iter__</tt> and <tt>__call__</tt> but don\u2019t\nworry if you don\u2019t know about these magic methods as I will demonstrate the usage with simple code\nexamples that don\u2019t assume that you know them.)\nThe reason for having no public methods is simple: We allow querying json object keys with\n<tt>__getattr__</tt> (with the dot or member access operator like <tt>config.myvalue</tt>) and we don\u2019t want any\npublic methods to conflict with the key values in your config file.</p>\n<p>After loading the config you have a tree of wrapper object nodes and you have to perform these two\noperations to get values from the config:</p>\n<ol>\n<li>querying/reading/traversing the json hierarchy: the result of querying is a wrapper object</li>\n<li>fetching the python value from the selected wrapper object: this can be done by calling the\nqueried wrapper object.</li>\n</ol>\n<p>The following sections explain these two operations in detail.</p>\n<div id=\"querying-the-json-config-hierarchy\">\n<h4><a href=\"#id7\" rel=\"nofollow\">Querying the json config hierarchy</a></h4>\n<p>To read and query the json hierarchy and the wrapper object nodes that build up the tree you have\nto exploit the <tt>__contains__</tt>, <tt>__getattr__</tt>, <tt>__getitem__</tt>, <tt>__len__</tt>, <tt>__iter__</tt> magic methods\nof the wrapper objects. We will use the previously shown server config for the following examples.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">jsoncfg</span>\n\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">jsoncfg</span><span class=\"o\">.</span><span class=\"n\">load_config</span><span class=\"p\">(</span><span class=\"s1\">'server.cfg'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Using __getattr__ to get the servers key from the config json object.</span>\n<span class=\"c1\"># The result of this expression is a wrapper object that wraps the servers array/list.</span>\n<span class=\"n\">server_array</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">servers</span>\n\n<span class=\"c1\"># The equivalent of the previous expression using __getitem__:</span>\n<span class=\"n\">server_array</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"p\">[</span><span class=\"s1\">'servers'</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Note that querying a non-existing key from an object doesn't raise an error. Instead</span>\n<span class=\"c1\"># it returns a special ValueNotFoundNode instance that you can continue using as a</span>\n<span class=\"c1\"># wrapper object. The error happens only if you try to fetch the value of this key</span>\n<span class=\"c1\"># without specifying a default value - but more on this later in the section where we</span>\n<span class=\"c1\"># discuss value fetching from wrapper objects.</span>\n<span class=\"n\">special_value_not_found_node</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">non_existing_key</span>\n\n<span class=\"c1\"># Checking whether a key exists in a json object:</span>\n<span class=\"n\">servers_exists</span> <span class=\"o\">=</span> <span class=\"s1\">'servers'</span> <span class=\"ow\">in</span> <span class=\"n\">config</span>\n\n<span class=\"c1\"># Using __getitem__ to index into json array wrapper objects:</span>\n<span class=\"c1\"># Over-indexing the array would raise an exception with useful error message</span>\n<span class=\"c1\"># containing the location of the servers_array in the config file.</span>\n<span class=\"n\">first_item_wrapper_object</span> <span class=\"o\">=</span> <span class=\"n\">servers_array</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Getting the length of json object and json array wrappers:</span>\n<span class=\"n\">num_config_key_value_pairs</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"p\">)</span>\n<span class=\"n\">servers_array_len</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">servers_array</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Iterating the items of a json object or array:</span>\n<span class=\"k\">for</span> <span class=\"n\">key_string</span><span class=\"p\">,</span> <span class=\"n\">value_wrapper_object</span> <span class=\"ow\">in</span> <span class=\"n\">config</span><span class=\"p\">:</span>\n    <span class=\"k\">pass</span>\n<span class=\"k\">for</span> <span class=\"n\">value_wrapper_object</span> <span class=\"ow\">in</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">servers</span><span class=\"p\">:</span>\n    <span class=\"k\">pass</span>\n</pre>\n<p>Not all node types (object, array, scalar) support all operations. For example a scalar json value\ndoesn\u2019t support <tt>len()</tt> and you can not iterate it. What happens if someone puts a scalar value\ninto the config in place of the servers array? In that case the config loader code sooner or\nlater performs an array-specific operation on that scalar value (for example iteration) and this\nraises an exception with a useful error message pointing the the loader code with the stack trace\nand pointing to the scalar value in the config file with line/column numbers. You can find more info\nabout json-node-type related checks and error handling mechanisms in the following sections (value\nfetching and error handling).</p>\n</div>\n<div id=\"fetching-python-values-from-the-queried-wrapper-objects\">\n<h4><a href=\"#id8\" rel=\"nofollow\">Fetching python values from the queried wrapper objects</a></h4>\n<p>After selecting any of the wrapper object nodes from the json config hierarchy you can fetch its\nwrapped value by using its <tt>__call__</tt> magic method. This works on all json node types: objects,\narrays and scalars. If you fetch a container (object or array) then this fetch is recursive: it\nfetches the whole subtree whose root node is the fetched wrapper object. In most cases it is a\ngood practice to fetch only leaf nodes of the config. Leaving the containers (objects, arrays) in\nwrappers helps getting better error messages if something goes wrong while you are processing the\nconfig data.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">jsoncfg</span>\n\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">jsoncfg</span><span class=\"o\">.</span><span class=\"n\">load_config</span><span class=\"p\">(</span><span class=\"s1\">'server.cfg'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Fetching the value of the whole json object hierarchy.</span>\n<span class=\"c1\"># python_hierarchy now looks like something you normally</span>\n<span class=\"c1\"># get as a result of a standard ``json.load()``.</span>\n<span class=\"n\">python_hierarchy</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Converting only the servers array into python-object format:</span>\n<span class=\"n\">python_server_list</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">servers</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Getting the ip_address of the first server.</span>\n<span class=\"n\">server_0_ip_address_str</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">servers</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">ip_address</span><span class=\"p\">()</span>\n</pre>\n<div id=\"fetching-optional-config-values-by-specifying-a-default-value\">\n<h5><a href=\"#id9\" rel=\"nofollow\">Fetching optional config values (by specifying a default value)</a></h5>\n<p>The value fetcher call has some optional parameters. You can call it with an optional default value\nfollowed by zero or more <tt>jsoncfg.JSONValueMapper</tt> instances. The default value comes in handy when\nyou are querying an <strong>optional</strong> item from a json object:</p>\n<pre><span class=\"c1\"># If \"optional_value\" isn't in the config then return the default value (50).</span>\n<span class=\"n\">v0</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">optional_value</span><span class=\"p\">(</span><span class=\"mi\">50</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># This raises an exception if \"required_value\" isn't in the config.</span>\n<span class=\"n\">v1</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">required_value</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"using-value-mappers-to-validate-and-or-transform-fetched-values\">\n<h5><a href=\"#id10\" rel=\"nofollow\">Using value mappers to validate and/or transform fetched values</a></h5>\n<p>Whether you are using a default value or not you can specify zero or more <tt>jsoncfg.JSONValueMapper</tt>\ninstances too in the parameter list of the fetcher function call. These instances have to be\ncallable, they have to have a <tt>__call__</tt> method that receives one parameter - the fetched value -\nand they have to return the transformed (or untouched) value. If you specify more than one value\nmapper instances then these value mappers are applied to the fetched value in left-to-right order\nas you specify them in the argument list. You can use these value mapper instances not only to\ntransform the fetched value, but also to perform (type) checks on them. The <tt>jsoncfg.value_mappers</tt>\nmodule contains a few predefined type-checkers but you can create your own value mappers.</p>\n<div>\n<p>Warning</p>\n<p>If you specify both a default value and one or more value mapper instances in your value fetcher\ncall then the value mappers are never applied to the default value. The value mappers are used\nonly when you fetch a value that exists in the config. json-cfg uses either the default value\nor the list of value mapper instances but not both.</p>\n</div>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">jsoncfg.value_mappers</span> <span class=\"kn\">import</span> <span class=\"n\">RequireType</span>\n<span class=\"kn\">from</span> <span class=\"nn\">jsoncfg.value_mappers</span> <span class=\"kn\">import</span> <span class=\"n\">require_list</span><span class=\"p\">,</span> <span class=\"n\">require_string</span><span class=\"p\">,</span> <span class=\"n\">require_integer</span><span class=\"p\">,</span> <span class=\"n\">require_number</span>\n\n<span class=\"c1\"># require_list is a jsoncfg.JSONValueMapper instance that checks if the fetched value is a list.</span>\n<span class=\"c1\"># If the \"servers\" key is missing form the config or its type isn't list then an exception is</span>\n<span class=\"c1\"># raised because we haven't specified a default value.</span>\n<span class=\"n\">python_server_list</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">servers</span><span class=\"p\">(</span><span class=\"n\">require_list</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># If the \"servers\" key is missing from the config then the return value is None. If \"servers\"</span>\n<span class=\"c1\"># is in the config and it isn't a list instance then an exception is raised otherwise the</span>\n<span class=\"c1\"># return value is the servers list.</span>\n<span class=\"n\">python_server_list</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">servers</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">require_list</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Querying the required ip_address parameter with required string type.</span>\n<span class=\"n\">ip_address</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">servers</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">ip_address</span><span class=\"p\">(</span><span class=\"n\">require_string</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Querying the optional port parameter with a default value of 8000.</span>\n<span class=\"c1\"># If the optional port parameter is specified in the config then it has to be an integer.</span>\n<span class=\"n\">ip_address</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">servers</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">port</span><span class=\"p\">(</span><span class=\"mi\">8000</span><span class=\"p\">,</span> <span class=\"n\">require_integer</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># An optional timeout parameter with a default value of 5. If the timeout parameter is in</span>\n<span class=\"c1\"># the config then it has to be a number (int, long, or float).</span>\n<span class=\"n\">timeout</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">timeout</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">require_number</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Getting a required guest_name parameter from the config. The parameter has to be either</span>\n<span class=\"c1\"># None (null in the json file) or a string.</span>\n<span class=\"n\">guest_name</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">guest_name</span><span class=\"p\">(</span><span class=\"n\">RequireType</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">),</span> <span class=\"nb\">str</span><span class=\"p\">))</span>\n</pre>\n<div id=\"writing-a-custom-value-mapper-or-validator\">\n<h6><a href=\"#id11\" rel=\"nofollow\">Writing a custom value mapper (or validator)</a></h6>\n<ul>\n<li><p>Derive your own value mapper class from <tt>jsoncfg.JSONValueMapper</tt>.</p>\n</li>\n<li><p>Implement the <tt>__call__</tt> method that receives one value and returns one value:</p>\n<blockquote>\n<ul>\n<li>Your <tt>__call__</tt> method can return the received value intact but it is allowed to\nreturn a completely different transformed value.</li>\n<li>Your <tt>__call__</tt> implementation can perform validation. If the validation fails then\nyou have to raise an exception. This exception can be anything but if you don\u2019t have\na better idea then simply use the standard <tt>ValueError</tt> or <tt>TypeError</tt>. This exception\nis caught by the value fetcher call and re-raised as another json-cfg specific\nexception that contains useful error message with the location of the error and that\nexception also contains the exception you raised while validating.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<p>Custom value mapper example code:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">datetime</span>\n<span class=\"kn\">import</span> <span class=\"nn\">jsoncfg</span>\n<span class=\"kn\">from</span> <span class=\"nn\">jsoncfg</span> <span class=\"kn\">import</span> <span class=\"n\">JSONValueMapper</span>\n<span class=\"kn\">from</span> <span class=\"nn\">jsoncfg.value_mappers</span> <span class=\"kn\">import</span> <span class=\"n\">require_integer</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">OneOf</span><span class=\"p\">(</span><span class=\"n\">JSONValueMapper</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">enum_members</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">enum_members</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">(</span><span class=\"n\">enum_members</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">v</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">enum_members</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"si\">%r</span><span class=\"s1\"> is not one of these: </span><span class=\"si\">%r</span><span class=\"s1\">'</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">enum_members</span><span class=\"p\">))</span>\n        <span class=\"k\">return</span> <span class=\"n\">v</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">RangeCheck</span><span class=\"p\">(</span><span class=\"n\">JSONValueMapper</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">min_</span><span class=\"p\">,</span> <span class=\"n\">max_</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">min</span> <span class=\"o\">=</span> <span class=\"n\">min_</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">max_</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">min</span> <span class=\"o\">&lt;=</span> <span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">max</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">v</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"si\">%r</span><span class=\"s1\"> is not in range [</span><span class=\"si\">%r</span><span class=\"s1\">, </span><span class=\"si\">%r</span><span class=\"s1\">)'</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">min</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">max</span><span class=\"p\">))</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ToDateTime</span><span class=\"p\">(</span><span class=\"n\">JSONValueMapper</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">):</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s1\">'Expected a naive iso8601 datetime string but found </span><span class=\"si\">%r</span><span class=\"s1\">'</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,))</span>\n        <span class=\"k\">return</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">strptime</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">,</span> <span class=\"s1\">'%Y-%m-</span><span class=\"si\">%d</span><span class=\"s1\">T%H:%M:%S'</span><span class=\"p\">)</span>\n\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">jsoncfg</span><span class=\"o\">.</span><span class=\"n\">load_config</span><span class=\"p\">(</span><span class=\"s1\">'server.cfg'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Creating a value mapper instance for reuse.</span>\n<span class=\"n\">require_cool_superuser_name</span> <span class=\"o\">=</span> <span class=\"n\">OneOf</span><span class=\"p\">(</span><span class=\"s1\">'tron'</span><span class=\"p\">,</span> <span class=\"s1\">'neo'</span><span class=\"p\">)</span>\n<span class=\"n\">superuser_name</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">superuser_name</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">require_cool_superuser_name</span><span class=\"p\">)</span>\n\n<span class=\"n\">check_http_port_range</span> <span class=\"o\">=</span> <span class=\"n\">RangeCheck</span><span class=\"p\">(</span><span class=\"mi\">8000</span><span class=\"p\">,</span> <span class=\"mi\">9000</span><span class=\"p\">)</span>\n<span class=\"n\">port</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">servers</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">port</span><span class=\"p\">(</span><span class=\"mi\">8000</span><span class=\"p\">,</span> <span class=\"n\">check_http_port_range</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Chaining value mappers. First require_integer receives the value of the port</span>\n<span class=\"c1\"># attribute, checks/transforms it and the output of require_integer goes</span>\n<span class=\"c1\"># to the check_http_port_range value mapper. What you receive as a result of</span>\n<span class=\"c1\"># value fetching is the output of check_http_port_range.</span>\n<span class=\"n\">port</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">servers</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">port</span><span class=\"p\">(</span><span class=\"n\">require_integer</span><span class=\"p\">,</span> <span class=\"n\">check_http_port_range</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># to_datetime converts a naive iso8601 datetime string into a datetime instance.</span>\n<span class=\"n\">to_datetime</span> <span class=\"o\">=</span> <span class=\"n\">ToDateTime</span><span class=\"p\">()</span>\n<span class=\"n\">superuser_birthday</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">superuser_birthday</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">to_datetime</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n</div>\n<div id=\"setting-python-values-to-the-wrapper-objects-and-saving-the-config\">\n<h4><a href=\"#id12\" rel=\"nofollow\">Setting python values to the wrapper objects and saving the config</a></h4>\n<p>jsoncfg can also be used to write back the json config file. However, the file will be\nwritten using json.dump, and all comments will be lost.</p>\n<pre><span class=\"c1\"># TODO : Unit tests based on this example</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">jsoncfg</span>\n\n<span class=\"n\">server_file_name</span> <span class=\"o\">=</span> <span class=\"s1\">'server.cfg'</span>\n\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">jsoncfg</span><span class=\"o\">.</span><span class=\"n\">load_config</span><span class=\"p\">(</span><span class=\"n\">server_file_name</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Create some values and store them</span>\n<span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s2\">\"three\"</span><span class=\"p\">]</span>\n<span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">example_arr</span> <span class=\"o\">=</span> <span class=\"n\">arr</span>\n\n<span class=\"c1\"># As \"subobj1\" doesn't exist, it will be created as a json object, and then \"val1\"</span>\n<span class=\"c1\"># will be assigned to it</span>\n<span class=\"n\">val1</span> <span class=\"o\">=</span> <span class=\"s2\">\"This is a string value\"</span>\n<span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">subobj1</span><span class=\"o\">.</span><span class=\"n\">val1</span> <span class=\"o\">=</span> <span class=\"n\">val1</span>\n\n<span class=\"c1\"># The assignment is clever enough to accept json compatible structures</span>\n<span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"key1\"</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">,</span>\n       <span class=\"s2\">\"key2\"</span><span class=\"p\">:</span><span class=\"s2\">\"two\"</span><span class=\"p\">,</span>\n       <span class=\"s2\">\"subobj1\"</span><span class=\"p\">:</span> <span class=\"p\">{}</span> <span class=\"p\">}</span>\n<span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">obj1</span> <span class=\"o\">=</span> <span class=\"n\">obj</span>\n\n<span class=\"c1\"># Now that we've created some data, we can save it.</span>\n<span class=\"n\">jsoncfg</span><span class=\"o\">.</span><span class=\"n\">save_config</span><span class=\"p\">(</span><span class=\"n\">server_file_name</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Now lets load it up again and check that the values match</span>\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">jsoncfg</span><span class=\"o\">.</span><span class=\"n\">load_config</span><span class=\"p\">(</span><span class=\"n\">server_file_name</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">example_arr</span> <span class=\"o\">==</span> <span class=\"n\">arr</span>\n<span class=\"k\">assert</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">subobj1</span><span class=\"o\">.</span><span class=\"n\">val1</span> <span class=\"o\">==</span> <span class=\"n\">val1</span>\n<span class=\"k\">assert</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">obj1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span> <span class=\"c1\"># This comparison may not work</span>\n</pre>\n</div>\n<div id=\"saving-the-config-with-a-with-block\">\n<h4><a href=\"#id13\" rel=\"nofollow\">Saving the config with a with block</a></h4>\n<p>jsoncfg has a wrapper class and a with block, taking much of the burdon away from\ndeciding if you need to save or not</p>\n<pre><span class=\"c1\"># TODO : Unit tests based on this example</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">jsoncfg</span>\n\n<span class=\"n\">server_file_name</span> <span class=\"o\">=</span> <span class=\"s1\">'server.cfg'</span>\n<span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"key1\"</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">,</span>\n       <span class=\"s2\">\"key2\"</span><span class=\"p\">:</span><span class=\"s2\">\"two\"</span><span class=\"p\">,</span>\n       <span class=\"s2\">\"subobj1\"</span><span class=\"p\">:</span> <span class=\"p\">{}</span> <span class=\"p\">}</span>\n<span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s2\">\"three\"</span><span class=\"p\">]</span>\n<span class=\"n\">val1</span> <span class=\"o\">=</span> <span class=\"s2\">\"This is a string value\"</span>\n\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">jsoncfg</span><span class=\"o\">.</span><span class=\"n\">ConfigWithWrapper</span><span class=\"p\">(</span><span class=\"s1\">'server.cfg'</span><span class=\"p\">)</span>\n\n<span class=\"k\">with</span> <span class=\"n\">config</span> <span class=\"k\">as</span> <span class=\"n\">c</span><span class=\"p\">:</span>\n    <span class=\"c1\"># This will store an array as a property of the root config object</span>\n    <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">example_arr</span> <span class=\"o\">=</span> <span class=\"n\">arr</span>\n\n    <span class=\"c1\"># As \"subobj1\" doesn't exist, it will be created as a json object, and then \"val1\"</span>\n    <span class=\"c1\"># will be assigned to it</span>\n    <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">subobj1</span><span class=\"o\">.</span><span class=\"n\">val1</span> <span class=\"o\">=</span> <span class=\"n\">val1</span>\n\n    <span class=\"c1\"># The assignment is clever enough to accept json compatible structures</span>\n    <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">obj1</span> <span class=\"o\">=</span> <span class=\"n\">obj</span>\n\n<span class=\"c1\"># The config file is automatically saved when we left the with block</span>\n\n<span class=\"c1\"># Now lets load it up again and check that the values match</span>\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">jsoncfg</span><span class=\"o\">.</span><span class=\"n\">load_config</span><span class=\"p\">(</span><span class=\"n\">server_file_name</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">example_arr</span> <span class=\"o\">==</span> <span class=\"n\">arr</span>\n<span class=\"k\">assert</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">subobj1</span><span class=\"o\">.</span><span class=\"n\">val1</span> <span class=\"o\">==</span> <span class=\"n\">val1</span>\n<span class=\"k\">assert</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">obj1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span> <span class=\"c1\"># This comparison may not work</span>\n</pre>\n</div>\n</div>\n<div id=\"error-handling-exceptions\">\n<h3><a href=\"#id14\" rel=\"nofollow\">Error handling: exceptions</a></h3>\n<p>The base of all library exceptions is <tt>jsoncfg.JSONConfigException</tt>. If the parsed json contains a\nsyntax error then you receive a <tt>jsoncfg.JSONConfigParserException</tt> - this exception has no\nsubclasses. In case of config query errors you receive a <tt>jsoncfg.JSONConfigQueryError</tt> - this\nexception has several subclasses.</p>\n<pre>                 +---------------------+\n                 | JSONConfigException |\n                 +---------------------+\n                    ^               ^\n                    |               |\n+-------------------+-------+       |\n| JSONConfigParserException |       |\n+---------------------------+       |\n                              +-----+----------------+\n      +----------------------&gt;| JSONConfigQueryError |&lt;------------------------+\n      |                       +----------------------+                         |\n      |                          ^                ^                            |\n      |                          |                |                            |\n      |   +----------------------+-----+    +-----+------------------------+   |\n      |   | JSONConfigValueMapperError |    | JSONConfigValueNotFoundError |   |\n      |   +----------------------------+    +------------------------------+   |\n      |                                                                        |\n+-----+-------------------+                                   +----------------+-----+\n| JSONConfigNodeTypeError |                                   | JSONConfigIndexError |\n+-------------------------+                                   +----------------------+\n</pre>\n<p>jsoncfg.<strong>JSONConfigException</strong></p>\n<blockquote>\nThis is the mother of all exceptions raised by the library (aside from some some <tt><span class=\"pre\">ValueError``s</span>\nand ``TypeErrors</tt> that are raised in case of trivial programming mistakes). Note that this\nexception is never raised directly - the library raises only exceptions that are derived from\nthis.</blockquote>\n<p>jsoncfg.<strong>JSONConfigParserException</strong></p>\n<blockquote>\n<p>You receive this exception if there is a syntax error in the parsed json.</p>\n<ul>\n<li><tt>error_message</tt>: The error message without the line/column number\ninfo. The standard <tt>Exception.message</tt> field contains this very same message but with the\nline/column info formatted into it as a postfix.</li>\n<li><tt>line</tt>, <tt>column</tt>: line and column information to locate the error easily in the parsed json.</li>\n</ul>\n</blockquote>\n<p>jsoncfg.<strong>JSONConfigQueryError</strong></p>\n<blockquote>\n<p>You receive this exception in case of errors you make while processing the parsed json. This\nexception class is never instantiated directly, only its subclasses are used.</p>\n<ul>\n<li><tt>config_node</tt>: The json node/element that was processed when the error happened.</li>\n<li><tt>line</tt>, <tt>column</tt>: line and column information to locate the error easily in the parsed json.</li>\n</ul>\n</blockquote>\n<p>jsoncfg.<strong>JSONConfigValueMapperError</strong></p>\n<blockquote>\n<p>Raised when you query and fetch a value by specifying a value mapper but the value mapper\ninstance raises an exception during while fetching the value.</p>\n<ul>\n<li><tt>mapper_exception</tt>: The exception instance raised by the value mapper.</li>\n</ul>\n</blockquote>\n<p>jsoncfg.<strong>JSONConfigValueNotFoundError</strong></p>\n<blockquote>\nThis is raised when you try to fetch a required (non-optional) value that doesn\u2019t exist in the\nconfig file.</blockquote>\n<p>jsoncfg.<strong>JSONConfigNodeTypeError</strong></p>\n<blockquote>\nYou get this exception if you try to perform an operation on a node that is not allowed for\nthat node type (object, array or scalar), for example indexing into an array with a string.</blockquote>\n<p>jsoncfg.<strong>JSONConfigIndexError</strong></p>\n<blockquote>\n<p>Over-indexing a json array results in this exception.</p>\n<ul>\n<li><tt>index</tt>: The index used to over-index the array.</li>\n</ul>\n</blockquote>\n</div>\n<div id=\"utility-functions\">\n<h3><a href=\"#id15\" rel=\"nofollow\">Utility functions</a></h3>\n<p>The config wrapper objects have no public methods but in some cases you may want to extract some info from them\n(for example line/column number, type of node). You can do that with utility functions that can be imported from\nthe <tt>jsoncfg</tt> module.</p>\n<p>jsoncfg.<strong>node_location</strong><em>(config_node)</em></p>\n<blockquote>\nReturns the location of the specified config node in the file it was parsed from. The returned location is a\nnamed tuple <tt>NodeLocation(line, column)</tt> containing the 1-based line and column numbers.</blockquote>\n<p>jsoncfg.<strong>node_exists</strong><em>(config_node)</em></p>\n<blockquote>\n<p>The library doesn\u2019t raise an error if you query a non-existing key. It raises error only when you try to fetch\na value from it. Querying a non-existing key returns a special <tt>ValueNotFoundNode</tt> instance and this function\nactually checks whether the node is something else than a <tt>ValueNotFoundNode</tt> instance. A node can be\nany part of the json: an object/dict, a list, or any other json value. Before trying to fetch a value from the\nqueried node you can test the result of a query with <tt>node_exists()</tt> whether it is an existing or non-existing\nnode in order to handle missing/optional config blocks gracefully without exceptions.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">jsoncfg</span> <span class=\"kn\">import</span> <span class=\"n\">load_config</span><span class=\"p\">,</span> <span class=\"n\">node_exists</span>\n\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">load_config</span><span class=\"p\">(</span><span class=\"s1\">'my_config.cfg'</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"n\">node_exists</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">whatever1</span><span class=\"o\">.</span><span class=\"n\">whatever2</span><span class=\"o\">.</span><span class=\"n\">whatever3</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n\n<span class=\"c1\"># OR an equivalent piece of code:</span>\n\n<span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">whatever1</span><span class=\"o\">.</span><span class=\"n\">whatever2</span><span class=\"o\">.</span><span class=\"n\">whatever3</span>\n<span class=\"k\">if</span> <span class=\"n\">node_exists</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n\n<span class=\"c1\"># This node_exists() call returns True:</span>\n<span class=\"n\">exists_1</span> <span class=\"o\">=</span> <span class=\"n\">node_exists</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">existing_key1</span><span class=\"o\">.</span><span class=\"n\">existing_key2</span><span class=\"o\">.</span><span class=\"n\">existing_key3</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># This node_exists() call returns False:</span>\n<span class=\"n\">exists_2</span> <span class=\"o\">=</span> <span class=\"n\">node_exists</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">non_existing_key1</span><span class=\"o\">.</span><span class=\"n\">non_existing_key2</span><span class=\"p\">)</span>\n</pre>\n</blockquote>\n<p>jsoncfg.<strong>node_is_object</strong><em>(config_node)</em></p>\n<blockquote>\nReturns <tt>True</tt> if the specified <tt>config_node</tt> is a json object/dict.</blockquote>\n<p>jsoncfg.<strong>node_is_array</strong><em>(config_node)</em></p>\n<blockquote>\nReturns <tt>True</tt> if the specified <tt>config_node</tt> is a json array/list.</blockquote>\n<p>jsoncfg.<strong>node_is_scalar</strong><em>(config_node)</em></p>\n<blockquote>\nReturns <tt>True</tt> if the specified <tt>config_node</tt> is a json value other than an object or array - if it isn\u2019t a\ncontainer.</blockquote>\n<p>jsoncfg.<strong>ensure_exists</strong><em>(config_node)</em></p>\n<blockquote>\nReturns the specified <tt>config_node</tt> if it is an existing node, otherwise it raises a config error (with\nconfig file location info when possible).</blockquote>\n<p>jsoncfg.<strong>expect_object</strong><em>(config_node)</em></p>\n<blockquote>\n<p>Returns the specified <tt>config_node</tt> if it is a json object/dict, otherwise it raises a config error (with\nconfig file location info when possible).</p>\n<p>In many cases you can just query and fetch objects using jsoncfg without doing explicit error handling and\njsoncfg provides useful error messages when an error occurs (like trying the fetch the value from a non-existing\nnode, trying to map a non-integer value to an integer, etc\u2026). There is however at least one exception when\njsoncfg can\u2019t really auto-detect problems in a smart way: When you iterate over a json object or array. A json\nobject returns <cite>(key, value)</cite> pairs during iteration while an array returns simple items. If you just assume\n(without actually checking) that a config node is a json object/dict and you iterate over it with auto-unpacking\nthe returned <cite>(key, value)</cite> pairs into two variables then you might get into trouble if your assumption is\nincorrect and the actual config node is a json array. If it is an array then it will return simple items and\npython fails to unpack it into two variables. The result is an ugly python runtime error and not a nice jsoncfg\nerror that says that the config node is an array and not an object/dict that your code expected. To overcome this\nproblem you can use this <tt>jsoncfg.expect_object()</tt> function to ensure that the node you iterate is a json\nobject. The same is recommended in case of json arrays: it is recommended to check them with\n<tt>jsoncfg.expect_array()</tt> before iteration:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">jsoncfg</span> <span class=\"kn\">import</span> <span class=\"n\">load_config</span><span class=\"p\">,</span> <span class=\"n\">expect_object</span><span class=\"p\">,</span> <span class=\"n\">expect_array</span>\n\n<span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">load_config</span><span class=\"p\">(</span><span class=\"s1\">'server.cfg'</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">server</span> <span class=\"ow\">in</span> <span class=\"n\">expect_array</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">servers</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'------------'</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">expect_object</span><span class=\"p\">(</span><span class=\"n\">server</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"si\">%s</span><span class=\"s1\">: </span><span class=\"si\">%r</span><span class=\"s1\">'</span> <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">))</span>\n</pre>\n</blockquote>\n<p>jsoncfg.<strong>expect_array</strong><em>(config_node)</em></p>\n<blockquote>\nReturns the specified <tt>config_node</tt> if it is a json array/list, otherwise it raises a config error (with\nconfig file location info when possible).</blockquote>\n<p>jsoncfg.<strong>expect_scalar</strong><em>(config_node)</em></p>\n<blockquote>\nReturns the specified <tt>config_node</tt> if it isn\u2019t a json object or array, otherwise it raises a config error (with\nconfig file location info when possible).</blockquote>\n</div>\n</div>\n\n          </div>"}, "last_serial": 2511571, "releases": {"0.5.0": [{"comment_text": "", "digests": {"md5": "af17009f9fb581ad2e6661b2dffc9e08", "sha256": "45b73e32ea6e23b3281680d0a9581c4cb14f9a1b2ac5b887067f370f3f2d3979"}, "downloads": -1, "filename": "json-cfg-rw-0.5.0.tar.gz", "has_sig": false, "md5_digest": "af17009f9fb581ad2e6661b2dffc9e08", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51040, "upload_time": "2016-12-11T07:58:53", "upload_time_iso_8601": "2016-12-11T07:58:53.982529Z", "url": "https://files.pythonhosted.org/packages/4e/31/f78f2a2152ebd167dca90b6b4b88fce93c82bc614a3c7f0f929a66cb3f88/json-cfg-rw-0.5.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "af17009f9fb581ad2e6661b2dffc9e08", "sha256": "45b73e32ea6e23b3281680d0a9581c4cb14f9a1b2ac5b887067f370f3f2d3979"}, "downloads": -1, "filename": "json-cfg-rw-0.5.0.tar.gz", "has_sig": false, "md5_digest": "af17009f9fb581ad2e6661b2dffc9e08", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51040, "upload_time": "2016-12-11T07:58:53", "upload_time_iso_8601": "2016-12-11T07:58:53.982529Z", "url": "https://files.pythonhosted.org/packages/4e/31/f78f2a2152ebd167dca90b6b4b88fce93c82bc614a3c7f0f929a66cb3f88/json-cfg-rw-0.5.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:52 2020"}