{"info": {"author": "Julien Palard", "author_email": "julien@palard.fr", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Topic :: Software Development", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# Infix programming toolkit\n\nModule enabling a sh like infix syntax (using pipes).\n\n\n# Introduction\n\nAs an example, here is the solution for the 2nd Euler Project exercise:\n\n> Find the sum of all the even-valued terms in Fibonacci which do not\n  exceed four million.\n\nGiven fib a generator of Fibonacci numbers:\n\n    euler2 = (fib() | where(lambda x: x % 2 == 0)\n                    | take_while(lambda x: x < 4000000)\n                    | add)\n\n\n# Deprecations of pipe 1.x\n\nIn pipe 1.x a lot of functions were returning iterables and a lot\nother functions were returning non-iterables, causing confusion. The\none returning non-iterables could only be used as the last function of\na pipe expression, so they are in fact useless:\n\n    range(100) | where(lambda x: x % 2 == 0) | add\n\ncan be rewritten with no less readability as:\n\n    sum(range(100) | where(lambda x: x % 2 == 0))\n\nso all pipes returning a non-pipe are now deprecated and will be removed in pipe 2.0.\n\n\n# Vocabulary\n\n- A Pipe: a Pipe is a 'pipeable' function, something that you can pipe to,\n  In the code '[1, 2, 3] | add' add is a Pipe\n- A Pipe function: A standard function returning a Pipe so it can be used like\n  a normal Pipe but called like in : [1, 2, 3] | concat(\"#\")\n\n\n# Syntax\n\nI don't like `import * `but for the following examples in an REPL it\nwill be OK, so:\n\n    >>> from pipe import *\n\nThe basic syntax is to use a Pipe like in a shell:\n\n    >>> sum(range(100) | select(lambda x: x ** 2) | where(lambda x: x < 100))\n    285\n\nSome pipes take an argument, some do not need one:\n\n    >>> sum([1, 2, 3, 4] | where(lambda x: x % 2 == 0))\n    6\n\n    >>> sum([1, [2, 3], 4] | traverse)\n    10\n\nA Pipe as a function is nothing more than a function returning\na specialized Pipe.\n\n\n# Constructing your own\n\nYou can construct your pipes using Pipe class initialized with lambdas like:\n\n    stdout = Pipe(lambda x: sys.stdout.write(str(x)))\n    select = Pipe(lambda iterable, pred: (pred(x) for x in iterable))\n\nOr using decorators:\n\n    @Pipe\n    def stdout(x):\n        sys.stdout.write(str(x))\n\n\n# Existing Pipes in this module\n\n    tee\n        tee outputs to the standard output and yield unchanged items, usefull for\n        debugging\n        >>> sum([1, 2, 3, 4, 5] | tee)\n        1\n        2\n        3\n        4\n        5\n        15\n\n    chain\n        Chain a sequence of iterables:\n        >>> list([[1, 2], [3, 4], [5]] | chain)\n        [1, 2, 3, 4, 5]\n\n        Warning : chain only unfold iterable containing ONLY iterables:\n          [1, 2, [3]] | chain\n        Gives a TypeError: chain argument #1 must support iteration\n        Consider using traverse.\n\n    traverse\n        Recursively unfold iterables:\n        >>> list([[1, 2], [[[3], [[4]]], [5]]] | traverse)\n        [1, 2, 3, 4, 5]\n        >>> squares = (i * i for i in range(3))\n        >>> list([[0, 1, 2], squares] | traverse)\n        [0, 1, 2, 0, 1, 4]\n\n    map()\n        Apply a conversion expression given as parameter\n        to each element of the given iterable\n        >>> list([1, 2, 3] | map(lambda x: x * x))\n        [1, 4, 9]\n\n    select()\n        An alias for map().\n        >>> list([1, 2, 3] | select(lambda x: x * x))\n        [1, 4, 9]\n\n    where()\n        Only yields the matching items of the given iterable:\n        >>> list([1, 2, 3] | where(lambda x: x % 2 == 0))\n        [2]\n\n    take_while()\n        Like itertools.takewhile, yields elements of the\n        given iterable while the predicat is true:\n        >>> list([1, 2, 3, 4] | take_while(lambda x: x < 3))\n        [1, 2]\n\n    skip_while()\n        Like itertools.dropwhile, skips elements of the given iterable\n        while the predicat is true, then yields others:\n        >>> list([1, 2, 3, 4] | skip_while(lambda x: x < 3))\n        [3, 4]\n\n    chain_with()\n        Like itertools.chain, yields elements of the given iterable,\n        then yields elements of its parameters\n        >>> list((1, 2, 3) | chain_with([4, 5], [6]))\n        [1, 2, 3, 4, 5, 6]\n\n    take()\n        Yields the given quantity of elemenets from the given iterable, like head\n        in shell script.\n        >>> list((1, 2, 3, 4, 5) | take(2))\n        [1, 2]\n\n    tail()\n        Yiels the given quantity of the last elements of the given iterable.\n        >>> list((1, 2, 3, 4, 5) | tail(3))\n        [3, 4, 5]\n\n    skip()\n        Skips the given quantity of elements from the given iterable, then yields\n        >>> list((1, 2, 3, 4, 5) | skip(2))\n        [3, 4, 5]\n\n    islice()\n        Just the itertools.islice\n        >>> list((1, 2, 3, 4, 5, 6, 7, 8, 9) | islice(2, 8, 2))\n        [3, 5, 7]\n\n    izip()\n        Just the itertools.izip\n        >>> list((1, 2, 3, 4, 5, 6, 7, 8, 9)\n        ...  | izip([9, 8, 7, 6, 5, 4, 3, 2, 1]))\n        [(1, 9), (2, 8), (3, 7), (4, 6), (5, 5), (6, 4), (7, 3), (8, 2), (9, 1)]\n\n    groupby()\n        Like itertools.groupby(sorted(iterable, key = keyfunc), keyfunc)\n        (1, 2, 3, 4, 5, 6, 7, 8, 9) \\\n                | groupby(lambda x: x % 2 and \"Even\" or \"Odd\")\n                | select(lambda x: \"%s : %s\" % (x[0], (x[1] | concat(', '))))\n                | concat(' / ')\n        'Even : 1, 3, 5, 7, 9 / Odd : 2, 4, 6, 8'\n\n    sort()\n        Like Python's built-in \"sorted\" primitive. Allows cmp (Python 2.x\n        only), key, and reverse arguments. By default sorts using the\n        identity function as the key.\n\n        >>> ''.join(\"python\" | sort)\n        'hnopty'\n        >>> list([5, -4, 3, -2, 1] | sort(key=abs))\n        [1, -2, 3, -4, 5]\n\n    dedup()\n        Deduplicate values, using the given key function if provided (or else\n        the identity)\n\n        >>> list([1, 1, 2, 2, 3, 3, 1, 2, 3] | dedup)\n        [1, 2, 3]\n        >>> list([1, 1, 2, 2, 3, 3, 1, 2, 3] | dedup(key=lambda n:n % 2))\n        [1, 2]\n\n    uniq()\n        Like dedup() but only deduplicate consecutive values, using the given\n        key function if provided (or else the identity)\n\n        >>> list([1, 1, 2, 2, 3, 3, 1, 2, 3] | uniq)\n        [1, 2, 3, 1, 2, 3]\n        >>> list([1, 1, 2, 2, 3, 3, 1, 2, 3] | uniq(key=lambda n:n % 2))\n        [1, 2, 3, 2, 3]\n\n    reverse\n        Like Python's built-in \"reversed\" primitive.\n        >>> list([1, 2, 3] | reverse)\n        [3, 2, 1]\n\n    strip\n        Like Python's strip-method for str.\n        >>> '  abc   ' | strip\n        'abc'\n        >>> '.,[abc] ] ' | strip('.,[] ')\n        'abc'\n\n    rstrip\n        Like Python's rstrip-method for str.\n        >>> '  abc   ' | rstrip\n        '  abc'\n        >>> '.,[abc] ] ' | rstrip('.,[] ')\n        '.,[abc'\n\n    lstrip\n        Like Python's lstrip-method for str.\n        >>> 'abc   ' | lstrip\n        'abc   '\n        >>> '.,[abc] ] ' | lstrip('.,[] ')\n        'abc] ] '\n\n    t\n        Like Haskell's operator \":\"\n        >>> list(0 | t(1) | t(2)) == list(range(3))\n        True\n\n    permutations()\n        Returns all possible permutations\n        >>> list('ABC' | permutations(2))\n        [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]\n\n        >>> list(range(3) | permutations)\n        [(0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0)]\n\n    transpose()\n        Transposes the rows and columns of a matrix\n        >>> [[1, 2, 3], [4, 5, 6], [7, 8, 9]] | transpose\n        [(1, 4, 7), (2, 5, 8), (3, 6, 9)]\n\n\n# Euler project samples\n\n> Find the sum of all the multiples of 3 or 5 below 1000.\n\n    euler1 = (itertools.count() | select(lambda x: x * 3) | take_while(lambda x: x < 1000) | add) \\\n           + (itertools.count() | select(lambda x: x * 5) | take_while(lambda x: x < 1000) | add) \\\n           - (itertools.count() | select(lambda x: x * 15) | take_while(lambda x: x < 1000) | add)\n    assert euler1 == 233168\n\n> Find the sum of all the even-valued terms in Fibonacci which do not exceed four million.\n\n    euler2 = fib() | where(lambda x: x % 2 == 0) | take_while(lambda x: x < 4000000) | add\n    assert euler2 == 4613732\n\n> Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.\n\n    square = lambda x: x * x\n    euler6 = square(itertools.count(1) | take(100) | add) - (itertools.count(1) | take(100) | select(square) | add)\n    assert euler6 == 25164150\n\n\n", "description_content_type": "text/markdown; charset=UTF-8", "docs_url": null, "download_url": "https://github.com/JulienPalard/Pipe/tarball/master", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/JulienPalard/Pipe", "keywords": "", "license": "MIT license", "maintainer": "", "maintainer_email": "", "name": "pipe", "package_url": "https://pypi.org/project/pipe/", "platform": "", "project_url": "https://pypi.org/project/pipe/", "project_urls": {"Download": "https://github.com/JulienPalard/Pipe/tarball/master", "Homepage": "https://github.com/JulienPalard/Pipe"}, "release_url": "https://pypi.org/project/pipe/1.6.0/", "requires_dist": null, "requires_python": "", "summary": "Module enablig a sh like infix syntax (using pipes)", "version": "1.6.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Infix programming toolkit</h1>\n<p>Module enabling a sh like infix syntax (using pipes).</p>\n<h1>Introduction</h1>\n<p>As an example, here is the solution for the 2nd Euler Project exercise:</p>\n<blockquote>\n<p>Find the sum of all the even-valued terms in Fibonacci which do not\nexceed four million.</p>\n</blockquote>\n<p>Given fib a generator of Fibonacci numbers:</p>\n<pre><code>euler2 = (fib() | where(lambda x: x % 2 == 0)\n                | take_while(lambda x: x &lt; 4000000)\n                | add)\n</code></pre>\n<h1>Deprecations of pipe 1.x</h1>\n<p>In pipe 1.x a lot of functions were returning iterables and a lot\nother functions were returning non-iterables, causing confusion. The\none returning non-iterables could only be used as the last function of\na pipe expression, so they are in fact useless:</p>\n<pre><code>range(100) | where(lambda x: x % 2 == 0) | add\n</code></pre>\n<p>can be rewritten with no less readability as:</p>\n<pre><code>sum(range(100) | where(lambda x: x % 2 == 0))\n</code></pre>\n<p>so all pipes returning a non-pipe are now deprecated and will be removed in pipe 2.0.</p>\n<h1>Vocabulary</h1>\n<ul>\n<li>A Pipe: a Pipe is a 'pipeable' function, something that you can pipe to,\nIn the code '[1, 2, 3] | add' add is a Pipe</li>\n<li>A Pipe function: A standard function returning a Pipe so it can be used like\na normal Pipe but called like in : [1, 2, 3] | concat(\"#\")</li>\n</ul>\n<h1>Syntax</h1>\n<p>I don't like <code>import *</code>but for the following examples in an REPL it\nwill be OK, so:</p>\n<pre><code>&gt;&gt;&gt; from pipe import *\n</code></pre>\n<p>The basic syntax is to use a Pipe like in a shell:</p>\n<pre><code>&gt;&gt;&gt; sum(range(100) | select(lambda x: x ** 2) | where(lambda x: x &lt; 100))\n285\n</code></pre>\n<p>Some pipes take an argument, some do not need one:</p>\n<pre><code>&gt;&gt;&gt; sum([1, 2, 3, 4] | where(lambda x: x % 2 == 0))\n6\n\n&gt;&gt;&gt; sum([1, [2, 3], 4] | traverse)\n10\n</code></pre>\n<p>A Pipe as a function is nothing more than a function returning\na specialized Pipe.</p>\n<h1>Constructing your own</h1>\n<p>You can construct your pipes using Pipe class initialized with lambdas like:</p>\n<pre><code>stdout = Pipe(lambda x: sys.stdout.write(str(x)))\nselect = Pipe(lambda iterable, pred: (pred(x) for x in iterable))\n</code></pre>\n<p>Or using decorators:</p>\n<pre><code>@Pipe\ndef stdout(x):\n    sys.stdout.write(str(x))\n</code></pre>\n<h1>Existing Pipes in this module</h1>\n<pre><code>tee\n    tee outputs to the standard output and yield unchanged items, usefull for\n    debugging\n    &gt;&gt;&gt; sum([1, 2, 3, 4, 5] | tee)\n    1\n    2\n    3\n    4\n    5\n    15\n\nchain\n    Chain a sequence of iterables:\n    &gt;&gt;&gt; list([[1, 2], [3, 4], [5]] | chain)\n    [1, 2, 3, 4, 5]\n\n    Warning : chain only unfold iterable containing ONLY iterables:\n      [1, 2, [3]] | chain\n    Gives a TypeError: chain argument #1 must support iteration\n    Consider using traverse.\n\ntraverse\n    Recursively unfold iterables:\n    &gt;&gt;&gt; list([[1, 2], [[[3], [[4]]], [5]]] | traverse)\n    [1, 2, 3, 4, 5]\n    &gt;&gt;&gt; squares = (i * i for i in range(3))\n    &gt;&gt;&gt; list([[0, 1, 2], squares] | traverse)\n    [0, 1, 2, 0, 1, 4]\n\nmap()\n    Apply a conversion expression given as parameter\n    to each element of the given iterable\n    &gt;&gt;&gt; list([1, 2, 3] | map(lambda x: x * x))\n    [1, 4, 9]\n\nselect()\n    An alias for map().\n    &gt;&gt;&gt; list([1, 2, 3] | select(lambda x: x * x))\n    [1, 4, 9]\n\nwhere()\n    Only yields the matching items of the given iterable:\n    &gt;&gt;&gt; list([1, 2, 3] | where(lambda x: x % 2 == 0))\n    [2]\n\ntake_while()\n    Like itertools.takewhile, yields elements of the\n    given iterable while the predicat is true:\n    &gt;&gt;&gt; list([1, 2, 3, 4] | take_while(lambda x: x &lt; 3))\n    [1, 2]\n\nskip_while()\n    Like itertools.dropwhile, skips elements of the given iterable\n    while the predicat is true, then yields others:\n    &gt;&gt;&gt; list([1, 2, 3, 4] | skip_while(lambda x: x &lt; 3))\n    [3, 4]\n\nchain_with()\n    Like itertools.chain, yields elements of the given iterable,\n    then yields elements of its parameters\n    &gt;&gt;&gt; list((1, 2, 3) | chain_with([4, 5], [6]))\n    [1, 2, 3, 4, 5, 6]\n\ntake()\n    Yields the given quantity of elemenets from the given iterable, like head\n    in shell script.\n    &gt;&gt;&gt; list((1, 2, 3, 4, 5) | take(2))\n    [1, 2]\n\ntail()\n    Yiels the given quantity of the last elements of the given iterable.\n    &gt;&gt;&gt; list((1, 2, 3, 4, 5) | tail(3))\n    [3, 4, 5]\n\nskip()\n    Skips the given quantity of elements from the given iterable, then yields\n    &gt;&gt;&gt; list((1, 2, 3, 4, 5) | skip(2))\n    [3, 4, 5]\n\nislice()\n    Just the itertools.islice\n    &gt;&gt;&gt; list((1, 2, 3, 4, 5, 6, 7, 8, 9) | islice(2, 8, 2))\n    [3, 5, 7]\n\nizip()\n    Just the itertools.izip\n    &gt;&gt;&gt; list((1, 2, 3, 4, 5, 6, 7, 8, 9)\n    ...  | izip([9, 8, 7, 6, 5, 4, 3, 2, 1]))\n    [(1, 9), (2, 8), (3, 7), (4, 6), (5, 5), (6, 4), (7, 3), (8, 2), (9, 1)]\n\ngroupby()\n    Like itertools.groupby(sorted(iterable, key = keyfunc), keyfunc)\n    (1, 2, 3, 4, 5, 6, 7, 8, 9) \\\n            | groupby(lambda x: x % 2 and \"Even\" or \"Odd\")\n            | select(lambda x: \"%s : %s\" % (x[0], (x[1] | concat(', '))))\n            | concat(' / ')\n    'Even : 1, 3, 5, 7, 9 / Odd : 2, 4, 6, 8'\n\nsort()\n    Like Python's built-in \"sorted\" primitive. Allows cmp (Python 2.x\n    only), key, and reverse arguments. By default sorts using the\n    identity function as the key.\n\n    &gt;&gt;&gt; ''.join(\"python\" | sort)\n    'hnopty'\n    &gt;&gt;&gt; list([5, -4, 3, -2, 1] | sort(key=abs))\n    [1, -2, 3, -4, 5]\n\ndedup()\n    Deduplicate values, using the given key function if provided (or else\n    the identity)\n\n    &gt;&gt;&gt; list([1, 1, 2, 2, 3, 3, 1, 2, 3] | dedup)\n    [1, 2, 3]\n    &gt;&gt;&gt; list([1, 1, 2, 2, 3, 3, 1, 2, 3] | dedup(key=lambda n:n % 2))\n    [1, 2]\n\nuniq()\n    Like dedup() but only deduplicate consecutive values, using the given\n    key function if provided (or else the identity)\n\n    &gt;&gt;&gt; list([1, 1, 2, 2, 3, 3, 1, 2, 3] | uniq)\n    [1, 2, 3, 1, 2, 3]\n    &gt;&gt;&gt; list([1, 1, 2, 2, 3, 3, 1, 2, 3] | uniq(key=lambda n:n % 2))\n    [1, 2, 3, 2, 3]\n\nreverse\n    Like Python's built-in \"reversed\" primitive.\n    &gt;&gt;&gt; list([1, 2, 3] | reverse)\n    [3, 2, 1]\n\nstrip\n    Like Python's strip-method for str.\n    &gt;&gt;&gt; '  abc   ' | strip\n    'abc'\n    &gt;&gt;&gt; '.,[abc] ] ' | strip('.,[] ')\n    'abc'\n\nrstrip\n    Like Python's rstrip-method for str.\n    &gt;&gt;&gt; '  abc   ' | rstrip\n    '  abc'\n    &gt;&gt;&gt; '.,[abc] ] ' | rstrip('.,[] ')\n    '.,[abc'\n\nlstrip\n    Like Python's lstrip-method for str.\n    &gt;&gt;&gt; 'abc   ' | lstrip\n    'abc   '\n    &gt;&gt;&gt; '.,[abc] ] ' | lstrip('.,[] ')\n    'abc] ] '\n\nt\n    Like Haskell's operator \":\"\n    &gt;&gt;&gt; list(0 | t(1) | t(2)) == list(range(3))\n    True\n\npermutations()\n    Returns all possible permutations\n    &gt;&gt;&gt; list('ABC' | permutations(2))\n    [('A', 'B'), ('A', 'C'), ('B', 'A'), ('B', 'C'), ('C', 'A'), ('C', 'B')]\n\n    &gt;&gt;&gt; list(range(3) | permutations)\n    [(0, 1, 2), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0)]\n\ntranspose()\n    Transposes the rows and columns of a matrix\n    &gt;&gt;&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9]] | transpose\n    [(1, 4, 7), (2, 5, 8), (3, 6, 9)]\n</code></pre>\n<h1>Euler project samples</h1>\n<blockquote>\n<p>Find the sum of all the multiples of 3 or 5 below 1000.</p>\n</blockquote>\n<pre><code>euler1 = (itertools.count() | select(lambda x: x * 3) | take_while(lambda x: x &lt; 1000) | add) \\\n       + (itertools.count() | select(lambda x: x * 5) | take_while(lambda x: x &lt; 1000) | add) \\\n       - (itertools.count() | select(lambda x: x * 15) | take_while(lambda x: x &lt; 1000) | add)\nassert euler1 == 233168\n</code></pre>\n<blockquote>\n<p>Find the sum of all the even-valued terms in Fibonacci which do not exceed four million.</p>\n</blockquote>\n<pre><code>euler2 = fib() | where(lambda x: x % 2 == 0) | take_while(lambda x: x &lt; 4000000) | add\nassert euler2 == 4613732\n</code></pre>\n<blockquote>\n<p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p>\n</blockquote>\n<pre><code>square = lambda x: x * x\neuler6 = square(itertools.count(1) | take(100) | add) - (itertools.count(1) | take(100) | select(square) | add)\nassert euler6 == 25164150\n</code></pre>\n\n          </div>"}, "last_serial": 6015417, "releases": {"1.3": [{"comment_text": "", "digests": {"md5": "f61af48362497db5b80ab34ba8f47796", "sha256": "4636fb16f05c302bbf882533b4e79a90c59ddb8295e74a0236c5084fc3ed31fd"}, "downloads": -1, "filename": "pipe-1.3.tar.gz", "has_sig": false, "md5_digest": "f61af48362497db5b80ab34ba8f47796", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6862, "upload_time": "2011-03-29T07:57:32", "upload_time_iso_8601": "2011-03-29T07:57:32.632401Z", "url": "https://files.pythonhosted.org/packages/77/e2/477d8a6793e8c7da0a09d560397ea746ba149d19d4d733ae45a05173b891/pipe-1.3.tar.gz", "yanked": false}], "1.4": [{"comment_text": "", "digests": {"md5": "a15a779e4d0b291c8eec8e5256d0dece", "sha256": "0aaba5b5f97d037601d8ae8dccfc7adcb009af02d9451ac4731d9bc75d4a6d92"}, "downloads": -1, "filename": "pipe-1.4.tar.gz", "has_sig": false, "md5_digest": "a15a779e4d0b291c8eec8e5256d0dece", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6934, "upload_time": "2011-03-29T12:37:57", "upload_time_iso_8601": "2011-03-29T12:37:57.175896Z", "url": "https://files.pythonhosted.org/packages/91/c6/4d578366c787a9d4b4e6323af6695bb8cdfdbb567d738dc124b74af01d29/pipe-1.4.tar.gz", "yanked": false}], "1.4.1": [{"comment_text": "", "digests": {"md5": "3bff61cab5d189ce88ec44bd64f1788d", "sha256": "1bc9b3456c86406aea508edff9d606ee9caf4962fe534116f96a82e10c5bd0d7"}, "downloads": -1, "filename": "pipe-1.4.1.tar.gz", "has_sig": false, "md5_digest": "3bff61cab5d189ce88ec44bd64f1788d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7166, "upload_time": "2011-04-07T12:35:37", "upload_time_iso_8601": "2011-04-07T12:35:37.702027Z", "url": "https://files.pythonhosted.org/packages/8a/9d/f6e5733502049d878c5f7aaa3ce53732d5c55883d604c06f818222dc5cf2/pipe-1.4.1.tar.gz", "yanked": false}], "1.4.2": [{"comment_text": "", "digests": {"md5": "b0f8eeab6368df806290d8744d91bc59", "sha256": "84655b9ccbb049d869b1ecf5df0c6f4676ef502ce003eb4b09f04a6e71b6960e"}, "downloads": -1, "filename": "pipe-1.4.2.tar.gz", "has_sig": false, "md5_digest": "b0f8eeab6368df806290d8744d91bc59", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8868, "upload_time": "2017-12-04T22:03:35", "upload_time_iso_8601": "2017-12-04T22:03:35.600728Z", "url": "https://files.pythonhosted.org/packages/5f/b0/e078169700e5653788ba8ebc59f7af2e91cc7fec30d043c5a47b8415d8b9/pipe-1.4.2.tar.gz", "yanked": false}], "1.5.0": [{"comment_text": "", "digests": {"md5": "12e3652314c4111a090607a6755fbf1c", "sha256": "b1a589c27ac59ef42f34602c4927f2579dc92179f5f882afe2041202d1fb1449"}, "downloads": -1, "filename": "pipe-1.5.0-py3-none-any.whl", "has_sig": false, "md5_digest": "12e3652314c4111a090607a6755fbf1c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 7085, "upload_time": "2018-07-27T21:27:55", "upload_time_iso_8601": "2018-07-27T21:27:55.345343Z", "url": "https://files.pythonhosted.org/packages/fa/5e/79d9c53cb50dad5e3cfd9c0913d812a6eb76c487e07345949d31ccd0ef38/pipe-1.5.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1d8dcaf38fba2c82cf33924363435245", "sha256": "969e8330cea612688134ce3e244eef92f24513af655c78c4302fda709d750aef"}, "downloads": -1, "filename": "pipe-1.5.0.tar.gz", "has_sig": false, "md5_digest": "1d8dcaf38fba2c82cf33924363435245", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7937, "upload_time": "2018-07-27T21:27:57", "upload_time_iso_8601": "2018-07-27T21:27:57.275999Z", "url": "https://files.pythonhosted.org/packages/e5/50/348ec7b5162ee997cf4723de3122c237d2f6e695445a61c6935e18dbdecf/pipe-1.5.0.tar.gz", "yanked": false}], "1.6.0": [{"comment_text": "", "digests": {"md5": "b7c6574fb4be8b9fa1bb4d6876622130", "sha256": "cb89e7c553d819e97fa912afaf592c2553fa7b92c047c47772b4a96ef59c8825"}, "downloads": -1, "filename": "pipe-1.6.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "b7c6574fb4be8b9fa1bb4d6876622130", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 6795, "upload_time": "2019-10-22T21:47:19", "upload_time_iso_8601": "2019-10-22T21:47:19.638869Z", "url": "https://files.pythonhosted.org/packages/50/aa/2c7d8e1131d709d009deb9919c29ee8b1e1b2997034cbd4a440fddbf1d3e/pipe-1.6.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "759e586c2c0cde835e238df0473bed36", "sha256": "9bec3a88f8829f5074507795bc633603d61c025c88069f4d865018c721c6aa31"}, "downloads": -1, "filename": "pipe-1.6.0.tar.gz", "has_sig": false, "md5_digest": "759e586c2c0cde835e238df0473bed36", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7622, "upload_time": "2019-10-22T21:47:21", "upload_time_iso_8601": "2019-10-22T21:47:21.459375Z", "url": "https://files.pythonhosted.org/packages/70/70/3ee82de58ebd57c88764037bff419b8f3f7963e329bbe8a9f5f7611463a9/pipe-1.6.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b7c6574fb4be8b9fa1bb4d6876622130", "sha256": "cb89e7c553d819e97fa912afaf592c2553fa7b92c047c47772b4a96ef59c8825"}, "downloads": -1, "filename": "pipe-1.6.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "b7c6574fb4be8b9fa1bb4d6876622130", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 6795, "upload_time": "2019-10-22T21:47:19", "upload_time_iso_8601": "2019-10-22T21:47:19.638869Z", "url": "https://files.pythonhosted.org/packages/50/aa/2c7d8e1131d709d009deb9919c29ee8b1e1b2997034cbd4a440fddbf1d3e/pipe-1.6.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "759e586c2c0cde835e238df0473bed36", "sha256": "9bec3a88f8829f5074507795bc633603d61c025c88069f4d865018c721c6aa31"}, "downloads": -1, "filename": "pipe-1.6.0.tar.gz", "has_sig": false, "md5_digest": "759e586c2c0cde835e238df0473bed36", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7622, "upload_time": "2019-10-22T21:47:21", "upload_time_iso_8601": "2019-10-22T21:47:21.459375Z", "url": "https://files.pythonhosted.org/packages/70/70/3ee82de58ebd57c88764037bff419b8f3f7963e329bbe8a9f5f7611463a9/pipe-1.6.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:54:22 2020"}