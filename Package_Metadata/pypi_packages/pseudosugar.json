{"info": {"author": "kai zhu", "author_email": "kaizhu256@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "Intended Audience :: End Users/Desktop", "Intended Audience :: Science/Research", "License :: OSI Approved :: GNU General Public License (GPL)", "Natural Language :: English", "Operating System :: POSIX", "Operating System :: POSIX :: Linux", "Programming Language :: C", "Programming Language :: C++", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.1", "Topic :: Multimedia", "Topic :: Multimedia :: Graphics", "Topic :: Scientific/Engineering", "Topic :: Scientific/Engineering :: Mathematics", "Topic :: Scientific/Engineering :: Visualization", "Topic :: Software Development", "Topic :: Software Development :: Code Generators", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Utilities"], "description": "DESCRIPTION: pseudosugar - extend python with functional programming language features\n\n  REQUIRES: LINUX OS AND PYTHON3.1\n\n  QUICK TEST: $ python3.1 setup.py build dev --quicktest\n\n  SUMMARY:\n  pseudosugar is a pure python module.\n  pseudosugar is a python ast tree hack, adding the following syntax sugars:\n\n  function<<<< aa, bb, cc, ... -> function(aa, bb, cc, ...)\n  aa, bb, cc, ... >>>>function -> function(aa, bb, cc, ...)\n\n  xx ..function(aa, bb, cc) -> function(xx, aa, bb, cc)\n  xx ...function(aa, bb, cc) -> function(aa, xx, bb, cc)\n  xx ....function(aa, bb, cc) -> function(aa, bb, xx, cc)\n  \nRECENT CHANGELOG:\n  20091231 - added <<<< and >>>> sugar\n  20091224 - added pseudomethod interactive console - revamped pseudomethod import hook\n  20091224 - modularized package - fix install issues - added sdist check\n  20091209 - improved documentation\n  20091205 - moved source code to c++\n  20091116 - package integrated\n\nDEMO USAGE:\n\n>>> ## start up the interactive console\n>>> from pseudosugar import *\n>>> pseudo_console().interact()\n\nPython 3.1.1 (r311:74480, Sep 13 2009, 17:17:12)\n[GCC 4.3.2] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n(pseudo_console)\npseudo_importer - adding hook <pseudosugar.pseudo_importer object at 0xb7ac754c> to sys.meta_path\n>>> from pseudosugar import *\n\n>>> #### QUICK EXAMPLES\n>>> ## prefix operator\n>>> print<<<< 'hello', 'world'\nhello world\n\n>>> ## postfix operator\n>>> 'hello', 'world' >>>>print\nhello world\n\n>>> ## pseudomethod\n>>> def function(aa, bb, cc): return (aa, bb, cc)\n>>> 1 ..function(0, 0) >>>>print\n(1, 0, 0)\n>>> 2 ...function(0, 0) >>>>print\n(0, 2, 0)\n>>> 3 ....function(0, 0) >>>>print\n(0, 0, 3)\n\n\n\n\n\n\n\n>>> ## '<<<<' CONVERTS FUNCTIONS INTO PREFIX OPERATORS\n>>> ## foo<<<< turns foo into a prefix operator\n>>> ## foo<<<< will take in everything to its right that is comma delimited\n>>> ## print<<<< is useful for making print statements\n>>> print<<<< 'bob says', 'hello ' + re.sub<<<< re.compile('(\\w+)'), '\\\\1!', 'world'\nbob says hello world!\n\n>>> ## '>>>>' CONVERTS FUNCTIONS INTO POSTFIX OPERATORS\n>>> ## it behaves almost exactly like '>>>>' except in reverse\n>>> ## it is useful for chaining together multiple operators\n>>> 'qwerty' >>>>list >>>>sorted >>>>enumerate >>>>dict >>>>print\n{0: 'e', 1: 'q', 2: 'r', 3: 't', 4: 'w', 5: 'y'}\n\n>>> ## OPERATOR PRECEDENCE\n>>> ## '>>>>' has higher operator precedence than '<<<<'\n>>> print( list<<<< 'abcd' >>>>tuple ) ## list(tuple('abcd'))\n['a', 'b', 'c', 'd']\n\n\n\n\n\n\n\n>>> #### PSEUDOMETHOD SYNTAX\n>>> ## DYNAMICALLY BIND FUNCTION CALLS TO OBJECTS\n>>> ## bind the function call print() to 'hello'\n>>> print('hello')\nhello\n>>> 'hello' ..print()\nhello\n>>> 'hello' ..print('world')\nhello world\n>>> 'hello' ..print('world', '!')\nhello world !\n>>> 'hello' ..print('world', '!', file = sys.stdout)\nhello world !\n\n>>> ## create a string pseudomethod which adds an exclamation or other endings\n>>> def add_ending(self, end = '!'): return self + end\n>>> 'hello' ..add_ending() ..print()\nhello!\n>>> 'hello'.upper() ..add_ending() ..print()\nHELLO!\n>>> 'hello'.upper() ..add_ending(' world') ..print()\nHELLO world\n>>> 'hello'.upper() ..add_ending(' world').lower() ..print()\nhello world\n>>> 'hello'.upper() ..add_ending(' world').lower() ..add_ending('!') ..print()\nhello world!\n>>> 'hello'.upper() ..add_ending(' world').lower() ..add_ending('!') ..add_ending(end = '!') ..print()\nhello world!!\n\n\n\n>>> ## OPERATOR PRECEDENCE\n>>> ## 'aa ..bb()' has the same operator precedence as the attribute operator 'a.b'\n>>> def add(aa, bb): return aa + bb\n>>> print( 2 * 3 ..add(4) + 5 == 2 * (3 + 4) + 5 )\nTrue\n>>> print( 3 == 1 ..add(2) )\nTrue\n>>> print( 0, 0 ..add(1), 0 )\n0 1 0\n\n\n\n>>> ## EXTEND RESTRICTED TYPES\n>>> ## the python code object type <class 'code'> cannot be subtyped nor will it accept any method binding.\n>>> ## however, we can extend it by dynamically binding ordinary functions.\n>>> ## here's a pseudomethod which disassembles an instance of the type to a specified output\n>>> import dis, io, sys\n>>> def disassemble(self, file):\n...   backup_stdout = sys.stdout ## backup sys.stdout\n...   try:\n...     sys.stdout = file\n...     dis.dis(self) ## disassemble self\n...     return file\n...   finally:\n...     sys.stdout = backup_stdout ## restore sys.stdout\n\n>>> code_source = 'print( \"hello\" )'; code_object = compile(code_source, '', 'exec'); exec( code_object )\nhello\n>>> code_object ..disassemble(file = io.StringIO()).getvalue() ..print()\n  1           0 LOAD_NAME                0 (print) \n              3 LOAD_CONST               0 ('hello') \n              6 CALL_FUNCTION            1 \n              9 POP_TOP              \n             10 LOAD_CONST               1 (None) \n             13 RETURN_VALUE         \n\n\n\n\n>>> ## '...' AND '....' SYNTAX\n>>> ## sometimes we instead want the 2nd or 3rd argument of a function bound to an object.\n>>> ## '...' and '....' will do this respectively\n>>> '2nd' ...print(0, 0)\n0 2nd 0\n>>> '3rd' ....print(0, 0)\n0 0 3rd\n\n>>> ## '....' is useful for chaining re.sub\n>>> ss = 'file = io.StringIO(); print 1, 2, 3 >> file; print file.getvalue()'; print( ss )\nfile = io.StringIO(); print 1, 2, 3 >> file; print file.getvalue()\n\n>>> print(\n...   re.sub('print (.*?)$', 'print( \\\\1 )',\n...          re.sub('print (.*) >> (.*?);', 'print( \\\\1, file = \\\\2 );', ss)\n...          )\n...   )\nfile = io.StringIO(); print( 1, 2, 3, file = file ); print( file.getvalue() )\n\n>>> ss ....re.sub('print (.*) >> (.*?);', 'print( \\\\1, file = \\\\2 );') \\\n...    ....re.sub('print (.*?)$', 'print( \\\\1 )') \\\n...    ..print()\nfile = io.StringIO(); print( 1, 2, 3, file = file ); print( file.getvalue() )\n\n>>> ## in fact, another primary use of pseudomethod is to flatten ugly, hard-to-read, lisp-like nested function calls\n>>> print( dict( enumerate( zip( 'abc',  sorted( 'abc bca cab'.split(' '), key = lambda x: x[1] ) ) ) ) )\n{0: ('a', 'cab'), 1: ('b', 'abc'), 2: ('c', 'bca')}\n\n>>> 'abc bca cab'.split(' ') ..sorted(key = lambda x: x[1]) ...zip('abc') ..enumerate() ..dict() ..print()\n{0: ('a', 'cab'), 1: ('b', 'abc'), 2: ('c', 'bca')}\n\n\n\n>>> ## IMPORT MODULES WRITTEN WITH PSEUDOMETHOD SYNTAX\n>>> ## create test_module.py\n>>> open('test_module.py', 'w').write('\"hello\" ..print()\\n') ..print('bytes written')\n18 bytes written\n\n>>> ## during import, insert the magic prefix 'pseudosugar.' before the last module\n>>> ## import pseudosugar.a\n>>> ## import a.pseudosugar.b\n>>> ## import a.b.pseudosugar.c\n>>> import pseudosugar.test_module\nhello", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/pseudosugar", "keywords": null, "license": "gpl", "maintainer": null, "maintainer_email": null, "name": "pseudosugar", "package_url": "https://pypi.org/project/pseudosugar/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/pseudosugar/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/pseudosugar"}, "release_url": "https://pypi.org/project/pseudosugar/2010.01.01.README/", "requires_dist": null, "requires_python": null, "summary": "DESCRIPTION: pseudosugar - extend python with functional programming language features", "version": "2010.01.01.README", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>DESCRIPTION: pseudosugar - extend python with functional programming language features</p>\n<blockquote>\n<p>REQUIRES: LINUX OS AND PYTHON3.1</p>\n<p>QUICK TEST: $ python3.1 setup.py build dev \u2013quicktest</p>\n<p>SUMMARY:\npseudosugar is a pure python module.\npseudosugar is a python ast tree hack, adding the following syntax sugars:</p>\n<p>function&lt;&lt;&lt;&lt; aa, bb, cc, \u2026 -&gt; function(aa, bb, cc, \u2026)\naa, bb, cc, \u2026 &gt;&gt;&gt;&gt;function -&gt; function(aa, bb, cc, \u2026)</p>\n<p>xx ..function(aa, bb, cc) -&gt; function(xx, aa, bb, cc)\nxx \u2026function(aa, bb, cc) -&gt; function(aa, xx, bb, cc)\nxx \u2026.function(aa, bb, cc) -&gt; function(aa, bb, xx, cc)</p>\n</blockquote>\n<dl>\n<dt>RECENT CHANGELOG:</dt>\n<dd>20091231 - added &lt;&lt;&lt;&lt; and &gt;&gt;&gt;&gt; sugar\n20091224 - added pseudomethod interactive console - revamped pseudomethod import hook\n20091224 - modularized package - fix install issues - added sdist check\n20091209 - improved documentation\n20091205 - moved source code to c++\n20091116 - package integrated</dd>\n</dl>\n<p>DEMO USAGE:</p>\n<pre>&gt;&gt;&gt; ## start up the interactive console\n&gt;&gt;&gt; from pseudosugar import *\n&gt;&gt;&gt; pseudo_console().interact()\n</pre>\n<p>Python 3.1.1 (r311:74480, Sep 13 2009, 17:17:12)\n[GCC 4.3.2] on linux2\nType \u201chelp\u201d, \u201ccopyright\u201d, \u201ccredits\u201d or \u201clicense\u201d for more information.\n(pseudo_console)\npseudo_importer - adding hook &lt;pseudosugar.pseudo_importer object at 0xb7ac754c&gt; to sys.meta_path\n&gt;&gt;&gt; from pseudosugar import *</p>\n<pre>&gt;&gt;&gt; #### QUICK EXAMPLES\n&gt;&gt;&gt; ## prefix operator\n&gt;&gt;&gt; print&lt;&lt;&lt;&lt; 'hello', 'world'\nhello world\n</pre>\n<pre>&gt;&gt;&gt; ## postfix operator\n&gt;&gt;&gt; 'hello', 'world' &gt;&gt;&gt;&gt;print\nhello world\n</pre>\n<pre>&gt;&gt;&gt; ## pseudomethod\n&gt;&gt;&gt; def function(aa, bb, cc): return (aa, bb, cc)\n&gt;&gt;&gt; 1 ..function(0, 0) &gt;&gt;&gt;&gt;print\n(1, 0, 0)\n&gt;&gt;&gt; 2 ...function(0, 0) &gt;&gt;&gt;&gt;print\n(0, 2, 0)\n&gt;&gt;&gt; 3 ....function(0, 0) &gt;&gt;&gt;&gt;print\n(0, 0, 3)\n</pre>\n<pre>&gt;&gt;&gt; ## '&lt;&lt;&lt;&lt;' CONVERTS FUNCTIONS INTO PREFIX OPERATORS\n&gt;&gt;&gt; ## foo&lt;&lt;&lt;&lt; turns foo into a prefix operator\n&gt;&gt;&gt; ## foo&lt;&lt;&lt;&lt; will take in everything to its right that is comma delimited\n&gt;&gt;&gt; ## print&lt;&lt;&lt;&lt; is useful for making print statements\n&gt;&gt;&gt; print&lt;&lt;&lt;&lt; 'bob says', 'hello ' + re.sub&lt;&lt;&lt;&lt; re.compile('(\\w+)'), '\\\\1!', 'world'\nbob says hello world!\n</pre>\n<pre>&gt;&gt;&gt; ## '&gt;&gt;&gt;&gt;' CONVERTS FUNCTIONS INTO POSTFIX OPERATORS\n&gt;&gt;&gt; ## it behaves almost exactly like '&gt;&gt;&gt;&gt;' except in reverse\n&gt;&gt;&gt; ## it is useful for chaining together multiple operators\n&gt;&gt;&gt; 'qwerty' &gt;&gt;&gt;&gt;list &gt;&gt;&gt;&gt;sorted &gt;&gt;&gt;&gt;enumerate &gt;&gt;&gt;&gt;dict &gt;&gt;&gt;&gt;print\n{0: 'e', 1: 'q', 2: 'r', 3: 't', 4: 'w', 5: 'y'}\n</pre>\n<pre>&gt;&gt;&gt; ## OPERATOR PRECEDENCE\n&gt;&gt;&gt; ## '&gt;&gt;&gt;&gt;' has higher operator precedence than '&lt;&lt;&lt;&lt;'\n&gt;&gt;&gt; print( list&lt;&lt;&lt;&lt; 'abcd' &gt;&gt;&gt;&gt;tuple ) ## list(tuple('abcd'))\n['a', 'b', 'c', 'd']\n</pre>\n<pre>&gt;&gt;&gt; #### PSEUDOMETHOD SYNTAX\n&gt;&gt;&gt; ## DYNAMICALLY BIND FUNCTION CALLS TO OBJECTS\n&gt;&gt;&gt; ## bind the function call print() to 'hello'\n&gt;&gt;&gt; print('hello')\nhello\n&gt;&gt;&gt; 'hello' ..print()\nhello\n&gt;&gt;&gt; 'hello' ..print('world')\nhello world\n&gt;&gt;&gt; 'hello' ..print('world', '!')\nhello world !\n&gt;&gt;&gt; 'hello' ..print('world', '!', file = sys.stdout)\nhello world !\n</pre>\n<pre>&gt;&gt;&gt; ## create a string pseudomethod which adds an exclamation or other endings\n&gt;&gt;&gt; def add_ending(self, end = '!'): return self + end\n&gt;&gt;&gt; 'hello' ..add_ending() ..print()\nhello!\n&gt;&gt;&gt; 'hello'.upper() ..add_ending() ..print()\nHELLO!\n&gt;&gt;&gt; 'hello'.upper() ..add_ending(' world') ..print()\nHELLO world\n&gt;&gt;&gt; 'hello'.upper() ..add_ending(' world').lower() ..print()\nhello world\n&gt;&gt;&gt; 'hello'.upper() ..add_ending(' world').lower() ..add_ending('!') ..print()\nhello world!\n&gt;&gt;&gt; 'hello'.upper() ..add_ending(' world').lower() ..add_ending('!') ..add_ending(end = '!') ..print()\nhello world!!\n</pre>\n<pre>&gt;&gt;&gt; ## OPERATOR PRECEDENCE\n&gt;&gt;&gt; ## 'aa ..bb()' has the same operator precedence as the attribute operator 'a.b'\n&gt;&gt;&gt; def add(aa, bb): return aa + bb\n&gt;&gt;&gt; print( 2 * 3 ..add(4) + 5 == 2 * (3 + 4) + 5 )\nTrue\n&gt;&gt;&gt; print( 3 == 1 ..add(2) )\nTrue\n&gt;&gt;&gt; print( 0, 0 ..add(1), 0 )\n0 1 0\n</pre>\n<pre>&gt;&gt;&gt; ## EXTEND RESTRICTED TYPES\n&gt;&gt;&gt; ## the python code object type &lt;class 'code'&gt; cannot be subtyped nor will it accept any method binding.\n&gt;&gt;&gt; ## however, we can extend it by dynamically binding ordinary functions.\n&gt;&gt;&gt; ## here's a pseudomethod which disassembles an instance of the type to a specified output\n&gt;&gt;&gt; import dis, io, sys\n&gt;&gt;&gt; def disassemble(self, file):\n...   backup_stdout = sys.stdout ## backup sys.stdout\n...   try:\n...     sys.stdout = file\n...     dis.dis(self) ## disassemble self\n...     return file\n...   finally:\n...     sys.stdout = backup_stdout ## restore sys.stdout\n</pre>\n<pre>&gt;&gt;&gt; code_source = 'print( \"hello\" )'; code_object = compile(code_source, '', 'exec'); exec( code_object )\nhello\n&gt;&gt;&gt; code_object ..disassemble(file = io.StringIO()).getvalue() ..print()\n  1           0 LOAD_NAME                0 (print)\n              3 LOAD_CONST               0 ('hello')\n              6 CALL_FUNCTION            1\n              9 POP_TOP\n             10 LOAD_CONST               1 (None)\n             13 RETURN_VALUE\n</pre>\n<pre>&gt;&gt;&gt; ## '...' AND '....' SYNTAX\n&gt;&gt;&gt; ## sometimes we instead want the 2nd or 3rd argument of a function bound to an object.\n&gt;&gt;&gt; ## '...' and '....' will do this respectively\n&gt;&gt;&gt; '2nd' ...print(0, 0)\n0 2nd 0\n&gt;&gt;&gt; '3rd' ....print(0, 0)\n0 0 3rd\n</pre>\n<pre>&gt;&gt;&gt; ## '....' is useful for chaining re.sub\n&gt;&gt;&gt; ss = 'file = io.StringIO(); print 1, 2, 3 &gt;&gt; file; print file.getvalue()'; print( ss )\nfile = io.StringIO(); print 1, 2, 3 &gt;&gt; file; print file.getvalue()\n</pre>\n<pre>&gt;&gt;&gt; print(\n...   re.sub('print (.*?)$', 'print( \\\\1 )',\n...          re.sub('print (.*) &gt;&gt; (.*?);', 'print( \\\\1, file = \\\\2 );', ss)\n...          )\n...   )\nfile = io.StringIO(); print( 1, 2, 3, file = file ); print( file.getvalue() )\n</pre>\n<pre>&gt;&gt;&gt; ss ....re.sub('print (.*) &gt;&gt; (.*?);', 'print( \\\\1, file = \\\\2 );') \\\n...    ....re.sub('print (.*?)$', 'print( \\\\1 )') \\\n...    ..print()\nfile = io.StringIO(); print( 1, 2, 3, file = file ); print( file.getvalue() )\n</pre>\n<pre>&gt;&gt;&gt; ## in fact, another primary use of pseudomethod is to flatten ugly, hard-to-read, lisp-like nested function calls\n&gt;&gt;&gt; print( dict( enumerate( zip( 'abc',  sorted( 'abc bca cab'.split(' '), key = lambda x: x[1] ) ) ) ) )\n{0: ('a', 'cab'), 1: ('b', 'abc'), 2: ('c', 'bca')}\n</pre>\n<pre>&gt;&gt;&gt; 'abc bca cab'.split(' ') ..sorted(key = lambda x: x[1]) ...zip('abc') ..enumerate() ..dict() ..print()\n{0: ('a', 'cab'), 1: ('b', 'abc'), 2: ('c', 'bca')}\n</pre>\n<pre>&gt;&gt;&gt; ## IMPORT MODULES WRITTEN WITH PSEUDOMETHOD SYNTAX\n&gt;&gt;&gt; ## create test_module.py\n&gt;&gt;&gt; open('test_module.py', 'w').write('\"hello\" ..print()\\n') ..print('bytes written')\n18 bytes written\n</pre>\n<pre>&gt;&gt;&gt; ## during import, insert the magic prefix 'pseudosugar.' before the last module\n&gt;&gt;&gt; ## import pseudosugar.a\n&gt;&gt;&gt; ## import a.pseudosugar.b\n&gt;&gt;&gt; ## import a.b.pseudosugar.c\n&gt;&gt;&gt; import pseudosugar.test_module\nhello\n</pre>\n\n          </div>"}, "last_serial": 796756, "releases": {"2010.01.01.README": [{"comment_text": "", "digests": {"md5": "07832f7642f640fdb423eb2886196d7d", "sha256": "736e1bfe5fef9e81c368eb32d668c2e4599ce230ca398793561788e505526456"}, "downloads": -1, "filename": "pseudosugar-2010.01.01.README.tar.gz", "has_sig": false, "md5_digest": "07832f7642f640fdb423eb2886196d7d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 90063, "upload_time": "2010-01-04T20:15:21", "upload_time_iso_8601": "2010-01-04T20:15:21.141520Z", "url": "https://files.pythonhosted.org/packages/0f/91/bfbbd5ff836e03472387e89320a14940908f795d73d098312b33f1b8046f/pseudosugar-2010.01.01.README.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "07832f7642f640fdb423eb2886196d7d", "sha256": "736e1bfe5fef9e81c368eb32d668c2e4599ce230ca398793561788e505526456"}, "downloads": -1, "filename": "pseudosugar-2010.01.01.README.tar.gz", "has_sig": false, "md5_digest": "07832f7642f640fdb423eb2886196d7d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 90063, "upload_time": "2010-01-04T20:15:21", "upload_time_iso_8601": "2010-01-04T20:15:21.141520Z", "url": "https://files.pythonhosted.org/packages/0f/91/bfbbd5ff836e03472387e89320a14940908f795d73d098312b33f1b8046f/pseudosugar-2010.01.01.README.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:15:57 2020"}