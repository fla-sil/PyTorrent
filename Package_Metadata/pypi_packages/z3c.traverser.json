{"info": {"author": "Zope Corporation and Contributors", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: Implementation :: CPython", "Topic :: Internet :: WWW/HTTP"], "description": "This package provides the pluggable traverser mechanism allowing developers\nto add new traversers to an object without altering the original traversal\nimplementation.\n\nIn addition to the pluggable traversers, this package contains two more\nsubpackages:\n\n * viewlet - provides a way to traverse to viewlets using namespaces\n \n * stackinfo - provides a way to consume parts of url and store them\n   as attributes of the \"consumer\" object. Useful for urls like:\n   /blog/2009/02/02/hello-world\n\n\n.. contents::\n\n=======\nCHANGES\n=======\n\n1.0.0 (2015-11-09)\n------------------\n\n- Standardize namespace __init__.\n\n- Claim support for Python 3.4.\n\n\n1.0.0a2 (2013-03-03)\n--------------------\n\n- Added Trove classifiers to specify supported Python versions.\n\n\n1.0.0a1 (2013-03-03)\n--------------------\n\n- Added support for Python 3.3.\n\n- Replaced deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Dropped support for Python 2.4 and 2.5.\n\n- Switched from ``zope.testbrowser`` to ``WebTest`` for browser testing, since\n  testbrowser is not yet ported.\n\n- Modernized API to use latest packages and component paths.\n\n- Reduced test dependencies to the smallest set possible.\n\n\n0.3.0 (2010-11-01)\n------------------\n\n- Updated test set up to run with ZTK 1.0.\n\n- Using Python's ``doctest`` module instead of depreacted\n  ``zope.testing.doctest[unit]``.\n\n\n0.2.5 (2009-03-13)\n------------------\n\n- Adapt to the move of IDefaultViewName from zope.component to zope.publisher.\n\n0.2.4 (2009-02-02)\n------------------\n\n- Make ``PluggableBrowserTraverser`` implement ``IBrowserPublisher``\n  interface.\n- Fix tests and deprecation warnings.\n- Improve test coverage.\n- Get rid of zope.app.zapi dependency by replacing its uses with direct\n  calls.\n- Change package's mailing list address to zope-dev at zope.org,\n  because zope3-dev at zope.org is now retired.\n- Change \"cheeseshop\" to \"pypi\" in the package's url.\n\n0.2.3 (2008-07-14)\n------------------\n\n- Bugfix: In z3c.traverser.stackinfo the traversal stack got messed up\n  when using the VirtualHost namespace with more than one thread.\n\n0.2.2 (2008-03-06)\n------------------\n\n- Restructuring: Separated pluggable traverser functionality into two classes\n  for better code reuse.\n\n\n0.2.1 (2007-11-92)\n------------------\n\n- Bugfix: if viewlet and managers get nested a viewlet was not found if\n  the depth reaches 3 because the context was set to the page and not\n  to the context object.\n\n- Bugfix: replaced call to ``_getContextName`` because it has been removed\n  from ``absoluteURL``.\n\n\n0.2.0 (2007-10-31)\n------------------\n\n- Update package meta-data.\n\n- Resolve ``ZopeSecurityPolicy`` deprecation warning.\n\n\n0.2.0b2 (2007-10-26)\n--------------------\n\n- Use only ``absolute_url`` adapters in unconsumed URL caclulations, to\n  make it work for traversable viewlets or other special cases too.\n\n\n0.2.0b1 (2007-09-21)\n--------------------\n\n- added a generic stack consumer handler which can be registered for\n  BeforeTraverse events.\n\n\n0.1.3 (2007-06-03)\n------------------\n\n- Added principal namespace, see ``namespace.rst``\n\n- Fire ``BeforeUpdateEvent`` in viewlet view\n\n\n0.1.1 (2007-03-22)\n------------------\n\n- First egg release\n\n\n\n\n====================\nPluggable Traversers\n====================\n\nTraversers are Zope's mechanism to convert URI paths to an object of the\napplication. They provide an extremly flexible mechanism to make decisions\nbased on the policies of the application. Unfortunately the default traverser\nimplementation is not flexible enough to deal with arbitrary extensions (via\nadapters) of objects that also wish to participate in the traversal decision\nprocess.\n\nThe pluggable traverser allows developers, especially third-party developers,\nto add new traversers to an object without altering the original traversal\nimplementation.\n\n    >>> from z3c.traverser.traverser import PluggableTraverser\n\nLet's say that we have an object\n\n    >>> from zope.interface import Interface, implementer\n    >>> class IContent(Interface):\n    ...     pass\n\n    >>> @implementer(IContent)\n    ... class Content(object):\n    ...     var = True\n\n    >>> content = Content()\n\nthat we wish to traverse to. Since traversers are presentation-type specific,\nthey are implemented as views and must thus be initiated using a request:\n\n    >>> from zope.publisher.base import TestRequest\n    >>> request = TestRequest('')\n    >>> traverser = PluggableTraverser(content, request)\n\nWe can now try to lookup the variable:\n\n    >>> traverser.publishTraverse(request, 'var')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <Content object at ...>, name: 'var'\n\nBut it failed. Why? Because we have not registered a plugin traverser yet that\nknows how to lookup attributes. This package provides such a traverser\nalready, so we just have to register it:\n\n    >>> from zope.component import provideSubscriptionAdapter\n    >>> from zope.publisher.interfaces import IPublisherRequest\n    >>> from z3c.traverser.traverser import AttributeTraverserPlugin\n\n    >>> provideSubscriptionAdapter(AttributeTraverserPlugin,\n    ...                            (IContent, IPublisherRequest))\n\nIf we now try to lookup the attribute, we the value:\n\n    >>> traverser.publishTraverse(request, 'var')\n    True\n\nHowever, an incorrect variable name will still return a ``NotFound`` error:\n\n    >>> traverser.publishTraverse(request, 'bad')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <Content object at ...>, name: 'bad'\n\nEvery traverser should also make sure that the passed in name is not a\nview. (This allows us to not specify the ``@@`` in front of a view.) So let's\nregister one:\n\n    >>> class View(object):\n    ...     def __init__(self, context, request):\n    ...         pass\n\n    >>> from zope.component import provideAdapter\n    >>> from zope.publisher.interfaces import IPublisherRequest\n    >>> provideAdapter(View,\n    ...                adapts=(IContent, IPublisherRequest),\n    ...                provides=Interface,\n    ...                name='view.html')\n\nNow we can lookup the view as well:\n\n    >>> traverser.publishTraverse(request, 'view.html')\n    <View object at ...>\n\n\nAdvanced Uses\n-------------\n\nA more interesting case to consider is a traverser for a container. If you\nreally dislike the Zope 3 traversal namespace notation ``++namespace++`` and\nyou can control the names in the container, then the pluggable traverser will\nalso provide a viable solution. Let's say we have a container\n\n    >>> from zope.container.interfaces import IContainer\n    >>> class IMyContainer(IContainer):\n    ...     pass\n\n    >>> from zope.container.btree import BTreeContainer\n    >>> @implementer(IMyContainer)\n    ... class MyContainer(BTreeContainer):\n    ...     foo = True\n    ...     bar = False\n\n    >>> myContainer = MyContainer()\n    >>> myContainer['blah'] = 123\n\nand we would like to be able to traverse\n\n  * all items of the container, as well as\n\n    >>> from z3c.traverser.traverser import ContainerTraverserPlugin\n    >>> from z3c.traverser.interfaces import ITraverserPlugin\n\n    >>> provideSubscriptionAdapter(ContainerTraverserPlugin,\n    ...                            (IMyContainer, IPublisherRequest),\n    ...                            ITraverserPlugin)\n\n  * the ``foo`` attribute. Luckily we also have a predeveloped traverser for\n    this:\n\n    >>> from z3c.traverser.traverser import \\\n    ...     SingleAttributeTraverserPlugin\n    >>> provideSubscriptionAdapter(SingleAttributeTraverserPlugin('foo'),\n    ...                            (IMyContainer, IPublisherRequest))\n\nWe can now use the pluggable traverser\n\n    >>> traverser = PluggableTraverser(myContainer, request)\n\nto look up items\n\n    >>> traverser.publishTraverse(request, 'blah')\n    123\n\nand the ``foo`` attribute:\n\n    >>> traverser.publishTraverse(request, 'foo')\n    True\n\nHowever, we cannot lookup the ``bar`` attribute or any other non-existent\nitem:\n\n    >>> traverser.publishTraverse(request, 'bar')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <MyContainer object at ...>, name: 'bar'\n\n    >>> traverser.publishTraverse(request, 'bad')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <MyContainer object at ...>, name: 'bad'\n\nYou can also add traversers that return an adapted object. For example, let's\ntake the following adapter:\n\n    >>> class ISomeAdapter(Interface):\n    ...     pass\n\n    >>> from zope.component import adapts\n    >>> @implementer(ISomeAdapter)\n    ... class SomeAdapter(object):\n    ...     adapts(IMyContainer)\n    ...\n    ...     def __init__(self, context):\n    ...         pass\n\n    >>> from zope.component import adapts, provideAdapter\n    >>> provideAdapter(SomeAdapter)\n\nNow we register this adapter under the traversal name ``some``:\n\n    >>> from z3c.traverser.traverser import AdapterTraverserPlugin\n    >>> provideSubscriptionAdapter(\n    ...     AdapterTraverserPlugin('some', ISomeAdapter),\n    ...     (IMyContainer, IPublisherRequest))\n\nSo here is the result:\n\n    >>> traverser.publishTraverse(request, 'some')\n    <SomeAdapter object at ...>\n\nIf the object is not adaptable, we'll get NotFound. Let's register a\nplugin that tries to query a named adapter for ISomeAdapter. The third\nargument for AdapterTraverserPlugin is used to specify the adapter name.\n\n    >>> provideSubscriptionAdapter(\n    ...     AdapterTraverserPlugin('badadapter', ISomeAdapter, 'other'),\n    ...     (IMyContainer, IPublisherRequest))\n\n    >>> traverser.publishTraverse(request, 'badadapter')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <MyContainer object at ...>, name: 'badadapter'\n\nTraverser Plugins\n-----------------\n\nThe `traverser` package comes with several default traverser plugins; three of\nthem were already introduced above: `SingleAttributeTraverserPlugin`,\n`AdapterTraverserPlugin`, and `ContainerTraverserPlugin`. Another plugin is\nthe the `NullTraverserPlugin`, which always just returns the object itself:\n\n    >>> from z3c.traverser.traverser import NullTraverserPlugin\n    >>> SomethingPlugin = NullTraverserPlugin('something')\n\n    >>> plugin = SomethingPlugin(content, request)\n    >>> plugin.publishTraverse(request, 'something')\n    <Content object at ...>\n\n    >>> plugin.publishTraverse(request, 'something else')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <Content object at ...>, name: 'something else'\n\nAll of the above traversers with exception of the `ContainerTraverserPlugin`\nare implementation of the abstract `NameTraverserPlugin` class. Name traversers\nare traversers that can resolve one particular name. By using the abstract\n`NameTraverserPlugin` class, all of the traverser boilerplate can be\navoided. Here is a simple example that always returns a specific value for a\ntraversed name:\n\n    >>> from z3c.traverser.traverser import NameTraverserPlugin\n    >>> class TrueTraverserPlugin(NameTraverserPlugin):\n    ...     traversalName = 'true'\n    ...     def _traverse(self, request, name):\n    ...         return True\n\nAs you can see realized name traversers must implement the ``_traverse()``\nmethod, which is only responsible for returning the result. Of course it can\nalso raise the `NotFound` error if something goes wrong during the\ncomputation. LEt's check it out:\n\n    >>> plugin = TrueTraverserPlugin(content, request)\n    >>> plugin.publishTraverse(request, 'true')\n    True\n\n    >>> plugin.publishTraverse(request, 'false')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <Content object at ...>, name: 'false'\n\nA final traverser that is offered by the package is the\n`AttributeTraverserPlugin``, which simply allows one to traverse all\naccessible attributes of an object:\n\n    >>> from z3c.traverser.traverser import AttributeTraverserPlugin\n\n    >>> plugin = AttributeTraverserPlugin(myContainer, request)\n    >>> plugin.publishTraverse(request, 'foo')\n    True\n    >>> plugin.publishTraverse(request, 'bar')\n    False\n    >>> plugin.publishTraverse(request, 'blah')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <MyContainer object at ...>, name: 'blah'\n    >>> plugin.publishTraverse(request, 'some')\n    Traceback (most recent call last):\n    ...\n    NotFound: Object: <MyContainer object at ...>, name: 'some'\n\n\nBrowser traverser\n-----------------\n\nThere's also a special subclass of the PluggableTraverser that\nimplements the ``IBrowserPublisher`` interface, thus providing the\n``browserDefault`` method that returns a default object and a view\nname to traverse and use if there's no more steps to traverse.\n\nLet's provide a view name registered as an IDefaultView adapter. This\nis usually done by zope.publisher's browser:defaultView directive.\n\n    >>> from zope.publisher.interfaces import IDefaultViewName\n    >>> provideAdapter('view.html', (IContent, Interface), IDefaultViewName)\n\n    >>> from z3c.traverser.browser import PluggableBrowserTraverser\n    >>> traverser = PluggableBrowserTraverser(content, request)\n    >>> traverser.browserDefault(request)\n    (<Content object at 0x...>, ('@@view.html',))\n\n\n=====================\nAdditional Namespaces\n=====================\n\nPrincipal\n---------\n\nThe ``principal`` namespace allows to differentiate between usernames\nin the url. This is usefull for caching on a per principal basis. The\nnamespace itself doesn't change anything. It just checks if the\nprincipal is the one that is logged in.\n\n    >>> from z3c.traverser import namespace\n    >>> from zope.publisher.browser import TestRequest\n    >>> class Request(TestRequest):\n    ...     principal = None\n    ...\n    ...     def shiftNameToApplication(self):\n    ...         pass\n\n    >>> class Principal(object):\n    ...     def __init__(self, id):\n    ...         self.id = id\n\n    >>> pid = 'something'\n    >>> r = Request()\n    >>> r.principal = Principal('anonymous')\n\nIf we have the wrong principal we get an Unauthorized exception.\n\n    >>> ns = namespace.principal(object(), r)\n    >>> ns.traverse('another', None) # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    Unauthorized: ++principal++another\n\nOtherwise not\n\n    >>> ns.traverse('anonymous', None)\n    <object object at ...>\n\n\n===================\nTraversing Viewlets\n===================\n\nThis package allows to traverse viewlets and viewletmanagers. It also\nprovides absolute url views for those objects which are described in\nthis file, for traversers see BROWSER.rst.\n\n  >>> from z3c.traverser.viewlet import browser\n\nLet us define some test classes.\n\n  >>> import zope.component\n  >>> from zope.viewlet import manager\n  >>> from zope.viewlet import interfaces\n  >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n  >>> import zope.interface\n  >>> class ILeftColumn(interfaces.IViewletManager):\n  ...     \"\"\"Viewlet manager located in the left column.\"\"\"\n  >>> LeftColumn = manager.ViewletManager('left', ILeftColumn)\n  >>> zope.component.provideAdapter(\n  ...     LeftColumn,\n  ...     (zope.interface.Interface,\n  ...     IDefaultBrowserLayer, zope.interface.Interface),\n  ...     interfaces.IViewletManager, name='left')\n\nYou can then create a viewlet manager using this interface now:\n\n\n  >>> from zope.viewlet import viewlet\n  >>> from zope.container.contained import Contained\n\n  >>> class Content(Contained):\n  ...     pass\n  >>> root['content'] = Content()\n  >>> content = root['content']\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n  >>> from zope.publisher.interfaces.browser import IBrowserView\n  >>> from zope.publisher.browser import BrowserView\n  >>> class View(BrowserView):\n  ...     pass\n\nWe have to set the name, this is normally done in zcml.\n\n  >>> view = View(content, request)\n  >>> view.__name__ = 'test.html'\n  >>> leftColumn = LeftColumn(content, request, view)\n\nLet us create a simple viewlet. Note that we need a __name__ attribute\nin order to make the viewlet traversable. Normally you don't have to\ntake care of this, because the zcml directive sets the name upon\nregistration.\n\n  >>> class MyViewlet(viewlet.ViewletBase):\n  ...     __name__ = 'myViewlet'\n  ...     def render(self):\n  ...         return u'<div>My Viewlet</div>'\n  >>> from zope.security.checker import NamesChecker, defineChecker\n  >>> viewletChecker = NamesChecker(('update', 'render'))\n  >>> defineChecker(MyViewlet, viewletChecker)\n\n  >>> zope.component.provideAdapter(\n  ...     MyViewlet,\n  ...     (zope.interface.Interface, IDefaultBrowserLayer,\n  ...     IBrowserView, ILeftColumn),\n  ...     interfaces.IViewlet, name='myViewlet')\n\nWe should now be able to get the absolute url of the viewlet and the\nmanager. We have to register the adapter for the test.\n\n  >>> from zope.traversing.browser.interfaces import IAbsoluteURL\n  >>> from zope.traversing.browser import absoluteurl\n\n  >>> zope.component.provideAdapter(\n  ...     browser.ViewletAbsoluteURL,\n  ...     (interfaces.IViewlet, IDefaultBrowserLayer),\n  ...     IAbsoluteURL)\n  >>> zope.component.provideAdapter(\n  ...     browser.ViewletManagerAbsoluteURL,\n  ...     (interfaces.IViewletManager, IDefaultBrowserLayer),\n  ...     IAbsoluteURL, name=\"absolute_url\")\n  >>> zope.component.provideAdapter(\n  ...     browser.ViewletManagerAbsoluteURL,\n  ...     (interfaces.IViewletManager, IDefaultBrowserLayer),\n  ...     IAbsoluteURL)\n  >>> myViewlet = MyViewlet(content, request, view, leftColumn)\n  >>> absoluteurl.absoluteURL(leftColumn, request)\n  'http://127.0.0.1/content/test.html/++manager++left'\n  >>> absoluteurl.absoluteURL(myViewlet, request)\n  '.../content/test.html/++manager++left/++viewlet++myViewlet'\n\n\n\n====================\n Viewlet Traversing\n====================\n\nTraversing to viewlets is done via namespaces.\n\n  >>> from webtest.app import TestApp\n  >>> browser = TestApp(wsgi_app)\n  >>> res = browser.get('http://localhost/@@test.html')\n\nWe have a test page registered that contains our viewlet. The viewlet\nitself just renders a link to its location (this is just for testing).\n\n  >>> print(res.html)\n  <html>\n    <body>\n       <div><div><a\n       href=\"http://localhost/test.html/++manager++IMyManager/++viewlet++MyViewlet\">My\n       Viewlet</a></div></div>\n    </body>\n  </html>\n\nLet's follow the link to traverse the viewlet directly.\n\n  >>> res = res.click('My Viewlet')\n  >>> res.request.url\n  'http://localhost/test.html/++manager++IMyManager/++viewlet++MyViewlet'\n  >>> print(res.body.decode())\n  <div><a href=\"http://localhost/test.html/++manager++IMyManager/++viewlet++MyViewlet\">My Viewlet</a></div>\n\nWhat happens if a viewlet managers is nested into another viewlet? To test\nthis we will create another manager and another viewlet::\n\n  >>> res = browser.get('http://localhost/@@nested.html')\n  >>> print(res.html)\n  <html>\n    <body>\n      <div><div><a href=\"http://localhost/nested.html/++manager++IOuterManager/++viewlet++OuterViewlet/++manager++IInnerManager/++viewlet++InnerViewlet/++manager++IMostInnerManager/++viewlet++MostInnerViewlet\">Most inner viewlet</a></div></div>\n    </body>\n  </html>\n\nLet's follow the link to traverse the viewlet directly.\n\n  >>> res = res.click('Most inner viewlet')\n  >>> res.request.url\n  'http://localhost/nested.html/++manager++IOuterManager/++viewlet++OuterViewlet/++manager++IInnerManager/++viewlet++InnerViewlet/++manager++IMostInnerManager/++viewlet++MostInnerViewlet'\n\n  >>> print(res.body.decode())\n  <div><a href=\"http://localhost/nested.html/++manager++IOuterManager/++viewlet++OuterViewlet/++manager++IInnerManager/++viewlet++InnerViewlet/++manager++IMostInnerManager/++viewlet++MostInnerViewlet\">Most inner viewlet</a></div>\n\n\nCaveats\n-------\n\nUpdate of the manager is not called, because this may be too expensive\nand normally the managers update just collects viewlets.\n\n\n===============================================\nExtracting Information from the Traversal Stack\n===============================================\n\nThis package allows to define virtual traversal paths for collecting\narbitrary information from the traversal stack instead of, for\nexample, query strings.\n\nIn contrast to the common way of defining custom Traversers, this\nimplementation does not require to go through the whole traversal\nprocess step by step. The traversal information needed is taken from\nthe traversalstack directly and the used parts of the stack are\nconsumed. This way one don't have to define proxy classes just for\ntraversal.\n\nThis implementation does not work in tales because it requires the\ntraversalstack of the request.\n\nFor each name in the traversal stack a named multiadapter is looked up\nfor ITraversalStackConsumer, if found the item gets removed from the\nstack and the adapter is added to the request annotation.\n\n  >>> from z3c.traverser.stackinfo import traversing\n  >>> from z3c.traverser.stackinfo import interfaces\n\nIf there are no adapters defined, the traversalstack is kept as is. To\nshow this behaviour we define some sample classes.\n\n  >>> from zope import interface\n  >>> class IContent(interface.Interface):\n  ...     pass\n\n  >>> from zope.site.folder import Folder\n  >>> @interface.implementer(IContent)\n  ... class Content(Folder):\n  ...     pass\n\nThere is a convinience function which returns an iterator which\niterates over tuples of adapterName, adapter. Additionally the\ntraversal stack of the request is consumed if needed.\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> from zope.publisher.interfaces.browser import IBrowserRequest\n  >>> request = TestRequest()\n\nWe set the traversal stack manually for testing here.\n\n  >>> request.setTraversalStack([u'index.html', u'path', u'some'])\n  >>> content = Content()\n\nSo if no ITraversalStackConsumer adapters are found the stack is left\nuntouched.\n\n  >>> list(traversing.getStackConsumers(content, request))\n  []\n  >>> request.getTraversalStack()\n  [u'index.html', u'path', u'some']\n\nThere is a base class for consumer implementations which implements\nthe ITraversalStackConsumer interface.\n\n  >>> from z3c.traverser.stackinfo import consumer\n  >>> from zope.interface.verify import verifyObject\n  >>> o = consumer.BaseConsumer(None, None)\n  >>> verifyObject(interfaces.ITraversalStackConsumer,o)\n  True\n\nLet us define a custom consumer.\n\n  >>> from zope import component\n  >>> class DummyConsumer(consumer.BaseConsumer):\n  ...     component.adapts(IContent, IBrowserRequest)\n  >>> component.provideAdapter(DummyConsumer, name='some')\n\nNow we will find the newly registered consumer and the 'some' part of\nthe stack is consumed.\n\n  >>> consumers = list(traversing.getStackConsumers(content, request))\n  >>> consumers\n  [(u'some', <DummyConsumer named u'some'>)]\n  >>> request.getTraversalStack()\n  [u'index.html', u'path']\n\nEach consumer at least has to consume one element, which is always\nthe name under which the adapter was registered under.\n\n  >>> name, cons = consumers[0]\n  >>> cons.__name__\n  u'some'\n\nLet us provide another adapter, to demonstrate that the adpaters\nalways have the reverse order of the traversal stack. This is actually\nthe order in the url.\n\n  >>> component.provideAdapter(DummyConsumer, name='other')\n  >>> stack = [u'index.html', u'path', u'some', u'other']\n  >>> request.setTraversalStack(stack)\n  >>> consumers = list(traversing.getStackConsumers(content, request))\n  >>> consumers\n  [(u'other', <DummyConsumer named u'other'>),\n   (u'some', <DummyConsumer named u'some'>)]\n\n  >>> [c.__name__ for name, c in consumers]\n  [u'other', u'some']\n\nThe arguments attribute of the consumer class defines how many\narguments are consumed/needed from the stack. Let us create a KeyValue\nconsumer, that should extract key value pairs from the stack.\n\n  >>> class KeyValueConsumer(DummyConsumer):\n  ...     arguments=('key', 'value')\n  >>> component.provideAdapter(KeyValueConsumer, name='kv')\n  >>> stack = [u'index.html', u'value', u'key', u'kv']\n  >>> request.setTraversalStack(stack)\n  >>> consumers = list(traversing.getStackConsumers(content, request))\n  >>> consumers\n  [(u'kv', <KeyValueConsumer named u'kv'>)]\n  >>> request.getTraversalStack()\n  [u'index.html']\n  >>> name, cons = consumers[0]\n  >>> cons.key\n  u'key'\n  >>> cons.value\n  u'value'\n\nWe can of course use multiple consumers of the same type.\n\n  >>> stack = [u'index.html', u'v2', u'k2', u'kv', u'v1', u'k1', u'kv']\n  >>> request.setTraversalStack(stack)\n  >>> consumers = list(traversing.getStackConsumers(content, request))\n  >>> [(c.__name__, c.key, c.value) for name, c in consumers]\n  [(u'kv', u'k1', u'v1'), (u'kv', u'k2', u'v2')]\n\nIf we have too less arguments a NotFound exception.\n\n  >>> stack = [u'k2', u'kv', u'v1', u'k1', u'kv']\n  >>> request.setTraversalStack(stack)\n  >>> consumers = list(traversing.getStackConsumers(content, request))\n  Traceback (most recent call last):\n    ...\n  NotFound: Object: <Content object at ...>, name: u'kv'\n\n\nIn order to actually use the stack consumers to retrieve information,\nthere is another convinience function which stores the consumers in\nthe requests annotations. This should noramlly be called on\nBeforeTraverseEvents.\n\n  >>> stack = [u'index.html', u'v2', u'k2', u'kv', u'v1', u'k1', u'kv']\n  >>> request.setTraversalStack(stack)\n  >>> traversing.applyStackConsumers(content, request)\n  >>> request.annotations[traversing.CONSUMERS_ANNOTATION_KEY]\n  [<KeyValueConsumer named u'kv'>,\n   <KeyValueConsumer named u'kv'>]\n\nInstead of messing with the annotations one just can adapt the request\nto ITraversalStackInfo.\n\n  >>> component.provideAdapter(consumer.requestTraversalStackInfo)\n  >>> ti = interfaces.ITraversalStackInfo(request)\n  >>> ti\n  (<KeyValueConsumer named u'kv'>, <KeyValueConsumer named u'kv'>)\n\n  >>> len(ti)\n  2\n\nThe adapter always returs an empty TraversalStackInfoObject if there\nis no traversalstack information.\n\n  >>> request = TestRequest()\n  >>> ti = interfaces.ITraversalStackInfo(request)\n  >>> len(ti)\n  0\n\n\nVirtual Host\n------------\n\nIf virtual hosts are used the traversal stack contains aditional information\nfor the virtual host which will interfere which the stack consumer.\n\n  >>> stack = [u'index.html', u'value', u'key',\n  ...          u'kv', u'++', u'inside vh', '++vh++something']\n  >>> request.setTraversalStack(stack)\n  >>> consumers = list(traversing.getStackConsumers(content, request))\n  >>> consumers\n  [(u'kv', <KeyValueConsumer named u'kv'>)]\n  >>> request.getTraversalStack()\n  [u'index.html', u'++', u'inside vh', '++vh++something']\n\n\nURL Handling\n------------\n\nLet us try these things with a real url, in our test the root is the site.\n\n  >>> from zope.traversing.browser.absoluteurl import absoluteURL\n  >>> absoluteURL(root, request)\n  'http://127.0.0.1'\n\nThere is an unconsumedURL function which returns the url of an object\nwith the traversal information, which is normally omitted.\n\n  >>> request = TestRequest()\n  >>> root['content'] = content\n  >>> absoluteURL(root['content'], request)\n  'http://127.0.0.1/content'\n  >>> stack = [u'index.html', u'v2 space', u'k2', u'kv', u'v1', u'k1', u'kv']\n  >>> request.setTraversalStack(stack)\n  >>> traversing.applyStackConsumers(root['content'], request)\n  >>> traversing.unconsumedURL(root['content'], request)\n  'http://127.0.0.1/content/kv/k1/v1/kv/k2/v2%20space'\n\nLet us have more than one content object\n\n  >>> under = content[u'under'] = Content()\n  >>> request = TestRequest()\n  >>> traversing.unconsumedURL(under, request)\n  'http://127.0.0.1/content/under'\n\nWe add some consumers to the above object\n\n  >>> request = TestRequest()\n  >>> stack = [u'index.html', u'value1', u'key1', u'kv']\n  >>> request.setTraversalStack(stack)\n  >>> traversing.applyStackConsumers(root['content'], request)\n  >>> traversing.unconsumedURL(root['content'], request)\n  'http://127.0.0.1/content/kv/key1/value1'\n  >>> traversing.unconsumedURL(under, request)\n  'http://127.0.0.1/content/kv/key1/value1/under'\n\nAnd now to the object below too.\n\n  >>> request = TestRequest()\n  >>> stack = [u'index.html', u'value1', u'key1', u'kv']\n  >>> request.setTraversalStack(stack)\n  >>> traversing.applyStackConsumers(root['content'], request)\n  >>> stack = [u'index.html', u'value2', u'key2', u'kv']\n  >>> request.setTraversalStack(stack)\n  >>> traversing.applyStackConsumers(under, request)\n  >>> traversing.unconsumedURL(root['content'], request)\n  'http://127.0.0.1/content/kv/key1/value1'\n  >>> traversing.unconsumedURL(under, request)\n  'http://127.0.0.1/content/kv/key1/value1/under/kv/key2/value2'\n\nOr only the object below.\n\n  >>> request = TestRequest()\n  >>> traversing.applyStackConsumers(root['content'], request)\n  >>> stack = [u'index.html', u'value2', u'key2', u'kv']\n  >>> request.setTraversalStack(stack)\n  >>> traversing.applyStackConsumers(under, request)\n  >>> traversing.unconsumedURL(root['content'], request)\n  'http://127.0.0.1/content'\n  >>> traversing.unconsumedURL(under, request)\n  'http://127.0.0.1/content/under/kv/key2/value2'\n\nThe unconsumedURL function is also available as a view, named\n``unconsumed_url``, similar to ``absolute_url`` one.\n\n  >>> from zope.component import getMultiAdapter\n  >>> url = getMultiAdapter((under, request), name='unconsumed_url')\n\n  >>> str(url)\n  'http://127.0.0.1/content/under/kv/key2/value2'\n\n  >>> url()\n  'http://127.0.0.1/content/under/kv/key2/value2'\n\n\n===============================================\nExtracting Information from the Traversal Stack\n===============================================\n\nThis is a simple example to demonstrate the usage of this\npackage. Please take a look into the testing directory to see how\nthings should be set up.\n\n  >>> from webtest.app import TestApp\n  >>> browser = TestApp(wsgi_app,\n  ...     extra_environ={'wsgi.handleErrors': False,\n  ...                    'paste.throw_errors': True,\n  ...                    'x-wsgiorg.throw_errors': True})\n  >>> res = browser.get('http://localhost/@@stackinfo.html')\n\nSo basically we have no stack info.\n\n  >>> print(res.body.decode())\n  Stack Info from object at http://localhost/stackinfo.html:\n\nLet us try to set foo to bar.\n\n  >>> res = browser.get('http://localhost/kv/foo/bar/@@stackinfo.html')\n  >>> print(res.body.decode())\n  Stack Info from object at http://localhost/stackinfo.html:\n  consumer kv:\n  key = u'foo'\n  value = u'bar'\n\nTwo consumers.\n\n  >>> res = browser.get(\n  ...     'http://localhost/kv/foo/bar/kv/time/late/@@stackinfo.html')\n  >>> print(res.body.decode())\n  Stack Info from object at http://localhost/stackinfo.html:\n  consumer kv:\n  key = u'foo'\n  value = u'bar'\n  consumer kv:\n  key = u'time'\n  value = u'late'\n\nInvalid url:\n\n  >>> browser.get('http://localhost/kv/foo/bar/kv/@@stackinfo.html') \\\n  ...     # doctes: +IGNORE_EXCEPTION_DETAIL\n  Traceback (most recent call last):\n  ...\n  NotFound: Object: <...Folder object at ...>, name: u'kv'", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/z3c.traverser", "keywords": "zope3 traverser pluggable plugin viewlet", "license": "ZPL 2.1", "maintainer": null, "maintainer_email": null, "name": "z3c.traverser", "package_url": "https://pypi.org/project/z3c.traverser/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/z3c.traverser/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/z3c.traverser"}, "release_url": "https://pypi.org/project/z3c.traverser/1.0.0/", "requires_dist": null, "requires_python": null, "summary": "Pluggable Traversers And URL handling utilities", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This package provides the pluggable traverser mechanism allowing developers\nto add new traversers to an object without altering the original traversal\nimplementation.</p>\n<p>In addition to the pluggable traversers, this package contains two more\nsubpackages:</p>\n<blockquote>\n<ul>\n<li>viewlet - provides a way to traverse to viewlets using namespaces</li>\n<li>stackinfo - provides a way to consume parts of url and store them\nas attributes of the \u201cconsumer\u201d object. Useful for urls like:\n/blog/2009/02/02/hello-world</li>\n</ul>\n</blockquote>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#changes\" id=\"id12\" rel=\"nofollow\">CHANGES</a><ul>\n<li><a href=\"#id1\" id=\"id13\" rel=\"nofollow\">1.0.0 (2015-11-09)</a></li>\n<li><a href=\"#a2-2013-03-03\" id=\"id14\" rel=\"nofollow\">1.0.0a2 (2013-03-03)</a></li>\n<li><a href=\"#a1-2013-03-03\" id=\"id15\" rel=\"nofollow\">1.0.0a1 (2013-03-03)</a></li>\n<li><a href=\"#id2\" id=\"id16\" rel=\"nofollow\">0.3.0 (2010-11-01)</a></li>\n<li><a href=\"#id3\" id=\"id17\" rel=\"nofollow\">0.2.5 (2009-03-13)</a></li>\n<li><a href=\"#id4\" id=\"id18\" rel=\"nofollow\">0.2.4 (2009-02-02)</a></li>\n<li><a href=\"#id5\" id=\"id19\" rel=\"nofollow\">0.2.3 (2008-07-14)</a></li>\n<li><a href=\"#id6\" id=\"id20\" rel=\"nofollow\">0.2.2 (2008-03-06)</a></li>\n<li><a href=\"#id7\" id=\"id21\" rel=\"nofollow\">0.2.1 (2007-11-92)</a></li>\n<li><a href=\"#id8\" id=\"id22\" rel=\"nofollow\">0.2.0 (2007-10-31)</a></li>\n<li><a href=\"#b2-2007-10-26\" id=\"id23\" rel=\"nofollow\">0.2.0b2 (2007-10-26)</a></li>\n<li><a href=\"#b1-2007-09-21\" id=\"id24\" rel=\"nofollow\">0.2.0b1 (2007-09-21)</a></li>\n<li><a href=\"#id9\" id=\"id25\" rel=\"nofollow\">0.1.3 (2007-06-03)</a></li>\n<li><a href=\"#id10\" id=\"id26\" rel=\"nofollow\">0.1.1 (2007-03-22)</a></li>\n</ul>\n</li>\n<li><a href=\"#pluggable-traversers\" id=\"id27\" rel=\"nofollow\">Pluggable Traversers</a><ul>\n<li><a href=\"#advanced-uses\" id=\"id28\" rel=\"nofollow\">Advanced Uses</a></li>\n<li><a href=\"#traverser-plugins\" id=\"id29\" rel=\"nofollow\">Traverser Plugins</a></li>\n<li><a href=\"#browser-traverser\" id=\"id30\" rel=\"nofollow\">Browser traverser</a></li>\n</ul>\n</li>\n<li><a href=\"#additional-namespaces\" id=\"id31\" rel=\"nofollow\">Additional Namespaces</a></li>\n<li><a href=\"#traversing-viewlets\" id=\"id32\" rel=\"nofollow\">Traversing Viewlets</a></li>\n<li><a href=\"#viewlet-traversing\" id=\"id33\" rel=\"nofollow\">Viewlet Traversing</a><ul>\n<li><a href=\"#caveats\" id=\"id34\" rel=\"nofollow\">Caveats</a></li>\n</ul>\n</li>\n<li><a href=\"#extracting-information-from-the-traversal-stack\" id=\"id35\" rel=\"nofollow\">Extracting Information from the Traversal Stack</a><ul>\n<li><a href=\"#virtual-host\" id=\"id36\" rel=\"nofollow\">Virtual Host</a></li>\n<li><a href=\"#url-handling\" id=\"id37\" rel=\"nofollow\">URL Handling</a></li>\n</ul>\n</li>\n<li><a href=\"#id11\" id=\"id38\" rel=\"nofollow\">Extracting Information from the Traversal Stack</a></li>\n</ul>\n</div>\n<div id=\"changes\">\n<h2><a href=\"#id12\" rel=\"nofollow\">CHANGES</a></h2>\n<div id=\"id1\">\n<h3><a href=\"#id13\" rel=\"nofollow\">1.0.0 (2015-11-09)</a></h3>\n<ul>\n<li>Standardize namespace __init__.</li>\n<li>Claim support for Python 3.4.</li>\n</ul>\n</div>\n<div id=\"a2-2013-03-03\">\n<h3><a href=\"#id14\" rel=\"nofollow\">1.0.0a2 (2013-03-03)</a></h3>\n<ul>\n<li>Added Trove classifiers to specify supported Python versions.</li>\n</ul>\n</div>\n<div id=\"a1-2013-03-03\">\n<h3><a href=\"#id15\" rel=\"nofollow\">1.0.0a1 (2013-03-03)</a></h3>\n<ul>\n<li>Added support for Python 3.3.</li>\n<li>Replaced deprecated <tt>zope.interface.implements</tt> usage with equivalent\n<tt>zope.interface.implementer</tt> decorator.</li>\n<li>Dropped support for Python 2.4 and 2.5.</li>\n<li>Switched from <tt>zope.testbrowser</tt> to <tt>WebTest</tt> for browser testing, since\ntestbrowser is not yet ported.</li>\n<li>Modernized API to use latest packages and component paths.</li>\n<li>Reduced test dependencies to the smallest set possible.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3><a href=\"#id16\" rel=\"nofollow\">0.3.0 (2010-11-01)</a></h3>\n<ul>\n<li>Updated test set up to run with ZTK 1.0.</li>\n<li>Using Python\u2019s <tt>doctest</tt> module instead of depreacted\n<tt>zope.testing.doctest[unit]</tt>.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3><a href=\"#id17\" rel=\"nofollow\">0.2.5 (2009-03-13)</a></h3>\n<ul>\n<li>Adapt to the move of IDefaultViewName from zope.component to zope.publisher.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3><a href=\"#id18\" rel=\"nofollow\">0.2.4 (2009-02-02)</a></h3>\n<ul>\n<li>Make <tt>PluggableBrowserTraverser</tt> implement <tt>IBrowserPublisher</tt>\ninterface.</li>\n<li>Fix tests and deprecation warnings.</li>\n<li>Improve test coverage.</li>\n<li>Get rid of zope.app.zapi dependency by replacing its uses with direct\ncalls.</li>\n<li>Change package\u2019s mailing list address to zope-dev at zope.org,\nbecause zope3-dev at zope.org is now retired.</li>\n<li>Change \u201ccheeseshop\u201d to \u201cpypi\u201d in the package\u2019s url.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3><a href=\"#id19\" rel=\"nofollow\">0.2.3 (2008-07-14)</a></h3>\n<ul>\n<li>Bugfix: In z3c.traverser.stackinfo the traversal stack got messed up\nwhen using the VirtualHost namespace with more than one thread.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id20\" rel=\"nofollow\">0.2.2 (2008-03-06)</a></h3>\n<ul>\n<li>Restructuring: Separated pluggable traverser functionality into two classes\nfor better code reuse.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3><a href=\"#id21\" rel=\"nofollow\">0.2.1 (2007-11-92)</a></h3>\n<ul>\n<li>Bugfix: if viewlet and managers get nested a viewlet was not found if\nthe depth reaches 3 because the context was set to the page and not\nto the context object.</li>\n<li>Bugfix: replaced call to <tt>_getContextName</tt> because it has been removed\nfrom <tt>absoluteURL</tt>.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3><a href=\"#id22\" rel=\"nofollow\">0.2.0 (2007-10-31)</a></h3>\n<ul>\n<li>Update package meta-data.</li>\n<li>Resolve <tt>ZopeSecurityPolicy</tt> deprecation warning.</li>\n</ul>\n</div>\n<div id=\"b2-2007-10-26\">\n<h3><a href=\"#id23\" rel=\"nofollow\">0.2.0b2 (2007-10-26)</a></h3>\n<ul>\n<li>Use only <tt>absolute_url</tt> adapters in unconsumed URL caclulations, to\nmake it work for traversable viewlets or other special cases too.</li>\n</ul>\n</div>\n<div id=\"b1-2007-09-21\">\n<h3><a href=\"#id24\" rel=\"nofollow\">0.2.0b1 (2007-09-21)</a></h3>\n<ul>\n<li>added a generic stack consumer handler which can be registered for\nBeforeTraverse events.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3><a href=\"#id25\" rel=\"nofollow\">0.1.3 (2007-06-03)</a></h3>\n<ul>\n<li>Added principal namespace, see <tt>namespace.rst</tt></li>\n<li>Fire <tt>BeforeUpdateEvent</tt> in viewlet view</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3><a href=\"#id26\" rel=\"nofollow\">0.1.1 (2007-03-22)</a></h3>\n<ul>\n<li>First egg release</li>\n</ul>\n</div>\n</div>\n<div id=\"pluggable-traversers\">\n<h2><a href=\"#id27\" rel=\"nofollow\">Pluggable Traversers</a></h2>\n<p>Traversers are Zope\u2019s mechanism to convert URI paths to an object of the\napplication. They provide an extremly flexible mechanism to make decisions\nbased on the policies of the application. Unfortunately the default traverser\nimplementation is not flexible enough to deal with arbitrary extensions (via\nadapters) of objects that also wish to participate in the traversal decision\nprocess.</p>\n<p>The pluggable traverser allows developers, especially third-party developers,\nto add new traversers to an object without altering the original traversal\nimplementation.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.traverser.traverser import PluggableTraverser\n</pre>\n</blockquote>\n<p>Let\u2019s say that we have an object</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.interface import Interface, implementer\n&gt;&gt;&gt; class IContent(Interface):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; @implementer(IContent)\n... class Content(object):\n...     var = True\n</pre>\n<pre>&gt;&gt;&gt; content = Content()\n</pre>\n</blockquote>\n<p>that we wish to traverse to. Since traversers are presentation-type specific,\nthey are implemented as views and must thus be initiated using a request:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.base import TestRequest\n&gt;&gt;&gt; request = TestRequest('')\n&gt;&gt;&gt; traverser = PluggableTraverser(content, request)\n</pre>\n</blockquote>\n<p>We can now try to lookup the variable:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; traverser.publishTraverse(request, 'var')\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;Content object at ...&gt;, name: 'var'\n</pre>\n</blockquote>\n<p>But it failed. Why? Because we have not registered a plugin traverser yet that\nknows how to lookup attributes. This package provides such a traverser\nalready, so we just have to register it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.component import provideSubscriptionAdapter\n&gt;&gt;&gt; from zope.publisher.interfaces import IPublisherRequest\n&gt;&gt;&gt; from z3c.traverser.traverser import AttributeTraverserPlugin\n</pre>\n<pre>&gt;&gt;&gt; provideSubscriptionAdapter(AttributeTraverserPlugin,\n...                            (IContent, IPublisherRequest))\n</pre>\n</blockquote>\n<p>If we now try to lookup the attribute, we the value:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; traverser.publishTraverse(request, 'var')\nTrue\n</pre>\n</blockquote>\n<p>However, an incorrect variable name will still return a <tt>NotFound</tt> error:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; traverser.publishTraverse(request, 'bad')\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;Content object at ...&gt;, name: 'bad'\n</pre>\n</blockquote>\n<p>Every traverser should also make sure that the passed in name is not a\nview. (This allows us to not specify the <tt>@@</tt> in front of a view.) So let\u2019s\nregister one:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class View(object):\n...     def __init__(self, context, request):\n...         pass\n</pre>\n<pre>&gt;&gt;&gt; from zope.component import provideAdapter\n&gt;&gt;&gt; from zope.publisher.interfaces import IPublisherRequest\n&gt;&gt;&gt; provideAdapter(View,\n...                adapts=(IContent, IPublisherRequest),\n...                provides=Interface,\n...                name='view.html')\n</pre>\n</blockquote>\n<p>Now we can lookup the view as well:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; traverser.publishTraverse(request, 'view.html')\n&lt;View object at ...&gt;\n</pre>\n</blockquote>\n<div id=\"advanced-uses\">\n<h3><a href=\"#id28\" rel=\"nofollow\">Advanced Uses</a></h3>\n<p>A more interesting case to consider is a traverser for a container. If you\nreally dislike the Zope 3 traversal namespace notation <tt>++namespace++</tt> and\nyou can control the names in the container, then the pluggable traverser will\nalso provide a viable solution. Let\u2019s say we have a container</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.container.interfaces import IContainer\n&gt;&gt;&gt; class IMyContainer(IContainer):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; from zope.container.btree import BTreeContainer\n&gt;&gt;&gt; @implementer(IMyContainer)\n... class MyContainer(BTreeContainer):\n...     foo = True\n...     bar = False\n</pre>\n<pre>&gt;&gt;&gt; myContainer = MyContainer()\n&gt;&gt;&gt; myContainer['blah'] = 123\n</pre>\n</blockquote>\n<p>and we would like to be able to traverse</p>\n<blockquote>\n<ul>\n<li><p>all items of the container, as well as</p>\n<pre>&gt;&gt;&gt; from z3c.traverser.traverser import ContainerTraverserPlugin\n&gt;&gt;&gt; from z3c.traverser.interfaces import ITraverserPlugin\n</pre>\n<pre>&gt;&gt;&gt; provideSubscriptionAdapter(ContainerTraverserPlugin,\n...                            (IMyContainer, IPublisherRequest),\n...                            ITraverserPlugin)\n</pre>\n</li>\n<li><p>the <tt>foo</tt> attribute. Luckily we also have a predeveloped traverser for\nthis:</p>\n<pre>&gt;&gt;&gt; from z3c.traverser.traverser import \\\n...     SingleAttributeTraverserPlugin\n&gt;&gt;&gt; provideSubscriptionAdapter(SingleAttributeTraverserPlugin('foo'),\n...                            (IMyContainer, IPublisherRequest))\n</pre>\n</li>\n</ul>\n</blockquote>\n<p>We can now use the pluggable traverser</p>\n<blockquote>\n<pre>&gt;&gt;&gt; traverser = PluggableTraverser(myContainer, request)\n</pre>\n</blockquote>\n<p>to look up items</p>\n<blockquote>\n<pre>&gt;&gt;&gt; traverser.publishTraverse(request, 'blah')\n123\n</pre>\n</blockquote>\n<p>and the <tt>foo</tt> attribute:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; traverser.publishTraverse(request, 'foo')\nTrue\n</pre>\n</blockquote>\n<p>However, we cannot lookup the <tt>bar</tt> attribute or any other non-existent\nitem:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; traverser.publishTraverse(request, 'bar')\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;MyContainer object at ...&gt;, name: 'bar'\n</pre>\n<pre>&gt;&gt;&gt; traverser.publishTraverse(request, 'bad')\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;MyContainer object at ...&gt;, name: 'bad'\n</pre>\n</blockquote>\n<p>You can also add traversers that return an adapted object. For example, let\u2019s\ntake the following adapter:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class ISomeAdapter(Interface):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; from zope.component import adapts\n&gt;&gt;&gt; @implementer(ISomeAdapter)\n... class SomeAdapter(object):\n...     adapts(IMyContainer)\n...\n...     def __init__(self, context):\n...         pass\n</pre>\n<pre>&gt;&gt;&gt; from zope.component import adapts, provideAdapter\n&gt;&gt;&gt; provideAdapter(SomeAdapter)\n</pre>\n</blockquote>\n<p>Now we register this adapter under the traversal name <tt>some</tt>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.traverser.traverser import AdapterTraverserPlugin\n&gt;&gt;&gt; provideSubscriptionAdapter(\n...     AdapterTraverserPlugin('some', ISomeAdapter),\n...     (IMyContainer, IPublisherRequest))\n</pre>\n</blockquote>\n<p>So here is the result:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; traverser.publishTraverse(request, 'some')\n&lt;SomeAdapter object at ...&gt;\n</pre>\n</blockquote>\n<p>If the object is not adaptable, we\u2019ll get NotFound. Let\u2019s register a\nplugin that tries to query a named adapter for ISomeAdapter. The third\nargument for AdapterTraverserPlugin is used to specify the adapter name.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; provideSubscriptionAdapter(\n...     AdapterTraverserPlugin('badadapter', ISomeAdapter, 'other'),\n...     (IMyContainer, IPublisherRequest))\n</pre>\n<pre>&gt;&gt;&gt; traverser.publishTraverse(request, 'badadapter')\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;MyContainer object at ...&gt;, name: 'badadapter'\n</pre>\n</blockquote>\n</div>\n<div id=\"traverser-plugins\">\n<h3><a href=\"#id29\" rel=\"nofollow\">Traverser Plugins</a></h3>\n<p>The <cite>traverser</cite> package comes with several default traverser plugins; three of\nthem were already introduced above: <cite>SingleAttributeTraverserPlugin</cite>,\n<cite>AdapterTraverserPlugin</cite>, and <cite>ContainerTraverserPlugin</cite>. Another plugin is\nthe the <cite>NullTraverserPlugin</cite>, which always just returns the object itself:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.traverser.traverser import NullTraverserPlugin\n&gt;&gt;&gt; SomethingPlugin = NullTraverserPlugin('something')\n</pre>\n<pre>&gt;&gt;&gt; plugin = SomethingPlugin(content, request)\n&gt;&gt;&gt; plugin.publishTraverse(request, 'something')\n&lt;Content object at ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; plugin.publishTraverse(request, 'something else')\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;Content object at ...&gt;, name: 'something else'\n</pre>\n</blockquote>\n<p>All of the above traversers with exception of the <cite>ContainerTraverserPlugin</cite>\nare implementation of the abstract <cite>NameTraverserPlugin</cite> class. Name traversers\nare traversers that can resolve one particular name. By using the abstract\n<cite>NameTraverserPlugin</cite> class, all of the traverser boilerplate can be\navoided. Here is a simple example that always returns a specific value for a\ntraversed name:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.traverser.traverser import NameTraverserPlugin\n&gt;&gt;&gt; class TrueTraverserPlugin(NameTraverserPlugin):\n...     traversalName = 'true'\n...     def _traverse(self, request, name):\n...         return True\n</pre>\n</blockquote>\n<p>As you can see realized name traversers must implement the <tt>_traverse()</tt>\nmethod, which is only responsible for returning the result. Of course it can\nalso raise the <cite>NotFound</cite> error if something goes wrong during the\ncomputation. LEt\u2019s check it out:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; plugin = TrueTraverserPlugin(content, request)\n&gt;&gt;&gt; plugin.publishTraverse(request, 'true')\nTrue\n</pre>\n<pre>&gt;&gt;&gt; plugin.publishTraverse(request, 'false')\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;Content object at ...&gt;, name: 'false'\n</pre>\n</blockquote>\n<p>A final traverser that is offered by the package is the\n<cite>AttributeTraverserPlugin`</cite>, which simply allows one to traverse all\naccessible attributes of an object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.traverser.traverser import AttributeTraverserPlugin\n</pre>\n<pre>&gt;&gt;&gt; plugin = AttributeTraverserPlugin(myContainer, request)\n&gt;&gt;&gt; plugin.publishTraverse(request, 'foo')\nTrue\n&gt;&gt;&gt; plugin.publishTraverse(request, 'bar')\nFalse\n&gt;&gt;&gt; plugin.publishTraverse(request, 'blah')\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;MyContainer object at ...&gt;, name: 'blah'\n&gt;&gt;&gt; plugin.publishTraverse(request, 'some')\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;MyContainer object at ...&gt;, name: 'some'\n</pre>\n</blockquote>\n</div>\n<div id=\"browser-traverser\">\n<h3><a href=\"#id30\" rel=\"nofollow\">Browser traverser</a></h3>\n<p>There\u2019s also a special subclass of the PluggableTraverser that\nimplements the <tt>IBrowserPublisher</tt> interface, thus providing the\n<tt>browserDefault</tt> method that returns a default object and a view\nname to traverse and use if there\u2019s no more steps to traverse.</p>\n<p>Let\u2019s provide a view name registered as an IDefaultView adapter. This\nis usually done by zope.publisher\u2019s browser:defaultView directive.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.interfaces import IDefaultViewName\n&gt;&gt;&gt; provideAdapter('view.html', (IContent, Interface), IDefaultViewName)\n</pre>\n<pre>&gt;&gt;&gt; from z3c.traverser.browser import PluggableBrowserTraverser\n&gt;&gt;&gt; traverser = PluggableBrowserTraverser(content, request)\n&gt;&gt;&gt; traverser.browserDefault(request)\n(&lt;Content object at 0x...&gt;, ('@@view.html',))\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"additional-namespaces\">\n<h2><a href=\"#id31\" rel=\"nofollow\">Additional Namespaces</a></h2>\n<h2 id=\"principal\"><span class=\"section-subtitle\">Principal</span></h2>\n<p>The <tt>principal</tt> namespace allows to differentiate between usernames\nin the url. This is usefull for caching on a per principal basis. The\nnamespace itself doesn\u2019t change anything. It just checks if the\nprincipal is the one that is logged in.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.traverser import namespace\n&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; class Request(TestRequest):\n...     principal = None\n...\n...     def shiftNameToApplication(self):\n...         pass\n</pre>\n<pre>&gt;&gt;&gt; class Principal(object):\n...     def __init__(self, id):\n...         self.id = id\n</pre>\n<pre>&gt;&gt;&gt; pid = 'something'\n&gt;&gt;&gt; r = Request()\n&gt;&gt;&gt; r.principal = Principal('anonymous')\n</pre>\n</blockquote>\n<p>If we have the wrong principal we get an Unauthorized exception.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ns = namespace.principal(object(), r)\n&gt;&gt;&gt; ns.traverse('another', None) # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nUnauthorized: ++principal++another\n</pre>\n</blockquote>\n<p>Otherwise not</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ns.traverse('anonymous', None)\n&lt;object object at ...&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"traversing-viewlets\">\n<h2><a href=\"#id32\" rel=\"nofollow\">Traversing Viewlets</a></h2>\n<p>This package allows to traverse viewlets and viewletmanagers. It also\nprovides absolute url views for those objects which are described in\nthis file, for traversers see BROWSER.rst.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.traverser.viewlet import browser\n</pre>\n</blockquote>\n<p>Let us define some test classes.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from zope.viewlet import manager\n&gt;&gt;&gt; from zope.viewlet import interfaces\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; class ILeftColumn(interfaces.IViewletManager):\n...     \"\"\"Viewlet manager located in the left column.\"\"\"\n&gt;&gt;&gt; LeftColumn = manager.ViewletManager('left', ILeftColumn)\n&gt;&gt;&gt; zope.component.provideAdapter(\n...     LeftColumn,\n...     (zope.interface.Interface,\n...     IDefaultBrowserLayer, zope.interface.Interface),\n...     interfaces.IViewletManager, name='left')\n</pre>\n</blockquote>\n<p>You can then create a viewlet manager using this interface now:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.viewlet import viewlet\n&gt;&gt;&gt; from zope.container.contained import Contained\n</pre>\n<pre>&gt;&gt;&gt; class Content(Contained):\n...     pass\n&gt;&gt;&gt; root['content'] = Content()\n&gt;&gt;&gt; content = root['content']\n&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IBrowserView\n&gt;&gt;&gt; from zope.publisher.browser import BrowserView\n&gt;&gt;&gt; class View(BrowserView):\n...     pass\n</pre>\n</blockquote>\n<p>We have to set the name, this is normally done in zcml.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view = View(content, request)\n&gt;&gt;&gt; view.__name__ = 'test.html'\n&gt;&gt;&gt; leftColumn = LeftColumn(content, request, view)\n</pre>\n</blockquote>\n<p>Let us create a simple viewlet. Note that we need a __name__ attribute\nin order to make the viewlet traversable. Normally you don\u2019t have to\ntake care of this, because the zcml directive sets the name upon\nregistration.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class MyViewlet(viewlet.ViewletBase):\n...     __name__ = 'myViewlet'\n...     def render(self):\n...         return u'&lt;div&gt;My Viewlet&lt;/div&gt;'\n&gt;&gt;&gt; from zope.security.checker import NamesChecker, defineChecker\n&gt;&gt;&gt; viewletChecker = NamesChecker(('update', 'render'))\n&gt;&gt;&gt; defineChecker(MyViewlet, viewletChecker)\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(\n...     MyViewlet,\n...     (zope.interface.Interface, IDefaultBrowserLayer,\n...     IBrowserView, ILeftColumn),\n...     interfaces.IViewlet, name='myViewlet')\n</pre>\n</blockquote>\n<p>We should now be able to get the absolute url of the viewlet and the\nmanager. We have to register the adapter for the test.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.traversing.browser.interfaces import IAbsoluteURL\n&gt;&gt;&gt; from zope.traversing.browser import absoluteurl\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(\n...     browser.ViewletAbsoluteURL,\n...     (interfaces.IViewlet, IDefaultBrowserLayer),\n...     IAbsoluteURL)\n&gt;&gt;&gt; zope.component.provideAdapter(\n...     browser.ViewletManagerAbsoluteURL,\n...     (interfaces.IViewletManager, IDefaultBrowserLayer),\n...     IAbsoluteURL, name=\"absolute_url\")\n&gt;&gt;&gt; zope.component.provideAdapter(\n...     browser.ViewletManagerAbsoluteURL,\n...     (interfaces.IViewletManager, IDefaultBrowserLayer),\n...     IAbsoluteURL)\n&gt;&gt;&gt; myViewlet = MyViewlet(content, request, view, leftColumn)\n&gt;&gt;&gt; absoluteurl.absoluteURL(leftColumn, request)\n'http://127.0.0.1/content/test.html/++manager++left'\n&gt;&gt;&gt; absoluteurl.absoluteURL(myViewlet, request)\n'.../content/test.html/++manager++left/++viewlet++myViewlet'\n</pre>\n</blockquote>\n</div>\n<div id=\"viewlet-traversing\">\n<h2><a href=\"#id33\" rel=\"nofollow\">Viewlet Traversing</a></h2>\n<p>Traversing to viewlets is done via namespaces.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from webtest.app import TestApp\n&gt;&gt;&gt; browser = TestApp(wsgi_app)\n&gt;&gt;&gt; res = browser.get('http://localhost/@@test.html')\n</pre>\n</blockquote>\n<p>We have a test page registered that contains our viewlet. The viewlet\nitself just renders a link to its location (this is just for testing).</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(res.html)\n&lt;html&gt;\n  &lt;body&gt;\n     &lt;div&gt;&lt;div&gt;&lt;a\n     href=\"http://localhost/test.html/++manager++IMyManager/++viewlet++MyViewlet\"&gt;My\n     Viewlet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n</blockquote>\n<p>Let\u2019s follow the link to traverse the viewlet directly.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = res.click('My Viewlet')\n&gt;&gt;&gt; res.request.url\n'http://localhost/test.html/++manager++IMyManager/++viewlet++MyViewlet'\n&gt;&gt;&gt; print(res.body.decode())\n&lt;div&gt;&lt;a href=\"http://localhost/test.html/++manager++IMyManager/++viewlet++MyViewlet\"&gt;My Viewlet&lt;/a&gt;&lt;/div&gt;\n</pre>\n</blockquote>\n<p>What happens if a viewlet managers is nested into another viewlet? To test\nthis we will create another manager and another viewlet:</p>\n<pre>&gt;&gt;&gt; res = browser.get('http://localhost/@@nested.html')\n&gt;&gt;&gt; print(res.html)\n&lt;html&gt;\n  &lt;body&gt;\n    &lt;div&gt;&lt;div&gt;&lt;a href=\"http://localhost/nested.html/++manager++IOuterManager/++viewlet++OuterViewlet/++manager++IInnerManager/++viewlet++InnerViewlet/++manager++IMostInnerManager/++viewlet++MostInnerViewlet\"&gt;Most inner viewlet&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n<p>Let\u2019s follow the link to traverse the viewlet directly.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = res.click('Most inner viewlet')\n&gt;&gt;&gt; res.request.url\n'http://localhost/nested.html/++manager++IOuterManager/++viewlet++OuterViewlet/++manager++IInnerManager/++viewlet++InnerViewlet/++manager++IMostInnerManager/++viewlet++MostInnerViewlet'\n</pre>\n<pre>&gt;&gt;&gt; print(res.body.decode())\n&lt;div&gt;&lt;a href=\"http://localhost/nested.html/++manager++IOuterManager/++viewlet++OuterViewlet/++manager++IInnerManager/++viewlet++InnerViewlet/++manager++IMostInnerManager/++viewlet++MostInnerViewlet\"&gt;Most inner viewlet&lt;/a&gt;&lt;/div&gt;\n</pre>\n</blockquote>\n<div id=\"caveats\">\n<h3><a href=\"#id34\" rel=\"nofollow\">Caveats</a></h3>\n<p>Update of the manager is not called, because this may be too expensive\nand normally the managers update just collects viewlets.</p>\n</div>\n</div>\n<div id=\"extracting-information-from-the-traversal-stack\">\n<h2><a href=\"#id35\" rel=\"nofollow\">Extracting Information from the Traversal Stack</a></h2>\n<p>This package allows to define virtual traversal paths for collecting\narbitrary information from the traversal stack instead of, for\nexample, query strings.</p>\n<p>In contrast to the common way of defining custom Traversers, this\nimplementation does not require to go through the whole traversal\nprocess step by step. The traversal information needed is taken from\nthe traversalstack directly and the used parts of the stack are\nconsumed. This way one don\u2019t have to define proxy classes just for\ntraversal.</p>\n<p>This implementation does not work in tales because it requires the\ntraversalstack of the request.</p>\n<p>For each name in the traversal stack a named multiadapter is looked up\nfor ITraversalStackConsumer, if found the item gets removed from the\nstack and the adapter is added to the request annotation.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.traverser.stackinfo import traversing\n&gt;&gt;&gt; from z3c.traverser.stackinfo import interfaces\n</pre>\n</blockquote>\n<p>If there are no adapters defined, the traversalstack is kept as is. To\nshow this behaviour we define some sample classes.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope import interface\n&gt;&gt;&gt; class IContent(interface.Interface):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; from zope.site.folder import Folder\n&gt;&gt;&gt; @interface.implementer(IContent)\n... class Content(Folder):\n...     pass\n</pre>\n</blockquote>\n<p>There is a convinience function which returns an iterator which\niterates over tuples of adapterName, adapter. Additionally the\ntraversal stack of the request is consumed if needed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IBrowserRequest\n&gt;&gt;&gt; request = TestRequest()\n</pre>\n</blockquote>\n<p>We set the traversal stack manually for testing here.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request.setTraversalStack([u'index.html', u'path', u'some'])\n&gt;&gt;&gt; content = Content()\n</pre>\n</blockquote>\n<p>So if no ITraversalStackConsumer adapters are found the stack is left\nuntouched.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(traversing.getStackConsumers(content, request))\n[]\n&gt;&gt;&gt; request.getTraversalStack()\n[u'index.html', u'path', u'some']\n</pre>\n</blockquote>\n<p>There is a base class for consumer implementations which implements\nthe ITraversalStackConsumer interface.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.traverser.stackinfo import consumer\n&gt;&gt;&gt; from zope.interface.verify import verifyObject\n&gt;&gt;&gt; o = consumer.BaseConsumer(None, None)\n&gt;&gt;&gt; verifyObject(interfaces.ITraversalStackConsumer,o)\nTrue\n</pre>\n</blockquote>\n<p>Let us define a custom consumer.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope import component\n&gt;&gt;&gt; class DummyConsumer(consumer.BaseConsumer):\n...     component.adapts(IContent, IBrowserRequest)\n&gt;&gt;&gt; component.provideAdapter(DummyConsumer, name='some')\n</pre>\n</blockquote>\n<p>Now we will find the newly registered consumer and the \u2018some\u2019 part of\nthe stack is consumed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; consumers = list(traversing.getStackConsumers(content, request))\n&gt;&gt;&gt; consumers\n[(u'some', &lt;DummyConsumer named u'some'&gt;)]\n&gt;&gt;&gt; request.getTraversalStack()\n[u'index.html', u'path']\n</pre>\n</blockquote>\n<p>Each consumer at least has to consume one element, which is always\nthe name under which the adapter was registered under.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; name, cons = consumers[0]\n&gt;&gt;&gt; cons.__name__\nu'some'\n</pre>\n</blockquote>\n<p>Let us provide another adapter, to demonstrate that the adpaters\nalways have the reverse order of the traversal stack. This is actually\nthe order in the url.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; component.provideAdapter(DummyConsumer, name='other')\n&gt;&gt;&gt; stack = [u'index.html', u'path', u'some', u'other']\n&gt;&gt;&gt; request.setTraversalStack(stack)\n&gt;&gt;&gt; consumers = list(traversing.getStackConsumers(content, request))\n&gt;&gt;&gt; consumers\n[(u'other', &lt;DummyConsumer named u'other'&gt;),\n (u'some', &lt;DummyConsumer named u'some'&gt;)]\n</pre>\n<pre>&gt;&gt;&gt; [c.__name__ for name, c in consumers]\n[u'other', u'some']\n</pre>\n</blockquote>\n<p>The arguments attribute of the consumer class defines how many\narguments are consumed/needed from the stack. Let us create a KeyValue\nconsumer, that should extract key value pairs from the stack.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class KeyValueConsumer(DummyConsumer):\n...     arguments=('key', 'value')\n&gt;&gt;&gt; component.provideAdapter(KeyValueConsumer, name='kv')\n&gt;&gt;&gt; stack = [u'index.html', u'value', u'key', u'kv']\n&gt;&gt;&gt; request.setTraversalStack(stack)\n&gt;&gt;&gt; consumers = list(traversing.getStackConsumers(content, request))\n&gt;&gt;&gt; consumers\n[(u'kv', &lt;KeyValueConsumer named u'kv'&gt;)]\n&gt;&gt;&gt; request.getTraversalStack()\n[u'index.html']\n&gt;&gt;&gt; name, cons = consumers[0]\n&gt;&gt;&gt; cons.key\nu'key'\n&gt;&gt;&gt; cons.value\nu'value'\n</pre>\n</blockquote>\n<p>We can of course use multiple consumers of the same type.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; stack = [u'index.html', u'v2', u'k2', u'kv', u'v1', u'k1', u'kv']\n&gt;&gt;&gt; request.setTraversalStack(stack)\n&gt;&gt;&gt; consumers = list(traversing.getStackConsumers(content, request))\n&gt;&gt;&gt; [(c.__name__, c.key, c.value) for name, c in consumers]\n[(u'kv', u'k1', u'v1'), (u'kv', u'k2', u'v2')]\n</pre>\n</blockquote>\n<p>If we have too less arguments a NotFound exception.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; stack = [u'k2', u'kv', u'v1', u'k1', u'kv']\n&gt;&gt;&gt; request.setTraversalStack(stack)\n&gt;&gt;&gt; consumers = list(traversing.getStackConsumers(content, request))\nTraceback (most recent call last):\n  ...\nNotFound: Object: &lt;Content object at ...&gt;, name: u'kv'\n</pre>\n</blockquote>\n<p>In order to actually use the stack consumers to retrieve information,\nthere is another convinience function which stores the consumers in\nthe requests annotations. This should noramlly be called on\nBeforeTraverseEvents.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; stack = [u'index.html', u'v2', u'k2', u'kv', u'v1', u'k1', u'kv']\n&gt;&gt;&gt; request.setTraversalStack(stack)\n&gt;&gt;&gt; traversing.applyStackConsumers(content, request)\n&gt;&gt;&gt; request.annotations[traversing.CONSUMERS_ANNOTATION_KEY]\n[&lt;KeyValueConsumer named u'kv'&gt;,\n &lt;KeyValueConsumer named u'kv'&gt;]\n</pre>\n</blockquote>\n<p>Instead of messing with the annotations one just can adapt the request\nto ITraversalStackInfo.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; component.provideAdapter(consumer.requestTraversalStackInfo)\n&gt;&gt;&gt; ti = interfaces.ITraversalStackInfo(request)\n&gt;&gt;&gt; ti\n(&lt;KeyValueConsumer named u'kv'&gt;, &lt;KeyValueConsumer named u'kv'&gt;)\n</pre>\n<pre>&gt;&gt;&gt; len(ti)\n2\n</pre>\n</blockquote>\n<p>The adapter always returs an empty TraversalStackInfoObject if there\nis no traversalstack information.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; ti = interfaces.ITraversalStackInfo(request)\n&gt;&gt;&gt; len(ti)\n0\n</pre>\n</blockquote>\n<div id=\"virtual-host\">\n<h3><a href=\"#id36\" rel=\"nofollow\">Virtual Host</a></h3>\n<p>If virtual hosts are used the traversal stack contains aditional information\nfor the virtual host which will interfere which the stack consumer.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; stack = [u'index.html', u'value', u'key',\n...          u'kv', u'++', u'inside vh', '++vh++something']\n&gt;&gt;&gt; request.setTraversalStack(stack)\n&gt;&gt;&gt; consumers = list(traversing.getStackConsumers(content, request))\n&gt;&gt;&gt; consumers\n[(u'kv', &lt;KeyValueConsumer named u'kv'&gt;)]\n&gt;&gt;&gt; request.getTraversalStack()\n[u'index.html', u'++', u'inside vh', '++vh++something']\n</pre>\n</blockquote>\n</div>\n<div id=\"url-handling\">\n<h3><a href=\"#id37\" rel=\"nofollow\">URL Handling</a></h3>\n<p>Let us try these things with a real url, in our test the root is the site.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.traversing.browser.absoluteurl import absoluteURL\n&gt;&gt;&gt; absoluteURL(root, request)\n'http://127.0.0.1'\n</pre>\n</blockquote>\n<p>There is an unconsumedURL function which returns the url of an object\nwith the traversal information, which is normally omitted.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; root['content'] = content\n&gt;&gt;&gt; absoluteURL(root['content'], request)\n'http://127.0.0.1/content'\n&gt;&gt;&gt; stack = [u'index.html', u'v2 space', u'k2', u'kv', u'v1', u'k1', u'kv']\n&gt;&gt;&gt; request.setTraversalStack(stack)\n&gt;&gt;&gt; traversing.applyStackConsumers(root['content'], request)\n&gt;&gt;&gt; traversing.unconsumedURL(root['content'], request)\n'http://127.0.0.1/content/kv/k1/v1/kv/k2/v2%20space'\n</pre>\n</blockquote>\n<p>Let us have more than one content object</p>\n<blockquote>\n<pre>&gt;&gt;&gt; under = content[u'under'] = Content()\n&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; traversing.unconsumedURL(under, request)\n'http://127.0.0.1/content/under'\n</pre>\n</blockquote>\n<p>We add some consumers to the above object</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; stack = [u'index.html', u'value1', u'key1', u'kv']\n&gt;&gt;&gt; request.setTraversalStack(stack)\n&gt;&gt;&gt; traversing.applyStackConsumers(root['content'], request)\n&gt;&gt;&gt; traversing.unconsumedURL(root['content'], request)\n'http://127.0.0.1/content/kv/key1/value1'\n&gt;&gt;&gt; traversing.unconsumedURL(under, request)\n'http://127.0.0.1/content/kv/key1/value1/under'\n</pre>\n</blockquote>\n<p>And now to the object below too.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; stack = [u'index.html', u'value1', u'key1', u'kv']\n&gt;&gt;&gt; request.setTraversalStack(stack)\n&gt;&gt;&gt; traversing.applyStackConsumers(root['content'], request)\n&gt;&gt;&gt; stack = [u'index.html', u'value2', u'key2', u'kv']\n&gt;&gt;&gt; request.setTraversalStack(stack)\n&gt;&gt;&gt; traversing.applyStackConsumers(under, request)\n&gt;&gt;&gt; traversing.unconsumedURL(root['content'], request)\n'http://127.0.0.1/content/kv/key1/value1'\n&gt;&gt;&gt; traversing.unconsumedURL(under, request)\n'http://127.0.0.1/content/kv/key1/value1/under/kv/key2/value2'\n</pre>\n</blockquote>\n<p>Or only the object below.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest()\n&gt;&gt;&gt; traversing.applyStackConsumers(root['content'], request)\n&gt;&gt;&gt; stack = [u'index.html', u'value2', u'key2', u'kv']\n&gt;&gt;&gt; request.setTraversalStack(stack)\n&gt;&gt;&gt; traversing.applyStackConsumers(under, request)\n&gt;&gt;&gt; traversing.unconsumedURL(root['content'], request)\n'http://127.0.0.1/content'\n&gt;&gt;&gt; traversing.unconsumedURL(under, request)\n'http://127.0.0.1/content/under/kv/key2/value2'\n</pre>\n</blockquote>\n<p>The unconsumedURL function is also available as a view, named\n<tt>unconsumed_url</tt>, similar to <tt>absolute_url</tt> one.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.component import getMultiAdapter\n&gt;&gt;&gt; url = getMultiAdapter((under, request), name='unconsumed_url')\n</pre>\n<pre>&gt;&gt;&gt; str(url)\n'http://127.0.0.1/content/under/kv/key2/value2'\n</pre>\n<pre>&gt;&gt;&gt; url()\n'http://127.0.0.1/content/under/kv/key2/value2'\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"id11\">\n<h2><a href=\"#id38\" rel=\"nofollow\">Extracting Information from the Traversal Stack</a></h2>\n<p>This is a simple example to demonstrate the usage of this\npackage. Please take a look into the testing directory to see how\nthings should be set up.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from webtest.app import TestApp\n&gt;&gt;&gt; browser = TestApp(wsgi_app,\n...     extra_environ={'wsgi.handleErrors': False,\n...                    'paste.throw_errors': True,\n...                    'x-wsgiorg.throw_errors': True})\n&gt;&gt;&gt; res = browser.get('http://localhost/@@stackinfo.html')\n</pre>\n</blockquote>\n<p>So basically we have no stack info.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(res.body.decode())\nStack Info from object at http://localhost/stackinfo.html:\n</pre>\n</blockquote>\n<p>Let us try to set foo to bar.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = browser.get('http://localhost/kv/foo/bar/@@stackinfo.html')\n&gt;&gt;&gt; print(res.body.decode())\nStack Info from object at http://localhost/stackinfo.html:\nconsumer kv:\nkey = u'foo'\nvalue = u'bar'\n</pre>\n</blockquote>\n<p>Two consumers.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = browser.get(\n...     'http://localhost/kv/foo/bar/kv/time/late/@@stackinfo.html')\n&gt;&gt;&gt; print(res.body.decode())\nStack Info from object at http://localhost/stackinfo.html:\nconsumer kv:\nkey = u'foo'\nvalue = u'bar'\nconsumer kv:\nkey = u'time'\nvalue = u'late'\n</pre>\n</blockquote>\n<p>Invalid url:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; browser.get('http://localhost/kv/foo/bar/kv/@@stackinfo.html') \\\n...     # doctes: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;...Folder object at ...&gt;, name: u'kv'\n</pre>\n</blockquote>\n</div>\n\n          </div>"}, "last_serial": 1807869, "releases": {"0.1.1-r74198": [{"comment_text": "", "digests": {"md5": "24c488e0739c227574b9d7daab369d47", "sha256": "2d88655f3c590fe4843315432d36c89febc9d58376668b4df3a4610f5aa153cf"}, "downloads": -1, "filename": "z3c.traverser-0.1.1-r74198.tar.gz", "has_sig": false, "md5_digest": "24c488e0739c227574b9d7daab369d47", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14605, "upload_time": "2007-04-18T06:44:08", "upload_time_iso_8601": "2007-04-18T06:44:08Z", "url": "https://files.pythonhosted.org/packages/38/55/a40bae8d2c2620900b908b1c92a5f94188bc1e404cd1708aaf4b67dbba94/z3c.traverser-0.1.1-r74198.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "bec6a794ab527a726f0f430e465bdce3", "sha256": "c07838893cfbfcdea8c7360793178f00691baf6d0becb8a5720e6babad7821b6"}, "downloads": -1, "filename": "z3c.traverser-0.2.0.tar.gz", "has_sig": false, "md5_digest": "bec6a794ab527a726f0f430e465bdce3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27630, "upload_time": "2007-11-01T09:12:52", "upload_time_iso_8601": "2007-11-01T09:12:52Z", "url": "https://files.pythonhosted.org/packages/87/ab/f5e11d6a3b887fc25bdceef6fefe5bc4ceb6361bb14ede12fa38292be251/z3c.traverser-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "b20985c73b99b17bf710aa96b16c0a2b", "sha256": "dccfe1c7691f52262e132d64d31836157bdf6dd56652753f6cdd1db91a81d863"}, "downloads": -1, "filename": "z3c.traverser-0.2.1.tar.gz", "has_sig": false, "md5_digest": "b20985c73b99b17bf710aa96b16c0a2b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31355, "upload_time": "2007-11-29T14:34:59", "upload_time_iso_8601": "2007-11-29T14:34:59Z", "url": "https://files.pythonhosted.org/packages/f8/ac/2a350dfd21612cdcdcb56b9b0fdaef3220c0dc52d0cf1ea13948f294baa4/z3c.traverser-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "614185659b20c120b3a1f5e5754b5911", "sha256": "3be3b24f123a5ab67e975e6e988f3f0c9ed2672b25f3b151f74310c929f817f9"}, "downloads": -1, "filename": "z3c.traverser-0.2.2.tar.gz", "has_sig": false, "md5_digest": "614185659b20c120b3a1f5e5754b5911", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29413, "upload_time": "2008-03-06T07:49:27", "upload_time_iso_8601": "2008-03-06T07:49:27Z", "url": "https://files.pythonhosted.org/packages/10/27/c333ba4f51132b4ec0412e681356ec110200d6698fe0bdf3def49ff1016f/z3c.traverser-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "63dbf1f3fae95101ad6b0fbb290fa6f3", "sha256": "0195a1cdb8ebab5f0da3ebc180ddb5568935de695769d9af2e5cecfe06318b5d"}, "downloads": -1, "filename": "z3c.traverser-0.2.3.tar.gz", "has_sig": false, "md5_digest": "63dbf1f3fae95101ad6b0fbb290fa6f3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31847, "upload_time": "2008-07-14T08:47:37", "upload_time_iso_8601": "2008-07-14T08:47:37Z", "url": "https://files.pythonhosted.org/packages/86/8f/d501c96ed8bef1b57299870c0bebafc42ac8272a3abf4e2c3408e3240d07/z3c.traverser-0.2.3.tar.gz", "yanked": false}], "0.2.4": [{"comment_text": "", "digests": {"md5": "f4fc9647bc39858686f059a13d4c2cf8", "sha256": "ceb4ca28ab365f75a316befb5f09833aa44d85b05028c996bda23c1d420c81f3"}, "downloads": -1, "filename": "z3c.traverser-0.2.4.tar.gz", "has_sig": false, "md5_digest": "f4fc9647bc39858686f059a13d4c2cf8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33137, "upload_time": "2009-02-02T15:46:45", "upload_time_iso_8601": "2009-02-02T15:46:45Z", "url": "https://files.pythonhosted.org/packages/8b/07/304f5887e3d2c63a6f009705c991dfaf4029ee919608c2f1ee536acbaf20/z3c.traverser-0.2.4.tar.gz", "yanked": false}], "0.2.5": [{"comment_text": "", "digests": {"md5": "73a63c0171a509ccd5c8e64cff29ff9d", "sha256": "5df6882c7b163e4b251d3305412bcbbd7085d8d612f07dc990f536ef3d66179b"}, "downloads": -1, "filename": "z3c.traverser-0.2.5.tar.gz", "has_sig": false, "md5_digest": "73a63c0171a509ccd5c8e64cff29ff9d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33189, "upload_time": "2009-03-13T07:58:36", "upload_time_iso_8601": "2009-03-13T07:58:36.851905Z", "url": "https://files.pythonhosted.org/packages/98/41/35cd96bddabd1d26ac87f6179632a4758198b6072c765709c308618b6ab5/z3c.traverser-0.2.5.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "095381a8de6ad4547b98fecb929e3885", "sha256": "51fb7fb07d6791d2fc20eb77803b6171b9e282870956f33d2934a8dd747c4653"}, "downloads": -1, "filename": "z3c.traverser-0.3.0.tar.gz", "has_sig": false, "md5_digest": "095381a8de6ad4547b98fecb929e3885", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33707, "upload_time": "2010-11-01T08:26:49", "upload_time_iso_8601": "2010-11-01T08:26:49.591949Z", "url": "https://files.pythonhosted.org/packages/c9/e0/fa53f7a545abcb6ee74b59632012460fc0c4152af4ebb4ca41e41e6b7354/z3c.traverser-0.3.0.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "3a6f0b07a1dbc12c6763707f2ad1e762", "sha256": "445bda7eb89f2359ca6d9d1315ec51169a1923e106e89d65a9674880e0998657"}, "downloads": -1, "filename": "z3c.traverser-1.0.0.tar.gz", "has_sig": false, "md5_digest": "3a6f0b07a1dbc12c6763707f2ad1e762", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37239, "upload_time": "2015-11-09T14:13:45", "upload_time_iso_8601": "2015-11-09T14:13:45.822432Z", "url": "https://files.pythonhosted.org/packages/9a/5d/2a571de911eed0786389fbd9c75d35930e907b08e5e82b98b6be4728fb6a/z3c.traverser-1.0.0.tar.gz", "yanked": false}], "1.0.0a1": [{"comment_text": "", "digests": {"md5": "fb2e7c31d0bca5bd11ddbe694357ae77", "sha256": "a82f194d743a3ca66b6268e8c02bc460853cd832a4c069f40408f7c0a62624d0"}, "downloads": -1, "filename": "z3c.traverser-1.0.0a1.zip", "has_sig": false, "md5_digest": "fb2e7c31d0bca5bd11ddbe694357ae77", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58465, "upload_time": "2013-03-03T10:15:22", "upload_time_iso_8601": "2013-03-03T10:15:22.756181Z", "url": "https://files.pythonhosted.org/packages/5f/25/507a44d804965bac1526d6bd148c069adba160445fe478839d0823311da8/z3c.traverser-1.0.0a1.zip", "yanked": false}], "1.0.0a2": [{"comment_text": "", "digests": {"md5": "413a6209ae299351ac7368d4fc6ff320", "sha256": "051f1bf54bbe7a34f51994274748071667661b9a97659647ae4d32fee211f7b1"}, "downloads": -1, "filename": "z3c.traverser-1.0.0a2.zip", "has_sig": false, "md5_digest": "413a6209ae299351ac7368d4fc6ff320", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58662, "upload_time": "2013-03-03T14:45:33", "upload_time_iso_8601": "2013-03-03T14:45:33.723812Z", "url": "https://files.pythonhosted.org/packages/fa/50/5fd7416603d603858c9011c19ff0c93808249e971724f03b3e6e33cbf39c/z3c.traverser-1.0.0a2.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3a6f0b07a1dbc12c6763707f2ad1e762", "sha256": "445bda7eb89f2359ca6d9d1315ec51169a1923e106e89d65a9674880e0998657"}, "downloads": -1, "filename": "z3c.traverser-1.0.0.tar.gz", "has_sig": false, "md5_digest": "3a6f0b07a1dbc12c6763707f2ad1e762", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37239, "upload_time": "2015-11-09T14:13:45", "upload_time_iso_8601": "2015-11-09T14:13:45.822432Z", "url": "https://files.pythonhosted.org/packages/9a/5d/2a571de911eed0786389fbd9c75d35930e907b08e5e82b98b6be4728fb6a/z3c.traverser-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:20:20 2020"}