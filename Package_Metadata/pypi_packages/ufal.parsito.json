{"info": {"author": "Milan Straka", "author_email": "straka@ufal.mff.cuni.cz", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)", "Programming Language :: C++", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries"], "description": "ufal.parsito\n============\n\nThe ``ufal.parsito`` is a Python binding to Parsito library <http://ufal.mff.cuni.cz/parsito>.\n\nThe bindings is a straightforward conversion of the ``C++`` bindings API.\nIn Python 2, strings can be both ``unicode`` and UTF-8 encoded ``str``, and the\nlibrary always produces ``unicode``. In Python 3, strings must be only ``str``.\n\n\nWrapped C++ API\n---------------\n\nThe C++ API being wrapped follows. For a API reference of the original\nC++ API, see <http://ufal.mff.cuni.cz/parsito/api-reference>.\n\n::\n\n  Helper Structures\n  -----------------\n\n    typedef vector<int> Children;\n\n    class Node {\n     public:\n      int id;          // 0 is root, >0 is sentence node, <0 is undefined\n      string form;    // form\n      string lemma;   // lemma\n      string upostag; // universal part-of-speech tag\n      string xpostag; // language-specific part-of-speech tag\n      string feats;   // list of morphological features\n      int head;       // head, 0 is root, <0 is without parent\n      string deprel;  // dependency relation to the head\n      string deps;    // secondary dependencies\n      string misc;    // miscellaneous information\n\n      Children children;\n\n      node(int id = -1, string form = string());\n    };\n    typedef std::vector<node> Nodes;\n\n\n  Main Classes\n  ------------\n\n    class Tree {\n     public:\n      Tree();\n\n      Nodes nodes;\n\n      bool empty();\n      void clear();\n      node& addNode(string form);\n      void setHead(int id, int head, string deprel);\n      void unlinkAllNodes();\n\n      static const std::string root_form;\n    }\n\n    class TreeInputFormat {\n     public:\n      virtual void setText(string text);\n      virtual bool nextTree(tree& t) = 0;\n      string lastError() const;\n\n      // Static factory methods\n      static TreeInputFormat* newInputFormat(string name);\n      static TreeInputFormat* newConlluInputFormat();\n    };\n\n    class TreeOutputFormat {\n     public:\n\n      virtual string writeTree(const tree& t, const tree_input_format* additional_info = nullptr);\n\n      // Static factory methods\n      static TreeOutputFormat* newOutputFormat(string name);\n      static TreeOutputFormat* newConlluOutputFormat();\n    };\n\n    class Parser {\n     public:\n      virtual void parse(tree& t, unsigned beam_size = 0) const;\n\n      enum { NO_CACHE = 0, FULL_CACHE = 2147483647};\n      static Parser* load(string file, unsigned cache = 1000);\n    };\n\n    class Version {\n     public:\n      unsigned major;\n      unsigned minor;\n      unsigned patch;\n      string prerelease;\n\n      static Version current();\n    };\n\n\nExamples\n========\n\nrun_parsito\n--------------\n\nSimple parsing example::\n\n\n  from ufal.parsito import *\n\n  # In Python2, wrap sys.stdin and sys.stdout to work with unicode.\n  if sys.version_info[0] < 3:\n    import codecs\n    import locale\n    encoding = locale.getpreferredencoding()\n    sys.stdin = codecs.getreader(encoding)(sys.stdin)\n    sys.stdout = codecs.getwriter(encoding)(sys.stdout)\n\n  if len(sys.argv) == 1:\n    sys.stderr.write('Usage: %s parser_file\\n' % sys.argv[0])\n    sys.exit(1)\n\n  sys.stderr.write('Loading parser: ')\n  parser = Parser.load(sys.argv[1])\n  if not parser:\n    sys.stderr.write(\"Cannot load parser from file '%s'\\n\" % sys.argv[1])\n    sys.exit(1)\n  sys.stderr.write('done\\n')\n\n  conlluInput = TreeInputFormat.newInputFormat(\"conllu\");\n  conlluOutput = TreeOutputFormat.newOutputFormat(\"conllu\");\n  tree = Tree()\n\n  not_eof = True\n  while not_eof:\n    text = ''\n\n    # Read block\n    while True:\n      line = sys.stdin.readline()\n      not_eof = bool(line)\n      if not not_eof: break\n      line = line.rstrip('\\r\\n')\n      text += line\n      text += '\\n';\n      if not line: break\n\n\n    # Parse\n    conlluInput.setText(text)\n    while conlluInput.nextTree(tree):\n      parser.parse(tree)\n\n      output = conlluOutput.writeTree(tree, conlluInput)\n      sys.stdout.write(output)\n    if conlluInput.lastError():\n      sys.stderr.write(\"Cannot read input CoNLL-U: \")\n      sys.stderr.write(conlluInput.lastError())\n      sys.stderr.write(\"\\n\")\n      sys.exit(1)\n\n\nAUTHORS\n=======\n\nMilan Straka <straka@ufal.mff.cuni.cz>\n\n\nCOPYRIGHT AND LICENCE\n=====================\n\nCopyright 2015 Institute of Formal and Applied Linguistics, Faculty of\nMathematics and Physics, Charles University in Prague, Czech Republic.\n\nThis Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at http://mozilla.org/MPL/2.0/.", "description_content_type": null, "docs_url": null, "download_url": null, "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://ufal.mff.cuni.cz/parsito", "keywords": null, "license": "MPL 2.0", "maintainer": null, "maintainer_email": null, "name": "ufal.parsito", "package_url": "https://pypi.org/project/ufal.parsito/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/ufal.parsito/", "project_urls": {"Homepage": "http://ufal.mff.cuni.cz/parsito"}, "release_url": "https://pypi.org/project/ufal.parsito/1.1.0.1/", "requires_dist": null, "requires_python": null, "summary": "Bindings to Parsito library", "version": "1.1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"ufal-parsito\">\n<h2>ufal.parsito</h2>\n<p>The <tt>ufal.parsito</tt> is a Python binding to Parsito library &lt;<a href=\"http://ufal.mff.cuni.cz/parsito\" rel=\"nofollow\">http://ufal.mff.cuni.cz/parsito</a>&gt;.</p>\n<p>The bindings is a straightforward conversion of the <tt>C++</tt> bindings API.\nIn Python 2, strings can be both <tt>unicode</tt> and UTF-8 encoded <tt>str</tt>, and the\nlibrary always produces <tt>unicode</tt>. In Python 3, strings must be only <tt>str</tt>.</p>\n<div id=\"wrapped-c-api\">\n<h3>Wrapped C++ API</h3>\n<p>The C++ API being wrapped follows. For a API reference of the original\nC++ API, see &lt;<a href=\"http://ufal.mff.cuni.cz/parsito/api-reference\" rel=\"nofollow\">http://ufal.mff.cuni.cz/parsito/api-reference</a>&gt;.</p>\n<pre>Helper Structures\n-----------------\n\n  typedef vector&lt;int&gt; Children;\n\n  class Node {\n   public:\n    int id;          // 0 is root, &gt;0 is sentence node, &lt;0 is undefined\n    string form;    // form\n    string lemma;   // lemma\n    string upostag; // universal part-of-speech tag\n    string xpostag; // language-specific part-of-speech tag\n    string feats;   // list of morphological features\n    int head;       // head, 0 is root, &lt;0 is without parent\n    string deprel;  // dependency relation to the head\n    string deps;    // secondary dependencies\n    string misc;    // miscellaneous information\n\n    Children children;\n\n    node(int id = -1, string form = string());\n  };\n  typedef std::vector&lt;node&gt; Nodes;\n\n\nMain Classes\n------------\n\n  class Tree {\n   public:\n    Tree();\n\n    Nodes nodes;\n\n    bool empty();\n    void clear();\n    node&amp; addNode(string form);\n    void setHead(int id, int head, string deprel);\n    void unlinkAllNodes();\n\n    static const std::string root_form;\n  }\n\n  class TreeInputFormat {\n   public:\n    virtual void setText(string text);\n    virtual bool nextTree(tree&amp; t) = 0;\n    string lastError() const;\n\n    // Static factory methods\n    static TreeInputFormat* newInputFormat(string name);\n    static TreeInputFormat* newConlluInputFormat();\n  };\n\n  class TreeOutputFormat {\n   public:\n\n    virtual string writeTree(const tree&amp; t, const tree_input_format* additional_info = nullptr);\n\n    // Static factory methods\n    static TreeOutputFormat* newOutputFormat(string name);\n    static TreeOutputFormat* newConlluOutputFormat();\n  };\n\n  class Parser {\n   public:\n    virtual void parse(tree&amp; t, unsigned beam_size = 0) const;\n\n    enum { NO_CACHE = 0, FULL_CACHE = 2147483647};\n    static Parser* load(string file, unsigned cache = 1000);\n  };\n\n  class Version {\n   public:\n    unsigned major;\n    unsigned minor;\n    unsigned patch;\n    string prerelease;\n\n    static Version current();\n  };\n</pre>\n</div>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<h2 id=\"run-parsito\"><span class=\"section-subtitle\">run_parsito</span></h2>\n<p>Simple parsing example:</p>\n<pre>from ufal.parsito import *\n\n# In Python2, wrap sys.stdin and sys.stdout to work with unicode.\nif sys.version_info[0] &lt; 3:\n  import codecs\n  import locale\n  encoding = locale.getpreferredencoding()\n  sys.stdin = codecs.getreader(encoding)(sys.stdin)\n  sys.stdout = codecs.getwriter(encoding)(sys.stdout)\n\nif len(sys.argv) == 1:\n  sys.stderr.write('Usage: %s parser_file\\n' % sys.argv[0])\n  sys.exit(1)\n\nsys.stderr.write('Loading parser: ')\nparser = Parser.load(sys.argv[1])\nif not parser:\n  sys.stderr.write(\"Cannot load parser from file '%s'\\n\" % sys.argv[1])\n  sys.exit(1)\nsys.stderr.write('done\\n')\n\nconlluInput = TreeInputFormat.newInputFormat(\"conllu\");\nconlluOutput = TreeOutputFormat.newOutputFormat(\"conllu\");\ntree = Tree()\n\nnot_eof = True\nwhile not_eof:\n  text = ''\n\n  # Read block\n  while True:\n    line = sys.stdin.readline()\n    not_eof = bool(line)\n    if not not_eof: break\n    line = line.rstrip('\\r\\n')\n    text += line\n    text += '\\n';\n    if not line: break\n\n\n  # Parse\n  conlluInput.setText(text)\n  while conlluInput.nextTree(tree):\n    parser.parse(tree)\n\n    output = conlluOutput.writeTree(tree, conlluInput)\n    sys.stdout.write(output)\n  if conlluInput.lastError():\n    sys.stderr.write(\"Cannot read input CoNLL-U: \")\n    sys.stderr.write(conlluInput.lastError())\n    sys.stderr.write(\"\\n\")\n    sys.exit(1)\n</pre>\n</div>\n<div id=\"authors\">\n<h2>AUTHORS</h2>\n<p>Milan Straka &lt;<a href=\"mailto:straka%40ufal.mff.cuni.cz\">straka<span>@</span>ufal<span>.</span>mff<span>.</span>cuni<span>.</span>cz</a>&gt;</p>\n</div>\n<div id=\"copyright-and-licence\">\n<h2>COPYRIGHT AND LICENCE</h2>\n<p>Copyright 2015 Institute of Formal and Applied Linguistics, Faculty of\nMathematics and Physics, Charles University in Prague, Czech Republic.</p>\n<p>This Source Code Form is subject to the terms of the Mozilla Public\nLicense, v. 2.0. If a copy of the MPL was not distributed with this\nfile, You can obtain one at <a href=\"http://mozilla.org/MPL/2.0/\" rel=\"nofollow\">http://mozilla.org/MPL/2.0/</a>.</p>\n</div>\n\n          </div>"}, "last_serial": 1887347, "releases": {"1.0.0.1": [{"comment_text": "", "digests": {"md5": "730adc4692167e4cbb39ac3235f48199", "sha256": "c9aa6669983b94c7baca757a51f2a0c9429f76658ba0147cccda78a8f3ea0cdf"}, "downloads": -1, "filename": "ufal.parsito-1.0.0.1.tar.gz", "has_sig": false, "md5_digest": "730adc4692167e4cbb39ac3235f48199", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 112260, "upload_time": "2015-12-04T10:34:42", "upload_time_iso_8601": "2015-12-04T10:34:42.115807Z", "url": "https://files.pythonhosted.org/packages/a8/9f/3465c68063040cd7cf8705cf87180e1c69ed1c7f1b5266e835d7f3eb32f8/ufal.parsito-1.0.0.1.tar.gz", "yanked": false}], "1.1.0.1": [{"comment_text": "", "digests": {"md5": "b9a511024076b7a982914ff9ca9737b6", "sha256": "1056672f019de326978fe144aaccf181e950fb70ae4cc1d12f221c5358e308a1"}, "downloads": -1, "filename": "ufal.parsito-1.1.0.1.tar.gz", "has_sig": false, "md5_digest": "b9a511024076b7a982914ff9ca9737b6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 114655, "upload_time": "2016-01-04T12:29:22", "upload_time_iso_8601": "2016-01-04T12:29:22.650114Z", "url": "https://files.pythonhosted.org/packages/d6/12/9c081af96169578accec4527b1632783d2b16c15abba01265f0b178b0919/ufal.parsito-1.1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b9a511024076b7a982914ff9ca9737b6", "sha256": "1056672f019de326978fe144aaccf181e950fb70ae4cc1d12f221c5358e308a1"}, "downloads": -1, "filename": "ufal.parsito-1.1.0.1.tar.gz", "has_sig": false, "md5_digest": "b9a511024076b7a982914ff9ca9737b6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 114655, "upload_time": "2016-01-04T12:29:22", "upload_time_iso_8601": "2016-01-04T12:29:22.650114Z", "url": "https://files.pythonhosted.org/packages/d6/12/9c081af96169578accec4527b1632783d2b16c15abba01265f0b178b0919/ufal.parsito-1.1.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:41:45 2020"}