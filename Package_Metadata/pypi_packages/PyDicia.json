{"info": {"author": "Phillip J. Eby", "author_email": "peak@eby-sarna.com", "bugtrack_url": null, "classifiers": [], "description": "==========================================================\nPackage Shipment and Address Verification with ``PyDicia``\n==========================================================\n\nNew in 0.1a3\n  * Added ``FlatRateLargeBox`` and ``ExpressMailPremiumService`` tags, for use\n    with DAZzle 8.0 and up.\n\nNew in 0.1a2\n  * Dropped MS Windows requirement; you can now use PyDicia to generate XML for\n    the Endicia Mac client, or to be sent via download or networked directory\n    to a Windows client.  \n\n  * Added a ``Shipment.run()`` method to allow running multiple batches in\n    sequence.\n\n  * Fixed the ``Status.ToZip4`` attribute (it was incorrectly spelled\n    ``ToZIP4``, and thus didn't work).\n   \nPyDicia is a Python interface to endicia.com's postal services client, DAZzle.\nUsing DAZzle's XML interface, PyDicia can be used to print shipping labels,\nenvelopes, postcards and more, with or without prepaid US postage indicia\n(electronic stamps), as well as doing address verification.\n\nIn addition to providing a layer of syntax sugar for the DAZzle XML interface,\nPyDicia provides a novel adaptive interface that lets you smoothly integrate\nits functions with your application's core types (like invoice, customer, or\n\"packing slip\" objects) without subclassing.  (This is particularly useful if\nyou are extending a CRM or other database that was written by somebody else.)\n\nThis version of PyDicia is an alpha proof-of-concept release.  It is actually\nusable -- I've in fact been using it in production for over a year, shipping\ndozens of envelopes and packages a month all over the US, Canada, and Europe.\nHowever, the API is still potentially subject to change, the reference\ndocumentation is sketchy, and the developer's guide lacks detail about some of\nthe more advanced features.  This should improve in future releases, but at\nleast this way, you can use it now, if you need something like it.  Reading the\n`DAZzle XML API specification`_ is a good idea if you want to use this, though;\nthe 8.0 version is the latest, although PyDicia also supports 7.0.x versions.\n\n.. _DAZzle XML API specification: http://fileserver.surveygizmo.com/users/4508/dazzleXMLInterfaceV8.pdf\n\nPyDicia uses the ElementTree, simplegeneric, and DecoratorTools packages, and\nrequires Python 2.4 or higher (due to use of decorators and the ``Decimal``\ntype).  Actually printing any labels requires that you have an Endicia\n\"Premium\" or \"Mac\" account.  (Note: I have not used the Mac client, so I don't\nknow how well it works there.  See the section below on `Using PyDicia on\nNon-Windows Platforms`_ for more info.)\n\nIMPORTANT\n    Please note that PyDicia does not attempt to implement all of the US Postal\n    Service's business rules for what options may be used in what combinations.\n    It doesn't even validate most of the DAZzle client's documented\n    restrictions!  So it's strictly a \"Garbage In, Garbage Out\" kind of deal.\n    If you put garbage in, who knows what the heck will happen.  You might end\n    up spending lots of money *and* getting your packages returned to you --\n    and **I AM NOT RESPONSIBLE**, even if your problem is due to an error in\n    PyDicia or its documentation!\n\n    So, make sure you understand the shipping options you wish to use, and test\n    your application thoroughly before using this code in production.  You have\n    been warned!\n\nQuestions, discussion, and bug reports for this software should be directed to\nthe PEAK mailing list; see http://www.eby-sarna.com/mailman/listinfo/PEAK/\nfor details.\n\n.. contents:: **Table of Contents**\n\n\n-----------------\nDeveloper's Guide\n-----------------\n\n\nBasic XML Generation\n====================\n\nPyDicia simplifies the creation of XML for DAZzle by using objects to specify\nwhat data needs to go in the XML.  These objects are mostly ``Option``\ninstances, or callables that create ``Option`` instances.  However, the\nframework is extensible, so that you can use your own object types with the\nsame API.  Your object types can either generate ``Option`` instances, or\ndirectly manipulate the XML using ElementTree APIs for maximum control.\n\nIn the simpler cases, however, you will just use lists or tuples of objects\nprovided by (or created with) the PyDicia API to represent packages or labels.\n\n\nBatch Objects\n-------------\n\nXML documents are represented using ``Batch`` objects::\n\n    >>> from pydicia import *\n    >>> b = Batch()\n\nThe ``tostring()`` method of a batch returns its XML in string form, optionally\nin a given encoding (defaulting to ASCII if not specified)::\n\n    >>> print b.tostring('latin1')\n    <?xml version='1.0' encoding='latin1'?>\n    <DAZzle />\n\nTo add a package to a batch, you use the ``add_package()`` method::\n\n    >>> b.add_package(ToName('Phillip Eby'))\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\">\n             <ToName>Phillip Eby</ToName>\n        </Package>\n    </DAZzle>\n\nThe ``add_package()`` method accepts zero or more objects that can manipulate\nPyDicia package objects.  It also accepts tuples or lists of such objects,\nnested to arbitrary depth::\n\n    >>> b.add_package([Services.COD, (Stealth, ToName('Ty Sarna'))], FlatRateBox)\n\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\">\n            <ToName>Phillip Eby</ToName>\n        </Package>\n        <Package ID=\"2\">\n            <Services COD=\"ON\" />\n            <Stealth>TRUE</Stealth>\n            <ToName>Ty Sarna</ToName>\n            <PackageType>FLATRATEBOX</PackageType>\n        </Package>\n    </DAZzle>\n\nAnd the ``packages`` attribute of a batch keeps track of the arguments that\nhave been passed to ``add_package()``::\n\n    >>> b.packages\n    [Package(ToName('Phillip Eby'),),\n     Package([Services.COD('ON'), (Stealth('TRUE'), ToName('Ty Sarna'))],\n      PackageType('FLATRATEBOX'))]\n\nEach package object in the list wraps a tuple of the arguments that were\nsupplied for each invocation of ``add_package()``.  This allows the system\nto send status updates (including delivery confirmation numbers, customs IDs,\netc.) back to the application.\n\nBut before we can process status updates, we need to have some application\nobjects, as described in the next section.\n\n\nUsing Your Application Objects as Package Sources\n-------------------------------------------------\n\nIn addition to PyDicia-defined objects and sequences thereof, the\n``add_package()`` method also accepts any custom objects of your own design\nthat have been registered with the ``pydicia.add_to_package()`` or\n``pydicia.iter_options()`` generic functions::\n\n    >>> class Customer:\n    ...     def __init__(self, **kw):\n    ...         self.__dict__ = kw\n\n    >>> @iter_options.when_type(Customer)\n    ... def cust_options(ob):\n    ...     yield ToName(ob.name)\n    ...     yield ToAddress(ob.address)\n    ...     yield ToCity(ob.city)\n    ...     yield ToState(ob.state)\n    ...     yield ToPostalCode(ob.zip)\n\n    >>> b = Batch()\n    >>> c = Customer(\n    ...     name='PJE', address='123 Nowhere Dr', state='FL', city='Nowhere',\n    ...     zip='12345-6789'\n    ... )\n    >>> b.add_package(c)\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\">\n            <ToName>PJE</ToName>\n            <ToAddress1>123 Nowhere Dr</ToAddress1>\n            <ToCity>Nowhere</ToCity>\n            <ToState>FL</ToState>\n            <ToPostalCode>12345-6789</ToPostalCode>\n        </Package>\n    </DAZzle>\n\nThis allows you to pass customer, package, product, invoice, or other\napplication-specific objects into ``add_package()``.  And the objects yielded\nby your ``iter_options`` implementation can also be application objects, e.g.::\n\n    >>> class Invoice:\n    ...     def __init__(self, **kw):\n    ...         self.__dict__ = kw\n\n    >>> @iter_options.when_type(Invoice)\n    ... def invoice_options(ob):\n    ...     yield ob.shippingtype\n    ...     yield ob.products\n    ...     yield ob.customer\n\n    >>> b = Batch()\n    >>> i = Invoice(\n    ...     shippingtype=(Tomorrow, MailClass('MEDIAMAIL')),\n    ...     products=[WeightOz(27),], customer=c\n    ... )\n    >>> b.add_package(i)\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\">\n            <DateAdvance>1</DateAdvance>\n            <MailClass>MEDIAMAIL</MailClass>\n            <WeightOz>27</WeightOz>\n            <ToName>PJE</ToName>\n            <ToAddress1>123 Nowhere Dr</ToAddress1>\n            <ToCity>Nowhere</ToCity>\n            <ToState>FL</ToState>\n            <ToPostalCode>12345-6789</ToPostalCode>\n        </Package>\n    </DAZzle>\n\nNote that there is no particular significance to my choice of lists vs. tuples\nin these examples; they're more to demonstrate that you can use arbitrary\nstructures, as long as they contain objects that are supported by either\n``iter_options()`` or ``add_to_package()``.  Normally, you will simply use\ncollections of either PyDicia-provided symbols, or application objects for\nwhich you've defined an ``iter_options()`` method.\n\nYou will also usually want to implement your PyDicia support in a module by\nitself, so you can use ``from pydicia import *`` without worrying about symbol\ncollisions.\n\n\nBatch-wide Options\n------------------\n\nWhen you create a batch, you can pass in any number of objects, to specify\noptions that will be applied to every package.  For example, this batch will\nhave every package set to be mailed tomorrow as media mail::\n\n    >>> b = Batch( Tomorrow, MailClass('MEDIAMAIL') )\n    >>> b.add_package(ToName('PJE'))\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\">\n            <ToName>PJE</ToName>\n            <DateAdvance>1</DateAdvance>\n            <MailClass>MEDIAMAIL</MailClass>\n        </Package>\n    </DAZzle>\n\n\nMulti-Batch Shipments\n=====================\n\nCertain DAZzle options can only be set once per XML file, such as the choice of\nlayout file.  If you are shipping multiple packages with different label\nlayouts (such as domestic vs. international mail), you need to separate these\npackages into different batches, each of which will be in a separate XML file.\nThe ``Shipment`` class handles this separation for you automatically.\n\nWhen you create a shipment, it initially has no batches::\n\n    >>> s = Shipment()\n    >>> s.batches\n    []\n\n\nBut as you add packages to it, it will create batches as needed::\n\n    >>> s.add_package(ToName('Phillip Eby'), DAZzle.Test)\n    >>> len(s.batches)\n    1\n\n    >>> print s.batches[0].tostring()\n    <DAZzle Test=\"YES\">\n        <Package ID=\"1\">\n            <ToName>Phillip Eby</ToName>\n        </Package>\n    </DAZzle>\n\nAs long as you're adding packages with the same or compatible options, the\nsame batch will be reused::\n\n    >>> s.add_package(ToName('Ty Sarna'), DAZzle.Test)\n    >>> len(s.batches)\n    1\n    >>> print s.batches[0].tostring()\n    <DAZzle Test=\"YES\">\n        <Package ID=\"1\">\n            <ToName>Phillip Eby</ToName>\n        </Package>\n        <Package ID=\"2\">\n            <ToName>Ty Sarna</ToName>\n        </Package>\n    </DAZzle>\n\nBut as soon as you add a package with any incompatible options, a new batch\nwill be created and used::\n\n    >>> s.add_package(ToName('PJE'), ~DAZzle.Test)\n    >>> len(s.batches)\n    2\n\n    >>> print s.batches[1].tostring()\n    <DAZzle Test=\"NO\">\n        <Package ID=\"1\">\n            <ToName>PJE</ToName>\n        </Package>\n    </DAZzle>\n\nAnd each time you add a package, it's added to the first compatible batch::\n\n    >>> s.add_package(ToName('Some Body'), ~DAZzle.Test)\n    >>> len(s.batches)\n    2\n\n    >>> print s.batches[1].tostring()\n    <DAZzle Test=\"NO\">\n        <Package ID=\"1\">\n            <ToName>PJE</ToName>\n        </Package>\n        <Package ID=\"2\">\n            <ToName>Some Body</ToName>\n        </Package>\n    </DAZzle>\n\n    >>> s.add_package(ToName('No Body'), DAZzle.Test)\n    >>> len(s.batches)\n    2\n\n    >>> print s.batches[0].tostring()\n    <DAZzle Test=\"YES\">\n        <Package ID=\"1\">\n            <ToName>Phillip Eby</ToName>\n        </Package>\n        <Package ID=\"2\">\n            <ToName>Ty Sarna</ToName>\n        </Package>\n        <Package ID=\"3\">\n            <ToName>No Body</ToName>\n        </Package>\n    </DAZzle>\n\nBy the way, as with batches, you can create a shipment with options that will\nbe applied to all packages::\n\n    >>> s = Shipment(Tomorrow, Services.COD)\n    >>> s.add_package(ToName('Some Body'), DAZzle.Test)\n    >>> s.add_package(ToName('No Body'), ~DAZzle.Test)\n    >>> len(s.batches)\n    2\n    >>> print s.batches[0].tostring()\n    <DAZzle Test=\"YES\">\n        <Package ID=\"1\">\n            <ToName>Some Body</ToName>\n            <DateAdvance>1</DateAdvance>\n            <Services COD=\"ON\" />\n        </Package>\n    </DAZzle>\n\n    >>> print s.batches[1].tostring()\n    <DAZzle Test=\"NO\">\n        <Package ID=\"1\">\n            <ToName>No Body</ToName>\n            <DateAdvance>1</DateAdvance>\n            <Services COD=\"ON\" />\n        </Package>\n    </DAZzle>\n\n\n\nReceiving Status Updates\n========================\n\nWhen DAZzle completes a batch, it creates an output file containing status\ninformation for each package in the batch.  If you'd like to process this\nstatus information for the corresponding application objects you passed in\nto ``add_package()``, you can extend the ``report_status()`` generic function\nto do this::\n\n    >>> @report_status.when_type(Customer)\n    ... def customer_status(ob, status):\n    ...     print ob\n    ...     print status\n\n    >>> b = Batch()\n    >>> b.add_package(c)\n\nWhen the batch receives status information, it will invoke ``report_status()``\non each package's application items, with a status object for the corresponding\npackage::\n\n    >>> b.report_statuses()\n    <...Customer instance...>\n    ToAddress           : [u'123 Nowhere Dr']\n    ToCity              : u'Nowhere'\n    ToState             : u'FL'\n    ToPostalCode        : u'12345-6789'\n    ToAddress1          : u'123 Nowhere Dr'\n\nNote that you don't normally need to call ``report_statuses()`` directly; it's\nusually done for you as part of the process of running a batch or shipment.\n(See the section below on `Invoking DAZzle`_.)\n\nThe `status` object passed to your method will be a ``Status`` instance with\nattributes similar to those above, containing USPS-normalized address data.\nIn addition, several other fields are possible::\n\n    >>> from pydicia import ET\n    >>> b.etree = ET.fromstring('''\n    ... <DAZzle><Package ID=\"1\">\n    ...     <ToZip4>1234</ToZip4>\n    ...     <Status>Rejected (-3)</Status>\n    ...     <PIC>123465874359</PIC>\n    ...     <FinalPostage>4.60</FinalPostage>\n    ...     <TransactionDateTime>20070704173221</TransactionDateTime>\n    ...     <PostmarkDate>20070705</PostmarkDate>\n    ... </Package></DAZzle>''')\n\n    >>> b.report_statuses()\n    <...Customer instance...>\n    Status              : 'Rejected (-3)'\n    ErrorCode           : -3\n    ToAddress           : []\n    ToZip4              : '1234'\n    PIC                 : '123465874359'\n    FinalPostage        : Decimal(\"4.60\")\n    TransactionDateTime : datetime.datetime(2007, 7, 4, 17, 32, 21)\n    PostmarkDate        : datetime.date(2007, 7, 5)\n\nThe ``Status`` object should support all output fields supported by DAZzle; see\nthe DAZzle documentation for details.  The non-string fields shown above are\nthe only ones which are postprocessed to specialized Python objects; the rest\nare kept as strings or Unicode values.  The ``ErrorCode`` field is computed by\nextracting the integer portion of any rejection code.  It is ``None`` in the\ncase of a successful live print, and ``0`` in the case of a successful test\nprint.  See the DAZzle XML interface documentation for a description of other\nerror codes.\n\nNote that for a more compact presentation, attributes with ``None`` values are\nnot included in the ``str()`` of a ``Status`` object, which is why the statuses\ndisplayed above show different sets of fields.  The attributes, however, always\nexist; they simply have ``None`` as their value.\n\n\nInvoking DAZzle\n===============\n\nIn the simplest case, invoking a batch or shipment object's ``.run()`` method\nwill launch a local copy of DAZzle on a temporary file containing the batch's\nXML, wait for DAZzle to exit, then process status updates from the output file\nand return DAZzle's return code.  (Or a list of return codes, in the case of a\n``Shipment``.)\n\nIf you are using this approach, you may wish to include ``~DAZzle.Prompt``\n(which keeps end-user prompts to a minimum) and ``DAZzle.AutoClose`` (so that\nDAZzle exits upon completion of the batch) in your batch options.\n\nIf you do not have a local copy of DAZzle, but instead are using a network\nqueue directory to send jobs remotely, you can instead use the batch object's\n``.write(queuedir)`` method to send the batch to the queue.  You can also\nuse this approach to send jobs to a local copy of DAZzle running in the\nbackground.\n\nIf a copy of DAZzle is installed locally, you can get its XML queue directory\nfrom ``DAZzle.XMLDirectory``, and check whether it is monitoring for files\nusing ``DAZzle.get_preference(\"MonitorXML\")``.  (These values will be ``None``\nif DAZzle is not installed.)\n\nIf DAZzle is installed locally, you can launch it with the\n``DAZzle.run(args=(), sync=True)`` function.  The `args` are a list of command\nline arguments to pass, and `sync` is a flag indicating whether to wait for\nDAZzle to exit.  If `sync` is a false value, ``run()`` returns a\n``subprocess.Popen`` instance.  Otherwise, it returns the process's exit code\n(ala ``subprocess.call``).\n\nXXX async batch status retrieval\n\nXXX DAZzle.exe_path, DAZzle.get_preference(), DAZzle.LayoutDirectory\n\nXXX Launching for multi-batch, remote, queued, and other async processing\n\n\nUsing PyDicia on Non-Windows Platforms\n======================================\n\nWhen used on a non-Windows platform, PyDicia cannot detect any DAZzle\nconfiguration information, so you must manually set ``DAZzle.exe_path`` to\nthe client program, if you wish to use any of the ``run()`` methods.\n(Likewise, you must manually set ``DAZzle.LayoutDirectory`` if you want layout\npaths to be automatically adjusted.)\n\nOn the Mac, the ``exe_path`` should be set to a program that takes a single\nXML filename as an argument.  The Mac ``endiciatool`` program probably will\nnot work on its own, without a wrapper shell script of some kind; I'm open to\nsuggestions as to how to improve this.  (Note, by the way, that the Mac client\ndoesn't support all of the options that the Windows client does, so remember\nthat use of PyDicia is entirely at your own risk, whatever the platform!)\n\nOn other platforms, the main usefulness of PyDicia would be in generating XML\nfor users to download (e.g. from a web application) or submitting and\nprocessing jobs via a Samba-mounted queue directory.  You don't need an\n``exe_path`` for this, but you will need to generate your own layout and output\nfile paths using ``Option`` objects, to avoid them being mangled by PyDicia's\nplatform-specific path munging.\n\nXXX explain how to do that, or make it work anyway\n\n\nAdvanced Customization\n======================\n\nXXX Using Option elements, add_to_package()\n\n\n-----------------\nOptions Reference\n-----------------\n\nBasic Package Options\n=====================\n\nXXX MailClass(text), NoPostage\nDateAdvance(), Today, Tomorrow\nValue()\nDescription()\nWeightOz()\n\n\nAddresses\n=========\n\n::\n    >>> ToName(\"Phillip J. Eby\")\n    ToName('Phillip J. Eby')\n\n    >>> ToTitle(\"President\")\n    ToTitle('President')\n\n    >>> ToCompany(\"Dirt Simple, Inc.\")\n    ToCompany('Dirt Simple, Inc.')\n\n\nXXX ToAddress(\\*lines)\nToCity(text), ToState(text), ToPostalCode(text), ToZIP4(text), ToCountry(text)\n\nXXX ReturnAddress(\\*lines)\nToDeliveryPoint(text)\nEndorsementLine(text)\nToCarrierRoute(text)\n\n\nPackage Details\n===============\n\nXXX PackageType()\nFlatRateEnvelope\nFlatRateBox\nRectangularParcel\nNonRectangularParcel\nPostcard\nFlat\nEnvelope\nWidth(), Length(), Depth()\nNonMachinable\nBalloonRate\n\n\nService Options\n===============\n\nXXX ReplyPostage\nStealth\nSignatureWaiver\nNoWeekendDelivery\nNoHolidayDelivery\nReturnToSender\nInsurance.USPS\nInsurance.Endicia\nInsurance.UPIC\nInsurance.NONE\nServices.RegisteredMail\nServices.CertifiedMail\nServices.RestrictedDelivery\nServices.CertificateOfMailing\nServices.ReturnReceipt\nServices.DeliveryConfirmation\nServices.SignatureConfirmation\nServices.COD\nServices.InsuredMail()\n\n\nCustoms Forms\n=============\n\nWhen processing international shipments, you will usually need to specify a\ncustoms form, contents type, and items.  Additionally, if you want to print\nthe customs forms already \"signed\", you can specify a signer and the\ncertification option.\n\nContents Types\n--------------\n\nThe ``ContentsType`` constructor defines the type of contents declared on the\ncustoms form.  There are six predefined constants for the standard contents\ntypes::\n\n    >>> Customs.Sample\n    ContentsType('SAMPLE')\n\n    >>> Customs.Gift\n    ContentsType('GIFT')\n\n    >>> Customs.Documents\n    ContentsType('DOCUMENTS')\n\n    >>> Customs.Other\n    ContentsType('OTHER')\n\n    >>> Customs.Merchandise\n    ContentsType('MERCHANDISE')\n\n    >>> Customs.ReturnedGoods\n    ContentsType('RETURNEDGOODS')\n\n\nCustoms Form Types\n------------------\n\nThe ``CustomsFormType`` constructor defines the type of customs form to be\nused.  There are four predefined constants for the allowed form types::\n\n    >>> Customs.GEM\n    CustomsFormType('GEM')\n\n    >>> Customs.CN22\n    CustomsFormType('CN22')\n\n    >>> Customs.CP72\n    CustomsFormType('CP72')\n\n    >>> Customs.NONE\n    CustomsFormType('NONE')\n\n\nCustoms Items\n-------------\n\nItems to be declared on a customs form are created using ``Customs.Item``.\nThe minimum required arguments are a description, a unit weight in ounces\n(which must be an integer or decimal), and a value in US dollars (also an\ninteger or decimal)::\n\n    >>> from decimal import Decimal\n    >>> i = Customs.Item(\"Paperback book\", 12, Decimal('29.95'))\n\nYou may also optionally specify a quantity (which must be an integer) and a\ncountry of origin.  The defaults for these are ``1`` and ``\"United States\"``,\nrespectively::\n\n    >>> i\n    Item('Paperback book', Decimal(\"12\"), Decimal(\"29.95\"), 1, 'United States')\n\nYou always specify a unit weight and value; these are automatically multiplied\nby the quantity on the customs form, and for purposes of calculating total\nweight/value.\n\nNote that a package's total weight must be greater than or equal to the sum of\nits items' weight, and its value must exactly equal the sum of its items'\nvalues::\n\n    >>> b = Batch()\n    >>> b.add_package(i)\n    Traceback (most recent call last):\n      ...\n    OptionConflict: Total package weight must be specified when Customs.Items\n                    are used\n\n    >>> b.add_package(i, WeightOz(1))\n    Traceback (most recent call last):\n      ...\n    OptionConflict: Total item weight is 12 oz, but\n                    total package weight is only 1 oz\n\n    >>> b.add_package(i, WeightOz(12), Value(69))\n    Traceback (most recent call last):\n      ...\n    OptionConflict: Can't set 'Value=29.95' when 'Value=69' already set\n\nAnd a form type and contents type must be specified if you include any items::\n\n    >>> b.add_package(i, WeightOz(12))\n    Traceback (most recent call last):\n      ...\n    OptionConflict: Customs form + content type must be specified with items\n\n    >>> b.add_package(i, WeightOz(12), Customs.Gift)\n    Traceback (most recent call last):\n      ...\n    OptionConflict: Customs form + content type must be specified with items\n\n    >>> b.add_package(i, WeightOz(12), Customs.CN22)\n    Traceback (most recent call last):\n      ...\n    OptionConflict: Customs form + content type must be specified with items\n\n    >>> b.add_package(i, WeightOz(12), Customs.Gift, Customs.CN22)\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\">\n            <CustomsQuantity1>1</CustomsQuantity1>\n            <CustomsCountry1>United States</CustomsCountry1>\n            <CustomsDescription1>Paperback book</CustomsDescription1>\n            <CustomsWeight1>12</CustomsWeight1>\n            <CustomsValue1>29.95</CustomsValue1>\n            <WeightOz>12</WeightOz>\n            <ContentsType>GIFT</ContentsType>\n            <CustomsFormType>CN22</CustomsFormType>\n            <Value>29.95</Value>\n        </Package>\n    </DAZzle>\n\nThe final customs form will include the multiplied-out weights and values based\non the quantity of each item::\n\n    >>> b = Batch()\n    >>> b.add_package(\n    ...     Customs.Item('x',23,42,3), Customs.Item('y',1,7),\n    ...     WeightOz(99), Customs.Gift, Customs.CN22\n    ... )\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\">\n            <CustomsQuantity1>3</CustomsQuantity1>\n            <CustomsCountry1>United States</CustomsCountry1>\n            <CustomsDescription1>x</CustomsDescription1>\n            <CustomsWeight1>69</CustomsWeight1>\n            <CustomsValue1>126</CustomsValue1>\n            <CustomsQuantity2>1</CustomsQuantity2>\n            <CustomsCountry2>United States</CustomsCountry2>\n            <CustomsDescription2>y</CustomsDescription2>\n            <CustomsWeight2>1</CustomsWeight2>\n            <CustomsValue2>7</CustomsValue2>\n            <WeightOz>99</WeightOz>\n            <ContentsType>GIFT</ContentsType>\n            <CustomsFormType>CN22</CustomsFormType>\n            <Value>133</Value>\n        </Package>\n    </DAZzle>\n\n\nCustoms Signature\n-----------------\n\nYou can specify the person who's certifying the customs form using these\noptions::\n\n    >>> Customs.Signer(\"Phillip Eby\")\n    CustomsSigner('Phillip Eby')\n\n    >>> Customs.Certify\n    CustomsCertify('TRUE')\n\n\n\nProcessing Options\n==================\n\nXXX DAZzle.Test\nDAZzle.Layout(filename)\nDAZzle.OutputFile(filename)\nDAZzle.Print\nDAZzle.Verify\nDAZzle.SkipUnverified\nDAZzle.AutoClose\nDAZzle.Prompt\nDAZzle.AbortOnError\nDAZzle.AutoPrintCustomsForms\nDAZzle.XMLDirectory\nDAZzle.LayoutDirectory\nDAZzle.exe_path\n\n\nMiscellaneous\n=============\n\nXXX RubberStamp(n, text)\nReferenceID(text)\nCostCenter(int)\n\n\n\n-------------------\nInternals and Tests\n-------------------\n\nMisc imports for tests::\n\n    >>> from pydicia import add_to_package, ET, Option, Batch, Package\n\nPackages::\n\n    >>> b = Batch()\n    >>> p = Package(b)\n\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\" />\n    </DAZzle>\n\n    >>> Box = Option('FlatRate', 'BOX')\n    >>> add_to_package(Box, p, False)\n\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\">\n            <FlatRate>BOX</FlatRate>\n        </Package>\n    </DAZzle>\n\n    >>> Envelope = Option('FlatRate', 'TRUE')\n    >>> add_to_package(Envelope, p, False)\n    Traceback (most recent call last):\n      ...\n    OptionConflict: Can't set 'FlatRate=TRUE' when 'FlatRate=BOX' already set\n\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\">\n            <FlatRate>BOX</FlatRate>\n        </Package>\n    </DAZzle>\n\n    >>> add_to_package(Box, p, False)\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\">\n            <FlatRate>BOX</FlatRate>\n        </Package>\n    </DAZzle>\n\n    >>> add_to_package(Envelope, p, True)\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\">\n            <FlatRate>BOX</FlatRate>\n        </Package>\n    </DAZzle>\n\n    >>> del p.element[-1]; p.element.text=''\n    >>> print b.tostring()\n    <DAZzle>\n        <Package ID=\"1\" />\n    </DAZzle>\n\n    >>> verify_zip = Option('DAZzle', 'DAZ', 'Start')\n\n    >>> add_to_package(verify_zip, p, False)\n    >>> print b.tostring()\n    <DAZzle Start=\"DAZ\">\n        <Package ID=\"1\" />\n    </DAZzle>\n\n    >>> add_to_package(Option('DAZzle', 'PRINTING', 'Start'), p, False)\n    Traceback (most recent call last):\n      ...\n    OptionConflict: Can't set 'DAZzle.Start=PRINTING' when 'DAZzle.Start=DAZ' already set\n\n    >>> b = Batch()\n    >>> p = Package(b)\n    >>> add_to_package([verify_zip, Envelope], p, False)\n    >>> print b.tostring()\n    <DAZzle Start=\"DAZ\">\n        <Package ID=\"1\">\n            <FlatRate>TRUE</FlatRate>\n        </Package>\n    </DAZzle>\n\n    >>> p.should_queue(Services.COD)\n    True\n    >>> print b.tostring()\n    <DAZzle Start=\"DAZ\">\n        <Package ID=\"1\">\n            <FlatRate>TRUE</FlatRate>\n        </Package>\n    </DAZzle>\n\n    >>> p.finish()\n    >>> print b.tostring()\n    <DAZzle Start=\"DAZ\">\n        <Package ID=\"1\">\n            <FlatRate>TRUE</FlatRate>\n            <Services COD=\"ON\" />\n        </Package>\n    </DAZzle>\n\n    >>> p.should_queue(Services.COD)\n    False\n\n\nBatch rollback::\n\n    >>> b = Batch()\n    >>> print b.tostring()\n    <DAZzle />\n\n    >>> b.add_package(FlatRateEnvelope, FlatRateBox)\n    Traceback (most recent call last):\n      ...\n    OptionConflict: Can't set 'PackageType=FLATRATEBOX' when\n                               'PackageType=FLATRATEENVELOPE' already set\n\n    >>> print b.tostring()  # rollback on error\n    <DAZzle />\n\n\nMisc shipment and postprocessing::\n\n    >>> s = Shipment(verify_zip)\n    >>> s.add_package(Box)\n    >>> s.add_package(Envelope)\n    >>> root, = s.batches\n    >>> print root.tostring()\n    <DAZzle Start=\"DAZ\">\n        <Package ID=\"1\">\n            <FlatRate>BOX</FlatRate>\n        </Package>\n        <Package ID=\"2\">\n            <FlatRate>TRUE</FlatRate>\n        </Package>\n    </DAZzle>\n\nOption inversion::\n\n    >>> ~Envelope\n    FlatRate('FALSE')\n    >>> ~~Envelope\n    FlatRate('TRUE')\n\n    >>> ~Option('Services', 'ON', 'RegisteredMail')\n    Services.RegisteredMail('OFF')\n    >>> ~~Option('Services', 'ON', 'RegisteredMail')\n    Services.RegisteredMail('ON')\n\n    >>> ~Option('DAZzle', 'YES', 'Prompt')\n    DAZzle.Prompt('NO')\n    >>> ~~Option('DAZzle', 'YES', 'Prompt')\n    DAZzle.Prompt('YES')\n\n\nThe ``iter_options()`` generic function yields \"option\" objects for an\napplication object.  The default implementation is to raise an error::\n\n    >>> from pydicia import iter_options\n\n    >>> iter_options(27)\n    Traceback (most recent call last):\n      ...\n    NotImplementedError: ('No option producer registered for', <type 'int'>)\n\nAnd for lists and tuples, the default is to yield their contents::\n\n    >>> list(iter_options((1, 2, 3)))\n    [1, 2, 3]\n\n    >>> list(iter_options(['a', 'b']))\n    ['a', 'b']\n\nThis routine is used internally by ``add_to_package()``.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://cheeseshop.python.org/pypi/PyDicia", "keywords": null, "license": "PSF or ZPL", "maintainer": null, "maintainer_email": null, "name": "PyDicia", "package_url": "https://pypi.org/project/PyDicia/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/PyDicia/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://cheeseshop.python.org/pypi/PyDicia"}, "release_url": "https://pypi.org/project/PyDicia/0.1a3/", "requires_dist": null, "requires_python": null, "summary": "Print labels, envelopes, US postage, and more using the endicia.com API", "version": "0.1a3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <dl>\n<dt>New in 0.1a3</dt>\n<dd><ul>\n<li>Added <tt>FlatRateLargeBox</tt> and <tt>ExpressMailPremiumService</tt> tags, for use\nwith DAZzle 8.0 and up.</li>\n</ul>\n</dd>\n<dt>New in 0.1a2</dt>\n<dd><ul>\n<li>Dropped MS Windows requirement; you can now use PyDicia to generate XML for\nthe Endicia Mac client, or to be sent via download or networked directory\nto a Windows client.</li>\n<li>Added a <tt>Shipment.run()</tt> method to allow running multiple batches in\nsequence.</li>\n<li>Fixed the <tt>Status.ToZip4</tt> attribute (it was incorrectly spelled\n<tt>ToZIP4</tt>, and thus didn\u2019t work).</li>\n</ul>\n</dd>\n</dl>\n<p>PyDicia is a Python interface to endicia.com\u2019s postal services client, DAZzle.\nUsing DAZzle\u2019s XML interface, PyDicia can be used to print shipping labels,\nenvelopes, postcards and more, with or without prepaid US postage indicia\n(electronic stamps), as well as doing address verification.</p>\n<p>In addition to providing a layer of syntax sugar for the DAZzle XML interface,\nPyDicia provides a novel adaptive interface that lets you smoothly integrate\nits functions with your application\u2019s core types (like invoice, customer, or\n\u201cpacking slip\u201d objects) without subclassing.  (This is particularly useful if\nyou are extending a CRM or other database that was written by somebody else.)</p>\n<p>This version of PyDicia is an alpha proof-of-concept release.  It is actually\nusable \u2013 I\u2019ve in fact been using it in production for over a year, shipping\ndozens of envelopes and packages a month all over the US, Canada, and Europe.\nHowever, the API is still potentially subject to change, the reference\ndocumentation is sketchy, and the developer\u2019s guide lacks detail about some of\nthe more advanced features.  This should improve in future releases, but at\nleast this way, you can use it now, if you need something like it.  Reading the\n<a href=\"http://fileserver.surveygizmo.com/users/4508/dazzleXMLInterfaceV8.pdf\" rel=\"nofollow\">DAZzle XML API specification</a> is a good idea if you want to use this, though;\nthe 8.0 version is the latest, although PyDicia also supports 7.0.x versions.</p>\n<p>PyDicia uses the ElementTree, simplegeneric, and DecoratorTools packages, and\nrequires Python 2.4 or higher (due to use of decorators and the <tt>Decimal</tt>\ntype).  Actually printing any labels requires that you have an Endicia\n\u201cPremium\u201d or \u201cMac\u201d account.  (Note: I have not used the Mac client, so I don\u2019t\nknow how well it works there.  See the section below on <a href=\"#using-pydicia-on-non-windows-platforms\" rel=\"nofollow\">Using PyDicia on\nNon-Windows Platforms</a> for more info.)</p>\n<dl>\n<dt>IMPORTANT</dt>\n<dd><p>Please note that PyDicia does not attempt to implement all of the US Postal\nService\u2019s business rules for what options may be used in what combinations.\nIt doesn\u2019t even validate most of the DAZzle client\u2019s documented\nrestrictions!  So it\u2019s strictly a \u201cGarbage In, Garbage Out\u201d kind of deal.\nIf you put garbage in, who knows what the heck will happen.  You might end\nup spending lots of money <em>and</em> getting your packages returned to you \u2013\nand <strong>I AM NOT RESPONSIBLE</strong>, even if your problem is due to an error in\nPyDicia or its documentation!</p>\n<p>So, make sure you understand the shipping options you wish to use, and test\nyour application thoroughly before using this code in production.  You have\nbeen warned!</p>\n</dd>\n</dl>\n<p>Questions, discussion, and bug reports for this software should be directed to\nthe PEAK mailing list; see <a href=\"http://www.eby-sarna.com/mailman/listinfo/PEAK/\" rel=\"nofollow\">http://www.eby-sarna.com/mailman/listinfo/PEAK/</a>\nfor details.</p>\n<div id=\"table-of-contents\">\n<p><strong>Table of Contents</strong></p>\n<ul>\n<li><a href=\"#developer-s-guide\" id=\"id1\" rel=\"nofollow\">Developer\u2019s Guide</a><ul>\n<li><a href=\"#basic-xml-generation\" id=\"id2\" rel=\"nofollow\">Basic XML Generation</a><ul>\n<li><a href=\"#batch-objects\" id=\"id3\" rel=\"nofollow\">Batch Objects</a></li>\n<li><a href=\"#using-your-application-objects-as-package-sources\" id=\"id4\" rel=\"nofollow\">Using Your Application Objects as Package Sources</a></li>\n<li><a href=\"#batch-wide-options\" id=\"id5\" rel=\"nofollow\">Batch-wide Options</a></li>\n</ul>\n</li>\n<li><a href=\"#multi-batch-shipments\" id=\"id6\" rel=\"nofollow\">Multi-Batch Shipments</a></li>\n<li><a href=\"#receiving-status-updates\" id=\"id7\" rel=\"nofollow\">Receiving Status Updates</a></li>\n<li><a href=\"#invoking-dazzle\" id=\"id8\" rel=\"nofollow\">Invoking DAZzle</a></li>\n<li><a href=\"#using-pydicia-on-non-windows-platforms\" id=\"id9\" rel=\"nofollow\">Using PyDicia on Non-Windows Platforms</a></li>\n<li><a href=\"#advanced-customization\" id=\"id10\" rel=\"nofollow\">Advanced Customization</a></li>\n</ul>\n</li>\n<li><a href=\"#options-reference\" id=\"id11\" rel=\"nofollow\">Options Reference</a><ul>\n<li><a href=\"#basic-package-options\" id=\"id12\" rel=\"nofollow\">Basic Package Options</a></li>\n<li><a href=\"#addresses\" id=\"id13\" rel=\"nofollow\">Addresses</a></li>\n<li><a href=\"#package-details\" id=\"id14\" rel=\"nofollow\">Package Details</a></li>\n<li><a href=\"#service-options\" id=\"id15\" rel=\"nofollow\">Service Options</a></li>\n<li><a href=\"#customs-forms\" id=\"id16\" rel=\"nofollow\">Customs Forms</a><ul>\n<li><a href=\"#contents-types\" id=\"id17\" rel=\"nofollow\">Contents Types</a></li>\n<li><a href=\"#customs-form-types\" id=\"id18\" rel=\"nofollow\">Customs Form Types</a></li>\n<li><a href=\"#customs-items\" id=\"id19\" rel=\"nofollow\">Customs Items</a></li>\n<li><a href=\"#customs-signature\" id=\"id20\" rel=\"nofollow\">Customs Signature</a></li>\n</ul>\n</li>\n<li><a href=\"#processing-options\" id=\"id21\" rel=\"nofollow\">Processing Options</a></li>\n<li><a href=\"#miscellaneous\" id=\"id22\" rel=\"nofollow\">Miscellaneous</a></li>\n</ul>\n</li>\n<li><a href=\"#internals-and-tests\" id=\"id23\" rel=\"nofollow\">Internals and Tests</a></li>\n</ul>\n</div>\n<div id=\"developer-s-guide\">\n<h2><a href=\"#id1\" rel=\"nofollow\">Developer\u2019s Guide</a></h2>\n<div id=\"basic-xml-generation\">\n<h3><a href=\"#id2\" rel=\"nofollow\">Basic XML Generation</a></h3>\n<p>PyDicia simplifies the creation of XML for DAZzle by using objects to specify\nwhat data needs to go in the XML.  These objects are mostly <tt>Option</tt>\ninstances, or callables that create <tt>Option</tt> instances.  However, the\nframework is extensible, so that you can use your own object types with the\nsame API.  Your object types can either generate <tt>Option</tt> instances, or\ndirectly manipulate the XML using ElementTree APIs for maximum control.</p>\n<p>In the simpler cases, however, you will just use lists or tuples of objects\nprovided by (or created with) the PyDicia API to represent packages or labels.</p>\n<div id=\"batch-objects\">\n<h4><a href=\"#id3\" rel=\"nofollow\">Batch Objects</a></h4>\n<p>XML documents are represented using <tt>Batch</tt> objects:</p>\n<pre>&gt;&gt;&gt; from pydicia import *\n&gt;&gt;&gt; b = Batch()\n</pre>\n<p>The <tt>tostring()</tt> method of a batch returns its XML in string form, optionally\nin a given encoding (defaulting to ASCII if not specified):</p>\n<pre>&gt;&gt;&gt; print b.tostring('latin1')\n&lt;?xml version='1.0' encoding='latin1'?&gt;\n&lt;DAZzle /&gt;\n</pre>\n<p>To add a package to a batch, you use the <tt>add_package()</tt> method:</p>\n<pre>&gt;&gt;&gt; b.add_package(ToName('Phillip Eby'))\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\"&gt;\n         &lt;ToName&gt;Phillip Eby&lt;/ToName&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n<p>The <tt>add_package()</tt> method accepts zero or more objects that can manipulate\nPyDicia package objects.  It also accepts tuples or lists of such objects,\nnested to arbitrary depth:</p>\n<pre>&gt;&gt;&gt; b.add_package([Services.COD, (Stealth, ToName('Ty Sarna'))], FlatRateBox)\n\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;ToName&gt;Phillip Eby&lt;/ToName&gt;\n    &lt;/Package&gt;\n    &lt;Package ID=\"2\"&gt;\n        &lt;Services COD=\"ON\" /&gt;\n        &lt;Stealth&gt;TRUE&lt;/Stealth&gt;\n        &lt;ToName&gt;Ty Sarna&lt;/ToName&gt;\n        &lt;PackageType&gt;FLATRATEBOX&lt;/PackageType&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n<p>And the <tt>packages</tt> attribute of a batch keeps track of the arguments that\nhave been passed to <tt>add_package()</tt>:</p>\n<pre>&gt;&gt;&gt; b.packages\n[Package(ToName('Phillip Eby'),),\n Package([Services.COD('ON'), (Stealth('TRUE'), ToName('Ty Sarna'))],\n  PackageType('FLATRATEBOX'))]\n</pre>\n<p>Each package object in the list wraps a tuple of the arguments that were\nsupplied for each invocation of <tt>add_package()</tt>.  This allows the system\nto send status updates (including delivery confirmation numbers, customs IDs,\netc.) back to the application.</p>\n<p>But before we can process status updates, we need to have some application\nobjects, as described in the next section.</p>\n</div>\n<div id=\"using-your-application-objects-as-package-sources\">\n<h4><a href=\"#id4\" rel=\"nofollow\">Using Your Application Objects as Package Sources</a></h4>\n<p>In addition to PyDicia-defined objects and sequences thereof, the\n<tt>add_package()</tt> method also accepts any custom objects of your own design\nthat have been registered with the <tt>pydicia.add_to_package()</tt> or\n<tt>pydicia.iter_options()</tt> generic functions:</p>\n<pre>&gt;&gt;&gt; class Customer:\n...     def __init__(self, **kw):\n...         self.__dict__ = kw\n\n&gt;&gt;&gt; @iter_options.when_type(Customer)\n... def cust_options(ob):\n...     yield ToName(ob.name)\n...     yield ToAddress(ob.address)\n...     yield ToCity(ob.city)\n...     yield ToState(ob.state)\n...     yield ToPostalCode(ob.zip)\n\n&gt;&gt;&gt; b = Batch()\n&gt;&gt;&gt; c = Customer(\n...     name='PJE', address='123 Nowhere Dr', state='FL', city='Nowhere',\n...     zip='12345-6789'\n... )\n&gt;&gt;&gt; b.add_package(c)\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;ToName&gt;PJE&lt;/ToName&gt;\n        &lt;ToAddress1&gt;123 Nowhere Dr&lt;/ToAddress1&gt;\n        &lt;ToCity&gt;Nowhere&lt;/ToCity&gt;\n        &lt;ToState&gt;FL&lt;/ToState&gt;\n        &lt;ToPostalCode&gt;12345-6789&lt;/ToPostalCode&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n<p>This allows you to pass customer, package, product, invoice, or other\napplication-specific objects into <tt>add_package()</tt>.  And the objects yielded\nby your <tt>iter_options</tt> implementation can also be application objects, e.g.:</p>\n<pre>&gt;&gt;&gt; class Invoice:\n...     def __init__(self, **kw):\n...         self.__dict__ = kw\n\n&gt;&gt;&gt; @iter_options.when_type(Invoice)\n... def invoice_options(ob):\n...     yield ob.shippingtype\n...     yield ob.products\n...     yield ob.customer\n\n&gt;&gt;&gt; b = Batch()\n&gt;&gt;&gt; i = Invoice(\n...     shippingtype=(Tomorrow, MailClass('MEDIAMAIL')),\n...     products=[WeightOz(27),], customer=c\n... )\n&gt;&gt;&gt; b.add_package(i)\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;DateAdvance&gt;1&lt;/DateAdvance&gt;\n        &lt;MailClass&gt;MEDIAMAIL&lt;/MailClass&gt;\n        &lt;WeightOz&gt;27&lt;/WeightOz&gt;\n        &lt;ToName&gt;PJE&lt;/ToName&gt;\n        &lt;ToAddress1&gt;123 Nowhere Dr&lt;/ToAddress1&gt;\n        &lt;ToCity&gt;Nowhere&lt;/ToCity&gt;\n        &lt;ToState&gt;FL&lt;/ToState&gt;\n        &lt;ToPostalCode&gt;12345-6789&lt;/ToPostalCode&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n<p>Note that there is no particular significance to my choice of lists vs. tuples\nin these examples; they\u2019re more to demonstrate that you can use arbitrary\nstructures, as long as they contain objects that are supported by either\n<tt>iter_options()</tt> or <tt>add_to_package()</tt>.  Normally, you will simply use\ncollections of either PyDicia-provided symbols, or application objects for\nwhich you\u2019ve defined an <tt>iter_options()</tt> method.</p>\n<p>You will also usually want to implement your PyDicia support in a module by\nitself, so you can use <tt>from pydicia import *</tt> without worrying about symbol\ncollisions.</p>\n</div>\n<div id=\"batch-wide-options\">\n<h4><a href=\"#id5\" rel=\"nofollow\">Batch-wide Options</a></h4>\n<p>When you create a batch, you can pass in any number of objects, to specify\noptions that will be applied to every package.  For example, this batch will\nhave every package set to be mailed tomorrow as media mail:</p>\n<pre>&gt;&gt;&gt; b = Batch( Tomorrow, MailClass('MEDIAMAIL') )\n&gt;&gt;&gt; b.add_package(ToName('PJE'))\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;ToName&gt;PJE&lt;/ToName&gt;\n        &lt;DateAdvance&gt;1&lt;/DateAdvance&gt;\n        &lt;MailClass&gt;MEDIAMAIL&lt;/MailClass&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n</div>\n</div>\n<div id=\"multi-batch-shipments\">\n<h3><a href=\"#id6\" rel=\"nofollow\">Multi-Batch Shipments</a></h3>\n<p>Certain DAZzle options can only be set once per XML file, such as the choice of\nlayout file.  If you are shipping multiple packages with different label\nlayouts (such as domestic vs. international mail), you need to separate these\npackages into different batches, each of which will be in a separate XML file.\nThe <tt>Shipment</tt> class handles this separation for you automatically.</p>\n<p>When you create a shipment, it initially has no batches:</p>\n<pre>&gt;&gt;&gt; s = Shipment()\n&gt;&gt;&gt; s.batches\n[]\n</pre>\n<p>But as you add packages to it, it will create batches as needed:</p>\n<pre>&gt;&gt;&gt; s.add_package(ToName('Phillip Eby'), DAZzle.Test)\n&gt;&gt;&gt; len(s.batches)\n1\n\n&gt;&gt;&gt; print s.batches[0].tostring()\n&lt;DAZzle Test=\"YES\"&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;ToName&gt;Phillip Eby&lt;/ToName&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n<p>As long as you\u2019re adding packages with the same or compatible options, the\nsame batch will be reused:</p>\n<pre>&gt;&gt;&gt; s.add_package(ToName('Ty Sarna'), DAZzle.Test)\n&gt;&gt;&gt; len(s.batches)\n1\n&gt;&gt;&gt; print s.batches[0].tostring()\n&lt;DAZzle Test=\"YES\"&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;ToName&gt;Phillip Eby&lt;/ToName&gt;\n    &lt;/Package&gt;\n    &lt;Package ID=\"2\"&gt;\n        &lt;ToName&gt;Ty Sarna&lt;/ToName&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n<p>But as soon as you add a package with any incompatible options, a new batch\nwill be created and used:</p>\n<pre>&gt;&gt;&gt; s.add_package(ToName('PJE'), ~DAZzle.Test)\n&gt;&gt;&gt; len(s.batches)\n2\n\n&gt;&gt;&gt; print s.batches[1].tostring()\n&lt;DAZzle Test=\"NO\"&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;ToName&gt;PJE&lt;/ToName&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n<p>And each time you add a package, it\u2019s added to the first compatible batch:</p>\n<pre>&gt;&gt;&gt; s.add_package(ToName('Some Body'), ~DAZzle.Test)\n&gt;&gt;&gt; len(s.batches)\n2\n\n&gt;&gt;&gt; print s.batches[1].tostring()\n&lt;DAZzle Test=\"NO\"&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;ToName&gt;PJE&lt;/ToName&gt;\n    &lt;/Package&gt;\n    &lt;Package ID=\"2\"&gt;\n        &lt;ToName&gt;Some Body&lt;/ToName&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n\n&gt;&gt;&gt; s.add_package(ToName('No Body'), DAZzle.Test)\n&gt;&gt;&gt; len(s.batches)\n2\n\n&gt;&gt;&gt; print s.batches[0].tostring()\n&lt;DAZzle Test=\"YES\"&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;ToName&gt;Phillip Eby&lt;/ToName&gt;\n    &lt;/Package&gt;\n    &lt;Package ID=\"2\"&gt;\n        &lt;ToName&gt;Ty Sarna&lt;/ToName&gt;\n    &lt;/Package&gt;\n    &lt;Package ID=\"3\"&gt;\n        &lt;ToName&gt;No Body&lt;/ToName&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n<p>By the way, as with batches, you can create a shipment with options that will\nbe applied to all packages:</p>\n<pre>&gt;&gt;&gt; s = Shipment(Tomorrow, Services.COD)\n&gt;&gt;&gt; s.add_package(ToName('Some Body'), DAZzle.Test)\n&gt;&gt;&gt; s.add_package(ToName('No Body'), ~DAZzle.Test)\n&gt;&gt;&gt; len(s.batches)\n2\n&gt;&gt;&gt; print s.batches[0].tostring()\n&lt;DAZzle Test=\"YES\"&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;ToName&gt;Some Body&lt;/ToName&gt;\n        &lt;DateAdvance&gt;1&lt;/DateAdvance&gt;\n        &lt;Services COD=\"ON\" /&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n\n&gt;&gt;&gt; print s.batches[1].tostring()\n&lt;DAZzle Test=\"NO\"&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;ToName&gt;No Body&lt;/ToName&gt;\n        &lt;DateAdvance&gt;1&lt;/DateAdvance&gt;\n        &lt;Services COD=\"ON\" /&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n</div>\n<div id=\"receiving-status-updates\">\n<h3><a href=\"#id7\" rel=\"nofollow\">Receiving Status Updates</a></h3>\n<p>When DAZzle completes a batch, it creates an output file containing status\ninformation for each package in the batch.  If you\u2019d like to process this\nstatus information for the corresponding application objects you passed in\nto <tt>add_package()</tt>, you can extend the <tt>report_status()</tt> generic function\nto do this:</p>\n<pre>&gt;&gt;&gt; @report_status.when_type(Customer)\n... def customer_status(ob, status):\n...     print ob\n...     print status\n\n&gt;&gt;&gt; b = Batch()\n&gt;&gt;&gt; b.add_package(c)\n</pre>\n<p>When the batch receives status information, it will invoke <tt>report_status()</tt>\non each package\u2019s application items, with a status object for the corresponding\npackage:</p>\n<pre>&gt;&gt;&gt; b.report_statuses()\n&lt;...Customer instance...&gt;\nToAddress           : [u'123 Nowhere Dr']\nToCity              : u'Nowhere'\nToState             : u'FL'\nToPostalCode        : u'12345-6789'\nToAddress1          : u'123 Nowhere Dr'\n</pre>\n<p>Note that you don\u2019t normally need to call <tt>report_statuses()</tt> directly; it\u2019s\nusually done for you as part of the process of running a batch or shipment.\n(See the section below on <a href=\"#invoking-dazzle\" rel=\"nofollow\">Invoking DAZzle</a>.)</p>\n<p>The <cite>status</cite> object passed to your method will be a <tt>Status</tt> instance with\nattributes similar to those above, containing USPS-normalized address data.\nIn addition, several other fields are possible:</p>\n<pre>&gt;&gt;&gt; from pydicia import ET\n&gt;&gt;&gt; b.etree = ET.fromstring('''\n... &lt;DAZzle&gt;&lt;Package ID=\"1\"&gt;\n...     &lt;ToZip4&gt;1234&lt;/ToZip4&gt;\n...     &lt;Status&gt;Rejected (-3)&lt;/Status&gt;\n...     &lt;PIC&gt;123465874359&lt;/PIC&gt;\n...     &lt;FinalPostage&gt;4.60&lt;/FinalPostage&gt;\n...     &lt;TransactionDateTime&gt;20070704173221&lt;/TransactionDateTime&gt;\n...     &lt;PostmarkDate&gt;20070705&lt;/PostmarkDate&gt;\n... &lt;/Package&gt;&lt;/DAZzle&gt;''')\n\n&gt;&gt;&gt; b.report_statuses()\n&lt;...Customer instance...&gt;\nStatus              : 'Rejected (-3)'\nErrorCode           : -3\nToAddress           : []\nToZip4              : '1234'\nPIC                 : '123465874359'\nFinalPostage        : Decimal(\"4.60\")\nTransactionDateTime : datetime.datetime(2007, 7, 4, 17, 32, 21)\nPostmarkDate        : datetime.date(2007, 7, 5)\n</pre>\n<p>The <tt>Status</tt> object should support all output fields supported by DAZzle; see\nthe DAZzle documentation for details.  The non-string fields shown above are\nthe only ones which are postprocessed to specialized Python objects; the rest\nare kept as strings or Unicode values.  The <tt>ErrorCode</tt> field is computed by\nextracting the integer portion of any rejection code.  It is <tt>None</tt> in the\ncase of a successful live print, and <tt>0</tt> in the case of a successful test\nprint.  See the DAZzle XML interface documentation for a description of other\nerror codes.</p>\n<p>Note that for a more compact presentation, attributes with <tt>None</tt> values are\nnot included in the <tt>str()</tt> of a <tt>Status</tt> object, which is why the statuses\ndisplayed above show different sets of fields.  The attributes, however, always\nexist; they simply have <tt>None</tt> as their value.</p>\n</div>\n<div id=\"invoking-dazzle\">\n<h3><a href=\"#id8\" rel=\"nofollow\">Invoking DAZzle</a></h3>\n<p>In the simplest case, invoking a batch or shipment object\u2019s <tt>.run()</tt> method\nwill launch a local copy of DAZzle on a temporary file containing the batch\u2019s\nXML, wait for DAZzle to exit, then process status updates from the output file\nand return DAZzle\u2019s return code.  (Or a list of return codes, in the case of a\n<tt>Shipment</tt>.)</p>\n<p>If you are using this approach, you may wish to include <tt>~DAZzle.Prompt</tt>\n(which keeps end-user prompts to a minimum) and <tt>DAZzle.AutoClose</tt> (so that\nDAZzle exits upon completion of the batch) in your batch options.</p>\n<p>If you do not have a local copy of DAZzle, but instead are using a network\nqueue directory to send jobs remotely, you can instead use the batch object\u2019s\n<tt>.write(queuedir)</tt> method to send the batch to the queue.  You can also\nuse this approach to send jobs to a local copy of DAZzle running in the\nbackground.</p>\n<p>If a copy of DAZzle is installed locally, you can get its XML queue directory\nfrom <tt>DAZzle.XMLDirectory</tt>, and check whether it is monitoring for files\nusing <tt><span class=\"pre\">DAZzle.get_preference(\"MonitorXML\")</span></tt>.  (These values will be <tt>None</tt>\nif DAZzle is not installed.)</p>\n<p>If DAZzle is installed locally, you can launch it with the\n<tt><span class=\"pre\">DAZzle.run(args=(),</span> sync=True)</tt> function.  The <cite>args</cite> are a list of command\nline arguments to pass, and <cite>sync</cite> is a flag indicating whether to wait for\nDAZzle to exit.  If <cite>sync</cite> is a false value, <tt>run()</tt> returns a\n<tt>subprocess.Popen</tt> instance.  Otherwise, it returns the process\u2019s exit code\n(ala <tt>subprocess.call</tt>).</p>\n<p>XXX async batch status retrieval</p>\n<p>XXX DAZzle.exe_path, DAZzle.get_preference(), DAZzle.LayoutDirectory</p>\n<p>XXX Launching for multi-batch, remote, queued, and other async processing</p>\n</div>\n<div id=\"using-pydicia-on-non-windows-platforms\">\n<h3><a href=\"#id9\" rel=\"nofollow\">Using PyDicia on Non-Windows Platforms</a></h3>\n<p>When used on a non-Windows platform, PyDicia cannot detect any DAZzle\nconfiguration information, so you must manually set <tt>DAZzle.exe_path</tt> to\nthe client program, if you wish to use any of the <tt>run()</tt> methods.\n(Likewise, you must manually set <tt>DAZzle.LayoutDirectory</tt> if you want layout\npaths to be automatically adjusted.)</p>\n<p>On the Mac, the <tt>exe_path</tt> should be set to a program that takes a single\nXML filename as an argument.  The Mac <tt>endiciatool</tt> program probably will\nnot work on its own, without a wrapper shell script of some kind; I\u2019m open to\nsuggestions as to how to improve this.  (Note, by the way, that the Mac client\ndoesn\u2019t support all of the options that the Windows client does, so remember\nthat use of PyDicia is entirely at your own risk, whatever the platform!)</p>\n<p>On other platforms, the main usefulness of PyDicia would be in generating XML\nfor users to download (e.g. from a web application) or submitting and\nprocessing jobs via a Samba-mounted queue directory.  You don\u2019t need an\n<tt>exe_path</tt> for this, but you will need to generate your own layout and output\nfile paths using <tt>Option</tt> objects, to avoid them being mangled by PyDicia\u2019s\nplatform-specific path munging.</p>\n<p>XXX explain how to do that, or make it work anyway</p>\n</div>\n<div id=\"advanced-customization\">\n<h3><a href=\"#id10\" rel=\"nofollow\">Advanced Customization</a></h3>\n<p>XXX Using Option elements, add_to_package()</p>\n</div>\n</div>\n<div id=\"options-reference\">\n<h2><a href=\"#id11\" rel=\"nofollow\">Options Reference</a></h2>\n<div id=\"basic-package-options\">\n<h3><a href=\"#id12\" rel=\"nofollow\">Basic Package Options</a></h3>\n<p>XXX MailClass(text), NoPostage\nDateAdvance(), Today, Tomorrow\nValue()\nDescription()\nWeightOz()</p>\n</div>\n<div id=\"addresses\">\n<h3><a href=\"#id13\" rel=\"nofollow\">Addresses</a></h3>\n<dl>\n<dt>::</dt>\n<dd><pre>&gt;&gt;&gt; ToName(\"Phillip J. Eby\")\nToName('Phillip J. Eby')\n</pre>\n<pre>&gt;&gt;&gt; ToTitle(\"President\")\nToTitle('President')\n</pre>\n<pre>&gt;&gt;&gt; ToCompany(\"Dirt Simple, Inc.\")\nToCompany('Dirt Simple, Inc.')\n</pre>\n</dd>\n</dl>\n<p>XXX ToAddress(*lines)\nToCity(text), ToState(text), ToPostalCode(text), ToZIP4(text), ToCountry(text)</p>\n<p>XXX ReturnAddress(*lines)\nToDeliveryPoint(text)\nEndorsementLine(text)\nToCarrierRoute(text)</p>\n</div>\n<div id=\"package-details\">\n<h3><a href=\"#id14\" rel=\"nofollow\">Package Details</a></h3>\n<p>XXX PackageType()\nFlatRateEnvelope\nFlatRateBox\nRectangularParcel\nNonRectangularParcel\nPostcard\nFlat\nEnvelope\nWidth(), Length(), Depth()\nNonMachinable\nBalloonRate</p>\n</div>\n<div id=\"service-options\">\n<h3><a href=\"#id15\" rel=\"nofollow\">Service Options</a></h3>\n<p>XXX ReplyPostage\nStealth\nSignatureWaiver\nNoWeekendDelivery\nNoHolidayDelivery\nReturnToSender\nInsurance.USPS\nInsurance.Endicia\nInsurance.UPIC\nInsurance.NONE\nServices.RegisteredMail\nServices.CertifiedMail\nServices.RestrictedDelivery\nServices.CertificateOfMailing\nServices.ReturnReceipt\nServices.DeliveryConfirmation\nServices.SignatureConfirmation\nServices.COD\nServices.InsuredMail()</p>\n</div>\n<div id=\"customs-forms\">\n<h3><a href=\"#id16\" rel=\"nofollow\">Customs Forms</a></h3>\n<p>When processing international shipments, you will usually need to specify a\ncustoms form, contents type, and items.  Additionally, if you want to print\nthe customs forms already \u201csigned\u201d, you can specify a signer and the\ncertification option.</p>\n<div id=\"contents-types\">\n<h4><a href=\"#id17\" rel=\"nofollow\">Contents Types</a></h4>\n<p>The <tt>ContentsType</tt> constructor defines the type of contents declared on the\ncustoms form.  There are six predefined constants for the standard contents\ntypes:</p>\n<pre>&gt;&gt;&gt; Customs.Sample\nContentsType('SAMPLE')\n\n&gt;&gt;&gt; Customs.Gift\nContentsType('GIFT')\n\n&gt;&gt;&gt; Customs.Documents\nContentsType('DOCUMENTS')\n\n&gt;&gt;&gt; Customs.Other\nContentsType('OTHER')\n\n&gt;&gt;&gt; Customs.Merchandise\nContentsType('MERCHANDISE')\n\n&gt;&gt;&gt; Customs.ReturnedGoods\nContentsType('RETURNEDGOODS')\n</pre>\n</div>\n<div id=\"customs-form-types\">\n<h4><a href=\"#id18\" rel=\"nofollow\">Customs Form Types</a></h4>\n<p>The <tt>CustomsFormType</tt> constructor defines the type of customs form to be\nused.  There are four predefined constants for the allowed form types:</p>\n<pre>&gt;&gt;&gt; Customs.GEM\nCustomsFormType('GEM')\n\n&gt;&gt;&gt; Customs.CN22\nCustomsFormType('CN22')\n\n&gt;&gt;&gt; Customs.CP72\nCustomsFormType('CP72')\n\n&gt;&gt;&gt; Customs.NONE\nCustomsFormType('NONE')\n</pre>\n</div>\n<div id=\"customs-items\">\n<h4><a href=\"#id19\" rel=\"nofollow\">Customs Items</a></h4>\n<p>Items to be declared on a customs form are created using <tt>Customs.Item</tt>.\nThe minimum required arguments are a description, a unit weight in ounces\n(which must be an integer or decimal), and a value in US dollars (also an\ninteger or decimal):</p>\n<pre>&gt;&gt;&gt; from decimal import Decimal\n&gt;&gt;&gt; i = Customs.Item(\"Paperback book\", 12, Decimal('29.95'))\n</pre>\n<p>You may also optionally specify a quantity (which must be an integer) and a\ncountry of origin.  The defaults for these are <tt>1</tt> and <tt>\"United States\"</tt>,\nrespectively:</p>\n<pre>&gt;&gt;&gt; i\nItem('Paperback book', Decimal(\"12\"), Decimal(\"29.95\"), 1, 'United States')\n</pre>\n<p>You always specify a unit weight and value; these are automatically multiplied\nby the quantity on the customs form, and for purposes of calculating total\nweight/value.</p>\n<p>Note that a package\u2019s total weight must be greater than or equal to the sum of\nits items\u2019 weight, and its value must exactly equal the sum of its items\u2019\nvalues:</p>\n<pre>&gt;&gt;&gt; b = Batch()\n&gt;&gt;&gt; b.add_package(i)\nTraceback (most recent call last):\n  ...\nOptionConflict: Total package weight must be specified when Customs.Items\n                are used\n\n&gt;&gt;&gt; b.add_package(i, WeightOz(1))\nTraceback (most recent call last):\n  ...\nOptionConflict: Total item weight is 12 oz, but\n                total package weight is only 1 oz\n\n&gt;&gt;&gt; b.add_package(i, WeightOz(12), Value(69))\nTraceback (most recent call last):\n  ...\nOptionConflict: Can't set 'Value=29.95' when 'Value=69' already set\n</pre>\n<p>And a form type and contents type must be specified if you include any items:</p>\n<pre>&gt;&gt;&gt; b.add_package(i, WeightOz(12))\nTraceback (most recent call last):\n  ...\nOptionConflict: Customs form + content type must be specified with items\n\n&gt;&gt;&gt; b.add_package(i, WeightOz(12), Customs.Gift)\nTraceback (most recent call last):\n  ...\nOptionConflict: Customs form + content type must be specified with items\n\n&gt;&gt;&gt; b.add_package(i, WeightOz(12), Customs.CN22)\nTraceback (most recent call last):\n  ...\nOptionConflict: Customs form + content type must be specified with items\n\n&gt;&gt;&gt; b.add_package(i, WeightOz(12), Customs.Gift, Customs.CN22)\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;CustomsQuantity1&gt;1&lt;/CustomsQuantity1&gt;\n        &lt;CustomsCountry1&gt;United States&lt;/CustomsCountry1&gt;\n        &lt;CustomsDescription1&gt;Paperback book&lt;/CustomsDescription1&gt;\n        &lt;CustomsWeight1&gt;12&lt;/CustomsWeight1&gt;\n        &lt;CustomsValue1&gt;29.95&lt;/CustomsValue1&gt;\n        &lt;WeightOz&gt;12&lt;/WeightOz&gt;\n        &lt;ContentsType&gt;GIFT&lt;/ContentsType&gt;\n        &lt;CustomsFormType&gt;CN22&lt;/CustomsFormType&gt;\n        &lt;Value&gt;29.95&lt;/Value&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n<p>The final customs form will include the multiplied-out weights and values based\non the quantity of each item:</p>\n<pre>&gt;&gt;&gt; b = Batch()\n&gt;&gt;&gt; b.add_package(\n...     Customs.Item('x',23,42,3), Customs.Item('y',1,7),\n...     WeightOz(99), Customs.Gift, Customs.CN22\n... )\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;CustomsQuantity1&gt;3&lt;/CustomsQuantity1&gt;\n        &lt;CustomsCountry1&gt;United States&lt;/CustomsCountry1&gt;\n        &lt;CustomsDescription1&gt;x&lt;/CustomsDescription1&gt;\n        &lt;CustomsWeight1&gt;69&lt;/CustomsWeight1&gt;\n        &lt;CustomsValue1&gt;126&lt;/CustomsValue1&gt;\n        &lt;CustomsQuantity2&gt;1&lt;/CustomsQuantity2&gt;\n        &lt;CustomsCountry2&gt;United States&lt;/CustomsCountry2&gt;\n        &lt;CustomsDescription2&gt;y&lt;/CustomsDescription2&gt;\n        &lt;CustomsWeight2&gt;1&lt;/CustomsWeight2&gt;\n        &lt;CustomsValue2&gt;7&lt;/CustomsValue2&gt;\n        &lt;WeightOz&gt;99&lt;/WeightOz&gt;\n        &lt;ContentsType&gt;GIFT&lt;/ContentsType&gt;\n        &lt;CustomsFormType&gt;CN22&lt;/CustomsFormType&gt;\n        &lt;Value&gt;133&lt;/Value&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n</div>\n<div id=\"customs-signature\">\n<h4><a href=\"#id20\" rel=\"nofollow\">Customs Signature</a></h4>\n<p>You can specify the person who\u2019s certifying the customs form using these\noptions:</p>\n<pre>&gt;&gt;&gt; Customs.Signer(\"Phillip Eby\")\nCustomsSigner('Phillip Eby')\n\n&gt;&gt;&gt; Customs.Certify\nCustomsCertify('TRUE')\n</pre>\n</div>\n</div>\n<div id=\"processing-options\">\n<h3><a href=\"#id21\" rel=\"nofollow\">Processing Options</a></h3>\n<p>XXX DAZzle.Test\nDAZzle.Layout(filename)\nDAZzle.OutputFile(filename)\nDAZzle.Print\nDAZzle.Verify\nDAZzle.SkipUnverified\nDAZzle.AutoClose\nDAZzle.Prompt\nDAZzle.AbortOnError\nDAZzle.AutoPrintCustomsForms\nDAZzle.XMLDirectory\nDAZzle.LayoutDirectory\nDAZzle.exe_path</p>\n</div>\n<div id=\"miscellaneous\">\n<h3><a href=\"#id22\" rel=\"nofollow\">Miscellaneous</a></h3>\n<p>XXX RubberStamp(n, text)\nReferenceID(text)\nCostCenter(int)</p>\n</div>\n</div>\n<div id=\"internals-and-tests\">\n<h2><a href=\"#id23\" rel=\"nofollow\">Internals and Tests</a></h2>\n<p>Misc imports for tests:</p>\n<pre>&gt;&gt;&gt; from pydicia import add_to_package, ET, Option, Batch, Package\n</pre>\n<p>Packages:</p>\n<pre>&gt;&gt;&gt; b = Batch()\n&gt;&gt;&gt; p = Package(b)\n\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\" /&gt;\n&lt;/DAZzle&gt;\n\n&gt;&gt;&gt; Box = Option('FlatRate', 'BOX')\n&gt;&gt;&gt; add_to_package(Box, p, False)\n\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;FlatRate&gt;BOX&lt;/FlatRate&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n\n&gt;&gt;&gt; Envelope = Option('FlatRate', 'TRUE')\n&gt;&gt;&gt; add_to_package(Envelope, p, False)\nTraceback (most recent call last):\n  ...\nOptionConflict: Can't set 'FlatRate=TRUE' when 'FlatRate=BOX' already set\n\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;FlatRate&gt;BOX&lt;/FlatRate&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n\n&gt;&gt;&gt; add_to_package(Box, p, False)\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;FlatRate&gt;BOX&lt;/FlatRate&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n\n&gt;&gt;&gt; add_to_package(Envelope, p, True)\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;FlatRate&gt;BOX&lt;/FlatRate&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n\n&gt;&gt;&gt; del p.element[-1]; p.element.text=''\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle&gt;\n    &lt;Package ID=\"1\" /&gt;\n&lt;/DAZzle&gt;\n\n&gt;&gt;&gt; verify_zip = Option('DAZzle', 'DAZ', 'Start')\n\n&gt;&gt;&gt; add_to_package(verify_zip, p, False)\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle Start=\"DAZ\"&gt;\n    &lt;Package ID=\"1\" /&gt;\n&lt;/DAZzle&gt;\n\n&gt;&gt;&gt; add_to_package(Option('DAZzle', 'PRINTING', 'Start'), p, False)\nTraceback (most recent call last):\n  ...\nOptionConflict: Can't set 'DAZzle.Start=PRINTING' when 'DAZzle.Start=DAZ' already set\n\n&gt;&gt;&gt; b = Batch()\n&gt;&gt;&gt; p = Package(b)\n&gt;&gt;&gt; add_to_package([verify_zip, Envelope], p, False)\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle Start=\"DAZ\"&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;FlatRate&gt;TRUE&lt;/FlatRate&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n\n&gt;&gt;&gt; p.should_queue(Services.COD)\nTrue\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle Start=\"DAZ\"&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;FlatRate&gt;TRUE&lt;/FlatRate&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n\n&gt;&gt;&gt; p.finish()\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle Start=\"DAZ\"&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;FlatRate&gt;TRUE&lt;/FlatRate&gt;\n        &lt;Services COD=\"ON\" /&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n\n&gt;&gt;&gt; p.should_queue(Services.COD)\nFalse\n</pre>\n<p>Batch rollback:</p>\n<pre>&gt;&gt;&gt; b = Batch()\n&gt;&gt;&gt; print b.tostring()\n&lt;DAZzle /&gt;\n\n&gt;&gt;&gt; b.add_package(FlatRateEnvelope, FlatRateBox)\nTraceback (most recent call last):\n  ...\nOptionConflict: Can't set 'PackageType=FLATRATEBOX' when\n                           'PackageType=FLATRATEENVELOPE' already set\n\n&gt;&gt;&gt; print b.tostring()  # rollback on error\n&lt;DAZzle /&gt;\n</pre>\n<p>Misc shipment and postprocessing:</p>\n<pre>&gt;&gt;&gt; s = Shipment(verify_zip)\n&gt;&gt;&gt; s.add_package(Box)\n&gt;&gt;&gt; s.add_package(Envelope)\n&gt;&gt;&gt; root, = s.batches\n&gt;&gt;&gt; print root.tostring()\n&lt;DAZzle Start=\"DAZ\"&gt;\n    &lt;Package ID=\"1\"&gt;\n        &lt;FlatRate&gt;BOX&lt;/FlatRate&gt;\n    &lt;/Package&gt;\n    &lt;Package ID=\"2\"&gt;\n        &lt;FlatRate&gt;TRUE&lt;/FlatRate&gt;\n    &lt;/Package&gt;\n&lt;/DAZzle&gt;\n</pre>\n<p>Option inversion:</p>\n<pre>&gt;&gt;&gt; ~Envelope\nFlatRate('FALSE')\n&gt;&gt;&gt; ~~Envelope\nFlatRate('TRUE')\n\n&gt;&gt;&gt; ~Option('Services', 'ON', 'RegisteredMail')\nServices.RegisteredMail('OFF')\n&gt;&gt;&gt; ~~Option('Services', 'ON', 'RegisteredMail')\nServices.RegisteredMail('ON')\n\n&gt;&gt;&gt; ~Option('DAZzle', 'YES', 'Prompt')\nDAZzle.Prompt('NO')\n&gt;&gt;&gt; ~~Option('DAZzle', 'YES', 'Prompt')\nDAZzle.Prompt('YES')\n</pre>\n<p>The <tt>iter_options()</tt> generic function yields \u201coption\u201d objects for an\napplication object.  The default implementation is to raise an error:</p>\n<pre>&gt;&gt;&gt; from pydicia import iter_options\n\n&gt;&gt;&gt; iter_options(27)\nTraceback (most recent call last):\n  ...\nNotImplementedError: ('No option producer registered for', &lt;type 'int'&gt;)\n</pre>\n<p>And for lists and tuples, the default is to yield their contents:</p>\n<pre>&gt;&gt;&gt; list(iter_options((1, 2, 3)))\n[1, 2, 3]\n\n&gt;&gt;&gt; list(iter_options(['a', 'b']))\n['a', 'b']\n</pre>\n<p>This routine is used internally by <tt>add_to_package()</tt>.</p>\n</div>\n\n          </div>"}, "last_serial": 785261, "releases": {"0.1a1": [{"comment_text": "", "digests": {"md5": "aa403591994bb09cfeb30bd15200c2f0", "sha256": "2645b8d10be70f53cf107f2541ccf0d3e2eff64302ede76cabe0be87ae4ccb04"}, "downloads": -1, "filename": "PyDicia-0.1a1-py2.4.egg", "has_sig": false, "md5_digest": "aa403591994bb09cfeb30bd15200c2f0", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 33679, "upload_time": "2007-07-05T13:29:45", "upload_time_iso_8601": "2007-07-05T13:29:45Z", "url": "https://files.pythonhosted.org/packages/41/52/cdb8672510fecc0b682d86b21c6a332cb1226ebe168255d846d70c0254f5/PyDicia-0.1a1-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "3dcb6125ef692fc52bd1b06b84b9e943", "sha256": "8e05a70355f608871f5f013f34f7d8960ecfd5b4378b6b5c7b46b29c1b89fd7d"}, "downloads": -1, "filename": "PyDicia-0.1a1-py2.5.egg", "has_sig": false, "md5_digest": "3dcb6125ef692fc52bd1b06b84b9e943", "packagetype": "bdist_egg", "python_version": "2.5", "requires_python": null, "size": 33281, "upload_time": "2007-07-05T13:30:01", "upload_time_iso_8601": "2007-07-05T13:30:01Z", "url": "https://files.pythonhosted.org/packages/5a/9a/fe6812b8bfbc9a3dcbae060a0acaaa2f4ca2550dc465f808765e1a742f80/PyDicia-0.1a1-py2.5.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "d7f74e380a04224e505049fefdc0862a", "sha256": "42b7282fe62b63534ae73e3a52b9c4318b1fcd776c9d14948fe7e3fe58103119"}, "downloads": -1, "filename": "PyDicia-0.1a1.zip", "has_sig": false, "md5_digest": "d7f74e380a04224e505049fefdc0862a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36859, "upload_time": "2007-07-05T13:29:44", "upload_time_iso_8601": "2007-07-05T13:29:44Z", "url": "https://files.pythonhosted.org/packages/26/22/1cddcee599486f2115172d1dd448b75a36dca150793010588fbf6c6b22d6/PyDicia-0.1a1.zip", "yanked": false}], "0.1a2": [{"comment_text": "", "digests": {"md5": "b96318c7752b0caa1541d6634fd86ce6", "sha256": "95253282b740fa3b273ae5771f4148c65a9bc43bcfe50041a838a4eb076fc6fc"}, "downloads": -1, "filename": "PyDicia-0.1a2-py2.4.egg", "has_sig": false, "md5_digest": "b96318c7752b0caa1541d6634fd86ce6", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 34860, "upload_time": "2007-07-07T20:27:20", "upload_time_iso_8601": "2007-07-07T20:27:20Z", "url": "https://files.pythonhosted.org/packages/3f/bd/50644a2be41b803e4c810f5c560050ce6d3da61806a9d7cb26d62d228181/PyDicia-0.1a2-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "cdf5a9ea66adfebfc68bfcba2c8ce49a", "sha256": "1df46c84148dfc7360f52acbe463866f4fa7c2dfd2c69f65814e451147b5b0c3"}, "downloads": -1, "filename": "PyDicia-0.1a2-py2.5.egg", "has_sig": false, "md5_digest": "cdf5a9ea66adfebfc68bfcba2c8ce49a", "packagetype": "bdist_egg", "python_version": "2.5", "requires_python": null, "size": 34422, "upload_time": "2007-07-07T20:27:54", "upload_time_iso_8601": "2007-07-07T20:27:54Z", "url": "https://files.pythonhosted.org/packages/84/47/8fc6df657c3d0cb064c2576ed5d1d402458861e7961cef7694533ab2da16/PyDicia-0.1a2-py2.5.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "5a0ecb47e93baa69b939b62e54d71299", "sha256": "a1d36ad642854322c6c17a9512d054d4e1be801588c563ad29128e0c7c11271b"}, "downloads": -1, "filename": "PyDicia-0.1a2.zip", "has_sig": false, "md5_digest": "5a0ecb47e93baa69b939b62e54d71299", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39467, "upload_time": "2007-07-07T20:27:18", "upload_time_iso_8601": "2007-07-07T20:27:18Z", "url": "https://files.pythonhosted.org/packages/a2/7a/e1b986c5aa7ea593d507feb4819195a4ad19a5b94f0445a53eb11b54e008/PyDicia-0.1a2.zip", "yanked": false}], "0.1a3": [{"comment_text": "", "digests": {"md5": "846a4e1b554deddbc11624d294f6eac3", "sha256": "160a9e7fb7405ea6642dce62cfc685414250b4e22b40c2de7368667a1672db39"}, "downloads": -1, "filename": "PyDicia-0.1a3-py2.4.egg", "has_sig": false, "md5_digest": "846a4e1b554deddbc11624d294f6eac3", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 35023, "upload_time": "2008-03-05T16:54:24", "upload_time_iso_8601": "2008-03-05T16:54:24Z", "url": "https://files.pythonhosted.org/packages/06/33/8a7c4600ccbab2a1c7bfc45095e31f13c3afb71b689b57fa9193c5bad40b/PyDicia-0.1a3-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "7bb08c19a2cb756b0f52cb35b1a1e621", "sha256": "415bf2fe70406e3234bda3259bb231de27f193d5837da791bd47bb669bbeb1be"}, "downloads": -1, "filename": "PyDicia-0.1a3-py2.5.egg", "has_sig": false, "md5_digest": "7bb08c19a2cb756b0f52cb35b1a1e621", "packagetype": "bdist_egg", "python_version": "2.5", "requires_python": null, "size": 34607, "upload_time": "2008-03-05T16:53:07", "upload_time_iso_8601": "2008-03-05T16:53:07Z", "url": "https://files.pythonhosted.org/packages/02/34/23b7471de2ce7c95c26e1b753ea0994b808d13bf06de01a5aeabae197048/PyDicia-0.1a3-py2.5.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "c77e56e8b341ba8ccd7bbbaf63afcda6", "sha256": "193da2ece127f863b05e1c76747c383787cdf13d2394831f0c864768e08431ac"}, "downloads": -1, "filename": "PyDicia-0.1a3.zip", "has_sig": false, "md5_digest": "c77e56e8b341ba8ccd7bbbaf63afcda6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39737, "upload_time": "2008-03-05T16:53:05", "upload_time_iso_8601": "2008-03-05T16:53:05Z", "url": "https://files.pythonhosted.org/packages/4d/57/2e65c97b001401379ba3d913a8294425e98161a6212093c7278f79b86811/PyDicia-0.1a3.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "846a4e1b554deddbc11624d294f6eac3", "sha256": "160a9e7fb7405ea6642dce62cfc685414250b4e22b40c2de7368667a1672db39"}, "downloads": -1, "filename": "PyDicia-0.1a3-py2.4.egg", "has_sig": false, "md5_digest": "846a4e1b554deddbc11624d294f6eac3", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 35023, "upload_time": "2008-03-05T16:54:24", "upload_time_iso_8601": "2008-03-05T16:54:24Z", "url": "https://files.pythonhosted.org/packages/06/33/8a7c4600ccbab2a1c7bfc45095e31f13c3afb71b689b57fa9193c5bad40b/PyDicia-0.1a3-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "7bb08c19a2cb756b0f52cb35b1a1e621", "sha256": "415bf2fe70406e3234bda3259bb231de27f193d5837da791bd47bb669bbeb1be"}, "downloads": -1, "filename": "PyDicia-0.1a3-py2.5.egg", "has_sig": false, "md5_digest": "7bb08c19a2cb756b0f52cb35b1a1e621", "packagetype": "bdist_egg", "python_version": "2.5", "requires_python": null, "size": 34607, "upload_time": "2008-03-05T16:53:07", "upload_time_iso_8601": "2008-03-05T16:53:07Z", "url": "https://files.pythonhosted.org/packages/02/34/23b7471de2ce7c95c26e1b753ea0994b808d13bf06de01a5aeabae197048/PyDicia-0.1a3-py2.5.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "c77e56e8b341ba8ccd7bbbaf63afcda6", "sha256": "193da2ece127f863b05e1c76747c383787cdf13d2394831f0c864768e08431ac"}, "downloads": -1, "filename": "PyDicia-0.1a3.zip", "has_sig": false, "md5_digest": "c77e56e8b341ba8ccd7bbbaf63afcda6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39737, "upload_time": "2008-03-05T16:53:05", "upload_time_iso_8601": "2008-03-05T16:53:05Z", "url": "https://files.pythonhosted.org/packages/4d/57/2e65c97b001401379ba3d913a8294425e98161a6212093c7278f79b86811/PyDicia-0.1a3.zip", "yanked": false}], "timestamp": "Fri May  8 03:07:02 2020"}