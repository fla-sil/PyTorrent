{"info": {"author": "Benjamin Roepken <broepken57@hotmail.com>", "author_email": "Benjamin Roepken <broepken57@hotmail.com>", "bugtrack_url": null, "classifiers": [], "description": "# rs_fec_conv\r\n\r\n[![PyPi](https://img.shields.io/pypi/v/rs_fec_conv.svg?style=flat-square)](https://pypi.org/project/rs_fec_conv/)\r\n[![Docs](https://readthedocs.org/projects/rs_fec_conv/badge/?version=latest)](http://rs_fec_conv.readthedocs.io/en/latest/?badge=latest)\r\n\r\n## Getting Started\r\nThe package rs_fec_conv is a rust binding built with [pyo3](https://github.com/PyO3/pyo3).\r\nrs_fec_conv is intended to be used in parallel with the \r\n[scikit-dsp-comm](https://github.com/mwickert/scikit-dsp-comm) package.\r\nThe rust binding improve the processing time of the conv_encoder and viterbi_decoder algorithms.\r\n\r\n### Rust Install\r\nRust is not needed on the system to execute the binaries since the functions are already pre-compiled.\r\nAlthough, [Rust](https://www.rust-lang.org/tools/install) can be downloaded online or \r\ninstalled on Windows Subsystem for Linux.\r\n\r\n```bash\r\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\r\n```\r\n### Package Requirements\r\nThis package requires Python 3.7.x.\r\n\r\n### rs_fec_conv Install\r\nYou can download the package rs_fec_conv from PyPi [PyPi](https://pypi.org/project/rs_fec_conv/),\r\nor by the command\r\n```bash\r\npip install rs_fec_conv\r\n``` \r\n\r\nNote: The preferred method is to download from PyPi. \r\nIf downloading directly from GitHub you will need to install Rust prior.\r\n\r\n### Results\r\n| BEP Simulation (EbN0=4,100000 bits)  G, depth | Python Time (sec) | Rust Time (sec) | Rust Speed Factor Increase |\r\n| --------------------------------------------- | ----------------- | --------------- | -------------------------- |\r\n| ('111', '101'), 10            | 39.88       | 0.79      | 50.24      |\r\n| ('11111','11011','10101'), 25 | 675.00      | 21.32     | 31.66      |\r\n| ('1111001','1011011'), 25     | 217.02      | 9.27      | 23.41      |\r\n\r\n\r\n## Tutorial\r\n\r\n### Convolutional Encoder\r\nThe function conv_encoder_rs can be implemented\r\n\r\n```bash\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimport sk_dsp_comm.rs_fec_conv as rs_fec\r\n\r\n# Generate random data\r\nN = 20\r\nx = randint(0,2,N)\r\n\r\n# Initialize fec_conv object with either G length 2 or 3\r\nG =('111','101')\r\n# G = ('11110111','11011001','10010101')\r\ncc1 = rs_fec.fec_conv(G,10)\r\nstate = '00'\r\n\r\n# Convolutionally Encode Signal\r\ny,state = cc1.conv_encoder(x,state)\r\n\r\n# Plot input signal\r\nsubplot(211)\r\nstem(x)\r\nxlabel('Number of Samples')\r\nylabel('x')\r\ntitle('Input Signal')\r\n\r\n# Plot convolutionally encoded signal\r\nsubplot(212)\r\nstem(y)\r\nxlabel('Number of Samples')\r\nylabel('y')\r\ntitle('Convolutionally Encoded Signal')\r\ntight_layout()\r\nsavefig('conv_enc.png')\r\n```\r\n\r\n![Convolutionally Encoded Signal](https://github.com/grayfox57/rs_fec_conv/blob/master/conv_enc.png)\r\n\r\n### Viterbi Decoder\r\nThe function viterbi_decoder_rs can be implemented by\r\n```bash\r\n# Viterbi decode\r\nz = cc1.viterbi_decoder(y.astype(int), 'hard', 3)\r\n\r\n# Plot input signal\r\nsubplot(211)\r\nstem(x[:11])\r\nxlabel('Number of Samples')\r\nylabel('x')\r\ntitle('Input Signal')\r\nxlim([0,10])\r\n\r\n# Plot viterbi decoded signal\r\nsubplot(212)\r\nstem(z)\r\nxlabel('Number of Samples')\r\nylabel('z')\r\ntitle('Viterbi decoded Signal')\r\nxlim([0,10])\r\ntight_layout()\r\nsavefig('viterbi_dec.png')\r\n```\r\n\r\n![Viterbi Decoded Signal](https://github.com/grayfox57/rs_fec_conv/blob/master/viterbi_dec.png)\r\n\r\nSince there is no channel noise added to the signal the Viterbi decoded signal results\r\nin no bit errors from the original signal.   \r\n\r\n### Channel Simulation\r\nA simulation using AWGN can be done using by integrating with other functions provided \r\nin the scikit-dsp-comm toolbox\r\n```bash\r\n# Soft decision rate 1/2 simulation\r\nN_bits_per_frame = 100000\r\nEbN0 = 4\r\ntotal_bit_errors = 0\r\ntotal_bit_count = 0\r\ncc1 = rs_fec.fec_conv(('11101','10011'),25)\r\n\r\n# Encode with shift register starting state of '0000'\r\nstate = '0000'\r\nwhile total_bit_errors < 100:\r\n\t# Create 100000 random 0/1 bits\r\n\tx = randint(0,2,N_bits_per_frame)\r\n\ty,state = cc1.conv_encoder(x,state)\r\n\r\n\t# Add channel noise to bits, include antipodal level shift to [-1,1]\r\n\t# Channel SNR is 3 dB less for rate 1/2\r\n\tyn_soft = dc.cpx_AWGN(2*y-1,EbN0-3,1) \r\n\tyn_hard = ((np.sign(yn_soft.real)+1)/2).astype(int)\r\n\tz = cc1.viterbi_decoder(yn_hard,'hard')\r\n\r\n\t# Count bit errors\r\n\tbit_count, bit_errors = dc.bit_errors(x,z)\r\n\ttotal_bit_errors += bit_errors\r\n\ttotal_bit_count += bit_count\r\n\tprint('Bits Received = %d, Bit errors = %d, BEP = %1.2e' %\\\r\n\t\t  (total_bit_count, total_bit_errors,\\\r\n\t\t   total_bit_errors/total_bit_count))\r\n\r\nprint('*****************************************************')\r\nprint('Bits Received = %d, Bit errors = %d, BEP = %1.2e' %\\\r\n\t  (total_bit_count, total_bit_errors,\\\r\n\t   total_bit_errors/total_bit_count))\r\n```\r\n   \r\nRate 1/2 Object\r\n\r\nkmax =  0, taumax = 0\r\n\r\nBits Received = 99976, Bit errors = 845, BEP = 8.45e-03\r\n\r\n*****************************************************\r\n\r\nBits Received = 99976, Bit errors = 845, BEP = 8.45e-03", "description_content_type": "text/markdown; charset=UTF-8; variant=GFM", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "rs_fec_conv", "package_url": "https://pypi.org/project/rs_fec_conv/", "platform": "", "project_url": "https://pypi.org/project/rs_fec_conv/", "project_urls": null, "release_url": "https://pypi.org/project/rs_fec_conv/0.4.5/", "requires_dist": null, "requires_python": "", "summary": "Convolutional Encoder and Viterbi Decoder built with Rust bindings for integration with Python", "version": "0.4.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>rs_fec_conv</h1>\n<p><a href=\"https://pypi.org/project/rs_fec_conv/\" rel=\"nofollow\"><img alt=\"PyPi\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/93f4e7ea68311d0e5b74b33c87d25ad9813b479f/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f72735f6665635f636f6e762e7376673f7374796c653d666c61742d737175617265\"></a>\n<a href=\"http://rs_fec_conv.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Docs\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f3007b0a6ef20c938febda05a237c4156dabc88b/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f72735f6665635f636f6e762f62616467652f3f76657273696f6e3d6c6174657374\"></a></p>\n<h2>Getting Started</h2>\n<p>The package rs_fec_conv is a rust binding built with <a href=\"https://github.com/PyO3/pyo3\" rel=\"nofollow\">pyo3</a>.\nrs_fec_conv is intended to be used in parallel with the\n<a href=\"https://github.com/mwickert/scikit-dsp-comm\" rel=\"nofollow\">scikit-dsp-comm</a> package.\nThe rust binding improve the processing time of the conv_encoder and viterbi_decoder algorithms.</p>\n<h3>Rust Install</h3>\n<p>Rust is not needed on the system to execute the binaries since the functions are already pre-compiled.\nAlthough, <a href=\"https://www.rust-lang.org/tools/install\" rel=\"nofollow\">Rust</a> can be downloaded online or\ninstalled on Windows Subsystem for Linux.</p>\n<pre>curl --proto <span class=\"s1\">'=https'</span> --tlsv1.2 -sSf https://sh.rustup.rs <span class=\"p\">|</span> sh\n</pre>\n<h3>Package Requirements</h3>\n<p>This package requires Python 3.7.x.</p>\n<h3>rs_fec_conv Install</h3>\n<p>You can download the package rs_fec_conv from PyPi <a href=\"https://pypi.org/project/rs_fec_conv/\" rel=\"nofollow\">PyPi</a>,\nor by the command</p>\n<pre>pip install rs_fec_conv\n</pre>\n<p>Note: The preferred method is to download from PyPi.\nIf downloading directly from GitHub you will need to install Rust prior.</p>\n<h3>Results</h3>\n<table>\n<thead>\n<tr>\n<th>BEP Simulation (EbN0=4,100000 bits)  G, depth</th>\n<th>Python Time (sec)</th>\n<th>Rust Time (sec)</th>\n<th>Rust Speed Factor Increase</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>('111', '101'), 10</td>\n<td>39.88</td>\n<td>0.79</td>\n<td>50.24</td>\n</tr>\n<tr>\n<td>('11111','11011','10101'), 25</td>\n<td>675.00</td>\n<td>21.32</td>\n<td>31.66</td>\n</tr>\n<tr>\n<td>('1111001','1011011'), 25</td>\n<td>217.02</td>\n<td>9.27</td>\n<td>23.41</td>\n</tr></tbody></table>\n<h2>Tutorial</h2>\n<h3>Convolutional Encoder</h3>\n<p>The function conv_encoder_rs can be implemented</p>\n<pre>import numpy as np\nimport matplotlib.pyplot as plt\nimport sk_dsp_comm.rs_fec_conv as rs_fec\n\n<span class=\"c1\"># Generate random data</span>\n<span class=\"nv\">N</span> <span class=\"o\">=</span> <span class=\"m\">20</span>\n<span class=\"nv\">x</span> <span class=\"o\">=</span> randint<span class=\"o\">(</span><span class=\"m\">0</span>,2,N<span class=\"o\">)</span>\n\n<span class=\"c1\"># Initialize fec_conv object with either G length 2 or 3</span>\n<span class=\"nv\">G</span> <span class=\"o\">=(</span><span class=\"s1\">'111'</span>,<span class=\"s1\">'101'</span><span class=\"o\">)</span>\n<span class=\"c1\"># G = ('11110111','11011001','10010101')</span>\n<span class=\"nv\">cc1</span> <span class=\"o\">=</span> rs_fec.fec_conv<span class=\"o\">(</span>G,10<span class=\"o\">)</span>\n<span class=\"nv\">state</span> <span class=\"o\">=</span> <span class=\"s1\">'00'</span>\n\n<span class=\"c1\"># Convolutionally Encode Signal</span>\ny,state <span class=\"o\">=</span> cc1.conv_encoder<span class=\"o\">(</span>x,state<span class=\"o\">)</span>\n\n<span class=\"c1\"># Plot input signal</span>\nsubplot<span class=\"o\">(</span><span class=\"m\">211</span><span class=\"o\">)</span>\nstem<span class=\"o\">(</span>x<span class=\"o\">)</span>\nxlabel<span class=\"o\">(</span><span class=\"s1\">'Number of Samples'</span><span class=\"o\">)</span>\nylabel<span class=\"o\">(</span><span class=\"s1\">'x'</span><span class=\"o\">)</span>\ntitle<span class=\"o\">(</span><span class=\"s1\">'Input Signal'</span><span class=\"o\">)</span>\n\n<span class=\"c1\"># Plot convolutionally encoded signal</span>\nsubplot<span class=\"o\">(</span><span class=\"m\">212</span><span class=\"o\">)</span>\nstem<span class=\"o\">(</span>y<span class=\"o\">)</span>\nxlabel<span class=\"o\">(</span><span class=\"s1\">'Number of Samples'</span><span class=\"o\">)</span>\nylabel<span class=\"o\">(</span><span class=\"s1\">'y'</span><span class=\"o\">)</span>\ntitle<span class=\"o\">(</span><span class=\"s1\">'Convolutionally Encoded Signal'</span><span class=\"o\">)</span>\ntight_layout<span class=\"o\">()</span>\nsavefig<span class=\"o\">(</span><span class=\"s1\">'conv_enc.png'</span><span class=\"o\">)</span>\n</pre>\n<p><img alt=\"Convolutionally Encoded Signal\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/698ce538c7cd46600787b14faf0fa17d93389fbf/68747470733a2f2f6769746875622e636f6d2f67726179666f7835372f72735f6665635f636f6e762f626c6f622f6d61737465722f636f6e765f656e632e706e67\"></p>\n<h3>Viterbi Decoder</h3>\n<p>The function viterbi_decoder_rs can be implemented by</p>\n<pre><span class=\"c1\"># Viterbi decode</span>\n<span class=\"nv\">z</span> <span class=\"o\">=</span> cc1.viterbi_decoder<span class=\"o\">(</span>y.astype<span class=\"o\">(</span>int<span class=\"o\">)</span>, <span class=\"s1\">'hard'</span>, <span class=\"m\">3</span><span class=\"o\">)</span>\n\n<span class=\"c1\"># Plot input signal</span>\nsubplot<span class=\"o\">(</span><span class=\"m\">211</span><span class=\"o\">)</span>\nstem<span class=\"o\">(</span>x<span class=\"o\">[</span>:11<span class=\"o\">])</span>\nxlabel<span class=\"o\">(</span><span class=\"s1\">'Number of Samples'</span><span class=\"o\">)</span>\nylabel<span class=\"o\">(</span><span class=\"s1\">'x'</span><span class=\"o\">)</span>\ntitle<span class=\"o\">(</span><span class=\"s1\">'Input Signal'</span><span class=\"o\">)</span>\nxlim<span class=\"o\">([</span><span class=\"m\">0</span>,10<span class=\"o\">])</span>\n\n<span class=\"c1\"># Plot viterbi decoded signal</span>\nsubplot<span class=\"o\">(</span><span class=\"m\">212</span><span class=\"o\">)</span>\nstem<span class=\"o\">(</span>z<span class=\"o\">)</span>\nxlabel<span class=\"o\">(</span><span class=\"s1\">'Number of Samples'</span><span class=\"o\">)</span>\nylabel<span class=\"o\">(</span><span class=\"s1\">'z'</span><span class=\"o\">)</span>\ntitle<span class=\"o\">(</span><span class=\"s1\">'Viterbi decoded Signal'</span><span class=\"o\">)</span>\nxlim<span class=\"o\">([</span><span class=\"m\">0</span>,10<span class=\"o\">])</span>\ntight_layout<span class=\"o\">()</span>\nsavefig<span class=\"o\">(</span><span class=\"s1\">'viterbi_dec.png'</span><span class=\"o\">)</span>\n</pre>\n<p><img alt=\"Viterbi Decoded Signal\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1494ee390c69d4e93be03d2c45db75a84c5036d6/68747470733a2f2f6769746875622e636f6d2f67726179666f7835372f72735f6665635f636f6e762f626c6f622f6d61737465722f766974657262695f6465632e706e67\"></p>\n<p>Since there is no channel noise added to the signal the Viterbi decoded signal results\nin no bit errors from the original signal.</p>\n<h3>Channel Simulation</h3>\n<p>A simulation using AWGN can be done using by integrating with other functions provided\nin the scikit-dsp-comm toolbox</p>\n<pre><span class=\"c1\"># Soft decision rate 1/2 simulation</span>\n<span class=\"nv\">N_bits_per_frame</span> <span class=\"o\">=</span> <span class=\"m\">100000</span>\n<span class=\"nv\">EbN0</span> <span class=\"o\">=</span> <span class=\"m\">4</span>\n<span class=\"nv\">total_bit_errors</span> <span class=\"o\">=</span> <span class=\"m\">0</span>\n<span class=\"nv\">total_bit_count</span> <span class=\"o\">=</span> <span class=\"m\">0</span>\n<span class=\"nv\">cc1</span> <span class=\"o\">=</span> rs_fec.fec_conv<span class=\"o\">((</span><span class=\"s1\">'11101'</span>,<span class=\"s1\">'10011'</span><span class=\"o\">)</span>,25<span class=\"o\">)</span>\n\n<span class=\"c1\"># Encode with shift register starting state of '0000'</span>\n<span class=\"nv\">state</span> <span class=\"o\">=</span> <span class=\"s1\">'0000'</span>\n<span class=\"k\">while</span> total_bit_errors &lt; <span class=\"m\">100</span>:\n\t<span class=\"c1\"># Create 100000 random 0/1 bits</span>\n\t<span class=\"nv\">x</span> <span class=\"o\">=</span> randint<span class=\"o\">(</span><span class=\"m\">0</span>,2,N_bits_per_frame<span class=\"o\">)</span>\n\ty,state <span class=\"o\">=</span> cc1.conv_encoder<span class=\"o\">(</span>x,state<span class=\"o\">)</span>\n\n\t<span class=\"c1\"># Add channel noise to bits, include antipodal level shift to [-1,1]</span>\n\t<span class=\"c1\"># Channel SNR is 3 dB less for rate 1/2</span>\n\t<span class=\"nv\">yn_soft</span> <span class=\"o\">=</span> dc.cpx_AWGN<span class=\"o\">(</span><span class=\"m\">2</span>*y-1,EbN0-3,1<span class=\"o\">)</span> \n\t<span class=\"nv\">yn_hard</span> <span class=\"o\">=</span> <span class=\"o\">((</span>np.sign<span class=\"o\">(</span>yn_soft.real<span class=\"o\">)</span>+1<span class=\"o\">)</span>/2<span class=\"o\">)</span>.astype<span class=\"o\">(</span>int<span class=\"o\">)</span>\n\t<span class=\"nv\">z</span> <span class=\"o\">=</span> cc1.viterbi_decoder<span class=\"o\">(</span>yn_hard,<span class=\"s1\">'hard'</span><span class=\"o\">)</span>\n\n\t<span class=\"c1\"># Count bit errors</span>\n\tbit_count, <span class=\"nv\">bit_errors</span> <span class=\"o\">=</span> dc.bit_errors<span class=\"o\">(</span>x,z<span class=\"o\">)</span>\n\t<span class=\"nv\">total_bit_errors</span> <span class=\"o\">+=</span> bit_errors\n\t<span class=\"nv\">total_bit_count</span> <span class=\"o\">+=</span> bit_count\n\tprint<span class=\"o\">(</span><span class=\"s1\">'Bits Received = %d, Bit errors = %d, BEP = %1.2e'</span> %<span class=\"se\">\\</span>\n\t\t  <span class=\"o\">(</span>total_bit_count, total_bit_errors,<span class=\"se\">\\</span>\n\t\t   total_bit_errors/total_bit_count<span class=\"o\">))</span>\n\nprint<span class=\"o\">(</span><span class=\"s1\">'*****************************************************'</span><span class=\"o\">)</span>\nprint<span class=\"o\">(</span><span class=\"s1\">'Bits Received = %d, Bit errors = %d, BEP = %1.2e'</span> %<span class=\"se\">\\</span>\n\t  <span class=\"o\">(</span>total_bit_count, total_bit_errors,<span class=\"se\">\\</span>\n\t   total_bit_errors/total_bit_count<span class=\"o\">))</span>\n</pre>\n<p>Rate 1/2 Object</p>\n<p>kmax =  0, taumax = 0</p>\n<p>Bits Received = 99976, Bit errors = 845, BEP = 8.45e-03</p>\n<hr>\n<p>Bits Received = 99976, Bit errors = 845, BEP = 8.45e-03</p>\n\n          </div>"}, "last_serial": 6914265, "releases": {"0.4.5": [{"comment_text": "", "digests": {"md5": "38e082f9efb8fdb0fe4713e84676a970", "sha256": "992b6dd6ccbafeafd1b5462a42d69df50d1e9d6c31977e7518f835fab128117a"}, "downloads": -1, "filename": "rs_fec_conv-0.4.5-cp37-cp37m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "38e082f9efb8fdb0fe4713e84676a970", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 163430, "upload_time": "2020-03-30T16:45:46", "upload_time_iso_8601": "2020-03-30T16:45:46.483603Z", "url": "https://files.pythonhosted.org/packages/ab/c7/a8d181792618ae3073f61c1a5f178722ac22549fda0c4e3c850d4e5f4de8/rs_fec_conv-0.4.5-cp37-cp37m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0860d942a1638e964d4cc05834115470", "sha256": "b17da03664597a84b8aea48b4f15baff36316f14358447269d6b5a93f71d2967"}, "downloads": -1, "filename": "rs_fec_conv-0.4.5-cp37-none-win_amd64.whl", "has_sig": false, "md5_digest": "0860d942a1638e964d4cc05834115470", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 178326, "upload_time": "2020-03-28T19:43:31", "upload_time_iso_8601": "2020-03-28T19:43:31.101963Z", "url": "https://files.pythonhosted.org/packages/26/b9/12a5dc63cada9b23fa3f713e5735701db6efdc94bf8145bfb55b27cb3149/rs_fec_conv-0.4.5-cp37-none-win_amd64.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "38e082f9efb8fdb0fe4713e84676a970", "sha256": "992b6dd6ccbafeafd1b5462a42d69df50d1e9d6c31977e7518f835fab128117a"}, "downloads": -1, "filename": "rs_fec_conv-0.4.5-cp37-cp37m-manylinux1_x86_64.whl", "has_sig": false, "md5_digest": "38e082f9efb8fdb0fe4713e84676a970", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 163430, "upload_time": "2020-03-30T16:45:46", "upload_time_iso_8601": "2020-03-30T16:45:46.483603Z", "url": "https://files.pythonhosted.org/packages/ab/c7/a8d181792618ae3073f61c1a5f178722ac22549fda0c4e3c850d4e5f4de8/rs_fec_conv-0.4.5-cp37-cp37m-manylinux1_x86_64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0860d942a1638e964d4cc05834115470", "sha256": "b17da03664597a84b8aea48b4f15baff36316f14358447269d6b5a93f71d2967"}, "downloads": -1, "filename": "rs_fec_conv-0.4.5-cp37-none-win_amd64.whl", "has_sig": false, "md5_digest": "0860d942a1638e964d4cc05834115470", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 178326, "upload_time": "2020-03-28T19:43:31", "upload_time_iso_8601": "2020-03-28T19:43:31.101963Z", "url": "https://files.pythonhosted.org/packages/26/b9/12a5dc63cada9b23fa3f713e5735701db6efdc94bf8145bfb55b27cb3149/rs_fec_conv-0.4.5-cp37-none-win_amd64.whl", "yanked": false}], "timestamp": "Fri May  8 03:00:41 2020"}