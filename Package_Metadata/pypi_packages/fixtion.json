{"info": {"author": "Jason Aguilon", "author_email": "jaguilon@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 1 - Planning", "Intended Audience :: Developers", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: Testing", "Topic :: Utilities"], "description": "Examples\n--------\n\nA basic fixture function definition:\n\n    >>> from fixtion import fixture\n    >>>\n    >>> @fixture\n    ... def basic_fixture():\n    ...   print 'enter basic fixture'\n    ...   yield\n    ...   print 'exit basic fixture'\n\nDecorating a test function with the basic fixture function will wrap the setup\nand teardown code (the stuff before and after the yield) around the test\nfunction invocation:\n\n    >>> @basic_fixture\n    ... def test_basic():\n    ...   print '-- A test setup with a basic fixture'\n    >>>\n    >>> test_basic()\n    enter basic fixture\n    -- A test setup with a basic fixture\n    exit basic fixture\n\n\nDecorating unittest.TestCase test methods work, too:\n\n    >>> import unittest\n    >>>\n    >>> class Tester(unittest.TestCase):\n    ...   @basic_fixture\n    ...   def test_foo(self):\n    ...     print '-- a standard unittest fixtured using fixtion'\n    >>>\n    >>> tester = Tester('test_foo')\n    >>> tester.test_foo()\n    enter basic fixture\n    -- a standard unittest fixtured using fixtion\n    exit basic fixture\n\n\nChange and restore os.environ:\n\n    >>> import os\n    >>>\n    >>> @fixture\n    ... def environ_fixture(**kwargs):\n    ...   # Save the original environment values then update the environ.\n    ...   original = {k: v for k, v in os.environ.iteritems() if k in kwargs}\n    ...   os.environ.update(**kwargs)\n    ...\n    ...   yield\n    ...\n    ...   # Restore the original environment values.\n    ...   for key in kwargs:\n    ...     os.environ.pop(key)\n    ...   os.environ.update(**original)\n    >>>\n    >>> @environ_fixture(foo='bar')\n    ... def test_environ():\n    ...   print 'foo: %r' % os.environ['foo']\n    >>>\n    >>> test_environ()\n    foo: 'bar'\n    >>>\n    >>> 'foo' in os.environ\n    False\n\n\nReturn some test context:\n\n    >>> @fixture\n    ... def login_fixture():\n    ...   class context(object):\n    ...     username = 'ksoze'\n    ...\n    ...   yield context()\n    >>>\n    >>> @login_fixture\n    ... def test_login(context):\n    ...   print context.username\n    >>>\n    >>> test_login()\n    ksoze\n\n\nWorks with mock.patch:\n\n    >>> import random\n    >>> import mock\n    >>>\n    >>> @fixture\n    ... @mock.patch('random.randint', return_value=123)\n    ... def patched_fixture(randint):\n    ...   yield\n    >>>\n    >>> @patched_fixture\n    ... def test_patched():\n    ...     print 'A random number between 1 and 10: %r' % random.randint(1, 10)\n    ...     print 'courtesy of %r' % random.randint\n    >>>\n    >>> test_patched()\n    A random number between 1 and 10: 123\n    courtesy of <MagicMock name='randint' ...>\n    >>>\n    >>> random.randint\n    <bound method Random.randint of <random.Random object at ...>>\n\n\nThe previous os.environ example can be really simplified:\n\n  >>> @fixture\n  ... def environ_fixture(**kwargs):\n  ...   with mock.patch.dict('os.environ', kwargs):\n  ...     yield\n  >>>\n  >>> @environ_fixture(foo='bar')\n  ... def test_environ():\n  ...   print 'foo: %r' % os.environ['foo']\n  >>>\n  >>> test_environ()\n  foo: 'bar'\n  >>>\n  >>> 'foo' in os.environ\n  False", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "UNKNOWN", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "fixtion", "package_url": "https://pypi.org/project/fixtion/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/fixtion/", "project_urls": {"Download": "UNKNOWN", "Homepage": "UNKNOWN"}, "release_url": "https://pypi.org/project/fixtion/0.0.1/", "requires_dist": null, "requires_python": null, "summary": "fixtion: Test fixture function definition in Python using context manager style generators.", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>A basic fixture function definition:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from fixtion import fixture\n&gt;&gt;&gt;\n&gt;&gt;&gt; @fixture\n... def basic_fixture():\n...   print 'enter basic fixture'\n...   yield\n...   print 'exit basic fixture'\n</pre>\n</blockquote>\n<p>Decorating a test function with the basic fixture function will wrap the setup\nand teardown code (the stuff before and after the yield) around the test\nfunction invocation:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @basic_fixture\n... def test_basic():\n...   print '-- A test setup with a basic fixture'\n&gt;&gt;&gt;\n&gt;&gt;&gt; test_basic()\nenter basic fixture\n-- A test setup with a basic fixture\nexit basic fixture\n</pre>\n</blockquote>\n<p>Decorating unittest.TestCase test methods work, too:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import unittest\n&gt;&gt;&gt;\n&gt;&gt;&gt; class Tester(unittest.TestCase):\n...   @basic_fixture\n...   def test_foo(self):\n...     print '-- a standard unittest fixtured using fixtion'\n&gt;&gt;&gt;\n&gt;&gt;&gt; tester = Tester('test_foo')\n&gt;&gt;&gt; tester.test_foo()\nenter basic fixture\n-- a standard unittest fixtured using fixtion\nexit basic fixture\n</pre>\n</blockquote>\n<p>Change and restore os.environ:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import os\n&gt;&gt;&gt;\n&gt;&gt;&gt; @fixture\n... def environ_fixture(**kwargs):\n...   # Save the original environment values then update the environ.\n...   original = {k: v for k, v in os.environ.iteritems() if k in kwargs}\n...   os.environ.update(**kwargs)\n...\n...   yield\n...\n...   # Restore the original environment values.\n...   for key in kwargs:\n...     os.environ.pop(key)\n...   os.environ.update(**original)\n&gt;&gt;&gt;\n&gt;&gt;&gt; @environ_fixture(foo='bar')\n... def test_environ():\n...   print 'foo: %r' % os.environ['foo']\n&gt;&gt;&gt;\n&gt;&gt;&gt; test_environ()\nfoo: 'bar'\n&gt;&gt;&gt;\n&gt;&gt;&gt; 'foo' in os.environ\nFalse\n</pre>\n</blockquote>\n<p>Return some test context:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @fixture\n... def login_fixture():\n...   class context(object):\n...     username = 'ksoze'\n...\n...   yield context()\n&gt;&gt;&gt;\n&gt;&gt;&gt; @login_fixture\n... def test_login(context):\n...   print context.username\n&gt;&gt;&gt;\n&gt;&gt;&gt; test_login()\nksoze\n</pre>\n</blockquote>\n<p>Works with mock.patch:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import random\n&gt;&gt;&gt; import mock\n&gt;&gt;&gt;\n&gt;&gt;&gt; @fixture\n... @mock.patch('random.randint', return_value=123)\n... def patched_fixture(randint):\n...   yield\n&gt;&gt;&gt;\n&gt;&gt;&gt; @patched_fixture\n... def test_patched():\n...     print 'A random number between 1 and 10: %r' % random.randint(1, 10)\n...     print 'courtesy of %r' % random.randint\n&gt;&gt;&gt;\n&gt;&gt;&gt; test_patched()\nA random number between 1 and 10: 123\ncourtesy of &lt;MagicMock name='randint' ...&gt;\n&gt;&gt;&gt;\n&gt;&gt;&gt; random.randint\n&lt;bound method Random.randint of &lt;random.Random object at ...&gt;&gt;\n</pre>\n</blockquote>\n<p>The previous os.environ example can be really simplified:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @fixture\n... def environ_fixture(**kwargs):\n...   with mock.patch.dict('os.environ', kwargs):\n...     yield\n&gt;&gt;&gt;\n&gt;&gt;&gt; @environ_fixture(foo='bar')\n... def test_environ():\n...   print 'foo: %r' % os.environ['foo']\n&gt;&gt;&gt;\n&gt;&gt;&gt; test_environ()\nfoo: 'bar'\n&gt;&gt;&gt;\n&gt;&gt;&gt; 'foo' in os.environ\nFalse\n</pre>\n</blockquote>\n\n          </div>"}, "last_serial": 876993, "releases": {"0.0.1": []}, "urls": [], "timestamp": "Fri May  8 00:42:02 2020"}