{"info": {"author": "Pave\u0142 Ty\u015blacki", "author_email": "pavel.tyslacki@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Framework :: Django", "Framework :: Django :: 2.2", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "[![PyPI](https://img.shields.io/pypi/v/django-pg-zero-downtime-migrations.svg)](https://pypi.org/project/django-pg-zero-downtime-migrations/)\n![PyPI - Python Version](https://img.shields.io/pypi/pyversions/django-pg-zero-downtime-migrations.svg)\n![PyPI - Django Version](https://img.shields.io/pypi/djversions/django-pg-zero-downtime-migrations.svg?label=django)\n![Postgres Version](https://img.shields.io/badge/postgres-9.5%20|%209.6%20|%2010%20|%2011%20|%2012%20-blue.svg)\n[![PyPI - License](https://img.shields.io/pypi/l/django-pg-zero-downtime-migrations.svg)](https://raw.githubusercontent.com/tbicr/django-pg-zero-downtime-migrations/master/LICENSE)\n\n[![PyPI - Downloads](https://img.shields.io/pypi/dm/django-pg-zero-downtime-migrations.svg)](https://pypistats.org/packages/django-pg-zero-downtime-migrations)\n[![GitHub last commit](https://img.shields.io/github/last-commit/tbicr/django-pg-zero-downtime-migrations/master.svg)](https://github.com/tbicr/django-pg-zero-downtime-migrations/commits/master)\n[![Build Status](https://travis-ci.org/tbicr/django-pg-zero-downtime-migrations.svg?branch=master)](https://travis-ci.org/tbicr/django-pg-zero-downtime-migrations)\n\n# django-pg-zero-downtime-migrations\nDjango postgresql backend that apply migrations with respect to database locks.\n\n## Installation\n\n    pip install django-pg-zero-downtime-migrations\n\n## Usage\n\nTo enable zero downtime migrations for postgres just setup django backend provided by this package and add most safe settings:\n\n    DATABASES = {\n        'default': {\n            'ENGINE': 'django_zero_downtime_migrations.backends.postgres',\n            #'ENGINE': 'django_zero_downtime_migrations.backends.postgis',\n            ...\n        }\n    }\n    ZERO_DOWNTIME_MIGRATIONS_LOCK_TIMEOUT = '2s'\n    ZERO_DOWNTIME_MIGRATIONS_STATEMENT_TIMEOUT = '2s'\n    ZERO_DOWNTIME_MIGRATIONS_FLEXIBLE_STATEMENT_TIMEOUT = True\n    ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True\n    ZERO_DOWNTIME_MIGRATIONS_USE_NOT_NULL = False\n\n> *NOTE:* this backend brings zero downtime improvements only for migrations (schema and `RunSQL` operations, but not for `RunPython` operation), for other purpose it works the same as standard django backend.\n\n> *NOTE:* this package is in beta, please check your migrations SQL before applying on production and submit issue for any question.\n\n### Differences with standard django backend\n\nThis backend provides same result state (except `NOT NULL` constraint replacement for old postgres versions if appropriate option configured), but different way and with additional guarantees for avoiding stuck table locks.\n\nThis backend doesn't use transactions for migrations (except `RunPython` operation), because not all SQL fixes can be run in transaction and it allows to avoid deadlocks for complex migration. So when your migration will down in middle of transaction you need fix it manually (instead potential downtime). For that reason good practice to make migration modules small as possible.\n\n### Deployment flow\n\nThere ara main rules for zero downtime deployment:\n1. We have one database;\n1. We have several instances with application - application always should be available, even you restart one of instances;\n1. We have balancer before instances;\n1. Our application works fine before, on and after migration - old application works fine with old and new database schema version;\n1. Our application works fine before, on and after instance updating - old and new application versions work fine with new database schema version.\n\n![deployment timeline](https://raw.githubusercontent.com/tbicr/django-pg-zero-downtime-migrations/0.8/images/timeline.png \"deployment timeline\")\n\nFlow:\n1. apply migrations\n1. disconnect instance form balancer, restart it and back to balancer - repeat this operation one by one for all instances\n\nIf our deployment don't satisfy zero downtime deployment rules, then we split it to smaller deployments.\n\n![deployment flow](https://raw.githubusercontent.com/tbicr/django-pg-zero-downtime-migrations/0.8/images/deployment.gif \"deployment flow\")\n\n### Settings\n\n#### ZERO_DOWNTIME_MIGRATIONS_LOCK_TIMEOUT\n\nApply [`lock_timeout`](https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-LOCK-TIMEOUT) for SQL statements that require `ACCESS EXCLUSIVE` lock, default `None`:\n\n    ZERO_DOWNTIME_MIGRATIONS_LOCK_TIMEOUT = '2s'\n\nAllowed values:\n - `None` - current postgres setting used\n - other - timeout will be applied, `0` and equivalents mean that timeout will be disabled\n\n#### ZERO_DOWNTIME_MIGRATIONS_STATEMENT_TIMEOUT\n\nApply [`statement_timeout`](https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT) for SQL statements that require `ACCESS EXCLUSIVE` lock, default `None`:\n\n    ZERO_DOWNTIME_MIGRATIONS_STATEMENT_TIMEOUT = '2s'\n\nAllowed values:\n - `None` - current postgres setting used\n - other - timeout will be applied, `0` and equivalents mean that timeout will be disabled\n\n#### ZERO_DOWNTIME_MIGRATIONS_FLEXIBLE_STATEMENT_TIMEOUT\n\nSet [`statement_timeout`](https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT) to `0ms` for SQL statements that require `SHARE UPDATE EXCLUSIVE` lock that useful in case when `statement_timeout` enabled globally and you try run long-running operations like index creation or constraint validation, default `False`:\n\n    ZERO_DOWNTIME_MIGRATIONS_FLEXIBLE_STATEMENT_TIMEOUT = True\n\n#### ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE\n\nEnabled option doesn't allow run potential unsafe migration, default `False`:\n\n    ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True\n\n#### ZERO_DOWNTIME_MIGRATIONS_USE_NOT_NULL\n\nSet policy for avoiding `NOT NULL` constraint creation long lock, default `None`:\n\n    ZERO_DOWNTIME_MIGRATIONS_USE_NOT_NULL = 10 ** 7\n\nAllowed values:\n - `None` - standard django's behaviour (raise for `ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True`)\n - `True` - always replace `NOT NULL` constraint with `CHECK (field IS NOT NULL)` (don't raise for `ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True`)\n - `False` - always use `NOT NULL` constraint (don't raise for `ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True`)\n - `int` value - use `CHECK (field IS NOT NULL)` instead `NOT NULL` constraint if table has more than `value` rows (approximate rows count used) otherwise use `NOT NULL` constraint (don't raise for `ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True`)\n - `USE_PG_ATTRIBUTE_UPDATE_FOR_SUPERUSER` - use `pg_catalog.pg_attribute` update to mark column `NOT NULL` and provide same state as default django backend (don't raise for `ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True`).\n\n> *NOTE:* For postgres 12 and newest `NOT NULL` constraint creation has migration replacement that provide same state as default django backend, so this option deprecated and doesn't used this postgres version. If you use `CHECK NOT NULL` compatible constraint before you can migrate it to `NOT NULL` constraints with `manage.py migrate_isnotnull_check_constraints` management command (add `INSTALLED_APPS += ['django_zero_downtime_migrations']` to `settings.py` to use management command).\n\n## How it works\n\n### Postgres table level locks\n\nPostgres has different locks on table level that can conflict with each other https://www.postgresql.org/docs/current/static/explicit-locking.html#LOCKING-TABLES:\n\n|                          | `ACCESS SHARE` | `ROW SHARE` | `ROW EXCLUSIVE` | `SHARE UPDATE EXCLUSIVE` | `SHARE` | `SHARE ROW EXCLUSIVE` | `EXCLUSIVE` | `ACCESS EXCLUSIVE` |\n|--------------------------|:--------------:|:-----------:|:---------------:|:------------------------:|:-------:|:---------------------:|:-----------:|:------------------:|\n| `ACCESS SHARE`           |                |             |                 |                          |         |                       |             | X                  |\n| `ROW SHARE`              |                |             |                 |                          |         |                       | X           | X                  |\n| `ROW EXCLUSIVE`          |                |             |                 |                          | X       | X                     | X           | X                  |\n| `SHARE UPDATE EXCLUSIVE` |                |             |                 | X                        | X       | X                     | X           | X                  |\n| `SHARE`                  |                |             | X               | X                        |         | X                     | X           | X                  |\n| `SHARE ROW EXCLUSIVE`    |                |             | X               | X                        | X       | X                     | X           | X                  |\n| `EXCLUSIVE`              |                | X           | X               | X                        | X       | X                     | X           | X                  |\n| `ACCESS EXCLUSIVE`       | X              | X           | X               | X                        | X       | X                     | X           | X                  |\n\n### Migration and business logic locks\n\nLets split this lock to migration and business logic operations.\n\n- Migration operations work synchronously in one thread and cover schema migrations (data migrations conflict with business logic operations same as business logic conflict concurrently).\n- Business logic operations work concurrently.\n\n#### Migration locks\n\n| lock                     | operations                                                                                            |\n|--------------------------|-------------------------------------------------------------------------------------------------------|\n| `ACCESS EXCLUSIVE`       | `CREATE SEQUENCE`, `DROP SEQUENCE`, `CREATE TABLE`, `DROP TABLE` \\*, `ALTER TABLE` \\*\\*, `DROP INDEX` |\n| `SHARE`                  | `CREATE INDEX`                                                                                        |\n| `SHARE UPDATE EXCLUSIVE` | `CREATE INDEX CONCURRENTLY`, `DROP INDEX CONCURRENTLY`, `ALTER TABLE VALIDATE CONSTRAINT` \\*\\*\\*      |\n\n\\*: `CREATE SEQUENCE`, `DROP SEQUENCE`, `CREATE TABLE`, `DROP TABLE` shouldn't have conflicts, because your business logic shouldn't yet operate with created tables and shouldn't already operate with deleted tables.\n\n\\*\\*: Not all `ALTER TABLE` operations take `ACCESS EXCLUSIVE` lock, but all current django's migrations take it https://github.com/django/django/blob/master/django/db/backends/base/schema.py, https://github.com/django/django/blob/master/django/db/backends/postgresql/schema.py and https://www.postgresql.org/docs/current/static/sql-altertable.html.\n\n\\*\\*\\*: Django doesn't have `VALIDATE CONSTRAINT` logic, but we will use it for some cases.\n\n#### Business logic locks\n\n| lock            | operations                   | conflict with lock                                              | conflict with operations                    |\n|-----------------|------------------------------|-----------------------------------------------------------------|---------------------------------------------|\n| `ACCESS SHARE`  | `SELECT`                     | `ACCESS EXCLUSIVE`                                              | `ALTER TABLE`, `DROP INDEX`                 |\n| `ROW SHARE`     | `SELECT FOR UPDATE`          | `ACCESS EXCLUSIVE`, `EXCLUSIVE`                                 | `ALTER TABLE`, `DROP INDEX`                 |\n| `ROW EXCLUSIVE` | `INSERT`, `UPDATE`, `DELETE` | `ACCESS EXCLUSIVE`, `EXCLUSIVE`, `SHARE ROW EXCLUSIVE`, `SHARE` | `ALTER TABLE`, `DROP INDEX`, `CREATE INDEX` |\n\nSo you can find that all django schema changes for exist table conflicts with business logic, but fortunately they are safe or has safe alternative in general.\n\n### Postgres row level locks\n\nAs business logic mostly works with table rows it's also important to understand lock conflicts on row level https://www.postgresql.org/docs/current/static/explicit-locking.html#LOCKING-ROWS:\n\n| lock                | `FOR KEY SHARE` | `FOR SHARE` | `FOR NO KEY UPDATE` | `FOR UPDATE` |\n|---------------------|:---------------:|:-----------:|:-------------------:|:------------:|\n| `FOR KEY SHARE`     |                 |             |                     | X            |\n| `FOR SHARE`         |                 |             | X                   | X            |\n| `FOR NO KEY UPDATE` |                 | X           | X                   | X            |\n| `FOR UPDATE`        | X               | X           | X                   | X            |\n\nMain point there is if you have two transactions that update one row, then second transaction will wait until first will be completed. So for business logic and data migrations better to avoid updates for whole table and use batch operations instead.\n\n> *NOTE:* batch operations also can work faster because postgres can use more optimal execution plan with indexes for small data range.\n\n### Transactions FIFO waiting\n\n![postgres FIFO](https://raw.githubusercontent.com/tbicr/django-pg-zero-downtime-migrations/0.8/images/fifo-diagram.png \"postgres FIFO\")\n\nFound same diagram in interesting article http://pankrat.github.io/2015/django-migrations-without-downtimes/.\n\nIn this diagram we can extract several metrics:\n\n1. operation time - time what you spend for schema change, so there is issue for long running operation on many rows tables like `CREATE INDEX` or `ALTER TABLE ADD COLUMN SET DEFAULT`, so you need use more save equivalents instead.\n2. waiting time - your migration will wait until all transactions will be completed, so there is issue for long running operations/transactions like analytic, so you need avoid it or disable on migration time.\n3. queries per second + execution time and connections pool - if you too many queries to table and this queries take long time then this queries can just take all available connections to database until wait for release lock, so look like you need different optimizations there: run migrations when load minimal, decrease queries count and execution time, split you data.\n4. too many operations in one transaction - you have issues in all previous points for one operation so if you have many operations in one transaction then you have more chances to get this issues, so you need avoid many operations in one transactions (or even don't run it in transactions at all but you should be more careful when some operation will fail).\n\n### Dealing with timeouts\n\nPostgres has two settings to dealing with `waiting time` and `operation time` presented in diagram: `lock_timeout` and `statement_timeout`.\n\n`SET lock_timeout TO '2s'` allow you to avoid downtime when you have long running query/transaction before run migration (https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-LOCK-TIMEOUT).\n\n`SET statement_timeout TO '2s'` allow you to avoid downtime when you have long running migration query (https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT).\n\n### Deadlocks\n\nThere no downtime issues for deadlocks, but too many operations in one transaction can take most conflicted lock and release it only after transaction commit or rollback. So it's a good idea to avoid `ACCESS EXCLUSIVE` lock operations and long time operations in one transaction. Deadlocks also can make you migration stuck on production deployment when different tables will be locked, for example, for FOREIGN KEY that take `ACCESS EXCLUSIVE` lock for two tables.\n\n### Rows and values storing\n\nPostgres store values of different types different ways. If you try to convert one type to another and it stored different way then postgres will rewrite all values. Fortunately some types stored same way and postgres need to do nothing to change type, but in some cases postgres need to check that all values have same with new type limitations, for example string length.  \n\n### Multiversion Concurrency Control\n\nRegarding documentation https://www.postgresql.org/docs/current/static/mvcc-intro.html data consistency in postgres is maintained by using a multiversion model. This means that each SQL statement sees a snapshot of data. It has advantage for adding and deleting columns without any indexes, constrains and defaults do not change exist data, new version of data will be created on `INSERT` and `UPDATE`, delete just mark you record expired. All garbage will be collected later by `VACUUM` or `AUTO VACUUM`.\n\n### Django migrations hacks\n\nAny schema changes can be processed with creation of new table and copy data to it, but it can take significant time.\n\n|  # | name                                          | safe | safe alternative              | description |\n|---:|-----------------------------------------------|:----:|:-----------------------------:|-------------|\n|  1 | `CREATE SEQUENCE`                             | X    |                               | safe operation, because your business logic shouldn't operate with new sequence on migration time \\*\n|  2 | `DROP SEQUENCE`                               | X    |                               | safe operation, because your business logic shouldn't operate with this sequence on migration time \\*\n|  3 | `CREATE TABLE`                                | X    |                               | safe operation, because your business logic shouldn't operate with new table on migration time \\*\n|  4 | `DROP TABLE`                                  | X    |                               | safe operation, because your business logic shouldn't operate with this table on migration time \\*\n|  5 | `ALTER TABLE RENAME TO`                       |      | add new table and copy data   | **unsafe operation**, it's too hard write business logic that operate with two tables simultaneously, so propose `CREATE TABLE` and then copy all data to new table \\*\n|  6 | `ALTER TABLE SET TABLESPACE`                  |      | add new table and copy data   | **unsafe operation**, but probably you don't need it at all or often \\*\n|  7 | `ALTER TABLE ADD COLUMN`                      | X    |                               | safe operation if without `SET NOT NULL`, `SET DEFAULT`, `PRIMARY KEY`, `UNIQUE` \\*\n|  8 | `ALTER TABLE ADD COLUMN SET DEFAULT`          |      | add column and set default    | **unsafe operation**, because you spend time in migration to populate all values in table, so propose `ALTER TABLE ADD COLUMN` and then populate column and then `SET DEFAULT` \\*\n|  9 | `ALTER TABLE ADD COLUMN SET NOT NULL`         |      | +/-                           | **unsafe operation**, because doesn't work without `SET DEFAULT` or after migration old code can insert rows without new column and raise exception, so propose `ALTER TABLE ADD COLUMN` and then populate column and then `ALTER TABLE ALTER COLUMN SET NOT NULL` \\* and \\*\\*\n| 10 | `ALTER TABLE ADD COLUMN PRIMARY KEY`          |      | add index and add constraint  | **unsafe operation**, because you spend time in migration to `CREATE INDEX`, so propose `ALTER TABLE ADD COLUMN` and then `CREATE INDEX CONCURRENTLY` and then `ALTER TABLE ADD CONSTRAINT PRIMARY KEY USING INDEX` \\*\\*\\*\n| 11 | `ALTER TABLE ADD COLUMN UNIQUE`               |      | add index and add constraint  | **unsafe operation**, because you spend time in migration to `CREATE INDEX`, so propose `ALTER TABLE ADD COLUMN` and then `CREATE INDEX CONCURRENTLY` and then `ALTER TABLE ADD CONSTRAINT UNIQUE USING INDEX` \\*\\*\\*\n| 12 | `ALTER TABLE ALTER COLUMN TYPE`               |      | +/-                           | **unsafe operation**, because you spend time in migration to check that all items in column valid or to change type, but some operations can be safe \\*\\*\\*\\*\n| 13 | `ALTER TABLE ALTER COLUMN SET NOT NULL`       |      | +/-                           | **unsafe operation**, because you spend time in migration to check that all items in column `NOT NULL` \\*\\*\n| 14 | `ALTER TABLE ALTER COLUMN DROP NOT NULL`      | X    |                               | safe operation\n| 15 | `ALTER TABLE ALTER COLUMN SET DEFAULT`        | X    |                               | safe operation\n| 16 | `ALTER TABLE ALTER COLUMN DROP DEFAULT`       | X    |                               | safe operation\n| 17 | `ALTER TABLE DROP COLUMN`                     | X    |                               | safe operation, because you business logic shouldn't operate with this column on migration time, however better `ALTER TABLE ALTER COLUMN DROP NOT NULL`, `ALTER TABLE DROP CONSTRAINT` and `DROP INDEX` before \\* and \\*\\*\\*\\*\\*\n| 18 | `ALTER TABLE RENAME COLUMN`                   |      | add new column and copy data  | **unsafe operation**, it's too hard write business logic that operate with two columns simultaneously, so propose `ALTER TABLE CREATE COLUMN` and then copy all data to new column \\*\n| 19 | `ALTER TABLE ADD CONSTRAINT CHECK`            |      | add as not valid and validate | **unsafe operation**, because you spend time in migration to check constraint\n| 20 | `ALTER TABLE DROP CONSTRAINT` (`CHECK`)       | X    |                               | safe operation\n| 21 | `ALTER TABLE ADD CONSTRAINT FOREIGN KEY`      |      | add as not valid and validate | **unsafe operation**, because you spend time in migration to check constraint, lock two tables\n| 22 | `ALTER TABLE DROP CONSTRAINT` (`FOREIGN KEY`) | X    |                               | safe operation, lock two tables\n| 23 | `ALTER TABLE ADD CONSTRAINT PRIMARY KEY`      |      | add index and add constraint  | **unsafe operation**, because you spend time in migration to create index \\*\\*\\*\n| 24 | `ALTER TABLE DROP CONSTRAINT` (`PRIMARY KEY`) | X    |                               | safe operation \\*\\*\\*\n| 25 | `ALTER TABLE ADD CONSTRAINT UNIQUE`           |      | add index and add constraint  | **unsafe operation**, because you spend time in migration to create index \\*\\*\\*\n| 26 | `ALTER TABLE DROP CONSTRAINT` (`UNIQUE`)      | X    |                               | safe operation \\*\\*\\*\n| 27 | `ALTER TABLE ADD CONSTRAINT EXCLUDE`          |      | add new table and copy data   |\n| 28 | `ALTER TABLE DROP CONSTRAINT (EXCLUDE)`       | X    |                               |\n| 29 | `CREATE INDEX`                                |      | `CREATE INDEX CONCURRENTLY`   | **unsafe operation**, because you spend time in migration to create index\n| 30 | `DROP INDEX`                                  | X    | `DROP INDEX CONCURRENTLY`     | safe operation  \\*\\*\\*\n| 31 | `CREATE INDEX CONCURRENTLY`                   | X    |                               | safe operation\n| 32 | `DROP INDEX CONCURRENTLY`                     | X    |                               | safe operation  \\*\\*\\*\n\n\\*: main point with migration on production without downtime that your code should correctly work before and after migration, lets look this point closely in [Dealing with logic that should work before and after migration](#dealing-with-logic-that-should-work-before-and-after-migration) section.\n\n\\*\\*: postgres will check that all items in column `NOT NULL` that take time, lets look this point closely in [Dealing with `NOT NULL` constraint](#dealing-with-not-null-constraint) section.\n\n\\*\\*\\*: postgres will have same behaviour when you skip `ALTER TABLE ADD CONSTRAINT UNIQUE USING INDEX` and still unclear difference with `CONCURRENTLY` except difference in locks, lets look this point closely in [Dealing with `UNIQUE` constraint](#dealing-with-unique-constraint).\n\n\\*\\*\\*\\*: lets look this point closely in [Dealing with `ALTER TABLE ALTER COLUMN TYPE`](#dealing-with-alter-table-alter-column-type) section.\n\n\\*\\*\\*\\*\\*: if you check migration on CI with `python manage.py makemigrations --check` you can't drop column in code without migration creation, so in this case you can be useful *back migration flow*: apply code on all instances and then migrate database\n\n#### Dealing with logic that should work before and after migration\n\n##### Adding and removing models and columns\n\nMigrations: `CREATE SEQUENCE`, `DROP SEQUENCE`, `CREATE TABLE`, `DROP TABLE`, `ALTER TABLE ADD COLUMN`, `ALTER TABLE DROP COLUMN`.\n\nThis migrations are pretty safe, because your logic doesn't work with this data before migration\n\n##### Changes for working logic\n\nMigrations: `ALTER TABLE RENAME TO`, `ALTER TABLE SET TABLESPACE`, `ALTER TABLE RENAME COLUMN`, `ALTER TABLE ADD CONSTRAINT EXCLUDE`.\n\nFor this migration too hard implement logic that will work correctly for all instances, so there are two ways to dealing with it:\n\n1. create new table/column, copy exist data, drop old table/column\n2. downtime\n\n##### Create column with default\n\nMigrations: `ALTER TABLE ADD COLUMN SET DEFAULT`.\n\nStandard django's behaviour for creation column with default is populate all values with default. Django don't use database defaults permanently, so when you add new column with default django will create column with default and drop this default at once, eg. new default will come from django code. In this case you can have a gap when migration applied by not all instances has updated and at this moment new rows in table will be without default and probably you need update nullable values after that. So to avoid this case best way is avoid creation column with default and split column creation (with default for new rows) and data population to two migrations (with deployments).\n\n#### Dealing with `NOT NULL` constraint\n\nPostgres check that all column items `NOT NULL` when you applying `NOT NULL` constraint, for postgres 12 and newest it doesn't make this check if appropriate `CHECK CONSTRAINT` exists, but for older versions you can't defer this check as for `NOT VALID`. Fortunately we have some hacks and alternatives there for old postgres versions.\n\n1. Run migrations when load minimal to avoid negative affect of locking.\n2. `SET statement_timeout` and try to set `NOT NULL` constraint for small tables.\n3. Use `CHECK (column IS NOT NULL)` constraint instead that support `NOT VALID` option with next `VALIDATE CONSTRAINT`, see article for details https://medium.com/doctolib-engineering/adding-a-not-null-constraint-on-pg-faster-with-minimal-locking-38b2c00c4d1c. There are additionally can be applied `NOT NULL` constraint via direct `pg_catalog.pg_attribute` `attnotnull` update, but it require superuser permissions.\n\n#### Dealing with `UNIQUE` constraint\n\nPostgres has two approaches for uniqueness: `CREATE UNIQUE INDEX` and `ALTER TABLE ADD CONSTRAINT UNIQUE` - both use unique index inside. Difference that we can find that we cannot apply `DROP INDEX CONCURRENTLY` for constraint. However it still unclear what difference for `DROP INDEX` and `DROP INDEX CONCURRENTLY` except difference in locks, but as we seen before both marked as safe - we don't spend time in `DROP INDEX`, just wait for lock. So as django use constraint for uniqueness we also have a hacks to use constraint safely.\n\n#### Dealing with `ALTER TABLE ALTER COLUMN TYPE`\n\nNext operations are safe:\n\n1. `varchar(LESS)` to `varchar(MORE)` where LESS < MORE\n2. `varchar(ANY)` to `text`\n3. `numeric(LESS, SAME)` to `numeric(MORE, SAME)` where LESS < MORE and SAME == SAME\n\nFor other operations propose to create new column and copy data to it. Eg. some types can be also safe, but you should check yourself.\n\n\n# django-pg-zero-downtime-migrations changelog\n\n## 0.8\n- added django 3.0 support\n- added concurrently index creation and removal operations\n- added exclude constraint support as unsafe operation\n- drop postgres 9.4 support\n- drop django 2.0 support\n- drop django 2.1 support\n- drop deprecated `django_zero_downtime_migrations_postgres_backend` module\n\n## 0.7\n  - added python 3.8 support\n  - added postgres specific indexes support\n  - improved tests clearness\n  - fixed regexp escaping warning for management command\n  - fixed style check\n  - improved README\n  - marked python 3.5 support deprecated\n  - marked postgres 9.4 support deprecated\n  - marked django 2.0 support deprecated\n  - marked django 2.1 support deprecated\n\n## 0.6\n  - marked `ZERO_DOWNTIME_MIGRATIONS_USE_NOT_NULL` option deprecated for postgres 12+\n  - added management command for migration to real `NOT NULL` from `CHECK IS NOT NULL` constraint\n  - added integration tests for pg 12, pg 11 root, pg 11 compatible not null constraint, pg 11 standard not null constraint and pg 10, 9.6, 9.5, 9.4, postgis databases\n  - fixed compatible check not null constraint deletion and creation via pg_attribute bugs\n  - minimized side affect with deferred sql execution between operations in one migration module\n  - added postgres 12 safe `NOT NULL` constraint creation\n  - added safe `NOT NULL` constraint creation for extra permissions for `pg_catalog.pg_attribute` with `ZERO_DOWNTIME_MIGRATIONS_USE_NOT_NULL=USE_PG_ATTRIBUTE_UPDATE_FOR_SUPERUSER` option enabled\n  - marked `AddField` with `null=False` parameter and compatible `CHECK IS NOT NULL` constraint option as unsafe operation and avoid `ZERO_DOWNTIME_MIGRATIONS_USE_NOT_NULL` value in this case\n  - added version to package\n  - fixed pypi README images links\n  - improved README\n\n## 0.5\n  - extracted zero-downtime-schema to mixin to allow use this logic with other backends\n  - moved module from `django_zero_downtime_migrations_postgres_backend` to `django_zero_downtime_migrations.backends.postgres`\n  - marked `django_zero_downtime_migrations_postgres_backend` module as deprecated\n  - added postgis backend support\n  - improved README\n\n## 0.4\n  - changed defaults for `ZERO_DOWNTIME_MIGRATIONS_LOCK_TIMEOUT` and `ZERO_DOWNTIME_MIGRATIONS_STATEMENT_TIMEOUT` from `0ms` to `None` to get same with default django behavior that respect default postgres timeouts\n  - added updates to documentations with options defaults\n  - added updates to documentations with best options usage\n  - fixed adding nullable field with default had no error and warning issue\n  - added links to documentation with issue describing and safe alternatives usage for errors and warnings\n  - added updates to documentations with type casting workarounds\n\n## 0.3\n  - added django 2.2 support with `Meta.indexes` and `Meta.constraints` attributes\n  - fixed python deprecation warnings for regexp\n  - removed unused `TimeoutException`\n  - improved README and PYPI description\n\n## 0.2\n  - added option that allow disable `statement_timeout` for long operations like index creation on constraint validation when statement_timeout set globally\n\n## 0.1.1\n  - added long description content type\n\n## 0.1\n  - replaced default sql queries with more safe\n  - added options for `statement_timeout` and `lock_timeout`\n  - added option for `NOT NULL` constraint behaviour\n  - added option for unsafe operation restriction\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/tbicr/django-pg-zero-downtime-migrations", "keywords": "django postgres postgresql migrations", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "django-pg-zero-downtime-migrations", "package_url": "https://pypi.org/project/django-pg-zero-downtime-migrations/", "platform": "", "project_url": "https://pypi.org/project/django-pg-zero-downtime-migrations/", "project_urls": {"Homepage": "https://github.com/tbicr/django-pg-zero-downtime-migrations"}, "release_url": "https://pypi.org/project/django-pg-zero-downtime-migrations/0.8/", "requires_dist": ["django (>=2.2)"], "requires_python": ">=3.5", "summary": "Django postgresql backend that apply migrations with respect to database locks", "version": "0.8", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://pypi.org/project/django-pg-zero-downtime-migrations/\" rel=\"nofollow\"><img alt=\"PyPI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/74153d7c7cdca946de1a4147063cc7da40a02d13/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f646a616e676f2d70672d7a65726f2d646f776e74696d652d6d6967726174696f6e732e737667\"></a>\n<img alt=\"PyPI - Python Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ddb35bc18423834e4abd388fa3c5e5eaf7c36729/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f646a616e676f2d70672d7a65726f2d646f776e74696d652d6d6967726174696f6e732e737667\">\n<img alt=\"PyPI - Django Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ce12da737dedd6fc2f69a5d1a643aa58c9054fc3/68747470733a2f2f696d672e736869656c64732e696f2f707970692f646a76657273696f6e732f646a616e676f2d70672d7a65726f2d646f776e74696d652d6d6967726174696f6e732e7376673f6c6162656c3d646a616e676f\">\n<img alt=\"Postgres Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/92f4dde4472df209298f8f7e2afd35163444c736/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f706f7374677265732d392e35253230253743253230392e362532302537432532303130253230253743253230313125323025374325323031322532302d626c75652e737667\">\n<a href=\"https://raw.githubusercontent.com/tbicr/django-pg-zero-downtime-migrations/master/LICENSE\" rel=\"nofollow\"><img alt=\"PyPI - License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d4610d7e120c89ab33bd504c3d40a0c1ee9c4074/68747470733a2f2f696d672e736869656c64732e696f2f707970692f6c2f646a616e676f2d70672d7a65726f2d646f776e74696d652d6d6967726174696f6e732e737667\"></a></p>\n<p><a href=\"https://pypistats.org/packages/django-pg-zero-downtime-migrations\" rel=\"nofollow\"><img alt=\"PyPI - Downloads\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/98fafdd9e7fb43ef79a9764cef4f5d661a25eefa/68747470733a2f2f696d672e736869656c64732e696f2f707970692f646d2f646a616e676f2d70672d7a65726f2d646f776e74696d652d6d6967726174696f6e732e737667\"></a>\n<a href=\"https://github.com/tbicr/django-pg-zero-downtime-migrations/commits/master\" rel=\"nofollow\"><img alt=\"GitHub last commit\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/49edfda028a077df82508fe5a8c2a0619db2cc98/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6173742d636f6d6d69742f74626963722f646a616e676f2d70672d7a65726f2d646f776e74696d652d6d6967726174696f6e732f6d61737465722e737667\"></a>\n<a href=\"https://travis-ci.org/tbicr/django-pg-zero-downtime-migrations\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/600c01d88c5a95ad59b61a09aa46a444923c4824/68747470733a2f2f7472617669732d63692e6f72672f74626963722f646a616e676f2d70672d7a65726f2d646f776e74696d652d6d6967726174696f6e732e7376673f6272616e63683d6d6173746572\"></a></p>\n<h1>django-pg-zero-downtime-migrations</h1>\n<p>Django postgresql backend that apply migrations with respect to database locks.</p>\n<h2>Installation</h2>\n<pre><code>pip install django-pg-zero-downtime-migrations\n</code></pre>\n<h2>Usage</h2>\n<p>To enable zero downtime migrations for postgres just setup django backend provided by this package and add most safe settings:</p>\n<pre><code>DATABASES = {\n    'default': {\n        'ENGINE': 'django_zero_downtime_migrations.backends.postgres',\n        #'ENGINE': 'django_zero_downtime_migrations.backends.postgis',\n        ...\n    }\n}\nZERO_DOWNTIME_MIGRATIONS_LOCK_TIMEOUT = '2s'\nZERO_DOWNTIME_MIGRATIONS_STATEMENT_TIMEOUT = '2s'\nZERO_DOWNTIME_MIGRATIONS_FLEXIBLE_STATEMENT_TIMEOUT = True\nZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True\nZERO_DOWNTIME_MIGRATIONS_USE_NOT_NULL = False\n</code></pre>\n<blockquote>\n<p><em>NOTE:</em> this backend brings zero downtime improvements only for migrations (schema and <code>RunSQL</code> operations, but not for <code>RunPython</code> operation), for other purpose it works the same as standard django backend.</p>\n</blockquote>\n<blockquote>\n<p><em>NOTE:</em> this package is in beta, please check your migrations SQL before applying on production and submit issue for any question.</p>\n</blockquote>\n<h3>Differences with standard django backend</h3>\n<p>This backend provides same result state (except <code>NOT NULL</code> constraint replacement for old postgres versions if appropriate option configured), but different way and with additional guarantees for avoiding stuck table locks.</p>\n<p>This backend doesn't use transactions for migrations (except <code>RunPython</code> operation), because not all SQL fixes can be run in transaction and it allows to avoid deadlocks for complex migration. So when your migration will down in middle of transaction you need fix it manually (instead potential downtime). For that reason good practice to make migration modules small as possible.</p>\n<h3>Deployment flow</h3>\n<p>There ara main rules for zero downtime deployment:</p>\n<ol>\n<li>We have one database;</li>\n<li>We have several instances with application - application always should be available, even you restart one of instances;</li>\n<li>We have balancer before instances;</li>\n<li>Our application works fine before, on and after migration - old application works fine with old and new database schema version;</li>\n<li>Our application works fine before, on and after instance updating - old and new application versions work fine with new database schema version.</li>\n</ol>\n<p><img alt=\"deployment timeline\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/185f58d0b8f94ed80530b81a576983fbe9f5a6e9/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f74626963722f646a616e676f2d70672d7a65726f2d646f776e74696d652d6d6967726174696f6e732f302e382f696d616765732f74696d656c696e652e706e67\"></p>\n<p>Flow:</p>\n<ol>\n<li>apply migrations</li>\n<li>disconnect instance form balancer, restart it and back to balancer - repeat this operation one by one for all instances</li>\n</ol>\n<p>If our deployment don't satisfy zero downtime deployment rules, then we split it to smaller deployments.</p>\n<p><img alt=\"deployment flow\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0cb4a1e43d6d3892559c05d9d387cd1922ba940e/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f74626963722f646a616e676f2d70672d7a65726f2d646f776e74696d652d6d6967726174696f6e732f302e382f696d616765732f6465706c6f796d656e742e676966\"></p>\n<h3>Settings</h3>\n<h4>ZERO_DOWNTIME_MIGRATIONS_LOCK_TIMEOUT</h4>\n<p>Apply <a href=\"https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-LOCK-TIMEOUT\" rel=\"nofollow\"><code>lock_timeout</code></a> for SQL statements that require <code>ACCESS EXCLUSIVE</code> lock, default <code>None</code>:</p>\n<pre><code>ZERO_DOWNTIME_MIGRATIONS_LOCK_TIMEOUT = '2s'\n</code></pre>\n<p>Allowed values:</p>\n<ul>\n<li><code>None</code> - current postgres setting used</li>\n<li>other - timeout will be applied, <code>0</code> and equivalents mean that timeout will be disabled</li>\n</ul>\n<h4>ZERO_DOWNTIME_MIGRATIONS_STATEMENT_TIMEOUT</h4>\n<p>Apply <a href=\"https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT\" rel=\"nofollow\"><code>statement_timeout</code></a> for SQL statements that require <code>ACCESS EXCLUSIVE</code> lock, default <code>None</code>:</p>\n<pre><code>ZERO_DOWNTIME_MIGRATIONS_STATEMENT_TIMEOUT = '2s'\n</code></pre>\n<p>Allowed values:</p>\n<ul>\n<li><code>None</code> - current postgres setting used</li>\n<li>other - timeout will be applied, <code>0</code> and equivalents mean that timeout will be disabled</li>\n</ul>\n<h4>ZERO_DOWNTIME_MIGRATIONS_FLEXIBLE_STATEMENT_TIMEOUT</h4>\n<p>Set <a href=\"https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT\" rel=\"nofollow\"><code>statement_timeout</code></a> to <code>0ms</code> for SQL statements that require <code>SHARE UPDATE EXCLUSIVE</code> lock that useful in case when <code>statement_timeout</code> enabled globally and you try run long-running operations like index creation or constraint validation, default <code>False</code>:</p>\n<pre><code>ZERO_DOWNTIME_MIGRATIONS_FLEXIBLE_STATEMENT_TIMEOUT = True\n</code></pre>\n<h4>ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE</h4>\n<p>Enabled option doesn't allow run potential unsafe migration, default <code>False</code>:</p>\n<pre><code>ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True\n</code></pre>\n<h4>ZERO_DOWNTIME_MIGRATIONS_USE_NOT_NULL</h4>\n<p>Set policy for avoiding <code>NOT NULL</code> constraint creation long lock, default <code>None</code>:</p>\n<pre><code>ZERO_DOWNTIME_MIGRATIONS_USE_NOT_NULL = 10 ** 7\n</code></pre>\n<p>Allowed values:</p>\n<ul>\n<li><code>None</code> - standard django's behaviour (raise for <code>ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True</code>)</li>\n<li><code>True</code> - always replace <code>NOT NULL</code> constraint with <code>CHECK (field IS NOT NULL)</code> (don't raise for <code>ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True</code>)</li>\n<li><code>False</code> - always use <code>NOT NULL</code> constraint (don't raise for <code>ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True</code>)</li>\n<li><code>int</code> value - use <code>CHECK (field IS NOT NULL)</code> instead <code>NOT NULL</code> constraint if table has more than <code>value</code> rows (approximate rows count used) otherwise use <code>NOT NULL</code> constraint (don't raise for <code>ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True</code>)</li>\n<li><code>USE_PG_ATTRIBUTE_UPDATE_FOR_SUPERUSER</code> - use <code>pg_catalog.pg_attribute</code> update to mark column <code>NOT NULL</code> and provide same state as default django backend (don't raise for <code>ZERO_DOWNTIME_MIGRATIONS_RAISE_FOR_UNSAFE = True</code>).</li>\n</ul>\n<blockquote>\n<p><em>NOTE:</em> For postgres 12 and newest <code>NOT NULL</code> constraint creation has migration replacement that provide same state as default django backend, so this option deprecated and doesn't used this postgres version. If you use <code>CHECK NOT NULL</code> compatible constraint before you can migrate it to <code>NOT NULL</code> constraints with <code>manage.py migrate_isnotnull_check_constraints</code> management command (add <code>INSTALLED_APPS += ['django_zero_downtime_migrations']</code> to <code>settings.py</code> to use management command).</p>\n</blockquote>\n<h2>How it works</h2>\n<h3>Postgres table level locks</h3>\n<p>Postgres has different locks on table level that can conflict with each other <a href=\"https://www.postgresql.org/docs/current/static/explicit-locking.html#LOCKING-TABLES\" rel=\"nofollow\">https://www.postgresql.org/docs/current/static/explicit-locking.html#LOCKING-TABLES</a>:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th align=\"center\"><code>ACCESS SHARE</code></th>\n<th align=\"center\"><code>ROW SHARE</code></th>\n<th align=\"center\"><code>ROW EXCLUSIVE</code></th>\n<th align=\"center\"><code>SHARE UPDATE EXCLUSIVE</code></th>\n<th align=\"center\"><code>SHARE</code></th>\n<th align=\"center\"><code>SHARE ROW EXCLUSIVE</code></th>\n<th align=\"center\"><code>EXCLUSIVE</code></th>\n<th align=\"center\"><code>ACCESS EXCLUSIVE</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ACCESS SHARE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td><code>ROW SHARE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td><code>ROW EXCLUSIVE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td><code>SHARE UPDATE EXCLUSIVE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td><code>SHARE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td><code>SHARE ROW EXCLUSIVE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td><code>EXCLUSIVE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td><code>ACCESS EXCLUSIVE</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n</tr></tbody></table>\n<h3>Migration and business logic locks</h3>\n<p>Lets split this lock to migration and business logic operations.</p>\n<ul>\n<li>Migration operations work synchronously in one thread and cover schema migrations (data migrations conflict with business logic operations same as business logic conflict concurrently).</li>\n<li>Business logic operations work concurrently.</li>\n</ul>\n<h4>Migration locks</h4>\n<table>\n<thead>\n<tr>\n<th>lock</th>\n<th>operations</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ACCESS EXCLUSIVE</code></td>\n<td><code>CREATE SEQUENCE</code>, <code>DROP SEQUENCE</code>, <code>CREATE TABLE</code>, <code>DROP TABLE</code> *, <code>ALTER TABLE</code> **, <code>DROP INDEX</code></td>\n</tr>\n<tr>\n<td><code>SHARE</code></td>\n<td><code>CREATE INDEX</code></td>\n</tr>\n<tr>\n<td><code>SHARE UPDATE EXCLUSIVE</code></td>\n<td><code>CREATE INDEX CONCURRENTLY</code>, <code>DROP INDEX CONCURRENTLY</code>, <code>ALTER TABLE VALIDATE CONSTRAINT</code> ***</td>\n</tr></tbody></table>\n<p>*: <code>CREATE SEQUENCE</code>, <code>DROP SEQUENCE</code>, <code>CREATE TABLE</code>, <code>DROP TABLE</code> shouldn't have conflicts, because your business logic shouldn't yet operate with created tables and shouldn't already operate with deleted tables.</p>\n<p>**: Not all <code>ALTER TABLE</code> operations take <code>ACCESS EXCLUSIVE</code> lock, but all current django's migrations take it <a href=\"https://github.com/django/django/blob/master/django/db/backends/base/schema.py\" rel=\"nofollow\">https://github.com/django/django/blob/master/django/db/backends/base/schema.py</a>, <a href=\"https://github.com/django/django/blob/master/django/db/backends/postgresql/schema.py\" rel=\"nofollow\">https://github.com/django/django/blob/master/django/db/backends/postgresql/schema.py</a> and <a href=\"https://www.postgresql.org/docs/current/static/sql-altertable.html\" rel=\"nofollow\">https://www.postgresql.org/docs/current/static/sql-altertable.html</a>.</p>\n<p>***: Django doesn't have <code>VALIDATE CONSTRAINT</code> logic, but we will use it for some cases.</p>\n<h4>Business logic locks</h4>\n<table>\n<thead>\n<tr>\n<th>lock</th>\n<th>operations</th>\n<th>conflict with lock</th>\n<th>conflict with operations</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>ACCESS SHARE</code></td>\n<td><code>SELECT</code></td>\n<td><code>ACCESS EXCLUSIVE</code></td>\n<td><code>ALTER TABLE</code>, <code>DROP INDEX</code></td>\n</tr>\n<tr>\n<td><code>ROW SHARE</code></td>\n<td><code>SELECT FOR UPDATE</code></td>\n<td><code>ACCESS EXCLUSIVE</code>, <code>EXCLUSIVE</code></td>\n<td><code>ALTER TABLE</code>, <code>DROP INDEX</code></td>\n</tr>\n<tr>\n<td><code>ROW EXCLUSIVE</code></td>\n<td><code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code></td>\n<td><code>ACCESS EXCLUSIVE</code>, <code>EXCLUSIVE</code>, <code>SHARE ROW EXCLUSIVE</code>, <code>SHARE</code></td>\n<td><code>ALTER TABLE</code>, <code>DROP INDEX</code>, <code>CREATE INDEX</code></td>\n</tr></tbody></table>\n<p>So you can find that all django schema changes for exist table conflicts with business logic, but fortunately they are safe or has safe alternative in general.</p>\n<h3>Postgres row level locks</h3>\n<p>As business logic mostly works with table rows it's also important to understand lock conflicts on row level <a href=\"https://www.postgresql.org/docs/current/static/explicit-locking.html#LOCKING-ROWS\" rel=\"nofollow\">https://www.postgresql.org/docs/current/static/explicit-locking.html#LOCKING-ROWS</a>:</p>\n<table>\n<thead>\n<tr>\n<th>lock</th>\n<th align=\"center\"><code>FOR KEY SHARE</code></th>\n<th align=\"center\"><code>FOR SHARE</code></th>\n<th align=\"center\"><code>FOR NO KEY UPDATE</code></th>\n<th align=\"center\"><code>FOR UPDATE</code></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>FOR KEY SHARE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td><code>FOR SHARE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td><code>FOR NO KEY UPDATE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n</tr>\n<tr>\n<td><code>FOR UPDATE</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n<td align=\"center\">X</td>\n</tr></tbody></table>\n<p>Main point there is if you have two transactions that update one row, then second transaction will wait until first will be completed. So for business logic and data migrations better to avoid updates for whole table and use batch operations instead.</p>\n<blockquote>\n<p><em>NOTE:</em> batch operations also can work faster because postgres can use more optimal execution plan with indexes for small data range.</p>\n</blockquote>\n<h3>Transactions FIFO waiting</h3>\n<p><img alt=\"postgres FIFO\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/99fbab7c5ea4a726dd39bcdd72180b5a796f8f73/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f74626963722f646a616e676f2d70672d7a65726f2d646f776e74696d652d6d6967726174696f6e732f302e382f696d616765732f6669666f2d6469616772616d2e706e67\"></p>\n<p>Found same diagram in interesting article <a href=\"http://pankrat.github.io/2015/django-migrations-without-downtimes/\" rel=\"nofollow\">http://pankrat.github.io/2015/django-migrations-without-downtimes/</a>.</p>\n<p>In this diagram we can extract several metrics:</p>\n<ol>\n<li>operation time - time what you spend for schema change, so there is issue for long running operation on many rows tables like <code>CREATE INDEX</code> or <code>ALTER TABLE ADD COLUMN SET DEFAULT</code>, so you need use more save equivalents instead.</li>\n<li>waiting time - your migration will wait until all transactions will be completed, so there is issue for long running operations/transactions like analytic, so you need avoid it or disable on migration time.</li>\n<li>queries per second + execution time and connections pool - if you too many queries to table and this queries take long time then this queries can just take all available connections to database until wait for release lock, so look like you need different optimizations there: run migrations when load minimal, decrease queries count and execution time, split you data.</li>\n<li>too many operations in one transaction - you have issues in all previous points for one operation so if you have many operations in one transaction then you have more chances to get this issues, so you need avoid many operations in one transactions (or even don't run it in transactions at all but you should be more careful when some operation will fail).</li>\n</ol>\n<h3>Dealing with timeouts</h3>\n<p>Postgres has two settings to dealing with <code>waiting time</code> and <code>operation time</code> presented in diagram: <code>lock_timeout</code> and <code>statement_timeout</code>.</p>\n<p><code>SET lock_timeout TO '2s'</code> allow you to avoid downtime when you have long running query/transaction before run migration (<a href=\"https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-LOCK-TIMEOUT\" rel=\"nofollow\">https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-LOCK-TIMEOUT</a>).</p>\n<p><code>SET statement_timeout TO '2s'</code> allow you to avoid downtime when you have long running migration query (<a href=\"https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT\" rel=\"nofollow\">https://www.postgresql.org/docs/current/static/runtime-config-client.html#GUC-STATEMENT-TIMEOUT</a>).</p>\n<h3>Deadlocks</h3>\n<p>There no downtime issues for deadlocks, but too many operations in one transaction can take most conflicted lock and release it only after transaction commit or rollback. So it's a good idea to avoid <code>ACCESS EXCLUSIVE</code> lock operations and long time operations in one transaction. Deadlocks also can make you migration stuck on production deployment when different tables will be locked, for example, for FOREIGN KEY that take <code>ACCESS EXCLUSIVE</code> lock for two tables.</p>\n<h3>Rows and values storing</h3>\n<p>Postgres store values of different types different ways. If you try to convert one type to another and it stored different way then postgres will rewrite all values. Fortunately some types stored same way and postgres need to do nothing to change type, but in some cases postgres need to check that all values have same with new type limitations, for example string length.</p>\n<h3>Multiversion Concurrency Control</h3>\n<p>Regarding documentation <a href=\"https://www.postgresql.org/docs/current/static/mvcc-intro.html\" rel=\"nofollow\">https://www.postgresql.org/docs/current/static/mvcc-intro.html</a> data consistency in postgres is maintained by using a multiversion model. This means that each SQL statement sees a snapshot of data. It has advantage for adding and deleting columns without any indexes, constrains and defaults do not change exist data, new version of data will be created on <code>INSERT</code> and <code>UPDATE</code>, delete just mark you record expired. All garbage will be collected later by <code>VACUUM</code> or <code>AUTO VACUUM</code>.</p>\n<h3>Django migrations hacks</h3>\n<p>Any schema changes can be processed with creation of new table and copy data to it, but it can take significant time.</p>\n<table>\n<thead>\n<tr>\n<th align=\"right\">#</th>\n<th>name</th>\n<th align=\"center\">safe</th>\n<th align=\"center\">safe alternative</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"right\">1</td>\n<td><code>CREATE SEQUENCE</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation, because your business logic shouldn't operate with new sequence on migration time *</td>\n</tr>\n<tr>\n<td align=\"right\">2</td>\n<td><code>DROP SEQUENCE</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation, because your business logic shouldn't operate with this sequence on migration time *</td>\n</tr>\n<tr>\n<td align=\"right\">3</td>\n<td><code>CREATE TABLE</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation, because your business logic shouldn't operate with new table on migration time *</td>\n</tr>\n<tr>\n<td align=\"right\">4</td>\n<td><code>DROP TABLE</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation, because your business logic shouldn't operate with this table on migration time *</td>\n</tr>\n<tr>\n<td align=\"right\">5</td>\n<td><code>ALTER TABLE RENAME TO</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">add new table and copy data</td>\n<td><strong>unsafe operation</strong>, it's too hard write business logic that operate with two tables simultaneously, so propose <code>CREATE TABLE</code> and then copy all data to new table *</td>\n</tr>\n<tr>\n<td align=\"right\">6</td>\n<td><code>ALTER TABLE SET TABLESPACE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">add new table and copy data</td>\n<td><strong>unsafe operation</strong>, but probably you don't need it at all or often *</td>\n</tr>\n<tr>\n<td align=\"right\">7</td>\n<td><code>ALTER TABLE ADD COLUMN</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation if without <code>SET NOT NULL</code>, <code>SET DEFAULT</code>, <code>PRIMARY KEY</code>, <code>UNIQUE</code> *</td>\n</tr>\n<tr>\n<td align=\"right\">8</td>\n<td><code>ALTER TABLE ADD COLUMN SET DEFAULT</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">add column and set default</td>\n<td><strong>unsafe operation</strong>, because you spend time in migration to populate all values in table, so propose <code>ALTER TABLE ADD COLUMN</code> and then populate column and then <code>SET DEFAULT</code> *</td>\n</tr>\n<tr>\n<td align=\"right\">9</td>\n<td><code>ALTER TABLE ADD COLUMN SET NOT NULL</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">+/-</td>\n<td><strong>unsafe operation</strong>, because doesn't work without <code>SET DEFAULT</code> or after migration old code can insert rows without new column and raise exception, so propose <code>ALTER TABLE ADD COLUMN</code> and then populate column and then <code>ALTER TABLE ALTER COLUMN SET NOT NULL</code> * and **</td>\n</tr>\n<tr>\n<td align=\"right\">10</td>\n<td><code>ALTER TABLE ADD COLUMN PRIMARY KEY</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">add index and add constraint</td>\n<td><strong>unsafe operation</strong>, because you spend time in migration to <code>CREATE INDEX</code>, so propose <code>ALTER TABLE ADD COLUMN</code> and then <code>CREATE INDEX CONCURRENTLY</code> and then <code>ALTER TABLE ADD CONSTRAINT PRIMARY KEY USING INDEX</code> ***</td>\n</tr>\n<tr>\n<td align=\"right\">11</td>\n<td><code>ALTER TABLE ADD COLUMN UNIQUE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">add index and add constraint</td>\n<td><strong>unsafe operation</strong>, because you spend time in migration to <code>CREATE INDEX</code>, so propose <code>ALTER TABLE ADD COLUMN</code> and then <code>CREATE INDEX CONCURRENTLY</code> and then <code>ALTER TABLE ADD CONSTRAINT UNIQUE USING INDEX</code> ***</td>\n</tr>\n<tr>\n<td align=\"right\">12</td>\n<td><code>ALTER TABLE ALTER COLUMN TYPE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">+/-</td>\n<td><strong>unsafe operation</strong>, because you spend time in migration to check that all items in column valid or to change type, but some operations can be safe ****</td>\n</tr>\n<tr>\n<td align=\"right\">13</td>\n<td><code>ALTER TABLE ALTER COLUMN SET NOT NULL</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">+/-</td>\n<td><strong>unsafe operation</strong>, because you spend time in migration to check that all items in column <code>NOT NULL</code> **</td>\n</tr>\n<tr>\n<td align=\"right\">14</td>\n<td><code>ALTER TABLE ALTER COLUMN DROP NOT NULL</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation</td>\n</tr>\n<tr>\n<td align=\"right\">15</td>\n<td><code>ALTER TABLE ALTER COLUMN SET DEFAULT</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation</td>\n</tr>\n<tr>\n<td align=\"right\">16</td>\n<td><code>ALTER TABLE ALTER COLUMN DROP DEFAULT</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation</td>\n</tr>\n<tr>\n<td align=\"right\">17</td>\n<td><code>ALTER TABLE DROP COLUMN</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation, because you business logic shouldn't operate with this column on migration time, however better <code>ALTER TABLE ALTER COLUMN DROP NOT NULL</code>, <code>ALTER TABLE DROP CONSTRAINT</code> and <code>DROP INDEX</code> before * and *****</td>\n</tr>\n<tr>\n<td align=\"right\">18</td>\n<td><code>ALTER TABLE RENAME COLUMN</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">add new column and copy data</td>\n<td><strong>unsafe operation</strong>, it's too hard write business logic that operate with two columns simultaneously, so propose <code>ALTER TABLE CREATE COLUMN</code> and then copy all data to new column *</td>\n</tr>\n<tr>\n<td align=\"right\">19</td>\n<td><code>ALTER TABLE ADD CONSTRAINT CHECK</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">add as not valid and validate</td>\n<td><strong>unsafe operation</strong>, because you spend time in migration to check constraint</td>\n</tr>\n<tr>\n<td align=\"right\">20</td>\n<td><code>ALTER TABLE DROP CONSTRAINT</code> (<code>CHECK</code>)</td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation</td>\n</tr>\n<tr>\n<td align=\"right\">21</td>\n<td><code>ALTER TABLE ADD CONSTRAINT FOREIGN KEY</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">add as not valid and validate</td>\n<td><strong>unsafe operation</strong>, because you spend time in migration to check constraint, lock two tables</td>\n</tr>\n<tr>\n<td align=\"right\">22</td>\n<td><code>ALTER TABLE DROP CONSTRAINT</code> (<code>FOREIGN KEY</code>)</td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation, lock two tables</td>\n</tr>\n<tr>\n<td align=\"right\">23</td>\n<td><code>ALTER TABLE ADD CONSTRAINT PRIMARY KEY</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">add index and add constraint</td>\n<td><strong>unsafe operation</strong>, because you spend time in migration to create index ***</td>\n</tr>\n<tr>\n<td align=\"right\">24</td>\n<td><code>ALTER TABLE DROP CONSTRAINT</code> (<code>PRIMARY KEY</code>)</td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation ***</td>\n</tr>\n<tr>\n<td align=\"right\">25</td>\n<td><code>ALTER TABLE ADD CONSTRAINT UNIQUE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">add index and add constraint</td>\n<td><strong>unsafe operation</strong>, because you spend time in migration to create index ***</td>\n</tr>\n<tr>\n<td align=\"right\">26</td>\n<td><code>ALTER TABLE DROP CONSTRAINT</code> (<code>UNIQUE</code>)</td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation ***</td>\n</tr>\n<tr>\n<td align=\"right\">27</td>\n<td><code>ALTER TABLE ADD CONSTRAINT EXCLUDE</code></td>\n<td align=\"center\"></td>\n<td align=\"center\">add new table and copy data</td>\n<td></td>\n</tr>\n<tr>\n<td align=\"right\">28</td>\n<td><code>ALTER TABLE DROP CONSTRAINT (EXCLUDE)</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td></td>\n</tr>\n<tr>\n<td align=\"right\">29</td>\n<td><code>CREATE INDEX</code></td>\n<td align=\"center\"></td>\n<td align=\"center\"><code>CREATE INDEX CONCURRENTLY</code></td>\n<td><strong>unsafe operation</strong>, because you spend time in migration to create index</td>\n</tr>\n<tr>\n<td align=\"right\">30</td>\n<td><code>DROP INDEX</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"><code>DROP INDEX CONCURRENTLY</code></td>\n<td>safe operation  ***</td>\n</tr>\n<tr>\n<td align=\"right\">31</td>\n<td><code>CREATE INDEX CONCURRENTLY</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation</td>\n</tr>\n<tr>\n<td align=\"right\">32</td>\n<td><code>DROP INDEX CONCURRENTLY</code></td>\n<td align=\"center\">X</td>\n<td align=\"center\"></td>\n<td>safe operation  ***</td>\n</tr></tbody></table>\n<p>*: main point with migration on production without downtime that your code should correctly work before and after migration, lets look this point closely in <a href=\"#dealing-with-logic-that-should-work-before-and-after-migration\" rel=\"nofollow\">Dealing with logic that should work before and after migration</a> section.</p>\n<p>**: postgres will check that all items in column <code>NOT NULL</code> that take time, lets look this point closely in <a href=\"#dealing-with-not-null-constraint\" rel=\"nofollow\">Dealing with <code>NOT NULL</code> constraint</a> section.</p>\n<p>***: postgres will have same behaviour when you skip <code>ALTER TABLE ADD CONSTRAINT UNIQUE USING INDEX</code> and still unclear difference with <code>CONCURRENTLY</code> except difference in locks, lets look this point closely in <a href=\"#dealing-with-unique-constraint\" rel=\"nofollow\">Dealing with <code>UNIQUE</code> constraint</a>.</p>\n<p>****: lets look this point closely in <a href=\"#dealing-with-alter-table-alter-column-type\" rel=\"nofollow\">Dealing with <code>ALTER TABLE ALTER COLUMN TYPE</code></a> section.</p>\n<p>*****: if you check migration on CI with <code>python manage.py makemigrations --check</code> you can't drop column in code without migration creation, so in this case you can be useful <em>back migration flow</em>: apply code on all instances and then migrate database</p>\n<h4>Dealing with logic that should work before and after migration</h4>\n<h5>Adding and removing models and columns</h5>\n<p>Migrations: <code>CREATE SEQUENCE</code>, <code>DROP SEQUENCE</code>, <code>CREATE TABLE</code>, <code>DROP TABLE</code>, <code>ALTER TABLE ADD COLUMN</code>, <code>ALTER TABLE DROP COLUMN</code>.</p>\n<p>This migrations are pretty safe, because your logic doesn't work with this data before migration</p>\n<h5>Changes for working logic</h5>\n<p>Migrations: <code>ALTER TABLE RENAME TO</code>, <code>ALTER TABLE SET TABLESPACE</code>, <code>ALTER TABLE RENAME COLUMN</code>, <code>ALTER TABLE ADD CONSTRAINT EXCLUDE</code>.</p>\n<p>For this migration too hard implement logic that will work correctly for all instances, so there are two ways to dealing with it:</p>\n<ol>\n<li>create new table/column, copy exist data, drop old table/column</li>\n<li>downtime</li>\n</ol>\n<h5>Create column with default</h5>\n<p>Migrations: <code>ALTER TABLE ADD COLUMN SET DEFAULT</code>.</p>\n<p>Standard django's behaviour for creation column with default is populate all values with default. Django don't use database defaults permanently, so when you add new column with default django will create column with default and drop this default at once, eg. new default will come from django code. In this case you can have a gap when migration applied by not all instances has updated and at this moment new rows in table will be without default and probably you need update nullable values after that. So to avoid this case best way is avoid creation column with default and split column creation (with default for new rows) and data population to two migrations (with deployments).</p>\n<h4>Dealing with <code>NOT NULL</code> constraint</h4>\n<p>Postgres check that all column items <code>NOT NULL</code> when you applying <code>NOT NULL</code> constraint, for postgres 12 and newest it doesn't make this check if appropriate <code>CHECK CONSTRAINT</code> exists, but for older versions you can't defer this check as for <code>NOT VALID</code>. Fortunately we have some hacks and alternatives there for old postgres versions.</p>\n<ol>\n<li>Run migrations when load minimal to avoid negative affect of locking.</li>\n<li><code>SET statement_timeout</code> and try to set <code>NOT NULL</code> constraint for small tables.</li>\n<li>Use <code>CHECK (column IS NOT NULL)</code> constraint instead that support <code>NOT VALID</code> option with next <code>VALIDATE CONSTRAINT</code>, see article for details <a href=\"https://medium.com/doctolib-engineering/adding-a-not-null-constraint-on-pg-faster-with-minimal-locking-38b2c00c4d1c\" rel=\"nofollow\">https://medium.com/doctolib-engineering/adding-a-not-null-constraint-on-pg-faster-with-minimal-locking-38b2c00c4d1c</a>. There are additionally can be applied <code>NOT NULL</code> constraint via direct <code>pg_catalog.pg_attribute</code> <code>attnotnull</code> update, but it require superuser permissions.</li>\n</ol>\n<h4>Dealing with <code>UNIQUE</code> constraint</h4>\n<p>Postgres has two approaches for uniqueness: <code>CREATE UNIQUE INDEX</code> and <code>ALTER TABLE ADD CONSTRAINT UNIQUE</code> - both use unique index inside. Difference that we can find that we cannot apply <code>DROP INDEX CONCURRENTLY</code> for constraint. However it still unclear what difference for <code>DROP INDEX</code> and <code>DROP INDEX CONCURRENTLY</code> except difference in locks, but as we seen before both marked as safe - we don't spend time in <code>DROP INDEX</code>, just wait for lock. So as django use constraint for uniqueness we also have a hacks to use constraint safely.</p>\n<h4>Dealing with <code>ALTER TABLE ALTER COLUMN TYPE</code></h4>\n<p>Next operations are safe:</p>\n<ol>\n<li><code>varchar(LESS)</code> to <code>varchar(MORE)</code> where LESS &lt; MORE</li>\n<li><code>varchar(ANY)</code> to <code>text</code></li>\n<li><code>numeric(LESS, SAME)</code> to <code>numeric(MORE, SAME)</code> where LESS &lt; MORE and SAME == SAME</li>\n</ol>\n<p>For other operations propose to create new column and copy data to it. Eg. some types can be also safe, but you should check yourself.</p>\n<h1>django-pg-zero-downtime-migrations changelog</h1>\n<h2>0.8</h2>\n<ul>\n<li>added django 3.0 support</li>\n<li>added concurrently index creation and removal operations</li>\n<li>added exclude constraint support as unsafe operation</li>\n<li>drop postgres 9.4 support</li>\n<li>drop django 2.0 support</li>\n<li>drop django 2.1 support</li>\n<li>drop deprecated <code>django_zero_downtime_migrations_postgres_backend</code> module</li>\n</ul>\n<h2>0.7</h2>\n<ul>\n<li>added python 3.8 support</li>\n<li>added postgres specific indexes support</li>\n<li>improved tests clearness</li>\n<li>fixed regexp escaping warning for management command</li>\n<li>fixed style check</li>\n<li>improved README</li>\n<li>marked python 3.5 support deprecated</li>\n<li>marked postgres 9.4 support deprecated</li>\n<li>marked django 2.0 support deprecated</li>\n<li>marked django 2.1 support deprecated</li>\n</ul>\n<h2>0.6</h2>\n<ul>\n<li>marked <code>ZERO_DOWNTIME_MIGRATIONS_USE_NOT_NULL</code> option deprecated for postgres 12+</li>\n<li>added management command for migration to real <code>NOT NULL</code> from <code>CHECK IS NOT NULL</code> constraint</li>\n<li>added integration tests for pg 12, pg 11 root, pg 11 compatible not null constraint, pg 11 standard not null constraint and pg 10, 9.6, 9.5, 9.4, postgis databases</li>\n<li>fixed compatible check not null constraint deletion and creation via pg_attribute bugs</li>\n<li>minimized side affect with deferred sql execution between operations in one migration module</li>\n<li>added postgres 12 safe <code>NOT NULL</code> constraint creation</li>\n<li>added safe <code>NOT NULL</code> constraint creation for extra permissions for <code>pg_catalog.pg_attribute</code> with <code>ZERO_DOWNTIME_MIGRATIONS_USE_NOT_NULL=USE_PG_ATTRIBUTE_UPDATE_FOR_SUPERUSER</code> option enabled</li>\n<li>marked <code>AddField</code> with <code>null=False</code> parameter and compatible <code>CHECK IS NOT NULL</code> constraint option as unsafe operation and avoid <code>ZERO_DOWNTIME_MIGRATIONS_USE_NOT_NULL</code> value in this case</li>\n<li>added version to package</li>\n<li>fixed pypi README images links</li>\n<li>improved README</li>\n</ul>\n<h2>0.5</h2>\n<ul>\n<li>extracted zero-downtime-schema to mixin to allow use this logic with other backends</li>\n<li>moved module from <code>django_zero_downtime_migrations_postgres_backend</code> to <code>django_zero_downtime_migrations.backends.postgres</code></li>\n<li>marked <code>django_zero_downtime_migrations_postgres_backend</code> module as deprecated</li>\n<li>added postgis backend support</li>\n<li>improved README</li>\n</ul>\n<h2>0.4</h2>\n<ul>\n<li>changed defaults for <code>ZERO_DOWNTIME_MIGRATIONS_LOCK_TIMEOUT</code> and <code>ZERO_DOWNTIME_MIGRATIONS_STATEMENT_TIMEOUT</code> from <code>0ms</code> to <code>None</code> to get same with default django behavior that respect default postgres timeouts</li>\n<li>added updates to documentations with options defaults</li>\n<li>added updates to documentations with best options usage</li>\n<li>fixed adding nullable field with default had no error and warning issue</li>\n<li>added links to documentation with issue describing and safe alternatives usage for errors and warnings</li>\n<li>added updates to documentations with type casting workarounds</li>\n</ul>\n<h2>0.3</h2>\n<ul>\n<li>added django 2.2 support with <code>Meta.indexes</code> and <code>Meta.constraints</code> attributes</li>\n<li>fixed python deprecation warnings for regexp</li>\n<li>removed unused <code>TimeoutException</code></li>\n<li>improved README and PYPI description</li>\n</ul>\n<h2>0.2</h2>\n<ul>\n<li>added option that allow disable <code>statement_timeout</code> for long operations like index creation on constraint validation when statement_timeout set globally</li>\n</ul>\n<h2>0.1.1</h2>\n<ul>\n<li>added long description content type</li>\n</ul>\n<h2>0.1</h2>\n<ul>\n<li>replaced default sql queries with more safe</li>\n<li>added options for <code>statement_timeout</code> and <code>lock_timeout</code></li>\n<li>added option for <code>NOT NULL</code> constraint behaviour</li>\n<li>added option for unsafe operation restriction</li>\n</ul>\n\n          </div>"}, "last_serial": 6277657, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "e6d12bb695aedc2d93a8f48e0de0857c", "sha256": "9dc287d5aa345e35acc921ec2c545a9b91ad69d029028e70b8dfc098f49f9722"}, "downloads": -1, "filename": "django_pg_zero_downtime_migrations-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "e6d12bb695aedc2d93a8f48e0de0857c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 16951, "upload_time": "2018-08-22T20:39:35", "upload_time_iso_8601": "2018-08-22T20:39:35.570657Z", "url": "https://files.pythonhosted.org/packages/23/31/bbc6a17b567c67afb171ec6fd162b936979d557a731b3d5b08c471355f7e/django_pg_zero_downtime_migrations-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a91aa66e2fc08c84aa7d97fb8cda45db", "sha256": "1a028520471f871b284e301f35e7a936a8c601a3fb010e6136077fcc874123c7"}, "downloads": -1, "filename": "django-pg-zero-downtime-migrations-0.1.tar.gz", "has_sig": false, "md5_digest": "a91aa66e2fc08c84aa7d97fb8cda45db", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 18864, "upload_time": "2018-08-22T20:39:37", "upload_time_iso_8601": "2018-08-22T20:39:37.276214Z", "url": "https://files.pythonhosted.org/packages/dc/cc/d481de21adddbbc61a85c1820b9675af9c79f1c84e92019534e4b8800715/django-pg-zero-downtime-migrations-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "a86c870301827670f5e19fc3ddf74233", "sha256": "790e65f8b5f16529a1e4e7d5e12c46a5ee89d6fbe0ea8334df5eda8f0178a453"}, "downloads": -1, "filename": "django_pg_zero_downtime_migrations-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "a86c870301827670f5e19fc3ddf74233", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 16981, "upload_time": "2018-08-22T20:42:47", "upload_time_iso_8601": "2018-08-22T20:42:47.249384Z", "url": "https://files.pythonhosted.org/packages/c6/f6/c1a6932795871b22f9fcf6fe8c7a0b7278b5dc697b01cdf39d5b78ea7df2/django_pg_zero_downtime_migrations-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "edbf37b757d9a43c42f889ceb4c38b1a", "sha256": "6f4d62d648b3c75a2bba5427e089782f3f7af30459fb2bc19638bc39eae17886"}, "downloads": -1, "filename": "django-pg-zero-downtime-migrations-0.1.1.tar.gz", "has_sig": false, "md5_digest": "edbf37b757d9a43c42f889ceb4c38b1a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 18899, "upload_time": "2018-08-22T20:42:49", "upload_time_iso_8601": "2018-08-22T20:42:49.802722Z", "url": "https://files.pythonhosted.org/packages/ce/1f/4a2164f62784076aacfbd184b43b7543c4995e2960ac0ae92e8550ab830e/django-pg-zero-downtime-migrations-0.1.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "63b0be71ce74c61167267eb0c61ef780", "sha256": "347b496f7a141020c221faf2fe6d0b06aa4c97d984c39c53e17d259b7633d196"}, "downloads": -1, "filename": "django_pg_zero_downtime_migrations-0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "63b0be71ce74c61167267eb0c61ef780", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 17820, "upload_time": "2018-09-01T20:30:47", "upload_time_iso_8601": "2018-09-01T20:30:47.992460Z", "url": "https://files.pythonhosted.org/packages/63/0c/c431ec21d5e11024fd1bc0092e52d6c3c1591cf9dff6b014674eca52ee19/django_pg_zero_downtime_migrations-0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8c3b02afea7a140f2012a343f6b7e655", "sha256": "59dcc5404acf52fb667fe1dee9d6ddc1253cbf9fccd026f892eaef7c680ad733"}, "downloads": -1, "filename": "django-pg-zero-downtime-migrations-0.2.tar.gz", "has_sig": false, "md5_digest": "8c3b02afea7a140f2012a343f6b7e655", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 19999, "upload_time": "2018-09-01T20:30:49", "upload_time_iso_8601": "2018-09-01T20:30:49.732665Z", "url": "https://files.pythonhosted.org/packages/6b/fa/953bcd77c5a2a7ae2df546e9b92b41653a16b28ed6987f185506a1f14010/django-pg-zero-downtime-migrations-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "6820e347b2743c509897c631a5bab735", "sha256": "b7b90545477b65e6f8c3a098af091828e968d54cafe2d270fe84a1e85382f6b8"}, "downloads": -1, "filename": "django_pg_zero_downtime_migrations-0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "6820e347b2743c509897c631a5bab735", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 13691, "upload_time": "2019-04-01T19:21:00", "upload_time_iso_8601": "2019-04-01T19:21:00.263665Z", "url": "https://files.pythonhosted.org/packages/0a/23/41a2d69f6a2d54688f1a5f87f0d99495f0895fd9ee4720eb5ad255626330/django_pg_zero_downtime_migrations-0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "301224bd610554f23624a0128585c4b9", "sha256": "6921026b4fcff862e7a56452c9f17f0ad698cb1d727d38d55bd830c37b96e168"}, "downloads": -1, "filename": "django-pg-zero-downtime-migrations-0.3.tar.gz", "has_sig": false, "md5_digest": "301224bd610554f23624a0128585c4b9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 19840, "upload_time": "2019-04-01T19:21:01", "upload_time_iso_8601": "2019-04-01T19:21:01.677006Z", "url": "https://files.pythonhosted.org/packages/9c/9e/4db581800b02395e0a5ba7ab9fcbcb02d1c02a00c38e53c8d58a95d8fdbf/django-pg-zero-downtime-migrations-0.3.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "92f712e466621e5e9df2d8b78d8cc461", "sha256": "e0a916103c2c9441a8f2f176e541eb0abc176402d42340bb0cde9d818ddd3c89"}, "downloads": -1, "filename": "django_pg_zero_downtime_migrations-0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "92f712e466621e5e9df2d8b78d8cc461", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 14144, "upload_time": "2019-05-05T00:34:43", "upload_time_iso_8601": "2019-05-05T00:34:43.588025Z", "url": "https://files.pythonhosted.org/packages/6a/9b/367d8f01c765ce1e3ea3156ab4ab041c4ec0dcb8dac2de294bfc250394c3/django_pg_zero_downtime_migrations-0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4b0c324046ace9b0ac489c130ba8f537", "sha256": "036375b166ab19fa80c3858602a6dba9e509b514424f455ca1ed63a308408d0d"}, "downloads": -1, "filename": "django-pg-zero-downtime-migrations-0.4.tar.gz", "has_sig": false, "md5_digest": "4b0c324046ace9b0ac489c130ba8f537", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 20919, "upload_time": "2019-05-05T00:34:45", "upload_time_iso_8601": "2019-05-05T00:34:45.737322Z", "url": "https://files.pythonhosted.org/packages/8f/8b/abedae9f39927e6c426b850b6b7bee155f08d86ae801c1a29866df5f50b6/django-pg-zero-downtime-migrations-0.4.tar.gz", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "e0df990266f933dabb3cee2ccaeac89d", "sha256": "9d0865efdc7f716f80a6d19bcba5867f259044936c4ce456d12d6dfaed2ae4b1"}, "downloads": -1, "filename": "django_pg_zero_downtime_migrations-0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "e0df990266f933dabb3cee2ccaeac89d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 16646, "upload_time": "2019-06-01T22:18:07", "upload_time_iso_8601": "2019-06-01T22:18:07.141315Z", "url": "https://files.pythonhosted.org/packages/dc/06/b0b8a6d05e1d249c99cfb44c1e2c81940d9fe9c5a12848eb371dc58e6231/django_pg_zero_downtime_migrations-0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "38c55b356dadb739b749a1fb14468ebc", "sha256": "82a71f8faf8fcf3b03c53018177b9d46d56efd8631bb178d624784dd9df3e436"}, "downloads": -1, "filename": "django-pg-zero-downtime-migrations-0.5.tar.gz", "has_sig": false, "md5_digest": "38c55b356dadb739b749a1fb14468ebc", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 21955, "upload_time": "2019-06-01T22:18:11", "upload_time_iso_8601": "2019-06-01T22:18:11.003696Z", "url": "https://files.pythonhosted.org/packages/ae/36/adad0db67e9fb3a5bfdfdccb97da3b868b5663ebe46aef8f873e1d0731a6/django-pg-zero-downtime-migrations-0.5.tar.gz", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "a2a57f83219cb29f0b3364b480d0cbab", "sha256": "e82c12b6e8154d30d5e3641d350defdb0247b22fc93f9beda4bafee2129c2db0"}, "downloads": -1, "filename": "django_pg_zero_downtime_migrations-0.6-py3-none-any.whl", "has_sig": false, "md5_digest": "a2a57f83219cb29f0b3364b480d0cbab", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 20894, "upload_time": "2019-09-24T23:53:44", "upload_time_iso_8601": "2019-09-24T23:53:44.286781Z", "url": "https://files.pythonhosted.org/packages/1f/f6/fd48893f17cf12e27ba7818316a0f2deda060d381c03a015b17b449dbef4/django_pg_zero_downtime_migrations-0.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fa6be31a88e35a254966a35d565577d8", "sha256": "028c6559aac18ebae77e9c6810dda1dffecb53b98f1927e11779ad1211e5aac8"}, "downloads": -1, "filename": "django-pg-zero-downtime-migrations-0.6.tar.gz", "has_sig": false, "md5_digest": "fa6be31a88e35a254966a35d565577d8", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 25432, "upload_time": "2019-09-24T23:53:46", "upload_time_iso_8601": "2019-09-24T23:53:46.694809Z", "url": "https://files.pythonhosted.org/packages/ee/e6/7c36c693b0bdcc461f114e92b2a913bfd9d5c754f6b7e8507276dfaecb47/django-pg-zero-downtime-migrations-0.6.tar.gz", "yanked": false}], "0.7": [{"comment_text": "", "digests": {"md5": "b25e638f2d864f67d87ec86a98c45c0f", "sha256": "e3d9828104e7ec19ce2a1efb6f5f4ae91fda7d29a981d4163ba91a990bf2f632"}, "downloads": -1, "filename": "django_pg_zero_downtime_migrations-0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "b25e638f2d864f67d87ec86a98c45c0f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 20995, "upload_time": "2019-12-02T19:40:06", "upload_time_iso_8601": "2019-12-02T19:40:06.963268Z", "url": "https://files.pythonhosted.org/packages/89/d1/4110567a42402a827badc99f16045a1b67d5ce59c92197ccafe4ed239ead/django_pg_zero_downtime_migrations-0.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fe667553e35a696370f39aa76b78fd11", "sha256": "2e03af739bb3caa45b629a2988f8997a3ac5e5349b15e5b195fcae29668fa955"}, "downloads": -1, "filename": "django-pg-zero-downtime-migrations-0.7.tar.gz", "has_sig": false, "md5_digest": "fe667553e35a696370f39aa76b78fd11", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 26570, "upload_time": "2019-12-02T19:40:09", "upload_time_iso_8601": "2019-12-02T19:40:09.202390Z", "url": "https://files.pythonhosted.org/packages/a2/f5/12fed78b2fa41c7df6a4fe13eddcb4812ffff8eaa8cc2fec90b3b4a09d79/django-pg-zero-downtime-migrations-0.7.tar.gz", "yanked": false}], "0.8": [{"comment_text": "", "digests": {"md5": "41c34d3977e8706b752f5271c5a1b868", "sha256": "1c44541fae885d363d020cec80e4d072ebc1899e42250529fe3ce870df5b0577"}, "downloads": -1, "filename": "django_pg_zero_downtime_migrations-0.8-py3-none-any.whl", "has_sig": false, "md5_digest": "41c34d3977e8706b752f5271c5a1b868", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 20889, "upload_time": "2019-12-11T07:19:24", "upload_time_iso_8601": "2019-12-11T07:19:24.142880Z", "url": "https://files.pythonhosted.org/packages/63/52/77bfdf3de3a364c9f60a4329efcfe415531e0741bd4b59c26d999c57e780/django_pg_zero_downtime_migrations-0.8-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "efe1c2ebae34380a2249be1b3d182e92", "sha256": "b67a8a2824ad9b460a2568be430c7b0db79fb2ce13dfaffa7b9afddcaee3eaf6"}, "downloads": -1, "filename": "django-pg-zero-downtime-migrations-0.8.tar.gz", "has_sig": false, "md5_digest": "efe1c2ebae34380a2249be1b3d182e92", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 25542, "upload_time": "2019-12-11T07:19:30", "upload_time_iso_8601": "2019-12-11T07:19:30.793910Z", "url": "https://files.pythonhosted.org/packages/5d/93/8c76dcf429fff19c30202d3044aa03f683616625ef1ced7238e73d50fd19/django-pg-zero-downtime-migrations-0.8.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "41c34d3977e8706b752f5271c5a1b868", "sha256": "1c44541fae885d363d020cec80e4d072ebc1899e42250529fe3ce870df5b0577"}, "downloads": -1, "filename": "django_pg_zero_downtime_migrations-0.8-py3-none-any.whl", "has_sig": false, "md5_digest": "41c34d3977e8706b752f5271c5a1b868", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 20889, "upload_time": "2019-12-11T07:19:24", "upload_time_iso_8601": "2019-12-11T07:19:24.142880Z", "url": "https://files.pythonhosted.org/packages/63/52/77bfdf3de3a364c9f60a4329efcfe415531e0741bd4b59c26d999c57e780/django_pg_zero_downtime_migrations-0.8-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "efe1c2ebae34380a2249be1b3d182e92", "sha256": "b67a8a2824ad9b460a2568be430c7b0db79fb2ce13dfaffa7b9afddcaee3eaf6"}, "downloads": -1, "filename": "django-pg-zero-downtime-migrations-0.8.tar.gz", "has_sig": false, "md5_digest": "efe1c2ebae34380a2249be1b3d182e92", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 25542, "upload_time": "2019-12-11T07:19:30", "upload_time_iso_8601": "2019-12-11T07:19:30.793910Z", "url": "https://files.pythonhosted.org/packages/5d/93/8c76dcf429fff19c30202d3044aa03f683616625ef1ced7238e73d50fd19/django-pg-zero-downtime-migrations-0.8.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:55:03 2020"}