{"info": {"author": "Wojciech Bana\u015b", "author_email": "fizista+umqtt.simple2@gmail.com", "bugtrack_url": null, "classifiers": ["Programming Language :: Python :: Implementation :: MicroPython"], "description": ".. role:: bash(code)\n   :language: bash\n\n.. role:: python(code)\n   :language: python\n\numqtt.simple2\n=============\n\numqtt.simple2 is a MQTT client for MicroPython. (Note that it uses some\nMicroPython shortcuts and doesn't work with CPython).\n\nSupport MQTT Version 3.1.1 only.\n\nIt certainly works with micropython ports: esp8266 and esp32. It should also\nwork with other ports, but the library was not tested under other ports.\n\nMQTT client with more features\n------------------------------\n\nThere's a separate `umqtt.robust2` ( https://github.com/fizista/micropython-umqtt.robust2 ) module which builds\non `umqtt.simple2` adds the ability to reconnect.\nIt is able to send unsent messages itself. And many more...\n\nDifferences between umqtt.simple and umqtt.simple2\n--------------------------------------------------\n* When sending messages from QoS=1, there is no problem with \"suspending\"\n  the script while waiting for confirmation of message receipt by the server.\n* When subscribing to a channel, there is no problem with \"suspending\"\n  the script while waiting for confirmation of the subscription by the server.\n* Information about receiving or failing to receive a message from QoS=1 or subscription\n  can only be received by registering a callback using the :python:`set_callback_status()` method.\n* Currently, the module informs about errors in more detailed way. See the umqtt/errno.py file.\n* The application should also not hang up when using :python:`check_msg()`\n* The code compiled for MPY files, is about 30% larger than the original one.\n  So this library has gained more functionality (maybe reliability),\n  but this was done at the expense of the amount of code.\n\nHow and where to install this code?\n-----------------------------------\nYou can install using the upip:\n\n.. code-block:: python\n\n    import upip\n    upip.install(\"micropython-umqtt.simple2\")\n\nor\n\n.. code-block:: bash\n\n    micropython -m upip install -p modules micropython-umqtt.simple2\n\n\nYou can also clone this repository, and install it manually:\n\n.. code-block:: bash\n\n    git clone https://github.com/fizista/micropython-umqtt.simple2.git\n\nManual installation gives you more possibilities:\n\n* You can compile this library into MPY files using the :bash:`compile.sh` script.\n* You can remove comments from the code with the command: :bash:`python setup.py minify`\n* You can of course copy the code as it is, if you don't mind.\n\n**Please note that the PyPi repositories contain optimized code (no comments).**\n\nDesign requirements\n-------------------\n\n* Memory efficiency.\n* Avoid infamous design anti-patterns like \"callback hell\".\n* Support for both publishing and subscription via a single client\n  object (another alternative would be to have separate client classes\n  for publishing and subscription).\n\nAPI design\n----------\n\nBased on the requirements above, there are following API traits:\n\n* All data related to MQTT messages is encoded as bytes. This includes\n  both message content AND topic names (even though MQTT spec states\n  that topic name is UTF-8 encoded). The reason for this is simple:\n  what is received over network socket is binary data (bytes) and\n  it would require extra step to convert that to a string, spending\n  memory on that. Note that this applies only to topic names (because\n  they can be both sent and received). Other parameters specified by\n  MQTT as UTF-8 encoded (e.g. ClientID) are accepted as strings.\n* Subscribed messages are delivered via a callback. This is to avoid\n  using a queue for subscribed messages, as otherwise they may be\n  received at any time (including when client expects other type\n  of server response, so there're 2 choices: either deliver them\n  immediately via a callback or queue up until an \"expected\" response\n  arrives). Note that lack of need for a queue is delusive: the\n  runtime call stack forms an implicit queue in this case. And unlike\n  explicit queue, it's much harder to control. This design was chosen\n  because in a common case of processing subscribed messages it's\n  the most efficient. However, if in subscription callback, new\n  messages of QoS>0 are published, this may lead to deep, or\n  infinite recursion (the latter means an application will terminate\n  with :python:`RuntimeException`).\n\nAPI reference\n-------------\n\nTaking into account API traits described above, umqtt pretty closely\nfollows MQTT control operations, and maps them to class methods:\n\n* ``connect(...)`` - Connect to a server. Returns True if this connection\n  uses persisten session stored on a server (this will be always False if\n  clean_session=True argument is used (default)).\n* ``disconnect()`` - Disconnect from a server, release resources.\n* ``ping()`` - Ping server (response is processed automatically by wait_msg()).\n* ``publish()`` - Publish a message.\n* ``subscribe()`` - Subscribe to a topic.\n* ``set_callback()`` - Set callback for received subscription messages. call(topic, msg, retained)\n* ``set_callback_status()`` - Set callback for received subscription messages. call(pid, status)\n* ``set_last_will()`` - Set MQTT \"last will\" message. Should be called\n  *before* connect().\n* ``wait_msg()`` - Wait for a server message. A subscription message will be\n  delivered to a callback set with set_callback(), any other messages\n  will be processed internally.\n* ``check_msg()`` - Check if there's pending message from server. If yes,\n  process the same way as wait_msg(), if not, return immediately.\n\n``wait_msg()`` and ``check_msg()`` are \"main loop iteration\" methods, blocking\nand non-blocking version. They should be called periodically in a loop,\n``wait_msg()`` if you don't have any other foreground tasks to perform\n(i.e. your app just reacts to subscribed MQTT messages), ``check_msg()``\nif you process other foreground tasks too.\n\nNote that you don't need to call ``wait_msg()``/``check_msg()`` if you only\npublish messages with QoS==0, never subscribe to them.\n\nIf you are using a subscription and/or sending QoS>0 messages, you must run one of these\ncommands ( ``wait_msg()`` or ``check_msg()`` ).\n\n**For more detailed information about API please see the source code\n(which is quite short and easy to review) and provided examples.**\n\n\nSupported MQTT features\n-----------------------\n\nQoS 0 and 1 are supported for both publish and subscribe. QoS2 isn't\nsupported to keep code size small. Besides ClientID, only \"clean\nsession\" parameter is supported for connect as of now.\n\nSimple library testing\n----------------------\nThe current tests are not only to test the code, but also to check it in a real environment. Therefore, a good idea,\nbefore we use this library in our own project, is to test its operation with the MQTT broker.\n\nTo test if the library works well with your device and MQTT broker,\nuse the TestMQTT class from the `tests.py` module.\n\nIf you don't have your own MQTT broker yet, you can use the free MQTT test broker (test.mosquitto.org).\n\nThere is also a sample file `main.py`(`example_test_main.py`),\nIn this file we add only network configuration. Upload this file to your device with `umqtt.simple2`\nlibrary and `tests.py` module. Then reset the device and watch the results in the console.\n\nDifferent problems\n------------------\n* Wrong topic format during subscription - you'll get `OSError: [Errno 104] ECONNRESET` in subscribe()\n  or `MQTTException: 1` in the `wait_msg()/check_msg()`\n\nAdditional resources\n--------------------\n* https://mosquitto.org/ - Eclipse Mosquitto is an open source  message broker that implements the MQTT protocol.\n* https://test.mosquitto.org/ - MQTT test server\n* http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html - MQTT 3.1.1 specyfication\n* https://flespi.com/tools/mqtt-board - An open-source MQTT client tool for easy MQTT pub/sub, testing, and demonstration.\n* https://github.com/wialon/gmqtt - Python MQTT client implementation(not for the micropython)\n* https://www.hivemq.com/mqtt-essentials/ - Blog with explanation of MQTT specifications\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/fizista/micropython-umqtt.simple2", "keywords": "mqtt micropython", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "micropython-umqtt.simple2", "package_url": "https://pypi.org/project/micropython-umqtt.simple2/", "platform": "", "project_url": "https://pypi.org/project/micropython-umqtt.simple2/", "project_urls": {"Homepage": "https://github.com/fizista/micropython-umqtt.simple2"}, "release_url": "https://pypi.org/project/micropython-umqtt.simple2/2.0.4/", "requires_dist": null, "requires_python": "", "summary": "MQTT client for MicroPython.", "version": "2.0.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>umqtt.simple2 is a MQTT client for MicroPython. (Note that it uses some\nMicroPython shortcuts and doesn\u2019t work with CPython).</p>\n<p>Support MQTT Version 3.1.1 only.</p>\n<p>It certainly works with micropython ports: esp8266 and esp32. It should also\nwork with other ports, but the library was not tested under other ports.</p>\n<div id=\"mqtt-client-with-more-features\">\n<h2>MQTT client with more features</h2>\n<p>There\u2019s a separate <cite>umqtt.robust2</cite> ( <a href=\"https://github.com/fizista/micropython-umqtt.robust2\" rel=\"nofollow\">https://github.com/fizista/micropython-umqtt.robust2</a> ) module which builds\non <cite>umqtt.simple2</cite> adds the ability to reconnect.\nIt is able to send unsent messages itself. And many more\u2026</p>\n</div>\n<div id=\"differences-between-umqtt-simple-and-umqtt-simple2\">\n<h2>Differences between umqtt.simple and umqtt.simple2</h2>\n<ul>\n<li>When sending messages from QoS=1, there is no problem with \u201csuspending\u201d\nthe script while waiting for confirmation of message receipt by the server.</li>\n<li>When subscribing to a channel, there is no problem with \u201csuspending\u201d\nthe script while waiting for confirmation of the subscription by the server.</li>\n<li>Information about receiving or failing to receive a message from QoS=1 or subscription\ncan only be received by registering a callback using the <code class=\"python\"><span class=\"n\">set_callback_status</span><span class=\"p\">()</span></code> method.</li>\n<li>Currently, the module informs about errors in more detailed way. See the umqtt/errno.py file.</li>\n<li>The application should also not hang up when using <code class=\"python\"><span class=\"n\">check_msg</span><span class=\"p\">()</span></code></li>\n<li>The code compiled for MPY files, is about 30% larger than the original one.\nSo this library has gained more functionality (maybe reliability),\nbut this was done at the expense of the amount of code.</li>\n</ul>\n</div>\n<div id=\"how-and-where-to-install-this-code\">\n<h2>How and where to install this code?</h2>\n<p>You can install using the upip:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">upip</span>\n<span class=\"n\">upip</span><span class=\"o\">.</span><span class=\"n\">install</span><span class=\"p\">(</span><span class=\"s2\">\"micropython-umqtt.simple2\"</span><span class=\"p\">)</span>\n</pre>\n<p>or</p>\n<pre>micropython -m upip install -p modules micropython-umqtt.simple2\n</pre>\n<p>You can also clone this repository, and install it manually:</p>\n<pre>git clone https://github.com/fizista/micropython-umqtt.simple2.git\n</pre>\n<p>Manual installation gives you more possibilities:</p>\n<ul>\n<li>You can compile this library into MPY files using the <code class=\"bash\">compile.sh</code> script.</li>\n<li>You can remove comments from the code with the command: <code class=\"bash\">python setup.py minify</code></li>\n<li>You can of course copy the code as it is, if you don\u2019t mind.</li>\n</ul>\n<p><strong>Please note that the PyPi repositories contain optimized code (no comments).</strong></p>\n</div>\n<div id=\"design-requirements\">\n<h2>Design requirements</h2>\n<ul>\n<li>Memory efficiency.</li>\n<li>Avoid infamous design anti-patterns like \u201ccallback hell\u201d.</li>\n<li>Support for both publishing and subscription via a single client\nobject (another alternative would be to have separate client classes\nfor publishing and subscription).</li>\n</ul>\n</div>\n<div id=\"api-design\">\n<h2>API design</h2>\n<p>Based on the requirements above, there are following API traits:</p>\n<ul>\n<li>All data related to MQTT messages is encoded as bytes. This includes\nboth message content AND topic names (even though MQTT spec states\nthat topic name is UTF-8 encoded). The reason for this is simple:\nwhat is received over network socket is binary data (bytes) and\nit would require extra step to convert that to a string, spending\nmemory on that. Note that this applies only to topic names (because\nthey can be both sent and received). Other parameters specified by\nMQTT as UTF-8 encoded (e.g. ClientID) are accepted as strings.</li>\n<li>Subscribed messages are delivered via a callback. This is to avoid\nusing a queue for subscribed messages, as otherwise they may be\nreceived at any time (including when client expects other type\nof server response, so there\u2019re 2 choices: either deliver them\nimmediately via a callback or queue up until an \u201cexpected\u201d response\narrives). Note that lack of need for a queue is delusive: the\nruntime call stack forms an implicit queue in this case. And unlike\nexplicit queue, it\u2019s much harder to control. This design was chosen\nbecause in a common case of processing subscribed messages it\u2019s\nthe most efficient. However, if in subscription callback, new\nmessages of QoS&gt;0 are published, this may lead to deep, or\ninfinite recursion (the latter means an application will terminate\nwith <code class=\"python\"><span class=\"n\">RuntimeException</span></code>).</li>\n</ul>\n</div>\n<div id=\"api-reference\">\n<h2>API reference</h2>\n<p>Taking into account API traits described above, umqtt pretty closely\nfollows MQTT control operations, and maps them to class methods:</p>\n<ul>\n<li><tt><span class=\"pre\">connect(...)</span></tt> - Connect to a server. Returns True if this connection\nuses persisten session stored on a server (this will be always False if\nclean_session=True argument is used (default)).</li>\n<li><tt>disconnect()</tt> - Disconnect from a server, release resources.</li>\n<li><tt>ping()</tt> - Ping server (response is processed automatically by wait_msg()).</li>\n<li><tt>publish()</tt> - Publish a message.</li>\n<li><tt>subscribe()</tt> - Subscribe to a topic.</li>\n<li><tt>set_callback()</tt> - Set callback for received subscription messages. call(topic, msg, retained)</li>\n<li><tt>set_callback_status()</tt> - Set callback for received subscription messages. call(pid, status)</li>\n<li><tt>set_last_will()</tt> - Set MQTT \u201clast will\u201d message. Should be called\n<em>before</em> connect().</li>\n<li><tt>wait_msg()</tt> - Wait for a server message. A subscription message will be\ndelivered to a callback set with set_callback(), any other messages\nwill be processed internally.</li>\n<li><tt>check_msg()</tt> - Check if there\u2019s pending message from server. If yes,\nprocess the same way as wait_msg(), if not, return immediately.</li>\n</ul>\n<p><tt>wait_msg()</tt> and <tt>check_msg()</tt> are \u201cmain loop iteration\u201d methods, blocking\nand non-blocking version. They should be called periodically in a loop,\n<tt>wait_msg()</tt> if you don\u2019t have any other foreground tasks to perform\n(i.e. your app just reacts to subscribed MQTT messages), <tt>check_msg()</tt>\nif you process other foreground tasks too.</p>\n<p>Note that you don\u2019t need to call <tt>wait_msg()</tt>/<tt>check_msg()</tt> if you only\npublish messages with QoS==0, never subscribe to them.</p>\n<p>If you are using a subscription and/or sending QoS&gt;0 messages, you must run one of these\ncommands ( <tt>wait_msg()</tt> or <tt>check_msg()</tt> ).</p>\n<p><strong>For more detailed information about API please see the source code\n(which is quite short and easy to review) and provided examples.</strong></p>\n</div>\n<div id=\"supported-mqtt-features\">\n<h2>Supported MQTT features</h2>\n<p>QoS 0 and 1 are supported for both publish and subscribe. QoS2 isn\u2019t\nsupported to keep code size small. Besides ClientID, only \u201cclean\nsession\u201d parameter is supported for connect as of now.</p>\n</div>\n<div id=\"simple-library-testing\">\n<h2>Simple library testing</h2>\n<p>The current tests are not only to test the code, but also to check it in a real environment. Therefore, a good idea,\nbefore we use this library in our own project, is to test its operation with the MQTT broker.</p>\n<p>To test if the library works well with your device and MQTT broker,\nuse the TestMQTT class from the <cite>tests.py</cite> module.</p>\n<p>If you don\u2019t have your own MQTT broker yet, you can use the free MQTT test broker (test.mosquitto.org).</p>\n<p>There is also a sample file <cite>main.py`(`example_test_main.py</cite>),\nIn this file we add only network configuration. Upload this file to your device with <cite>umqtt.simple2</cite>\nlibrary and <cite>tests.py</cite> module. Then reset the device and watch the results in the console.</p>\n</div>\n<div id=\"different-problems\">\n<h2>Different problems</h2>\n<ul>\n<li>Wrong topic format during subscription - you\u2019ll get <cite>OSError: [Errno 104] ECONNRESET</cite> in subscribe()\nor <cite>MQTTException: 1</cite> in the <cite>wait_msg()/check_msg()</cite></li>\n</ul>\n</div>\n<div id=\"additional-resources\">\n<h2>Additional resources</h2>\n<ul>\n<li><a href=\"https://mosquitto.org/\" rel=\"nofollow\">https://mosquitto.org/</a> - Eclipse Mosquitto is an open source  message broker that implements the MQTT protocol.</li>\n<li><a href=\"https://test.mosquitto.org/\" rel=\"nofollow\">https://test.mosquitto.org/</a> - MQTT test server</li>\n<li><a href=\"http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html\" rel=\"nofollow\">http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html</a> - MQTT 3.1.1 specyfication</li>\n<li><a href=\"https://flespi.com/tools/mqtt-board\" rel=\"nofollow\">https://flespi.com/tools/mqtt-board</a> - An open-source MQTT client tool for easy MQTT pub/sub, testing, and demonstration.</li>\n<li><a href=\"https://github.com/wialon/gmqtt\" rel=\"nofollow\">https://github.com/wialon/gmqtt</a> - Python MQTT client implementation(not for the micropython)</li>\n<li><a href=\"https://www.hivemq.com/mqtt-essentials/\" rel=\"nofollow\">https://www.hivemq.com/mqtt-essentials/</a> - Blog with explanation of MQTT specifications</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 6842418, "releases": {"1.99.999": [{"comment_text": "", "digests": {"md5": "242a56cc95211bc8554cd686d23d11d7", "sha256": "99377d76bed0b79007597f1ebd4c117bf8a03af2b12de51532d284b36f38f640"}, "downloads": -1, "filename": "micropython-umqtt.simple2-1.99.999.tar.gz", "has_sig": false, "md5_digest": "242a56cc95211bc8554cd686d23d11d7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6092, "upload_time": "2019-12-23T10:23:19", "upload_time_iso_8601": "2019-12-23T10:23:19.381782Z", "url": "https://files.pythonhosted.org/packages/fc/c2/9d1d152f9e849d7efc13c98480c4da68bdcb47f19f1233aefbaa3af081d8/micropython-umqtt.simple2-1.99.999.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "ecdd5897ae356826e1b943adef8696b5", "sha256": "4ac93e04bffb978efbefaf2453d3c3c5ab6e03124f30c396023c0c068637c109"}, "downloads": -1, "filename": "micropython-umqtt.simple2-2.0.0.tar.gz", "has_sig": false, "md5_digest": "ecdd5897ae356826e1b943adef8696b5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6209, "upload_time": "2019-12-27T10:34:12", "upload_time_iso_8601": "2019-12-27T10:34:12.827477Z", "url": "https://files.pythonhosted.org/packages/0c/01/dadb46e3f5119e4c735465443f399760d0c83ab300a054cbc854ffec5f38/micropython-umqtt.simple2-2.0.0.tar.gz", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "50b3e278bf35dda3a615a6ea19679329", "sha256": "9077e3c80459a14b888c218610415c2f3e524c215f1cf3228cc02a495c466cab"}, "downloads": -1, "filename": "micropython-umqtt.simple2-2.0.1.tar.gz", "has_sig": false, "md5_digest": "50b3e278bf35dda3a615a6ea19679329", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6208, "upload_time": "2020-01-14T15:31:41", "upload_time_iso_8601": "2020-01-14T15:31:41.567445Z", "url": "https://files.pythonhosted.org/packages/12/76/edc65827ba722ca7ca8d9e0c0ce6fb09b6cfa4c0c725eea988a6c7e5d5ec/micropython-umqtt.simple2-2.0.1.tar.gz", "yanked": false}], "2.0.2": [{"comment_text": "", "digests": {"md5": "58d5507980bcf9fcaeda6c4059a10576", "sha256": "e18f12e745929a00c5e7bd9294209f3aa042b532410d9d6e106bf9f2326ed410"}, "downloads": -1, "filename": "micropython-umqtt.simple2-2.0.2.tar.gz", "has_sig": false, "md5_digest": "58d5507980bcf9fcaeda6c4059a10576", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6215, "upload_time": "2020-03-17T20:23:51", "upload_time_iso_8601": "2020-03-17T20:23:51.087113Z", "url": "https://files.pythonhosted.org/packages/b8/3b/306db385a0419e5439100508e789463b4b3741b64b47ed318fd77aecf6e0/micropython-umqtt.simple2-2.0.2.tar.gz", "yanked": false}], "2.0.3": [{"comment_text": "", "digests": {"md5": "1dc8dd6ca73dcaeb3fd0295baa5cb1c3", "sha256": "18612137a7d70c0fe9615a98427cfb8f4b2e652edf3fa4a00a90d0e608910d58"}, "downloads": -1, "filename": "micropython-umqtt.simple2-2.0.3.tar.gz", "has_sig": false, "md5_digest": "1dc8dd6ca73dcaeb3fd0295baa5cb1c3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6245, "upload_time": "2020-03-18T13:17:26", "upload_time_iso_8601": "2020-03-18T13:17:26.739420Z", "url": "https://files.pythonhosted.org/packages/dc/5b/2aebe7738643005112261165e63aa0c749c189d7fb1ce9a1935797e4d583/micropython-umqtt.simple2-2.0.3.tar.gz", "yanked": false}], "2.0.4": [{"comment_text": "", "digests": {"md5": "720dd2f338c63e63a57a95e86dc10d52", "sha256": "76a63dd8950c61f886fdc2e29025cfed0b62ca664c9ff2907b67d842cbe88a95"}, "downloads": -1, "filename": "micropython-umqtt.simple2-2.0.4.tar.gz", "has_sig": false, "md5_digest": "720dd2f338c63e63a57a95e86dc10d52", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6227, "upload_time": "2020-03-19T10:31:20", "upload_time_iso_8601": "2020-03-19T10:31:20.305049Z", "url": "https://files.pythonhosted.org/packages/8d/03/a672669a4b4dac03ab5e685777b5dac0e39443d5db9a4bd0980e1fd7c4cf/micropython-umqtt.simple2-2.0.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "720dd2f338c63e63a57a95e86dc10d52", "sha256": "76a63dd8950c61f886fdc2e29025cfed0b62ca664c9ff2907b67d842cbe88a95"}, "downloads": -1, "filename": "micropython-umqtt.simple2-2.0.4.tar.gz", "has_sig": false, "md5_digest": "720dd2f338c63e63a57a95e86dc10d52", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6227, "upload_time": "2020-03-19T10:31:20", "upload_time_iso_8601": "2020-03-19T10:31:20.305049Z", "url": "https://files.pythonhosted.org/packages/8d/03/a672669a4b4dac03ab5e685777b5dac0e39443d5db9a4bd0980e1fd7c4cf/micropython-umqtt.simple2-2.0.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:59 2020"}