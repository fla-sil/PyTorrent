{"info": {"author": "", "author_email": "lapeyre@cerfacs.fr", "bugtrack_url": null, "classifiers": ["Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "# nob: the Nested OBject manipulator\n\nJSON is a very popular format for nested data exchange, and Object Relational\nMapping (ORM) is a popular method to help developers make sense of large JSON\nobjects, by mapping objects to the data. In some cases however, the nesting\ncan be very deep, and difficult to map with objects. This is where nob can be\nuseful: it offers a simple set of tools to explore and edit any nested data\n(Python native dicts and lists).\n\nFor more, checkout the [home page](https://gitlab.com/cerfacs/nob), or play\naround with the library in colab:\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/weiji14/deepbedmap/]\n\n## Usage\n\n### Instantiation\n\n`nob.Nob` objects can be instantiated directly from a Python dictionary:\n\n    t = Nob({\n        'key1': 'val1',\n        'key2': {\n            'key3': 4,\n            'key4': {'key5': 'val2'},\n            'key5': [3, 4, 5]\n            },\n        'key5': 'val3'\n        })\n\nTo create a `Nob` from a JSON (or YAML) file, simply read it and feed the data\nto the constructor:\n\n    import json\n    with open('file.json') as fh:\n        t2 = Nob(json.load(fh))\n\n    import yaml\n    with open('file.yml') as fh:\n        t3 = Nob(yaml.load(fh))\n\nSimilarly, to create a JSON (YAML) file from a tree, you can use:\n\n    with open('file.json', 'w') as fh:\n        json.dump(t2[:], fh)\n\n    with open('file.yml', 'w') as fh:\n        yaml.dump(t3[:], fh)\n\n### Basic manipulation\n\nThe variable `t` now holds a tree, *i.e* the reference to the actual data. However,\nfor many practical cases it is useful to work with a subtree. `nob` offers a useful\nclass `NobView` to this end. It handles identically for the most part as the main tree,\nbut changes performed on a `NobView` affect the main `Nob` instance that it is linked\nto. In practice, any access to a key of `t` yields a `NobView` instance, *e.g.*:\n\n    tv1 = t['/key1']         # NobView(/key1)\n    tv2 = t['key1']          # NobView(/key1)\n    tv3 = t.key1             # NobView(/key1)\n    tv1 == tv2 == tv3        # True\n\nNote that a *full path* `'/key1'`, as well as a simple key `'key1'` are valid\nidentifiers. Simple keys can also be called as attributes, using `t.key1`.\n\nTo access the actual value that is stored in the nested object, simply use the `[:]`\noperator:\n\n    tv1[:]                   >>> 'val1'\n    t.key1[:]                >>> 'val1'\n\nTo assign a new value to this node, you can do it directly on the NobView instance:\n\n    t.key1 = 'new'\n    tv1[:]                   >>> 'new'\n    t[:]['key1']             >>> 'new'\n\nOf course, because of how Python variables work, you cannot simply assign the value to\n`tv1`, as this would just overwrite it's contents:\n\n    tv1 = 'new'\n    tv1                      >>> 'new'\n    t[:]['key1']             >>> 'val1'\n\nIf you find yourself with a `NobView` object that you would like to edit directly,\nyou can use the `.set` method:\n\n    tv1 = t.key1\n    tv1.set('new')\n    t[:]['key1']             >>> 'new'\n\nBecause nested objects can contain both dicts and lists, integers are sometimes\nneeded as keys:\n\n    t['/key2/key5/0']        >>> NobView(/key2/key5/0)\n    t.key2.key5[0]           >>> NobView(/key2/key5/0)\n    t.key2.key5['0']         >>> NobView(/key2/key5/0)\n\nHowever, since Python does not support attributes starting with an integer, there is\nno attribute support for lists. Only key access (full path, integer index or its\nstringified counterpart) are supported.\n\n### Smart key access\n\nIn a simple nested dictionary, the access to `'key1'` would be simply done with:\n\n    nested_dict['key1']\n\nIf you are looking for *e.g.* `key3`, you would need to write:\n\n    nested_dict['key2']['key3']\n\nFor deep nested objects however, this can be a chore, and become very difficult to\nread. `nob` helps you here by supplying a smart method for finding unique keys:\n\n    t['key3']                >>> NobView(/key2/key3)\n    t.key3                   >>> NobView(/key2/key3)\n\nNote that attribute access `t.key3` behaves like simple key access `t['key3']`. This\nhas some implications when the key is not unique in the tree. Let's say *e.g.* we wish\nto access `key5`. Let's try using attribute access:\n\n    t.key5                   >>> KeyError: Identifier key5 yielded 3 results instead of 1\n\nOups! Because `key5` is not unique (it appears 3 times in the tree), `t.key5` is not\nspecific, and `nob` wouldn't know which one to return. In this instance, we have\nseveral possibilities, depending on which `key5` we are looking for:\n\n    t.key4.key5              >>> NobView(/key2/key4/key5)\n    t.key2['/key5']          >>> NobView(/key2/key5)\n    t['/key5']               >>> NobView(/key5)\n\nThere is a bit to unpack here:\n\n  - The first `key5` is unique in the `NobView` `t.key4` (and `key4` is itself\n    unique), so `t.key4.key5` finds it correctly.\n  - The second is complex: `key2` is unique, but `key5` is still not unique to `t.key2`.\n    There is not much advantage compared to a full path access `t['/key2/key5']`.\n  - The last cannot be resolved using keys in its path, because there are none. The \n    only solution is to use a full path.\n\n## Other tree tools\n\n**Paths:** any `Nob` (or `NobView`) object can introspect itself to find all its valid paths:\n\n    t.paths                  >>> [Path('/'),\n                                  Path('/key1'),\n                                  Path('/key2'),\n                                  Path('/key2/key3'),\n                                  Path('/key2/key4'),\n                                  Path('/key2/key4/key5'),\n                                  Path('/key2/key5'),\n                                  Path('/key2/key5/0'),\n                                  Path('/key2/key5/1'),\n                                  Path('/key2/key5/2'),\n                                  Path('/key5')]\n\n**Find:** in order to easily search in this path list, the `.find` method is available:\n\n    t.find('key5')           >>> [Path('/key2/key4/key5'),\n                                  Path('/key2/key5'),\n                                  Path('/key5')]\n\nThe elements of these lists are not strings, but `Path` objects, as described\nbelow.\n\n**Iterable:** any tree or tree view is also iterable, yielding its children:\n\n    [tv for tv in t.key2]    >>> [NobView(/key2/key3),\n                                  NobView(/key2/key4),\n                                  NobView(/key2/key5)]\n\n**Copy:** to make an independant copy of a tree, use its `.copy()` method:\n\n    t_cop = t.copy()\n    t == t_cop               >>> True\n    t_cop.key1 = 'new_val'\n    t == t_cop               >>> False\n\nA new standalone tree can also be produced from any tree view:\n\n    t_cop = t.key2.copy()\n    t_cop == t.key2          >>> True\n    t_cop.key3 = 5\n    t_cop == t.key2          >>> False\n\n## Path\n\nAll paths are stored internally using the `nob.Path` class. Paths are full\n(w.r.t. their `Nob` or `NobView`), and are in essence a list of the keys\nconstituting the nested address. They can however be viewed equivalently as\na unix-type path string with `/` separators. Here are some examples\n\n    p1 = Path(['key1'])\n    p1                       >>> Path(/key1)\n    p2 = Path('/key1/key2')\n    p2                       >>> Path(/key1/key2)\n    p1 / 'key3'              >>> Path(/key1/key3)\n    p2.parent                >>> Path(/key1)\n    p2.parent == p1          >>> True\n    'key2' in p2             >>> True\n    [k for k in p2]          >>> ['key1', 'key2']\n    p2[-1]                   >>> 'key2'\n    len(p2)                  >>> 2\n\nThese can be helpful to manipulate paths yourself, as any full access with\na string to a `Nob` or `NobView` object also accepts a `Path` object. So say\nyou are accessing the keys in `list_of_keys` at one position, but that thet also\nexist elsewhere in the tree. You could use *e.g.*:\n\n    root = Path('/path/to/root/of/keys')\n    [t[root / key] for key in list_of_keys]\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://gitlab.com/cerfacs/nob", "keywords": "JSON,YAML,Nested Object", "license": "", "maintainer": "", "maintainer_email": "", "name": "nob", "package_url": "https://pypi.org/project/nob/", "platform": "", "project_url": "https://pypi.org/project/nob/", "project_urls": {"Homepage": "https://gitlab.com/cerfacs/nob"}, "release_url": "https://pypi.org/project/nob/0.4.1/", "requires_dist": null, "requires_python": "", "summary": "Nested OBject manipulations", "version": "0.4.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>nob: the Nested OBject manipulator</h1>\n<p>JSON is a very popular format for nested data exchange, and Object Relational\nMapping (ORM) is a popular method to help developers make sense of large JSON\nobjects, by mapping objects to the data. In some cases however, the nesting\ncan be very deep, and difficult to map with objects. This is where nob can be\nuseful: it offers a simple set of tools to explore and edit any nested data\n(Python native dicts and lists).</p>\n<p>For more, checkout the <a href=\"https://gitlab.com/cerfacs/nob\" rel=\"nofollow\">home page</a>, or play\naround with the library in colab:</p>\n<p>[<img alt=\"Open In Colab\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/74d996556a82b2f1dd5252d2fd8bead60f9e9d21/68747470733a2f2f636f6c61622e72657365617263682e676f6f676c652e636f6d2f6173736574732f636f6c61622d62616467652e737667\">](<a href=\"https://colab.research.google.com/github/weiji14/deepbedmap/%5D\" rel=\"nofollow\">https://colab.research.google.com/github/weiji14/deepbedmap/]</a></p>\n<h2>Usage</h2>\n<h3>Instantiation</h3>\n<p><code>nob.Nob</code> objects can be instantiated directly from a Python dictionary:</p>\n<pre><code>t = Nob({\n    'key1': 'val1',\n    'key2': {\n        'key3': 4,\n        'key4': {'key5': 'val2'},\n        'key5': [3, 4, 5]\n        },\n    'key5': 'val3'\n    })\n</code></pre>\n<p>To create a <code>Nob</code> from a JSON (or YAML) file, simply read it and feed the data\nto the constructor:</p>\n<pre><code>import json\nwith open('file.json') as fh:\n    t2 = Nob(json.load(fh))\n\nimport yaml\nwith open('file.yml') as fh:\n    t3 = Nob(yaml.load(fh))\n</code></pre>\n<p>Similarly, to create a JSON (YAML) file from a tree, you can use:</p>\n<pre><code>with open('file.json', 'w') as fh:\n    json.dump(t2[:], fh)\n\nwith open('file.yml', 'w') as fh:\n    yaml.dump(t3[:], fh)\n</code></pre>\n<h3>Basic manipulation</h3>\n<p>The variable <code>t</code> now holds a tree, <em>i.e</em> the reference to the actual data. However,\nfor many practical cases it is useful to work with a subtree. <code>nob</code> offers a useful\nclass <code>NobView</code> to this end. It handles identically for the most part as the main tree,\nbut changes performed on a <code>NobView</code> affect the main <code>Nob</code> instance that it is linked\nto. In practice, any access to a key of <code>t</code> yields a <code>NobView</code> instance, <em>e.g.</em>:</p>\n<pre><code>tv1 = t['/key1']         # NobView(/key1)\ntv2 = t['key1']          # NobView(/key1)\ntv3 = t.key1             # NobView(/key1)\ntv1 == tv2 == tv3        # True\n</code></pre>\n<p>Note that a <em>full path</em> <code>'/key1'</code>, as well as a simple key <code>'key1'</code> are valid\nidentifiers. Simple keys can also be called as attributes, using <code>t.key1</code>.</p>\n<p>To access the actual value that is stored in the nested object, simply use the <code>[:]</code>\noperator:</p>\n<pre><code>tv1[:]                   &gt;&gt;&gt; 'val1'\nt.key1[:]                &gt;&gt;&gt; 'val1'\n</code></pre>\n<p>To assign a new value to this node, you can do it directly on the NobView instance:</p>\n<pre><code>t.key1 = 'new'\ntv1[:]                   &gt;&gt;&gt; 'new'\nt[:]['key1']             &gt;&gt;&gt; 'new'\n</code></pre>\n<p>Of course, because of how Python variables work, you cannot simply assign the value to\n<code>tv1</code>, as this would just overwrite it's contents:</p>\n<pre><code>tv1 = 'new'\ntv1                      &gt;&gt;&gt; 'new'\nt[:]['key1']             &gt;&gt;&gt; 'val1'\n</code></pre>\n<p>If you find yourself with a <code>NobView</code> object that you would like to edit directly,\nyou can use the <code>.set</code> method:</p>\n<pre><code>tv1 = t.key1\ntv1.set('new')\nt[:]['key1']             &gt;&gt;&gt; 'new'\n</code></pre>\n<p>Because nested objects can contain both dicts and lists, integers are sometimes\nneeded as keys:</p>\n<pre><code>t['/key2/key5/0']        &gt;&gt;&gt; NobView(/key2/key5/0)\nt.key2.key5[0]           &gt;&gt;&gt; NobView(/key2/key5/0)\nt.key2.key5['0']         &gt;&gt;&gt; NobView(/key2/key5/0)\n</code></pre>\n<p>However, since Python does not support attributes starting with an integer, there is\nno attribute support for lists. Only key access (full path, integer index or its\nstringified counterpart) are supported.</p>\n<h3>Smart key access</h3>\n<p>In a simple nested dictionary, the access to <code>'key1'</code> would be simply done with:</p>\n<pre><code>nested_dict['key1']\n</code></pre>\n<p>If you are looking for <em>e.g.</em> <code>key3</code>, you would need to write:</p>\n<pre><code>nested_dict['key2']['key3']\n</code></pre>\n<p>For deep nested objects however, this can be a chore, and become very difficult to\nread. <code>nob</code> helps you here by supplying a smart method for finding unique keys:</p>\n<pre><code>t['key3']                &gt;&gt;&gt; NobView(/key2/key3)\nt.key3                   &gt;&gt;&gt; NobView(/key2/key3)\n</code></pre>\n<p>Note that attribute access <code>t.key3</code> behaves like simple key access <code>t['key3']</code>. This\nhas some implications when the key is not unique in the tree. Let's say <em>e.g.</em> we wish\nto access <code>key5</code>. Let's try using attribute access:</p>\n<pre><code>t.key5                   &gt;&gt;&gt; KeyError: Identifier key5 yielded 3 results instead of 1\n</code></pre>\n<p>Oups! Because <code>key5</code> is not unique (it appears 3 times in the tree), <code>t.key5</code> is not\nspecific, and <code>nob</code> wouldn't know which one to return. In this instance, we have\nseveral possibilities, depending on which <code>key5</code> we are looking for:</p>\n<pre><code>t.key4.key5              &gt;&gt;&gt; NobView(/key2/key4/key5)\nt.key2['/key5']          &gt;&gt;&gt; NobView(/key2/key5)\nt['/key5']               &gt;&gt;&gt; NobView(/key5)\n</code></pre>\n<p>There is a bit to unpack here:</p>\n<ul>\n<li>The first <code>key5</code> is unique in the <code>NobView</code> <code>t.key4</code> (and <code>key4</code> is itself\nunique), so <code>t.key4.key5</code> finds it correctly.</li>\n<li>The second is complex: <code>key2</code> is unique, but <code>key5</code> is still not unique to <code>t.key2</code>.\nThere is not much advantage compared to a full path access <code>t['/key2/key5']</code>.</li>\n<li>The last cannot be resolved using keys in its path, because there are none. The\nonly solution is to use a full path.</li>\n</ul>\n<h2>Other tree tools</h2>\n<p><strong>Paths:</strong> any <code>Nob</code> (or <code>NobView</code>) object can introspect itself to find all its valid paths:</p>\n<pre><code>t.paths                  &gt;&gt;&gt; [Path('/'),\n                              Path('/key1'),\n                              Path('/key2'),\n                              Path('/key2/key3'),\n                              Path('/key2/key4'),\n                              Path('/key2/key4/key5'),\n                              Path('/key2/key5'),\n                              Path('/key2/key5/0'),\n                              Path('/key2/key5/1'),\n                              Path('/key2/key5/2'),\n                              Path('/key5')]\n</code></pre>\n<p><strong>Find:</strong> in order to easily search in this path list, the <code>.find</code> method is available:</p>\n<pre><code>t.find('key5')           &gt;&gt;&gt; [Path('/key2/key4/key5'),\n                              Path('/key2/key5'),\n                              Path('/key5')]\n</code></pre>\n<p>The elements of these lists are not strings, but <code>Path</code> objects, as described\nbelow.</p>\n<p><strong>Iterable:</strong> any tree or tree view is also iterable, yielding its children:</p>\n<pre><code>[tv for tv in t.key2]    &gt;&gt;&gt; [NobView(/key2/key3),\n                              NobView(/key2/key4),\n                              NobView(/key2/key5)]\n</code></pre>\n<p><strong>Copy:</strong> to make an independant copy of a tree, use its <code>.copy()</code> method:</p>\n<pre><code>t_cop = t.copy()\nt == t_cop               &gt;&gt;&gt; True\nt_cop.key1 = 'new_val'\nt == t_cop               &gt;&gt;&gt; False\n</code></pre>\n<p>A new standalone tree can also be produced from any tree view:</p>\n<pre><code>t_cop = t.key2.copy()\nt_cop == t.key2          &gt;&gt;&gt; True\nt_cop.key3 = 5\nt_cop == t.key2          &gt;&gt;&gt; False\n</code></pre>\n<h2>Path</h2>\n<p>All paths are stored internally using the <code>nob.Path</code> class. Paths are full\n(w.r.t. their <code>Nob</code> or <code>NobView</code>), and are in essence a list of the keys\nconstituting the nested address. They can however be viewed equivalently as\na unix-type path string with <code>/</code> separators. Here are some examples</p>\n<pre><code>p1 = Path(['key1'])\np1                       &gt;&gt;&gt; Path(/key1)\np2 = Path('/key1/key2')\np2                       &gt;&gt;&gt; Path(/key1/key2)\np1 / 'key3'              &gt;&gt;&gt; Path(/key1/key3)\np2.parent                &gt;&gt;&gt; Path(/key1)\np2.parent == p1          &gt;&gt;&gt; True\n'key2' in p2             &gt;&gt;&gt; True\n[k for k in p2]          &gt;&gt;&gt; ['key1', 'key2']\np2[-1]                   &gt;&gt;&gt; 'key2'\nlen(p2)                  &gt;&gt;&gt; 2\n</code></pre>\n<p>These can be helpful to manipulate paths yourself, as any full access with\na string to a <code>Nob</code> or <code>NobView</code> object also accepts a <code>Path</code> object. So say\nyou are accessing the keys in <code>list_of_keys</code> at one position, but that thet also\nexist elsewhere in the tree. You could use <em>e.g.</em>:</p>\n<pre><code>root = Path('/path/to/root/of/keys')\n[t[root / key] for key in list_of_keys]\n</code></pre>\n\n          </div>"}, "last_serial": 6625037, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "9b0dd426265a8113c73deefaf2b725ca", "sha256": "c112e3f7f5616a3ced7719de560b5d5201db12f51b5261380de5b4ed46e2f5c5"}, "downloads": -1, "filename": "nob-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9b0dd426265a8113c73deefaf2b725ca", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 6834, "upload_time": "2019-08-15T15:28:06", "upload_time_iso_8601": "2019-08-15T15:28:06.857112Z", "url": "https://files.pythonhosted.org/packages/bd/ae/3fd26a8292f748a22460c0449410dac341b0d0c0b523b664c64fd109d55b/nob-0.1.0-py2.py3-none-any.whl", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "7e17cc15eb208647344bc2980806d211", "sha256": "a63226be28393b6a4cc4c71979490e47a8721c71c32fe6166ffce65918587940"}, "downloads": -1, "filename": "nob-0.1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "7e17cc15eb208647344bc2980806d211", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 7063, "upload_time": "2019-08-19T08:06:46", "upload_time_iso_8601": "2019-08-19T08:06:46.993599Z", "url": "https://files.pythonhosted.org/packages/d2/fc/e23ca18103659fce39af7ee11e6cf76fda2fc0e1b5d91292a7979be7d62d/nob-0.1.1-py2.py3-none-any.whl", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "e78598cfb0ff6b0d6c429c75a4b8454d", "sha256": "e006d869b811d50db811ed1d3473bd19b7c1c618b7abba3322d4f7750dc46214"}, "downloads": -1, "filename": "nob-0.1.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "e78598cfb0ff6b0d6c429c75a4b8454d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 7030, "upload_time": "2019-08-19T15:42:59", "upload_time_iso_8601": "2019-08-19T15:42:59.764665Z", "url": "https://files.pythonhosted.org/packages/d5/d1/061ef02a9e21c8317b4a3aedcf824488bd21dff5af1764db3100630575e7/nob-0.1.2-py2.py3-none-any.whl", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "b5b88ea6f0c2aa09e1762fe65d9e1e61", "sha256": "f60fd1f192b4b0aa8c5ce92c7d9a02aecf09313e0ffd6381d69edbc5e9dbb936"}, "downloads": -1, "filename": "nob-0.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "b5b88ea6f0c2aa09e1762fe65d9e1e61", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 7590, "upload_time": "2019-08-23T06:19:24", "upload_time_iso_8601": "2019-08-23T06:19:24.733779Z", "url": "https://files.pythonhosted.org/packages/75/b0/129590f8f5020ba76b3bfef1005465218923a6500b2ad8614f8b5fdd8967/nob-0.2.0-py2.py3-none-any.whl", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "304c9974b6c4459b07e68d1fcf0ec6d0", "sha256": "353e5f556666df529285d0d20401702f727732e4e1ff6c8fc3e8a3317dc947c6"}, "downloads": -1, "filename": "nob-0.2.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "304c9974b6c4459b07e68d1fcf0ec6d0", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8536, "upload_time": "2019-08-26T15:28:58", "upload_time_iso_8601": "2019-08-26T15:28:58.046789Z", "url": "https://files.pythonhosted.org/packages/1c/81/2cba16bd7abe37251e8ce55f47d7c0da9c501f577f709d152e809ebde659/nob-0.2.1-py2.py3-none-any.whl", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "1bf4502adb89ac393c0fad48340124c9", "sha256": "e11ea90871ab2e74790570eaa0e267c63d95fb119256dd898d5b6b7dd3574bbf"}, "downloads": -1, "filename": "nob-0.3.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "1bf4502adb89ac393c0fad48340124c9", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8840, "upload_time": "2020-01-31T08:54:08", "upload_time_iso_8601": "2020-01-31T08:54:08.027817Z", "url": "https://files.pythonhosted.org/packages/b7/e9/7c31c985b1aac235352e0d18e3acffaacb096848844d38e485ce36bd0af4/nob-0.3.0-py2.py3-none-any.whl", "yanked": false}], "0.3.1": [{"comment_text": "", "digests": {"md5": "a93acd7705f6c056194ca3edcbddde63", "sha256": "608021d5227f20d94a2fc0834ab5e95a875915766f240eda3af44e01861fc6ff"}, "downloads": -1, "filename": "nob-0.3.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a93acd7705f6c056194ca3edcbddde63", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8959, "upload_time": "2020-01-31T11:01:56", "upload_time_iso_8601": "2020-01-31T11:01:56.023046Z", "url": "https://files.pythonhosted.org/packages/d9/35/23b45c04893e801193e94b1f5c3469b3b519ce305fcedeb5851333b296aa/nob-0.3.1-py2.py3-none-any.whl", "yanked": false}], "0.3.2": [{"comment_text": "", "digests": {"md5": "28cdc8c8d3466917a947e570b59651bd", "sha256": "6d31f162db172fce05d34f8f2ec08e1f7382a3ff0534ccb47ad0e626fa0f5bee"}, "downloads": -1, "filename": "nob-0.3.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "28cdc8c8d3466917a947e570b59651bd", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12600, "upload_time": "2020-02-05T08:22:30", "upload_time_iso_8601": "2020-02-05T08:22:30.086145Z", "url": "https://files.pythonhosted.org/packages/37/27/fae4865a24bcb5ecc0f26a80b28f5c884b18594dfdcb64e53741b30c71b9/nob-0.3.2-py2.py3-none-any.whl", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "4eb19b4953f87c0f7223b18ad6602071", "sha256": "47d5489b95eaa38595d0d3259e258325efec326f0bb6fd2665edcf69265ea8a2"}, "downloads": -1, "filename": "nob-0.4.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "4eb19b4953f87c0f7223b18ad6602071", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12762, "upload_time": "2020-02-05T14:14:22", "upload_time_iso_8601": "2020-02-05T14:14:22.217840Z", "url": "https://files.pythonhosted.org/packages/0f/0c/483c0a99b525ca94ec64ac4fe3365dcac57f9d5ac8024236c357f478d0ab/nob-0.4.0-py2.py3-none-any.whl", "yanked": false}], "0.4.1": [{"comment_text": "", "digests": {"md5": "e2b1070e77d0afd6b4513d869b6460d7", "sha256": "b5d571fa5013d8f462e9ddb2cc76f6531e590733ab0d432ae03a8ba01139c35c"}, "downloads": -1, "filename": "nob-0.4.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "e2b1070e77d0afd6b4513d869b6460d7", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12833, "upload_time": "2020-02-13T17:40:47", "upload_time_iso_8601": "2020-02-13T17:40:47.166064Z", "url": "https://files.pythonhosted.org/packages/f4/49/bcb511637eab0575eb0687ab7cda52217e4b5c59eab423f860834520bb94/nob-0.4.1-py2.py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e2b1070e77d0afd6b4513d869b6460d7", "sha256": "b5d571fa5013d8f462e9ddb2cc76f6531e590733ab0d432ae03a8ba01139c35c"}, "downloads": -1, "filename": "nob-0.4.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "e2b1070e77d0afd6b4513d869b6460d7", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12833, "upload_time": "2020-02-13T17:40:47", "upload_time_iso_8601": "2020-02-13T17:40:47.166064Z", "url": "https://files.pythonhosted.org/packages/f4/49/bcb511637eab0575eb0687ab7cda52217e4b5c59eab423f860834520bb94/nob-0.4.1-py2.py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 00:45:01 2020"}