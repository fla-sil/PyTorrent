{"info": {"author": "Jean Cochrane", "author_email": "jean@jeancochrane.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Plugins", "Environment :: Web Environment", "Framework :: Pytest", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Software Development :: Testing"], "description": "# pytest-flask-sqlalchemy\n\n[![Build Status](https://travis-ci.org/jeancochrane/pytest-flask-sqlalchemy.svg?branch=master)](https://travis-ci.org/jeancochrane/pytest-flask-sqlalchemy) ![PyPI - Python Version](https://img.shields.io/pypi/pyversions/Django.svg)\n\nA [pytest](https://docs.pytest.org/en/latest/) plugin providing fixtures for running tests in\ntransactions using [Flask-SQLAlchemy](http://flask-sqlalchemy.pocoo.org/latest/).\n\n## Contents\n\n- [**Motivation**](#motivation)\n- [**Quick examples**](#quick-examples)\n- [**Usage**](#usage)\n    - [Installation](#installation)\n        - [From PyPi](#from-pypi)\n        - [Development version](#development-version)\n        - [Supported backends](#supported-backends)\n    - [Configuration](#configuration)\n        - [Conftest setup](#conftest-setup)\n        - [Test configuration](#test-configuration)\n            - [`mocked-engines`](#mocked-engines)\n            - [`mocked-sessions`](#mocked-sessions)\n            - [`mocked-sessionmakers`](#mocked-sessionmakers)\n        - [Writing transactional tests](#writing-transactional-tests)\n    - [Fixtures](#fixtures)\n        - [`db_session`](#db_session)\n        - [`db_engine`](#db_engine)\n    - [Enabling transactions without fixtures](#enabling-transactions-without-fixtures)\n- [**Development**](#development)\n    - [Running the tests](#running-the-tests)\n    - [Acknowledgements](#acknowledgements)\n    - [Copyright](#copyright)\n\n## <a name=\"motivation\"></a>Motivation\n\nInspired by [Django's built-in support for transactional\ntests](https://jeancochrane.com/blog/django-test-transactions), this plugin \nseeks to provide comprehensive, easy-to-use Pytest fixtures for wrapping tests in\ndatabase transactions for [Flask-SQLAlchemy](http://flask-sqlalchemy.pocoo.org/latest/)\napps. The goal is to make testing stateful Flask-SQLAlchemy applications easier by\nproviding fixtures that permit the developer to **make arbitrary database updates\nwith the confidence that any changes made during a test will roll back** once the test exits.\n\n## <a name=\"quick-examples\"></a>Quick examples\n\nUse the [`db_session` fixture](#db_session) to make **database updates that won't persist beyond\nthe body of the test**:\n\n```python\ndef test_a_transaction(db_session):\n   row = db_session.query(Table).get(1) \n   row.name = 'testing'\n\n   db_session.add(row)\n   db_session.commit()\n\ndef test_transaction_doesnt_persist(db_session):\n   row = db_session.query(Table).get(1) \n   assert row.name != 'testing'\n```\n\nThe [`db_engine` fixture](#db_engine) works the same way, but **copies the API of\nSQLAlchemy's [Engine\nobject](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine)**:\n\n```python\ndef test_a_transaction_using_engine(db_engine):\n    with db_engine.begin() as conn:\n        row = conn.execute('''UPDATE table SET name = 'testing' WHERE id = 1''')\n\ndef test_transaction_doesnt_persist(db_engine):\n    row_name = db_engine.execute('''SELECT name FROM table WHERE id = 1''').fetchone()[0]\n    assert row_name != 'testing' \n```\n\nUse [configuration properties](#test-configuration) to\n**mock database connections in an app and enforce nested transactions**,\nallowing any method from the codebase to run inside a test with the assurance\nthat any database changes made will be rolled back at the end of the test:\n\n```ini\n# In setup.cfg\n\n[tool:pytest]\nmocked-sessions=database.db.session\nmocked-engines=database.engine\n```\n\n```python\n# In database.py\n\ndb = flask_sqlalchemy.SQLAlchemy()\nengine = sqlalchemy.create_engine('DATABASE_URI')\n```\n\n```python\n# In models.py\n\nclass Table(db.Model):\n    __tablename__ = 'table'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(80))\n\n    def set_name(new_name)\n        self.name = new_name\n        db.session.add(self)\n        db.session.commit()\n```\n\n```python\n# In tests/test_set_name.py\n\ndef test_set_name(db_session):\n    row = db_session.query(Table).get(1)\n    row.set_name('testing')\n    assert row.name == 'testing'\n\ndef test_transaction_doesnt_persist(db_session):\n   row = db_session.query(Table).get(1) \n   assert row.name != 'testing'\n```\n\n# <a name=\"usage\"></a>Usage\n\n## <a name=\"installation\"></a>Installation\n\n### <a name=\"from-pypi\"></a>From PyPi\n\nInstall using pip:\n\n```\npip install pytest-flask-sqlalchemy\n```\n\nOnce installed, pytest will detect the plugin automatically during test collection.\nFor basic background on using third-party plugins with pytest, see the [pytest\ndocumentation](https://docs.pytest.org/en/latest/plugins.html?highlight=plugins).\n\n### <a name=\"development-version\"></a>Development version\n\nClone the repo from GitHub and switch into the new directory:\n\n```\ngit clone git@github.com:jeancochrane/pytest-flask-sqlalchemy.git\ncd pytest-flask-sqlalchemy\n```\n\nYou can install using pip:\n\n```\npip install .\n```\n\n### <a name=\"supported-backends\"></a>Supported backends\n\nSo far, pytest-flask-sqlalchemy has been most extensively tested against\nPostgreSQL 9.6. It should theoretically work with any backend that is supported\nby SQLAlchemy, but Postgres is the only backend that is currently tested by the\ntest suite.\n\nOfficial support for SQLite and MySQL is [planned for a future\nrelease](https://github.com/jeancochrane/pytest-flask-sqlalchemy/issues/3).\nIn the meantime, if you're using one of those backends and you run in to\nproblems, we would greatly appreciate your help! [Open an\nissue](https://github.com/jeancochrane/pytest-flask-sqlalchemy/issues/new) if\nsomething isn't working as you expect.\n\n## <a name=\"configuration\"></a>Configuration\n\n### <a name=\"conftest-setup\"></a>Conftest setup\n\nThis plugin assumes that a fixture called `_db` has been\ndefined in the root conftest file for your tests. The `_db` fixture should\nexpose access to a valid [SQLAlchemy `Session` object](http://docs.sqlalchemy.org/en/latest/orm/session_api.html?highlight=session#sqlalchemy.orm.session.Session) that can interact with your database,\nfor example via the [`SQLAlchemy` initialization class](http://flask-sqlalchemy.pocoo.org/2.3/api/#flask_sqlalchemy.SQLAlchemy)\nthat configures Flask-SQLAlchemy.\n\nThe fixtures in this plugin depend on this `_db` fixture to access your\ndatabase and create nested transactions to run tests in. **You must define\nthis fixture in your `conftest.py` file for the plugin to work.**\n\nAn example setup that will produce a valid `_db` fixture could look like this\n(this example comes from the [test setup](./tests/_conftest.py#L25-L61) for this repo):\n\n```python\n@pytest.fixture(scope='session')\ndef database(request):\n    '''\n    Create a Postgres database for the tests, and drop it when the tests are done.\n    '''\n    pg_host = DB_OPTS.get(\"host\")\n    pg_port = DB_OPTS.get(\"port\")\n    pg_user = DB_OPTS.get(\"username\")\n    pg_db = DB_OPTS[\"database\"]\n\n    init_postgresql_database(pg_user, pg_host, pg_port, pg_db)\n\n    @request.addfinalizer\n    def drop_database():\n        drop_postgresql_database(pg_user, pg_host, pg_port, pg_db, 9.6)\n\n\n@pytest.fixture(scope='session')\ndef app(database):\n    '''\n    Create a Flask app context for the tests.\n    '''\n    app = Flask(__name__)\n\n    app.config['SQLALCHEMY_DATABASE_URI'] = DB_CONN\n\n    return app\n\n\n@pytest.fixture(scope='session')\ndef _db(app):\n    '''\n    Provide the transactional fixtures with access to the database via a Flask-SQLAlchemy\n    database connection.\n    '''\n    db = SQLAlchemy(app=app)\n\n    return db\n```\n\nAlternatively, if you already have a fixture that sets up database access for\nyour tests, you can define `_db` to return that fixture directly:\n\n```python\n@pytest.fixture(scope='session')\ndef database():\n    # Set up all your database stuff here\n    # ...\n    return db\n\n@pytest.fixture(scope='session')\ndef _db(database):\n    return database\n```\n\n### <a name=\"test-configuration\"></a>Test configuration\n\nThis plugin allows you to configure a few different properties in a \n`setup.cfg` test configuration file in order to handle the specific database connection needs\nof your app. For basic background on setting up pytest configuration files, see\nthe [pytest docs](https://docs.pytest.org/en/latest/customize.html#adding-default-options).\n\nAll three configuration properties ([`mocked-engines`](#mocked-engines),\n[`mocked-sessions`](#mocked-sessions), and [`mocked-sessionmakers`](#mocked-sessionmakers))\nwork by **[patching](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch)\none or more specified objects during a test**, replacing them with equivalent objects whose\ndatabase interactions will run inside of a transaction and ultimately be\nrolled back when the test exits. Using these patches, you can call methods from\nyour codebase that alter database state with the knowledge that no changes will persist\nbeyond the body of the test.\n\nThe configured patches are only applied in tests where a transactional fixture\n(either [`db_session`](#db_session) or [`db_engine`](#db_engine)) is included\nin the test function arguments.\n\n#### <a name=\"mocked-engines\"></a>`mocked-engines`\n\nThe `mocked-engines` property directs the plugin to [patch](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch)\nobjects in your codebase, typically SQLAlchemy [Engine](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine)\ninstances, replacing them with the [`db_engine` fixture](#db_engine) such that\nany database updates performed by the objects get rolled back at the end of \nthe test. \n\nThe value for this property should be formatted as a whitespace-separated list \nof standard Python import paths, like `database.engine`. This property is **optional**.\n\nExample:\n\n```python\n# In database.py\n\nengine = sqlalchemy.create_engine(DATABASE_URI)\n```\n\n```ini\n# In setup.cfg\n\n[tool:pytest]\nmocked-engines=database.engine\n```\n\nTo patch multiple objects at once, separate the paths with a whitespace:\n\n```ini\n# In setup.cfg\n\n[tool:pytest]\nmocked-engines=database.engine database.second_engine\n```\n\n#### <a name=\"mocked-sessions\"></a>`mocked-sessions`\n\nThe `mocked-sessions` property directs the plugin to [patch](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch)\nobjects in your codebase, typically SQLAlchemy [Session](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine)\ninstances, replacing them with the [`db_session`](#db_session) fixture such that\nany database updates performed by the objects get rolled back at the end of \nthe test. \n\nThe value for this property should be formatted as a whitespace-separated list \nof standard Python import paths, like `database.db.session`. This property is **optional**.\n\nExample:\n\n```python\n# In database.py\n\ndb = SQLAlchemy()\n```\n\n```ini\n# In setup.cfg\n\n[tool:pytest]\nmocked-sessions=database.db.session\n```\n\nTo patch multiple objects at once, separate the paths with a whitespace:\n\n```ini\n# In setup.cfg\n\n[tool:pytest]\nmocked-sessions=database.db.session database.second_db.session\n```\n\n#### <a name=\"mocked-sessionmakers\"></a>`mocked-sessionmakers`\n\nThe `mocked-sessionmakers` property directs the plugin to [patch](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch)\nobjects in your codebase, typically instances of [SQLAlchemy's `sessionmaker`\nfactory](http://docs.sqlalchemy.org/en/latest/orm/session_api.html?highlight=sessionmaker#sqlalchemy.orm.session.sessionmaker),\nreplacing them with a mocked class that will return the transactional\n[`db_session`](#db_session) fixture. This can be useful if you have\npre-configured instances of sessionmaker objects that you import in the code\nto spin up sessions on the fly.\n\nThe value for this property should be formatted as a whitespace-separated list \nof standard Python import paths, like `database.WorkerSessionmaker`. This property is **optional**.\n\nExample:\n\n```python\n# In database.py\n\nWorkerSessionmaker = sessionmaker()\n```\n\n```ini\n[tool:pytest]\nmocked-sessionmakers=database.WorkerSessionmaker\n```\n\nTo patch multiple objects at once, separate the paths with a whitespace.\n\n```ini\n[tool:pytest]\nmocked-sessionmakers=database.WorkerSessionmaker database.SecondWorkerSessionmaker\n```\n\n### <a name=\"writing-transactional-tests\"></a>Writing transactional tests\n\nOnce you have your [conftest file set up](#conftest-setup) and you've [overrided the\nnecessary connectables in your test configuration](#test-configuration), you're ready\nto write some transactional tests. Simply import one of the module's [transactional\nfixtures](#fixtures) in your test signature, and the test will be wrapped in a transaction.\n\nNote that by default, **tests are only wrapped in transactions if they import one of\nthe [transactional fixtures](#fixtures) provided by this module.** Tests that do not\nimport the fixture will interact with your database without opening a transaction:\n\n```python\n# This test will be wrapped in a transaction.\ndef transactional_test(db_session):\n    ...\n\n# This test **will not** be wrapped in a transaction, since it does not import a\n# transactional fixture.\ndef non_transactional_test():\n    ...\n```\n\nThe fixtures provide a way for you to control which tests require transactions and\nwhich don't. This is often useful, since avoiding transaction setup can speed up\ntests that don't interact with your database.\n\nFor more information about the transactional fixtures provided by this module, read on\nto the [fixtures section](#fixtures). For guidance on how to automatically enable\ntransactions without having to specify fixtures, see the section on [enabling transactions\nwithout fixtures](#enabling-transactions-without-fixtures).\n\n## <a name=\"fixtures\"></a>Fixtures\n\nThis plugin provides two fixtures for performing database updates inside nested\ntransactions that get rolled back at the end of a test: [`db_session`](#db_session) and\n[`db_engine`](#db_engine). The fixtures provide similar functionality, but\nwith different APIs.\n\n### <a name=\"db_session\"></a>`db_session`\n\nThe `db_session` fixture allows you to perform direct updates that will be\nrolled back when the test exits. It exposes the same API as [SQLAlchemy's\n`scoped_session` object](http://docs.sqlalchemy.org/en/latest/orm/contextual.html#sqlalchemy.orm.scoping.scoped_session).\n\nIncluding this fixture as a function argument of a test will activate any mocks that are defined\nby the configuration properties [`mocked-engines`](#mocked-engines), [`mocked-sessions`](#mocked-sessions),\nor [`mocked-sessionmakers`](#mocked-sessionmakers) in the test configuration file for\nthe duration of that test.\n\nExample:\n\n```python\ndef test_a_transaction(db_session):\n   row = db_session.query(Table).get(1) \n   row.name = 'testing'\n\n   db_session.add(row)\n   db_session.commit()\n\ndef test_transaction_doesnt_persist(db_session):\n   row = db_session.query(Table).get(1) \n   assert row.name != 'testing'\n```\n\n### <a name=\"db_engine\"></a>`db_engine`\n\nLike [`db_session`](#db_session), the `db_engine` fixture allows you to perform direct updates\nagainst the test database that will be rolled back when the test exits. It is\nan instance of Python's built-in [`MagicMock`](https://docs.python.org/3/library/unittest.mock.html#unittest.mock.MagicMock)\nclass, with a spec set to match the API of [SQLAlchemy's\n`Engine`](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine) object.\n\nOnly a few `Engine` methods are exposed on this fixture:\n\n- `db_engine.begin`: begin a new nested transaction ([API docs](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine.begin))\n- `db_engine.execute`: execute a raw SQL query ([API docs](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine.execute)) \n- `db_engine.raw_connection`: return a raw DBAPI connection ([API docs](http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine.raw_connection)) \n\nSince `db_engine` is an instance of `MagicMock` with an `Engine` spec, other\nmethods of the `Engine` API can be called, but they will not perform any useful\nwork.\n\nIncluding this fixture as a function argument of a test will activate any mocks that are defined\nby the configuration properties [`mocked-engines`](#mocked-engines), [`mocked-sessions`](#mocked-sessions),\nor [`mocked-sessionmakers`](#mocked-sessionmakers) in the test configuration file for\nthe duration of that test.\n\nExample:\n\n```python\ndef test_a_transaction_using_engine(db_engine):\n    with db_engine.begin() as conn:\n        row = conn.execute('''UPDATE table SET name = 'testing' WHERE id = 1''')\n\ndef test_transaction_doesnt_persist(db_engine):\n    row_name = db_engine.execute('''SELECT name FROM table WHERE id = 1''').fetchone()[0]\n    assert row_name != 'testing' \n```\n\n## <a name=\"enabling-transactions-without-fixtures\"></a>Enabling transactions without fixtures\n\nIf you know you want to make all of your tests transactional, it can be annoying to have\nto specify one of the [fixtures](#fixtures) in every test signature.\n\nThe best way to automatically enable transactions without having to include an extra fixture\nin every test is to wire up an\n[autouse fixture](https://docs.pytest.org/en/latest/fixture.html#autouse-fixtures-xunit-setup-on-steroids)\nfor your test suite. This can be as simple as:\n\n```python\n# Automatically enable transactions for all tests, without importing any extra fixtures.\n@pytest.fixture(autouse=True)\ndef enable_transactional_tests(db_session):\n    pass\n```\n\nIn this configuration, the `enable_transactional_tests` fixture will be automatically used in\nall tests, meaning that `db_session` will also be used. This way, all tests will be wrapped\nin transactions without having to explicitly require either `db_session` or `enable_transactional_tests`.\n\n# <a name=\"development\"></a>Development\n\n## <a name=\"running-the-tests\"></a>Running the tests\n\nTo run the tests, start by installing a development version of the plugin that\nincludes test dependencies:\n\n```\npip install -e .[tests]\n```\n\nNext, export a [database connection string](http://docs.sqlalchemy.org/en/latest/core/engines.html#database-urls)\nthat the tests can use (the database referenced by the string will be created\nduring test setup, so it does not need to exist):\n\n```\nexport TEST_DATABASE_URL=<db_connection_string>\n```\n\nFinally, run the tests using pytest:\n\n```\npytest\n```\n\n## <a name=\"acknowledgements\"></a>Acknowledgements\n\nThis plugin was initially developed for testing\n[Dedupe.io](https://dedupe.io), a web app for record linkage and entity\nresolution using machine learning. Dedupe.io is built and maintained\nby [DataMade](https://datamade.us).\n\nThe code is greatly indebted to [Alex Michael](https://github.com/alexmic),\nwhose blog post [\"Delightful testing with pytest and\nFlask-SQLAlchemy\"](http://alexmic.net/flask-sqlalchemy-pytest/) helped\nestablish the basic approach on which this plugin builds.\n\nMany thanks to [Igor Ghisi](https://github.com/igortg/), who donated the PyPi\npackage name. Igor had been working on a similar plugin and proposed combining\nefforts. Thanks to Igor, the plugin name is much stronger.\n\n## <a name=\"copyright\"></a>Copyright\n\nCopyright (c) 2019 Jean Cochrane and DataMade. Released under the MIT License.\n\nThird-party copyright in this distribution is noted where applicable.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/jeancochrane/pytest-flask-sqlalchemy", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pytest-flask-sqlalchemy", "package_url": "https://pypi.org/project/pytest-flask-sqlalchemy/", "platform": "", "project_url": "https://pypi.org/project/pytest-flask-sqlalchemy/", "project_urls": {"Homepage": "https://github.com/jeancochrane/pytest-flask-sqlalchemy"}, "release_url": "https://pypi.org/project/pytest-flask-sqlalchemy/1.0.2/", "requires_dist": ["pytest (>=3.2.1)", "pytest-mock (>=1.6.2)", "SQLAlchemy (>=1.2.2)", "Flask-SQLAlchemy (>=2.3)", "packaging (>=14.1)", "pytest-postgresql ; extra == 'tests'"], "requires_python": "", "summary": "A pytest plugin for preserving test isolation in Flask-SQlAlchemy using database transactions.", "version": "1.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>pytest-flask-sqlalchemy</h1>\n<p><a href=\"https://travis-ci.org/jeancochrane/pytest-flask-sqlalchemy\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/058433a454807e2b50d09d3c08e4032397081123/68747470733a2f2f7472617669732d63692e6f72672f6a65616e636f636872616e652f7079746573742d666c61736b2d73716c616c6368656d792e7376673f6272616e63683d6d6173746572\"></a> <img alt=\"PyPI - Python Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/10dfd3abcb9a0ba765e14beb5116c17f39ed86b2/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f446a616e676f2e737667\"></p>\n<p>A <a href=\"https://docs.pytest.org/en/latest/\" rel=\"nofollow\">pytest</a> plugin providing fixtures for running tests in\ntransactions using <a href=\"http://flask-sqlalchemy.pocoo.org/latest/\" rel=\"nofollow\">Flask-SQLAlchemy</a>.</p>\n<h2>Contents</h2>\n<ul>\n<li><a href=\"#motivation\" rel=\"nofollow\"><strong>Motivation</strong></a></li>\n<li><a href=\"#quick-examples\" rel=\"nofollow\"><strong>Quick examples</strong></a></li>\n<li><a href=\"#usage\" rel=\"nofollow\"><strong>Usage</strong></a>\n<ul>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a>\n<ul>\n<li><a href=\"#from-pypi\" rel=\"nofollow\">From PyPi</a></li>\n<li><a href=\"#development-version\" rel=\"nofollow\">Development version</a></li>\n<li><a href=\"#supported-backends\" rel=\"nofollow\">Supported backends</a></li>\n</ul>\n</li>\n<li><a href=\"#configuration\" rel=\"nofollow\">Configuration</a>\n<ul>\n<li><a href=\"#conftest-setup\" rel=\"nofollow\">Conftest setup</a></li>\n<li><a href=\"#test-configuration\" rel=\"nofollow\">Test configuration</a>\n<ul>\n<li><a href=\"#mocked-engines\" rel=\"nofollow\"><code>mocked-engines</code></a></li>\n<li><a href=\"#mocked-sessions\" rel=\"nofollow\"><code>mocked-sessions</code></a></li>\n<li><a href=\"#mocked-sessionmakers\" rel=\"nofollow\"><code>mocked-sessionmakers</code></a></li>\n</ul>\n</li>\n<li><a href=\"#writing-transactional-tests\" rel=\"nofollow\">Writing transactional tests</a></li>\n</ul>\n</li>\n<li><a href=\"#fixtures\" rel=\"nofollow\">Fixtures</a>\n<ul>\n<li><a href=\"#db_session\" rel=\"nofollow\"><code>db_session</code></a></li>\n<li><a href=\"#db_engine\" rel=\"nofollow\"><code>db_engine</code></a></li>\n</ul>\n</li>\n<li><a href=\"#enabling-transactions-without-fixtures\" rel=\"nofollow\">Enabling transactions without fixtures</a></li>\n</ul>\n</li>\n<li><a href=\"#development\" rel=\"nofollow\"><strong>Development</strong></a>\n<ul>\n<li><a href=\"#running-the-tests\" rel=\"nofollow\">Running the tests</a></li>\n<li><a href=\"#acknowledgements\" rel=\"nofollow\">Acknowledgements</a></li>\n<li><a href=\"#copyright\" rel=\"nofollow\">Copyright</a></li>\n</ul>\n</li>\n</ul>\n<h2><a></a>Motivation</h2>\n<p>Inspired by <a href=\"https://jeancochrane.com/blog/django-test-transactions\" rel=\"nofollow\">Django's built-in support for transactional\ntests</a>, this plugin\nseeks to provide comprehensive, easy-to-use Pytest fixtures for wrapping tests in\ndatabase transactions for <a href=\"http://flask-sqlalchemy.pocoo.org/latest/\" rel=\"nofollow\">Flask-SQLAlchemy</a>\napps. The goal is to make testing stateful Flask-SQLAlchemy applications easier by\nproviding fixtures that permit the developer to <strong>make arbitrary database updates\nwith the confidence that any changes made during a test will roll back</strong> once the test exits.</p>\n<h2><a></a>Quick examples</h2>\n<p>Use the <a href=\"#db_session\" rel=\"nofollow\"><code>db_session</code> fixture</a> to make <strong>database updates that won't persist beyond\nthe body of the test</strong>:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">test_a_transaction</span><span class=\"p\">(</span><span class=\"n\">db_session</span><span class=\"p\">):</span>\n   <span class=\"n\">row</span> <span class=\"o\">=</span> <span class=\"n\">db_session</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">Table</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> \n   <span class=\"n\">row</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'testing'</span>\n\n   <span class=\"n\">db_session</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">)</span>\n   <span class=\"n\">db_session</span><span class=\"o\">.</span><span class=\"n\">commit</span><span class=\"p\">()</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_transaction_doesnt_persist</span><span class=\"p\">(</span><span class=\"n\">db_session</span><span class=\"p\">):</span>\n   <span class=\"n\">row</span> <span class=\"o\">=</span> <span class=\"n\">db_session</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">Table</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> \n   <span class=\"k\">assert</span> <span class=\"n\">row</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">!=</span> <span class=\"s1\">'testing'</span>\n</pre>\n<p>The <a href=\"#db_engine\" rel=\"nofollow\"><code>db_engine</code> fixture</a> works the same way, but <strong>copies the API of\nSQLAlchemy's <a href=\"http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine\" rel=\"nofollow\">Engine\nobject</a></strong>:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">test_a_transaction_using_engine</span><span class=\"p\">(</span><span class=\"n\">db_engine</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">db_engine</span><span class=\"o\">.</span><span class=\"n\">begin</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n        <span class=\"n\">row</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"s1\">'''UPDATE table SET name = 'testing' WHERE id = 1'''</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_transaction_doesnt_persist</span><span class=\"p\">(</span><span class=\"n\">db_engine</span><span class=\"p\">):</span>\n    <span class=\"n\">row_name</span> <span class=\"o\">=</span> <span class=\"n\">db_engine</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"s1\">'''SELECT name FROM table WHERE id = 1'''</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fetchone</span><span class=\"p\">()[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"k\">assert</span> <span class=\"n\">row_name</span> <span class=\"o\">!=</span> <span class=\"s1\">'testing'</span> \n</pre>\n<p>Use <a href=\"#test-configuration\" rel=\"nofollow\">configuration properties</a> to\n<strong>mock database connections in an app and enforce nested transactions</strong>,\nallowing any method from the codebase to run inside a test with the assurance\nthat any database changes made will be rolled back at the end of the test:</p>\n<pre><span class=\"c1\"># In setup.cfg</span>\n\n<span class=\"k\">[tool:pytest]</span>\n<span class=\"na\">mocked-sessions</span><span class=\"o\">=</span><span class=\"s\">database.db.session</span>\n<span class=\"na\">mocked-engines</span><span class=\"o\">=</span><span class=\"s\">database.engine</span>\n</pre>\n<pre><span class=\"c1\"># In database.py</span>\n\n<span class=\"n\">db</span> <span class=\"o\">=</span> <span class=\"n\">flask_sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">SQLAlchemy</span><span class=\"p\">()</span>\n<span class=\"n\">engine</span> <span class=\"o\">=</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">create_engine</span><span class=\"p\">(</span><span class=\"s1\">'DATABASE_URI'</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"c1\"># In models.py</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Table</span><span class=\"p\">(</span><span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">__tablename__</span> <span class=\"o\">=</span> <span class=\"s1\">'table'</span>\n    <span class=\"nb\">id</span> <span class=\"o\">=</span> <span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">(</span><span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">Integer</span><span class=\"p\">,</span> <span class=\"n\">primary_key</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">Column</span><span class=\"p\">(</span><span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">String</span><span class=\"p\">(</span><span class=\"mi\">80</span><span class=\"p\">))</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">set_name</span><span class=\"p\">(</span><span class=\"n\">new_name</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">new_name</span>\n        <span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n        <span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">commit</span><span class=\"p\">()</span>\n</pre>\n<pre><span class=\"c1\"># In tests/test_set_name.py</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_set_name</span><span class=\"p\">(</span><span class=\"n\">db_session</span><span class=\"p\">):</span>\n    <span class=\"n\">row</span> <span class=\"o\">=</span> <span class=\"n\">db_session</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">Table</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">row</span><span class=\"o\">.</span><span class=\"n\">set_name</span><span class=\"p\">(</span><span class=\"s1\">'testing'</span><span class=\"p\">)</span>\n    <span class=\"k\">assert</span> <span class=\"n\">row</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s1\">'testing'</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_transaction_doesnt_persist</span><span class=\"p\">(</span><span class=\"n\">db_session</span><span class=\"p\">):</span>\n   <span class=\"n\">row</span> <span class=\"o\">=</span> <span class=\"n\">db_session</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">Table</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> \n   <span class=\"k\">assert</span> <span class=\"n\">row</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">!=</span> <span class=\"s1\">'testing'</span>\n</pre>\n<h1><a></a>Usage</h1>\n<h2><a></a>Installation</h2>\n<h3><a></a>From PyPi</h3>\n<p>Install using pip:</p>\n<pre><code>pip install pytest-flask-sqlalchemy\n</code></pre>\n<p>Once installed, pytest will detect the plugin automatically during test collection.\nFor basic background on using third-party plugins with pytest, see the <a href=\"https://docs.pytest.org/en/latest/plugins.html?highlight=plugins\" rel=\"nofollow\">pytest\ndocumentation</a>.</p>\n<h3><a></a>Development version</h3>\n<p>Clone the repo from GitHub and switch into the new directory:</p>\n<pre><code>git clone git@github.com:jeancochrane/pytest-flask-sqlalchemy.git\ncd pytest-flask-sqlalchemy\n</code></pre>\n<p>You can install using pip:</p>\n<pre><code>pip install .\n</code></pre>\n<h3><a></a>Supported backends</h3>\n<p>So far, pytest-flask-sqlalchemy has been most extensively tested against\nPostgreSQL 9.6. It should theoretically work with any backend that is supported\nby SQLAlchemy, but Postgres is the only backend that is currently tested by the\ntest suite.</p>\n<p>Official support for SQLite and MySQL is <a href=\"https://github.com/jeancochrane/pytest-flask-sqlalchemy/issues/3\" rel=\"nofollow\">planned for a future\nrelease</a>.\nIn the meantime, if you're using one of those backends and you run in to\nproblems, we would greatly appreciate your help! <a href=\"https://github.com/jeancochrane/pytest-flask-sqlalchemy/issues/new\" rel=\"nofollow\">Open an\nissue</a> if\nsomething isn't working as you expect.</p>\n<h2><a></a>Configuration</h2>\n<h3><a></a>Conftest setup</h3>\n<p>This plugin assumes that a fixture called <code>_db</code> has been\ndefined in the root conftest file for your tests. The <code>_db</code> fixture should\nexpose access to a valid <a href=\"http://docs.sqlalchemy.org/en/latest/orm/session_api.html?highlight=session#sqlalchemy.orm.session.Session\" rel=\"nofollow\">SQLAlchemy <code>Session</code> object</a> that can interact with your database,\nfor example via the <a href=\"http://flask-sqlalchemy.pocoo.org/2.3/api/#flask_sqlalchemy.SQLAlchemy\" rel=\"nofollow\"><code>SQLAlchemy</code> initialization class</a>\nthat configures Flask-SQLAlchemy.</p>\n<p>The fixtures in this plugin depend on this <code>_db</code> fixture to access your\ndatabase and create nested transactions to run tests in. <strong>You must define\nthis fixture in your <code>conftest.py</code> file for the plugin to work.</strong></p>\n<p>An example setup that will produce a valid <code>_db</code> fixture could look like this\n(this example comes from the <a href=\"./tests/_conftest.py#L25-L61\" rel=\"nofollow\">test setup</a> for this repo):</p>\n<pre><span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">fixture</span><span class=\"p\">(</span><span class=\"n\">scope</span><span class=\"o\">=</span><span class=\"s1\">'session'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">database</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''</span>\n<span class=\"sd\">    Create a Postgres database for the tests, and drop it when the tests are done.</span>\n<span class=\"sd\">    '''</span>\n    <span class=\"n\">pg_host</span> <span class=\"o\">=</span> <span class=\"n\">DB_OPTS</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"host\"</span><span class=\"p\">)</span>\n    <span class=\"n\">pg_port</span> <span class=\"o\">=</span> <span class=\"n\">DB_OPTS</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"port\"</span><span class=\"p\">)</span>\n    <span class=\"n\">pg_user</span> <span class=\"o\">=</span> <span class=\"n\">DB_OPTS</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"username\"</span><span class=\"p\">)</span>\n    <span class=\"n\">pg_db</span> <span class=\"o\">=</span> <span class=\"n\">DB_OPTS</span><span class=\"p\">[</span><span class=\"s2\">\"database\"</span><span class=\"p\">]</span>\n\n    <span class=\"n\">init_postgresql_database</span><span class=\"p\">(</span><span class=\"n\">pg_user</span><span class=\"p\">,</span> <span class=\"n\">pg_host</span><span class=\"p\">,</span> <span class=\"n\">pg_port</span><span class=\"p\">,</span> <span class=\"n\">pg_db</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@request</span><span class=\"o\">.</span><span class=\"n\">addfinalizer</span>\n    <span class=\"k\">def</span> <span class=\"nf\">drop_database</span><span class=\"p\">():</span>\n        <span class=\"n\">drop_postgresql_database</span><span class=\"p\">(</span><span class=\"n\">pg_user</span><span class=\"p\">,</span> <span class=\"n\">pg_host</span><span class=\"p\">,</span> <span class=\"n\">pg_port</span><span class=\"p\">,</span> <span class=\"n\">pg_db</span><span class=\"p\">,</span> <span class=\"mf\">9.6</span><span class=\"p\">)</span>\n\n\n<span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">fixture</span><span class=\"p\">(</span><span class=\"n\">scope</span><span class=\"o\">=</span><span class=\"s1\">'session'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">app</span><span class=\"p\">(</span><span class=\"n\">database</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''</span>\n<span class=\"sd\">    Create a Flask app context for the tests.</span>\n<span class=\"sd\">    '''</span>\n    <span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Flask</span><span class=\"p\">(</span><span class=\"vm\">__name__</span><span class=\"p\">)</span>\n\n    <span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"p\">[</span><span class=\"s1\">'SQLALCHEMY_DATABASE_URI'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">DB_CONN</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">app</span>\n\n\n<span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">fixture</span><span class=\"p\">(</span><span class=\"n\">scope</span><span class=\"o\">=</span><span class=\"s1\">'session'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">_db</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''</span>\n<span class=\"sd\">    Provide the transactional fixtures with access to the database via a Flask-SQLAlchemy</span>\n<span class=\"sd\">    database connection.</span>\n<span class=\"sd\">    '''</span>\n    <span class=\"n\">db</span> <span class=\"o\">=</span> <span class=\"n\">SQLAlchemy</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"o\">=</span><span class=\"n\">app</span><span class=\"p\">)</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">db</span>\n</pre>\n<p>Alternatively, if you already have a fixture that sets up database access for\nyour tests, you can define <code>_db</code> to return that fixture directly:</p>\n<pre><span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">fixture</span><span class=\"p\">(</span><span class=\"n\">scope</span><span class=\"o\">=</span><span class=\"s1\">'session'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">database</span><span class=\"p\">():</span>\n    <span class=\"c1\"># Set up all your database stuff here</span>\n    <span class=\"c1\"># ...</span>\n    <span class=\"k\">return</span> <span class=\"n\">db</span>\n\n<span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">fixture</span><span class=\"p\">(</span><span class=\"n\">scope</span><span class=\"o\">=</span><span class=\"s1\">'session'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">_db</span><span class=\"p\">(</span><span class=\"n\">database</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">database</span>\n</pre>\n<h3><a></a>Test configuration</h3>\n<p>This plugin allows you to configure a few different properties in a\n<code>setup.cfg</code> test configuration file in order to handle the specific database connection needs\nof your app. For basic background on setting up pytest configuration files, see\nthe <a href=\"https://docs.pytest.org/en/latest/customize.html#adding-default-options\" rel=\"nofollow\">pytest docs</a>.</p>\n<p>All three configuration properties (<a href=\"#mocked-engines\" rel=\"nofollow\"><code>mocked-engines</code></a>,\n<a href=\"#mocked-sessions\" rel=\"nofollow\"><code>mocked-sessions</code></a>, and <a href=\"#mocked-sessionmakers\" rel=\"nofollow\"><code>mocked-sessionmakers</code></a>)\nwork by <strong><a href=\"https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch\" rel=\"nofollow\">patching</a>\none or more specified objects during a test</strong>, replacing them with equivalent objects whose\ndatabase interactions will run inside of a transaction and ultimately be\nrolled back when the test exits. Using these patches, you can call methods from\nyour codebase that alter database state with the knowledge that no changes will persist\nbeyond the body of the test.</p>\n<p>The configured patches are only applied in tests where a transactional fixture\n(either <a href=\"#db_session\" rel=\"nofollow\"><code>db_session</code></a> or <a href=\"#db_engine\" rel=\"nofollow\"><code>db_engine</code></a>) is included\nin the test function arguments.</p>\n<h4><a></a><code>mocked-engines</code></h4>\n<p>The <code>mocked-engines</code> property directs the plugin to <a href=\"https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch\" rel=\"nofollow\">patch</a>\nobjects in your codebase, typically SQLAlchemy <a href=\"http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine\" rel=\"nofollow\">Engine</a>\ninstances, replacing them with the <a href=\"#db_engine\" rel=\"nofollow\"><code>db_engine</code> fixture</a> such that\nany database updates performed by the objects get rolled back at the end of\nthe test.</p>\n<p>The value for this property should be formatted as a whitespace-separated list\nof standard Python import paths, like <code>database.engine</code>. This property is <strong>optional</strong>.</p>\n<p>Example:</p>\n<pre><span class=\"c1\"># In database.py</span>\n\n<span class=\"n\">engine</span> <span class=\"o\">=</span> <span class=\"n\">sqlalchemy</span><span class=\"o\">.</span><span class=\"n\">create_engine</span><span class=\"p\">(</span><span class=\"n\">DATABASE_URI</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"c1\"># In setup.cfg</span>\n\n<span class=\"k\">[tool:pytest]</span>\n<span class=\"na\">mocked-engines</span><span class=\"o\">=</span><span class=\"s\">database.engine</span>\n</pre>\n<p>To patch multiple objects at once, separate the paths with a whitespace:</p>\n<pre><span class=\"c1\"># In setup.cfg</span>\n\n<span class=\"k\">[tool:pytest]</span>\n<span class=\"na\">mocked-engines</span><span class=\"o\">=</span><span class=\"s\">database.engine database.second_engine</span>\n</pre>\n<h4><a></a><code>mocked-sessions</code></h4>\n<p>The <code>mocked-sessions</code> property directs the plugin to <a href=\"https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch\" rel=\"nofollow\">patch</a>\nobjects in your codebase, typically SQLAlchemy <a href=\"http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine\" rel=\"nofollow\">Session</a>\ninstances, replacing them with the <a href=\"#db_session\" rel=\"nofollow\"><code>db_session</code></a> fixture such that\nany database updates performed by the objects get rolled back at the end of\nthe test.</p>\n<p>The value for this property should be formatted as a whitespace-separated list\nof standard Python import paths, like <code>database.db.session</code>. This property is <strong>optional</strong>.</p>\n<p>Example:</p>\n<pre><span class=\"c1\"># In database.py</span>\n\n<span class=\"n\">db</span> <span class=\"o\">=</span> <span class=\"n\">SQLAlchemy</span><span class=\"p\">()</span>\n</pre>\n<pre><span class=\"c1\"># In setup.cfg</span>\n\n<span class=\"k\">[tool:pytest]</span>\n<span class=\"na\">mocked-sessions</span><span class=\"o\">=</span><span class=\"s\">database.db.session</span>\n</pre>\n<p>To patch multiple objects at once, separate the paths with a whitespace:</p>\n<pre><span class=\"c1\"># In setup.cfg</span>\n\n<span class=\"k\">[tool:pytest]</span>\n<span class=\"na\">mocked-sessions</span><span class=\"o\">=</span><span class=\"s\">database.db.session database.second_db.session</span>\n</pre>\n<h4><a></a><code>mocked-sessionmakers</code></h4>\n<p>The <code>mocked-sessionmakers</code> property directs the plugin to <a href=\"https://docs.python.org/3/library/unittest.mock.html#unittest.mock.patch\" rel=\"nofollow\">patch</a>\nobjects in your codebase, typically instances of <a href=\"http://docs.sqlalchemy.org/en/latest/orm/session_api.html?highlight=sessionmaker#sqlalchemy.orm.session.sessionmaker\" rel=\"nofollow\">SQLAlchemy's <code>sessionmaker</code>\nfactory</a>,\nreplacing them with a mocked class that will return the transactional\n<a href=\"#db_session\" rel=\"nofollow\"><code>db_session</code></a> fixture. This can be useful if you have\npre-configured instances of sessionmaker objects that you import in the code\nto spin up sessions on the fly.</p>\n<p>The value for this property should be formatted as a whitespace-separated list\nof standard Python import paths, like <code>database.WorkerSessionmaker</code>. This property is <strong>optional</strong>.</p>\n<p>Example:</p>\n<pre><span class=\"c1\"># In database.py</span>\n\n<span class=\"n\">WorkerSessionmaker</span> <span class=\"o\">=</span> <span class=\"n\">sessionmaker</span><span class=\"p\">()</span>\n</pre>\n<pre><span class=\"k\">[tool:pytest]</span>\n<span class=\"na\">mocked-sessionmakers</span><span class=\"o\">=</span><span class=\"s\">database.WorkerSessionmaker</span>\n</pre>\n<p>To patch multiple objects at once, separate the paths with a whitespace.</p>\n<pre><span class=\"k\">[tool:pytest]</span>\n<span class=\"na\">mocked-sessionmakers</span><span class=\"o\">=</span><span class=\"s\">database.WorkerSessionmaker database.SecondWorkerSessionmaker</span>\n</pre>\n<h3><a></a>Writing transactional tests</h3>\n<p>Once you have your <a href=\"#conftest-setup\" rel=\"nofollow\">conftest file set up</a> and you've <a href=\"#test-configuration\" rel=\"nofollow\">overrided the\nnecessary connectables in your test configuration</a>, you're ready\nto write some transactional tests. Simply import one of the module's <a href=\"#fixtures\" rel=\"nofollow\">transactional\nfixtures</a> in your test signature, and the test will be wrapped in a transaction.</p>\n<p>Note that by default, <strong>tests are only wrapped in transactions if they import one of\nthe <a href=\"#fixtures\" rel=\"nofollow\">transactional fixtures</a> provided by this module.</strong> Tests that do not\nimport the fixture will interact with your database without opening a transaction:</p>\n<pre><span class=\"c1\"># This test will be wrapped in a transaction.</span>\n<span class=\"k\">def</span> <span class=\"nf\">transactional_test</span><span class=\"p\">(</span><span class=\"n\">db_session</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n\n<span class=\"c1\"># This test **will not** be wrapped in a transaction, since it does not import a</span>\n<span class=\"c1\"># transactional fixture.</span>\n<span class=\"k\">def</span> <span class=\"nf\">non_transactional_test</span><span class=\"p\">():</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>The fixtures provide a way for you to control which tests require transactions and\nwhich don't. This is often useful, since avoiding transaction setup can speed up\ntests that don't interact with your database.</p>\n<p>For more information about the transactional fixtures provided by this module, read on\nto the <a href=\"#fixtures\" rel=\"nofollow\">fixtures section</a>. For guidance on how to automatically enable\ntransactions without having to specify fixtures, see the section on <a href=\"#enabling-transactions-without-fixtures\" rel=\"nofollow\">enabling transactions\nwithout fixtures</a>.</p>\n<h2><a></a>Fixtures</h2>\n<p>This plugin provides two fixtures for performing database updates inside nested\ntransactions that get rolled back at the end of a test: <a href=\"#db_session\" rel=\"nofollow\"><code>db_session</code></a> and\n<a href=\"#db_engine\" rel=\"nofollow\"><code>db_engine</code></a>. The fixtures provide similar functionality, but\nwith different APIs.</p>\n<h3><a></a><code>db_session</code></h3>\n<p>The <code>db_session</code> fixture allows you to perform direct updates that will be\nrolled back when the test exits. It exposes the same API as <a href=\"http://docs.sqlalchemy.org/en/latest/orm/contextual.html#sqlalchemy.orm.scoping.scoped_session\" rel=\"nofollow\">SQLAlchemy's\n<code>scoped_session</code> object</a>.</p>\n<p>Including this fixture as a function argument of a test will activate any mocks that are defined\nby the configuration properties <a href=\"#mocked-engines\" rel=\"nofollow\"><code>mocked-engines</code></a>, <a href=\"#mocked-sessions\" rel=\"nofollow\"><code>mocked-sessions</code></a>,\nor <a href=\"#mocked-sessionmakers\" rel=\"nofollow\"><code>mocked-sessionmakers</code></a> in the test configuration file for\nthe duration of that test.</p>\n<p>Example:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">test_a_transaction</span><span class=\"p\">(</span><span class=\"n\">db_session</span><span class=\"p\">):</span>\n   <span class=\"n\">row</span> <span class=\"o\">=</span> <span class=\"n\">db_session</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">Table</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> \n   <span class=\"n\">row</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'testing'</span>\n\n   <span class=\"n\">db_session</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">)</span>\n   <span class=\"n\">db_session</span><span class=\"o\">.</span><span class=\"n\">commit</span><span class=\"p\">()</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_transaction_doesnt_persist</span><span class=\"p\">(</span><span class=\"n\">db_session</span><span class=\"p\">):</span>\n   <span class=\"n\">row</span> <span class=\"o\">=</span> <span class=\"n\">db_session</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">Table</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> \n   <span class=\"k\">assert</span> <span class=\"n\">row</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">!=</span> <span class=\"s1\">'testing'</span>\n</pre>\n<h3><a></a><code>db_engine</code></h3>\n<p>Like <a href=\"#db_session\" rel=\"nofollow\"><code>db_session</code></a>, the <code>db_engine</code> fixture allows you to perform direct updates\nagainst the test database that will be rolled back when the test exits. It is\nan instance of Python's built-in <a href=\"https://docs.python.org/3/library/unittest.mock.html#unittest.mock.MagicMock\" rel=\"nofollow\"><code>MagicMock</code></a>\nclass, with a spec set to match the API of <a href=\"http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine\" rel=\"nofollow\">SQLAlchemy's\n<code>Engine</code></a> object.</p>\n<p>Only a few <code>Engine</code> methods are exposed on this fixture:</p>\n<ul>\n<li><code>db_engine.begin</code>: begin a new nested transaction (<a href=\"http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine.begin\" rel=\"nofollow\">API docs</a>)</li>\n<li><code>db_engine.execute</code>: execute a raw SQL query (<a href=\"http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine.execute\" rel=\"nofollow\">API docs</a>)</li>\n<li><code>db_engine.raw_connection</code>: return a raw DBAPI connection (<a href=\"http://docs.sqlalchemy.org/en/latest/core/connections.html#sqlalchemy.engine.Engine.raw_connection\" rel=\"nofollow\">API docs</a>)</li>\n</ul>\n<p>Since <code>db_engine</code> is an instance of <code>MagicMock</code> with an <code>Engine</code> spec, other\nmethods of the <code>Engine</code> API can be called, but they will not perform any useful\nwork.</p>\n<p>Including this fixture as a function argument of a test will activate any mocks that are defined\nby the configuration properties <a href=\"#mocked-engines\" rel=\"nofollow\"><code>mocked-engines</code></a>, <a href=\"#mocked-sessions\" rel=\"nofollow\"><code>mocked-sessions</code></a>,\nor <a href=\"#mocked-sessionmakers\" rel=\"nofollow\"><code>mocked-sessionmakers</code></a> in the test configuration file for\nthe duration of that test.</p>\n<p>Example:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">test_a_transaction_using_engine</span><span class=\"p\">(</span><span class=\"n\">db_engine</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">db_engine</span><span class=\"o\">.</span><span class=\"n\">begin</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n        <span class=\"n\">row</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"s1\">'''UPDATE table SET name = 'testing' WHERE id = 1'''</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_transaction_doesnt_persist</span><span class=\"p\">(</span><span class=\"n\">db_engine</span><span class=\"p\">):</span>\n    <span class=\"n\">row_name</span> <span class=\"o\">=</span> <span class=\"n\">db_engine</span><span class=\"o\">.</span><span class=\"n\">execute</span><span class=\"p\">(</span><span class=\"s1\">'''SELECT name FROM table WHERE id = 1'''</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fetchone</span><span class=\"p\">()[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"k\">assert</span> <span class=\"n\">row_name</span> <span class=\"o\">!=</span> <span class=\"s1\">'testing'</span> \n</pre>\n<h2><a></a>Enabling transactions without fixtures</h2>\n<p>If you know you want to make all of your tests transactional, it can be annoying to have\nto specify one of the <a href=\"#fixtures\" rel=\"nofollow\">fixtures</a> in every test signature.</p>\n<p>The best way to automatically enable transactions without having to include an extra fixture\nin every test is to wire up an\n<a href=\"https://docs.pytest.org/en/latest/fixture.html#autouse-fixtures-xunit-setup-on-steroids\" rel=\"nofollow\">autouse fixture</a>\nfor your test suite. This can be as simple as:</p>\n<pre><span class=\"c1\"># Automatically enable transactions for all tests, without importing any extra fixtures.</span>\n<span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">fixture</span><span class=\"p\">(</span><span class=\"n\">autouse</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">enable_transactional_tests</span><span class=\"p\">(</span><span class=\"n\">db_session</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n</pre>\n<p>In this configuration, the <code>enable_transactional_tests</code> fixture will be automatically used in\nall tests, meaning that <code>db_session</code> will also be used. This way, all tests will be wrapped\nin transactions without having to explicitly require either <code>db_session</code> or <code>enable_transactional_tests</code>.</p>\n<h1><a></a>Development</h1>\n<h2><a></a>Running the tests</h2>\n<p>To run the tests, start by installing a development version of the plugin that\nincludes test dependencies:</p>\n<pre><code>pip install -e .[tests]\n</code></pre>\n<p>Next, export a <a href=\"http://docs.sqlalchemy.org/en/latest/core/engines.html#database-urls\" rel=\"nofollow\">database connection string</a>\nthat the tests can use (the database referenced by the string will be created\nduring test setup, so it does not need to exist):</p>\n<pre><code>export TEST_DATABASE_URL=&lt;db_connection_string&gt;\n</code></pre>\n<p>Finally, run the tests using pytest:</p>\n<pre><code>pytest\n</code></pre>\n<h2><a></a>Acknowledgements</h2>\n<p>This plugin was initially developed for testing\n<a href=\"https://dedupe.io\" rel=\"nofollow\">Dedupe.io</a>, a web app for record linkage and entity\nresolution using machine learning. Dedupe.io is built and maintained\nby <a href=\"https://datamade.us\" rel=\"nofollow\">DataMade</a>.</p>\n<p>The code is greatly indebted to <a href=\"https://github.com/alexmic\" rel=\"nofollow\">Alex Michael</a>,\nwhose blog post <a href=\"http://alexmic.net/flask-sqlalchemy-pytest/\" rel=\"nofollow\">\"Delightful testing with pytest and\nFlask-SQLAlchemy\"</a> helped\nestablish the basic approach on which this plugin builds.</p>\n<p>Many thanks to <a href=\"https://github.com/igortg/\" rel=\"nofollow\">Igor Ghisi</a>, who donated the PyPi\npackage name. Igor had been working on a similar plugin and proposed combining\nefforts. Thanks to Igor, the plugin name is much stronger.</p>\n<h2><a></a>Copyright</h2>\n<p>Copyright (c) 2019 Jean Cochrane and DataMade. Released under the MIT License.</p>\n<p>Third-party copyright in this distribution is noted where applicable.</p>\n\n          </div>"}, "last_serial": 5093759, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "60292c4427892c985eb84139990374e0", "sha256": "36a9a7f3db8f50894653e73d0209f3aa5afa97b110c52b2ea61728d2484e1ec1"}, "downloads": -1, "filename": "pytest_flask_sqlalchemy-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "60292c4427892c985eb84139990374e0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 9813, "upload_time": "2018-08-02T01:01:21", "upload_time_iso_8601": "2018-08-02T01:01:21.254548Z", "url": "https://files.pythonhosted.org/packages/63/60/2d8360a81bfaf5fb98f1cad9a92c30f444daac1c2f96b9854b5693629bcd/pytest_flask_sqlalchemy-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9e98241cc11c3f4d6226bd5cadd70355", "sha256": "240e9cdf8edafded79045773c68d945a544a4f0b78f7ae9370ce67e8683c6af3"}, "downloads": -1, "filename": "pytest-flask-sqlalchemy-1.0.0.tar.gz", "has_sig": false, "md5_digest": "9e98241cc11c3f4d6226bd5cadd70355", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11370, "upload_time": "2018-08-02T01:01:22", "upload_time_iso_8601": "2018-08-02T01:01:22.488345Z", "url": "https://files.pythonhosted.org/packages/46/c6/16bee5395d03e41e69a5f811f10ee6c92d4b7aeb39e02d8b440b54d37e29/pytest-flask-sqlalchemy-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "cf54728bf091a6370fbcf46222fb29fd", "sha256": "6de3a81cb5616026f565869ed81f015bdcc8e8777da2201ad87ef955a2ba1468"}, "downloads": -1, "filename": "pytest_flask_sqlalchemy-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "cf54728bf091a6370fbcf46222fb29fd", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11494, "upload_time": "2019-03-02T19:03:57", "upload_time_iso_8601": "2019-03-02T19:03:57.339398Z", "url": "https://files.pythonhosted.org/packages/90/a3/50d92b16984fe759e11fea861c177ae32ca5c47dca6de35f591b1835ed88/pytest_flask_sqlalchemy-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "85bd2c0db75d161a9952ece64ead4a12", "sha256": "ee3c409f213893c33ce891b0416ab0ad050e86103cc24368bf75f5c1b3366a8e"}, "downloads": -1, "filename": "pytest-flask-sqlalchemy-1.0.1.tar.gz", "has_sig": false, "md5_digest": "85bd2c0db75d161a9952ece64ead4a12", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11257, "upload_time": "2019-03-02T19:03:58", "upload_time_iso_8601": "2019-03-02T19:03:58.726338Z", "url": "https://files.pythonhosted.org/packages/47/e7/840a437f4d18e196f8d69cc8d58547091d5bedac546b4330c87cc57a6c96/pytest-flask-sqlalchemy-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "ecf3e0ce078c292991785df0307e142f", "sha256": "19cad31d654c2301dd2dd70d06a62e5dc4ea380500f4b89bbcb3d59a475f0cf6"}, "downloads": -1, "filename": "pytest_flask_sqlalchemy-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "ecf3e0ce078c292991785df0307e142f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11659, "upload_time": "2019-04-04T00:49:34", "upload_time_iso_8601": "2019-04-04T00:49:34.146094Z", "url": "https://files.pythonhosted.org/packages/b2/bc/2c2c3249a1328fc22e7f2c5027f1316f49bf0428c37492b344c4d7c25b24/pytest_flask_sqlalchemy-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ee2f86c77d061d95ed22c0be302055d4", "sha256": "34fa0f9a63c3892f54a8d11ab67f907c0e0911ac609e3cff5d518c3af6b897cd"}, "downloads": -1, "filename": "pytest-flask-sqlalchemy-1.0.2.tar.gz", "has_sig": false, "md5_digest": "ee2f86c77d061d95ed22c0be302055d4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11413, "upload_time": "2019-04-04T00:49:35", "upload_time_iso_8601": "2019-04-04T00:49:35.750216Z", "url": "https://files.pythonhosted.org/packages/a2/19/4c975be16c745db333d7bc7809e0bfb8f22b6ac0daf9880bba24a689029a/pytest-flask-sqlalchemy-1.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ecf3e0ce078c292991785df0307e142f", "sha256": "19cad31d654c2301dd2dd70d06a62e5dc4ea380500f4b89bbcb3d59a475f0cf6"}, "downloads": -1, "filename": "pytest_flask_sqlalchemy-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "ecf3e0ce078c292991785df0307e142f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11659, "upload_time": "2019-04-04T00:49:34", "upload_time_iso_8601": "2019-04-04T00:49:34.146094Z", "url": "https://files.pythonhosted.org/packages/b2/bc/2c2c3249a1328fc22e7f2c5027f1316f49bf0428c37492b344c4d7c25b24/pytest_flask_sqlalchemy-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ee2f86c77d061d95ed22c0be302055d4", "sha256": "34fa0f9a63c3892f54a8d11ab67f907c0e0911ac609e3cff5d518c3af6b897cd"}, "downloads": -1, "filename": "pytest-flask-sqlalchemy-1.0.2.tar.gz", "has_sig": false, "md5_digest": "ee2f86c77d061d95ed22c0be302055d4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11413, "upload_time": "2019-04-04T00:49:35", "upload_time_iso_8601": "2019-04-04T00:49:35.750216Z", "url": "https://files.pythonhosted.org/packages/a2/19/4c975be16c745db333d7bc7809e0bfb8f22b6ac0daf9880bba24a689029a/pytest-flask-sqlalchemy-1.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:55:08 2020"}