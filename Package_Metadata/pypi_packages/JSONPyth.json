{"info": {"author": "Mark Frimston", "author_email": "mfrimston@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3 :: Only"], "description": "# JSONPyth #\n\n[![Build Status](https://travis-ci.com/Frimkron/JSONPyth.svg?branch=master)](\n    https://travis-ci.com/Frimkron/JSONPyth)\n\nAnother [JSONPath] implementation for Python.\n\nSupports:\n\n* Root `$` and current `@` node\n* Child operator `.` or `[` ... `]`\n* Property access (including single quote `'` and double `\"` quote delimited \n  names)\n* Recursive descent `..`\n* Wildcard `*`\n* Sets of names/indices `[a,b,c]`\n* Array slice `[start:end:step]` (including negative values)\n* Python script expression `(` ... `)` and filter expression `?(` ... `)` using \n  `$` and `@`\n\n\n## Requirements\n\nRequires Python 3.5+ and depends on the [PyParsing] package.\n\n\n## Installation ##\n\nJSONPyth can be git-cloned directly from Github and installed along with its \ndependencies using `pip`:\n\n    $ pip install git+https://github.com/Frimkron/JSONPyth#egg=JSONPyth\n\nOr the source can be downloaded manually and then installed by running the \n`setup.py` script:\n\n    $ python setup.py install\n    \n\n## Usage ##\n\nFirst parse some JSON data into a Python structure, for example using the [json]\npackage from the standard library:\n\n``` python\n\nimport json\n\n# parse some JSON from a string\ndata = json.loads(\"\"\"\n    {\n        \"cakes\": [\n            { \"name\": \"red velvet\", \"rating\": 4.5 },\n            { \"name\": \"battenberg\" },\n            { \"name\": \"jaffa cakes\", \"rating\": 5.0 }\n        ],\n        \"biscuits\": [\n            { \"name\": \"bourbon\", \"rating\": 5.0 },\n            { \"name\": \"custard cream\", \"rating\": 3.5 },\n            { \"name\": \"pink wafer\", \"rating\": null },\n            { \"name\": \"nice\" }\n        ]\n    }\n\"\"\")\n\n```\n\nThen the data can be queried with a JSONPath expression:\n\n``` python\n\nfrom jsonpyth import jsonpath\n\nresult = jsonpath(data, '$.biscuits[*].rating')\n\nfor r in result:\n    print(r)\n    \n```\n\nThe example above would print the following output:\n\n``` \n5\n3.5\nNone\n\n```\n\n### Returning Paths\n\nBy default the value of each result is returned. To obtain the normalised path\nof each result instead, set the `result_type` parameter to `RESULT_TYPE_PATH`,\nor `RESULT_TYPE_BOTH` can be used to return 2-tuples containing both the value\nand the path:\n\n``` python\n\nfrom jsonpyth import jsonpath, RESULT_TYPE_BOTH\n\nresult = jsonpath(data, '$.biscuits[*].rating', result_type=RESULT_TYPE_BOTH):\n\nfor r in result:\n    print(r)\n\n```\n\nOutput:\n\n``` \n(5, '$[\"biscuits\"][0][\"rating\"]')\n(3.5, '$[\"biscuits\"][1][\"rating\"]')\n(None, '$[\"biscuits\"][2][\"rating\"]')\n```\n\n### Python Expressions\n\nA JSONPath _script expression_ (enclosed in parentheses `(...)` ) can be used to\nevaluate a Python statement to provide a dictionary key as a string, or list \nindex as a number. Return values of other types will be ignored.\n\nAs parentheses are used to delimit the expression, parentheses used in the \nscript itself must be escaped with a backslash `\\`.\n\nThe special symbols `@` (current node) and `$` (root node) will be substituted \nfor variables named `__current` and `__root` respectively, using a simple text \nreplacement before the statement is evaluated. To use a literal `@` or `$` in\nthe script, it must be escaped with _two_ backslashes `\\\\`. Note that a string \nliteral will recognise `\\\\` as an escaped backslash; in such a case each \nbackslash must be further escaped (`\"\\\\\\\\@\"`) or else a raw literal used \n(`r\"\\\\@\"`).\n\nAn example script expression:\n\n``` python\n\nresult = jsonpath(data, r'$.cakes[(len\\(@\\)-1)].name')\n\nfor r in result:\n    print(r)\n```\n\nOutput:\n\n``` \njaffa cakes\n```\n\n**NOTE** JSONPyth calls `eval` to evaluate Python script, and so is **unsafe**\nto use for JSONPath expressions from untrusted sources.\n\n\n### Python Filters\n\nSimilar to expressions, filters ( `?(...)` ) use a Python statement to test \nwhether to include a node or not. The truthiness of the resulting value will be\ntested using `bool`, and if `False` the node will be omitted.\n\nExample:\n\n``` python\n\nresult = jsonpath(data, r'$[*][?(@[\"name\"].startswith\\(\"b\"\\))]')\n\nfor r in result:\n    print(r)\n```\n\nOutput:\n\n``` \n{\"name\": \"battenberg\"}\n{\"name\": \"bourbon\", \"rating\": 5}\n```\n\n\n# Credits and Licence\n\n[JSONPyth] was written by Mark Frimston and is licenced using the the MIT \nlicence. The full text of this licence can be found in the `LICENCE.txt` file.\n\n\n[JSONPath]: http://goessner.net/articles/JsonPath/\n[PyParsing]: https://github.com/pyparsing/pyparsing\n[json]: https://docs.python.org/3/library/json.html\n[JSONPyth]: https://github.com/Frimkron/JSONPyth", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Frimkron/JSONPyth", "keywords": "json jsonpath xpath query", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "JSONPyth", "package_url": "https://pypi.org/project/JSONPyth/", "platform": "", "project_url": "https://pypi.org/project/JSONPyth/", "project_urls": {"Homepage": "https://github.com/Frimkron/JSONPyth"}, "release_url": "https://pypi.org/project/JSONPyth/0.1.3/", "requires_dist": null, "requires_python": ">=3.5", "summary": "A JSONPath implementation for Python", "version": "0.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>JSONPyth</h1>\n<p><a href=\"https://travis-ci.com/Frimkron/JSONPyth\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0a8121d1f5d7473d539875262bcdd0ef9cf71f0b/68747470733a2f2f7472617669732d63692e636f6d2f4672696d6b726f6e2f4a534f4e507974682e7376673f6272616e63683d6d6173746572\"></a></p>\n<p>Another <a href=\"http://goessner.net/articles/JsonPath/\" rel=\"nofollow\">JSONPath</a> implementation for Python.</p>\n<p>Supports:</p>\n<ul>\n<li>Root <code>$</code> and current <code>@</code> node</li>\n<li>Child operator <code>.</code> or <code>[</code> ... <code>]</code></li>\n<li>Property access (including single quote <code>'</code> and double <code>\"</code> quote delimited\nnames)</li>\n<li>Recursive descent <code>..</code></li>\n<li>Wildcard <code>*</code></li>\n<li>Sets of names/indices <code>[a,b,c]</code></li>\n<li>Array slice <code>[start:end:step]</code> (including negative values)</li>\n<li>Python script expression <code>(</code> ... <code>)</code> and filter expression <code>?(</code> ... <code>)</code> using\n<code>$</code> and <code>@</code></li>\n</ul>\n<h2>Requirements</h2>\n<p>Requires Python 3.5+ and depends on the <a href=\"https://github.com/pyparsing/pyparsing\" rel=\"nofollow\">PyParsing</a> package.</p>\n<h2>Installation</h2>\n<p>JSONPyth can be git-cloned directly from Github and installed along with its\ndependencies using <code>pip</code>:</p>\n<pre><code>$ pip install git+https://github.com/Frimkron/JSONPyth#egg=JSONPyth\n</code></pre>\n<p>Or the source can be downloaded manually and then installed by running the\n<code>setup.py</code> script:</p>\n<pre><code>$ python setup.py install\n</code></pre>\n<h2>Usage</h2>\n<p>First parse some JSON data into a Python structure, for example using the <a href=\"https://docs.python.org/3/library/json.html\" rel=\"nofollow\">json</a>\npackage from the standard library:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">json</span>\n\n<span class=\"c1\"># parse some JSON from a string</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">loads</span><span class=\"p\">(</span><span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">    {</span>\n<span class=\"s2\">        \"cakes\": [</span>\n<span class=\"s2\">            { \"name\": \"red velvet\", \"rating\": 4.5 },</span>\n<span class=\"s2\">            { \"name\": \"battenberg\" },</span>\n<span class=\"s2\">            { \"name\": \"jaffa cakes\", \"rating\": 5.0 }</span>\n<span class=\"s2\">        ],</span>\n<span class=\"s2\">        \"biscuits\": [</span>\n<span class=\"s2\">            { \"name\": \"bourbon\", \"rating\": 5.0 },</span>\n<span class=\"s2\">            { \"name\": \"custard cream\", \"rating\": 3.5 },</span>\n<span class=\"s2\">            { \"name\": \"pink wafer\", \"rating\": null },</span>\n<span class=\"s2\">            { \"name\": \"nice\" }</span>\n<span class=\"s2\">        ]</span>\n<span class=\"s2\">    }</span>\n<span class=\"s2\">\"\"\"</span><span class=\"p\">)</span>\n</pre>\n<p>Then the data can be queried with a JSONPath expression:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">jsonpyth</span> <span class=\"kn\">import</span> <span class=\"n\">jsonpath</span>\n\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">jsonpath</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"s1\">'$.biscuits[*].rating'</span><span class=\"p\">)</span>\n\n<span class=\"k\">for</span> <span class=\"n\">r</span> <span class=\"ow\">in</span> <span class=\"n\">result</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">)</span>\n    \n</pre>\n<p>The example above would print the following output:</p>\n<pre><code>5\n3.5\nNone\n\n</code></pre>\n<h3>Returning Paths</h3>\n<p>By default the value of each result is returned. To obtain the normalised path\nof each result instead, set the <code>result_type</code> parameter to <code>RESULT_TYPE_PATH</code>,\nor <code>RESULT_TYPE_BOTH</code> can be used to return 2-tuples containing both the value\nand the path:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">jsonpyth</span> <span class=\"kn\">import</span> <span class=\"n\">jsonpath</span><span class=\"p\">,</span> <span class=\"n\">RESULT_TYPE_BOTH</span>\n\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">jsonpath</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"s1\">'$.biscuits[*].rating'</span><span class=\"p\">,</span> <span class=\"n\">result_type</span><span class=\"o\">=</span><span class=\"n\">RESULT_TYPE_BOTH</span><span class=\"p\">):</span>\n\n<span class=\"k\">for</span> <span class=\"n\">r</span> <span class=\"ow\">in</span> <span class=\"n\">result</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">)</span>\n</pre>\n<p>Output:</p>\n<pre><code>(5, '$[\"biscuits\"][0][\"rating\"]')\n(3.5, '$[\"biscuits\"][1][\"rating\"]')\n(None, '$[\"biscuits\"][2][\"rating\"]')\n</code></pre>\n<h3>Python Expressions</h3>\n<p>A JSONPath <em>script expression</em> (enclosed in parentheses <code>(...)</code> ) can be used to\nevaluate a Python statement to provide a dictionary key as a string, or list\nindex as a number. Return values of other types will be ignored.</p>\n<p>As parentheses are used to delimit the expression, parentheses used in the\nscript itself must be escaped with a backslash <code>\\</code>.</p>\n<p>The special symbols <code>@</code> (current node) and <code>$</code> (root node) will be substituted\nfor variables named <code>__current</code> and <code>__root</code> respectively, using a simple text\nreplacement before the statement is evaluated. To use a literal <code>@</code> or <code>$</code> in\nthe script, it must be escaped with <em>two</em> backslashes <code>\\\\</code>. Note that a string\nliteral will recognise <code>\\\\</code> as an escaped backslash; in such a case each\nbackslash must be further escaped (<code>\"\\\\\\\\@\"</code>) or else a raw literal used\n(<code>r\"\\\\@\"</code>).</p>\n<p>An example script expression:</p>\n<pre><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">jsonpath</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"sa\">r</span><span class=\"s1\">'$.cakes[(len\\(@\\)-1)].name'</span><span class=\"p\">)</span>\n\n<span class=\"k\">for</span> <span class=\"n\">r</span> <span class=\"ow\">in</span> <span class=\"n\">result</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">)</span>\n</pre>\n<p>Output:</p>\n<pre><code>jaffa cakes\n</code></pre>\n<p><strong>NOTE</strong> JSONPyth calls <code>eval</code> to evaluate Python script, and so is <strong>unsafe</strong>\nto use for JSONPath expressions from untrusted sources.</p>\n<h3>Python Filters</h3>\n<p>Similar to expressions, filters ( <code>?(...)</code> ) use a Python statement to test\nwhether to include a node or not. The truthiness of the resulting value will be\ntested using <code>bool</code>, and if <code>False</code> the node will be omitted.</p>\n<p>Example:</p>\n<pre><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">jsonpath</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"sa\">r</span><span class=\"s1\">'$[*][?(@[\"name\"].startswith\\(\"b\"\\))]'</span><span class=\"p\">)</span>\n\n<span class=\"k\">for</span> <span class=\"n\">r</span> <span class=\"ow\">in</span> <span class=\"n\">result</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">)</span>\n</pre>\n<p>Output:</p>\n<pre><code>{\"name\": \"battenberg\"}\n{\"name\": \"bourbon\", \"rating\": 5}\n</code></pre>\n<h1>Credits and Licence</h1>\n<p><a href=\"https://github.com/Frimkron/JSONPyth\" rel=\"nofollow\">JSONPyth</a> was written by Mark Frimston and is licenced using the the MIT\nlicence. The full text of this licence can be found in the <code>LICENCE.txt</code> file.</p>\n\n          </div>"}, "last_serial": 4539156, "releases": {"0.1.2": [{"comment_text": "", "digests": {"md5": "6fce718b9fd85df4c47924ba1504ba84", "sha256": "51a9b7051c70b1290018bd28888d2b33800ee80d4290a15c2bb2592364bcae2b"}, "downloads": -1, "filename": "JSONPyth-0.1.2.tar.gz", "has_sig": false, "md5_digest": "6fce718b9fd85df4c47924ba1504ba84", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 6988, "upload_time": "2018-10-05T12:03:11", "upload_time_iso_8601": "2018-10-05T12:03:11.646671Z", "url": "https://files.pythonhosted.org/packages/6f/66/0708d4aec887f764e2df9ac4b2724ec9c421d0e94c8941a1f7c53fcfeb95/JSONPyth-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "6b9651007dd5d7d13644a14f9d23e5fd", "sha256": "ab9d8e9e72558e7e1e59d598b408d60372e0d95f56d4c4167df2946b9b99da68"}, "downloads": -1, "filename": "JSONPyth-0.1.3.tar.gz", "has_sig": false, "md5_digest": "6b9651007dd5d7d13644a14f9d23e5fd", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 6861, "upload_time": "2018-11-28T15:30:58", "upload_time_iso_8601": "2018-11-28T15:30:58.330925Z", "url": "https://files.pythonhosted.org/packages/6f/7d/f0c9f28064522bca8cf1231237e6b7ab4895e4a3cbcbb0222666af2c14bd/JSONPyth-0.1.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6b9651007dd5d7d13644a14f9d23e5fd", "sha256": "ab9d8e9e72558e7e1e59d598b408d60372e0d95f56d4c4167df2946b9b99da68"}, "downloads": -1, "filename": "JSONPyth-0.1.3.tar.gz", "has_sig": false, "md5_digest": "6b9651007dd5d7d13644a14f9d23e5fd", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 6861, "upload_time": "2018-11-28T15:30:58", "upload_time_iso_8601": "2018-11-28T15:30:58.330925Z", "url": "https://files.pythonhosted.org/packages/6f/7d/f0c9f28064522bca8cf1231237e6b7ab4895e4a3cbcbb0222666af2c14bd/JSONPyth-0.1.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:42 2020"}