{"info": {"author": "Simone Basso", "author_email": "sb@ovalmoney.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: DFSG approved", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "JWT authentication for Pyramid\n==============================\n\nThis package implements an authentication policy for Pyramid that using  `JSON\nWeb Tokens <http://jwt.io/>`_. This standard (`RFC 7519\n<https://tools.ietf.org/html/rfc7519>`_) is often used to secure backens APIs.\nThe excellent `PyJWT <https://pyjwt.readthedocs.org/en/latest/>`_ library is\nused for the JWT encoding / decoding logic.\n\nEnabling JWT support in a Pyramid application is very simple:\n\n.. code-block:: python\n\n   from pyramid.config import Configurator\n   from pyramid.authorization import ACLAuthorizationPolicy\n\n   def main():\n       config = Configurator()\n       # Pyramid requires an authorization policy to be active.\n       config.set_authorization_policy(ACLAuthorizationPolicy())\n       # Enable JWT authentication.\n       config.include('pyramid_jwt')\n       config.set_jwt_authentication_policy('secret')\n\nThis will set a JWT authentication policy using the `Authorization` HTTP header\nwith a `JWT` scheme to retrieve tokens. Using another HTTP header is trivial:\n\n.. code-block:: python\n\n    config.set_jwt_authentication_policy('secret', http_header='X-My-Header')\n\nIf your application needs to decode tokens which contain an `Audience <http://pyjwt.readthedocs.io/en/latest/usage.html?highlight=decode#audience-claim-aud>`_ claim you can extend this with:\n\n.. code-block:: python\n\n    config.set_jwt_authentication_policy('secret', \n                                        auth_type='Bearer',\n                                        callback=add_role_principals,\n                                        audience=\"example.org\")\n\n\nTo make creating valid tokens easier a new ``create_jwt_token`` method is\nadded to the request. You can use this in your view to create tokens. A simple\nauthentication view for a REST backend could look something like this:\n\n.. code-block:: python\n\n    @view_config('login', request_method='POST', renderer='json')\n    def login(request):\n        login = request.POST['login']\n        password = request.POST['password']\n        user_id = authenticate(login, password)  # You will need to implement this.\n        if user_id:\n            return {\n                'result': 'ok',\n                'token': request.create_jwt_token(user_id)\n            }\n        else:\n            return {\n                'result': 'error'\n            }\n\nSince JWT is typically used via HTTP headers and does not use cookies the\nstandard ``remember()`` and ``forget()`` functions from Pyramid are not useful.\nTrying to use them while JWT authentication is enabled will result in a warning.\n\n\nExtra claims\n------------\n\nNormally pyramid_jwt only makes a single JWT claim: the *subject* (or\n``sub`` claim) is set to the principal. You can also add extra claims to the\ntoken by passing keyword parameters to the ``create_jwt_token`` method.\n\n.. code-block:: python\n\n   token = request.create_jwt_token(user.id,\n       name=user.name,\n       admin=(user.role == 'admin'))\n\n\nAll claims found in a JWT token can be accessed through the ``jwt_claims``\ndictionary property on a request. For the above example you can retrieve the\nname and admin-status for the user directly from the request:\n\n.. code-block:: python\n\n   print('User id: %d' % request.authenticated_userid)\n   print('Users name: %s', request.jwt_claims['name'])\n   if request.jwt_claims['admin']:\n      print('This user is an admin!')\n\nKeep in mind that data ``jwt_claims`` only reflects the claims from a JWT\ntoken and do not check if the user is valid: the callback configured for the\nauthentication policy is *not* checked. For this reason you should always use\n``request.authenticated_userid`` instead of ``request.jwt_claims['sub']``.\n\nYou can also use extra claims to manage extra principals for users. For example\nyou could claims to represent add group membership or roles for a user. This\nrequires two steps: first add the extra claims to the JWT token as shown above,\nand then use the authentication policy's callback hook to turn the extra claim\ninto principals. Here is a quick example:\n\n.. code-block:: python\n\n   def add_role_principals(userid, request):\n      return ['role:%s' % role for role in request.jwt_claims.get('roles', [])]\n\n   config.set_jwt_authentication_policy(callback=add_role_principals)\n\n\nYou can then use the role principals in an ACL:\n\n.. code-block:: python\n\n   class MyView:\n       __acl__ = [\n           (Allow, Everyone, ['read']),\n           (Allow, 'role:admin', ['create', 'update']),\n       ]\n\nValidation Example\n------------------\n\nAfter creating and returning the token through your API with\n``create_jwt_token`` you can test by issuing an HTTP authorization header type\nfor JWT.\n\n.. code-block:: text\n\n   GET /resource HTTP/1.1\n   Host: server.example.com\n   Authorization: JWT eyJhbGciOiJIUzI1NiIXVCJ9...TJVA95OrM7E20RMHrHDcEfxjoYZgeFONFh7HgQ\n\nWe can test using curl.\n\n.. code-block:: bash\n\n   curl --header 'Authorization: JWT TOKEN' server.example.com/ROUTE_PATH\n\n.. code-block:: python\n\n   config.add_route('example', '/ROUTE_PATH')\n   @view_config(route_name=example)\n   def some_action(request):\n       if request.authenticated_userid:\n           # Do something\n\n\nSettings\n--------\n\nThere are a number of flags that specify how tokens are created and verified.\nYou can either set this in your .ini-file, or pass/override them directly to the\n``config.set_jwt_authentication_policy()`` function.\n\n+--------------+-----------------+---------------+--------------------------------------------+\n| Parameter    | ini-file entry  | Default       | Description                                |\n+==============+=================+===============+============================================+\n| private_key  | jwt.private_key |               | Key used to hash or sign tokens.           |\n+--------------+-----------------+---------------+--------------------------------------------+\n| public_key   | jwt.public_key  |               | Key used to verify token signatures. Only  |\n|              |                 |               | used with assymetric algorithms.           |\n+--------------+-----------------+---------------+--------------------------------------------+\n| algorithm    | jwt.algorithm   | HS512         | Hash or encryption algorithm               |\n+--------------+-----------------+---------------+--------------------------------------------+\n| expiration   | jwt.expiration  |               | Number of seconds (or a datetime.timedelta |\n|              |                 |               | instance) before a token expires.          |\n+--------------+-----------------+---------------+--------------------------------------------+\n| audience     | jwt.audience    |               | Proposed audience for the token            |\n+--------------+-----------------+---------------+--------------------------------------------+\n| leeway       | jwt.leeway      | 0             | Number of seconds a token is allowed to be |\n|              |                 |               | expired before it is rejected.             |\n+--------------+-----------------+---------------+--------------------------------------------+\n| http_header  | jwt.http_header | Authorization | HTTP header used for tokens                |\n+--------------+-----------------+---------------+--------------------------------------------+\n| auth_type    | jwt.auth_type   | JWT           | Authentication type used in Authorization  |\n|              |                 |               | header. Unused for other HTTP headers.     |\n+--------------+-----------------+---------------+--------------------------------------------+\n| json_encoder |                 | None          | A subclass of JSONEncoder to be used       |\n|              |                 |               | to encode principal and claims infos.      |\n+--------------+-----------------+---------------+--------------------------------------------+\n\nPyramid JWT example use cases\n=============================\n\nThis is a basic guide (that will assume for all following statements that you\nhave followed the Readme for this project) that will explain how (and why) to\nuse JWT to secure/restrict access to a pyramid REST style backend API, this\nguide will explain a basic overview on:\n\n- Creating JWT's\n- Decoding JWT's\n- Restricting access to certain pyramid views via JWT's\n\n\nCreating JWT's\n--------------\n\nFirst off, lets start with the first view in our pyramid project, this would\nnormally be say a login view, this view has no permissions associated with it,\nany user can access and post login credentials to it, for example:\n\n.. code-block:: python\n\n   def authenticate_user(login, password):\n       # Note the below will not work, its just an example of returning a user\n       # object back to the JWT creation.\n       login_query = session.query(User).\\\n           filter(User.login == login).\\\n           filter(User.password == password).first()\n\n       if login_query:\n           user_dict = {\n               'userid': login_query.id, \n               'user_name': login_query.user_name,\n               'roles': login_query.roles\n           }\n           # An example of login_query.roles would be a list\n           # print(login_query.roles)\n           # ['admin', 'reports']\n           return user_dict\n       else:\n           # If we end up here, no logins have been found\n           return None\n\n   @view_config('login', request_method='POST', renderer='json')\n   def login(request):\n       '''Create a login view\n       '''\n       login = request.POST['login']\n       password = request.POST['password']\n       user = authenticate(login, password)\n       if user:\n           return {\n               'result': 'ok',\n               'token': request.create_jwt_token(\n                                               user['userid'], \n                                               roles=user['roles'],\n                                               userName=user['user_name']\n                                               )\n           }\n       else:\n           return {\n               'result': 'error',\n               'token': None\n           }\n\nNow what this does is return your JWT back to whatever front end application\nyou may have, with the user details, along with their permissions, this will\nreturn a decoded token such as:\n\n.. code-block::\n\n   eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyTmFtZSI6Imx1a2UiLCJyb2xlcyI6WyJhZG1pbiIsInJlcG9ydHMiXSwic3ViIjo0LCJpYXQiOjE1MTkwNDQyNzB9.__KjyW1U-tpAEvTbSJsasS-8CaFyXH784joUPONH6hQ\n\nNow I would suggest heading over to `JWT.io <https://jwt.io>`_, copy this data\ninto their page, and you will see the decoded token:\n\n.. code-block:: json\n\n   {\n     \"userName\": \"luke\",\n     \"roles\": [\n       \"admin\",\n       \"reports\"\n     ],\n     \"sub\": 4,\n     \"iat\": 1519044270\n   }\n\nNote, at the bottom of jwt.io's webpage, that the signature shows verified, if\nyou change the \"secret\" at the bottom, it will say \"NOT Verified\" this is\nbecause in order for any JWT process to be verified, the valid \"secret\" or\n\"private key\" must be used. It is important to note that any data sent in a JWT\nis accessible and readable by anyone.\n\nDecoding JWT\n------------\n\nThe following section would also work if pyramid did not create the JWT, all it\nneeds to know to decode a JWT is the \"secret\" or \"private key\" used to\ncreate/sign the original JWT.By their nature  JWT's aren't secure, but they can\nbe used \"to secure\". In our example above, we returned the \"roles\" array in our\nJWT, this had two properties \"admin\" and \"reports\" so we could then in our\npyramid application, setup an ACL to map JWT permissions to pyramid based\nsecurity, for example in our projects __init__.py we could add:\n\n.. code-block:: python\n\n   from pyramid.security import ALL_PERMISSIONS\n\n   class RootACL(object):\n       __acl__ = [\n           (Allow, 'admin', ALL_PERMISSIONS),\n           (Allow, 'reports', ['reports'])\n       ]\n\n       def __init__(self, request):\n           pass\n\nWhat this ACL will do is allow anyone with the \"admin\" role in their JWT access\nto all views protected via a permission, where as users with \"reports\" in their\nJWT will only have access to views protected via the \"reports\" permission.\n\nNow this ACL in itself is not enough to map the JWT permission to pyramids\nsecurity backend, we need to also add the following to __init__.py:\n\n.. code-block:: python\n\n   from pyramid.authorization import ACLAuthorizationPolicy\n\n\n   def add_role_principals(userid, request):\n       return request.jwt_claims.get('roles', [])\n\n   def main(global_config, **settings):\n       \"\"\" This function returns a Pyramid WSGI application.\n       \"\"\"\n       config = Configurator(settings=settings)\n       ...\n       # Enable JWT - JSON Web Token based authentication\n       config.set_root_factory(RootACL)\n       config.set_authorization_policy(ACLAuthorizationPolicy())\n       config.include('pyramid_jwt')\n       config.set_jwt_authentication_policy('myJWTsecretKeepThisSafe', \n                                           auth_type='Bearer',\n                                           callback=add_role_principals)\n\nThis code will map any properties of the \"roles\" attribute of the JWT, run them\nthrough the ACL and then tie them into pyramids security framework.\n\nHow is this secure?\n-------------------\n\nFor example, a JWT could easily be manipulated, anyone could hijack the token,\nchange the values of the \"roles\" array to gain access to a view they do not\nactually have access to. WRONG! pyramid_jwt checks the signature of all JWT\ntokens as part of the decode process, if it notices that the signature of the\ntoken is not as expected, it means either the application has been setup\ncorrectly with the wrong private key, OR an attacker has tried to manipulate\nthe token.\n\nSecuring views with JWT's\n-------------------------\n\nIn the example posted above we creating an \"admin\" role that we gave\nALL_PERMISSIONS access in our ACL, so any user with this role could access any\nview e.g.:\n\n.. code-block:: python\n\n   @view_config(route_name='view_a', request_method='GET', \n                permission=\"admin\", renderer='json')\n   def view_a(request):\n       return\n\n   @view_config(route_name='view_b', request_method='GET', \n                permission=\"cpanel\", renderer='json')\n   def view_b(request):\n       return\n\nThis user would be able to access both of these views, however any user with\nthe \"reports\" permission would not be able to access any of these views, they\ncould only access permissions with \"reports\". Obviously in our use case, one\nuser had both \"admin\" and \"reports\" permissions, so they would be able to\naccess any view regardless.\n\n\nChangelog\n=========\n\n1.4.1 - August 10, 2018\n-----------------------\n\n- `Pull request #23 <https://github.com/wichert/pyramid_jwt/pull/21>`_:\n  Allow specifying the audience in the app configuration, from `John Stevens II\n  <https://github.com/jstevensfit>`_.\n\n\n1.4 - August 9, 2018\n--------------------\n\n- `Pull request #21 <https://github.com/wichert/pyramid_jwt/pull/21>`_:\n  add support for JWT aud claims, from `Luke Crooks\n  <https://github.com/crooksey>`_.\n\n1.3 - March 20, 2018\n---------------------\n\n- `Issue #20 <https://github.com/wichert/pyramid_jwt/issues/20>`_:\n  Fix handling of public keys.\n- `Pull request #17 <https://github.com/wichert/pyramid_jwt/pull/17>`_:\n  a lot of documentation improvements from `Luke Crooks\n  <https://github.com/crooksey>`_.\n\n\n1.2 - May 25, 2017\n------------------\n\n- Fix a `log.warn` deprecation warning on Python 3.6.\n\n- Documentation improvements, courtesy of `\u00c9ric Araujo <https://github.com/merwok>`_\n  and `Guillermo Cruz <https://github.com/webjunkie01>`_.\n\n- `Pull request #10 <https://github.com/wichert/pyramid_jwt/pull/10>`_\n  Allow use of a custom JSON encoder.\n  Submitted by `Julien Meyer <https://github.com/julienmeyer>`_.\n\n\n1.1 - May 4, 2016\n-----------------\n\n- `Issue #2 <https://github.com/wichert/pyramid_jwt/issues/2>`_:\n  Support setting and reading extra claims in a JWT token.\n\n- `Pull request #4 <https://github.com/wichert/pyramid_jwt/pull/4>`_:\n  Fix parsing of expiration and leeway settings from a configuration value.\n  Submitted by `Daniel Kraus <https://github.com/dakra>`_.\n\n- `Pull request #3 <https://github.com/wichert/pyramid_jwt/pull/3>`_:\n  Allow overriding the expiration timestamp for a token when creating a new\n  token. Submitted by `Daniel Kraus`_.\n\n\n1.0 - December 17, 2015\n-----------------------\n\n- First release\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/OvalMoney/pyramid_jwt_policy", "keywords": "Pyramid JWT authentication security", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "pyramid-jwt-policy", "package_url": "https://pypi.org/project/pyramid-jwt-policy/", "platform": "", "project_url": "https://pypi.org/project/pyramid-jwt-policy/", "project_urls": {"Homepage": "https://github.com/OvalMoney/pyramid_jwt_policy"}, "release_url": "https://pypi.org/project/pyramid-jwt-policy/1.0.0/", "requires_dist": ["pyramid", "PyJWT", "pytest; extra == 'tests'", "WebTest; extra == 'tests'"], "requires_python": "", "summary": "JWT authentication policy for Pyramid", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"jwt-authentication-for-pyramid\">\n<h2>JWT authentication for Pyramid</h2>\n<p>This package implements an authentication policy for Pyramid that using  <a href=\"http://jwt.io/\" rel=\"nofollow\">JSON\nWeb Tokens</a>. This standard (<a href=\"https://tools.ietf.org/html/rfc7519\" rel=\"nofollow\">RFC 7519</a>) is often used to secure backens APIs.\nThe excellent <a href=\"https://pyjwt.readthedocs.org/en/latest/\" rel=\"nofollow\">PyJWT</a> library is\nused for the JWT encoding / decoding logic.</p>\n<p>Enabling JWT support in a Pyramid application is very simple:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyramid.config</span> <span class=\"kn\">import</span> <span class=\"n\">Configurator</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyramid.authorization</span> <span class=\"kn\">import</span> <span class=\"n\">ACLAuthorizationPolicy</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">Configurator</span><span class=\"p\">()</span>\n    <span class=\"c1\"># Pyramid requires an authorization policy to be active.</span>\n    <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">set_authorization_policy</span><span class=\"p\">(</span><span class=\"n\">ACLAuthorizationPolicy</span><span class=\"p\">())</span>\n    <span class=\"c1\"># Enable JWT authentication.</span>\n    <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">include</span><span class=\"p\">(</span><span class=\"s1\">'pyramid_jwt'</span><span class=\"p\">)</span>\n    <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">set_jwt_authentication_policy</span><span class=\"p\">(</span><span class=\"s1\">'secret'</span><span class=\"p\">)</span>\n</pre>\n<p>This will set a JWT authentication policy using the <cite>Authorization</cite> HTTP header\nwith a <cite>JWT</cite> scheme to retrieve tokens. Using another HTTP header is trivial:</p>\n<pre><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">set_jwt_authentication_policy</span><span class=\"p\">(</span><span class=\"s1\">'secret'</span><span class=\"p\">,</span> <span class=\"n\">http_header</span><span class=\"o\">=</span><span class=\"s1\">'X-My-Header'</span><span class=\"p\">)</span>\n</pre>\n<p>If your application needs to decode tokens which contain an <a href=\"http://pyjwt.readthedocs.io/en/latest/usage.html?highlight=decode#audience-claim-aud\" rel=\"nofollow\">Audience</a> claim you can extend this with:</p>\n<pre><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">set_jwt_authentication_policy</span><span class=\"p\">(</span><span class=\"s1\">'secret'</span><span class=\"p\">,</span>\n                                    <span class=\"n\">auth_type</span><span class=\"o\">=</span><span class=\"s1\">'Bearer'</span><span class=\"p\">,</span>\n                                    <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"n\">add_role_principals</span><span class=\"p\">,</span>\n                                    <span class=\"n\">audience</span><span class=\"o\">=</span><span class=\"s2\">\"example.org\"</span><span class=\"p\">)</span>\n</pre>\n<p>To make creating valid tokens easier a new <tt>create_jwt_token</tt> method is\nadded to the request. You can use this in your view to create tokens. A simple\nauthentication view for a REST backend could look something like this:</p>\n<pre><span class=\"nd\">@view_config</span><span class=\"p\">(</span><span class=\"s1\">'login'</span><span class=\"p\">,</span> <span class=\"n\">request_method</span><span class=\"o\">=</span><span class=\"s1\">'POST'</span><span class=\"p\">,</span> <span class=\"n\">renderer</span><span class=\"o\">=</span><span class=\"s1\">'json'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">login</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"n\">login</span> <span class=\"o\">=</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">POST</span><span class=\"p\">[</span><span class=\"s1\">'login'</span><span class=\"p\">]</span>\n    <span class=\"n\">password</span> <span class=\"o\">=</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">POST</span><span class=\"p\">[</span><span class=\"s1\">'password'</span><span class=\"p\">]</span>\n    <span class=\"n\">user_id</span> <span class=\"o\">=</span> <span class=\"n\">authenticate</span><span class=\"p\">(</span><span class=\"n\">login</span><span class=\"p\">,</span> <span class=\"n\">password</span><span class=\"p\">)</span>  <span class=\"c1\"># You will need to implement this.</span>\n    <span class=\"k\">if</span> <span class=\"n\">user_id</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'result'</span><span class=\"p\">:</span> <span class=\"s1\">'ok'</span><span class=\"p\">,</span>\n            <span class=\"s1\">'token'</span><span class=\"p\">:</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">create_jwt_token</span><span class=\"p\">(</span><span class=\"n\">user_id</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'result'</span><span class=\"p\">:</span> <span class=\"s1\">'error'</span>\n        <span class=\"p\">}</span>\n</pre>\n<p>Since JWT is typically used via HTTP headers and does not use cookies the\nstandard <tt>remember()</tt> and <tt>forget()</tt> functions from Pyramid are not useful.\nTrying to use them while JWT authentication is enabled will result in a warning.</p>\n<div id=\"extra-claims\">\n<h3>Extra claims</h3>\n<p>Normally pyramid_jwt only makes a single JWT claim: the <em>subject</em> (or\n<tt>sub</tt> claim) is set to the principal. You can also add extra claims to the\ntoken by passing keyword parameters to the <tt>create_jwt_token</tt> method.</p>\n<pre><span class=\"n\">token</span> <span class=\"o\">=</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">create_jwt_token</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">,</span>\n    <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">,</span>\n    <span class=\"n\">admin</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">role</span> <span class=\"o\">==</span> <span class=\"s1\">'admin'</span><span class=\"p\">))</span>\n</pre>\n<p>All claims found in a JWT token can be accessed through the <tt>jwt_claims</tt>\ndictionary property on a request. For the above example you can retrieve the\nname and admin-status for the user directly from the request:</p>\n<pre><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'User id: </span><span class=\"si\">%d</span><span class=\"s1\">'</span> <span class=\"o\">%</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">authenticated_userid</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Users name: </span><span class=\"si\">%s</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">jwt_claims</span><span class=\"p\">[</span><span class=\"s1\">'name'</span><span class=\"p\">])</span>\n<span class=\"k\">if</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">jwt_claims</span><span class=\"p\">[</span><span class=\"s1\">'admin'</span><span class=\"p\">]:</span>\n   <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'This user is an admin!'</span><span class=\"p\">)</span>\n</pre>\n<p>Keep in mind that data <tt>jwt_claims</tt> only reflects the claims from a JWT\ntoken and do not check if the user is valid: the callback configured for the\nauthentication policy is <em>not</em> checked. For this reason you should always use\n<tt>request.authenticated_userid</tt> instead of <tt><span class=\"pre\">request.jwt_claims['sub']</span></tt>.</p>\n<p>You can also use extra claims to manage extra principals for users. For example\nyou could claims to represent add group membership or roles for a user. This\nrequires two steps: first add the extra claims to the JWT token as shown above,\nand then use the authentication policy\u2019s callback hook to turn the extra claim\ninto principals. Here is a quick example:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">add_role_principals</span><span class=\"p\">(</span><span class=\"n\">userid</span><span class=\"p\">,</span> <span class=\"n\">request</span><span class=\"p\">):</span>\n   <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"s1\">'role:</span><span class=\"si\">%s</span><span class=\"s1\">'</span> <span class=\"o\">%</span> <span class=\"n\">role</span> <span class=\"k\">for</span> <span class=\"n\">role</span> <span class=\"ow\">in</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">jwt_claims</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'roles'</span><span class=\"p\">,</span> <span class=\"p\">[])]</span>\n\n<span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">set_jwt_authentication_policy</span><span class=\"p\">(</span><span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"n\">add_role_principals</span><span class=\"p\">)</span>\n</pre>\n<p>You can then use the role principals in an ACL:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyView</span><span class=\"p\">:</span>\n    <span class=\"n\">__acl__</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n        <span class=\"p\">(</span><span class=\"n\">Allow</span><span class=\"p\">,</span> <span class=\"n\">Everyone</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'read'</span><span class=\"p\">]),</span>\n        <span class=\"p\">(</span><span class=\"n\">Allow</span><span class=\"p\">,</span> <span class=\"s1\">'role:admin'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'create'</span><span class=\"p\">,</span> <span class=\"s1\">'update'</span><span class=\"p\">]),</span>\n    <span class=\"p\">]</span>\n</pre>\n</div>\n<div id=\"validation-example\">\n<h3>Validation Example</h3>\n<p>After creating and returning the token through your API with\n<tt>create_jwt_token</tt> you can test by issuing an HTTP authorization header type\nfor JWT.</p>\n<pre>GET /resource HTTP/1.1\nHost: server.example.com\nAuthorization: JWT eyJhbGciOiJIUzI1NiIXVCJ9...TJVA95OrM7E20RMHrHDcEfxjoYZgeFONFh7HgQ\n</pre>\n<p>We can test using curl.</p>\n<pre>curl --header <span class=\"s1\">'Authorization: JWT TOKEN'</span> server.example.com/ROUTE_PATH\n</pre>\n<pre><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">add_route</span><span class=\"p\">(</span><span class=\"s1\">'example'</span><span class=\"p\">,</span> <span class=\"s1\">'/ROUTE_PATH'</span><span class=\"p\">)</span>\n<span class=\"nd\">@view_config</span><span class=\"p\">(</span><span class=\"n\">route_name</span><span class=\"o\">=</span><span class=\"n\">example</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">some_action</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">authenticated_userid</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Do something</span>\n</pre>\n</div>\n<div id=\"settings\">\n<h3>Settings</h3>\n<p>There are a number of flags that specify how tokens are created and verified.\nYou can either set this in your .ini-file, or pass/override them directly to the\n<tt>config.set_jwt_authentication_policy()</tt> function.</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Parameter</th>\n<th>ini-file entry</th>\n<th>Default</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>private_key</td>\n<td>jwt.private_key</td>\n<td>\u00a0</td>\n<td>Key used to hash or sign tokens.</td>\n</tr>\n<tr><td>public_key</td>\n<td>jwt.public_key</td>\n<td>\u00a0</td>\n<td>Key used to verify token signatures. Only\nused with assymetric algorithms.</td>\n</tr>\n<tr><td>algorithm</td>\n<td>jwt.algorithm</td>\n<td>HS512</td>\n<td>Hash or encryption algorithm</td>\n</tr>\n<tr><td>expiration</td>\n<td>jwt.expiration</td>\n<td>\u00a0</td>\n<td>Number of seconds (or a datetime.timedelta\ninstance) before a token expires.</td>\n</tr>\n<tr><td>audience</td>\n<td>jwt.audience</td>\n<td>\u00a0</td>\n<td>Proposed audience for the token</td>\n</tr>\n<tr><td>leeway</td>\n<td>jwt.leeway</td>\n<td>0</td>\n<td>Number of seconds a token is allowed to be\nexpired before it is rejected.</td>\n</tr>\n<tr><td>http_header</td>\n<td>jwt.http_header</td>\n<td>Authorization</td>\n<td>HTTP header used for tokens</td>\n</tr>\n<tr><td>auth_type</td>\n<td>jwt.auth_type</td>\n<td>JWT</td>\n<td>Authentication type used in Authorization\nheader. Unused for other HTTP headers.</td>\n</tr>\n<tr><td>json_encoder</td>\n<td>\u00a0</td>\n<td>None</td>\n<td>A subclass of JSONEncoder to be used\nto encode principal and claims infos.</td>\n</tr>\n</tbody>\n</table>\n</div>\n</div>\n<div id=\"pyramid-jwt-example-use-cases\">\n<h2>Pyramid JWT example use cases</h2>\n<p>This is a basic guide (that will assume for all following statements that you\nhave followed the Readme for this project) that will explain how (and why) to\nuse JWT to secure/restrict access to a pyramid REST style backend API, this\nguide will explain a basic overview on:</p>\n<ul>\n<li>Creating JWT\u2019s</li>\n<li>Decoding JWT\u2019s</li>\n<li>Restricting access to certain pyramid views via JWT\u2019s</li>\n</ul>\n<div id=\"creating-jwt-s\">\n<h3>Creating JWT\u2019s</h3>\n<p>First off, lets start with the first view in our pyramid project, this would\nnormally be say a login view, this view has no permissions associated with it,\nany user can access and post login credentials to it, for example:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">authenticate_user</span><span class=\"p\">(</span><span class=\"n\">login</span><span class=\"p\">,</span> <span class=\"n\">password</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Note the below will not work, its just an example of returning a user</span>\n    <span class=\"c1\"># object back to the JWT creation.</span>\n    <span class=\"n\">login_query</span> <span class=\"o\">=</span> <span class=\"n\">session</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">User</span><span class=\"p\">)</span><span class=\"o\">.</span>\\\n        <span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"n\">User</span><span class=\"o\">.</span><span class=\"n\">login</span> <span class=\"o\">==</span> <span class=\"n\">login</span><span class=\"p\">)</span><span class=\"o\">.</span>\\\n        <span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"n\">User</span><span class=\"o\">.</span><span class=\"n\">password</span> <span class=\"o\">==</span> <span class=\"n\">password</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">first</span><span class=\"p\">()</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">login_query</span><span class=\"p\">:</span>\n        <span class=\"n\">user_dict</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'userid'</span><span class=\"p\">:</span> <span class=\"n\">login_query</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">,</span>\n            <span class=\"s1\">'user_name'</span><span class=\"p\">:</span> <span class=\"n\">login_query</span><span class=\"o\">.</span><span class=\"n\">user_name</span><span class=\"p\">,</span>\n            <span class=\"s1\">'roles'</span><span class=\"p\">:</span> <span class=\"n\">login_query</span><span class=\"o\">.</span><span class=\"n\">roles</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\"># An example of login_query.roles would be a list</span>\n        <span class=\"c1\"># print(login_query.roles)</span>\n        <span class=\"c1\"># ['admin', 'reports']</span>\n        <span class=\"k\">return</span> <span class=\"n\">user_dict</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"c1\"># If we end up here, no logins have been found</span>\n        <span class=\"k\">return</span> <span class=\"kc\">None</span>\n\n<span class=\"nd\">@view_config</span><span class=\"p\">(</span><span class=\"s1\">'login'</span><span class=\"p\">,</span> <span class=\"n\">request_method</span><span class=\"o\">=</span><span class=\"s1\">'POST'</span><span class=\"p\">,</span> <span class=\"n\">renderer</span><span class=\"o\">=</span><span class=\"s1\">'json'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">login</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"sd\">'''Create a login view\n    '''</span>\n    <span class=\"n\">login</span> <span class=\"o\">=</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">POST</span><span class=\"p\">[</span><span class=\"s1\">'login'</span><span class=\"p\">]</span>\n    <span class=\"n\">password</span> <span class=\"o\">=</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">POST</span><span class=\"p\">[</span><span class=\"s1\">'password'</span><span class=\"p\">]</span>\n    <span class=\"n\">user</span> <span class=\"o\">=</span> <span class=\"n\">authenticate</span><span class=\"p\">(</span><span class=\"n\">login</span><span class=\"p\">,</span> <span class=\"n\">password</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">user</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'result'</span><span class=\"p\">:</span> <span class=\"s1\">'ok'</span><span class=\"p\">,</span>\n            <span class=\"s1\">'token'</span><span class=\"p\">:</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">create_jwt_token</span><span class=\"p\">(</span>\n                                            <span class=\"n\">user</span><span class=\"p\">[</span><span class=\"s1\">'userid'</span><span class=\"p\">],</span>\n                                            <span class=\"n\">roles</span><span class=\"o\">=</span><span class=\"n\">user</span><span class=\"p\">[</span><span class=\"s1\">'roles'</span><span class=\"p\">],</span>\n                                            <span class=\"n\">userName</span><span class=\"o\">=</span><span class=\"n\">user</span><span class=\"p\">[</span><span class=\"s1\">'user_name'</span><span class=\"p\">]</span>\n                                            <span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'result'</span><span class=\"p\">:</span> <span class=\"s1\">'error'</span><span class=\"p\">,</span>\n            <span class=\"s1\">'token'</span><span class=\"p\">:</span> <span class=\"kc\">None</span>\n        <span class=\"p\">}</span>\n</pre>\n<p>Now what this does is return your JWT back to whatever front end application\nyou may have, with the user details, along with their permissions, this will\nreturn a decoded token such as:</p>\n<pre>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyTmFtZSI6Imx1a2UiLCJyb2xlcyI6WyJhZG1pbiIsInJlcG9ydHMiXSwic3ViIjo0LCJpYXQiOjE1MTkwNDQyNzB9.__KjyW1U-tpAEvTbSJsasS-8CaFyXH784joUPONH6hQ\n</pre>\n<p>Now I would suggest heading over to <a href=\"https://jwt.io\" rel=\"nofollow\">JWT.io</a>, copy this data\ninto their page, and you will see the decoded token:</p>\n<pre><span class=\"p\">{</span>\n  <span class=\"nt\">\"userName\"</span><span class=\"p\">:</span> <span class=\"s2\">\"luke\"</span><span class=\"p\">,</span>\n  <span class=\"nt\">\"roles\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n    <span class=\"s2\">\"admin\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"reports\"</span>\n  <span class=\"p\">],</span>\n  <span class=\"nt\">\"sub\"</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span>\n  <span class=\"nt\">\"iat\"</span><span class=\"p\">:</span> <span class=\"mi\">1519044270</span>\n<span class=\"p\">}</span>\n</pre>\n<p>Note, at the bottom of jwt.io\u2019s webpage, that the signature shows verified, if\nyou change the \u201csecret\u201d at the bottom, it will say \u201cNOT Verified\u201d this is\nbecause in order for any JWT process to be verified, the valid \u201csecret\u201d or\n\u201cprivate key\u201d must be used. It is important to note that any data sent in a JWT\nis accessible and readable by anyone.</p>\n</div>\n<div id=\"decoding-jwt\">\n<h3>Decoding JWT</h3>\n<p>The following section would also work if pyramid did not create the JWT, all it\nneeds to know to decode a JWT is the \u201csecret\u201d or \u201cprivate key\u201d used to\ncreate/sign the original JWT.By their nature  JWT\u2019s aren\u2019t secure, but they can\nbe used \u201cto secure\u201d. In our example above, we returned the \u201croles\u201d array in our\nJWT, this had two properties \u201cadmin\u201d and \u201creports\u201d so we could then in our\npyramid application, setup an ACL to map JWT permissions to pyramid based\nsecurity, for example in our projects __init__.py we could add:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyramid.security</span> <span class=\"kn\">import</span> <span class=\"n\">ALL_PERMISSIONS</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">RootACL</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"n\">__acl__</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n        <span class=\"p\">(</span><span class=\"n\">Allow</span><span class=\"p\">,</span> <span class=\"s1\">'admin'</span><span class=\"p\">,</span> <span class=\"n\">ALL_PERMISSIONS</span><span class=\"p\">),</span>\n        <span class=\"p\">(</span><span class=\"n\">Allow</span><span class=\"p\">,</span> <span class=\"s1\">'reports'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'reports'</span><span class=\"p\">])</span>\n    <span class=\"p\">]</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">request</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n</pre>\n<p>What this ACL will do is allow anyone with the \u201cadmin\u201d role in their JWT access\nto all views protected via a permission, where as users with \u201creports\u201d in their\nJWT will only have access to views protected via the \u201creports\u201d permission.</p>\n<p>Now this ACL in itself is not enough to map the JWT permission to pyramids\nsecurity backend, we need to also add the following to __init__.py:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyramid.authorization</span> <span class=\"kn\">import</span> <span class=\"n\">ACLAuthorizationPolicy</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">add_role_principals</span><span class=\"p\">(</span><span class=\"n\">userid</span><span class=\"p\">,</span> <span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">jwt_claims</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'roles'</span><span class=\"p\">,</span> <span class=\"p\">[])</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"n\">global_config</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">settings</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\" This function returns a Pyramid WSGI application.\n    \"\"\"</span>\n    <span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">Configurator</span><span class=\"p\">(</span><span class=\"n\">settings</span><span class=\"o\">=</span><span class=\"n\">settings</span><span class=\"p\">)</span>\n    <span class=\"o\">...</span>\n    <span class=\"c1\"># Enable JWT - JSON Web Token based authentication</span>\n    <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">set_root_factory</span><span class=\"p\">(</span><span class=\"n\">RootACL</span><span class=\"p\">)</span>\n    <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">set_authorization_policy</span><span class=\"p\">(</span><span class=\"n\">ACLAuthorizationPolicy</span><span class=\"p\">())</span>\n    <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">include</span><span class=\"p\">(</span><span class=\"s1\">'pyramid_jwt'</span><span class=\"p\">)</span>\n    <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">set_jwt_authentication_policy</span><span class=\"p\">(</span><span class=\"s1\">'myJWTsecretKeepThisSafe'</span><span class=\"p\">,</span>\n                                        <span class=\"n\">auth_type</span><span class=\"o\">=</span><span class=\"s1\">'Bearer'</span><span class=\"p\">,</span>\n                                        <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"n\">add_role_principals</span><span class=\"p\">)</span>\n</pre>\n<p>This code will map any properties of the \u201croles\u201d attribute of the JWT, run them\nthrough the ACL and then tie them into pyramids security framework.</p>\n</div>\n<div id=\"how-is-this-secure\">\n<h3>How is this secure?</h3>\n<p>For example, a JWT could easily be manipulated, anyone could hijack the token,\nchange the values of the \u201croles\u201d array to gain access to a view they do not\nactually have access to. WRONG! pyramid_jwt checks the signature of all JWT\ntokens as part of the decode process, if it notices that the signature of the\ntoken is not as expected, it means either the application has been setup\ncorrectly with the wrong private key, OR an attacker has tried to manipulate\nthe token.</p>\n</div>\n<div id=\"securing-views-with-jwt-s\">\n<h3>Securing views with JWT\u2019s</h3>\n<p>In the example posted above we creating an \u201cadmin\u201d role that we gave\nALL_PERMISSIONS access in our ACL, so any user with this role could access any\nview e.g.:</p>\n<pre><span class=\"nd\">@view_config</span><span class=\"p\">(</span><span class=\"n\">route_name</span><span class=\"o\">=</span><span class=\"s1\">'view_a'</span><span class=\"p\">,</span> <span class=\"n\">request_method</span><span class=\"o\">=</span><span class=\"s1\">'GET'</span><span class=\"p\">,</span>\n             <span class=\"n\">permission</span><span class=\"o\">=</span><span class=\"s2\">\"admin\"</span><span class=\"p\">,</span> <span class=\"n\">renderer</span><span class=\"o\">=</span><span class=\"s1\">'json'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">view_a</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span>\n\n<span class=\"nd\">@view_config</span><span class=\"p\">(</span><span class=\"n\">route_name</span><span class=\"o\">=</span><span class=\"s1\">'view_b'</span><span class=\"p\">,</span> <span class=\"n\">request_method</span><span class=\"o\">=</span><span class=\"s1\">'GET'</span><span class=\"p\">,</span>\n             <span class=\"n\">permission</span><span class=\"o\">=</span><span class=\"s2\">\"cpanel\"</span><span class=\"p\">,</span> <span class=\"n\">renderer</span><span class=\"o\">=</span><span class=\"s1\">'json'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">view_b</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span>\n</pre>\n<p>This user would be able to access both of these views, however any user with\nthe \u201creports\u201d permission would not be able to access any of these views, they\ncould only access permissions with \u201creports\u201d. Obviously in our use case, one\nuser had both \u201cadmin\u201d and \u201creports\u201d permissions, so they would be able to\naccess any view regardless.</p>\n</div>\n</div>\n<div id=\"changelog\">\n<h2>Changelog</h2>\n<div id=\"august-10-2018\">\n<h3>1.4.1 - August 10, 2018</h3>\n<ul>\n<li><a href=\"https://github.com/wichert/pyramid_jwt/pull/21\" rel=\"nofollow\">Pull request #23</a>:\nAllow specifying the audience in the app configuration, from <a href=\"https://github.com/jstevensfit\" rel=\"nofollow\">John Stevens II</a>.</li>\n</ul>\n</div>\n<div id=\"august-9-2018\">\n<h3>1.4 - August 9, 2018</h3>\n<ul>\n<li><a href=\"https://github.com/wichert/pyramid_jwt/pull/21\" rel=\"nofollow\">Pull request #21</a>:\nadd support for JWT aud claims, from <a href=\"https://github.com/crooksey\" rel=\"nofollow\">Luke Crooks</a>.</li>\n</ul>\n</div>\n<div id=\"march-20-2018\">\n<h3>1.3 - March 20, 2018</h3>\n<ul>\n<li><a href=\"https://github.com/wichert/pyramid_jwt/issues/20\" rel=\"nofollow\">Issue #20</a>:\nFix handling of public keys.</li>\n<li><a href=\"https://github.com/wichert/pyramid_jwt/pull/17\" rel=\"nofollow\">Pull request #17</a>:\na lot of documentation improvements from <a href=\"https://github.com/crooksey\" rel=\"nofollow\">Luke Crooks</a>.</li>\n</ul>\n</div>\n<div id=\"may-25-2017\">\n<h3>1.2 - May 25, 2017</h3>\n<ul>\n<li>Fix a <cite>log.warn</cite> deprecation warning on Python 3.6.</li>\n<li>Documentation improvements, courtesy of <a href=\"https://github.com/merwok\" rel=\"nofollow\">\u00c9ric Araujo</a>\nand <a href=\"https://github.com/webjunkie01\" rel=\"nofollow\">Guillermo Cruz</a>.</li>\n<li><a href=\"https://github.com/wichert/pyramid_jwt/pull/10\" rel=\"nofollow\">Pull request #10</a>\nAllow use of a custom JSON encoder.\nSubmitted by <a href=\"https://github.com/julienmeyer\" rel=\"nofollow\">Julien Meyer</a>.</li>\n</ul>\n</div>\n<div id=\"may-4-2016\">\n<h3>1.1 - May 4, 2016</h3>\n<ul>\n<li><a href=\"https://github.com/wichert/pyramid_jwt/issues/2\" rel=\"nofollow\">Issue #2</a>:\nSupport setting and reading extra claims in a JWT token.</li>\n<li><a href=\"https://github.com/wichert/pyramid_jwt/pull/4\" rel=\"nofollow\">Pull request #4</a>:\nFix parsing of expiration and leeway settings from a configuration value.\nSubmitted by <a href=\"https://github.com/dakra\" rel=\"nofollow\">Daniel Kraus</a>.</li>\n<li><a href=\"https://github.com/wichert/pyramid_jwt/pull/3\" rel=\"nofollow\">Pull request #3</a>:\nAllow overriding the expiration timestamp for a token when creating a new\ntoken. Submitted by <a href=\"https://github.com/dakra\" rel=\"nofollow\">Daniel Kraus</a>.</li>\n</ul>\n</div>\n<div id=\"december-17-2015\">\n<h3>1.0 - December 17, 2015</h3>\n<ul>\n<li>First release</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4299471, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "f4c6d3122e74fc746a1dab438c2c2647", "sha256": "8f8a12ef4bc55c2b77e87a9187c5b36368319f402e87397bb52264050e78d79d"}, "downloads": -1, "filename": "pyramid_jwt_policy-1.0.0-py2.py3-none-any.whl", "has_sig": true, "md5_digest": "f4c6d3122e74fc746a1dab438c2c2647", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8587, "upload_time": "2018-09-22T11:27:24", "upload_time_iso_8601": "2018-09-22T11:27:24.662651Z", "url": "https://files.pythonhosted.org/packages/27/e2/f9f11c18da6bac02f8c691aa6597d1cca5d9bb2dc9b5c5dd1d056bfa595b/pyramid_jwt_policy-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fca7a9e6b6e339ceafe33e694819b235", "sha256": "37a4980ffdf60dde072a0e4f526f83dac760e213a38a6b22d64abccdbf8e248e"}, "downloads": -1, "filename": "pyramid_jwt_policy-1.0.0.tar.gz", "has_sig": true, "md5_digest": "fca7a9e6b6e339ceafe33e694819b235", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12460, "upload_time": "2018-09-22T11:27:26", "upload_time_iso_8601": "2018-09-22T11:27:26.349747Z", "url": "https://files.pythonhosted.org/packages/b0/12/1f9bde63879178f70223f0737221a78dfba538fee0980c4cd5fe96a1b3b4/pyramid_jwt_policy-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f4c6d3122e74fc746a1dab438c2c2647", "sha256": "8f8a12ef4bc55c2b77e87a9187c5b36368319f402e87397bb52264050e78d79d"}, "downloads": -1, "filename": "pyramid_jwt_policy-1.0.0-py2.py3-none-any.whl", "has_sig": true, "md5_digest": "f4c6d3122e74fc746a1dab438c2c2647", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8587, "upload_time": "2018-09-22T11:27:24", "upload_time_iso_8601": "2018-09-22T11:27:24.662651Z", "url": "https://files.pythonhosted.org/packages/27/e2/f9f11c18da6bac02f8c691aa6597d1cca5d9bb2dc9b5c5dd1d056bfa595b/pyramid_jwt_policy-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fca7a9e6b6e339ceafe33e694819b235", "sha256": "37a4980ffdf60dde072a0e4f526f83dac760e213a38a6b22d64abccdbf8e248e"}, "downloads": -1, "filename": "pyramid_jwt_policy-1.0.0.tar.gz", "has_sig": true, "md5_digest": "fca7a9e6b6e339ceafe33e694819b235", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12460, "upload_time": "2018-09-22T11:27:26", "upload_time_iso_8601": "2018-09-22T11:27:26.349747Z", "url": "https://files.pythonhosted.org/packages/b0/12/1f9bde63879178f70223f0737221a78dfba538fee0980c4cd5fe96a1b3b4/pyramid_jwt_policy-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:58:24 2020"}