{"info": {"author": "Panos Kittenis", "author_email": "22e889d8@opayq.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: GNU Lesser General Public License v2 (LGPLv2)", "License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Scientific/Engineering :: Information Analysis", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "NodeTrie\n==========\n\nA Trie data structure library.\n\n.. image:: https://img.shields.io/pypi/v/nodetrie.svg\n  :target: https://pypi.python.org/pypi/nodetrie\n  :alt: Latest Version\n.. image:: https://travis-ci.org/NodeTrie/NodeTrie_Py.svg?branch=master\n  :target: https://travis-ci.org/NodeTrie/NodeTrie_Py\n  :alt: CI status\n\nInstallation\n=============\n\n::\n\n  pip install nodetrie\n\nMotivation, design goals\n==========================\n\nNodeTrie is a Python extension to a native C library written for this purpose.\n\nIt came about from a lack of viable alternatives for Python. While other trie library implementations exist, they suffer from severe limitations such as\n\n* Read only structures, no insertions\n* High memory use for large trees\n* Lack of searching, particularly file mask or wild card style searching\n* Slow inserts\n\nExisting implementations on PyPi fall into these broad categories, including `Marissa-Trie <https://github.com/pytries/marisa-trie>`_ (read only) and `datrie <https://github.com/pytries/datrie>`_ (slow inserts, very high memory use for large trees).\n\nNodeTrie's C library is designed to minimize memory use as much as possible and still allow arbitrary length trees that can be searched.\n\nEach node has a name associated with it as its data, along with children list and number of children.\n\nFeatures and design notes\n==========================\n\n* NodeTrie is an n-ary tree, meaning any one node can have any number of children\n* Node children arrays are dynamically resized *as needed on insertion* on a per node basis. No fixed minimum nor maximum size\n* Node names can be of arbitrary length, available memory allowing\n* Node names from ``Node.name`` are always unicode in either Python 2/3\n* Any python string type may be used on insertion\n* Node names are implicitly decoded from unicode on insertion, if needed, with ``nodetrie.ENCODING`` (`utf-8`) default encoding which can be overridden\n* New Python ``Node`` objects are created from the underlying C pointers every time ``Node.children`` is called. There is overhead on the Python interpreter to create these objects. It is safe and better performing to keep and re-use children references instead, see examples below\n\nLimitations\n=============\n\n* Deletions are not implemented\n* The C library implementation uses pointer arrays for children to reduce search space complexity and character pointers for names to allow for arbitrary name lengths. This may lead to memory fragmentation\n* ``Node`` objects in python are read only. It is not possible to override the name of an existing ``Node`` object nor modify its attributes\n* Character encodings that allow for null characters such as UCS-2 *should not be used*\n\nExample Usage\n==============\n\n.. code-block:: python\n\n  from nodetrie import Node\n\n  # This is the root of the tree, keep a reference to it.\n  # Deleting or letting the root node go out of scope will de-allocate\n  # the entire tree\n  node = Node()\n\n  # Insert a linked tree so that a->b->c->d where -> means 'has child node'\n  node.insert_split_path(['a', 'b', 'c', 'd'])\n  node.children[0].name == 'a'\n\n  # Sub-trees can be referred to by child nodes\n  a_node = node.children[0]\n  a_node.name == 'a'\n  a_node.children[0].name == 'b'\n  a_node.is_leaf() == False\n\n  # Insertions create only new nodes\n  # Insert linked tree so that a->b->c->dd\n  node.insert_split_path(['a', 'b', 'c', 'dd'])\n\n  # Only one 'a' node\n  node.children_size == 1\n\n  # Existing references to nodes will have correct children\n  # after insertion without recreating the node object.\n  # Here, a_node is an existing object prior to more nodes\n  # being added to its sub-tree. After insertion, a's sub-tree contains newly\n  # inserted nodes as expected\n\n  # 'c' node is first child of 'b' which is first child of 'a'\n  # 'c' node has two children, 'd' and 'dd'\n  c_node = a_node.children[0].children[0]\n  c_node.children_size == 2\n  c_node.is_leaf() == False\n\n  # 'd' and 'dd' are both leaf nodes\n  leaf_nodes = [c for c in c_node.children if c.is_leaf()]\n  len(leaf_nodes) == 2\n\n.. note:: De-allocation\n\n  Tree is de-allocated when and only when root node goes out of scope or is deleted. Letting sub-tree objects go out of scope or explicitly deleting them will *not de-allocate that sub-tree*.\n\n.. note:: Sub-tree insertions\n\n  Insertions on non-root nodes work as expected. However, ``Node.insert`` does *not* check if a node is already present, unlike ``Node.insert_split_path``\n\nSearching\n----------\n\nNodeTrie supports exact name as well as file mask matching tree search.\n\n.. code-block:: python\n\n  from __future__ import print_function\n  from nodetrie import Node\n\n  node = Node()\n  for paths in [['a', 'b', 'c1', 'd1'], ['a', 'b', 'c1', 'd2'],\n                ['a', 'b', 'c2', 'd1'], ['a', 'b', 'c2', 'd2']]:\n      node.insert_split_path(paths)\n  for path, _node in node.search(node, ['a', 'b', '*', '*'], []):\n      print(path, _node)\n\nOutput\n\n.. code-block:: python\n\n  [u'a', u'b', u'c1', u'd1'] Node: 'd1'\n  [u'a', u'b', u'c1', u'd2'] Node: 'd2'\n  [u'a', u'b', u'c2', u'd1'] Node: 'd1'\n  [u'a', u'b', u'c2', u'd2'] Node: 'd2'\n\nSeparator joined node names for a matched sub-tree are returned by the query function.\n\n.. code:: python\n\n  for match in node.query('a.b.*.*'):\n      print(match)\n\n  for match in node.query('a|b|*|*', separator='|'):\n     print(match)\n\nOutput\n\n.. code:: python\n\n  (u'a.b.c1.d1', Node: 'd1')\n  (u'a.b.c1.d2', Node: 'd2')\n  (u'a.b.c2.d1', Node: 'd1')\n  (u'a.b.c2.d2', Node: 'd2')\n\n  (u'a|b|c1|d1', Node: 'd1')\n  (u'a|b|c1|d2', Node: 'd2')\n  (u'a|b|c2|d1', Node: 'd1')\n  (u'a|b|c2|d2', Node: 'd2')\n\nContributions are most welcome.", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/NodeTrie/NodeTrie_Py", "keywords": "", "license": "LGPLv2", "maintainer": "", "maintainer_email": "", "name": "nodetrie", "package_url": "https://pypi.org/project/nodetrie/", "platform": "any", "project_url": "https://pypi.org/project/nodetrie/", "project_urls": {"Homepage": "https://github.com/NodeTrie/NodeTrie_Py"}, "release_url": "https://pypi.org/project/nodetrie/1.0.6/", "requires_dist": null, "requires_python": "", "summary": "Python bindings for NodeTrie, a trie data structure library", "version": "1.0.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"nodetrie\">\n<h2>NodeTrie</h2>\n<p>A Trie data structure library.</p>\n<a href=\"https://pypi.python.org/pypi/nodetrie\" rel=\"nofollow\"><img alt=\"Latest Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e83db65baaa135eb91623cc4445f94b20108b983/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6e6f6465747269652e737667\"></a>\n<a href=\"https://travis-ci.org/NodeTrie/NodeTrie_Py\" rel=\"nofollow\"><img alt=\"CI status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/44d93aa5762668beba472a45fce23e680205fafc/68747470733a2f2f7472617669732d63692e6f72672f4e6f6465547269652f4e6f6465547269655f50792e7376673f6272616e63683d6d6173746572\"></a>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<pre>pip install nodetrie\n</pre>\n</div>\n<div id=\"motivation-design-goals\">\n<h2>Motivation, design goals</h2>\n<p>NodeTrie is a Python extension to a native C library written for this purpose.</p>\n<p>It came about from a lack of viable alternatives for Python. While other trie library implementations exist, they suffer from severe limitations such as</p>\n<ul>\n<li>Read only structures, no insertions</li>\n<li>High memory use for large trees</li>\n<li>Lack of searching, particularly file mask or wild card style searching</li>\n<li>Slow inserts</li>\n</ul>\n<p>Existing implementations on PyPi fall into these broad categories, including <a href=\"https://github.com/pytries/marisa-trie\" rel=\"nofollow\">Marissa-Trie</a> (read only) and <a href=\"https://github.com/pytries/datrie\" rel=\"nofollow\">datrie</a> (slow inserts, very high memory use for large trees).</p>\n<p>NodeTrie\u2019s C library is designed to minimize memory use as much as possible and still allow arbitrary length trees that can be searched.</p>\n<p>Each node has a name associated with it as its data, along with children list and number of children.</p>\n</div>\n<div id=\"features-and-design-notes\">\n<h2>Features and design notes</h2>\n<ul>\n<li>NodeTrie is an n-ary tree, meaning any one node can have any number of children</li>\n<li>Node children arrays are dynamically resized <em>as needed on insertion</em> on a per node basis. No fixed minimum nor maximum size</li>\n<li>Node names can be of arbitrary length, available memory allowing</li>\n<li>Node names from <tt>Node.name</tt> are always unicode in either Python 2/3</li>\n<li>Any python string type may be used on insertion</li>\n<li>Node names are implicitly decoded from unicode on insertion, if needed, with <tt>nodetrie.ENCODING</tt> (<cite>utf-8</cite>) default encoding which can be overridden</li>\n<li>New Python <tt>Node</tt> objects are created from the underlying C pointers every time <tt>Node.children</tt> is called. There is overhead on the Python interpreter to create these objects. It is safe and better performing to keep and re-use children references instead, see examples below</li>\n</ul>\n</div>\n<div id=\"limitations\">\n<h2>Limitations</h2>\n<ul>\n<li>Deletions are not implemented</li>\n<li>The C library implementation uses pointer arrays for children to reduce search space complexity and character pointers for names to allow for arbitrary name lengths. This may lead to memory fragmentation</li>\n<li><tt>Node</tt> objects in python are read only. It is not possible to override the name of an existing <tt>Node</tt> object nor modify its attributes</li>\n<li>Character encodings that allow for null characters such as UCS-2 <em>should not be used</em></li>\n</ul>\n</div>\n<div id=\"example-usage\">\n<h2>Example Usage</h2>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">nodetrie</span> <span class=\"kn\">import</span> <span class=\"n\">Node</span>\n\n<span class=\"c1\"># This is the root of the tree, keep a reference to it.</span>\n<span class=\"c1\"># Deleting or letting the root node go out of scope will de-allocate</span>\n<span class=\"c1\"># the entire tree</span>\n<span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">Node</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Insert a linked tree so that a-&gt;b-&gt;c-&gt;d where -&gt; means 'has child node'</span>\n<span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">insert_split_path</span><span class=\"p\">([</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"s1\">'c'</span><span class=\"p\">,</span> <span class=\"s1\">'d'</span><span class=\"p\">])</span>\n<span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">children</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s1\">'a'</span>\n\n<span class=\"c1\"># Sub-trees can be referred to by child nodes</span>\n<span class=\"n\">a_node</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">children</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">a_node</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s1\">'a'</span>\n<span class=\"n\">a_node</span><span class=\"o\">.</span><span class=\"n\">children</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s1\">'b'</span>\n<span class=\"n\">a_node</span><span class=\"o\">.</span><span class=\"n\">is_leaf</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>\n\n<span class=\"c1\"># Insertions create only new nodes</span>\n<span class=\"c1\"># Insert linked tree so that a-&gt;b-&gt;c-&gt;dd</span>\n<span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">insert_split_path</span><span class=\"p\">([</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"s1\">'c'</span><span class=\"p\">,</span> <span class=\"s1\">'dd'</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Only one 'a' node</span>\n<span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">children_size</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>\n\n<span class=\"c1\"># Existing references to nodes will have correct children</span>\n<span class=\"c1\"># after insertion without recreating the node object.</span>\n<span class=\"c1\"># Here, a_node is an existing object prior to more nodes</span>\n<span class=\"c1\"># being added to its sub-tree. After insertion, a's sub-tree contains newly</span>\n<span class=\"c1\"># inserted nodes as expected</span>\n\n<span class=\"c1\"># 'c' node is first child of 'b' which is first child of 'a'</span>\n<span class=\"c1\"># 'c' node has two children, 'd' and 'dd'</span>\n<span class=\"n\">c_node</span> <span class=\"o\">=</span> <span class=\"n\">a_node</span><span class=\"o\">.</span><span class=\"n\">children</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">children</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">c_node</span><span class=\"o\">.</span><span class=\"n\">children_size</span> <span class=\"o\">==</span> <span class=\"mi\">2</span>\n<span class=\"n\">c_node</span><span class=\"o\">.</span><span class=\"n\">is_leaf</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>\n\n<span class=\"c1\"># 'd' and 'dd' are both leaf nodes</span>\n<span class=\"n\">leaf_nodes</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">c</span> <span class=\"k\">for</span> <span class=\"n\">c</span> <span class=\"ow\">in</span> <span class=\"n\">c_node</span><span class=\"o\">.</span><span class=\"n\">children</span> <span class=\"k\">if</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">is_leaf</span><span class=\"p\">()]</span>\n<span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">leaf_nodes</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">2</span>\n</pre>\n<div>\n<p>Note</p>\n<p>De-allocation</p>\n<p>Tree is de-allocated when and only when root node goes out of scope or is deleted. Letting sub-tree objects go out of scope or explicitly deleting them will <em>not de-allocate that sub-tree</em>.</p>\n</div>\n<div>\n<p>Note</p>\n<p>Sub-tree insertions</p>\n<p>Insertions on non-root nodes work as expected. However, <tt>Node.insert</tt> does <em>not</em> check if a node is already present, unlike <tt>Node.insert_split_path</tt></p>\n</div>\n<div id=\"searching\">\n<h3>Searching</h3>\n<p>NodeTrie supports exact name as well as file mask matching tree search.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">__future__</span> <span class=\"kn\">import</span> <span class=\"n\">print_function</span>\n<span class=\"kn\">from</span> <span class=\"nn\">nodetrie</span> <span class=\"kn\">import</span> <span class=\"n\">Node</span>\n\n<span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">Node</span><span class=\"p\">()</span>\n<span class=\"k\">for</span> <span class=\"n\">paths</span> <span class=\"ow\">in</span> <span class=\"p\">[[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"s1\">'c1'</span><span class=\"p\">,</span> <span class=\"s1\">'d1'</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"s1\">'c1'</span><span class=\"p\">,</span> <span class=\"s1\">'d2'</span><span class=\"p\">],</span>\n              <span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"s1\">'c2'</span><span class=\"p\">,</span> <span class=\"s1\">'d1'</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"s1\">'c2'</span><span class=\"p\">,</span> <span class=\"s1\">'d2'</span><span class=\"p\">]]:</span>\n    <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">insert_split_path</span><span class=\"p\">(</span><span class=\"n\">paths</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">path</span><span class=\"p\">,</span> <span class=\"n\">_node</span> <span class=\"ow\">in</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"s1\">'*'</span><span class=\"p\">,</span> <span class=\"s1\">'*'</span><span class=\"p\">],</span> <span class=\"p\">[]):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">,</span> <span class=\"n\">_node</span><span class=\"p\">)</span>\n</pre>\n<p>Output</p>\n<pre><span class=\"p\">[</span><span class=\"sa\">u</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'c1'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'d1'</span><span class=\"p\">]</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"s1\">'d1'</span>\n<span class=\"p\">[</span><span class=\"sa\">u</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'c1'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'d2'</span><span class=\"p\">]</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"s1\">'d2'</span>\n<span class=\"p\">[</span><span class=\"sa\">u</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'c2'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'d1'</span><span class=\"p\">]</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"s1\">'d1'</span>\n<span class=\"p\">[</span><span class=\"sa\">u</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'c2'</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'d2'</span><span class=\"p\">]</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"s1\">'d2'</span>\n</pre>\n<p>Separator joined node names for a matched sub-tree are returned by the query function.</p>\n<pre><span class=\"k\">for</span> <span class=\"n\">match</span> <span class=\"ow\">in</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"s1\">'a.b.*.*'</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">match</span><span class=\"p\">)</span>\n\n<span class=\"k\">for</span> <span class=\"n\">match</span> <span class=\"ow\">in</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"s1\">'a|b|*|*'</span><span class=\"p\">,</span> <span class=\"n\">separator</span><span class=\"o\">=</span><span class=\"s1\">'|'</span><span class=\"p\">):</span>\n   <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">match</span><span class=\"p\">)</span>\n</pre>\n<p>Output</p>\n<pre><span class=\"p\">(</span><span class=\"sa\">u</span><span class=\"s1\">'a.b.c1.d1'</span><span class=\"p\">,</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"s1\">'d1'</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"sa\">u</span><span class=\"s1\">'a.b.c1.d2'</span><span class=\"p\">,</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"s1\">'d2'</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"sa\">u</span><span class=\"s1\">'a.b.c2.d1'</span><span class=\"p\">,</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"s1\">'d1'</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"sa\">u</span><span class=\"s1\">'a.b.c2.d2'</span><span class=\"p\">,</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"s1\">'d2'</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"sa\">u</span><span class=\"s1\">'a|b|c1|d1'</span><span class=\"p\">,</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"s1\">'d1'</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"sa\">u</span><span class=\"s1\">'a|b|c1|d2'</span><span class=\"p\">,</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"s1\">'d2'</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"sa\">u</span><span class=\"s1\">'a|b|c2|d1'</span><span class=\"p\">,</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"s1\">'d1'</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"sa\">u</span><span class=\"s1\">'a|b|c2|d2'</span><span class=\"p\">,</span> <span class=\"n\">Node</span><span class=\"p\">:</span> <span class=\"s1\">'d2'</span><span class=\"p\">)</span>\n</pre>\n<p>Contributions are most welcome.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 3257369, "releases": {"1.0.1": [{"comment_text": "", "digests": {"md5": "ab6cdcef4046d845d1abd91ff46b5704", "sha256": "a4a459a2302d448800cbdef165e64a8406b8b98bf81375a0372ab2a1359323a0"}, "downloads": -1, "filename": "nodetrie-1.0.1.tar.gz", "has_sig": false, "md5_digest": "ab6cdcef4046d845d1abd91ff46b5704", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 72978, "upload_time": "2017-03-16T18:22:06", "upload_time_iso_8601": "2017-03-16T18:22:06.133860Z", "url": "https://files.pythonhosted.org/packages/27/b9/92467bd792b22cd198b473fed13048a39d4def8f11c4642d49e49996f8ce/nodetrie-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "c2076d6948cbfb0aae776cacfae9d7a2", "sha256": "e4b58a2038a9734ad7c437b3845bcfeb2d5cf0343085fafcadba0f293eded13d"}, "downloads": -1, "filename": "nodetrie-1.0.2.tar.gz", "has_sig": false, "md5_digest": "c2076d6948cbfb0aae776cacfae9d7a2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 75175, "upload_time": "2017-03-21T18:33:50", "upload_time_iso_8601": "2017-03-21T18:33:50.855143Z", "url": "https://files.pythonhosted.org/packages/6b/17/ef2f5581761bab759b4d5d63794b731b2be10c63b8300693884252b55e28/nodetrie-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "af8e83c6fb51b9163728ff50a3173238", "sha256": "ed950bb4be05ce96a30a06a3f6fd94429e7a325e2de380c8e5e5b5dcb0690894"}, "downloads": -1, "filename": "nodetrie-1.0.3.tar.gz", "has_sig": false, "md5_digest": "af8e83c6fb51b9163728ff50a3173238", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 75191, "upload_time": "2017-03-24T17:56:39", "upload_time_iso_8601": "2017-03-24T17:56:39.774313Z", "url": "https://files.pythonhosted.org/packages/40/b2/6a2659c17bfed30b6cf6d2feb5d6d2107148fd75c40e1881b578de13f052/nodetrie-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "8bacbab6294254779b4b051d1d38a15b", "sha256": "a14b43260c78cb758f4b430b5d7b1aa75f756f158d149d209d4bba6ee9159be7"}, "downloads": -1, "filename": "nodetrie-1.0.4.tar.gz", "has_sig": false, "md5_digest": "8bacbab6294254779b4b051d1d38a15b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 75030, "upload_time": "2017-03-24T18:18:29", "upload_time_iso_8601": "2017-03-24T18:18:29.977276Z", "url": "https://files.pythonhosted.org/packages/e4/9e/bf1a832312b04996556286f98fb6ca6c74367004236d1c221caaf120ce7d/nodetrie-1.0.4.tar.gz", "yanked": false}], "1.0.5": [{"comment_text": "", "digests": {"md5": "9ba8292de494d6c63438d31803aa4f24", "sha256": "a0d15558e25d20a24408f9537b7d0313646d1ee4a33e3c240c23aa4e23a7c306"}, "downloads": -1, "filename": "nodetrie-1.0.5.tar.gz", "has_sig": false, "md5_digest": "9ba8292de494d6c63438d31803aa4f24", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 75437, "upload_time": "2017-03-24T18:30:44", "upload_time_iso_8601": "2017-03-24T18:30:44.684300Z", "url": "https://files.pythonhosted.org/packages/55/de/1c27f24d0ce9b25938fbe295d2c8df7f1b5efe103bc24e6a30b30142805b/nodetrie-1.0.5.tar.gz", "yanked": false}], "1.0.6": [{"comment_text": "", "digests": {"md5": "b6b56add17727dd278ee408e0e016647", "sha256": "bdbf51b1ef96ccd405a4b95944f812323b28c7ab34f474c683d270ef3efc450a"}, "downloads": -1, "filename": "nodetrie-1.0.6.tar.gz", "has_sig": false, "md5_digest": "b6b56add17727dd278ee408e0e016647", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 77953, "upload_time": "2017-10-17T16:25:29", "upload_time_iso_8601": "2017-10-17T16:25:29.276425Z", "url": "https://files.pythonhosted.org/packages/0b/69/25e5a761a9744a0b7857155a92cc9541fac167b9bb5a3e9dc9f3052a3e68/nodetrie-1.0.6.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b6b56add17727dd278ee408e0e016647", "sha256": "bdbf51b1ef96ccd405a4b95944f812323b28c7ab34f474c683d270ef3efc450a"}, "downloads": -1, "filename": "nodetrie-1.0.6.tar.gz", "has_sig": false, "md5_digest": "b6b56add17727dd278ee408e0e016647", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 77953, "upload_time": "2017-10-17T16:25:29", "upload_time_iso_8601": "2017-10-17T16:25:29.276425Z", "url": "https://files.pythonhosted.org/packages/0b/69/25e5a761a9744a0b7857155a92cc9541fac167b9bb5a3e9dc9f3052a3e68/nodetrie-1.0.6.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:57 2020"}