{"info": {"author": "Edward Labao", "author_email": "edlabao.dev@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# jaraf\n<br>\n\nJust another rakish application framework.\n<br>\n<br>\n\n## Overview\n<br>\n\nJARAF is an application framework, which just just a fancy name for a\ncollection of python code that can help jumpstart the development of\ncommand-line tools and applications, providing a developer is willing to follow\na few rules and conventions to use the framework.\n<br>\n\nThe framework itself is fairly straighforward to use. An application will\ninherit from a base application class named `jaraf.App` and implement\none required method (`jaraf.App.main()`). From there, the application can\noptionally implement a number of other prescribed methods to set up and\ncustomize itself. For example, an application that needs custom command-line\narguments will implement the `jaraf.App.add_arguments()` and\n`jaraf.App.process_arguments()` methods.\n<br>\n\nA lot of simple applications will probably only ever need the\n`jaraf.App` class, but for more complex applications, additional\nfeatures are provided through mixin classes.\n<br>\n<br>\n\nApplication Base Class\n---\n<br>\n\nThe application base class, `jaraf.App`, is a virtual base class that\nmust be inherited by an application in order to use the framework. It provides\nsome basic features useful to most command-line applications. This includes\nexception handling to prevent an application from abruptly exiting, a\nbest-effort exit code, logging methods, and built-in command-line arguments to\nset various parameters.\n<br>\n\nIt has one virtual method named :meth:`jaraf.App.main()` that must be\nimplemented. A minimalist application need only implement this one method to\nuse the framework. However, there are other virtual methods that can be\nimplemented and public methods that can be overloaded that enable developers to\nfurther customize an application.\n<br>\n\nHere's the obligatory starting example:\n<br>\n\n```python\nfrom jaraf import App\n\nclass HelloWorldApp(App):\n    def main(self):\n        self.log.info(\"Hello, World!\")\n        raise RuntimeError(\"Aaand goodbye...\")\n\nif __name__ == \"__main__\":\n    app = HelloWorldApp()\n    app.run()\n```\n<br>\n\nWhen saved to file named hello_world.py and run, it will print something like\nthe following output to the terminal::\n<br>\n\n```\n2018-04-10 22:00:10,379 INFO ---------------------------------------------------------------\n2018-04-10 22:00:10,379 INFO STARTING hello_world.py\n2018-04-10 22:00:10,379 INFO Hello, World!\n2018-04-10 22:00:10,379 ERROR Unhandled exception: Aaand goodbye...\n2018-04-10 22:00:10,379 ERROR > Traceback (most recent call last):\n2018-04-10 22:00:10,379 ERROR >   File \"/lib/python/jaraf/app/__init__.py\", line 218, in run\n2018-04-10 22:00:10,379 ERROR >     self.main()\n2018-04-10 22:00:10,379 ERROR >   File \"./hello_world.py\", line 5, in main\n2018-04-10 22:00:10,379 ERROR >     raise RuntimeError(\"Aaand goodbye...\")\n2018-04-10 22:00:10,379 ERROR > RuntimeError: Aaand goodbye...\n2018-04-10 22:00:10,379 INFO FINISHED hello_world.py\n2018-04-10 22:00:10,379 INFO - Exit status: 1\n```\n<br>\n\nIt's an underwhelming example to be sure, but for a few lines of code, we get a\ntimestamped output format (even the stack trace is properly formatted) and\nlogged callouts for the start, finish and exit status of our applications. Plus\nif you bring up the help text with `hello_world.py -h`, you'll see a handful of\noptions that were automatically added to our application.\n<br>\n<br>\n\n## Mixins\n<br>\n\nMixins provide additional functionality to an application through multiple\ninheritance with each mixin class usually providing just a narrow feature set.\nThe philosophy here is that applications should not be bloated by code that is\nnever going to be run. Instead, an application should be able to selectively\nload just the functionality it needs.\n<br>\n\nFor example, to add support for logging to a file, an application class could\nbe defined like so:\n<br>\n\n```python\nfrom jaraf import App\nfrom jaraf.mixin.cron import CronMixin\nfrom jaraf.mixin.logfile import LogfileMixin\n\nclass HelloWorldApp(LogfileMixin, App):\n    # Class definition follows...\n```\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/edlabao/jaraf", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "jaraf", "package_url": "https://pypi.org/project/jaraf/", "platform": "", "project_url": "https://pypi.org/project/jaraf/", "project_urls": {"Homepage": "https://github.com/edlabao/jaraf"}, "release_url": "https://pypi.org/project/jaraf/0.1.1/", "requires_dist": null, "requires_python": "", "summary": "Just another rakish application framework", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>jaraf</h1>\n<br>\n<p>Just another rakish application framework.\n<br>\n<br></p>\n<h2>Overview</h2>\n<br>\n<p>JARAF is an application framework, which just just a fancy name for a\ncollection of python code that can help jumpstart the development of\ncommand-line tools and applications, providing a developer is willing to follow\na few rules and conventions to use the framework.\n<br></p>\n<p>The framework itself is fairly straighforward to use. An application will\ninherit from a base application class named <code>jaraf.App</code> and implement\none required method (<code>jaraf.App.main()</code>). From there, the application can\noptionally implement a number of other prescribed methods to set up and\ncustomize itself. For example, an application that needs custom command-line\narguments will implement the <code>jaraf.App.add_arguments()</code> and\n<code>jaraf.App.process_arguments()</code> methods.\n<br></p>\n<p>A lot of simple applications will probably only ever need the\n<code>jaraf.App</code> class, but for more complex applications, additional\nfeatures are provided through mixin classes.\n<br>\n<br></p>\n<h2>Application Base Class</h2>\n<br>\n<p>The application base class, <code>jaraf.App</code>, is a virtual base class that\nmust be inherited by an application in order to use the framework. It provides\nsome basic features useful to most command-line applications. This includes\nexception handling to prevent an application from abruptly exiting, a\nbest-effort exit code, logging methods, and built-in command-line arguments to\nset various parameters.\n<br></p>\n<p>It has one virtual method named :meth:<code>jaraf.App.main()</code> that must be\nimplemented. A minimalist application need only implement this one method to\nuse the framework. However, there are other virtual methods that can be\nimplemented and public methods that can be overloaded that enable developers to\nfurther customize an application.\n<br></p>\n<p>Here's the obligatory starting example:\n<br></p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">jaraf</span> <span class=\"kn\">import</span> <span class=\"n\">App</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">HelloWorldApp</span><span class=\"p\">(</span><span class=\"n\">App</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s2\">\"Hello, World!\"</span><span class=\"p\">)</span>\n        <span class=\"k\">raise</span> <span class=\"ne\">RuntimeError</span><span class=\"p\">(</span><span class=\"s2\">\"Aaand goodbye...\"</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">HelloWorldApp</span><span class=\"p\">()</span>\n    <span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre>\n<br>\n<p>When saved to file named hello_world.py and run, it will print something like\nthe following output to the terminal::\n<br></p>\n<pre><code>2018-04-10 22:00:10,379 INFO ---------------------------------------------------------------\n2018-04-10 22:00:10,379 INFO STARTING hello_world.py\n2018-04-10 22:00:10,379 INFO Hello, World!\n2018-04-10 22:00:10,379 ERROR Unhandled exception: Aaand goodbye...\n2018-04-10 22:00:10,379 ERROR &gt; Traceback (most recent call last):\n2018-04-10 22:00:10,379 ERROR &gt;   File \"/lib/python/jaraf/app/__init__.py\", line 218, in run\n2018-04-10 22:00:10,379 ERROR &gt;     self.main()\n2018-04-10 22:00:10,379 ERROR &gt;   File \"./hello_world.py\", line 5, in main\n2018-04-10 22:00:10,379 ERROR &gt;     raise RuntimeError(\"Aaand goodbye...\")\n2018-04-10 22:00:10,379 ERROR &gt; RuntimeError: Aaand goodbye...\n2018-04-10 22:00:10,379 INFO FINISHED hello_world.py\n2018-04-10 22:00:10,379 INFO - Exit status: 1\n</code></pre>\n<br>\n<p>It's an underwhelming example to be sure, but for a few lines of code, we get a\ntimestamped output format (even the stack trace is properly formatted) and\nlogged callouts for the start, finish and exit status of our applications. Plus\nif you bring up the help text with <code>hello_world.py -h</code>, you'll see a handful of\noptions that were automatically added to our application.\n<br>\n<br></p>\n<h2>Mixins</h2>\n<br>\n<p>Mixins provide additional functionality to an application through multiple\ninheritance with each mixin class usually providing just a narrow feature set.\nThe philosophy here is that applications should not be bloated by code that is\nnever going to be run. Instead, an application should be able to selectively\nload just the functionality it needs.\n<br></p>\n<p>For example, to add support for logging to a file, an application class could\nbe defined like so:\n<br></p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">jaraf</span> <span class=\"kn\">import</span> <span class=\"n\">App</span>\n<span class=\"kn\">from</span> <span class=\"nn\">jaraf.mixin.cron</span> <span class=\"kn\">import</span> <span class=\"n\">CronMixin</span>\n<span class=\"kn\">from</span> <span class=\"nn\">jaraf.mixin.logfile</span> <span class=\"kn\">import</span> <span class=\"n\">LogfileMixin</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">HelloWorldApp</span><span class=\"p\">(</span><span class=\"n\">LogfileMixin</span><span class=\"p\">,</span> <span class=\"n\">App</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Class definition follows...</span>\n</pre>\n\n          </div>"}, "last_serial": 6277958, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "93f1d14c58ee219efb564bfc8f06f3f3", "sha256": "65420ec3800f9f57ba67ae919b03e0b56f0d3c2c4603e27952bcc77ed5606074"}, "downloads": -1, "filename": "jaraf-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "93f1d14c58ee219efb564bfc8f06f3f3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12465, "upload_time": "2019-12-11T08:29:06", "upload_time_iso_8601": "2019-12-11T08:29:06.567765Z", "url": "https://files.pythonhosted.org/packages/f9/fc/7806bb9d3e190694ba55b8fc6cf7173bf7139b014989add4637a0d111c30/jaraf-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "782f39520dc901ad770637d1a75f87b2", "sha256": "70ddc6feab5132c14daae7918a93ef9adce77366451b49f580fadca16f60e22d"}, "downloads": -1, "filename": "jaraf-0.1.1.tar.gz", "has_sig": false, "md5_digest": "782f39520dc901ad770637d1a75f87b2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11056, "upload_time": "2019-12-11T08:29:09", "upload_time_iso_8601": "2019-12-11T08:29:09.522667Z", "url": "https://files.pythonhosted.org/packages/22/df/97e291ea54034fb6fcc60a1d5ac751fc8990759577dc164c86e77422d099/jaraf-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "93f1d14c58ee219efb564bfc8f06f3f3", "sha256": "65420ec3800f9f57ba67ae919b03e0b56f0d3c2c4603e27952bcc77ed5606074"}, "downloads": -1, "filename": "jaraf-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "93f1d14c58ee219efb564bfc8f06f3f3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12465, "upload_time": "2019-12-11T08:29:06", "upload_time_iso_8601": "2019-12-11T08:29:06.567765Z", "url": "https://files.pythonhosted.org/packages/f9/fc/7806bb9d3e190694ba55b8fc6cf7173bf7139b014989add4637a0d111c30/jaraf-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "782f39520dc901ad770637d1a75f87b2", "sha256": "70ddc6feab5132c14daae7918a93ef9adce77366451b49f580fadca16f60e22d"}, "downloads": -1, "filename": "jaraf-0.1.1.tar.gz", "has_sig": false, "md5_digest": "782f39520dc901ad770637d1a75f87b2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11056, "upload_time": "2019-12-11T08:29:09", "upload_time_iso_8601": "2019-12-11T08:29:09.522667Z", "url": "https://files.pythonhosted.org/packages/22/df/97e291ea54034fb6fcc60a1d5ac751fc8990759577dc164c86e77422d099/jaraf-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:53:09 2020"}