{"info": {"author": "Daniel Dom\u00ednguez", "author_email": "daniel.dominguez@imdea.org", "bugtrack_url": null, "classifiers": [], "description": "Taza\n====\n\nTaza is a Python library with a set of abstractions over Tacyt that\nprovides an OO layer over the query language.\n\nInstalation\n~~~~~~~~~~~\n\nInstall via pip\n\n::\n\n   pip install taza\n\nThe libraries for tacyt are vendored inside taza, this is because the\nTacyt python client is not distributed using pip.\n\nUsage\n~~~~~\n\nThe library has currently two main components, the wrapper for the API\nand the query abstractions.\n\nTo use the API wrapper you must instantiate a ``TazaClient`` class.\n\n.. code:: python\n\n   from taza.tacyt.TacytApp import TacytApp\n   from taza import TazaClient\n\n   app = TacytApp(APP_ID, SECREY_KEY)\n   client = TazaClient(app)\n\nClients can also be instantiated with a factory method that wraps the\nTacytApp class. Removing the need of importing Tacyt to the current\nscript.\n\n.. code:: python\n\n   from taza import TazaClient\n\n   client = TazaClient.from_credentials(APP_ID, SECRET_KEY)\n\nQuerying tacyt\n^^^^^^^^^^^^^^\n\nYou can send queries to tacyt for searching apps throught the\n``search_apps_with_query`` method. This method will handle pagination\nautomatically. It returns a generators, so no query is actually made\nuntil the data is collected.\n\nFor example, let\u2019s get the SHA256 hash of the apk of whatsapp.\n\n.. code:: python\n\n   from taza import TazaClient\n\n   client = TazaClient.from_credentials(APP_ID, SECRET_KEY)\n\n   query = \"packageName:com.whatsapp AND origin:GooglePlay\"\n   fields = [\"sha256\"]\n\n   apps = client.search_apps_with_query(query, fields) # No actual connection to Tacyt done here.\n\n   for app in apps: # Now the generator starts yielding and therefore connecting to Tacyt.\n       print(app)\n\nQuery language abstraction\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe queries are send as a string to Tacyt, this means that the queries\nmust be managed as strings, which sometimes can get messy. Taza has an\nOO abstraction that allows to write queries in Python.\n\nFirst, each predicate can he specified with the ``cond`` class. There\nare shorthands for common predicates (at least common to me).\n\n.. code:: python\n\n   from taza.query import cond, packageName, fromGooglePlay\n\n   q1 = cond('packageName', 'com.company.awesome_app')\n   q2 = packageName('com.company.awesome_app')\n\n   str(q1) # => \"packageName:com.company.awesome_app\"\n   str(q2) # => \"packageName:com.company.awesome_app\"\n   str(fromGooglePlay) => \"origin:GooglePlay\"\n\n   assert str(q1) == str(q2)\n\nThe predicates can be combined with AND, OR and NOT operators.\n\n.. code:: python\n\n   from taza.query import cond, packageName, fromGooglePlay\n\n   q1 = cond('packageName', 'com.company.awesome_app')\n   q2 = packageName('com.company.awesome_app')\n\n   str(q1 & fromGooglePlay) # => \"packageName:com.company.awesome_app AND origin:GooglePlay\"\n   str(q2 | -fromGooglePlay) # => \"packageName:com.company.awesome_app OR -origin:GooglePlay\"\n\nBear in mind that Tacyt only allows up to 40 predicates per query.\n\nIf you need to agreggate several predicates under the same operator, you\ncan use the ``or_many`` and ``and_many`` functions. They are usefull if\nyou need to define the query programatically under a set of elements.\n\n.. code:: python\n\n   from taza.query import cond, packageName, fromGooglePlay\n\n   q1 = packageName(\"app1\")\n   q2 = packageName(\"app2\")\n   q3 = packageName(\"app3\")\n\n   assert or_many(q1, q2, q3) == (q1 | q2 | q3)\n\n   qs = [fromGooglePlay, cond('versionCode', '42'), packageName('my.another.app')]\n   assert and_many(*qs) == (fromGooglePlay & cond('versionCode', '42') & packageName('my.another.app'))\n\nThese queries are sent to the ``search_apps_with_query`` method in the\nsame way that string based queries are sent. The whatsapp example could\nbe rewritten as such.\n\n.. code:: python\n\n   from taza import TazaClient\n   from taza.query import packageName, fromGooglePlay\n\n   client = TazaClient.from_credentials(APP_ID, SECRET_KEY)\n\n   query = packageName('com.whatsapp') & fromGooglePlay\n   fields = [\"sha256\"]\n\n   apps = client.search_apps_with_query(query, fields) # No actual connection to Tacyt done here.\n\n   for app in apps: # Now the generator starts yielding and therefore connecting to Tacyt.\n       print(app)", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://gitlab.software.imdea.org/android/taza", "keywords": "mobile tacyt android", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "taza", "package_url": "https://pypi.org/project/taza/", "platform": "", "project_url": "https://pypi.org/project/taza/", "project_urls": {"Homepage": "https://gitlab.software.imdea.org/android/taza"}, "release_url": "https://pypi.org/project/taza/2.0.0/", "requires_dist": null, "requires_python": "", "summary": "A set of classes and abstractions for working with Tacyt", "version": "2.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Taza is a Python library with a set of abstractions over Tacyt that\nprovides an OO layer over the query language.</p>\n<div id=\"instalation\">\n<h2>Instalation</h2>\n<p>Install via pip</p>\n<pre>pip install taza\n</pre>\n<p>The libraries for tacyt are vendored inside taza, this is because the\nTacyt python client is not distributed using pip.</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>The library has currently two main components, the wrapper for the API\nand the query abstractions.</p>\n<p>To use the API wrapper you must instantiate a <tt>TazaClient</tt> class.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">taza.tacyt.TacytApp</span> <span class=\"kn\">import</span> <span class=\"n\">TacytApp</span>\n<span class=\"kn\">from</span> <span class=\"nn\">taza</span> <span class=\"kn\">import</span> <span class=\"n\">TazaClient</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">TacytApp</span><span class=\"p\">(</span><span class=\"n\">APP_ID</span><span class=\"p\">,</span> <span class=\"n\">SECREY_KEY</span><span class=\"p\">)</span>\n<span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">TazaClient</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"p\">)</span>\n</pre>\n<p>Clients can also be instantiated with a factory method that wraps the\nTacytApp class. Removing the need of importing Tacyt to the current\nscript.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">taza</span> <span class=\"kn\">import</span> <span class=\"n\">TazaClient</span>\n\n<span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">TazaClient</span><span class=\"o\">.</span><span class=\"n\">from_credentials</span><span class=\"p\">(</span><span class=\"n\">APP_ID</span><span class=\"p\">,</span> <span class=\"n\">SECRET_KEY</span><span class=\"p\">)</span>\n</pre>\n<div id=\"querying-tacyt\">\n<h3>Querying tacyt</h3>\n<p>You can send queries to tacyt for searching apps throught the\n<tt>search_apps_with_query</tt> method. This method will handle pagination\nautomatically. It returns a generators, so no query is actually made\nuntil the data is collected.</p>\n<p>For example, let\u2019s get the SHA256 hash of the apk of whatsapp.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">taza</span> <span class=\"kn\">import</span> <span class=\"n\">TazaClient</span>\n\n<span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">TazaClient</span><span class=\"o\">.</span><span class=\"n\">from_credentials</span><span class=\"p\">(</span><span class=\"n\">APP_ID</span><span class=\"p\">,</span> <span class=\"n\">SECRET_KEY</span><span class=\"p\">)</span>\n\n<span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"s2\">\"packageName:com.whatsapp AND origin:GooglePlay\"</span>\n<span class=\"n\">fields</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"sha256\"</span><span class=\"p\">]</span>\n\n<span class=\"n\">apps</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">search_apps_with_query</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span> <span class=\"c1\"># No actual connection to Tacyt done here.</span>\n\n<span class=\"k\">for</span> <span class=\"n\">app</span> <span class=\"ow\">in</span> <span class=\"n\">apps</span><span class=\"p\">:</span> <span class=\"c1\"># Now the generator starts yielding and therefore connecting to Tacyt.</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"query-language-abstraction\">\n<h3>Query language abstraction</h3>\n<p>The queries are send as a string to Tacyt, this means that the queries\nmust be managed as strings, which sometimes can get messy. Taza has an\nOO abstraction that allows to write queries in Python.</p>\n<p>First, each predicate can he specified with the <tt>cond</tt> class. There\nare shorthands for common predicates (at least common to me).</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">taza.query</span> <span class=\"kn\">import</span> <span class=\"n\">cond</span><span class=\"p\">,</span> <span class=\"n\">packageName</span><span class=\"p\">,</span> <span class=\"n\">fromGooglePlay</span>\n\n<span class=\"n\">q1</span> <span class=\"o\">=</span> <span class=\"n\">cond</span><span class=\"p\">(</span><span class=\"s1\">'packageName'</span><span class=\"p\">,</span> <span class=\"s1\">'com.company.awesome_app'</span><span class=\"p\">)</span>\n<span class=\"n\">q2</span> <span class=\"o\">=</span> <span class=\"n\">packageName</span><span class=\"p\">(</span><span class=\"s1\">'com.company.awesome_app'</span><span class=\"p\">)</span>\n\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">q1</span><span class=\"p\">)</span> <span class=\"c1\"># =&gt; \"packageName:com.company.awesome_app\"</span>\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">q2</span><span class=\"p\">)</span> <span class=\"c1\"># =&gt; \"packageName:com.company.awesome_app\"</span>\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">fromGooglePlay</span><span class=\"p\">)</span> <span class=\"o\">=&gt;</span> <span class=\"s2\">\"origin:GooglePlay\"</span>\n\n<span class=\"k\">assert</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">q1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">q2</span><span class=\"p\">)</span>\n</pre>\n<p>The predicates can be combined with AND, OR and NOT operators.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">taza.query</span> <span class=\"kn\">import</span> <span class=\"n\">cond</span><span class=\"p\">,</span> <span class=\"n\">packageName</span><span class=\"p\">,</span> <span class=\"n\">fromGooglePlay</span>\n\n<span class=\"n\">q1</span> <span class=\"o\">=</span> <span class=\"n\">cond</span><span class=\"p\">(</span><span class=\"s1\">'packageName'</span><span class=\"p\">,</span> <span class=\"s1\">'com.company.awesome_app'</span><span class=\"p\">)</span>\n<span class=\"n\">q2</span> <span class=\"o\">=</span> <span class=\"n\">packageName</span><span class=\"p\">(</span><span class=\"s1\">'com.company.awesome_app'</span><span class=\"p\">)</span>\n\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">q1</span> <span class=\"o\">&amp;</span> <span class=\"n\">fromGooglePlay</span><span class=\"p\">)</span> <span class=\"c1\"># =&gt; \"packageName:com.company.awesome_app AND origin:GooglePlay\"</span>\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">q2</span> <span class=\"o\">|</span> <span class=\"o\">-</span><span class=\"n\">fromGooglePlay</span><span class=\"p\">)</span> <span class=\"c1\"># =&gt; \"packageName:com.company.awesome_app OR -origin:GooglePlay\"</span>\n</pre>\n<p>Bear in mind that Tacyt only allows up to 40 predicates per query.</p>\n<p>If you need to agreggate several predicates under the same operator, you\ncan use the <tt>or_many</tt> and <tt>and_many</tt> functions. They are usefull if\nyou need to define the query programatically under a set of elements.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">taza.query</span> <span class=\"kn\">import</span> <span class=\"n\">cond</span><span class=\"p\">,</span> <span class=\"n\">packageName</span><span class=\"p\">,</span> <span class=\"n\">fromGooglePlay</span>\n\n<span class=\"n\">q1</span> <span class=\"o\">=</span> <span class=\"n\">packageName</span><span class=\"p\">(</span><span class=\"s2\">\"app1\"</span><span class=\"p\">)</span>\n<span class=\"n\">q2</span> <span class=\"o\">=</span> <span class=\"n\">packageName</span><span class=\"p\">(</span><span class=\"s2\">\"app2\"</span><span class=\"p\">)</span>\n<span class=\"n\">q3</span> <span class=\"o\">=</span> <span class=\"n\">packageName</span><span class=\"p\">(</span><span class=\"s2\">\"app3\"</span><span class=\"p\">)</span>\n\n<span class=\"k\">assert</span> <span class=\"n\">or_many</span><span class=\"p\">(</span><span class=\"n\">q1</span><span class=\"p\">,</span> <span class=\"n\">q2</span><span class=\"p\">,</span> <span class=\"n\">q3</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"n\">q1</span> <span class=\"o\">|</span> <span class=\"n\">q2</span> <span class=\"o\">|</span> <span class=\"n\">q3</span><span class=\"p\">)</span>\n\n<span class=\"n\">qs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">fromGooglePlay</span><span class=\"p\">,</span> <span class=\"n\">cond</span><span class=\"p\">(</span><span class=\"s1\">'versionCode'</span><span class=\"p\">,</span> <span class=\"s1\">'42'</span><span class=\"p\">),</span> <span class=\"n\">packageName</span><span class=\"p\">(</span><span class=\"s1\">'my.another.app'</span><span class=\"p\">)]</span>\n<span class=\"k\">assert</span> <span class=\"n\">and_many</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">qs</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"n\">fromGooglePlay</span> <span class=\"o\">&amp;</span> <span class=\"n\">cond</span><span class=\"p\">(</span><span class=\"s1\">'versionCode'</span><span class=\"p\">,</span> <span class=\"s1\">'42'</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">packageName</span><span class=\"p\">(</span><span class=\"s1\">'my.another.app'</span><span class=\"p\">))</span>\n</pre>\n<p>These queries are sent to the <tt>search_apps_with_query</tt> method in the\nsame way that string based queries are sent. The whatsapp example could\nbe rewritten as such.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">taza</span> <span class=\"kn\">import</span> <span class=\"n\">TazaClient</span>\n<span class=\"kn\">from</span> <span class=\"nn\">taza.query</span> <span class=\"kn\">import</span> <span class=\"n\">packageName</span><span class=\"p\">,</span> <span class=\"n\">fromGooglePlay</span>\n\n<span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">TazaClient</span><span class=\"o\">.</span><span class=\"n\">from_credentials</span><span class=\"p\">(</span><span class=\"n\">APP_ID</span><span class=\"p\">,</span> <span class=\"n\">SECRET_KEY</span><span class=\"p\">)</span>\n\n<span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"n\">packageName</span><span class=\"p\">(</span><span class=\"s1\">'com.whatsapp'</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">fromGooglePlay</span>\n<span class=\"n\">fields</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"sha256\"</span><span class=\"p\">]</span>\n\n<span class=\"n\">apps</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">search_apps_with_query</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">)</span> <span class=\"c1\"># No actual connection to Tacyt done here.</span>\n\n<span class=\"k\">for</span> <span class=\"n\">app</span> <span class=\"ow\">in</span> <span class=\"n\">apps</span><span class=\"p\">:</span> <span class=\"c1\"># Now the generator starts yielding and therefore connecting to Tacyt.</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6533273, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "4d3dd01b8b2b069cc46b88c876e09b19", "sha256": "8ff4d73258023c8edabdb1b79670e991865bb455dec0855c436a5442898f3ded"}, "downloads": -1, "filename": "taza-1.0.0.tar.gz", "has_sig": false, "md5_digest": "4d3dd01b8b2b069cc46b88c876e09b19", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14593, "upload_time": "2019-02-06T09:59:03", "upload_time_iso_8601": "2019-02-06T09:59:03.138514Z", "url": "https://files.pythonhosted.org/packages/21/f5/01e7c2696aa1a0d34dca9f52c076445a09373646678ae8cab46ced02ee46/taza-1.0.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "5b5794ac0d7de4cbd4443d07532c4cda", "sha256": "90fd47787369bb6d432cbaf5226207e804101e656abc484fadfe9c14c9db604e"}, "downloads": -1, "filename": "taza-1.1.1.macosx-10.14-x86_64.tar.gz", "has_sig": false, "md5_digest": "5b5794ac0d7de4cbd4443d07532c4cda", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27018, "upload_time": "2019-06-10T15:48:04", "upload_time_iso_8601": "2019-06-10T15:48:04.954549Z", "url": "https://files.pythonhosted.org/packages/f4/69/93927d329165a093b10c0caa7ec509c6fd1371d53a9e1a3791d6f1061585/taza-1.1.1.macosx-10.14-x86_64.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "9438e1d09019c51b34e7586dd2a8ed6e", "sha256": "efda48d6e38e7e12f498d292bcf35fc9717ba394fc5de620f33ce7852b00f5d9"}, "downloads": -1, "filename": "taza-1.2.1.tar.gz", "has_sig": false, "md5_digest": "9438e1d09019c51b34e7586dd2a8ed6e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15206, "upload_time": "2020-01-09T14:24:36", "upload_time_iso_8601": "2020-01-09T14:24:36.606779Z", "url": "https://files.pythonhosted.org/packages/25/03/1bd1432f3b2ff0afb92ae628dece6374c9eadc304e4e99b2acbd1f837238/taza-1.2.1.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "ce3666dc288044b02e41987bf9476b34", "sha256": "22abae5241b4420f9836aea40dece4d7669b4aa24b71a663597970029c4fc87a"}, "downloads": -1, "filename": "taza-2.0.0.tar.gz", "has_sig": false, "md5_digest": "ce3666dc288044b02e41987bf9476b34", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15422, "upload_time": "2020-01-28T16:38:07", "upload_time_iso_8601": "2020-01-28T16:38:07.571873Z", "url": "https://files.pythonhosted.org/packages/a3/e9/de8f4c6c349be6cbda53c9e1551eda45f85259484010211052c76d9ce794/taza-2.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ce3666dc288044b02e41987bf9476b34", "sha256": "22abae5241b4420f9836aea40dece4d7669b4aa24b71a663597970029c4fc87a"}, "downloads": -1, "filename": "taza-2.0.0.tar.gz", "has_sig": false, "md5_digest": "ce3666dc288044b02e41987bf9476b34", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15422, "upload_time": "2020-01-28T16:38:07", "upload_time_iso_8601": "2020-01-28T16:38:07.571873Z", "url": "https://files.pythonhosted.org/packages/a3/e9/de8f4c6c349be6cbda53c9e1551eda45f85259484010211052c76d9ce794/taza-2.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:57:35 2020"}