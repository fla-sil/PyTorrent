{"info": {"author": "Zoltan Nagy, Zsolt Dollenstein", "author_email": "zoltan.nagy@prezi.com, zsolt.dollenstein@prezi.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Web Environment", "Framework :: Django", "Intended Audience :: Developers", "License :: Freely Distributable", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Topic :: Software Development :: Libraries :: Application Frameworks", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "django-zipkin\n=============\n\n|Build Status|\n\n*django-zipkin* is a middleware and api for recording and sending\nmessages to `Zipkin <http://twitter.github.io/zipkin/>`_. Why use it?\nFrom the http://twitter.github.io/zipkin/:\n\n\"Collecting traces helps developers gain deeper knowledge about how\ncertain requests perform in a distributed system. Let's say we're having\nproblems with user requests timing out. We can look up traced requests\nthat timed out and display it in the web UI. We'll be able to quickly\nfind the service responsible for adding the unexpected response time. If\nthe service has been annotated adequately we can also find out where in\nthat service the issue is happening.\"\n\nSupported versions\n------------------\n\n**Python**: ``2.6``, ``2.7`` (the current Python Thrift release doesn't\nsupport Python 3)\n\n**Django**: ``1.3`` - ``1.7``\n\n\nGetting started\n---------------\n\nInstall the library:\n\n::\n\n    pip install django-zipkin\n\nAdd the middleware to the list of installed middlewares:\n\n.. code:: python\n\n    MIDDLEWARE_CLASSES = ('...',\n                          'django_zipkin.middleware.ZipkinMiddleware',\n                          '...')\n\nSet the name your service will use to identify itself. This will appear\nas the service name in Zipkin.\n\n.. code:: python\n\n    ZIPKIN_SERVICE_NAME = 'awesome-service'\n\n``django-zipkin`` is now logging data compatible with the Zipkin\ncollector to the logger called ``zipkin``.\n\nGetting the data to Zipkin\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFrom here you it's up to you to get the messages to Zipkin. Here's how\nwe do it at `Prezi <https://prezi.com>`_:\n\n-  We configure logging in each service using ``django-zipkin`` to send\n   log messages from the ``zipkin`` logger to the locally running Scribe\n   instance, into the category ``zipkin``.\n-  The Scribe instances are configured to forward the ``zipkin``\n   category directly to the Zipkin collector. This is useful because\n   Scribe buffers messages in case the collector (or the network to it)\n   is down.\n\nAnother alternative may be logging to syslog, and using\n``scribe_apache`` shipped with Scribe to send data to Zipkin (possibly\nvia a local Scribe server).\n\nRecording annotations\n~~~~~~~~~~~~~~~~~~~~~\n\n``django-zipkin`` creates a single span per served requests. It\nautomatically adds a number of annotations (see below). You can also add\nyour own annotations from anywhere in your code:\n\n.. code:: python\n\n    from django_zipkin.api import api as zipkin_api\n\n    zipkin_api.record_event('MySQL: \"SELECT * FROM auth_users\"', duration=15000)  # Note duration is in microseconds, as defined by Zipkin\n    zipkin_api.record_key_value('Cache misses', 15)  # You can use string, int, long and bool values\n\nPropagating tracing information\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTo identify which spans belong to the same trace, some information must\nbe passed on with inter-service calls. ``django-zipkin`` provides\nfacilities for this on both the client and the server side. The\nmiddleware automatically reads the trace propagation HTTP headers\ndescribed `in the Zipkin\ndocumentation <https://github.com/twitter/zipkin/blob/master/doc/collector-api.md#traceid-propagation>`_.\nFor propagating data to outgoing requests, a function returning a dict\nof the correct HTTP headers is provided:\n\n.. code:: python\n\n    from django_zipkin.api import api as zipkin_api\n    headers = zipkin_api.get_headers_for_downstream_request()\n\n    # During a request returns something like this:\n    {'X-B3-Sampled': 'false', 'X-B3-TraceId': 'b059fb34103a46f7', 'X-B3-Flags': '0', 'X-B3-SpanId': 'a42f4f3a045c54a5'}\n\nAutomatically generated annotations\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n``sr`` and ``ss`` annotations are automatically added by the middleware.\nThe following binary (key-value) annotations are also added:\n\n+----------------------------------+--------------------------+-----------------------------------------------------------------------------------------------------+\n| Annotation                       | Example value            | Added if                                                                                            |\n+==================================+==========================+=====================================================================================================+\n| http.uri                         | ``/api/v1/login``        | Always                                                                                              |\n+----------------------------------+--------------------------+-----------------------------------------------------------------------------------------------------+\n| http.statuscode                  | ``200``                  | Always                                                                                              |\n+----------------------------------+--------------------------+-----------------------------------------------------------------------------------------------------+\n| django.view.func\\_name           | ``login``                | Always                                                                                              |\n+----------------------------------+--------------------------+-----------------------------------------------------------------------------------------------------+\n| django.view.class                | ``AuthView``             | If the view function is the method of a view-based class                                            |\n+----------------------------------+--------------------------+-----------------------------------------------------------------------------------------------------+\n| django.view.args                 | ``('oauth')``            | Always                                                                                              |\n+----------------------------------+--------------------------+-----------------------------------------------------------------------------------------------------+\n| django.view.kwargs               | ``{\"next\": \"/index\"}``   | Always                                                                                              |\n+----------------------------------+--------------------------+-----------------------------------------------------------------------------------------------------+\n| django.url\\_name                 | ``myapp.views.login``    | Always                                                                                              |\n+----------------------------------+--------------------------+-----------------------------------------------------------------------------------------------------+\n| django.tastypie.resource\\_name   | ``user``                 | If the request is served by Tastypie (specifically, when the view gets a kwarg ``resource_name``)   |\n+----------------------------------+--------------------------+-----------------------------------------------------------------------------------------------------+\n\nIt's up to you to add ``cs`` and ``cr`` (client send and client receive)\nannotations in whatever client you use.\n\nThings to keep in mind\n----------------------\n\nMiddleware order\n~~~~~~~~~~~~~~~~\n\nIf a middleware above ``django-zipkin`` returns a response, then the\nrequest processing part of ``django-zipkin`` will never be called,\nresulting in an inconsistent internal state. In this case your custom\nannotations and most of the automatically added annotations will be\nlost, and timing information will be incorrect. An extra annotation will\nbe added with the following\nvalue:\\ ``No ZipkinData in thread local store. This can happen if process_request didn't run due to a previous middleware returning a response. Timing information is invalid.``\n\nView wrappers\n~~~~~~~~~~~~~\n\nIf your view is wrapped (for example with a decorator) without using the\n``functools.wraps`` decorator, then ``django-zipkin`` has no way of\nretrieving the name of the view. In this case ``django.view.func_name``\nwill be the function name of the wrapper function. This is something\nyou'll want to avoid in your own code.\n\nOne offender is Tastypie: ``django.view.func_name`` will always be\n``wrapper``. On requests served by Tastypie the annotation\n``django.tastypie.resource_name`` will be added with the name of the\nTastypie resource, and ``django.url_name`` will be something useful like\n``api_dispatch_list``.\n\nZipkin UI vs. JSON annotation values\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``django.view.kwargs`` annotation has a JSON string as its value for\neasier automated processing. Unfortunately this make the UI display the\nvalue as ``[object Object]``. See `Zipkin issue\n#410 <https://github.com/twitter/zipkin/issues/410>`_ for any progress\non this. If you want to find the value on the web UI, you can open the\npage source and search for ``django.view.kwargs``.\n\nCustomizing\n-----------\n\nYou can customize the way ``django-zipkin`` works with the following\nsettings values. They are defined in ``django_zipkin/defaults.py``.\n\nSettings variables\n~~~~~~~~~~~~~~~~~~\n\n**ZIPKIN\\_SERVICE\\_NAME**: Default ``None``. The service name that will\nappear on Zipkin (the ``service_name`` value in the sent Thrift\nobjects).\n\n**ZIPKIN\\_LOGGER\\_NAME**: Default ``'zipkin'``. The name of the logger\nto use when sending Zipkin messages through the Python logging system.\n\n**ZIPKIN\\_DATA\\_STORE\\_CLASS**: Default\n``'django_zipkin.data_store.ThreadLocalDataStore'``. ``django-zipkin``\nneeds to pass some data from the request processor to the response\nprocessor. This same data needs to be accessible from anywhere in the\nusers code. The default implementation for this is to use thread-local\nstorage. ``gevent`` and ``greenlet`` monkey-patch it, so this\nimplementation works fine even under ``gunicorn`` and friends. You can\nprovide your own implementation - it needs to implement the methods of\n``django_zipkin.data_store.BaseDataStore``.\n\n**ZIPKIN\\_ID\\_GENERATOR\\_CLASS**: Default\n``'django_zipkin.id_generator.SimpleIdGenerator'``. The class used to\ngenerate span and trace ids if we don't get one from the incoming\nrequest.\n\nConfigglue\n~~~~~~~~~~\n\n``configglue`` support is provided via ``django_zipkin.schema``; you can\ninclude it into your own schema like this:\n\n.. code:: python\n\n    from django_zipkin.schema import DjangoZipkinSection\n\n\n    class MySchema(...):\n       ...\n       class zipkin(DjangoZipkinSection):\n           pass\n\nHacking\n-------\n\nSee\n`CONTRIBUTING.md <https://github.com/prezi/django-zipkin/blob/master/CONTRIBUTING.md>`_\nfor guidelines.\n\nYou can start hacking on ``django-zipkin`` with:\n\n.. code:: sh\n\n    git clone https://github.com/prezi/django-zipkin.git\n    cd django-zipkin\n    git remote rename origin upstream\n    virtualenv virtualenv\n    . virtualenv/bin/activate\n    pip install django\n    python setup.py test\n\n.. |Build Status| image:: https://travis-ci.org/prezi/django-zipkin.svg?branch=master\n   :target: https://travis-ci.org/prezi/django-zipkin\n", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/prezi/django-zipkin", "keywords": "django zipkin middleware", "license": "WTFPL License", "maintainer": null, "maintainer_email": null, "name": "django-zipkin", "package_url": "https://pypi.org/project/django-zipkin/", "platform": "any", "project_url": "https://pypi.org/project/django-zipkin/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/prezi/django-zipkin"}, "release_url": "https://pypi.org/project/django-zipkin/0.0.3/", "requires_dist": null, "requires_python": null, "summary": "django-zipkin is a Django middleware and api for recording and sending messages to Zipkin", "version": "0.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://travis-ci.org/prezi/django-zipkin\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/911805722fa2d143bbe4000f3ed8a3af77d9af16/68747470733a2f2f7472617669732d63692e6f72672f7072657a692f646a616e676f2d7a69706b696e2e7376673f6272616e63683d6d6173746572\"></a></p>\n<p><em>django-zipkin</em> is a middleware and api for recording and sending\nmessages to <a href=\"http://twitter.github.io/zipkin/\" rel=\"nofollow\">Zipkin</a>. Why use it?\nFrom the <a href=\"http://twitter.github.io/zipkin/\" rel=\"nofollow\">http://twitter.github.io/zipkin/</a>:</p>\n<p>\u201cCollecting traces helps developers gain deeper knowledge about how\ncertain requests perform in a distributed system. Let\u2019s say we\u2019re having\nproblems with user requests timing out. We can look up traced requests\nthat timed out and display it in the web UI. We\u2019ll be able to quickly\nfind the service responsible for adding the unexpected response time. If\nthe service has been annotated adequately we can also find out where in\nthat service the issue is happening.\u201d</p>\n<div id=\"supported-versions\">\n<h2>Supported versions</h2>\n<p><strong>Python</strong>: <tt>2.6</tt>, <tt>2.7</tt> (the current Python Thrift release doesn\u2019t\nsupport Python 3)</p>\n<p><strong>Django</strong>: <tt>1.3</tt> - <tt>1.7</tt></p>\n</div>\n<div id=\"getting-started\">\n<h2>Getting started</h2>\n<p>Install the library:</p>\n<pre>pip install django-zipkin\n</pre>\n<p>Add the middleware to the list of installed middlewares:</p>\n<pre><span class=\"n\">MIDDLEWARE_CLASSES</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'...'</span><span class=\"p\">,</span>\n                      <span class=\"s1\">'django_zipkin.middleware.ZipkinMiddleware'</span><span class=\"p\">,</span>\n                      <span class=\"s1\">'...'</span><span class=\"p\">)</span>\n</pre>\n<p>Set the name your service will use to identify itself. This will appear\nas the service name in Zipkin.</p>\n<pre><span class=\"n\">ZIPKIN_SERVICE_NAME</span> <span class=\"o\">=</span> <span class=\"s1\">'awesome-service'</span>\n</pre>\n<p><tt><span class=\"pre\">django-zipkin</span></tt> is now logging data compatible with the Zipkin\ncollector to the logger called <tt>zipkin</tt>.</p>\n<div id=\"getting-the-data-to-zipkin\">\n<h3>Getting the data to Zipkin</h3>\n<p>From here you it\u2019s up to you to get the messages to Zipkin. Here\u2019s how\nwe do it at <a href=\"https://prezi.com\" rel=\"nofollow\">Prezi</a>:</p>\n<ul>\n<li>We configure logging in each service using <tt><span class=\"pre\">django-zipkin</span></tt> to send\nlog messages from the <tt>zipkin</tt> logger to the locally running Scribe\ninstance, into the category <tt>zipkin</tt>.</li>\n<li>The Scribe instances are configured to forward the <tt>zipkin</tt>\ncategory directly to the Zipkin collector. This is useful because\nScribe buffers messages in case the collector (or the network to it)\nis down.</li>\n</ul>\n<p>Another alternative may be logging to syslog, and using\n<tt>scribe_apache</tt> shipped with Scribe to send data to Zipkin (possibly\nvia a local Scribe server).</p>\n</div>\n<div id=\"recording-annotations\">\n<h3>Recording annotations</h3>\n<p><tt><span class=\"pre\">django-zipkin</span></tt> creates a single span per served requests. It\nautomatically adds a number of annotations (see below). You can also add\nyour own annotations from anywhere in your code:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">django_zipkin.api</span> <span class=\"kn\">import</span> <span class=\"n\">api</span> <span class=\"k\">as</span> <span class=\"n\">zipkin_api</span>\n\n<span class=\"n\">zipkin_api</span><span class=\"o\">.</span><span class=\"n\">record_event</span><span class=\"p\">(</span><span class=\"s1\">'MySQL: \"SELECT * FROM auth_users\"'</span><span class=\"p\">,</span> <span class=\"n\">duration</span><span class=\"o\">=</span><span class=\"mi\">15000</span><span class=\"p\">)</span>  <span class=\"c1\"># Note duration is in microseconds, as defined by Zipkin</span>\n<span class=\"n\">zipkin_api</span><span class=\"o\">.</span><span class=\"n\">record_key_value</span><span class=\"p\">(</span><span class=\"s1\">'Cache misses'</span><span class=\"p\">,</span> <span class=\"mi\">15</span><span class=\"p\">)</span>  <span class=\"c1\"># You can use string, int, long and bool values</span>\n</pre>\n</div>\n<div id=\"propagating-tracing-information\">\n<h3>Propagating tracing information</h3>\n<p>To identify which spans belong to the same trace, some information must\nbe passed on with inter-service calls. <tt><span class=\"pre\">django-zipkin</span></tt> provides\nfacilities for this on both the client and the server side. The\nmiddleware automatically reads the trace propagation HTTP headers\ndescribed <a href=\"https://github.com/twitter/zipkin/blob/master/doc/collector-api.md#traceid-propagation\" rel=\"nofollow\">in the Zipkin\ndocumentation</a>.\nFor propagating data to outgoing requests, a function returning a dict\nof the correct HTTP headers is provided:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">django_zipkin.api</span> <span class=\"kn\">import</span> <span class=\"n\">api</span> <span class=\"k\">as</span> <span class=\"n\">zipkin_api</span>\n<span class=\"n\">headers</span> <span class=\"o\">=</span> <span class=\"n\">zipkin_api</span><span class=\"o\">.</span><span class=\"n\">get_headers_for_downstream_request</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># During a request returns something like this:</span>\n<span class=\"p\">{</span><span class=\"s1\">'X-B3-Sampled'</span><span class=\"p\">:</span> <span class=\"s1\">'false'</span><span class=\"p\">,</span> <span class=\"s1\">'X-B3-TraceId'</span><span class=\"p\">:</span> <span class=\"s1\">'b059fb34103a46f7'</span><span class=\"p\">,</span> <span class=\"s1\">'X-B3-Flags'</span><span class=\"p\">:</span> <span class=\"s1\">'0'</span><span class=\"p\">,</span> <span class=\"s1\">'X-B3-SpanId'</span><span class=\"p\">:</span> <span class=\"s1\">'a42f4f3a045c54a5'</span><span class=\"p\">}</span>\n</pre>\n</div>\n<div id=\"automatically-generated-annotations\">\n<h3>Automatically generated annotations</h3>\n<p><tt>sr</tt> and <tt>ss</tt> annotations are automatically added by the middleware.\nThe following binary (key-value) annotations are also added:</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Annotation</th>\n<th>Example value</th>\n<th>Added if</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>http.uri</td>\n<td><tt>/api/v1/login</tt></td>\n<td>Always</td>\n</tr>\n<tr><td>http.statuscode</td>\n<td><tt>200</tt></td>\n<td>Always</td>\n</tr>\n<tr><td>django.view.func_name</td>\n<td><tt>login</tt></td>\n<td>Always</td>\n</tr>\n<tr><td>django.view.class</td>\n<td><tt>AuthView</tt></td>\n<td>If the view function is the method of a view-based class</td>\n</tr>\n<tr><td>django.view.args</td>\n<td><tt>('oauth')</tt></td>\n<td>Always</td>\n</tr>\n<tr><td>django.view.kwargs</td>\n<td><tt>{\"next\": \"/index\"}</tt></td>\n<td>Always</td>\n</tr>\n<tr><td>django.url_name</td>\n<td><tt>myapp.views.login</tt></td>\n<td>Always</td>\n</tr>\n<tr><td>django.tastypie.resource_name</td>\n<td><tt>user</tt></td>\n<td>If the request is served by Tastypie (specifically, when the view gets a kwarg <tt>resource_name</tt>)</td>\n</tr>\n</tbody>\n</table>\n<p>It\u2019s up to you to add <tt>cs</tt> and <tt>cr</tt> (client send and client receive)\nannotations in whatever client you use.</p>\n</div>\n</div>\n<div id=\"things-to-keep-in-mind\">\n<h2>Things to keep in mind</h2>\n<div id=\"middleware-order\">\n<h3>Middleware order</h3>\n<p>If a middleware above <tt><span class=\"pre\">django-zipkin</span></tt> returns a response, then the\nrequest processing part of <tt><span class=\"pre\">django-zipkin</span></tt> will never be called,\nresulting in an inconsistent internal state. In this case your custom\nannotations and most of the automatically added annotations will be\nlost, and timing information will be incorrect. An extra annotation will\nbe added with the following\nvalue:<tt>No ZipkinData in thread local store. This can happen if process_request didn't run due to a previous middleware returning a response. Timing information is invalid.</tt></p>\n</div>\n<div id=\"view-wrappers\">\n<h3>View wrappers</h3>\n<p>If your view is wrapped (for example with a decorator) without using the\n<tt>functools.wraps</tt> decorator, then <tt><span class=\"pre\">django-zipkin</span></tt> has no way of\nretrieving the name of the view. In this case <tt>django.view.func_name</tt>\nwill be the function name of the wrapper function. This is something\nyou\u2019ll want to avoid in your own code.</p>\n<p>One offender is Tastypie: <tt>django.view.func_name</tt> will always be\n<tt>wrapper</tt>. On requests served by Tastypie the annotation\n<tt>django.tastypie.resource_name</tt> will be added with the name of the\nTastypie resource, and <tt>django.url_name</tt> will be something useful like\n<tt>api_dispatch_list</tt>.</p>\n</div>\n<div id=\"zipkin-ui-vs-json-annotation-values\">\n<h3>Zipkin UI vs. JSON annotation values</h3>\n<p>The <tt>django.view.kwargs</tt> annotation has a JSON string as its value for\neasier automated processing. Unfortunately this make the UI display the\nvalue as <tt>[object Object]</tt>. See <a href=\"https://github.com/twitter/zipkin/issues/410\" rel=\"nofollow\">Zipkin issue\n#410</a> for any progress\non this. If you want to find the value on the web UI, you can open the\npage source and search for <tt>django.view.kwargs</tt>.</p>\n</div>\n</div>\n<div id=\"customizing\">\n<h2>Customizing</h2>\n<p>You can customize the way <tt><span class=\"pre\">django-zipkin</span></tt> works with the following\nsettings values. They are defined in <tt>django_zipkin/defaults.py</tt>.</p>\n<div id=\"settings-variables\">\n<h3>Settings variables</h3>\n<p><strong>ZIPKIN_SERVICE_NAME</strong>: Default <tt>None</tt>. The service name that will\nappear on Zipkin (the <tt>service_name</tt> value in the sent Thrift\nobjects).</p>\n<p><strong>ZIPKIN_LOGGER_NAME</strong>: Default <tt>'zipkin'</tt>. The name of the logger\nto use when sending Zipkin messages through the Python logging system.</p>\n<p><strong>ZIPKIN_DATA_STORE_CLASS</strong>: Default\n<tt>'django_zipkin.data_store.ThreadLocalDataStore'</tt>. <tt><span class=\"pre\">django-zipkin</span></tt>\nneeds to pass some data from the request processor to the response\nprocessor. This same data needs to be accessible from anywhere in the\nusers code. The default implementation for this is to use thread-local\nstorage. <tt>gevent</tt> and <tt>greenlet</tt> monkey-patch it, so this\nimplementation works fine even under <tt>gunicorn</tt> and friends. You can\nprovide your own implementation - it needs to implement the methods of\n<tt>django_zipkin.data_store.BaseDataStore</tt>.</p>\n<p><strong>ZIPKIN_ID_GENERATOR_CLASS</strong>: Default\n<tt>'django_zipkin.id_generator.SimpleIdGenerator'</tt>. The class used to\ngenerate span and trace ids if we don\u2019t get one from the incoming\nrequest.</p>\n</div>\n<div id=\"configglue\">\n<h3>Configglue</h3>\n<p><tt>configglue</tt> support is provided via <tt>django_zipkin.schema</tt>; you can\ninclude it into your own schema like this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">django_zipkin.schema</span> <span class=\"kn\">import</span> <span class=\"n\">DjangoZipkinSection</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MySchema</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">):</span>\n   <span class=\"o\">...</span>\n   <span class=\"k\">class</span> <span class=\"nc\">zipkin</span><span class=\"p\">(</span><span class=\"n\">DjangoZipkinSection</span><span class=\"p\">):</span>\n       <span class=\"k\">pass</span>\n</pre>\n</div>\n</div>\n<div id=\"hacking\">\n<h2>Hacking</h2>\n<p>See\n<a href=\"https://github.com/prezi/django-zipkin/blob/master/CONTRIBUTING.md\" rel=\"nofollow\">CONTRIBUTING.md</a>\nfor guidelines.</p>\n<p>You can start hacking on <tt><span class=\"pre\">django-zipkin</span></tt> with:</p>\n<pre>git clone https://github.com/prezi/django-zipkin.git\n<span class=\"nb\">cd</span> django-zipkin\ngit remote rename origin upstream\nvirtualenv virtualenv\n. virtualenv/bin/activate\npip install django\npython setup.py <span class=\"nb\">test</span>\n</pre>\n</div>\n\n          </div>"}, "last_serial": 1624438, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "aaf18dec62ab4641262d94da71323c02", "sha256": "e0d2360542ccfea1a5f2cfc73bbe19bfbf2a32bdff5d0bc40842b696a8b53a04"}, "downloads": -1, "filename": "django-zipkin-0.0.1.tar.gz", "has_sig": false, "md5_digest": "aaf18dec62ab4641262d94da71323c02", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9732, "upload_time": "2014-09-15T10:11:52", "upload_time_iso_8601": "2014-09-15T10:11:52.609543Z", "url": "https://files.pythonhosted.org/packages/6d/13/ecc309173b729475a5935760ee5e5d549da15934c84d032787274397372c/django-zipkin-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "d245f814a1d68eff2d0ff1910d09ca6c", "sha256": "d9ed65f1c6377bddb46f775be156431c79e86ef29e736a1ebf6ddfd5aad6526d"}, "downloads": -1, "filename": "django-zipkin-0.0.2.tar.gz", "has_sig": false, "md5_digest": "d245f814a1d68eff2d0ff1910d09ca6c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29829, "upload_time": "2015-03-04T15:21:34", "upload_time_iso_8601": "2015-03-04T15:21:34.876928Z", "url": "https://files.pythonhosted.org/packages/ec/91/8d892444af29a8cef5daca809ea0919abe013c05fc2f42b461a8fa097a8e/django-zipkin-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "20bc6b085456f453ee23c251d9bb481b", "sha256": "3c60f64558df2f9f27c368d550c369f6a32632fd8dadda49c4491c3f60437007"}, "downloads": -1, "filename": "django-zipkin-0.0.3.tar.gz", "has_sig": false, "md5_digest": "20bc6b085456f453ee23c251d9bb481b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30818, "upload_time": "2015-07-08T13:52:01", "upload_time_iso_8601": "2015-07-08T13:52:01.792312Z", "url": "https://files.pythonhosted.org/packages/65/2e/8e7f5c439a96ee00ca3c8583cc40ec466727d46139282c812c0d161111e5/django-zipkin-0.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "20bc6b085456f453ee23c251d9bb481b", "sha256": "3c60f64558df2f9f27c368d550c369f6a32632fd8dadda49c4491c3f60437007"}, "downloads": -1, "filename": "django-zipkin-0.0.3.tar.gz", "has_sig": false, "md5_digest": "20bc6b085456f453ee23c251d9bb481b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30818, "upload_time": "2015-07-08T13:52:01", "upload_time_iso_8601": "2015-07-08T13:52:01.792312Z", "url": "https://files.pythonhosted.org/packages/65/2e/8e7f5c439a96ee00ca3c8583cc40ec466727d46139282c812c0d161111e5/django-zipkin-0.0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:43 2020"}