{"info": {"author": "Hans Musgrave", "author_email": "Hans.Musgrave@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: GNU Affero General Public License v3", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# square-fuffle\n**Alpha Stage -- API will change**. Quickly solves differentiable multi-objective optimization problems.\n\n# Installation\nComing soon.\n\n# Purpose\n**Multi-objective solvers** exist to help *find compromises* in the presence of multiple competing goals -- for example, maximizing profits while also maximizing customer satisfaction. These two goals are usually at odds to some extent (what customer wouldn't be happier if a business dropped its prices down to its break-even point?), and an MO solver allows you to consciously weigh the tradeoffs in different solutions.\n\n**square-fuffle** is one of many techniques for solving MO problems. As a rule of thumb, you would choose square-fuffle over other solutions when the *objectives are differentiable* and when the *problem is sufficiently complicated*. High-dimensional input spaces are especially problematic for evolutionary MO solvers if any kind of precision is required, but they are straightforward for square-fuffle.\n\n# Examples\nWhen trying to minimize two parabaloids, one situated on the origin and one at the all ones point, the only points that are locally non-dominated are those where `y=x` and which are directly between the two parabolic minima. Our `create_single_objective` function has a group of minima precisely in that location.\n```python\n\"\"\"\nPlots our two objectives with inputs in the unit square and colors them\naccording to the output of create_single_objective().\n\"\"\"\n\nfrom sqfuffle.objectives import create_single_objective\nimport jax.numpy as np\nfrom jax import jit\nimport matplotlib.pyplot as plt\n\ndef f(x):\n    return np.array([np.sum(x**2), np.sum((x-1)**2)])\n\npoints = [np.array([a, b]) for a in np.linspace(0, 1, 30) for b in np.linspace(0, 1, 30)]\nx, y, c = (list(map(h, points)) for h in (lambda p: f(p)[0], lambda p: f(p)[1], jit(create_single_objective(f))))\n\nplt.scatter(x, y, c=c)\nplt.xlabel('$x^2 + y^2$')\nplt.ylabel('$(x-1)^2 + (y-1)^2$')\nplt.title('Pareto Front')\nplt.xticks([])\nplt.yticks([])\nplt.axis('scaled')\nplt.show()\n```\n\n![Pareto Front](examples/paraboloid_front.png)\n\n# Caveats\n1. square-fuffle depends on jax for its differentiation, and that is exposed to the end user in that if they supply a function jax does not understand then **square-fuffle** will throw a number of exceptions. This isn't fundamentally necessary, and in a future iteration we will probably use jax internally and expose the *ability* for users to supply differentiable functions, but we will also expose hooks where vjp, jvp, or hessians can be provided directly (raw jacobians won't suffice without numerical approximation shenanigans).\n1. square-fuffle does NOT only return points from the Pareto front. In practice, high-precision points from the Pareto front along with points from some kinds of other interesting manifolds in the context of an MO problem are returned, and square-fuffle's results should be followed with a non-dominated filter. We might provide one in future API versions.\n\n# Theory\nTLDR; The main idea is that being locally non-dominated is a constraint on the directional gradients, and since all of those can be represented as Jacobian-vector products this implies that the Jacobian is singular. For problems where singular Jacobians are rare this narrows the search space substantially.\n\n**Warning:** Without some substantial re-working, the ideas here only work on differentiable MOO problems with at least 2 variables and objectives. We rely heavily on the Jacobian having all non-zero singular values with probability 1, so duplicated information in the jacobians (e.g. having one objective be a constant multiple of another) will prevent meaningful solutions from being found.\n\nTrying to minimize multiple functions at once isn't all that different from just minimizing a single function. Recall how in ordinary calculus it suffices to restrict the solution set to places where the derivative is 0 or undefined. In multi-objective optimization a point can have the property of being *locally non-dominated*, and the only possible solutions to an MOO problem are places which are locally non-dominated and places where that notion is not defined.\n\nAs a quick recap, a point is locally non-dominated if no matter which direction you try to go, if you walk a little bit in that direction you can't find a solution that is at least as good in **every** coordinate and strictly better in **at least one** coordinate.\n\nWhat's interesting about this is that \"walking a little bit in a direction\" can be represented via the directional gradient in that direction -- and that gradient is just the Jacobian multiplied by an appropriate unit vector. If a point is locally non-dominated then there are some directional gradients that just aren't possible (e.g. the all ones vector), which means our Jacobian has a non-trivial null space.\n\nThere are all kinds of reasons a Jacobian might have a non-trivial null space. In particular, if the objectives and variables aren't equal in number we're guaranteed to have a null singular value, but a linear dependance in the objectives or other subtler artifacts can suffice just as well. However, if the objectives and variables are equinumerous then the set of locally non-dominated points is a subset of the set of points yielding a singular Jacobian. Moreover, across the space of all differentiable functions this set will have measure 0 almost surely, so in some sense we drastically reduce the search space if we can find that set of points.\n\nIn practice, one easy way to find a singular Jacobian is to minimize the least singular value of the Jacobian. The singular values are non-negative, and the Jacobian is singular iff one of those is zero, so our problem can really be re-stated as finding roots/minima of the least singular value.\n\nThere is also the issue of undifferentiability in the presence of doubled singular values or any other abnormal behavior. That isn't always the deal-breaker it might seem. Undifferentiable eigenvalues behave similarly in many respects to the absolute value function in a higher coordinate system. Much like the standard 1D counterpart, functional composition can easily create situations where the components are not differentiable but the composition is computationally easy to work with. For example, squaring the absolute value just yields another quadratic which is easily differentiable.\n\nEven in the event that our eigenvalues have tons of undifferentiable locations, they almost surely fall onto a set of measure 0. In practice, many minimization algorithms that assume differentiability in their underpinnings will perform perfectly satisfactorily on exactly this kind of performance landscape. In the event that poorly conditioned Hessians actually throw off your computations then it might be prudent to switch to a less opinionated solver.\n\n# Extended Theory\nFor problems with differing numbers of inputs and outputs, the Jacobian is always singular, and we need a way around that problem. The method we've chosen is to widen the search space to include some potentially extraneous results that only happen with probability 0.\n\nIn particular, a solution is locally non-dominated at a point iff it is locally non-dominated with respect to every directional derivative at that point. This state of affairs would certainly imply being non-dominated with respect to a restricted set of directional derivatives. We fix all but two coordinates and examine the Jacobian of the resulting partially applied function. This affords additional numerical precision in that the smallest eigenvalue has a simple closed form, and we can increase our confidence by simply repeating the procedure for more pairs of input coordinates. In general we're searching a larger solution space than before, but we've opened the technique to a much larger space of functions.\n\nIt does not suffice to only consider the input space -- reducing from n to 2. We still have the problem that the number of inputs with this theory must match the number of outputs, and if we reduce every input to a size of 2 then we need corresponding 2D outputs to get square 2x2 Jacobians. What we've chosen to do is exploit the fact that if a point is non-dominated, then there must be 2 output dimensions for which the point is non-dominated. Hence, we can compute the minimum eigen-score across all pairs of distinct output dimensions to give a condition which is necessary for a point to be locally non-dominated.\n\nOne thing to note is that the minimum behaves extremely poorly in optimization algorithms and does not have a continuous derivative. It is reasonable to use other similar functions with smoother, nicer characteristics to create more easily differentiable objectives. We supply a variety of those to choose from in `sqfuffle.minimizers`.\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/quantum-programmer/square-fuffle", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "sqfuffle", "package_url": "https://pypi.org/project/sqfuffle/", "platform": "", "project_url": "https://pypi.org/project/sqfuffle/", "project_urls": {"Homepage": "https://github.com/quantum-programmer/square-fuffle"}, "release_url": "https://pypi.org/project/sqfuffle/0.0.1/", "requires_dist": null, "requires_python": ">=3.4", "summary": "Quickly solves differentiable multi-objective optimization problems.", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>square-fuffle</h1>\n<p><strong>Alpha Stage -- API will change</strong>. Quickly solves differentiable multi-objective optimization problems.</p>\n<h1>Installation</h1>\n<p>Coming soon.</p>\n<h1>Purpose</h1>\n<p><strong>Multi-objective solvers</strong> exist to help <em>find compromises</em> in the presence of multiple competing goals -- for example, maximizing profits while also maximizing customer satisfaction. These two goals are usually at odds to some extent (what customer wouldn't be happier if a business dropped its prices down to its break-even point?), and an MO solver allows you to consciously weigh the tradeoffs in different solutions.</p>\n<p><strong>square-fuffle</strong> is one of many techniques for solving MO problems. As a rule of thumb, you would choose square-fuffle over other solutions when the <em>objectives are differentiable</em> and when the <em>problem is sufficiently complicated</em>. High-dimensional input spaces are especially problematic for evolutionary MO solvers if any kind of precision is required, but they are straightforward for square-fuffle.</p>\n<h1>Examples</h1>\n<p>When trying to minimize two parabaloids, one situated on the origin and one at the all ones point, the only points that are locally non-dominated are those where <code>y=x</code> and which are directly between the two parabolic minima. Our <code>create_single_objective</code> function has a group of minima precisely in that location.</p>\n<pre><span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">Plots our two objectives with inputs in the unit square and colors them</span>\n<span class=\"sd\">according to the output of create_single_objective().</span>\n<span class=\"sd\">\"\"\"</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">sqfuffle.objectives</span> <span class=\"kn\">import</span> <span class=\"n\">create_single_objective</span>\n<span class=\"kn\">import</span> <span class=\"nn\">jax.numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">jax</span> <span class=\"kn\">import</span> <span class=\"n\">jit</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)])</span>\n\n<span class=\"n\">points</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"ow\">in</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">b</span> <span class=\"ow\">in</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">)]</span>\n<span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">,</span> <span class=\"n\">points</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">h</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">p</span><span class=\"p\">:</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"k\">lambda</span> <span class=\"n\">p</span><span class=\"p\">:</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">jit</span><span class=\"p\">(</span><span class=\"n\">create_single_objective</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))))</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">scatter</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"n\">c</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">xlabel</span><span class=\"p\">(</span><span class=\"s1\">'$x^2 + y^2$'</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">ylabel</span><span class=\"p\">(</span><span class=\"s1\">'$(x-1)^2 + (y-1)^2$'</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">title</span><span class=\"p\">(</span><span class=\"s1\">'Pareto Front'</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">xticks</span><span class=\"p\">([])</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">yticks</span><span class=\"p\">([])</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">axis</span><span class=\"p\">(</span><span class=\"s1\">'scaled'</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p><img alt=\"Pareto Front\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e35aed55b10f9809e0ff7e299e5389068d7c9997/6578616d706c65732f70617261626f6c6f69645f66726f6e742e706e67\"></p>\n<h1>Caveats</h1>\n<ol>\n<li>square-fuffle depends on jax for its differentiation, and that is exposed to the end user in that if they supply a function jax does not understand then <strong>square-fuffle</strong> will throw a number of exceptions. This isn't fundamentally necessary, and in a future iteration we will probably use jax internally and expose the <em>ability</em> for users to supply differentiable functions, but we will also expose hooks where vjp, jvp, or hessians can be provided directly (raw jacobians won't suffice without numerical approximation shenanigans).</li>\n<li>square-fuffle does NOT only return points from the Pareto front. In practice, high-precision points from the Pareto front along with points from some kinds of other interesting manifolds in the context of an MO problem are returned, and square-fuffle's results should be followed with a non-dominated filter. We might provide one in future API versions.</li>\n</ol>\n<h1>Theory</h1>\n<p>TLDR; The main idea is that being locally non-dominated is a constraint on the directional gradients, and since all of those can be represented as Jacobian-vector products this implies that the Jacobian is singular. For problems where singular Jacobians are rare this narrows the search space substantially.</p>\n<p><strong>Warning:</strong> Without some substantial re-working, the ideas here only work on differentiable MOO problems with at least 2 variables and objectives. We rely heavily on the Jacobian having all non-zero singular values with probability 1, so duplicated information in the jacobians (e.g. having one objective be a constant multiple of another) will prevent meaningful solutions from being found.</p>\n<p>Trying to minimize multiple functions at once isn't all that different from just minimizing a single function. Recall how in ordinary calculus it suffices to restrict the solution set to places where the derivative is 0 or undefined. In multi-objective optimization a point can have the property of being <em>locally non-dominated</em>, and the only possible solutions to an MOO problem are places which are locally non-dominated and places where that notion is not defined.</p>\n<p>As a quick recap, a point is locally non-dominated if no matter which direction you try to go, if you walk a little bit in that direction you can't find a solution that is at least as good in <strong>every</strong> coordinate and strictly better in <strong>at least one</strong> coordinate.</p>\n<p>What's interesting about this is that \"walking a little bit in a direction\" can be represented via the directional gradient in that direction -- and that gradient is just the Jacobian multiplied by an appropriate unit vector. If a point is locally non-dominated then there are some directional gradients that just aren't possible (e.g. the all ones vector), which means our Jacobian has a non-trivial null space.</p>\n<p>There are all kinds of reasons a Jacobian might have a non-trivial null space. In particular, if the objectives and variables aren't equal in number we're guaranteed to have a null singular value, but a linear dependance in the objectives or other subtler artifacts can suffice just as well. However, if the objectives and variables are equinumerous then the set of locally non-dominated points is a subset of the set of points yielding a singular Jacobian. Moreover, across the space of all differentiable functions this set will have measure 0 almost surely, so in some sense we drastically reduce the search space if we can find that set of points.</p>\n<p>In practice, one easy way to find a singular Jacobian is to minimize the least singular value of the Jacobian. The singular values are non-negative, and the Jacobian is singular iff one of those is zero, so our problem can really be re-stated as finding roots/minima of the least singular value.</p>\n<p>There is also the issue of undifferentiability in the presence of doubled singular values or any other abnormal behavior. That isn't always the deal-breaker it might seem. Undifferentiable eigenvalues behave similarly in many respects to the absolute value function in a higher coordinate system. Much like the standard 1D counterpart, functional composition can easily create situations where the components are not differentiable but the composition is computationally easy to work with. For example, squaring the absolute value just yields another quadratic which is easily differentiable.</p>\n<p>Even in the event that our eigenvalues have tons of undifferentiable locations, they almost surely fall onto a set of measure 0. In practice, many minimization algorithms that assume differentiability in their underpinnings will perform perfectly satisfactorily on exactly this kind of performance landscape. In the event that poorly conditioned Hessians actually throw off your computations then it might be prudent to switch to a less opinionated solver.</p>\n<h1>Extended Theory</h1>\n<p>For problems with differing numbers of inputs and outputs, the Jacobian is always singular, and we need a way around that problem. The method we've chosen is to widen the search space to include some potentially extraneous results that only happen with probability 0.</p>\n<p>In particular, a solution is locally non-dominated at a point iff it is locally non-dominated with respect to every directional derivative at that point. This state of affairs would certainly imply being non-dominated with respect to a restricted set of directional derivatives. We fix all but two coordinates and examine the Jacobian of the resulting partially applied function. This affords additional numerical precision in that the smallest eigenvalue has a simple closed form, and we can increase our confidence by simply repeating the procedure for more pairs of input coordinates. In general we're searching a larger solution space than before, but we've opened the technique to a much larger space of functions.</p>\n<p>It does not suffice to only consider the input space -- reducing from n to 2. We still have the problem that the number of inputs with this theory must match the number of outputs, and if we reduce every input to a size of 2 then we need corresponding 2D outputs to get square 2x2 Jacobians. What we've chosen to do is exploit the fact that if a point is non-dominated, then there must be 2 output dimensions for which the point is non-dominated. Hence, we can compute the minimum eigen-score across all pairs of distinct output dimensions to give a condition which is necessary for a point to be locally non-dominated.</p>\n<p>One thing to note is that the minimum behaves extremely poorly in optimization algorithms and does not have a continuous derivative. It is reasonable to use other similar functions with smoother, nicer characteristics to create more easily differentiable objectives. We supply a variety of those to choose from in <code>sqfuffle.minimizers</code>.</p>\n\n          </div>"}, "last_serial": 6226442, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "0bef77b50daa61f66c8fcd6f67e6daa5", "sha256": "b12ebe68dfaa9564e1009de7d683f981437fd45a03d3a225bb0f69f461ae910e"}, "downloads": -1, "filename": "sqfuffle-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "0bef77b50daa61f66c8fcd6f67e6daa5", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.4", "size": 21114, "upload_time": "2019-12-02T03:41:09", "upload_time_iso_8601": "2019-12-02T03:41:09.940007Z", "url": "https://files.pythonhosted.org/packages/41/89/00da04d893825b3f4b0379daee1be937bae96d3f91ddb99bab669b38ba0c/sqfuffle-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c702661c8c8751d068b48cbe595de1e5", "sha256": "9a764a01de461a7a631fef4ef6b97420247e4a01d7ce1e67ceeea4ee8396dc70"}, "downloads": -1, "filename": "sqfuffle-0.0.1.tar.gz", "has_sig": false, "md5_digest": "c702661c8c8751d068b48cbe595de1e5", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 7606, "upload_time": "2019-12-02T03:41:12", "upload_time_iso_8601": "2019-12-02T03:41:12.601004Z", "url": "https://files.pythonhosted.org/packages/96/95/0d338d7e4c21abdffe83dc789d2b6bb6471fc6585f573f485f3c00de4cac/sqfuffle-0.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0bef77b50daa61f66c8fcd6f67e6daa5", "sha256": "b12ebe68dfaa9564e1009de7d683f981437fd45a03d3a225bb0f69f461ae910e"}, "downloads": -1, "filename": "sqfuffle-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "0bef77b50daa61f66c8fcd6f67e6daa5", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.4", "size": 21114, "upload_time": "2019-12-02T03:41:09", "upload_time_iso_8601": "2019-12-02T03:41:09.940007Z", "url": "https://files.pythonhosted.org/packages/41/89/00da04d893825b3f4b0379daee1be937bae96d3f91ddb99bab669b38ba0c/sqfuffle-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c702661c8c8751d068b48cbe595de1e5", "sha256": "9a764a01de461a7a631fef4ef6b97420247e4a01d7ce1e67ceeea4ee8396dc70"}, "downloads": -1, "filename": "sqfuffle-0.0.1.tar.gz", "has_sig": false, "md5_digest": "c702661c8c8751d068b48cbe595de1e5", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 7606, "upload_time": "2019-12-02T03:41:12", "upload_time_iso_8601": "2019-12-02T03:41:12.601004Z", "url": "https://files.pythonhosted.org/packages/96/95/0d338d7e4c21abdffe83dc789d2b6bb6471fc6585f573f485f3c00de4cac/sqfuffle-0.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:04:03 2020"}