{"info": {"author": "Chuck \"Sarchar\"", "author_email": "chuck@borboggle.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Topic :: Internet", "Topic :: Security :: Cryptography", "Topic :: System :: Distributed Computing", "Topic :: System :: Networking"], "description": "pyspv\n=====\n\n__WARNING__: *This is experimental software. Use at your own risk*\n\npyspv is a no-bullshit, easy-to-use Python module implementing the full Bitcoin\nSPV client protocol.  Connecting to the Bitcoin network is as easy as:\n\n```python\nimport pyspv\nspv = pyspv.pyspv(\"my-application-name\")\n...\n```\n\n... but just connecting to the Bitcoin network would be boring.  The real goal\nof this project is to make embedding Bitcoin into your project so simple that\neverybody does it.  pyspv handles the details like Blockchain syncing, the\npeer-to-peer network, payment management, wallets, etc., and allows you to get\nstarted prototyping your Bitcoin application quickly.\n\nI intend to make this SPV client as extensible as possible with a goal of\nsupporting alt-coins using simple coin definitions.  Because pyspv is modular,\nit is now easy to connect to several different alt-coin networks within the\nsame application -- simply initialize two pyspv classes with different coin\ndefinitions.\n\nYou can develop a pretty UI wallet or just a simple utility to send you an\nE-mail you when an address receives a payment. The possibilities are really\nendless.\n\nrequirements\n============\n\npyspv only relies on a small handful of dependencies:\n\n* [Python 3.3](http://www.python.org/) :: It probably works on other versions, but this is my testing platform.\n* OpenSSL :: You'll need libssl.so (Linux/Mac) or libeay32.dll (Windows) in your path.\n* [Bitarray](https://pypi.python.org/pypi/bitarray/) :: This is required by the bloom filter implementation.\n\nfeatures\n========\n\n* SPV implementation, so relatively lightweight\n* Python, useful for server and user applications\n* Multisignature support, can create, send to and spend multisignature payments\n* Stealth address support, can create, send to and spend stealth address payments\n* Tor/SOCKS support\n* Testnet support\n* Extensible payment monitor and transaction building system\n\nexamples\n========\n\nsimple-wallet.py\n----------------\n\nThis example runs a basic wallet.  Running it with no arguments starts an RPC\nserver.  With arguments, an RPC call is made.  The program behaves similarly to\nbitcoind, with several noticeable differences.\n\nAvailable commands:\n\n* getnewaddress \\[label\\]? - returns a standard public-key-hash address\n* getnewstealthaddress \\[label\\]? - returns a new stealth address\n* getnewpubkey \\[label\\]? \\[compressed=false\\]? - returns a new public key (hex)\n* getbalance - returns total balance in the wallet\n* getinfo - returns information on the state of the SPV node\n* listspends \\[include\\_spent=false\\] - returns a dictionary describing the Spends in the wallet\n* sendtoaddress \\[address\\] \\[amount\\] \\[memo\\]? - sends amount of coins to address. The address can be a stealth address, a multisig address, or a standard address.\n* sendspendtoaddress \\[spend\\_hash\\] \\[address\\] \\[amount\\] \\[memo\\]? - force inclusion of a specific Spend to the specified address. more coins are selected from the wallet if they're needed to complete the transaction.\n* dumppubkey \\[address\\] - yield the public key of the specified address, if it's in the wallet\n* dumpprivkey \\[address\\] - yield the private key (in WIF format) of the specified address, if it's in the wallet\n* genmultisig \\[nreq\\] \\[mtotal\\] \\[pubkey1,pubkey2,...\\]? - produce a new multsignature address. If not mtotal public keys are provided, new ones are generated and stored in the wallet. The multisignature address requires nreq signatures to spend.\n* sendrawtransaction \\[tx\\_hex\\] - broadcast a transaction to the network\n\ntest-stealth-keys.py\n--------------------\n\nThis example runs through the math and demonstrates how stealth addresses work in theory.  \n\nanyonecanpay-new.py\n-------------------\n\nCreate a new transaction with specified outputs and zero inputs.  The transaction displayed can be used as input to anyonecanpay-add.py.\n\nanyonecanpay-add.py\n-------------------\n\nGiven a transaction and a spend id, add those inputs and sign them using ANYONECANPAY.  This program, combined with anyonecanpay-new.py\neffectly allows easy creation of [assurance contracts](https://en.bitcoin.it/wiki/Contracts#Example_3:_Assurance_contracts).\n\ndocumentation\n=============\n\nTODO\n\nDocumentation will soon be available at http://docs.pyspv.org/", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/sarchar/pyspv", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "pyspv", "package_url": "https://pypi.org/project/pyspv/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/pyspv/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/sarchar/pyspv"}, "release_url": "https://pypi.org/project/pyspv/0.0.1/", "requires_dist": null, "requires_python": null, "summary": "Bitcoin SPV implementation in Python", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"pyspv\">\n<h2>pyspv</h2>\n<p>__WARNING__: <em>This is experimental software. Use at your own risk</em></p>\n<p>pyspv is a no-bullshit, easy-to-use Python module implementing the full Bitcoin\nSPV client protocol.  Connecting to the Bitcoin network is as easy as:</p>\n<p><tt>`python\nimport pyspv\nspv = <span class=\"pre\">pyspv.pyspv(\"my-application-name\")</span>\n...\n`</tt></p>\n<p>\u2026 but just connecting to the Bitcoin network would be boring.  The real goal\nof this project is to make embedding Bitcoin into your project so simple that\neverybody does it.  pyspv handles the details like Blockchain syncing, the\npeer-to-peer network, payment management, wallets, etc., and allows you to get\nstarted prototyping your Bitcoin application quickly.</p>\n<p>I intend to make this SPV client as extensible as possible with a goal of\nsupporting alt-coins using simple coin definitions.  Because pyspv is modular,\nit is now easy to connect to several different alt-coin networks within the\nsame application \u2013 simply initialize two pyspv classes with different coin\ndefinitions.</p>\n<p>You can develop a pretty UI wallet or just a simple utility to send you an\nE-mail you when an address receives a payment. The possibilities are really\nendless.</p>\n</div>\n<div id=\"requirements\">\n<h2>requirements</h2>\n<p>pyspv only relies on a small handful of dependencies:</p>\n<ul>\n<li>[Python 3.3](<a href=\"http://www.python.org/\" rel=\"nofollow\">http://www.python.org/</a>) :: It probably works on other versions, but this is my testing platform.</li>\n<li>OpenSSL :: You\u2019ll need libssl.so (Linux/Mac) or libeay32.dll (Windows) in your path.</li>\n<li>[Bitarray](<a href=\"https://pypi.python.org/pypi/bitarray/\" rel=\"nofollow\">https://pypi.python.org/pypi/bitarray/</a>) :: This is required by the bloom filter implementation.</li>\n</ul>\n</div>\n<div id=\"features\">\n<h2>features</h2>\n<ul>\n<li>SPV implementation, so relatively lightweight</li>\n<li>Python, useful for server and user applications</li>\n<li>Multisignature support, can create, send to and spend multisignature payments</li>\n<li>Stealth address support, can create, send to and spend stealth address payments</li>\n<li>Tor/SOCKS support</li>\n<li>Testnet support</li>\n<li>Extensible payment monitor and transaction building system</li>\n</ul>\n</div>\n<div id=\"examples\">\n<h2>examples</h2>\n<div id=\"simple-wallet-py\">\n<h3>simple-wallet.py</h3>\n<p>This example runs a basic wallet.  Running it with no arguments starts an RPC\nserver.  With arguments, an RPC call is made.  The program behaves similarly to\nbitcoind, with several noticeable differences.</p>\n<p>Available commands:</p>\n<ul>\n<li>getnewaddress [label]? - returns a standard public-key-hash address</li>\n<li>getnewstealthaddress [label]? - returns a new stealth address</li>\n<li>getnewpubkey [label]? [compressed=false]? - returns a new public key (hex)</li>\n<li>getbalance - returns total balance in the wallet</li>\n<li>getinfo - returns information on the state of the SPV node</li>\n<li>listspends [include_spent=false] - returns a dictionary describing the Spends in the wallet</li>\n<li>sendtoaddress [address] [amount] [memo]? - sends amount of coins to address. The address can be a stealth address, a multisig address, or a standard address.</li>\n<li>sendspendtoaddress [spend_hash] [address] [amount] [memo]? - force inclusion of a specific Spend to the specified address. more coins are selected from the wallet if they\u2019re needed to complete the transaction.</li>\n<li>dumppubkey [address] - yield the public key of the specified address, if it\u2019s in the wallet</li>\n<li>dumpprivkey [address] - yield the private key (in WIF format) of the specified address, if it\u2019s in the wallet</li>\n<li>genmultisig [nreq] [mtotal] [pubkey1,pubkey2,\u2026]? - produce a new multsignature address. If not mtotal public keys are provided, new ones are generated and stored in the wallet. The multisignature address requires nreq signatures to spend.</li>\n<li>sendrawtransaction [tx_hex] - broadcast a transaction to the network</li>\n</ul>\n</div>\n<div id=\"test-stealth-keys-py\">\n<h3>test-stealth-keys.py</h3>\n<p>This example runs through the math and demonstrates how stealth addresses work in theory.</p>\n</div>\n<div id=\"anyonecanpay-new-py\">\n<h3>anyonecanpay-new.py</h3>\n<p>Create a new transaction with specified outputs and zero inputs.  The transaction displayed can be used as input to anyonecanpay-add.py.</p>\n</div>\n<div id=\"anyonecanpay-add-py\">\n<h3>anyonecanpay-add.py</h3>\n<p>Given a transaction and a spend id, add those inputs and sign them using ANYONECANPAY.  This program, combined with anyonecanpay-new.py\neffectly allows easy creation of [assurance contracts](<a href=\"https://en.bitcoin.it/wiki/Contracts#Example_3:_Assurance_contracts\" rel=\"nofollow\">https://en.bitcoin.it/wiki/Contracts#Example_3:_Assurance_contracts</a>).</p>\n</div>\n</div>\n<div id=\"documentation\">\n<h2>documentation</h2>\n<p>TODO</p>\n<p>Documentation will soon be available at <a href=\"http://docs.pyspv.org/\" rel=\"nofollow\">http://docs.pyspv.org/</a></p>\n</div>\n\n          </div>"}, "last_serial": 1008563, "releases": {"0.0.1": []}, "urls": [], "timestamp": "Fri May  8 02:56:09 2020"}