{"info": {"author": "Florimond Manca", "author_email": "florimond.manca@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Framework :: AsyncIO", "Framework :: Trio", "Intended Audience :: Developers", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: 3 :: Only"], "description": "# aiometer\n\n[![Build Status](https://dev.azure.com/florimondmanca/public/_apis/build/status/florimondmanca.aiometer?branchName=master)](https://dev.azure.com/florimondmanca/public/_build/latest?definitionId=1&branchName=master)\n[![Coverage](https://codecov.io/gh/florimondmanca/aiometer/branch/master/graph/badge.svg)](https://codecov.io/gh/florimondmanca/aiometer)\n![Python versions](https://img.shields.io/pypi/pyversions/aiometer.svg)\n[![Package version](https://badge.fury.io/py/aiometer.svg)](https://pypi.org/project/aiometer)\n\n`aiometer` is a Python 3.7+ concurrency scheduling library compatible with `asyncio` and `trio` and inspired by [Trimeter](https://github.com/python-trio/trimeter). It makes it easier to execute lots of tasks concurrently while controlling concurrency limits (i.e. applying _[backpressure](https://lucumr.pocoo.org/2020/1/1/async-pressure/)_) and collecting results in a predictable manner.\n\n_This project is currently in early alpha. Be sure to pin any dependencies to the latest minor._\n\n**Content**\n\n- [Example](#example)\n- [Features](#features)\n- [Installation](#installation)\n- [Guide](#guide)\n  - [Flow control](#flow-control)\n  - [Running tasks](#running-tasks)\n\n## Example\n\nLet's use [HTTPX](https://github.com/encode/httpx) to make web requests concurrently...\n\n_Try this code interactively using [IPython](https://ipython.org/install.html)._\n\n```python\n>>> import asyncio\n>>> import functools\n>>> import random\n>>> import aiometer\n>>> import httpx\n>>>\n>>> client = httpx.AsyncClient()\n>>>\n>>> async def fetch(client, request):\n...     response = await client.send(request)\n...     # Simulate extra processing...\n...     await asyncio.sleep(2 * random.random())\n...     return response.json()[\"json\"]\n...\n>>> requests = [\n...     httpx.Request(\"POST\", \"https://httpbin.org/anything\", json={\"index\": index})\n...     for index in range(100)\n... ]\n...\n>>> # Send requests, and process responses as they're made available:\n>>> async with aiometer.amap(\n...     functools.partial(fetch, client),\n...     requests,\n...     max_at_once=10, # Limit maximum number of concurrently running tasks.\n...     max_per_second=5,  # Limit request rate to not overload the server.\n... ) as results:\n...     async for data in results:\n...         print(data)\n...\n{'index': 3}\n{'index': 4}\n{'index': 1}\n{'index': 2}\n{'index': 0}\n...\n>>> # Alternatively, fetch and aggregate responses into an (ordered) list...\n>>> jobs = [functools.partial(fetch, client, request) for request in requests]\n>>> results = await aiometer.run_all(jobs, max_at_once=10, max_per_second=5)\n>>> results\n[{'index': 0}, {'index': 1}, {'index': 2}, {'index': 3}, {'index': 4}, ...]\n```\n\n## Installation\n\n```bash\npip install \"aiometer==0.2.*\"\n```\n\n## Features\n\n- Concurrency management and throttling helpers.\n- `asyncio` and `trio` support.\n- Fully type annotated.\n- 100% test coverage.\n\n## Guide\n\n### Flow control\n\nThe key highlight of `aiometer` is allowing you to apply flow control strategies in order to limit the degree of concurrency of your programs.\n\nThere are two knobs you can play with to fine-tune concurrency:\n\n- `max_at_once`: this is used to limit the maximum number of concurrently running tasks at any given time. (If you have 100 tasks and set `max_at_once=10`, then `aiometer` will ensure that no more than 10 run at the same time.)\n- `max_per_second`: this option limits the number of tasks spawned per second. This is useful to not overload I/O resources, such as servers that may have a rate limiting policy in place.\n\nExample usage:\n\n```python\n>>> import asyncio\n>>> import aiometer\n>>> async def make_query(query):\n...     await asyncio.sleep(0.05)  # Simulate a database request.\n...\n>>> queries = ['SELECT * from authors'] * 1000\n>>> # Allow at most 5 queries to run concurrently at any given time:\n>>> await aiometer.run_on_each(make_query, queries, max_at_once=5)\n...\n>>> # Make at most 10 queries per second:\n>>> await aiometer.run_on_each(make_query, queries, max_per_second=10)\n...\n>>> # Run at most 10 concurrent jobs, spawning new ones at least every 5 seconds:\n>>> async def job(id):\n...     await asyncio.sleep(10)  # A very long task.\n...\n>>> await aiometer.run_on_each(job, range(100),  max_at_once=10, max_per_second=0.2)\n```\n\n### Running tasks\n\n`aiometer` provides 4 different ways to run tasks concurrently in the form of 4 different run functions. Each function accepts all the options documented in [Flow control](#flow-control), and runs tasks in a slightly different way, allowing to address a variety of use cases. Here's a handy table for reference:\n\n| Entrypoint      | Use case                                       |\n| --------------- | ---------------------------------------------- |\n| `run_on_each()` | Execute async callbacks in any order.          |\n| `run_all()`     | Return results as an ordered list.             |\n| `amap()`        | Iterate over results as they become available. |\n| `run_any()`     | Return result of first completed function.     |\n\nTo illustrate the behavior of each run function, let's first setup a hello world async program:\n\n```python\n>>> import asyncio\n>>> import random\n>>> from functools import partial\n>>> import aiometer\n>>>\n>>> async def get_greeting(name):\n...     await asyncio.sleep(random.random())  # Simulate I/O\n...     return f\"Hello, {name}\"\n...\n>>> async def greet(name):\n...     greeting = await get_greeting(name)\n...     print(greeting)\n...\n>>> names = [\"Robert\", \"Carmen\", \"Lucas\"]\n```\n\nLet's start with `run_on_each()`. It executes an async function once for each item in a list passed as argument:\n\n```python\n>>> await aiometer.run_on_each(greet, names)\n'Hello, Robert!'\n'Hello, Lucas!'\n'Hello, Carmen!'\n```\n\nIf we'd like to get the list of greetings in the same order as `names`, in a fashion similar to [`Promise.all()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all), we can use `run_all()`:\n\n```python\n>>> await aiometer.run_all([partial(get_greeting, name) for name in names])\n['Hello, Robert', 'Hello, Carmen!', 'Hello, Lucas!']\n```\n\n`amap()` allows us to process each greeting as it becomes available (which means maintaining order is not guaranteed):\n\n```python\n>>> async with aiometer.amap(get_greeting, names) as greetings:\n...     async for greeting in greetings:\n...         print(greeting)\n'Hello, Lucas!'\n'Hello, Robert!'\n'Hello, Carmen!'\n```\n\nLastly, `run_any()` can be used to run async functions until the first one completes, similarly to [`Promise.any()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any):\n\n```python\n>>> await aiometer.run_any([partial(get_greeting, name) for name in names])\n'Hello, Carmen!'\n```\n\nAs a last fun example, let's use `amap()` to implement a no-threads async version of [sleep sort](https://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort):\n\n```python\n>>> import asyncio\n>>> from functools import partial\n>>> import aiometer\n>>> numbers = [0.3, 0.1, 0.6, 0.2, 0.7, 0.5, 0.5, 0.2]\n>>> async def process(n):\n...     await asyncio.sleep(n)\n...     return n\n...\n>>> async with aiometer.amap(process, numbers) as results:\n...     sorted_numbers = [n async for n in results]\n...\n>>> sorted_numbers\n[0.1, 0.2, 0.2, 0.3, 0.5, 0.5, 0.6, 0.7]\n```\n\n## License\n\nMIT\n\n\n# Changelog\n\nAll notable changes to this project will be documented in this file.\n\nThe format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n\n## 0.2.1 - 2020-03-26\n\n### Fixed\n\n- Improve robustness of the `max_per_second` implementation by using the generic cell rate algorithm (GCRA) instead of leaky bucket. (Pull #5)\n\n## 0.2.0 - 2020-03-22\n\n### Added\n\n- Add support for Python 3.7. (Pull #3)\n\n## 0.1.0 - 2020-03-21\n\n### Added\n\n- Add `run_on_each()`, `run_all()`, `amap()` and `run_any()`, with `max_at_once` and `max_per_second` options. (Pull #1)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/florimondmanca/aiometer", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "aiometer", "package_url": "https://pypi.org/project/aiometer/", "platform": "", "project_url": "https://pypi.org/project/aiometer/", "project_urls": {"Homepage": "http://github.com/florimondmanca/aiometer"}, "release_url": "https://pypi.org/project/aiometer/0.2.1/", "requires_dist": ["anyio (==1.*)", "typing-extensions (==3.7.*) ; python_version < \"3.8\""], "requires_python": ">=3.7", "summary": "A Python concurrency scheduling library, compatible with asyncio and trio", "version": "0.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>aiometer</h1>\n<p><a href=\"https://dev.azure.com/florimondmanca/public/_build/latest?definitionId=1&amp;branchName=master\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7746fdbf2bbc1ee0a4140e9edb2ae4daecdbd5e6/68747470733a2f2f6465762e617a7572652e636f6d2f666c6f72696d6f6e646d616e63612f7075626c69632f5f617069732f6275696c642f7374617475732f666c6f72696d6f6e646d616e63612e61696f6d657465723f6272616e63684e616d653d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/florimondmanca/aiometer\" rel=\"nofollow\"><img alt=\"Coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f4b90129d796a95359e26c0e5abab6d6687bb4e1/68747470733a2f2f636f6465636f762e696f2f67682f666c6f72696d6f6e646d616e63612f61696f6d657465722f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<img alt=\"Python versions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5c2e54acd018bd76e40ce5adb5bc3fbc3db6c2a9/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f61696f6d657465722e737667\">\n<a href=\"https://pypi.org/project/aiometer\" rel=\"nofollow\"><img alt=\"Package version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/823d6224dff4301c837eb85b8c556ac72229e070/68747470733a2f2f62616467652e667572792e696f2f70792f61696f6d657465722e737667\"></a></p>\n<p><code>aiometer</code> is a Python 3.7+ concurrency scheduling library compatible with <code>asyncio</code> and <code>trio</code> and inspired by <a href=\"https://github.com/python-trio/trimeter\" rel=\"nofollow\">Trimeter</a>. It makes it easier to execute lots of tasks concurrently while controlling concurrency limits (i.e. applying <em><a href=\"https://lucumr.pocoo.org/2020/1/1/async-pressure/\" rel=\"nofollow\">backpressure</a></em>) and collecting results in a predictable manner.</p>\n<p><em>This project is currently in early alpha. Be sure to pin any dependencies to the latest minor.</em></p>\n<p><strong>Content</strong></p>\n<ul>\n<li><a href=\"#example\" rel=\"nofollow\">Example</a></li>\n<li><a href=\"#features\" rel=\"nofollow\">Features</a></li>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#guide\" rel=\"nofollow\">Guide</a>\n<ul>\n<li><a href=\"#flow-control\" rel=\"nofollow\">Flow control</a></li>\n<li><a href=\"#running-tasks\" rel=\"nofollow\">Running tasks</a></li>\n</ul>\n</li>\n</ul>\n<h2>Example</h2>\n<p>Let's use <a href=\"https://github.com/encode/httpx\" rel=\"nofollow\">HTTPX</a> to make web requests concurrently...</p>\n<p><em>Try this code interactively using <a href=\"https://ipython.org/install.html\" rel=\"nofollow\">IPython</a>.</em></p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">functools</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">random</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">aiometer</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">httpx</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">httpx</span><span class=\"o\">.</span><span class=\"n\">AsyncClient</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">fetch</span><span class=\"p\">(</span><span class=\"n\">client</span><span class=\"p\">,</span> <span class=\"n\">request</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>     <span class=\"c1\"># Simulate extra processing...</span>\n<span class=\"o\">...</span>     <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">())</span>\n<span class=\"o\">...</span>     <span class=\"k\">return</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">json</span><span class=\"p\">()[</span><span class=\"s2\">\"json\"</span><span class=\"p\">]</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">requests</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n<span class=\"o\">...</span>     <span class=\"n\">httpx</span><span class=\"o\">.</span><span class=\"n\">Request</span><span class=\"p\">(</span><span class=\"s2\">\"POST\"</span><span class=\"p\">,</span> <span class=\"s2\">\"https://httpbin.org/anything\"</span><span class=\"p\">,</span> <span class=\"n\">json</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s2\">\"index\"</span><span class=\"p\">:</span> <span class=\"n\">index</span><span class=\"p\">})</span>\n<span class=\"o\">...</span>     <span class=\"k\">for</span> <span class=\"n\">index</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"o\">...</span> <span class=\"p\">]</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Send requests, and process responses as they're made available:</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">aiometer</span><span class=\"o\">.</span><span class=\"n\">amap</span><span class=\"p\">(</span>\n<span class=\"o\">...</span>     <span class=\"n\">functools</span><span class=\"o\">.</span><span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">fetch</span><span class=\"p\">,</span> <span class=\"n\">client</span><span class=\"p\">),</span>\n<span class=\"o\">...</span>     <span class=\"n\">requests</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>     <span class=\"n\">max_at_once</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"c1\"># Limit maximum number of concurrently running tasks.</span>\n<span class=\"o\">...</span>     <span class=\"n\">max_per_second</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">,</span>  <span class=\"c1\"># Limit request rate to not overload the server.</span>\n<span class=\"o\">...</span> <span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">results</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>     <span class=\"k\">async</span> <span class=\"k\">for</span> <span class=\"n\">data</span> <span class=\"ow\">in</span> <span class=\"n\">results</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>         <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n<span class=\"p\">{</span><span class=\"s1\">'index'</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s1\">'index'</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s1\">'index'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s1\">'index'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s1\">'index'</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">}</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Alternatively, fetch and aggregate responses into an (ordered) list...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">jobs</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">functools</span><span class=\"o\">.</span><span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">fetch</span><span class=\"p\">,</span> <span class=\"n\">client</span><span class=\"p\">,</span> <span class=\"n\">request</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">request</span> <span class=\"ow\">in</span> <span class=\"n\">requests</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">aiometer</span><span class=\"o\">.</span><span class=\"n\">run_all</span><span class=\"p\">(</span><span class=\"n\">jobs</span><span class=\"p\">,</span> <span class=\"n\">max_at_once</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">max_per_second</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">results</span>\n<span class=\"p\">[{</span><span class=\"s1\">'index'</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"s1\">'index'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"s1\">'index'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"s1\">'index'</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"s1\">'index'</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">},</span> <span class=\"o\">...</span><span class=\"p\">]</span>\n</pre>\n<h2>Installation</h2>\n<pre>pip install <span class=\"s2\">\"aiometer==0.2.*\"</span>\n</pre>\n<h2>Features</h2>\n<ul>\n<li>Concurrency management and throttling helpers.</li>\n<li><code>asyncio</code> and <code>trio</code> support.</li>\n<li>Fully type annotated.</li>\n<li>100% test coverage.</li>\n</ul>\n<h2>Guide</h2>\n<h3>Flow control</h3>\n<p>The key highlight of <code>aiometer</code> is allowing you to apply flow control strategies in order to limit the degree of concurrency of your programs.</p>\n<p>There are two knobs you can play with to fine-tune concurrency:</p>\n<ul>\n<li><code>max_at_once</code>: this is used to limit the maximum number of concurrently running tasks at any given time. (If you have 100 tasks and set <code>max_at_once=10</code>, then <code>aiometer</code> will ensure that no more than 10 run at the same time.)</li>\n<li><code>max_per_second</code>: this option limits the number of tasks spawned per second. This is useful to not overload I/O resources, such as servers that may have a rate limiting policy in place.</li>\n</ul>\n<p>Example usage:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">aiometer</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">make_query</span><span class=\"p\">(</span><span class=\"n\">query</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">0.05</span><span class=\"p\">)</span>  <span class=\"c1\"># Simulate a database request.</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">queries</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'SELECT * from authors'</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"mi\">1000</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Allow at most 5 queries to run concurrently at any given time:</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">await</span> <span class=\"n\">aiometer</span><span class=\"o\">.</span><span class=\"n\">run_on_each</span><span class=\"p\">(</span><span class=\"n\">make_query</span><span class=\"p\">,</span> <span class=\"n\">queries</span><span class=\"p\">,</span> <span class=\"n\">max_at_once</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Make at most 10 queries per second:</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">await</span> <span class=\"n\">aiometer</span><span class=\"o\">.</span><span class=\"n\">run_on_each</span><span class=\"p\">(</span><span class=\"n\">make_query</span><span class=\"p\">,</span> <span class=\"n\">queries</span><span class=\"p\">,</span> <span class=\"n\">max_per_second</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Run at most 10 concurrent jobs, spawning new ones at least every 5 seconds:</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">job</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>  <span class=\"c1\"># A very long task.</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">await</span> <span class=\"n\">aiometer</span><span class=\"o\">.</span><span class=\"n\">run_on_each</span><span class=\"p\">(</span><span class=\"n\">job</span><span class=\"p\">,</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">),</span>  <span class=\"n\">max_at_once</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">max_per_second</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">)</span>\n</pre>\n<h3>Running tasks</h3>\n<p><code>aiometer</code> provides 4 different ways to run tasks concurrently in the form of 4 different run functions. Each function accepts all the options documented in <a href=\"#flow-control\" rel=\"nofollow\">Flow control</a>, and runs tasks in a slightly different way, allowing to address a variety of use cases. Here's a handy table for reference:</p>\n<table>\n<thead>\n<tr>\n<th>Entrypoint</th>\n<th>Use case</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>run_on_each()</code></td>\n<td>Execute async callbacks in any order.</td>\n</tr>\n<tr>\n<td><code>run_all()</code></td>\n<td>Return results as an ordered list.</td>\n</tr>\n<tr>\n<td><code>amap()</code></td>\n<td>Iterate over results as they become available.</td>\n</tr>\n<tr>\n<td><code>run_any()</code></td>\n<td>Return result of first completed function.</td>\n</tr></tbody></table>\n<p>To illustrate the behavior of each run function, let's first setup a hello world async program:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">random</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">functools</span> <span class=\"kn\">import</span> <span class=\"n\">partial</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">aiometer</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">get_greeting</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">())</span>  <span class=\"c1\"># Simulate I/O</span>\n<span class=\"o\">...</span>     <span class=\"k\">return</span> <span class=\"sa\">f</span><span class=\"s2\">\"Hello, </span><span class=\"si\">{</span><span class=\"n\">name</span><span class=\"si\">}</span><span class=\"s2\">\"</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">greet</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"n\">greeting</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">get_greeting</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>     <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">greeting</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">names</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"Robert\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Carmen\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Lucas\"</span><span class=\"p\">]</span>\n</pre>\n<p>Let's start with <code>run_on_each()</code>. It executes an async function once for each item in a list passed as argument:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">await</span> <span class=\"n\">aiometer</span><span class=\"o\">.</span><span class=\"n\">run_on_each</span><span class=\"p\">(</span><span class=\"n\">greet</span><span class=\"p\">,</span> <span class=\"n\">names</span><span class=\"p\">)</span>\n<span class=\"s1\">'Hello, Robert!'</span>\n<span class=\"s1\">'Hello, Lucas!'</span>\n<span class=\"s1\">'Hello, Carmen!'</span>\n</pre>\n<p>If we'd like to get the list of greetings in the same order as <code>names</code>, in a fashion similar to <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\" rel=\"nofollow\"><code>Promise.all()</code></a>, we can use <code>run_all()</code>:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">await</span> <span class=\"n\">aiometer</span><span class=\"o\">.</span><span class=\"n\">run_all</span><span class=\"p\">([</span><span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">get_greeting</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">name</span> <span class=\"ow\">in</span> <span class=\"n\">names</span><span class=\"p\">])</span>\n<span class=\"p\">[</span><span class=\"s1\">'Hello, Robert'</span><span class=\"p\">,</span> <span class=\"s1\">'Hello, Carmen!'</span><span class=\"p\">,</span> <span class=\"s1\">'Hello, Lucas!'</span><span class=\"p\">]</span>\n</pre>\n<p><code>amap()</code> allows us to process each greeting as it becomes available (which means maintaining order is not guaranteed):</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">aiometer</span><span class=\"o\">.</span><span class=\"n\">amap</span><span class=\"p\">(</span><span class=\"n\">get_greeting</span><span class=\"p\">,</span> <span class=\"n\">names</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">greetings</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>     <span class=\"k\">async</span> <span class=\"k\">for</span> <span class=\"n\">greeting</span> <span class=\"ow\">in</span> <span class=\"n\">greetings</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>         <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">greeting</span><span class=\"p\">)</span>\n<span class=\"s1\">'Hello, Lucas!'</span>\n<span class=\"s1\">'Hello, Robert!'</span>\n<span class=\"s1\">'Hello, Carmen!'</span>\n</pre>\n<p>Lastly, <code>run_any()</code> can be used to run async functions until the first one completes, similarly to <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\" rel=\"nofollow\"><code>Promise.any()</code></a>:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">await</span> <span class=\"n\">aiometer</span><span class=\"o\">.</span><span class=\"n\">run_any</span><span class=\"p\">([</span><span class=\"n\">partial</span><span class=\"p\">(</span><span class=\"n\">get_greeting</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">name</span> <span class=\"ow\">in</span> <span class=\"n\">names</span><span class=\"p\">])</span>\n<span class=\"s1\">'Hello, Carmen!'</span>\n</pre>\n<p>As a last fun example, let's use <code>amap()</code> to implement a no-threads async version of <a href=\"https://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort\" rel=\"nofollow\">sleep sort</a>:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">functools</span> <span class=\"kn\">import</span> <span class=\"n\">partial</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">aiometer</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">numbers</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.6</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">process</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>     <span class=\"k\">return</span> <span class=\"n\">n</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">aiometer</span><span class=\"o\">.</span><span class=\"n\">amap</span><span class=\"p\">(</span><span class=\"n\">process</span><span class=\"p\">,</span> <span class=\"n\">numbers</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">results</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>     <span class=\"n\">sorted_numbers</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">n</span> <span class=\"k\">async</span> <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">results</span><span class=\"p\">]</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sorted_numbers</span>\n<span class=\"p\">[</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.6</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">]</span>\n</pre>\n<h2>License</h2>\n<p>MIT</p>\n<h1>Changelog</h1>\n<p>All notable changes to this project will be documented in this file.</p>\n<p>The format is based on <a href=\"https://keepachangelog.com/en/1.0.0/\" rel=\"nofollow\">Keep a Changelog</a>.</p>\n<h2>0.2.1 - 2020-03-26</h2>\n<h3>Fixed</h3>\n<ul>\n<li>Improve robustness of the <code>max_per_second</code> implementation by using the generic cell rate algorithm (GCRA) instead of leaky bucket. (Pull #5)</li>\n</ul>\n<h2>0.2.0 - 2020-03-22</h2>\n<h3>Added</h3>\n<ul>\n<li>Add support for Python 3.7. (Pull #3)</li>\n</ul>\n<h2>0.1.0 - 2020-03-21</h2>\n<h3>Added</h3>\n<ul>\n<li>Add <code>run_on_each()</code>, <code>run_all()</code>, <code>amap()</code> and <code>run_any()</code>, with <code>max_at_once</code> and <code>max_per_second</code> options. (Pull #1)</li>\n</ul>\n\n          </div>"}, "last_serial": 6890604, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "026140757c287371abcfc0d3b8ba6c4a", "sha256": "fa0f2828140b1e52082a62de8bf46f0b447f524d03aef2dd0baa59ea53a4964e"}, "downloads": -1, "filename": "aiometer-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "026140757c287371abcfc0d3b8ba6c4a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.8", "size": 11086, "upload_time": "2020-03-21T22:16:05", "upload_time_iso_8601": "2020-03-21T22:16:05.654994Z", "url": "https://files.pythonhosted.org/packages/80/e7/5d5c1282b407664884401297f3fd90348bbae48afa35b98494da1a6ac465/aiometer-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "050249c3c8e45390ea575622272996c4", "sha256": "253bafb546c1f1567feda824c5d2a01c2c54b6a4ef0c76c0d90c4a0bb15facc0"}, "downloads": -1, "filename": "aiometer-0.1.0.tar.gz", "has_sig": false, "md5_digest": "050249c3c8e45390ea575622272996c4", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.8", "size": 12738, "upload_time": "2020-03-21T22:16:09", "upload_time_iso_8601": "2020-03-21T22:16:09.087374Z", "url": "https://files.pythonhosted.org/packages/b5/98/060fa80243328725e2b3a1e244a8f499bc20d204c4bffe839140a5b7cf37/aiometer-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "cb902b79de7671f50fec60ef63873904", "sha256": "e9c4a515ab8e894db85c7a2c7d59e8ecf6c3253e46143bad8a5edf3d48392561"}, "downloads": -1, "filename": "aiometer-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "cb902b79de7671f50fec60ef63873904", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 11204, "upload_time": "2020-03-22T12:00:01", "upload_time_iso_8601": "2020-03-22T12:00:01.394626Z", "url": "https://files.pythonhosted.org/packages/18/0d/8298fd8eafe756b3f53e9a4182e8d8c547bd11539de01d2b58e9be708b54/aiometer-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a081b7d8b301e2fb59b69097bc216b72", "sha256": "efb3ceafb55954c4c81c33246d7e4870e0680540b43aafa1016c31278d6c2961"}, "downloads": -1, "filename": "aiometer-0.2.0.tar.gz", "has_sig": false, "md5_digest": "a081b7d8b301e2fb59b69097bc216b72", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 12963, "upload_time": "2020-03-22T12:00:02", "upload_time_iso_8601": "2020-03-22T12:00:02.856837Z", "url": "https://files.pythonhosted.org/packages/f3/b4/b42c59ea2342c39393bf4d3f78e3926b1f93360deb3f1c8963558c47706d/aiometer-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "83ff553f5155ee0368a81173f8eb35f1", "sha256": "6a6d9181032d4173d94a38f4bfe9dffa43874665c73f41539af4ae7147679cef"}, "downloads": -1, "filename": "aiometer-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "83ff553f5155ee0368a81173f8eb35f1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 11335, "upload_time": "2020-03-26T19:07:31", "upload_time_iso_8601": "2020-03-26T19:07:31.032313Z", "url": "https://files.pythonhosted.org/packages/21/3c/ff3c531b429bf909b44ef26b5e5c3edbb90fe97dd2327f74e9fe801d9a75/aiometer-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5ab82d686f51d10a658270a807c21180", "sha256": "379e4e5a01f4c4b9bc3200cd93cd17e9bbcd791d404a312eb331e47f7011fd53"}, "downloads": -1, "filename": "aiometer-0.2.1.tar.gz", "has_sig": false, "md5_digest": "5ab82d686f51d10a658270a807c21180", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 13254, "upload_time": "2020-03-26T19:07:32", "upload_time_iso_8601": "2020-03-26T19:07:32.594817Z", "url": "https://files.pythonhosted.org/packages/c1/fc/da8f767c618a33b305bcab5218a0b6b4c70d826f50586dc9650f32b597da/aiometer-0.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "83ff553f5155ee0368a81173f8eb35f1", "sha256": "6a6d9181032d4173d94a38f4bfe9dffa43874665c73f41539af4ae7147679cef"}, "downloads": -1, "filename": "aiometer-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "83ff553f5155ee0368a81173f8eb35f1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 11335, "upload_time": "2020-03-26T19:07:31", "upload_time_iso_8601": "2020-03-26T19:07:31.032313Z", "url": "https://files.pythonhosted.org/packages/21/3c/ff3c531b429bf909b44ef26b5e5c3edbb90fe97dd2327f74e9fe801d9a75/aiometer-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5ab82d686f51d10a658270a807c21180", "sha256": "379e4e5a01f4c4b9bc3200cd93cd17e9bbcd791d404a312eb331e47f7011fd53"}, "downloads": -1, "filename": "aiometer-0.2.1.tar.gz", "has_sig": false, "md5_digest": "5ab82d686f51d10a658270a807c21180", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 13254, "upload_time": "2020-03-26T19:07:32", "upload_time_iso_8601": "2020-03-26T19:07:32.594817Z", "url": "https://files.pythonhosted.org/packages/c1/fc/da8f767c618a33b305bcab5218a0b6b4c70d826f50586dc9650f32b597da/aiometer-0.2.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:21:05 2020"}