{"info": {"author": "Michal Orsak", "author_email": "michal.o.socials@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)", "Topic :: System :: Emulators", "Topic :: System :: Hardware", "Topic :: Utilities"], "description": "# pyMathBitPrecise\n[![Build Status](https://travis-ci.org/Nic30/pyMathBitPrecise.svg?branch=master)](https://travis-ci.org/Nic30/pyMathBitPrecise)\n[![Coverage Status](https://coveralls.io/repos/github/Nic30/pyMathBitPrecise/badge.svg?branch=master)](https://coveralls.io/github/Nic30/pyMathBitPrecise?branch=master)\n[![PyPI version](https://badge.fury.io/py/pyMathBitPrecise.svg)](http://badge.fury.io/py/pyMathBitPrecise) \n[![Documentation Status](https://readthedocs.org/projects/pyMathBitPrecise/badge/?version=latest)](http://pyMathBitPrecise.readthedocs.io/en/latest/?badge=latest) \n[![](https://img.shields.io/github/license/Nic30/pyMathBitPrecise.svg)](https://github.com/Nic30/pyMathBitPrecise)\n[![Python version](https://img.shields.io/pypi/pyversions/pyMathBitPrecise.svg)](https://img.shields.io/pypi/pyversions/pyMathBitPrecise.svg)\n\nThis library contains number types of variable bit size and utils for bit manipulations.\nThre are also types which support tri state values etc. (Python equivalents of VHDL `std_logic_vector`, Verilog `wire`/`reg`.)\n\nThis may be usefull for tools which are simulating hardware or software which needs numbers of exact size.\n\n\n## Example\n\n```Python\nfrom pyMathBitPrecise.bits3t import Bits3t\n\n#3t means that bits can have values 1,0,x\nuint512_t = Bits3t(512, signed=False)\n\na = uint512_t.from_py(1)\n\n# indexing on bits\n# [note] == is not overloaded, because it would make the values unhashable\n#        because of support of partially valid values which can not be compared\nassert a[0]._eq(1)\nassert a[0]._dtype.bit_length() == 1\nassert a[1]._eq(0)\nassert a[8:]._eq(1)\nassert a[8:]._dtype.bit_length() == 8\n\n# arithmetic\nb = a + 1\nassert b._eq(2)\nassert b._dtype == uint512_t\n\n# bitwise operations\nc = a >> 8\nassert c.eq(0)\nassert c._dtype == uint512_t\n\n# casting\nd = int(a)\nassert d == 1 and isinstance(d, int)\n\nuint8_t = Bits3t(8, signed=False)\ne = a.cast(uint8_t)\nassert e._dtype == uint8_t\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Nic30/pyMathBitPrecise", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pyMathBitPrecise", "package_url": "https://pypi.org/project/pyMathBitPrecise/", "platform": "", "project_url": "https://pypi.org/project/pyMathBitPrecise/", "project_urls": {"Homepage": "https://github.com/Nic30/pyMathBitPrecise"}, "release_url": "https://pypi.org/project/pyMathBitPrecise/0.2/", "requires_dist": null, "requires_python": "", "summary": "number types of variable bit size and utils for bit manipulations", "version": "0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>pyMathBitPrecise</h1>\n<p><a href=\"https://travis-ci.org/Nic30/pyMathBitPrecise\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b3ca48a6e783725f6b53e44219b608b422de4230/68747470733a2f2f7472617669732d63692e6f72672f4e696333302f70794d617468426974507265636973652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/Nic30/pyMathBitPrecise?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4984a8fb491f3aa6bfb624ac92dac6afa76af75f/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f4e696333302f70794d617468426974507265636973652f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"http://badge.fury.io/py/pyMathBitPrecise\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d3c5620251de01324a0b49ce5a06f2d6228b2cf0/68747470733a2f2f62616467652e667572792e696f2f70792f70794d617468426974507265636973652e737667\"></a>\n<a href=\"http://pyMathBitPrecise.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d00604651644a62003e9f1fbf1f2123e168a8fbc/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f70794d617468426974507265636973652f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<a href=\"https://github.com/Nic30/pyMathBitPrecise\" rel=\"nofollow\"><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/80ea8592d1759f73b09f8b6c4131287b2a7d76aa/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f4e696333302f70794d617468426974507265636973652e737667\"></a>\n<a href=\"https://img.shields.io/pypi/pyversions/pyMathBitPrecise.svg\" rel=\"nofollow\"><img alt=\"Python version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/40e398d86adf4e81edcdb26eb27fe27f36e24f43/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f70794d617468426974507265636973652e737667\"></a></p>\n<p>This library contains number types of variable bit size and utils for bit manipulations.\nThre are also types which support tri state values etc. (Python equivalents of VHDL <code>std_logic_vector</code>, Verilog <code>wire</code>/<code>reg</code>.)</p>\n<p>This may be usefull for tools which are simulating hardware or software which needs numbers of exact size.</p>\n<h2>Example</h2>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyMathBitPrecise.bits3t</span> <span class=\"kn\">import</span> <span class=\"n\">Bits3t</span>\n\n<span class=\"c1\">#3t means that bits can have values 1,0,x</span>\n<span class=\"n\">uint512_t</span> <span class=\"o\">=</span> <span class=\"n\">Bits3t</span><span class=\"p\">(</span><span class=\"mi\">512</span><span class=\"p\">,</span> <span class=\"n\">signed</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">uint512_t</span><span class=\"o\">.</span><span class=\"n\">from_py</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># indexing on bits</span>\n<span class=\"c1\"># [note] == is not overloaded, because it would make the values unhashable</span>\n<span class=\"c1\">#        because of support of partially valid values which can not be compared</span>\n<span class=\"k\">assert</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">_eq</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">_dtype</span><span class=\"o\">.</span><span class=\"n\">bit_length</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">1</span>\n<span class=\"k\">assert</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">_eq</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">8</span><span class=\"p\">:]</span><span class=\"o\">.</span><span class=\"n\">_eq</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">8</span><span class=\"p\">:]</span><span class=\"o\">.</span><span class=\"n\">_dtype</span><span class=\"o\">.</span><span class=\"n\">bit_length</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">8</span>\n\n<span class=\"c1\"># arithmetic</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n<span class=\"k\">assert</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">_eq</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">_dtype</span> <span class=\"o\">==</span> <span class=\"n\">uint512_t</span>\n\n<span class=\"c1\"># bitwise operations</span>\n<span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">&gt;&gt;</span> <span class=\"mi\">8</span>\n<span class=\"k\">assert</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">eq</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">_dtype</span> <span class=\"o\">==</span> <span class=\"n\">uint512_t</span>\n\n<span class=\"c1\"># casting</span>\n<span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">d</span> <span class=\"o\">==</span> <span class=\"mi\">1</span> <span class=\"ow\">and</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">)</span>\n\n<span class=\"n\">uint8_t</span> <span class=\"o\">=</span> <span class=\"n\">Bits3t</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">signed</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">cast</span><span class=\"p\">(</span><span class=\"n\">uint8_t</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">_dtype</span> <span class=\"o\">==</span> <span class=\"n\">uint8_t</span>\n</pre>\n\n          </div>"}, "last_serial": 6094562, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "44df080441dd7be2203d3dbd1ea899f6", "sha256": "50e44e8b04a3e30049550aa8364f05fe5295bfad9c58fdf2d68a356374fa005b"}, "downloads": -1, "filename": "pyMathBitPrecise-0.1.tar.gz", "has_sig": false, "md5_digest": "44df080441dd7be2203d3dbd1ea899f6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10357, "upload_time": "2019-10-11T15:45:38", "upload_time_iso_8601": "2019-10-11T15:45:38.531025Z", "url": "https://files.pythonhosted.org/packages/85/31/accfd562a635e4904b18e1a29776fac2d6e935fd0d961044743f1944469d/pyMathBitPrecise-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "7993ffc64e15303a37d042d8b7d253a6", "sha256": "10934c9b661cb63aa11295b77193f406f67d4abdaef88ce6cfb1d3739a7bad6c"}, "downloads": -1, "filename": "pyMathBitPrecise-0.2.tar.gz", "has_sig": false, "md5_digest": "7993ffc64e15303a37d042d8b7d253a6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13350, "upload_time": "2019-11-07T16:52:57", "upload_time_iso_8601": "2019-11-07T16:52:57.466103Z", "url": "https://files.pythonhosted.org/packages/8f/b1/deb4baec5a2d0376156f11604f7e9c83d65f69f17b333e48f41eb9d2dc84/pyMathBitPrecise-0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7993ffc64e15303a37d042d8b7d253a6", "sha256": "10934c9b661cb63aa11295b77193f406f67d4abdaef88ce6cfb1d3739a7bad6c"}, "downloads": -1, "filename": "pyMathBitPrecise-0.2.tar.gz", "has_sig": false, "md5_digest": "7993ffc64e15303a37d042d8b7d253a6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13350, "upload_time": "2019-11-07T16:52:57", "upload_time_iso_8601": "2019-11-07T16:52:57.466103Z", "url": "https://files.pythonhosted.org/packages/8f/b1/deb4baec5a2d0376156f11604f7e9c83d65f69f17b333e48f41eb9d2dc84/pyMathBitPrecise-0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:26 2020"}