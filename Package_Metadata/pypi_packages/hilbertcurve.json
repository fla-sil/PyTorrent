{"info": {"author": "Gabriel Altay", "author_email": "gabriel.altay@gmail.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3 :: Only"], "description": "============\nIntroduction\n============\n\nThis is a package to convert between one dimensional distance along a\n`Hilbert curve`_, ``h``, and ``N``-dimensional coordinates,\n``(x_0, x_1, ... x_N-1)``.  There are two important parameters,\n\n* ``N`` -- the number of dimensions (must be > 0)\n* ``p`` -- the number of iterations used in constructing the Hilbert curve (must be > 0)\n\nWe consider an ``N``-dimensional `hypercube`_ of side length ``2^p``.\nThis hypercube contains ``2^{N p}`` unit hypercubes (``2^p`` along\neach dimension).  The number of unit hypercubes determine the possible\ndiscrete distances along the Hilbert curve (indexed from 0 to\n``2^{N p} - 1``).\n\n\n==========\nQuickstart\n==========\n\nInstall the package with pip,\n\n.. code-block:: bash\n\n  pip install hilbertcurve\n\nYou can calculate coordinates given distances along a hilbert curve,\n\n.. code-block:: python\n\n  >>> from hilbertcurve.hilbertcurve import HilbertCurve\n  >>> p=1; N=2\n  >>> hilbert_curve = HilbertCurve(p, N)\n  >>> for ii in range(4):\n  >>>     coords = hilbert_curve.coordinates_from_distance(ii)\n  >>>     print(f'coords(h={ii}) = {coords}')\n\n  coords(h=0) = [0, 0]\n  coords(h=1) = [0, 1]\n  coords(h=2) = [1, 1]\n  coords(h=3) = [1, 0]\n\nYou can also calculate distances along a hilbert curve given coordinates,\n\n.. code-block:: python\n\n  >>> for coords in [[0,0], [0,1], [1,1], [1,0]]:\n  >>>     dist = hilbert_curve.distance_from_coordinates(coords)\n  >>>     print(f'distance(x={coords}) = {dist}')\n\n  distance(x=[0, 0]) = 0\n  distance(x=[0, 1]) = 1\n  distance(x=[1, 1]) = 2\n  distance(x=[1, 0]) = 3\n\n\n=========================\n(Absurdly) Large Integers\n=========================\n\nDue to the magic of `arbitrarily large integers in Python`_,\nthese calculations can be done with ... well ... arbitrarily large integers!\n\n.. code-block:: python\n\n  >>> p = 512; N = 10\n  >>> hilbert_curve = HilbertCurve(p, N)\n  >>> ii = 123456789101112131415161718192021222324252627282930\n  >>> coords = hilbert_curve.coordinates_from_distance(ii)\n  >>> print(f'coords = {coords}')\n\n  coords = [121075, 67332, 67326, 108879, 26637, 43346, 23848, 1551, 68130, 84004]\n\nThe calculations above represent the 512th iteration of the Hilbert curve in 10 dimensions.\nThe maximum value along any coordinate axis is an integer with 155 digits and the maximum\ndistance along the curve is an integer with 1542 digits.  For comparison,\n`an estimate of the number of atoms in the observable universe`_\nis ``10^{82}`` (i.e. an integer with 83 digits).\n\n=======\nVisuals\n=======\n\n\n.. figure:: n2_p3.png\n\n   The figure above shows the first three iterations of the Hilbert\n   curve in two (``N=2``) dimensions.  The ``p=1`` iteration is shown\n   in red, ``p=2`` in blue, and ``p=3`` in black.\n   For the ``p=3`` iteration, distances, ``h``, along the curve are\n   labeled from 0 to 63 (i.e. from 0 to ``2^{N p}-1``).  This package\n   provides methods to translate between ``N``-dimensional coordinates and one\n   dimensional distance.  For example, between (``x_0=4, x_1=6``) and\n   ``h=36``.  Note that the ``p=1`` and ``p=2`` iterations have been\n   scaled and translated to the coordinate system of the ``p=3`` iteration.\n\n\nAn animation of the same case in 3-D is available on YouTube.  To watch the video,\nclick the link below.  Once the YouTube video loads, you can right click on it and\nturn \"Loop\" on to watch the curve rotate continuously.\n\n.. figure:: https://img.youtube.com/vi/TfJEJidwkBQ/0.jpg\n\n   3-D Hilbert Curve Animation https://www.youtube.com/watch?v=TfJEJidwkBQ\n\n=========\nReference\n=========\n\nThis module is based on the C code provided in the 2004 article\n\"Programming the Hilbert Curve\" by John Skilling,\n\n* http://adsabs.harvard.edu/abs/2004AIPC..707..381S\n\nI was also helped by the discussion in the following stackoverflow post,\n\n* `mapping-n-dimensional-value-to-a-point-on-hilbert-curve`_\n\nwhich points out a typo in the source code of the paper.  The Skilling code\nprovides two functions ``TransposetoAxes`` and ``AxestoTranspose``.  In this\ncase, Transpose refers to a specific packing of the integer that represents\ndistance along the Hilbert curve (see below for details) and\nAxes refer to the N-dimensional coordinates.  Below is an excerpt from the\ndocumentation of Skilling's code,\n\n::\n\n    //+++++++++++++++++++++++++++ PUBLIC-DOMAIN SOFTWARE ++++++++++++++++++++++++++\n    // Functions: TransposetoAxes  AxestoTranspose\n    // Purpose:   Transform in-place between Hilbert transpose and geometrical axes\n    // Example:   b=5 bits for each of n=3 coordinates.\n    //            15-bit Hilbert integer = A B C D E F G H I J K L M N O is stored\n    //            as its Transpose\n    //                   X[0] = A D G J M                X[2]|\n    //                   X[1] = B E H K N    <------->       | /X[1]\n    //                   X[2] = C F I L O               axes |/\n    //                          high  low                    0------ X[0]\n    //            Axes are stored conveniently as b-bit integers.\n    // Author:    John Skilling  20 Apr 2001 to 11 Oct 2003\n\n\n\n.. _Hilbert curve: https://en.wikipedia.org/wiki/Hilbert_curve\n.. _hypercube: https://en.wikipedia.org/wiki/Hypercube\n.. _arbitrarily large integers in Python: https://docs.python.org/3.3/library/stdtypes.html#numeric-types-int-float-complex\n.. _an estimate of the number of atoms in the observable universe: https://www.universetoday.com/36302/atoms-in-the-universe\n.. _mapping-n-dimensional-value-to-a-point-on-hilbert-curve: http://stackoverflow.com/questions/499166/mapping-n-dimensional-value-to-a-point-on-hilbert-curve", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/galtay/hilbertcurve", "keywords": "fractal space-filling-curves hilbert hilbert-curve python python3 wikidata parser", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "hilbertcurve", "package_url": "https://pypi.org/project/hilbertcurve/", "platform": "", "project_url": "https://pypi.org/project/hilbertcurve/", "project_urls": {"Homepage": "https://github.com/galtay/hilbertcurve"}, "release_url": "https://pypi.org/project/hilbertcurve/1.0.3/", "requires_dist": null, "requires_python": ">=3.5", "summary": "Construct Hilbert Curves.", "version": "1.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>This is a package to convert between one dimensional distance along a\n<a href=\"https://en.wikipedia.org/wiki/Hilbert_curve\" rel=\"nofollow\">Hilbert curve</a>, <tt>h</tt>, and <tt>N</tt>-dimensional coordinates,\n<tt>(x_0, x_1, ... <span class=\"pre\">x_N-1)</span></tt>.  There are two important parameters,</p>\n<ul>\n<li><tt>N</tt> \u2013 the number of dimensions (must be &gt; 0)</li>\n<li><tt>p</tt> \u2013 the number of iterations used in constructing the Hilbert curve (must be &gt; 0)</li>\n</ul>\n<p>We consider an <tt>N</tt>-dimensional <a href=\"https://en.wikipedia.org/wiki/Hypercube\" rel=\"nofollow\">hypercube</a> of side length <tt>2^p</tt>.\nThis hypercube contains <tt><span class=\"pre\">2^{N</span> p}</tt> unit hypercubes (<tt>2^p</tt> along\neach dimension).  The number of unit hypercubes determine the possible\ndiscrete distances along the Hilbert curve (indexed from 0 to\n<tt><span class=\"pre\">2^{N</span> p} - 1</tt>).</p>\n</div>\n<div id=\"quickstart\">\n<h2>Quickstart</h2>\n<p>Install the package with pip,</p>\n<pre>pip install hilbertcurve\n</pre>\n<p>You can calculate coordinates given distances along a hilbert curve,</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">hilbertcurve.hilbertcurve</span> <span class=\"kn\">import</span> <span class=\"n\">HilbertCurve</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">N</span><span class=\"o\">=</span><span class=\"mi\">2</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">hilbert_curve</span> <span class=\"o\">=</span> <span class=\"n\">HilbertCurve</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">ii</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">):</span>\n<span class=\"o\">&gt;&gt;&gt;</span>     <span class=\"n\">coords</span> <span class=\"o\">=</span> <span class=\"n\">hilbert_curve</span><span class=\"o\">.</span><span class=\"n\">coordinates_from_distance</span><span class=\"p\">(</span><span class=\"n\">ii</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>     <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'coords(h=</span><span class=\"si\">{</span><span class=\"n\">ii</span><span class=\"si\">}</span><span class=\"s1\">) = </span><span class=\"si\">{</span><span class=\"n\">coords</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n\n<span class=\"n\">coords</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">coords</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"n\">coords</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"n\">coords</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n</pre>\n<p>You can also calculate distances along a hilbert curve given coordinates,</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">coords</span> <span class=\"ow\">in</span> <span class=\"p\">[[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]]:</span>\n<span class=\"o\">&gt;&gt;&gt;</span>     <span class=\"n\">dist</span> <span class=\"o\">=</span> <span class=\"n\">hilbert_curve</span><span class=\"o\">.</span><span class=\"n\">distance_from_coordinates</span><span class=\"p\">(</span><span class=\"n\">coords</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>     <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'distance(x=</span><span class=\"si\">{</span><span class=\"n\">coords</span><span class=\"si\">}</span><span class=\"s1\">) = </span><span class=\"si\">{</span><span class=\"n\">dist</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n\n<span class=\"n\">distance</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">distance</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">distance</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"n\">distance</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n</pre>\n</div>\n<div id=\"absurdly-large-integers\">\n<h2>(Absurdly) Large Integers</h2>\n<p>Due to the magic of <a href=\"https://docs.python.org/3.3/library/stdtypes.html#numeric-types-int-float-complex\" rel=\"nofollow\">arbitrarily large integers in Python</a>,\nthese calculations can be done with \u2026 well \u2026 arbitrarily large integers!</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"mi\">512</span><span class=\"p\">;</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">hilbert_curve</span> <span class=\"o\">=</span> <span class=\"n\">HilbertCurve</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ii</span> <span class=\"o\">=</span> <span class=\"mi\">123456789101112131415161718192021222324252627282930</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">coords</span> <span class=\"o\">=</span> <span class=\"n\">hilbert_curve</span><span class=\"o\">.</span><span class=\"n\">coordinates_from_distance</span><span class=\"p\">(</span><span class=\"n\">ii</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'coords = </span><span class=\"si\">{</span><span class=\"n\">coords</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n\n<span class=\"n\">coords</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">121075</span><span class=\"p\">,</span> <span class=\"mi\">67332</span><span class=\"p\">,</span> <span class=\"mi\">67326</span><span class=\"p\">,</span> <span class=\"mi\">108879</span><span class=\"p\">,</span> <span class=\"mi\">26637</span><span class=\"p\">,</span> <span class=\"mi\">43346</span><span class=\"p\">,</span> <span class=\"mi\">23848</span><span class=\"p\">,</span> <span class=\"mi\">1551</span><span class=\"p\">,</span> <span class=\"mi\">68130</span><span class=\"p\">,</span> <span class=\"mi\">84004</span><span class=\"p\">]</span>\n</pre>\n<p>The calculations above represent the 512th iteration of the Hilbert curve in 10 dimensions.\nThe maximum value along any coordinate axis is an integer with 155 digits and the maximum\ndistance along the curve is an integer with 1542 digits.  For comparison,\n<a href=\"https://www.universetoday.com/36302/atoms-in-the-universe\" rel=\"nofollow\">an estimate of the number of atoms in the observable universe</a>\nis <tt><span class=\"pre\">10^{82}</span></tt> (i.e. an integer with 83 digits).</p>\n</div>\n<div id=\"visuals\">\n<h2>Visuals</h2>\n<div>\n<img alt=\"n2_p3.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/15adf3edad9065513372c19db2d41f861fb63ba6/6e325f70332e706e67\">\n<p>The figure above shows the first three iterations of the Hilbert\ncurve in two (<tt>N=2</tt>) dimensions.  The <tt>p=1</tt> iteration is shown\nin red, <tt>p=2</tt> in blue, and <tt>p=3</tt> in black.\nFor the <tt>p=3</tt> iteration, distances, <tt>h</tt>, along the curve are\nlabeled from 0 to 63 (i.e. from 0 to <tt><span class=\"pre\">2^{N</span> <span class=\"pre\">p}-1</span></tt>).  This package\nprovides methods to translate between <tt>N</tt>-dimensional coordinates and one\ndimensional distance.  For example, between (<tt>x_0=4, x_1=6</tt>) and\n<tt>h=36</tt>.  Note that the <tt>p=1</tt> and <tt>p=2</tt> iterations have been\nscaled and translated to the coordinate system of the <tt>p=3</tt> iteration.</p>\n</div>\n<p>An animation of the same case in 3-D is available on YouTube.  To watch the video,\nclick the link below.  Once the YouTube video loads, you can right click on it and\nturn \u201cLoop\u201d on to watch the curve rotate continuously.</p>\n<div>\n<img alt=\"https://img.youtube.com/vi/TfJEJidwkBQ/0.jpg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/59c093c38167477bd25ebb43a050c5fac7b6ce5a/68747470733a2f2f696d672e796f75747562652e636f6d2f76692f54664a454a6964776b42512f302e6a7067\">\n<p>3-D Hilbert Curve Animation <a href=\"https://www.youtube.com/watch?v=TfJEJidwkBQ\" rel=\"nofollow\">https://www.youtube.com/watch?v=TfJEJidwkBQ</a></p>\n</div>\n</div>\n<div id=\"reference\">\n<h2>Reference</h2>\n<p>This module is based on the C code provided in the 2004 article\n\u201cProgramming the Hilbert Curve\u201d by John Skilling,</p>\n<ul>\n<li><a href=\"http://adsabs.harvard.edu/abs/2004AIPC..707..381S\" rel=\"nofollow\">http://adsabs.harvard.edu/abs/2004AIPC..707..381S</a></li>\n</ul>\n<p>I was also helped by the discussion in the following stackoverflow post,</p>\n<ul>\n<li><a href=\"http://stackoverflow.com/questions/499166/mapping-n-dimensional-value-to-a-point-on-hilbert-curve\" rel=\"nofollow\">mapping-n-dimensional-value-to-a-point-on-hilbert-curve</a></li>\n</ul>\n<p>which points out a typo in the source code of the paper.  The Skilling code\nprovides two functions <tt>TransposetoAxes</tt> and <tt>AxestoTranspose</tt>.  In this\ncase, Transpose refers to a specific packing of the integer that represents\ndistance along the Hilbert curve (see below for details) and\nAxes refer to the N-dimensional coordinates.  Below is an excerpt from the\ndocumentation of Skilling\u2019s code,</p>\n<pre>//+++++++++++++++++++++++++++ PUBLIC-DOMAIN SOFTWARE ++++++++++++++++++++++++++\n// Functions: TransposetoAxes  AxestoTranspose\n// Purpose:   Transform in-place between Hilbert transpose and geometrical axes\n// Example:   b=5 bits for each of n=3 coordinates.\n//            15-bit Hilbert integer = A B C D E F G H I J K L M N O is stored\n//            as its Transpose\n//                   X[0] = A D G J M                X[2]|\n//                   X[1] = B E H K N    &lt;-------&gt;       | /X[1]\n//                   X[2] = C F I L O               axes |/\n//                          high  low                    0------ X[0]\n//            Axes are stored conveniently as b-bit integers.\n// Author:    John Skilling  20 Apr 2001 to 11 Oct 2003\n</pre>\n</div>\n\n          </div>"}, "last_serial": 6222652, "releases": {"1.0.1": [{"comment_text": "", "digests": {"md5": "f3c0a45dc2870600187e756b55482108", "sha256": "bb5968fdb94000b84b8f80f4e91f0fb448ef028b77ddfc62c37c2d16270e9ca9"}, "downloads": -1, "filename": "hilbertcurve-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "f3c0a45dc2870600187e756b55482108", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 6250, "upload_time": "2019-03-03T19:32:25", "upload_time_iso_8601": "2019-03-03T19:32:25.427128Z", "url": "https://files.pythonhosted.org/packages/70/79/8f7c63284d3bb35eafe9caafbab3429e194726309bde0e03e5cf4958aeb3/hilbertcurve-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ff44bfa8158b6d967e163b49edefc8d2", "sha256": "b1ddf58f529219d3b76e8b61ed03e2975a724aff4848b720397c7d5601f49521"}, "downloads": -1, "filename": "hilbertcurve-1.0.1.tar.gz", "has_sig": false, "md5_digest": "ff44bfa8158b6d967e163b49edefc8d2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 5648, "upload_time": "2019-03-03T19:32:27", "upload_time_iso_8601": "2019-03-03T19:32:27.245249Z", "url": "https://files.pythonhosted.org/packages/0d/37/854cce6c8db1022182316e482d385a388fc69489d894cd9d024963883092/hilbertcurve-1.0.1.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "9eba2c5c369abee80d54095071033418", "sha256": "cb041f40f1b26843ef093d104954c55cf0dba5b6e976371a510432c193ee951d"}, "downloads": -1, "filename": "hilbertcurve-1.0.3.tar.gz", "has_sig": false, "md5_digest": "9eba2c5c369abee80d54095071033418", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 6395, "upload_time": "2019-11-30T22:03:22", "upload_time_iso_8601": "2019-11-30T22:03:22.302456Z", "url": "https://files.pythonhosted.org/packages/89/6f/25919200d8b3851321738e5e72ff370db3fd7f0d6c13748997aab34d3f80/hilbertcurve-1.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "9eba2c5c369abee80d54095071033418", "sha256": "cb041f40f1b26843ef093d104954c55cf0dba5b6e976371a510432c193ee951d"}, "downloads": -1, "filename": "hilbertcurve-1.0.3.tar.gz", "has_sig": false, "md5_digest": "9eba2c5c369abee80d54095071033418", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 6395, "upload_time": "2019-11-30T22:03:22", "upload_time_iso_8601": "2019-11-30T22:03:22.302456Z", "url": "https://files.pythonhosted.org/packages/89/6f/25919200d8b3851321738e5e72ff370db3fd7f0d6c13748997aab34d3f80/hilbertcurve-1.0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:11 2020"}