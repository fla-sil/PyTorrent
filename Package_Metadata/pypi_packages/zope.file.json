{"info": {"author": "Zope Corporation and Contributors", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Zope :: 3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Internet :: WWW/HTTP"], "description": "The `zope.file` package provides a content object used to store a\nfile. The interface supports efficient upload and download.\n\n\n.. contents::\n\n=============\n File Object\n=============\n\nThe `zope.file` package provides a content object used to store a\nfile.  The interface supports efficient upload and download.  Let's\ncreate an instance:\n\n  >>> from zope.file.file import File\n  >>> f = File()\n\nThe object provides a limited number of data attributes.  The\n`mimeType` attribute is used to store the preferred MIME\ncontent-type value for the data:\n\n  >>> f.mimeType\n\n  >>> f.mimeType = \"text/plain\"\n  >>> f.mimeType\n  'text/plain'\n\n  >>> f.mimeType = \"application/postscript\"\n  >>> f.mimeType\n  'application/postscript'\n\nThe `parameters` attribute is a mapping used to store the content-type\nparameters.  This is where encoding information can be found when\napplicable (and available):\n\n  >>> f.parameters\n  {}\n  >>> f.parameters[\"charset\"] = \"us-ascii\"\n  >>> f.parameters[\"charset\"]\n  'us-ascii'\n\nBoth, `parameters` and `mimeType` can optionally also be set when\ncreating a `File` object:\n\n  >>> f2 = File(mimeType = \"application/octet-stream\",\n  ...           parameters = dict(charset = \"utf-8\"))\n  >>> f2.mimeType\n  'application/octet-stream'\n\n  >>> f2.parameters[\"charset\"]\n  'utf-8'\n\nFile objects also sport a `size` attribute that provides the number of\nbytes in the file:\n\n  >>> f.size\n  0\n\nThe object supports efficient upload and download by providing all\naccess to content data through accessor objects that provide (subsets\nof) Python's file API.\n\nA file that hasn't been written to is empty.  We can get a reader by calling\n`open()`. Note that all blobs are binary, thus the mode always contains a\n'b':\n\n  >>> r = f.open(\"r\")\n  >>> r.mode\n  'rb'\n\nThe `read()` method can be called with a non-negative integer argument\nto specify how many bytes to read, or with a negative or omitted\nargument to read to the end of the file:\n\n  >>> r.read(10)\n  ''\n  >>> r.read()\n  ''\n  >>> r.read(-1)\n  ''\n\nOnce the accessor has been closed, we can no longer read from it:\n\n  >>> r.close()\n  >>> r.read()\n  Traceback (most recent call last):\n  ValueError: I/O operation on closed file\n\nWe'll see that readers are more interesting once there's data in the\nfile object.\n\nData is added by using a writer, which is also created using the\n`open()` method on the file, but requesting a write file mode:\n\n  >>> w = f.open(\"w\")\n  >>> w.mode\n  'wb'\n\nThe `write()` method is used to add data to the file, but note that\nthe data may be buffered in the writer:\n\n  >>> _ = w.write(b\"some text \")\n  >>> _ = w.write(b\"more text\")\n\nThe `flush()` method ensure that the data written so far is written to\nthe file object:\n\n  >>> w.flush()\n\nWe need to close the file first before determining its file size\n\n  >>> w.close()\n  >>> f.size\n  19\n\nWe can now use a reader to see that the data has been written to the\nfile:\n\n  >>> w = f.open(\"w\")\n  >>> _ = w.write(b'some text more text')\n  >>> _ = w.write(b\" still more\")\n  >>> w.close()\n  >>> f.size\n  30\n\n\nNow create a new reader and let's perform some seek operations.\n\n  >>> r = f.open()\n\nThe reader also has a `seek()` method that can be used to back up or\nskip forward in the data stream.  Simply passing an offset argument,\nwe see that the current position is moved to that offset from the\nstart of the file:\n\n  >>> _ = r.seek(20)\n  >>> r.read()\n  'still more'\n\nThat's equivalent to passing 0 as the `whence` argument:\n\n  >>> _ = r.seek(20, 0)\n  >>> r.read()\n  'still more'\n\nWe can skip backward and forward relative to the current position by\npassing 1 for `whence`:\n\n  >>> _ = r.seek(-10, 1)\n  >>> r.read(5)\n  'still'\n  >>> _ = r.seek(2, 1)\n  >>> r.read()\n  'ore'\n\nWe can skip to some position backward from the end of the file using\nthe value 2 for `whence`:\n\n  >>> _ = r.seek(-10, 2)\n  >>> r.read()\n  'still more'\n\n  >>> _ = r.seek(0)\n  >>> _ = r.seek(-4, 2)\n  >>> r.read()\n  'more'\n\n  >>> r.close()\n\n\nAttempting to write to a closed writer raises an exception:\n\n\n  >>> w = f.open('w')\n  >>> w.close()\n\n  >>> w.write(b'foobar')\n  Traceback (most recent call last):\n  ValueError: I/O operation on closed file\n\nSimilarly, using `seek()` or `tell()` on a closed reader raises an\nexception:\n\n  >>> r.close()\n  >>> _ = r.seek(0)\n  Traceback (most recent call last):\n  ValueError: I/O operation on closed file\n\n  >>> r.tell()\n  Traceback (most recent call last):\n  ValueError: I/O operation on closed file\n\n\n==========================\n Downloading File Objects\n==========================\n\nThe file content type provides a view used to download the file,\nregardless of the browser's default behavior for the content type.\nThis relies on browser support for the Content-Disposition header.\n\nThe download support is provided by two distinct objects:  A view that\nprovides the download support using the information in the content\nobject, and a result object that can be used to implement a file\ndownload by other views.  The view can override the content-type or the\nfilename suggested to the browser using the standard IResponse.setHeader\nmethod.\n\nNote that result objects are intended to be used once and then\ndiscarded.\n\nLet's start by creating a file object we can use to demonstrate the\ndownload support:\n\n  >>> import transaction\n  >>> from zope.file.file import File\n  >>> f = File()\n  >>> getRootFolder()['file'] = f\n  >>> transaction.commit()\n\nHeaders\n=======\n\nNow, let's get the headers for this file.  We use a utility function called\n``getHeaders``:\n\n  >>> from zope.file.download import getHeaders\n  >>> headers = getHeaders(f, contentDisposition='attachment')\n\nSince there's no suggested download filename on the file, the\nContent-Disposition header doesn't specify one, but does indicate that\nthe response body be treated as a file to save rather than to apply\nthe default handler for the content type:\n\n  >>> sorted(headers)\n  [('Content-Disposition', 'attachment; filename=\"file\"'),\n   ('Content-Length', '0'),\n   ('Content-Type', 'application/octet-stream')]\n\n\nNote that a default content type of 'application/octet-stream' is\nused.\n\nIf the file object specifies a content type, that's used in the headers\nby default:\n\n  >>> f.mimeType = \"text/plain\"\n  >>> headers = getHeaders(f, contentDisposition='attachment')\n  >>> sorted(headers)\n  [('Content-Disposition', 'attachment; filename=\"file\"'),\n   ('Content-Length', '0'),\n   ('Content-Type', 'text/plain')]\n\nAlternatively, a content type can be specified to ``getHeaders``:\n\n  >>> headers = getHeaders(f, contentType=\"text/xml\",\n  ...                      contentDisposition='attachment')\n  >>> sorted(headers)\n  [('Content-Disposition', 'attachment; filename=\"file\"'),\n   ('Content-Length', '0'),\n   ('Content-Type', 'text/xml')]\n\nThe filename provided to the browser can be controlled similarly.  If\nthe content object provides one, it will be used by default:\n\n  >>> headers = getHeaders(f, contentDisposition='attachment')\n  >>> sorted(headers)\n  [('Content-Disposition', 'attachment; filename=\"file\"'),\n   ('Content-Length', '0'),\n   ('Content-Type', 'text/plain')]\n\nProviding an alternate name to ``getHeaders`` overrides the download\nname from the file:\n\n  >>> headers = getHeaders(f, downloadName=\"foo.txt\",\n  ...                      contentDisposition='attachment')\n  >>> sorted(headers)\n  [('Content-Disposition', 'attachment; filename=\"foo.txt\"'),\n   ('Content-Length', '0'),\n   ('Content-Type', 'text/plain')]\n\nThe default Content-Disposition header can be overridden by providing\nan argument to ``getHeaders``:\n\n  >>> headers = getHeaders(f, contentDisposition=\"inline\")\n  >>> sorted(headers)\n  [('Content-Disposition', 'inline; filename=\"file\"'),\n   ('Content-Length', '0'),\n   ('Content-Type', 'text/plain')]\n\nIf the ``contentDisposition`` argument is not provided, none will be\nincluded in the headers:\n\n  >>> headers = getHeaders(f)\n  >>> sorted(headers)\n  [('Content-Length', '0'),\n   ('Content-Type', 'text/plain')]\n\n\nBody\n====\n\nWe use DownloadResult to deliver the content to the browser.  Since\nthere's no data in this file, there are no body chunks:\n\n  >>> transaction.commit()\n  >>> from zope.file.download import DownloadResult\n  >>> result = DownloadResult(f)\n  >>> list(result)\n  []\n\nWe still need to see how non-empty files are handled.  Let's write\nsome data to our file object:\n\n  >>> with f.open(\"w\") as w:\n  ...    _ = w.write(b\"some text\")\n  ...    w.flush()\n  >>> transaction.commit()\n\nNow we can create a result object and see if we get the data we\nexpect:\n\n  >>> result = DownloadResult(f)\n  >>> L = list(result)\n  >>> b\"\".join(L)\n  'some text'\n\nIf the body content is really large, the iterator may provide more\nthan one chunk of data:\n\n  >>> with f.open(\"w\") as w:\n  ...   _ = w.write(b\"*\" * 1024 * 1024)\n  ...   w.flush()\n  >>> transaction.commit()\n\n  >>> result = DownloadResult(f)\n  >>> L = list(result)\n  >>> len(L) > 1\n  True\n\nOnce iteration over the body has completed, further iteration will not\nyield additional data:\n\n  >>> list(result)\n  []\n\n\nThe Download View\n=================\n\nNow that we've seen the ``getHeaders`` function and the result object,\nlet's take a look at the basic download view that uses them.  We'll need\nto add a file object where we can get to it using a browser:\n\n  >>> f = File()\n  >>> f.mimeType = \"text/plain\"\n  >>> with f.open(\"w\") as w:\n  ...    _ = w.write(b\"some text\")\n  >>> transaction.commit()\n\n  >>> getRootFolder()[\"abcdefg\"] = f\n\n  >>> transaction.commit()\n\nNow, let's request the download view of the file object and check the\nresult:\n\n  >>> print(http(b\"\"\"\n  ... GET /abcdefg/@@download HTTP/1.1\n  ... Authorization: Basic mgr:mgrpw\n  ... \"\"\", handle_errors=False))\n  HTTP/1.0 200 Ok\n  Content-Disposition: attachment; filename=\"abcdefg\"\n  Content-Length: 9\n  Content-Type: text/plain\n  <BLANKLINE>\n  some text\n\n\nThe Inline View\n===============\n\nIn addition, it is sometimes useful to view the data inline instead of\ndownloading it.  A basic inline view is provided for this use case.\nNote that browsers may decide not to display the image when this view\nis used and there is not page that it's being loaded into: if this\nview is being referenced directly via the URL, the browser may show\nnothing:\n\n  >>> print(http(b\"\"\"\n  ... GET /abcdefg/@@inline HTTP/1.1\n  ... Authorization: Basic mgr:mgrpw\n  ... \"\"\", handle_errors=False))\n  HTTP/1.0 200 Ok\n  Content-Disposition: inline; filename=\"abcdefg\"\n  Content-Length: 9\n  Content-Type: text/plain\n  <BLANKLINE>\n  some text\n\n\nThe Default Display View\n========================\n\nThis view is similar to the download and inline views, but no content\ndisposition is specified at all.  This lets the browser's default\nhandling of the data in the current context to be applied:\n\n  >>> print(http(b\"\"\"\n  ... GET /abcdefg/@@display HTTP/1.1\n  ... Authorization: Basic mgr:mgrpw\n  ... \"\"\", handle_errors=False))\n  HTTP/1.0 200 Ok\n  Content-Length: 9\n  Content-Type: text/plain\n  <BLANKLINE>\n  some text\n\nLarge Unicode Characters\n========================\n\nWe need to be able to support Unicode characters in the filename\ngreater than what Latin-1 (the encoding used by WSGI) can support.\n\nLet's rename a file to contain a high Unicode character and try to\ndownload it; the filename will be encoded:\n\n  >>> getRootFolder()[\"abcdefg\"].__name__ = u'Big \\U0001F4A9'\n  >>> transaction.commit()\n\n  >>> print(http(b\"\"\"\n  ... GET /abcdefg/@@download HTTP/1.1\n  ... Authorization: Basic mgr:mgrpw\n  ... \"\"\", handle_errors=False))\n  HTTP/1.0 200 Ok\n  Content-Disposition: attachment; filename=\"Big \u00f0\u009f\u0092\u00a9\"\n  Content-Length: 9\n  Content-Type: text/plain\n  <BLANKLINE>\n  some text\n\n\n======================\n Uploading a new file\n======================\n\nThere's a simple view for uploading a new file.  Let's try it:\n\n  >>> from io import BytesIO as StringIO\n\n  >>> sio = StringIO(b\"some text\")\n\n  >>> from zope.testbrowser.wsgi import Browser\n  >>> browser = Browser()\n  >>> browser.handleErrors = False\n  >>> browser.addHeader(\"Authorization\", \"Basic mgr:mgrpw\")\n  >>> browser.addHeader(\"Accept-Language\", \"en-US\")\n\n  >>> browser.open(\"http://localhost/@@+/zope.file.File\")\n\n  >>> ctrl = browser.getControl(name=\"form.data\")\n  >>> ctrl.add_file(\n  ...     sio, \"text/plain; charset=utf-8\", \"plain.txt\")\n  >>> browser.getControl(\"Add\").click()\n\nNow, let's request the download view of the file object and check the\nresult:\n\n  >>> print(http(b\"\"\"\n  ... GET /plain.txt/@@download HTTP/1.1\n  ... Authorization: Basic mgr:mgrpw\n  ... \"\"\", handle_errors=False))\n  HTTP/1.0 200 Ok\n  Content-Disposition: attachment; filename=\"plain.txt\"\n  Content-Length: 9\n  Content-Type: text/plain;charset=utf-8\n  <BLANKLINE>\n  some text\n\nWe'll peek into the database to make sure the object implements the\nexpected MIME type interface:\n\n  >>> from zope.mimetype import types\n  >>> ob = getRootFolder()[\"plain.txt\"]\n  >>> types.IContentTypeTextPlain.providedBy(ob)\n  True\n\nWe can upload new data into our file object as well:\n\n  >>> sio = StringIO(b\"new text\")\n  >>> browser.open(\"http://localhost/plain.txt/@@edit.html\")\n\n  >>> ctrl = browser.getControl(name=\"form.data\")\n  >>> ctrl.add_file(\n  ...     sio, \"text/plain; charset=utf-8\", \"stuff.txt\")\n  >>> browser.getControl(\"Edit\").click()\n\nNow, let's request the download view of the file object and check the\nresult:\n\n  >>> print(http(b\"\"\"\n  ... GET /plain.txt/@@download HTTP/1.1\n  ... Authorization: Basic mgr:mgrpw\n  ... \"\"\", handle_errors=False))\n  HTTP/1.0 200 Ok\n  Content-Disposition: attachment; filename=\"plain.txt\"\n  Content-Length: 8\n  Content-Type: text/plain;charset=utf-8\n  <BLANKLINE>\n  new text\n\nIf we upload a file that has imprecise content type information (as we\nexpect from browsers generally, and MSIE most significantly), we can\nsee that the MIME type machinery will improve the information where\npossible:\n\n  >>> sio = StringIO(b\"<?xml version='1.0' encoding='utf-8'?>\\n\"\n  ...                b\"<html>...</html>\\n\")\n\n  >>> browser.open(\"http://localhost/@@+/zope.file.File\")\n\n  >>> ctrl = browser.getControl(name=\"form.data\")\n  >>> ctrl.add_file(\n  ...     sio, \"text/html; charset=utf-8\", \"simple.html\")\n  >>> browser.getControl(\"Add\").click()\n\nAgain, we'll request the download view of the file object and check\nthe result:\n\n  >>> print(http(b\"\"\"\n  ... GET /simple.html/@@download HTTP/1.1\n  ... Authorization: Basic mgr:mgrpw\n  ... \"\"\", handle_errors=False))\n  HTTP/1.0 200 Ok\n  Content-Disposition: attachment; filename=\"simple.html\"\n  Content-Length: 56\n  Content-Type: application/xhtml+xml;charset=utf-8\n  <BLANKLINE>\n  <?xml version='1.0' encoding='utf-8'?>\n  <html>...</html>\n  <BLANKLINE>\n\nFurther, if a browser is bad and sends a full path as the file name (as\nsometimes happens in many browsers, apparently), the name is correctly\ntruncated and changed.\n\n  >>> sio = StringIO(b\"<?xml version='1.0' encoding='utf-8'?>\\n\"\n  ...                b\"<html>...</html>\\n\")\n\n  >>> browser.open(\"http://localhost/@@+/zope.file.File\")\n\n  >>> ctrl = browser.getControl(name=\"form.data\")\n  >>> ctrl.add_file(\n  ...     sio, \"text/html; charset=utf-8\", r\"C:\\Documents and Settings\\Joe\\naughty name.html\")\n  >>> browser.getControl(\"Add\").click()\n\n\nAgain, we'll request the download view of the file object and check\nthe result:\n\n  >>> print(http(b\"\"\"\n  ... GET /naughty%20name.html/@@download HTTP/1.1\n  ... Authorization: Basic mgr:mgrpw\n  ... \"\"\", handle_errors=False))\n  HTTP/1.0 200 Ok\n  Content-Disposition: attachment; filename=\"naughty name.html\"\n  Content-Length: 56\n  Content-Type: application/xhtml+xml;charset=utf-8\n  <BLANKLINE>\n  <?xml version='1.0' encoding='utf-8'?>\n  <html>...</html>\n  <BLANKLINE>\n\nIn zope.file <= 0.5.0, a redundant ObjectCreatedEvent was fired in the\nUpload view.  We'll demonstrate that this is no longer the case.\n\n  >>> import zope.component\n  >>> from zope.file.interfaces import IFile\n  >>> from zope.lifecycleevent import IObjectCreatedEvent\n\nWe'll register a subscriber for IObjectCreatedEvent that simply increments\na counter.\n\n  >>> count = 0\n  >>> def inc(*args):\n  ...   global count; count += 1\n  >>> zope.component.provideHandler(inc, (IFile, IObjectCreatedEvent))\n\n  >>> browser.open(\"http://localhost/@@+/zope.file.File\")\n\n  >>> ctrl = browser.getControl(name=\"form.data\")\n  >>> sio = StringIO(b\"some data\")\n  >>> ctrl.add_file(\n  ...     sio, \"text/html; charset=utf-8\", \"name.html\")\n  >>> browser.getControl(\"Add\").click()\n\nThe subscriber was called only once.\n\n  >>> print(count)\n  1\n\n\n====================================\n Content type and encoding controls\n====================================\n\nFiles provide a view that supports controlling the MIME content type\nand, where applicable, the content encoding.  Content encoding is\napplicable based on the specific content type of the file.\n\nLet's demonstrate the behavior of the form with a simple bit of\ncontent.  We'll upload a bit of HTML as a sample document:\n\n  >>> from io import BytesIO\n  >>> sio = BytesIO(b\"A <sub>little</sub> HTML.\"\n  ...               b\"  There's one 8-bit Latin-1 character: \\xd8.\")\n\n  >>> from zope.testbrowser.wsgi import Browser\n  >>> browser = Browser()\n  >>> browser.handleErrors = False\n  >>> browser.addHeader(\"Authorization\", \"Basic mgr:mgrpw\")\n  >>> browser.addHeader(\"Accept-Language\", \"en-US\")\n  >>> browser.open(\"http://localhost/@@+/zope.file.File\")\n\n  >>> ctrl = browser.getControl(name=\"form.data\")\n  >>> ctrl.add_file(\n  ...     sio, \"text/html\", \"sample.html\")\n  >>> browser.getControl(\"Add\").click()\n\nWe can see that the MIME handlers have marked this as HTML content:\n\n  >>> import zope.mimetype.interfaces\n  >>> import zope.mimetype.mtypes\n\n  >>> file = getRootFolder()[u\"sample.html\"]\n  >>> zope.mimetype.mtypes.IContentTypeTextHtml.providedBy(file)\n  True\n\nIt's important to note that this also means the content is encoded\ntext:\n\n  >>> zope.mimetype.interfaces.IContentTypeEncoded.providedBy(file)\n  True\n\nThe \"Content Type\" page will show us the MIME type and encoding that\nhave been selected:\n\n  >>> browser.getLink(\"sample.html\").click()\n  >>> browser.getLink(\"Content Type\").click()\n\n  >>> browser.getControl(name=\"form.mimeType\").value\n  ['zope.mimetype.mtypes.IContentTypeTextHtml']\n\nThe empty string value indicates that we have no encoding\ninformation:\n\n  >>> ctrl = browser.getControl(name=\"form.encoding\")\n  >>> print(ctrl.value)\n  ['']\n\nLet's now set the encoding value to an old favorite, Latin-1:\n\n  >>> ctrl.value = [\"iso-8859-1\"]\n  >>> browser.handleErrors = False\n  >>> browser.getControl(\"Save\").click()\n\nWe now see the updated value in the form, and can check the value in\nthe MIME content-type parameters on the object:\n\n  >>> ctrl = browser.getControl(name=\"form.encoding\")\n  >>> print(ctrl.value)\n  ['iso-8859-1']\n\n  >>> file = getRootFolder()[\"sample.html\"]\n  >>> file.parameters\n  {'charset': 'iso-8859-1'}\n\nSomething more interesting is that we can now use a non-encoded\ncontent type, and the encoding field will be removed from the form:\n\n  >>> ctrl = browser.getControl(name=\"form.mimeType\")\n  >>> ctrl.value = [\"zope.mimetype.mtypes.IContentTypeImageTiff\"]\n  >>> browser.getControl(\"Save\").click()\n\n  >>> browser.getControl(name=\"form.encoding\")\n  Traceback (most recent call last):\n    ...\n  LookupError: name 'form.encoding'\n  ...\n\nIf we switch back to an encoded type, we see that our encoding wasn't\nlost:\n\n  >>> ctrl = browser.getControl(name=\"form.mimeType\")\n  >>> ctrl.value = [\"zope.mimetype.mtypes.IContentTypeTextHtml\"]\n  >>> browser.getControl(\"Save\").click()\n\n  >>> browser.getControl(name=\"form.encoding\").value\n  ['iso-8859-1']\n\nOn the other hand, if we try setting the encoding to something which\nsimply cannot decode the input data, we get an error message saying\nthat's not going to work, and no changes are saved:\n\n  >>> ctrl = browser.getControl(name=\"form.encoding\")\n  >>> ctrl.value = [\"utf-8\"]\n\n  >>> browser.getControl(\"Save\").click()\n\n  >>> print(browser.contents)\n  <...Selected encoding cannot decode document...\n\n\n=======================\n Presentation Adapters\n=======================\n\nObject size\n===========\n\nThe size of the file as presented in the contents view of a container is\nprovided using an adapter implementing the `zope.size.interfaces.ISized`\ninterface. Such an adapter is available for the file object.\n\nLet's do some imports and create a new file object:\n\n  >>> from zope.file.file import File\n  >>> from zope.file.browser import Sized\n  >>> from zope.size.interfaces import ISized\n\n  >>> f = File()\n  >>> f.size\n  0\n\n  >>> s = Sized(f)\n  >>> ISized.providedBy(s)\n  True\n  >>> s.sizeForSorting()\n  ('byte', 0)\n  >>> s.sizeForDisplay()\n  u'0 KB'\n\nLet's add some content to the file:\n\n  >>> with f.open('w') as w:\n  ...    _ =  w.write(b\"some text\")\n\nThe sized adapter now reflects the updated size:\n\n  >>> s.sizeForSorting()\n  ('byte', 9)\n  >>> s.sizeForDisplay()\n  u'1 KB'\n\nLet's try again with a larger file size:\n\n  >>> with f.open('w') as w:\n  ...    _ = w.write(b\"x\" * (1024*1024+10))\n\n  >>> s.sizeForSorting()\n  ('byte', 1048586)\n  >>> m = s.sizeForDisplay()\n  >>> m\n  u'${size} MB'\n  >>> m.mapping\n  {'size': '1.00'}\n\nAnd still a bigger size:\n\n  >>> with f.open('w') as w:\n  ...    _ = w.write(b\"x\" * 3*512*1024)\n\n  >>> s.sizeForSorting()\n  ('byte', 1572864)\n  >>> m = s.sizeForDisplay()\n  >>> m\n  u'${size} MB'\n  >>> m.mapping\n  {'size': '1.50'}\n\n\n=========\n CHANGES\n=========\n\n1.2.0 (2020-03-06)\n==================\n\n- Add support for Python 3.7 and 3.8\n\n- Drop Python 3.4 support.\n\n\n1.1.0 (2017-09-30)\n==================\n\n- Move more browser dependencies to the ``browser`` extra.\n\n- Begin testing PyPy3 on Travis CI.\n\n\n1.0.0 (2017-04-25)\n==================\n\n- Remove unneeded test dependencies zope.app.server,\n  zope.app.component, zope.app.container, and others.\n\n- Update to work with zope.testbrowser 5.\n\n- Add PyPy support.\n\n- Add support for Python 3.4, 3.5 and 3.6.\n  See `PR 5 <https://github.com/zopefoundation/zope.file/pull/5>`_.\n\n0.6.2 (2012-06-04)\n==================\n\n- Moved menu-oriented registrations into new menus.zcml. This is now\n  loaded if zope.app.zcmlfiles is available only.\n\n- Increase test coverage.\n\n0.6.1 (2012-01-26)\n==================\n\n- Declared more dependencies.\n\n\n0.6.0 (2010-09-16)\n==================\n\n- Bug fix: remove duplicate firing of ObjectCreatedEvent in\n  zope.file.upload.Upload (the event is already fired in its base class,\n  zope.formlib.form.AddForm).\n\n- Move browser-related zcml to `browser.zcml` so that it easier for\n  applications to exclude it.\n\n- Import content-type parser from zope.contenttype, adding a dependency on\n  that package.\n\n- Removed undeclared dependency on zope.app.container, depend on zope.browser.\n\n- Using Python's ``doctest`` module instead of deprecated\n  ``zope.testing.doctest``.\n\n0.5.0 (2009-07-23)\n==================\n\n- Change package's mailing list address to zope-dev at zope.org instead\n  of the retired one.\n\n- Made tests compatible with ZODB 3.9.\n\n- Removed not needed install requirement declarations.\n\n\n0.4.0 (2009-01-31)\n==================\n\n- `openDetached` is now protected by zope.View instead of zope.ManageContent.\n\n- Use zope.container instead of zope.app.container.\n\n0.3.0 (2007-11-01)\n==================\n\n- Package data update.\n\n0.2.0 (2007-04-18)\n==================\n\n- Fix code for Publisher version 3.4.\n\n0.1.0 (2007-04-18)\n==================\n\n- Initial release.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/zopefoundation/zope.file", "keywords": "zope3 web html ui file pattern", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "zope.file", "package_url": "https://pypi.org/project/zope.file/", "platform": "", "project_url": "https://pypi.org/project/zope.file/", "project_urls": {"Homepage": "https://github.com/zopefoundation/zope.file"}, "release_url": "https://pypi.org/project/zope.file/1.2.0/", "requires_dist": ["setuptools", "ZODB", "zope.annotation", "zope.component", "zope.container", "zope.contenttype", "zope.event", "zope.filerepresentation", "zope.i18nmessageid", "zope.lifecycleevent", "zope.interface", "zope.location", "zope.mimetype (>=2.3.0)", "zope.schema", "zope.security (>=4.1.0)", "zope.size", "zope.browser ; extra == 'browser'", "zope.browserresource ; extra == 'browser'", "zope.publisher (>=4.3.1) ; extra == 'browser'", "zope.formlib ; extra == 'browser'", "zope.browser ; extra == 'test'", "zope.browserresource ; extra == 'test'", "zope.publisher (>=4.3.1) ; extra == 'test'", "zope.formlib ; extra == 'test'", "zope.app.basicskin (>=4.0.0) ; extra == 'test'", "zope.app.http ; extra == 'test'", "zope.app.pagetemplate (>=4.0.0) ; extra == 'test'", "zope.app.principalannotation ; extra == 'test'", "zope.app.publication ; extra == 'test'", "zope.app.wsgi ; extra == 'test'", "zope.applicationcontrol ; extra == 'test'", "zope.copypastemove ; extra == 'test'", "zope.browsermenu ; extra == 'test'", "zope.login ; extra == 'test'", "zope.password ; extra == 'test'", "zope.proxy (>=4.2.1) ; extra == 'test'", "zope.principalregistry ; extra == 'test'", "zope.securitypolicy ; extra == 'test'", "zope.testbrowser (>=5.2) ; extra == 'test'", "zope.testrunner ; extra == 'test'"], "requires_python": "", "summary": "Efficient File Implementation for Zope Applications", "version": "1.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>The <cite>zope.file</cite> package provides a content object used to store a\nfile. The interface supports efficient upload and download.</p>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#file-object\" id=\"id12\" rel=\"nofollow\">File Object</a></li>\n<li><a href=\"#downloading-file-objects\" id=\"id13\" rel=\"nofollow\">Downloading File Objects</a><ul>\n<li><a href=\"#headers\" id=\"id14\" rel=\"nofollow\">Headers</a></li>\n<li><a href=\"#body\" id=\"id15\" rel=\"nofollow\">Body</a></li>\n<li><a href=\"#the-download-view\" id=\"id16\" rel=\"nofollow\">The Download View</a></li>\n<li><a href=\"#the-inline-view\" id=\"id17\" rel=\"nofollow\">The Inline View</a></li>\n<li><a href=\"#the-default-display-view\" id=\"id18\" rel=\"nofollow\">The Default Display View</a></li>\n<li><a href=\"#large-unicode-characters\" id=\"id19\" rel=\"nofollow\">Large Unicode Characters</a></li>\n</ul>\n</li>\n<li><a href=\"#uploading-a-new-file\" id=\"id20\" rel=\"nofollow\">Uploading a new file</a></li>\n<li><a href=\"#content-type-and-encoding-controls\" id=\"id21\" rel=\"nofollow\">Content type and encoding controls</a></li>\n<li><a href=\"#presentation-adapters\" id=\"id22\" rel=\"nofollow\">Presentation Adapters</a></li>\n<li><a href=\"#changes\" id=\"id23\" rel=\"nofollow\">CHANGES</a><ul>\n<li><a href=\"#id1\" id=\"id24\" rel=\"nofollow\">1.2.0 (2020-03-06)</a></li>\n<li><a href=\"#id2\" id=\"id25\" rel=\"nofollow\">1.1.0 (2017-09-30)</a></li>\n<li><a href=\"#id3\" id=\"id26\" rel=\"nofollow\">1.0.0 (2017-04-25)</a></li>\n<li><a href=\"#id4\" id=\"id27\" rel=\"nofollow\">0.6.2 (2012-06-04)</a></li>\n<li><a href=\"#id5\" id=\"id28\" rel=\"nofollow\">0.6.1 (2012-01-26)</a></li>\n<li><a href=\"#id6\" id=\"id29\" rel=\"nofollow\">0.6.0 (2010-09-16)</a></li>\n<li><a href=\"#id7\" id=\"id30\" rel=\"nofollow\">0.5.0 (2009-07-23)</a></li>\n<li><a href=\"#id8\" id=\"id31\" rel=\"nofollow\">0.4.0 (2009-01-31)</a></li>\n<li><a href=\"#id9\" id=\"id32\" rel=\"nofollow\">0.3.0 (2007-11-01)</a></li>\n<li><a href=\"#id10\" id=\"id33\" rel=\"nofollow\">0.2.0 (2007-04-18)</a></li>\n<li><a href=\"#id11\" id=\"id34\" rel=\"nofollow\">0.1.0 (2007-04-18)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"file-object\">\n<h2><a href=\"#id12\" rel=\"nofollow\">File Object</a></h2>\n<p>The <cite>zope.file</cite> package provides a content object used to store a\nfile.  The interface supports efficient upload and download.  Let\u2019s\ncreate an instance:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.file.file import File\n&gt;&gt;&gt; f = File()\n</pre>\n</blockquote>\n<p>The object provides a limited number of data attributes.  The\n<cite>mimeType</cite> attribute is used to store the preferred MIME\ncontent-type value for the data:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; f.mimeType\n</pre>\n<pre>&gt;&gt;&gt; f.mimeType = \"text/plain\"\n&gt;&gt;&gt; f.mimeType\n'text/plain'\n</pre>\n<pre>&gt;&gt;&gt; f.mimeType = \"application/postscript\"\n&gt;&gt;&gt; f.mimeType\n'application/postscript'\n</pre>\n</blockquote>\n<p>The <cite>parameters</cite> attribute is a mapping used to store the content-type\nparameters.  This is where encoding information can be found when\napplicable (and available):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; f.parameters\n{}\n&gt;&gt;&gt; f.parameters[\"charset\"] = \"us-ascii\"\n&gt;&gt;&gt; f.parameters[\"charset\"]\n'us-ascii'\n</pre>\n</blockquote>\n<p>Both, <cite>parameters</cite> and <cite>mimeType</cite> can optionally also be set when\ncreating a <cite>File</cite> object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; f2 = File(mimeType = \"application/octet-stream\",\n...           parameters = dict(charset = \"utf-8\"))\n&gt;&gt;&gt; f2.mimeType\n'application/octet-stream'\n</pre>\n<pre>&gt;&gt;&gt; f2.parameters[\"charset\"]\n'utf-8'\n</pre>\n</blockquote>\n<p>File objects also sport a <cite>size</cite> attribute that provides the number of\nbytes in the file:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; f.size\n0\n</pre>\n</blockquote>\n<p>The object supports efficient upload and download by providing all\naccess to content data through accessor objects that provide (subsets\nof) Python\u2019s file API.</p>\n<p>A file that hasn\u2019t been written to is empty.  We can get a reader by calling\n<cite>open()</cite>. Note that all blobs are binary, thus the mode always contains a\n\u2018b\u2019:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; r = f.open(\"r\")\n&gt;&gt;&gt; r.mode\n'rb'\n</pre>\n</blockquote>\n<p>The <cite>read()</cite> method can be called with a non-negative integer argument\nto specify how many bytes to read, or with a negative or omitted\nargument to read to the end of the file:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; r.read(10)\n''\n&gt;&gt;&gt; r.read()\n''\n&gt;&gt;&gt; r.read(-1)\n''\n</pre>\n</blockquote>\n<p>Once the accessor has been closed, we can no longer read from it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; r.close()\n&gt;&gt;&gt; r.read()\nTraceback (most recent call last):\nValueError: I/O operation on closed file\n</pre>\n</blockquote>\n<p>We\u2019ll see that readers are more interesting once there\u2019s data in the\nfile object.</p>\n<p>Data is added by using a writer, which is also created using the\n<cite>open()</cite> method on the file, but requesting a write file mode:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; w = f.open(\"w\")\n&gt;&gt;&gt; w.mode\n'wb'\n</pre>\n</blockquote>\n<p>The <cite>write()</cite> method is used to add data to the file, but note that\nthe data may be buffered in the writer:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; _ = w.write(b\"some text \")\n&gt;&gt;&gt; _ = w.write(b\"more text\")\n</pre>\n</blockquote>\n<p>The <cite>flush()</cite> method ensure that the data written so far is written to\nthe file object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; w.flush()\n</pre>\n</blockquote>\n<p>We need to close the file first before determining its file size</p>\n<blockquote>\n<pre>&gt;&gt;&gt; w.close()\n&gt;&gt;&gt; f.size\n19\n</pre>\n</blockquote>\n<p>We can now use a reader to see that the data has been written to the\nfile:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; w = f.open(\"w\")\n&gt;&gt;&gt; _ = w.write(b'some text more text')\n&gt;&gt;&gt; _ = w.write(b\" still more\")\n&gt;&gt;&gt; w.close()\n&gt;&gt;&gt; f.size\n30\n</pre>\n</blockquote>\n<p>Now create a new reader and let\u2019s perform some seek operations.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; r = f.open()\n</pre>\n</blockquote>\n<p>The reader also has a <cite>seek()</cite> method that can be used to back up or\nskip forward in the data stream.  Simply passing an offset argument,\nwe see that the current position is moved to that offset from the\nstart of the file:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; _ = r.seek(20)\n&gt;&gt;&gt; r.read()\n'still more'\n</pre>\n</blockquote>\n<p>That\u2019s equivalent to passing 0 as the <cite>whence</cite> argument:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; _ = r.seek(20, 0)\n&gt;&gt;&gt; r.read()\n'still more'\n</pre>\n</blockquote>\n<p>We can skip backward and forward relative to the current position by\npassing 1 for <cite>whence</cite>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; _ = r.seek(-10, 1)\n&gt;&gt;&gt; r.read(5)\n'still'\n&gt;&gt;&gt; _ = r.seek(2, 1)\n&gt;&gt;&gt; r.read()\n'ore'\n</pre>\n</blockquote>\n<p>We can skip to some position backward from the end of the file using\nthe value 2 for <cite>whence</cite>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; _ = r.seek(-10, 2)\n&gt;&gt;&gt; r.read()\n'still more'\n</pre>\n<pre>&gt;&gt;&gt; _ = r.seek(0)\n&gt;&gt;&gt; _ = r.seek(-4, 2)\n&gt;&gt;&gt; r.read()\n'more'\n</pre>\n<pre>&gt;&gt;&gt; r.close()\n</pre>\n</blockquote>\n<p>Attempting to write to a closed writer raises an exception:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; w = f.open('w')\n&gt;&gt;&gt; w.close()\n</pre>\n<pre>&gt;&gt;&gt; w.write(b'foobar')\nTraceback (most recent call last):\nValueError: I/O operation on closed file\n</pre>\n</blockquote>\n<p>Similarly, using <cite>seek()</cite> or <cite>tell()</cite> on a closed reader raises an\nexception:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; r.close()\n&gt;&gt;&gt; _ = r.seek(0)\nTraceback (most recent call last):\nValueError: I/O operation on closed file\n</pre>\n<pre>&gt;&gt;&gt; r.tell()\nTraceback (most recent call last):\nValueError: I/O operation on closed file\n</pre>\n</blockquote>\n</div>\n<div id=\"downloading-file-objects\">\n<h2><a href=\"#id13\" rel=\"nofollow\">Downloading File Objects</a></h2>\n<p>The file content type provides a view used to download the file,\nregardless of the browser\u2019s default behavior for the content type.\nThis relies on browser support for the Content-Disposition header.</p>\n<p>The download support is provided by two distinct objects:  A view that\nprovides the download support using the information in the content\nobject, and a result object that can be used to implement a file\ndownload by other views.  The view can override the content-type or the\nfilename suggested to the browser using the standard IResponse.setHeader\nmethod.</p>\n<p>Note that result objects are intended to be used once and then\ndiscarded.</p>\n<p>Let\u2019s start by creating a file object we can use to demonstrate the\ndownload support:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; from zope.file.file import File\n&gt;&gt;&gt; f = File()\n&gt;&gt;&gt; getRootFolder()['file'] = f\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<div id=\"headers\">\n<h3><a href=\"#id14\" rel=\"nofollow\">Headers</a></h3>\n<p>Now, let\u2019s get the headers for this file.  We use a utility function called\n<tt>getHeaders</tt>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.file.download import getHeaders\n&gt;&gt;&gt; headers = getHeaders(f, contentDisposition='attachment')\n</pre>\n</blockquote>\n<p>Since there\u2019s no suggested download filename on the file, the\nContent-Disposition header doesn\u2019t specify one, but does indicate that\nthe response body be treated as a file to save rather than to apply\nthe default handler for the content type:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(headers)\n[('Content-Disposition', 'attachment; filename=\"file\"'),\n ('Content-Length', '0'),\n ('Content-Type', 'application/octet-stream')]\n</pre>\n</blockquote>\n<p>Note that a default content type of \u2018application/octet-stream\u2019 is\nused.</p>\n<p>If the file object specifies a content type, that\u2019s used in the headers\nby default:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; f.mimeType = \"text/plain\"\n&gt;&gt;&gt; headers = getHeaders(f, contentDisposition='attachment')\n&gt;&gt;&gt; sorted(headers)\n[('Content-Disposition', 'attachment; filename=\"file\"'),\n ('Content-Length', '0'),\n ('Content-Type', 'text/plain')]\n</pre>\n</blockquote>\n<p>Alternatively, a content type can be specified to <tt>getHeaders</tt>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; headers = getHeaders(f, contentType=\"text/xml\",\n...                      contentDisposition='attachment')\n&gt;&gt;&gt; sorted(headers)\n[('Content-Disposition', 'attachment; filename=\"file\"'),\n ('Content-Length', '0'),\n ('Content-Type', 'text/xml')]\n</pre>\n</blockquote>\n<p>The filename provided to the browser can be controlled similarly.  If\nthe content object provides one, it will be used by default:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; headers = getHeaders(f, contentDisposition='attachment')\n&gt;&gt;&gt; sorted(headers)\n[('Content-Disposition', 'attachment; filename=\"file\"'),\n ('Content-Length', '0'),\n ('Content-Type', 'text/plain')]\n</pre>\n</blockquote>\n<p>Providing an alternate name to <tt>getHeaders</tt> overrides the download\nname from the file:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; headers = getHeaders(f, downloadName=\"foo.txt\",\n...                      contentDisposition='attachment')\n&gt;&gt;&gt; sorted(headers)\n[('Content-Disposition', 'attachment; filename=\"foo.txt\"'),\n ('Content-Length', '0'),\n ('Content-Type', 'text/plain')]\n</pre>\n</blockquote>\n<p>The default Content-Disposition header can be overridden by providing\nan argument to <tt>getHeaders</tt>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; headers = getHeaders(f, contentDisposition=\"inline\")\n&gt;&gt;&gt; sorted(headers)\n[('Content-Disposition', 'inline; filename=\"file\"'),\n ('Content-Length', '0'),\n ('Content-Type', 'text/plain')]\n</pre>\n</blockquote>\n<p>If the <tt>contentDisposition</tt> argument is not provided, none will be\nincluded in the headers:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; headers = getHeaders(f)\n&gt;&gt;&gt; sorted(headers)\n[('Content-Length', '0'),\n ('Content-Type', 'text/plain')]\n</pre>\n</blockquote>\n</div>\n<div id=\"body\">\n<h3><a href=\"#id15\" rel=\"nofollow\">Body</a></h3>\n<p>We use DownloadResult to deliver the content to the browser.  Since\nthere\u2019s no data in this file, there are no body chunks:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; transaction.commit()\n&gt;&gt;&gt; from zope.file.download import DownloadResult\n&gt;&gt;&gt; result = DownloadResult(f)\n&gt;&gt;&gt; list(result)\n[]\n</pre>\n</blockquote>\n<p>We still need to see how non-empty files are handled.  Let\u2019s write\nsome data to our file object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; with f.open(\"w\") as w:\n...    _ = w.write(b\"some text\")\n...    w.flush()\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Now we can create a result object and see if we get the data we\nexpect:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; result = DownloadResult(f)\n&gt;&gt;&gt; L = list(result)\n&gt;&gt;&gt; b\"\".join(L)\n'some text'\n</pre>\n</blockquote>\n<p>If the body content is really large, the iterator may provide more\nthan one chunk of data:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; with f.open(\"w\") as w:\n...   _ = w.write(b\"*\" * 1024 * 1024)\n...   w.flush()\n&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; result = DownloadResult(f)\n&gt;&gt;&gt; L = list(result)\n&gt;&gt;&gt; len(L) &gt; 1\nTrue\n</pre>\n</blockquote>\n<p>Once iteration over the body has completed, further iteration will not\nyield additional data:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(result)\n[]\n</pre>\n</blockquote>\n</div>\n<div id=\"the-download-view\">\n<h3><a href=\"#id16\" rel=\"nofollow\">The Download View</a></h3>\n<p>Now that we\u2019ve seen the <tt>getHeaders</tt> function and the result object,\nlet\u2019s take a look at the basic download view that uses them.  We\u2019ll need\nto add a file object where we can get to it using a browser:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; f = File()\n&gt;&gt;&gt; f.mimeType = \"text/plain\"\n&gt;&gt;&gt; with f.open(\"w\") as w:\n...    _ = w.write(b\"some text\")\n&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; getRootFolder()[\"abcdefg\"] = f\n</pre>\n<pre>&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Now, let\u2019s request the download view of the file object and check the\nresult:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(http(b\"\"\"\n... GET /abcdefg/@@download HTTP/1.1\n... Authorization: Basic mgr:mgrpw\n... \"\"\", handle_errors=False))\nHTTP/1.0 200 Ok\nContent-Disposition: attachment; filename=\"abcdefg\"\nContent-Length: 9\nContent-Type: text/plain\n&lt;BLANKLINE&gt;\nsome text\n</pre>\n</blockquote>\n</div>\n<div id=\"the-inline-view\">\n<h3><a href=\"#id17\" rel=\"nofollow\">The Inline View</a></h3>\n<p>In addition, it is sometimes useful to view the data inline instead of\ndownloading it.  A basic inline view is provided for this use case.\nNote that browsers may decide not to display the image when this view\nis used and there is not page that it\u2019s being loaded into: if this\nview is being referenced directly via the URL, the browser may show\nnothing:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(http(b\"\"\"\n... GET /abcdefg/@@inline HTTP/1.1\n... Authorization: Basic mgr:mgrpw\n... \"\"\", handle_errors=False))\nHTTP/1.0 200 Ok\nContent-Disposition: inline; filename=\"abcdefg\"\nContent-Length: 9\nContent-Type: text/plain\n&lt;BLANKLINE&gt;\nsome text\n</pre>\n</blockquote>\n</div>\n<div id=\"the-default-display-view\">\n<h3><a href=\"#id18\" rel=\"nofollow\">The Default Display View</a></h3>\n<p>This view is similar to the download and inline views, but no content\ndisposition is specified at all.  This lets the browser\u2019s default\nhandling of the data in the current context to be applied:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(http(b\"\"\"\n... GET /abcdefg/@@display HTTP/1.1\n... Authorization: Basic mgr:mgrpw\n... \"\"\", handle_errors=False))\nHTTP/1.0 200 Ok\nContent-Length: 9\nContent-Type: text/plain\n&lt;BLANKLINE&gt;\nsome text\n</pre>\n</blockquote>\n</div>\n<div id=\"large-unicode-characters\">\n<h3><a href=\"#id19\" rel=\"nofollow\">Large Unicode Characters</a></h3>\n<p>We need to be able to support Unicode characters in the filename\ngreater than what Latin-1 (the encoding used by WSGI) can support.</p>\n<p>Let\u2019s rename a file to contain a high Unicode character and try to\ndownload it; the filename will be encoded:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; getRootFolder()[\"abcdefg\"].__name__ = u'Big \\U0001F4A9'\n&gt;&gt;&gt; transaction.commit()\n</pre>\n<pre>&gt;&gt;&gt; print(http(b\"\"\"\n... GET /abcdefg/@@download HTTP/1.1\n... Authorization: Basic mgr:mgrpw\n... \"\"\", handle_errors=False))\nHTTP/1.0 200 Ok\nContent-Disposition: attachment; filename=\"Big \u00f0\u009f\u0092\u00a9\"\nContent-Length: 9\nContent-Type: text/plain\n&lt;BLANKLINE&gt;\nsome text\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"uploading-a-new-file\">\n<h2><a href=\"#id20\" rel=\"nofollow\">Uploading a new file</a></h2>\n<p>There\u2019s a simple view for uploading a new file.  Let\u2019s try it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from io import BytesIO as StringIO\n</pre>\n<pre>&gt;&gt;&gt; sio = StringIO(b\"some text\")\n</pre>\n<pre>&gt;&gt;&gt; from zope.testbrowser.wsgi import Browser\n&gt;&gt;&gt; browser = Browser()\n&gt;&gt;&gt; browser.handleErrors = False\n&gt;&gt;&gt; browser.addHeader(\"Authorization\", \"Basic mgr:mgrpw\")\n&gt;&gt;&gt; browser.addHeader(\"Accept-Language\", \"en-US\")\n</pre>\n<pre>&gt;&gt;&gt; browser.open(\"http://localhost/@@+/zope.file.File\")\n</pre>\n<pre>&gt;&gt;&gt; ctrl = browser.getControl(name=\"form.data\")\n&gt;&gt;&gt; ctrl.add_file(\n...     sio, \"text/plain; charset=utf-8\", \"plain.txt\")\n&gt;&gt;&gt; browser.getControl(\"Add\").click()\n</pre>\n</blockquote>\n<p>Now, let\u2019s request the download view of the file object and check the\nresult:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(http(b\"\"\"\n... GET /plain.txt/@@download HTTP/1.1\n... Authorization: Basic mgr:mgrpw\n... \"\"\", handle_errors=False))\nHTTP/1.0 200 Ok\nContent-Disposition: attachment; filename=\"plain.txt\"\nContent-Length: 9\nContent-Type: text/plain;charset=utf-8\n&lt;BLANKLINE&gt;\nsome text\n</pre>\n</blockquote>\n<p>We\u2019ll peek into the database to make sure the object implements the\nexpected MIME type interface:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.mimetype import types\n&gt;&gt;&gt; ob = getRootFolder()[\"plain.txt\"]\n&gt;&gt;&gt; types.IContentTypeTextPlain.providedBy(ob)\nTrue\n</pre>\n</blockquote>\n<p>We can upload new data into our file object as well:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sio = StringIO(b\"new text\")\n&gt;&gt;&gt; browser.open(\"http://localhost/plain.txt/@@edit.html\")\n</pre>\n<pre>&gt;&gt;&gt; ctrl = browser.getControl(name=\"form.data\")\n&gt;&gt;&gt; ctrl.add_file(\n...     sio, \"text/plain; charset=utf-8\", \"stuff.txt\")\n&gt;&gt;&gt; browser.getControl(\"Edit\").click()\n</pre>\n</blockquote>\n<p>Now, let\u2019s request the download view of the file object and check the\nresult:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(http(b\"\"\"\n... GET /plain.txt/@@download HTTP/1.1\n... Authorization: Basic mgr:mgrpw\n... \"\"\", handle_errors=False))\nHTTP/1.0 200 Ok\nContent-Disposition: attachment; filename=\"plain.txt\"\nContent-Length: 8\nContent-Type: text/plain;charset=utf-8\n&lt;BLANKLINE&gt;\nnew text\n</pre>\n</blockquote>\n<p>If we upload a file that has imprecise content type information (as we\nexpect from browsers generally, and MSIE most significantly), we can\nsee that the MIME type machinery will improve the information where\npossible:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sio = StringIO(b\"&lt;?xml version='1.0' encoding='utf-8'?&gt;\\n\"\n...                b\"&lt;html&gt;...&lt;/html&gt;\\n\")\n</pre>\n<pre>&gt;&gt;&gt; browser.open(\"http://localhost/@@+/zope.file.File\")\n</pre>\n<pre>&gt;&gt;&gt; ctrl = browser.getControl(name=\"form.data\")\n&gt;&gt;&gt; ctrl.add_file(\n...     sio, \"text/html; charset=utf-8\", \"simple.html\")\n&gt;&gt;&gt; browser.getControl(\"Add\").click()\n</pre>\n</blockquote>\n<p>Again, we\u2019ll request the download view of the file object and check\nthe result:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(http(b\"\"\"\n... GET /simple.html/@@download HTTP/1.1\n... Authorization: Basic mgr:mgrpw\n... \"\"\", handle_errors=False))\nHTTP/1.0 200 Ok\nContent-Disposition: attachment; filename=\"simple.html\"\nContent-Length: 56\nContent-Type: application/xhtml+xml;charset=utf-8\n&lt;BLANKLINE&gt;\n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;html&gt;...&lt;/html&gt;\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n<p>Further, if a browser is bad and sends a full path as the file name (as\nsometimes happens in many browsers, apparently), the name is correctly\ntruncated and changed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sio = StringIO(b\"&lt;?xml version='1.0' encoding='utf-8'?&gt;\\n\"\n...                b\"&lt;html&gt;...&lt;/html&gt;\\n\")\n</pre>\n<pre>&gt;&gt;&gt; browser.open(\"http://localhost/@@+/zope.file.File\")\n</pre>\n<pre>&gt;&gt;&gt; ctrl = browser.getControl(name=\"form.data\")\n&gt;&gt;&gt; ctrl.add_file(\n...     sio, \"text/html; charset=utf-8\", r\"C:\\Documents and Settings\\Joe\\naughty name.html\")\n&gt;&gt;&gt; browser.getControl(\"Add\").click()\n</pre>\n</blockquote>\n<p>Again, we\u2019ll request the download view of the file object and check\nthe result:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(http(b\"\"\"\n... GET /naughty%20name.html/@@download HTTP/1.1\n... Authorization: Basic mgr:mgrpw\n... \"\"\", handle_errors=False))\nHTTP/1.0 200 Ok\nContent-Disposition: attachment; filename=\"naughty name.html\"\nContent-Length: 56\nContent-Type: application/xhtml+xml;charset=utf-8\n&lt;BLANKLINE&gt;\n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;html&gt;...&lt;/html&gt;\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n<p>In zope.file &lt;= 0.5.0, a redundant ObjectCreatedEvent was fired in the\nUpload view.  We\u2019ll demonstrate that this is no longer the case.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from zope.file.interfaces import IFile\n&gt;&gt;&gt; from zope.lifecycleevent import IObjectCreatedEvent\n</pre>\n</blockquote>\n<p>We\u2019ll register a subscriber for IObjectCreatedEvent that simply increments\na counter.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; count = 0\n&gt;&gt;&gt; def inc(*args):\n...   global count; count += 1\n&gt;&gt;&gt; zope.component.provideHandler(inc, (IFile, IObjectCreatedEvent))\n</pre>\n<pre>&gt;&gt;&gt; browser.open(\"http://localhost/@@+/zope.file.File\")\n</pre>\n<pre>&gt;&gt;&gt; ctrl = browser.getControl(name=\"form.data\")\n&gt;&gt;&gt; sio = StringIO(b\"some data\")\n&gt;&gt;&gt; ctrl.add_file(\n...     sio, \"text/html; charset=utf-8\", \"name.html\")\n&gt;&gt;&gt; browser.getControl(\"Add\").click()\n</pre>\n</blockquote>\n<p>The subscriber was called only once.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print(count)\n1\n</pre>\n</blockquote>\n</div>\n<div id=\"content-type-and-encoding-controls\">\n<h2><a href=\"#id21\" rel=\"nofollow\">Content type and encoding controls</a></h2>\n<p>Files provide a view that supports controlling the MIME content type\nand, where applicable, the content encoding.  Content encoding is\napplicable based on the specific content type of the file.</p>\n<p>Let\u2019s demonstrate the behavior of the form with a simple bit of\ncontent.  We\u2019ll upload a bit of HTML as a sample document:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from io import BytesIO\n&gt;&gt;&gt; sio = BytesIO(b\"A &lt;sub&gt;little&lt;/sub&gt; HTML.\"\n...               b\"  There's one 8-bit Latin-1 character: \\xd8.\")\n</pre>\n<pre>&gt;&gt;&gt; from zope.testbrowser.wsgi import Browser\n&gt;&gt;&gt; browser = Browser()\n&gt;&gt;&gt; browser.handleErrors = False\n&gt;&gt;&gt; browser.addHeader(\"Authorization\", \"Basic mgr:mgrpw\")\n&gt;&gt;&gt; browser.addHeader(\"Accept-Language\", \"en-US\")\n&gt;&gt;&gt; browser.open(\"http://localhost/@@+/zope.file.File\")\n</pre>\n<pre>&gt;&gt;&gt; ctrl = browser.getControl(name=\"form.data\")\n&gt;&gt;&gt; ctrl.add_file(\n...     sio, \"text/html\", \"sample.html\")\n&gt;&gt;&gt; browser.getControl(\"Add\").click()\n</pre>\n</blockquote>\n<p>We can see that the MIME handlers have marked this as HTML content:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.mimetype.interfaces\n&gt;&gt;&gt; import zope.mimetype.mtypes\n</pre>\n<pre>&gt;&gt;&gt; file = getRootFolder()[u\"sample.html\"]\n&gt;&gt;&gt; zope.mimetype.mtypes.IContentTypeTextHtml.providedBy(file)\nTrue\n</pre>\n</blockquote>\n<p>It\u2019s important to note that this also means the content is encoded\ntext:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.mimetype.interfaces.IContentTypeEncoded.providedBy(file)\nTrue\n</pre>\n</blockquote>\n<p>The \u201cContent Type\u201d page will show us the MIME type and encoding that\nhave been selected:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; browser.getLink(\"sample.html\").click()\n&gt;&gt;&gt; browser.getLink(\"Content Type\").click()\n</pre>\n<pre>&gt;&gt;&gt; browser.getControl(name=\"form.mimeType\").value\n['zope.mimetype.mtypes.IContentTypeTextHtml']\n</pre>\n</blockquote>\n<p>The empty string value indicates that we have no encoding\ninformation:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ctrl = browser.getControl(name=\"form.encoding\")\n&gt;&gt;&gt; print(ctrl.value)\n['']\n</pre>\n</blockquote>\n<p>Let\u2019s now set the encoding value to an old favorite, Latin-1:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ctrl.value = [\"iso-8859-1\"]\n&gt;&gt;&gt; browser.handleErrors = False\n&gt;&gt;&gt; browser.getControl(\"Save\").click()\n</pre>\n</blockquote>\n<p>We now see the updated value in the form, and can check the value in\nthe MIME content-type parameters on the object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ctrl = browser.getControl(name=\"form.encoding\")\n&gt;&gt;&gt; print(ctrl.value)\n['iso-8859-1']\n</pre>\n<pre>&gt;&gt;&gt; file = getRootFolder()[\"sample.html\"]\n&gt;&gt;&gt; file.parameters\n{'charset': 'iso-8859-1'}\n</pre>\n</blockquote>\n<p>Something more interesting is that we can now use a non-encoded\ncontent type, and the encoding field will be removed from the form:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ctrl = browser.getControl(name=\"form.mimeType\")\n&gt;&gt;&gt; ctrl.value = [\"zope.mimetype.mtypes.IContentTypeImageTiff\"]\n&gt;&gt;&gt; browser.getControl(\"Save\").click()\n</pre>\n<pre>&gt;&gt;&gt; browser.getControl(name=\"form.encoding\")\nTraceback (most recent call last):\n  ...\nLookupError: name 'form.encoding'\n...\n</pre>\n</blockquote>\n<p>If we switch back to an encoded type, we see that our encoding wasn\u2019t\nlost:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ctrl = browser.getControl(name=\"form.mimeType\")\n&gt;&gt;&gt; ctrl.value = [\"zope.mimetype.mtypes.IContentTypeTextHtml\"]\n&gt;&gt;&gt; browser.getControl(\"Save\").click()\n</pre>\n<pre>&gt;&gt;&gt; browser.getControl(name=\"form.encoding\").value\n['iso-8859-1']\n</pre>\n</blockquote>\n<p>On the other hand, if we try setting the encoding to something which\nsimply cannot decode the input data, we get an error message saying\nthat\u2019s not going to work, and no changes are saved:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ctrl = browser.getControl(name=\"form.encoding\")\n&gt;&gt;&gt; ctrl.value = [\"utf-8\"]\n</pre>\n<pre>&gt;&gt;&gt; browser.getControl(\"Save\").click()\n</pre>\n<pre>&gt;&gt;&gt; print(browser.contents)\n&lt;...Selected encoding cannot decode document...\n</pre>\n</blockquote>\n</div>\n<div id=\"presentation-adapters\">\n<h2><a href=\"#id22\" rel=\"nofollow\">Presentation Adapters</a></h2>\n<h2 id=\"object-size\"><span class=\"section-subtitle\">Object size</span></h2>\n<p>The size of the file as presented in the contents view of a container is\nprovided using an adapter implementing the <cite>zope.size.interfaces.ISized</cite>\ninterface. Such an adapter is available for the file object.</p>\n<p>Let\u2019s do some imports and create a new file object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.file.file import File\n&gt;&gt;&gt; from zope.file.browser import Sized\n&gt;&gt;&gt; from zope.size.interfaces import ISized\n</pre>\n<pre>&gt;&gt;&gt; f = File()\n&gt;&gt;&gt; f.size\n0\n</pre>\n<pre>&gt;&gt;&gt; s = Sized(f)\n&gt;&gt;&gt; ISized.providedBy(s)\nTrue\n&gt;&gt;&gt; s.sizeForSorting()\n('byte', 0)\n&gt;&gt;&gt; s.sizeForDisplay()\nu'0 KB'\n</pre>\n</blockquote>\n<p>Let\u2019s add some content to the file:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; with f.open('w') as w:\n...    _ =  w.write(b\"some text\")\n</pre>\n</blockquote>\n<p>The sized adapter now reflects the updated size:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; s.sizeForSorting()\n('byte', 9)\n&gt;&gt;&gt; s.sizeForDisplay()\nu'1 KB'\n</pre>\n</blockquote>\n<p>Let\u2019s try again with a larger file size:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; with f.open('w') as w:\n...    _ = w.write(b\"x\" * (1024*1024+10))\n</pre>\n<pre>&gt;&gt;&gt; s.sizeForSorting()\n('byte', 1048586)\n&gt;&gt;&gt; m = s.sizeForDisplay()\n&gt;&gt;&gt; m\nu'${size} MB'\n&gt;&gt;&gt; m.mapping\n{'size': '1.00'}\n</pre>\n</blockquote>\n<p>And still a bigger size:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; with f.open('w') as w:\n...    _ = w.write(b\"x\" * 3*512*1024)\n</pre>\n<pre>&gt;&gt;&gt; s.sizeForSorting()\n('byte', 1572864)\n&gt;&gt;&gt; m = s.sizeForDisplay()\n&gt;&gt;&gt; m\nu'${size} MB'\n&gt;&gt;&gt; m.mapping\n{'size': '1.50'}\n</pre>\n</blockquote>\n</div>\n<div id=\"changes\">\n<h2><a href=\"#id23\" rel=\"nofollow\">CHANGES</a></h2>\n<div id=\"id1\">\n<h3><a href=\"#id24\" rel=\"nofollow\">1.2.0 (2020-03-06)</a></h3>\n<ul>\n<li>Add support for Python 3.7 and 3.8</li>\n<li>Drop Python 3.4 support.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3><a href=\"#id25\" rel=\"nofollow\">1.1.0 (2017-09-30)</a></h3>\n<ul>\n<li>Move more browser dependencies to the <tt>browser</tt> extra.</li>\n<li>Begin testing PyPy3 on Travis CI.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3><a href=\"#id26\" rel=\"nofollow\">1.0.0 (2017-04-25)</a></h3>\n<ul>\n<li>Remove unneeded test dependencies zope.app.server,\nzope.app.component, zope.app.container, and others.</li>\n<li>Update to work with zope.testbrowser 5.</li>\n<li>Add PyPy support.</li>\n<li>Add support for Python 3.4, 3.5 and 3.6.\nSee <a href=\"https://github.com/zopefoundation/zope.file/pull/5\" rel=\"nofollow\">PR 5</a>.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3><a href=\"#id27\" rel=\"nofollow\">0.6.2 (2012-06-04)</a></h3>\n<ul>\n<li>Moved menu-oriented registrations into new menus.zcml. This is now\nloaded if zope.app.zcmlfiles is available only.</li>\n<li>Increase test coverage.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3><a href=\"#id28\" rel=\"nofollow\">0.6.1 (2012-01-26)</a></h3>\n<ul>\n<li>Declared more dependencies.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id29\" rel=\"nofollow\">0.6.0 (2010-09-16)</a></h3>\n<ul>\n<li>Bug fix: remove duplicate firing of ObjectCreatedEvent in\nzope.file.upload.Upload (the event is already fired in its base class,\nzope.formlib.form.AddForm).</li>\n<li>Move browser-related zcml to <cite>browser.zcml</cite> so that it easier for\napplications to exclude it.</li>\n<li>Import content-type parser from zope.contenttype, adding a dependency on\nthat package.</li>\n<li>Removed undeclared dependency on zope.app.container, depend on zope.browser.</li>\n<li>Using Python\u2019s <tt>doctest</tt> module instead of deprecated\n<tt>zope.testing.doctest</tt>.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3><a href=\"#id30\" rel=\"nofollow\">0.5.0 (2009-07-23)</a></h3>\n<ul>\n<li>Change package\u2019s mailing list address to zope-dev at zope.org instead\nof the retired one.</li>\n<li>Made tests compatible with ZODB 3.9.</li>\n<li>Removed not needed install requirement declarations.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3><a href=\"#id31\" rel=\"nofollow\">0.4.0 (2009-01-31)</a></h3>\n<ul>\n<li><cite>openDetached</cite> is now protected by zope.View instead of zope.ManageContent.</li>\n<li>Use zope.container instead of zope.app.container.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3><a href=\"#id32\" rel=\"nofollow\">0.3.0 (2007-11-01)</a></h3>\n<ul>\n<li>Package data update.</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3><a href=\"#id33\" rel=\"nofollow\">0.2.0 (2007-04-18)</a></h3>\n<ul>\n<li>Fix code for Publisher version 3.4.</li>\n</ul>\n</div>\n<div id=\"id11\">\n<h3><a href=\"#id34\" rel=\"nofollow\">0.1.0 (2007-04-18)</a></h3>\n<ul>\n<li>Initial release.</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6760106, "releases": {"0.3.0": [{"comment_text": "", "digests": {"md5": "1a89bcae612103df5f4089404942caa2", "sha256": "316f6b9c02e1ee9dc5c205935a1fce102d2703f8f8ef3ac9dac892e9565014f7"}, "downloads": -1, "filename": "zope.file-0.3.0.tar.gz", "has_sig": false, "md5_digest": "1a89bcae612103df5f4089404942caa2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27615, "upload_time": "2007-11-02T03:21:18", "upload_time_iso_8601": "2007-11-02T03:21:18Z", "url": "https://files.pythonhosted.org/packages/6d/8a/5001e0771a53610e9bdaea6a256f0dedfe339049d3ec293836e63a9f5f70/zope.file-0.3.0.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "671fdbc127c04c8150790c08796320ad", "sha256": "c8efcb23e2bffaa8ad4a2d4b018fff6e17b908ef52508e881eff41bf173e8efb"}, "downloads": -1, "filename": "zope.file-0.4.0.tar.gz", "has_sig": false, "md5_digest": "671fdbc127c04c8150790c08796320ad", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27231, "upload_time": "2009-01-31T15:10:45", "upload_time_iso_8601": "2009-01-31T15:10:45Z", "url": "https://files.pythonhosted.org/packages/d8/a5/fa1c429fdb7bcadc2a081a1e4ea84d1e3c34c9cbb82c3f09173989194671/zope.file-0.4.0.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "8e87f7fee844d1a81741d98bba1d2081", "sha256": "69c873c6e112dfa03fac010b7434b259f0cc21672ac740f3f3c30ae6f71833ea"}, "downloads": -1, "filename": "zope.file-0.5.0.tar.gz", "has_sig": false, "md5_digest": "8e87f7fee844d1a81741d98bba1d2081", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27462, "upload_time": "2009-07-23T20:33:45", "upload_time_iso_8601": "2009-07-23T20:33:45.853497Z", "url": "https://files.pythonhosted.org/packages/28/c0/aa64a29841d3a36504dc268bbafd61bd3383bcca2496d26484ca0a5f3227/zope.file-0.5.0.tar.gz", "yanked": false}], "0.6.0": [{"comment_text": "", "digests": {"md5": "2a4fbbd65c4d3fa4534b278e09b8b578", "sha256": "05867b37e195ca3d71817c459f4dd25239f4d4f594c8332f0cc5b4dbbc9c4fe6"}, "downloads": -1, "filename": "zope.file-0.6.0.tar.gz", "has_sig": false, "md5_digest": "2a4fbbd65c4d3fa4534b278e09b8b578", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29146, "upload_time": "2010-09-16T15:12:36", "upload_time_iso_8601": "2010-09-16T15:12:36.959810Z", "url": "https://files.pythonhosted.org/packages/b4/7c/6880e043f644d6673883f751353b1b64a1b846e071ae4fd719eac2b9664a/zope.file-0.6.0.tar.gz", "yanked": false}], "0.6.1": [{"comment_text": "", "digests": {"md5": "5df3b63c678f4b445be345f1dff1bc9b", "sha256": "6a5ffd8b48459ec61d37b529c2c6feb94d4895e9ed7b9cf98815cb0a7da09c50"}, "downloads": -1, "filename": "zope.file-0.6.1.tar.gz", "has_sig": false, "md5_digest": "5df3b63c678f4b445be345f1dff1bc9b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29781, "upload_time": "2012-01-26T18:40:07", "upload_time_iso_8601": "2012-01-26T18:40:07.958560Z", "url": "https://files.pythonhosted.org/packages/82/5c/45a26826d4e621cfeae8e80714562880d217a25612a57cdfaf86baa20d1f/zope.file-0.6.1.tar.gz", "yanked": false}], "0.6.2": [{"comment_text": "", "digests": {"md5": "8c4603043140836855561f8d24f4b1df", "sha256": "2cc55b26c4d356c8ce2a980efa06c8e1a11278234ffdf4004e2e13cf20f5e7eb"}, "downloads": -1, "filename": "zope.file-0.6.2.tar.gz", "has_sig": false, "md5_digest": "8c4603043140836855561f8d24f4b1df", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30542, "upload_time": "2012-06-04T17:51:34", "upload_time_iso_8601": "2012-06-04T17:51:34.979951Z", "url": "https://files.pythonhosted.org/packages/c9/67/bbc74312fc58bc4050e5ac73372a440212f59a89183ad8b3b1f2e4e26c77/zope.file-0.6.2.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "05055396ec92297188417238d798e235", "sha256": "1701336795639c2e6c40a7789aab31adf3b2d7aa2ae9d5ee38485d07e176d38e"}, "downloads": -1, "filename": "zope.file-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "05055396ec92297188417238d798e235", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 45911, "upload_time": "2017-04-25T11:36:16", "upload_time_iso_8601": "2017-04-25T11:36:16.719336Z", "url": "https://files.pythonhosted.org/packages/c3/24/7d6cda931c9ca791dc8af47a2ddaa74de1fbe0aa891fb9d6915ca65186f7/zope.file-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d9e859a04c24aa762e48fbb364480fa9", "sha256": "747f0c1fd00ba850a38aaa43d0026f500ae7e7947d6a509a9c416229e86828fb"}, "downloads": -1, "filename": "zope.file-1.0.0.tar.gz", "has_sig": false, "md5_digest": "d9e859a04c24aa762e48fbb364480fa9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35918, "upload_time": "2017-04-25T11:36:23", "upload_time_iso_8601": "2017-04-25T11:36:23.971603Z", "url": "https://files.pythonhosted.org/packages/a4/de/deee73bce39eaea2b9496e0a4ebdab3adf6d829f79a34951ec70656702ef/zope.file-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "40248cfb6e003c4a95ab5fb7e9402eff", "sha256": "7cb2f3ecb2cf95ef6319c2eacceb993ea00ba3f193a1045314a1c94d700c2b7b"}, "downloads": -1, "filename": "zope.file-1.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "40248cfb6e003c4a95ab5fb7e9402eff", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 46543, "upload_time": "2017-09-30T10:50:28", "upload_time_iso_8601": "2017-09-30T10:50:28.749955Z", "url": "https://files.pythonhosted.org/packages/2a/b2/bbcb91bdf6911c7b6815ba6eb078a980574e498504c6ef7898d40bf996dd/zope.file-1.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9943fd4649e014411b317ff05a5678a1", "sha256": "9c466f07dd92ee1d03e51ffb349d90c59a586316ed2ff11b395b9a5dd78f2fc6"}, "downloads": -1, "filename": "zope.file-1.1.0.tar.gz", "has_sig": false, "md5_digest": "9943fd4649e014411b317ff05a5678a1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36054, "upload_time": "2017-09-30T10:50:30", "upload_time_iso_8601": "2017-09-30T10:50:30.483835Z", "url": "https://files.pythonhosted.org/packages/4c/d6/21038b3dd31b509ead0c680ccf7b58e2c403fe5d8094ea9bc63208e3da89/zope.file-1.1.0.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "86cf784631a1baae09a44dfcfa225856", "sha256": "de196cd130123dfdfa7b0672cca8b28bf1aa2b63b4da020768b1e04feb8ac4e9"}, "downloads": -1, "filename": "zope.file-1.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "86cf784631a1baae09a44dfcfa225856", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 40107, "upload_time": "2020-03-06T07:46:37", "upload_time_iso_8601": "2020-03-06T07:46:37.087002Z", "url": "https://files.pythonhosted.org/packages/36/16/d9f36d54fabb52653593b60a258587e558f0174812d6967a21dac19d7d63/zope.file-1.2.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1602761c2c1bd9d352498a4fe66517bf", "sha256": "ee8a98361c9fbb60dd2aa8a8a2295236e0c5a646dc71997b96649e3d6d5e6cf4"}, "downloads": -1, "filename": "zope.file-1.2.0.tar.gz", "has_sig": false, "md5_digest": "1602761c2c1bd9d352498a4fe66517bf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36170, "upload_time": "2020-03-06T07:46:39", "upload_time_iso_8601": "2020-03-06T07:46:39.878812Z", "url": "https://files.pythonhosted.org/packages/11/78/7f821a1ef34746c3623b589ba5bce03d560c6f48174abef724fd6d7a2169/zope.file-1.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "86cf784631a1baae09a44dfcfa225856", "sha256": "de196cd130123dfdfa7b0672cca8b28bf1aa2b63b4da020768b1e04feb8ac4e9"}, "downloads": -1, "filename": "zope.file-1.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "86cf784631a1baae09a44dfcfa225856", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 40107, "upload_time": "2020-03-06T07:46:37", "upload_time_iso_8601": "2020-03-06T07:46:37.087002Z", "url": "https://files.pythonhosted.org/packages/36/16/d9f36d54fabb52653593b60a258587e558f0174812d6967a21dac19d7d63/zope.file-1.2.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1602761c2c1bd9d352498a4fe66517bf", "sha256": "ee8a98361c9fbb60dd2aa8a8a2295236e0c5a646dc71997b96649e3d6d5e6cf4"}, "downloads": -1, "filename": "zope.file-1.2.0.tar.gz", "has_sig": false, "md5_digest": "1602761c2c1bd9d352498a4fe66517bf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36170, "upload_time": "2020-03-06T07:46:39", "upload_time_iso_8601": "2020-03-06T07:46:39.878812Z", "url": "https://files.pythonhosted.org/packages/11/78/7f821a1ef34746c3623b589ba5bce03d560c6f48174abef724fd6d7a2169/zope.file-1.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:13:50 2020"}