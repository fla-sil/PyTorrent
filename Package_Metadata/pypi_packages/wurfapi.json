{"info": {"author": "Steinwurf ApS", "author_email": "contact@steinwurf.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Plugins", "Environment :: Web Environment", "Framework :: Sphinx :: Extension", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Documentation", "Topic :: Documentation :: Sphinx", "Topic :: Software Development :: Documentation", "Topic :: Text Processing", "Topic :: Utilities"], "description": "wurfapi\n=======\n\n.. image:: https://ci.appveyor.com/api/projects/status/l41u9e7y50r685ep?svg=true&branch=master\n    :target: https://ci.appveyor.com/project/SteinwurfApS/wurfapi\n\n.. image:: https://travis-ci.org/steinwurf/wurfapi.svg?branch=master\n    :target: https://travis-ci.org/steinwurf/wurfapi\n\nWe wanted to have a configurable and easy to use Sphinx API documentation\ngenerator for our C++ projects. To achieve this we leaned on others for\ninspiration:\n\n* Breathe (https://github.com/michaeljones/breathe): Excellent extension\n  and the default choice for many.\n* Gasp (https://github.com/troelsfr/Gasp): Gasp inspired us by allowing\n  templates to control the output. Unfortunately development of Gaps\n  seems to have stopped.\n\nSo what is ``wurfapi``:\n\n* Essentially we picked up where Gasp let go. We have\n  borrowed the idea of templates to make it highly configurable.\n\n* We made it easy to use by automatically running Doxygen to generate the\n  initial API documentation.\n\n* We parse the Doxygen XML into an easy to use Python dictionary. Which can\n  be consumed in the templates.\n\n* We prepared the extension for other backends (replacing Doxygen) e.g.\n  https://github.com/foonathan/standardese once they become ready.\n\n.. contents:: Table of Contents:\n   :local:\n\n\nStatus\n======\n\nWe are still very much in the initial development phase - all things are\nsubject to change.\n\n* Parsing Doxygen XML: We do not support everything yet (and probably never\n  will). We still are missing some crucial elements like proper parsing of\n  the text elements in comments, parameter descriptions etc.\n\nUsage\n=====\n\nWe recommend that you install wurfapi and sphinx in a virtual environment.\nTo use the extension, the following steps are needed:\n\n1. Create a virtual environment::\n\n    Follow the https://docs.python.org/3/tutorial/venv.html\n\n2. Install the extension::\n\n    pip install sphinx\n    pip install wurfapi\n\n3. Generate the initial ``Sphinx`` documentation by running::\n\n      mkdir docs\n      cd docs\n      python sphinx-quickstart\n\n   You will need to enter some basic information about your project such\n   as the project name etc.\n\n4. Open the ``conf.py`` generated by ``sphinx-quickstart`` and add the\n   the following::\n\n      # Append or insert 'wurfapi' in the extensions list\n      extensions = ['wurfapi']\n\n      # wurfapi options - relative to your docs dir\n      wurfapi = {\n        'source_paths': ['../src'],\n        'recursive': True,\n        'parser': {'type': 'doxygen', 'download': True,  'warnings_as_error': True}\n      }\n\n   .. note::\n\n    ``source_path``\n        If you separate source and build dir in sphinx your 'source_path'\n        should be something like '../../src'.\n\n    ``recursive``\n        Set recursive ``True`` if you want recursively scan the ``source_paths``\n\n    ``download``\n        If you do not want to automatically download Doxygen, set\n        ``download`` to ``False``. In that case ``wurfapi`` will try to invoke\n        plain ``doxygen`` without specifying any path or similar. This means\n        it ``doxygen`` must be available in the path.\n\n    ``warnings_as_error``\n        If Doxygen emits many warnings you might want to set warnings_as_error\n        to False until they have been fixed.\n\n5. To generate the API documentation for a class open a ``.rst`` file\n   e.g. ``index.rst`` if you ran ``sphinx-quickstart``. Say we want to\n   generate docs for a class called ``test`` in the namespace ``project``.\n\n   To do this we add the following directive to the rst file::\n\n      .. wurfapi:: class_synopsis.rst\n        :selector: project::coffee::machine\n\n   Such that ``index.rst`` becomes something like::\n\n      Welcome to Coffee's documentation!\n      ===================================\n\n      .. toctree::\n        :maxdepth: 2\n        :caption: Contents:\n\n      .. wurfapi:: class_synopsis.rst\n          :selector: project::coffee::machine\n\n      .. wurfapi:: class_synopsis.rst\n          :selector: project::coffee::recipe\n\n\n      Indices and tables\n      ==================\n\n      * :ref:`genindex`\n      * :ref:`modindex`\n      * :ref:`search`\n\n\n    To do this we use the ``class_synopsis.rst`` template.\n\n6. Generate the Documentation\n\n    make html\n\nRunning on readthedocs.org\n--------------------------\n\nTo use this on readthedocs.org you need to have the ``wurfapi`` Sphinx\nextension installed. This can be done by adding a ``requirements.txt`` in the\ndocumentation folder. readthedocs.org can be configured to use the\n``requirements.txt`` when building a project. Simply put ``wurfapi`` in to the\n``requirements.txt``.\n\nDoxygen issues\n--------------\n\nNothing is perfect, neither is Doxygen. Sometimes Doxygen gets it wrong e.g. in\nthe following example::\n\n    class foo\n    {\n    private:\n        class bar;\n    };\n\nDoxygen incorrectly reports that ``bar`` has public scope (also reported here\nhttps://bit.ly/2BWPllZ). To deal with such issues, until a fix lands in\nDoxygen, you can do the following:\n\nAdd a list of *patches* to the API to your ``conf.py`` file. Extending the\nexample from before, we can add the following fix::\n\n      wurfapi = {\n        'source_paths': ['../src'],\n        'recursive': True,\n        'parser': {\n          'type': 'doxygen', 'download': True,  'warnings_as_error': True,\n           'patch_api': [\n            {'selector': 'foo::bar', 'key': 'access', 'value': 'private'}\n          ]\n        }\n      }\n\nThe ``patch_api`` allows you to reach in to the parsed API information and\nupdate certain values. The ``selector`` is the ``unique-name`` of the\nentity you want to update. Check the \"Dictionary layout\" section further down\nfor more information.\n\nCollapse inline namespaces\n--------------------------\n\nFor symbol versioning you may use ``inline namespaces``, however typically\nyou don't want these to show up in the docs, as these are mostly\ninvisible for your users.\n\nWith ``wurfapi`` you can collapse the inline namespace such that it\nis removed form the scopes etc.\n\nExample::\n\n  namespace foo { inline namespace v1_2_3 { struct bar{}; } }\n\nThe scope to bar is ``foo::v1_2_3``. If you collapse the inline namespace it will\njust be ``foo``.\n\nFirst issue you have to deal with is that Doxygen currently does not\nsupport inline namespaces. So we need to patch the API first::\n\n      wurfapi = {\n        'source_paths': ['../src'],\n        'recursive': True,\n        'parser': {\n          'type': 'doxygen', 'download': True,  'warnings_as_error': True,\n           'patch_api': [\n            {'selector': 'foo::v1_2_3', 'key': 'inline', 'value': True}\n          ]\n        }\n      }\n\nAfter this we can collapse the namespace::\n\n      wurfapi = {\n        'source_paths': ['../src'],\n        'recursive': True,\n        'parser': {\n          'type': 'doxygen', 'download': True,  'warnings_as_error': True,\n           'patch_api': [\n            {'selector': 'foo::v1_2_3', 'key': 'inline', 'value': True}\n          ],\n          'collapse_inline_namespaces': [\n            \"foo::v1_2_3\"\n          ]\n        }\n      }\n\n\nNow you will be able to refer to ``bar`` as ``foo::bar``. Note, that\ncollapsing the namespace will affect the selectors you write when\ngenerating the documentation.\n\nCustom templates\n----------------\n\nYou can write you own custom templates for generating the rst output.\nTo to this you simply write a Jinja2 compatible rst template and place\nit in some folder. Adding the ``user_templates`` key to the ``wurfapi``\nconfiguration dictionary in the ``conf.py`` file will make it available.\n\nFor example::\n\n    wurfapi = {\n        'source_paths': ['../src', '../examples/header/header.h'],\n        'recursive': True,\n        'user_templates': 'rst_templates',\n        'parser': {\n            'type': 'doxygen', 'download': True, 'warnings_as_error': True\n        }\n    }\n\n    exclude_patterns = ['rst_templates/*.rst']\n\nNow we can use ``*.rst`` files inside the ``rst_templates`` folder e.g. if\nwe had a ``class_list.rst`` template we could use it like this::\n\n    .. wurfapi:: class_list.rst\n        :selector: project::coffee\n\nRelease new version\n===================\n\n1. Edit ``NEWS.rst``, ``wscript`` and ``src/wurfapi/wurfapi.py`` (set\n   correct ``VERSION``)\n\n2. Run ::\n\n    ./waf upload\n\n\nSource code\n===========\n\n\nTests\n=====\n\nThe tests will run automatically by passing ``--run_tests`` to waf::\n\n    ./waf --run_tests\n\nThis follows what seems to be \"best practice\" advise, namely to install the\npackage in editable mode in a virtualenv.\n\nRecordings\n----------\n\nA bunch of the tests use a class called ``Record``, defined in\n(``test/record.py``). The ``Record`` class is used to store output as\nfiles from different parsing and rendering operations.\n\nE.g. say we want to make sure that a parser function returns a certain\n``dict`` object. Then we can record that ``dict``::\n\n    recorder = record.Record(filename='test.json',\n                             recording_path='/tmp/recording',\n                             mismatch_path='/tmp/mismatch')\n\n    recorder.record(data={'foo': 2, 'bar': 3})\n\nIf ``data`` changes compared to a previous recording a mismatch will be\ndetected. To update a recording simply delete the recording file.\n\nTest directories\n----------------\n\nYou will also notice that a bunch of the tests take a parameter called\n``testdirectory``. The ``testdirectory`` is a pytest fixture, which\nrepresents a temporary directory on the filesystem. When running the tests\nyou will notice these temporary test directories pop up under the\n``pytest_temp`` directory in the project root.\n\nYou can read more about that here:\n\n* https://github.com/steinwurf/pytest-testdirectory\n\nDeveloper Notes\n===============\n\nThe `sphinx` documentation on creating extensions:\nhttp://www.sphinx-doc.org/en/stable/extdev/index.html#dev-extensions\n\n* An extension is a Python module. When an extension loads, Sphinx will import\n  it and execute its ``setup()`` function.\n\n* Understanding how to put together docutils nodes seems pretty difficult. One\n  suggesting form the mailinglist was to look at the following document:\n  https://github.com/docutils-mirror/docutils/blob/master/test/functional/expected/standalone_rst_pseudoxml.txt\n\n* While researching how to do this, there seem to be three potential approaches:\n\n  1. Use the standard Sphinx approach and operate with the doctree.\n  2. Create RST based on jinja templates\n  3. Create HTML based on jinja templates\n\n* Inspiration - Sphinx extensions that were used as inspiration while\n  developing this extension.\n\n  * Breathe\n  * Gasp\n  * https://github.com/Robpol86/sphinxcontrib-imgur\n  * https://github.com/djungelorm/sphinx-tabs\n\n* Understanding how to write stuff with docutils:\n  * http://agateau.com/2015/docutils-snippets/\n\n* Creating custom directive\n  * http://www.xavierdupre.fr/blog/2015-06-07_nojs.html\n\n* Nice looking Sphinx extensions\n  * https://github.com/bokeh/bokeh/tree/master/bokeh/sphinxext\n\n* This part of the documentation was useful in order to understand the need\n  for ViewLists etc. in the directives run(...) function.\n  http://www.sphinx-doc.org/en/stable/extdev/markupapi.html\n\n* This link provided inspiration for the text json format: https://github.com/micnews/html-to-article-json\n* More xml->json for the text: https://www.xml.com/pub/a/2006/05/31/converting-between-xml-and-json.html\n\nDictionary layout\n-----------------\n\nWe want to support different \"backends\" like Doxygen to parse the source\ncode. To make this possible we define an internal source code description\nformat. We then translate e.g. Doxygen XML to this and use that to render\nthe API documentation.\n\nThis way a different \"backend\" e.g. Doxygen2 could be use used as the source\ncode parser and the API documentation could be generated.\n\n\n``unique-name``\n...............\n\nIn order to be able to reference the different entities in the API we need\nto assign them a name.\n\nWe use a similar approach here as described in standardese_.\n\nThis means that the ``unique-name`` of an entity is the name with all\nscopes e.g. ``foo::bar::baz``.\n\n* For functions you need to specify the signature (parameter types and for\n  member functions cv-qualifier and ref-qualifier) e.g. ``foo::bar::baz::func()``\n  or ``foo::bar::baz::func(int a, char*) const``. See cppreference_ for more\n  information.\n\n* For class template specializations the unique name includes the specialization\n  arguments. For example::\n\n      // Here the unique-name is just 'foo'\n      template<class T>\n      class foo {};\n\n      // Here the unique name is foo<int>\n      template<>\n      class foo<int> {};\n\n* In addition to types, we also have entries for the parsed files. For files\n  the unique name will be the relative path from the project root.\n\n.. _cppreference: http://en.cppreference.com/w/cpp/language/member_functions\n.. _standardese: https://github.com/foonathan/standardese#linking\n\n\n\nThe API dictionary\n...................\n\nThe internal structure is a dicts with the different API entities. The\n``unique-name`` of the entity is the key and the entity type also a\nPython dictionary is the value e.g::\n\n\n    api = {\n      'unique-name': { ... },\n      'unique-name': { ... },\n      ...\n    }\n\nTo make this a bit more concrete consider the following code::\n\n    namespace ns1\n    {\n      class shape\n      {\n        void print(int a) const;\n      };\n\n      namespace ns2\n      {\n        struct box\n        {\n          void hello();\n        };\n\n        void print();\n      }\n    }\n\nParsing the above code would produce the following API dictionary::\n\n      api = {\n        'ns1': { 'kind': 'namespace', ...},\n        'ns1::shape': { 'kind': 'class', ... },\n        'ns1::shape::print(int) const': { kind': function' ... },\n        'ns1::ns2': { 'kind': 'namespace', ... },\n        'ns1::ns2::box': { 'kind': 'struct', ... },\n        'ns1::ns2::box::hello()': { kind': function' ... },\n        'ns1::ns2::print()': { 'kind': 'function', ...},\n        'ns1.hpp': { 'kind': 'file', ...}\n      }\n\nThe different entity kinds expose different information about the\nAPI. We will document the different kinds in the following.\n\nWe make some keys *optional* this is marked in the following way::\n\n    api = {\n      'unique-name': {\n        'some_key': ...\n        Optional('an_optional_key'): ...\n      },\n      ...\n    }\n\n``namespace`` Kind\n..................\n\nPython dictionary representing a C++ namespace::\n\n    info = {\n      'kind': 'namespace',\n      'name': 'unqualified-name',\n      'scope': 'unique-name' | None,\n      'members: [ 'unique-name', 'unique-name' ],\n      'briefdescription': paragraphs,\n      'detaileddescription': paragraphs,\n      'inline': True | False\n    }\n\nNote: Currently Doxygen does not support parsing ``inline namespaces``. So\nyou need to use the patch API to change the value from ``False`` to ``True``\nmanually. Maybe at some point https://github.com/doxygen/doxygen/issues/6741\nit will be supported.\n\n``class`` | ``struct`` Kind\n...........................\n\nPython dictionary representing a C++ class or struct::\n\n    info = {\n      'kind': 'class' | 'struct',\n      'name': 'unqualified-name',\n      'location': location,\n      'scope': 'unique-name' | None,\n      'access': 'public' | 'protected' | 'private',\n      Optional('template_parameters'): template_parameters,\n      'members: [ 'unique-name', 'unique-name' ],\n      'briefdescription': paragraphs,\n      'detaileddescription': paragraphs\n    }\n\n\n``enum`` | ``enum class`` Kind\n..............................\n\nPython dictionary representing a C++ enum or enum class::\n\n    info = {\n      'kind': 'enum',\n      'name': 'unqualified-name',\n      'location': location,\n      'scope': 'unique-name' | None,\n      'access': 'public' | 'protected' | 'private',\n      'values: [\n        {\n          'name': 'somename',\n          'briefdescription': paragraphs,\n          'detaileddescription': paragraphs,\n          Optional('value'): 'some value'\n        }\n       ],\n      'briefdescription': paragraphs,\n      'detaileddescription': paragraphs\n    }\n\n``typedef`` | ``using`` Kind\n............................\n\nPython dictionary representing a C++ using or typedef statement::\n\n    info = {\n      'kind': 'typedef' | 'using',\n      'name': 'unqualified-name',\n      'location': location,\n      'scope': 'unique-name' | None,\n      'access': 'public' | 'protected' | 'private',\n      'type': type,\n      'briefdescription': paragraphs,\n      'detaileddescription': paragraphs\n    }\n\n``file`` Kind\n............................\n\nPython dictionary representing a file in the project::\n\n    info = {\n      'kind': 'file',\n      'name': 'somefile.hpp',\n      'path': 'relative/path/to/somefile.hpp',\n    }\n\n``function`` Kind\n.................\n\nPython dictionary representing a C++ function::\n\n    info = {\n      'kind': 'function',\n      'name': 'unqualified-name',\n      'location': location,\n      'scope': 'unique-name' | None,\n      Optional('return'): {\n        'type': type,\n        'description': paragraphs\n      }\n      'signature': 'text',\n      Optional('template_parameters'): template_parameters,\n      'is_const': True | False,\n      'is_static': True | False,\n      'is_virtual': True | False,\n      'is_explicit': True | False,\n      'is_inline': True | False,\n      'is_constructor': True | False,\n      'is_destructor': True | False,\n      'trailing_return': True | False,\n      'access': 'public' | 'protected' | 'private',\n      'briefdescription: paragraphs,\n      'detaileddescription: paragraphs,\n      'parameters': [\n        { 'type': type, Optional('name'): 'somename', 'description': paragraphs },\n        ...\n      ]\n  }\n\nThe `return` key is optional if the function is either a constructor or\ndestructor.\n\n``variable`` Kind\n.................\n\nPython dictionary representing a C++ variable::\n\n    info = {\n      'kind': 'variable',\n      'name': 'unqualified-name',\n      Optional('value'): 'some value',\n      'type': type,\n      'location': location,\n      'is_static': True | False,\n      'is_mutable': True | False,\n      'is_volatile': True | False,\n      'is_const': True | False,\n      'is_constexpr': True | False,\n      'scope': 'unique-name' | None,\n      'access': 'public' | 'protected' | 'private',\n      'briefdescription: paragraphs,\n      'detaileddescription: paragraphs,\n    }\n\n``location`` item\n.................\n\nPython dictionary representing a location::\n\n    location = {\n      Optional('include'): 'some/header.h',\n      'path': 'src/project/header.h',\n      'line-start': 10,\n      'line-end': 12 | None\n      }\n\n* The ``include`` will be relative to any ``include_paths`` specified in the\n  ``wurfapi`` dictionary in your Sphinx ``conf.py``.\n\n* The ``path`` will be relative to the project root folder.\n\n``type`` item\n.............\n\nPython list representing a C++ type::\n\n    type = [\n      {\n        'value': 'sometext',\n        Optional('link'): link\n      }, ...\n    ]\n\nHaving the type as a list of items we can create links to nested types e.g.\nsay we have a `std::unique_ptr<impl>` and we would like to make `impl` a link.\nThis could look like::\n\n    \"type\": [\n      {\n        \"value\": \"std::unique_ptr<\"\n      },\n      {\n        \"link\": {\"url\": False, \"value\": \"project::impl\"},\n        \"value\": \"impl\"\n      },\n      {\n        \"value\": \">\"\n      }\n    ]\n\nAny spaces in the type list should be preserved all the way from the Doxygen\noutput and into the type list. In the rst it should be sufficient to simply\noutput the values of the type. No spaces or other stuff should be injected.\n\n``link`` item\n.............\n\nPython dictionary representing a link::\n\n    link = { 'url': True | False, 'value': 'somestring' }\n\nIf `url` is `True` we have a basic extrenal reference otherwise we have a\nlink to an internal type in the API.\n\n``parameter`` item\n...................\n\nDictionary representing a function parameter::\n\n    parameter = {\n      'type': type,\n      Optional('name'): 'somestring',\n      Optional('description'): paragraphs\n    }\n\nFor the parameter the name is also included into the type list. The reason\nis that some parameters can be pretty complex, with the name embedded\ninside the type e.g.::\n\n    void function(int (*(*foo)())[3]);\n\nThis is a function which takes one parameter `foo` which is pointer\nfunction returning pointer to array 3 of int - nice right? Anyway, in\nsuch cases the parameter name is embedded inside the type of the parameter.\nWe therefore took the easy out and `wurfapi` will always include the\nparameter name in the type.\n\nAs an example the parameter dictionary for a function `void test(int b)`\ncould be::\n\n    {\n       'type': [{'value': 'int '}, {'value': 'b'}],\n       'name': 'b'\n    }\n\n``template_parameters`` item\n.............................\n\nPython list of dictionaries representing template parameters::\n\n    template_parameters = [{\n      'type': type,\n      'name': 'somestring',\n      Optional('default'): type,\n      Optional('description'): paragraphs\n    }]\n\nText information\n.................\n\nText information is stored in a of list paragraphs::\n\n    paragraphs = [paragraph]\n\nA paragraph consists of a list of paragraph elements::\n\n    paragraph = [\n          {\n            \"kind\": \"text\" | \"code\" | \"list\",\n            ...\n          },\n        ]\n\nParagraph elements can be one of three kinds, \"text\", \"code\" or \"list\"::\n\n    text = {\n      'kind': 'text',\n      'content': 'hello',\n      Optional('link'): link\n      }\n\n    code = {\n      'kind': 'code',\n      'content': 'void print();',\n      'is_block': true | false\n    }\n\n    list = {\n      'kind': 'list',\n      'ordered': true | false,\n      'items': [paragraphs] # Each item is a list of paragraphs\n    }\n\n\nProblem with ``unique-name`` for functions\n..........................................\n\nIssue equivalent C++ function signatures can be written in a number of\ndifferent ways::\n\n  void hello(const int *x); // x is a pointer to const int\n  void hello(int const *x); // x is a pointer to const int\n\nWe can also move the asterisk (``*``) to the left::\n\n  void hello(const int* x); // x is a pointer to const int\n  void hello(int const* x); // x is a pointer to const int\n\nSo we need some way to normalize the function signature when transforming it\nto ``unique-name``. We cannot simply rely on sting comparisons.\n\nAccording to the numerous google searches it is hard to write a regex for this.\nInstead we will try to use a parser:\n\n* Python parser: https://github.com/erezsh/lark\n* C++ Grammar: http://www.externsoft.ch/media/swf/cpp11-iso.html#parameters_and_qualifiers\n\nWe only need to parse the function parameter list denoted as the\n``http://www.externsoft.ch/media/swf/cpp11-iso.html#parameters_and_qualifiers``.\n\n\nGenerated output\n----------------\n\nSince we are going to be using Doxygen's XML output as input to the\nextension we need a place to store it. We store it system temporary folder e.g.\nif the project name is \"foobar\" on Linux this would be\n``/tmp/wurfapi-foobar-123456`` where ``123456`` is a hash of the source\ndirectory paths. In addition to Doxygen's XML we also store the generated rst\nfor the different directives there. This is nice for debugging to see whether\nwe generate broken rst.\n\nThe API in json format can be found in the ``_build/.doctree/wurfapi_api.json``.\n\nPaths and directories\n---------------------\n\n\n* Source directory: In Sphinx the source directory is where our .rst files are\n  located. This is what you pass to ``sphinx-build`` when building your\n  documentation. We will use this in our extension to find the C++ source code\n  and output customization templates.\n\n\nNotes\n=====\n\n* Why use an ``src`` folder (https://hynek.me/articles/testing-packaging/).\n  tl;dr you should run your tests in the same environment as your users would\n  run your code. So by placing the source files in a non-importable folder you\n  avoid accidentally having access to resources not added to the Python\n  package your users will install...\n* Python packaging guide: https://packaging.python.org/distributing/\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/steinwurf/", "keywords": "wurfapi", "license": "BSD 3-clause \"New\" or \"Revised\" License", "maintainer": "", "maintainer_email": "", "name": "wurfapi", "package_url": "https://pypi.org/project/wurfapi/", "platform": "", "project_url": "https://pypi.org/project/wurfapi/", "project_urls": {"Homepage": "https://github.com/steinwurf/"}, "release_url": "https://pypi.org/project/wurfapi/6.0.0/", "requires_dist": ["pyquery", "python-archive", "schema", "six", "sphinx (>3)", "pathlib2 ; python_version < \"3.4\""], "requires_python": "", "summary": "C++ Documentation generator.", "version": "6.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"wurfapi\">\n<h2>wurfapi</h2>\n<a href=\"https://ci.appveyor.com/project/SteinwurfApS/wurfapi\" rel=\"nofollow\"><img alt=\"https://ci.appveyor.com/api/projects/status/l41u9e7y50r685ep?svg=true&amp;branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cf5fa6fa5ac54bb9131a0f6af62f9b0a5e10747a/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6c3431753965377935307236383565703f7376673d74727565266272616e63683d6d6173746572\"></a>\n<a href=\"https://travis-ci.org/steinwurf/wurfapi\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/steinwurf/wurfapi.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ec9b6164b54db9d40a2cd3f74c6b94efa4f8b461/68747470733a2f2f7472617669732d63692e6f72672f737465696e777572662f777572666170692e7376673f6272616e63683d6d6173746572\"></a>\n<p>We wanted to have a configurable and easy to use Sphinx API documentation\ngenerator for our C++ projects. To achieve this we leaned on others for\ninspiration:</p>\n<ul>\n<li>Breathe (<a href=\"https://github.com/michaeljones/breathe\" rel=\"nofollow\">https://github.com/michaeljones/breathe</a>): Excellent extension\nand the default choice for many.</li>\n<li>Gasp (<a href=\"https://github.com/troelsfr/Gasp\" rel=\"nofollow\">https://github.com/troelsfr/Gasp</a>): Gasp inspired us by allowing\ntemplates to control the output. Unfortunately development of Gaps\nseems to have stopped.</li>\n</ul>\n<p>So what is <tt>wurfapi</tt>:</p>\n<ul>\n<li>Essentially we picked up where Gasp let go. We have\nborrowed the idea of templates to make it highly configurable.</li>\n<li>We made it easy to use by automatically running Doxygen to generate the\ninitial API documentation.</li>\n<li>We parse the Doxygen XML into an easy to use Python dictionary. Which can\nbe consumed in the templates.</li>\n<li>We prepared the extension for other backends (replacing Doxygen) e.g.\n<a href=\"https://github.com/foonathan/standardese\" rel=\"nofollow\">https://github.com/foonathan/standardese</a> once they become ready.</li>\n</ul>\n</div>\n<div id=\"status\">\n<h2>Status</h2>\n<p>We are still very much in the initial development phase - all things are\nsubject to change.</p>\n<ul>\n<li>Parsing Doxygen XML: We do not support everything yet (and probably never\nwill). We still are missing some crucial elements like proper parsing of\nthe text elements in comments, parameter descriptions etc.</li>\n</ul>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>We recommend that you install wurfapi and sphinx in a virtual environment.\nTo use the extension, the following steps are needed:</p>\n<ol>\n<li><p>Create a virtual environment:</p>\n<pre>Follow the https://docs.python.org/3/tutorial/venv.html\n</pre>\n</li>\n<li><p>Install the extension:</p>\n<pre>pip install sphinx\npip install wurfapi\n</pre>\n</li>\n<li><p>Generate the initial <tt>Sphinx</tt> documentation by running:</p>\n<pre>mkdir docs\ncd docs\npython sphinx-quickstart\n</pre>\n<p>You will need to enter some basic information about your project such\nas the project name etc.</p>\n</li>\n<li><p>Open the <tt>conf.py</tt> generated by <tt><span class=\"pre\">sphinx-quickstart</span></tt> and add the\nthe following:</p>\n<pre># Append or insert 'wurfapi' in the extensions list\nextensions = ['wurfapi']\n\n# wurfapi options - relative to your docs dir\nwurfapi = {\n  'source_paths': ['../src'],\n  'recursive': True,\n  'parser': {'type': 'doxygen', 'download': True,  'warnings_as_error': True}\n}\n</pre>\n<div>\n<p>Note</p>\n<dl>\n<dt><tt>source_path</tt></dt>\n<dd><p>If you separate source and build dir in sphinx your \u2018source_path\u2019\nshould be something like \u2018../../src\u2019.</p>\n</dd>\n<dt><tt>recursive</tt></dt>\n<dd><p>Set recursive <tt>True</tt> if you want recursively scan the <tt>source_paths</tt></p>\n</dd>\n<dt><tt>download</tt></dt>\n<dd><p>If you do not want to automatically download Doxygen, set\n<tt>download</tt> to <tt>False</tt>. In that case <tt>wurfapi</tt> will try to invoke\nplain <tt>doxygen</tt> without specifying any path or similar. This means\nit <tt>doxygen</tt> must be available in the path.</p>\n</dd>\n<dt><tt>warnings_as_error</tt></dt>\n<dd><p>If Doxygen emits many warnings you might want to set warnings_as_error\nto False until they have been fixed.</p>\n</dd>\n</dl>\n</div>\n</li>\n<li><p>To generate the API documentation for a class open a <tt>.rst</tt> file\ne.g. <tt>index.rst</tt> if you ran <tt><span class=\"pre\">sphinx-quickstart</span></tt>. Say we want to\ngenerate docs for a class called <tt>test</tt> in the namespace <tt>project</tt>.</p>\n<p>To do this we add the following directive to the rst file:</p>\n<pre>.. wurfapi:: class_synopsis.rst\n  :selector: project::coffee::machine\n</pre>\n<p>Such that <tt>index.rst</tt> becomes something like:</p>\n<pre>  Welcome to Coffee's documentation!\n  ===================================\n\n  .. toctree::\n    :maxdepth: 2\n    :caption: Contents:\n\n  .. wurfapi:: class_synopsis.rst\n      :selector: project::coffee::machine\n\n  .. wurfapi:: class_synopsis.rst\n      :selector: project::coffee::recipe\n\n\n  Indices and tables\n  ==================\n\n  * :ref:`genindex`\n  * :ref:`modindex`\n  * :ref:`search`\n\n\nTo do this we use the ``class_synopsis.rst`` template.\n</pre>\n</li>\n<li><p>Generate the Documentation</p>\n<blockquote>\n<p>make html</p>\n</blockquote>\n</li>\n</ol>\n<div id=\"running-on-readthedocs-org\">\n<h3>Running on readthedocs.org</h3>\n<p>To use this on readthedocs.org you need to have the <tt>wurfapi</tt> Sphinx\nextension installed. This can be done by adding a <tt>requirements.txt</tt> in the\ndocumentation folder. readthedocs.org can be configured to use the\n<tt>requirements.txt</tt> when building a project. Simply put <tt>wurfapi</tt> in to the\n<tt>requirements.txt</tt>.</p>\n</div>\n<div id=\"doxygen-issues\">\n<h3>Doxygen issues</h3>\n<p>Nothing is perfect, neither is Doxygen. Sometimes Doxygen gets it wrong e.g. in\nthe following example:</p>\n<pre>class foo\n{\nprivate:\n    class bar;\n};\n</pre>\n<p>Doxygen incorrectly reports that <tt>bar</tt> has public scope (also reported here\n<a href=\"https://bit.ly/2BWPllZ\" rel=\"nofollow\">https://bit.ly/2BWPllZ</a>). To deal with such issues, until a fix lands in\nDoxygen, you can do the following:</p>\n<p>Add a list of <em>patches</em> to the API to your <tt>conf.py</tt> file. Extending the\nexample from before, we can add the following fix:</p>\n<pre>wurfapi = {\n  'source_paths': ['../src'],\n  'recursive': True,\n  'parser': {\n    'type': 'doxygen', 'download': True,  'warnings_as_error': True,\n     'patch_api': [\n      {'selector': 'foo::bar', 'key': 'access', 'value': 'private'}\n    ]\n  }\n}\n</pre>\n<p>The <tt>patch_api</tt> allows you to reach in to the parsed API information and\nupdate certain values. The <tt>selector</tt> is the <tt><span class=\"pre\">unique-name</span></tt> of the\nentity you want to update. Check the \u201cDictionary layout\u201d section further down\nfor more information.</p>\n</div>\n<div id=\"collapse-inline-namespaces\">\n<h3>Collapse inline namespaces</h3>\n<p>For symbol versioning you may use <tt>inline namespaces</tt>, however typically\nyou don\u2019t want these to show up in the docs, as these are mostly\ninvisible for your users.</p>\n<p>With <tt>wurfapi</tt> you can collapse the inline namespace such that it\nis removed form the scopes etc.</p>\n<p>Example:</p>\n<pre>namespace foo { inline namespace v1_2_3 { struct bar{}; } }\n</pre>\n<p>The scope to bar is <tt><span class=\"pre\">foo::v1_2_3</span></tt>. If you collapse the inline namespace it will\njust be <tt>foo</tt>.</p>\n<p>First issue you have to deal with is that Doxygen currently does not\nsupport inline namespaces. So we need to patch the API first:</p>\n<pre>wurfapi = {\n  'source_paths': ['../src'],\n  'recursive': True,\n  'parser': {\n    'type': 'doxygen', 'download': True,  'warnings_as_error': True,\n     'patch_api': [\n      {'selector': 'foo::v1_2_3', 'key': 'inline', 'value': True}\n    ]\n  }\n}\n</pre>\n<p>After this we can collapse the namespace:</p>\n<pre>wurfapi = {\n  'source_paths': ['../src'],\n  'recursive': True,\n  'parser': {\n    'type': 'doxygen', 'download': True,  'warnings_as_error': True,\n     'patch_api': [\n      {'selector': 'foo::v1_2_3', 'key': 'inline', 'value': True}\n    ],\n    'collapse_inline_namespaces': [\n      \"foo::v1_2_3\"\n    ]\n  }\n}\n</pre>\n<p>Now you will be able to refer to <tt>bar</tt> as <tt><span class=\"pre\">foo::bar</span></tt>. Note, that\ncollapsing the namespace will affect the selectors you write when\ngenerating the documentation.</p>\n</div>\n<div id=\"custom-templates\">\n<h3>Custom templates</h3>\n<p>You can write you own custom templates for generating the rst output.\nTo to this you simply write a Jinja2 compatible rst template and place\nit in some folder. Adding the <tt>user_templates</tt> key to the <tt>wurfapi</tt>\nconfiguration dictionary in the <tt>conf.py</tt> file will make it available.</p>\n<p>For example:</p>\n<pre>wurfapi = {\n    'source_paths': ['../src', '../examples/header/header.h'],\n    'recursive': True,\n    'user_templates': 'rst_templates',\n    'parser': {\n        'type': 'doxygen', 'download': True, 'warnings_as_error': True\n    }\n}\n\nexclude_patterns = ['rst_templates/*.rst']\n</pre>\n<p>Now we can use <tt>*.rst</tt> files inside the <tt>rst_templates</tt> folder e.g. if\nwe had a <tt>class_list.rst</tt> template we could use it like this:</p>\n<pre>.. wurfapi:: class_list.rst\n    :selector: project::coffee\n</pre>\n</div>\n</div>\n<div id=\"release-new-version\">\n<h2>Release new version</h2>\n<ol>\n<li><p>Edit <tt>NEWS.rst</tt>, <tt>wscript</tt> and <tt>src/wurfapi/wurfapi.py</tt> (set\ncorrect <tt>VERSION</tt>)</p>\n</li>\n<li><p>Run</p>\n<pre>./waf upload\n</pre>\n</li>\n</ol>\n</div>\n<div id=\"source-code\">\n<h2>Source code</h2>\n</div>\n<div id=\"tests\">\n<h2>Tests</h2>\n<p>The tests will run automatically by passing <tt><span class=\"pre\">--run_tests</span></tt> to waf:</p>\n<pre>./waf --run_tests\n</pre>\n<p>This follows what seems to be \u201cbest practice\u201d advise, namely to install the\npackage in editable mode in a virtualenv.</p>\n<div id=\"recordings\">\n<h3>Recordings</h3>\n<p>A bunch of the tests use a class called <tt>Record</tt>, defined in\n(<tt>test/record.py</tt>). The <tt>Record</tt> class is used to store output as\nfiles from different parsing and rendering operations.</p>\n<p>E.g. say we want to make sure that a parser function returns a certain\n<tt>dict</tt> object. Then we can record that <tt>dict</tt>:</p>\n<pre>recorder = record.Record(filename='test.json',\n                         recording_path='/tmp/recording',\n                         mismatch_path='/tmp/mismatch')\n\nrecorder.record(data={'foo': 2, 'bar': 3})\n</pre>\n<p>If <tt>data</tt> changes compared to a previous recording a mismatch will be\ndetected. To update a recording simply delete the recording file.</p>\n</div>\n<div id=\"test-directories\">\n<h3>Test directories</h3>\n<p>You will also notice that a bunch of the tests take a parameter called\n<tt>testdirectory</tt>. The <tt>testdirectory</tt> is a pytest fixture, which\nrepresents a temporary directory on the filesystem. When running the tests\nyou will notice these temporary test directories pop up under the\n<tt>pytest_temp</tt> directory in the project root.</p>\n<p>You can read more about that here:</p>\n<ul>\n<li><a href=\"https://github.com/steinwurf/pytest-testdirectory\" rel=\"nofollow\">https://github.com/steinwurf/pytest-testdirectory</a></li>\n</ul>\n</div>\n</div>\n<div id=\"developer-notes\">\n<h2>Developer Notes</h2>\n<p>The <cite>sphinx</cite> documentation on creating extensions:\n<a href=\"http://www.sphinx-doc.org/en/stable/extdev/index.html#dev-extensions\" rel=\"nofollow\">http://www.sphinx-doc.org/en/stable/extdev/index.html#dev-extensions</a></p>\n<ul>\n<li>An extension is a Python module. When an extension loads, Sphinx will import\nit and execute its <tt>setup()</tt> function.</li>\n<li>Understanding how to put together docutils nodes seems pretty difficult. One\nsuggesting form the mailinglist was to look at the following document:\n<a href=\"https://github.com/docutils-mirror/docutils/blob/master/test/functional/expected/standalone_rst_pseudoxml.txt\" rel=\"nofollow\">https://github.com/docutils-mirror/docutils/blob/master/test/functional/expected/standalone_rst_pseudoxml.txt</a></li>\n<li>While researching how to do this, there seem to be three potential approaches:<ol>\n<li>Use the standard Sphinx approach and operate with the doctree.</li>\n<li>Create RST based on jinja templates</li>\n<li>Create HTML based on jinja templates</li>\n</ol>\n</li>\n<li>Inspiration - Sphinx extensions that were used as inspiration while\ndeveloping this extension.<ul>\n<li>Breathe</li>\n<li>Gasp</li>\n<li><a href=\"https://github.com/Robpol86/sphinxcontrib-imgur\" rel=\"nofollow\">https://github.com/Robpol86/sphinxcontrib-imgur</a></li>\n<li><a href=\"https://github.com/djungelorm/sphinx-tabs\" rel=\"nofollow\">https://github.com/djungelorm/sphinx-tabs</a></li>\n</ul>\n</li>\n<li>Understanding how to write stuff with docutils:\n* <a href=\"http://agateau.com/2015/docutils-snippets/\" rel=\"nofollow\">http://agateau.com/2015/docutils-snippets/</a></li>\n<li>Creating custom directive\n* <a href=\"http://www.xavierdupre.fr/blog/2015-06-07_nojs.html\" rel=\"nofollow\">http://www.xavierdupre.fr/blog/2015-06-07_nojs.html</a></li>\n<li>Nice looking Sphinx extensions\n* <a href=\"https://github.com/bokeh/bokeh/tree/master/bokeh/sphinxext\" rel=\"nofollow\">https://github.com/bokeh/bokeh/tree/master/bokeh/sphinxext</a></li>\n<li>This part of the documentation was useful in order to understand the need\nfor ViewLists etc. in the directives run(\u2026) function.\n<a href=\"http://www.sphinx-doc.org/en/stable/extdev/markupapi.html\" rel=\"nofollow\">http://www.sphinx-doc.org/en/stable/extdev/markupapi.html</a></li>\n<li>This link provided inspiration for the text json format: <a href=\"https://github.com/micnews/html-to-article-json\" rel=\"nofollow\">https://github.com/micnews/html-to-article-json</a></li>\n<li>More xml-&gt;json for the text: <a href=\"https://www.xml.com/pub/a/2006/05/31/converting-between-xml-and-json.html\" rel=\"nofollow\">https://www.xml.com/pub/a/2006/05/31/converting-between-xml-and-json.html</a></li>\n</ul>\n<div id=\"dictionary-layout\">\n<h3>Dictionary layout</h3>\n<p>We want to support different \u201cbackends\u201d like Doxygen to parse the source\ncode. To make this possible we define an internal source code description\nformat. We then translate e.g. Doxygen XML to this and use that to render\nthe API documentation.</p>\n<p>This way a different \u201cbackend\u201d e.g. Doxygen2 could be use used as the source\ncode parser and the API documentation could be generated.</p>\n<div id=\"unique-name\">\n<h4><tt><span class=\"pre\">unique-name</span></tt></h4>\n<p>In order to be able to reference the different entities in the API we need\nto assign them a name.</p>\n<p>We use a similar approach here as described in <a href=\"https://github.com/foonathan/standardese#linking\" rel=\"nofollow\">standardese</a>.</p>\n<p>This means that the <tt><span class=\"pre\">unique-name</span></tt> of an entity is the name with all\nscopes e.g. <tt><span class=\"pre\">foo::bar::baz</span></tt>.</p>\n<ul>\n<li><p>For functions you need to specify the signature (parameter types and for\nmember functions cv-qualifier and ref-qualifier) e.g. <tt><span class=\"pre\">foo::bar::baz::func()</span></tt>\nor <tt><span class=\"pre\">foo::bar::baz::func(int</span> a, char*) const</tt>. See <a href=\"http://en.cppreference.com/w/cpp/language/member_functions\" rel=\"nofollow\">cppreference</a> for more\ninformation.</p>\n</li>\n<li><p>For class template specializations the unique name includes the specialization\narguments. For example:</p>\n<pre>// Here the unique-name is just 'foo'\ntemplate&lt;class T&gt;\nclass foo {};\n\n// Here the unique name is foo&lt;int&gt;\ntemplate&lt;&gt;\nclass foo&lt;int&gt; {};\n</pre>\n</li>\n<li><p>In addition to types, we also have entries for the parsed files. For files\nthe unique name will be the relative path from the project root.</p>\n</li>\n</ul>\n</div>\n<div id=\"the-api-dictionary\">\n<h4>The API dictionary</h4>\n<p>The internal structure is a dicts with the different API entities. The\n<tt><span class=\"pre\">unique-name</span></tt> of the entity is the key and the entity type also a\nPython dictionary is the value e.g:</p>\n<pre>api = {\n  'unique-name': { ... },\n  'unique-name': { ... },\n  ...\n}\n</pre>\n<p>To make this a bit more concrete consider the following code:</p>\n<pre>namespace ns1\n{\n  class shape\n  {\n    void print(int a) const;\n  };\n\n  namespace ns2\n  {\n    struct box\n    {\n      void hello();\n    };\n\n    void print();\n  }\n}\n</pre>\n<p>Parsing the above code would produce the following API dictionary:</p>\n<pre>api = {\n  'ns1': { 'kind': 'namespace', ...},\n  'ns1::shape': { 'kind': 'class', ... },\n  'ns1::shape::print(int) const': { kind': function' ... },\n  'ns1::ns2': { 'kind': 'namespace', ... },\n  'ns1::ns2::box': { 'kind': 'struct', ... },\n  'ns1::ns2::box::hello()': { kind': function' ... },\n  'ns1::ns2::print()': { 'kind': 'function', ...},\n  'ns1.hpp': { 'kind': 'file', ...}\n}\n</pre>\n<p>The different entity kinds expose different information about the\nAPI. We will document the different kinds in the following.</p>\n<p>We make some keys <em>optional</em> this is marked in the following way:</p>\n<pre>api = {\n  'unique-name': {\n    'some_key': ...\n    Optional('an_optional_key'): ...\n  },\n  ...\n}\n</pre>\n</div>\n<div id=\"namespace-kind\">\n<h4><tt>namespace</tt> Kind</h4>\n<p>Python dictionary representing a C++ namespace:</p>\n<pre>info = {\n  'kind': 'namespace',\n  'name': 'unqualified-name',\n  'scope': 'unique-name' | None,\n  'members: [ 'unique-name', 'unique-name' ],\n  'briefdescription': paragraphs,\n  'detaileddescription': paragraphs,\n  'inline': True | False\n}\n</pre>\n<p>Note: Currently Doxygen does not support parsing <tt>inline namespaces</tt>. So\nyou need to use the patch API to change the value from <tt>False</tt> to <tt>True</tt>\nmanually. Maybe at some point <a href=\"https://github.com/doxygen/doxygen/issues/6741\" rel=\"nofollow\">https://github.com/doxygen/doxygen/issues/6741</a>\nit will be supported.</p>\n</div>\n<div id=\"class-struct-kind\">\n<h4><tt>class</tt> | <tt>struct</tt> Kind</h4>\n<p>Python dictionary representing a C++ class or struct:</p>\n<pre>info = {\n  'kind': 'class' | 'struct',\n  'name': 'unqualified-name',\n  'location': location,\n  'scope': 'unique-name' | None,\n  'access': 'public' | 'protected' | 'private',\n  Optional('template_parameters'): template_parameters,\n  'members: [ 'unique-name', 'unique-name' ],\n  'briefdescription': paragraphs,\n  'detaileddescription': paragraphs\n}\n</pre>\n</div>\n<div id=\"enum-enum-class-kind\">\n<h4><tt>enum</tt> | <tt>enum class</tt> Kind</h4>\n<p>Python dictionary representing a C++ enum or enum class:</p>\n<pre>info = {\n  'kind': 'enum',\n  'name': 'unqualified-name',\n  'location': location,\n  'scope': 'unique-name' | None,\n  'access': 'public' | 'protected' | 'private',\n  'values: [\n    {\n      'name': 'somename',\n      'briefdescription': paragraphs,\n      'detaileddescription': paragraphs,\n      Optional('value'): 'some value'\n    }\n   ],\n  'briefdescription': paragraphs,\n  'detaileddescription': paragraphs\n}\n</pre>\n</div>\n<div id=\"typedef-using-kind\">\n<h4><tt>typedef</tt> | <tt>using</tt> Kind</h4>\n<p>Python dictionary representing a C++ using or typedef statement:</p>\n<pre>info = {\n  'kind': 'typedef' | 'using',\n  'name': 'unqualified-name',\n  'location': location,\n  'scope': 'unique-name' | None,\n  'access': 'public' | 'protected' | 'private',\n  'type': type,\n  'briefdescription': paragraphs,\n  'detaileddescription': paragraphs\n}\n</pre>\n</div>\n<div id=\"file-kind\">\n<h4><tt>file</tt> Kind</h4>\n<p>Python dictionary representing a file in the project:</p>\n<pre>info = {\n  'kind': 'file',\n  'name': 'somefile.hpp',\n  'path': 'relative/path/to/somefile.hpp',\n}\n</pre>\n</div>\n<div id=\"function-kind\">\n<h4><tt>function</tt> Kind</h4>\n<p>Python dictionary representing a C++ function:</p>\n<pre>  info = {\n    'kind': 'function',\n    'name': 'unqualified-name',\n    'location': location,\n    'scope': 'unique-name' | None,\n    Optional('return'): {\n      'type': type,\n      'description': paragraphs\n    }\n    'signature': 'text',\n    Optional('template_parameters'): template_parameters,\n    'is_const': True | False,\n    'is_static': True | False,\n    'is_virtual': True | False,\n    'is_explicit': True | False,\n    'is_inline': True | False,\n    'is_constructor': True | False,\n    'is_destructor': True | False,\n    'trailing_return': True | False,\n    'access': 'public' | 'protected' | 'private',\n    'briefdescription: paragraphs,\n    'detaileddescription: paragraphs,\n    'parameters': [\n      { 'type': type, Optional('name'): 'somename', 'description': paragraphs },\n      ...\n    ]\n}\n</pre>\n<p>The <cite>return</cite> key is optional if the function is either a constructor or\ndestructor.</p>\n</div>\n<div id=\"variable-kind\">\n<h4><tt>variable</tt> Kind</h4>\n<p>Python dictionary representing a C++ variable:</p>\n<pre>info = {\n  'kind': 'variable',\n  'name': 'unqualified-name',\n  Optional('value'): 'some value',\n  'type': type,\n  'location': location,\n  'is_static': True | False,\n  'is_mutable': True | False,\n  'is_volatile': True | False,\n  'is_const': True | False,\n  'is_constexpr': True | False,\n  'scope': 'unique-name' | None,\n  'access': 'public' | 'protected' | 'private',\n  'briefdescription: paragraphs,\n  'detaileddescription: paragraphs,\n}\n</pre>\n</div>\n<div id=\"location-item\">\n<h4><tt>location</tt> item</h4>\n<p>Python dictionary representing a location:</p>\n<pre>location = {\n  Optional('include'): 'some/header.h',\n  'path': 'src/project/header.h',\n  'line-start': 10,\n  'line-end': 12 | None\n  }\n</pre>\n<ul>\n<li>The <tt>include</tt> will be relative to any <tt>include_paths</tt> specified in the\n<tt>wurfapi</tt> dictionary in your Sphinx <tt>conf.py</tt>.</li>\n<li>The <tt>path</tt> will be relative to the project root folder.</li>\n</ul>\n</div>\n<div id=\"type-item\">\n<h4><tt>type</tt> item</h4>\n<p>Python list representing a C++ type:</p>\n<pre>type = [\n  {\n    'value': 'sometext',\n    Optional('link'): link\n  }, ...\n]\n</pre>\n<p>Having the type as a list of items we can create links to nested types e.g.\nsay we have a <cite>std::unique_ptr&lt;impl&gt;</cite> and we would like to make <cite>impl</cite> a link.\nThis could look like:</p>\n<pre>\"type\": [\n  {\n    \"value\": \"std::unique_ptr&lt;\"\n  },\n  {\n    \"link\": {\"url\": False, \"value\": \"project::impl\"},\n    \"value\": \"impl\"\n  },\n  {\n    \"value\": \"&gt;\"\n  }\n]\n</pre>\n<p>Any spaces in the type list should be preserved all the way from the Doxygen\noutput and into the type list. In the rst it should be sufficient to simply\noutput the values of the type. No spaces or other stuff should be injected.</p>\n</div>\n<div id=\"link-item\">\n<h4><tt>link</tt> item</h4>\n<p>Python dictionary representing a link:</p>\n<pre>link = { 'url': True | False, 'value': 'somestring' }\n</pre>\n<p>If <cite>url</cite> is <cite>True</cite> we have a basic extrenal reference otherwise we have a\nlink to an internal type in the API.</p>\n</div>\n<div id=\"parameter-item\">\n<h4><tt>parameter</tt> item</h4>\n<p>Dictionary representing a function parameter:</p>\n<pre>parameter = {\n  'type': type,\n  Optional('name'): 'somestring',\n  Optional('description'): paragraphs\n}\n</pre>\n<p>For the parameter the name is also included into the type list. The reason\nis that some parameters can be pretty complex, with the name embedded\ninside the type e.g.:</p>\n<pre>void function(int (*(*foo)())[3]);\n</pre>\n<p>This is a function which takes one parameter <cite>foo</cite> which is pointer\nfunction returning pointer to array 3 of int - nice right? Anyway, in\nsuch cases the parameter name is embedded inside the type of the parameter.\nWe therefore took the easy out and <cite>wurfapi</cite> will always include the\nparameter name in the type.</p>\n<p>As an example the parameter dictionary for a function <cite>void test(int b)</cite>\ncould be:</p>\n<pre>{\n   'type': [{'value': 'int '}, {'value': 'b'}],\n   'name': 'b'\n}\n</pre>\n</div>\n<div id=\"template-parameters-item\">\n<h4><tt>template_parameters</tt> item</h4>\n<p>Python list of dictionaries representing template parameters:</p>\n<pre>template_parameters = [{\n  'type': type,\n  'name': 'somestring',\n  Optional('default'): type,\n  Optional('description'): paragraphs\n}]\n</pre>\n</div>\n<div id=\"text-information\">\n<h4>Text information</h4>\n<p>Text information is stored in a of list paragraphs:</p>\n<pre>paragraphs = [paragraph]\n</pre>\n<p>A paragraph consists of a list of paragraph elements:</p>\n<pre>paragraph = [\n      {\n        \"kind\": \"text\" | \"code\" | \"list\",\n        ...\n      },\n    ]\n</pre>\n<p>Paragraph elements can be one of three kinds, \u201ctext\u201d, \u201ccode\u201d or \u201clist\u201d:</p>\n<pre>text = {\n  'kind': 'text',\n  'content': 'hello',\n  Optional('link'): link\n  }\n\ncode = {\n  'kind': 'code',\n  'content': 'void print();',\n  'is_block': true | false\n}\n\nlist = {\n  'kind': 'list',\n  'ordered': true | false,\n  'items': [paragraphs] # Each item is a list of paragraphs\n}\n</pre>\n</div>\n<div id=\"problem-with-unique-name-for-functions\">\n<h4>Problem with <tt><span class=\"pre\">unique-name</span></tt> for functions</h4>\n<p>Issue equivalent C++ function signatures can be written in a number of\ndifferent ways:</p>\n<pre>void hello(const int *x); // x is a pointer to const int\nvoid hello(int const *x); // x is a pointer to const int\n</pre>\n<p>We can also move the asterisk (<tt>*</tt>) to the left:</p>\n<pre>void hello(const int* x); // x is a pointer to const int\nvoid hello(int const* x); // x is a pointer to const int\n</pre>\n<p>So we need some way to normalize the function signature when transforming it\nto <tt><span class=\"pre\">unique-name</span></tt>. We cannot simply rely on sting comparisons.</p>\n<p>According to the numerous google searches it is hard to write a regex for this.\nInstead we will try to use a parser:</p>\n<ul>\n<li>Python parser: <a href=\"https://github.com/erezsh/lark\" rel=\"nofollow\">https://github.com/erezsh/lark</a></li>\n<li>C++ Grammar: <a href=\"http://www.externsoft.ch/media/swf/cpp11-iso.html#parameters_and_qualifiers\" rel=\"nofollow\">http://www.externsoft.ch/media/swf/cpp11-iso.html#parameters_and_qualifiers</a></li>\n</ul>\n<p>We only need to parse the function parameter list denoted as the\n<tt><span class=\"pre\">http://www.externsoft.ch/media/swf/cpp11-iso.html#parameters_and_qualifiers</span></tt>.</p>\n</div>\n</div>\n<div id=\"generated-output\">\n<h3>Generated output</h3>\n<p>Since we are going to be using Doxygen\u2019s XML output as input to the\nextension we need a place to store it. We store it system temporary folder e.g.\nif the project name is \u201cfoobar\u201d on Linux this would be\n<tt><span class=\"pre\">/tmp/wurfapi-foobar-123456</span></tt> where <tt>123456</tt> is a hash of the source\ndirectory paths. In addition to Doxygen\u2019s XML we also store the generated rst\nfor the different directives there. This is nice for debugging to see whether\nwe generate broken rst.</p>\n<p>The API in json format can be found in the <tt><span class=\"pre\">_build/.doctree/wurfapi_api.json</span></tt>.</p>\n</div>\n<div id=\"paths-and-directories\">\n<h3>Paths and directories</h3>\n<ul>\n<li>Source directory: In Sphinx the source directory is where our .rst files are\nlocated. This is what you pass to <tt><span class=\"pre\">sphinx-build</span></tt> when building your\ndocumentation. We will use this in our extension to find the C++ source code\nand output customization templates.</li>\n</ul>\n</div>\n</div>\n<div id=\"notes\">\n<h2>Notes</h2>\n<ul>\n<li>Why use an <tt>src</tt> folder (<a href=\"https://hynek.me/articles/testing-packaging/\" rel=\"nofollow\">https://hynek.me/articles/testing-packaging/</a>).\ntl;dr you should run your tests in the same environment as your users would\nrun your code. So by placing the source files in a non-importable folder you\navoid accidentally having access to resources not added to the Python\npackage your users will install\u2026</li>\n<li>Python packaging guide: <a href=\"https://packaging.python.org/distributing/\" rel=\"nofollow\">https://packaging.python.org/distributing/</a></li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 7082961, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "5c7327991e5d4b39d43c18109177c818", "sha256": "c3335fe0464b77b2d6efe8401af09c992610add2ac813d3a3c4f42aa00314959"}, "downloads": -1, "filename": "wurfapi-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "5c7327991e5d4b39d43c18109177c818", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 20966, "upload_time": "2018-05-16T21:07:21", "upload_time_iso_8601": "2018-05-16T21:07:21.532942Z", "url": "https://files.pythonhosted.org/packages/a9/a5/e7008bfb185fa4ef2c79aa05921c0466ab293ebd88efe8c93b700ab328c2/wurfapi-1.0.0-py2.py3-none-any.whl", "yanked": false}], "2.1.0": [{"comment_text": "", "digests": {"md5": "63e03c21f5d3f727cd6188a2a6c06734", "sha256": "98073ddf34645f33e1ecc60b53c62998d10f1c04f0af606cde3af4d247c9da25"}, "downloads": -1, "filename": "wurfapi-2.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "63e03c21f5d3f727cd6188a2a6c06734", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 26086, "upload_time": "2018-07-30T12:30:52", "upload_time_iso_8601": "2018-07-30T12:30:52.467928Z", "url": "https://files.pythonhosted.org/packages/91/34/c34b5a07c119166ba63c42fbfece22ccd7f370f76ba1dccefe08ff377c6e/wurfapi-2.1.0-py2.py3-none-any.whl", "yanked": false}], "2.2.0": [{"comment_text": "", "digests": {"md5": "021434ca8290c46d6624be0fc43d27cb", "sha256": "455102aa2751b90838ea5d38b71f9428be4b9366aa6a6b125c4c2a334748d6e4"}, "downloads": -1, "filename": "wurfapi-2.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "021434ca8290c46d6624be0fc43d27cb", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 26201, "upload_time": "2018-08-01T13:20:17", "upload_time_iso_8601": "2018-08-01T13:20:17.443350Z", "url": "https://files.pythonhosted.org/packages/61/4c/27c93d2fae22c13e765e8feb767dfbabf24cc71c1f744bc2115ab65409d2/wurfapi-2.2.0-py2.py3-none-any.whl", "yanked": false}], "3.0.0": [{"comment_text": "", "digests": {"md5": "394d53d8ed21ad2c9eb0ec9bcaf3733b", "sha256": "80150f309e0bfe999e1194ef679723202214cc69acabb0b1e616064f100ac07e"}, "downloads": -1, "filename": "wurfapi-3.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "394d53d8ed21ad2c9eb0ec9bcaf3733b", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 41525, "upload_time": "2019-07-22T21:06:11", "upload_time_iso_8601": "2019-07-22T21:06:11.941669Z", "url": "https://files.pythonhosted.org/packages/dd/31/e4f51e6903f2e36ca3fc86724a997c17f8f3314064edd1bea410c0f32c5f/wurfapi-3.0.0-py2.py3-none-any.whl", "yanked": false}], "4.0.0": [{"comment_text": "", "digests": {"md5": "9d1da9dfb47c875d8064b14d0801a32d", "sha256": "98e7080cf70c350e7657d8fd24b5d729ea811a9f32b67281cb6ff41608ab907b"}, "downloads": -1, "filename": "wurfapi-4.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9d1da9dfb47c875d8064b14d0801a32d", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 42352, "upload_time": "2020-01-20T08:58:02", "upload_time_iso_8601": "2020-01-20T08:58:02.836267Z", "url": "https://files.pythonhosted.org/packages/f1/ac/141a01aa1a18880f15c5b2acd219afc50db2ff1bf619cd38bb2b9b08e12c/wurfapi-4.0.0-py2.py3-none-any.whl", "yanked": false}], "5.0.0": [{"comment_text": "", "digests": {"md5": "82386db93c540ceb42e1eb790d3b4418", "sha256": "2ed7531df96d4c7ad9b51ba314b1ea1d5e7e32ab913433c67737d1bb7fb0d174"}, "downloads": -1, "filename": "wurfapi-5.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "82386db93c540ceb42e1eb790d3b4418", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 42702, "upload_time": "2020-02-02T16:14:33", "upload_time_iso_8601": "2020-02-02T16:14:33.637283Z", "url": "https://files.pythonhosted.org/packages/8c/b1/d9c7ab3e4f99136eb5f94a458e8143837bc5a5286c96ca459529ac68cdef/wurfapi-5.0.0-py2.py3-none-any.whl", "yanked": false}], "5.1.0": [{"comment_text": "", "digests": {"md5": "5cb2523f32d671a0597ff83e43c7747f", "sha256": "8640e40a442421fc8b1bdd2bec283d45b380a9327902e18b76b103570b1de795"}, "downloads": -1, "filename": "wurfapi-5.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "5cb2523f32d671a0597ff83e43c7747f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 42842, "upload_time": "2020-03-16T09:35:54", "upload_time_iso_8601": "2020-03-16T09:35:54.072326Z", "url": "https://files.pythonhosted.org/packages/a3/3f/f3183cabfe92320fb317b21146f562d56a1731c9e2ae2f7c36ffb9106125/wurfapi-5.1.0-py2.py3-none-any.whl", "yanked": false}], "5.1.1": [{"comment_text": "", "digests": {"md5": "5f3fc4c4401eb0a221cf5241e8276cc1", "sha256": "de0cd938eb9c9572ffabd53fe75a34898cec4b2028b8620a6770c59b8f192c7e"}, "downloads": -1, "filename": "wurfapi-5.1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "5f3fc4c4401eb0a221cf5241e8276cc1", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 42846, "upload_time": "2020-04-21T10:19:52", "upload_time_iso_8601": "2020-04-21T10:19:52.826629Z", "url": "https://files.pythonhosted.org/packages/fd/0d/984708cf6b5069baba198e1153c85bb9f39205bd68b9d8252e0edec54ec3/wurfapi-5.1.1-py2.py3-none-any.whl", "yanked": false}], "6.0.0": [{"comment_text": "", "digests": {"md5": "acffbbe9e756da30a218c9e227f6f015", "sha256": "b6fa038ad3c61aa4eaca1ffe54c01d1941509d65e8711d7f6232e10dd62d15d4"}, "downloads": -1, "filename": "wurfapi-6.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "acffbbe9e756da30a218c9e227f6f015", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 43114, "upload_time": "2020-04-23T09:09:53", "upload_time_iso_8601": "2020-04-23T09:09:53.386414Z", "url": "https://files.pythonhosted.org/packages/81/47/c7e3f04e836dfea7d9ae856c0610bd49255e542a433bcb42c3538cd82018/wurfapi-6.0.0-py2.py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "acffbbe9e756da30a218c9e227f6f015", "sha256": "b6fa038ad3c61aa4eaca1ffe54c01d1941509d65e8711d7f6232e10dd62d15d4"}, "downloads": -1, "filename": "wurfapi-6.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "acffbbe9e756da30a218c9e227f6f015", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 43114, "upload_time": "2020-04-23T09:09:53", "upload_time_iso_8601": "2020-04-23T09:09:53.386414Z", "url": "https://files.pythonhosted.org/packages/81/47/c7e3f04e836dfea7d9ae856c0610bd49255e542a433bcb42c3538cd82018/wurfapi-6.0.0-py2.py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 03:26:45 2020"}