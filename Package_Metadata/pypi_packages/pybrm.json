{"info": {"author": "Matthew Moisen", "author_email": "mmoisen@cisco.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "Intended Audience :: Telecommunications Industry", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Operating System :: POSIX :: Linux", "Programming Language :: C", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: Implementation :: CPython"], "description": "# pybrm\nA Python C wrapper for Oracle BRM.\n\n`pybrm` requires >= Python 3.6 and is tested with Python 3.6.5 and 3.7.1, on BRM 7.5 (GCC 4.4.7) and BRM 12 (GCC 4.8.5). It has been tested on both 32bit and 64bit.\n\n# Installation\nTo install and compile `pybrm`, your `PIN_HOME` environment variable must point to the BRM home directory.\n\nInstall it with `pip` like this:\n\n    pip install pybrm\n\nThe installation will determine if you are on 32bit or 64bit Python and attempt to install correctly.\n\n# Usage\n\nImports:\n\n    from pybrm import Client\n    from datetime import datetime\n    \nOpen up a client CM connection:\n\n    c = Client()\n    \nCreate an empty flist:\n\n    f = c.flist()\n    \nSet some scalar data on the flist:\n\n    f['PIN_FLD_POID'] = '/account'  # type /account, id -1, revision 0\n    f['PIN_FLD_STATUS'] = 1\n    f['PIN_FLD_CREATED_T'] = datetime.now()  # you can also set it to an integer\n\nCreate a substructure in one shot, the preferred way:\n\n    f['PIN_FLD_INHERITED_INFO'] = {\n        'PIN_FLD_POID': ('/service', 1234), # type service, id 1234, revision 0\n        'PIN_FLD_STATUS': 2,\n    }\n\nPrint the flist:\n\n    >>> print(f)\n    0 PIN_FLD_POID           POID [0] 0.0.0.1 /account -1 0\n    0 PIN_FLD_STATUS         ENUM [0] 1\n    0 PIN_FLD_CREATED_T    TSTAMP [0] (1582600707) Mon Feb 24 19:18:27 2020\n    0 PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n    1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 0\n    1     PIN_FLD_STATUS         ENUM [0] 2\n\nYou can also build up a substruct it up piece by piece:\n\n    f['PIN_FLD_EVENT'] = {}  # Creates an empty substruct\n    f['PIN_FLD_EVENT']['PIN_FLD_POID'] = ('/service', 1234, 1)  # type service, id 1234, revision 1\n    \n    # You can pull a subsctruct out into its own variable if you like\n    substruct = f['PIN_FLD_EVENT']\n    substruct['PIN_FLD_STATUS'] = 3\n\nLet's print it again:\n\n    >>> print(f)\n    # number of field entries allocated 20, used 5\n    0 PIN_FLD_POID           POID [0] 0.0.0.1 /account -1 0\n    0 PIN_FLD_STATUS         ENUM [0] 1\n    0 PIN_FLD_CREATED_T    TSTAMP [0] (1582600707) Mon Feb 24 19:18:27 2020\n    0 PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n    1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 0\n    1     PIN_FLD_STATUS         ENUM [0] 2\n    0 PIN_FLD_EVENT        SUBSTRUCT [0] allocated 20, used 2\n    1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 1\n    1     PIN_FLD_STATUS         ENUM [0] 3\n\nCreate an array in one shot, the preferred way with dict syntax `{}`. The keys are the elem_ids, and the values are flists. In this example, we will creates two flists on elem_id 4 and 16:\n\n    f['PIN_FLD_ARGS'] = {\n        4: {'PIN_FLD_STATUS': 4},\n        16: {'PIN_FLD_STATUS': 5},\n    }\n\nLet's print if again:\n\n    >>> print(f)\n    # number of field entries allocated 20, used 9\n    0 PIN_FLD_POID           POID [0] 0.0.0.1 /account -1 0\n    0 PIN_FLD_STATUS         ENUM [0] 1\n    0 PIN_FLD_CREATED_T    TSTAMP [0] (1582600707) Mon Feb 24 19:18:27 2020\n    0 PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n    1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 0\n    1     PIN_FLD_STATUS         ENUM [0] 2\n    0 PIN_FLD_EVENT        SUBSTRUCT [0] allocated 20, used 2\n    1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 1\n    1     PIN_FLD_STATUS         ENUM [0] 3\n    0 PIN_FLD_ARGS          ARRAY [4] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 4\n\nYou can instead use list syntax `[]`, and not specify the elem_ids. This will automatically start the elem_id off at 0 and increase it by one for each flist.\n\n    f['PIN_FLD_RESULTS'] = [\n        {'PIN_FLD_STATUS': 6},  # sets at elem_id 0\n        {'PIN_FLD_STATUS': 7},  # sets at elem_id 1 \n    ]\n\nLet's print it again:\n\n    >>> print(f)\n    # number of field entries allocated 20, used 9\n    0 PIN_FLD_POID           POID [0] 0.0.0.1 /account -1 0\n    0 PIN_FLD_STATUS         ENUM [0] 1\n    0 PIN_FLD_CREATED_T    TSTAMP [0] (1582600707) Mon Feb 24 19:18:27 2020\n    0 PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n    1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 0\n    1     PIN_FLD_STATUS         ENUM [0] 2\n    0 PIN_FLD_EVENT        SUBSTRUCT [0] allocated 20, used 2\n    1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 1\n    1     PIN_FLD_STATUS         ENUM [0] 3\n    0 PIN_FLD_ARGS          ARRAY [4] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 4\n    0 PIN_FLD_ARGS          ARRAY [16] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 5\n    0 PIN_FLD_RESULTS       ARRAY [0] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 6\n    0 PIN_FLD_RESULTS       ARRAY [1] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 7\n    \nYou can also build up an array piece by piece:\n\n    f['PIN_FLD_VALUES'] = {}  #  Creates an empty array\n    f['PIN_FLD_VALUES'][0] = {'PIN_FLD_STATUS': 8}  # Adds an flist on the 0th elem_id of this array\n    \n    # You can pull an array out into its own variable if you like\n    array = f['PIN_FLD_VALUES']\n    array[1] = {}  # Create empty flist on the 1st elem_id of this array\n    array[1]['PIN_FLD_STATUS'] = 9  # set one field on the flist we just created\n\nLet's print it again:\n\n    >>> print(f)\n    # number of field entries allocated 20, used 11\n    0 PIN_FLD_POID           POID [0] 0.0.0.1 /account -1 0\n    0 PIN_FLD_STATUS         ENUM [0] 1\n    0 PIN_FLD_CREATED_T    TSTAMP [0] (1582600707) Mon Feb 24 19:18:27 2020\n    0 PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n    1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 0\n    1     PIN_FLD_STATUS         ENUM [0] 2\n    0 PIN_FLD_EVENT        SUBSTRUCT [0] allocated 20, used 2\n    1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 1\n    1     PIN_FLD_STATUS         ENUM [0] 3\n    0 PIN_FLD_ARGS          ARRAY [4] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 4\n    0 PIN_FLD_ARGS          ARRAY [16] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 5\n    0 PIN_FLD_RESULTS       ARRAY [0] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 6\n    0 PIN_FLD_RESULTS       ARRAY [1] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 7\n    0 PIN_FLD_VALUES        ARRAY [0] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 8\n    0 PIN_FLD_VALUES        ARRAY [1] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 9\n\nHowever, it's better to just create it all with a dict. This will keep your code clean:\n\n    f = c.flist({\n        'PIN_FLD_POID': '/account',\n        'PIN_FLD_STATUS': 1,\n        'PIN_FLD_CREATED_T': datetime.now(),\n        'PIN_FLD_INHERITED_INFO': {\n            'PIN_FLD_POID': ('/service', 1234),\n            'PIN_FLD_STATUS': 2,\n        },\n        'PIN_FLD_EVENT': {\n            'PIN_FLD_POID': ('/service', 1234, 1),\n            'PIN_FLD_STATUS': 3,\n        },\n        'PIN_FLD_ARGS': {\n            4: {'PIN_FLD_STATUS': 4},\n            16: {'PIN_FLD_STATUS': 5},\n        },\n        'PIN_FLD_RESULTS': [\n            {'PIN_FLD_STATUS': 6},\n            {'PIN_FLD_STATUS': 7},\n        ],\n        'PIN_FLD_VALUES': {\n            0: {'PIN_FLD_STATUS': 8},\n            1: {'PIN_FLD_STATUS': 9},\n        },\n    })\n\nCall an opcode via PCM_OP with no flags:\n    \n    output = f('PCM_OP_TEST_LOOPBACK')  # or f.opcode('PCM_OP_TEST_LOOPBACK')\n\nCall an opcode via PCM_OP with one flag:\n\n    output = f('PCM_OP_TEST_LOOPBACK', flags='SRCH_DISTINCT')\n\nCall an opcode via PCM_OP with multiple flags:\n\n    output = f('PCM_OP_TEST_LOOPBACK', flags=('SRCH_DISTINCT', 'PCM_OPFLG_REV_CHECK'))\n\nYou can also use the `f.opcode` function. One benefit is you can ctrl+f to find all opcode calls.\n\n    output = f.opcode('PCM_OP_TEST_LOOPBACK', flags='SRCH_DISTINCT')\n \nTo use PCM_OPREF, which passes the reference of the flist to the opcode, instead of a copy like PCM_OP:\n    \n    output = f('PCM_OP_TEST_LOOPBACK', reference=True)  # or f.opcode('PCM_OP_TEST_LOOPBACK', reference=True)\n\n\nGet some data off the flist:\n\n    status = f['PIN_FLD_STATUS']\n    assert status == 1\n    \n    poid = f['PIN_FLD_POID']\n    assert poid.type == '/account'\n    assert poid.id == -1\n    assert poid.revision == 0\n    print(poid.database)  # this is picked up dynamically, but is probably 1\n    \n    assert f['PIN_FLD_INHERITED_INFO']['PIN_FLD_POID'].type == '/service'\n    assert len(f['PIN_FLD_VALUES']) == 2\n    assert f['PIN_FLD_VALUES'][0]['PIN_FLD_STATUS'] == 8\n\nGet the length:\n\n\n    assert len(f) == 8\n    assert f.count() == 8  # same as len\n    assert f.count(recursive=True) == 18  # counts items in arrays/substructs\n    \n    assert len(f['PIN_FLD_INHERITED_INFO']) == 2  # count of a substruct\n    assert f['PIN_FLD_INHERITED_INFO'].count() == 2 # same as len\n    \n    assert len(f['PIN_FLD_VALUES']) == 2  # count of an array\n    assert f['PIN_FLD_VALUES'].count() == 2  # same as len\n    \n\nGet all the field names:\n\n    >>> print(list(f.keys())\n    ['PIN_FLD_POID', 'PIN_FLD_STATUS', 'PIN_FLD_CREATED_T', 'PIN_FLD_INHERITED_INFO', 'PIN_FLD_EVENT', 'PIN_FLD_ARGS', 'PIN_FLD_RESULTS', 'PIN_FLD_VALUES']\n\nCheck if a field exists on our flist:\n\n    >>> 'PIN_FLD_POID' in f\n    True\n    >>> 'PIN_FLD_EVENT' in f\n    True\n    >>> 'PIN_FLD_VALUES' in f\n    True\n    >>> 'PIN_FLD_QUANTITY' in f\n    False\n\nGet an flist at a particular elem_id from an array:\n\n    child = f['PIN_FLD_VALUES'][0]\n    child = f['PIN_FLD_VALUES'][1]\n\nGet any flist from an array (PIN_ELEMID_ANY):\n\n    child = f['PIN_FLD_VALUES']['*']\n    # This is equivalent\n    child = f['PIN_FLD_VALUES']['PIN_ELEMID_ANY']\n    # This is also equivalent\n    child = f['PIN_FLD_VALUES'][-1]\n\nDelete a field:\n\n    assert 'PIN_FLD_STATUS' in f\n    del f['PIN_FLD_STATUS']\n    assert 'PIN_FLD_STATUS' not in f\n\n# Searching Shortcuts for PCM_OP_SEARCH\n\nYou can create your own flists and call `PCM_OP_SEARCH` yourself, however the `client.search()` make searching convenient with syntactic sugar:\n\n    output = c.search(\n        template=' select X from /foo where F1 = V1 and F2 = V2',\n        search_flags='SRCH_DISTINCT',\n        args={'PIN_FLD_LOGIN': 'bar', 'PIN_FLD_USAGE_TYPE': 'foo'},\n    )\n\nThis would build the following search flist and execute it, returning the results:\n\n    # number of field entries allocated 20, used 6\n    0 PIN_FLD_POID           POID [0] 0.0.0.1 /search -1 0\n    0 PIN_FLD_FLAGS           INT [0] 256\n    0 PIN_FLD_TEMPLATE        STR [0] \" select X from /foo where F1 = V1 and F2 = V2\"\n    0 PIN_FLD_ARGS          ARRAY [1] allocated 20, used 1\n    1     PIN_FLD_LOGIN           STR [0] \"bar\"\n    0 PIN_FLD_ARGS          ARRAY [2] allocated 20, used 1\n    1     PIN_FLD_USAGE_TYPE      STR [0] \"foo\"\n    0 PIN_FLD_RESULTS       ARRAY [*] allocated 0, used 0\n\nFor the `args` parameter, you may specify it with a dict, or a list of tuples. These two are the same:\n\n    output = c.search(\n        template=' select X from /foo where F1 = V1 and F2 = V2',\n        args={'PIN_FLD_LOGIN': 'bar', 'PIN_FLD_USAGE_TYPE': 'foo'},\n    )\n    \n    output = c.search(\n        template=' select X from /foo where F1 = V1 and F2 = V2',\n        args=[('PIN_FLD_LOGIN', 'bar'), ('PIN_FLD_USAGE_TYPE', 'foo')],\n    )\n\nUsing a dict in args is just syntactic sugar to save a few keystrokes.\nSometimes you cannot use the dict, for example if you have a template like `select C from /foo where F1 IN (V1, V2)`.\nA dict will not work because a dict can only have unique keys.\n\n    output = c.search(\n        template=' select X from /foo where F1 IN (V1, V2) ',\n        args=[\n            ('PIN_FLD_USAGE_TYPE', 'FOO'),\n            ('PIN_FLD_USAGE_TYPE', 'BAR')\n        ]\n    )\n\nThis would build the following search flist:\n\n    # number of field entries allocated 20, used 6\n    0 PIN_FLD_POID           POID [0] 0.0.0.1 /search -1 0\n    0 PIN_FLD_FLAGS           INT [0] 0\n    0 PIN_FLD_TEMPLATE        STR [0] \" select C from /foo where F1 IN (V1, V2) \"\n    0 PIN_FLD_ARGS          ARRAY [1] allocated 20, used 1\n    1     PIN_FLD_USAGE_TYPE      STR [0] \"FOO\"\n    0 PIN_FLD_ARGS          ARRAY [2] allocated 20, used 1\n    1     PIN_FLD_USAGE_TYPE      STR [0] \"BAR\"\n    0 PIN_FLD_RESULTS       ARRAY [*] allocated 0, used 0\n\nYou can use nested substructs and arrays in the `args` param like the following:\n\n    output = c.search(\n        template=' select X from /foo where F1 = V1 ',\n        args={'PIN_FLD_EVENT': {'PIN_FLD_USAGE_TYPE': 'bar'}}\n    )\n\nThis would create the following search flist:\n\n    # number of field entries allocated 20, used 5\n    0 PIN_FLD_POID           POID [0] 0.0.0.1 /search -1 0\n    0 PIN_FLD_FLAGS           INT [0] 0\n    0 PIN_FLD_TEMPLATE        STR [0] \" select X from /foo where F1 = V1 \"\n    0 PIN_FLD_ARGS          ARRAY [1] allocated 20, used 1\n    1     PIN_FLD_EVENT        SUBSTRUCT [0] allocated 20, used 1\n    2         PIN_FLD_USAGE_TYPE      STR [0] \"bar\"\n    0 PIN_FLD_RESULTS       ARRAY [*] allocated 0, used 0\n\nYou may customize the results of the search by using the `results` argument. By default, it will return all all the fields.\n\nThis will return only the three fields specified in `results`:\n\n    output = c.search(\n        template=' select X from /foo where F1 = V1 ',\n        args={'PIN_FLD_LOGIN': 'bar'},\n        results={'PIN_FLD_USAGE_TYPE', 'PIN_FLD_EVENT_TYPE', 'PIN_FLD_SERVICE_TYPE'}\n    )\n\nHere is the search flist that would be created:\n\n    # number of field entries allocated 20, used 5\n    0 PIN_FLD_POID           POID [0] 0.0.0.1 /search -1 0\n    0 PIN_FLD_FLAGS           INT [0] 0\n    0 PIN_FLD_TEMPLATE        STR [0] \" select X from /foo where F1 = V1 \"\n    0 PIN_FLD_ARGS          ARRAY [1] allocated 20, used 1\n    1     PIN_FLD_LOGIN           STR [0] \"bar\"\n    0 PIN_FLD_RESULTS       ARRAY [*] allocated 20, used 3\n    1     PIN_FLD_EVENT_TYPE      STR [0] NULL str ptr\n    1     PIN_FLD_USAGE_TYPE      STR [0] NULL str ptr\n    1     PIN_FLD_SERVICE_TYPE    STR [0] NULL str ptr\n\nThese three are identical:\n\n    output = c.search(\n        template=' select X from /foo where F1 = V1 ',\n        args={'PIN_FLD_LOGIN': 'bar'},\n        results={'PIN_FLD_USAGE_TYPE', 'PIN_FLD_EVENT_TYPE', 'PIN_FLD_SERVICE_TYPE'}\n    )\n    \n    output = c.search(\n        template=' select X from /foo where F1 = V1 ',\n        args={'PIN_FLD_LOGIN': 'bar'},\n        results={'PIN_FLD_USAGE_TYPE': None, 'PIN_FLD_EVENT_TYPE': None, 'PIN_FLD_SERVICE_TYPE': None}\n    )\n    \n    output = c.search(\n        template=' select X from /foo where F1 = V1 ',\n        args={'PIN_FLD_LOGIN': 'bar'},\n        results=['PIN_FLD_USAGE_TYPE', 'PIN_FLD_EVENT_TYPE', 'PIN_FLD_SERVICE_TYPE']\n    )\n\nThe following will return all the fields in the substructure:\n\n    output = c.search(\n        template=' select X from /foo where F1 = V1 ',\n        args={'PIN_FLD_LOGIN': 'bar'},\n        results={'PIN_FLD_INHERITED_INFO'}\n    )\n\n\nThis will return only the subset of fields in the substructure:\n\n    output = c.search(\n        template=' select X from /foo where F1 = V1 ',\n        args={'PIN_FLD_LOGIN': 'bar'},\n        results={'PIN_FLD_INHERITED_INFO': {\n            'PIN_FLD_USAGE_TYPE', 'PIN_FLD_EVENT_TYPE'\n        }}\n    )\n\nHere is the search flist that would be created:\n\n    # number of field entries allocated 20, used 5\n    0 PIN_FLD_POID           POID [0] 0.0.0.1 /search -1 0\n    0 PIN_FLD_FLAGS           INT [0] 0\n    0 PIN_FLD_TEMPLATE        STR [0] \" select X from /foo where F1 = V1 \"\n    0 PIN_FLD_ARGS          ARRAY [1] allocated 20, used 1\n    1     PIN_FLD_LOGIN           STR [0] \"bar\"\n    0 PIN_FLD_RESULTS       ARRAY [*] allocated 20, used 1\n    1     PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n    2         PIN_FLD_EVENT_TYPE      STR [0] NULL str ptr\n    2         PIN_FLD_USAGE_TYPE      STR [0] NULL str ptr\n\nYou can do the same with arrays, for example `PIN_FLD_FIELD`.\n\n    output = c.search(\n        template=' select X from /foo where F1 = V1 ',\n        args={'PIN_FLD_LOGIN': 'bar'},\n        results={'PIN_FLD_FIELD': {\n            'PIN_FLD_USAGE_TYPE', 'PIN_FLD_EVENT_TYPE'\n        }}\n    )\n\nHere is the search flist that would be created:\n\n    # number of field entries allocated 20, used 5\n    0 PIN_FLD_POID           POID [0] 0.0.0.1 /search -1 0\n    0 PIN_FLD_FLAGS           INT [0] 0\n    0 PIN_FLD_TEMPLATE        STR [0] \" select X from /foo where F1 = V1 \"\n    0 PIN_FLD_ARGS          ARRAY [1] allocated 20, used 1\n    1     PIN_FLD_LOGIN           STR [0] \"bar\"\n    0 PIN_FLD_RESULTS       ARRAY [*] allocated 20, used 1\n    1     PIN_FLD_FIELD         ARRAY [*] allocated 20, used 2\n    2         PIN_FLD_EVENT_TYPE      STR [0] NULL str ptr\n    2         PIN_FLD_USAGE_TYPE      STR [0] NULL str ptr\n\nYou can specify the search flags in `PIN_FLD_FLAGS` via the `search_flags` parameter:\n\n    output = c.search(\n        template=' select X from /foo where F1 = V1 ',\n        search_flags='SRCH_DISTINCT',\n        args={'PIN_FLD_LOGIN': 'bar'},\n    )\n\nYou can pass in more than one search flag in a sequence:\n\n    output = c.search(\n        template=' select X from /foo where F1 = V1 ',\n        search_flags=('SRCH_DISTINCT', 'SRCH_EXACT'),\n        args={'PIN_FLD_LOGIN': 'bar'},\n    )\n\nYou can specify the opcode flags via the `opcode_flags` parameter:\n\n    output = c.search(\n        template=' select X from /foo where F1 = V1 ',\n        search_flags=('SRCH_DISTINCT', 'SRCH_EXACT'),\n        args={'PIN_FLD_LOGIN': 'bar'},\n        opcode_flags='PCM_OPFLG_CACHEABLE',\n    )\n\n\nIn fact, if you want to examine the search flist, and not execute it, you can use `c.search_build_flist()`:\n\n    search =c.search_build_flist(\n        template=' select X from /foo where F1 = V1 ',\n        args={'PIN_FLD_LOGIN': 'bar'},\n    )\n    print(search)\n\n# Substructures and Arrays\n\nOne important thing to note about substructures is that when you add one flist to another flist, it is ALWAYS copied.\n \n\n    c = Client()\n    f = c.flist({'PIN_FLD_STATUS': 1}) \n    f2 = c.flist()\n    \n    # COPY f onto f2\n    f2['PIN_FLD_INHERITED_INFO'] = f\n    \n    # Change f, which does not change anything on f2\n    f['PIN_FLD_STATUS'] = 2\n    # The copy on f2['PIN_FLD_INHERITED_INFO'] was not changed!\n    assert f2['PIN_FLD_INHERITED_INFO']['PIN_FLD_STATUS'] == 1\n\nThe same is true for arrays:\n\n    c = Client()\n    f = c.flist({'PIN_FLD_STATUS': 1})\n    f2 = c.flist()\n    \n    # COPY f2 onto f's PIN_FLD_VALUES array\n    f2['PIN_FLD_VALUES'] = {0: f}\n    \n    # Change f, which does not change anything on f2\n    f['PIN_FLD_STATUS'] = 2\n    # The copy on f['PIN_FLD_VALUES'][0] was not changed!\n    assert f2['PIN_FLD_VALUES'][0]['PIN_FLD_STATUS'] == 1\n    \nBoth the FList and the BRMArray classes implement the Python dictionary protocol. What this means is that they both have a key that maps to a value. \nIn the case of an flist, the key is the field, and the value is the value of the flist at that field. \nIn the case of a BRMArray, the key is the elem_id, and the value is the flist at that elem_id.\n\n\nDo not try to iterate over a BRMArray like a Python list:\n\n    f = c.flist({\n        'PIN_FLD_VALUES': [\n            {'PIN_FLD_STATUS': 2},\n            {'PIN_FLD_STATUS': 4},\n        ]\n    })\n    \n    # Wrong, probably not what you want:\n    >>> for v in f['PIN_FLD_VALUES']:\n    >>>     v\n    0\n    1\n\nDoing it that way will return the keys, or elem_ids of the BRMArray, which in this case are `0` and `1`.\n\nInstead, you have to use the `.values()` function, like you would on a dict in python:\n\n    >>> for v in f['PIN_FLD_VALUES'].values():\n    >>>     v\n    {'PIN_FLD_STATUS': 2}\n    {'PIN_FLD_STATUS': 4}\n    \nLikewise, to get the keys and the values, use `.items()`:\n\n    >>> for k, v in f['PIN_FLD_VALUES'].items():\n    >>>     k, v\n    (0, {'PIN_FLD_STATUS': 2})\n    (1, {'PIN_FLD_STATUS': 4})\n\n\n## Empty Array Behavior\n\nThere is some behavior with empty arrays that is important to keep in mind.\n\nIn the following example, does anything happen to the C flist?\n\n    c = client()\n    f = c.flist()\n    f['PIN_FLD_RESULTS'] = {}\n    \nNo, nothing has happened. We have not added any flists at all. However in Python we can access this array:\n\n    ar = f['PIN_FLD_RESULTS']\n    \nMost importantly to keep in mind, we can check if `PIN_FLD_RESULTS` exists on our flist:\n\n    if 'PIN_FLD_RESULTS' in f:\n        print('yes it exists')\n\nHowever, in fact there is nothing on the C flist at this point, until you add your first flist:\n\n    ar[0] = {'PIN_FLD_POID': '/foo'}\n\nIt's worth repeating: the BRMArray class is not implemented as a list, but rather as a dictionary.\nWhy was this decision made? An array in brm is sparse array where each value is an flist.\nYou can put an flist at index 2 of an array, and then place another flist on the 9th position, leaving gaps in between.\nDue to this sparse nature, it is better to represent it as a dict of keys (elem_ids) to values (flists)\n\n# Logging\n\n`pybrm` integrates with the normal `pinlog` logging that the BRM C API does.\n\n    import logging\n    import pybrm\n    from pybrm import Client, BRMHandler\n    \n    # These three are the defaults\n    pybrm.pin_err_set_level(pybrm.PIN_ERR_LEVEL_ERROR)\n    pybrm.pin_err_set_program('pybrm')\n    pybrm.pin_err_set_logfile('default.pinlog')\n    \n    logging.basicConfig(level=pybrm.brm_to_python_log_level(pybrm.PIN_ERR_LEVEL_ERROR))\n    logger = logging.getLogger(__name__)\n    logger.addHandler(BRMHandler())\n    \n    logger.error('This is visible')\n    logger.debug('This is not visible')\n\nNote how we are passing through two loggers here, the regular python logger as well as the BRM logger.\n\nTherefore we have to sync the python log level with the BRM log level, \nwhich is what `pybrm.brm_to_python_log_level` does.\n\nLater on in your program, you can change the logging parameters like the following:\n\n    pybrm.pin_err_set_level(pybrm.PIN_ERR_LEVEL_DEBUG)\n    logger.setLevel(pybrm.brm_to_python_log_level(pybrm.PIN_ERR_LEVEL_DEBUG))\n    pybrm.pin_err_set_program('new_program_name')\n    pybrm.pin_err_set_logfile('new.pinlog')\n\n# Transactions\n\nYou can use transactions like the following:\n\n    c = Client()\n    t = c.transaction('/poid')\n    try:\n        f = c.flist()\n        f['PIN_FLD_POID'] = '/foo'\n        f('PCM_OP_TEST_LOOPBACK')\n    except Exception:\n        t.rollback()\n    else:\n        t.commit()\n\nBetter yet, use the context manager:\n\n    c = Client()\n    with c.transaction('/poid') as t:\n        f = c.flist()\n        f['PIN_FLD_POID'] = '/foo'\n        f('PCM_OP_TEST_LOOPBACK')\n        t.commit()\n\nUsing the context manager will result in a rollback if a) an exception is raised or b) no commit was issued.\n\nFor example, this will rollback, since `commit` was never executed:\n\n    c = Client()\n    with c.transaction('/poid') as t:\n        f = c.flist()\n        f['PIN_FLD_POID'] = '/foo'\n        f('PCM_OP_TEST_LOOPBACK')\n        # Rollback occurs now, since commit was not invoked.\n\n# Multi Threading\n\n`pybrm` is thread safe, as long as each `Client()`, and all the flists owned by a client, are accessed by a single thread.\nJust as with the BRM C API, it is not thread safe to have multiple threads access a single `Client()` or touching flists with shared error buffers.\n\nFor example, if you needed to split up some work and run them in multiple threads, each thread must have its own `Client()`:\n\n    import threading\n    \n    def work(data):\n        # do NOT pass a parent flist to a thread; rather serialize it with .asdict()\n        with Client() as c:\n            flist = c.flist(data)\n            out = flist('PCM_OP_TEST_LOOPBACK')\n            print(out)\n    \n    def main():\n        with Client() as c:\n            flists = [\n                c.flist({'PIN_FLD_POID': ('/account', i)})  # account with id = i\n                for i in range(10)\n            ]\n            # do NOT pass parent flists to a thread; serialize it with .asdict() first\n            threads = [\n                threading.Thread(target=work, args=(flist.asdict(),))  # serialize the flist to a dict\n                for flist in flists\n            ]\n            for thread in threads:\n                thread.start()\n            for thread in threads:\n                thread.join()\n    \n\nOne important fact to keep in mind is that the flists created from a client belong to that client.\n\nYou should not pass flists created in one thread to another thread. Instead, you should serialize them to a dictionary and back:\n\n    c = Client()\n    c2 = Client()\n    f = c.flist()\n    f['PIN_FLD_POID'] = '/account'\n    data = f.asdict()  # serialize from flist to dict\n    f2 = c2.flist(data)  # deserialize from dict to flist\n\n# Miscellaneous\n\nTo get the `pin_virtual_time`:\n\n    import pybrm\n    print(pybrm.pin_virtual_time())\n\nIf you want to set `pin_virtual_time`, you can create a function like the following:\n\n    import subprocess\n    from datetime import datetime\n    \n    def set_pin_virtual_time(time, mode='2'):\n        mode = str(mode)\n        assert mode in ('0', '1', '2')\n        if isinstance(time, datetime):\n            time = time.strftime('%m%d%H%M%Y.%S')\n        args = [\"pin_virtual_time\", \"-m\", mode]\n        if mode != \"0\":\n            args.append(time)\n        subprocess.run(args)\n\nPlease note that this should not ever be run in prod, which is why it is not built into the library.\n\n\nYou can also create an flist from a BRM formatted flist string:\n\n    f = c.flist('''\n        # number of field entries allocated 20, used 8\n        0 PIN_FLD_POID           POID [0] 0.0.0.1 /account -1 0\n        0 PIN_FLD_STATUS         ENUM [0] 1\n        0 PIN_FLD_CREATED_T    TSTAMP [0] (1582071028) Tue Feb 18 16:10:28 2020\n        0 PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n        1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 0\n        1     PIN_FLD_STATUS         ENUM [0] 2\n        0 PIN_FLD_EVENT        SUBSTRUCT [0] allocated 20, used 2\n        1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 1\n        1     PIN_FLD_STATUS         ENUM [0] 3\n        0 PIN_FLD_ARGS          ARRAY [4] allocated 20, used 1\n        1     PIN_FLD_STATUS         ENUM [0] 4\n        0 PIN_FLD_ARGS          ARRAY [16] allocated 20, used 1\n        1     PIN_FLD_STATUS         ENUM [0] 5\n        0 PIN_FLD_VALUES        ARRAY [0] allocated 20, used 1\n        1     PIN_FLD_STATUS         ENUM [0] 6\n        0 PIN_FLD_VALUES        ARRAY [1] allocated 20, used 1\n        1     PIN_FLD_STATUS         ENUM [0] 7\n    ''')\n\nAdditionally, you can create serialize an flist to XML, and create an flist via XML:\n\n    xml = f.xml()\n    f2 = c.flist(xml)\n    \nLikewise you can serialize an flist to JSON, and create an flist from JSON\n\n    j = f.json()\n    f2 = c.flist(j)\n\n\n\n## Python3 Installation\n\nIt is easiest to install Miniconda, which contains precompiled Python binaries for both 32 and 64bit.\n\n32 bit (Python 3.7):\n\n    wget https://repo.anaconda.com/miniconda/Miniconda3-4.5.12-Linux-x86.sh\n\n64 bit (Python 3.7):\n\n    wget https://repo.anaconda.com/miniconda/Miniconda3-4.7.12.1-Linux-x86_64.sh\n\nTo install it, chose a path you want it to be installed on, like `/path/to/miniconda3`\n\n    sh Miniconda3-4.5.12-Linux-x86.sh -b -p /path/to/miniconda3\n    rm Miniconda3-4.5.12-Linux-x86.sh\n\nYou can alternatively build Python from source which will take up less space than Miniconda.\n\n# Run the tests\n\nThe tests require a valid CM up and running. It only calls `PCM_OP_TEST_LOOPBACK`.\n\ncd into the tests directory, and edit pin.conf. Change this line to point to the correct CM:\n\n    - nap cm_ptr ip ${HOSTNAME} ${BRM_CM_PORT}\n\nAdditionally, cd into the `pin_conf_test` directory, and do the same for the pin.conf there.\n\nAfter this, run the tests from inside the `tests/` directory like:\n\n    python3 tests.py\n\n# pin.conf\nA `pin.conf` file has to be created in the same directory you run Python from\n\nAt a minimum it needs these lines:\n\n    - nap cm_ptr ip ${HOSTNAME} ${BRM_CM_PORT}\n    - nap login_type 1\n    - nap login_name root.0.0.0.1\n    - nap login_pw   password\n    - - userid 0.0.0.1 /service/pcm_client 1\n\nYou should also include this:\n\n     - - pin_virtual_time ${PIN_HOME}/lib/pin_virtual_time_file\n     - - ops_fields_extension_file ${PIN_HOME}/include/custom_ops_dat.dat\n     \nwhere `custom_ops_dat.dat` points to your custom opcode file.\n\nJust like with normal BRM C code, you need this file in order to get access to custom fields and opcodes.\n\n# Calling C from Python\n\nCheck out the examples/call_c_from_python/ for an example of calling C from Python using ctypes.\n\n# Calling Python from C\n\nCheck out the examples/call_python_from_c/ for an example of calling Python from C.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/mkmoisen/pybrm", "keywords": "brm", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pybrm", "package_url": "https://pypi.org/project/pybrm/", "platform": "", "project_url": "https://pypi.org/project/pybrm/", "project_urls": {"Documentation": "https://github.com/mkmoisen/pybrm", "Homepage": "https://github.com/mkmoisen/pybrm", "Source": "https://github.com/mkmoisen/pybrm"}, "release_url": "https://pypi.org/project/pybrm/1.0.0/", "requires_dist": null, "requires_python": ">=3.6", "summary": "A Python library for Oracle BRM", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>pybrm</h1>\n<p>A Python C wrapper for Oracle BRM.</p>\n<p><code>pybrm</code> requires &gt;= Python 3.6 and is tested with Python 3.6.5 and 3.7.1, on BRM 7.5 (GCC 4.4.7) and BRM 12 (GCC 4.8.5). It has been tested on both 32bit and 64bit.</p>\n<h1>Installation</h1>\n<p>To install and compile <code>pybrm</code>, your <code>PIN_HOME</code> environment variable must point to the BRM home directory.</p>\n<p>Install it with <code>pip</code> like this:</p>\n<pre><code>pip install pybrm\n</code></pre>\n<p>The installation will determine if you are on 32bit or 64bit Python and attempt to install correctly.</p>\n<h1>Usage</h1>\n<p>Imports:</p>\n<pre><code>from pybrm import Client\nfrom datetime import datetime\n</code></pre>\n<p>Open up a client CM connection:</p>\n<pre><code>c = Client()\n</code></pre>\n<p>Create an empty flist:</p>\n<pre><code>f = c.flist()\n</code></pre>\n<p>Set some scalar data on the flist:</p>\n<pre><code>f['PIN_FLD_POID'] = '/account'  # type /account, id -1, revision 0\nf['PIN_FLD_STATUS'] = 1\nf['PIN_FLD_CREATED_T'] = datetime.now()  # you can also set it to an integer\n</code></pre>\n<p>Create a substructure in one shot, the preferred way:</p>\n<pre><code>f['PIN_FLD_INHERITED_INFO'] = {\n    'PIN_FLD_POID': ('/service', 1234), # type service, id 1234, revision 0\n    'PIN_FLD_STATUS': 2,\n}\n</code></pre>\n<p>Print the flist:</p>\n<pre><code>&gt;&gt;&gt; print(f)\n0 PIN_FLD_POID           POID [0] 0.0.0.1 /account -1 0\n0 PIN_FLD_STATUS         ENUM [0] 1\n0 PIN_FLD_CREATED_T    TSTAMP [0] (1582600707) Mon Feb 24 19:18:27 2020\n0 PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 0\n1     PIN_FLD_STATUS         ENUM [0] 2\n</code></pre>\n<p>You can also build up a substruct it up piece by piece:</p>\n<pre><code>f['PIN_FLD_EVENT'] = {}  # Creates an empty substruct\nf['PIN_FLD_EVENT']['PIN_FLD_POID'] = ('/service', 1234, 1)  # type service, id 1234, revision 1\n\n# You can pull a subsctruct out into its own variable if you like\nsubstruct = f['PIN_FLD_EVENT']\nsubstruct['PIN_FLD_STATUS'] = 3\n</code></pre>\n<p>Let's print it again:</p>\n<pre><code>&gt;&gt;&gt; print(f)\n# number of field entries allocated 20, used 5\n0 PIN_FLD_POID           POID [0] 0.0.0.1 /account -1 0\n0 PIN_FLD_STATUS         ENUM [0] 1\n0 PIN_FLD_CREATED_T    TSTAMP [0] (1582600707) Mon Feb 24 19:18:27 2020\n0 PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 0\n1     PIN_FLD_STATUS         ENUM [0] 2\n0 PIN_FLD_EVENT        SUBSTRUCT [0] allocated 20, used 2\n1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 1\n1     PIN_FLD_STATUS         ENUM [0] 3\n</code></pre>\n<p>Create an array in one shot, the preferred way with dict syntax <code>{}</code>. The keys are the elem_ids, and the values are flists. In this example, we will creates two flists on elem_id 4 and 16:</p>\n<pre><code>f['PIN_FLD_ARGS'] = {\n    4: {'PIN_FLD_STATUS': 4},\n    16: {'PIN_FLD_STATUS': 5},\n}\n</code></pre>\n<p>Let's print if again:</p>\n<pre><code>&gt;&gt;&gt; print(f)\n# number of field entries allocated 20, used 9\n0 PIN_FLD_POID           POID [0] 0.0.0.1 /account -1 0\n0 PIN_FLD_STATUS         ENUM [0] 1\n0 PIN_FLD_CREATED_T    TSTAMP [0] (1582600707) Mon Feb 24 19:18:27 2020\n0 PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 0\n1     PIN_FLD_STATUS         ENUM [0] 2\n0 PIN_FLD_EVENT        SUBSTRUCT [0] allocated 20, used 2\n1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 1\n1     PIN_FLD_STATUS         ENUM [0] 3\n0 PIN_FLD_ARGS          ARRAY [4] allocated 20, used 1\n1     PIN_FLD_STATUS         ENUM [0] 4\n</code></pre>\n<p>You can instead use list syntax <code>[]</code>, and not specify the elem_ids. This will automatically start the elem_id off at 0 and increase it by one for each flist.</p>\n<pre><code>f['PIN_FLD_RESULTS'] = [\n    {'PIN_FLD_STATUS': 6},  # sets at elem_id 0\n    {'PIN_FLD_STATUS': 7},  # sets at elem_id 1 \n]\n</code></pre>\n<p>Let's print it again:</p>\n<pre><code>&gt;&gt;&gt; print(f)\n# number of field entries allocated 20, used 9\n0 PIN_FLD_POID           POID [0] 0.0.0.1 /account -1 0\n0 PIN_FLD_STATUS         ENUM [0] 1\n0 PIN_FLD_CREATED_T    TSTAMP [0] (1582600707) Mon Feb 24 19:18:27 2020\n0 PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 0\n1     PIN_FLD_STATUS         ENUM [0] 2\n0 PIN_FLD_EVENT        SUBSTRUCT [0] allocated 20, used 2\n1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 1\n1     PIN_FLD_STATUS         ENUM [0] 3\n0 PIN_FLD_ARGS          ARRAY [4] allocated 20, used 1\n1     PIN_FLD_STATUS         ENUM [0] 4\n0 PIN_FLD_ARGS          ARRAY [16] allocated 20, used 1\n1     PIN_FLD_STATUS         ENUM [0] 5\n0 PIN_FLD_RESULTS       ARRAY [0] allocated 20, used 1\n1     PIN_FLD_STATUS         ENUM [0] 6\n0 PIN_FLD_RESULTS       ARRAY [1] allocated 20, used 1\n1     PIN_FLD_STATUS         ENUM [0] 7\n</code></pre>\n<p>You can also build up an array piece by piece:</p>\n<pre><code>f['PIN_FLD_VALUES'] = {}  #  Creates an empty array\nf['PIN_FLD_VALUES'][0] = {'PIN_FLD_STATUS': 8}  # Adds an flist on the 0th elem_id of this array\n\n# You can pull an array out into its own variable if you like\narray = f['PIN_FLD_VALUES']\narray[1] = {}  # Create empty flist on the 1st elem_id of this array\narray[1]['PIN_FLD_STATUS'] = 9  # set one field on the flist we just created\n</code></pre>\n<p>Let's print it again:</p>\n<pre><code>&gt;&gt;&gt; print(f)\n# number of field entries allocated 20, used 11\n0 PIN_FLD_POID           POID [0] 0.0.0.1 /account -1 0\n0 PIN_FLD_STATUS         ENUM [0] 1\n0 PIN_FLD_CREATED_T    TSTAMP [0] (1582600707) Mon Feb 24 19:18:27 2020\n0 PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 0\n1     PIN_FLD_STATUS         ENUM [0] 2\n0 PIN_FLD_EVENT        SUBSTRUCT [0] allocated 20, used 2\n1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 1\n1     PIN_FLD_STATUS         ENUM [0] 3\n0 PIN_FLD_ARGS          ARRAY [4] allocated 20, used 1\n1     PIN_FLD_STATUS         ENUM [0] 4\n0 PIN_FLD_ARGS          ARRAY [16] allocated 20, used 1\n1     PIN_FLD_STATUS         ENUM [0] 5\n0 PIN_FLD_RESULTS       ARRAY [0] allocated 20, used 1\n1     PIN_FLD_STATUS         ENUM [0] 6\n0 PIN_FLD_RESULTS       ARRAY [1] allocated 20, used 1\n1     PIN_FLD_STATUS         ENUM [0] 7\n0 PIN_FLD_VALUES        ARRAY [0] allocated 20, used 1\n1     PIN_FLD_STATUS         ENUM [0] 8\n0 PIN_FLD_VALUES        ARRAY [1] allocated 20, used 1\n1     PIN_FLD_STATUS         ENUM [0] 9\n</code></pre>\n<p>However, it's better to just create it all with a dict. This will keep your code clean:</p>\n<pre><code>f = c.flist({\n    'PIN_FLD_POID': '/account',\n    'PIN_FLD_STATUS': 1,\n    'PIN_FLD_CREATED_T': datetime.now(),\n    'PIN_FLD_INHERITED_INFO': {\n        'PIN_FLD_POID': ('/service', 1234),\n        'PIN_FLD_STATUS': 2,\n    },\n    'PIN_FLD_EVENT': {\n        'PIN_FLD_POID': ('/service', 1234, 1),\n        'PIN_FLD_STATUS': 3,\n    },\n    'PIN_FLD_ARGS': {\n        4: {'PIN_FLD_STATUS': 4},\n        16: {'PIN_FLD_STATUS': 5},\n    },\n    'PIN_FLD_RESULTS': [\n        {'PIN_FLD_STATUS': 6},\n        {'PIN_FLD_STATUS': 7},\n    ],\n    'PIN_FLD_VALUES': {\n        0: {'PIN_FLD_STATUS': 8},\n        1: {'PIN_FLD_STATUS': 9},\n    },\n})\n</code></pre>\n<p>Call an opcode via PCM_OP with no flags:</p>\n<pre><code>output = f('PCM_OP_TEST_LOOPBACK')  # or f.opcode('PCM_OP_TEST_LOOPBACK')\n</code></pre>\n<p>Call an opcode via PCM_OP with one flag:</p>\n<pre><code>output = f('PCM_OP_TEST_LOOPBACK', flags='SRCH_DISTINCT')\n</code></pre>\n<p>Call an opcode via PCM_OP with multiple flags:</p>\n<pre><code>output = f('PCM_OP_TEST_LOOPBACK', flags=('SRCH_DISTINCT', 'PCM_OPFLG_REV_CHECK'))\n</code></pre>\n<p>You can also use the <code>f.opcode</code> function. One benefit is you can ctrl+f to find all opcode calls.</p>\n<pre><code>output = f.opcode('PCM_OP_TEST_LOOPBACK', flags='SRCH_DISTINCT')\n</code></pre>\n<p>To use PCM_OPREF, which passes the reference of the flist to the opcode, instead of a copy like PCM_OP:</p>\n<pre><code>output = f('PCM_OP_TEST_LOOPBACK', reference=True)  # or f.opcode('PCM_OP_TEST_LOOPBACK', reference=True)\n</code></pre>\n<p>Get some data off the flist:</p>\n<pre><code>status = f['PIN_FLD_STATUS']\nassert status == 1\n\npoid = f['PIN_FLD_POID']\nassert poid.type == '/account'\nassert poid.id == -1\nassert poid.revision == 0\nprint(poid.database)  # this is picked up dynamically, but is probably 1\n\nassert f['PIN_FLD_INHERITED_INFO']['PIN_FLD_POID'].type == '/service'\nassert len(f['PIN_FLD_VALUES']) == 2\nassert f['PIN_FLD_VALUES'][0]['PIN_FLD_STATUS'] == 8\n</code></pre>\n<p>Get the length:</p>\n<pre><code>assert len(f) == 8\nassert f.count() == 8  # same as len\nassert f.count(recursive=True) == 18  # counts items in arrays/substructs\n\nassert len(f['PIN_FLD_INHERITED_INFO']) == 2  # count of a substruct\nassert f['PIN_FLD_INHERITED_INFO'].count() == 2 # same as len\n\nassert len(f['PIN_FLD_VALUES']) == 2  # count of an array\nassert f['PIN_FLD_VALUES'].count() == 2  # same as len\n</code></pre>\n<p>Get all the field names:</p>\n<pre><code>&gt;&gt;&gt; print(list(f.keys())\n['PIN_FLD_POID', 'PIN_FLD_STATUS', 'PIN_FLD_CREATED_T', 'PIN_FLD_INHERITED_INFO', 'PIN_FLD_EVENT', 'PIN_FLD_ARGS', 'PIN_FLD_RESULTS', 'PIN_FLD_VALUES']\n</code></pre>\n<p>Check if a field exists on our flist:</p>\n<pre><code>&gt;&gt;&gt; 'PIN_FLD_POID' in f\nTrue\n&gt;&gt;&gt; 'PIN_FLD_EVENT' in f\nTrue\n&gt;&gt;&gt; 'PIN_FLD_VALUES' in f\nTrue\n&gt;&gt;&gt; 'PIN_FLD_QUANTITY' in f\nFalse\n</code></pre>\n<p>Get an flist at a particular elem_id from an array:</p>\n<pre><code>child = f['PIN_FLD_VALUES'][0]\nchild = f['PIN_FLD_VALUES'][1]\n</code></pre>\n<p>Get any flist from an array (PIN_ELEMID_ANY):</p>\n<pre><code>child = f['PIN_FLD_VALUES']['*']\n# This is equivalent\nchild = f['PIN_FLD_VALUES']['PIN_ELEMID_ANY']\n# This is also equivalent\nchild = f['PIN_FLD_VALUES'][-1]\n</code></pre>\n<p>Delete a field:</p>\n<pre><code>assert 'PIN_FLD_STATUS' in f\ndel f['PIN_FLD_STATUS']\nassert 'PIN_FLD_STATUS' not in f\n</code></pre>\n<h1>Searching Shortcuts for PCM_OP_SEARCH</h1>\n<p>You can create your own flists and call <code>PCM_OP_SEARCH</code> yourself, however the <code>client.search()</code> make searching convenient with syntactic sugar:</p>\n<pre><code>output = c.search(\n    template=' select X from /foo where F1 = V1 and F2 = V2',\n    search_flags='SRCH_DISTINCT',\n    args={'PIN_FLD_LOGIN': 'bar', 'PIN_FLD_USAGE_TYPE': 'foo'},\n)\n</code></pre>\n<p>This would build the following search flist and execute it, returning the results:</p>\n<pre><code># number of field entries allocated 20, used 6\n0 PIN_FLD_POID           POID [0] 0.0.0.1 /search -1 0\n0 PIN_FLD_FLAGS           INT [0] 256\n0 PIN_FLD_TEMPLATE        STR [0] \" select X from /foo where F1 = V1 and F2 = V2\"\n0 PIN_FLD_ARGS          ARRAY [1] allocated 20, used 1\n1     PIN_FLD_LOGIN           STR [0] \"bar\"\n0 PIN_FLD_ARGS          ARRAY [2] allocated 20, used 1\n1     PIN_FLD_USAGE_TYPE      STR [0] \"foo\"\n0 PIN_FLD_RESULTS       ARRAY [*] allocated 0, used 0\n</code></pre>\n<p>For the <code>args</code> parameter, you may specify it with a dict, or a list of tuples. These two are the same:</p>\n<pre><code>output = c.search(\n    template=' select X from /foo where F1 = V1 and F2 = V2',\n    args={'PIN_FLD_LOGIN': 'bar', 'PIN_FLD_USAGE_TYPE': 'foo'},\n)\n\noutput = c.search(\n    template=' select X from /foo where F1 = V1 and F2 = V2',\n    args=[('PIN_FLD_LOGIN', 'bar'), ('PIN_FLD_USAGE_TYPE', 'foo')],\n)\n</code></pre>\n<p>Using a dict in args is just syntactic sugar to save a few keystrokes.\nSometimes you cannot use the dict, for example if you have a template like <code>select C from /foo where F1 IN (V1, V2)</code>.\nA dict will not work because a dict can only have unique keys.</p>\n<pre><code>output = c.search(\n    template=' select X from /foo where F1 IN (V1, V2) ',\n    args=[\n        ('PIN_FLD_USAGE_TYPE', 'FOO'),\n        ('PIN_FLD_USAGE_TYPE', 'BAR')\n    ]\n)\n</code></pre>\n<p>This would build the following search flist:</p>\n<pre><code># number of field entries allocated 20, used 6\n0 PIN_FLD_POID           POID [0] 0.0.0.1 /search -1 0\n0 PIN_FLD_FLAGS           INT [0] 0\n0 PIN_FLD_TEMPLATE        STR [0] \" select C from /foo where F1 IN (V1, V2) \"\n0 PIN_FLD_ARGS          ARRAY [1] allocated 20, used 1\n1     PIN_FLD_USAGE_TYPE      STR [0] \"FOO\"\n0 PIN_FLD_ARGS          ARRAY [2] allocated 20, used 1\n1     PIN_FLD_USAGE_TYPE      STR [0] \"BAR\"\n0 PIN_FLD_RESULTS       ARRAY [*] allocated 0, used 0\n</code></pre>\n<p>You can use nested substructs and arrays in the <code>args</code> param like the following:</p>\n<pre><code>output = c.search(\n    template=' select X from /foo where F1 = V1 ',\n    args={'PIN_FLD_EVENT': {'PIN_FLD_USAGE_TYPE': 'bar'}}\n)\n</code></pre>\n<p>This would create the following search flist:</p>\n<pre><code># number of field entries allocated 20, used 5\n0 PIN_FLD_POID           POID [0] 0.0.0.1 /search -1 0\n0 PIN_FLD_FLAGS           INT [0] 0\n0 PIN_FLD_TEMPLATE        STR [0] \" select X from /foo where F1 = V1 \"\n0 PIN_FLD_ARGS          ARRAY [1] allocated 20, used 1\n1     PIN_FLD_EVENT        SUBSTRUCT [0] allocated 20, used 1\n2         PIN_FLD_USAGE_TYPE      STR [0] \"bar\"\n0 PIN_FLD_RESULTS       ARRAY [*] allocated 0, used 0\n</code></pre>\n<p>You may customize the results of the search by using the <code>results</code> argument. By default, it will return all all the fields.</p>\n<p>This will return only the three fields specified in <code>results</code>:</p>\n<pre><code>output = c.search(\n    template=' select X from /foo where F1 = V1 ',\n    args={'PIN_FLD_LOGIN': 'bar'},\n    results={'PIN_FLD_USAGE_TYPE', 'PIN_FLD_EVENT_TYPE', 'PIN_FLD_SERVICE_TYPE'}\n)\n</code></pre>\n<p>Here is the search flist that would be created:</p>\n<pre><code># number of field entries allocated 20, used 5\n0 PIN_FLD_POID           POID [0] 0.0.0.1 /search -1 0\n0 PIN_FLD_FLAGS           INT [0] 0\n0 PIN_FLD_TEMPLATE        STR [0] \" select X from /foo where F1 = V1 \"\n0 PIN_FLD_ARGS          ARRAY [1] allocated 20, used 1\n1     PIN_FLD_LOGIN           STR [0] \"bar\"\n0 PIN_FLD_RESULTS       ARRAY [*] allocated 20, used 3\n1     PIN_FLD_EVENT_TYPE      STR [0] NULL str ptr\n1     PIN_FLD_USAGE_TYPE      STR [0] NULL str ptr\n1     PIN_FLD_SERVICE_TYPE    STR [0] NULL str ptr\n</code></pre>\n<p>These three are identical:</p>\n<pre><code>output = c.search(\n    template=' select X from /foo where F1 = V1 ',\n    args={'PIN_FLD_LOGIN': 'bar'},\n    results={'PIN_FLD_USAGE_TYPE', 'PIN_FLD_EVENT_TYPE', 'PIN_FLD_SERVICE_TYPE'}\n)\n\noutput = c.search(\n    template=' select X from /foo where F1 = V1 ',\n    args={'PIN_FLD_LOGIN': 'bar'},\n    results={'PIN_FLD_USAGE_TYPE': None, 'PIN_FLD_EVENT_TYPE': None, 'PIN_FLD_SERVICE_TYPE': None}\n)\n\noutput = c.search(\n    template=' select X from /foo where F1 = V1 ',\n    args={'PIN_FLD_LOGIN': 'bar'},\n    results=['PIN_FLD_USAGE_TYPE', 'PIN_FLD_EVENT_TYPE', 'PIN_FLD_SERVICE_TYPE']\n)\n</code></pre>\n<p>The following will return all the fields in the substructure:</p>\n<pre><code>output = c.search(\n    template=' select X from /foo where F1 = V1 ',\n    args={'PIN_FLD_LOGIN': 'bar'},\n    results={'PIN_FLD_INHERITED_INFO'}\n)\n</code></pre>\n<p>This will return only the subset of fields in the substructure:</p>\n<pre><code>output = c.search(\n    template=' select X from /foo where F1 = V1 ',\n    args={'PIN_FLD_LOGIN': 'bar'},\n    results={'PIN_FLD_INHERITED_INFO': {\n        'PIN_FLD_USAGE_TYPE', 'PIN_FLD_EVENT_TYPE'\n    }}\n)\n</code></pre>\n<p>Here is the search flist that would be created:</p>\n<pre><code># number of field entries allocated 20, used 5\n0 PIN_FLD_POID           POID [0] 0.0.0.1 /search -1 0\n0 PIN_FLD_FLAGS           INT [0] 0\n0 PIN_FLD_TEMPLATE        STR [0] \" select X from /foo where F1 = V1 \"\n0 PIN_FLD_ARGS          ARRAY [1] allocated 20, used 1\n1     PIN_FLD_LOGIN           STR [0] \"bar\"\n0 PIN_FLD_RESULTS       ARRAY [*] allocated 20, used 1\n1     PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n2         PIN_FLD_EVENT_TYPE      STR [0] NULL str ptr\n2         PIN_FLD_USAGE_TYPE      STR [0] NULL str ptr\n</code></pre>\n<p>You can do the same with arrays, for example <code>PIN_FLD_FIELD</code>.</p>\n<pre><code>output = c.search(\n    template=' select X from /foo where F1 = V1 ',\n    args={'PIN_FLD_LOGIN': 'bar'},\n    results={'PIN_FLD_FIELD': {\n        'PIN_FLD_USAGE_TYPE', 'PIN_FLD_EVENT_TYPE'\n    }}\n)\n</code></pre>\n<p>Here is the search flist that would be created:</p>\n<pre><code># number of field entries allocated 20, used 5\n0 PIN_FLD_POID           POID [0] 0.0.0.1 /search -1 0\n0 PIN_FLD_FLAGS           INT [0] 0\n0 PIN_FLD_TEMPLATE        STR [0] \" select X from /foo where F1 = V1 \"\n0 PIN_FLD_ARGS          ARRAY [1] allocated 20, used 1\n1     PIN_FLD_LOGIN           STR [0] \"bar\"\n0 PIN_FLD_RESULTS       ARRAY [*] allocated 20, used 1\n1     PIN_FLD_FIELD         ARRAY [*] allocated 20, used 2\n2         PIN_FLD_EVENT_TYPE      STR [0] NULL str ptr\n2         PIN_FLD_USAGE_TYPE      STR [0] NULL str ptr\n</code></pre>\n<p>You can specify the search flags in <code>PIN_FLD_FLAGS</code> via the <code>search_flags</code> parameter:</p>\n<pre><code>output = c.search(\n    template=' select X from /foo where F1 = V1 ',\n    search_flags='SRCH_DISTINCT',\n    args={'PIN_FLD_LOGIN': 'bar'},\n)\n</code></pre>\n<p>You can pass in more than one search flag in a sequence:</p>\n<pre><code>output = c.search(\n    template=' select X from /foo where F1 = V1 ',\n    search_flags=('SRCH_DISTINCT', 'SRCH_EXACT'),\n    args={'PIN_FLD_LOGIN': 'bar'},\n)\n</code></pre>\n<p>You can specify the opcode flags via the <code>opcode_flags</code> parameter:</p>\n<pre><code>output = c.search(\n    template=' select X from /foo where F1 = V1 ',\n    search_flags=('SRCH_DISTINCT', 'SRCH_EXACT'),\n    args={'PIN_FLD_LOGIN': 'bar'},\n    opcode_flags='PCM_OPFLG_CACHEABLE',\n)\n</code></pre>\n<p>In fact, if you want to examine the search flist, and not execute it, you can use <code>c.search_build_flist()</code>:</p>\n<pre><code>search =c.search_build_flist(\n    template=' select X from /foo where F1 = V1 ',\n    args={'PIN_FLD_LOGIN': 'bar'},\n)\nprint(search)\n</code></pre>\n<h1>Substructures and Arrays</h1>\n<p>One important thing to note about substructures is that when you add one flist to another flist, it is ALWAYS copied.</p>\n<pre><code>c = Client()\nf = c.flist({'PIN_FLD_STATUS': 1}) \nf2 = c.flist()\n\n# COPY f onto f2\nf2['PIN_FLD_INHERITED_INFO'] = f\n\n# Change f, which does not change anything on f2\nf['PIN_FLD_STATUS'] = 2\n# The copy on f2['PIN_FLD_INHERITED_INFO'] was not changed!\nassert f2['PIN_FLD_INHERITED_INFO']['PIN_FLD_STATUS'] == 1\n</code></pre>\n<p>The same is true for arrays:</p>\n<pre><code>c = Client()\nf = c.flist({'PIN_FLD_STATUS': 1})\nf2 = c.flist()\n\n# COPY f2 onto f's PIN_FLD_VALUES array\nf2['PIN_FLD_VALUES'] = {0: f}\n\n# Change f, which does not change anything on f2\nf['PIN_FLD_STATUS'] = 2\n# The copy on f['PIN_FLD_VALUES'][0] was not changed!\nassert f2['PIN_FLD_VALUES'][0]['PIN_FLD_STATUS'] == 1\n</code></pre>\n<p>Both the FList and the BRMArray classes implement the Python dictionary protocol. What this means is that they both have a key that maps to a value.\nIn the case of an flist, the key is the field, and the value is the value of the flist at that field.\nIn the case of a BRMArray, the key is the elem_id, and the value is the flist at that elem_id.</p>\n<p>Do not try to iterate over a BRMArray like a Python list:</p>\n<pre><code>f = c.flist({\n    'PIN_FLD_VALUES': [\n        {'PIN_FLD_STATUS': 2},\n        {'PIN_FLD_STATUS': 4},\n    ]\n})\n\n# Wrong, probably not what you want:\n&gt;&gt;&gt; for v in f['PIN_FLD_VALUES']:\n&gt;&gt;&gt;     v\n0\n1\n</code></pre>\n<p>Doing it that way will return the keys, or elem_ids of the BRMArray, which in this case are <code>0</code> and <code>1</code>.</p>\n<p>Instead, you have to use the <code>.values()</code> function, like you would on a dict in python:</p>\n<pre><code>&gt;&gt;&gt; for v in f['PIN_FLD_VALUES'].values():\n&gt;&gt;&gt;     v\n{'PIN_FLD_STATUS': 2}\n{'PIN_FLD_STATUS': 4}\n</code></pre>\n<p>Likewise, to get the keys and the values, use <code>.items()</code>:</p>\n<pre><code>&gt;&gt;&gt; for k, v in f['PIN_FLD_VALUES'].items():\n&gt;&gt;&gt;     k, v\n(0, {'PIN_FLD_STATUS': 2})\n(1, {'PIN_FLD_STATUS': 4})\n</code></pre>\n<h2>Empty Array Behavior</h2>\n<p>There is some behavior with empty arrays that is important to keep in mind.</p>\n<p>In the following example, does anything happen to the C flist?</p>\n<pre><code>c = client()\nf = c.flist()\nf['PIN_FLD_RESULTS'] = {}\n</code></pre>\n<p>No, nothing has happened. We have not added any flists at all. However in Python we can access this array:</p>\n<pre><code>ar = f['PIN_FLD_RESULTS']\n</code></pre>\n<p>Most importantly to keep in mind, we can check if <code>PIN_FLD_RESULTS</code> exists on our flist:</p>\n<pre><code>if 'PIN_FLD_RESULTS' in f:\n    print('yes it exists')\n</code></pre>\n<p>However, in fact there is nothing on the C flist at this point, until you add your first flist:</p>\n<pre><code>ar[0] = {'PIN_FLD_POID': '/foo'}\n</code></pre>\n<p>It's worth repeating: the BRMArray class is not implemented as a list, but rather as a dictionary.\nWhy was this decision made? An array in brm is sparse array where each value is an flist.\nYou can put an flist at index 2 of an array, and then place another flist on the 9th position, leaving gaps in between.\nDue to this sparse nature, it is better to represent it as a dict of keys (elem_ids) to values (flists)</p>\n<h1>Logging</h1>\n<p><code>pybrm</code> integrates with the normal <code>pinlog</code> logging that the BRM C API does.</p>\n<pre><code>import logging\nimport pybrm\nfrom pybrm import Client, BRMHandler\n\n# These three are the defaults\npybrm.pin_err_set_level(pybrm.PIN_ERR_LEVEL_ERROR)\npybrm.pin_err_set_program('pybrm')\npybrm.pin_err_set_logfile('default.pinlog')\n\nlogging.basicConfig(level=pybrm.brm_to_python_log_level(pybrm.PIN_ERR_LEVEL_ERROR))\nlogger = logging.getLogger(__name__)\nlogger.addHandler(BRMHandler())\n\nlogger.error('This is visible')\nlogger.debug('This is not visible')\n</code></pre>\n<p>Note how we are passing through two loggers here, the regular python logger as well as the BRM logger.</p>\n<p>Therefore we have to sync the python log level with the BRM log level,\nwhich is what <code>pybrm.brm_to_python_log_level</code> does.</p>\n<p>Later on in your program, you can change the logging parameters like the following:</p>\n<pre><code>pybrm.pin_err_set_level(pybrm.PIN_ERR_LEVEL_DEBUG)\nlogger.setLevel(pybrm.brm_to_python_log_level(pybrm.PIN_ERR_LEVEL_DEBUG))\npybrm.pin_err_set_program('new_program_name')\npybrm.pin_err_set_logfile('new.pinlog')\n</code></pre>\n<h1>Transactions</h1>\n<p>You can use transactions like the following:</p>\n<pre><code>c = Client()\nt = c.transaction('/poid')\ntry:\n    f = c.flist()\n    f['PIN_FLD_POID'] = '/foo'\n    f('PCM_OP_TEST_LOOPBACK')\nexcept Exception:\n    t.rollback()\nelse:\n    t.commit()\n</code></pre>\n<p>Better yet, use the context manager:</p>\n<pre><code>c = Client()\nwith c.transaction('/poid') as t:\n    f = c.flist()\n    f['PIN_FLD_POID'] = '/foo'\n    f('PCM_OP_TEST_LOOPBACK')\n    t.commit()\n</code></pre>\n<p>Using the context manager will result in a rollback if a) an exception is raised or b) no commit was issued.</p>\n<p>For example, this will rollback, since <code>commit</code> was never executed:</p>\n<pre><code>c = Client()\nwith c.transaction('/poid') as t:\n    f = c.flist()\n    f['PIN_FLD_POID'] = '/foo'\n    f('PCM_OP_TEST_LOOPBACK')\n    # Rollback occurs now, since commit was not invoked.\n</code></pre>\n<h1>Multi Threading</h1>\n<p><code>pybrm</code> is thread safe, as long as each <code>Client()</code>, and all the flists owned by a client, are accessed by a single thread.\nJust as with the BRM C API, it is not thread safe to have multiple threads access a single <code>Client()</code> or touching flists with shared error buffers.</p>\n<p>For example, if you needed to split up some work and run them in multiple threads, each thread must have its own <code>Client()</code>:</p>\n<pre><code>import threading\n\ndef work(data):\n    # do NOT pass a parent flist to a thread; rather serialize it with .asdict()\n    with Client() as c:\n        flist = c.flist(data)\n        out = flist('PCM_OP_TEST_LOOPBACK')\n        print(out)\n\ndef main():\n    with Client() as c:\n        flists = [\n            c.flist({'PIN_FLD_POID': ('/account', i)})  # account with id = i\n            for i in range(10)\n        ]\n        # do NOT pass parent flists to a thread; serialize it with .asdict() first\n        threads = [\n            threading.Thread(target=work, args=(flist.asdict(),))  # serialize the flist to a dict\n            for flist in flists\n        ]\n        for thread in threads:\n            thread.start()\n        for thread in threads:\n            thread.join()\n</code></pre>\n<p>One important fact to keep in mind is that the flists created from a client belong to that client.</p>\n<p>You should not pass flists created in one thread to another thread. Instead, you should serialize them to a dictionary and back:</p>\n<pre><code>c = Client()\nc2 = Client()\nf = c.flist()\nf['PIN_FLD_POID'] = '/account'\ndata = f.asdict()  # serialize from flist to dict\nf2 = c2.flist(data)  # deserialize from dict to flist\n</code></pre>\n<h1>Miscellaneous</h1>\n<p>To get the <code>pin_virtual_time</code>:</p>\n<pre><code>import pybrm\nprint(pybrm.pin_virtual_time())\n</code></pre>\n<p>If you want to set <code>pin_virtual_time</code>, you can create a function like the following:</p>\n<pre><code>import subprocess\nfrom datetime import datetime\n\ndef set_pin_virtual_time(time, mode='2'):\n    mode = str(mode)\n    assert mode in ('0', '1', '2')\n    if isinstance(time, datetime):\n        time = time.strftime('%m%d%H%M%Y.%S')\n    args = [\"pin_virtual_time\", \"-m\", mode]\n    if mode != \"0\":\n        args.append(time)\n    subprocess.run(args)\n</code></pre>\n<p>Please note that this should not ever be run in prod, which is why it is not built into the library.</p>\n<p>You can also create an flist from a BRM formatted flist string:</p>\n<pre><code>f = c.flist('''\n    # number of field entries allocated 20, used 8\n    0 PIN_FLD_POID           POID [0] 0.0.0.1 /account -1 0\n    0 PIN_FLD_STATUS         ENUM [0] 1\n    0 PIN_FLD_CREATED_T    TSTAMP [0] (1582071028) Tue Feb 18 16:10:28 2020\n    0 PIN_FLD_INHERITED_INFO SUBSTRUCT [0] allocated 20, used 2\n    1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 0\n    1     PIN_FLD_STATUS         ENUM [0] 2\n    0 PIN_FLD_EVENT        SUBSTRUCT [0] allocated 20, used 2\n    1     PIN_FLD_POID           POID [0] 0.0.0.1 /service 1234 1\n    1     PIN_FLD_STATUS         ENUM [0] 3\n    0 PIN_FLD_ARGS          ARRAY [4] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 4\n    0 PIN_FLD_ARGS          ARRAY [16] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 5\n    0 PIN_FLD_VALUES        ARRAY [0] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 6\n    0 PIN_FLD_VALUES        ARRAY [1] allocated 20, used 1\n    1     PIN_FLD_STATUS         ENUM [0] 7\n''')\n</code></pre>\n<p>Additionally, you can create serialize an flist to XML, and create an flist via XML:</p>\n<pre><code>xml = f.xml()\nf2 = c.flist(xml)\n</code></pre>\n<p>Likewise you can serialize an flist to JSON, and create an flist from JSON</p>\n<pre><code>j = f.json()\nf2 = c.flist(j)\n</code></pre>\n<h2>Python3 Installation</h2>\n<p>It is easiest to install Miniconda, which contains precompiled Python binaries for both 32 and 64bit.</p>\n<p>32 bit (Python 3.7):</p>\n<pre><code>wget https://repo.anaconda.com/miniconda/Miniconda3-4.5.12-Linux-x86.sh\n</code></pre>\n<p>64 bit (Python 3.7):</p>\n<pre><code>wget https://repo.anaconda.com/miniconda/Miniconda3-4.7.12.1-Linux-x86_64.sh\n</code></pre>\n<p>To install it, chose a path you want it to be installed on, like <code>/path/to/miniconda3</code></p>\n<pre><code>sh Miniconda3-4.5.12-Linux-x86.sh -b -p /path/to/miniconda3\nrm Miniconda3-4.5.12-Linux-x86.sh\n</code></pre>\n<p>You can alternatively build Python from source which will take up less space than Miniconda.</p>\n<h1>Run the tests</h1>\n<p>The tests require a valid CM up and running. It only calls <code>PCM_OP_TEST_LOOPBACK</code>.</p>\n<p>cd into the tests directory, and edit pin.conf. Change this line to point to the correct CM:</p>\n<pre><code>- nap cm_ptr ip ${HOSTNAME} ${BRM_CM_PORT}\n</code></pre>\n<p>Additionally, cd into the <code>pin_conf_test</code> directory, and do the same for the pin.conf there.</p>\n<p>After this, run the tests from inside the <code>tests/</code> directory like:</p>\n<pre><code>python3 tests.py\n</code></pre>\n<h1>pin.conf</h1>\n<p>A <code>pin.conf</code> file has to be created in the same directory you run Python from</p>\n<p>At a minimum it needs these lines:</p>\n<pre><code>- nap cm_ptr ip ${HOSTNAME} ${BRM_CM_PORT}\n- nap login_type 1\n- nap login_name root.0.0.0.1\n- nap login_pw   password\n- - userid 0.0.0.1 /service/pcm_client 1\n</code></pre>\n<p>You should also include this:</p>\n<pre><code> - - pin_virtual_time ${PIN_HOME}/lib/pin_virtual_time_file\n - - ops_fields_extension_file ${PIN_HOME}/include/custom_ops_dat.dat\n</code></pre>\n<p>where <code>custom_ops_dat.dat</code> points to your custom opcode file.</p>\n<p>Just like with normal BRM C code, you need this file in order to get access to custom fields and opcodes.</p>\n<h1>Calling C from Python</h1>\n<p>Check out the examples/call_c_from_python/ for an example of calling C from Python using ctypes.</p>\n<h1>Calling Python from C</h1>\n<p>Check out the examples/call_python_from_c/ for an example of calling Python from C.</p>\n\n          </div>"}, "last_serial": 6694711, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "6fb8958193395211bcc6b2e57e5744e6", "sha256": "88c2451dc98c2d1be2eed5cc267e64cf6819dc05caedb06fc0a0d92818e02590"}, "downloads": -1, "filename": "pybrm-1.0.0.tar.gz", "has_sig": false, "md5_digest": "6fb8958193395211bcc6b2e57e5744e6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 62427, "upload_time": "2020-02-25T06:55:55", "upload_time_iso_8601": "2020-02-25T06:55:55.000283Z", "url": "https://files.pythonhosted.org/packages/04/f1/9c3bd60c4d5e377156d07daf1641feb58cc7ed0208a2026c00192952afc1/pybrm-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6fb8958193395211bcc6b2e57e5744e6", "sha256": "88c2451dc98c2d1be2eed5cc267e64cf6819dc05caedb06fc0a0d92818e02590"}, "downloads": -1, "filename": "pybrm-1.0.0.tar.gz", "has_sig": false, "md5_digest": "6fb8958193395211bcc6b2e57e5744e6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 62427, "upload_time": "2020-02-25T06:55:55", "upload_time_iso_8601": "2020-02-25T06:55:55.000283Z", "url": "https://files.pythonhosted.org/packages/04/f1/9c3bd60c4d5e377156d07daf1641feb58cc7ed0208a2026c00192952afc1/pybrm-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:09:01 2020"}