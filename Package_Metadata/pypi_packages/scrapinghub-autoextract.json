{"info": {"author": "Mikhail Korobov", "author_email": "kmike84@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "=======================\nscrapinghub-autoextract\n=======================\n\n.. image:: https://img.shields.io/pypi/v/scrapinghub-autoextract.svg\n   :target: https://pypi.python.org/pypi/scrapinghub-autoextract\n   :alt: PyPI Version\n\n.. image:: https://img.shields.io/pypi/pyversions/scrapinghub-autoextract.svg\n   :target: https://pypi.python.org/pypi/scrapinghub-autoextract\n   :alt: Supported Python Versions\n\n.. image:: https://travis-ci.org/scrapinghub/scrapinghub-autoextract.svg?branch=master\n   :target: https://travis-ci.org/scrapinghub/scrapinghub-autoextract\n   :alt: Build Status\n\n.. image:: https://codecov.io/github/scrapinghub/scrapinghub-autoextract/coverage.svg?branch=master\n   :target: https://codecov.io/gh/scrapinghub/scrapinghub-autoextract\n   :alt: Coverage report\n\n\nPython client libraries for `Scrapinghub AutoExtract API`_.\nIt allows to extract product, article, job posting, etc.\ninformation from any website - whatever the API supports.\n\nCommand-line utility, asyncio-based library and a simple synchronous wrapper\nare provided by this package.\n\nLicense is BSD 3-clause.\n\n.. _Scrapinghub AutoExtract API: https://scrapinghub.com/autoextract\n\n\nInstallation\n============\n\n::\n\n    pip install scrapinghub-autoextract\n\nscrapinghub-autoextract requires Python 3.6+ for CLI tool and for\nthe asyncio API; basic, synchronous API works with Python 3.5.\n\nUsage\n=====\n\nFirst, make sure you have an API key. To avoid passing it in ``api_key``\nargument with every call, you can set ``SCRAPINGHUB_AUTOEXTRACT_KEY``\nenvironment variable with the key.\n\nCommand-line interface\n----------------------\n\nThe most basic way to use the client is from a command line.\nFirst, create a file with urls, an URL per line (e.g. ``urls.txt``).\nSecond, set ``SCRAPINGHUB_AUTOEXTRACT_KEY`` env variable with your\nAutoExtract API key (you can also pass API key as ``--api-key`` script\nargument).\n\nThen run a script, to get the results::\n\n    python -m autoextract urls.txt --page-type article --output res.jl\n\n.. note::\n    The results can be stored in an order which is different from the input\n    order. If you need to match the output results to the input URLs, the\n    best way is to use ``meta`` field (see below); it is passed through,\n    and returned as-is in ``row[\"query\"][\"userQuery\"][\"meta\"]``.\n\nIf you need more flexibility, you can customize the requests by creating\na JsonLines file with queries: a JSON object per line. You can pass any\nAutoExtract options there. Example - store it in ``queries.jl`` file::\n\n    {\"url\": \"http://example.com\", \"meta\": \"id0\", \"articleBodyRaw\": false}\n    {\"url\": \"http://example.com/foo\", \"meta\": \"id1\", \"articleBodyRaw\": false}\n    {\"url\": \"http://example.com/bar\", \"meta\": \"id2\", \"articleBodyRaw\": false}\n\nSee `API docs`_ for a description of all supported parameters in these query\ndicts. API docs mention batch requests and their limitation\n(no more than 100 queries at time); these limits don't apply to the queries.jl\nfile (i.e. it may have millions of rows), as the command-line script does\nits own batching.\n\n.. _API docs: https://doc.scrapinghub.com/autoextract.html\n\nNote that in the example ``pageType`` argument is omitted; ``pageType``\nvalues are filled automatically from ``--page-type`` command line argument\nvalue. You can also set a different ``pageType`` for a row in ``queries.jl``\nfile; it has a priority over ``--page-type`` passed in cmdline.\n\nTo get results for this ``queries.jl`` file, run::\n\n    python -m autoextract --intype jl queries.jl --page-type article --output res.jl\n\nProcessing speed\n~~~~~~~~~~~~~~~~\n\nEach API key has a limit on RPS. To get your URLs processed faster you can\ntune concurrency options: batch size and a number of connections.\n\nBest options depend on the RPS limit and on websites you're extracting\ndata from. For example, if your API key has a limit of 3RPS, and average\nresponse time you observe for your websites is 10s, then to get to these\n3RPS you may set e.g. batch size = 2, number of connections = 15 - this\nwould allow to process 30 requests in parallel.\n\nTo set these options in the CLI, use ``--n-conn`` and ``--batch-size``\narguments::\n\n    python -m autoextract urls.txt --page-type articles --n-conn 15 --batch-size 2 --output res.jl\n\nIf too many requests are being processed in parallel, you'll be getting\nthrottling errors. They are handled by CLI automatically, but they make\nextraction less efficient; please tune the concurrency options to\nnot hit the throttling errors (HTTP 429) often.\n\nYou may be also limited by the website speed. AutoExtract tries not to hit\nany individual website too hard, but it could be better to limit this on\na client side as well. If you're extracting data from a single website,\nit could make sense to decrease the amount of parallel requests; it can ensure\nhigher success ratio overall.\n\nIf you're extracting data from multiple websites, it makes sense to spread the\nload across time: if you have websites A, B and C, don't send requests in\nAAAABBBBCCCC order, send them in ABCABCABCABC order instead.\n\nTo do so, you can change the order of the queries in your input file.\nAlternatively, you can pass ``--shuffle`` options; it randomly shuffles\ninput queries before sending them to the API:\n\n    python -m autoextract urls.txt --shuffle --page-type articles --output res.jl\n\nRun ``python -m autoextract --help`` to get description of all supported\noptions.\n\nSynchronous API\n---------------\n\nSynchronous API provides an easy way to try AutoExtract.\nFor production usage asyncio API is strongly recommended. Currently the\nsynchronous API doesn't handle throttling errors, and has other limitations;\nit is most suited for quickly checking extraction results for a few URLs.\n\nTo send a request, use ``request_raw`` function; consult with the\n`API docs`_ to understand how to populate the query::\n\n    from autoextract.sync import request_raw\n    query = [{'url': 'http://example.com.foo', 'pageType': 'article'}]\n    results = request_raw(query)\n\nNote that if there are several URLs in the query, results can be returned in\narbitrary order.\n\nThere is also a ``autoextract.sync.request_batch`` helper, which accepts URLs\nand page type, and ensures results are in the same order as requested URLs::\n\n    from autoextract.sync import request_batch\n    urls = ['http://example.com/foo', 'http://example.com/bar']\n    results = request_batch(urls, page_type='article')\n\n.. note::\n    Currently request_batch is limited to 100 URLs at time only.\n\nasyncio API\n-----------\n\nBasic usage is similar to the sync API (``request_raw``),\nbut asyncio event loop is used::\n\n    from autoextract.aio import request_raw\n\n    async def foo():\n        query = [{'url': 'http://example.com.foo', 'pageType': 'article'}]\n        results1 = await request_raw(query)\n        # ...\n\nThere is also ``request_parallel_as_completed`` function, which allows\nto process many URLs in parallel, using both batching and multiple\nconnections::\n\n    import sys\n    from autoextract.aio import request_parallel_as_completed, create_session\n    from autoextract import ArticleRequest\n\n    async def extract_from(urls):\n        requests = [ArticleRequest(url) for url in urls]\n        async with create_session() as session:\n            res_iter = request_parallel_as_completed(requests,\n                                        n_conn=15, batch_size=2,\n                                        session=session)\n            for fut in res_iter:\n                try:\n                    batch_result = await fut\n                    for res in batch_result:\n                        # do something with a result, e.g.\n                        print(json.dumps(res))\n                except ApiError as e:\n                    print(e, file=sys.stderr)\n                    raise\n\n``request_parallel_as_completed`` is modelled after ``asyncio.as_completed``\n(see https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed),\nand actually uses it under the hood.\n\nNote ``from autoextract import ArticleRequest`` and its usage in the\nexample above. There are several Request helper classes,\nwhich simplify building of the queries.\n\n``request_parallel_as_completed`` and ``request_raw`` functions handle\nthrottling (http 429 errors) and network errors, retrying a request in\nthese cases.\n\nCLI interface implementation (``autoextract/__main__.py``) can serve\nas an usage example.\n\nRequest helpers\n---------------\n\nTo query AutoExtract you need to create a dict with request parameters, e.g.::\n\n    {'url': 'http://example.com.foo', 'pageType': 'article'}\n\nTo simplify the library usage and avoid typos, scrapinghub-autpextract\nprovides helper classes for constructing these dicts::\n\n* autoextract.Request\n* autoextract.ArticleRequest\n* autoextract.ProductRequest\n* autoextract.JobPostingRequest\n\nYou can pass instances of these classes instead of dicts everywhere when\nrequests dicts are accepted. So e.g. instead of writing this::\n\n    query = [{\"url\": url, \"pageType\": \"article\"} for url in urls]\n\nYou can write this::\n\n    query = [Request(url, pageType=\"article\") for url in urls]\n\nor this::\n\n    query = [ArticleRequest(url) for url in urls]\n\nThere is one difference: ``articleBodyRaw`` parameter is set to ``false``\nby default when Request or its variants are used, while it is ``true``\nby default in the API.\n\nContributing\n============\n\n* Source code: https://github.com/scrapinghub/scrapinghub-autoextract\n* Issue tracker: https://github.com/scrapinghub/scrapinghub-autoextract/issues\n\nUse tox_ to run tests with different Python versions::\n\n    tox\n\nThe command above also runs type checks; we use mypy.\n\n.. _tox: https://tox.readthedocs.io\n\n\nChanges\n=======\n\n0.2.0 (2020-04-15)\n------------------\n\n* asyncio API is rewritten, to simplify use in cases where passing meta\n  is required. ``autoextract.aio.request_parallel_as_completed`` is added,\n  ``autoextract.aio.request_parallel`` and ``autoextract.aio.request_batch``\n  are removed.\n* CLI: it now shows various stats: mean response and connect time,\n  % of throttling errors, % of network and other errors\n* CLI: new ``--intype jl`` option allows to process a .jl file\n  with arbitrary AutoExtract API queries\n* CLI: new ``--shuffle`` option allows to shuffle input data, to spread it\n  more evenly across websites.\n* CLI: it no longer exits on unrecoverable errors, to aid long-running\n  processing tasks.\n* retry logic is adjusted to handle network errors better.\n* ``autoextract.aio.request_raw`` and\n  ``autoextract.aio.request_parallel_as_completed`` functions provide an\n  interface to return statistics about requests made, including retries.\n* autoextract.Request, autoextract.ArticleRequest, autoextract.ProductRequest,\n  autoextract.JobPostingRequest helper classes\n* Documentation improvements.\n\n0.1.1 (2020-03-12)\n------------------\n\n* allow up to 100 elements in a batch, not up to 99\n* custom User-Agent header is added\n* Python 3.8 support is declared & tested\n\n0.1 (2019-10-09)\n----------------\n\nInitial release.\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/scrapinghub/scrapinghub-autoextract", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "scrapinghub-autoextract", "package_url": "https://pypi.org/project/scrapinghub-autoextract/", "platform": "", "project_url": "https://pypi.org/project/scrapinghub-autoextract/", "project_urls": {"Homepage": "https://github.com/scrapinghub/scrapinghub-autoextract"}, "release_url": "https://pypi.org/project/scrapinghub-autoextract/0.2.0/", "requires_dist": ["requests", "attrs", "runstats", "tenacity ; python_version >= \"3.6\"", "aiohttp (>=3.6.0) ; python_version >= \"3.6\"", "tqdm ; python_version >= \"3.6\""], "requires_python": "", "summary": "Python interface to Scrapinghub Automatic Extraction API", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://pypi.python.org/pypi/scrapinghub-autoextract\" rel=\"nofollow\"><img alt=\"PyPI Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7d276057853efd01a9c5f4e3f747ecf6967156b4/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f7363726170696e676875622d6175746f657874726163742e737667\"></a>\n<a href=\"https://pypi.python.org/pypi/scrapinghub-autoextract\" rel=\"nofollow\"><img alt=\"Supported Python Versions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9276f775ab401072143073ab8d67a3aa0453404d/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f7363726170696e676875622d6175746f657874726163742e737667\"></a>\n<a href=\"https://travis-ci.org/scrapinghub/scrapinghub-autoextract\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5bcaa02ff41cd6ae2aa8e6b0aa84ef0133ed19db/68747470733a2f2f7472617669732d63692e6f72672f7363726170696e676875622f7363726170696e676875622d6175746f657874726163742e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/scrapinghub/scrapinghub-autoextract\" rel=\"nofollow\"><img alt=\"Coverage report\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/44d26567664d64ec071f157bf49009a6a4797177/68747470733a2f2f636f6465636f762e696f2f6769746875622f7363726170696e676875622f7363726170696e676875622d6175746f657874726163742f636f7665726167652e7376673f6272616e63683d6d6173746572\"></a>\n<p>Python client libraries for <a href=\"https://scrapinghub.com/autoextract\" rel=\"nofollow\">Scrapinghub AutoExtract API</a>.\nIt allows to extract product, article, job posting, etc.\ninformation from any website - whatever the API supports.</p>\n<p>Command-line utility, asyncio-based library and a simple synchronous wrapper\nare provided by this package.</p>\n<p>License is BSD 3-clause.</p>\n<div id=\"installation\">\n<h2>Installation</h2>\n<pre>pip install scrapinghub-autoextract\n</pre>\n<p>scrapinghub-autoextract requires Python 3.6+ for CLI tool and for\nthe asyncio API; basic, synchronous API works with Python 3.5.</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>First, make sure you have an API key. To avoid passing it in <tt>api_key</tt>\nargument with every call, you can set <tt>SCRAPINGHUB_AUTOEXTRACT_KEY</tt>\nenvironment variable with the key.</p>\n<div id=\"command-line-interface\">\n<h3>Command-line interface</h3>\n<p>The most basic way to use the client is from a command line.\nFirst, create a file with urls, an URL per line (e.g. <tt>urls.txt</tt>).\nSecond, set <tt>SCRAPINGHUB_AUTOEXTRACT_KEY</tt> env variable with your\nAutoExtract API key (you can also pass API key as <tt><span class=\"pre\">--api-key</span></tt> script\nargument).</p>\n<p>Then run a script, to get the results:</p>\n<pre>python -m autoextract urls.txt --page-type article --output res.jl\n</pre>\n<div>\n<p>Note</p>\n<p>The results can be stored in an order which is different from the input\norder. If you need to match the output results to the input URLs, the\nbest way is to use <tt>meta</tt> field (see below); it is passed through,\nand returned as-is in <tt><span class=\"pre\">row[\"query\"][\"userQuery\"][\"meta\"]</span></tt>.</p>\n</div>\n<p>If you need more flexibility, you can customize the requests by creating\na JsonLines file with queries: a JSON object per line. You can pass any\nAutoExtract options there. Example - store it in <tt>queries.jl</tt> file:</p>\n<pre>{\"url\": \"http://example.com\", \"meta\": \"id0\", \"articleBodyRaw\": false}\n{\"url\": \"http://example.com/foo\", \"meta\": \"id1\", \"articleBodyRaw\": false}\n{\"url\": \"http://example.com/bar\", \"meta\": \"id2\", \"articleBodyRaw\": false}\n</pre>\n<p>See <a href=\"https://doc.scrapinghub.com/autoextract.html\" rel=\"nofollow\">API docs</a> for a description of all supported parameters in these query\ndicts. API docs mention batch requests and their limitation\n(no more than 100 queries at time); these limits don\u2019t apply to the queries.jl\nfile (i.e. it may have millions of rows), as the command-line script does\nits own batching.</p>\n<p>Note that in the example <tt>pageType</tt> argument is omitted; <tt>pageType</tt>\nvalues are filled automatically from <tt><span class=\"pre\">--page-type</span></tt> command line argument\nvalue. You can also set a different <tt>pageType</tt> for a row in <tt>queries.jl</tt>\nfile; it has a priority over <tt><span class=\"pre\">--page-type</span></tt> passed in cmdline.</p>\n<p>To get results for this <tt>queries.jl</tt> file, run:</p>\n<pre>python -m autoextract --intype jl queries.jl --page-type article --output res.jl\n</pre>\n<div id=\"processing-speed\">\n<h4>Processing speed</h4>\n<p>Each API key has a limit on RPS. To get your URLs processed faster you can\ntune concurrency options: batch size and a number of connections.</p>\n<p>Best options depend on the RPS limit and on websites you\u2019re extracting\ndata from. For example, if your API key has a limit of 3RPS, and average\nresponse time you observe for your websites is 10s, then to get to these\n3RPS you may set e.g. batch size = 2, number of connections = 15 - this\nwould allow to process 30 requests in parallel.</p>\n<p>To set these options in the CLI, use <tt><span class=\"pre\">--n-conn</span></tt> and <tt><span class=\"pre\">--batch-size</span></tt>\narguments:</p>\n<pre>python -m autoextract urls.txt --page-type articles --n-conn 15 --batch-size 2 --output res.jl\n</pre>\n<p>If too many requests are being processed in parallel, you\u2019ll be getting\nthrottling errors. They are handled by CLI automatically, but they make\nextraction less efficient; please tune the concurrency options to\nnot hit the throttling errors (HTTP 429) often.</p>\n<p>You may be also limited by the website speed. AutoExtract tries not to hit\nany individual website too hard, but it could be better to limit this on\na client side as well. If you\u2019re extracting data from a single website,\nit could make sense to decrease the amount of parallel requests; it can ensure\nhigher success ratio overall.</p>\n<p>If you\u2019re extracting data from multiple websites, it makes sense to spread the\nload across time: if you have websites A, B and C, don\u2019t send requests in\nAAAABBBBCCCC order, send them in ABCABCABCABC order instead.</p>\n<p>To do so, you can change the order of the queries in your input file.\nAlternatively, you can pass <tt><span class=\"pre\">--shuffle</span></tt> options; it randomly shuffles\ninput queries before sending them to the API:</p>\n<blockquote>\npython -m autoextract urls.txt \u2013shuffle \u2013page-type articles \u2013output res.jl</blockquote>\n<p>Run <tt>python <span class=\"pre\">-m</span> autoextract <span class=\"pre\">--help</span></tt> to get description of all supported\noptions.</p>\n</div>\n</div>\n<div id=\"synchronous-api\">\n<h3>Synchronous API</h3>\n<p>Synchronous API provides an easy way to try AutoExtract.\nFor production usage asyncio API is strongly recommended. Currently the\nsynchronous API doesn\u2019t handle throttling errors, and has other limitations;\nit is most suited for quickly checking extraction results for a few URLs.</p>\n<p>To send a request, use <tt>request_raw</tt> function; consult with the\n<a href=\"https://doc.scrapinghub.com/autoextract.html\" rel=\"nofollow\">API docs</a> to understand how to populate the query:</p>\n<pre>from autoextract.sync import request_raw\nquery = [{'url': 'http://example.com.foo', 'pageType': 'article'}]\nresults = request_raw(query)\n</pre>\n<p>Note that if there are several URLs in the query, results can be returned in\narbitrary order.</p>\n<p>There is also a <tt>autoextract.sync.request_batch</tt> helper, which accepts URLs\nand page type, and ensures results are in the same order as requested URLs:</p>\n<pre>from autoextract.sync import request_batch\nurls = ['http://example.com/foo', 'http://example.com/bar']\nresults = request_batch(urls, page_type='article')\n</pre>\n<div>\n<p>Note</p>\n<p>Currently request_batch is limited to 100 URLs at time only.</p>\n</div>\n</div>\n<div id=\"asyncio-api\">\n<h3>asyncio API</h3>\n<p>Basic usage is similar to the sync API (<tt>request_raw</tt>),\nbut asyncio event loop is used:</p>\n<pre>from autoextract.aio import request_raw\n\nasync def foo():\n    query = [{'url': 'http://example.com.foo', 'pageType': 'article'}]\n    results1 = await request_raw(query)\n    # ...\n</pre>\n<p>There is also <tt>request_parallel_as_completed</tt> function, which allows\nto process many URLs in parallel, using both batching and multiple\nconnections:</p>\n<pre>import sys\nfrom autoextract.aio import request_parallel_as_completed, create_session\nfrom autoextract import ArticleRequest\n\nasync def extract_from(urls):\n    requests = [ArticleRequest(url) for url in urls]\n    async with create_session() as session:\n        res_iter = request_parallel_as_completed(requests,\n                                    n_conn=15, batch_size=2,\n                                    session=session)\n        for fut in res_iter:\n            try:\n                batch_result = await fut\n                for res in batch_result:\n                    # do something with a result, e.g.\n                    print(json.dumps(res))\n            except ApiError as e:\n                print(e, file=sys.stderr)\n                raise\n</pre>\n<p><tt>request_parallel_as_completed</tt> is modelled after <tt>asyncio.as_completed</tt>\n(see <a href=\"https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed\" rel=\"nofollow\">https://docs.python.org/3/library/asyncio-task.html#asyncio.as_completed</a>),\nand actually uses it under the hood.</p>\n<p>Note <tt>from autoextract import ArticleRequest</tt> and its usage in the\nexample above. There are several Request helper classes,\nwhich simplify building of the queries.</p>\n<p><tt>request_parallel_as_completed</tt> and <tt>request_raw</tt> functions handle\nthrottling (http 429 errors) and network errors, retrying a request in\nthese cases.</p>\n<p>CLI interface implementation (<tt>autoextract/__main__.py</tt>) can serve\nas an usage example.</p>\n</div>\n<div id=\"request-helpers\">\n<h3>Request helpers</h3>\n<p>To query AutoExtract you need to create a dict with request parameters, e.g.:</p>\n<pre>{'url': 'http://example.com.foo', 'pageType': 'article'}\n</pre>\n<p>To simplify the library usage and avoid typos, scrapinghub-autpextract\nprovides helper classes for constructing these dicts:</p>\n<pre>* autoextract.Request\n* autoextract.ArticleRequest\n* autoextract.ProductRequest\n* autoextract.JobPostingRequest\n</pre>\n<p>You can pass instances of these classes instead of dicts everywhere when\nrequests dicts are accepted. So e.g. instead of writing this:</p>\n<pre>query = [{\"url\": url, \"pageType\": \"article\"} for url in urls]\n</pre>\n<p>You can write this:</p>\n<pre>query = [Request(url, pageType=\"article\") for url in urls]\n</pre>\n<p>or this:</p>\n<pre>query = [ArticleRequest(url) for url in urls]\n</pre>\n<p>There is one difference: <tt>articleBodyRaw</tt> parameter is set to <tt>false</tt>\nby default when Request or its variants are used, while it is <tt>true</tt>\nby default in the API.</p>\n</div>\n</div>\n<div id=\"contributing\">\n<h2>Contributing</h2>\n<ul>\n<li>Source code: <a href=\"https://github.com/scrapinghub/scrapinghub-autoextract\" rel=\"nofollow\">https://github.com/scrapinghub/scrapinghub-autoextract</a></li>\n<li>Issue tracker: <a href=\"https://github.com/scrapinghub/scrapinghub-autoextract/issues\" rel=\"nofollow\">https://github.com/scrapinghub/scrapinghub-autoextract/issues</a></li>\n</ul>\n<p>Use <a href=\"https://tox.readthedocs.io\" rel=\"nofollow\">tox</a> to run tests with different Python versions:</p>\n<pre>tox\n</pre>\n<p>The command above also runs type checks; we use mypy.</p>\n</div>\n<div id=\"changes\">\n<h2>Changes</h2>\n<div id=\"id1\">\n<h3>0.2.0 (2020-04-15)</h3>\n<ul>\n<li>asyncio API is rewritten, to simplify use in cases where passing meta\nis required. <tt>autoextract.aio.request_parallel_as_completed</tt> is added,\n<tt>autoextract.aio.request_parallel</tt> and <tt>autoextract.aio.request_batch</tt>\nare removed.</li>\n<li>CLI: it now shows various stats: mean response and connect time,\n% of throttling errors, % of network and other errors</li>\n<li>CLI: new <tt><span class=\"pre\">--intype</span> jl</tt> option allows to process a .jl file\nwith arbitrary AutoExtract API queries</li>\n<li>CLI: new <tt><span class=\"pre\">--shuffle</span></tt> option allows to shuffle input data, to spread it\nmore evenly across websites.</li>\n<li>CLI: it no longer exits on unrecoverable errors, to aid long-running\nprocessing tasks.</li>\n<li>retry logic is adjusted to handle network errors better.</li>\n<li><tt>autoextract.aio.request_raw</tt> and\n<tt>autoextract.aio.request_parallel_as_completed</tt> functions provide an\ninterface to return statistics about requests made, including retries.</li>\n<li>autoextract.Request, autoextract.ArticleRequest, autoextract.ProductRequest,\nautoextract.JobPostingRequest helper classes</li>\n<li>Documentation improvements.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>0.1.1 (2020-03-12)</h3>\n<ul>\n<li>allow up to 100 elements in a batch, not up to 99</li>\n<li>custom User-Agent header is added</li>\n<li>Python 3.8 support is declared &amp; tested</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>0.1 (2019-10-09)</h3>\n<p>Initial release.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 7026673, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "731b2061c99f5b9ef99cf61bed9d2b19", "sha256": "f0a9e69c49e5f1e3d1cdfa6069c322b1d9fa8d10c59a422295aa34cf74c14672"}, "downloads": -1, "filename": "scrapinghub_autoextract-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "731b2061c99f5b9ef99cf61bed9d2b19", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 11964, "upload_time": "2019-10-09T18:16:23", "upload_time_iso_8601": "2019-10-09T18:16:23.270093Z", "url": "https://files.pythonhosted.org/packages/30/ef/71ab8223947762163e062a0c79ce5019cce474831e77cf19d1fafd97e2d2/scrapinghub_autoextract-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "18ad64552554031e4bc6b67efc4d3677", "sha256": "672e67b9443aa5ab78345de212b273f92031c95688474b58b0b3fe46ba2d13fa"}, "downloads": -1, "filename": "scrapinghub-autoextract-0.1.tar.gz", "has_sig": false, "md5_digest": "18ad64552554031e4bc6b67efc4d3677", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11042, "upload_time": "2019-10-09T18:16:27", "upload_time_iso_8601": "2019-10-09T18:16:27.302969Z", "url": "https://files.pythonhosted.org/packages/81/1c/826a9aa957870fc84f1306ecc3b7d71a9eb4a57b254eb31b5e0813985d1c/scrapinghub-autoextract-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "51b5cca6b7561a08484055916ab3438f", "sha256": "d70a2266792950983b8d64503759861d6d2d4fa41d0c48364489fe00de0c2321"}, "downloads": -1, "filename": "scrapinghub_autoextract-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "51b5cca6b7561a08484055916ab3438f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 12462, "upload_time": "2020-03-12T16:06:21", "upload_time_iso_8601": "2020-03-12T16:06:21.444455Z", "url": "https://files.pythonhosted.org/packages/cc/99/bf13abb586f316554b9f43be21a74523f7b1a94cabf4e6a2c1950a794fa9/scrapinghub_autoextract-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "93f43fd475a0158d5fa5590b4b67302b", "sha256": "c1dc2f0ec3112513d44b7f43d433247c62fea91c9e487d9bd53491d3a45e3fab"}, "downloads": -1, "filename": "scrapinghub-autoextract-0.1.1.tar.gz", "has_sig": false, "md5_digest": "93f43fd475a0158d5fa5590b4b67302b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11756, "upload_time": "2020-03-12T16:06:22", "upload_time_iso_8601": "2020-03-12T16:06:22.740253Z", "url": "https://files.pythonhosted.org/packages/c3/80/89f406181f8f408c8a763f1484e54ff247cb18ad4488745d9021f528c0cf/scrapinghub-autoextract-0.1.1.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "413a65c74b7496329a0966c4e77677d1", "sha256": "4c5416cfe81609d8a2f0f40d60bc197aee68061ae938a3cd64ea9de0e1aa54d4"}, "downloads": -1, "filename": "scrapinghub_autoextract-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "413a65c74b7496329a0966c4e77677d1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17797, "upload_time": "2020-04-15T19:13:22", "upload_time_iso_8601": "2020-04-15T19:13:22.009007Z", "url": "https://files.pythonhosted.org/packages/66/50/a7f710e92738d7521fadbde072df89d02a405847d9ed344cbf7a3e4c49c4/scrapinghub_autoextract-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bce951efbb8d9e6d2be9e1975f049eca", "sha256": "78138f5285c73d2baeff1151cc814858b5cb521b65425487810a037f52fe29b5"}, "downloads": -1, "filename": "scrapinghub-autoextract-0.2.0.tar.gz", "has_sig": false, "md5_digest": "bce951efbb8d9e6d2be9e1975f049eca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19065, "upload_time": "2020-04-15T19:13:23", "upload_time_iso_8601": "2020-04-15T19:13:23.395799Z", "url": "https://files.pythonhosted.org/packages/f5/a0/acd2b913beb1f532513b5953c8ba8795198d964145f16e6cb0ef80d97753/scrapinghub-autoextract-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "413a65c74b7496329a0966c4e77677d1", "sha256": "4c5416cfe81609d8a2f0f40d60bc197aee68061ae938a3cd64ea9de0e1aa54d4"}, "downloads": -1, "filename": "scrapinghub_autoextract-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "413a65c74b7496329a0966c4e77677d1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17797, "upload_time": "2020-04-15T19:13:22", "upload_time_iso_8601": "2020-04-15T19:13:22.009007Z", "url": "https://files.pythonhosted.org/packages/66/50/a7f710e92738d7521fadbde072df89d02a405847d9ed344cbf7a3e4c49c4/scrapinghub_autoextract-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bce951efbb8d9e6d2be9e1975f049eca", "sha256": "78138f5285c73d2baeff1151cc814858b5cb521b65425487810a037f52fe29b5"}, "downloads": -1, "filename": "scrapinghub-autoextract-0.2.0.tar.gz", "has_sig": false, "md5_digest": "bce951efbb8d9e6d2be9e1975f049eca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19065, "upload_time": "2020-04-15T19:13:23", "upload_time_iso_8601": "2020-04-15T19:13:23.395799Z", "url": "https://files.pythonhosted.org/packages/f5/a0/acd2b913beb1f532513b5953c8ba8795198d964145f16e6cb0ef80d97753/scrapinghub-autoextract-0.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:56:52 2020"}