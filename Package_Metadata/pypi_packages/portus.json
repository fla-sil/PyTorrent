{"info": {"author": "Frank Cangialosi", "author_email": "frankc@csail.mit.edu", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 2", "Programming Language :: Python :: 3", "Programming Language :: Rust", "Topic :: System :: Networking"], "description": "# pyportus\n\nThis module provides a python interface to the Portus CCP implementation.\n\n\n## Setup\n\nTo build and use the python bindings, you also need setuptools_rust\n\n```bash\nsudo pip install setuptools_rust\n```\n\nYou need to tell it to use the nightly version of rust since some features\nare still experimental:\n* Check where the package was installed: `pip show setuptools_rust`\n* Edit `packages/setuptools_rust/build.py`\n* Search for the line containing \"rustc\" (should be ~102), and change the args to be `[\"cargo\", \"+nightly\", \"rustc\", ...`\n\nNow, rather than running make, you can build with\n\n```bash\npython setup.py develop\n```\n\nDepending on your python environment setup, you may need to run this with `sudo`\n(and ensure that your `PATH` variable is preserved):\n\n```bash\nsudo env PATH=$PATH python setup.py develop\n```\n\nNow you should be able to import the package like so:\n\n```python\nimport portus\n```\n\n\n\n## Writing Algorithms\n\n\n### Overview\n\nAn algorithm in portus is represented by a Python class and an instance of this class represents a single TCP flow. A new instance is created *for each* flow. \n\nThis class must be a subclass of `portus.AlgBase` and must implement the two \nfollowing method signatures:\n* `on_create(self)` \n* `on_report(self, r)` \n  - `r` is a Report object containing all the fields defined in your datapath program, as well as the current `Cwnd` and `Rate`. Suppose your program defines just a single variable: `(def (acked 0))`, where `acked` adds up the total bytes acked since the last report. This value can be accessed as `r.acked`. Similarly, you can access the cwnd or rate as `r.Cwnd` and `r.Rate` (captialization important!).\n\nEach instantiation of the class will automatically have two fields inside self:\n  - `self.datapath` is a pointer to the datapath object that can be used to install\n    new datapath programs. It has two available methods:\n    1. `datapath.install( str )`, which takes a datapath program as a string. It compiles the program and installs it in the datapath. It does not return anything, though it may raise an exception if your program fails to compile.  \n    2. `datapath.update_field(field, val)`, which takes a variable in the `Report` scope of your datapath program and sets the value to `val`. For example, to update just the cwnd, you could use `datapath.update_field(\"Cwnd\", 10000)` (note: cwnd is denoted in bytes, not packets). \n  - `self.datapath_info` is a struct containing fields about this particular flow from the datapath (this could be used, for example, in `on_create` to set an initial cwnd based on the datapath's `mss`)\n    * `sock_id`: unique id of this flow in the datapath\n    * `init_cwnd`: the initial congestion window this flow will have until you set it\n    * `src_ip`, `src_port`, `dst_ip`, `dst_port`: the ip address and port of the source and destination for the flow \n\n\n### Datapath Programs\n\nDatapath programs are used to (1) define *which* statistics to send back to your usespace program and *how often* and (2) set the congestion window and/or pacing rate. A datapath program is written in a very simple lisp-like dialect and consists of a single variable definition line followed by any number of when clauses:\n```\n(def ( ... ) ( ... ))\n(when (event) (\n  do_stuff ...\n)\n(when (other_event) (\n    do_other_stuff ...\n)\n```\n\n# NOTE: the following info is out of date as the datapath program API has been\nupdated\n\n##### 1. Report Variable Definitions\n\nExample: `(def (Report.acked 0) (Report.rtt 0) (Report.timeout false))`\n\nThis line defines the names and initial values of variables in the __report scope__. Calling `(report)` in your datapath program results in a call to your algorithm's `on_report` function with the current value of these variables. *After the call these variables are reset back to their initial value.*\n\n__NOTE__: Variables in datapath programs are written as `{scope}.{name}`. For example, the `acked` variable in the `Report` scope is written as `Report.acked`. Therefore, *all variables defined in this line must* start with `Report.` However, when you access them in `on_report`, you just provide the variable name. In our example above, `Report.rtt` defines the variable `rtt` in the `Report` scope. If we want to access this value in `on_report(r)`, we'd use `r.rtt` (i.e. *not* `r.Report.rtt`). \n\n\n##### 2. When Clauses\n\nWhen clauses consist of a boolean expression and a set of instructions. On each ack, the datapath checks the boolean expression, and if it evaluates to `true`, it runs the set of instructions. For example, the following when clause sends a report (i.e. calls the `on_report` function) once every rtt:\n```\n(when (> Micros Flow.rtt_sample_us)\n    (report)\n)\n```\n\n### Putting it all together\n\nA sample algorithm definition showing the full API:\n```python\nimport portus\n\n# Class must sublcass portus.AlgBase\nclass SampleCCAlg(portus.AlgBase):\n  # Init must take exactly these parameters\n  def __init__(self, datapath, datapath_info):\n    # Store a copy of the datapath and info for later\n    self.datapath = datapath\n    self.datapath_info = datapath_info\n\n    # Internally store an initial cwnd value\n    self.cwnd = 10 * self.datapath_info.mss\n\n    # Install an initial datapath program to keep track of the RTT and report it once per RTT\n    # The first when clause is true on every single ack,\n    #    which means the 'Report.rtt' field will always keep the latest rtt sample\n    # The second when clause is true once one rtt's worth of time has passed, \n    #    at which point it will trigger on_report, and Micros (and Report.rtt) will be reset to 0\n    self.datapath.install(\"\"\"\\\n    (def\n        (Report.rtt 0)\n    )\n    (when true\n        (:= Report.rtt Flow.rtt_sample_us)\n        (fallthrough)\n    )\n    (when (> Micros Flow.rtt_sample_us)\n        (report)\n    )\n    \"\"\")\n\n  # This function will be called once per RTT, and the report struct `r` will contain:\n  # \"rtt\", \"Cwnd\", and \"Rate\"\n  def on_report(self, r):\n      # Compute new cwnd internally \n      # If the rtt has decreased, increase the cwnd by 1 packet, else decrease by 1 packet\n      if self.last_rtt < r.rtt:\n          self.cwnd += self.datapath_info.mss\n      else:\n          self.cwnd -= self.datapath_info.mss\n      self.last_rtt = r.rtt\n\n      # Send this new value of cwnd to the datapath\n      self.datapath.update_field(\"Cwnd\", self.cwnd)\n\n```\n\n\n### Important Notes\n1. You should install an initial datapath program in your `__init__` implementation, otherwise you will not receive any reports and nothing else will happen. You can always install a different datapath program later when handling `on_report`.\n2. If you want to print anything, you should use `sys.stderr.write()` (note that you need to `import sys` and that it doesn't automatically add new lines for you like `print` does). \n3. You *must* store a reference to `datapath` in `self` called \"datapath\" (i.e. `self.datapath = datapath`), because the library internally uses this to access the datapath struct as well. \n\n\n### Starting CCP \n\nThe CCP entry point is `portus.connect(ipc_type, class, debug, blocking)`:\n* `ipc_type (string)`: (netlink | unix | char) on linux or (unix) on mac\n* `class`: your algorithm class, e.g. `SampleCCAlg`\n* `debug (bool)`: if true, the CCP will log all messages passed between the ccp and datapath\n* `blocking (bool)`: if true, use blocking ipc reads, otherwise use non-blocking\n\nFor example: `portus.connect(\"netlink\", SampleCCAlg, debug=True, blocking=True)`. \n\nRegardless of whether you use blocking or non-blocking sockets, `connect` will block forever (to stop the CCP just send ctrl+c or kill the process). \n\n### Example\n\nFor a full working example of both defining an algorithm and running the CCP, see the simple AIMD scheme in `./aimd.py` and try running it: `sudo python aimd.py`. \n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ccp-project/portus", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "portus", "package_url": "https://pypi.org/project/portus/", "platform": "", "project_url": "https://pypi.org/project/portus/", "project_urls": {"Homepage": "https://github.com/ccp-project/portus"}, "release_url": "https://pypi.org/project/portus/0.5.1/", "requires_dist": ["pyportus"], "requires_python": "", "summary": "Python bindings for the Portus implementation of CCP", "version": "0.5.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>pyportus</h1>\n<p>This module provides a python interface to the Portus CCP implementation.</p>\n<h2>Setup</h2>\n<p>To build and use the python bindings, you also need setuptools_rust</p>\n<pre>sudo pip install setuptools_rust\n</pre>\n<p>You need to tell it to use the nightly version of rust since some features\nare still experimental:</p>\n<ul>\n<li>Check where the package was installed: <code>pip show setuptools_rust</code></li>\n<li>Edit <code>packages/setuptools_rust/build.py</code></li>\n<li>Search for the line containing \"rustc\" (should be ~102), and change the args to be <code>[\"cargo\", \"+nightly\", \"rustc\", ...</code></li>\n</ul>\n<p>Now, rather than running make, you can build with</p>\n<pre>python setup.py develop\n</pre>\n<p>Depending on your python environment setup, you may need to run this with <code>sudo</code>\n(and ensure that your <code>PATH</code> variable is preserved):</p>\n<pre>sudo env <span class=\"nv\">PATH</span><span class=\"o\">=</span><span class=\"nv\">$PATH</span> python setup.py develop\n</pre>\n<p>Now you should be able to import the package like so:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">portus</span>\n</pre>\n<h2>Writing Algorithms</h2>\n<h3>Overview</h3>\n<p>An algorithm in portus is represented by a Python class and an instance of this class represents a single TCP flow. A new instance is created <em>for each</em> flow.</p>\n<p>This class must be a subclass of <code>portus.AlgBase</code> and must implement the two\nfollowing method signatures:</p>\n<ul>\n<li><code>on_create(self)</code></li>\n<li><code>on_report(self, r)</code>\n<ul>\n<li><code>r</code> is a Report object containing all the fields defined in your datapath program, as well as the current <code>Cwnd</code> and <code>Rate</code>. Suppose your program defines just a single variable: <code>(def (acked 0))</code>, where <code>acked</code> adds up the total bytes acked since the last report. This value can be accessed as <code>r.acked</code>. Similarly, you can access the cwnd or rate as <code>r.Cwnd</code> and <code>r.Rate</code> (captialization important!).</li>\n</ul>\n</li>\n</ul>\n<p>Each instantiation of the class will automatically have two fields inside self:</p>\n<ul>\n<li><code>self.datapath</code> is a pointer to the datapath object that can be used to install\nnew datapath programs. It has two available methods:\n<ol>\n<li><code>datapath.install( str )</code>, which takes a datapath program as a string. It compiles the program and installs it in the datapath. It does not return anything, though it may raise an exception if your program fails to compile.</li>\n<li><code>datapath.update_field(field, val)</code>, which takes a variable in the <code>Report</code> scope of your datapath program and sets the value to <code>val</code>. For example, to update just the cwnd, you could use <code>datapath.update_field(\"Cwnd\", 10000)</code> (note: cwnd is denoted in bytes, not packets).</li>\n</ol>\n</li>\n<li><code>self.datapath_info</code> is a struct containing fields about this particular flow from the datapath (this could be used, for example, in <code>on_create</code> to set an initial cwnd based on the datapath's <code>mss</code>)\n<ul>\n<li><code>sock_id</code>: unique id of this flow in the datapath</li>\n<li><code>init_cwnd</code>: the initial congestion window this flow will have until you set it</li>\n<li><code>src_ip</code>, <code>src_port</code>, <code>dst_ip</code>, <code>dst_port</code>: the ip address and port of the source and destination for the flow</li>\n</ul>\n</li>\n</ul>\n<h3>Datapath Programs</h3>\n<p>Datapath programs are used to (1) define <em>which</em> statistics to send back to your usespace program and <em>how often</em> and (2) set the congestion window and/or pacing rate. A datapath program is written in a very simple lisp-like dialect and consists of a single variable definition line followed by any number of when clauses:</p>\n<pre><code>(def ( ... ) ( ... ))\n(when (event) (\n  do_stuff ...\n)\n(when (other_event) (\n    do_other_stuff ...\n)\n</code></pre>\n<h1>NOTE: the following info is out of date as the datapath program API has been</h1>\n<p>updated</p>\n<h5>1. Report Variable Definitions</h5>\n<p>Example: <code>(def (Report.acked 0) (Report.rtt 0) (Report.timeout false))</code></p>\n<p>This line defines the names and initial values of variables in the <strong>report scope</strong>. Calling <code>(report)</code> in your datapath program results in a call to your algorithm's <code>on_report</code> function with the current value of these variables. <em>After the call these variables are reset back to their initial value.</em></p>\n<p><strong>NOTE</strong>: Variables in datapath programs are written as <code>{scope}.{name}</code>. For example, the <code>acked</code> variable in the <code>Report</code> scope is written as <code>Report.acked</code>. Therefore, <em>all variables defined in this line must</em> start with <code>Report.</code> However, when you access them in <code>on_report</code>, you just provide the variable name. In our example above, <code>Report.rtt</code> defines the variable <code>rtt</code> in the <code>Report</code> scope. If we want to access this value in <code>on_report(r)</code>, we'd use <code>r.rtt</code> (i.e. <em>not</em> <code>r.Report.rtt</code>).</p>\n<h5>2. When Clauses</h5>\n<p>When clauses consist of a boolean expression and a set of instructions. On each ack, the datapath checks the boolean expression, and if it evaluates to <code>true</code>, it runs the set of instructions. For example, the following when clause sends a report (i.e. calls the <code>on_report</code> function) once every rtt:</p>\n<pre><code>(when (&gt; Micros Flow.rtt_sample_us)\n    (report)\n)\n</code></pre>\n<h3>Putting it all together</h3>\n<p>A sample algorithm definition showing the full API:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">portus</span>\n\n<span class=\"c1\"># Class must sublcass portus.AlgBase</span>\n<span class=\"k\">class</span> <span class=\"nc\">SampleCCAlg</span><span class=\"p\">(</span><span class=\"n\">portus</span><span class=\"o\">.</span><span class=\"n\">AlgBase</span><span class=\"p\">):</span>\n  <span class=\"c1\"># Init must take exactly these parameters</span>\n  <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">datapath</span><span class=\"p\">,</span> <span class=\"n\">datapath_info</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Store a copy of the datapath and info for later</span>\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">datapath</span> <span class=\"o\">=</span> <span class=\"n\">datapath</span>\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">datapath_info</span> <span class=\"o\">=</span> <span class=\"n\">datapath_info</span>\n\n    <span class=\"c1\"># Internally store an initial cwnd value</span>\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">cwnd</span> <span class=\"o\">=</span> <span class=\"mi\">10</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">datapath_info</span><span class=\"o\">.</span><span class=\"n\">mss</span>\n\n    <span class=\"c1\"># Install an initial datapath program to keep track of the RTT and report it once per RTT</span>\n    <span class=\"c1\"># The first when clause is true on every single ack,</span>\n    <span class=\"c1\">#    which means the 'Report.rtt' field will always keep the latest rtt sample</span>\n    <span class=\"c1\"># The second when clause is true once one rtt's worth of time has passed, </span>\n    <span class=\"c1\">#    at which point it will trigger on_report, and Micros (and Report.rtt) will be reset to 0</span>\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">datapath</span><span class=\"o\">.</span><span class=\"n\">install</span><span class=\"p\">(</span><span class=\"s2\">\"\"\"</span><span class=\"se\">\\</span>\n<span class=\"s2\">    (def</span>\n<span class=\"s2\">        (Report.rtt 0)</span>\n<span class=\"s2\">    )</span>\n<span class=\"s2\">    (when true</span>\n<span class=\"s2\">        (:= Report.rtt Flow.rtt_sample_us)</span>\n<span class=\"s2\">        (fallthrough)</span>\n<span class=\"s2\">    )</span>\n<span class=\"s2\">    (when (&gt; Micros Flow.rtt_sample_us)</span>\n<span class=\"s2\">        (report)</span>\n<span class=\"s2\">    )</span>\n<span class=\"s2\">    \"\"\"</span><span class=\"p\">)</span>\n\n  <span class=\"c1\"># This function will be called once per RTT, and the report struct `r` will contain:</span>\n  <span class=\"c1\"># \"rtt\", \"Cwnd\", and \"Rate\"</span>\n  <span class=\"k\">def</span> <span class=\"nf\">on_report</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">):</span>\n      <span class=\"c1\"># Compute new cwnd internally </span>\n      <span class=\"c1\"># If the rtt has decreased, increase the cwnd by 1 packet, else decrease by 1 packet</span>\n      <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">last_rtt</span> <span class=\"o\">&lt;</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">rtt</span><span class=\"p\">:</span>\n          <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">cwnd</span> <span class=\"o\">+=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">datapath_info</span><span class=\"o\">.</span><span class=\"n\">mss</span>\n      <span class=\"k\">else</span><span class=\"p\">:</span>\n          <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">cwnd</span> <span class=\"o\">-=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">datapath_info</span><span class=\"o\">.</span><span class=\"n\">mss</span>\n      <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">last_rtt</span> <span class=\"o\">=</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"n\">rtt</span>\n\n      <span class=\"c1\"># Send this new value of cwnd to the datapath</span>\n      <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">datapath</span><span class=\"o\">.</span><span class=\"n\">update_field</span><span class=\"p\">(</span><span class=\"s2\">\"Cwnd\"</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">cwnd</span><span class=\"p\">)</span>\n</pre>\n<h3>Important Notes</h3>\n<ol>\n<li>You should install an initial datapath program in your <code>__init__</code> implementation, otherwise you will not receive any reports and nothing else will happen. You can always install a different datapath program later when handling <code>on_report</code>.</li>\n<li>If you want to print anything, you should use <code>sys.stderr.write()</code> (note that you need to <code>import sys</code> and that it doesn't automatically add new lines for you like <code>print</code> does).</li>\n<li>You <em>must</em> store a reference to <code>datapath</code> in <code>self</code> called \"datapath\" (i.e. <code>self.datapath = datapath</code>), because the library internally uses this to access the datapath struct as well.</li>\n</ol>\n<h3>Starting CCP</h3>\n<p>The CCP entry point is <code>portus.connect(ipc_type, class, debug, blocking)</code>:</p>\n<ul>\n<li><code>ipc_type (string)</code>: (netlink | unix | char) on linux or (unix) on mac</li>\n<li><code>class</code>: your algorithm class, e.g. <code>SampleCCAlg</code></li>\n<li><code>debug (bool)</code>: if true, the CCP will log all messages passed between the ccp and datapath</li>\n<li><code>blocking (bool)</code>: if true, use blocking ipc reads, otherwise use non-blocking</li>\n</ul>\n<p>For example: <code>portus.connect(\"netlink\", SampleCCAlg, debug=True, blocking=True)</code>.</p>\n<p>Regardless of whether you use blocking or non-blocking sockets, <code>connect</code> will block forever (to stop the CCP just send ctrl+c or kill the process).</p>\n<h3>Example</h3>\n<p>For a full working example of both defining an algorithm and running the CCP, see the simple AIMD scheme in <code>./aimd.py</code> and try running it: <code>sudo python aimd.py</code>.</p>\n\n          </div>"}, "last_serial": 5184133, "releases": {"0.5.1": [{"comment_text": "", "digests": {"md5": "da165022bd02dadbbc08e7614d9a8e92", "sha256": "c359ba2f9602f4f56596dadd0dc29afce69a8d5d0cc1afef235ed34093c7f0b6"}, "downloads": -1, "filename": "portus-0.5.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "da165022bd02dadbbc08e7614d9a8e92", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 7467, "upload_time": "2019-04-24T19:40:47", "upload_time_iso_8601": "2019-04-24T19:40:47.430057Z", "url": "https://files.pythonhosted.org/packages/98/64/ba22ca66cfaa3f61560d4a83b490f46727eea989f4eb1ea4f8bd1b4119e6/portus-0.5.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "640f7e94e3a89741cf7be434440a522e", "sha256": "fb1449a0a1dec2603f9fd5a8b0dfa00136da8be5a11c59b9107b5b4be9fd0269"}, "downloads": -1, "filename": "portus-0.5.1.tar.gz", "has_sig": false, "md5_digest": "640f7e94e3a89741cf7be434440a522e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7323, "upload_time": "2019-04-24T19:40:53", "upload_time_iso_8601": "2019-04-24T19:40:53.094854Z", "url": "https://files.pythonhosted.org/packages/28/5c/9ffb33399cfe39fb9973db3013fc6cf2b734e0464bdc51e2fd7af725db05/portus-0.5.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "da165022bd02dadbbc08e7614d9a8e92", "sha256": "c359ba2f9602f4f56596dadd0dc29afce69a8d5d0cc1afef235ed34093c7f0b6"}, "downloads": -1, "filename": "portus-0.5.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "da165022bd02dadbbc08e7614d9a8e92", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 7467, "upload_time": "2019-04-24T19:40:47", "upload_time_iso_8601": "2019-04-24T19:40:47.430057Z", "url": "https://files.pythonhosted.org/packages/98/64/ba22ca66cfaa3f61560d4a83b490f46727eea989f4eb1ea4f8bd1b4119e6/portus-0.5.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "640f7e94e3a89741cf7be434440a522e", "sha256": "fb1449a0a1dec2603f9fd5a8b0dfa00136da8be5a11c59b9107b5b4be9fd0269"}, "downloads": -1, "filename": "portus-0.5.1.tar.gz", "has_sig": false, "md5_digest": "640f7e94e3a89741cf7be434440a522e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7323, "upload_time": "2019-04-24T19:40:53", "upload_time_iso_8601": "2019-04-24T19:40:53.094854Z", "url": "https://files.pythonhosted.org/packages/28/5c/9ffb33399cfe39fb9973db3013fc6cf2b734e0464bdc51e2fd7af725db05/portus-0.5.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:51:25 2020"}