{"info": {"author": "Ryan C", "author_email": "r.cross@lancaster.ac.uk", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "# pyRclone\n\nA typed rClone interface for python.\n\nWritten to more easily express awkward logic, that would be a pain or not\n(easily) possible on the command line.\n\nA short example, to tidy up and half the number of backups is shown below.\nThe logic can be trivially expanded to instead say, parse the time stamp of\nthe backup out of the folder name, to allow different logic to be applied\ndepending on the age of a backup (do nothing if 1 month old, half is 2 months\nold, remove every other after a year old etc).\n\n```py\nimport json\nimport logging\nimport os\nimport sys\n\nfrom pyrclone import Rclone, RcloneError\n\n\ndef main():\n\n    # Setup rclone runner, and have it run in verbose and dry run mode.\n    rclone: Rclone = Rclone()\n    rclone.verbose_mode = True\n    rclone.dry_run_mode = True\n\n    # Attach a logger, for more immediate output, rather than just on command completion.\n    rclone.logger.setLevel(logging.DEBUG)\n    handler: logging.StreamHandler = logging.StreamHandler(sys.stdout)\n    handler.setLevel(logging.DEBUG)\n    formatter: logging.Formatter = logging.Formatter(\n        \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n    )\n    handler.setFormatter(formatter)\n    rclone.logger.addHandler(handler)\n\n    # List all folders in backup directory to iterate over them.\n    remote_path: str = \"drive:PC/Backups\"\n    output = rclone.lsd(remote_path)\n\n    # If we failed to run, stop.\n    if output.return_code is not RcloneError.SUCCESS:\n        print(output.error)\n        return\n\n    # lsd (and all other ls commands) will default to using lsjson.\n    # Lets decode the JSON, and get a list of all our folders.\n    backup_folders = []\n    for folder in json.loads(\"\".join(files)):\n        backup_folders.append(f\"{remote_path}/{folder['Path']}\")\n\n    # With our list of folders, lets delete every other folder, excluding these\n    # useful ones.\n    #\n    # This could also be more indepth logic, such as using the modified timestamp\n    # or the timestamp in the folder name to do logic to different backups of\n    # varying age. This is allows the ease of scripting in Python to help, versus\n    # confusing/verbose command line options and shell scripts.\n    ignore_list = [\n        \"drive:PC/Backups/2017-09-18_WindowsUpdate\",\n        \"drive:PC/Backups/2019-07-30_FlatMove\",\n        \"drive:PC/Backups/2019-08-12_HDD-Swap\",\n    ]\n\n    # Iterate over every other folder and delete if not in the ignore.\n    #\n    # Of course, right now we are in dry_run mode, so this won't do anything\n    # except list what it would have done.\n    for folder in backup_folders[1::2]:\n        if folder in ignore_list:\n            continue\n        rclone.delete(folder)\n\n\nif __name__ == \"__main__\":\n    main()\n\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "GPL-3.0", "maintainer": "", "maintainer_email": "", "name": "pyrclone", "package_url": "https://pypi.org/project/pyrclone/", "platform": "", "project_url": "https://pypi.org/project/pyrclone/", "project_urls": null, "release_url": "https://pypi.org/project/pyrclone/1.0.1/", "requires_dist": null, "requires_python": ">=3.6,<4.0", "summary": "A typed interface for rclone.", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>pyRclone</h1>\n<p>A typed rClone interface for python.</p>\n<p>Written to more easily express awkward logic, that would be a pain or not\n(easily) possible on the command line.</p>\n<p>A short example, to tidy up and half the number of backups is shown below.\nThe logic can be trivially expanded to instead say, parse the time stamp of\nthe backup out of the folder name, to allow different logic to be applied\ndepending on the age of a backup (do nothing if 1 month old, half is 2 months\nold, remove every other after a year old etc).</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">json</span>\n<span class=\"kn\">import</span> <span class=\"nn\">logging</span>\n<span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">pyrclone</span> <span class=\"kn\">import</span> <span class=\"n\">Rclone</span><span class=\"p\">,</span> <span class=\"n\">RcloneError</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n\n    <span class=\"c1\"># Setup rclone runner, and have it run in verbose and dry run mode.</span>\n    <span class=\"n\">rclone</span><span class=\"p\">:</span> <span class=\"n\">Rclone</span> <span class=\"o\">=</span> <span class=\"n\">Rclone</span><span class=\"p\">()</span>\n    <span class=\"n\">rclone</span><span class=\"o\">.</span><span class=\"n\">verbose_mode</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n    <span class=\"n\">rclone</span><span class=\"o\">.</span><span class=\"n\">dry_run_mode</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n\n    <span class=\"c1\"># Attach a logger, for more immediate output, rather than just on command completion.</span>\n    <span class=\"n\">rclone</span><span class=\"o\">.</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">setLevel</span><span class=\"p\">(</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">DEBUG</span><span class=\"p\">)</span>\n    <span class=\"n\">handler</span><span class=\"p\">:</span> <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">StreamHandler</span> <span class=\"o\">=</span> <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">StreamHandler</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">stdout</span><span class=\"p\">)</span>\n    <span class=\"n\">handler</span><span class=\"o\">.</span><span class=\"n\">setLevel</span><span class=\"p\">(</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">DEBUG</span><span class=\"p\">)</span>\n    <span class=\"n\">formatter</span><span class=\"p\">:</span> <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">Formatter</span> <span class=\"o\">=</span> <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">Formatter</span><span class=\"p\">(</span>\n        <span class=\"s2\">\"</span><span class=\"si\">%(asctime)s</span><span class=\"s2\"> - </span><span class=\"si\">%(name)s</span><span class=\"s2\"> - </span><span class=\"si\">%(levelname)s</span><span class=\"s2\"> - </span><span class=\"si\">%(message)s</span><span class=\"s2\">\"</span>\n    <span class=\"p\">)</span>\n    <span class=\"n\">handler</span><span class=\"o\">.</span><span class=\"n\">setFormatter</span><span class=\"p\">(</span><span class=\"n\">formatter</span><span class=\"p\">)</span>\n    <span class=\"n\">rclone</span><span class=\"o\">.</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">addHandler</span><span class=\"p\">(</span><span class=\"n\">handler</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># List all folders in backup directory to iterate over them.</span>\n    <span class=\"n\">remote_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s2\">\"drive:PC/Backups\"</span>\n    <span class=\"n\">output</span> <span class=\"o\">=</span> <span class=\"n\">rclone</span><span class=\"o\">.</span><span class=\"n\">lsd</span><span class=\"p\">(</span><span class=\"n\">remote_path</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># If we failed to run, stop.</span>\n    <span class=\"k\">if</span> <span class=\"n\">output</span><span class=\"o\">.</span><span class=\"n\">return_code</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"n\">RcloneError</span><span class=\"o\">.</span><span class=\"n\">SUCCESS</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"o\">.</span><span class=\"n\">error</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span>\n\n    <span class=\"c1\"># lsd (and all other ls commands) will default to using lsjson.</span>\n    <span class=\"c1\"># Lets decode the JSON, and get a list of all our folders.</span>\n    <span class=\"n\">backup_folders</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">folder</span> <span class=\"ow\">in</span> <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">loads</span><span class=\"p\">(</span><span class=\"s2\">\"\"</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">files</span><span class=\"p\">)):</span>\n        <span class=\"n\">backup_folders</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"</span><span class=\"si\">{</span><span class=\"n\">remote_path</span><span class=\"si\">}</span><span class=\"s2\">/</span><span class=\"si\">{</span><span class=\"n\">folder</span><span class=\"p\">[</span><span class=\"s1\">'Path'</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># With our list of folders, lets delete every other folder, excluding these</span>\n    <span class=\"c1\"># useful ones.</span>\n    <span class=\"c1\">#</span>\n    <span class=\"c1\"># This could also be more indepth logic, such as using the modified timestamp</span>\n    <span class=\"c1\"># or the timestamp in the folder name to do logic to different backups of</span>\n    <span class=\"c1\"># varying age. This is allows the ease of scripting in Python to help, versus</span>\n    <span class=\"c1\"># confusing/verbose command line options and shell scripts.</span>\n    <span class=\"n\">ignore_list</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n        <span class=\"s2\">\"drive:PC/Backups/2017-09-18_WindowsUpdate\"</span><span class=\"p\">,</span>\n        <span class=\"s2\">\"drive:PC/Backups/2019-07-30_FlatMove\"</span><span class=\"p\">,</span>\n        <span class=\"s2\">\"drive:PC/Backups/2019-08-12_HDD-Swap\"</span><span class=\"p\">,</span>\n    <span class=\"p\">]</span>\n\n    <span class=\"c1\"># Iterate over every other folder and delete if not in the ignore.</span>\n    <span class=\"c1\">#</span>\n    <span class=\"c1\"># Of course, right now we are in dry_run mode, so this won't do anything</span>\n    <span class=\"c1\"># except list what it would have done.</span>\n    <span class=\"k\">for</span> <span class=\"n\">folder</span> <span class=\"ow\">in</span> <span class=\"n\">backup_folders</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">::</span><span class=\"mi\">2</span><span class=\"p\">]:</span>\n        <span class=\"k\">if</span> <span class=\"n\">folder</span> <span class=\"ow\">in</span> <span class=\"n\">ignore_list</span><span class=\"p\">:</span>\n            <span class=\"k\">continue</span>\n        <span class=\"n\">rclone</span><span class=\"o\">.</span><span class=\"n\">delete</span><span class=\"p\">(</span><span class=\"n\">folder</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n\n          </div>"}, "last_serial": 6892244, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "44e2473aa52524d8bad89c24bcae466f", "sha256": "ae7cdcebdbc7f2b15202203678bff907274cd8b005be315148adf0ae39f1a2f1"}, "downloads": -1, "filename": "pyRclone-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "44e2473aa52524d8bad89c24bcae466f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 16807, "upload_time": "2020-03-26T21:41:22", "upload_time_iso_8601": "2020-03-26T21:41:22.228167Z", "url": "https://files.pythonhosted.org/packages/e3/8d/0b37400ef37c6f5c709bdec7ebe8adfcfe71a036f6dd78961399f0685846/pyRclone-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "63b1f86fad657101c28724c2f4ced88c", "sha256": "8cd627dedf1babddffb8383c76e3f37e35b7ba2264c71db6f60641341539cdb7"}, "downloads": -1, "filename": "pyrclone-1.0.0.tar.gz", "has_sig": false, "md5_digest": "63b1f86fad657101c28724c2f4ced88c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 16003, "upload_time": "2020-03-26T21:41:24", "upload_time_iso_8601": "2020-03-26T21:41:24.186778Z", "url": "https://files.pythonhosted.org/packages/2c/68/9ef5408db9d4aafc391c9cfdb3058fb5c5246dbcd292822ea7ecab4c9433/pyrclone-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "7dc3902601c878fcdd813a7068bd6ff0", "sha256": "edea1230efb424e7d4ded9bbb52d44b6f9611a50f221fbd386533666afa591f4"}, "downloads": -1, "filename": "pyRclone-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "7dc3902601c878fcdd813a7068bd6ff0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 18080, "upload_time": "2020-03-26T22:03:11", "upload_time_iso_8601": "2020-03-26T22:03:11.081186Z", "url": "https://files.pythonhosted.org/packages/09/d1/7c66e2b2962005f5d0bb9ee235677797e58454e758a3b300e77564282127/pyRclone-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b2ac5360f68e7a21200a6deeb64b75ae", "sha256": "d6baaea54d1104dba854c06b9680ce5e395068d78b937a8bb6bf4a07c028b37a"}, "downloads": -1, "filename": "pyrclone-1.0.1.tar.gz", "has_sig": false, "md5_digest": "b2ac5360f68e7a21200a6deeb64b75ae", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 17531, "upload_time": "2020-03-26T22:03:12", "upload_time_iso_8601": "2020-03-26T22:03:12.603158Z", "url": "https://files.pythonhosted.org/packages/80/f9/f50fd8e6b241705382c78a6a5159a900483a9f0b1fca5bbd95162a9f9c1b/pyrclone-1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7dc3902601c878fcdd813a7068bd6ff0", "sha256": "edea1230efb424e7d4ded9bbb52d44b6f9611a50f221fbd386533666afa591f4"}, "downloads": -1, "filename": "pyRclone-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "7dc3902601c878fcdd813a7068bd6ff0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 18080, "upload_time": "2020-03-26T22:03:11", "upload_time_iso_8601": "2020-03-26T22:03:11.081186Z", "url": "https://files.pythonhosted.org/packages/09/d1/7c66e2b2962005f5d0bb9ee235677797e58454e758a3b300e77564282127/pyRclone-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b2ac5360f68e7a21200a6deeb64b75ae", "sha256": "d6baaea54d1104dba854c06b9680ce5e395068d78b937a8bb6bf4a07c028b37a"}, "downloads": -1, "filename": "pyrclone-1.0.1.tar.gz", "has_sig": false, "md5_digest": "b2ac5360f68e7a21200a6deeb64b75ae", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 17531, "upload_time": "2020-03-26T22:03:12", "upload_time_iso_8601": "2020-03-26T22:03:12.603158Z", "url": "https://files.pythonhosted.org/packages/80/f9/f50fd8e6b241705382c78a6a5159a900483a9f0b1fca5bbd95162a9f9c1b/pyrclone-1.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:58:04 2020"}