{"info": {"author": "Ben Hoyt", "author_email": "benhoyt@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Internet :: WWW/HTTP"], "description": "\n=========\ncdnupload\n=========\n\n\nIntroduction\n============\n\ncdnupload uploads your website\u2019s static files to a CDN with a content-based hash in the filenames, giving great caching while avoiding versioning issues. cdnupload is:\n\n* Fast and simple to integrate\n* Helps you follow web best practices: `use a CDN <#why-should-i-use-a-cdn>`_, good Cache-Control headers, versioned filenames\n* Works with web apps written in any language\n* Written in Python (runs on Python 2 and 3)\n\nThe tool helps you follow performance best practices by including a content-based hash in each asset filename.\n\nDeploying is really fast too: only files that have actually changed will be uploaded (with a new hash).\n\ncdnupload is **trivial to install**::\n\n    $ pip install cdnupload\n\nIt's **simple to use**::\n\n    $ cdnupload /website/static s3://static-bucket --key-map=statics.json\n    uploading script.js to script_8f3283c6342816f7.js\n    uploading style.css to style_abcdef0123456789.css\n    writing key map JSON to statics.json\n\nAnd it's **easy to integrate** in most languages, for example Python::\n\n    import json, settings\n\n    def init_server():\n        with open('statics.json') as f:\n            settings.statics = json.load(f)\n\n    def static_url(path):\n        return '//mycdn.com/' + settings.statics[path]\n\n\nInstallation\n============\n\ncdnupload is a Python package which runs under Python 3.4+ as well as Python 2.7. To install it `from PyPI <https://pypi.python.org/pypi/cdnupload>`_ as a command-line script and in the global Python environment, simply type::\n\n    pip install cdnupload\n\nIf you are using a specific version of Python or want to install it in a virtual Python environment, activate the virtual environment first, then run the ``pip install``.\n\nAdditionally, if you\u2019ll be using Amazon S3 as a destination, you\u2019ll need to install the boto3 package to interact with Amazon AWS. To install boto3, type the following (in your virtual environment if you\u2019re using one)::\n\n    pip install boto3\n\nAfter cdnupload is installed, you can run the command-line script simply by typing ``cdnupload``. Or, if you need to run it against a specific Python interpreter, run the script as a module with ``python -m``, like so::\n\n    /path/to/my/python -m cdnupload\n\n\nOverview\n========\n\ncdnupload is primarily a **command-line tool** that uploads your site\u2019s static files to a CDN (well, really the CDN\u2019s origin server). It optionally generates a JSON \u201ckey mapping\u201d that maps file paths to destination keys. A destination key is a file path with a hash in it based on the file\u2019s contents. This allows you to set up the CDN to cache your static files aggressively, with an essentially infinite expiry time (max age).\n\n(For a brief introduction to what a CDN is and why you might want to use one, `see the CDN section of this document. <#why-should-i-use-a-cdn>`_)\n\nWhen you upload statics, you specify a source directory and a destination directory (or Amazon S3 URL or other origin pseudo-URL). For example, you can upload all the static files from the ``/website/static`` directory to ``static-bucket``, and output the key mapping to the file ``statics.json`` using the following command::\n\n    cdnupload /website/static s3://static-bucket --key-map=statics.json\n\nThe uploader will walk the source directory tree, query the destination S3 bucket (or directory), and upload any files that are missing. For example, if you have one JavaScript file and two CSS files, the output of the tool might look something like this::\n\n    uploading script.js to script_0beec7b5ea3f0fdb.js\n    uploading style.css to style_62cdb7020ff920e5.css\n    uploading mobile.css to mobile_bbe960a25ea311d2.css\n    writing key map JSON to statics.json\n\nIf you modify mobile.css and then run it again, you\u2019ll see that it only uploads the changed files::\n\n    uploading mobile.css to mobile_6b369e490de120a9.css\n    writing key map JSON to statics.json\n\nIt doesn\u2019t delete unused files on the destination directory automatically (as the currently-deployed website is probably still using them). To do that, you need to use the delete action::\n\n    cdnupload /website/static s3://static-bucket --action=delete\n\nHere\u2019s what the output might be after the above uploads::\n\n    deleting mobile_bbe960a25ea311d2.css\n\nThere are many `command-line options <#command-line-usage>`_ to control what files to upload, change the destination parameters, etc. And you can use the `Python API`_ directly if you need advanced features or if you need to add another destination \u201cprovider\u201d.\n\nYou\u2019ll also need to **integrate with your web server** so that your web application knows the hash mapping and can output the correct static URLs. That can be as simple as a ``static_url`` template function that uses the key map JSON to convert from a file path to the destination key. See details in the `web server integration section below. <#web-server-integration>`_\n\n\nWhy should I use a CDN?\n=======================\n\n*If you\u2019re not sure what a CDN is, or if you\u2019re wondering why you should use one, this section is for you.*\n\n.. image:: https://raw.githubusercontent.com/benhoyt/cdnupload/master/images/cdn.png\n    :alt: From Wikimedia under Creative Commons (NCDN_-_CDN.png)\n    :align: center\n\nCDN stands for Content Delivery Network, which is a service that serves your static files -- heavily cached, on servers around the world that are close to your users.\n\nSo if someone from New Jersey requests ``https://mycdn.com/style.css``, the CDN will almost certainly have a cached version in an East Coast or even a local New Jersey data center, and will serve that up to the user faster than you can say \u201cHTTP/2\u201d.\n\nIf the CDN doesn\u2019t have a cached version of the file, it will in turn request it from the origin server (where the files are hosted). If you\u2019re using something like Amazon S3 as your origin server, that request will be quick too, and the user will still get the file in good time. From then on, the CDN will serve the cached version.\n\nBecause the files are heavily cached (ideally with long expiry times), you need to include version numbers in the filenames. cdnupload does this by appending to the filename a 16-character hash based on the file\u2019s contents. For example, ``style.css`` might become ``style_abcdef0123456789.css``, and then ``style_a0b1c2d3e4f56789.css`` in the next revision.\n\nOn one `website <https://giftyweddings.com/>`_ we run, we saw our **static file load time drop from 1500ms to 220ms** when we starting using cdnupload with the Amazon Cloudfront CDN.\n\nSo you should use a CDN if your site gets a good amount of traffic, and you need good performance from various locations around the world. You probably *don\u2019t* need to use a CDN if you have a small personal site.\n\nUsing the `Amazon CloudFront <https://aws.amazon.com/cloudfront/>`_ CDN together with `Amazon S3 <https://aws.amazon.com/s3/>`_ as an origin server is a great place to start -- like other AWS products, you only pay for the bytes you use, and there\u2019s no monthly fee.\n\n\nCommand-line usage\n==================\n\nThe format of the cdnupload command line is::\n\n    cdnupload [options] source destination [dest_args]\n\nWhere ``options`` are short or long command line options (``-s`` or ``--long``). You can mix these freely with the positional arguments if you want.\n\nSource\n------\n\n``source`` is the source directory of your static files, for example ``/website/static``. Use the optional ``--include`` and ``--exclude`` arguments, and other arguments described below, to control exactly which files are uploaded.\n\nDestination and dest-args\n-------------------------\n\n``destination`` is the destination directory to upload to, or an ``s3://static-bucket/prefix`` path for uploading to Amazon S3.\n\nYou can also specify a custom scheme for the destination (the ``scheme://`` part of the URL), and cdnupload will try to import a module named ``cdnupload_scheme`` (which must be on the PYTHONPATH) and use that module\u2019s ``Destination`` class along with the ``dest_args`` to create the destination instance.\n\nFor example, if you create your own uploader for Google Cloud Storage, you might use the prefix ``gcs://`` and name your module ``cdnupload_gcs``. Then you could use ``gcs://my/path`` as a destination, and cdnupload would instantiate the destination instance using ``cdnupload_gcs.Destination('gcs://bucket', **dest_args)``.\n\nSee the `custom destination`_ section for more details about custom ``Destination`` subclasses.\n\n``dest_args`` are destination-specific arguments passed as keyword arguments to the ``Destination`` class (for example, for ``s3://`` destinations, useful dest args might be ``max-age=86400`` or ``region-name=us-west-2``). Note that hyphens in dest args are converted to underscores, so ``region-name=us-west-2`` becomes ``region_name='us-west-2'``.\n\nFor help on destination-specific args, use the ``dest-help`` action. For example, to show S3-specific destination args::\n\n    cdnupload source s3:// --action=dest-help\n\nCommon arguments\n----------------\n\n  -h, --help\n        Show help about these command-line options and exit.\n\n  -a ACTION, --action ACTION\n        Specify action to perform (the default is to upload):\n\n        * ``upload``: Upload files from the source to the destination (but only if they\u2019re not already on the destination).\n        * ``delete``: Delete unused files at the destination (files no longer present at the source). Be careful with deleting, and use ``--dry-run`` to test first!\n        * ``dest-help``: Show help and available destination arguments for the given Destination class.\n\n  -d, --dry-run\n        Show what the script would upload or delete instead of actually doing it. This option is recommended before running with ``--action=delete``, to ensure you\u2019re not deleting more than you expect.\n\n  -e PATTERN, --exclude PATTERN\n        Exclude source files if their relative path matches the given pattern (according to globbing rules as per Python\u2019s ``fnmatch``). For example, ``*.txt`` to exclude all text files, or ``__pycache__/*`` to exclude everything under the *pycache* directory. This option may be specified multiple times to exclude more than one pattern.\n\n        Excludes take precedence over includes, so you can do ``--include=*.txt`` but then exclude a specific text file with ``--exclude=docs/README.txt``.\n\n  -f, --force\n        If uploading, force all files to be uploaded even if destination files already exist (useful, for example, when updating headers on Amazon S3).\n\n        If deleting, allow the delete to occur even if all files on the destination would be deleted (the default is to prevent that to avoid ``rm -rf`` style mistakes).\n\n  -i PATTERN, --include PATTERN\n        If specified, only include source files if their relative path matches the given pattern (according to globbing rules as per Python\u2019s ``fnmatch``). For example, ``*.png`` to include all PNG images, or ``images/*`` to include everything under the *images* directory. This option may be specified multiple times to include more than one pattern.\n\n        Excludes take precedence over includes, so you can do ``--include=*.txt`` but then exclude a specific text file with ``--exclude=docs/README.txt``.\n\n  -k FILENAME, --key-map FILENAME\n        Write key mapping to given file as JSON (but only after successful upload or delete). This file can be used by your web server to produce full CDN URLs for your static files.\n\n        Keys in the JSON object are the original paths (relative to the source root), and values in the object are the destination paths (relative to the destination root). For example, the JSON might look like ``{\"script.js\": \"script_0beec7b5ea3f0fdb.js\", ...}``.\n\n  -l LEVEL, --log-level LEVEL\n        Set the verbosity of the log output. The level must be one of:\n\n        * ``debug``: Most detailed output. Log even files that the script would skip uploading.\n        * ``verbose``: Verbose output. Log when the script starts, finishes, and when uploads and deletes occur (or would occur if doing a ``--dry-run``).\n        * ``default``: Default level of log output. Only log when and if the script actually uploads or deletes files (no start or finish logs). If there\u2019s nothing to do, don\u2019t log anything.\n        * ``error``: Only log errors.\n        * ``off``: Turn all logging off completely.\n\n  -v, --version\n        Show cdnupload\u2019s version number and exit.\n\nLess common arguments\n---------------------\n\n  --continue-on-errors\n        Continue after upload or delete errors. The script will still log the errors, and it will also return a nonzero exit code if there is at least one error. The default is to stop on the first error.\n  --dot-names\n        Include source files and directories that start with ``.`` (dot). The default is to skip any files or directories that start with a dot.\n  --follow-symlinks\n        Follow symbolic links to directories when walking the source tree. The default is to skip any symbolic links to directories.\n  --hash-length N\n        Set the number of hexadecimal characters of the content hash to use for destination key. The default is 16.\n  --ignore-walk-errors\n        Ignore errors when walking the source tree (for example, permissions errors on a directory), except for an error when listing the source root directory.\n\n\nWeb server integration\n======================\n\nIn addition to using the command line script to upload files, you\u2019ll need to modify your web server so it knows how to generate the static URLs including the content-based hash in the filename.\n\nThe recommended way to do this is to use the key mapping JSON, which is written out by the ``--key-map`` command line argument when you upload your statics. You can load this into a key-value dictionary when your server starts up, and then generate a static URL simply by looking up the relative path of a static file in this dictionary.\n\nEven though the keys in the JSON are relative file paths, they\u2019re normalized to always use ``/`` (forward slash) as the directory separator, even on Windows. This is so consumers of the mapping can look up files directly in the mapping with a consistent path separator.\n\nBelow is a simple example of loading the key mapping in your web server startup (call ``init_server()`` on startup) and then defining a function to generate full static URLs for use in your HTML templates. This example is written in Python, but you can use any language that can parse JSON and look something up in a map::\n\n    import json\n    import settings\n\n    def init_server():\n        settings.cdn_base_url = 'https://mycdn.com/'\n        with open('statics.json') as f:\n            settings.statics = json.load(f)\n\n    def static_url(rel_path):\n        \"\"\"Convert relative static path to full static URL (including hash)\"\"\"\n        return settings.cdn_base_url + settings.statics[rel_path]\n\nAnd then in your HTML templates, just reference a static file using the ``static_url`` function (referenced here as a Jinja2 template filter)::\n\n    <link rel=\"stylesheet\" href=\"{{ 'style.css'|static_url }}\">\n\nIf your web server is in fact written in Python, you can also ``import cdnupload`` directly and use ``cdnupload.FileSource`` with the same parameters as the upload command line. This will build the key mapping at server startup time, and may simplify the deployment process a little::\n\n    import cdnupload\n    import settings\n\n    def init_server():\n        settings.cdn_base_url = 'https://mycdn.com/'\n        source = cdnupload.FileSource(settings.static_dir)\n        settings.static_paths = source.build_key_map()\n\nIf you have huge numbers of static files, this is not recommended, as it does have to re-hash all the files when the server starts up. So for larger sites it\u2019s best to produce the key map JSON and copy that to your app servers as part of your deployment process.\n\n\nStatic URLs in CSS\n==================\n\nIf you reference static files in your CSS (for example, background images with ``url(...)`` expressions), you\u2019ll need to either remove them from your CSS and generate them in an inline ``<style>`` section at the top of your HTML, or use a post-processor script on your CSS to change the URLs from relative to full hashed URLs.\n\nFor small sites, it may be simpler to just extract them from your CSS. For example, for a CSS rule like this::\n\n    body.home {\n        font-family: Verdana;\n        font-size: 10px;\n        background-image: url(/static/images/hero.jpg);\n    }\n\nYou would remove just the ``background-image`` line and put it in an inline style block in the ``<head>`` section of relevant pages, like this::\n\n    <head>\n        <!-- other head elements; link to the stylesheet above -->\n        <style type=\"text/css\">\n            body.home {\n                background-image: url({{ 'images/hero.jpg'|static_url }});\n            }\n        </style>\n    </head>\n\nHowever, for larger-scale sites where the CSS references a lot of static images, this quickly becomes hard to manage. In that case, you\u2019ll want to use a tool like `PostCSS <http://postcss.org/>`_ to rewrite static URLs in your CSS to cdnupload URLs via the key mapping. There\u2019s a PostCSS plugin called `postcss-url <https://github.com/postcss/postcss-url>`_ that you can use to rewrite URLs with a custom transform function.\n\nThe CSS rewriting should be integrated into your build or deployment process, as the PostCSS rule will need access to the JSON key mapping that the uploader wrote out.\n\n\nPython API\n==========\n\ncdnupload is a Python command-line script, but it\u2019s also a Python module you can import and extend if you need to customize it or hook into advanced features. It works on both Python 3.4+ and Python 2.7.\n\nCustom destination\n------------------\n\nThe most likely reason you\u2019ll need to extend cdnupload is to write a custom ``Destination`` subclass (if the built-in file or Amazon S3 destinations don\u2019t work for you).\n\nFor example, if you\u2019re using a CDN that connects to an origin server called \u201cMy Origin\u201d, you might write a custom subclass for uploading to your origin. You\u2019ll need to subclass ``cdnupload.Destination`` and implement an initalizer as well as the ``__str__``, ``walk_keys``, ``upload``, and ``delete`` methods::\n\n    import cdnupload\n    import myorigin\n\n    class Destination(cdnupload.Destination):\n        def __init__(self, url, foo='FOO', bar=None):\n            \"\"\"Initialize destination instance with given \"My Origin\" URL\n            (which should be in form my://server/path).\n            \"\"\"\n            self.url = url\n            self.conn = myorigin.Connection(url, foo=foo, bar=bar)\n\n        def __str__(self):\n            \"\"\"Return a human-readable string for this destination.\"\"\"\n            return self.url\n\n        def walk_keys(self):\n            \"\"\"Yield keys (files) that are currently on the destination.\"\"\"\n            for file in self.conn.get_files():\n                yield file.name\n\n        def upload(self, key, source, rel_path):\n            \"\"\"Upload a single file from source at rel_path to destination\n            at given key. Normally this function will use the with statement\n            \"with source.open(rel_path)\" to open the source file object.\n            \"\"\"\n            with source.open(rel_path) as source_file:\n                self.conn.upload_file_obj(source_file, key)\n\n        def delete(self, key):\n            \"\"\"Delete a single file on destination at given key.\"\"\"\n            self.conn.delete_file(key)\n\nTo use this custom destination, save your custom code to ``cdnupload_my.py`` and ensure the file is somewhere on your PYTHONPATH. Then if you run the cdnupload command-line tool with a destination starting with scheme ``my://``, it will automatically import ``cdnupload_my`` and look for a class called ``Destination``, passing the ``my://server/path`` URL and any additional destination arguments to your initializer.\n\nNote that when the command-line tool passes additional dest_args to a custom destination, it always passes them as strings (or a list of strings if a dest arg is specified more than once). So if you need an integer or other type, you\u2019ll need to convert it in your ``__init__`` method.\n\nUpload and delete\n-----------------\n\nThe top-level functions ``upload()`` and ``delete()`` drive cdnupload. You can create your own command-line entry point if you want to hook into cdnupload\u2019s Python API. For example, you could make a ``myupload.py`` script as follows::\n\n    import cdnupload\n    import hashlib\n\n    source = cdnupload.FileSource('/path/to/my/statics',\n                                  hash_class=hashlib.md5)\n    destination = cdnupload.S3Destination('s3://bucket/path')\n    cdnupload.upload(source, destination)\n\nHere we\u2019re doing some light customization of ``FileSource``\u2019s hashing behaviour (changing it from SHA-1 to MD5) and then performing an upload.\n\nThe ``upload()`` function uploads files from a source to a destination, but only if they\u2019re missing at the destination (according to ``destination.walk_keys``).\n\nThe ``delete()`` function deletes files from the destination if they\u2019re no longer present at the source (according to ``source.build_key_map``).\n\nBoth ``upload`` and ``delete`` take the same set of arguments:\n\n* ``source``: the source object; either a ``FileSource`` instance (or object that implements the same interface), or a string in which case it gets converted to a source via ``FileSource(source)``\n* ``destination``: the destination object; either an instance of a concrete ``Destination`` subclass, or a string in which case it gets converted to a destination via ``FileDestination(destination)``\n* ``force=False``: if True, same as specifying the ``--force`` command line option\n* ``dry_run=False``: if True, same as specifying the ``--dry-run`` command line option\n* ``continue_on_errors=False``: if True, same as specifying the ``--continue-on-errors`` command line option\n\nBoth functions return a ``Result`` namedtuple, which has the following attributes:\n\n* ``source_key_map``: the source path to destination key mapping, the same dict returned by ``source.build_key_map()``\n* ``destination_keys``: a set containing the destination keys, as returned by ``destination.walk_keys()``\n* ``num_scanned``: total number of files scanned (source files when uploading, or destination keys when deleting)\n* ``num_processed``: number of files processed (actually uploaded or deleted)\n* ``num_errors``: number of errors (useful when ``continue_on_errors`` is true)\n\nCustom source\n-------------\n\nYou can also customize the source of the files. There\u2019s currently only one source class, ``FileSource``, which reads files from the filesystem and produces file hashes. You can pass options to the ``FileSource`` initializer to control which files it includes or excludes, as well as how it hashes their contents to produce the content-based hash.\n\nThe ``dot_names``, ``include``, ``exclude``, ``ignore_walk_errors``, ``follow_symlinks``, and ``hash_length`` arguments correspond directly to the ``--dot-names``, ``--include``, ``--exclude``, ``--ignore-walk-errors``, ``--follow-symlinks``, and ``--hash-length`` command line options.\n\nAdditionally, you can customize ``FileSource`` further with the ``hash_chunk_size`` and ``hash_class`` arguments. The file is read in ``hash_chunk_size``-byte blocks when being hashed, and ``hash_class`` is instantiated to generate the hashes (must have a hashlib-style signature).\n\nOr you can subclass ``FileSource`` if you want to customize advanced behaviour. For example, you could override ``FileSource.hash_file()``\u2019s handling of text and binary files to treat all files as binary::\n\n    from cdnupload import FileSource\n\n    class BinarySource(FileSource):\n        def hash_file(self, rel_path):\n            return FileSource.hash_file(self, rel_path, is_text=False)\n\nTo use a subclassed ``FileSource``, you\u2019ll need to call the ``upload()`` and ``delete()`` functions with your instance directly from Python. It\u2019s not currently possibly to use a subclassed source via the cdnupload command line script.\n\nLogging\n-------\n\ncdnupload functions use standard Python logging to log all operations. The name of the logger is ``cdnupload``, and you can control log output format and verbosity (log level) using the Python logging functions.\n\nFor example, to log all errors but turn debug-level logging on only for cdnupload logs, you could do this::\n\n    import logging\n\n    logging.basicConfig(level=logging.ERROR)\n    logging.getLogger('cdnupload').setLevel(logging.DEBUG)\n\n\nContributing\n============\n\nIf you find a bug in cdnupload, please open an issue with the following information:\n\n* Full error messages or tracebacks\n* The cdnupload version, Python version, and operating system type and version\n* Steps or a test case that reproduces the issue (ideally)\n\nIf you have a feature request, documentation fix, or other suggestion, open an issue and we\u2019ll discuss!\n\nSee also `CONTRIBUTING.md <https://github.com/benhoyt/cdnupload/blob/master/CONTRIBUTING.md>`_ in the cdnupload source tree.\n\n\nLicense\n=======\n\ncdnupload is licensed under a permissive MIT license: see `LICENSE.txt <https://github.com/benhoyt/cdnupload/blob/master/LICENSE.txt>`_ for details.\n\nNote that prior to August 2017 it was licensed under an AGPL plus commercial license combination, but now it's completely free.\n\n\nAbout the author\n================\n\ncdnupload is written and maintained by Ben Hoyt: a `software developer <http://benhoyt.com/cv/>`_, `Python contributor <http://benhoyt.com/writings/scandir/>`_, and general all-round software geek. For more info, see his personal website at `benhoyt.com <http://benhoyt.com/>`_.\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/benhoyt/cdnupload", "keywords": "", "license": "MIT License", "maintainer": "", "maintainer_email": "", "name": "cdnupload", "package_url": "https://pypi.org/project/cdnupload/", "platform": "", "project_url": "https://pypi.org/project/cdnupload/", "project_urls": {"Homepage": "https://github.com/benhoyt/cdnupload"}, "release_url": "https://pypi.org/project/cdnupload/1.0.4/", "requires_dist": null, "requires_python": "", "summary": "Upload static files from given source directory to destination directory or Amazon S3 bucket, with content-based hash in filenames for versioning.", "version": "1.0.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>cdnupload uploads your website\u2019s static files to a CDN with a content-based hash in the filenames, giving great caching while avoiding versioning issues. cdnupload is:</p>\n<ul>\n<li>Fast and simple to integrate</li>\n<li>Helps you follow web best practices: <a href=\"#why-should-i-use-a-cdn\" rel=\"nofollow\">use a CDN</a>, good Cache-Control headers, versioned filenames</li>\n<li>Works with web apps written in any language</li>\n<li>Written in Python (runs on Python 2 and 3)</li>\n</ul>\n<p>The tool helps you follow performance best practices by including a content-based hash in each asset filename.</p>\n<p>Deploying is really fast too: only files that have actually changed will be uploaded (with a new hash).</p>\n<p>cdnupload is <strong>trivial to install</strong>:</p>\n<pre>$ pip install cdnupload\n</pre>\n<p>It\u2019s <strong>simple to use</strong>:</p>\n<pre>$ cdnupload /website/static s3://static-bucket --key-map=statics.json\nuploading script.js to script_8f3283c6342816f7.js\nuploading style.css to style_abcdef0123456789.css\nwriting key map JSON to statics.json\n</pre>\n<p>And it\u2019s <strong>easy to integrate</strong> in most languages, for example Python:</p>\n<pre>import json, settings\n\ndef init_server():\n    with open('statics.json') as f:\n        settings.statics = json.load(f)\n\ndef static_url(path):\n    return '//mycdn.com/' + settings.statics[path]\n</pre>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>cdnupload is a Python package which runs under Python 3.4+ as well as Python 2.7. To install it <a href=\"https://pypi.python.org/pypi/cdnupload\" rel=\"nofollow\">from PyPI</a> as a command-line script and in the global Python environment, simply type:</p>\n<pre>pip install cdnupload\n</pre>\n<p>If you are using a specific version of Python or want to install it in a virtual Python environment, activate the virtual environment first, then run the <tt>pip install</tt>.</p>\n<p>Additionally, if you\u2019ll be using Amazon S3 as a destination, you\u2019ll need to install the boto3 package to interact with Amazon AWS. To install boto3, type the following (in your virtual environment if you\u2019re using one):</p>\n<pre>pip install boto3\n</pre>\n<p>After cdnupload is installed, you can run the command-line script simply by typing <tt>cdnupload</tt>. Or, if you need to run it against a specific Python interpreter, run the script as a module with <tt>python <span class=\"pre\">-m</span></tt>, like so:</p>\n<pre>/path/to/my/python -m cdnupload\n</pre>\n</div>\n<div id=\"overview\">\n<h2>Overview</h2>\n<p>cdnupload is primarily a <strong>command-line tool</strong> that uploads your site\u2019s static files to a CDN (well, really the CDN\u2019s origin server). It optionally generates a JSON \u201ckey mapping\u201d that maps file paths to destination keys. A destination key is a file path with a hash in it based on the file\u2019s contents. This allows you to set up the CDN to cache your static files aggressively, with an essentially infinite expiry time (max age).</p>\n<p>(For a brief introduction to what a CDN is and why you might want to use one, <a href=\"#why-should-i-use-a-cdn\" rel=\"nofollow\">see the CDN section of this document.</a>)</p>\n<p>When you upload statics, you specify a source directory and a destination directory (or Amazon S3 URL or other origin pseudo-URL). For example, you can upload all the static files from the <tt>/website/static</tt> directory to <tt><span class=\"pre\">static-bucket</span></tt>, and output the key mapping to the file <tt>statics.json</tt> using the following command:</p>\n<pre>cdnupload /website/static s3://static-bucket --key-map=statics.json\n</pre>\n<p>The uploader will walk the source directory tree, query the destination S3 bucket (or directory), and upload any files that are missing. For example, if you have one JavaScript file and two CSS files, the output of the tool might look something like this:</p>\n<pre>uploading script.js to script_0beec7b5ea3f0fdb.js\nuploading style.css to style_62cdb7020ff920e5.css\nuploading mobile.css to mobile_bbe960a25ea311d2.css\nwriting key map JSON to statics.json\n</pre>\n<p>If you modify mobile.css and then run it again, you\u2019ll see that it only uploads the changed files:</p>\n<pre>uploading mobile.css to mobile_6b369e490de120a9.css\nwriting key map JSON to statics.json\n</pre>\n<p>It doesn\u2019t delete unused files on the destination directory automatically (as the currently-deployed website is probably still using them). To do that, you need to use the delete action:</p>\n<pre>cdnupload /website/static s3://static-bucket --action=delete\n</pre>\n<p>Here\u2019s what the output might be after the above uploads:</p>\n<pre>deleting mobile_bbe960a25ea311d2.css\n</pre>\n<p>There are many <a href=\"#command-line-usage\" rel=\"nofollow\">command-line options</a> to control what files to upload, change the destination parameters, etc. And you can use the <a href=\"#python-api\" rel=\"nofollow\">Python API</a> directly if you need advanced features or if you need to add another destination \u201cprovider\u201d.</p>\n<p>You\u2019ll also need to <strong>integrate with your web server</strong> so that your web application knows the hash mapping and can output the correct static URLs. That can be as simple as a <tt>static_url</tt> template function that uses the key map JSON to convert from a file path to the destination key. See details in the <a href=\"#web-server-integration\" rel=\"nofollow\">web server integration section below.</a></p>\n</div>\n<div id=\"why-should-i-use-a-cdn\">\n<h2>Why should I use a CDN?</h2>\n<p><em>If you\u2019re not sure what a CDN is, or if you\u2019re wondering why you should use one, this section is for you.</em></p>\n<img alt=\"From Wikimedia under Creative Commons (NCDN_-_CDN.png)\" class=\"align-center\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0b7c7543053088fe20787d481da39b75e11f18b4/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f62656e686f79742f63646e75706c6f61642f6d61737465722f696d616765732f63646e2e706e67\">\n<p>CDN stands for Content Delivery Network, which is a service that serves your static files \u2013 heavily cached, on servers around the world that are close to your users.</p>\n<p>So if someone from New Jersey requests <tt><span class=\"pre\">https://mycdn.com/style.css</span></tt>, the CDN will almost certainly have a cached version in an East Coast or even a local New Jersey data center, and will serve that up to the user faster than you can say \u201cHTTP/2\u201d.</p>\n<p>If the CDN doesn\u2019t have a cached version of the file, it will in turn request it from the origin server (where the files are hosted). If you\u2019re using something like Amazon S3 as your origin server, that request will be quick too, and the user will still get the file in good time. From then on, the CDN will serve the cached version.</p>\n<p>Because the files are heavily cached (ideally with long expiry times), you need to include version numbers in the filenames. cdnupload does this by appending to the filename a 16-character hash based on the file\u2019s contents. For example, <tt>style.css</tt> might become <tt>style_abcdef0123456789.css</tt>, and then <tt>style_a0b1c2d3e4f56789.css</tt> in the next revision.</p>\n<p>On one <a href=\"https://giftyweddings.com/\" rel=\"nofollow\">website</a> we run, we saw our <strong>static file load time drop from 1500ms to 220ms</strong> when we starting using cdnupload with the Amazon Cloudfront CDN.</p>\n<p>So you should use a CDN if your site gets a good amount of traffic, and you need good performance from various locations around the world. You probably <em>don\u2019t</em> need to use a CDN if you have a small personal site.</p>\n<p>Using the <a href=\"https://aws.amazon.com/cloudfront/\" rel=\"nofollow\">Amazon CloudFront</a> CDN together with <a href=\"https://aws.amazon.com/s3/\" rel=\"nofollow\">Amazon S3</a> as an origin server is a great place to start \u2013 like other AWS products, you only pay for the bytes you use, and there\u2019s no monthly fee.</p>\n</div>\n<div id=\"command-line-usage\">\n<h2>Command-line usage</h2>\n<p>The format of the cdnupload command line is:</p>\n<pre>cdnupload [options] source destination [dest_args]\n</pre>\n<p>Where <tt>options</tt> are short or long command line options (<tt><span class=\"pre\">-s</span></tt> or <tt><span class=\"pre\">--long</span></tt>). You can mix these freely with the positional arguments if you want.</p>\n<div id=\"source\">\n<h3>Source</h3>\n<p><tt>source</tt> is the source directory of your static files, for example <tt>/website/static</tt>. Use the optional <tt><span class=\"pre\">--include</span></tt> and <tt><span class=\"pre\">--exclude</span></tt> arguments, and other arguments described below, to control exactly which files are uploaded.</p>\n</div>\n<div id=\"destination-and-dest-args\">\n<h3>Destination and dest-args</h3>\n<p><tt>destination</tt> is the destination directory to upload to, or an <tt><span class=\"pre\">s3://static-bucket/prefix</span></tt> path for uploading to Amazon S3.</p>\n<p>You can also specify a custom scheme for the destination (the <tt><span class=\"pre\">scheme://</span></tt> part of the URL), and cdnupload will try to import a module named <tt>cdnupload_scheme</tt> (which must be on the PYTHONPATH) and use that module\u2019s <tt>Destination</tt> class along with the <tt>dest_args</tt> to create the destination instance.</p>\n<p>For example, if you create your own uploader for Google Cloud Storage, you might use the prefix <tt><span class=\"pre\">gcs://</span></tt> and name your module <tt>cdnupload_gcs</tt>. Then you could use <tt><span class=\"pre\">gcs://my/path</span></tt> as a destination, and cdnupload would instantiate the destination instance using <tt><span class=\"pre\">cdnupload_gcs.Destination('gcs://bucket',</span> **dest_args)</tt>.</p>\n<p>See the <a href=\"#custom-destination\" rel=\"nofollow\">custom destination</a> section for more details about custom <tt>Destination</tt> subclasses.</p>\n<p><tt>dest_args</tt> are destination-specific arguments passed as keyword arguments to the <tt>Destination</tt> class (for example, for <tt><span class=\"pre\">s3://</span></tt> destinations, useful dest args might be <tt><span class=\"pre\">max-age=86400</span></tt> or <tt><span class=\"pre\">region-name=us-west-2</span></tt>). Note that hyphens in dest args are converted to underscores, so <tt><span class=\"pre\">region-name=us-west-2</span></tt> becomes <tt><span class=\"pre\">region_name='us-west-2'</span></tt>.</p>\n<p>For help on destination-specific args, use the <tt><span class=\"pre\">dest-help</span></tt> action. For example, to show S3-specific destination args:</p>\n<pre>cdnupload source s3:// --action=dest-help\n</pre>\n</div>\n<div id=\"common-arguments\">\n<h3>Common arguments</h3>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><td>\n<kbd><span class=\"option\">-h</span>, <span class=\"option\">--help</span></kbd></td>\n<td>Show help about these command-line options and exit.</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-a <var>ACTION</var></span>, <span class=\"option\">--action <var>ACTION</var></span></kbd></td>\n</tr>\n<tr><td>\u00a0</td><td><p>Specify action to perform (the default is to upload):</p>\n<ul>\n<li><tt>upload</tt>: Upload files from the source to the destination (but only if they\u2019re not already on the destination).</li>\n<li><tt>delete</tt>: Delete unused files at the destination (files no longer present at the source). Be careful with deleting, and use <tt><span class=\"pre\">--dry-run</span></tt> to test first!</li>\n<li><tt><span class=\"pre\">dest-help</span></tt>: Show help and available destination arguments for the given Destination class.</li>\n</ul>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-d</span>, <span class=\"option\">--dry-run</span></kbd></td>\n<td>Show what the script would upload or delete instead of actually doing it. This option is recommended before running with <tt><span class=\"pre\">--action=delete</span></tt>, to ensure you\u2019re not deleting more than you expect.</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-e <var>PATTERN</var></span>, <span class=\"option\">--exclude <var>PATTERN</var></span></kbd></td>\n</tr>\n<tr><td>\u00a0</td><td><p>Exclude source files if their relative path matches the given pattern (according to globbing rules as per Python\u2019s <tt>fnmatch</tt>). For example, <tt>*.txt</tt> to exclude all text files, or <tt>__pycache__/*</tt> to exclude everything under the <em>pycache</em> directory. This option may be specified multiple times to exclude more than one pattern.</p>\n<p>Excludes take precedence over includes, so you can do <tt><span class=\"pre\">--include=*.txt</span></tt> but then exclude a specific text file with <tt><span class=\"pre\">--exclude=docs/README.txt</span></tt>.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-f</span>, <span class=\"option\">--force</span></kbd></td>\n<td><p>If uploading, force all files to be uploaded even if destination files already exist (useful, for example, when updating headers on Amazon S3).</p>\n<p>If deleting, allow the delete to occur even if all files on the destination would be deleted (the default is to prevent that to avoid <tt>rm <span class=\"pre\">-rf</span></tt> style mistakes).</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-i <var>PATTERN</var></span>, <span class=\"option\">--include <var>PATTERN</var></span></kbd></td>\n</tr>\n<tr><td>\u00a0</td><td><p>If specified, only include source files if their relative path matches the given pattern (according to globbing rules as per Python\u2019s <tt>fnmatch</tt>). For example, <tt>*.png</tt> to include all PNG images, or <tt>images/*</tt> to include everything under the <em>images</em> directory. This option may be specified multiple times to include more than one pattern.</p>\n<p>Excludes take precedence over includes, so you can do <tt><span class=\"pre\">--include=*.txt</span></tt> but then exclude a specific text file with <tt><span class=\"pre\">--exclude=docs/README.txt</span></tt>.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-k <var>FILENAME</var></span>, <span class=\"option\">--key-map <var>FILENAME</var></span></kbd></td>\n</tr>\n<tr><td>\u00a0</td><td><p>Write key mapping to given file as JSON (but only after successful upload or delete). This file can be used by your web server to produce full CDN URLs for your static files.</p>\n<p>Keys in the JSON object are the original paths (relative to the source root), and values in the object are the destination paths (relative to the destination root). For example, the JSON might look like <tt>{\"script.js\": \"script_0beec7b5ea3f0fdb.js\", <span class=\"pre\">...}</span></tt>.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-l <var>LEVEL</var></span>, <span class=\"option\">--log-level <var>LEVEL</var></span></kbd></td>\n</tr>\n<tr><td>\u00a0</td><td><p>Set the verbosity of the log output. The level must be one of:</p>\n<ul>\n<li><tt>debug</tt>: Most detailed output. Log even files that the script would skip uploading.</li>\n<li><tt>verbose</tt>: Verbose output. Log when the script starts, finishes, and when uploads and deletes occur (or would occur if doing a <tt><span class=\"pre\">--dry-run</span></tt>).</li>\n<li><tt>default</tt>: Default level of log output. Only log when and if the script actually uploads or deletes files (no start or finish logs). If there\u2019s nothing to do, don\u2019t log anything.</li>\n<li><tt>error</tt>: Only log errors.</li>\n<li><tt>off</tt>: Turn all logging off completely.</li>\n</ul>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-v</span>, <span class=\"option\">--version</span></kbd></td>\n<td>Show cdnupload\u2019s version number and exit.</td></tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n<div id=\"less-common-arguments\">\n<h3>Less common arguments</h3>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><td>\n<kbd><span class=\"option\">--continue-on-errors</span></kbd></td>\n</tr>\n<tr><td>\u00a0</td><td>Continue after upload or delete errors. The script will still log the errors, and it will also return a nonzero exit code if there is at least one error. The default is to stop on the first error.</td></tr>\n<tr><td>\n<kbd><span class=\"option\">--dot-names</span></kbd></td>\n<td>Include source files and directories that start with <tt>.</tt> (dot). The default is to skip any files or directories that start with a dot.</td></tr>\n<tr><td>\n<kbd><span class=\"option\">--follow-symlinks</span></kbd></td>\n</tr>\n<tr><td>\u00a0</td><td>Follow symbolic links to directories when walking the source tree. The default is to skip any symbolic links to directories.</td></tr>\n<tr><td>\n<kbd><span class=\"option\">--hash-length <var>N</var></span></kbd></td>\n</tr>\n<tr><td>\u00a0</td><td>Set the number of hexadecimal characters of the content hash to use for destination key. The default is 16.</td></tr>\n<tr><td>\n<kbd><span class=\"option\">--ignore-walk-errors</span></kbd></td>\n</tr>\n<tr><td>\u00a0</td><td>Ignore errors when walking the source tree (for example, permissions errors on a directory), except for an error when listing the source root directory.</td></tr>\n</tbody>\n</table>\n</blockquote>\n</div>\n</div>\n<div id=\"web-server-integration\">\n<h2>Web server integration</h2>\n<p>In addition to using the command line script to upload files, you\u2019ll need to modify your web server so it knows how to generate the static URLs including the content-based hash in the filename.</p>\n<p>The recommended way to do this is to use the key mapping JSON, which is written out by the <tt><span class=\"pre\">--key-map</span></tt> command line argument when you upload your statics. You can load this into a key-value dictionary when your server starts up, and then generate a static URL simply by looking up the relative path of a static file in this dictionary.</p>\n<p>Even though the keys in the JSON are relative file paths, they\u2019re normalized to always use <tt>/</tt> (forward slash) as the directory separator, even on Windows. This is so consumers of the mapping can look up files directly in the mapping with a consistent path separator.</p>\n<p>Below is a simple example of loading the key mapping in your web server startup (call <tt>init_server()</tt> on startup) and then defining a function to generate full static URLs for use in your HTML templates. This example is written in Python, but you can use any language that can parse JSON and look something up in a map:</p>\n<pre>import json\nimport settings\n\ndef init_server():\n    settings.cdn_base_url = 'https://mycdn.com/'\n    with open('statics.json') as f:\n        settings.statics = json.load(f)\n\ndef static_url(rel_path):\n    \"\"\"Convert relative static path to full static URL (including hash)\"\"\"\n    return settings.cdn_base_url + settings.statics[rel_path]\n</pre>\n<p>And then in your HTML templates, just reference a static file using the <tt>static_url</tt> function (referenced here as a Jinja2 template filter):</p>\n<pre>&lt;link rel=\"stylesheet\" href=\"{{ 'style.css'|static_url }}\"&gt;\n</pre>\n<p>If your web server is in fact written in Python, you can also <tt>import cdnupload</tt> directly and use <tt>cdnupload.FileSource</tt> with the same parameters as the upload command line. This will build the key mapping at server startup time, and may simplify the deployment process a little:</p>\n<pre>import cdnupload\nimport settings\n\ndef init_server():\n    settings.cdn_base_url = 'https://mycdn.com/'\n    source = cdnupload.FileSource(settings.static_dir)\n    settings.static_paths = source.build_key_map()\n</pre>\n<p>If you have huge numbers of static files, this is not recommended, as it does have to re-hash all the files when the server starts up. So for larger sites it\u2019s best to produce the key map JSON and copy that to your app servers as part of your deployment process.</p>\n</div>\n<div id=\"static-urls-in-css\">\n<h2>Static URLs in CSS</h2>\n<p>If you reference static files in your CSS (for example, background images with <tt><span class=\"pre\">url(...)</span></tt> expressions), you\u2019ll need to either remove them from your CSS and generate them in an inline <tt>&lt;style&gt;</tt> section at the top of your HTML, or use a post-processor script on your CSS to change the URLs from relative to full hashed URLs.</p>\n<p>For small sites, it may be simpler to just extract them from your CSS. For example, for a CSS rule like this:</p>\n<pre>body.home {\n    font-family: Verdana;\n    font-size: 10px;\n    background-image: url(/static/images/hero.jpg);\n}\n</pre>\n<p>You would remove just the <tt><span class=\"pre\">background-image</span></tt> line and put it in an inline style block in the <tt>&lt;head&gt;</tt> section of relevant pages, like this:</p>\n<pre>&lt;head&gt;\n    &lt;!-- other head elements; link to the stylesheet above --&gt;\n    &lt;style type=\"text/css\"&gt;\n        body.home {\n            background-image: url({{ 'images/hero.jpg'|static_url }});\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n</pre>\n<p>However, for larger-scale sites where the CSS references a lot of static images, this quickly becomes hard to manage. In that case, you\u2019ll want to use a tool like <a href=\"http://postcss.org/\" rel=\"nofollow\">PostCSS</a> to rewrite static URLs in your CSS to cdnupload URLs via the key mapping. There\u2019s a PostCSS plugin called <a href=\"https://github.com/postcss/postcss-url\" rel=\"nofollow\">postcss-url</a> that you can use to rewrite URLs with a custom transform function.</p>\n<p>The CSS rewriting should be integrated into your build or deployment process, as the PostCSS rule will need access to the JSON key mapping that the uploader wrote out.</p>\n</div>\n<div id=\"python-api\">\n<h2>Python API</h2>\n<p>cdnupload is a Python command-line script, but it\u2019s also a Python module you can import and extend if you need to customize it or hook into advanced features. It works on both Python 3.4+ and Python 2.7.</p>\n<div id=\"custom-destination\">\n<h3>Custom destination</h3>\n<p>The most likely reason you\u2019ll need to extend cdnupload is to write a custom <tt>Destination</tt> subclass (if the built-in file or Amazon S3 destinations don\u2019t work for you).</p>\n<p>For example, if you\u2019re using a CDN that connects to an origin server called \u201cMy Origin\u201d, you might write a custom subclass for uploading to your origin. You\u2019ll need to subclass <tt>cdnupload.Destination</tt> and implement an initalizer as well as the <tt>__str__</tt>, <tt>walk_keys</tt>, <tt>upload</tt>, and <tt>delete</tt> methods:</p>\n<pre>import cdnupload\nimport myorigin\n\nclass Destination(cdnupload.Destination):\n    def __init__(self, url, foo='FOO', bar=None):\n        \"\"\"Initialize destination instance with given \"My Origin\" URL\n        (which should be in form my://server/path).\n        \"\"\"\n        self.url = url\n        self.conn = myorigin.Connection(url, foo=foo, bar=bar)\n\n    def __str__(self):\n        \"\"\"Return a human-readable string for this destination.\"\"\"\n        return self.url\n\n    def walk_keys(self):\n        \"\"\"Yield keys (files) that are currently on the destination.\"\"\"\n        for file in self.conn.get_files():\n            yield file.name\n\n    def upload(self, key, source, rel_path):\n        \"\"\"Upload a single file from source at rel_path to destination\n        at given key. Normally this function will use the with statement\n        \"with source.open(rel_path)\" to open the source file object.\n        \"\"\"\n        with source.open(rel_path) as source_file:\n            self.conn.upload_file_obj(source_file, key)\n\n    def delete(self, key):\n        \"\"\"Delete a single file on destination at given key.\"\"\"\n        self.conn.delete_file(key)\n</pre>\n<p>To use this custom destination, save your custom code to <tt>cdnupload_my.py</tt> and ensure the file is somewhere on your PYTHONPATH. Then if you run the cdnupload command-line tool with a destination starting with scheme <tt><span class=\"pre\">my://</span></tt>, it will automatically import <tt>cdnupload_my</tt> and look for a class called <tt>Destination</tt>, passing the <tt><span class=\"pre\">my://server/path</span></tt> URL and any additional destination arguments to your initializer.</p>\n<p>Note that when the command-line tool passes additional dest_args to a custom destination, it always passes them as strings (or a list of strings if a dest arg is specified more than once). So if you need an integer or other type, you\u2019ll need to convert it in your <tt>__init__</tt> method.</p>\n</div>\n<div id=\"upload-and-delete\">\n<h3>Upload and delete</h3>\n<p>The top-level functions <tt>upload()</tt> and <tt>delete()</tt> drive cdnupload. You can create your own command-line entry point if you want to hook into cdnupload\u2019s Python API. For example, you could make a <tt>myupload.py</tt> script as follows:</p>\n<pre>import cdnupload\nimport hashlib\n\nsource = cdnupload.FileSource('/path/to/my/statics',\n                              hash_class=hashlib.md5)\ndestination = cdnupload.S3Destination('s3://bucket/path')\ncdnupload.upload(source, destination)\n</pre>\n<p>Here we\u2019re doing some light customization of <tt>FileSource</tt>\u2019s hashing behaviour (changing it from SHA-1 to MD5) and then performing an upload.</p>\n<p>The <tt>upload()</tt> function uploads files from a source to a destination, but only if they\u2019re missing at the destination (according to <tt>destination.walk_keys</tt>).</p>\n<p>The <tt>delete()</tt> function deletes files from the destination if they\u2019re no longer present at the source (according to <tt>source.build_key_map</tt>).</p>\n<p>Both <tt>upload</tt> and <tt>delete</tt> take the same set of arguments:</p>\n<ul>\n<li><tt>source</tt>: the source object; either a <tt>FileSource</tt> instance (or object that implements the same interface), or a string in which case it gets converted to a source via <tt>FileSource(source)</tt></li>\n<li><tt>destination</tt>: the destination object; either an instance of a concrete <tt>Destination</tt> subclass, or a string in which case it gets converted to a destination via <tt>FileDestination(destination)</tt></li>\n<li><tt>force=False</tt>: if True, same as specifying the <tt><span class=\"pre\">--force</span></tt> command line option</li>\n<li><tt>dry_run=False</tt>: if True, same as specifying the <tt><span class=\"pre\">--dry-run</span></tt> command line option</li>\n<li><tt>continue_on_errors=False</tt>: if True, same as specifying the <tt><span class=\"pre\">--continue-on-errors</span></tt> command line option</li>\n</ul>\n<p>Both functions return a <tt>Result</tt> namedtuple, which has the following attributes:</p>\n<ul>\n<li><tt>source_key_map</tt>: the source path to destination key mapping, the same dict returned by <tt>source.build_key_map()</tt></li>\n<li><tt>destination_keys</tt>: a set containing the destination keys, as returned by <tt>destination.walk_keys()</tt></li>\n<li><tt>num_scanned</tt>: total number of files scanned (source files when uploading, or destination keys when deleting)</li>\n<li><tt>num_processed</tt>: number of files processed (actually uploaded or deleted)</li>\n<li><tt>num_errors</tt>: number of errors (useful when <tt>continue_on_errors</tt> is true)</li>\n</ul>\n</div>\n<div id=\"custom-source\">\n<h3>Custom source</h3>\n<p>You can also customize the source of the files. There\u2019s currently only one source class, <tt>FileSource</tt>, which reads files from the filesystem and produces file hashes. You can pass options to the <tt>FileSource</tt> initializer to control which files it includes or excludes, as well as how it hashes their contents to produce the content-based hash.</p>\n<p>The <tt>dot_names</tt>, <tt>include</tt>, <tt>exclude</tt>, <tt>ignore_walk_errors</tt>, <tt>follow_symlinks</tt>, and <tt>hash_length</tt> arguments correspond directly to the <tt><span class=\"pre\">--dot-names</span></tt>, <tt><span class=\"pre\">--include</span></tt>, <tt><span class=\"pre\">--exclude</span></tt>, <tt><span class=\"pre\">--ignore-walk-errors</span></tt>, <tt><span class=\"pre\">--follow-symlinks</span></tt>, and <tt><span class=\"pre\">--hash-length</span></tt> command line options.</p>\n<p>Additionally, you can customize <tt>FileSource</tt> further with the <tt>hash_chunk_size</tt> and <tt>hash_class</tt> arguments. The file is read in <tt>hash_chunk_size</tt>-byte blocks when being hashed, and <tt>hash_class</tt> is instantiated to generate the hashes (must have a hashlib-style signature).</p>\n<p>Or you can subclass <tt>FileSource</tt> if you want to customize advanced behaviour. For example, you could override <tt>FileSource.hash_file()</tt>\u2019s handling of text and binary files to treat all files as binary:</p>\n<pre>from cdnupload import FileSource\n\nclass BinarySource(FileSource):\n    def hash_file(self, rel_path):\n        return FileSource.hash_file(self, rel_path, is_text=False)\n</pre>\n<p>To use a subclassed <tt>FileSource</tt>, you\u2019ll need to call the <tt>upload()</tt> and <tt>delete()</tt> functions with your instance directly from Python. It\u2019s not currently possibly to use a subclassed source via the cdnupload command line script.</p>\n</div>\n<div id=\"logging\">\n<h3>Logging</h3>\n<p>cdnupload functions use standard Python logging to log all operations. The name of the logger is <tt>cdnupload</tt>, and you can control log output format and verbosity (log level) using the Python logging functions.</p>\n<p>For example, to log all errors but turn debug-level logging on only for cdnupload logs, you could do this:</p>\n<pre>import logging\n\nlogging.basicConfig(level=logging.ERROR)\nlogging.getLogger('cdnupload').setLevel(logging.DEBUG)\n</pre>\n</div>\n</div>\n<div id=\"contributing\">\n<h2>Contributing</h2>\n<p>If you find a bug in cdnupload, please open an issue with the following information:</p>\n<ul>\n<li>Full error messages or tracebacks</li>\n<li>The cdnupload version, Python version, and operating system type and version</li>\n<li>Steps or a test case that reproduces the issue (ideally)</li>\n</ul>\n<p>If you have a feature request, documentation fix, or other suggestion, open an issue and we\u2019ll discuss!</p>\n<p>See also <a href=\"https://github.com/benhoyt/cdnupload/blob/master/CONTRIBUTING.md\" rel=\"nofollow\">CONTRIBUTING.md</a> in the cdnupload source tree.</p>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>cdnupload is licensed under a permissive MIT license: see <a href=\"https://github.com/benhoyt/cdnupload/blob/master/LICENSE.txt\" rel=\"nofollow\">LICENSE.txt</a> for details.</p>\n<p>Note that prior to August 2017 it was licensed under an AGPL plus commercial license combination, but now it\u2019s completely free.</p>\n</div>\n<div id=\"about-the-author\">\n<h2>About the author</h2>\n<p>cdnupload is written and maintained by Ben Hoyt: a <a href=\"http://benhoyt.com/cv/\" rel=\"nofollow\">software developer</a>, <a href=\"http://benhoyt.com/writings/scandir/\" rel=\"nofollow\">Python contributor</a>, and general all-round software geek. For more info, see his personal website at <a href=\"http://benhoyt.com/\" rel=\"nofollow\">benhoyt.com</a>.</p>\n</div>\n\n          </div>"}, "last_serial": 3086737, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "74f1fc8e67b3df8b40334bbe42137bca", "sha256": "918734ad4a25c3bcb1cf38b778d2bd80a862342ab8d674b3cb5d0d9282b92a9f"}, "downloads": -1, "filename": "cdnupload-1.0.0.tar.gz", "has_sig": false, "md5_digest": "74f1fc8e67b3df8b40334bbe42137bca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32572, "upload_time": "2017-04-06T12:39:54", "upload_time_iso_8601": "2017-04-06T12:39:54.024958Z", "url": "https://files.pythonhosted.org/packages/d4/6e/895fb7ffe3404768e556002e7683e0eece69bf3157b5caf0f759841fc7db/cdnupload-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "f9853cf389828f804fa148b70e6d93fd", "sha256": "10e16771136b0c58245d4d4af8cae97536cd75fb27b47849d4f99ff6d94c9bfe"}, "downloads": -1, "filename": "cdnupload-1.0.1.tar.gz", "has_sig": false, "md5_digest": "f9853cf389828f804fa148b70e6d93fd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32628, "upload_time": "2017-04-08T16:09:52", "upload_time_iso_8601": "2017-04-08T16:09:52.402299Z", "url": "https://files.pythonhosted.org/packages/0d/da/dbad9a9897f816d7ed2c7fc18815cfe5451bb2a6c0570720cbd59b625e59/cdnupload-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "fd5368519706071cc950700357f31bf1", "sha256": "5241ef288725490fe812e6f05098e9bceef5d01654f8025c5f43cdf36aebe4c4"}, "downloads": -1, "filename": "cdnupload-1.0.2.tar.gz", "has_sig": false, "md5_digest": "fd5368519706071cc950700357f31bf1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32702, "upload_time": "2017-04-08T17:34:18", "upload_time_iso_8601": "2017-04-08T17:34:18.807069Z", "url": "https://files.pythonhosted.org/packages/b0/a5/30b04e713de3ef11a1abfc05f688e9537513a0c8dc17671f8360d637c230/cdnupload-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "1c9b6daf28e21ecd433cc451d43d1c63", "sha256": "fb69020cbeae65a99bc6b81c96780321ca13239a398f3693b6ef5587ecdde0e0"}, "downloads": -1, "filename": "cdnupload-1.0.3.tar.gz", "has_sig": false, "md5_digest": "1c9b6daf28e21ecd433cc451d43d1c63", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32672, "upload_time": "2017-04-12T16:43:13", "upload_time_iso_8601": "2017-04-12T16:43:13.429325Z", "url": "https://files.pythonhosted.org/packages/79/11/5b108c97ae3c0cc1eb7c7df919ca7b20fcb692ba1b690b4e93c1c64a6c78/cdnupload-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "f2ef6a0f68c44af7420bdf2e19c3f225", "sha256": "e1b6c7dfaef3c7968ffeecb82e3665f32c0ec175fc79fab2a018ffd6e57f56df"}, "downloads": -1, "filename": "cdnupload-1.0.4.tar.gz", "has_sig": false, "md5_digest": "f2ef6a0f68c44af7420bdf2e19c3f225", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33824, "upload_time": "2017-08-10T12:40:54", "upload_time_iso_8601": "2017-08-10T12:40:54.409800Z", "url": "https://files.pythonhosted.org/packages/be/0c/79a6f9ba704590c2a3e0fb295d717e7ec611195278d9eebe16bb933d0f66/cdnupload-1.0.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f2ef6a0f68c44af7420bdf2e19c3f225", "sha256": "e1b6c7dfaef3c7968ffeecb82e3665f32c0ec175fc79fab2a018ffd6e57f56df"}, "downloads": -1, "filename": "cdnupload-1.0.4.tar.gz", "has_sig": false, "md5_digest": "f2ef6a0f68c44af7420bdf2e19c3f225", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33824, "upload_time": "2017-08-10T12:40:54", "upload_time_iso_8601": "2017-08-10T12:40:54.409800Z", "url": "https://files.pythonhosted.org/packages/be/0c/79a6f9ba704590c2a3e0fb295d717e7ec611195278d9eebe16bb933d0f66/cdnupload-1.0.4.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:34:55 2020"}