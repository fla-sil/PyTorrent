{"info": {"author": "Cameron Simpson", "author_email": "cs@cskk.id.au", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "*Latest release 20200229*:\nListField: replace transcribe method with transcribe_value method, aids external use.\nAdd `.length` attribute to struct based packet classes providing the data length of the structure (struct.Struct.size).\nPacket: new `add_deferred_field` method to consume the raw data for a field for parsing later (done automatically if the attribute is accessed).\nNew `@deferred_field` decorator for the parser for that stashed data.\n\nFacilities associated with binary data parsing and transcription.\n\nThe classes in this module support easy parsing of binary data\nstructures.\n\nThese classes work in conjuction with a `cs.buffer.CornuCopyBuffer`\n(henceforce a \"buffer\"),\nwhich presents an iterable of bytes-like values\nvia various useful methods\nand with factory methods to make one from a variety of sources\nsuch as bytes, iterables, binary files, `mmap`ped files,\nTCP data streams, etc.\n\nNote: this module requires Python 3 and recommends Python 3.6+\nbecause it uses abc.ABC, because a Python 2 bytes object is too\nweak (just a `str`) as also is my `cs.py3.bytes` hack class and\nbecause the keyword based `Packet` initiialisation benefits from\nkeyword argument ordering.\n\nIn the description below I use the word \"chunk\" to mean a piece\nof binary data obeying the buffer protocol, almost always a\n`bytes` instance or a `memoryview`, but in principle also things\nlike `bytearray`.\n\nThe functions and classes in this module the following:\n\nThe two base classes for binary data:\n* `PacketField`: an abstract class for a binary field, with a\n  factory method to parse it, a transcription method to transcribe\n  it back out in binary form and usually a `.value` attribute\n  holding the parsed value.\n* `Packet`: a `PacketField` subclass for parsing multiple\n  `PacketField`s into a larger structure with ordered named\n  fields.\n  The fields themselves may be `Packet`s for complex structures.\n\nSeveral presupplied subclasses for common basic types such\nas `UInt32BE` (an unsigned 32 bit big endian integer).\n\nClasses built from `struct` format strings:\n* `struct_field`: a factory for making PacketField classes for\n  `struct` formats with a single value field.\n* `multi_struct_field` and `structtuple`: factories for making\n  `PacketField`s from `struct` formats with multiple value\n  fields;\n  `structtuple` makes `PacketField`s which are also `namedtuple`s,\n  supporting trivial access to the parsed values.\n\nYou don't need to make fields only from binary data; because\n`PacketField.__init__` takes a post parse value, you can also\nconstruct `PacketField`s from scratch with their values and\ntranscribe the resulting binary form.\n\nEach `PacketField` subclass has the following methods:\n* `transcribe`: easily return the binary transcription of this field,\n  either directly as a chunk (or for convenience, also None or\n  an ASCII str) or by yielding successive binary data.\n* `from_buffer`: a factory to parse this field from a\n  `cs.buffer.CornuCopyBuffer`.\n* `from_bytes`: a factory to parse this field from a chunk with\n  an optional starting offset; this is a convenience wrapper for\n  `from_buffer`.\n\nThat may sound a little arcane, but we also supply:\n* `flatten`: a recursive function to take the return from any\n  `transcribe` method and yield chunks, so copying a packet to\n  a file or elsewhere can always be done by iterating over\n  `flatten(field.transcribe())` or via the convenience\n  `field.transcribe_flat()` method which calls `flatten` itself.\n* a `CornuCopyBuffer` is an easy to use wrapper for parsing any\n  iterable of chunks, which may come from almost any source.\n  It has a bunch of convenient factories including:\n  `from_bytes`, make a buffer from a chunk;\n  `from_fd`, make a buffer from a file descriptor;\n  `from_file`, make a buffer from a file-like object;\n  `from_mmap`, make a buffer from a file descriptor using a\n  memory map (the `mmap` module) of the file, so that chunks\n  can use the file itself as backing store instead of allocating\n  and copying memory.\n  See the `cs.buffer` module for further detail.\n\nWhen parsing a complex structure\none must choose between subclassing `PacketField` or `Packet`.\nAn effective guideline is the degree of substructure.\n\nA `Packet` is designed for deeper structures;\nall of its attributes are themselves `PacketField`s\n(or `Packet`s, which are `PacketField` subclasses).\nThe leaves of this hierarchy will be `PacketField`s,\nwhose attributes are ordinary types.\n\nBy contrast, a `PacketField`'s attributes are \"flat\" values:\nthe plain post-parse value, such as a `str` or an `int`\nor some other conventional Python type.\n\nThe base case for `PacketField`\nis a single such value, named `.value`,\nand the natural implementation\nis to provide a `.value_from_buffer` method\nwhich returns the basic single value\nand the corresponding `.transcribe_value` method\nto return or yield its binary form\n(directly or in pieces respectively).\n\nHowever,\nyou can handle multiple attributes with this class\nby instead implementing:\n* `__init__`: to compose an instance from post-parse values\n  (and thus from scratch rather than parsed from existing binary data)\n* `from_buffer`: class method to parse the values\n  from a `CornuCopyBuffer` and call the class constructor\n* `transcribe`: to return or yield the binary form of the attributes\n\nCameron Simpson <cs@cskk.id.au> 22jul2018\n\n## Class `BSData(PacketField)`\n\nA run length encoded data chunk, with the length encoded as a BSUInt.\n\n## Class `BSSFloat(PacketField)`\n\nA float transcribed as a BSString of str(float).\n\n## Class `BSString(PacketField)`\n\nA run length encoded string, with the length encoded as a BSUInt.\n\n## Class `BSUInt(PacketField)`\n\nA binary serialsed unsigned int.\n\nThis uses a big endian byte encoding where continuation octets\nhave their high bit set. The bits contributing to the value\nare in the low order 7 bits.\n\n## Class `BytesesField(PacketField)`\n\nA field containing a list of bytes chunks.\n\nThe following attributes are defined:\n* `value`: the gathered data as a list of bytes instances,\n  or None if the field was gathered with `discard_data` true.\n* `offset`: the starting offset of the data.\n* `end_offset`: the ending offset of the data.\n\nThe `offset` and `end_offset` values are recorded during the\nparse, and may become irrelevant if the field's contents are\nchanged.\n\n## Class `BytesField(PacketField)`\n\nA field of bytes.\n\n## Class `BytesRunField(PacketField)`\n\nA field containing a continuous run of a single bytes value.\n\nThe following attributes are defined:\n* `length`: the length of the run\n* `bytes_value`: the repeated bytes value\n\nThe property `value` is computed on the fly on every reference\nand returns a value obeying the buffer protocol: a bytes or\nmemoryview object.\n\n## Function `deferred_field(from_buffer)`\n\nA decorator for a field property.\n\nUsage:\n\n    @deferred_field\n    def (self, bfr):\n        ... parse value from `bfr`, return value\n\n## Class `EmptyPacketField(PacketField)`\n\nAn empty data field, used as a placeholder for optional\nfields when they are not present.\n\nThe singleton `EmptyField` is a predefined instance.\n\n## Function `fixed_bytes_field(length, class_name=None)`\n\nFactory for `BytesField` subclasses built from fixed length byte strings.\n\n## Function `flatten(chunks)`\n\nFlatten `chunks` into an iterable of `bytes` instances.\n\nThis exists to allow subclass methods to easily return ASCII\nstrings or bytes or iterables or even `None`, in turn allowing\nthem simply to return their superclass' chunks iterators\ndirectly instead of having to unpack them.\n\n## Class `Float64BE(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'>d'`.\n\n## Class `Float64LE(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'<d'`.\n\n## Class `Int16BE(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'>h'`.\n\n## Class `Int16LE(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'<h'`.\n\n## Class `Int32BE(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'>l'`.\n\n## Class `Int32LE(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'<l'`.\n\n## Class `ListField(PacketField)`\n\nA field which is itself a list of other `PacketField`s.\n\n## Function `multi_struct_field(struct_format, subvalue_names=None, class_name=None)`\n\nFactory for `PacketField` subclasses build around complex struct formats.\n\nParameters:\n* `struct_format`: the struct format string\n* `subvalue_names`: an optional namedtuple field name list;\n  if supplied then the field value will be a namedtuple with\n  these names\n* `class_name`: option name for the generated class\n\n## Class `Packet(PacketField)`\n\nBase class for compound objects derived from binary data.\n\n### Method `Packet.__init__(self, **fields)`\n\nInitialise the `Packet`.\n\nA `Packet` is its own `.value`.\n\nIf any keyword arguments are provided, they are used as a\nmapping of `field_name` to `Field` instance, supporting\ndirect construction of simple `Packet`s.\nFrom Python 3.6 onwards keyword arguments preserve the calling order;\nin Python versions earlier than this the caller should\nadjust the `Packet.field_names` list to the correct order after\ninitialisation.\n\n## Class `PacketField`\n\nA record for an individual packet field.\n\nThis normally holds a single value, such as a int of a particular size\nor a string.\n\nThere are 2 basic ways to implement a `PacketField` subclass.\n\nFor the simple case subclasses should implement two methods:\n* `value_from_buffer`:\n  parse the value from a `CornuCopyBuffer` and returns the parsed value\n* `transcribe_value`:\n  transcribe the value as bytes\n\nSometimes a `PacketField` may be slightly more complex\nwhile still not warranting (or perhaps fitting)\nthe formality of a `Packet` with its multifield structure.\nOne example is the `cs.iso14496.UTF8or16Field` class.\n\n`UTF8or16Field` supports an ISO14496 UTF8 or UTF16 string field,\nas as such has 2 attributes:\n* `value`: the string itself\n* `bom`: a UTF16 byte order marker or `None`;\n  `None` indicates that the string should be encoded as UTF-8\n  and otherwise the BOM indicates UTF16 big endian or little endian.\n\nTo make this subclass it defines these methods:\n* `from_buffer`:\n  to read the optional BOM and then the following encoded string;\n  it then returns the new `UTF8or16Field`\n  initialised from these values via `cls(text, bom=bom)`.\n* `transcribe`:\n  to transcribe the option BOM and suitably encoded string.\nThe instance method `transcribe` is required because the transcription\nrequires knowledge of the BOM, an attribute of an instance.\n\n### Method `PacketField.__init__(self, value=None)`\n\nInitialise the `PacketField`.\nIf omitted the inial field `value` will be `None`.\n\n## Function `struct_field(struct_format, class_name)`\n\nFactory for `PacketField` subclasses built around a single struct format.\n\nParameters:\n* `struct_format`: the struct format string, specifying a\n  single struct field\n* `class_name`: the class name for the generated class\n\nExample:\n\n    >>> UInt16BE = struct_field('>H', class_name='UInt16BE')\n    >>> UInt16BE.__name__\n    'UInt16BE'\n    >>> UInt16BE.format\n    '>H'\n    >>> UInt16BE.struct   #doctest: +ELLIPSIS\n    <Struct object at ...>\n    >>> field, offset = UInt16BE.from_bytes(bytes((2,3,4)))\n    >>> field\n    UInt16BE(515)\n    >>> offset\n    2\n    >>> field.value\n    515\n\n## Function `structtuple(class_name, struct_format, subvalue_names)`\n\nConvenience wrapper for multi_struct_field.\n\n## Class `UInt16BE(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'>H'`.\n\n## Class `UInt16LE(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'<H'`.\n\n## Class `UInt32BE(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'>L'`.\n\n## Class `UInt32LE(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'<L'`.\n\n## Class `UInt64BE(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'>Q'`.\n\n## Class `UInt64LE(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'<Q'`.\n\n## Class `UInt8(PacketField)`\n\nA `PacketField` which parses and transcribes the struct format `'B'`.\n\n## Class `UTF16NULField(PacketField)`\n\nA NUL terminated UTF-16 string.\n\n### Method `UTF16NULField.__init__(self, value, *, encoding)`\n\nInitialise the `PacketField`.\nIf omitted the inial field `value` will be `None`.\n\n## Class `UTF8NULField(PacketField)`\n\nA NUL terminated UTF-8 string.\n\n## Function `warning(msg, *a, f=None)`\n\nIssue a formatted warning message.\n\n\n\n# Release Log\n\n*Release 20200229*:\nListField: replace transcribe method with transcribe_value method, aids external use.\nAdd `.length` attribute to struct based packet classes providing the data length of the structure (struct.Struct.size).\nPacket: new `add_deferred_field` method to consume the raw data for a field for parsing later (done automatically if the attribute is accessed).\nNew `@deferred_field` decorator for the parser for that stashed data.\n\n*Release 20191230.3*:\nDocstring tweak.\n\n*Release 20191230.2*:\nDocumentation updates.\n\n*Release 20191230.1*:\nDocstring updates. Semantic changes were in the previous release.\n\n*Release 20191230*:\nListField: new __iter__ method.\nPacket: __str__: accept optional `skip_fields` parameter to omit some field names.\nPacket: new .add_from_value method to add a named field with a presupplied value.\nPacket: new remove_field(field_name) and pop_field() methods to remove fields.\nBytesesField: __iter__ yields the bytes values, transcribe=__iter__.\nPacketField: propagate keyword arguments through various methods, required for parameterised PacketFields.\nNew UTF16NULField, a NUL terminated UTF16 string.\nPacketField: provide a default `.transcribe_value` method which makes a new instance and calls its `.transcribe` method.\nDocumentation update and several minor changes.\n\n*Release 20190220*:\nPacket.self_check: fields without a sanity check cause a warning, not a ValueError.\nNew Float64BE, Float64LE and BSSFloat classes for IEEE floats and floats-as-strings.\nAdditional module docstringage on subclassing Packet and PacketField.\nBSString: drop redundant from_buffer class method.\nPacketField.__init__: default to value=None if omitted.\n\n*Release 20181231*:\nflatten: do not yield zero length bytelike objects, can be misread as EOF on some streams.\n\n*Release 20181108*:\nNew PacketField.transcribe_value_flat convenience method to return a flat iterable of bytes-like objects.\nNew PacketField.parse_buffer generator method to parse instances of the PacketField from a buffer until end of input.\nNew PacketField.parse_buffer_values generator method to parse instances of the PacketField from a buffer and yield the `.value` attribute until end of input.\n\n*Release 20180823*:\nSome bugfixes.\nDefine PacketField.__eq__.\nBSUInt, BSData and BSString classes implementing the serialisations from cs.serialise.\nNew PacketField.value_from_bytes class method.\nNew PacketField.value_from_buffer method.\n\n*Release 20180810.2*:\nDocumentation improvements.\n\n*Release 20180810.1*:\nImprove module description.\n\n*Release 20180810*:\nBytesesField.from_buffer: make use of the buffer's skipto method if discard_data is true.\n\n*Release 20180805*:\nPacket: now an abstract class, new self_check method initially checking the\nPACKET_FIELDS class attribute against the instance, new methods get_field\nand set_field to fetch or replace existing fields, allow keyword arguments\nto initialise the Packet fields and document the dependency on keyword\nargument ordering.\nPacketField: __len__ computed directory from a transcribe, drop other __len__\nmethods.\nEmptyField singleton to use as a placeholder for missing optional fields.\nBytesField: implement value_s and from_buffer.\nmulti_struct_field: implement __len__ for generated class.\nflatten: treat memoryviews like bytes.\nAssorted docstrings and fixes.\n\n*Release 20180801*:\nInitial PyPI release.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/cameron_simpson/css/commits/all", "keywords": "python3", "license": "GNU General Public License v3 or later (GPLv3+)", "maintainer": "", "maintainer_email": "", "name": "cs.binary", "package_url": "https://pypi.org/project/cs.binary/", "platform": "", "project_url": "https://pypi.org/project/cs.binary/", "project_urls": {"Homepage": "https://bitbucket.org/cameron_simpson/css/commits/all"}, "release_url": "https://pypi.org/project/cs.binary/20200229/", "requires_dist": null, "requires_python": "", "summary": "Facilities associated with binary data parsing and transcription.", "version": "20200229", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><em>Latest release 20200229</em>:\nListField: replace transcribe method with transcribe_value method, aids external use.\nAdd <code>.length</code> attribute to struct based packet classes providing the data length of the structure (struct.Struct.size).\nPacket: new <code>add_deferred_field</code> method to consume the raw data for a field for parsing later (done automatically if the attribute is accessed).\nNew <code>@deferred_field</code> decorator for the parser for that stashed data.</p>\n<p>Facilities associated with binary data parsing and transcription.</p>\n<p>The classes in this module support easy parsing of binary data\nstructures.</p>\n<p>These classes work in conjuction with a <code>cs.buffer.CornuCopyBuffer</code>\n(henceforce a \"buffer\"),\nwhich presents an iterable of bytes-like values\nvia various useful methods\nand with factory methods to make one from a variety of sources\nsuch as bytes, iterables, binary files, <code>mmap</code>ped files,\nTCP data streams, etc.</p>\n<p>Note: this module requires Python 3 and recommends Python 3.6+\nbecause it uses abc.ABC, because a Python 2 bytes object is too\nweak (just a <code>str</code>) as also is my <code>cs.py3.bytes</code> hack class and\nbecause the keyword based <code>Packet</code> initiialisation benefits from\nkeyword argument ordering.</p>\n<p>In the description below I use the word \"chunk\" to mean a piece\nof binary data obeying the buffer protocol, almost always a\n<code>bytes</code> instance or a <code>memoryview</code>, but in principle also things\nlike <code>bytearray</code>.</p>\n<p>The functions and classes in this module the following:</p>\n<p>The two base classes for binary data:</p>\n<ul>\n<li><code>PacketField</code>: an abstract class for a binary field, with a\nfactory method to parse it, a transcription method to transcribe\nit back out in binary form and usually a <code>.value</code> attribute\nholding the parsed value.</li>\n<li><code>Packet</code>: a <code>PacketField</code> subclass for parsing multiple\n<code>PacketField</code>s into a larger structure with ordered named\nfields.\nThe fields themselves may be <code>Packet</code>s for complex structures.</li>\n</ul>\n<p>Several presupplied subclasses for common basic types such\nas <code>UInt32BE</code> (an unsigned 32 bit big endian integer).</p>\n<p>Classes built from <code>struct</code> format strings:</p>\n<ul>\n<li><code>struct_field</code>: a factory for making PacketField classes for\n<code>struct</code> formats with a single value field.</li>\n<li><code>multi_struct_field</code> and <code>structtuple</code>: factories for making\n<code>PacketField</code>s from <code>struct</code> formats with multiple value\nfields;\n<code>structtuple</code> makes <code>PacketField</code>s which are also <code>namedtuple</code>s,\nsupporting trivial access to the parsed values.</li>\n</ul>\n<p>You don't need to make fields only from binary data; because\n<code>PacketField.__init__</code> takes a post parse value, you can also\nconstruct <code>PacketField</code>s from scratch with their values and\ntranscribe the resulting binary form.</p>\n<p>Each <code>PacketField</code> subclass has the following methods:</p>\n<ul>\n<li><code>transcribe</code>: easily return the binary transcription of this field,\neither directly as a chunk (or for convenience, also None or\nan ASCII str) or by yielding successive binary data.</li>\n<li><code>from_buffer</code>: a factory to parse this field from a\n<code>cs.buffer.CornuCopyBuffer</code>.</li>\n<li><code>from_bytes</code>: a factory to parse this field from a chunk with\nan optional starting offset; this is a convenience wrapper for\n<code>from_buffer</code>.</li>\n</ul>\n<p>That may sound a little arcane, but we also supply:</p>\n<ul>\n<li><code>flatten</code>: a recursive function to take the return from any\n<code>transcribe</code> method and yield chunks, so copying a packet to\na file or elsewhere can always be done by iterating over\n<code>flatten(field.transcribe())</code> or via the convenience\n<code>field.transcribe_flat()</code> method which calls <code>flatten</code> itself.</li>\n<li>a <code>CornuCopyBuffer</code> is an easy to use wrapper for parsing any\niterable of chunks, which may come from almost any source.\nIt has a bunch of convenient factories including:\n<code>from_bytes</code>, make a buffer from a chunk;\n<code>from_fd</code>, make a buffer from a file descriptor;\n<code>from_file</code>, make a buffer from a file-like object;\n<code>from_mmap</code>, make a buffer from a file descriptor using a\nmemory map (the <code>mmap</code> module) of the file, so that chunks\ncan use the file itself as backing store instead of allocating\nand copying memory.\nSee the <code>cs.buffer</code> module for further detail.</li>\n</ul>\n<p>When parsing a complex structure\none must choose between subclassing <code>PacketField</code> or <code>Packet</code>.\nAn effective guideline is the degree of substructure.</p>\n<p>A <code>Packet</code> is designed for deeper structures;\nall of its attributes are themselves <code>PacketField</code>s\n(or <code>Packet</code>s, which are <code>PacketField</code> subclasses).\nThe leaves of this hierarchy will be <code>PacketField</code>s,\nwhose attributes are ordinary types.</p>\n<p>By contrast, a <code>PacketField</code>'s attributes are \"flat\" values:\nthe plain post-parse value, such as a <code>str</code> or an <code>int</code>\nor some other conventional Python type.</p>\n<p>The base case for <code>PacketField</code>\nis a single such value, named <code>.value</code>,\nand the natural implementation\nis to provide a <code>.value_from_buffer</code> method\nwhich returns the basic single value\nand the corresponding <code>.transcribe_value</code> method\nto return or yield its binary form\n(directly or in pieces respectively).</p>\n<p>However,\nyou can handle multiple attributes with this class\nby instead implementing:</p>\n<ul>\n<li><code>__init__</code>: to compose an instance from post-parse values\n(and thus from scratch rather than parsed from existing binary data)</li>\n<li><code>from_buffer</code>: class method to parse the values\nfrom a <code>CornuCopyBuffer</code> and call the class constructor</li>\n<li><code>transcribe</code>: to return or yield the binary form of the attributes</li>\n</ul>\n<p>Cameron Simpson <a href=\"mailto:cs@cskk.id.au\">cs@cskk.id.au</a> 22jul2018</p>\n<h2>Class <code>BSData(PacketField)</code></h2>\n<p>A run length encoded data chunk, with the length encoded as a BSUInt.</p>\n<h2>Class <code>BSSFloat(PacketField)</code></h2>\n<p>A float transcribed as a BSString of str(float).</p>\n<h2>Class <code>BSString(PacketField)</code></h2>\n<p>A run length encoded string, with the length encoded as a BSUInt.</p>\n<h2>Class <code>BSUInt(PacketField)</code></h2>\n<p>A binary serialsed unsigned int.</p>\n<p>This uses a big endian byte encoding where continuation octets\nhave their high bit set. The bits contributing to the value\nare in the low order 7 bits.</p>\n<h2>Class <code>BytesesField(PacketField)</code></h2>\n<p>A field containing a list of bytes chunks.</p>\n<p>The following attributes are defined:</p>\n<ul>\n<li><code>value</code>: the gathered data as a list of bytes instances,\nor None if the field was gathered with <code>discard_data</code> true.</li>\n<li><code>offset</code>: the starting offset of the data.</li>\n<li><code>end_offset</code>: the ending offset of the data.</li>\n</ul>\n<p>The <code>offset</code> and <code>end_offset</code> values are recorded during the\nparse, and may become irrelevant if the field's contents are\nchanged.</p>\n<h2>Class <code>BytesField(PacketField)</code></h2>\n<p>A field of bytes.</p>\n<h2>Class <code>BytesRunField(PacketField)</code></h2>\n<p>A field containing a continuous run of a single bytes value.</p>\n<p>The following attributes are defined:</p>\n<ul>\n<li><code>length</code>: the length of the run</li>\n<li><code>bytes_value</code>: the repeated bytes value</li>\n</ul>\n<p>The property <code>value</code> is computed on the fly on every reference\nand returns a value obeying the buffer protocol: a bytes or\nmemoryview object.</p>\n<h2>Function <code>deferred_field(from_buffer)</code></h2>\n<p>A decorator for a field property.</p>\n<p>Usage:</p>\n<pre><code>@deferred_field\ndef (self, bfr):\n    ... parse value from `bfr`, return value\n</code></pre>\n<h2>Class <code>EmptyPacketField(PacketField)</code></h2>\n<p>An empty data field, used as a placeholder for optional\nfields when they are not present.</p>\n<p>The singleton <code>EmptyField</code> is a predefined instance.</p>\n<h2>Function <code>fixed_bytes_field(length, class_name=None)</code></h2>\n<p>Factory for <code>BytesField</code> subclasses built from fixed length byte strings.</p>\n<h2>Function <code>flatten(chunks)</code></h2>\n<p>Flatten <code>chunks</code> into an iterable of <code>bytes</code> instances.</p>\n<p>This exists to allow subclass methods to easily return ASCII\nstrings or bytes or iterables or even <code>None</code>, in turn allowing\nthem simply to return their superclass' chunks iterators\ndirectly instead of having to unpack them.</p>\n<h2>Class <code>Float64BE(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'&gt;d'</code>.</p>\n<h2>Class <code>Float64LE(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'&lt;d'</code>.</p>\n<h2>Class <code>Int16BE(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'&gt;h'</code>.</p>\n<h2>Class <code>Int16LE(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'&lt;h'</code>.</p>\n<h2>Class <code>Int32BE(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'&gt;l'</code>.</p>\n<h2>Class <code>Int32LE(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'&lt;l'</code>.</p>\n<h2>Class <code>ListField(PacketField)</code></h2>\n<p>A field which is itself a list of other <code>PacketField</code>s.</p>\n<h2>Function <code>multi_struct_field(struct_format, subvalue_names=None, class_name=None)</code></h2>\n<p>Factory for <code>PacketField</code> subclasses build around complex struct formats.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>struct_format</code>: the struct format string</li>\n<li><code>subvalue_names</code>: an optional namedtuple field name list;\nif supplied then the field value will be a namedtuple with\nthese names</li>\n<li><code>class_name</code>: option name for the generated class</li>\n</ul>\n<h2>Class <code>Packet(PacketField)</code></h2>\n<p>Base class for compound objects derived from binary data.</p>\n<h3>Method <code>Packet.__init__(self, **fields)</code></h3>\n<p>Initialise the <code>Packet</code>.</p>\n<p>A <code>Packet</code> is its own <code>.value</code>.</p>\n<p>If any keyword arguments are provided, they are used as a\nmapping of <code>field_name</code> to <code>Field</code> instance, supporting\ndirect construction of simple <code>Packet</code>s.\nFrom Python 3.6 onwards keyword arguments preserve the calling order;\nin Python versions earlier than this the caller should\nadjust the <code>Packet.field_names</code> list to the correct order after\ninitialisation.</p>\n<h2>Class <code>PacketField</code></h2>\n<p>A record for an individual packet field.</p>\n<p>This normally holds a single value, such as a int of a particular size\nor a string.</p>\n<p>There are 2 basic ways to implement a <code>PacketField</code> subclass.</p>\n<p>For the simple case subclasses should implement two methods:</p>\n<ul>\n<li><code>value_from_buffer</code>:\nparse the value from a <code>CornuCopyBuffer</code> and returns the parsed value</li>\n<li><code>transcribe_value</code>:\ntranscribe the value as bytes</li>\n</ul>\n<p>Sometimes a <code>PacketField</code> may be slightly more complex\nwhile still not warranting (or perhaps fitting)\nthe formality of a <code>Packet</code> with its multifield structure.\nOne example is the <code>cs.iso14496.UTF8or16Field</code> class.</p>\n<p><code>UTF8or16Field</code> supports an ISO14496 UTF8 or UTF16 string field,\nas as such has 2 attributes:</p>\n<ul>\n<li><code>value</code>: the string itself</li>\n<li><code>bom</code>: a UTF16 byte order marker or <code>None</code>;\n<code>None</code> indicates that the string should be encoded as UTF-8\nand otherwise the BOM indicates UTF16 big endian or little endian.</li>\n</ul>\n<p>To make this subclass it defines these methods:</p>\n<ul>\n<li><code>from_buffer</code>:\nto read the optional BOM and then the following encoded string;\nit then returns the new <code>UTF8or16Field</code>\ninitialised from these values via <code>cls(text, bom=bom)</code>.</li>\n<li><code>transcribe</code>:\nto transcribe the option BOM and suitably encoded string.\nThe instance method <code>transcribe</code> is required because the transcription\nrequires knowledge of the BOM, an attribute of an instance.</li>\n</ul>\n<h3>Method <code>PacketField.__init__(self, value=None)</code></h3>\n<p>Initialise the <code>PacketField</code>.\nIf omitted the inial field <code>value</code> will be <code>None</code>.</p>\n<h2>Function <code>struct_field(struct_format, class_name)</code></h2>\n<p>Factory for <code>PacketField</code> subclasses built around a single struct format.</p>\n<p>Parameters:</p>\n<ul>\n<li><code>struct_format</code>: the struct format string, specifying a\nsingle struct field</li>\n<li><code>class_name</code>: the class name for the generated class</li>\n</ul>\n<p>Example:</p>\n<pre><code>&gt;&gt;&gt; UInt16BE = struct_field('&gt;H', class_name='UInt16BE')\n&gt;&gt;&gt; UInt16BE.__name__\n'UInt16BE'\n&gt;&gt;&gt; UInt16BE.format\n'&gt;H'\n&gt;&gt;&gt; UInt16BE.struct   #doctest: +ELLIPSIS\n&lt;Struct object at ...&gt;\n&gt;&gt;&gt; field, offset = UInt16BE.from_bytes(bytes((2,3,4)))\n&gt;&gt;&gt; field\nUInt16BE(515)\n&gt;&gt;&gt; offset\n2\n&gt;&gt;&gt; field.value\n515\n</code></pre>\n<h2>Function <code>structtuple(class_name, struct_format, subvalue_names)</code></h2>\n<p>Convenience wrapper for multi_struct_field.</p>\n<h2>Class <code>UInt16BE(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'&gt;H'</code>.</p>\n<h2>Class <code>UInt16LE(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'&lt;H'</code>.</p>\n<h2>Class <code>UInt32BE(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'&gt;L'</code>.</p>\n<h2>Class <code>UInt32LE(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'&lt;L'</code>.</p>\n<h2>Class <code>UInt64BE(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'&gt;Q'</code>.</p>\n<h2>Class <code>UInt64LE(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'&lt;Q'</code>.</p>\n<h2>Class <code>UInt8(PacketField)</code></h2>\n<p>A <code>PacketField</code> which parses and transcribes the struct format <code>'B'</code>.</p>\n<h2>Class <code>UTF16NULField(PacketField)</code></h2>\n<p>A NUL terminated UTF-16 string.</p>\n<h3>Method <code>UTF16NULField.__init__(self, value, *, encoding)</code></h3>\n<p>Initialise the <code>PacketField</code>.\nIf omitted the inial field <code>value</code> will be <code>None</code>.</p>\n<h2>Class <code>UTF8NULField(PacketField)</code></h2>\n<p>A NUL terminated UTF-8 string.</p>\n<h2>Function <code>warning(msg, *a, f=None)</code></h2>\n<p>Issue a formatted warning message.</p>\n<h1>Release Log</h1>\n<p><em>Release 20200229</em>:\nListField: replace transcribe method with transcribe_value method, aids external use.\nAdd <code>.length</code> attribute to struct based packet classes providing the data length of the structure (struct.Struct.size).\nPacket: new <code>add_deferred_field</code> method to consume the raw data for a field for parsing later (done automatically if the attribute is accessed).\nNew <code>@deferred_field</code> decorator for the parser for that stashed data.</p>\n<p><em>Release 20191230.3</em>:\nDocstring tweak.</p>\n<p><em>Release 20191230.2</em>:\nDocumentation updates.</p>\n<p><em>Release 20191230.1</em>:\nDocstring updates. Semantic changes were in the previous release.</p>\n<p><em>Release 20191230</em>:\nListField: new <strong>iter</strong> method.\nPacket: <strong>str</strong>: accept optional <code>skip_fields</code> parameter to omit some field names.\nPacket: new .add_from_value method to add a named field with a presupplied value.\nPacket: new remove_field(field_name) and pop_field() methods to remove fields.\nBytesesField: <strong>iter</strong> yields the bytes values, transcribe=<strong>iter</strong>.\nPacketField: propagate keyword arguments through various methods, required for parameterised PacketFields.\nNew UTF16NULField, a NUL terminated UTF16 string.\nPacketField: provide a default <code>.transcribe_value</code> method which makes a new instance and calls its <code>.transcribe</code> method.\nDocumentation update and several minor changes.</p>\n<p><em>Release 20190220</em>:\nPacket.self_check: fields without a sanity check cause a warning, not a ValueError.\nNew Float64BE, Float64LE and BSSFloat classes for IEEE floats and floats-as-strings.\nAdditional module docstringage on subclassing Packet and PacketField.\nBSString: drop redundant from_buffer class method.\nPacketField.<strong>init</strong>: default to value=None if omitted.</p>\n<p><em>Release 20181231</em>:\nflatten: do not yield zero length bytelike objects, can be misread as EOF on some streams.</p>\n<p><em>Release 20181108</em>:\nNew PacketField.transcribe_value_flat convenience method to return a flat iterable of bytes-like objects.\nNew PacketField.parse_buffer generator method to parse instances of the PacketField from a buffer until end of input.\nNew PacketField.parse_buffer_values generator method to parse instances of the PacketField from a buffer and yield the <code>.value</code> attribute until end of input.</p>\n<p><em>Release 20180823</em>:\nSome bugfixes.\nDefine PacketField.<strong>eq</strong>.\nBSUInt, BSData and BSString classes implementing the serialisations from cs.serialise.\nNew PacketField.value_from_bytes class method.\nNew PacketField.value_from_buffer method.</p>\n<p><em>Release 20180810.2</em>:\nDocumentation improvements.</p>\n<p><em>Release 20180810.1</em>:\nImprove module description.</p>\n<p><em>Release 20180810</em>:\nBytesesField.from_buffer: make use of the buffer's skipto method if discard_data is true.</p>\n<p><em>Release 20180805</em>:\nPacket: now an abstract class, new self_check method initially checking the\nPACKET_FIELDS class attribute against the instance, new methods get_field\nand set_field to fetch or replace existing fields, allow keyword arguments\nto initialise the Packet fields and document the dependency on keyword\nargument ordering.\nPacketField: <strong>len</strong> computed directory from a transcribe, drop other <strong>len</strong>\nmethods.\nEmptyField singleton to use as a placeholder for missing optional fields.\nBytesField: implement value_s and from_buffer.\nmulti_struct_field: implement <strong>len</strong> for generated class.\nflatten: treat memoryviews like bytes.\nAssorted docstrings and fixes.</p>\n<p><em>Release 20180801</em>:\nInitial PyPI release.</p>\n\n          </div>"}, "last_serial": 6723087, "releases": {"20180801": [{"comment_text": "", "digests": {"md5": "4f7061791ca98c45e9cde6d484400a00", "sha256": "72ed8c091a5f260ddd43e942e5a1ee5123f020818bfadb175d0484eebbd9b671"}, "downloads": -1, "filename": "cs.binary-20180801.tar.gz", "has_sig": false, "md5_digest": "4f7061791ca98c45e9cde6d484400a00", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7010, "upload_time": "2018-08-01T01:08:43", "upload_time_iso_8601": "2018-08-01T01:08:43.205711Z", "url": "https://files.pythonhosted.org/packages/ac/1f/36cd473ce89ccee42719ba7ec9e3f80a42faa781438ef3004f3808ce5856/cs.binary-20180801.tar.gz", "yanked": false}], "20180805": [{"comment_text": "", "digests": {"md5": "bb5d025ae3e4733619e0d85066cf57f5", "sha256": "fbce0f378ad5c25678d5033f5975309bb569a2c7c2480b00628faa053443ed92"}, "downloads": -1, "filename": "cs.binary-20180805.tar.gz", "has_sig": false, "md5_digest": "bb5d025ae3e4733619e0d85066cf57f5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9304, "upload_time": "2018-08-05T11:02:38", "upload_time_iso_8601": "2018-08-05T11:02:38.487378Z", "url": "https://files.pythonhosted.org/packages/c8/ae/8258d2259d0cbcbedcadbc647ae8f672218cafd78349591e5650bd2a1ab8/cs.binary-20180805.tar.gz", "yanked": false}], "20180810": [{"comment_text": "", "digests": {"md5": "fd95a999da7a4931394e033b9594bc4c", "sha256": "91395927b8bd582d36f9338066aa982c9a0f23b452a628c36505e06784078db1"}, "downloads": -1, "filename": "cs.binary-20180810.tar.gz", "has_sig": false, "md5_digest": "fd95a999da7a4931394e033b9594bc4c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9429, "upload_time": "2018-08-09T23:09:48", "upload_time_iso_8601": "2018-08-09T23:09:48.843765Z", "url": "https://files.pythonhosted.org/packages/bf/57/0a4194bc76f74746504818cb189af7d37f2652383d0588bc9a7ae074bed0/cs.binary-20180810.tar.gz", "yanked": false}], "20180810.1": [{"comment_text": "", "digests": {"md5": "1561ed403b90a35d61809dcb5f1df0ef", "sha256": "8ef1bd098b39896c7c446befb2a905502acbcc359f3a5e3f0e28d8ffb66ea5a2"}, "downloads": -1, "filename": "cs.binary-20180810.1.tar.gz", "has_sig": false, "md5_digest": "1561ed403b90a35d61809dcb5f1df0ef", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10885, "upload_time": "2018-08-09T23:51:34", "upload_time_iso_8601": "2018-08-09T23:51:34.582805Z", "url": "https://files.pythonhosted.org/packages/93/fb/65986c09d4c6121ce844eb4399b30bfe32a1aabb981f12660f6a60a215e3/cs.binary-20180810.1.tar.gz", "yanked": false}], "20180810.2": [{"comment_text": "", "digests": {"md5": "9f6aa643aaa16e89c2d6bd78585241c5", "sha256": "b8149c55d38e88d8896e0ca8a01604a69a0386932b47faa9883228fbc0178ce1"}, "downloads": -1, "filename": "cs.binary-20180810.2.tar.gz", "has_sig": false, "md5_digest": "9f6aa643aaa16e89c2d6bd78585241c5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11269, "upload_time": "2018-08-10T01:55:44", "upload_time_iso_8601": "2018-08-10T01:55:44.191888Z", "url": "https://files.pythonhosted.org/packages/ff/c0/fcfb4ecb89ae720b701247dc8f449b4a5d091d44fdceb05e431ef38efbcf/cs.binary-20180810.2.tar.gz", "yanked": false}], "20180823": [{"comment_text": "", "digests": {"md5": "2b924c2442739d8ead720fb48e3e0e2d", "sha256": "a423163137719148686548decd29dd023d4f284971183049aeef089d13e7068a"}, "downloads": -1, "filename": "cs.binary-20180823.tar.gz", "has_sig": false, "md5_digest": "2b924c2442739d8ead720fb48e3e0e2d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14126, "upload_time": "2018-08-23T02:19:25", "upload_time_iso_8601": "2018-08-23T02:19:25.182849Z", "url": "https://files.pythonhosted.org/packages/67/83/181631b6a10945d8f3fb0097df1b04baa213de430f11ff83fdf475cec5e7/cs.binary-20180823.tar.gz", "yanked": false}], "20181108": [{"comment_text": "", "digests": {"md5": "7085c1f8b8d3300c3fefd713f1d47b70", "sha256": "19391685a31b751e13a5bacfdc5e4c6ff859d5cf5ef0ccea94da4b9c05d200af"}, "downloads": -1, "filename": "cs.binary-20181108.tar.gz", "has_sig": false, "md5_digest": "7085c1f8b8d3300c3fefd713f1d47b70", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14217, "upload_time": "2018-11-08T03:55:01", "upload_time_iso_8601": "2018-11-08T03:55:01.128696Z", "url": "https://files.pythonhosted.org/packages/de/9c/3e95b0cf82d389d117659bd62a0f19831414e960e8ca59ae4439e0e8066d/cs.binary-20181108.tar.gz", "yanked": false}], "20181231": [{"comment_text": "", "digests": {"md5": "1bc62cca3ea3b06d58c0e4c1f6d1aec4", "sha256": "f1b150dd903c3ea5fa880f0c421aac876e676122857eda5e1316757dd61d1858"}, "downloads": -1, "filename": "cs.binary-20181231.tar.gz", "has_sig": false, "md5_digest": "1bc62cca3ea3b06d58c0e4c1f6d1aec4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14230, "upload_time": "2018-12-31T10:13:12", "upload_time_iso_8601": "2018-12-31T10:13:12.733923Z", "url": "https://files.pythonhosted.org/packages/7c/7b/bf932ba9ebb7742f90be39f5040505698178b383a17a896018ecfe337df3/cs.binary-20181231.tar.gz", "yanked": false}], "20190220": [{"comment_text": "", "digests": {"md5": "9a7821ece70f07ee8b6daed884ddc696", "sha256": "9983df2636babdd2078ccfd590c9580b77f1564a9c813142c013980ac3158889"}, "downloads": -1, "filename": "cs.binary-20190220.tar.gz", "has_sig": false, "md5_digest": "9a7821ece70f07ee8b6daed884ddc696", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15687, "upload_time": "2019-02-20T08:54:21", "upload_time_iso_8601": "2019-02-20T08:54:21.774160Z", "url": "https://files.pythonhosted.org/packages/bb/88/d00aa74118c8607e9a36875c785041ec1bf969217b7f81b00c802215f073/cs.binary-20190220.tar.gz", "yanked": false}], "20191230": [{"comment_text": "", "digests": {"md5": "2b59951d24a391fa75a963e062f50c78", "sha256": "0d808523478261fbb66ce4d63d9570e391e70d28f74b9ed2ab6c214358d24bb4"}, "downloads": -1, "filename": "cs.binary-20191230.tar.gz", "has_sig": false, "md5_digest": "2b59951d24a391fa75a963e062f50c78", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23520, "upload_time": "2019-12-30T02:22:47", "upload_time_iso_8601": "2019-12-30T02:22:47.967575Z", "url": "https://files.pythonhosted.org/packages/84/8e/2d3566df6423245e0a49333ec006fd01b4f497265c0569a17d8bd59c3ee8/cs.binary-20191230.tar.gz", "yanked": false}], "20191230.1": [{"comment_text": "", "digests": {"md5": "fe0a9720993d47f96d06c4fcd8d49dae", "sha256": "06226e3fe7aa03733d7aca6f9f0412f5c360b97d61a8275d500b462d530738b9"}, "downloads": -1, "filename": "cs.binary-20191230.1.tar.gz", "has_sig": false, "md5_digest": "fe0a9720993d47f96d06c4fcd8d49dae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23621, "upload_time": "2019-12-30T02:48:07", "upload_time_iso_8601": "2019-12-30T02:48:07.957161Z", "url": "https://files.pythonhosted.org/packages/96/6a/1fd1a5d577f9e141bcb031c284238eda920538b9d8bab6353318a7aea6f7/cs.binary-20191230.1.tar.gz", "yanked": false}], "20191230.2": [{"comment_text": "", "digests": {"md5": "968869f6c1b22de2e2a76939abb19452", "sha256": "fef56abbf6a065ca62d60c24d60765f1fac86334ff44ecc2203c2abbce2466e7"}, "downloads": -1, "filename": "cs.binary-20191230.2.tar.gz", "has_sig": false, "md5_digest": "968869f6c1b22de2e2a76939abb19452", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23883, "upload_time": "2019-12-30T04:18:18", "upload_time_iso_8601": "2019-12-30T04:18:18.471415Z", "url": "https://files.pythonhosted.org/packages/51/4f/20703100a5cf11d02097008b281c9d39ae9ca8244a759ec730c77c355a2b/cs.binary-20191230.2.tar.gz", "yanked": false}], "20191230.3": [{"comment_text": "", "digests": {"md5": "078943b56298d1e63a2f4d751ce358d9", "sha256": "c44c4cad674db711bdbb0d0952c7cd1dffbdeb824661b3ffde8780009e979599"}, "downloads": -1, "filename": "cs.binary-20191230.3.tar.gz", "has_sig": false, "md5_digest": "078943b56298d1e63a2f4d751ce358d9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23910, "upload_time": "2019-12-30T04:21:00", "upload_time_iso_8601": "2019-12-30T04:21:00.280662Z", "url": "https://files.pythonhosted.org/packages/7d/db/efb104b26bffa7e729ab05d8275c50b3a48e9c9456cf9e34c90a2a7dd4dd/cs.binary-20191230.3.tar.gz", "yanked": false}], "20200229": [{"comment_text": "", "digests": {"md5": "41653df7a025d7739de4eaf9b97ee80c", "sha256": "3af805697f3c308e261056d4c806bb9a86eaafc85568cf4a9ef4f5748c85859d"}, "downloads": -1, "filename": "cs.binary-20200229.tar.gz", "has_sig": false, "md5_digest": "41653df7a025d7739de4eaf9b97ee80c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25098, "upload_time": "2020-02-29T05:01:02", "upload_time_iso_8601": "2020-02-29T05:01:02.625320Z", "url": "https://files.pythonhosted.org/packages/bf/1d/bd7ed9a41072fa2589a9b07e77133593faac3fd3a24c70845209a3285326/cs.binary-20200229.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "41653df7a025d7739de4eaf9b97ee80c", "sha256": "3af805697f3c308e261056d4c806bb9a86eaafc85568cf4a9ef4f5748c85859d"}, "downloads": -1, "filename": "cs.binary-20200229.tar.gz", "has_sig": false, "md5_digest": "41653df7a025d7739de4eaf9b97ee80c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25098, "upload_time": "2020-02-29T05:01:02", "upload_time_iso_8601": "2020-02-29T05:01:02.625320Z", "url": "https://files.pythonhosted.org/packages/bf/1d/bd7ed9a41072fa2589a9b07e77133593faac3fd3a24c70845209a3285326/cs.binary-20200229.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:41:52 2020"}