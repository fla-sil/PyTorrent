{"info": {"author": "Vahid Mardani", "author_email": "vahid.mardani@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Natural Language :: English", "Operating System :: Unix", "Programming Language :: Cython", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation :: CPython", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: System :: Hardware"], "description": "\n\naiolirc\n=======\n\n\n.. image:: http://img.shields.io/pypi/v/aiolirc.svg\n     :target: https://pypi.python.org/pypi/aiolirc\n\n.. image:: https://img.shields.io/badge/license-GPLv3-brightgreen.svg\n     :target: https://github.com/pylover/aiolirc/blob/master/LICENSE\n\n\nJump To\n-------\n\n * `Documentation <http://aiolirc.dobisel.com>`_\n * `Python package index <https://pypi.python.org/pypi/aiolirc>`_\n * `Source on github <https://github.com/pylover/aiolirc>`_\n * `Downloads <https://pypi.python.org/pypi/aiolirc#downloads>`_\n\n\nAbout\n-----\n\nAsynchronous messaging using python's new facility(async-await syntax), introduced in version 3.5 is so fun!\n\nSo, I decided to provide an asynchronous context manager and iterator wrapper for \n`Linux Infra-Red Remote Control(LIRC) <http://www.lirc.org/>`_.\n\nHappily, the Cython is working well with asyncio. So the `lirc_client` C extension has been made by cython's extenstion\ntype. \n\nIn addition, an `IRCDispatcher` type and a `listen_for` decorator have been provided.\n\nInstall\n-------\n\n::\n\n     $ apt-get install liblircclient-dev python3.5-dev build-essential\n     $ pip install cython\n     $ pip install aiolirc\n\n\nQuick Start\n-----------\n\nThe simplest way to use this library is the famous `very_quickstart` function as follows::\n\n    from aiolirc import very_quickstart, listen_for\n\n    @listen_for('play')\n    async def do_play(loop):\n        ...\n        # Do play stuff\n\n    very_quickstart('my-prog')  # my-prog is configured in your lircrc file.\n\n\nAnother coroutine function named `quickstart` is also available.This lets you have control over the event loop \nlife-cycle::\n\n    import asyncio\n    from aiolirc import quickstart\n\n    main_loop = asyncio.get_event_loop()\n    try:\n        main_loop.run_until_complete(quickstart(loop=main_loop))\n    except KeyboardInterrupt:\n        print('CTRL+C detected. terminating...')\n        return 1\n    finally:\n        if not main_loop.is_closed():\n            main_loop.close()\n\n\nThe `IRCDispatcher`\n-------------------\n    \nConstructor\n^^^^^^^^^^^\n\n::\n\n    def __init__(self, source: LIRCClient, loop: asyncio.BaseEventLoop=None):\n\n\nExample of usage\n^^^^^^^^^^^^^^^^\n::\n\n\n    import asyncio\n    \n    from aiolirc.lirc_client import LIRCClient\n    from aiolirc.dispatcher import IRCDispatcher, listen_for\n\n    @listen_for('amp power', repeat=5)\n    async def amp_power(loop):\n        ...\n        # Do your stuff\n\n    @listen_for('amp source')\n    async def amp_source(loop):\n        ...\n        # Do your stuff\n                        \n\n    async with LIRCClient('my-prog') as client:\n        dispatcher = IRCDispatcher(client)\n        await dispatcher.listen()\n\n\nThe `LIRCClient`\n----------------\n\nConstructor\n^^^^^^^^^^^\n::\n\n    def __cinit__(self, lircrc_prog, *, lircrc_file='~/.config/lircrc', loop=None, check_interval=.05, verbose=False, \n        blocking=False):\n\nTo advance control over the messages received from lirc, asychronously iter over an instance of the `LIRCClient` after\ncalling `LIRCClient.lirc_init()`. And make sure the `LIRCClient.lirc_deinit()` has been called after finishing your work\nwith `LIRCClient`::\n\n    from aiolirc.lirc_client import LIRCClient\n\n    client = LIRCClient('my-prog')\n    try:\n        client.lirc_init()\n        async for cmd in client:\n            print(cmd)\n    finally:\n        client.lirc_deinit()\n        \n\n\nYou may use the `LIRCClient` as an asynchronous context manager as described as follows, to automatically call the \n`LIRCClient.lirc_init()` and `LIRCClient.lirc_deinit()` functions, and also acquiring a lock to prevent multiple \ninstances of the `LIRCClient` from reading messages from lirc_client wrapper::\n\n    from aiolirc.lirc_client import LIRCClient\n \n    async with LIRCClient('my-prog') as client:\n        async for cmd in client:\n            print(cmd)\n        \n\nSystemd\n-------\n\nCreate a main.py::\n\n     import sys\n     import asyncio\n     \n     from aiolirc import IRCDispatcher, LIRCClient\n\n     async def launch(self) -> int:\n\n         async with LIRCClient('my-prog', lircrc_file='path/to/lircrc', check_interval=.06) as client:\n             dispatcher = IRCDispatcher(client)\n             result = (await asyncio.gather(dispatcher.listen(), return_exceptions=True))[0]\n\n         if isinstance(result, Exception):\n             raise result\n             \n         return 0\n    \n     def main(self):\n          \n         main_loop = asyncio.get_event_loop()\n         try:\n             return main_loop.run_until_complete(launch())\n         except KeyboardInterrupt:\n             print('CTRL+C detected.')\n             return 1\n         finally:\n             if not main_loop.is_closed():\n                 main_loop.close()\n                 \n     if __name__ == '__main__':\n         sys.exit(main())\n\n\n`/etc/systemd/system/aiolirc.service` file::\n\n     [Unit]\n     Description=aiolirc\n     \n     [Service]\n     ExecStart=python3.5 /path/to/main.py\n     User=user\n     Group=group\n     \n     [Install]\n     WantedBy=multi-user.target\n     \nsystemctl::\n\n     $ systemctl enable aiolirc\n     $ systemctl start aiolirc\n     $ systemctl restart aiolirc\n     \n     $ ps -Af | grep 'main.py'\n     \n     $ systemctl stop aiolirc\n\nChange Log\n----------\n\n**0.1.0**\n\n   - README.rst\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://aiolirc.dobisel.com", "keywords": "lirc asyncio extension", "license": "GPLv3", "maintainer": "", "maintainer_email": "", "name": "aiolirc", "package_url": "https://pypi.org/project/aiolirc/", "platform": "", "project_url": "https://pypi.org/project/aiolirc/", "project_urls": {"Homepage": "http://aiolirc.dobisel.com"}, "release_url": "https://pypi.org/project/aiolirc/0.1.2/", "requires_dist": null, "requires_python": "", "summary": "lirc python extension for asyncio", "version": "0.1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://pypi.python.org/pypi/aiolirc\" rel=\"nofollow\"><img alt=\"http://img.shields.io/pypi/v/aiolirc.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2cbfb56b32b94f87f424bd1f6d0070f5b594648e/687474703a2f2f696d672e736869656c64732e696f2f707970692f762f61696f6c6972632e737667\"></a>\n<a href=\"https://github.com/pylover/aiolirc/blob/master/LICENSE\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/license-GPLv3-brightgreen.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/96a38b96e9a7317680d6a5df4d2873358756aa6e/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d47504c76332d627269676874677265656e2e737667\"></a>\n<div id=\"jump-to\">\n<h2>Jump To</h2>\n<blockquote>\n<ul>\n<li><a href=\"http://aiolirc.dobisel.com\" rel=\"nofollow\">Documentation</a></li>\n<li><a href=\"https://pypi.python.org/pypi/aiolirc\" rel=\"nofollow\">Python package index</a></li>\n<li><a href=\"https://github.com/pylover/aiolirc\" rel=\"nofollow\">Source on github</a></li>\n<li><a href=\"https://pypi.python.org/pypi/aiolirc#downloads\" rel=\"nofollow\">Downloads</a></li>\n</ul>\n</blockquote>\n</div>\n<div id=\"about\">\n<h2>About</h2>\n<p>Asynchronous messaging using python\u2019s new facility(async-await syntax), introduced in version 3.5 is so fun!</p>\n<p>So, I decided to provide an asynchronous context manager and iterator wrapper for\n<a href=\"http://www.lirc.org/\" rel=\"nofollow\">Linux Infra-Red Remote Control(LIRC)</a>.</p>\n<p>Happily, the Cython is working well with asyncio. So the <cite>lirc_client</cite> C extension has been made by cython\u2019s extenstion\ntype.</p>\n<p>In addition, an <cite>IRCDispatcher</cite> type and a <cite>listen_for</cite> decorator have been provided.</p>\n</div>\n<div id=\"install\">\n<h2>Install</h2>\n<pre>$ apt-get install liblircclient-dev python3.5-dev build-essential\n$ pip install cython\n$ pip install aiolirc\n</pre>\n</div>\n<div id=\"quick-start\">\n<h2>Quick Start</h2>\n<p>The simplest way to use this library is the famous <cite>very_quickstart</cite> function as follows:</p>\n<pre>from aiolirc import very_quickstart, listen_for\n\n@listen_for('play')\nasync def do_play(loop):\n    ...\n    # Do play stuff\n\nvery_quickstart('my-prog')  # my-prog is configured in your lircrc file.\n</pre>\n<p>Another coroutine function named <cite>quickstart</cite> is also available.This lets you have control over the event loop\nlife-cycle:</p>\n<pre>import asyncio\nfrom aiolirc import quickstart\n\nmain_loop = asyncio.get_event_loop()\ntry:\n    main_loop.run_until_complete(quickstart(loop=main_loop))\nexcept KeyboardInterrupt:\n    print('CTRL+C detected. terminating...')\n    return 1\nfinally:\n    if not main_loop.is_closed():\n        main_loop.close()\n</pre>\n</div>\n<div id=\"the-ircdispatcher\">\n<h2>The <cite>IRCDispatcher</cite></h2>\n<div id=\"constructor\">\n<h3>Constructor</h3>\n<pre>def __init__(self, source: LIRCClient, loop: asyncio.BaseEventLoop=None):\n</pre>\n</div>\n<div id=\"example-of-usage\">\n<h3>Example of usage</h3>\n<pre>import asyncio\n\nfrom aiolirc.lirc_client import LIRCClient\nfrom aiolirc.dispatcher import IRCDispatcher, listen_for\n\n@listen_for('amp power', repeat=5)\nasync def amp_power(loop):\n    ...\n    # Do your stuff\n\n@listen_for('amp source')\nasync def amp_source(loop):\n    ...\n    # Do your stuff\n\n\nasync with LIRCClient('my-prog') as client:\n    dispatcher = IRCDispatcher(client)\n    await dispatcher.listen()\n</pre>\n</div>\n</div>\n<div id=\"the-lircclient\">\n<h2>The <cite>LIRCClient</cite></h2>\n<h2 id=\"id1\"><span class=\"section-subtitle\">Constructor</span></h2>\n<pre>def __cinit__(self, lircrc_prog, *, lircrc_file='~/.config/lircrc', loop=None, check_interval=.05, verbose=False,\n    blocking=False):\n</pre>\n<p>To advance control over the messages received from lirc, asychronously iter over an instance of the <cite>LIRCClient</cite> after\ncalling <cite>LIRCClient.lirc_init()</cite>. And make sure the <cite>LIRCClient.lirc_deinit()</cite> has been called after finishing your work\nwith <cite>LIRCClient</cite>:</p>\n<pre>from aiolirc.lirc_client import LIRCClient\n\nclient = LIRCClient('my-prog')\ntry:\n    client.lirc_init()\n    async for cmd in client:\n        print(cmd)\nfinally:\n    client.lirc_deinit()\n</pre>\n<p>You may use the <cite>LIRCClient</cite> as an asynchronous context manager as described as follows, to automatically call the\n<cite>LIRCClient.lirc_init()</cite> and <cite>LIRCClient.lirc_deinit()</cite> functions, and also acquiring a lock to prevent multiple\ninstances of the <cite>LIRCClient</cite> from reading messages from lirc_client wrapper:</p>\n<pre>from aiolirc.lirc_client import LIRCClient\n\nasync with LIRCClient('my-prog') as client:\n    async for cmd in client:\n        print(cmd)\n</pre>\n</div>\n<div id=\"systemd\">\n<h2>Systemd</h2>\n<p>Create a main.py:</p>\n<pre>import sys\nimport asyncio\n\nfrom aiolirc import IRCDispatcher, LIRCClient\n\nasync def launch(self) -&gt; int:\n\n    async with LIRCClient('my-prog', lircrc_file='path/to/lircrc', check_interval=.06) as client:\n        dispatcher = IRCDispatcher(client)\n        result = (await asyncio.gather(dispatcher.listen(), return_exceptions=True))[0]\n\n    if isinstance(result, Exception):\n        raise result\n\n    return 0\n\ndef main(self):\n\n    main_loop = asyncio.get_event_loop()\n    try:\n        return main_loop.run_until_complete(launch())\n    except KeyboardInterrupt:\n        print('CTRL+C detected.')\n        return 1\n    finally:\n        if not main_loop.is_closed():\n            main_loop.close()\n\nif __name__ == '__main__':\n    sys.exit(main())\n</pre>\n<p><cite>/etc/systemd/system/aiolirc.service</cite> file:</p>\n<pre>[Unit]\nDescription=aiolirc\n\n[Service]\nExecStart=python3.5 /path/to/main.py\nUser=user\nGroup=group\n\n[Install]\nWantedBy=multi-user.target\n</pre>\n<p>systemctl:</p>\n<pre>$ systemctl enable aiolirc\n$ systemctl start aiolirc\n$ systemctl restart aiolirc\n\n$ ps -Af | grep 'main.py'\n\n$ systemctl stop aiolirc\n</pre>\n</div>\n<div id=\"change-log\">\n<h2>Change Log</h2>\n<p><strong>0.1.0</strong></p>\n<blockquote>\n<ul>\n<li>README.rst</li>\n</ul>\n</blockquote>\n</div>\n\n          </div>"}, "last_serial": 2362897, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "b0a566c07f6b868e91110d6df2e12e53", "sha256": "03d7cf648c9b4ab78ce8d7990792425b70c4b5d1a0a5c301cb415a6c7f3838b9"}, "downloads": -1, "filename": "aiolirc-0.1.0.tar.gz", "has_sig": false, "md5_digest": "b0a566c07f6b868e91110d6df2e12e53", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58757, "upload_time": "2016-09-25T17:34:46", "upload_time_iso_8601": "2016-09-25T17:34:46.194661Z", "url": "https://files.pythonhosted.org/packages/3e/bb/955716e308d7eeeedf2e353f8f20fa7cd59693fb97731acb4c08e6229fc1/aiolirc-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "39ea8b11796e290314d03e447f8b3286", "sha256": "93180998b8739a32b3e2994748c0c70ab23ada13b11797619fed31251c90d4c1"}, "downloads": -1, "filename": "aiolirc-0.1.1.tar.gz", "has_sig": false, "md5_digest": "39ea8b11796e290314d03e447f8b3286", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58673, "upload_time": "2016-09-25T17:49:50", "upload_time_iso_8601": "2016-09-25T17:49:50.415549Z", "url": "https://files.pythonhosted.org/packages/de/53/4e89db4f26b6de00bf6f0f18d442e4a44e6696a219d41aeefd0b4379c877/aiolirc-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "554ff8defd7b34d934d280184f2fae11", "sha256": "137542f8dc3d56742746deeeeb5091eca711bd681af9aae12f178c2b8b989757"}, "downloads": -1, "filename": "aiolirc-0.1.2.tar.gz", "has_sig": false, "md5_digest": "554ff8defd7b34d934d280184f2fae11", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 61526, "upload_time": "2016-09-25T19:51:28", "upload_time_iso_8601": "2016-09-25T19:51:28.538585Z", "url": "https://files.pythonhosted.org/packages/44/82/5886ffc986eed77e957cd37cd7fbda095f8aca113c674000f00921127726/aiolirc-0.1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "554ff8defd7b34d934d280184f2fae11", "sha256": "137542f8dc3d56742746deeeeb5091eca711bd681af9aae12f178c2b8b989757"}, "downloads": -1, "filename": "aiolirc-0.1.2.tar.gz", "has_sig": false, "md5_digest": "554ff8defd7b34d934d280184f2fae11", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 61526, "upload_time": "2016-09-25T19:51:28", "upload_time_iso_8601": "2016-09-25T19:51:28.538585Z", "url": "https://files.pythonhosted.org/packages/44/82/5886ffc986eed77e957cd37cd7fbda095f8aca113c674000f00921127726/aiolirc-0.1.2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:21:08 2020"}