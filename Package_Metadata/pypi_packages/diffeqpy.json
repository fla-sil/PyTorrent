{"info": {"author": "Chris Rackauckas and Takafumi Arakaki", "author_email": "contact@juliadiffeq.org", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.6", "Topic :: Scientific/Engineering :: Mathematics", "Topic :: Scientific/Engineering :: Physics"], "description": "# diffeqpy\n\n[![Join the chat at https://gitter.im/JuliaDiffEq/Lobby](https://badges.gitter.im/JuliaDiffEq/Lobby.svg)](https://gitter.im/JuliaDiffEq/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Build Status](https://travis-ci.org/JuliaDiffEq/diffeqpy.svg?branch=master)](https://travis-ci.org/JuliaDiffEq/diffeqpy)\n[![Build status](https://ci.appveyor.com/api/projects/status/4ybwcrgopv6wrno1?svg=true)](https://ci.appveyor.com/project/ChrisRackauckas/diffeqpy)\n\ndiffeqpy is a package for solving differential equations in Python. It utilizes\n[DifferentialEquations.jl](http://docs.juliadiffeq.org/latest/) for its core routines\nto give high performance solving of many different types of differential equations,\nincluding:\n\n- Discrete equations (function maps, discrete stochastic (Gillespie/Markov)\n  simulations)\n- Ordinary differential equations (ODEs)\n- Split and Partitioned ODEs (Symplectic integrators, IMEX Methods)\n- Stochastic ordinary differential equations (SODEs or SDEs)\n- Random differential equations (RODEs or RDEs)\n- Differential algebraic equations (DAEs)\n- Delay differential equations (DDEs)\n- Mixed discrete and continuous equations (Hybrid Equations, Jump Diffusions)\n\ndirectly in Python.\n\nIf you have any questions, or just want to chat about solvers/using the package,\nplease feel free to chat in the [Gitter channel](https://gitter.im/JuliaDiffEq/Lobby?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge). For bug reports, feature requests, etc., please submit an issue.\n\n## Installation\n\nTo install diffeqpy, use pip:\n\n```\npip install diffeqpy\n```\n\nUsing diffeqpy requires that Julia is installed and in the path, along\nwith DifferentialEquations.jl and PyCall.jl. To install Julia,\ndownload a generic binary from\n[the JuliaLang site](https://julialang.org/downloads/) and add it to your path.\nTo install Julia packages required for diffeqpy, open up Python\ninterpreter then run:\n\n```pycon\n>>> import diffeqpy\n>>> diffeqpy.install()\n```\n\nand you're good! In addition, to improve the performance of your code it is\nrecommended that you use Numba to JIT compile your derivative functions. To\ninstall Numba, use:\n\n```\npip install numba\n```\n\n## General Flow\n\nImport and setup the solvers via the commands:\n\n```py\nfrom diffeqpy import de\n```\n\nThe general flow for using the package is to follow exactly as would be done\nin Julia, except add `de.` in front.\nMost of the commands will work without any modification. Thus\n[the DifferentialEquations.jl documentation](https://github.com/JuliaDiffEq/DifferentialEquations.jl)\nand the [DiffEqTutorials](https://github.com/JuliaDiffEq/DiffEqTutorials.jl)\nare the main in-depth documentation for this package. Below we will show how to\ntranslate these docs to Python code.\n\n## Ordinary Differential Equation (ODE) Examples\n\n### One-dimensional ODEs\n\n```py\nfrom diffeqpy import de\n\ndef f(u,p,t):\n    return -u\n\nu0 = 0.5\ntspan = (0., 1.)\nprob = de.ODEProblem(f, u0, tspan)\nsol = de.solve(prob)\n```\n\nThe solution object is the same as the one described\n[in the DiffEq tutorials](http://docs.juliadiffeq.org/latest/tutorials/ode_example.html#Step-3:-Analyzing-the-Solution-1)\nand in the [solution handling documentation](http://docs.juliadiffeq.org/latest/basics/solution.html)\n(note: the array interface is missing). Thus for example the solution time points\nare saved in `sol.t` and the solution values are saved in `sol.u`. Additionally,\nthe interpolation `sol(t)` gives a continuous solution.\n\nWe can plot the solution values using matplotlib:\n\n```py\nimport matplotlib.pyplot as plt\nplt.plot(sol.t,sol.u)\nplt.show()\n```\n\n![f1](https://user-images.githubusercontent.com/1814174/39089385-e898e116-457a-11e8-84c6-fb1f4dd82c48.png)\n\nWe can utilize the interpolation to get a finer solution:\n\n```py\nimport numpy\nnumpy.linspace(0,1,100)\nu = sol(t)\nplt.plot(t,u)\nplt.show()\n```\n\n![f2](https://user-images.githubusercontent.com/1814174/39089386-e8affac2-457a-11e8-8c35-d0f039803ff8.png)\n\n### Solve commands\n\nThe [common interface arguments](http://docs.juliadiffeq.org/latest/basics/common_solver_opts.html)\ncan be used to control the solve command. For example, let's use `saveat` to\nsave the solution at every `t=0.1`, and let's utilize the `Vern9()` 9th order\nRunge-Kutta method along with low tolerances `abstol=reltol=1e-10`:\n\n```py\nsol = de.solve(prob,de.Vern9(),saveat=0.1,abstol=1e-10,reltol=1e-10)\n```\n\nThe set of algorithms for ODEs is described\n[at the ODE solvers page](http://docs.juliadiffeq.org/latest/solvers/ode_solve.html).\n\n### Compilation with Numba and Julia\n\nWhen solving a differential equation, it's pertinent that your derivative\nfunction `f` is fast since it occurs in the inner loop of the solver. We can\nutilize Numba to JIT compile our derivative functions to improve the efficiency\nof the solver:\n\n```py\nimport numba\nnumba_f = numba.jit(f)\n\nprob = de.ODEProblem(numba_f, u0, tspan)\nsol = de.solve(prob)\n```\n\nAdditionally, you can directly define the functions in Julia. This will allow\nfor more specialization and could be helpful to increase the efficiency over\nthe Numba version for repeat or long calls. This is done via `julia.Main.eval`:\n\n```py\nfrom julia import Main\njul_f = Main.eval(\"(u,p,t)->-u\") # Define the anonymous function in Julia\nprob = de.ODEProblem(jul_f, u0, tspan)\nsol = de.solve(prob)\n```\n\n### Systems of ODEs: Lorenz Equations\n\nTo solve systems of ODEs, simply use an array as your initial condition and\ndefine `f` as an array function:\n\n```py\ndef f(u,p,t):\n    x, y, z = u\n    sigma, rho, beta = p\n    return [sigma * (y - x), x * (rho - z) - y, x * y - beta * z]\n\nu0 = [1.0,0.0,0.0]\ntspan = (0., 100.)\np = [10.0,28.0,8/3]\nprob = de.ODEProblem(f, u0, tspan, p)\nsol = de.solve(prob,saveat=0.01)\n\nplt.plot(sol.t,sol.u)\nplt.show()\n```\n\n![f3](https://user-images.githubusercontent.com/1814174/39089387-e8c5d9d2-457a-11e8-8f77-eecfc955ce27.png)\n\nor we can draw the phase plot:\n\n```py\nut = numpy.transpose(sol.u)\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot(ut[0,:],ut[1,:],ut[2,:])\nplt.show()\n```\n\n![f4](https://user-images.githubusercontent.com/1814174/39089388-e8dae00c-457a-11e8-879f-8b01e0b47178.png)\n\n### In-Place Mutating Form\n\nWhen dealing with systems of equations, in many cases it's helpful to reduce\nmemory allocations by using mutating functions. In diffeqpy, the mutating\nform adds the mutating vector to the front. Let's make a fast version of the\nLorenz derivative, i.e. mutating and JIT compiled:\n\n```py\ndef f(du,u,p,t):\n    x, y, z = u\n    sigma, rho, beta = p\n    du[0] = sigma * (y - x)\n    du[1] = x * (rho - z) - y\n    du[2] = x * y - beta * z\n\nnumba_f = numba.jit(f)\nu0 = [1.0,0.0,0.0]\ntspan = (0., 100.)\np = [10.0,28.0,2.66]\nprob = de.ODEProblem(numba_f, u0, tspan, p)\nsol = de.solve(prob)\n```\n\nor using a Julia function:\n\n```py\njul_f = Main.eval(\"\"\"\nfunction f(du,u,p,t)\n  x, y, z = u\n  sigma, rho, beta = p\n  du[1] = sigma * (y - x)\n  du[2] = x * (rho - z) - y\n  du[3] = x * y - beta * z\nend\"\"\")\nu0 = [1.0,0.0,0.0]\ntspan = (0., 100.)\np = [10.0,28.0,2.66]\nprob = de.ODEProblem(jul_f, u0, tspan, p)\nsol = de.solve(prob)\n```\n\n## Stochastic Differential Equation (SDE) Examples\n\n### One-dimensional SDEs\n\nSolving one-dimensonal SDEs `du = f(u,t)dt + g(u,t)dW_t` is like an ODE except\nwith an extra function for the diffusion (randomness or noise) term. The steps\nfollow the [SDE tutorial](http://docs.juliadiffeq.org/latest/tutorials/sde_example.html).\n\n```py\ndef f(u,p,t):\n  return 1.01*u\n\ndef g(u,p,t):\n  return 0.87*u\n\nu0 = 0.5\ntspan = (0.0,1.0)\nprob = de.SDEProblem(f,g,u0,tspan)\nsol = de.solve(prob,reltol=1e-3,abstol=1e-3)\n\nplt.plot(sol.t,sol.u)\nplt.show()\n```\n\n![f5](https://user-images.githubusercontent.com/1814174/39089389-e8f0343e-457a-11e8-87bb-9ed152caee02.png)\n\n### Systems of SDEs with Diagonal Noise\n\nAn SDE with diagonal noise is where a different Wiener process is applied to\nevery part of the system. This is common for models with phenomenological noise.\nLet's add multiplicative noise to the Lorenz equation:\n\n```py\ndef f(du,u,p,t):\n    x, y, z = u\n    sigma, rho, beta = p\n    du[0] = sigma * (y - x)\n    du[1] = x * (rho - z) - y\n    du[2] = x * y - beta * z\n\ndef g(du,u,p,t):\n    du[0] = 0.3*u[0]\n    du[1] = 0.3*u[1]\n    du[2] = 0.3*u[2]\n\nnumba_f = numba.jit(f)\nnumba_g = numba.jit(g)\nu0 = [1.0,0.0,0.0]\ntspan = (0., 100.)\np = [10.0,28.0,2.66]\nprob = de.SDEProblem(numba_f, numba_g, u0, tspan, p)\nsol = de.solve(prob)\n\n# Now let's draw a phase plot\n\nut = numpy.transpose(sol.u)\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot(ut[0,:],ut[1,:],ut[2,:])\nplt.show()\n```\n\n![f6](https://user-images.githubusercontent.com/1814174/39089390-e906c1ea-457a-11e8-8fd2-5cf059e2165a.png)\n\n### Systems of SDEs with Non-Diagonal Noise\n\nIn many cases you may want to share noise terms across the system. This is\nknown as non-diagonal noise. The\n[DifferentialEquations.jl SDE Tutorial](http://docs.juliadiffeq.org/latest/tutorials/sde_example.html#Example-4:-Systems-of-SDEs-with-Non-Diagonal-Noise-1)\nexplains how the matrix form of the diffusion term corresponds to the\nsummation style of multiple Wiener processes. Essentially, the row corresponds\nto which system the term is applied to, and the column is which noise term.\nSo `du[i,j]` is the amount of noise due to the `j`th Wiener process that's\napplied to `u[i]`. We solve the Lorenz system with correlated noise as follows:\n\n```py\ndef f(du,u,p,t):\n  x, y, z = u\n  sigma, rho, beta = p\n  du[0] = sigma * (y - x)\n  du[1] = x * (rho - z) - y\n  du[2] = x * y - beta * z\n\ndef g(du,u,p,t):\n  du[0,0] = 0.3*u[0]\n  du[1,0] = 0.6*u[0]\n  du[2,0] = 0.2*u[0]\n  du[0,1] = 1.2*u[1]\n  du[1,1] = 0.2*u[1]\n  du[2,1] = 0.3*u[1]\n\n\nu0 = [1.0,0.0,0.0]\ntspan = (0.0,100.0)\np = [10.0,28.0,2.66]\nnrp = numpy.zeros((3,2))\nnumba_f = numba.jit(f)\nnumba_g = numba.jit(g)\nprob = de.SDEProblem(numba_f,numba_g,u0,tspan,p,noise_rate_prototype=nrp)\nsol = de.solve(prob,saveat=0.005)\n\n# Now let's draw a phase plot\n\nut = numpy.transpose(sol.u)\nfrom mpl_toolkits.mplot3d import Axes3D\nfig = plt.figure()\nax = fig.add_subplot(111, projection='3d')\nax.plot(ut[0,:],ut[1,:],ut[2,:])\nplt.show()\n```\n\n![f7](https://user-images.githubusercontent.com/1814174/39089391-e91f0494-457a-11e8-860a-865caa26c262.png)\n\nHere you can see that the warping effect of the noise correlations is quite visible!\n\n## Differential-Algebraic Equation (DAE) Examples\n\nA differential-algebraic equation is defined by an implicit function\n`f(du,u,p,t)=0`. All of the controls are the same as the other examples, except\nhere you define a function which returns the residuals for each part of the\nequation to define the DAE. The initial value `u0` and the initial derivative\n`du0` are required, though they do not necessarily have to satisfy `f` (known\nas inconsistent initial conditions). The methods will automatically find\nconsistent initial conditions. In order for this to occur, `differential_vars`\nmust be set. This vector states which of the variables are differential (have a\nderivative term), with `false` meaning that the variable is purely algebraic.\n\nThis example shows how to solve the Robertson equation:\n\n```py\ndef f(du,u,p,t):\n  resid1 = - 0.04*u[0]               + 1e4*u[1]*u[2] - du[0]\n  resid2 = + 0.04*u[0] - 3e7*u[1]**2 - 1e4*u[1]*u[2] - du[1]\n  resid3 = u[0] + u[1] + u[2] - 1.0\n  return [resid1,resid2,resid3]\n\nu0 = [1.0, 0.0, 0.0]\ndu0 = [-0.04, 0.04, 0.0]\ntspan = (0.0,100000.0)\ndifferential_vars = [True,True,False]\nprob = de.DAEProblem(f,du0,u0,tspan,differential_vars=differential_vars)\nsol = de.solve(prob)\n```\n\n![f8](https://user-images.githubusercontent.com/1814174/39089392-e932f012-457a-11e8-9979-c006bcfabf71.png)\n\nand the in-place JIT compiled form:\n\n```py\ndef f(resid,du,u,p,t):\n  resid[0] = - 0.04*u[0]               + 1e4*u[1]*u[2] - du[0]\n  resid[1] = + 0.04*u[0] - 3e7*u[1]**2 - 1e4*u[1]*u[2] - du[1]\n  resid[2] = u[0] + u[1] + u[2] - 1.0\n\nnumba_f = numba.jit(f)\nprob = de.DAEProblem(numba_f,du0,u0,tspan,differential_vars=differential_vars)\nsol = de.solve(prob)\n```\n\n## Delay Differential Equations\n\nA delay differential equation is an ODE which allows the use of previous values.\nIn this case, the function needs to be a JIT compiled Julia function. It looks\njust like the ODE, except in this case there is a function `h(p,t)` which allows\nyou to interpolate and grab previous values.\n\nWe must provide a history function `h(p,t)` that gives values for `u` before `t0`.\nHere we assume that the solution was constant before the initial time point.\nAdditionally, we pass `constant_lags = [20.0]` to tell the solver that only\nconstant-time lags were used and what the lag length was. This helps improve\nthe solver accuracy by accurately stepping at the points of discontinuity.\nTogether this is:\n\n```py\nf = Main.eval(\"\"\"\nfunction f(du, u, h, p, t)\n  du[1] = 1.1/(1 + sqrt(10)*(h(p, t-20)[1])^(5/4)) - 10*u[1]/(1 + 40*u[2])\n  du[2] = 100*u[1]/(1 + 40*u[2]) - 2.43*u[2]\nend\"\"\")\nu0 = [1.05767027/3, 1.030713491/3]\n\nh = Main.eval(\"\"\"\nfunction h(p,t)\n  [1.05767027/3, 1.030713491/3]\nend\n\"\"\")\n\ntspan = (0.0, 100.0)\nconstant_lags = [20.0]\nprob = de.DDEProblem(f,u0,h,tspan,constant_lags=constant_lags)\nsol = de.solve(prob,saveat=0.1)\n\nu1 = [sol.u[i][0] for i in range(0,len(sol.u))]\nu2 = [sol.u[i][1] for i in range(0,len(sol.u))]\n\nimport matplotlib.pyplot as plt\nplt.plot(sol.t,u1)\nplt.plot(sol.t,u2)\nplt.show()\n```\n\n![dde](https://user-images.githubusercontent.com/1814174/39229670-815f2eba-4818-11e8-9ba3-a4f61cc845c5.png)\n\nNotice that the solver accurately is able to simulate the kink (discontinuity)\nat `t=20` due to the discontinuity of the derivative at the initial time point!\nThis is why declaring discontinuities can enhance the solver accuracy.\n\n## Known Limitations\n\n- Autodiff does not work on Python functions. When applicable, either define the derivative function\n  as a Julia function or set the algorithm to use finite differencing, i.e. `Rodas5(autodiff=false)`.\n  All default methods use autodiff.\n- Delay differential equations have to use Julia-defined functions otherwise the history function is\n  not appropriately typed with the overloads.\n\n## Testing\n\nUnit tests can be run by [`tox`](http://tox.readthedocs.io).\n\n```sh\ntox                # test with Python 3.6 and 2.7\ntox -e py36        # test only with Python 3.6\n```\n\n### Troubleshooting\n\nIn case you encounter silent failure from `tox`, try running it with\n`-- -s` (e.g., `tox -e py36 -- -s`) where `-s` option (`--capture=no`,\ni.e., don't capture stdio) is passed to `py.test`.  It may show an\nerror message `\"error initializing LibGit2 module\"`.  In this case,\nsetting environment variable `SSL_CERT_FILE` may help; e.g., try:\n\n```sh\nSSL_CERT_FILE=PATH/TO/cert.pem tox -e py36\n```\n\nSee also: [julia#18693](https://github.com/JuliaLang/julia/issues/18693).\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/JuliaDiffEq/diffeqpy", "keywords": "differential equations stochastic ordinary delay differential-algebraic dae ode sde dde", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "diffeqpy", "package_url": "https://pypi.org/project/diffeqpy/", "platform": "", "project_url": "https://pypi.org/project/diffeqpy/", "project_urls": {"Homepage": "http://github.com/JuliaDiffEq/diffeqpy"}, "release_url": "https://pypi.org/project/diffeqpy/1.1.0/", "requires_dist": ["julia (>=0.2)"], "requires_python": "", "summary": "Solving Differential Equations in Python", "version": "1.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>diffeqpy</h1>\n<p><a href=\"https://gitter.im/JuliaDiffEq/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge\" rel=\"nofollow\"><img alt=\"Join the chat at https://gitter.im/JuliaDiffEq/Lobby\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e59ca5f4af535aa5791a409ef6e20f224b746b08/68747470733a2f2f6261646765732e6769747465722e696d2f4a756c69614469666645712f4c6f6262792e737667\"></a>\n<a href=\"https://travis-ci.org/JuliaDiffEq/diffeqpy\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2deb21caa4f5f904a8f6bb0a7f63ea4a4fa0fcb3/68747470733a2f2f7472617669732d63692e6f72672f4a756c69614469666645712f64696666657170792e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://ci.appveyor.com/project/ChrisRackauckas/diffeqpy\" rel=\"nofollow\"><img alt=\"Build status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b3e32e53183baf2d82162548ec23202989ca8792/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f347962776372676f70763677726e6f313f7376673d74727565\"></a></p>\n<p>diffeqpy is a package for solving differential equations in Python. It utilizes\n<a href=\"http://docs.juliadiffeq.org/latest/\" rel=\"nofollow\">DifferentialEquations.jl</a> for its core routines\nto give high performance solving of many different types of differential equations,\nincluding:</p>\n<ul>\n<li>Discrete equations (function maps, discrete stochastic (Gillespie/Markov)\nsimulations)</li>\n<li>Ordinary differential equations (ODEs)</li>\n<li>Split and Partitioned ODEs (Symplectic integrators, IMEX Methods)</li>\n<li>Stochastic ordinary differential equations (SODEs or SDEs)</li>\n<li>Random differential equations (RODEs or RDEs)</li>\n<li>Differential algebraic equations (DAEs)</li>\n<li>Delay differential equations (DDEs)</li>\n<li>Mixed discrete and continuous equations (Hybrid Equations, Jump Diffusions)</li>\n</ul>\n<p>directly in Python.</p>\n<p>If you have any questions, or just want to chat about solvers/using the package,\nplease feel free to chat in the <a href=\"https://gitter.im/JuliaDiffEq/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge\" rel=\"nofollow\">Gitter channel</a>. For bug reports, feature requests, etc., please submit an issue.</p>\n<h2>Installation</h2>\n<p>To install diffeqpy, use pip:</p>\n<pre><code>pip install diffeqpy\n</code></pre>\n<p>Using diffeqpy requires that Julia is installed and in the path, along\nwith DifferentialEquations.jl and PyCall.jl. To install Julia,\ndownload a generic binary from\n<a href=\"https://julialang.org/downloads/\" rel=\"nofollow\">the JuliaLang site</a> and add it to your path.\nTo install Julia packages required for diffeqpy, open up Python\ninterpreter then run:</p>\n<pre><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">diffeqpy</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">diffeqpy</span><span class=\"o\">.</span><span class=\"n\">install</span><span class=\"p\">()</span>\n</pre>\n<p>and you're good! In addition, to improve the performance of your code it is\nrecommended that you use Numba to JIT compile your derivative functions. To\ninstall Numba, use:</p>\n<pre><code>pip install numba\n</code></pre>\n<h2>General Flow</h2>\n<p>Import and setup the solvers via the commands:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">diffeqpy</span> <span class=\"kn\">import</span> <span class=\"n\">de</span>\n</pre>\n<p>The general flow for using the package is to follow exactly as would be done\nin Julia, except add <code>de.</code> in front.\nMost of the commands will work without any modification. Thus\n<a href=\"https://github.com/JuliaDiffEq/DifferentialEquations.jl\" rel=\"nofollow\">the DifferentialEquations.jl documentation</a>\nand the <a href=\"https://github.com/JuliaDiffEq/DiffEqTutorials.jl\" rel=\"nofollow\">DiffEqTutorials</a>\nare the main in-depth documentation for this package. Below we will show how to\ntranslate these docs to Python code.</p>\n<h2>Ordinary Differential Equation (ODE) Examples</h2>\n<h3>One-dimensional ODEs</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">diffeqpy</span> <span class=\"kn\">import</span> <span class=\"n\">de</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">u</span>\n\n<span class=\"n\">u0</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>\n<span class=\"n\">tspan</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">)</span>\n<span class=\"n\">prob</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">ODEProblem</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">u0</span><span class=\"p\">,</span> <span class=\"n\">tspan</span><span class=\"p\">)</span>\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">)</span>\n</pre>\n<p>The solution object is the same as the one described\n<a href=\"http://docs.juliadiffeq.org/latest/tutorials/ode_example.html#Step-3:-Analyzing-the-Solution-1\" rel=\"nofollow\">in the DiffEq tutorials</a>\nand in the <a href=\"http://docs.juliadiffeq.org/latest/basics/solution.html\" rel=\"nofollow\">solution handling documentation</a>\n(note: the array interface is missing). Thus for example the solution time points\nare saved in <code>sol.t</code> and the solution values are saved in <code>sol.u</code>. Additionally,\nthe interpolation <code>sol(t)</code> gives a continuous solution.</p>\n<p>We can plot the solution values using matplotlib:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">u</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p><img alt=\"f1\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5aee03bc823c136d4f45753a0de7f7f734415cec/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f313831343137342f33393038393338352d65383938653131362d343537612d313165382d383463362d6662316634646438326334382e706e67\"></p>\n<p>We can utilize the interpolation to get a finer solution:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span>\n<span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"n\">u</span> <span class=\"o\">=</span> <span class=\"n\">sol</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p><img alt=\"f2\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/01b8dfd3a4ab0438d2cd2b8350250bd37fce42d7/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f313831343137342f33393038393338362d65386166666163322d343537612d313165382d386333352d6430663033393830336666382e706e67\"></p>\n<h3>Solve commands</h3>\n<p>The <a href=\"http://docs.juliadiffeq.org/latest/basics/common_solver_opts.html\" rel=\"nofollow\">common interface arguments</a>\ncan be used to control the solve command. For example, let's use <code>saveat</code> to\nsave the solution at every <code>t=0.1</code>, and let's utilize the <code>Vern9()</code> 9th order\nRunge-Kutta method along with low tolerances <code>abstol=reltol=1e-10</code>:</p>\n<pre><span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">,</span><span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">Vern9</span><span class=\"p\">(),</span><span class=\"n\">saveat</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span><span class=\"n\">abstol</span><span class=\"o\">=</span><span class=\"mf\">1e-10</span><span class=\"p\">,</span><span class=\"n\">reltol</span><span class=\"o\">=</span><span class=\"mf\">1e-10</span><span class=\"p\">)</span>\n</pre>\n<p>The set of algorithms for ODEs is described\n<a href=\"http://docs.juliadiffeq.org/latest/solvers/ode_solve.html\" rel=\"nofollow\">at the ODE solvers page</a>.</p>\n<h3>Compilation with Numba and Julia</h3>\n<p>When solving a differential equation, it's pertinent that your derivative\nfunction <code>f</code> is fast since it occurs in the inner loop of the solver. We can\nutilize Numba to JIT compile our derivative functions to improve the efficiency\nof the solver:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numba</span>\n<span class=\"n\">numba_f</span> <span class=\"o\">=</span> <span class=\"n\">numba</span><span class=\"o\">.</span><span class=\"n\">jit</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n\n<span class=\"n\">prob</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">ODEProblem</span><span class=\"p\">(</span><span class=\"n\">numba_f</span><span class=\"p\">,</span> <span class=\"n\">u0</span><span class=\"p\">,</span> <span class=\"n\">tspan</span><span class=\"p\">)</span>\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">)</span>\n</pre>\n<p>Additionally, you can directly define the functions in Julia. This will allow\nfor more specialization and could be helpful to increase the efficiency over\nthe Numba version for repeat or long calls. This is done via <code>julia.Main.eval</code>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">julia</span> <span class=\"kn\">import</span> <span class=\"n\">Main</span>\n<span class=\"n\">jul_f</span> <span class=\"o\">=</span> <span class=\"n\">Main</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"s2\">\"(u,p,t)-&gt;-u\"</span><span class=\"p\">)</span> <span class=\"c1\"># Define the anonymous function in Julia</span>\n<span class=\"n\">prob</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">ODEProblem</span><span class=\"p\">(</span><span class=\"n\">jul_f</span><span class=\"p\">,</span> <span class=\"n\">u0</span><span class=\"p\">,</span> <span class=\"n\">tspan</span><span class=\"p\">)</span>\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">)</span>\n</pre>\n<h3>Systems of ODEs: Lorenz Equations</h3>\n<p>To solve systems of ODEs, simply use an array as your initial condition and\ndefine <code>f</code> as an array function:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">):</span>\n    <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">u</span>\n    <span class=\"n\">sigma</span><span class=\"p\">,</span> <span class=\"n\">rho</span><span class=\"p\">,</span> <span class=\"n\">beta</span> <span class=\"o\">=</span> <span class=\"n\">p</span>\n    <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">sigma</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">),</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">rho</span> <span class=\"o\">-</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">beta</span> <span class=\"o\">*</span> <span class=\"n\">z</span><span class=\"p\">]</span>\n\n<span class=\"n\">u0</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span><span class=\"mf\">0.0</span><span class=\"p\">,</span><span class=\"mf\">0.0</span><span class=\"p\">]</span>\n<span class=\"n\">tspan</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">100.</span><span class=\"p\">)</span>\n<span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">10.0</span><span class=\"p\">,</span><span class=\"mf\">28.0</span><span class=\"p\">,</span><span class=\"mi\">8</span><span class=\"o\">/</span><span class=\"mi\">3</span><span class=\"p\">]</span>\n<span class=\"n\">prob</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">ODEProblem</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">u0</span><span class=\"p\">,</span> <span class=\"n\">tspan</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">,</span><span class=\"n\">saveat</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">)</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">u</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p><img alt=\"f3\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/be12b73320d30a6024e03d853fcc68a48a5adf56/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f313831343137342f33393038393338372d65386335643964322d343537612d313165382d386637372d6565636663393535636532372e706e67\"></p>\n<p>or we can draw the phase plot:</p>\n<pre><span class=\"n\">ut</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">u</span><span class=\"p\">)</span>\n<span class=\"kn\">from</span> <span class=\"nn\">mpl_toolkits.mplot3d</span> <span class=\"kn\">import</span> <span class=\"n\">Axes3D</span>\n<span class=\"n\">fig</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"p\">()</span>\n<span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">fig</span><span class=\"o\">.</span><span class=\"n\">add_subplot</span><span class=\"p\">(</span><span class=\"mi\">111</span><span class=\"p\">,</span> <span class=\"n\">projection</span><span class=\"o\">=</span><span class=\"s1\">'3d'</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,:],</span><span class=\"n\">ut</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,:],</span><span class=\"n\">ut</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,:])</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p><img alt=\"f4\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/65d06288008907e8b5b0bc9fd6b7d5ba761767bd/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f313831343137342f33393038393338382d65386461653030632d343537612d313165382d383739662d3862303165306234373137382e706e67\"></p>\n<h3>In-Place Mutating Form</h3>\n<p>When dealing with systems of equations, in many cases it's helpful to reduce\nmemory allocations by using mutating functions. In diffeqpy, the mutating\nform adds the mutating vector to the front. Let's make a fast version of the\nLorenz derivative, i.e. mutating and JIT compiled:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">du</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">):</span>\n    <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">u</span>\n    <span class=\"n\">sigma</span><span class=\"p\">,</span> <span class=\"n\">rho</span><span class=\"p\">,</span> <span class=\"n\">beta</span> <span class=\"o\">=</span> <span class=\"n\">p</span>\n    <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">sigma</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">rho</span> <span class=\"o\">-</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">y</span>\n    <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">beta</span> <span class=\"o\">*</span> <span class=\"n\">z</span>\n\n<span class=\"n\">numba_f</span> <span class=\"o\">=</span> <span class=\"n\">numba</span><span class=\"o\">.</span><span class=\"n\">jit</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"n\">u0</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span><span class=\"mf\">0.0</span><span class=\"p\">,</span><span class=\"mf\">0.0</span><span class=\"p\">]</span>\n<span class=\"n\">tspan</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">100.</span><span class=\"p\">)</span>\n<span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">10.0</span><span class=\"p\">,</span><span class=\"mf\">28.0</span><span class=\"p\">,</span><span class=\"mf\">2.66</span><span class=\"p\">]</span>\n<span class=\"n\">prob</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">ODEProblem</span><span class=\"p\">(</span><span class=\"n\">numba_f</span><span class=\"p\">,</span> <span class=\"n\">u0</span><span class=\"p\">,</span> <span class=\"n\">tspan</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">)</span>\n</pre>\n<p>or using a Julia function:</p>\n<pre><span class=\"n\">jul_f</span> <span class=\"o\">=</span> <span class=\"n\">Main</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">function f(du,u,p,t)</span>\n<span class=\"s2\">  x, y, z = u</span>\n<span class=\"s2\">  sigma, rho, beta = p</span>\n<span class=\"s2\">  du[1] = sigma * (y - x)</span>\n<span class=\"s2\">  du[2] = x * (rho - z) - y</span>\n<span class=\"s2\">  du[3] = x * y - beta * z</span>\n<span class=\"s2\">end\"\"\"</span><span class=\"p\">)</span>\n<span class=\"n\">u0</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span><span class=\"mf\">0.0</span><span class=\"p\">,</span><span class=\"mf\">0.0</span><span class=\"p\">]</span>\n<span class=\"n\">tspan</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">100.</span><span class=\"p\">)</span>\n<span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">10.0</span><span class=\"p\">,</span><span class=\"mf\">28.0</span><span class=\"p\">,</span><span class=\"mf\">2.66</span><span class=\"p\">]</span>\n<span class=\"n\">prob</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">ODEProblem</span><span class=\"p\">(</span><span class=\"n\">jul_f</span><span class=\"p\">,</span> <span class=\"n\">u0</span><span class=\"p\">,</span> <span class=\"n\">tspan</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">)</span>\n</pre>\n<h2>Stochastic Differential Equation (SDE) Examples</h2>\n<h3>One-dimensional SDEs</h3>\n<p>Solving one-dimensonal SDEs <code>du = f(u,t)dt + g(u,t)dW_t</code> is like an ODE except\nwith an extra function for the diffusion (randomness or noise) term. The steps\nfollow the <a href=\"http://docs.juliadiffeq.org/latest/tutorials/sde_example.html\" rel=\"nofollow\">SDE tutorial</a>.</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">):</span>\n  <span class=\"k\">return</span> <span class=\"mf\">1.01</span><span class=\"o\">*</span><span class=\"n\">u</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">):</span>\n  <span class=\"k\">return</span> <span class=\"mf\">0.87</span><span class=\"o\">*</span><span class=\"n\">u</span>\n\n<span class=\"n\">u0</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>\n<span class=\"n\">tspan</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n<span class=\"n\">prob</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">SDEProblem</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span><span class=\"n\">g</span><span class=\"p\">,</span><span class=\"n\">u0</span><span class=\"p\">,</span><span class=\"n\">tspan</span><span class=\"p\">)</span>\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">,</span><span class=\"n\">reltol</span><span class=\"o\">=</span><span class=\"mf\">1e-3</span><span class=\"p\">,</span><span class=\"n\">abstol</span><span class=\"o\">=</span><span class=\"mf\">1e-3</span><span class=\"p\">)</span>\n\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">u</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p><img alt=\"f5\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/46d2a62d427a1df79e497b99475a0cc3b38224ed/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f313831343137342f33393038393338392d65386630333433652d343537612d313165382d383762622d3965643135326361656530322e706e67\"></p>\n<h3>Systems of SDEs with Diagonal Noise</h3>\n<p>An SDE with diagonal noise is where a different Wiener process is applied to\nevery part of the system. This is common for models with phenomenological noise.\nLet's add multiplicative noise to the Lorenz equation:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">du</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">):</span>\n    <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">u</span>\n    <span class=\"n\">sigma</span><span class=\"p\">,</span> <span class=\"n\">rho</span><span class=\"p\">,</span> <span class=\"n\">beta</span> <span class=\"o\">=</span> <span class=\"n\">p</span>\n    <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">sigma</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">rho</span> <span class=\"o\">-</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">y</span>\n    <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">beta</span> <span class=\"o\">*</span> <span class=\"n\">z</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"n\">du</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">):</span>\n    <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.3</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.3</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n    <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.3</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n\n<span class=\"n\">numba_f</span> <span class=\"o\">=</span> <span class=\"n\">numba</span><span class=\"o\">.</span><span class=\"n\">jit</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"n\">numba_g</span> <span class=\"o\">=</span> <span class=\"n\">numba</span><span class=\"o\">.</span><span class=\"n\">jit</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">)</span>\n<span class=\"n\">u0</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span><span class=\"mf\">0.0</span><span class=\"p\">,</span><span class=\"mf\">0.0</span><span class=\"p\">]</span>\n<span class=\"n\">tspan</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">100.</span><span class=\"p\">)</span>\n<span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">10.0</span><span class=\"p\">,</span><span class=\"mf\">28.0</span><span class=\"p\">,</span><span class=\"mf\">2.66</span><span class=\"p\">]</span>\n<span class=\"n\">prob</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">SDEProblem</span><span class=\"p\">(</span><span class=\"n\">numba_f</span><span class=\"p\">,</span> <span class=\"n\">numba_g</span><span class=\"p\">,</span> <span class=\"n\">u0</span><span class=\"p\">,</span> <span class=\"n\">tspan</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Now let's draw a phase plot</span>\n\n<span class=\"n\">ut</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">u</span><span class=\"p\">)</span>\n<span class=\"kn\">from</span> <span class=\"nn\">mpl_toolkits.mplot3d</span> <span class=\"kn\">import</span> <span class=\"n\">Axes3D</span>\n<span class=\"n\">fig</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"p\">()</span>\n<span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">fig</span><span class=\"o\">.</span><span class=\"n\">add_subplot</span><span class=\"p\">(</span><span class=\"mi\">111</span><span class=\"p\">,</span> <span class=\"n\">projection</span><span class=\"o\">=</span><span class=\"s1\">'3d'</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,:],</span><span class=\"n\">ut</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,:],</span><span class=\"n\">ut</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,:])</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p><img alt=\"f6\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cb3f429ceab42fb9b88dddf4fab5ade284b9d5ee/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f313831343137342f33393038393339302d65393036633165612d343537612d313165382d386664322d3563663035396532313635612e706e67\"></p>\n<h3>Systems of SDEs with Non-Diagonal Noise</h3>\n<p>In many cases you may want to share noise terms across the system. This is\nknown as non-diagonal noise. The\n<a href=\"http://docs.juliadiffeq.org/latest/tutorials/sde_example.html#Example-4:-Systems-of-SDEs-with-Non-Diagonal-Noise-1\" rel=\"nofollow\">DifferentialEquations.jl SDE Tutorial</a>\nexplains how the matrix form of the diffusion term corresponds to the\nsummation style of multiple Wiener processes. Essentially, the row corresponds\nto which system the term is applied to, and the column is which noise term.\nSo <code>du[i,j]</code> is the amount of noise due to the <code>j</code>th Wiener process that's\napplied to <code>u[i]</code>. We solve the Lorenz system with correlated noise as follows:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">du</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">):</span>\n  <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">u</span>\n  <span class=\"n\">sigma</span><span class=\"p\">,</span> <span class=\"n\">rho</span><span class=\"p\">,</span> <span class=\"n\">beta</span> <span class=\"o\">=</span> <span class=\"n\">p</span>\n  <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">sigma</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">)</span>\n  <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">rho</span> <span class=\"o\">-</span> <span class=\"n\">z</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">y</span>\n  <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">beta</span> <span class=\"o\">*</span> <span class=\"n\">z</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"n\">du</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">):</span>\n  <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.3</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n  <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.6</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n  <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n  <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.2</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n  <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n  <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.3</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n\n\n<span class=\"n\">u0</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span><span class=\"mf\">0.0</span><span class=\"p\">,</span><span class=\"mf\">0.0</span><span class=\"p\">]</span>\n<span class=\"n\">tspan</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span><span class=\"mf\">100.0</span><span class=\"p\">)</span>\n<span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">10.0</span><span class=\"p\">,</span><span class=\"mf\">28.0</span><span class=\"p\">,</span><span class=\"mf\">2.66</span><span class=\"p\">]</span>\n<span class=\"n\">nrp</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n<span class=\"n\">numba_f</span> <span class=\"o\">=</span> <span class=\"n\">numba</span><span class=\"o\">.</span><span class=\"n\">jit</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"n\">numba_g</span> <span class=\"o\">=</span> <span class=\"n\">numba</span><span class=\"o\">.</span><span class=\"n\">jit</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">)</span>\n<span class=\"n\">prob</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">SDEProblem</span><span class=\"p\">(</span><span class=\"n\">numba_f</span><span class=\"p\">,</span><span class=\"n\">numba_g</span><span class=\"p\">,</span><span class=\"n\">u0</span><span class=\"p\">,</span><span class=\"n\">tspan</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"n\">noise_rate_prototype</span><span class=\"o\">=</span><span class=\"n\">nrp</span><span class=\"p\">)</span>\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">,</span><span class=\"n\">saveat</span><span class=\"o\">=</span><span class=\"mf\">0.005</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Now let's draw a phase plot</span>\n\n<span class=\"n\">ut</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">u</span><span class=\"p\">)</span>\n<span class=\"kn\">from</span> <span class=\"nn\">mpl_toolkits.mplot3d</span> <span class=\"kn\">import</span> <span class=\"n\">Axes3D</span>\n<span class=\"n\">fig</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"p\">()</span>\n<span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">fig</span><span class=\"o\">.</span><span class=\"n\">add_subplot</span><span class=\"p\">(</span><span class=\"mi\">111</span><span class=\"p\">,</span> <span class=\"n\">projection</span><span class=\"o\">=</span><span class=\"s1\">'3d'</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">ut</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,:],</span><span class=\"n\">ut</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,:],</span><span class=\"n\">ut</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,:])</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p><img alt=\"f7\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6bd99ba9280b41f07df43879eb61a6557e693969/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f313831343137342f33393038393339312d65393166303439342d343537612d313165382d383630612d3836356361613236633236322e706e67\"></p>\n<p>Here you can see that the warping effect of the noise correlations is quite visible!</p>\n<h2>Differential-Algebraic Equation (DAE) Examples</h2>\n<p>A differential-algebraic equation is defined by an implicit function\n<code>f(du,u,p,t)=0</code>. All of the controls are the same as the other examples, except\nhere you define a function which returns the residuals for each part of the\nequation to define the DAE. The initial value <code>u0</code> and the initial derivative\n<code>du0</code> are required, though they do not necessarily have to satisfy <code>f</code> (known\nas inconsistent initial conditions). The methods will automatically find\nconsistent initial conditions. In order for this to occur, <code>differential_vars</code>\nmust be set. This vector states which of the variables are differential (have a\nderivative term), with <code>false</code> meaning that the variable is purely algebraic.</p>\n<p>This example shows how to solve the Robertson equation:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">du</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">):</span>\n  <span class=\"n\">resid1</span> <span class=\"o\">=</span> <span class=\"o\">-</span> <span class=\"mf\">0.04</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>               <span class=\"o\">+</span> <span class=\"mf\">1e4</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n  <span class=\"n\">resid2</span> <span class=\"o\">=</span> <span class=\"o\">+</span> <span class=\"mf\">0.04</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mf\">3e7</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">-</span> <span class=\"mf\">1e4</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n  <span class=\"n\">resid3</span> <span class=\"o\">=</span> <span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mf\">1.0</span>\n  <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">resid1</span><span class=\"p\">,</span><span class=\"n\">resid2</span><span class=\"p\">,</span><span class=\"n\">resid3</span><span class=\"p\">]</span>\n\n<span class=\"n\">u0</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">]</span>\n<span class=\"n\">du0</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">0.04</span><span class=\"p\">,</span> <span class=\"mf\">0.04</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">]</span>\n<span class=\"n\">tspan</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span><span class=\"mf\">100000.0</span><span class=\"p\">)</span>\n<span class=\"n\">differential_vars</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"kc\">True</span><span class=\"p\">,</span><span class=\"kc\">True</span><span class=\"p\">,</span><span class=\"kc\">False</span><span class=\"p\">]</span>\n<span class=\"n\">prob</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">DAEProblem</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span><span class=\"n\">du0</span><span class=\"p\">,</span><span class=\"n\">u0</span><span class=\"p\">,</span><span class=\"n\">tspan</span><span class=\"p\">,</span><span class=\"n\">differential_vars</span><span class=\"o\">=</span><span class=\"n\">differential_vars</span><span class=\"p\">)</span>\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"f8\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3d3cb2b5f3e18b271df3b0f41e1a50df374a813a/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f313831343137342f33393038393339322d65393332663031322d343537612d313165382d393937392d6330303662636661626637312e706e67\"></p>\n<p>and the in-place JIT compiled form:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"n\">resid</span><span class=\"p\">,</span><span class=\"n\">du</span><span class=\"p\">,</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">):</span>\n  <span class=\"n\">resid</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span> <span class=\"mf\">0.04</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>               <span class=\"o\">+</span> <span class=\"mf\">1e4</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n  <span class=\"n\">resid</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">+</span> <span class=\"mf\">0.04</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mf\">3e7</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">-</span> <span class=\"mf\">1e4</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">du</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n  <span class=\"n\">resid</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">u</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mf\">1.0</span>\n\n<span class=\"n\">numba_f</span> <span class=\"o\">=</span> <span class=\"n\">numba</span><span class=\"o\">.</span><span class=\"n\">jit</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span>\n<span class=\"n\">prob</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">DAEProblem</span><span class=\"p\">(</span><span class=\"n\">numba_f</span><span class=\"p\">,</span><span class=\"n\">du0</span><span class=\"p\">,</span><span class=\"n\">u0</span><span class=\"p\">,</span><span class=\"n\">tspan</span><span class=\"p\">,</span><span class=\"n\">differential_vars</span><span class=\"o\">=</span><span class=\"n\">differential_vars</span><span class=\"p\">)</span>\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">)</span>\n</pre>\n<h2>Delay Differential Equations</h2>\n<p>A delay differential equation is an ODE which allows the use of previous values.\nIn this case, the function needs to be a JIT compiled Julia function. It looks\njust like the ODE, except in this case there is a function <code>h(p,t)</code> which allows\nyou to interpolate and grab previous values.</p>\n<p>We must provide a history function <code>h(p,t)</code> that gives values for <code>u</code> before <code>t0</code>.\nHere we assume that the solution was constant before the initial time point.\nAdditionally, we pass <code>constant_lags = [20.0]</code> to tell the solver that only\nconstant-time lags were used and what the lag length was. This helps improve\nthe solver accuracy by accurately stepping at the points of discontinuity.\nTogether this is:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">Main</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">function f(du, u, h, p, t)</span>\n<span class=\"s2\">  du[1] = 1.1/(1 + sqrt(10)*(h(p, t-20)[1])^(5/4)) - 10*u[1]/(1 + 40*u[2])</span>\n<span class=\"s2\">  du[2] = 100*u[1]/(1 + 40*u[2]) - 2.43*u[2]</span>\n<span class=\"s2\">end\"\"\"</span><span class=\"p\">)</span>\n<span class=\"n\">u0</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">1.05767027</span><span class=\"o\">/</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mf\">1.030713491</span><span class=\"o\">/</span><span class=\"mi\">3</span><span class=\"p\">]</span>\n\n<span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">Main</span><span class=\"o\">.</span><span class=\"n\">eval</span><span class=\"p\">(</span><span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">function h(p,t)</span>\n<span class=\"s2\">  [1.05767027/3, 1.030713491/3]</span>\n<span class=\"s2\">end</span>\n<span class=\"s2\">\"\"\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">tspan</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">100.0</span><span class=\"p\">)</span>\n<span class=\"n\">constant_lags</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">20.0</span><span class=\"p\">]</span>\n<span class=\"n\">prob</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">DDEProblem</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span><span class=\"n\">u0</span><span class=\"p\">,</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"n\">tspan</span><span class=\"p\">,</span><span class=\"n\">constant_lags</span><span class=\"o\">=</span><span class=\"n\">constant_lags</span><span class=\"p\">)</span>\n<span class=\"n\">sol</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">prob</span><span class=\"p\">,</span><span class=\"n\">saveat</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n\n<span class=\"n\">u1</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">u</span><span class=\"p\">))]</span>\n<span class=\"n\">u2</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">u</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">u</span><span class=\"p\">))]</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"n\">u1</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">sol</span><span class=\"o\">.</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"n\">u2</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p><img alt=\"dde\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/71ca1c5bbf2939ed4d81cb1e4eef27121439aa84/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f313831343137342f33393232393637302d38313566326562612d343831382d313165382d396261332d6134663631636338343563352e706e67\"></p>\n<p>Notice that the solver accurately is able to simulate the kink (discontinuity)\nat <code>t=20</code> due to the discontinuity of the derivative at the initial time point!\nThis is why declaring discontinuities can enhance the solver accuracy.</p>\n<h2>Known Limitations</h2>\n<ul>\n<li>Autodiff does not work on Python functions. When applicable, either define the derivative function\nas a Julia function or set the algorithm to use finite differencing, i.e. <code>Rodas5(autodiff=false)</code>.\nAll default methods use autodiff.</li>\n<li>Delay differential equations have to use Julia-defined functions otherwise the history function is\nnot appropriately typed with the overloads.</li>\n</ul>\n<h2>Testing</h2>\n<p>Unit tests can be run by <a href=\"http://tox.readthedocs.io\" rel=\"nofollow\"><code>tox</code></a>.</p>\n<pre>tox                <span class=\"c1\"># test with Python 3.6 and 2.7</span>\ntox -e py36        <span class=\"c1\"># test only with Python 3.6</span>\n</pre>\n<h3>Troubleshooting</h3>\n<p>In case you encounter silent failure from <code>tox</code>, try running it with\n<code>-- -s</code> (e.g., <code>tox -e py36 -- -s</code>) where <code>-s</code> option (<code>--capture=no</code>,\ni.e., don't capture stdio) is passed to <code>py.test</code>.  It may show an\nerror message <code>\"error initializing LibGit2 module\"</code>.  In this case,\nsetting environment variable <code>SSL_CERT_FILE</code> may help; e.g., try:</p>\n<pre><span class=\"nv\">SSL_CERT_FILE</span><span class=\"o\">=</span>PATH/TO/cert.pem tox -e py36\n</pre>\n<p>See also: <a href=\"https://github.com/JuliaLang/julia/issues/18693\" rel=\"nofollow\">julia#18693</a>.</p>\n\n          </div>"}, "last_serial": 5498365, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "9a033e50dee8277c11020ef8551ff446", "sha256": "aad579ea4de36931f8783d616283885bf8d9ad08845ee57fbc4f7e07713d51b2"}, "downloads": -1, "filename": "diffeqpy-0.1.tar.gz", "has_sig": false, "md5_digest": "9a033e50dee8277c11020ef8551ff446", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1270, "upload_time": "2018-04-21T18:44:57", "upload_time_iso_8601": "2018-04-21T18:44:57.165008Z", "url": "https://files.pythonhosted.org/packages/d1/22/2cd8d385038d4988120571f70a14f39975066baffa894180a26646f92d8b/diffeqpy-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "4d628ea718a2122fa3e6bdfdc6d066f2", "sha256": "1a44095a4aa1d1bc50f895e93187fb442b3cf039ea17c526dd949e7102a3b719"}, "downloads": -1, "filename": "diffeqpy-0.2.tar.gz", "has_sig": false, "md5_digest": "4d628ea718a2122fa3e6bdfdc6d066f2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7850, "upload_time": "2018-04-22T00:12:03", "upload_time_iso_8601": "2018-04-22T00:12:03.928746Z", "url": "https://files.pythonhosted.org/packages/f7/38/07ec0d7703451d81bbf89d2602f306169b18b4a8b69b512d2da0d53a2239/diffeqpy-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "1ca3c5768d56dca644cd6b97515e199f", "sha256": "862e73e7adf3a9d2792de82e13e7dc18c15b0ee09a3b3185be75e62720e5b833"}, "downloads": -1, "filename": "diffeqpy-0.3.tar.gz", "has_sig": false, "md5_digest": "1ca3c5768d56dca644cd6b97515e199f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10596, "upload_time": "2018-04-26T22:27:47", "upload_time_iso_8601": "2018-04-26T22:27:47.206591Z", "url": "https://files.pythonhosted.org/packages/cf/cf/f888df1691987ff9b668af471c4838d25ff4cab2d3c5240770e53de5e840/diffeqpy-0.3.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "250ab16698739cc655c94403968a14c5", "sha256": "d05401cf960f75c305e3969e802f7f961f28feea4f2a6d581a138a52df74521f"}, "downloads": -1, "filename": "diffeqpy-0.4.tar.gz", "has_sig": false, "md5_digest": "250ab16698739cc655c94403968a14c5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11387, "upload_time": "2018-04-28T04:31:43", "upload_time_iso_8601": "2018-04-28T04:31:43.878882Z", "url": "https://files.pythonhosted.org/packages/d0/05/ca832a0fb1f3e09efb1c0380aa83010d610c60d28bf2020866773c421bdf/diffeqpy-0.4.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "016c232d5258ee71eecf3cb05474fb57", "sha256": "c9da37710148e593695b334fe5fefe425e1dafae8575c64e6ae1202eff39358d"}, "downloads": -1, "filename": "diffeqpy-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "016c232d5258ee71eecf3cb05474fb57", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10658, "upload_time": "2019-07-07T23:14:46", "upload_time_iso_8601": "2019-07-07T23:14:46.313081Z", "url": "https://files.pythonhosted.org/packages/90/51/ed2177c869d397f2c0908280cf84cb5a200826e14ad17f5c21233319b886/diffeqpy-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c61f32b63c24bf9e07eab89f615f1256", "sha256": "21c1eee79b58ce88a16ddab70f6a6c506d5ab9ab95c07aa7b10caac6a65ccfff"}, "downloads": -1, "filename": "diffeqpy-1.0.0.tar.gz", "has_sig": false, "md5_digest": "c61f32b63c24bf9e07eab89f615f1256", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11185, "upload_time": "2018-12-21T05:15:45", "upload_time_iso_8601": "2018-12-21T05:15:45.971765Z", "url": "https://files.pythonhosted.org/packages/59/fa/31d698f49d9911a9f561337c2b42523d1f2c4a75dd0e874661d5db43dd15/diffeqpy-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "b3c576ee9db62a8ebf1439760c8cda4a", "sha256": "1098d3eef8c8eda18fb3f9f8ca857e5a138e6eff7592306fed0d2fe689d5a87e"}, "downloads": -1, "filename": "diffeqpy-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b3c576ee9db62a8ebf1439760c8cda4a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10656, "upload_time": "2019-07-07T23:17:09", "upload_time_iso_8601": "2019-07-07T23:17:09.727186Z", "url": "https://files.pythonhosted.org/packages/eb/3e/23e863a4841d09b6d697cfe54b93c5f67be0f7c0e5568f30180cf9f7dfa2/diffeqpy-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9949901731ab90c8012d9757febfff5b", "sha256": "0ff315bf3d4345a83dc623b614e39c8365302df1cc9d36dcb8ce782d926f255b"}, "downloads": -1, "filename": "diffeqpy-1.1.0.tar.gz", "has_sig": false, "md5_digest": "9949901731ab90c8012d9757febfff5b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11750, "upload_time": "2019-07-07T23:17:11", "upload_time_iso_8601": "2019-07-07T23:17:11.537201Z", "url": "https://files.pythonhosted.org/packages/b0/ba/9b11fd427e012d08c010e34fb37a3514a59ed823af69dd5fa987ee6a47df/diffeqpy-1.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b3c576ee9db62a8ebf1439760c8cda4a", "sha256": "1098d3eef8c8eda18fb3f9f8ca857e5a138e6eff7592306fed0d2fe689d5a87e"}, "downloads": -1, "filename": "diffeqpy-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b3c576ee9db62a8ebf1439760c8cda4a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10656, "upload_time": "2019-07-07T23:17:09", "upload_time_iso_8601": "2019-07-07T23:17:09.727186Z", "url": "https://files.pythonhosted.org/packages/eb/3e/23e863a4841d09b6d697cfe54b93c5f67be0f7c0e5568f30180cf9f7dfa2/diffeqpy-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9949901731ab90c8012d9757febfff5b", "sha256": "0ff315bf3d4345a83dc623b614e39c8365302df1cc9d36dcb8ce782d926f255b"}, "downloads": -1, "filename": "diffeqpy-1.1.0.tar.gz", "has_sig": false, "md5_digest": "9949901731ab90c8012d9757febfff5b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11750, "upload_time": "2019-07-07T23:17:11", "upload_time_iso_8601": "2019-07-07T23:17:11.537201Z", "url": "https://files.pythonhosted.org/packages/b0/ba/9b11fd427e012d08c010e34fb37a3514a59ed823af69dd5fa987ee6a47df/diffeqpy-1.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:38:29 2020"}