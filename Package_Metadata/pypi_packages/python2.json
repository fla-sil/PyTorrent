{"info": {"author": "Nicholas Gaya", "author_email": "nickgaya@users.noreply.github.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Software Development :: Libraries"], "description": "python2\n=======\n\nA library for running Python 2 code from a Python 3 application.\n\n    Effortlessly harness the power and convenience of Python 2... in Python 3!\n\nWhy?\n----\n\nWhy not??\n\nThis library was created for more whimsical than practical reasons.  In theory,\nit could be used to interface with legacy Python 2 code which for one reason or\nanother cannot be ported to Python 3.\n\nInstallation\n------------\n``python2`` requires a working install of both Python 2 and Python 3.\nCurrently the library has only been tested with Python 2.7 and Python 3.4, 3.5,\nand 3.6.\n\nTo install the package::\n\n    pip install -U python2\n\nIf using virtualenvs, you will need to create separate Python 2 and 3\nvirtualenvs, and install the package into both.\n\nUsage\n-----\nTo begin working with Python 2, import the package in Python 3 and create a new\n``Python2`` object::\n\n    >>> from python2.client import Python2\n    >>> py2 = Python2('/path/to/python2/executable')\n\nThis object is our gateway to the Python 2 world.  Python 2 builtins can be\naccessed as attributes of the ``Python2`` object. Let's use Python 2's\n``__import__()`` function to import the deprecated ``sha`` module, which was\nremoved in Python 3::\n\n    >>> py2_sha = py2.__import__('sha')\n    >>> py2_sha.sha('abc')\n    <Py2Object <sha1 HASH object @ 0x107463c30>>\n\nAhh, just like the good ol' days.  You can deprecate a module but you can't\ndeprecate the human spirit!\n\nWe can use the ``Python2.project()`` method to convert Python 3 objects to\nPython 2::\n\n    >>> py2.project(1)\n    <Py2Object 1>\n    >>> py2.project('foo')\n    <Py2Object u'foo'>\n\nYou can use ``Python2.lift()`` to lift Python 2 objects back to Python 3.  For\ncontainer types, use ``Python2.deeplift()`` to recursively perform the lifting.\n``Py2Object`` instances have special properties ``_`` and ``__`` to perform the\nequivalent operations::\n\n    >>> o = py2.project([1, 2, 3])\n    >>> o\n    <Py2Object [1, 2, 3]>\n    >>> o._\n    [<Py2Object 1>, <Py2Object 2>, <Py2Object 3>]\n    >>> o.__\n    [1, 2, 3]\n\nPython 2 objects can be used pretty much like regular Python 3 objects.  You\ncan also freely mix and match with Python 3 builtin types::\n\n    >>> x = py2.project(1)\n    >>> x\n    <Py2Object 1>\n    >>> str(x)\n    '1'\n    >>> x + 1\n    <Py2Object 2>\n    >>> d = py2.dict(foo=x, bar=None)\n    >>> d['foo'] is x\n    True\n    >>> del d['foo']\n    >>> d\n    <Py2Object {u'bar': None}>\n    >>> d.__\n    {'bar': None}\n\nIf you just want to execute some Python 2 code directly, you can use the\n``Python2.exec()`` method.  This method accepts a string containing Python 2\ncode and an optional dict representing the scope to execute the code in, and\nreturns the resulting scope after executing the code.  This can be used to\ndefine new Python 2 classes and functions::\n\n   >>> scope = py2.exec(\"\"\"\n   ... def foo(x):\n   ...     return x + 1\n   ... \"\"\")\n   >>> foo = scope['foo']\n   >>> foo(2)\n   <Py2Object 3>\n\nIf an exception occurs in Python 2, a ``Py2Error`` will be thrown by the\nclient.  The Python 2 exception is stored as the ``exception`` attribute of the\n``Py2Error`` object.  The underlying traceback is attached to the Python 2\nexception as the ``__traceback__`` attribute.\n\n::\n\n    >>> py2.int('asdf')\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n      ...\n    python2.client.exceptions.Py2Error: ValueError: invalid literal for int() with base 10: 'asdf'\n\nWhen you're done using Python 2, you can end the session by calling the\n``Python2.shutdown()`` method.  You can also use the ``Python2`` object as a\ncontext manager to automatically do the same thing when exiting the context.\n\n::\n\n    >>> py2.shutdown()\n\nTesting\n-------\nThis package uses Tox for testing.  Tests are not included in the Python dist,\nso you will need to clone the repo to run them.  To run the unit tests, install\nTox and run the following command from the project's base directory::\n\n    tox\n\nAfter running tox, you can run the client-server integration tests with the\n'integration_tests.sh' script.  This script takes two arguments specifying the\nTox virtualenvs to use for Python 2 and 3, respectively::\n\n    ./integration_tests.sh py27 py36\n\nTo modify the behavior of Tox, you can set the ``PYTEST_ADDOPTS`` variable.\nFor example, you can set the ``-x`` flag to abort after the first test\nfailure::\n\n    export PYTEST_ADDOPTS=-x\n\nYou can use the ``-n NUM`` flag to parallelize the tests using the\n`pytest-xdist plugin`_  This adds some overhead to the test setup, so this\noption is primarily useful for speeding up the integration tests.\n\n    export PYTEST_ADDOPTS='-n 4'\n\n.. _pytest-xdist plugin: http://pytest.org/dev/xdist.html\n\nCaveats\n-------\n\nSupported types\n```````````````\nProjection is only supported for basic builtin types.  Other objects cannot be\nprojected to Python 2.  The supported types are: ``bool``, ``int``, ``float``,\n``complex``, ``bytes``, ``unicode``, ``bytearray``, ``range``, ``slice``,\n``list``, ``tuple``, ``set``, ``frozenset``, and ``dict``.  The ``None``,\n``NotImplemented``, and ``Ellipsis`` singletons are also supported.\n\nIn particular, Python 3 functions, types, and instances of user-defined classes\ncannot currently be projected into Python 2.\n\nType introspection\n``````````````````\nThe ``Py2Object`` class implements many \"magic methods\" from the Python 3 data\nmodel.  As a result, a ``Py2Object`` appears to be callable, iterable, etc.,\neven if the underlying object is not.  Attempting to perform such operations may\nresult in a ``Py2Error``.\n\nIf you need to introspect a Python 2 object, use the corresponding *Python 2*\nbuiltin functions.  For example::\n\n    >>> i = py2.project(1)\n    >>> py2.callable(i)\n    <Py2Object False>\n    >>> py2.isinstance(i, py2.int)\n    <Py2Object True>\n\nString types\n````````````\nIn Python 2, ``str`` objects are raw byte strings, while in Python 3 they are\nUnicode strings.  This can lead to some confusion, as projecting a Python 3\n``str`` will result in a Python 2 ``unicode`` object, while lifting a Python 2\n``str`` will return a Python 3 ``bytes`` object.\n\n    >>> py2.project('foo')\n    <Py2Object u'foo'>\n    >>> py2.lift(py2.str(123))\n    b'123'\n\nDivision\n````````\nThe behavior of the division operator changed with `PEP 238`_.  This created\ntwo alternate division operations, \"true division\" and \"classic division\".\nClassic division was removed in Python 3.\n\nTo respect this change, when two ``Py2Object`` s are divided, classic division\nis used.  When a ``Py2Object`` divides or is divided by a Python 3 value, true division is used.\n\n::\n\n    >>> i = py2.project(1)\n    >>> j = py2.project(2)\n    >>> i / j  # classic division\n    <Py2Object 0>\n    >>> i / 2  # true division\n    <Py2Object 0.5>\n    >>> 1 / j  # true division\n    <Py2Object 0.5>\n\n.. _PEP 238: https://www.python.org/dev/peps/pep-0238/\n\nFurther discussion\n------------------\n\nHow it works\n````````````\nWhen you launch a Python 2 session, the library spawns a child process running\nPython 2.  This child process runs a *server* that listens for commands from\nthe Python 3 *client*.  For each command, the server performs an operation in\nPython 2 and returns the result either as an encoded *value* made up of\nsupported types, or a *reference* to a Python 2 object stored on the server.\n\nOn the client side, the library wraps Python 2 references with the\n``Py2Object`` class.  This class implements many of the \"magic methods\" of the\n`Python 3 data model`_ by sending commands to the Python 2 server to perform\nthe appropriate operation on the underlying Python 2 object.\n\n.. _Python 3 data model: https://docs.python.org/3/reference/datamodel.html\n\nCall-by-value semantics\n```````````````````````\nWhen projecting a value or calling a Python 2 function with Python 3 arguments,\nthe arguments will be passed to Python 2 \"by value\", that is, by encoding the\nvalue of the argument to be decoded by the server.  When using a Python 2\nobject, the object is stored in the Python 2 session and is passed \"by\nreference\".\n\nThis has some implications for the semantics of Python 2 functions.  Suppose we\nhave a Python 2 function that mutates a list.  If we pass this function a\nPython 3 list, the list will be copied into Python 2 and the copy will be\nmutated, but the original will not be modified::\n\n    >>> f = py2.eval(\"lambda l: l.append(1)\")\n    >>> l = []\n    >>> f(l)\n    <Py2Object None>\n    >>> l\n    []\n\nHowever, if we project the list into Python 2 before passing it to the\nfunction, then we can observe the modifications on the projected list::\n\n    >>> py2_l = py2.project(l)\n    >>> f(py2_l)\n    <Py2Object None>\n    >>> py2_l\n    <Py2Object [1]>\n\nReturn semantics\n````````````````\nReturning generally occurs by reference except for operations that require a\nspecific return type (``str()``, ``int()``, etc.).  The main reason for this is\nthat returning by value may lose information about object identity that needs\nto be preserved.  Return values can be easily lifted to Python 2 if desired.\n\nObject identity and lifespan\n````````````````````````````\nEach Python 2 object returned by the server is represented by a unique\n``Py2Object``.  This means that the ``is`` operator can be used to determine if\ntwo ``Py2Object`` s refer to the same underlying object.\n\nThe Python 2 server stores all objects it returns, to prevent them from being\ndeallocated.  When the corresponding ``Py2Object`` is deallocated in the Python\n3 process, the underlying Python 2 object will be removed from the server cache\nto allow it to be deallocated as appropriate.\n\nEncoding algorithm\n``````````````````\nThis library uses a simple JSON encoding for supported types.  For a given\nfunction call, each unique object will only be encoded once.  This means that\ndata structures with circular references are supported.  For a detailed\ndescription of the algorithm, see the ``python2.shared.codec`` module.\n\nPossible improvements\n---------------------\n\nPython 2 types\n``````````````\nCurrently there is a single type for Python 2 objects in Python 3,\n``Py2Object``. An alternate strategy would be to dynamically create Python 3\nclasses for each Python 2 type encountered, and create proxy objects as\ninstances of these classes.\n\nThe main benefit of this change would be better type introspection for Python 2\nobjects (see the discussion at `Type introspection`_).  However, it would be\nmore cumbersome and incur a performance cost, since the client would need to\nknow the type of each object and the methods supported by that type.\nAdditionally, this approach would not fully support the dynamic nature of the\nPython type system, since the proxied type would not reflect changes to the\nunderlying type such as adding or removing methods.\n\nThis would require the server to return the object type for references, and\nsome mechanism for the client to introspect Python 2 types.  The client would\ncache types for the lifetime of the Python 2 session, with a mechanism to\nexplicitly refresh a type to pick up any changes that had occurred in Python 2.\n\nBootstrapping the type system might be a little tricky.  We would want to\ncreate a type ``Py2type`` such all proxy types are instances of, *including\n``Py2type`` itself.*  We would also probably want a base type for all proxy\nobjects, including types.\n\nPython 3 proxy objects in Python 2\n``````````````````````````````````\nCurrently the relationship between client and server is asymmetrical.  The\nclient has a representation of Python 2 objects, but the server does not have\na way to represent Python 3 objects.  We might like to add such a mechanism.\nThis would mean that instead of the simple request-response pattern from client\nto server we have now, there would be the possibility of callbacks.  In effect,\nthe two processes would act more like coroutines with the flow of control\npassing back and forth between them.\n\nBetter Python version support\n`````````````````````````````\nWe could extend support to more Python 2 and 3 versions.\n\nSimilar projects\n----------------\nAfter writing this library, I discovered that I'm not the only one to have had\nthis idea.  `Sux`_ is a library that provides similar functionality, with some\nnotable differences:\n\n- The library is much smaller and more lightweight, and only needs to be\n  installed in the Python 3 environment to work.\n\n- The main emphasis is on imports and function calls, which makes sense since\n  these are the most important operations for the using legacy packages.  Most\n  other operators (e.g. arithmetic operators) are not supported.\n\n- The library uses Pickle to communicate between the Python 2 and 3 processes.\n  This is a good idea and I should probably have done the same, although I had\n  fun implementing the current encoding algorithm.\n\n.. _Sux: https://github.com/nicois/sux/\n", "description_content_type": null, "docs_url": null, "download_url": "https://github.com/nickgaya/python2/tarball/1.2", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/nickgaya/python2", "keywords": "python2,legacy,compatibility", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "python2", "package_url": "https://pypi.org/project/python2/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/python2/", "project_urls": {"Download": "https://github.com/nickgaya/python2/tarball/1.2", "Homepage": "https://github.com/nickgaya/python2"}, "release_url": "https://pypi.org/project/python2/1.2/", "requires_dist": null, "requires_python": null, "summary": "A library for running Python 2 code from a Python 3 application.", "version": "1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>A library for running Python 2 code from a Python 3 application.</p>\n<blockquote>\nEffortlessly harness the power and convenience of Python 2\u2026 in Python 3!</blockquote>\n<div id=\"why\">\n<h2>Why?</h2>\n<p>Why not??</p>\n<p>This library was created for more whimsical than practical reasons.  In theory,\nit could be used to interface with legacy Python 2 code which for one reason or\nanother cannot be ported to Python 3.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p><tt>python2</tt> requires a working install of both Python 2 and Python 3.\nCurrently the library has only been tested with Python 2.7 and Python 3.4, 3.5,\nand 3.6.</p>\n<p>To install the package:</p>\n<pre>pip install -U python2\n</pre>\n<p>If using virtualenvs, you will need to create separate Python 2 and 3\nvirtualenvs, and install the package into both.</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>To begin working with Python 2, import the package in Python 3 and create a new\n<tt>Python2</tt> object:</p>\n<pre>&gt;&gt;&gt; from python2.client import Python2\n&gt;&gt;&gt; py2 = Python2('/path/to/python2/executable')\n</pre>\n<p>This object is our gateway to the Python 2 world.  Python 2 builtins can be\naccessed as attributes of the <tt>Python2</tt> object. Let\u2019s use Python 2\u2019s\n<tt>__import__()</tt> function to import the deprecated <tt>sha</tt> module, which was\nremoved in Python 3:</p>\n<pre>&gt;&gt;&gt; py2_sha = py2.__import__('sha')\n&gt;&gt;&gt; py2_sha.sha('abc')\n&lt;Py2Object &lt;sha1 HASH object @ 0x107463c30&gt;&gt;\n</pre>\n<p>Ahh, just like the good ol\u2019 days.  You can deprecate a module but you can\u2019t\ndeprecate the human spirit!</p>\n<p>We can use the <tt>Python2.project()</tt> method to convert Python 3 objects to\nPython 2:</p>\n<pre>&gt;&gt;&gt; py2.project(1)\n&lt;Py2Object 1&gt;\n&gt;&gt;&gt; py2.project('foo')\n&lt;Py2Object u'foo'&gt;\n</pre>\n<p>You can use <tt>Python2.lift()</tt> to lift Python 2 objects back to Python 3.  For\ncontainer types, use <tt>Python2.deeplift()</tt> to recursively perform the lifting.\n<tt>Py2Object</tt> instances have special properties <tt>_</tt> and <tt>__</tt> to perform the\nequivalent operations:</p>\n<pre>&gt;&gt;&gt; o = py2.project([1, 2, 3])\n&gt;&gt;&gt; o\n&lt;Py2Object [1, 2, 3]&gt;\n&gt;&gt;&gt; o._\n[&lt;Py2Object 1&gt;, &lt;Py2Object 2&gt;, &lt;Py2Object 3&gt;]\n&gt;&gt;&gt; o.__\n[1, 2, 3]\n</pre>\n<p>Python 2 objects can be used pretty much like regular Python 3 objects.  You\ncan also freely mix and match with Python 3 builtin types:</p>\n<pre>&gt;&gt;&gt; x = py2.project(1)\n&gt;&gt;&gt; x\n&lt;Py2Object 1&gt;\n&gt;&gt;&gt; str(x)\n'1'\n&gt;&gt;&gt; x + 1\n&lt;Py2Object 2&gt;\n&gt;&gt;&gt; d = py2.dict(foo=x, bar=None)\n&gt;&gt;&gt; d['foo'] is x\nTrue\n&gt;&gt;&gt; del d['foo']\n&gt;&gt;&gt; d\n&lt;Py2Object {u'bar': None}&gt;\n&gt;&gt;&gt; d.__\n{'bar': None}\n</pre>\n<p>If you just want to execute some Python 2 code directly, you can use the\n<tt>Python2.exec()</tt> method.  This method accepts a string containing Python 2\ncode and an optional dict representing the scope to execute the code in, and\nreturns the resulting scope after executing the code.  This can be used to\ndefine new Python 2 classes and functions:</p>\n<pre>&gt;&gt;&gt; scope = py2.exec(\"\"\"\n... def foo(x):\n...     return x + 1\n... \"\"\")\n&gt;&gt;&gt; foo = scope['foo']\n&gt;&gt;&gt; foo(2)\n&lt;Py2Object 3&gt;\n</pre>\n<p>If an exception occurs in Python 2, a <tt>Py2Error</tt> will be thrown by the\nclient.  The Python 2 exception is stored as the <tt>exception</tt> attribute of the\n<tt>Py2Error</tt> object.  The underlying traceback is attached to the Python 2\nexception as the <tt>__traceback__</tt> attribute.</p>\n<pre>&gt;&gt;&gt; py2.int('asdf')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  ...\npython2.client.exceptions.Py2Error: ValueError: invalid literal for int() with base 10: 'asdf'\n</pre>\n<p>When you\u2019re done using Python 2, you can end the session by calling the\n<tt>Python2.shutdown()</tt> method.  You can also use the <tt>Python2</tt> object as a\ncontext manager to automatically do the same thing when exiting the context.</p>\n<pre>&gt;&gt;&gt; py2.shutdown()\n</pre>\n</div>\n<div id=\"testing\">\n<h2>Testing</h2>\n<p>This package uses Tox for testing.  Tests are not included in the Python dist,\nso you will need to clone the repo to run them.  To run the unit tests, install\nTox and run the following command from the project\u2019s base directory:</p>\n<pre>tox\n</pre>\n<p>After running tox, you can run the client-server integration tests with the\n\u2018integration_tests.sh\u2019 script.  This script takes two arguments specifying the\nTox virtualenvs to use for Python 2 and 3, respectively:</p>\n<pre>./integration_tests.sh py27 py36\n</pre>\n<p>To modify the behavior of Tox, you can set the <tt>PYTEST_ADDOPTS</tt> variable.\nFor example, you can set the <tt><span class=\"pre\">-x</span></tt> flag to abort after the first test\nfailure:</p>\n<pre>export PYTEST_ADDOPTS=-x\n</pre>\n<p>You can use the <tt><span class=\"pre\">-n</span> NUM</tt> flag to parallelize the tests using the\n<a href=\"http://pytest.org/dev/xdist.html\" rel=\"nofollow\">pytest-xdist plugin</a>  This adds some overhead to the test setup, so this\noption is primarily useful for speeding up the integration tests.</p>\n<blockquote>\nexport PYTEST_ADDOPTS=\u2019-n 4\u2019</blockquote>\n</div>\n<div id=\"caveats\">\n<h2>Caveats</h2>\n<div id=\"supported-types\">\n<h3>Supported types</h3>\n<p>Projection is only supported for basic builtin types.  Other objects cannot be\nprojected to Python 2.  The supported types are: <tt>bool</tt>, <tt>int</tt>, <tt>float</tt>,\n<tt>complex</tt>, <tt>bytes</tt>, <tt>unicode</tt>, <tt>bytearray</tt>, <tt>range</tt>, <tt>slice</tt>,\n<tt>list</tt>, <tt>tuple</tt>, <tt>set</tt>, <tt>frozenset</tt>, and <tt>dict</tt>.  The <tt>None</tt>,\n<tt>NotImplemented</tt>, and <tt>Ellipsis</tt> singletons are also supported.</p>\n<p>In particular, Python 3 functions, types, and instances of user-defined classes\ncannot currently be projected into Python 2.</p>\n</div>\n<div id=\"type-introspection\">\n<h3>Type introspection</h3>\n<p>The <tt>Py2Object</tt> class implements many \u201cmagic methods\u201d from the Python 3 data\nmodel.  As a result, a <tt>Py2Object</tt> appears to be callable, iterable, etc.,\neven if the underlying object is not.  Attempting to perform such operations may\nresult in a <tt>Py2Error</tt>.</p>\n<p>If you need to introspect a Python 2 object, use the corresponding <em>Python 2</em>\nbuiltin functions.  For example:</p>\n<pre>&gt;&gt;&gt; i = py2.project(1)\n&gt;&gt;&gt; py2.callable(i)\n&lt;Py2Object False&gt;\n&gt;&gt;&gt; py2.isinstance(i, py2.int)\n&lt;Py2Object True&gt;\n</pre>\n</div>\n<div id=\"string-types\">\n<h3>String types</h3>\n<p>In Python 2, <tt>str</tt> objects are raw byte strings, while in Python 3 they are\nUnicode strings.  This can lead to some confusion, as projecting a Python 3\n<tt>str</tt> will result in a Python 2 <tt>unicode</tt> object, while lifting a Python 2\n<tt>str</tt> will return a Python 3 <tt>bytes</tt> object.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; py2.project('foo')\n&lt;Py2Object u'foo'&gt;\n&gt;&gt;&gt; py2.lift(py2.str(123))\nb'123'\n</pre>\n</blockquote>\n</div>\n<div id=\"division\">\n<h3>Division</h3>\n<p>The behavior of the division operator changed with <a href=\"https://www.python.org/dev/peps/pep-0238/\" rel=\"nofollow\">PEP 238</a>.  This created\ntwo alternate division operations, \u201ctrue division\u201d and \u201cclassic division\u201d.\nClassic division was removed in Python 3.</p>\n<p>To respect this change, when two <tt>Py2Object</tt> s are divided, classic division\nis used.  When a <tt>Py2Object</tt> divides or is divided by a Python 3 value, true division is used.</p>\n<pre>&gt;&gt;&gt; i = py2.project(1)\n&gt;&gt;&gt; j = py2.project(2)\n&gt;&gt;&gt; i / j  # classic division\n&lt;Py2Object 0&gt;\n&gt;&gt;&gt; i / 2  # true division\n&lt;Py2Object 0.5&gt;\n&gt;&gt;&gt; 1 / j  # true division\n&lt;Py2Object 0.5&gt;\n</pre>\n</div>\n</div>\n<div id=\"further-discussion\">\n<h2>Further discussion</h2>\n<div id=\"how-it-works\">\n<h3>How it works</h3>\n<p>When you launch a Python 2 session, the library spawns a child process running\nPython 2.  This child process runs a <em>server</em> that listens for commands from\nthe Python 3 <em>client</em>.  For each command, the server performs an operation in\nPython 2 and returns the result either as an encoded <em>value</em> made up of\nsupported types, or a <em>reference</em> to a Python 2 object stored on the server.</p>\n<p>On the client side, the library wraps Python 2 references with the\n<tt>Py2Object</tt> class.  This class implements many of the \u201cmagic methods\u201d of the\n<a href=\"https://docs.python.org/3/reference/datamodel.html\" rel=\"nofollow\">Python 3 data model</a> by sending commands to the Python 2 server to perform\nthe appropriate operation on the underlying Python 2 object.</p>\n</div>\n<div id=\"call-by-value-semantics\">\n<h3>Call-by-value semantics</h3>\n<p>When projecting a value or calling a Python 2 function with Python 3 arguments,\nthe arguments will be passed to Python 2 \u201cby value\u201d, that is, by encoding the\nvalue of the argument to be decoded by the server.  When using a Python 2\nobject, the object is stored in the Python 2 session and is passed \u201cby\nreference\u201d.</p>\n<p>This has some implications for the semantics of Python 2 functions.  Suppose we\nhave a Python 2 function that mutates a list.  If we pass this function a\nPython 3 list, the list will be copied into Python 2 and the copy will be\nmutated, but the original will not be modified:</p>\n<pre>&gt;&gt;&gt; f = py2.eval(\"lambda l: l.append(1)\")\n&gt;&gt;&gt; l = []\n&gt;&gt;&gt; f(l)\n&lt;Py2Object None&gt;\n&gt;&gt;&gt; l\n[]\n</pre>\n<p>However, if we project the list into Python 2 before passing it to the\nfunction, then we can observe the modifications on the projected list:</p>\n<pre>&gt;&gt;&gt; py2_l = py2.project(l)\n&gt;&gt;&gt; f(py2_l)\n&lt;Py2Object None&gt;\n&gt;&gt;&gt; py2_l\n&lt;Py2Object [1]&gt;\n</pre>\n</div>\n<div id=\"return-semantics\">\n<h3>Return semantics</h3>\n<p>Returning generally occurs by reference except for operations that require a\nspecific return type (<tt>str()</tt>, <tt>int()</tt>, etc.).  The main reason for this is\nthat returning by value may lose information about object identity that needs\nto be preserved.  Return values can be easily lifted to Python 2 if desired.</p>\n</div>\n<div id=\"object-identity-and-lifespan\">\n<h3>Object identity and lifespan</h3>\n<p>Each Python 2 object returned by the server is represented by a unique\n<tt>Py2Object</tt>.  This means that the <tt>is</tt> operator can be used to determine if\ntwo <tt>Py2Object</tt> s refer to the same underlying object.</p>\n<p>The Python 2 server stores all objects it returns, to prevent them from being\ndeallocated.  When the corresponding <tt>Py2Object</tt> is deallocated in the Python\n3 process, the underlying Python 2 object will be removed from the server cache\nto allow it to be deallocated as appropriate.</p>\n</div>\n<div id=\"encoding-algorithm\">\n<h3>Encoding algorithm</h3>\n<p>This library uses a simple JSON encoding for supported types.  For a given\nfunction call, each unique object will only be encoded once.  This means that\ndata structures with circular references are supported.  For a detailed\ndescription of the algorithm, see the <tt>python2.shared.codec</tt> module.</p>\n</div>\n</div>\n<div id=\"possible-improvements\">\n<h2>Possible improvements</h2>\n<div id=\"python-2-types\">\n<h3>Python 2 types</h3>\n<p>Currently there is a single type for Python 2 objects in Python 3,\n<tt>Py2Object</tt>. An alternate strategy would be to dynamically create Python 3\nclasses for each Python 2 type encountered, and create proxy objects as\ninstances of these classes.</p>\n<p>The main benefit of this change would be better type introspection for Python 2\nobjects (see the discussion at <a href=\"#type-introspection\" rel=\"nofollow\">Type introspection</a>).  However, it would be\nmore cumbersome and incur a performance cost, since the client would need to\nknow the type of each object and the methods supported by that type.\nAdditionally, this approach would not fully support the dynamic nature of the\nPython type system, since the proxied type would not reflect changes to the\nunderlying type such as adding or removing methods.</p>\n<p>This would require the server to return the object type for references, and\nsome mechanism for the client to introspect Python 2 types.  The client would\ncache types for the lifetime of the Python 2 session, with a mechanism to\nexplicitly refresh a type to pick up any changes that had occurred in Python 2.</p>\n<p>Bootstrapping the type system might be a little tricky.  We would want to\ncreate a type <tt>Py2type</tt> such all proxy types are instances of, <em>including\n``Py2type`` itself.</em>  We would also probably want a base type for all proxy\nobjects, including types.</p>\n</div>\n<div id=\"python-3-proxy-objects-in-python-2\">\n<h3>Python 3 proxy objects in Python 2</h3>\n<p>Currently the relationship between client and server is asymmetrical.  The\nclient has a representation of Python 2 objects, but the server does not have\na way to represent Python 3 objects.  We might like to add such a mechanism.\nThis would mean that instead of the simple request-response pattern from client\nto server we have now, there would be the possibility of callbacks.  In effect,\nthe two processes would act more like coroutines with the flow of control\npassing back and forth between them.</p>\n</div>\n<div id=\"better-python-version-support\">\n<h3>Better Python version support</h3>\n<p>We could extend support to more Python 2 and 3 versions.</p>\n</div>\n</div>\n<div id=\"similar-projects\">\n<h2>Similar projects</h2>\n<p>After writing this library, I discovered that I\u2019m not the only one to have had\nthis idea.  <a href=\"https://github.com/nicois/sux/\" rel=\"nofollow\">Sux</a> is a library that provides similar functionality, with some\nnotable differences:</p>\n<ul>\n<li>The library is much smaller and more lightweight, and only needs to be\ninstalled in the Python 3 environment to work.</li>\n<li>The main emphasis is on imports and function calls, which makes sense since\nthese are the most important operations for the using legacy packages.  Most\nother operators (e.g. arithmetic operators) are not supported.</li>\n<li>The library uses Pickle to communicate between the Python 2 and 3 processes.\nThis is a good idea and I should probably have done the same, although I had\nfun implementing the current encoding algorithm.</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 2654677, "releases": {"1.1": [{"comment_text": "", "digests": {"md5": "fff8760790c713e30d95577069166678", "sha256": "e1edc9b99ca53f02cb53e890919d8a20fc6deb0d5bbd5de32e4de5084982ad91"}, "downloads": -1, "filename": "python2-1.1.tar.gz", "has_sig": false, "md5_digest": "fff8760790c713e30d95577069166678", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15442, "upload_time": "2017-02-18T08:22:07", "upload_time_iso_8601": "2017-02-18T08:22:07.642204Z", "url": "https://files.pythonhosted.org/packages/7a/dc/05cff0a37a272f2bbc00ec00cf351528bf53559e493a8671645ad8ed7d27/python2-1.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "c45fe5ae2353b471e21ba15e66398aa2", "sha256": "9219352345a5cfcdf2e104c469bcbfe5b959b8e15f194988809b984a3fcdda55"}, "downloads": -1, "filename": "python2-1.2.tar.gz", "has_sig": false, "md5_digest": "c45fe5ae2353b471e21ba15e66398aa2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15915, "upload_time": "2017-02-20T12:00:59", "upload_time_iso_8601": "2017-02-20T12:00:59.551158Z", "url": "https://files.pythonhosted.org/packages/7d/b5/fa7609a6ae251044c5751b14caae6bc29c129956ad251afd2d9cfcf7be6e/python2-1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c45fe5ae2353b471e21ba15e66398aa2", "sha256": "9219352345a5cfcdf2e104c469bcbfe5b959b8e15f194988809b984a3fcdda55"}, "downloads": -1, "filename": "python2-1.2.tar.gz", "has_sig": false, "md5_digest": "c45fe5ae2353b471e21ba15e66398aa2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15915, "upload_time": "2017-02-20T12:00:59", "upload_time_iso_8601": "2017-02-20T12:00:59.551158Z", "url": "https://files.pythonhosted.org/packages/7d/b5/fa7609a6ae251044c5751b14caae6bc29c129956ad251afd2d9cfcf7be6e/python2-1.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:54:27 2020"}