{"info": {"author": "NVIDIA", "author_email": "linux-tegra-bugs@nvidia.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Software Development", "Topic :: System :: Hardware"], "description": "# Jetson.GPIO - Linux for Tegra\n\nJetson TX1, TX2, AGX Xavier, and Nano development boards contain a 40 pin GPIO\nheader, similar to the 40 pin header in the Raspberry Pi. These GPIOs can be\ncontrolled for digital input and output using the Python library provided in the\nJetson GPIO Library package. The library has the same API as the RPi.GPIO\nlibrary for Raspberry Pi in order to provide an easy way to move applications\nrunning on the Raspberry Pi to the Jetson board.\n\nThis document walks through what is contained in The Jetson GPIO library\npackage, how to configure the system and run the provided sample applications,\nand the library API.\n\n# Package Components\n\nIn addition to this document, the Jetson GPIO library package contains the\nfollowing:\n\n1. The `lib/python/` subdirectory contains the Python modules that implement all\nlibrary functionality. The gpio.py module is the main component that will be\nimported into an application and provides the needed APIs. The `gpio_event.py`\nand `gpio_pin_data.py` modules are used by the `gpio.py` module and must not be\nimported directly in to an application.\n\n2. The `samples/` subdirectory contains sample applications to help in getting\nfamiliar with the library API and getting started on an application. The\n`simple_input.py` and `simple_output.py` applications show how to perform read\nand write to a GPIO pin respectively, while the `button_led.py`,\n`button_event.py` and `button_interrupt.py` show how a button press may be used\nto blink an LED using busy-waiting, blocking wait and interrupt callbacks\nrespectively.\n\n# Installation\n\n## Using pip\n\nThe easiest way to install this library is using `pip`:\n```shell\nsudo pip install Jetson.GPIO\n```\n\n## Manual download \n\nYou may clone this git repository, or download a copy of it as an archive file\nand decompress it. You may place the library files anywhere you like on your\nsystem. You may use the library directly from this directory by manually\nsetting `PYTHONPATH`, or install it using `setup.py`:\n```shell\nsudo python3 setup.py install\n```\n\n# Setting User Permissions\n\nIn order to use the Jetson GPIO Library, the correct user permissions/groups must\nbe set first.\n\nCreate a new gpio user group. Then add your user to the newly created group.\n```shell\nsudo groupadd -f -r gpio\nsudo usermod -a -G gpio your_user_name\n```\n\nInstall custom udev rules by copying the 99-gpio.rules file into the rules.d\ndirectory.\n\nIf you have downloaded the source to Jetson.GPIO:\n```shell\nsudo cp lib/python/Jetson/GPIO/99-gpio.rules /etc/udev/rules.d/\n```\n\nIf you installed Jetson.GPIO from a package, e.g. using pip into a virtual\nenvironment:\n```shell\nsudo cp venv/lib/pythonNN/site-packages/Jetson/GPIO/99-gpio.rules /etc/udev/rules.d/\n```\n\nFor the new rule to take place, you either need to reboot or reload the udev\nrules by running:\n```shell\nsudo udevadm control --reload-rules && sudo udevadm trigger\n```\n\n# Running the sample scripts\n\nWith the permissions set as needed, the sample applications provided in the\n`samples/` directory can be used. The following describes the operation of each\napplication:\n\n1. `simple_input.py`: This application uses the BCM pin numbering mode and reads\nthe value at pin 12 of the 40 pin header and prints the value to the\nscreen.\n\n2. `simple_out.py`: This application uses the BCM pin numbering mode from\nRaspberry Pi and outputs alternating high and low values at BCM pin 18 (or\nboard pin 12 on the header) every 2 seconds.\n\n3. `button_led.py`: This application uses the BOARD pin numbering. It requires a\nbutton connected to pin 18 and GND, a pull-up resistor connecting pin 18\nto 3V3 and an LED and current limiting resistor connected to pin 12. The\napplication reads the button state and keeps the LED on for 1 second every\ntime the button is pressed.\n\n4. `button_event.py`: This application uses the BOARD pin numbering. It requires a\nbutton connected to pin 18 and GND, a pull-up resistor connecting the button\nto 3V3 and an LED and current limiting resistor connected to pin 12. The\napplication performs the same function as the button_led.py but performs a\nblocking wait for the button press event instead of continuously checking the\nvalue of the pin in order to reduce CPU usage.\n\n5. `button_interrupt.py`: This application uses the BOARD pin numbering. It\nrequires a button connected to pin 18 and GND, a pull-up resistor connecting\nthe button to 3V3, an LED and current limiting resistor connected to pin 12\nand a second LED and current limiting resistor connected to pin 13. The\napplication slowly blinks the first LED continuously and rapidly blinks the\nsecond LED five times only when the button is pressed.\n\nTo run these sample applications if Jetson.GPIO is added to the PYTHONPATH:\n```shell\npython3 <name_of_application_to_run>\n```\n\nAlternatively, if Jetson.GPIO is not added to the PYTHONPATH, the `run_sample.sh`\nscript can be used to run these sample applications. This can be done with the\nfollowing command when in the samples/ directory:\n```shell\n./run_sample.sh <name_of_application_to_run>\n```\n\nThe usage of the script can also be viewed by using:\n```shell\n./run_sample.sh -h\n./run_sample.sh --help\n```\n\n# Complete library API\n\nThe Jetson GPIO library provides all public APIs provided by the RPi.GPIO\nlibrary. The following discusses the use of each API:\n\n#### 1. Importing the libary\n\nTo import the Jetson.GPIO module use:\n```python\nimport Jetson.GPIO as GPIO\n```\n\nThis way, you can refer to the module as GPIO throughout the rest of the\napplication. The module can also be imported using the name RPi.GPIO instead of\nJetson.GPIO for existing code using the RPi library.\n\n#### 2. Pin numbering\n\nThe Jetson GPIO library provides four ways of numbering the I/O pins. The first\ntwo correspond to the modes provided by the RPi.GPIO library, i.e BOARD and BCM\nwhich refer to the pin number of the 40 pin GPIO header and the Broadcom SoC\nGPIO numbers respectively. The remaining two modes, CVM and TEGRA_SOC use\nstrings instead of numbers which correspond to signal names on the CVM/CVB\nconnector and the Tegra SoC respectively.\n\nTo specify which mode you are using (mandatory), use the following function\ncall:\n```python\nGPIO.setmode(GPIO.BOARD)\n# or\nGPIO.setmode(GPIO.BCM)\n# or\nGPIO.setmode(GPIO.CVM)\n# or\nGPIO.setmode(GPIO.TEGRA_SOC)\n```\n\nTo check which mode has be set, you can call:\n```python\nmode = GPIO.getmode()\n```\n\nThe mode must be one of GPIO.BOARD, GPIO.BCM, GPIO.CVM, GPIO.TEGRA_SOC or\nNone.\n\n#### 3. Warnings\n\nIt is possible that the GPIO you are trying to use is already being used\nexternal to the current application. In such a condition, the Jetson GPIO\nlibrary will warn you if the GPIO being used is configured to anything but the\ndefault direction (input). It will also warn you if you try cleaning up before\nsetting up the mode and channels. To disable warnings, call:\n```python\nGPIO.setwarnings(False)\n```\n\n#### 4. Set up a channel\n\nThe GPIO channel must be set up before use as input or output. To configure\nthe channel as input, call:\n```python\n# (where channel is based on the pin numbering mode discussed above)\nGPIO.setup(channel, GPIO.IN)\n```\n\nTo set up a channel as output, call:\n```python\nGPIO.setup(channel, GPIO.OUT)\n```\n\nIt is also possible to specify an initial value for the output channel:\n```python\nGPIO.setup(channel, GPIO.OUT, initial=GPIO.HIGH)\n```\n\nWhen setting up a channel as output, it is also possible to set up more than one\nchannel at once:\n```python\n# add as many as channels as needed. You can also use tuples: (18,12,13)\nchannels = [18, 12, 13]\nGPIO.setup(channels, GPIO.OUT)\n```\n\n#### 5. Input\n\nTo read the value of a channel, use:\n\n```python\nGPIO.input(channel)\n```\n\nThis will return either GPIO.LOW or GPIO.HIGH.\n\n#### 6. Output\n\nTo set the value of a pin configured as output, use:\n\n```python\nGPIO.output(channel, state)\n```\n\nwhere state can be GPIO.LOW or GPIO.HIGH.\n\nYou can also output to a list or tuple of channels:\n\n```python\nchannels = [18, 12, 13] # or use tuples\nGPIO.output(channels, GPIO.HIGH) # or GPIO.LOW\n# set first channel to HIGH and rest to LOW\nGPIO.output(channel, (GPIO.LOW, GPIO.HIGH, GPIO.HIGH))\n```\n\n#### 7. Clean up\n\nAt the end of the program, it is good to clean up the channels so that all pins\nare set in their default state. To clean up all channels used, call:\n\n```python\nGPIO.cleanup()\n```\n\nIf you don't want to clean all channels, it is also possible to clean up\nindividual channels or a list or tuple of channels:\n\n```python\nGPIO.cleanup(chan1) # cleanup only chan1\nGPIO.cleanup([chan1, chan2]) # cleanup only chan1 and chan2\nGPIO.cleanup((chan1, chan2))  # does the same operation as previous statement\n```\n\n#### 8. Jetson Board Information and library version\n\nTo get information about the Jetson module, use/read:\n\n```python\nGPIO.JETSON_INFO\n```\n\nThis provides a Python dictionary with the following keys: P1_REVISION, RAM,\nREVISION, TYPE, MANUFACTURER and PROCESSOR. All values in the dictionary are\nstrings with the exception of P1_REVISION which is an integer.\n\nTo get information about the library version, use/read:\n\n```python\nGPIO.VERSION\n```\n\nThis provides a string with the X.Y.Z version format.\n\n#### 9. Interrupts\n\nAside from busy-polling, the library provides three additional ways of\nmonitoring an input event:\n\n##### The wait_for_edge() function\n\nThis function blocks the calling thread until the provided edge(s) is\ndetected. The function can be called as follows:\n\n```python\nGPIO.wait_for_edge(channel, GPIO.RISING)\n```\n\nThe second parameter specifies the edge to be detected and can be\nGPIO.RISING, GPIO.FALLING or GPIO.BOTH. If you only want to limit the wait\nto a specified amount of time, a timeout can be optionally set:\n\n```python\n# timeout is in milliseconds\nGPIO.wait_for_edge(channel, GPIO.RISING, timeout=500)\n```\n\nThe function returns the channel for which the edge was detected or None if a\ntimeout occurred.\n\n##### The event_detected() function\n\nThis function can be used to periodically check if an event occurred since the\nlast call. The function can be set up and called as follows:\n\n```python\n# set rising edge detection on the channel\nGPIO.add_event_detect(channel, GPIO.RISING)\nrun_other_code()\nif GPIO.event_detected(channel):\n    do_something()\n```\n\nAs before, you can detect events for GPIO.RISING, GPIO.FALLING or GPIO.BOTH.\n\n##### A callback function run when an edge is detected\n\nThis feature can be used to run a second thread for callback functions. Hence,\nthe callback function can be run concurrent to your main program in response\nto an edge. This feature can be used as follows:\n\n```python\n# define callback function\ndef callback_fn(channel):\n    print(\"Callback called from channel %s\" % channel)\n\n# add rising edge detection\nGPIO.add_event_detect(channel, GPIO.RISING, callback=callback_fn)\n```\n\nMore than one callback can also be added if required as follows:\n\n```python\ndef callback_one(channel):\n    print(\"First Callback\")\n\ndef callback_two(channel):\n    print(\"Second Callback\")\n\nGPIO.add_event_detect(channel, GPIO.RISING)\nGPIO.add_event_callback(channel, callback_one)\nGPIO.add_event_callback(channel, callback_two)\n```\n\nThe two callbacks in this case are run sequentially, not concurrently since\nthere is only thread running all callback functions.\n\nIn order to prevent multiple calls to the callback functions by collapsing\nmultiple events in to a single one, a debounce time can be optionally set:\n\n```python\n# bouncetime set in milliseconds\nGPIO.add_event_detect(channel, GPIO.RISING, callback=callback_fn,\nbouncetime=200)\n```\n\nIf the edge detection is not longer required it can be removed as follows:\n\n```python\nGPIO.remove_event_detect(channel)\n```\n\n#### 10. Check function of GPIO channels\n\nThis feature allows you to check the function of the provided GPIO channel:\n\n```python\nGPIO.gpio_function(channel)\n```\n\nThe function returns either GPIO.IN or GPIO.OUT.\n\n#### 11. PWM\n\nSee `samples/simple_pwm.py` for details on how to use PWM channels.\n\nThe Jetson.GPIO library supports PWM only on pins with attached hardware PWM\ncontrollers. Unlike the RPi.GPIO library, the Jetson.GPIO library does not\nimplement Software emulated PWM. Jetson Nano supports 2 PWM channels, and\nJetson AGX Xavier supports 3 PWM channels. Jetson TX1 and TX2 do not support\nany PWM channels.\n\nThe system pinmux must be configured to connect the hardware PWM controlller(s)\nto the relevant pins. If the pinmux is not configured, PWM signals will not\nreach the pins! The Jetson.GPIO library does not dynamically modify the pinmux\nconfiguration to achieve this. Read the L4T documentation for details on how to\nconfigure the pinmux.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/NVIDIA/jetson-gpio", "keywords": "Jetson GPIO", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "Jetson.GPIO", "package_url": "https://pypi.org/project/Jetson.GPIO/", "platform": "", "project_url": "https://pypi.org/project/Jetson.GPIO/", "project_urls": {"Homepage": "https://github.com/NVIDIA/jetson-gpio"}, "release_url": "https://pypi.org/project/Jetson.GPIO/2.0.8/", "requires_dist": null, "requires_python": "", "summary": "A module to control Jetson GPIO channels", "version": "2.0.8", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Jetson.GPIO - Linux for Tegra</h1>\n<p>Jetson TX1, TX2, AGX Xavier, and Nano development boards contain a 40 pin GPIO\nheader, similar to the 40 pin header in the Raspberry Pi. These GPIOs can be\ncontrolled for digital input and output using the Python library provided in the\nJetson GPIO Library package. The library has the same API as the RPi.GPIO\nlibrary for Raspberry Pi in order to provide an easy way to move applications\nrunning on the Raspberry Pi to the Jetson board.</p>\n<p>This document walks through what is contained in The Jetson GPIO library\npackage, how to configure the system and run the provided sample applications,\nand the library API.</p>\n<h1>Package Components</h1>\n<p>In addition to this document, the Jetson GPIO library package contains the\nfollowing:</p>\n<ol>\n<li>\n<p>The <code>lib/python/</code> subdirectory contains the Python modules that implement all\nlibrary functionality. The gpio.py module is the main component that will be\nimported into an application and provides the needed APIs. The <code>gpio_event.py</code>\nand <code>gpio_pin_data.py</code> modules are used by the <code>gpio.py</code> module and must not be\nimported directly in to an application.</p>\n</li>\n<li>\n<p>The <code>samples/</code> subdirectory contains sample applications to help in getting\nfamiliar with the library API and getting started on an application. The\n<code>simple_input.py</code> and <code>simple_output.py</code> applications show how to perform read\nand write to a GPIO pin respectively, while the <code>button_led.py</code>,\n<code>button_event.py</code> and <code>button_interrupt.py</code> show how a button press may be used\nto blink an LED using busy-waiting, blocking wait and interrupt callbacks\nrespectively.</p>\n</li>\n</ol>\n<h1>Installation</h1>\n<h2>Using pip</h2>\n<p>The easiest way to install this library is using <code>pip</code>:</p>\n<pre>sudo pip install Jetson.GPIO\n</pre>\n<h2>Manual download</h2>\n<p>You may clone this git repository, or download a copy of it as an archive file\nand decompress it. You may place the library files anywhere you like on your\nsystem. You may use the library directly from this directory by manually\nsetting <code>PYTHONPATH</code>, or install it using <code>setup.py</code>:</p>\n<pre>sudo python3 setup.py install\n</pre>\n<h1>Setting User Permissions</h1>\n<p>In order to use the Jetson GPIO Library, the correct user permissions/groups must\nbe set first.</p>\n<p>Create a new gpio user group. Then add your user to the newly created group.</p>\n<pre>sudo groupadd -f -r gpio\nsudo usermod -a -G gpio your_user_name\n</pre>\n<p>Install custom udev rules by copying the 99-gpio.rules file into the rules.d\ndirectory.</p>\n<p>If you have downloaded the source to Jetson.GPIO:</p>\n<pre>sudo cp lib/python/Jetson/GPIO/99-gpio.rules /etc/udev/rules.d/\n</pre>\n<p>If you installed Jetson.GPIO from a package, e.g. using pip into a virtual\nenvironment:</p>\n<pre>sudo cp venv/lib/pythonNN/site-packages/Jetson/GPIO/99-gpio.rules /etc/udev/rules.d/\n</pre>\n<p>For the new rule to take place, you either need to reboot or reload the udev\nrules by running:</p>\n<pre>sudo udevadm control --reload-rules <span class=\"o\">&amp;&amp;</span> sudo udevadm trigger\n</pre>\n<h1>Running the sample scripts</h1>\n<p>With the permissions set as needed, the sample applications provided in the\n<code>samples/</code> directory can be used. The following describes the operation of each\napplication:</p>\n<ol>\n<li>\n<p><code>simple_input.py</code>: This application uses the BCM pin numbering mode and reads\nthe value at pin 12 of the 40 pin header and prints the value to the\nscreen.</p>\n</li>\n<li>\n<p><code>simple_out.py</code>: This application uses the BCM pin numbering mode from\nRaspberry Pi and outputs alternating high and low values at BCM pin 18 (or\nboard pin 12 on the header) every 2 seconds.</p>\n</li>\n<li>\n<p><code>button_led.py</code>: This application uses the BOARD pin numbering. It requires a\nbutton connected to pin 18 and GND, a pull-up resistor connecting pin 18\nto 3V3 and an LED and current limiting resistor connected to pin 12. The\napplication reads the button state and keeps the LED on for 1 second every\ntime the button is pressed.</p>\n</li>\n<li>\n<p><code>button_event.py</code>: This application uses the BOARD pin numbering. It requires a\nbutton connected to pin 18 and GND, a pull-up resistor connecting the button\nto 3V3 and an LED and current limiting resistor connected to pin 12. The\napplication performs the same function as the button_led.py but performs a\nblocking wait for the button press event instead of continuously checking the\nvalue of the pin in order to reduce CPU usage.</p>\n</li>\n<li>\n<p><code>button_interrupt.py</code>: This application uses the BOARD pin numbering. It\nrequires a button connected to pin 18 and GND, a pull-up resistor connecting\nthe button to 3V3, an LED and current limiting resistor connected to pin 12\nand a second LED and current limiting resistor connected to pin 13. The\napplication slowly blinks the first LED continuously and rapidly blinks the\nsecond LED five times only when the button is pressed.</p>\n</li>\n</ol>\n<p>To run these sample applications if Jetson.GPIO is added to the PYTHONPATH:</p>\n<pre>python3 &lt;name_of_application_to_run&gt;\n</pre>\n<p>Alternatively, if Jetson.GPIO is not added to the PYTHONPATH, the <code>run_sample.sh</code>\nscript can be used to run these sample applications. This can be done with the\nfollowing command when in the samples/ directory:</p>\n<pre>./run_sample.sh &lt;name_of_application_to_run&gt;\n</pre>\n<p>The usage of the script can also be viewed by using:</p>\n<pre>./run_sample.sh -h\n./run_sample.sh --help\n</pre>\n<h1>Complete library API</h1>\n<p>The Jetson GPIO library provides all public APIs provided by the RPi.GPIO\nlibrary. The following discusses the use of each API:</p>\n<h4>1. Importing the libary</h4>\n<p>To import the Jetson.GPIO module use:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">Jetson.GPIO</span> <span class=\"k\">as</span> <span class=\"nn\">GPIO</span>\n</pre>\n<p>This way, you can refer to the module as GPIO throughout the rest of the\napplication. The module can also be imported using the name RPi.GPIO instead of\nJetson.GPIO for existing code using the RPi library.</p>\n<h4>2. Pin numbering</h4>\n<p>The Jetson GPIO library provides four ways of numbering the I/O pins. The first\ntwo correspond to the modes provided by the RPi.GPIO library, i.e BOARD and BCM\nwhich refer to the pin number of the 40 pin GPIO header and the Broadcom SoC\nGPIO numbers respectively. The remaining two modes, CVM and TEGRA_SOC use\nstrings instead of numbers which correspond to signal names on the CVM/CVB\nconnector and the Tegra SoC respectively.</p>\n<p>To specify which mode you are using (mandatory), use the following function\ncall:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">setmode</span><span class=\"p\">(</span><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">BOARD</span><span class=\"p\">)</span>\n<span class=\"c1\"># or</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">setmode</span><span class=\"p\">(</span><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">BCM</span><span class=\"p\">)</span>\n<span class=\"c1\"># or</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">setmode</span><span class=\"p\">(</span><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">CVM</span><span class=\"p\">)</span>\n<span class=\"c1\"># or</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">setmode</span><span class=\"p\">(</span><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">TEGRA_SOC</span><span class=\"p\">)</span>\n</pre>\n<p>To check which mode has be set, you can call:</p>\n<pre><span class=\"n\">mode</span> <span class=\"o\">=</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">getmode</span><span class=\"p\">()</span>\n</pre>\n<p>The mode must be one of GPIO.BOARD, GPIO.BCM, GPIO.CVM, GPIO.TEGRA_SOC or\nNone.</p>\n<h4>3. Warnings</h4>\n<p>It is possible that the GPIO you are trying to use is already being used\nexternal to the current application. In such a condition, the Jetson GPIO\nlibrary will warn you if the GPIO being used is configured to anything but the\ndefault direction (input). It will also warn you if you try cleaning up before\nsetting up the mode and channels. To disable warnings, call:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">setwarnings</span><span class=\"p\">(</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<h4>4. Set up a channel</h4>\n<p>The GPIO channel must be set up before use as input or output. To configure\nthe channel as input, call:</p>\n<pre><span class=\"c1\"># (where channel is based on the pin numbering mode discussed above)</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">setup</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">IN</span><span class=\"p\">)</span>\n</pre>\n<p>To set up a channel as output, call:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">setup</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">OUT</span><span class=\"p\">)</span>\n</pre>\n<p>It is also possible to specify an initial value for the output channel:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">setup</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">OUT</span><span class=\"p\">,</span> <span class=\"n\">initial</span><span class=\"o\">=</span><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">HIGH</span><span class=\"p\">)</span>\n</pre>\n<p>When setting up a channel as output, it is also possible to set up more than one\nchannel at once:</p>\n<pre><span class=\"c1\"># add as many as channels as needed. You can also use tuples: (18,12,13)</span>\n<span class=\"n\">channels</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">18</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">13</span><span class=\"p\">]</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">setup</span><span class=\"p\">(</span><span class=\"n\">channels</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">OUT</span><span class=\"p\">)</span>\n</pre>\n<h4>5. Input</h4>\n<p>To read the value of a channel, use:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">input</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">)</span>\n</pre>\n<p>This will return either GPIO.LOW or GPIO.HIGH.</p>\n<h4>6. Output</h4>\n<p>To set the value of a pin configured as output, use:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">output</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">state</span><span class=\"p\">)</span>\n</pre>\n<p>where state can be GPIO.LOW or GPIO.HIGH.</p>\n<p>You can also output to a list or tuple of channels:</p>\n<pre><span class=\"n\">channels</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">18</span><span class=\"p\">,</span> <span class=\"mi\">12</span><span class=\"p\">,</span> <span class=\"mi\">13</span><span class=\"p\">]</span> <span class=\"c1\"># or use tuples</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">output</span><span class=\"p\">(</span><span class=\"n\">channels</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">HIGH</span><span class=\"p\">)</span> <span class=\"c1\"># or GPIO.LOW</span>\n<span class=\"c1\"># set first channel to HIGH and rest to LOW</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">output</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">LOW</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">HIGH</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">HIGH</span><span class=\"p\">))</span>\n</pre>\n<h4>7. Clean up</h4>\n<p>At the end of the program, it is good to clean up the channels so that all pins\nare set in their default state. To clean up all channels used, call:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">cleanup</span><span class=\"p\">()</span>\n</pre>\n<p>If you don't want to clean all channels, it is also possible to clean up\nindividual channels or a list or tuple of channels:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">cleanup</span><span class=\"p\">(</span><span class=\"n\">chan1</span><span class=\"p\">)</span> <span class=\"c1\"># cleanup only chan1</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">cleanup</span><span class=\"p\">([</span><span class=\"n\">chan1</span><span class=\"p\">,</span> <span class=\"n\">chan2</span><span class=\"p\">])</span> <span class=\"c1\"># cleanup only chan1 and chan2</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">cleanup</span><span class=\"p\">((</span><span class=\"n\">chan1</span><span class=\"p\">,</span> <span class=\"n\">chan2</span><span class=\"p\">))</span>  <span class=\"c1\"># does the same operation as previous statement</span>\n</pre>\n<h4>8. Jetson Board Information and library version</h4>\n<p>To get information about the Jetson module, use/read:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">JETSON_INFO</span>\n</pre>\n<p>This provides a Python dictionary with the following keys: P1_REVISION, RAM,\nREVISION, TYPE, MANUFACTURER and PROCESSOR. All values in the dictionary are\nstrings with the exception of P1_REVISION which is an integer.</p>\n<p>To get information about the library version, use/read:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">VERSION</span>\n</pre>\n<p>This provides a string with the X.Y.Z version format.</p>\n<h4>9. Interrupts</h4>\n<p>Aside from busy-polling, the library provides three additional ways of\nmonitoring an input event:</p>\n<h5>The wait_for_edge() function</h5>\n<p>This function blocks the calling thread until the provided edge(s) is\ndetected. The function can be called as follows:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">RISING</span><span class=\"p\">)</span>\n</pre>\n<p>The second parameter specifies the edge to be detected and can be\nGPIO.RISING, GPIO.FALLING or GPIO.BOTH. If you only want to limit the wait\nto a specified amount of time, a timeout can be optionally set:</p>\n<pre><span class=\"c1\"># timeout is in milliseconds</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">wait_for_edge</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">RISING</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mi\">500</span><span class=\"p\">)</span>\n</pre>\n<p>The function returns the channel for which the edge was detected or None if a\ntimeout occurred.</p>\n<h5>The event_detected() function</h5>\n<p>This function can be used to periodically check if an event occurred since the\nlast call. The function can be set up and called as follows:</p>\n<pre><span class=\"c1\"># set rising edge detection on the channel</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">add_event_detect</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">RISING</span><span class=\"p\">)</span>\n<span class=\"n\">run_other_code</span><span class=\"p\">()</span>\n<span class=\"k\">if</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">event_detected</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">):</span>\n    <span class=\"n\">do_something</span><span class=\"p\">()</span>\n</pre>\n<p>As before, you can detect events for GPIO.RISING, GPIO.FALLING or GPIO.BOTH.</p>\n<h5>A callback function run when an edge is detected</h5>\n<p>This feature can be used to run a second thread for callback functions. Hence,\nthe callback function can be run concurrent to your main program in response\nto an edge. This feature can be used as follows:</p>\n<pre><span class=\"c1\"># define callback function</span>\n<span class=\"k\">def</span> <span class=\"nf\">callback_fn</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Callback called from channel </span><span class=\"si\">%s</span><span class=\"s2\">\"</span> <span class=\"o\">%</span> <span class=\"n\">channel</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># add rising edge detection</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">add_event_detect</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">RISING</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"n\">callback_fn</span><span class=\"p\">)</span>\n</pre>\n<p>More than one callback can also be added if required as follows:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">callback_one</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"First Callback\"</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">callback_two</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Second Callback\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">add_event_detect</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">RISING</span><span class=\"p\">)</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">add_event_callback</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">callback_one</span><span class=\"p\">)</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">add_event_callback</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">callback_two</span><span class=\"p\">)</span>\n</pre>\n<p>The two callbacks in this case are run sequentially, not concurrently since\nthere is only thread running all callback functions.</p>\n<p>In order to prevent multiple calls to the callback functions by collapsing\nmultiple events in to a single one, a debounce time can be optionally set:</p>\n<pre><span class=\"c1\"># bouncetime set in milliseconds</span>\n<span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">add_event_detect</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">,</span> <span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">RISING</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"n\">callback_fn</span><span class=\"p\">,</span>\n<span class=\"n\">bouncetime</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">)</span>\n</pre>\n<p>If the edge detection is not longer required it can be removed as follows:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">remove_event_detect</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">)</span>\n</pre>\n<h4>10. Check function of GPIO channels</h4>\n<p>This feature allows you to check the function of the provided GPIO channel:</p>\n<pre><span class=\"n\">GPIO</span><span class=\"o\">.</span><span class=\"n\">gpio_function</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">)</span>\n</pre>\n<p>The function returns either GPIO.IN or GPIO.OUT.</p>\n<h4>11. PWM</h4>\n<p>See <code>samples/simple_pwm.py</code> for details on how to use PWM channels.</p>\n<p>The Jetson.GPIO library supports PWM only on pins with attached hardware PWM\ncontrollers. Unlike the RPi.GPIO library, the Jetson.GPIO library does not\nimplement Software emulated PWM. Jetson Nano supports 2 PWM channels, and\nJetson AGX Xavier supports 3 PWM channels. Jetson TX1 and TX2 do not support\nany PWM channels.</p>\n<p>The system pinmux must be configured to connect the hardware PWM controlller(s)\nto the relevant pins. If the pinmux is not configured, PWM signals will not\nreach the pins! The Jetson.GPIO library does not dynamically modify the pinmux\nconfiguration to achieve this. Read the L4T documentation for details on how to\nconfigure the pinmux.</p>\n\n          </div>"}, "last_serial": 6824861, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "5570aa2c017d7525395e68a71ffb2d6d", "sha256": "53334f5fa568b3cb722673cc787a310885f38ad9b33df277cf1d8ead2e31396a"}, "downloads": -1, "filename": "Jetson.GPIO-0.1.0.tar.gz", "has_sig": false, "md5_digest": "5570aa2c017d7525395e68a71ffb2d6d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20159, "upload_time": "2019-03-27T22:04:57", "upload_time_iso_8601": "2019-03-27T22:04:57.165295Z", "url": "https://files.pythonhosted.org/packages/89/9e/6cc2823002a6d639217b382e8e3a06200acda7331e1dd7c91fcd31bce641/Jetson.GPIO-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "7c69f9bddee22a083b9d90b05daa82e0", "sha256": "46ad012bc884159adcf384b966fdb09707d912225fd5a2b1dc820b3609bfbf56"}, "downloads": -1, "filename": "Jetson.GPIO-0.1.1.tar.gz", "has_sig": false, "md5_digest": "7c69f9bddee22a083b9d90b05daa82e0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19947, "upload_time": "2019-03-29T21:31:20", "upload_time_iso_8601": "2019-03-29T21:31:20.603408Z", "url": "https://files.pythonhosted.org/packages/23/24/bc5a2b335cb413f4e3496732b58b13e83938dbaa31d75def28fd666da393/Jetson.GPIO-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "fea5a7e3477713117e71adce46dcc838", "sha256": "dd98e447f327b2e1cd5f1753acb80c72e0e6549971003e9c8a57c6a605ac3fa2"}, "downloads": -1, "filename": "Jetson.GPIO-0.1.2.tar.gz", "has_sig": false, "md5_digest": "fea5a7e3477713117e71adce46dcc838", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20348, "upload_time": "2019-04-09T23:57:20", "upload_time_iso_8601": "2019-04-09T23:57:20.131079Z", "url": "https://files.pythonhosted.org/packages/59/b2/4278fa96366f8a79d43cc017fa3ea6aac2ef1d23011e09738e8044253262/Jetson.GPIO-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "b68d88383f3889482daa6782744440e7", "sha256": "109f0427168edb96085d8051d0fa28cf9bb69f9b456c6db9cd9c6ace70cdba12"}, "downloads": -1, "filename": "Jetson.GPIO-0.1.3.tar.gz", "has_sig": false, "md5_digest": "b68d88383f3889482daa6782744440e7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16373, "upload_time": "2019-05-21T20:32:21", "upload_time_iso_8601": "2019-05-21T20:32:21.042048Z", "url": "https://files.pythonhosted.org/packages/e9/69/90b1fcef48056184bda9f1848a5e30e0facd1d8d2015ad701cc3246226ec/Jetson.GPIO-0.1.3.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "7d4a57fec3c9bc74c9d99dd93487469d", "sha256": "6e3c9b5e72acd7c5035d0f389f96d9931cb175a16a3487ffaddaa3d91a081554"}, "downloads": -1, "filename": "Jetson.GPIO-1.0.0.tar.gz", "has_sig": false, "md5_digest": "7d4a57fec3c9bc74c9d99dd93487469d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20246, "upload_time": "2019-06-17T20:47:16", "upload_time_iso_8601": "2019-06-17T20:47:16.062370Z", "url": "https://files.pythonhosted.org/packages/87/8b/77e1474b2ac910463c3b8176b491e20b25b3b60a40ce4ea67c297a464509/Jetson.GPIO-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "5ae9b11a0b4b7f1878fd8d1f932b23ce", "sha256": "49a169819d0cdce4762ccab93e39e02c84a9a004535ad86da21109a1eca8c396"}, "downloads": -1, "filename": "Jetson.GPIO-1.0.1.tar.gz", "has_sig": false, "md5_digest": "5ae9b11a0b4b7f1878fd8d1f932b23ce", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20183, "upload_time": "2019-08-14T21:41:28", "upload_time_iso_8601": "2019-08-14T21:41:28.817910Z", "url": "https://files.pythonhosted.org/packages/e1/30/57d2b0d5bfa499c4024c29ef943d401d8713a29874fba5ce8e56a43d070d/Jetson.GPIO-1.0.1.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "b0d551fa01c8df05d3559edbd7e4615a", "sha256": "891cdeedfb1075e6b498548943c9e7d6da207aaade8c4abb812dc73025e05f96"}, "downloads": -1, "filename": "Jetson.GPIO-2.0.0.tar.gz", "has_sig": false, "md5_digest": "b0d551fa01c8df05d3559edbd7e4615a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20232, "upload_time": "2019-08-21T16:09:10", "upload_time_iso_8601": "2019-08-21T16:09:10.592338Z", "url": "https://files.pythonhosted.org/packages/b1/1d/da0918d8c763492672a15dfc694ee9fba9cca35d086fa6dabf776e3e5859/Jetson.GPIO-2.0.0.tar.gz", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "f4ce2433423796dd860c41c7784d7c94", "sha256": "8a349f9c2e509415d0344a383f04369d2c00632edce7123ee9d5d7633265d685"}, "downloads": -1, "filename": "Jetson.GPIO-2.0.1.tar.gz", "has_sig": false, "md5_digest": "f4ce2433423796dd860c41c7784d7c94", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18311, "upload_time": "2019-09-04T17:45:07", "upload_time_iso_8601": "2019-09-04T17:45:07.611723Z", "url": "https://files.pythonhosted.org/packages/df/0d/66717eb4612c5551c6390c8003c7013594997d46f17dd9fccdc3551c6043/Jetson.GPIO-2.0.1.tar.gz", "yanked": false}], "2.0.2": [{"comment_text": "", "digests": {"md5": "25e814548a8eb323992c2d87256a5898", "sha256": "3049b64617c11eb04562c2ae06c0ac367b604b1fd0f37057f5a8ae58e62f2c11"}, "downloads": -1, "filename": "Jetson.GPIO-2.0.2.tar.gz", "has_sig": false, "md5_digest": "25e814548a8eb323992c2d87256a5898", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18623, "upload_time": "2019-10-04T19:13:09", "upload_time_iso_8601": "2019-10-04T19:13:09.403504Z", "url": "https://files.pythonhosted.org/packages/a9/80/4915e66a7b7e2baaf839c6cd5c6d54b1417ad9ba0f6fa7bd37f4404c37ff/Jetson.GPIO-2.0.2.tar.gz", "yanked": false}], "2.0.3": [{"comment_text": "", "digests": {"md5": "cc18d43b608f4675658b5a14c7d46a7e", "sha256": "41b70fe06e05454bcba875eff8eb67a2550ffe53fd16aa1d7e4b6bd812342fa8"}, "downloads": -1, "filename": "Jetson.GPIO-2.0.3.tar.gz", "has_sig": false, "md5_digest": "cc18d43b608f4675658b5a14c7d46a7e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18628, "upload_time": "2019-10-07T15:23:46", "upload_time_iso_8601": "2019-10-07T15:23:46.818291Z", "url": "https://files.pythonhosted.org/packages/d4/c8/0fc0daed554769111edb98ec46d16d92940679b1d5cbc91d1e30936ffc05/Jetson.GPIO-2.0.3.tar.gz", "yanked": false}], "2.0.4": [{"comment_text": "", "digests": {"md5": "c8f1f778e352db9524e90b5438504026", "sha256": "b2aed8d3ecdd2738e90dfdd8c95599a3702804d8ef5a47dedac63aab432e9ae9"}, "downloads": -1, "filename": "Jetson.GPIO-2.0.4.tar.gz", "has_sig": false, "md5_digest": "c8f1f778e352db9524e90b5438504026", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18628, "upload_time": "2019-10-10T17:03:44", "upload_time_iso_8601": "2019-10-10T17:03:44.707763Z", "url": "https://files.pythonhosted.org/packages/c8/d6/4d53259d4a3376d4bdece00c142bc2fdaf72a60fd523a3c1412679d51540/Jetson.GPIO-2.0.4.tar.gz", "yanked": false}], "2.0.6": [{"comment_text": "", "digests": {"md5": "80835f83c6935033efb2b819ef03250c", "sha256": "ad3b24cbe9336ede1490443f752331e19056cf76aa60e7987103b01ab6bb705c"}, "downloads": -1, "filename": "Jetson.GPIO-2.0.6.tar.gz", "has_sig": false, "md5_digest": "80835f83c6935033efb2b819ef03250c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18979, "upload_time": "2020-02-19T22:55:10", "upload_time_iso_8601": "2020-02-19T22:55:10.557607Z", "url": "https://files.pythonhosted.org/packages/8e/2d/15ffb7f89ef61dbc071ed93ee3cca52b7034d87522269857859ea16d2b2f/Jetson.GPIO-2.0.6.tar.gz", "yanked": false}], "2.0.7": [{"comment_text": "", "digests": {"md5": "ca8e5c33d2da38441472d1fc513fc46a", "sha256": "3fdf3b32304d636cf1ea83a36cb140066b859e417b39711330eb92667fff80bb"}, "downloads": -1, "filename": "Jetson.GPIO-2.0.7.tar.gz", "has_sig": false, "md5_digest": "ca8e5c33d2da38441472d1fc513fc46a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19315, "upload_time": "2020-03-16T23:28:22", "upload_time_iso_8601": "2020-03-16T23:28:22.950481Z", "url": "https://files.pythonhosted.org/packages/b4/d2/d3ed011a1f47e418f2e3fee1379b4ec687ff9e6f03d9be2fb8d374a3dae1/Jetson.GPIO-2.0.7.tar.gz", "yanked": false}], "2.0.8": [{"comment_text": "", "digests": {"md5": "a2ade30de4627f724f98843eca0e222d", "sha256": "f5d1103bbc2701c0b1603d31ea9043ca9ab670d6204846aa2ff25c2302c91fdc"}, "downloads": -1, "filename": "Jetson.GPIO-2.0.8.tar.gz", "has_sig": false, "md5_digest": "a2ade30de4627f724f98843eca0e222d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19316, "upload_time": "2020-03-16T23:31:17", "upload_time_iso_8601": "2020-03-16T23:31:17.477146Z", "url": "https://files.pythonhosted.org/packages/99/75/18443e5dbc6810eee02403234a5efc3e84ec516aec0a688bac4442a04373/Jetson.GPIO-2.0.8.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a2ade30de4627f724f98843eca0e222d", "sha256": "f5d1103bbc2701c0b1603d31ea9043ca9ab670d6204846aa2ff25c2302c91fdc"}, "downloads": -1, "filename": "Jetson.GPIO-2.0.8.tar.gz", "has_sig": false, "md5_digest": "a2ade30de4627f724f98843eca0e222d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19316, "upload_time": "2020-03-16T23:31:17", "upload_time_iso_8601": "2020-03-16T23:31:17.477146Z", "url": "https://files.pythonhosted.org/packages/99/75/18443e5dbc6810eee02403234a5efc3e84ec516aec0a688bac4442a04373/Jetson.GPIO-2.0.8.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:52:48 2020"}