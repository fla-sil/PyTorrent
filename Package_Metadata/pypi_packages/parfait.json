{"info": {"author": "James Saryerwinnie", "author_email": "js@jamesls.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Natural Language :: English", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "========================================\nPython Serverless Microframework for AWS\n========================================\n\n.. image:: https://badges.gitter.im/awslabs/chalice.svg\n   :target: https://gitter.im/awslabs/chalice?utm_source=badge&utm_medium=badge\n   :alt: Gitter\n.. image:: https://travis-ci.org/aws/chalice.svg?branch=master\n   :target: https://travis-ci.org/aws/chalice\n   :alt: Travis CI\n.. image:: https://readthedocs.org/projects/chalice/badge/?version=latest\n   :target: http://chalice.readthedocs.io/en/latest/?badge=latest\n   :alt: Documentation Status\n.. image:: https://codecov.io/github/aws/chalice/coverage.svg?branch=master\n   :target: https://codecov.io/github/aws/chalice\n   :alt: codecov.io\n\nChalice is a microframework for writing serverless apps in python. It allows\nyou to quickly create and deploy applications that use AWS Lambda.  It provides:\n\n* A command line tool for creating, deploying, and managing your app\n* A decorator based API for integrating with Amazon API Gateway, Amazon S3,\n  Amazon SNS, Amazon SQS, and other AWS services.\n* Automatic IAM policy generation\n\n\nYou can create Rest APIs:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name=\"helloworld\")\n\n    @app.route(\"/\")\n    def index():\n        return {\"hello\": \"world\"}\n\nTasks that run on a periodic basis:\n\n.. code-block:: python\n\n    from chalice import Chalice, Rate\n\n    app = Chalice(app_name=\"helloworld\")\n\n    # Automatically runs every 5 minutes\n    @app.schedule(Rate(5, unit=Rate.MINUTES))\n    def periodic_task(event):\n        return {\"hello\": \"world\"}\n\n\nYou can connect a lambda function to an S3 event:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name=\"helloworld\")\n\n    # Whenever an object is uploaded to 'mybucket'\n    # this lambda function will be invoked.\n\n    @app.on_s3_event(bucket='mybucket')\n    def handler(event):\n        print(\"Object uploaded for bucket: %s, key: %s\"\n              % (event.bucket, event.key))\n\nAs well as an SQS queue:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name=\"helloworld\")\n\n    # Invoke this lambda function whenever a message\n    # is sent to the ``my-queue-name`` SQS queue.\n\n    @app.on_sqs_message(queue='my-queue-name')\n    def handler(event):\n        for record in event:\n            print(\"Message body: %s\" % record.body)\n\n\nAnd several other AWS resources.\n\nOnce you've written your code, you just run ``chalice deploy``\nand Chalice takes care of deploying your app.\n\n::\n\n    $ chalice deploy\n    ...\n    https://endpoint/dev\n\n    $ curl https://endpoint/api\n    {\"hello\": \"world\"}\n\nUp and running in less than 30 seconds.\nGive this project a try and share your feedback with us here on Github.\n\nThe documentation is available\n`on readthedocs <http://chalice.readthedocs.io/en/latest/>`__.\n\nQuickstart\n==========\n\n.. quick-start-begin\n\nIn this tutorial, you'll use the ``chalice`` command line utility\nto create and deploy a basic REST API.\nFirst, you'll need to install ``chalice``.  Using a virtualenv\nis recommended::\n\n    $ pip install virtualenv\n    $ virtualenv ~/.virtualenvs/chalice-demo\n    $ source ~/.virtualenvs/chalice-demo/bin/activate\n\nNote: **make sure you are using python2.7, python3.6, or python3.7**.\nThese are the only python versions currently supported by AWS Lambda so they\nare also the only versions supported by the ``chalice`` CLI and ``chalice``\npython package. You can check the version of python in your virtualenv by\nrunning::\n\n    # Double check you have a supported python version in your virtualenv\n    $ python -V\n\nNext, in your virtualenv, install ``chalice``::\n\n    $ pip install chalice\n\nYou can verify you have chalice installed by running::\n\n    $ chalice --help\n    Usage: chalice [OPTIONS] COMMAND [ARGS]...\n    ...\n\n\nCredentials\n-----------\n\nBefore you can deploy an application, be sure you have\ncredentials configured.  If you have previously configured your\nmachine to run boto3 (the AWS SDK for Python) or the AWS CLI then\nyou can skip this section.\n\nIf this is your first time configuring credentials for AWS you\ncan follow these steps to quickly get started::\n\n    $ mkdir ~/.aws\n    $ cat >> ~/.aws/config\n    [default]\n    aws_access_key_id=YOUR_ACCESS_KEY_HERE\n    aws_secret_access_key=YOUR_SECRET_ACCESS_KEY\n    region=YOUR_REGION (such as us-west-2, us-west-1, etc)\n\nIf you want more information on all the supported methods for\nconfiguring credentials, see the\n`boto3 docs\n<http://boto3.readthedocs.io/en/latest/guide/configuration.html>`__.\n\n\nCreating Your Project\n---------------------\n\nThe next thing we'll do is use the ``chalice`` command to create a new\nproject::\n\n    $ chalice new-project helloworld\n\nThis will create a ``helloworld`` directory.  Cd into this\ndirectory.  You'll see several files have been created for you::\n\n    $ cd helloworld\n    $ ls -la\n    drwxr-xr-x   .chalice\n    -rw-r--r--   app.py\n    -rw-r--r--   requirements.txt\n\nYou can ignore the ``.chalice`` directory for now, the two main files\nwe'll focus on is ``app.py`` and ``requirements.txt``.\n\nLet's take a look at the ``app.py`` file:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name='helloworld')\n\n\n    @app.route('/')\n    def index():\n        return {'hello': 'world'}\n\n\nThe ``new-project`` command created a sample app that defines a\nsingle view, ``/``, that when called will return the JSON body\n``{\"hello\": \"world\"}``.\n\n\nDeploying\n---------\n\nLet's deploy this app.  Make sure you're in the ``helloworld``\ndirectory and run ``chalice deploy``::\n\n    $ chalice deploy\n    ...\n    Initiating first time deployment...\n    https://qxea58oupc.execute-api.us-west-2.amazonaws.com/api/\n\nYou now have an API up and running using API Gateway and Lambda::\n\n    $ curl https://qxea58oupc.execute-api.us-west-2.amazonaws.com/api/\n    {\"hello\": \"world\"}\n\nTry making a change to the returned dictionary from the ``index()``\nfunction.  You can then redeploy your changes by running ``chalice deploy``.\n\n\nFor the rest of these tutorials, we'll be using ``httpie`` instead of ``curl``\n(https://github.com/jakubroztocil/httpie) to test our API.  You can install\n``httpie`` using ``pip install httpie``, or if you're on Mac, you can run\n``brew install httpie``.  The Github link has more information on installation\ninstructions.  Here's an example of using ``httpie`` to request the root\nresource of the API we just created.  Note that the command name is ``http``::\n\n\n    $ http https://qxea58oupc.execute-api.us-west-2.amazonaws.com/api/\n    HTTP/1.1 200 OK\n    Connection: keep-alive\n    Content-Length: 18\n    Content-Type: application/json\n    Date: Mon, 30 May 2016 17:55:50 GMT\n    X-Cache: Miss from cloudfront\n\n    {\n        \"hello\": \"world\"\n    }\n\n\nAdditionally, the API Gateway endpoints will be shortened to\n``https://endpoint/api/`` for brevity.  Be sure to substitute\n``https://endpoint/api/`` for the actual endpoint that the ``chalice``\nCLI displays when you deploy your API (it will look something like\n``https://abcdefg.execute-api.us-west-2.amazonaws.com/api/``.\n\nNext Steps\n----------\n\nYou've now created your first app using ``chalice``.\n\nThe next few sections will build on this quickstart section and introduce\nyou to additional features including: URL parameter capturing,\nerror handling, advanced routing, current request metadata, and automatic\npolicy generation.\n\n\nTutorial: URL Parameters\n========================\n\nNow we're going to make a few changes to our ``app.py`` file that\ndemonstrate additional capabilities provided by the python serverless\nmicroframework for AWS.\n\nOur application so far has a single view that allows you to make\nan HTTP GET request to ``/``.  Now let's suppose we want to capture\nparts of the URI:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name='helloworld')\n\n    CITIES_TO_STATE = {\n        'seattle': 'WA',\n        'portland': 'OR',\n    }\n\n\n    @app.route('/')\n    def index():\n        return {'hello': 'world'}\n\n    @app.route('/cities/{city}')\n    def state_of_city(city):\n        return {'state': CITIES_TO_STATE[city]}\n\n\nIn the example above, we've now added a ``state_of_city`` view that allows\na user to specify a city name.  The view function takes the city\nname and returns name of the state the city is in.  Notice that the\n``@app.route`` decorator has a URL pattern of ``/cities/{city}``.  This\nmeans that the value of ``{city}`` is captured and passed to the view\nfunction.  You can also see that the ``state_of_city`` takes a single\nargument.  This argument is the name of the city provided by the user.\nFor example::\n\n    GET /cities/seattle   --> state_of_city('seattle')\n    GET /cities/portland  --> state_of_city('portland')\n\nNow that we've updated our ``app.py`` file with this new view function,\nlet's redeploy our application.  You can run ``chalice deploy`` from\nthe ``helloworld`` directory and it will deploy your application::\n\n    $ chalice deploy\n\nLet's try it out.  Note the examples below use the ``http`` command\nfrom the ``httpie`` package.  You can install this using ``pip install httpie``::\n\n    $ http https://endpoint/api/cities/seattle\n    HTTP/1.1 200 OK\n\n    {\n        \"state\": \"WA\"\n    }\n\n    $ http https://endpoint/api/cities/portland\n    HTTP/1.1 200 OK\n\n    {\n        \"state\": \"OR\"\n    }\n\n\nNotice what happens if we try to request a city that's not in our\n``CITIES_TO_STATE`` map::\n\n    $ http https://endpoint/api/cities/vancouver\n    HTTP/1.1 500 Internal Server Error\n    Content-Type: application/json\n    X-Cache: Error from cloudfront\n\n    {\n        \"Code\": \"ChaliceViewError\",\n        \"Message\": \"ChaliceViewError: An internal server error occurred.\"\n    }\n\n\nIn the next section, we'll see how to fix this and provide better\nerror messages.\n\n\nTutorial: Error Messages\n========================\n\nIn the example above, you'll notice that when our app raised\nan uncaught exception, a 500 internal server error was returned.\n\nIn this section, we're going to show how you can debug and improve\nthese error messages.\n\nThe first thing we're going to look at is how we can debug this\nissue.  By default, debugging is turned off, but you can\nenable debugging to get more information:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name='helloworld')\n    app.debug = True\n\n\nThe ``app.debug = True`` enables debugging for your app.\nSave this file and redeploy your changes::\n\n    $ chalice deploy\n    ...\n    https://endpoint/api/\n\nNow, when you request the same URL that returned an internal\nserver error, you'll get back the original stack trace::\n\n    $ http https://endpoint/api/cities/vancouver\n    Traceback (most recent call last):\n      File \"/var/task/chalice/app.py\", line 304, in _get_view_function_response\n        response = view_function(*function_args)\n      File \"/var/task/app.py\", line 18, in state_of_city\n        return {'state': CITIES_TO_STATE[city]}\n    KeyError: u'vancouver'\n\n\nWe can see that the error is caused from an uncaught ``KeyError`` resulting\nfrom trying to access the ``vancouver`` key.\n\nNow that we know the error, we can fix our code.  What we'd like to do is\ncatch this exception and instead return a more helpful error message\nto the user.  Here's the updated code:\n\n.. code-block:: python\n\n    from chalice import BadRequestError\n\n    @app.route('/cities/{city}')\n    def state_of_city(city):\n        try:\n            return {'state': CITIES_TO_STATE[city]}\n        except KeyError:\n            raise BadRequestError(\"Unknown city '%s', valid choices are: %s\" % (\n                city, ', '.join(CITIES_TO_STATE.keys())))\n\n\nSave and deploy these changes::\n\n    $ chalice deploy\n    $ http https://endpoint/api/cities/vancouver\n    HTTP/1.1 400 Bad Request\n\n    {\n        \"Code\": \"BadRequestError\",\n        \"Message\": \"Unknown city 'vancouver', valid choices are: portland, seattle\"\n    }\n\nWe can see now that we have received a ``Code`` and ``Message`` key, with the message\nbeing the value we passed to ``BadRequestError``.  Whenever you raise\na ``BadRequestError`` from your view function, the framework will return an\nHTTP status code of 400 along with a JSON body with a ``Code`` and ``Message``.\nThere are a few additional exceptions you can raise from your python code::\n\n* BadRequestError - return a status code of 400\n* UnauthorizedError - return a status code of 401\n* ForbiddenError - return a status code of 403\n* NotFoundError - return a status code of 404\n* ConflictError - return a status code of 409\n* UnprocessableEntityError - return a status code of 422\n* TooManyRequestsError - return a status code of 429\n* ChaliceViewError - return a status code of 500\n\nYou can import these directly from the ``chalice`` package:\n\n.. code-block:: python\n\n    from chalice import UnauthorizedError\n\n\nTutorial: Additional Routing\n============================\n\nSo far, our examples have only allowed GET requests.\nIt's actually possible to support additional HTTP methods.\nHere's an example of a view function that supports PUT:\n\n.. code-block:: python\n\n    @app.route('/resource/{value}', methods=['PUT'])\n    def put_test(value):\n        return {\"value\": value}\n\nWe can test this method using the ``http`` command::\n\n    $ http PUT https://endpoint/api/resource/foo\n    HTTP/1.1 200 OK\n\n    {\n        \"value\": \"foo\"\n    }\n\nNote that the ``methods`` kwarg accepts a list of methods.  Your view function\nwill be called when any of the HTTP methods you specify are used for the\nspecified resource.  For example:\n\n.. code-block:: python\n\n    @app.route('/myview', methods=['POST', 'PUT'])\n    def myview():\n        pass\n\nThe above view function will be called when either an HTTP POST or\nPUT is sent to ``/myview``.\n\nAlternatively if you do not want to share the same view function across\nmultiple HTTP methods for the same route url, you may define separate view\nfunctions to the same route url but have the view functions differ by\nHTTP method. For example:\n\n.. code-block:: python\n\n    @app.route('/myview', methods=['POST'])\n    def myview_post():\n        pass\n\n    @app.route('/myview', methods=['PUT'])\n    def myview_put():\n        pass\n\nThis setup will route all HTTP POST's to ``/myview`` to the ``myview_post()``\nview function and route all HTTP PUT's to ``/myview`` to the ``myview_put()``\nview function. It is also important to note that the view functions\n**must** have unique names. For example, both view functions cannot be\nnamed ``myview()``.\n\nIn the next section we'll go over how you can introspect the given request\nin order to differentiate between various HTTP methods.\n\n\nTutorial: Request Metadata\n==========================\n\nIn the examples above, you saw how to create a view function that supports\nan HTTP PUT request as well as a view function that supports both POST and\nPUT via the same view function.  However, there's more information we\nmight need about a given request:\n\n* In a PUT/POST, you frequently send a request body.  We need some\n  way of accessing the contents of the request body.\n* For view functions that support multiple HTTP methods, we'd like\n  to detect which HTTP method was used so we can have different\n  code paths for PUTs vs. POSTs.\n\nAll of this and more is handled by the current request object that the\n``chalice`` library makes available to each view function when it's called.\n\nLet's see an example of this.  Suppose we want to create a view function\nthat allowed you to PUT data to an object and retrieve that data\nvia a corresponding GET.  We could accomplish that with the\nfollowing view function:\n\n.. code-block:: python\n\n    from chalice import NotFoundError\n\n    OBJECTS = {\n    }\n\n    @app.route('/objects/{key}', methods=['GET', 'PUT'])\n    def myobject(key):\n        request = app.current_request\n        if request.method == 'PUT':\n            OBJECTS[key] = request.json_body\n        elif request.method == 'GET':\n            try:\n                return {key: OBJECTS[key]}\n            except KeyError:\n                raise NotFoundError(key)\n\n\nSave this in your ``app.py`` file and rerun ``chalice deploy``.\nNow, you can make a PUT request to ``/objects/your-key`` with a request\nbody, and retrieve the value of that body by making a subsequent\n``GET`` request to the same resource.  Here's an example of its usage::\n\n    # First, trying to retrieve the key will return a 404.\n    $ http GET https://endpoint/api/objects/mykey\n    HTTP/1.1 404 Not Found\n\n    {\n        \"Code\": \"NotFoundError\",\n        \"Message\": \"mykey\"\n    }\n\n    # Next, we'll create that key by sending a PUT request.\n    $ echo '{\"foo\": \"bar\"}' | http PUT https://endpoint/api/objects/mykey\n    HTTP/1.1 200 OK\n\n    null\n\n    # And now we no longer get a 404, we instead get the value we previously\n    # put.\n    $ http GET https://endpoint/api/objects/mykey\n    HTTP/1.1 200 OK\n\n    {\n        \"mykey\": {\n            \"foo\": \"bar\"\n        }\n    }\n\nYou might see a problem with storing the objects in a module level\n``OBJECTS`` variable.  We address this in the next section.\n\nThe ``app.current_request`` object also has the following properties.\n\n* ``current_request.query_params`` - A dict of the query params for the request.\n* ``current_request.headers`` - A dict of the request headers.\n* ``current_request.uri_params`` - A dict of the captured URI params.\n* ``current_request.method`` -  The HTTP method (as a string).\n* ``current_request.json_body`` - The parsed JSON body (``json.loads(raw_body)``)\n* ``current_request.raw_body`` - The raw HTTP body as bytes.\n* ``current_request.context`` - A dict of additional context information\n* ``current_request.stage_vars`` - Configuration for the API Gateway stage\n\nDon't worry about the ``context`` and ``stage_vars`` for now.  We haven't\ndiscussed those concepts yet.  The ``current_request`` object also\nhas a ``to_dict`` method, which returns all the information about the\ncurrent request as a dictionary.  Let's use this method to write a view\nfunction that returns everything it knows about the request:\n\n.. code-block:: python\n\n    @app.route('/introspect')\n    def introspect():\n        return app.current_request.to_dict()\n\n\nSave this to your ``app.py`` file and redeploy with ``chalice deploy``.\nHere's an example of hitting the ``/introspect`` URL.  Note how we're\nsending a query string as well as a custom ``X-TestHeader`` header::\n\n\n    $ http 'https://endpoint/api/introspect?query1=value1&query2=value2' 'X-TestHeader: Foo'\n    HTTP/1.1 200 OK\n\n    {\n        \"context\": {\n            \"apiId\": \"apiId\",\n            \"httpMethod\": \"GET\",\n            \"identity\": {\n                \"accessKey\": null,\n                \"accountId\": null,\n                \"apiKey\": null,\n                \"caller\": null,\n                \"cognitoAuthenticationProvider\": null,\n                \"cognitoAuthenticationType\": null,\n                \"cognitoIdentityId\": null,\n                \"cognitoIdentityPoolId\": null,\n                \"sourceIp\": \"1.1.1.1\",\n                \"userAgent\": \"HTTPie/0.9.3\",\n                \"userArn\": null\n            },\n            \"requestId\": \"request-id\",\n            \"resourceId\": \"resourceId\",\n            \"resourcePath\": \"/introspect\",\n            \"stage\": \"dev\"\n        },\n        \"headers\": {\n            \"accept\": \"*/*\",\n            ...\n            \"x-testheader\": \"Foo\"\n        },\n        \"method\": \"GET\",\n        \"query_params\": {\n            \"query1\": \"value1\",\n            \"query2\": \"value2\"\n        },\n        \"raw_body\": null,\n        \"stage_vars\": null,\n        \"uri_params\": null\n    }\n\n\nTutorial: Request Content Types\n===============================\n\nThe default behavior of a view function supports\na request body of ``application/json``.  When a request is\nmade with a ``Content-Type`` of ``application/json``, the\n``app.current_request.json_body`` attribute is automatically\nset for you.  This value is the parsed JSON body.\n\nYou can also configure a view function to support other\ncontent types.  You can do this by specifying the\n``content_types`` parameter value to your ``app.route``\nfunction.  This parameter is a list of acceptable content\ntypes.  Here's an example of this feature:\n\n.. code-block:: python\n\n    import sys\n\n    from chalice import Chalice\n    if sys.version_info[0] == 3:\n        # Python 3 imports.\n        from urllib.parse import urlparse, parse_qs\n    else:\n        # Python 2 imports.\n        from urlparse import urlparse, parse_qs\n\n\n    app = Chalice(app_name='helloworld')\n\n\n    @app.route('/', methods=['POST'],\n               content_types=['application/x-www-form-urlencoded'])\n    def index():\n        parsed = parse_qs(app.current_request.raw_body.decode())\n        return {\n            'states': parsed.get('states', [])\n        }\n\nThere's a few things worth noting in this view function.\nFirst, we've specified that we only accept the\n``application/x-www-form-urlencoded`` content type.  If we\ntry to send a request with ``application/json``, we'll now\nget a ``415 Unsupported Media Type`` response::\n\n    $ http POST https://endpoint/api/ states=WA states=CA --debug\n    ...\n    >>> requests.request(**{'allow_redirects': False,\n     'headers': {'Accept': 'application/json',\n                 'Content-Type': 'application/json',\n    ...\n\n\n    HTTP/1.1 415 Unsupported Media Type\n\n    {\n        \"message\": \"Unsupported Media Type\"\n    }\n\nIf we use the ``--form`` argument, we can see the\nexpected behavior of this view function because ``httpie`` sets the\n``Content-Type`` header to ``application/x-www-form-urlencoded``::\n\n    $ http --form POST https://endpoint/api/formtest states=WA states=CA --debug\n    ...\n    >>> requests.request(**{'allow_redirects': False,\n     'headers': {'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',\n    ...\n\n    HTTP/1.1 200 OK\n    {\n        \"states\": [\n            \"WA\",\n            \"CA\"\n        ]\n    }\n\nThe second thing worth noting is that ``app.current_request.json_body``\n**is only available for the application/json content type.**\nIn our example above, we used ``app.current_request.raw_body`` to access\nthe raw body bytes:\n\n.. code-block:: python\n\n    parsed = parse_qs(app.current_request.raw_body)\n\n``app.current_request.json_body`` is set to ``None`` whenever the\n``Content-Type`` is not ``application/json``.  This means that\nyou will need to use ``app.current_request.raw_body`` and parse\nthe request body as needed.\n\n\nTutorial: Customizing the HTTP Response\n=======================================\n\nThe return value from a chalice view function is serialized as JSON as the\nresponse body returned back to the caller.  This makes it easy to create\nrest APIs that return JSON response bodies.\n\nChalice allows you to control this behavior by returning an instance of\na chalice specific ``Response`` class.  This behavior allows you to:\n\n* Specify the status code to return\n* Specify custom headers to add to the response\n* Specify response bodies that are not ``application/json``\n\nHere's an example of this:\n\n.. code-block:: python\n\n    from chalice import Chalice, Response\n\n    app = Chalice(app_name='custom-response')\n\n\n    @app.route('/')\n    def index():\n        return Response(body='hello world!',\n                        status_code=200,\n                        headers={'Content-Type': 'text/plain'})\n\nThis will result in a plain text response body::\n\n    $ http https://endpoint/api/\n    HTTP/1.1 200 OK\n    Content-Length: 12\n    Content-Type: text/plain\n\n    hello world!\n\n\nTutorial: GZIP compression for json\n===================================\nThe return value from a chalice view function is serialized as JSON as the\nresponse body returned back to the caller.  This makes it easy to create\nrest APIs that return JSON response bodies.\n\nChalice allows you to control this behavior by returning an instance of\na chalice specific ``Response`` class.  This behavior allows you to:\n\n* Add ``application/json`` to binary_types\n* Specify the status code to return\n* Specify custom header ``Content-Type: application/json``\n* Specify custom header ``Content-Encoding: gzip``\n\nHere's an example of this:\n\n.. code-block:: python\n\n    import json\n    import gzip\n    from chalice import Chalice, Response\n\n    app = Chalice(app_name='compress-response')\n    app.api.binary_types.append('application/json')\n\n    @app.route('/')\n    def index():\n        blob = json.dumps({'hello': 'world'}).encode('utf-8')\n        payload = gzip.compress(blob)\n        custom_headers = {\n            'Content-Type': 'application/json',\n            'Content-Encoding': 'gzip'\n        }\n        return Response(body=payload,\n                        status_code=200,\n                        headers=custom_headers)\n\n\n\nTutorial: CORS Support\n======================\n\nYou can specify whether a view supports CORS by adding the\n``cors=True`` parameter to your ``@app.route()`` call.  By\ndefault this value is false:\n\n.. code-block:: python\n\n    @app.route('/supports-cors', methods=['PUT'], cors=True)\n    def supports_cors():\n        return {}\n\n\nSettings ``cors=True`` has similar behavior to enabling CORS\nusing the AWS Console.  This includes:\n\n* Injecting the ``Access-Control-Allow-Origin: *`` header to your\n  responses, including all error responses you can return.\n* Automatically adding an ``OPTIONS`` method to support preflighting\n  requests.\n\nThe preflight request will return a response that includes:\n\n* ``Access-Control-Allow-Origin: *``\n* The ``Access-Control-Allow-Methods`` header will return a list of all HTTP\n  methods you've called out in your view function.  In the example above,\n  this will be ``PUT,OPTIONS``.\n* ``Access-Control-Allow-Headers: Content-Type,X-Amz-Date,Authorization,\n  X-Api-Key,X-Amz-Security-Token``.\n\nIf more fine grained control of the CORS headers is desired, set the ``cors``\nparameter to an instance of ``CORSConfig`` instead of ``True``. The\n``CORSConfig`` object can be imported from from the ``chalice`` package it's\nconstructor takes the following keyword arguments that map to CORS headers:\n\n================= ==== ================================\nArgument          Type Header\n================= ==== ================================\nallow_origin      str  Access-Control-Allow-Origin\nallow_headers     list Access-Control-Allow-Headers\nexpose_headers    list Access-Control-Expose-Headers\nmax_age           int  Access-Control-Max-Age\nallow_credentials bool Access-Control-Allow-Credentials\n================= ==== ================================\n\nCode sample defining more CORS headers:\n\n.. code-block:: python\n\n    from chalice import CORSConfig\n    cors_config = CORSConfig(\n        allow_origin='https://foo.example.com',\n        allow_headers=['X-Special-Header'],\n        max_age=600,\n        expose_headers=['X-Special-Header'],\n        allow_credentials=True\n    )\n    @app.route('/custom_cors', methods=['GET'], cors=cors_config)\n    def supports_custom_cors():\n        return {'cors': True}\n\n\nThere's a couple of things to keep in mind when enabling cors for a view:\n\n* An ``OPTIONS`` method for preflighting is always injected.  Ensure that\n  you don't have ``OPTIONS`` in the ``methods=[...]`` list of your\n  view function.\n* Even though the ``Access-Control-Allow-Origin`` header can be set to a\n  string that is a space separated list of origins, this behavior does not\n  work on all clients that implement CORS. You should only supply a single\n  origin to the ``CORSConfig`` object. If you need to supply multiple origins\n  you will need to define a custom handler for it that accepts ``OPTIONS``\n  requests and matches the ``Origin`` header against a whitelist of origins.\n  If the match is successful then return just their ``Origin`` back to them\n  in the ``Access-Control-Allow-Origin`` header.\n\n  Example:\n\n.. code-block:: python\n\n    from chalice import Chalice, Response\n\n    app = Chalice(app_name='multipleorigincors')\n\n    _ALLOWED_ORIGINS = set([\n\t'http://allowed1.example.com',\n\t'http://allowed2.example.com',\n    ])\n\n\n    @app.route('/cors_multiple_origins', methods=['GET', 'OPTIONS'])\n    def supports_cors_multiple_origins():\n\tmethod = app.current_request.method\n\tif method == 'OPTIONS':\n\t    headers = {\n\t\t'Access-Control-Allow-Method': 'GET,OPTIONS',\n\t\t'Access-Control-Allow-Origin': ','.join(_ALLOWED_ORIGINS),\n\t\t'Access-Control-Allow-Headers': 'X-Some-Header',\n\t    }\n\t    origin = app.current_request.headers.get('origin', '')\n\t    if origin in _ALLOWED_ORIGINS:\n\t\theaders.update({'Access-Control-Allow-Origin': origin})\n\t    return Response(\n\t\tbody=None,\n\t\theaders=headers,\n\t    )\n\telif method == 'GET':\n\t    return 'Foo'\n\n* Every view function must explicitly enable CORS support.\n\nThe last point will change in the future.  See\n`this issue\n<https://github.com/aws/chalice/issues/70#issuecomment-248787037>`_\nfor more information.\n\n\nTutorial: Policy Generation\n===========================\n\nIn the previous section we created a basic rest API that\nallowed you to store JSON objects by sending the JSON\nin the body of an HTTP PUT request to ``/objects/{name}``.\nYou could then retrieve objects by sending a GET request to\n``/objects/{name}``.\n\nHowever, there's a problem with the code we wrote:\n\n.. code-block:: python\n\n    OBJECTS = {\n    }\n\n    @app.route('/objects/{key}', methods=['GET', 'PUT'])\n    def myobject(key):\n        request = app.current_request\n        if request.method == 'PUT':\n            OBJECTS[key] = request.json_body\n        elif request.method == 'GET':\n            try:\n                return {key: OBJECTS[key]}\n            except KeyError:\n                raise NotFoundError(key)\n\n\nWe're storing the key value pairs in a module level ``OBJECTS``\nvariable.  We can't rely on local storage like this persisting\nacross requests.\n\nA better solution would be to store this information in Amazon S3.\nTo do this, we're going to use boto3, the AWS SDK for Python.\nFirst, install boto3::\n\n    $ pip install boto3\n\nNext, add ``boto3`` to your requirements.txt file::\n\n    $ echo 'boto3==1.3.1' >> requirements.txt\n\nThe requirements.txt file should be in the same directory that contains\nyour ``app.py`` file.  Next, let's update our view code to use boto3:\n\n.. code-block:: python\n\n    import json\n    import boto3\n    from botocore.exceptions import ClientError\n\n    from chalice import NotFoundError\n\n\n    S3 = boto3.client('s3', region_name='us-west-2')\n    BUCKET = 'your-bucket-name'\n\n\n    @app.route('/objects/{key}', methods=['GET', 'PUT'])\n    def s3objects(key):\n        request = app.current_request\n        if request.method == 'PUT':\n            S3.put_object(Bucket=BUCKET, Key=key,\n                          Body=json.dumps(request.json_body))\n        elif request.method == 'GET':\n            try:\n                response = S3.get_object(Bucket=BUCKET, Key=key)\n                return json.loads(response['Body'].read())\n            except ClientError as e:\n                raise NotFoundError(key)\n\nMake sure to change ``BUCKET`` with the name of an S3 bucket\nyou own.  Redeploy your changes with ``chalice deploy``.\nNow, whenever we make a ``PUT`` request to ``/objects/keyname``, the\ndata send will be stored in S3.  Any subsequent ``GET`` requests will\nretrieve this data from S3.\n\nManually Providing Policies\n---------------------------\n\n\nIAM permissions can be auto generated, provided manually or can be\npre-created and explicitly configured. To use a\npre-configured IAM role ARN for chalice, add these two keys to your\nchalice configuration. Setting manage_iam_role to false tells\nChalice to not attempt to generate policies and create IAM role.\n\n::\n\n    \"manage_iam_role\":false\n    \"iam_role_arn\":\"arn:aws:iam::<account-id>:role/<role-name>\"\n\nWhenever your application is deployed using ``chalice``, the\nauto generated policy is written to disk at\n``<projectdir>/.chalice/policy.json``.  When you run the\n``chalice deploy`` command, you can also specify the\n``--no-autogen-policy`` option.  Doing so will result in the\n``chalice`` CLI loading the ``<projectdir>/.chalice/policy.json``\nfile and using that file as the policy for the IAM role.\nYou can manually edit this file and specify ``--no-autogen-policy``\nif you'd like to have full control over what IAM policy to associate\nwith the IAM role.\n\nYou can also run the ``chalice gen-policy`` command from your project\ndirectory to print the auto generated policy to stdout.  You can\nthen use this as a starting point for your policy.\n\n::\n\n    $ chalice gen-policy\n    {\n      \"Version\": \"2012-10-17\",\n      \"Statement\": [\n        {\n          \"Action\": [\n            \"s3:ListAllMyBuckets\"\n          ],\n          \"Resource\": [\n            \"*\"\n          ],\n          \"Effect\": \"Allow\",\n          \"Sid\": \"9155de6ad1d74e4c8b1448255770e60c\"\n        }\n      ]\n    }\n\nExperimental Status\n-------------------\n\nThe automatic policy generation is still in the early stages, it should\nbe considered experimental.  You can always disable policy\ngeneration with ``--no-autogen-policy`` for complete control.\n\nAdditionally, you will be prompted for confirmation whenever the\nauto policy generator detects actions that it would like to add or remove::\n\n\n    $ chalice deploy\n    Updating IAM policy.\n\n    The following action will be added to the execution policy:\n\n    s3:ListBucket\n\n    Would you like to continue?  [Y/n]:\n\n\nTutorial: Using Custom Authentication\n=====================================\n\nAWS API Gateway routes can be authenticated in multiple ways:\n\n- API Key\n- AWS IAM\n- Cognito User Pools\n- Custom Auth Handler\n\nAPI Key\n-------\n\n.. code-block:: python\n\n    @app.route('/authenticated', methods=['GET'], api_key_required=True)\n    def authenticated():\n        return {\"secure\": True}\n\nOnly requests sent with a valid `X-Api-Key` header will be accepted.\n\nUsing AWS IAM\n-------------\n\n.. code-block:: python\n\n    authorizer = IAMAuthorizer()\n\n    @app.route('/iam-role', methods=['GET'], authorizer=authorizer)\n    def authenticated():\n        return {\"secure\": True}\n\n\nUsing Amazon Cognito User Pools\n-------------------------------\n\nTo integrate with cognito user pools, you can use the\n``CognitoUserPoolAuthorizer`` object:\n\n.. code-block:: python\n\n    authorizer = CognitoUserPoolAuthorizer(\n        'MyPool', header='Authorization',\n        provider_arns=['arn:aws:cognito:...:userpool/name'])\n\n    @app.route('/user-pools', methods=['GET'], authorizer=authorizer)\n    def authenticated():\n        return {\"secure\": True}\n\n\nNote, earlier versions of chalice also have an ``app.define_authorizer``\nmethod as well as an ``authorizer_name`` argument on the ``@app.route(...)``\nmethod.  This approach is deprecated in favor of ``CognitoUserPoolAuthorizer``\nand the ``authorizer`` argument in the ``@app.route(...)`` method.\n``app.define_authorizer`` will be removed in future versions of chalice.\n\n\nUsing Custom Authorizers\n------------------------\n\nTo integrate with custom authorizers, you can use the ``CustomAuthorizer`` method\non the ``app`` object.  You'll need to set the ``authorizer_uri``\nto the URI of your lambda function.\n\n.. code-block:: python\n\n    authorizer = CustomAuthorizer(\n        'MyCustomAuth', header='Authorization',\n        authorizer_uri=('arn:aws:apigateway:region:lambda:path/2015-03-31'\n                        '/functions/arn:aws:lambda:region:account-id:'\n                        'function:FunctionName/invocations'))\n\n    @app.route('/custom-auth', methods=['GET'], authorizer=authorizer)\n    def authenticated():\n        return {\"secure\": True}\n\n\nTutorial: Local Mode\n====================\n\nAs you develop your application, you may want to experiment locally  before\ndeploying your changes.  You can use ``chalice local`` to spin up a local\nHTTP server you can use for testing.\n\nFor example, if we have the following ``app.py`` file:\n\n.. code-block:: python\n\n    from chalice import Chalice\n\n    app = Chalice(app_name='helloworld')\n\n\n    @app.route('/')\n    def index():\n        return {'hello': 'world'}\n\n\nWe can run ``chalice local`` to test this API locally:\n\n\n    $ chalice local\n    Serving on localhost:8000\n\nWe can override the port using:\n\n    $ chalice local --port=8080\n\nWe can now test our API using ``localhost:8000``::\n\n    $ http localhost:8000/\n    HTTP/1.0 200 OK\n    Content-Length: 18\n    Content-Type: application/json\n    Date: Thu, 27 Oct 2016 20:08:43 GMT\n    Server: BaseHTTP/0.3 Python/2.7.11\n\n    {\n        \"hello\": \"world\"\n    }\n\n\nThe ``chalice local`` command *does not* assume the\nrole associated with your lambda function, so you'll\nneed to use an ``AWS_PROFILE`` that has sufficient permissions\nto your AWS resources used in your ``app.py``.\n\n\nDeleting Your App\n=================\n\nYou can use the ``chalice delete`` command to delete your app.\nSimilar to the ``chalice deploy`` command, you can specify which\nchalice stage to delete.  By default it will delete the ``dev`` stage::\n\n    $ chalice delete --stage dev\n    Deleting Rest API: duvw4kwyl3\n    Deleting function aws:arn:lambda:region:123456789:helloworld-dev\n    Deleting IAM Role helloworld-dev\n\n.. quick-start-end\n\nFeedback\n========\n\nWe'also love to hear from you.  Please create any Github issues for\nadditional features you'd like to see over at\nhttps://github.com/aws/chalice/issues.  You can also chat with us\non gitter: https://gitter.im/awslabs/chalice\n\n\nFAQ\n===\n\n\n**Q: How does the Python Serverless Microframework for AWS compare to other\nsimilar frameworks?**\n\nThe biggest difference between this framework and others is that the Python\nServerless Microframework for AWS is singularly focused on using a familiar,\ndecorator-based API to write python applications that run on Amazon API Gateway\nand AWS Lambda.  You can think of it as\n`Flask <http://flask.pocoo.org/>`__/`Bottle <http://bottlepy.org/docs/dev/index.html>`__\nfor serverless APIs.  Its goal is to make writing and deploying these types of\napplications as simple as possible specifically for Python developers.\n\nTo achieve this goal, it has to make certain tradeoffs.  Python will always\nremain the only supported language in this framework.  Not every feature of API\nGateway and Lambda is exposed in the framework.  It makes assumptions about how\napplications will be deployed, and it has restrictions on how an application\ncan be structured.  It does not address the creation and lifecycle of other AWS\nresources your application may need (Amazon S3 buckets, Amazon DynamoDB tables,\netc.).  The feature set is purposefully small.\n\nOther full-stack frameworks offer a lot more features and configurability than\nwhat this framework has and likely will ever have.  Those frameworks are\nexcellent choices for applications that need more than what is offered by this\nmicroframework.  If all you need is to create a simple rest API in Python that\nruns on Amazon API Gateway and AWS Lambda, consider giving the Python\nServerless Microframework for AWS a try.\n\nRelated Projects\n----------------\n\n* `serverless <https://github.com/serverless/serverless>`__ - Build applications\n  comprised of microservices that run in response to events, auto-scale for\n  you, and only charge you when they run.\n* `Zappa <https://github.com/Miserlou/Zappa>`__ - Deploy python WSGI applications\n  on AWS Lambda and API Gateway.\n* `claudia <https://github.com/claudiajs/claudia>`__ - Deploy node.js projects\n  to AWS Lambda and API Gateway.\n* `Domovoi <https://github.com/kislyuk/domovoi>`_ - An extension to Chalice that\n  handles a variety of AWS Lambda event sources such as SNS push notifications,\n  S3 events, and Step Functions state machines.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/aws/chalice", "keywords": "chalice,parfait,aws,lambda,amazon web services", "license": "Apache License 2.0", "maintainer": "", "maintainer_email": "", "name": "parfait", "package_url": "https://pypi.org/project/parfait/", "platform": "", "project_url": "https://pypi.org/project/parfait/", "project_urls": {"Homepage": "https://github.com/aws/chalice"}, "release_url": "https://pypi.org/project/parfait/0.3/", "requires_dist": null, "requires_python": "", "summary": "Microframework", "version": "0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://gitter.im/awslabs/chalice?utm_source=badge&amp;utm_medium=badge\" rel=\"nofollow\"><img alt=\"Gitter\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d45a9820d7ee33c9bd8cbfaec1ecebcdc3c1a3e7/68747470733a2f2f6261646765732e6769747465722e696d2f6177736c6162732f6368616c6963652e737667\"></a>\n<a href=\"https://travis-ci.org/aws/chalice\" rel=\"nofollow\"><img alt=\"Travis CI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/84ea21fd5490ce8930140f3eb490bf0c736597e6/68747470733a2f2f7472617669732d63692e6f72672f6177732f6368616c6963652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"http://chalice.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/869088b7e554769ab3fd93fa22334009b522e1fe/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f6368616c6963652f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<a href=\"https://codecov.io/github/aws/chalice\" rel=\"nofollow\"><img alt=\"codecov.io\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2f2e1b6d0810c1df5b4ae555f770d8f671e00e09/68747470733a2f2f636f6465636f762e696f2f6769746875622f6177732f6368616c6963652f636f7665726167652e7376673f6272616e63683d6d6173746572\"></a>\n<p>Chalice is a microframework for writing serverless apps in python. It allows\nyou to quickly create and deploy applications that use AWS Lambda.  It provides:</p>\n<ul>\n<li>A command line tool for creating, deploying, and managing your app</li>\n<li>A decorator based API for integrating with Amazon API Gateway, Amazon S3,\nAmazon SNS, Amazon SQS, and other AWS services.</li>\n<li>Automatic IAM policy generation</li>\n</ul>\n<p>You can create Rest APIs:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">Chalice</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Chalice</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s2\">\"helloworld\"</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s2\">\"/\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">index</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s2\">\"hello\"</span><span class=\"p\">:</span> <span class=\"s2\">\"world\"</span><span class=\"p\">}</span>\n</pre>\n<p>Tasks that run on a periodic basis:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">Chalice</span><span class=\"p\">,</span> <span class=\"n\">Rate</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Chalice</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s2\">\"helloworld\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Automatically runs every 5 minutes</span>\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">schedule</span><span class=\"p\">(</span><span class=\"n\">Rate</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"n\">unit</span><span class=\"o\">=</span><span class=\"n\">Rate</span><span class=\"o\">.</span><span class=\"n\">MINUTES</span><span class=\"p\">))</span>\n<span class=\"k\">def</span> <span class=\"nf\">periodic_task</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s2\">\"hello\"</span><span class=\"p\">:</span> <span class=\"s2\">\"world\"</span><span class=\"p\">}</span>\n</pre>\n<p>You can connect a lambda function to an S3 event:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">Chalice</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Chalice</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s2\">\"helloworld\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Whenever an object is uploaded to 'mybucket'</span>\n<span class=\"c1\"># this lambda function will be invoked.</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">on_s3_event</span><span class=\"p\">(</span><span class=\"n\">bucket</span><span class=\"o\">=</span><span class=\"s1\">'mybucket'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Object uploaded for bucket: </span><span class=\"si\">%s</span><span class=\"s2\">, key: </span><span class=\"si\">%s</span><span class=\"s2\">\"</span>\n          <span class=\"o\">%</span> <span class=\"p\">(</span><span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">bucket</span><span class=\"p\">,</span> <span class=\"n\">event</span><span class=\"o\">.</span><span class=\"n\">key</span><span class=\"p\">))</span>\n</pre>\n<p>As well as an SQS queue:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">Chalice</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Chalice</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s2\">\"helloworld\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Invoke this lambda function whenever a message</span>\n<span class=\"c1\"># is sent to the ``my-queue-name`` SQS queue.</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">on_sqs_message</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"o\">=</span><span class=\"s1\">'my-queue-name'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">):</span>\n    <span class=\"k\">for</span> <span class=\"n\">record</span> <span class=\"ow\">in</span> <span class=\"n\">event</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Message body: </span><span class=\"si\">%s</span><span class=\"s2\">\"</span> <span class=\"o\">%</span> <span class=\"n\">record</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">)</span>\n</pre>\n<p>And several other AWS resources.</p>\n<p>Once you\u2019ve written your code, you just run <tt>chalice deploy</tt>\nand Chalice takes care of deploying your app.</p>\n<pre>$ chalice deploy\n...\nhttps://endpoint/dev\n\n$ curl https://endpoint/api\n{\"hello\": \"world\"}\n</pre>\n<p>Up and running in less than 30 seconds.\nGive this project a try and share your feedback with us here on Github.</p>\n<p>The documentation is available\n<a href=\"http://chalice.readthedocs.io/en/latest/\" rel=\"nofollow\">on readthedocs</a>.</p>\n<div id=\"quickstart\">\n<h2>Quickstart</h2>\n<p>In this tutorial, you\u2019ll use the <tt>chalice</tt> command line utility\nto create and deploy a basic REST API.\nFirst, you\u2019ll need to install <tt>chalice</tt>.  Using a virtualenv\nis recommended:</p>\n<pre>$ pip install virtualenv\n$ virtualenv ~/.virtualenvs/chalice-demo\n$ source ~/.virtualenvs/chalice-demo/bin/activate\n</pre>\n<p>Note: <strong>make sure you are using python2.7, python3.6, or python3.7</strong>.\nThese are the only python versions currently supported by AWS Lambda so they\nare also the only versions supported by the <tt>chalice</tt> CLI and <tt>chalice</tt>\npython package. You can check the version of python in your virtualenv by\nrunning:</p>\n<pre># Double check you have a supported python version in your virtualenv\n$ python -V\n</pre>\n<p>Next, in your virtualenv, install <tt>chalice</tt>:</p>\n<pre>$ pip install chalice\n</pre>\n<p>You can verify you have chalice installed by running:</p>\n<pre>$ chalice --help\nUsage: chalice [OPTIONS] COMMAND [ARGS]...\n...\n</pre>\n<div id=\"credentials\">\n<h3>Credentials</h3>\n<p>Before you can deploy an application, be sure you have\ncredentials configured.  If you have previously configured your\nmachine to run boto3 (the AWS SDK for Python) or the AWS CLI then\nyou can skip this section.</p>\n<p>If this is your first time configuring credentials for AWS you\ncan follow these steps to quickly get started:</p>\n<pre>$ mkdir ~/.aws\n$ cat &gt;&gt; ~/.aws/config\n[default]\naws_access_key_id=YOUR_ACCESS_KEY_HERE\naws_secret_access_key=YOUR_SECRET_ACCESS_KEY\nregion=YOUR_REGION (such as us-west-2, us-west-1, etc)\n</pre>\n<p>If you want more information on all the supported methods for\nconfiguring credentials, see the\n<a href=\"http://boto3.readthedocs.io/en/latest/guide/configuration.html\" rel=\"nofollow\">boto3 docs</a>.</p>\n</div>\n<div id=\"creating-your-project\">\n<h3>Creating Your Project</h3>\n<p>The next thing we\u2019ll do is use the <tt>chalice</tt> command to create a new\nproject:</p>\n<pre>$ chalice new-project helloworld\n</pre>\n<p>This will create a <tt>helloworld</tt> directory.  Cd into this\ndirectory.  You\u2019ll see several files have been created for you:</p>\n<pre>$ cd helloworld\n$ ls -la\ndrwxr-xr-x   .chalice\n-rw-r--r--   app.py\n-rw-r--r--   requirements.txt\n</pre>\n<p>You can ignore the <tt>.chalice</tt> directory for now, the two main files\nwe\u2019ll focus on is <tt>app.py</tt> and <tt>requirements.txt</tt>.</p>\n<p>Let\u2019s take a look at the <tt>app.py</tt> file:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">Chalice</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Chalice</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s1\">'helloworld'</span><span class=\"p\">)</span>\n\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">index</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s1\">'hello'</span><span class=\"p\">:</span> <span class=\"s1\">'world'</span><span class=\"p\">}</span>\n</pre>\n<p>The <tt><span class=\"pre\">new-project</span></tt> command created a sample app that defines a\nsingle view, <tt>/</tt>, that when called will return the JSON body\n<tt>{\"hello\": \"world\"}</tt>.</p>\n</div>\n<div id=\"deploying\">\n<h3>Deploying</h3>\n<p>Let\u2019s deploy this app.  Make sure you\u2019re in the <tt>helloworld</tt>\ndirectory and run <tt>chalice deploy</tt>:</p>\n<pre>$ chalice deploy\n...\nInitiating first time deployment...\nhttps://qxea58oupc.execute-api.us-west-2.amazonaws.com/api/\n</pre>\n<p>You now have an API up and running using API Gateway and Lambda:</p>\n<pre>$ curl https://qxea58oupc.execute-api.us-west-2.amazonaws.com/api/\n{\"hello\": \"world\"}\n</pre>\n<p>Try making a change to the returned dictionary from the <tt>index()</tt>\nfunction.  You can then redeploy your changes by running <tt>chalice deploy</tt>.</p>\n<p>For the rest of these tutorials, we\u2019ll be using <tt>httpie</tt> instead of <tt>curl</tt>\n(<a href=\"https://github.com/jakubroztocil/httpie\" rel=\"nofollow\">https://github.com/jakubroztocil/httpie</a>) to test our API.  You can install\n<tt>httpie</tt> using <tt>pip install httpie</tt>, or if you\u2019re on Mac, you can run\n<tt>brew install httpie</tt>.  The Github link has more information on installation\ninstructions.  Here\u2019s an example of using <tt>httpie</tt> to request the root\nresource of the API we just created.  Note that the command name is <tt>http</tt>:</p>\n<pre>$ http https://qxea58oupc.execute-api.us-west-2.amazonaws.com/api/\nHTTP/1.1 200 OK\nConnection: keep-alive\nContent-Length: 18\nContent-Type: application/json\nDate: Mon, 30 May 2016 17:55:50 GMT\nX-Cache: Miss from cloudfront\n\n{\n    \"hello\": \"world\"\n}\n</pre>\n<p>Additionally, the API Gateway endpoints will be shortened to\n<tt><span class=\"pre\">https://endpoint/api/</span></tt> for brevity.  Be sure to substitute\n<tt><span class=\"pre\">https://endpoint/api/</span></tt> for the actual endpoint that the <tt>chalice</tt>\nCLI displays when you deploy your API (it will look something like\n<tt><span class=\"pre\">https://abcdefg.execute-api.us-west-2.amazonaws.com/api/</span></tt>.</p>\n</div>\n<div id=\"next-steps\">\n<h3>Next Steps</h3>\n<p>You\u2019ve now created your first app using <tt>chalice</tt>.</p>\n<p>The next few sections will build on this quickstart section and introduce\nyou to additional features including: URL parameter capturing,\nerror handling, advanced routing, current request metadata, and automatic\npolicy generation.</p>\n</div>\n</div>\n<div id=\"tutorial-url-parameters\">\n<h2>Tutorial: URL Parameters</h2>\n<p>Now we\u2019re going to make a few changes to our <tt>app.py</tt> file that\ndemonstrate additional capabilities provided by the python serverless\nmicroframework for AWS.</p>\n<p>Our application so far has a single view that allows you to make\nan HTTP GET request to <tt>/</tt>.  Now let\u2019s suppose we want to capture\nparts of the URI:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">Chalice</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Chalice</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s1\">'helloworld'</span><span class=\"p\">)</span>\n\n<span class=\"n\">CITIES_TO_STATE</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'seattle'</span><span class=\"p\">:</span> <span class=\"s1\">'WA'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'portland'</span><span class=\"p\">:</span> <span class=\"s1\">'OR'</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">index</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s1\">'hello'</span><span class=\"p\">:</span> <span class=\"s1\">'world'</span><span class=\"p\">}</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/cities/</span><span class=\"si\">{city}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">state_of_city</span><span class=\"p\">(</span><span class=\"n\">city</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s1\">'state'</span><span class=\"p\">:</span> <span class=\"n\">CITIES_TO_STATE</span><span class=\"p\">[</span><span class=\"n\">city</span><span class=\"p\">]}</span>\n</pre>\n<p>In the example above, we\u2019ve now added a <tt>state_of_city</tt> view that allows\na user to specify a city name.  The view function takes the city\nname and returns name of the state the city is in.  Notice that the\n<tt>@app.route</tt> decorator has a URL pattern of <tt><span class=\"pre\">/cities/{city}</span></tt>.  This\nmeans that the value of <tt>{city}</tt> is captured and passed to the view\nfunction.  You can also see that the <tt>state_of_city</tt> takes a single\nargument.  This argument is the name of the city provided by the user.\nFor example:</p>\n<pre>GET /cities/seattle   --&gt; state_of_city('seattle')\nGET /cities/portland  --&gt; state_of_city('portland')\n</pre>\n<p>Now that we\u2019ve updated our <tt>app.py</tt> file with this new view function,\nlet\u2019s redeploy our application.  You can run <tt>chalice deploy</tt> from\nthe <tt>helloworld</tt> directory and it will deploy your application:</p>\n<pre>$ chalice deploy\n</pre>\n<p>Let\u2019s try it out.  Note the examples below use the <tt>http</tt> command\nfrom the <tt>httpie</tt> package.  You can install this using <tt>pip install httpie</tt>:</p>\n<pre>$ http https://endpoint/api/cities/seattle\nHTTP/1.1 200 OK\n\n{\n    \"state\": \"WA\"\n}\n\n$ http https://endpoint/api/cities/portland\nHTTP/1.1 200 OK\n\n{\n    \"state\": \"OR\"\n}\n</pre>\n<p>Notice what happens if we try to request a city that\u2019s not in our\n<tt>CITIES_TO_STATE</tt> map:</p>\n<pre>$ http https://endpoint/api/cities/vancouver\nHTTP/1.1 500 Internal Server Error\nContent-Type: application/json\nX-Cache: Error from cloudfront\n\n{\n    \"Code\": \"ChaliceViewError\",\n    \"Message\": \"ChaliceViewError: An internal server error occurred.\"\n}\n</pre>\n<p>In the next section, we\u2019ll see how to fix this and provide better\nerror messages.</p>\n</div>\n<div id=\"tutorial-error-messages\">\n<h2>Tutorial: Error Messages</h2>\n<p>In the example above, you\u2019ll notice that when our app raised\nan uncaught exception, a 500 internal server error was returned.</p>\n<p>In this section, we\u2019re going to show how you can debug and improve\nthese error messages.</p>\n<p>The first thing we\u2019re going to look at is how we can debug this\nissue.  By default, debugging is turned off, but you can\nenable debugging to get more information:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">Chalice</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Chalice</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s1\">'helloworld'</span><span class=\"p\">)</span>\n<span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">debug</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n</pre>\n<p>The <tt>app.debug = True</tt> enables debugging for your app.\nSave this file and redeploy your changes:</p>\n<pre>$ chalice deploy\n...\nhttps://endpoint/api/\n</pre>\n<p>Now, when you request the same URL that returned an internal\nserver error, you\u2019ll get back the original stack trace:</p>\n<pre>$ http https://endpoint/api/cities/vancouver\nTraceback (most recent call last):\n  File \"/var/task/chalice/app.py\", line 304, in _get_view_function_response\n    response = view_function(*function_args)\n  File \"/var/task/app.py\", line 18, in state_of_city\n    return {'state': CITIES_TO_STATE[city]}\nKeyError: u'vancouver'\n</pre>\n<p>We can see that the error is caused from an uncaught <tt>KeyError</tt> resulting\nfrom trying to access the <tt>vancouver</tt> key.</p>\n<p>Now that we know the error, we can fix our code.  What we\u2019d like to do is\ncatch this exception and instead return a more helpful error message\nto the user.  Here\u2019s the updated code:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">BadRequestError</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/cities/</span><span class=\"si\">{city}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">state_of_city</span><span class=\"p\">(</span><span class=\"n\">city</span><span class=\"p\">):</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s1\">'state'</span><span class=\"p\">:</span> <span class=\"n\">CITIES_TO_STATE</span><span class=\"p\">[</span><span class=\"n\">city</span><span class=\"p\">]}</span>\n    <span class=\"k\">except</span> <span class=\"ne\">KeyError</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"n\">BadRequestError</span><span class=\"p\">(</span><span class=\"s2\">\"Unknown city '</span><span class=\"si\">%s</span><span class=\"s2\">', valid choices are: </span><span class=\"si\">%s</span><span class=\"s2\">\"</span> <span class=\"o\">%</span> <span class=\"p\">(</span>\n            <span class=\"n\">city</span><span class=\"p\">,</span> <span class=\"s1\">', '</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">CITIES_TO_STATE</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">())))</span>\n</pre>\n<p>Save and deploy these changes:</p>\n<pre>$ chalice deploy\n$ http https://endpoint/api/cities/vancouver\nHTTP/1.1 400 Bad Request\n\n{\n    \"Code\": \"BadRequestError\",\n    \"Message\": \"Unknown city 'vancouver', valid choices are: portland, seattle\"\n}\n</pre>\n<p>We can see now that we have received a <tt>Code</tt> and <tt>Message</tt> key, with the message\nbeing the value we passed to <tt>BadRequestError</tt>.  Whenever you raise\na <tt>BadRequestError</tt> from your view function, the framework will return an\nHTTP status code of 400 along with a JSON body with a <tt>Code</tt> and <tt>Message</tt>.\nThere are a few additional exceptions you can raise from your python code:</p>\n<pre>* BadRequestError - return a status code of 400\n* UnauthorizedError - return a status code of 401\n* ForbiddenError - return a status code of 403\n* NotFoundError - return a status code of 404\n* ConflictError - return a status code of 409\n* UnprocessableEntityError - return a status code of 422\n* TooManyRequestsError - return a status code of 429\n* ChaliceViewError - return a status code of 500\n</pre>\n<p>You can import these directly from the <tt>chalice</tt> package:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">UnauthorizedError</span>\n</pre>\n</div>\n<div id=\"tutorial-additional-routing\">\n<h2>Tutorial: Additional Routing</h2>\n<p>So far, our examples have only allowed GET requests.\nIt\u2019s actually possible to support additional HTTP methods.\nHere\u2019s an example of a view function that supports PUT:</p>\n<pre><span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/resource/</span><span class=\"si\">{value}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'PUT'</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">put_test</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s2\">\"value\"</span><span class=\"p\">:</span> <span class=\"n\">value</span><span class=\"p\">}</span>\n</pre>\n<p>We can test this method using the <tt>http</tt> command:</p>\n<pre>$ http PUT https://endpoint/api/resource/foo\nHTTP/1.1 200 OK\n\n{\n    \"value\": \"foo\"\n}\n</pre>\n<p>Note that the <tt>methods</tt> kwarg accepts a list of methods.  Your view function\nwill be called when any of the HTTP methods you specify are used for the\nspecified resource.  For example:</p>\n<pre><span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/myview'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'POST'</span><span class=\"p\">,</span> <span class=\"s1\">'PUT'</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">myview</span><span class=\"p\">():</span>\n    <span class=\"k\">pass</span>\n</pre>\n<p>The above view function will be called when either an HTTP POST or\nPUT is sent to <tt>/myview</tt>.</p>\n<p>Alternatively if you do not want to share the same view function across\nmultiple HTTP methods for the same route url, you may define separate view\nfunctions to the same route url but have the view functions differ by\nHTTP method. For example:</p>\n<pre><span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/myview'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'POST'</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">myview_post</span><span class=\"p\">():</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/myview'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'PUT'</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">myview_put</span><span class=\"p\">():</span>\n    <span class=\"k\">pass</span>\n</pre>\n<p>This setup will route all HTTP POST\u2019s to <tt>/myview</tt> to the <tt>myview_post()</tt>\nview function and route all HTTP PUT\u2019s to <tt>/myview</tt> to the <tt>myview_put()</tt>\nview function. It is also important to note that the view functions\n<strong>must</strong> have unique names. For example, both view functions cannot be\nnamed <tt>myview()</tt>.</p>\n<p>In the next section we\u2019ll go over how you can introspect the given request\nin order to differentiate between various HTTP methods.</p>\n</div>\n<div id=\"tutorial-request-metadata\">\n<h2>Tutorial: Request Metadata</h2>\n<p>In the examples above, you saw how to create a view function that supports\nan HTTP PUT request as well as a view function that supports both POST and\nPUT via the same view function.  However, there\u2019s more information we\nmight need about a given request:</p>\n<ul>\n<li>In a PUT/POST, you frequently send a request body.  We need some\nway of accessing the contents of the request body.</li>\n<li>For view functions that support multiple HTTP methods, we\u2019d like\nto detect which HTTP method was used so we can have different\ncode paths for PUTs vs. POSTs.</li>\n</ul>\n<p>All of this and more is handled by the current request object that the\n<tt>chalice</tt> library makes available to each view function when it\u2019s called.</p>\n<p>Let\u2019s see an example of this.  Suppose we want to create a view function\nthat allowed you to PUT data to an object and retrieve that data\nvia a corresponding GET.  We could accomplish that with the\nfollowing view function:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">NotFoundError</span>\n\n<span class=\"n\">OBJECTS</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/objects/</span><span class=\"si\">{key}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'GET'</span><span class=\"p\">,</span> <span class=\"s1\">'PUT'</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">myobject</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">):</span>\n    <span class=\"n\">request</span> <span class=\"o\">=</span> <span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">current_request</span>\n    <span class=\"k\">if</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">method</span> <span class=\"o\">==</span> <span class=\"s1\">'PUT'</span><span class=\"p\">:</span>\n        <span class=\"n\">OBJECTS</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">json_body</span>\n    <span class=\"k\">elif</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">method</span> <span class=\"o\">==</span> <span class=\"s1\">'GET'</span><span class=\"p\">:</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"n\">OBJECTS</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">]}</span>\n        <span class=\"k\">except</span> <span class=\"ne\">KeyError</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"n\">NotFoundError</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span>\n</pre>\n<p>Save this in your <tt>app.py</tt> file and rerun <tt>chalice deploy</tt>.\nNow, you can make a PUT request to <tt><span class=\"pre\">/objects/your-key</span></tt> with a request\nbody, and retrieve the value of that body by making a subsequent\n<tt>GET</tt> request to the same resource.  Here\u2019s an example of its usage:</p>\n<pre># First, trying to retrieve the key will return a 404.\n$ http GET https://endpoint/api/objects/mykey\nHTTP/1.1 404 Not Found\n\n{\n    \"Code\": \"NotFoundError\",\n    \"Message\": \"mykey\"\n}\n\n# Next, we'll create that key by sending a PUT request.\n$ echo '{\"foo\": \"bar\"}' | http PUT https://endpoint/api/objects/mykey\nHTTP/1.1 200 OK\n\nnull\n\n# And now we no longer get a 404, we instead get the value we previously\n# put.\n$ http GET https://endpoint/api/objects/mykey\nHTTP/1.1 200 OK\n\n{\n    \"mykey\": {\n        \"foo\": \"bar\"\n    }\n}\n</pre>\n<p>You might see a problem with storing the objects in a module level\n<tt>OBJECTS</tt> variable.  We address this in the next section.</p>\n<p>The <tt>app.current_request</tt> object also has the following properties.</p>\n<ul>\n<li><tt>current_request.query_params</tt> - A dict of the query params for the request.</li>\n<li><tt>current_request.headers</tt> - A dict of the request headers.</li>\n<li><tt>current_request.uri_params</tt> - A dict of the captured URI params.</li>\n<li><tt>current_request.method</tt> -  The HTTP method (as a string).</li>\n<li><tt>current_request.json_body</tt> - The parsed JSON body (<tt>json.loads(raw_body)</tt>)</li>\n<li><tt>current_request.raw_body</tt> - The raw HTTP body as bytes.</li>\n<li><tt>current_request.context</tt> - A dict of additional context information</li>\n<li><tt>current_request.stage_vars</tt> - Configuration for the API Gateway stage</li>\n</ul>\n<p>Don\u2019t worry about the <tt>context</tt> and <tt>stage_vars</tt> for now.  We haven\u2019t\ndiscussed those concepts yet.  The <tt>current_request</tt> object also\nhas a <tt>to_dict</tt> method, which returns all the information about the\ncurrent request as a dictionary.  Let\u2019s use this method to write a view\nfunction that returns everything it knows about the request:</p>\n<pre><span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/introspect'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">introspect</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">current_request</span><span class=\"o\">.</span><span class=\"n\">to_dict</span><span class=\"p\">()</span>\n</pre>\n<p>Save this to your <tt>app.py</tt> file and redeploy with <tt>chalice deploy</tt>.\nHere\u2019s an example of hitting the <tt>/introspect</tt> URL.  Note how we\u2019re\nsending a query string as well as a custom <tt><span class=\"pre\">X-TestHeader</span></tt> header:</p>\n<pre>$ http 'https://endpoint/api/introspect?query1=value1&amp;query2=value2' 'X-TestHeader: Foo'\nHTTP/1.1 200 OK\n\n{\n    \"context\": {\n        \"apiId\": \"apiId\",\n        \"httpMethod\": \"GET\",\n        \"identity\": {\n            \"accessKey\": null,\n            \"accountId\": null,\n            \"apiKey\": null,\n            \"caller\": null,\n            \"cognitoAuthenticationProvider\": null,\n            \"cognitoAuthenticationType\": null,\n            \"cognitoIdentityId\": null,\n            \"cognitoIdentityPoolId\": null,\n            \"sourceIp\": \"1.1.1.1\",\n            \"userAgent\": \"HTTPie/0.9.3\",\n            \"userArn\": null\n        },\n        \"requestId\": \"request-id\",\n        \"resourceId\": \"resourceId\",\n        \"resourcePath\": \"/introspect\",\n        \"stage\": \"dev\"\n    },\n    \"headers\": {\n        \"accept\": \"*/*\",\n        ...\n        \"x-testheader\": \"Foo\"\n    },\n    \"method\": \"GET\",\n    \"query_params\": {\n        \"query1\": \"value1\",\n        \"query2\": \"value2\"\n    },\n    \"raw_body\": null,\n    \"stage_vars\": null,\n    \"uri_params\": null\n}\n</pre>\n</div>\n<div id=\"tutorial-request-content-types\">\n<h2>Tutorial: Request Content Types</h2>\n<p>The default behavior of a view function supports\na request body of <tt>application/json</tt>.  When a request is\nmade with a <tt><span class=\"pre\">Content-Type</span></tt> of <tt>application/json</tt>, the\n<tt>app.current_request.json_body</tt> attribute is automatically\nset for you.  This value is the parsed JSON body.</p>\n<p>You can also configure a view function to support other\ncontent types.  You can do this by specifying the\n<tt>content_types</tt> parameter value to your <tt>app.route</tt>\nfunction.  This parameter is a list of acceptable content\ntypes.  Here\u2019s an example of this feature:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">Chalice</span>\n<span class=\"k\">if</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">version_info</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">3</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Python 3 imports.</span>\n    <span class=\"kn\">from</span> <span class=\"nn\">urllib.parse</span> <span class=\"kn\">import</span> <span class=\"n\">urlparse</span><span class=\"p\">,</span> <span class=\"n\">parse_qs</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Python 2 imports.</span>\n    <span class=\"kn\">from</span> <span class=\"nn\">urlparse</span> <span class=\"kn\">import</span> <span class=\"n\">urlparse</span><span class=\"p\">,</span> <span class=\"n\">parse_qs</span>\n\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Chalice</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s1\">'helloworld'</span><span class=\"p\">)</span>\n\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'POST'</span><span class=\"p\">],</span>\n           <span class=\"n\">content_types</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'application/x-www-form-urlencoded'</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">index</span><span class=\"p\">():</span>\n    <span class=\"n\">parsed</span> <span class=\"o\">=</span> <span class=\"n\">parse_qs</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">current_request</span><span class=\"o\">.</span><span class=\"n\">raw_body</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">())</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'states'</span><span class=\"p\">:</span> <span class=\"n\">parsed</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'states'</span><span class=\"p\">,</span> <span class=\"p\">[])</span>\n    <span class=\"p\">}</span>\n</pre>\n<p>There\u2019s a few things worth noting in this view function.\nFirst, we\u2019ve specified that we only accept the\n<tt><span class=\"pre\">application/x-www-form-urlencoded</span></tt> content type.  If we\ntry to send a request with <tt>application/json</tt>, we\u2019ll now\nget a <tt>415 Unsupported Media Type</tt> response:</p>\n<pre>$ http POST https://endpoint/api/ states=WA states=CA --debug\n...\n&gt;&gt;&gt; requests.request(**{'allow_redirects': False,\n 'headers': {'Accept': 'application/json',\n             'Content-Type': 'application/json',\n...\n\n\nHTTP/1.1 415 Unsupported Media Type\n\n{\n    \"message\": \"Unsupported Media Type\"\n}\n</pre>\n<p>If we use the <tt><span class=\"pre\">--form</span></tt> argument, we can see the\nexpected behavior of this view function because <tt>httpie</tt> sets the\n<tt><span class=\"pre\">Content-Type</span></tt> header to <tt><span class=\"pre\">application/x-www-form-urlencoded</span></tt>:</p>\n<pre>$ http --form POST https://endpoint/api/formtest states=WA states=CA --debug\n...\n&gt;&gt;&gt; requests.request(**{'allow_redirects': False,\n 'headers': {'Content-Type': 'application/x-www-form-urlencoded; charset=utf-8',\n...\n\nHTTP/1.1 200 OK\n{\n    \"states\": [\n        \"WA\",\n        \"CA\"\n    ]\n}\n</pre>\n<p>The second thing worth noting is that <tt>app.current_request.json_body</tt>\n<strong>is only available for the application/json content type.</strong>\nIn our example above, we used <tt>app.current_request.raw_body</tt> to access\nthe raw body bytes:</p>\n<pre><span class=\"n\">parsed</span> <span class=\"o\">=</span> <span class=\"n\">parse_qs</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">current_request</span><span class=\"o\">.</span><span class=\"n\">raw_body</span><span class=\"p\">)</span>\n</pre>\n<p><tt>app.current_request.json_body</tt> is set to <tt>None</tt> whenever the\n<tt><span class=\"pre\">Content-Type</span></tt> is not <tt>application/json</tt>.  This means that\nyou will need to use <tt>app.current_request.raw_body</tt> and parse\nthe request body as needed.</p>\n</div>\n<div id=\"tutorial-customizing-the-http-response\">\n<h2>Tutorial: Customizing the HTTP Response</h2>\n<p>The return value from a chalice view function is serialized as JSON as the\nresponse body returned back to the caller.  This makes it easy to create\nrest APIs that return JSON response bodies.</p>\n<p>Chalice allows you to control this behavior by returning an instance of\na chalice specific <tt>Response</tt> class.  This behavior allows you to:</p>\n<ul>\n<li>Specify the status code to return</li>\n<li>Specify custom headers to add to the response</li>\n<li>Specify response bodies that are not <tt>application/json</tt></li>\n</ul>\n<p>Here\u2019s an example of this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">Chalice</span><span class=\"p\">,</span> <span class=\"n\">Response</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Chalice</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s1\">'custom-response'</span><span class=\"p\">)</span>\n\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">index</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"n\">Response</span><span class=\"p\">(</span><span class=\"n\">body</span><span class=\"o\">=</span><span class=\"s1\">'hello world!'</span><span class=\"p\">,</span>\n                    <span class=\"n\">status_code</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">,</span>\n                    <span class=\"n\">headers</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'Content-Type'</span><span class=\"p\">:</span> <span class=\"s1\">'text/plain'</span><span class=\"p\">})</span>\n</pre>\n<p>This will result in a plain text response body:</p>\n<pre>$ http https://endpoint/api/\nHTTP/1.1 200 OK\nContent-Length: 12\nContent-Type: text/plain\n\nhello world!\n</pre>\n</div>\n<div id=\"tutorial-gzip-compression-for-json\">\n<h2>Tutorial: GZIP compression for json</h2>\n<p>The return value from a chalice view function is serialized as JSON as the\nresponse body returned back to the caller.  This makes it easy to create\nrest APIs that return JSON response bodies.</p>\n<p>Chalice allows you to control this behavior by returning an instance of\na chalice specific <tt>Response</tt> class.  This behavior allows you to:</p>\n<ul>\n<li>Add <tt>application/json</tt> to binary_types</li>\n<li>Specify the status code to return</li>\n<li>Specify custom header <tt><span class=\"pre\">Content-Type:</span> application/json</tt></li>\n<li>Specify custom header <tt><span class=\"pre\">Content-Encoding:</span> gzip</tt></li>\n</ul>\n<p>Here\u2019s an example of this:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">json</span>\n<span class=\"kn\">import</span> <span class=\"nn\">gzip</span>\n<span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">Chalice</span><span class=\"p\">,</span> <span class=\"n\">Response</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Chalice</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s1\">'compress-response'</span><span class=\"p\">)</span>\n<span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">api</span><span class=\"o\">.</span><span class=\"n\">binary_types</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"s1\">'application/json'</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">index</span><span class=\"p\">():</span>\n    <span class=\"n\">blob</span> <span class=\"o\">=</span> <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">({</span><span class=\"s1\">'hello'</span><span class=\"p\">:</span> <span class=\"s1\">'world'</span><span class=\"p\">})</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"s1\">'utf-8'</span><span class=\"p\">)</span>\n    <span class=\"n\">payload</span> <span class=\"o\">=</span> <span class=\"n\">gzip</span><span class=\"o\">.</span><span class=\"n\">compress</span><span class=\"p\">(</span><span class=\"n\">blob</span><span class=\"p\">)</span>\n    <span class=\"n\">custom_headers</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'Content-Type'</span><span class=\"p\">:</span> <span class=\"s1\">'application/json'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'Content-Encoding'</span><span class=\"p\">:</span> <span class=\"s1\">'gzip'</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">Response</span><span class=\"p\">(</span><span class=\"n\">body</span><span class=\"o\">=</span><span class=\"n\">payload</span><span class=\"p\">,</span>\n                    <span class=\"n\">status_code</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">,</span>\n                    <span class=\"n\">headers</span><span class=\"o\">=</span><span class=\"n\">custom_headers</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"tutorial-cors-support\">\n<h2>Tutorial: CORS Support</h2>\n<p>You can specify whether a view supports CORS by adding the\n<tt>cors=True</tt> parameter to your <tt>@app.route()</tt> call.  By\ndefault this value is false:</p>\n<pre><span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/supports-cors'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'PUT'</span><span class=\"p\">],</span> <span class=\"n\">cors</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">supports_cors</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"p\">{}</span>\n</pre>\n<p>Settings <tt>cors=True</tt> has similar behavior to enabling CORS\nusing the AWS Console.  This includes:</p>\n<ul>\n<li>Injecting the <tt><span class=\"pre\">Access-Control-Allow-Origin:</span> *</tt> header to your\nresponses, including all error responses you can return.</li>\n<li>Automatically adding an <tt>OPTIONS</tt> method to support preflighting\nrequests.</li>\n</ul>\n<p>The preflight request will return a response that includes:</p>\n<ul>\n<li><tt><span class=\"pre\">Access-Control-Allow-Origin:</span> *</tt></li>\n<li>The <tt><span class=\"pre\">Access-Control-Allow-Methods</span></tt> header will return a list of all HTTP\nmethods you\u2019ve called out in your view function.  In the example above,\nthis will be <tt>PUT,OPTIONS</tt>.</li>\n<li><tt><span class=\"pre\">Access-Control-Allow-Headers:</span> <span class=\"pre\">Content-Type,X-Amz-Date,Authorization,</span>\n<span class=\"pre\">X-Api-Key,X-Amz-Security-Token</span></tt>.</li>\n</ul>\n<p>If more fine grained control of the CORS headers is desired, set the <tt>cors</tt>\nparameter to an instance of <tt>CORSConfig</tt> instead of <tt>True</tt>. The\n<tt>CORSConfig</tt> object can be imported from from the <tt>chalice</tt> package it\u2019s\nconstructor takes the following keyword arguments that map to CORS headers:</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Argument</th>\n<th>Type</th>\n<th>Header</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>allow_origin</td>\n<td>str</td>\n<td>Access-Control-Allow-Origin</td>\n</tr>\n<tr><td>allow_headers</td>\n<td>list</td>\n<td>Access-Control-Allow-Headers</td>\n</tr>\n<tr><td>expose_headers</td>\n<td>list</td>\n<td>Access-Control-Expose-Headers</td>\n</tr>\n<tr><td>max_age</td>\n<td>int</td>\n<td>Access-Control-Max-Age</td>\n</tr>\n<tr><td>allow_credentials</td>\n<td>bool</td>\n<td>Access-Control-Allow-Credentials</td>\n</tr>\n</tbody>\n</table>\n<p>Code sample defining more CORS headers:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">CORSConfig</span>\n<span class=\"n\">cors_config</span> <span class=\"o\">=</span> <span class=\"n\">CORSConfig</span><span class=\"p\">(</span>\n    <span class=\"n\">allow_origin</span><span class=\"o\">=</span><span class=\"s1\">'https://foo.example.com'</span><span class=\"p\">,</span>\n    <span class=\"n\">allow_headers</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'X-Special-Header'</span><span class=\"p\">],</span>\n    <span class=\"n\">max_age</span><span class=\"o\">=</span><span class=\"mi\">600</span><span class=\"p\">,</span>\n    <span class=\"n\">expose_headers</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'X-Special-Header'</span><span class=\"p\">],</span>\n    <span class=\"n\">allow_credentials</span><span class=\"o\">=</span><span class=\"kc\">True</span>\n<span class=\"p\">)</span>\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/custom_cors'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'GET'</span><span class=\"p\">],</span> <span class=\"n\">cors</span><span class=\"o\">=</span><span class=\"n\">cors_config</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">supports_custom_cors</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s1\">'cors'</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">}</span>\n</pre>\n<p>There\u2019s a couple of things to keep in mind when enabling cors for a view:</p>\n<ul>\n<li><p>An <tt>OPTIONS</tt> method for preflighting is always injected.  Ensure that\nyou don\u2019t have <tt>OPTIONS</tt> in the <tt><span class=\"pre\">methods=[...]</span></tt> list of your\nview function.</p>\n</li>\n<li><p>Even though the <tt><span class=\"pre\">Access-Control-Allow-Origin</span></tt> header can be set to a\nstring that is a space separated list of origins, this behavior does not\nwork on all clients that implement CORS. You should only supply a single\norigin to the <tt>CORSConfig</tt> object. If you need to supply multiple origins\nyou will need to define a custom handler for it that accepts <tt>OPTIONS</tt>\nrequests and matches the <tt>Origin</tt> header against a whitelist of origins.\nIf the match is successful then return just their <tt>Origin</tt> back to them\nin the <tt><span class=\"pre\">Access-Control-Allow-Origin</span></tt> header.</p>\n<p>Example:</p>\n</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">Chalice</span><span class=\"p\">,</span> <span class=\"n\">Response</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Chalice</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s1\">'multipleorigincors'</span><span class=\"p\">)</span>\n\n<span class=\"n\">_ALLOWED_ORIGINS</span> <span class=\"o\">=</span> <span class=\"nb\">set</span><span class=\"p\">([</span>\n    <span class=\"s1\">'http://allowed1.example.com'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'http://allowed2.example.com'</span><span class=\"p\">,</span>\n<span class=\"p\">])</span>\n\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/cors_multiple_origins'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'GET'</span><span class=\"p\">,</span> <span class=\"s1\">'OPTIONS'</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">supports_cors_multiple_origins</span><span class=\"p\">():</span>\n    <span class=\"n\">method</span> <span class=\"o\">=</span> <span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">current_request</span><span class=\"o\">.</span><span class=\"n\">method</span>\n    <span class=\"k\">if</span> <span class=\"n\">method</span> <span class=\"o\">==</span> <span class=\"s1\">'OPTIONS'</span><span class=\"p\">:</span>\n        <span class=\"n\">headers</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'Access-Control-Allow-Method'</span><span class=\"p\">:</span> <span class=\"s1\">'GET,OPTIONS'</span><span class=\"p\">,</span>\n            <span class=\"s1\">'Access-Control-Allow-Origin'</span><span class=\"p\">:</span> <span class=\"s1\">','</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">_ALLOWED_ORIGINS</span><span class=\"p\">),</span>\n            <span class=\"s1\">'Access-Control-Allow-Headers'</span><span class=\"p\">:</span> <span class=\"s1\">'X-Some-Header'</span><span class=\"p\">,</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">origin</span> <span class=\"o\">=</span> <span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">current_request</span><span class=\"o\">.</span><span class=\"n\">headers</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'origin'</span><span class=\"p\">,</span> <span class=\"s1\">''</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">origin</span> <span class=\"ow\">in</span> <span class=\"n\">_ALLOWED_ORIGINS</span><span class=\"p\">:</span>\n            <span class=\"n\">headers</span><span class=\"o\">.</span><span class=\"n\">update</span><span class=\"p\">({</span><span class=\"s1\">'Access-Control-Allow-Origin'</span><span class=\"p\">:</span> <span class=\"n\">origin</span><span class=\"p\">})</span>\n        <span class=\"k\">return</span> <span class=\"n\">Response</span><span class=\"p\">(</span>\n            <span class=\"n\">body</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n            <span class=\"n\">headers</span><span class=\"o\">=</span><span class=\"n\">headers</span><span class=\"p\">,</span>\n        <span class=\"p\">)</span>\n    <span class=\"k\">elif</span> <span class=\"n\">method</span> <span class=\"o\">==</span> <span class=\"s1\">'GET'</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"s1\">'Foo'</span>\n</pre>\n<ul>\n<li>Every view function must explicitly enable CORS support.</li>\n</ul>\n<p>The last point will change in the future.  See\n<a href=\"https://github.com/aws/chalice/issues/70#issuecomment-248787037\" rel=\"nofollow\">this issue</a>\nfor more information.</p>\n</div>\n<div id=\"tutorial-policy-generation\">\n<h2>Tutorial: Policy Generation</h2>\n<p>In the previous section we created a basic rest API that\nallowed you to store JSON objects by sending the JSON\nin the body of an HTTP PUT request to <tt><span class=\"pre\">/objects/{name}</span></tt>.\nYou could then retrieve objects by sending a GET request to\n<tt><span class=\"pre\">/objects/{name}</span></tt>.</p>\n<p>However, there\u2019s a problem with the code we wrote:</p>\n<pre><span class=\"n\">OBJECTS</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/objects/</span><span class=\"si\">{key}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'GET'</span><span class=\"p\">,</span> <span class=\"s1\">'PUT'</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">myobject</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">):</span>\n    <span class=\"n\">request</span> <span class=\"o\">=</span> <span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">current_request</span>\n    <span class=\"k\">if</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">method</span> <span class=\"o\">==</span> <span class=\"s1\">'PUT'</span><span class=\"p\">:</span>\n        <span class=\"n\">OBJECTS</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">json_body</span>\n    <span class=\"k\">elif</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">method</span> <span class=\"o\">==</span> <span class=\"s1\">'GET'</span><span class=\"p\">:</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"n\">key</span><span class=\"p\">:</span> <span class=\"n\">OBJECTS</span><span class=\"p\">[</span><span class=\"n\">key</span><span class=\"p\">]}</span>\n        <span class=\"k\">except</span> <span class=\"ne\">KeyError</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"n\">NotFoundError</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span>\n</pre>\n<p>We\u2019re storing the key value pairs in a module level <tt>OBJECTS</tt>\nvariable.  We can\u2019t rely on local storage like this persisting\nacross requests.</p>\n<p>A better solution would be to store this information in Amazon S3.\nTo do this, we\u2019re going to use boto3, the AWS SDK for Python.\nFirst, install boto3:</p>\n<pre>$ pip install boto3\n</pre>\n<p>Next, add <tt>boto3</tt> to your requirements.txt file:</p>\n<pre>$ echo 'boto3==1.3.1' &gt;&gt; requirements.txt\n</pre>\n<p>The requirements.txt file should be in the same directory that contains\nyour <tt>app.py</tt> file.  Next, let\u2019s update our view code to use boto3:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">json</span>\n<span class=\"kn\">import</span> <span class=\"nn\">boto3</span>\n<span class=\"kn\">from</span> <span class=\"nn\">botocore.exceptions</span> <span class=\"kn\">import</span> <span class=\"n\">ClientError</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">NotFoundError</span>\n\n\n<span class=\"n\">S3</span> <span class=\"o\">=</span> <span class=\"n\">boto3</span><span class=\"o\">.</span><span class=\"n\">client</span><span class=\"p\">(</span><span class=\"s1\">'s3'</span><span class=\"p\">,</span> <span class=\"n\">region_name</span><span class=\"o\">=</span><span class=\"s1\">'us-west-2'</span><span class=\"p\">)</span>\n<span class=\"n\">BUCKET</span> <span class=\"o\">=</span> <span class=\"s1\">'your-bucket-name'</span>\n\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/objects/</span><span class=\"si\">{key}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'GET'</span><span class=\"p\">,</span> <span class=\"s1\">'PUT'</span><span class=\"p\">])</span>\n<span class=\"k\">def</span> <span class=\"nf\">s3objects</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">):</span>\n    <span class=\"n\">request</span> <span class=\"o\">=</span> <span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">current_request</span>\n    <span class=\"k\">if</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">method</span> <span class=\"o\">==</span> <span class=\"s1\">'PUT'</span><span class=\"p\">:</span>\n        <span class=\"n\">S3</span><span class=\"o\">.</span><span class=\"n\">put_object</span><span class=\"p\">(</span><span class=\"n\">Bucket</span><span class=\"o\">=</span><span class=\"n\">BUCKET</span><span class=\"p\">,</span> <span class=\"n\">Key</span><span class=\"o\">=</span><span class=\"n\">key</span><span class=\"p\">,</span>\n                      <span class=\"n\">Body</span><span class=\"o\">=</span><span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">json_body</span><span class=\"p\">))</span>\n    <span class=\"k\">elif</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">method</span> <span class=\"o\">==</span> <span class=\"s1\">'GET'</span><span class=\"p\">:</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">S3</span><span class=\"o\">.</span><span class=\"n\">get_object</span><span class=\"p\">(</span><span class=\"n\">Bucket</span><span class=\"o\">=</span><span class=\"n\">BUCKET</span><span class=\"p\">,</span> <span class=\"n\">Key</span><span class=\"o\">=</span><span class=\"n\">key</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">loads</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"p\">[</span><span class=\"s1\">'Body'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">())</span>\n        <span class=\"k\">except</span> <span class=\"n\">ClientError</span> <span class=\"k\">as</span> <span class=\"n\">e</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"n\">NotFoundError</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">)</span>\n</pre>\n<p>Make sure to change <tt>BUCKET</tt> with the name of an S3 bucket\nyou own.  Redeploy your changes with <tt>chalice deploy</tt>.\nNow, whenever we make a <tt>PUT</tt> request to <tt>/objects/keyname</tt>, the\ndata send will be stored in S3.  Any subsequent <tt>GET</tt> requests will\nretrieve this data from S3.</p>\n<div id=\"manually-providing-policies\">\n<h3>Manually Providing Policies</h3>\n<p>IAM permissions can be auto generated, provided manually or can be\npre-created and explicitly configured. To use a\npre-configured IAM role ARN for chalice, add these two keys to your\nchalice configuration. Setting manage_iam_role to false tells\nChalice to not attempt to generate policies and create IAM role.</p>\n<pre>\"manage_iam_role\":false\n\"iam_role_arn\":\"arn:aws:iam::&lt;account-id&gt;:role/&lt;role-name&gt;\"\n</pre>\n<p>Whenever your application is deployed using <tt>chalice</tt>, the\nauto generated policy is written to disk at\n<tt><span class=\"pre\">&lt;projectdir&gt;/.chalice/policy.json</span></tt>.  When you run the\n<tt>chalice deploy</tt> command, you can also specify the\n<tt><span class=\"pre\">--no-autogen-policy</span></tt> option.  Doing so will result in the\n<tt>chalice</tt> CLI loading the <tt><span class=\"pre\">&lt;projectdir&gt;/.chalice/policy.json</span></tt>\nfile and using that file as the policy for the IAM role.\nYou can manually edit this file and specify <tt><span class=\"pre\">--no-autogen-policy</span></tt>\nif you\u2019d like to have full control over what IAM policy to associate\nwith the IAM role.</p>\n<p>You can also run the <tt>chalice <span class=\"pre\">gen-policy</span></tt> command from your project\ndirectory to print the auto generated policy to stdout.  You can\nthen use this as a starting point for your policy.</p>\n<pre>$ chalice gen-policy\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Action\": [\n        \"s3:ListAllMyBuckets\"\n      ],\n      \"Resource\": [\n        \"*\"\n      ],\n      \"Effect\": \"Allow\",\n      \"Sid\": \"9155de6ad1d74e4c8b1448255770e60c\"\n    }\n  ]\n}\n</pre>\n</div>\n<div id=\"experimental-status\">\n<h3>Experimental Status</h3>\n<p>The automatic policy generation is still in the early stages, it should\nbe considered experimental.  You can always disable policy\ngeneration with <tt><span class=\"pre\">--no-autogen-policy</span></tt> for complete control.</p>\n<p>Additionally, you will be prompted for confirmation whenever the\nauto policy generator detects actions that it would like to add or remove:</p>\n<pre>$ chalice deploy\nUpdating IAM policy.\n\nThe following action will be added to the execution policy:\n\ns3:ListBucket\n\nWould you like to continue?  [Y/n]:\n</pre>\n</div>\n</div>\n<div id=\"tutorial-using-custom-authentication\">\n<h2>Tutorial: Using Custom Authentication</h2>\n<p>AWS API Gateway routes can be authenticated in multiple ways:</p>\n<ul>\n<li>API Key</li>\n<li>AWS IAM</li>\n<li>Cognito User Pools</li>\n<li>Custom Auth Handler</li>\n</ul>\n<div id=\"api-key\">\n<h3>API Key</h3>\n<pre><span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/authenticated'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'GET'</span><span class=\"p\">],</span> <span class=\"n\">api_key_required</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">authenticated</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s2\">\"secure\"</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">}</span>\n</pre>\n<p>Only requests sent with a valid <cite>X-Api-Key</cite> header will be accepted.</p>\n</div>\n<div id=\"using-aws-iam\">\n<h3>Using AWS IAM</h3>\n<pre><span class=\"n\">authorizer</span> <span class=\"o\">=</span> <span class=\"n\">IAMAuthorizer</span><span class=\"p\">()</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/iam-role'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'GET'</span><span class=\"p\">],</span> <span class=\"n\">authorizer</span><span class=\"o\">=</span><span class=\"n\">authorizer</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">authenticated</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s2\">\"secure\"</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">}</span>\n</pre>\n</div>\n<div id=\"using-amazon-cognito-user-pools\">\n<h3>Using Amazon Cognito User Pools</h3>\n<p>To integrate with cognito user pools, you can use the\n<tt>CognitoUserPoolAuthorizer</tt> object:</p>\n<pre><span class=\"n\">authorizer</span> <span class=\"o\">=</span> <span class=\"n\">CognitoUserPoolAuthorizer</span><span class=\"p\">(</span>\n    <span class=\"s1\">'MyPool'</span><span class=\"p\">,</span> <span class=\"n\">header</span><span class=\"o\">=</span><span class=\"s1\">'Authorization'</span><span class=\"p\">,</span>\n    <span class=\"n\">provider_arns</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'arn:aws:cognito:...:userpool/name'</span><span class=\"p\">])</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/user-pools'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'GET'</span><span class=\"p\">],</span> <span class=\"n\">authorizer</span><span class=\"o\">=</span><span class=\"n\">authorizer</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">authenticated</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s2\">\"secure\"</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">}</span>\n</pre>\n<p>Note, earlier versions of chalice also have an <tt>app.define_authorizer</tt>\nmethod as well as an <tt>authorizer_name</tt> argument on the <tt><span class=\"pre\">@app.route(...)</span></tt>\nmethod.  This approach is deprecated in favor of <tt>CognitoUserPoolAuthorizer</tt>\nand the <tt>authorizer</tt> argument in the <tt><span class=\"pre\">@app.route(...)</span></tt> method.\n<tt>app.define_authorizer</tt> will be removed in future versions of chalice.</p>\n</div>\n<div id=\"using-custom-authorizers\">\n<h3>Using Custom Authorizers</h3>\n<p>To integrate with custom authorizers, you can use the <tt>CustomAuthorizer</tt> method\non the <tt>app</tt> object.  You\u2019ll need to set the <tt>authorizer_uri</tt>\nto the URI of your lambda function.</p>\n<pre><span class=\"n\">authorizer</span> <span class=\"o\">=</span> <span class=\"n\">CustomAuthorizer</span><span class=\"p\">(</span>\n    <span class=\"s1\">'MyCustomAuth'</span><span class=\"p\">,</span> <span class=\"n\">header</span><span class=\"o\">=</span><span class=\"s1\">'Authorization'</span><span class=\"p\">,</span>\n    <span class=\"n\">authorizer_uri</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">'arn:aws:apigateway:region:lambda:path/2015-03-31'</span>\n                    <span class=\"s1\">'/functions/arn:aws:lambda:region:account-id:'</span>\n                    <span class=\"s1\">'function:FunctionName/invocations'</span><span class=\"p\">))</span>\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/custom-auth'</span><span class=\"p\">,</span> <span class=\"n\">methods</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'GET'</span><span class=\"p\">],</span> <span class=\"n\">authorizer</span><span class=\"o\">=</span><span class=\"n\">authorizer</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">authenticated</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s2\">\"secure\"</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">}</span>\n</pre>\n</div>\n</div>\n<div id=\"tutorial-local-mode\">\n<h2>Tutorial: Local Mode</h2>\n<p>As you develop your application, you may want to experiment locally  before\ndeploying your changes.  You can use <tt>chalice local</tt> to spin up a local\nHTTP server you can use for testing.</p>\n<p>For example, if we have the following <tt>app.py</tt> file:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">chalice</span> <span class=\"kn\">import</span> <span class=\"n\">Chalice</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Chalice</span><span class=\"p\">(</span><span class=\"n\">app_name</span><span class=\"o\">=</span><span class=\"s1\">'helloworld'</span><span class=\"p\">)</span>\n\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">index</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s1\">'hello'</span><span class=\"p\">:</span> <span class=\"s1\">'world'</span><span class=\"p\">}</span>\n</pre>\n<p>We can run <tt>chalice local</tt> to test this API locally:</p>\n<blockquote>\n$ chalice local\nServing on localhost:8000</blockquote>\n<p>We can override the port using:</p>\n<blockquote>\n$ chalice local \u2013port=8080</blockquote>\n<p>We can now test our API using <tt>localhost:8000</tt>:</p>\n<pre>$ http localhost:8000/\nHTTP/1.0 200 OK\nContent-Length: 18\nContent-Type: application/json\nDate: Thu, 27 Oct 2016 20:08:43 GMT\nServer: BaseHTTP/0.3 Python/2.7.11\n\n{\n    \"hello\": \"world\"\n}\n</pre>\n<p>The <tt>chalice local</tt> command <em>does not</em> assume the\nrole associated with your lambda function, so you\u2019ll\nneed to use an <tt>AWS_PROFILE</tt> that has sufficient permissions\nto your AWS resources used in your <tt>app.py</tt>.</p>\n</div>\n<div id=\"deleting-your-app\">\n<h2>Deleting Your App</h2>\n<p>You can use the <tt>chalice delete</tt> command to delete your app.\nSimilar to the <tt>chalice deploy</tt> command, you can specify which\nchalice stage to delete.  By default it will delete the <tt>dev</tt> stage:</p>\n<pre>$ chalice delete --stage dev\nDeleting Rest API: duvw4kwyl3\nDeleting function aws:arn:lambda:region:123456789:helloworld-dev\nDeleting IAM Role helloworld-dev\n</pre>\n</div>\n<div id=\"feedback\">\n<h2>Feedback</h2>\n<p>We\u2019also love to hear from you.  Please create any Github issues for\nadditional features you\u2019d like to see over at\n<a href=\"https://github.com/aws/chalice/issues\" rel=\"nofollow\">https://github.com/aws/chalice/issues</a>.  You can also chat with us\non gitter: <a href=\"https://gitter.im/awslabs/chalice\" rel=\"nofollow\">https://gitter.im/awslabs/chalice</a></p>\n</div>\n<div id=\"faq\">\n<h2>FAQ</h2>\n<p><strong>Q: How does the Python Serverless Microframework for AWS compare to other\nsimilar frameworks?</strong></p>\n<p>The biggest difference between this framework and others is that the Python\nServerless Microframework for AWS is singularly focused on using a familiar,\ndecorator-based API to write python applications that run on Amazon API Gateway\nand AWS Lambda.  You can think of it as\n<a href=\"http://flask.pocoo.org/\" rel=\"nofollow\">Flask</a>/<a href=\"http://bottlepy.org/docs/dev/index.html\" rel=\"nofollow\">Bottle</a>\nfor serverless APIs.  Its goal is to make writing and deploying these types of\napplications as simple as possible specifically for Python developers.</p>\n<p>To achieve this goal, it has to make certain tradeoffs.  Python will always\nremain the only supported language in this framework.  Not every feature of API\nGateway and Lambda is exposed in the framework.  It makes assumptions about how\napplications will be deployed, and it has restrictions on how an application\ncan be structured.  It does not address the creation and lifecycle of other AWS\nresources your application may need (Amazon S3 buckets, Amazon DynamoDB tables,\netc.).  The feature set is purposefully small.</p>\n<p>Other full-stack frameworks offer a lot more features and configurability than\nwhat this framework has and likely will ever have.  Those frameworks are\nexcellent choices for applications that need more than what is offered by this\nmicroframework.  If all you need is to create a simple rest API in Python that\nruns on Amazon API Gateway and AWS Lambda, consider giving the Python\nServerless Microframework for AWS a try.</p>\n<div id=\"related-projects\">\n<h3>Related Projects</h3>\n<ul>\n<li><a href=\"https://github.com/serverless/serverless\" rel=\"nofollow\">serverless</a> - Build applications\ncomprised of microservices that run in response to events, auto-scale for\nyou, and only charge you when they run.</li>\n<li><a href=\"https://github.com/Miserlou/Zappa\" rel=\"nofollow\">Zappa</a> - Deploy python WSGI applications\non AWS Lambda and API Gateway.</li>\n<li><a href=\"https://github.com/claudiajs/claudia\" rel=\"nofollow\">claudia</a> - Deploy node.js projects\nto AWS Lambda and API Gateway.</li>\n<li><a href=\"https://github.com/kislyuk/domovoi\" rel=\"nofollow\">Domovoi</a> - An extension to Chalice that\nhandles a variety of AWS Lambda event sources such as SNS push notifications,\nS3 events, and Step Functions state machines.</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 5438085, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "2e1bda0cd62288dbe51196ee1305139f", "sha256": "a8607e322679d806ca29690d1c1abdf90fd5126ab408f712316de56331215748"}, "downloads": -1, "filename": "parfait-0.1.tar.gz", "has_sig": false, "md5_digest": "2e1bda0cd62288dbe51196ee1305139f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 199454, "upload_time": "2019-01-06T04:36:08", "upload_time_iso_8601": "2019-01-06T04:36:08.476729Z", "url": "https://files.pythonhosted.org/packages/02/ba/7392f0674fb012da9a52595d3b599f1f15c4e41795bdfe014eeba6dde211/parfait-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "5bac6776e14040b4e0874926ad762e59", "sha256": "5259fe0c0d909e80a5ccd304eb242e49b8d61a2d44756bcb2fd23f16c2a6296f"}, "downloads": -1, "filename": "parfait-0.2.tar.gz", "has_sig": false, "md5_digest": "5bac6776e14040b4e0874926ad762e59", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 200399, "upload_time": "2019-01-08T07:19:52", "upload_time_iso_8601": "2019-01-08T07:19:52.475314Z", "url": "https://files.pythonhosted.org/packages/1a/27/3703f27f7d64ca070b4d15ce092e2feb62adc24be9927d9ad70a55982213/parfait-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "afb29ad43fdebc396b675f7f7b544bd2", "sha256": "de6facf3fd0fbd46e6e785b7868f8f9ce6c26d6b691371d7d9192d0252be3d3c"}, "downloads": -1, "filename": "parfait-0.3.tar.gz", "has_sig": false, "md5_digest": "afb29ad43fdebc396b675f7f7b544bd2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 200012, "upload_time": "2019-04-09T12:14:56", "upload_time_iso_8601": "2019-04-09T12:14:56.912035Z", "url": "https://files.pythonhosted.org/packages/3d/39/1b4d5255d6b4efdd2f6713a43259afc3a62305d6c07dbea9b15ee9e5c997/parfait-0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "afb29ad43fdebc396b675f7f7b544bd2", "sha256": "de6facf3fd0fbd46e6e785b7868f8f9ce6c26d6b691371d7d9192d0252be3d3c"}, "downloads": -1, "filename": "parfait-0.3.tar.gz", "has_sig": false, "md5_digest": "afb29ad43fdebc396b675f7f7b544bd2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 200012, "upload_time": "2019-04-09T12:14:56", "upload_time_iso_8601": "2019-04-09T12:14:56.912035Z", "url": "https://files.pythonhosted.org/packages/3d/39/1b4d5255d6b4efdd2f6713a43259afc3a62305d6c07dbea9b15ee9e5c997/parfait-0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:58:27 2020"}