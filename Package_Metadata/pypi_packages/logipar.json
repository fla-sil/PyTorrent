{"info": {"author": "Brad Gill", "author_email": "brad@alteredeffect.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "[![npm](https://img.shields.io/npm/v/logipar)](https://npmjs.com/package/logipar) [![pypi](https://img.shields.io/pypi/v/logipar)](https://pypi.org/project/logipar/) [![haxelib install logipar](https://img.shields.io/badge/haxelib-logipar-orange, \"haxelib install logipar\")](https://lib.haxe.org/p/logipar/) [![php phar](https://img.shields.io/badge/php-Logipar.phar-orange, \"PHP Logipar.phar\")](https://github.com/altef/logipar/blob/master/php/Logipar.phar)\n\n<p align=\"center\">\n  <img src=\"https://altef.github.io/logipar/logo.png\" alt=\"Logipar\">\n</p>\n\n# Logipar\n/l\u0251\u02d0d\u0292\u026ap\u025c\u02d0r/\n\n*noun*: Your go-to polyglot **logic string parser**.\n\n*verb*: Parse that logic string, my friend.\n\n\n# What is a logic string parser?\n\nHave you ever wanted to filter data based on a string of ANDs and ORs and NOTs?  Well now you can!  \nIn fact, that's exactly what **Logipar** is here to help you do.\n\nIf that doesn't help, check out our [Cat breed](https://altef.github.io/logipar) demo to see **Logipar** in action!  Or you can try it yourself on [Runkit](https://npm.runkit.com/logipar).\n\n**Logipar** supports:\n* AND\n* OR\n* NOT\n* XOR\n* and Parenthises\n\nYou can rename the operatores however you want!  You can also use it with basically whatever *literals/values* you want\u00b9.  (1. There are *some* restrictions.)\n\nA simple example: `one AND (two OR three)`  \nA more complex example: `title=Cat XOR title contains dog`.  **Logipar** doesn't care about the literals you use, so you can add whatever complexity you is appropriate for your project there - I'm not judging!  In fact, _I endorse it_.\n\nLogipar will automatically merge adjacent literals, _unless you don't want it to_. So `title contains dog` can count as a single literal, even without quotation marks.  Or it can count as three `title`, `contains`, and `dog` - the choice is yours! (By default it merges.)\n\n# What can I do with it once it's parsed?\n\nOh, man, whatever you want really!  You can test objects against the parse tree (using a function **Logipar** returns - [see the filtering section](#filtering-data)).  You can flatten the parse tree to a string of your design (with the help of **Logipar**'s `stringify()` function - [see the stringing section](#stringification)).  \nI guess.. I guess that's really all.  But come on, what more do you even want??\n\n\n# Okay cool, can I use it though?\n**Logipar** is written in [Haxe](https://haxe.org).  **WAIT DON'T BE SCARED**.  All that means for you is it can be (and is) compiled to multiple languages.  Maybe you've heard of one of these before:\n* Javascript\n* Python\n* PHP\n\nThere are more, but I'm going to focus the examples on those for now.\n\n# Installation\n#### Javascript\n* `npm i logipar`\n* `yarn add logipar`\n* Or you can just download and use [Logipar.js](https://github.com/altef/logipar/blob/master/js/logipar/Logipar.js) - say in a `<script src=\"Logipar.js\"></scrip>` tag. \n\n#### Python\n* `pip install logipar`\n* Or you can just download and use [Logipar.py](https://github.com/altef/logipar/blob/master/python/logipar.py) in your project.\n\n#### PHP\nBad news. **Logipar** isn't on Composer.  I probably won't bother to add it there unless someone *really* wants it, because of [this issue](https://github.com/composer/packagist/issues/472).\nGood news! You can totally use this [Logipar.phar](https://github.com/altef/logipar/blob/master/php/Logipar.phar) instead.  Or, you know, donwload the files directly if you want.\n\n#### Haxe\n* `haxelib install logipar`\n* Also the source files are [here](https://github.com/altef/logipar/blob/master/src/logipar).\n\n# But how do I use it?\nGreat question!  Here are some examples in different languages. \n## Usage\n##### Javascript\nYou can follow along with these javascript samples on  on [Runkit](https://npm.runkit.com/logipar).\n```javascript\nconst logipar = require(\"logipar\")\nconst lp = new logipar.Logipar();\nlp.parse(\"a AND b\");\nconsole.log(lp.toString())\n````\nOr you can include [Logipar.js](https://github.com/altef/logipar/blob/master/js/Logipar.js) in your code.  Note that in this method the classes are accessed via `Logipar`, `Token`, and `Node` - rather than through a `logipar` constant, as above.\n```html\n<script src=\"Logipar.js\"></script>\n```\n```javascript\n    // Include the library however works for you.  You can see how I did it in js_sample.html\n    var lp = new Logipar();\n    lp.parse(\"a AND b\");\n    console.log(lp.stringify());\n```\n##### Python\n```python\n    import logipar\n    lp = logipar.Logipar()\n    lp.parse(\"a AND b\")\n    print(lp.toString())\n```\n##### Php\nWhen you're using the PHAR, it should take care of loading the classes for you.\n```php\n    require_once(\"Logipar.phar\");   \n    $lp = new \\logipar\\Logipar();\n    $lp->parse(\"a AND b\");\n    print($lp->toString());\n```\n\n## Quotations marks\nWhile **Logipar** can automatically merge neigbouring literals, sometimes that's not enough.  It also supports quotation marks around literals.  This means you can have values that would otherwise be parsed as tokens _in_ the literals - if they're wrapped in quotation marks.  The quotation marks become part of the value, for you to deal with however you want.  This is also handy for supplying whitespace as a value.\nTake the logic string `a=\"CAT OR DOG\" OR This is a sentance.`.\n`a=\"CAT OR DOG\"` is a literal.  Even though it has and an OR in it.  You can then use it however is appropriate - split it on the equals sign maybe, and strip the quotation marks to check for the string \"CAT OR DOG\" in the \"a\" column.  I don't know, that's your journey!\n\n`This is a sentance.` is also a literal since it'll be automatically merged by default.  **Logipar**'s `mergeAdjacentLiterals` (which defaults to `true`) controls this. So set it to false if you don't want to merge them.\n\nSo it'll parse out to: `a=\"CAT OR DOG\"` *OR* `This is a sentance.`.\n\nThe default quotation mark characters are `\"` and `'`.  But you can add to or change these through **Logipar**'s aptly-named `quotations` property - which is an array of strings denoting whatever you want to use as valid quotation mark characters.\n\n##### Javascript\n```javascript\nlp.quotations.push(\"`\"); // Add backtick \nlp.mergeAdjacentLiterals = true; // This is its default value\n```\n##### Python\n```python\nlp.quotations.append(\"`\"); // Add backtick \nlp.mergeAdjacentLiterals = true; // This is its default value\n```\n##### Php\n```php\n$lp->quotations[] = \"`\"; // Add backtick\n$lp->mergeAdjacentLiterals = true; // This is its default value\n```\n\n## Case sensitivity\nBy default the **Logipar**'s operators are case-sensitive, but they don't have to be.  Simply change the `caseSensitive` property to `false`, and YoU cAn TyPe ThEm HoWeVeR yOu Want!\n##### Javascript\n```javascript\nlp.caseSensitive = false;\n```\n##### Python\n```python\nlp.caseSensitive = False;\n```\n##### Php\n```php\n$lp->caseSensitive = false;\n```\n\n## Custom operators\nYou can also replace the default strings for any or all of **logipar**'s operators.  Maybe you want to go the old `^ v` route.  Or maybe `&&` and `||`.  Or even just `+` and `*`.  I don't know what you want!\nValid operators are:\n* `Token.AND` default: `AND`\n* `Token.OR` default: `OR`\n* `Token.XOR` default: `XOR`\n* `Token.NOT` default: `NOT`\n* `Token.OPEN` default: `(`\n* `Token.CLOSE` default: `)`\n\nYou should probably keep the `OPEN` and `CLOSE` (parentheses) operators as single characters, unless you want to enforce whitespace between all tokens tokens. \n\n##### Javascript\n```javascript\nlp.overwrite(logipar.Token.AND, \"&&\");\n```\n##### Python\n```python\nlp.overwrite(logipar.logipar_Token.AND, \"et\")\n```\n##### Php\nPHP is a little more problematic.  `AND`, `OR` and `XOR` are keywords in it, which makes it difficult to access those Token constants.  Rather than rename those variables, you can just use the string values. (You can do the same with the other ones, if you really want to - **all the string values are the same as the constant after `Token.`.**)\n```php\n$lp->overwrite(\"AND\", \"et\");\n```\n\n## Stringification\nSometimes you want your logic tree flattened; pressed firmly into a string.  Maybe you just want to display it, or maybe you'd like to use it in your SQL. I don't know - and I'm not judging.  **Logipar** should provide for all your stringifying needs with it's `stringify()` function.\nWhen you call `stringify`, you have the option of passing a function to it - this function is used to convert nodes to strings in any manner you like.  It will be called on each node in the tree.  Anything you don't account for will use the default `toString()` function provided by **Logipar**.\n\nThat's confusing right?  Well here, take a look at this function in Haxe:\n\n```haxe\nfunction mystringer(n:logipar.Node):String {\n\tif (n.token.type == logipar.Token.XOR) {\n\t\treturn \"((\" + n.f(n.left) + \" AND NOT \" + n.f(n.right) + \") OR (NOT \" + n.f(n.left) + \" AND \" + n.f(n.right) + \"))\";\n\t}\n\treturn null;\n}\n```\n\nThere are some things going on there.  Definite things.  Let's start with the signature:  Your function should take a `logipar.Node` as a param, and return a `String`.  \nSay whatever we're using doesn't support an `XOR` operation.  That's okay, `a XOR b` is just a fancy way of saying `(a AND NOT b) OR (NOT a AND b)`.  We can handle that.\nFirst, we need to know if this is the type of node we want to change (`XOR`), so we check if the node passed in (`n`) is currently of type `logipar.Token.XOR`.  Then we just return the string the way we want it.  In this case:\n`\treturn \"((\" + n.f(n.left) + \" AND NOT \" + n.f(n.right) + \") OR (NOT \" + n.f(n.left) + \" AND \" + n.f(n.right) + \"))\";`\n\nBut wait.  What's going on there?   Well `XOR` nodes (and all binary nodes) have `left` and `right` properties, representing their preceeding and succeeding operands. (Unary nodes like `NOT` only have a `right` property; or rather, `left` will be null.)  So we're just saying:\n`(({LEFT} AND NOT {RIGHT}) OR (NOT {LEFT} AND {RIGHT}))`\n\nWith one added wrinkle.  The `left` and `right` properties are nodes themselves.  They may contain `XOR`s of their own.  So we want to recursively call the same stringification function on them.  `f()` is a helper function available for the duration of the stringification process for this very purpose.  That's why you see `n.f(n.left)` above.\n\nThe `return null;` lets **Logipar** know it should display any other node as usual.  So in this case, anything that's not an `XOR` gets displayed as it normally would.\n\n##### Javascript\n```javascript\nvar str = lp.stringify(function(n) {\n\tif (n.token.type == logipar.Token.XOR) \n\t\treturn \"((\" + n.f(n.left) + \" AND NOT \" + n.f(n.right) + \") OR (NOT \" + n.f(n.left) + \" AND \" + n.f(n.right) + \"))\";\n\treturn null;\n});\n```\n##### Python\n```python\ndef expandXOR(n):\n\tif n.token.type == logipar.logipar_Token.XOR:\n\t\tl = n.f(n.left)\n\t\tr = n.f(n.right)\n\t\treturn \"(({} AND NOT {}) OR (NOT {} AND {}))\".format(l, r, l, r)\n\treturn None\n\nflattened = lp.stringify(expandXOR)\n```\n##### Php\nNote that again I'm just using the string \"XOR\" in PHP.  Also, I'm using [call_user_func](https://www.php.net/call_user_func) to call `$n->f()` on the child nodes.\n```php\n$flattened = $lp->stringify(function($n) {\n\tif ($n->token->type == \"XOR\") {\n\t\t$l = call_user_func($n->f, $n->left);\n\t\t$r = call_user_func($n->f, $n->right);\n\t\treturn \"((\" . $l . \" AND NOT \" . $r . \") OR (NOT \" . $l . \" AND \" . $r . \"))\";\n\t}\n\treturn null;\n});\n\n```\n\nThe string returned will make use if minimal parentheses.  If for some reason you want everything wrapped in brackets, that's easy too:\n\n```haxe\nlp.walk(function(n:logipar.Node):Void { n.bracketing = logipar.Node.MAXIMAL_BRACKETS; });\n```\nThat'll set the bracketing mode for each node in the tree to `MAXIMAL_BRACKETS`.  If you only want to change certain node types, you can check the value in `n.token.type` and act accordingly.\n\n## Filtering data\nSometimes you just want to filter an array of rows. Nothing more, nothing less.  Well, maybe more.  Maybe you want to do it based on _a logic string_. \n**Logipar**'s `filterFunction` can help.  It creates a function you can use to filter your data.  But how does it work?  You handle the leaves, and we'll handle the logic tree.\n\n> Basically, you just need to decide if a given leaf resolves `true` or `false` for a given row of data.  And then we'll figure out if it matches overall.\n\nHere's an example in Haxe:\n\n```haxe\nvar leafresolver = function(row:Dynamic, value:String):Bool {\n\t// This is  just checks a leaf node (value) against every column in the data (row), in a case-insensitive way.  \n\t// But you can get as complex as you'd like and parse the value variable however you like.\n\tfor (f in Reflect.fields(row)) { // For each property of row\n\t\tif (Std.string(Reflect.field(row, f)).toLowerCase().indexOf(value.toLowerCase()) != -1) // If that property contains the leaf \n\t\t\treturn true;\n\t}\n\treturn false;\n}\nvar myfilter:(Dynamic)->Bool = ls.filterFunction(leafresolver);\n```\nOkay, so you can see above that **Logipar**'s `filterFunction()` takes a function as its argument, and returns a function.  The first function (`leafresolver()`) we supply, the second we use to actually do our filtering.\n`leafresolver` takes a `row` of data.  This is probably an object of some sort, but that's your journey.  For the sake of our example, let's say it's `{title: \"Harry potter\", \"author\": \"J.K. Rowling\"}`.\nIt also takes a string `value`.  This is the value of the leaf we're checking.  For the sake of our example, `harry`.\n\nThe task of this function is to take `value` and see if it matches for `row`.  You can do this however you want.  This function is then run on every `LITERAL` (the leaves of the logic tree), and we use its result to decide if the logic tree resolves to `true` or `false` for `row`.\n\nFor this example, it'd check `Har` against each property in `row`: `title`, and `author`.  Since the title is `Harry Potter`, and we've specified in the function to convert to lowercase before checking, it'll match and return `true`.\n\n`filterFunction` returns a function, whcih you can then  use on your data. For example, `myfilter(data[i])` will return `true` or `false` depending on if it matches the logic of the query.\n\nThat's still pretty confusing, but hopefully some more examples will clear it up.\n\n\n\n\n##### Javascript\n```javascript\nfunction leafresolver(row, value) {\n\t// This is  just checks the values against every column, in a case-insensitive way\n\tfor(var field in row)\n\t\tif (row[field].toString().toLowerCase().includes(value.toLowerCase()))\n\t\t\treturn true;\n\treturn false;\n}\nf = lp.filterFunction(leafresolver);\nfiltered_data = sample_data.filter(f);    // Javascript arrays have a filter function\n```\n##### Python\n```python\ndef leafresolver(row, value):\n\t# This is  just checks the values against every column, in a case-insensitive way\n\tfor field in row:\n\t\tif value.lower() in str(row[field]).lower():\n\t\t\treturn True\n\treturn False\n\nf = lp.filterFunction(leafresolver)\ndata = list(filter(f, data)) # Python has a filter function too\n```\n##### Php\n```php\n$leafresolver = function($row, $value) {\n\tforeach($row as $field=>$v)\n\t\tif (stripos($row[$field], $value) !== false)\n\t\t\treturn true;\n\treturn false;\n};\n\n$f = $lp->filterFunction($leafresolver);\n$data = array_filter($data, $f);    // Oh look, so does PHP\n```\n\nNow, let's try a more complex example in Haxe:\n\n```Haxe\nvar f = ls.filterFunction(function(row:Dynamic, value:String):Bool {\n\tvalue = value.replace('\"', ''); // Strip out the quotation marks\n\tif (value.indexOf(\":\") == -1) { // If there's no colon, just check if the value exists in any field\n\t\tfor (f in Reflect.fields(row)) {\n\t\t\tif (Std.string(Reflect.field(row, f)).toLowerCase().indexOf(value.toLowerCase()) != -1)\n\t\t\t\treturn true;\n\t\t}\n\t} else {\n\t\t// There was a colon.  Let's split it into field:value.\n\t\tvar chunks = value.split(':');\n\t\tvar field = chunks.shift(); // The field is before the first colon\n\t\tvar val = chunks.join(':'); // Any subsequent colons should be part of the value we look for\n\t\tif (Reflect.hasField(row, field)) { // If that field exists, check if the value is in it\n\t\t\tif (Std.string(Reflect.field(row, field)).toLowerCase().indexOf(val.toLowerCase()) != -1)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n});\n```\n\nWhat this function does is it allows for values in the format `column:value` and then checks if `value` exists in that column.  For example, a logic string we might support could be:  `title:harry and not \"and\"`.  This filter function will resolve true for any entries where:\n1. the title column contains \"harry\" (case-insensitive)\n2. the string \"and\" is not in any of the columns (case-insensitive)\n\n**To see some more filtering examples, check out: [docs/filters.md](https://github.com/altef/logipar/blob/master/docs/filters.md).**\n\n## The end\nThat's all for now.  Happy parsing!\n\n\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/altef/logipar", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "logipar", "package_url": "https://pypi.org/project/logipar/", "platform": "", "project_url": "https://pypi.org/project/logipar/", "project_urls": {"Homepage": "https://github.com/altef/logipar"}, "release_url": "https://pypi.org/project/logipar/0.4.0/", "requires_dist": null, "requires_python": "", "summary": "A logic string parser", "version": "0.4.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://npmjs.com/package/logipar\" rel=\"nofollow\"><img alt=\"npm\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/47a7f6f965f4784e5f4c0d006766dd3a60bedff2/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f6c6f6769706172\"></a> <a href=\"https://pypi.org/project/logipar/\" rel=\"nofollow\"><img alt=\"pypi\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/66a5300edfea8b86b1cb96a69b47725fb64046bf/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6c6f6769706172\"></a> <a href=\"https://lib.haxe.org/p/logipar/\" rel=\"nofollow\"><img alt=\"haxelib install logipar\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d547c7931dcc17c956c329c83dc4ad20fd7b1cbf/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f686178656c69622d6c6f67697061722d6f72616e67652c\"></a> <a href=\"https://github.com/altef/logipar/blob/master/php/Logipar.phar\" rel=\"nofollow\"><img alt=\"php phar\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cab36ad4ff786044dc3eeb4236b0011f3c03088f/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f7068702d4c6f67697061722e706861722d6f72616e67652c\"></a></p>\n<p align=\"center\">\n  <img alt=\"Logipar\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/727ec8436089635114490a12fa46ddfedb8261f5/68747470733a2f2f616c7465662e6769746875622e696f2f6c6f67697061722f6c6f676f2e706e67\">\n</p>\n<h1>Logipar</h1>\n<p>/l\u0251\u02d0d\u0292\u026ap\u025c\u02d0r/</p>\n<p><em>noun</em>: Your go-to polyglot <strong>logic string parser</strong>.</p>\n<p><em>verb</em>: Parse that logic string, my friend.</p>\n<h1>What is a logic string parser?</h1>\n<p>Have you ever wanted to filter data based on a string of ANDs and ORs and NOTs?  Well now you can!<br>\nIn fact, that's exactly what <strong>Logipar</strong> is here to help you do.</p>\n<p>If that doesn't help, check out our <a href=\"https://altef.github.io/logipar\" rel=\"nofollow\">Cat breed</a> demo to see <strong>Logipar</strong> in action!  Or you can try it yourself on <a href=\"https://npm.runkit.com/logipar\" rel=\"nofollow\">Runkit</a>.</p>\n<p><strong>Logipar</strong> supports:</p>\n<ul>\n<li>AND</li>\n<li>OR</li>\n<li>NOT</li>\n<li>XOR</li>\n<li>and Parenthises</li>\n</ul>\n<p>You can rename the operatores however you want!  You can also use it with basically whatever <em>literals/values</em> you want\u00b9.  (1. There are <em>some</em> restrictions.)</p>\n<p>A simple example: <code>one AND (two OR three)</code><br>\nA more complex example: <code>title=Cat XOR title contains dog</code>.  <strong>Logipar</strong> doesn't care about the literals you use, so you can add whatever complexity you is appropriate for your project there - I'm not judging!  In fact, <em>I endorse it</em>.</p>\n<p>Logipar will automatically merge adjacent literals, <em>unless you don't want it to</em>. So <code>title contains dog</code> can count as a single literal, even without quotation marks.  Or it can count as three <code>title</code>, <code>contains</code>, and <code>dog</code> - the choice is yours! (By default it merges.)</p>\n<h1>What can I do with it once it's parsed?</h1>\n<p>Oh, man, whatever you want really!  You can test objects against the parse tree (using a function <strong>Logipar</strong> returns - <a href=\"#filtering-data\" rel=\"nofollow\">see the filtering section</a>).  You can flatten the parse tree to a string of your design (with the help of <strong>Logipar</strong>'s <code>stringify()</code> function - <a href=\"#stringification\" rel=\"nofollow\">see the stringing section</a>).<br>\nI guess.. I guess that's really all.  But come on, what more do you even want??</p>\n<h1>Okay cool, can I use it though?</h1>\n<p><strong>Logipar</strong> is written in <a href=\"https://haxe.org\" rel=\"nofollow\">Haxe</a>.  <strong>WAIT DON'T BE SCARED</strong>.  All that means for you is it can be (and is) compiled to multiple languages.  Maybe you've heard of one of these before:</p>\n<ul>\n<li>Javascript</li>\n<li>Python</li>\n<li>PHP</li>\n</ul>\n<p>There are more, but I'm going to focus the examples on those for now.</p>\n<h1>Installation</h1>\n<h4>Javascript</h4>\n<ul>\n<li><code>npm i logipar</code></li>\n<li><code>yarn add logipar</code></li>\n<li>Or you can just download and use <a href=\"https://github.com/altef/logipar/blob/master/js/logipar/Logipar.js\" rel=\"nofollow\">Logipar.js</a> - say in a <code>&lt;script src=\"Logipar.js\"&gt;&lt;/scrip&gt;</code> tag.</li>\n</ul>\n<h4>Python</h4>\n<ul>\n<li><code>pip install logipar</code></li>\n<li>Or you can just download and use <a href=\"https://github.com/altef/logipar/blob/master/python/logipar.py\" rel=\"nofollow\">Logipar.py</a> in your project.</li>\n</ul>\n<h4>PHP</h4>\n<p>Bad news. <strong>Logipar</strong> isn't on Composer.  I probably won't bother to add it there unless someone <em>really</em> wants it, because of <a href=\"https://github.com/composer/packagist/issues/472\" rel=\"nofollow\">this issue</a>.\nGood news! You can totally use this <a href=\"https://github.com/altef/logipar/blob/master/php/Logipar.phar\" rel=\"nofollow\">Logipar.phar</a> instead.  Or, you know, donwload the files directly if you want.</p>\n<h4>Haxe</h4>\n<ul>\n<li><code>haxelib install logipar</code></li>\n<li>Also the source files are <a href=\"https://github.com/altef/logipar/blob/master/src/logipar\" rel=\"nofollow\">here</a>.</li>\n</ul>\n<h1>But how do I use it?</h1>\n<p>Great question!  Here are some examples in different languages.</p>\n<h2>Usage</h2>\n<h5>Javascript</h5>\n<p>You can follow along with these javascript samples on  on <a href=\"https://npm.runkit.com/logipar\" rel=\"nofollow\">Runkit</a>.</p>\n<pre><span class=\"kr\">const</span> <span class=\"nx\">logipar</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s2\">\"logipar\"</span><span class=\"p\">)</span>\n<span class=\"kr\">const</span> <span class=\"nx\">lp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">logipar</span><span class=\"p\">.</span><span class=\"nx\">Logipar</span><span class=\"p\">();</span>\n<span class=\"nx\">lp</span><span class=\"p\">.</span><span class=\"nx\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"a AND b\"</span><span class=\"p\">);</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">lp</span><span class=\"p\">.</span><span class=\"nx\">toString</span><span class=\"p\">())</span>\n</pre>\n<p>Or you can include <a href=\"https://github.com/altef/logipar/blob/master/js/Logipar.js\" rel=\"nofollow\">Logipar.js</a> in your code.  Note that in this method the classes are accessed via <code>Logipar</code>, <code>Token</code>, and <code>Node</code> - rather than through a <code>logipar</code> constant, as above.</p>\n<pre><span class=\"p\">&lt;</span><span class=\"nt\">script</span> <span class=\"na\">src</span><span class=\"o\">=</span><span class=\"s\">\"Logipar.js\"</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span>\n</pre>\n<pre>    <span class=\"c1\">// Include the library however works for you.  You can see how I did it in js_sample.html</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">lp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Logipar</span><span class=\"p\">();</span>\n    <span class=\"nx\">lp</span><span class=\"p\">.</span><span class=\"nx\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"a AND b\"</span><span class=\"p\">);</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">lp</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">());</span>\n</pre>\n<h5>Python</h5>\n<pre>    <span class=\"kn\">import</span> <span class=\"nn\">logipar</span>\n    <span class=\"n\">lp</span> <span class=\"o\">=</span> <span class=\"n\">logipar</span><span class=\"o\">.</span><span class=\"n\">Logipar</span><span class=\"p\">()</span>\n    <span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">\"a AND b\"</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"n\">toString</span><span class=\"p\">())</span>\n</pre>\n<h5>Php</h5>\n<p>When you're using the PHAR, it should take care of loading the classes for you.</p>\n<pre><span class=\"x\">    require_once(\"Logipar.phar\");   </span>\n<span class=\"x\">    $lp = new \\logipar\\Logipar();</span>\n<span class=\"x\">    $lp-&gt;parse(\"a AND b\");</span>\n<span class=\"x\">    print($lp-&gt;toString());</span>\n</pre>\n<h2>Quotations marks</h2>\n<p>While <strong>Logipar</strong> can automatically merge neigbouring literals, sometimes that's not enough.  It also supports quotation marks around literals.  This means you can have values that would otherwise be parsed as tokens <em>in</em> the literals - if they're wrapped in quotation marks.  The quotation marks become part of the value, for you to deal with however you want.  This is also handy for supplying whitespace as a value.\nTake the logic string <code>a=\"CAT OR DOG\" OR This is a sentance.</code>.\n<code>a=\"CAT OR DOG\"</code> is a literal.  Even though it has and an OR in it.  You can then use it however is appropriate - split it on the equals sign maybe, and strip the quotation marks to check for the string \"CAT OR DOG\" in the \"a\" column.  I don't know, that's your journey!</p>\n<p><code>This is a sentance.</code> is also a literal since it'll be automatically merged by default.  <strong>Logipar</strong>'s <code>mergeAdjacentLiterals</code> (which defaults to <code>true</code>) controls this. So set it to false if you don't want to merge them.</p>\n<p>So it'll parse out to: <code>a=\"CAT OR DOG\"</code> <em>OR</em> <code>This is a sentance.</code>.</p>\n<p>The default quotation mark characters are <code>\"</code> and <code>'</code>.  But you can add to or change these through <strong>Logipar</strong>'s aptly-named <code>quotations</code> property - which is an array of strings denoting whatever you want to use as valid quotation mark characters.</p>\n<h5>Javascript</h5>\n<pre><span class=\"nx\">lp</span><span class=\"p\">.</span><span class=\"nx\">quotations</span><span class=\"p\">.</span><span class=\"nx\">push</span><span class=\"p\">(</span><span class=\"s2\">\"`\"</span><span class=\"p\">);</span> <span class=\"c1\">// Add backtick </span>\n<span class=\"nx\">lp</span><span class=\"p\">.</span><span class=\"nx\">mergeAdjacentLiterals</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"p\">;</span> <span class=\"c1\">// This is its default value</span>\n</pre>\n<h5>Python</h5>\n<pre><span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"n\">quotations</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"s2\">\"`\"</span><span class=\"p\">);</span> <span class=\"o\">//</span> <span class=\"n\">Add</span> <span class=\"n\">backtick</span> \n<span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"n\">mergeAdjacentLiterals</span> <span class=\"o\">=</span> <span class=\"n\">true</span><span class=\"p\">;</span> <span class=\"o\">//</span> <span class=\"n\">This</span> <span class=\"ow\">is</span> <span class=\"n\">its</span> <span class=\"n\">default</span> <span class=\"n\">value</span>\n</pre>\n<h5>Php</h5>\n<pre><span class=\"x\">$lp-&gt;quotations[] = \"`\"; // Add backtick</span>\n<span class=\"x\">$lp-&gt;mergeAdjacentLiterals = true; // This is its default value</span>\n</pre>\n<h2>Case sensitivity</h2>\n<p>By default the <strong>Logipar</strong>'s operators are case-sensitive, but they don't have to be.  Simply change the <code>caseSensitive</code> property to <code>false</code>, and YoU cAn TyPe ThEm HoWeVeR yOu Want!</p>\n<h5>Javascript</h5>\n<pre><span class=\"nx\">lp</span><span class=\"p\">.</span><span class=\"nx\">caseSensitive</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"p\">;</span>\n</pre>\n<h5>Python</h5>\n<pre><span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"n\">caseSensitive</span> <span class=\"o\">=</span> <span class=\"kc\">False</span><span class=\"p\">;</span>\n</pre>\n<h5>Php</h5>\n<pre><span class=\"x\">$lp-&gt;caseSensitive = false;</span>\n</pre>\n<h2>Custom operators</h2>\n<p>You can also replace the default strings for any or all of <strong>logipar</strong>'s operators.  Maybe you want to go the old <code>^ v</code> route.  Or maybe <code>&amp;&amp;</code> and <code>||</code>.  Or even just <code>+</code> and <code>*</code>.  I don't know what you want!\nValid operators are:</p>\n<ul>\n<li><code>Token.AND</code> default: <code>AND</code></li>\n<li><code>Token.OR</code> default: <code>OR</code></li>\n<li><code>Token.XOR</code> default: <code>XOR</code></li>\n<li><code>Token.NOT</code> default: <code>NOT</code></li>\n<li><code>Token.OPEN</code> default: <code>(</code></li>\n<li><code>Token.CLOSE</code> default: <code>)</code></li>\n</ul>\n<p>You should probably keep the <code>OPEN</code> and <code>CLOSE</code> (parentheses) operators as single characters, unless you want to enforce whitespace between all tokens tokens.</p>\n<h5>Javascript</h5>\n<pre><span class=\"nx\">lp</span><span class=\"p\">.</span><span class=\"nx\">overwrite</span><span class=\"p\">(</span><span class=\"nx\">logipar</span><span class=\"p\">.</span><span class=\"nx\">Token</span><span class=\"p\">.</span><span class=\"nx\">AND</span><span class=\"p\">,</span> <span class=\"s2\">\"&amp;&amp;\"</span><span class=\"p\">);</span>\n</pre>\n<h5>Python</h5>\n<pre><span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"n\">overwrite</span><span class=\"p\">(</span><span class=\"n\">logipar</span><span class=\"o\">.</span><span class=\"n\">logipar_Token</span><span class=\"o\">.</span><span class=\"n\">AND</span><span class=\"p\">,</span> <span class=\"s2\">\"et\"</span><span class=\"p\">)</span>\n</pre>\n<h5>Php</h5>\n<p>PHP is a little more problematic.  <code>AND</code>, <code>OR</code> and <code>XOR</code> are keywords in it, which makes it difficult to access those Token constants.  Rather than rename those variables, you can just use the string values. (You can do the same with the other ones, if you really want to - <strong>all the string values are the same as the constant after <code>Token.</code>.</strong>)</p>\n<pre><span class=\"x\">$lp-&gt;overwrite(\"AND\", \"et\");</span>\n</pre>\n<h2>Stringification</h2>\n<p>Sometimes you want your logic tree flattened; pressed firmly into a string.  Maybe you just want to display it, or maybe you'd like to use it in your SQL. I don't know - and I'm not judging.  <strong>Logipar</strong> should provide for all your stringifying needs with it's <code>stringify()</code> function.\nWhen you call <code>stringify</code>, you have the option of passing a function to it - this function is used to convert nodes to strings in any manner you like.  It will be called on each node in the tree.  Anything you don't account for will use the default <code>toString()</code> function provided by <strong>Logipar</strong>.</p>\n<p>That's confusing right?  Well here, take a look at this function in Haxe:</p>\n<pre><span class=\"kd\">function</span> <span class=\"nf\">mystringer</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">:</span><span class=\"n\">logipar</span><span class=\"p\">.</span><span class=\"n\">Node</span><span class=\"p\">):</span><span class=\"n\">String</span> <span class=\"p\">{</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">.</span><span class=\"n\">token</span><span class=\"p\">.</span><span class=\"n\">type</span> <span class=\"o\">==</span> <span class=\"n\">logipar</span><span class=\"p\">.</span><span class=\"n\">Token</span><span class=\"p\">.</span><span class=\"n\">XOR</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"s2\">\"((\"</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"p\">.</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">.</span><span class=\"n\">left</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s2\">\" AND NOT \"</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"p\">.</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">.</span><span class=\"n\">right</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s2\">\") OR (NOT \"</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"p\">.</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">.</span><span class=\"n\">left</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s2\">\" AND \"</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"p\">.</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">.</span><span class=\"n\">right</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s2\">\"))\"</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</pre>\n<p>There are some things going on there.  Definite things.  Let's start with the signature:  Your function should take a <code>logipar.Node</code> as a param, and return a <code>String</code>.<br>\nSay whatever we're using doesn't support an <code>XOR</code> operation.  That's okay, <code>a XOR b</code> is just a fancy way of saying <code>(a AND NOT b) OR (NOT a AND b)</code>.  We can handle that.\nFirst, we need to know if this is the type of node we want to change (<code>XOR</code>), so we check if the node passed in (<code>n</code>) is currently of type <code>logipar.Token.XOR</code>.  Then we just return the string the way we want it.  In this case:\n<code>return \"((\" + n.f(n.left) + \" AND NOT \" + n.f(n.right) + \") OR (NOT \" + n.f(n.left) + \" AND \" + n.f(n.right) + \"))\";</code></p>\n<p>But wait.  What's going on there?   Well <code>XOR</code> nodes (and all binary nodes) have <code>left</code> and <code>right</code> properties, representing their preceeding and succeeding operands. (Unary nodes like <code>NOT</code> only have a <code>right</code> property; or rather, <code>left</code> will be null.)  So we're just saying:\n<code>(({LEFT} AND NOT {RIGHT}) OR (NOT {LEFT} AND {RIGHT}))</code></p>\n<p>With one added wrinkle.  The <code>left</code> and <code>right</code> properties are nodes themselves.  They may contain <code>XOR</code>s of their own.  So we want to recursively call the same stringification function on them.  <code>f()</code> is a helper function available for the duration of the stringification process for this very purpose.  That's why you see <code>n.f(n.left)</code> above.</p>\n<p>The <code>return null;</code> lets <strong>Logipar</strong> know it should display any other node as usual.  So in this case, anything that's not an <code>XOR</code> gets displayed as it normally would.</p>\n<h5>Javascript</h5>\n<pre><span class=\"kd\">var</span> <span class=\"nx\">str</span> <span class=\"o\">=</span> <span class=\"nx\">lp</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">.</span><span class=\"nx\">token</span><span class=\"p\">.</span><span class=\"nx\">type</span> <span class=\"o\">==</span> <span class=\"nx\">logipar</span><span class=\"p\">.</span><span class=\"nx\">Token</span><span class=\"p\">.</span><span class=\"nx\">XOR</span><span class=\"p\">)</span> \n\t\t<span class=\"k\">return</span> <span class=\"s2\">\"((\"</span> <span class=\"o\">+</span> <span class=\"nx\">n</span><span class=\"p\">.</span><span class=\"nx\">f</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">.</span><span class=\"nx\">left</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s2\">\" AND NOT \"</span> <span class=\"o\">+</span> <span class=\"nx\">n</span><span class=\"p\">.</span><span class=\"nx\">f</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">.</span><span class=\"nx\">right</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s2\">\") OR (NOT \"</span> <span class=\"o\">+</span> <span class=\"nx\">n</span><span class=\"p\">.</span><span class=\"nx\">f</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">.</span><span class=\"nx\">left</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s2\">\" AND \"</span> <span class=\"o\">+</span> <span class=\"nx\">n</span><span class=\"p\">.</span><span class=\"nx\">f</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">.</span><span class=\"nx\">right</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s2\">\"))\"</span><span class=\"p\">;</span>\n\t<span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"p\">;</span>\n<span class=\"p\">});</span>\n</pre>\n<h5>Python</h5>\n<pre><span class=\"k\">def</span> <span class=\"nf\">expandXOR</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n\t<span class=\"k\">if</span> <span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">token</span><span class=\"o\">.</span><span class=\"n\">type</span> <span class=\"o\">==</span> <span class=\"n\">logipar</span><span class=\"o\">.</span><span class=\"n\">logipar_Token</span><span class=\"o\">.</span><span class=\"n\">XOR</span><span class=\"p\">:</span>\n\t\t<span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">left</span><span class=\"p\">)</span>\n\t\t<span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">.</span><span class=\"n\">right</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">return</span> <span class=\"s2\">\"((</span><span class=\"si\">{}</span><span class=\"s2\"> AND NOT </span><span class=\"si\">{}</span><span class=\"s2\">) OR (NOT </span><span class=\"si\">{}</span><span class=\"s2\"> AND </span><span class=\"si\">{}</span><span class=\"s2\">))\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n\t<span class=\"k\">return</span> <span class=\"kc\">None</span>\n\n<span class=\"n\">flattened</span> <span class=\"o\">=</span> <span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"n\">stringify</span><span class=\"p\">(</span><span class=\"n\">expandXOR</span><span class=\"p\">)</span>\n</pre>\n<h5>Php</h5>\n<p>Note that again I'm just using the string \"XOR\" in PHP.  Also, I'm using <a href=\"https://www.php.net/call_user_func\" rel=\"nofollow\">call_user_func</a> to call <code>$n-&gt;f()</code> on the child nodes.</p>\n<pre><span class=\"x\">$flattened = $lp-&gt;stringify(function($n) {</span>\n<span class=\"x\">\tif ($n-&gt;token-&gt;type == \"XOR\") {</span>\n<span class=\"x\">\t\t$l = call_user_func($n-&gt;f, $n-&gt;left);</span>\n<span class=\"x\">\t\t$r = call_user_func($n-&gt;f, $n-&gt;right);</span>\n<span class=\"x\">\t\treturn \"((\" . $l . \" AND NOT \" . $r . \") OR (NOT \" . $l . \" AND \" . $r . \"))\";</span>\n<span class=\"x\">\t}</span>\n<span class=\"x\">\treturn null;</span>\n<span class=\"x\">});</span>\n</pre>\n<p>The string returned will make use if minimal parentheses.  If for some reason you want everything wrapped in brackets, that's easy too:</p>\n<pre><span class=\"n\">lp</span><span class=\"p\">.</span><span class=\"n\">walk</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">:</span><span class=\"n\">logipar</span><span class=\"p\">.</span><span class=\"n\">Node</span><span class=\"p\">):</span><span class=\"n\">Void</span> <span class=\"p\">{</span> <span class=\"n\">n</span><span class=\"p\">.</span><span class=\"n\">bracketing</span> <span class=\"o\">=</span> <span class=\"n\">logipar</span><span class=\"p\">.</span><span class=\"n\">Node</span><span class=\"p\">.</span><span class=\"n\">MAXIMAL_BRACKETS</span><span class=\"p\">;</span> <span class=\"p\">});</span>\n</pre>\n<p>That'll set the bracketing mode for each node in the tree to <code>MAXIMAL_BRACKETS</code>.  If you only want to change certain node types, you can check the value in <code>n.token.type</code> and act accordingly.</p>\n<h2>Filtering data</h2>\n<p>Sometimes you just want to filter an array of rows. Nothing more, nothing less.  Well, maybe more.  Maybe you want to do it based on <em>a logic string</em>.\n<strong>Logipar</strong>'s <code>filterFunction</code> can help.  It creates a function you can use to filter your data.  But how does it work?  You handle the leaves, and we'll handle the logic tree.</p>\n<blockquote>\n<p>Basically, you just need to decide if a given leaf resolves <code>true</code> or <code>false</code> for a given row of data.  And then we'll figure out if it matches overall.</p>\n</blockquote>\n<p>Here's an example in Haxe:</p>\n<pre><span class=\"kd\">var</span> leafresolver <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">:</span><span class=\"n\">Dynamic</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">:</span><span class=\"n\">String</span><span class=\"p\">):</span><span class=\"n\">Bool</span> <span class=\"p\">{</span>\n\t<span class=\"c1\">// This is  just checks a leaf node (value) against every column in the data (row), in a case-insensitive way.  </span>\n\t<span class=\"c1\">// But you can get as complex as you'd like and parse the value variable however you like.</span>\n\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"k\">in</span> <span class=\"n\">Reflect</span><span class=\"p\">.</span><span class=\"n\">fields</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">))</span> <span class=\"p\">{</span> <span class=\"c1\">// For each property of row</span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">Std</span><span class=\"p\">.</span><span class=\"n\">string</span><span class=\"p\">(</span><span class=\"n\">Reflect</span><span class=\"p\">.</span><span class=\"n\">field</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">)).</span><span class=\"n\">toLowerCase</span><span class=\"p\">().</span><span class=\"n\">indexOf</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">toLowerCase</span><span class=\"p\">())</span> <span class=\"o\">!=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\">// If that property contains the leaf </span>\n\t\t\t<span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">var</span> myfilter<span class=\"p\">:(</span><span class=\"n\">Dynamic</span><span class=\"p\">)-&gt;</span><span class=\"n\">Bool</span> <span class=\"o\">=</span> <span class=\"n\">ls</span><span class=\"p\">.</span><span class=\"n\">filterFunction</span><span class=\"p\">(</span><span class=\"n\">leafresolver</span><span class=\"p\">);</span>\n</pre>\n<p>Okay, so you can see above that <strong>Logipar</strong>'s <code>filterFunction()</code> takes a function as its argument, and returns a function.  The first function (<code>leafresolver()</code>) we supply, the second we use to actually do our filtering.\n<code>leafresolver</code> takes a <code>row</code> of data.  This is probably an object of some sort, but that's your journey.  For the sake of our example, let's say it's <code>{title: \"Harry potter\", \"author\": \"J.K. Rowling\"}</code>.\nIt also takes a string <code>value</code>.  This is the value of the leaf we're checking.  For the sake of our example, <code>harry</code>.</p>\n<p>The task of this function is to take <code>value</code> and see if it matches for <code>row</code>.  You can do this however you want.  This function is then run on every <code>LITERAL</code> (the leaves of the logic tree), and we use its result to decide if the logic tree resolves to <code>true</code> or <code>false</code> for <code>row</code>.</p>\n<p>For this example, it'd check <code>Har</code> against each property in <code>row</code>: <code>title</code>, and <code>author</code>.  Since the title is <code>Harry Potter</code>, and we've specified in the function to convert to lowercase before checking, it'll match and return <code>true</code>.</p>\n<p><code>filterFunction</code> returns a function, whcih you can then  use on your data. For example, <code>myfilter(data[i])</code> will return <code>true</code> or <code>false</code> depending on if it matches the logic of the query.</p>\n<p>That's still pretty confusing, but hopefully some more examples will clear it up.</p>\n<h5>Javascript</h5>\n<pre><span class=\"kd\">function</span> <span class=\"nx\">leafresolver</span><span class=\"p\">(</span><span class=\"nx\">row</span><span class=\"p\">,</span> <span class=\"nx\">value</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"c1\">// This is  just checks the values against every column, in a case-insensitive way</span>\n\t<span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">var</span> <span class=\"nx\">field</span> <span class=\"k\">in</span> <span class=\"nx\">row</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">row</span><span class=\"p\">[</span><span class=\"nx\">field</span><span class=\"p\">].</span><span class=\"nx\">toString</span><span class=\"p\">().</span><span class=\"nx\">toLowerCase</span><span class=\"p\">().</span><span class=\"nx\">includes</span><span class=\"p\">(</span><span class=\"nx\">value</span><span class=\"p\">.</span><span class=\"nx\">toLowerCase</span><span class=\"p\">()))</span>\n\t\t\t<span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"p\">;</span>\n\t<span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">f</span> <span class=\"o\">=</span> <span class=\"nx\">lp</span><span class=\"p\">.</span><span class=\"nx\">filterFunction</span><span class=\"p\">(</span><span class=\"nx\">leafresolver</span><span class=\"p\">);</span>\n<span class=\"nx\">filtered_data</span> <span class=\"o\">=</span> <span class=\"nx\">sample_data</span><span class=\"p\">.</span><span class=\"nx\">filter</span><span class=\"p\">(</span><span class=\"nx\">f</span><span class=\"p\">);</span>    <span class=\"c1\">// Javascript arrays have a filter function</span>\n</pre>\n<h5>Python</h5>\n<pre><span class=\"k\">def</span> <span class=\"nf\">leafresolver</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">):</span>\n\t<span class=\"c1\"># This is  just checks the values against every column, in a case-insensitive way</span>\n\t<span class=\"k\">for</span> <span class=\"n\">field</span> <span class=\"ow\">in</span> <span class=\"n\">row</span><span class=\"p\">:</span>\n\t\t<span class=\"k\">if</span> <span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">lower</span><span class=\"p\">()</span> <span class=\"ow\">in</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">[</span><span class=\"n\">field</span><span class=\"p\">])</span><span class=\"o\">.</span><span class=\"n\">lower</span><span class=\"p\">():</span>\n\t\t\t<span class=\"k\">return</span> <span class=\"kc\">True</span>\n\t<span class=\"k\">return</span> <span class=\"kc\">False</span>\n\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">lp</span><span class=\"o\">.</span><span class=\"n\">filterFunction</span><span class=\"p\">(</span><span class=\"n\">leafresolver</span><span class=\"p\">)</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"nb\">filter</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">))</span> <span class=\"c1\"># Python has a filter function too</span>\n</pre>\n<h5>Php</h5>\n<pre><span class=\"x\">$leafresolver = function($row, $value) {</span>\n<span class=\"x\">\tforeach($row as $field=&gt;$v)</span>\n<span class=\"x\">\t\tif (stripos($row[$field], $value) !== false)</span>\n<span class=\"x\">\t\t\treturn true;</span>\n<span class=\"x\">\treturn false;</span>\n<span class=\"x\">};</span>\n\n<span class=\"x\">$f = $lp-&gt;filterFunction($leafresolver);</span>\n<span class=\"x\">$data = array_filter($data, $f);    // Oh look, so does PHP</span>\n</pre>\n<p>Now, let's try a more complex example in Haxe:</p>\n<pre><span class=\"kd\">var</span> f <span class=\"o\">=</span> <span class=\"n\">ls</span><span class=\"p\">.</span><span class=\"n\">filterFunction</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">:</span><span class=\"n\">Dynamic</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">:</span><span class=\"n\">String</span><span class=\"p\">):</span><span class=\"n\">Bool</span> <span class=\"p\">{</span>\n\t<span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"s1\">'\"'</span><span class=\"p\">,</span> <span class=\"s1\">''</span><span class=\"p\">);</span> <span class=\"c1\">// Strip out the quotation marks</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">indexOf</span><span class=\"p\">(</span><span class=\"s2\">\":\"</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// If there's no colon, just check if the value exists in any field</span>\n\t\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">f</span> <span class=\"k\">in</span> <span class=\"n\">Reflect</span><span class=\"p\">.</span><span class=\"n\">fields</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">Std</span><span class=\"p\">.</span><span class=\"n\">string</span><span class=\"p\">(</span><span class=\"n\">Reflect</span><span class=\"p\">.</span><span class=\"n\">field</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">)).</span><span class=\"n\">toLowerCase</span><span class=\"p\">().</span><span class=\"n\">indexOf</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">toLowerCase</span><span class=\"p\">())</span> <span class=\"o\">!=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\t\t\t\t<span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"p\">;</span>\n\t\t<span class=\"p\">}</span>\n\t<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n\t\t<span class=\"c1\">// There was a colon.  Let's split it into field:value.</span>\n\t\t<span class=\"kd\">var</span> chunks <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"p\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s1\">':'</span><span class=\"p\">);</span>\n\t\t<span class=\"kd\">var</span> field <span class=\"o\">=</span> <span class=\"n\">chunks</span><span class=\"p\">.</span><span class=\"n\">shift</span><span class=\"p\">();</span> <span class=\"c1\">// The field is before the first colon</span>\n\t\t<span class=\"kd\">var</span> val <span class=\"o\">=</span> <span class=\"n\">chunks</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"s1\">':'</span><span class=\"p\">);</span> <span class=\"c1\">// Any subsequent colons should be part of the value we look for</span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">Reflect</span><span class=\"p\">.</span><span class=\"n\">hasField</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">,</span> <span class=\"n\">field</span><span class=\"p\">))</span> <span class=\"p\">{</span> <span class=\"c1\">// If that field exists, check if the value is in it</span>\n\t\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">Std</span><span class=\"p\">.</span><span class=\"n\">string</span><span class=\"p\">(</span><span class=\"n\">Reflect</span><span class=\"p\">.</span><span class=\"n\">field</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">,</span> <span class=\"n\">field</span><span class=\"p\">)).</span><span class=\"n\">toLowerCase</span><span class=\"p\">().</span><span class=\"n\">indexOf</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">.</span><span class=\"n\">toLowerCase</span><span class=\"p\">())</span> <span class=\"o\">!=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\t\t\t\t<span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"p\">;</span>\n\t\t<span class=\"p\">}</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"p\">;</span>\n<span class=\"p\">});</span>\n</pre>\n<p>What this function does is it allows for values in the format <code>column:value</code> and then checks if <code>value</code> exists in that column.  For example, a logic string we might support could be:  <code>title:harry and not \"and\"</code>.  This filter function will resolve true for any entries where:</p>\n<ol>\n<li>the title column contains \"harry\" (case-insensitive)</li>\n<li>the string \"and\" is not in any of the columns (case-insensitive)</li>\n</ol>\n<p><strong>To see some more filtering examples, check out: <a href=\"https://github.com/altef/logipar/blob/master/docs/filters.md\" rel=\"nofollow\">docs/filters.md</a>.</strong></p>\n<h2>The end</h2>\n<p>That's all for now.  Happy parsing!</p>\n\n          </div>"}, "last_serial": 5765537, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "d1485feb1984076358c0f5dae08b1282", "sha256": "d3c3aa18d816ac1ddda047eb52877056292e9ebb394db8c838f0ac41ad18789d"}, "downloads": -1, "filename": "logipar-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "d1485feb1984076358c0f5dae08b1282", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 13133, "upload_time": "2019-08-22T16:49:43", "upload_time_iso_8601": "2019-08-22T16:49:43.378440Z", "url": "https://files.pythonhosted.org/packages/bb/15/7b1d2a68f32e001f0c394da74a4feb9bfa7af9159990e80a0446a9b1d338/logipar-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e085e7b010bc4b0668adf7dd8c9d179c", "sha256": "b8e5f6e6035ee2bc725b5c883777dc70668d38bf5f991af94b8c4238d7e8c41b"}, "downloads": -1, "filename": "logipar-0.1.0.tar.gz", "has_sig": false, "md5_digest": "e085e7b010bc4b0668adf7dd8c9d179c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12114, "upload_time": "2019-08-22T16:49:47", "upload_time_iso_8601": "2019-08-22T16:49:47.730562Z", "url": "https://files.pythonhosted.org/packages/29/7b/5dadec4c22747303f43dc546c018cea5fa73c1036efadf97b5f5fe9feb60/logipar-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "8217f6cdc20433b2a130b251800b9b89", "sha256": "9e378ca712ba8caf9e10da8b123172ce6106a240aaa9895fa69b517dce6cb0ee"}, "downloads": -1, "filename": "logipar-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "8217f6cdc20433b2a130b251800b9b89", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 13098, "upload_time": "2019-08-22T16:49:45", "upload_time_iso_8601": "2019-08-22T16:49:45.880286Z", "url": "https://files.pythonhosted.org/packages/6d/ab/cffbcce591daf909d7b4570bb3e270656f61c9d43175a73be55c2222a4f6/logipar-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "32fad597dd3867971cdcc1eff61efe52", "sha256": "1e2f2d6729bad99df4daac30546304ff8316d2562c777a22b614e19c107c31e6"}, "downloads": -1, "filename": "logipar-0.2.0.tar.gz", "has_sig": false, "md5_digest": "32fad597dd3867971cdcc1eff61efe52", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12092, "upload_time": "2019-08-22T16:49:49", "upload_time_iso_8601": "2019-08-22T16:49:49.548686Z", "url": "https://files.pythonhosted.org/packages/44/f0/daab95c14f04a4970ef1b0c74ac252d36ba9dea26100b121e9ee373c76a8/logipar-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "49d4d33df79a08d030f288491b3586fa", "sha256": "2d48bc1ba21198d27928b47ff80328f43477b5289906a21e3e20c94e18014915"}, "downloads": -1, "filename": "logipar-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "49d4d33df79a08d030f288491b3586fa", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 13135, "upload_time": "2019-08-22T16:54:58", "upload_time_iso_8601": "2019-08-22T16:54:58.521562Z", "url": "https://files.pythonhosted.org/packages/cc/f1/d216d6e77a820c9e01ce94bc0a2d4dcbd4a49a3d993abce93b643890b7b9/logipar-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e2b7601293a8d37429d9d2de114e62a4", "sha256": "6246f73a0b8f05cae55461155744fcc199e4c0de43dea46fae6a3ac071ee2766"}, "downloads": -1, "filename": "logipar-0.2.1.tar.gz", "has_sig": false, "md5_digest": "e2b7601293a8d37429d9d2de114e62a4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12108, "upload_time": "2019-08-22T16:55:00", "upload_time_iso_8601": "2019-08-22T16:55:00.149184Z", "url": "https://files.pythonhosted.org/packages/c6/67/6fff158148429289c5b5708bc9d3778691f5495442fddbb49c324d8283f3/logipar-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "8374e488fc67f1b6b7d58995d2c30ce0", "sha256": "63240dab3441e7cbecf62bb521386018bed49c9ca574760149d6f8a411021778"}, "downloads": -1, "filename": "logipar-0.2.2-py3-none-any.whl", "has_sig": false, "md5_digest": "8374e488fc67f1b6b7d58995d2c30ce0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 13144, "upload_time": "2019-08-22T17:06:19", "upload_time_iso_8601": "2019-08-22T17:06:19.967556Z", "url": "https://files.pythonhosted.org/packages/e2/9f/d8df6b749b8b62e6cdfc017f02b844502b2d5ce863147b5fe92c8ad58dd9/logipar-0.2.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dbd137da82c64ff840abc83ea606b9f4", "sha256": "fe4609c67636aac1e21ebd9c09cdee042c34e9afcda02d9b49ec8a66de69a4fb"}, "downloads": -1, "filename": "logipar-0.2.2.tar.gz", "has_sig": false, "md5_digest": "dbd137da82c64ff840abc83ea606b9f4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12115, "upload_time": "2019-08-22T17:06:21", "upload_time_iso_8601": "2019-08-22T17:06:21.315093Z", "url": "https://files.pythonhosted.org/packages/eb/67/93bfb56431e9fdc52bd3762d6e6c5cd0e92a3a0a373efb401414c619dc1c/logipar-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "65734e1042398e0e2ed223553c601c4a", "sha256": "702a110a86aac9790b20a57c6b85f1cd356ac91cc11c41127afa4345e3926e39"}, "downloads": -1, "filename": "logipar-0.2.3-py3-none-any.whl", "has_sig": false, "md5_digest": "65734e1042398e0e2ed223553c601c4a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 13797, "upload_time": "2019-08-23T19:09:34", "upload_time_iso_8601": "2019-08-23T19:09:34.638802Z", "url": "https://files.pythonhosted.org/packages/ee/72/f35ba1e17fb393412b0106ad7809ebb4f79a99d4dbcac567f46cae736e4a/logipar-0.2.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a74da4d1680a34ed2100a5fdb3b43f56", "sha256": "a5a3d048ce6e40db173ce6a11f4089c16b31cfae308985da4b5ac9e5a106baad"}, "downloads": -1, "filename": "logipar-0.2.3.tar.gz", "has_sig": false, "md5_digest": "a74da4d1680a34ed2100a5fdb3b43f56", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12802, "upload_time": "2019-08-23T19:09:37", "upload_time_iso_8601": "2019-08-23T19:09:37.619854Z", "url": "https://files.pythonhosted.org/packages/9e/2d/3a73acd682098aff22ccc33c18e66fda296dfd563eb538e761b7c21ed0b8/logipar-0.2.3.tar.gz", "yanked": false}], "0.2.4": [{"comment_text": "", "digests": {"md5": "458e2e22875ae7146d40b4670b3c6b63", "sha256": "2f4aa79994a8e4cb402d307f8fe079386430d389419276ce146ae1dd078db515"}, "downloads": -1, "filename": "logipar-0.2.4-py3-none-any.whl", "has_sig": false, "md5_digest": "458e2e22875ae7146d40b4670b3c6b63", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 13800, "upload_time": "2019-08-23T19:20:40", "upload_time_iso_8601": "2019-08-23T19:20:40.896647Z", "url": "https://files.pythonhosted.org/packages/2a/b2/9f71bd38709147d5c467e5f0c4cd7022a4992f452b3cba8e4626e72c3c1e/logipar-0.2.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f2a781e907c6b6bcbf1032d39de0c936", "sha256": "c16707f19e6240e08336818b5043507f1e6037ab725317d4e1a67d4a2578d28f"}, "downloads": -1, "filename": "logipar-0.2.4.tar.gz", "has_sig": false, "md5_digest": "f2a781e907c6b6bcbf1032d39de0c936", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12805, "upload_time": "2019-08-23T19:20:44", "upload_time_iso_8601": "2019-08-23T19:20:44.471544Z", "url": "https://files.pythonhosted.org/packages/c5/6b/98288a235ba029cec7a189a792e6dc39c197c56e0d869506fb3b123c6994/logipar-0.2.4.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "9d4b3e85c50c90a25f1e905e1399c049", "sha256": "620b86014063769ea8b7de75d8a6b14e9ca6b67b4bfbf511ba9f737a4f6ad095"}, "downloads": -1, "filename": "logipar-0.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "9d4b3e85c50c90a25f1e905e1399c049", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14452, "upload_time": "2019-08-27T03:15:38", "upload_time_iso_8601": "2019-08-27T03:15:38.447675Z", "url": "https://files.pythonhosted.org/packages/6b/15/47941d0d3a5a4f2cb1496c97268acffec65d12faee05d67bff2939136b16/logipar-0.3.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8ef6b94e74985f6a6dd601039af8b994", "sha256": "08c02af90244e92cd400dea69c449b6efdfc54660b13e91e761210e161aa991c"}, "downloads": -1, "filename": "logipar-0.3.0.tar.gz", "has_sig": false, "md5_digest": "8ef6b94e74985f6a6dd601039af8b994", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13545, "upload_time": "2019-08-27T03:15:44", "upload_time_iso_8601": "2019-08-27T03:15:44.650156Z", "url": "https://files.pythonhosted.org/packages/ff/c0/8ebac24db8ab63fb1c2d39a4a16ab3cda8cfc33169b17d6da89ecdbdcd94/logipar-0.3.0.tar.gz", "yanked": false}], "0.3.1": [{"comment_text": "", "digests": {"md5": "ae732c7a999a4152beb0110b7ce0feab", "sha256": "57d8974cd782a20237e76a02b8b112004236e1b33c6847396e9920f57caf2897"}, "downloads": -1, "filename": "logipar-0.3.1-py3-none-any.whl", "has_sig": false, "md5_digest": "ae732c7a999a4152beb0110b7ce0feab", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14267, "upload_time": "2019-08-30T15:25:40", "upload_time_iso_8601": "2019-08-30T15:25:40.949724Z", "url": "https://files.pythonhosted.org/packages/31/12/aade909a1e99cdce073cdf0e656369bdcdc8497d2281e17440f5e3b0f26f/logipar-0.3.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "806a1a74eb6036a9606ac5baa0aaf41e", "sha256": "3c4f158742b5522ac04f0e81406ffeeb7b93a416f5c5d3e31934a733a3f96009"}, "downloads": -1, "filename": "logipar-0.3.1.tar.gz", "has_sig": false, "md5_digest": "806a1a74eb6036a9606ac5baa0aaf41e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13323, "upload_time": "2019-08-30T15:25:45", "upload_time_iso_8601": "2019-08-30T15:25:45.019607Z", "url": "https://files.pythonhosted.org/packages/a0/cb/c8a69bc21aac08b65ff0c8d443ff50590041f86a7d8fe51c9893115ae301/logipar-0.3.1.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "b0243c2747c4efe13417f484046a1db0", "sha256": "da72ab6b920dc9625ce643e2c73e4b217172fec488f96c68db547ca7613eda8b"}, "downloads": -1, "filename": "logipar-0.4.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b0243c2747c4efe13417f484046a1db0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14829, "upload_time": "2019-08-31T23:22:16", "upload_time_iso_8601": "2019-08-31T23:22:16.063915Z", "url": "https://files.pythonhosted.org/packages/83/da/3444f8b2f61033b7c3f11068b0168b9567ea2f763fc26afc7a79b26a7f98/logipar-0.4.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "48e31270cb3c70abb8adcb906eac3c7f", "sha256": "8d432874e27085ac9e4ba6e031e9ea8148af70b53d291c12fcce68ea6de898cc"}, "downloads": -1, "filename": "logipar-0.4.0.tar.gz", "has_sig": false, "md5_digest": "48e31270cb3c70abb8adcb906eac3c7f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13891, "upload_time": "2019-08-31T23:22:22", "upload_time_iso_8601": "2019-08-31T23:22:22.243421Z", "url": "https://files.pythonhosted.org/packages/33/f6/f441c5a2564187c76dd2a240b02284438a72666f4823ac08c3332c4d2c27/logipar-0.4.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b0243c2747c4efe13417f484046a1db0", "sha256": "da72ab6b920dc9625ce643e2c73e4b217172fec488f96c68db547ca7613eda8b"}, "downloads": -1, "filename": "logipar-0.4.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b0243c2747c4efe13417f484046a1db0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14829, "upload_time": "2019-08-31T23:22:16", "upload_time_iso_8601": "2019-08-31T23:22:16.063915Z", "url": "https://files.pythonhosted.org/packages/83/da/3444f8b2f61033b7c3f11068b0168b9567ea2f763fc26afc7a79b26a7f98/logipar-0.4.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "48e31270cb3c70abb8adcb906eac3c7f", "sha256": "8d432874e27085ac9e4ba6e031e9ea8148af70b53d291c12fcce68ea6de898cc"}, "downloads": -1, "filename": "logipar-0.4.0.tar.gz", "has_sig": false, "md5_digest": "48e31270cb3c70abb8adcb906eac3c7f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13891, "upload_time": "2019-08-31T23:22:22", "upload_time_iso_8601": "2019-08-31T23:22:22.243421Z", "url": "https://files.pythonhosted.org/packages/33/f6/f441c5a2564187c76dd2a240b02284438a72666f4823ac08c3332c4d2c27/logipar-0.4.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:12 2020"}