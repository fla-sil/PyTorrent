{"info": {"author": "Edgar Cabrera", "author_email": "ecabrera@intelimetrica.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python"], "description": "# PySignature\n\nPySingature is a python package that provides a set of utilities\nfor simple function parameter typechecking, without modifying\nthe target function and with minimal boilerplate or impact\non performance.\n\n## Usage\n\nPySignature provides two main components: a small set of\nclasses that represent type assertions and a decorator for defining\nthe function's signature.\n\n### Example\n\nLet's take a look at a (very) simple function:\n\n```python\ndef fn(x, y):\n    return x * y\n```\n\nWe can add parameter typechecking using the PySignature in the\nfollowing way:\n\n```python\nfrom pysignature import typechecked\nfrom pysignature.types import Numeric\n\n@typechecked(x=Numeric, y=Numeric)\ndef fn(x, y):\n    return x + y\n```\n\nNow if we call `fn` with non-numeric types (neither ints nor floats)\nwe get an exception `FunctionTypeCheckError` with detailed information\nabout the wrong parameters in its property `errors`.\n\n### Complex type assertions\n\nWe can go beyond numeric validation and use complex type assertions\nprovided by this module, or we can use any callable that uppon error\nreturns a `TypeError` (such as `float`).\n\nTo expand our previous example, let's consider the fact that the `*`\noperator works if the left operand is a list or a string and the right\noperand is an integer (`Numeric` accepts floats). We can make use\nof built-in function `int` and PySignature's `List`, `Or`, `List` and `Any`\ntype assertions.\n\n```python\nfrom pysignature import typechecked\nfrom pysignature.types import String, Or, List, Any\n\n@typechecked(x=Or(String, List(Any)), y=int)\ndef fn(x, y):\n    return x + y\n```\n\n### Variadic and keyword arguments\n\nPySignature supports typechecking for `*args` and `**kwargs` argument\ntypes. The only limitation is that they all must conform to a single\ntype. They are specified in the following way:\n\n```python\n@typechecked(x=String, _variadic=Numeric, _named=List(List(Any)))\ndef fn(x, *extra, **options):\n    # ... Do something\n    return\n```\n\n### Bypassing typechecks\n\nEach function decorated with `pysignature.typechecked` gets\na property named `untyped` that ignores the typechecking\nfunctionality. In our original example, that would mean\nwe can use `fn.untyped(None, 1)`.\n\n## Rationale\n\nPySignature was created to cover a very specific need: allow\nfor robust handling of parameters coming from the external world\n(the internet) without burdening the data scientists at\n[Intelim\u00e9trica](https://intelimetrica.com/) with the fact\nthat their functions might be called with unsafe arguments.\n\nThe idea is to use PySignature in the (normally) small subset\nof functions that are exposed from a certain module to the\noutside world, so the mantainers of the function can develop\nwithout extra cognitive burden and the clients of such function\ncan use them with extra confidence and robustness.\n\n## What PySignature is not\n\nPySignature is not (neither tries to be) an extension to Python's\ntype system. It does not attempt to bring full static typying\nto the languge and while it is not slow, it is not recommended\nfor functions that are too be called in very tight loops.\n\n## Installation\n\nSimply install via pip with:\n\n```\n$ pip install pysignature\n```\n\nOr, directly download the package and run\n\n```\n$ python setup.py install\n```\n\n## Contribute\n\nYes please! Help us with documentation, reporting bugs,\nimplementing new type assertions or improving code\n\nThe development requirements are minimal. The only consideration\nis that we use [pytest](https://github.com/pytest-dev/pytest/)\nfor testing.\n\n## LICENSE\n\nPySignature uses the Apache License 2.0.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/intelimetrica/pysignature", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "pysignature", "package_url": "https://pypi.org/project/pysignature/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/pysignature/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/intelimetrica/pysignature"}, "release_url": "https://pypi.org/project/pysignature/0.0.1/", "requires_dist": null, "requires_python": null, "summary": "Minimalistic typechecking of function calls", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            # PySignature<br><br>PySingature is a python package that provides a set of utilities<br>for simple function parameter typechecking, without modifying<br>the target function and with minimal boilerplate or impact<br>on performance.<br><br>## Usage<br><br>PySignature provides two main components: a small set of<br>classes that represent type assertions and a decorator for defining<br>the function's signature.<br><br>### Example<br><br>Let's take a look at a (very) simple function:<br><br>```python<br>def fn(x, y):<br>    return x * y<br>```<br><br>We can add parameter typechecking using the PySignature in the<br>following way:<br><br>```python<br>from pysignature import typechecked<br>from pysignature.types import Numeric<br><br>@typechecked(x=Numeric, y=Numeric)<br>def fn(x, y):<br>    return x + y<br>```<br><br>Now if we call `fn` with non-numeric types (neither ints nor floats)<br>we get an exception `FunctionTypeCheckError` with detailed information<br>about the wrong parameters in its property `errors`.<br><br>### Complex type assertions<br><br>We can go beyond numeric validation and use complex type assertions<br>provided by this module, or we can use any callable that uppon error<br>returns a `TypeError` (such as `float`).<br><br>To expand our previous example, let's consider the fact that the `*`<br>operator works if the left operand is a list or a string and the right<br>operand is an integer (`Numeric` accepts floats). We can make use<br>of built-in function `int` and PySignature's `List`, `Or`, `List` and `Any`<br>type assertions.<br><br>```python<br>from pysignature import typechecked<br>from pysignature.types import String, Or, List, Any<br><br>@typechecked(x=Or(String, List(Any)), y=int)<br>def fn(x, y):<br>    return x + y<br>```<br><br>### Variadic and keyword arguments<br><br>PySignature supports typechecking for `*args` and `**kwargs` argument<br>types. The only limitation is that they all must conform to a single<br>type. They are specified in the following way:<br><br>```python<br>@typechecked(x=String, _variadic=Numeric, _named=List(List(Any)))<br>def fn(x, *extra, **options):<br>    # ... Do something<br>    return<br>```<br><br>### Bypassing typechecks<br><br>Each function decorated with `pysignature.typechecked` gets<br>a property named `untyped` that ignores the typechecking<br>functionality. In our original example, that would mean<br>we can use `fn.untyped(None, 1)`.<br><br>## Rationale<br><br>PySignature was created to cover a very specific need: allow<br>for robust handling of parameters coming from the external world<br>(the internet) without burdening the data scientists at<br>[Intelim\u00e9trica](https://intelimetrica.com/) with the fact<br>that their functions might be called with unsafe arguments.<br><br>The idea is to use PySignature in the (normally) small subset<br>of functions that are exposed from a certain module to the<br>outside world, so the mantainers of the function can develop<br>without extra cognitive burden and the clients of such function<br>can use them with extra confidence and robustness.<br><br>## What PySignature is not<br><br>PySignature is not (neither tries to be) an extension to Python's<br>type system. It does not attempt to bring full static typying<br>to the languge and while it is not slow, it is not recommended<br>for functions that are too be called in very tight loops.<br><br>## Installation<br><br>Simply install via pip with:<br><br>```<br>$ pip install pysignature<br>```<br><br>Or, directly download the package and run<br><br>```<br>$ python setup.py install<br>```<br><br>## Contribute<br><br>Yes please! Help us with documentation, reporting bugs,<br>implementing new type assertions or improving code<br><br>The development requirements are minimal. The only consideration<br>is that we use [pytest](https://github.com/pytest-dev/pytest/)<br>for testing.<br><br>## LICENSE<br><br>PySignature uses the Apache License 2.0.\n          </div>"}, "last_serial": 1776288, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "6767bc5aeec3600d8920a4714cd07fd2", "sha256": "4862730a83d324b335393cec86d598bfbd71f99faf2b1aab2ab72184c0d3b0ef"}, "downloads": -1, "filename": "pysignature-0.0.1.tar.gz", "has_sig": false, "md5_digest": "6767bc5aeec3600d8920a4714cd07fd2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11183, "upload_time": "2015-10-19T15:09:18", "upload_time_iso_8601": "2015-10-19T15:09:18.068987Z", "url": "https://files.pythonhosted.org/packages/99/47/d634d0ead5c1e7ecd0ffbf188837e925899612aa20eabd1fe4483835a6a4/pysignature-0.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6767bc5aeec3600d8920a4714cd07fd2", "sha256": "4862730a83d324b335393cec86d598bfbd71f99faf2b1aab2ab72184c0d3b0ef"}, "downloads": -1, "filename": "pysignature-0.0.1.tar.gz", "has_sig": false, "md5_digest": "6767bc5aeec3600d8920a4714cd07fd2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11183, "upload_time": "2015-10-19T15:09:18", "upload_time_iso_8601": "2015-10-19T15:09:18.068987Z", "url": "https://files.pythonhosted.org/packages/99/47/d634d0ead5c1e7ecd0ffbf188837e925899612aa20eabd1fe4483835a6a4/pysignature-0.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:56:53 2020"}