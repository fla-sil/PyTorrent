{"info": {"author": "Jacob Levine", "author_email": "jl3545@columbia.edu", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering :: Bio-Informatics", "Topic :: Scientific/Engineering :: Visualization"], "description": "PhenoGraph for Python3\n======================\n\n[PhenoGraph](http://www.cell.com/cell/abstract/S0092-8674(15)00637-6) is a clustering method designed for \nhigh-dimensional single-cell data. It works by creating a graph (\"network\") representing phenotypic similarities \nbetween cells and then identifying communities in this graph. \n\nThis implementation is written in Python3 and depends only on `scikit-learn (>= 0.17)` and its dependencies.  \n\nThis software package includes compiled binaries that run community detection based on C++ code written by \nE. Lefebvre and J.-L. Guillaume in 2008 ([\"Louvain method\"](https://sites.google.com/site/findcommunities/)). The code\nhas been altered to interface more efficiently with the Python code here. It should work on reasonably current Linux, \nMac and Windows machines.\n\nTo install PhenoGraph, simply run the setup script:\n\n    pip install PhenoGraph\n\n\nExpected use is within a script or interactive kernel running Python `3.x`. Data are expected to be passed as a `numpy.ndarray`.\nWhen applicable, the code uses CPU multicore parallelism via `multiprocessing`. \n\nTo run basic clustering:\n\n    import phenograph\n    communities, graph, Q = phenograph.cluster(data)\n\nFor a dataset of *N* rows, `communities` will be a length *N* vector of integers specifying a community assignment for each row\nin the data. Any rows assigned `-1` were identified as *outliers* and should not be considered as a member of any community.\n`graph` is a *N* x *N* `scipy.sparse` matrix representing the weighted graph used for community detection. \n`Q` is the modularity score for `communities` as applied to `graph`.\n\nIf you use PhenoGraph in work you publish, please cite our publication:\n\n    @article{Levine_PhenoGraph_2015,\n      doi = {10.1016/j.cell.2015.05.047},\n      url = {http://dx.doi.org/10.1016/j.cell.2015.05.047},\n      year  = {2015},\n      month = {jul},\n      publisher = {Elsevier {BV}},\n      volume = {162},\n      number = {1},\n      pages = {184--197},\n      author = {Jacob H. Levine and Erin F. Simonds and Sean C. Bendall and Kara L. Davis and El-ad D. Amir and Michelle D. Tadmor and Oren Litvin and Harris G. Fienberg and Astraea Jager and Eli R. Zunder and Rachel Finck and Amanda L. Gedman and Ina Radtke and James R. Downing and Dana Pe'er and Garry P. Nolan},\n      title = {Data-Driven Phenotypic Dissection of {AML} Reveals Progenitor-like Cells that Correlate with Prognosis},\n      journal = {Cell}\n    }\n\nRelease Notes\n-------------\n\n### Version 1.5.5\n * Exposed parameter `n_iterations` for Leiden, along with minor fixes to manage sorting parallelism, and updated documentation of the clustering and sorting methods.\n\n### Version 1.5.4\n\n * Faster and more efficient sorting by size of clusters, for large nearest neighbours graph, implementing multiprocessing and faster methods for sorting.\n\n### Version 1.5.3\n\n * Phenograph supports now [**Leiden**](https://www.nature.com/articles/s41598-019-41695-z) algorithm for community detection.\n The new feature can be called from `phenograph.cluster`, by choosing `leiden` as the clustering algorithm. \n\n### Version 1.5.2\n\n * Include simple parallel implementation of brute force nearest neighbors search using scipy's `cdist` and `multiprocessing`. This may be more efficient than `kdtree` on very large high-dimensional data sets\n and avoids memory issues that arise in `sklearn`'s implementation.\n * Refactor `parallel_jaccard_kernel` to remove unnecessary use of `ctypes` and `multiprocessing.Array`.\n\n### Version 1.5.1\n\n * Make `louvain_time_limit` a parameter to `phenograph.cluster`.\n\n### Version 1.5\n\n * `phenograph.cluster` can now take as input a square sparse matrix, which will be interpreted as a k-nearest neighbor graph. \n Note that this graph _must_ have uniform degree (i.e. the same value of k at every point).\n * The default `time_limit` for Louvain iterations has been increased to a more generous 2000 seconds (~half hour).\n\n### Version 1.4.1\n\n * After observing inconsistent behavior of sklearn.NearestNeighbors with respect to inclusion of self-neighbors,\n the code now checks that self-neighbors have been included before deleting those entries.\n\n### Version 1.4\n\n * The dependence on IPython and/or ipyparallel has been removed. Instead the native `multiprocessing` package is used.\n * Multiple CPUs are used by default for computation of nearest neighbors and Jaccard graph.\n\n### Version 1.3\n\n * Proper support for Linux.\n\n---\nTroubleshooting\n---------------\n\n### Notebook freezes after several attempts of running PhenoGraph using Jypyter Notebook\n\n* Running `PhenoGraph` from a Jupyter Notebook repeatedly on macOS Catalina, but not Mojave,  using Python 3.7.6, causes a hang and the notebook becomes unresponsive, even for a basic matrix of nearest neighbors. However, this issue was not reproducible in command line using `Python` interpreter in both Catalina and Mojave platforms, without using Jupyter Notebook.\n\n  It was found that attempting to plot principal components using \n\n    ```\n    :func:`~matplotlib.pyplot.scatter`\n    ```\n\n  in Jupyter Notebook causes a freeze, and `PhenoGraph` becomes unresponsive unless the kernel is restarted. When removing this line of code, everything goes back to normal and the Jupyter Notebook stopes crashing with repeated runs of `PhenoGraph`. \n\n### Architecture related error\n\n* When attempting to process very large nearest neighbours graph, _e.g._ a 2000000 `x` 2000000 kNN graph matrix with 300 nearest neighbours, a `struct.error()` is raised: \n\n    ```python\n    struct.error: 'i' format requires -2147483648 <= number <= 2147483647\n    ```\n\n  This issue was reported on [stackoverflow](https://stackoverflow.com/questions/47776486/python-struct-error-i-format-requires-2147483648-number-2147483647) and it's related to the multiprocessing while building the Jaccard object.\n\n  The `struct.error()` has been fixed in python >= 3.8.0.\n\n### `leidenalg` inside conda environment\n\n* When using `PhenoGraph` inside a conda environment `leiden` takes longer to complete for larger samples compared to the system Python. \n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/dpeerlab/PhenoGraph.git", "keywords": "", "license": "LICENSE", "maintainer": "", "maintainer_email": "", "name": "PhenoGraph", "package_url": "https://pypi.org/project/PhenoGraph/", "platform": "", "project_url": "https://pypi.org/project/PhenoGraph/", "project_urls": {"Homepage": "https://github.com/dpeerlab/PhenoGraph.git"}, "release_url": "https://pypi.org/project/PhenoGraph/1.5.5/", "requires_dist": ["leidenalg (>=0.7.0)", "setuptools (>=18.0.1)", "numpy (>=1.12)", "scipy (>=0.16.0)", "scikit-learn (>=0.17)", "psutil (>4)"], "requires_python": ">=3.6", "summary": "Graph-based clustering for high-dimensional single-cell data", "version": "1.5.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>PhenoGraph for Python3</h1>\n<p><a href=\"http://www.cell.com/cell/abstract/S0092-8674(15)00637-6\" rel=\"nofollow\">PhenoGraph</a> is a clustering method designed for\nhigh-dimensional single-cell data. It works by creating a graph (\"network\") representing phenotypic similarities\nbetween cells and then identifying communities in this graph.</p>\n<p>This implementation is written in Python3 and depends only on <code>scikit-learn (&gt;= 0.17)</code> and its dependencies.</p>\n<p>This software package includes compiled binaries that run community detection based on C++ code written by\nE. Lefebvre and J.-L. Guillaume in 2008 (<a href=\"https://sites.google.com/site/findcommunities/\" rel=\"nofollow\">\"Louvain method\"</a>). The code\nhas been altered to interface more efficiently with the Python code here. It should work on reasonably current Linux,\nMac and Windows machines.</p>\n<p>To install PhenoGraph, simply run the setup script:</p>\n<pre><code>pip install PhenoGraph\n</code></pre>\n<p>Expected use is within a script or interactive kernel running Python <code>3.x</code>. Data are expected to be passed as a <code>numpy.ndarray</code>.\nWhen applicable, the code uses CPU multicore parallelism via <code>multiprocessing</code>.</p>\n<p>To run basic clustering:</p>\n<pre><code>import phenograph\ncommunities, graph, Q = phenograph.cluster(data)\n</code></pre>\n<p>For a dataset of <em>N</em> rows, <code>communities</code> will be a length <em>N</em> vector of integers specifying a community assignment for each row\nin the data. Any rows assigned <code>-1</code> were identified as <em>outliers</em> and should not be considered as a member of any community.\n<code>graph</code> is a <em>N</em> x <em>N</em> <code>scipy.sparse</code> matrix representing the weighted graph used for community detection.\n<code>Q</code> is the modularity score for <code>communities</code> as applied to <code>graph</code>.</p>\n<p>If you use PhenoGraph in work you publish, please cite our publication:</p>\n<pre><code>@article{Levine_PhenoGraph_2015,\n  doi = {10.1016/j.cell.2015.05.047},\n  url = {http://dx.doi.org/10.1016/j.cell.2015.05.047},\n  year  = {2015},\n  month = {jul},\n  publisher = {Elsevier {BV}},\n  volume = {162},\n  number = {1},\n  pages = {184--197},\n  author = {Jacob H. Levine and Erin F. Simonds and Sean C. Bendall and Kara L. Davis and El-ad D. Amir and Michelle D. Tadmor and Oren Litvin and Harris G. Fienberg and Astraea Jager and Eli R. Zunder and Rachel Finck and Amanda L. Gedman and Ina Radtke and James R. Downing and Dana Pe'er and Garry P. Nolan},\n  title = {Data-Driven Phenotypic Dissection of {AML} Reveals Progenitor-like Cells that Correlate with Prognosis},\n  journal = {Cell}\n}\n</code></pre>\n<h2>Release Notes</h2>\n<h3>Version 1.5.5</h3>\n<ul>\n<li>Exposed parameter <code>n_iterations</code> for Leiden, along with minor fixes to manage sorting parallelism, and updated documentation of the clustering and sorting methods.</li>\n</ul>\n<h3>Version 1.5.4</h3>\n<ul>\n<li>Faster and more efficient sorting by size of clusters, for large nearest neighbours graph, implementing multiprocessing and faster methods for sorting.</li>\n</ul>\n<h3>Version 1.5.3</h3>\n<ul>\n<li>Phenograph supports now <a href=\"https://www.nature.com/articles/s41598-019-41695-z\" rel=\"nofollow\"><strong>Leiden</strong></a> algorithm for community detection.\nThe new feature can be called from <code>phenograph.cluster</code>, by choosing <code>leiden</code> as the clustering algorithm.</li>\n</ul>\n<h3>Version 1.5.2</h3>\n<ul>\n<li>Include simple parallel implementation of brute force nearest neighbors search using scipy's <code>cdist</code> and <code>multiprocessing</code>. This may be more efficient than <code>kdtree</code> on very large high-dimensional data sets\nand avoids memory issues that arise in <code>sklearn</code>'s implementation.</li>\n<li>Refactor <code>parallel_jaccard_kernel</code> to remove unnecessary use of <code>ctypes</code> and <code>multiprocessing.Array</code>.</li>\n</ul>\n<h3>Version 1.5.1</h3>\n<ul>\n<li>Make <code>louvain_time_limit</code> a parameter to <code>phenograph.cluster</code>.</li>\n</ul>\n<h3>Version 1.5</h3>\n<ul>\n<li><code>phenograph.cluster</code> can now take as input a square sparse matrix, which will be interpreted as a k-nearest neighbor graph.\nNote that this graph <em>must</em> have uniform degree (i.e. the same value of k at every point).</li>\n<li>The default <code>time_limit</code> for Louvain iterations has been increased to a more generous 2000 seconds (~half hour).</li>\n</ul>\n<h3>Version 1.4.1</h3>\n<ul>\n<li>After observing inconsistent behavior of sklearn.NearestNeighbors with respect to inclusion of self-neighbors,\nthe code now checks that self-neighbors have been included before deleting those entries.</li>\n</ul>\n<h3>Version 1.4</h3>\n<ul>\n<li>The dependence on IPython and/or ipyparallel has been removed. Instead the native <code>multiprocessing</code> package is used.</li>\n<li>Multiple CPUs are used by default for computation of nearest neighbors and Jaccard graph.</li>\n</ul>\n<h3>Version 1.3</h3>\n<ul>\n<li>Proper support for Linux.</li>\n</ul>\n<hr>\n<h2>Troubleshooting</h2>\n<h3>Notebook freezes after several attempts of running PhenoGraph using Jypyter Notebook</h3>\n<ul>\n<li>\n<p>Running <code>PhenoGraph</code> from a Jupyter Notebook repeatedly on macOS Catalina, but not Mojave,  using Python 3.7.6, causes a hang and the notebook becomes unresponsive, even for a basic matrix of nearest neighbors. However, this issue was not reproducible in command line using <code>Python</code> interpreter in both Catalina and Mojave platforms, without using Jupyter Notebook.</p>\n<p>It was found that attempting to plot principal components using</p>\n<pre><code>:func:`~matplotlib.pyplot.scatter`\n</code></pre>\n<p>in Jupyter Notebook causes a freeze, and <code>PhenoGraph</code> becomes unresponsive unless the kernel is restarted. When removing this line of code, everything goes back to normal and the Jupyter Notebook stopes crashing with repeated runs of <code>PhenoGraph</code>.</p>\n</li>\n</ul>\n<h3>Architecture related error</h3>\n<ul>\n<li>\n<p>When attempting to process very large nearest neighbours graph, <em>e.g.</em> a 2000000 <code>x</code> 2000000 kNN graph matrix with 300 nearest neighbours, a <code>struct.error()</code> is raised:</p>\n<pre><span class=\"n\">struct</span><span class=\"o\">.</span><span class=\"n\">error</span><span class=\"p\">:</span> <span class=\"s1\">'i'</span> <span class=\"nb\">format</span> <span class=\"n\">requires</span> <span class=\"o\">-</span><span class=\"mi\">2147483648</span> <span class=\"o\">&lt;=</span> <span class=\"n\">number</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">2147483647</span>\n</pre>\n<p>This issue was reported on <a href=\"https://stackoverflow.com/questions/47776486/python-struct-error-i-format-requires-2147483648-number-2147483647\" rel=\"nofollow\">stackoverflow</a> and it's related to the multiprocessing while building the Jaccard object.</p>\n<p>The <code>struct.error()</code> has been fixed in python &gt;= 3.8.0.</p>\n</li>\n</ul>\n<h3><code>leidenalg</code> inside conda environment</h3>\n<ul>\n<li>When using <code>PhenoGraph</code> inside a conda environment <code>leiden</code> takes longer to complete for larger samples compared to the system Python.</li>\n</ul>\n\n          </div>"}, "last_serial": 7146040, "releases": {"1.5.3": [{"comment_text": "", "digests": {"md5": "12890ad0b53218055d11e4064c3266a7", "sha256": "56da594d09385ffa03af42513ce092c4e5ce6b2664a79a5c1b34135c78dc2d86"}, "downloads": -1, "filename": "PhenoGraph-1.5.3-py3-none-any.whl", "has_sig": false, "md5_digest": "12890ad0b53218055d11e4064c3266a7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 153228, "upload_time": "2020-03-06T19:53:29", "upload_time_iso_8601": "2020-03-06T19:53:29.924944Z", "url": "https://files.pythonhosted.org/packages/f4/77/180c44bd3cdcf63d8a25821d8454117df347df3ce4113bf97c2a9f81bd28/PhenoGraph-1.5.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d76e7b50c90080a6747811138718abcf", "sha256": "7e7179c4fe4f923285f186e13be0e2deb0b14f8142803d1aea9337b869b778d2"}, "downloads": -1, "filename": "PhenoGraph-1.5.3.tar.gz", "has_sig": false, "md5_digest": "d76e7b50c90080a6747811138718abcf", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 149940, "upload_time": "2020-03-06T19:53:31", "upload_time_iso_8601": "2020-03-06T19:53:31.900905Z", "url": "https://files.pythonhosted.org/packages/2f/d0/3cc4f6aec32d4d5a14cd3bd97f0564eb8402500e2183e41bfc23097e8bf3/PhenoGraph-1.5.3.tar.gz", "yanked": false}], "1.5.4": [{"comment_text": "", "digests": {"md5": "dec79921dfa9d3c06f4bef8ec641ab7f", "sha256": "b269ec07c120d8624f1185151022e33c7101467980ec22da1d095fe40e6fe9fd"}, "downloads": -1, "filename": "PhenoGraph-1.5.4-py3-none-any.whl", "has_sig": false, "md5_digest": "dec79921dfa9d3c06f4bef8ec641ab7f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 154224, "upload_time": "2020-04-29T04:02:11", "upload_time_iso_8601": "2020-04-29T04:02:11.400425Z", "url": "https://files.pythonhosted.org/packages/71/61/7274e235b787f4db22033bf364a584433865bcd51fc23dfdd3b2a901d4f6/PhenoGraph-1.5.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f84664dc10578cc59b159deb56569712", "sha256": "b1e2f1fa8a7ea17ab7272522da6547f2d78da2b68541488e9f6b28b590df4c01"}, "downloads": -1, "filename": "PhenoGraph-1.5.4.tar.gz", "has_sig": false, "md5_digest": "f84664dc10578cc59b159deb56569712", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 147582, "upload_time": "2020-04-29T04:02:12", "upload_time_iso_8601": "2020-04-29T04:02:12.758086Z", "url": "https://files.pythonhosted.org/packages/2b/3a/6a5345f18438f3e080968374d5143ea023f249f0f842cc51114bff23fee5/PhenoGraph-1.5.4.tar.gz", "yanked": false}], "1.5.5": [{"comment_text": "", "digests": {"md5": "37388899c700aa0b58ee689e921d9889", "sha256": "d44362dec99f694e87d6b1889b32b792db7c051e3736de57b07149a1edb8c961"}, "downloads": -1, "filename": "PhenoGraph-1.5.5-py3-none-any.whl", "has_sig": false, "md5_digest": "37388899c700aa0b58ee689e921d9889", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 154640, "upload_time": "2020-05-01T16:04:49", "upload_time_iso_8601": "2020-05-01T16:04:49.517082Z", "url": "https://files.pythonhosted.org/packages/18/6e/55d3e2393fd2bf4d9e26f7e93a771e7df5336b9aec46fb0c0413eb15d186/PhenoGraph-1.5.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ff31082b59fbd54b26ea932c6869a51f", "sha256": "5222c2be6e0d28d06ae0fe7990bb72853b090df54dee61bdc890e2dc9d7d6d5b"}, "downloads": -1, "filename": "PhenoGraph-1.5.5.tar.gz", "has_sig": false, "md5_digest": "ff31082b59fbd54b26ea932c6869a51f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 152280, "upload_time": "2020-05-01T16:04:50", "upload_time_iso_8601": "2020-05-01T16:04:50.697560Z", "url": "https://files.pythonhosted.org/packages/78/37/c0851e87403ace20a04d7bf0fe06450bcdc3c031f9e7eef506c3b2bc23d9/PhenoGraph-1.5.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "37388899c700aa0b58ee689e921d9889", "sha256": "d44362dec99f694e87d6b1889b32b792db7c051e3736de57b07149a1edb8c961"}, "downloads": -1, "filename": "PhenoGraph-1.5.5-py3-none-any.whl", "has_sig": false, "md5_digest": "37388899c700aa0b58ee689e921d9889", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 154640, "upload_time": "2020-05-01T16:04:49", "upload_time_iso_8601": "2020-05-01T16:04:49.517082Z", "url": "https://files.pythonhosted.org/packages/18/6e/55d3e2393fd2bf4d9e26f7e93a771e7df5336b9aec46fb0c0413eb15d186/PhenoGraph-1.5.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ff31082b59fbd54b26ea932c6869a51f", "sha256": "5222c2be6e0d28d06ae0fe7990bb72853b090df54dee61bdc890e2dc9d7d6d5b"}, "downloads": -1, "filename": "PhenoGraph-1.5.5.tar.gz", "has_sig": false, "md5_digest": "ff31082b59fbd54b26ea932c6869a51f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 152280, "upload_time": "2020-05-01T16:04:50", "upload_time_iso_8601": "2020-05-01T16:04:50.697560Z", "url": "https://files.pythonhosted.org/packages/78/37/c0851e87403ace20a04d7bf0fe06450bcdc3c031f9e7eef506c3b2bc23d9/PhenoGraph-1.5.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:55:33 2020"}