{"info": {"author": "Jesper Wramberg & Mathias Tausen", "author_email": "jesper.wramberg@gmail.com & mathias.tausen@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: Education", "Programming Language :: Python", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "Adaptfilt\r\n=========\r\n\r\nAdaptfilt is an adaptive filtering module for Python. It includes simple, procedural implementations of the following filtering algorithms:\r\n\r\n* **Least-mean-squares (LMS)** - including traditional and leaky filtering\r\n* **Normalized least-mean-squares (NLMS)** - including traditional and leaky filtering with recursively updated input energy\r\n* **Affine projection (AP)** - including traditional and leaky filtering\r\n\r\nThe algorithms are implemented using Numpy for computational efficiency. Further optimization have also been done, but this is very limited and only on the most computationally intensive parts of the source code. Future implementation of the following algorithms is currently planned:\r\n\r\n* **Recursive least squares (RLS)**\r\n* **Steepest descent (SD)**\r\n\r\n| **Authors**: Jesper Wramberg & Mathias Tausen\r\n| **Version**: 0.2\r\n| **PyPI**: https://pypi.python.org/pypi/adaptfilt\r\n| **GitHub**: https://github.com/Wramberg/adaptfilt\r\n| **License**: MIT\r\n\r\nInstallation\r\n------------\r\nTo install from PyPI using pip simply run::\r\n\r\n   sudo pip install adaptfilt\r\n\r\nAlternatively, the module can also be downloaded at https://pypi.python.org/pypi/adaptfilt or \r\nhttps://github.com/Wramberg/adaptfilt. The latter is also used for issue tracking. Note that adaptfilt requires Numpy to be installed (tested using version 1.9.0).\r\n\r\nUsage\r\n-----\r\nOnce installed, the module should be available for import by calling::\r\n\r\n   import adaptfilt\r\n\r\nFollowing the reference sections, examples are provided to show the modules functionality.\r\n\r\nFunction Reference\r\n------------------\r\nIn this section, the functions provided by adaptfilt are described. The descriptions correspond with excerpts from the function docstrings and are only included here for your convenience.\r\n\r\n**y, e, w = lms(u, d, M, step, leak=0., initCoeffs=None, N=None, returnCoeffs=False)**\r\n\r\n    Perform least-mean-squares (LMS) adaptive filtering on u to minimize error\r\n    given by e=d-y, where y is the output of the adaptive filter.\r\n\r\n    Parameters\r\n        u : array-like\r\n            One-dimensional filter input.\r\n        d : array-like\r\n            One-dimensional desired signal, i.e., the output of the unknown FIR\r\n            system which the adaptive filter should identify. Must have length >=\r\n            len(u), or N+M-1 if number of iterations are limited (via the N\r\n            parameter).\r\n        M : int\r\n            Desired number of filter taps (desired filter order + 1), must be\r\n            non-negative.\r\n        step : float\r\n            Step size of the algorithm, must be non-negative.\r\n\r\n    Optional Parameters\r\n        leak : float\r\n            Leakage factor, must be equal to or greater than zero and smaller than\r\n            one. When greater than zero a leaky LMS filter is used. Defaults to 0,\r\n            i.e., no leakage.\r\n        initCoeffs : array-like\r\n            Initial filter coefficients to use. Should match desired number of\r\n            filter taps, defaults to zeros.\r\n        N : int\r\n            Number of iterations, must be less than or equal to len(u)-M+1\r\n            (default).\r\n        returnCoeffs : boolean\r\n            If true, will return all filter coefficients for every iteration in an\r\n            N x M matrix. Does not include the initial coefficients. If false, only\r\n            the latest coefficients in a vector of length M is returned. Defaults\r\n            to false.\r\n\r\n    Returns\r\n        y : numpy.array\r\n            Output values of LMS filter, array of length N.\r\n        e : numpy.array\r\n            Error signal, i.e, d-y. Array of length N.\r\n        w : numpy.array\r\n            Final filter coefficients in array of length M if returnCoeffs is\r\n            False. NxM array containing all filter coefficients for all iterations\r\n            otherwise.\r\n\r\n    Raises\r\n        TypeError\r\n            If number of filter taps M is not type integer, number of iterations N\r\n            is not type integer, or leakage leak is not type float/int.\r\n        ValueError\r\n            If number of iterations N is greater than len(u)-M, number of filter\r\n            taps M is negative, or if step-size or leakage is outside specified\r\n            range.\r\n\r\n**y, e, w = nlmsru(u, d, M, step, eps=0.001, leak=0, initCoeffs=None, N=None, returnCoeffs=False)**\r\n\r\n    Same as nlms but updates input energy recursively for faster computation. Note that this can cause instability due to rounding errors.\r\n\r\n**y, e, w = nlms(u, d, M, step, eps=0.001, leak=0, initCoeffs=None, N=None, returnCoeffs=False)**\r\n\r\n    Perform normalized least-mean-squares (NLMS) adaptive filtering on u to\r\n    minimize error given by e=d-y, where y is the output of the adaptive\r\n    filter.\r\n\r\n    Parameters\r\n        u : array-like\r\n            One-dimensional filter input.\r\n        d : array-like\r\n            One-dimensional desired signal, i.e., the output of the unknown FIR\r\n            system which the adaptive filter should identify. Must have length >=\r\n            len(u), or N+M-1 if number of iterations are limited (via the N\r\n            parameter).\r\n        M : int\r\n            Desired number of filter taps (desired filter order + 1), must be\r\n            non-negative.\r\n        step : float\r\n            Step size of the algorithm, must be non-negative.\r\n\r\n    Optional Parameters\r\n        eps : float\r\n            Regularization factor to avoid numerical issues when power of input\r\n            is close to zero. Defaults to 0.001. Must be non-negative.\r\n        leak : float\r\n            Leakage factor, must be equal to or greater than zero and smaller than\r\n            one. When greater than zero a leaky LMS filter is used. Defaults to 0,\r\n            i.e., no leakage.\r\n        initCoeffs : array-like\r\n            Initial filter coefficients to use. Should match desired number of\r\n            filter taps, defaults to zeros.\r\n        N : int\r\n            Number of iterations to run. Must be less than or equal to len(u)-M+1.\r\n            Defaults to len(u)-M+1.\r\n        returnCoeffs : boolean\r\n            If true, will return all filter coefficients for every iteration in an\r\n            N x M matrix. Does not include the initial coefficients. If false, only\r\n            the latest coefficients in a vector of length M is returned. Defaults\r\n            to false.\r\n\r\n    Returns\r\n        y : numpy.array\r\n            Output values of LMS filter, array of length N.\r\n        e : numpy.array\r\n            Error signal, i.e, d-y. Array of length N.\r\n        w : numpy.array\r\n            Final filter coefficients in array of length M if returnCoeffs is\r\n            False. NxM array containing all filter coefficients for all iterations\r\n            otherwise.\r\n\r\n    Raises\r\n        TypeError\r\n            If number of filter taps M is not type integer, number of iterations N\r\n            is not type integer, or leakage leak is not type float/int.\r\n        ValueError\r\n            If number of iterations N is greater than len(u)-M, number of filter\r\n            taps M is negative, or if step-size or leakage is outside specified\r\n            range.\r\n\r\n\r\n**y, e, w = ap(u, d, M, step, K, eps=0.001, leak=0, initCoeffs=None, N=None, returnCoeffs=False)**\r\n\r\n    Perform affine projection (AP) adaptive filtering on u to minimize error\r\n    given by e=d-y, where y is the output of the adaptive filter.\r\n\r\n    Parameters\r\n        u : array-like\r\n            One-dimensional filter input.\r\n        d : array-like\r\n            One-dimensional desired signal, i.e., the output of the unknown FIR\r\n            system which the adaptive filter should identify. Must have length >=\r\n            len(u), or N+M-1 if number of iterations are limited (via the N\r\n            parameter).\r\n        M : int\r\n            Desired number of filter taps (desired filter order + 1), must be\r\n            non-negative.\r\n        step : float\r\n            Step size of the algorithm, must be non-negative.\r\n        K : int\r\n            Projection order, must be integer larger than zero.\r\n\r\n    Optional Parameters\r\n        eps : float\r\n            Regularization factor to avoid numerical issues when power of input\r\n            is close to zero. Defaults to 0.001. Must be non-negative.\r\n        leak : float\r\n            Leakage factor, must be equal to or greater than zero and smaller than\r\n            one. When greater than zero a leaky LMS filter is used. Defaults to 0,\r\n            i.e., no leakage.\r\n        initCoeffs : array-like\r\n            Initial filter coefficients to use. Should match desired number of\r\n            filter taps, defaults to zeros.\r\n        N : int\r\n            Number of iterations to run. Must be less than or equal to len(u)-M+1.\r\n            Defaults to len(u)-M+1.\r\n        returnCoeffs : boolean\r\n            If true, will return all filter coefficients for every iteration in an\r\n            N x M matrix. Does not include the initial coefficients. If false, only\r\n            the latest coefficients in a vector of length M is returned. Defaults\r\n            to false.\r\n\r\n    Returns\r\n        y : numpy.array\r\n            Output values of LMS filter, array of length N.\r\n        e : numpy.array\r\n            Error signal, i.e, d-y. Array of length N.\r\n        w : numpy.array\r\n            Final filter coefficients in array of length M if returnCoeffs is\r\n            False. NxM array containing all filter coefficients for all iterations\r\n            otherwise.\r\n\r\n    Raises\r\n        TypeError\r\n            If number of filter taps M is not type integer, number of iterations N\r\n            is not type integer, or leakage leak is not type float/int.\r\n        ValueError\r\n            If number of iterations N is greater than len(u)-M, number of filter\r\n            taps M is negative, or if step-size or leakage is outside specified\r\n            range.\r\n\r\n\r\nHelper Function Reference\r\n-------------------------\r\n**mswe = mswe(w, v)**\r\n\r\n    Calculate mean squared weight error between estimated and true filter\r\n    coefficients, in respect to iterations.\r\n\r\n    Parameters\r\n        v : array-like\r\n            True coefficients used to generate desired signal, must be a\r\n            one-dimensional array.\r\n        w : array-like\r\n            Estimated coefficients from adaptive filtering algorithm. Must be an\r\n            N x M matrix where N is the number of iterations, and M is the number\r\n            of filter coefficients.\r\n\r\n    Returns\r\n        mswe : numpy.array\r\n            One-dimensional array containing the mean-squared weight error for\r\n            every iteration.\r\n\r\n    Raises\r\n        TypeError\r\n            If inputs have wrong dimensions\r\n\r\n    Note\r\n        To use this function with the adaptive filter functions set the optional\r\n        parameter returnCoeffs to True. This will return a coefficient matrix w\r\n        corresponding with the input-parameter w.\r\n\r\n\r\nExamples\r\n--------\r\nThe following examples illustrate the use of the adaptfilt module. Note that the matplotlib.pyplot module is required to run them. \r\n\r\nAcoustic echo cancellation\r\n++++++++++++++++++++++++++\r\n::\r\n\r\n  \"\"\"\r\n  Acoustic echo cancellation in white background noise with NLMS.\r\n\r\n  Consider a scenario where two individuals, John and Emily, are talking over the\r\n  Internet. John is using his loudspeakers, which means Emily can hear herself\r\n  through John's microphone. The speech signal that Emily hears, is a distorted\r\n  version of her own. This is caused by the acoustic path from John's\r\n  loudspeakers to his microphone. This path includes attenuated echoes, etc.\r\n\r\n  Now for the problem!\r\n\r\n  Emily wishes to cancel the echo she hears from John's microphone. Emily only\r\n  knows the speech signal she sends to him, call that u(n), and the speech signal\r\n  she receives from him, call that d(n). To successfully remove her own echo\r\n  from d(n), she must approximate the acoustic path from John's loudspeakers to\r\n  his microphone. This path can be approximated by a FIR filter, which means an\r\n  adaptive NLMS FIR filter can be used to identify it. The model which Emily uses\r\n  to design this filter looks like this:\r\n\r\n        u(n) ------->->------+----------->->-----------\r\n                             |                        |\r\n                    +-----------------+      +------------------+\r\n                +->-| Adaptive filter |      |    John's Room   |\r\n                |   +-----------------+      +------------------+\r\n                |            | -y(n)                  |\r\n                |            |           d(n)         |\r\n        e(n) ---+---<-<------+-----------<-<----------+----<-<---- v(n)\r\n\r\n  As seen, the signal that is sent to John is also used as input to the adaptive\r\n  NLMS filter. The output of the filter, y(n), is subtracted from the signal\r\n  received from John, which results in an error signal e(n) = d(n)-y(n). By\r\n  feeding the error signal back to the adaptive filter, it can minimize the error\r\n  by approximating the impulse response (that is the FIR filter coefficients) of\r\n  John's room. Note that so far John's speech signal v(n) has not been taken into\r\n  account. If John speaks, the error should equal his speech, that is, e(n)\r\n  should equal v(n). For this simple example, however, we assume John is quiet\r\n  and v(n) is equal to white Gaussian background noise with zero-mean.\r\n\r\n  In the following example we keep the impulse response of John's room constant.\r\n  This is not required, however, since the advantage of adaptive filters, is that\r\n  they can be used to track changes in the impulse response.\r\n  \"\"\"\r\n\r\n  import numpy as np\r\n  import matplotlib.pyplot as plt\r\n  import adaptfilt as adf\r\n\r\n  # Get u(n) - this is available on github or pypi in the examples folder\r\n  u = np.load('speech.npy')\r\n\r\n  # Generate received signal d(n) using randomly chosen coefficients\r\n  coeffs = np.concatenate(([0.8], np.zeros(8), [-0.7], np.zeros(9),\r\n                           [0.5], np.zeros(11), [-0.3], np.zeros(3),\r\n                           [0.1], np.zeros(20), [-0.05]))\r\n\r\n  d = np.convolve(u, coeffs)\r\n\r\n  # Add background noise\r\n  v = np.random.randn(len(d)) * np.sqrt(5000)\r\n  d += v\r\n\r\n  # Apply adaptive filter\r\n  M = 100  # Number of filter taps in adaptive filter\r\n  step = 0.1  # Step size\r\n  y, e, w = adf.nlms(u, d, M, step, returnCoeffs=True)\r\n\r\n  # Calculate mean square weight error\r\n  mswe = adf.mswe(w, coeffs)\r\n\r\n  # Plot speech signals\r\n  plt.figure()\r\n  plt.title(\"Speech signals\")\r\n  plt.plot(u, label=\"Emily's speech signal, u(n)\")\r\n  plt.plot(d, label=\"Speech signal from John, d(n)\")\r\n  plt.grid()\r\n  plt.legend()\r\n  plt.xlabel('Samples')\r\n\r\n  # Plot error signal - note how the measurement noise affects the error\r\n  plt.figure()\r\n  plt.title('Error signal e(n)')\r\n  plt.plot(e)\r\n  plt.grid()\r\n  plt.xlabel('Samples')\r\n\r\n  # Plot mean squared weight error - note that the measurement noise causes the\r\n  # error the increase at some points when Emily isn't speaking\r\n  plt.figure()\r\n  plt.title('Mean squared weight error')\r\n  plt.plot(mswe)\r\n  plt.grid()\r\n  plt.xlabel('Samples')\r\n\r\n  # Plot final coefficients versus real coefficients\r\n  plt.figure()\r\n  plt.title('Real coefficients vs. estimated coefficients')\r\n  plt.plot(w[-1], 'g', label='Estimated coefficients')\r\n  plt.plot(coeffs, 'b--', label='Real coefficients')\r\n  plt.grid()\r\n  plt.legend()\r\n  plt.xlabel('Samples')\r\n\r\n  plt.show()\r\n\r\n.. image:: https://raw.githubusercontent.com/Wramberg/adaptfilt/master/examples/echocancel-input.png\r\n.. image:: https://raw.githubusercontent.com/Wramberg/adaptfilt/master/examples/echocancel-error.png\r\n.. image:: https://raw.githubusercontent.com/Wramberg/adaptfilt/master/examples/echocancel-mswe.png\r\n.. image:: https://raw.githubusercontent.com/Wramberg/adaptfilt/master/examples/echocancel-coeffs.png\r\n\r\n\r\nConvergence comparison\r\n++++++++++++++++++++++\r\n::\r\n\r\n   \"\"\"\r\n   Convergence comparison of different adaptive filtering algorithms (with\r\n   different step sizes) in white Gaussian noise.\r\n   \"\"\"\r\n   \r\n   import numpy as np\r\n   import matplotlib.pyplot as plt\r\n   import adaptfilt as adf\r\n   \r\n   # Generating input and desired signal\r\n   N = 3000\r\n   coeffs = np.concatenate(([-4, 3.2], np.zeros(20), [0.7], np.zeros(33), [-0.1]))\r\n   u = np.random.randn(N)\r\n   d = np.convolve(u, coeffs)\r\n   \r\n   # Perform filtering\r\n   M = 60  # No. of taps to estimate\r\n   mu1 = 0.0008  # Step size 1 in LMS\r\n   mu2 = 0.0004  # Step size 1 in LMS\r\n   beta1 = 0.08  # Step size 2 in NLMS and AP\r\n   beta2 = 0.04  # Step size 2 in NLMS and AP\r\n   K = 3  # Projection order 1 in AP\r\n   \r\n   # LMS\r\n   y_lms1, e_lms1, w_lms1 = adf.lms(u, d, M, mu1, returnCoeffs=True)\r\n   y_lms2, e_lms2, w_lms2 = adf.lms(u, d, M, mu2, returnCoeffs=True)\r\n   mswe_lms1 = adf.mswe(w_lms1, coeffs)\r\n   mswe_lms2 = adf.mswe(w_lms2, coeffs)\r\n   \r\n   # NLMS\r\n   y_nlms1, e_nlms1, w_nlms1 = adf.nlms(u, d, M, beta1, returnCoeffs=True)\r\n   y_nlms2, e_nlms2, w_nlms2 = adf.nlms(u, d, M, beta2, returnCoeffs=True)\r\n   mswe_nlms1 = adf.mswe(w_nlms1, coeffs)\r\n   mswe_nlms2 = adf.mswe(w_nlms2, coeffs)\r\n   \r\n   # AP\r\n   y_ap1, e_ap1, w_ap1 = adf.ap(u, d, M, beta1, K, returnCoeffs=True)\r\n   y_ap2, e_ap2, w_ap2 = adf.ap(u, d, M, beta2, K, returnCoeffs=True)\r\n   mswe_ap1 = adf.mswe(w_ap1, coeffs)\r\n   mswe_ap2 = adf.mswe(w_ap2, coeffs)\r\n   \r\n   # Plot results\r\n   plt.figure()\r\n   plt.title('Convergence comparison of different adaptive filtering algorithms')\r\n   plt.plot(mswe_lms1, 'b', label='LMS with stepsize=%.4f' % mu1)\r\n   plt.plot(mswe_lms2, 'b--', label='LMS with stepsize=%.4f' % mu2)\r\n   plt.plot(mswe_nlms1, 'g', label='NLMS with stepsize=%.2f' % beta1)\r\n   plt.plot(mswe_nlms2, 'g--', label='NLMS with stepsize=%.2f' % beta2)\r\n   plt.plot(mswe_ap1, 'r', label='AP with stepsize=%.2f' % beta1)\r\n   plt.plot(mswe_ap2, 'r--', label='AP with stepsize=%.2f' % beta2)\r\n   plt.legend()\r\n   plt.grid()\r\n   plt.xlabel('Iterations')\r\n   plt.ylabel('Mean-squared weight error')\r\n   plt.show()\r\n\r\n.. image:: https://raw.githubusercontent.com/Wramberg/adaptfilt/master/examples/convergence-result.png\r\n\r\nRelease History\r\n---------------\r\n0.2\r\n+++\r\n| Included NLMS filtering function with recursive updates of input energy.\r\n| Included acoustic echo cancellation example\r\n\r\n0.1\r\n+++\r\n| Initial module with LMS, NLMS and AP filtering functions.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Wramberg/adaptfilt", "keywords": "adaptive filter,adaptive filtering,signal-processing,lms,apa,nlms,rls", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "adaptfilt", "package_url": "https://pypi.org/project/adaptfilt/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/adaptfilt/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/Wramberg/adaptfilt"}, "release_url": "https://pypi.org/project/adaptfilt/0.2/", "requires_dist": null, "requires_python": null, "summary": "Adaptive filtering module for Python", "version": "0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Adaptfilt is an adaptive filtering module for Python. It includes simple, procedural implementations of the following filtering algorithms:</p>\n<ul>\n<li><strong>Least-mean-squares (LMS)</strong> - including traditional and leaky filtering</li>\n<li><strong>Normalized least-mean-squares (NLMS)</strong> - including traditional and leaky filtering with recursively updated input energy</li>\n<li><strong>Affine projection (AP)</strong> - including traditional and leaky filtering</li>\n</ul>\n<p>The algorithms are implemented using Numpy for computational efficiency. Further optimization have also been done, but this is very limited and only on the most computationally intensive parts of the source code. Future implementation of the following algorithms is currently planned:</p>\n<ul>\n<li><strong>Recursive least squares (RLS)</strong></li>\n<li><strong>Steepest descent (SD)</strong></li>\n</ul>\n<div>\n<div><strong>Authors</strong>: Jesper Wramberg &amp; Mathias Tausen</div>\n<div><strong>Version</strong>: 0.2</div>\n<div><strong>PyPI</strong>: <a href=\"https://pypi.python.org/pypi/adaptfilt\" rel=\"nofollow\">https://pypi.python.org/pypi/adaptfilt</a></div>\n<div><strong>GitHub</strong>: <a href=\"https://github.com/Wramberg/adaptfilt\" rel=\"nofollow\">https://github.com/Wramberg/adaptfilt</a></div>\n<div><strong>License</strong>: MIT</div>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>To install from PyPI using pip simply run:</p>\n<pre>sudo pip install adaptfilt\n</pre>\n<p>Alternatively, the module can also be downloaded at <a href=\"https://pypi.python.org/pypi/adaptfilt\" rel=\"nofollow\">https://pypi.python.org/pypi/adaptfilt</a> or\n<a href=\"https://github.com/Wramberg/adaptfilt\" rel=\"nofollow\">https://github.com/Wramberg/adaptfilt</a>. The latter is also used for issue tracking. Note that adaptfilt requires Numpy to be installed (tested using version 1.9.0).</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Once installed, the module should be available for import by calling:</p>\n<pre>import adaptfilt\n</pre>\n<p>Following the reference sections, examples are provided to show the modules functionality.</p>\n</div>\n<div id=\"function-reference\">\n<h2>Function Reference</h2>\n<p>In this section, the functions provided by adaptfilt are described. The descriptions correspond with excerpts from the function docstrings and are only included here for your convenience.</p>\n<p><strong>y, e, w = lms(u, d, M, step, leak=0., initCoeffs=None, N=None, returnCoeffs=False)</strong></p>\n<blockquote>\n<p>Perform least-mean-squares (LMS) adaptive filtering on u to minimize error\ngiven by e=d-y, where y is the output of the adaptive filter.</p>\n<dl>\n<dt>Parameters</dt>\n<dd><dl>\n<dt>u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>One-dimensional filter input.</dd>\n<dt>d <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>One-dimensional desired signal, i.e., the output of the unknown FIR\nsystem which the adaptive filter should identify. Must have length &gt;=\nlen(u), or N+M-1 if number of iterations are limited (via the N\nparameter).</dd>\n<dt>M <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Desired number of filter taps (desired filter order + 1), must be\nnon-negative.</dd>\n<dt>step <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Step size of the algorithm, must be non-negative.</dd>\n</dl>\n</dd>\n<dt>Optional Parameters</dt>\n<dd><dl>\n<dt>leak <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Leakage factor, must be equal to or greater than zero and smaller than\none. When greater than zero a leaky LMS filter is used. Defaults to 0,\ni.e., no leakage.</dd>\n<dt>initCoeffs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>Initial filter coefficients to use. Should match desired number of\nfilter taps, defaults to zeros.</dd>\n<dt>N <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Number of iterations, must be less than or equal to len(u)-M+1\n(default).</dd>\n<dt>returnCoeffs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">boolean</span></dt>\n<dd>If true, will return all filter coefficients for every iteration in an\nN x M matrix. Does not include the initial coefficients. If false, only\nthe latest coefficients in a vector of length M is returned. Defaults\nto false.</dd>\n</dl>\n</dd>\n<dt>Returns</dt>\n<dd><dl>\n<dt>y <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.array</span></dt>\n<dd>Output values of LMS filter, array of length N.</dd>\n<dt>e <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.array</span></dt>\n<dd>Error signal, i.e, d-y. Array of length N.</dd>\n<dt>w <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.array</span></dt>\n<dd>Final filter coefficients in array of length M if returnCoeffs is\nFalse. NxM array containing all filter coefficients for all iterations\notherwise.</dd>\n</dl>\n</dd>\n<dt>Raises</dt>\n<dd><dl>\n<dt>TypeError</dt>\n<dd>If number of filter taps M is not type integer, number of iterations N\nis not type integer, or leakage leak is not type float/int.</dd>\n<dt>ValueError</dt>\n<dd>If number of iterations N is greater than len(u)-M, number of filter\ntaps M is negative, or if step-size or leakage is outside specified\nrange.</dd>\n</dl>\n</dd>\n</dl>\n</blockquote>\n<p><strong>y, e, w = nlmsru(u, d, M, step, eps=0.001, leak=0, initCoeffs=None, N=None, returnCoeffs=False)</strong></p>\n<blockquote>\nSame as nlms but updates input energy recursively for faster computation. Note that this can cause instability due to rounding errors.</blockquote>\n<p><strong>y, e, w = nlms(u, d, M, step, eps=0.001, leak=0, initCoeffs=None, N=None, returnCoeffs=False)</strong></p>\n<blockquote>\n<p>Perform normalized least-mean-squares (NLMS) adaptive filtering on u to\nminimize error given by e=d-y, where y is the output of the adaptive\nfilter.</p>\n<dl>\n<dt>Parameters</dt>\n<dd><dl>\n<dt>u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>One-dimensional filter input.</dd>\n<dt>d <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>One-dimensional desired signal, i.e., the output of the unknown FIR\nsystem which the adaptive filter should identify. Must have length &gt;=\nlen(u), or N+M-1 if number of iterations are limited (via the N\nparameter).</dd>\n<dt>M <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Desired number of filter taps (desired filter order + 1), must be\nnon-negative.</dd>\n<dt>step <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Step size of the algorithm, must be non-negative.</dd>\n</dl>\n</dd>\n<dt>Optional Parameters</dt>\n<dd><dl>\n<dt>eps <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Regularization factor to avoid numerical issues when power of input\nis close to zero. Defaults to 0.001. Must be non-negative.</dd>\n<dt>leak <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Leakage factor, must be equal to or greater than zero and smaller than\none. When greater than zero a leaky LMS filter is used. Defaults to 0,\ni.e., no leakage.</dd>\n<dt>initCoeffs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>Initial filter coefficients to use. Should match desired number of\nfilter taps, defaults to zeros.</dd>\n<dt>N <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Number of iterations to run. Must be less than or equal to len(u)-M+1.\nDefaults to len(u)-M+1.</dd>\n<dt>returnCoeffs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">boolean</span></dt>\n<dd>If true, will return all filter coefficients for every iteration in an\nN x M matrix. Does not include the initial coefficients. If false, only\nthe latest coefficients in a vector of length M is returned. Defaults\nto false.</dd>\n</dl>\n</dd>\n<dt>Returns</dt>\n<dd><dl>\n<dt>y <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.array</span></dt>\n<dd>Output values of LMS filter, array of length N.</dd>\n<dt>e <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.array</span></dt>\n<dd>Error signal, i.e, d-y. Array of length N.</dd>\n<dt>w <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.array</span></dt>\n<dd>Final filter coefficients in array of length M if returnCoeffs is\nFalse. NxM array containing all filter coefficients for all iterations\notherwise.</dd>\n</dl>\n</dd>\n<dt>Raises</dt>\n<dd><dl>\n<dt>TypeError</dt>\n<dd>If number of filter taps M is not type integer, number of iterations N\nis not type integer, or leakage leak is not type float/int.</dd>\n<dt>ValueError</dt>\n<dd>If number of iterations N is greater than len(u)-M, number of filter\ntaps M is negative, or if step-size or leakage is outside specified\nrange.</dd>\n</dl>\n</dd>\n</dl>\n</blockquote>\n<p><strong>y, e, w = ap(u, d, M, step, K, eps=0.001, leak=0, initCoeffs=None, N=None, returnCoeffs=False)</strong></p>\n<blockquote>\n<p>Perform affine projection (AP) adaptive filtering on u to minimize error\ngiven by e=d-y, where y is the output of the adaptive filter.</p>\n<dl>\n<dt>Parameters</dt>\n<dd><dl>\n<dt>u <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>One-dimensional filter input.</dd>\n<dt>d <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>One-dimensional desired signal, i.e., the output of the unknown FIR\nsystem which the adaptive filter should identify. Must have length &gt;=\nlen(u), or N+M-1 if number of iterations are limited (via the N\nparameter).</dd>\n<dt>M <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Desired number of filter taps (desired filter order + 1), must be\nnon-negative.</dd>\n<dt>step <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Step size of the algorithm, must be non-negative.</dd>\n<dt>K <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Projection order, must be integer larger than zero.</dd>\n</dl>\n</dd>\n<dt>Optional Parameters</dt>\n<dd><dl>\n<dt>eps <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Regularization factor to avoid numerical issues when power of input\nis close to zero. Defaults to 0.001. Must be non-negative.</dd>\n<dt>leak <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">float</span></dt>\n<dd>Leakage factor, must be equal to or greater than zero and smaller than\none. When greater than zero a leaky LMS filter is used. Defaults to 0,\ni.e., no leakage.</dd>\n<dt>initCoeffs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>Initial filter coefficients to use. Should match desired number of\nfilter taps, defaults to zeros.</dd>\n<dt>N <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">int</span></dt>\n<dd>Number of iterations to run. Must be less than or equal to len(u)-M+1.\nDefaults to len(u)-M+1.</dd>\n<dt>returnCoeffs <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">boolean</span></dt>\n<dd>If true, will return all filter coefficients for every iteration in an\nN x M matrix. Does not include the initial coefficients. If false, only\nthe latest coefficients in a vector of length M is returned. Defaults\nto false.</dd>\n</dl>\n</dd>\n<dt>Returns</dt>\n<dd><dl>\n<dt>y <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.array</span></dt>\n<dd>Output values of LMS filter, array of length N.</dd>\n<dt>e <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.array</span></dt>\n<dd>Error signal, i.e, d-y. Array of length N.</dd>\n<dt>w <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.array</span></dt>\n<dd>Final filter coefficients in array of length M if returnCoeffs is\nFalse. NxM array containing all filter coefficients for all iterations\notherwise.</dd>\n</dl>\n</dd>\n<dt>Raises</dt>\n<dd><dl>\n<dt>TypeError</dt>\n<dd>If number of filter taps M is not type integer, number of iterations N\nis not type integer, or leakage leak is not type float/int.</dd>\n<dt>ValueError</dt>\n<dd>If number of iterations N is greater than len(u)-M, number of filter\ntaps M is negative, or if step-size or leakage is outside specified\nrange.</dd>\n</dl>\n</dd>\n</dl>\n</blockquote>\n</div>\n<div id=\"helper-function-reference\">\n<h2>Helper Function Reference</h2>\n<p><strong>mswe = mswe(w, v)</strong></p>\n<blockquote>\n<p>Calculate mean squared weight error between estimated and true filter\ncoefficients, in respect to iterations.</p>\n<dl>\n<dt>Parameters</dt>\n<dd><dl>\n<dt>v <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>True coefficients used to generate desired signal, must be a\none-dimensional array.</dd>\n<dt>w <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">array-like</span></dt>\n<dd>Estimated coefficients from adaptive filtering algorithm. Must be an\nN x M matrix where N is the number of iterations, and M is the number\nof filter coefficients.</dd>\n</dl>\n</dd>\n<dt>Returns</dt>\n<dd><dl>\n<dt>mswe <span class=\"classifier-delimiter\">:</span> <span class=\"classifier\">numpy.array</span></dt>\n<dd>One-dimensional array containing the mean-squared weight error for\nevery iteration.</dd>\n</dl>\n</dd>\n<dt>Raises</dt>\n<dd><dl>\n<dt>TypeError</dt>\n<dd>If inputs have wrong dimensions</dd>\n</dl>\n</dd>\n<dt>Note</dt>\n<dd>To use this function with the adaptive filter functions set the optional\nparameter returnCoeffs to True. This will return a coefficient matrix w\ncorresponding with the input-parameter w.</dd>\n</dl>\n</blockquote>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<p>The following examples illustrate the use of the adaptfilt module. Note that the matplotlib.pyplot module is required to run them.</p>\n<div id=\"acoustic-echo-cancellation\">\n<h3>Acoustic echo cancellation</h3>\n<pre>\"\"\"\nAcoustic echo cancellation in white background noise with NLMS.\n\nConsider a scenario where two individuals, John and Emily, are talking over the\nInternet. John is using his loudspeakers, which means Emily can hear herself\nthrough John's microphone. The speech signal that Emily hears, is a distorted\nversion of her own. This is caused by the acoustic path from John's\nloudspeakers to his microphone. This path includes attenuated echoes, etc.\n\nNow for the problem!\n\nEmily wishes to cancel the echo she hears from John's microphone. Emily only\nknows the speech signal she sends to him, call that u(n), and the speech signal\nshe receives from him, call that d(n). To successfully remove her own echo\nfrom d(n), she must approximate the acoustic path from John's loudspeakers to\nhis microphone. This path can be approximated by a FIR filter, which means an\nadaptive NLMS FIR filter can be used to identify it. The model which Emily uses\nto design this filter looks like this:\n\n      u(n) -------&gt;-&gt;------+-----------&gt;-&gt;-----------\n                           |                        |\n                  +-----------------+      +------------------+\n              +-&gt;-| Adaptive filter |      |    John's Room   |\n              |   +-----------------+      +------------------+\n              |            | -y(n)                  |\n              |            |           d(n)         |\n      e(n) ---+---&lt;-&lt;------+-----------&lt;-&lt;----------+----&lt;-&lt;---- v(n)\n\nAs seen, the signal that is sent to John is also used as input to the adaptive\nNLMS filter. The output of the filter, y(n), is subtracted from the signal\nreceived from John, which results in an error signal e(n) = d(n)-y(n). By\nfeeding the error signal back to the adaptive filter, it can minimize the error\nby approximating the impulse response (that is the FIR filter coefficients) of\nJohn's room. Note that so far John's speech signal v(n) has not been taken into\naccount. If John speaks, the error should equal his speech, that is, e(n)\nshould equal v(n). For this simple example, however, we assume John is quiet\nand v(n) is equal to white Gaussian background noise with zero-mean.\n\nIn the following example we keep the impulse response of John's room constant.\nThis is not required, however, since the advantage of adaptive filters, is that\nthey can be used to track changes in the impulse response.\n\"\"\"\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport adaptfilt as adf\n\n# Get u(n) - this is available on github or pypi in the examples folder\nu = np.load('speech.npy')\n\n# Generate received signal d(n) using randomly chosen coefficients\ncoeffs = np.concatenate(([0.8], np.zeros(8), [-0.7], np.zeros(9),\n                         [0.5], np.zeros(11), [-0.3], np.zeros(3),\n                         [0.1], np.zeros(20), [-0.05]))\n\nd = np.convolve(u, coeffs)\n\n# Add background noise\nv = np.random.randn(len(d)) * np.sqrt(5000)\nd += v\n\n# Apply adaptive filter\nM = 100  # Number of filter taps in adaptive filter\nstep = 0.1  # Step size\ny, e, w = adf.nlms(u, d, M, step, returnCoeffs=True)\n\n# Calculate mean square weight error\nmswe = adf.mswe(w, coeffs)\n\n# Plot speech signals\nplt.figure()\nplt.title(\"Speech signals\")\nplt.plot(u, label=\"Emily's speech signal, u(n)\")\nplt.plot(d, label=\"Speech signal from John, d(n)\")\nplt.grid()\nplt.legend()\nplt.xlabel('Samples')\n\n# Plot error signal - note how the measurement noise affects the error\nplt.figure()\nplt.title('Error signal e(n)')\nplt.plot(e)\nplt.grid()\nplt.xlabel('Samples')\n\n# Plot mean squared weight error - note that the measurement noise causes the\n# error the increase at some points when Emily isn't speaking\nplt.figure()\nplt.title('Mean squared weight error')\nplt.plot(mswe)\nplt.grid()\nplt.xlabel('Samples')\n\n# Plot final coefficients versus real coefficients\nplt.figure()\nplt.title('Real coefficients vs. estimated coefficients')\nplt.plot(w[-1], 'g', label='Estimated coefficients')\nplt.plot(coeffs, 'b--', label='Real coefficients')\nplt.grid()\nplt.legend()\nplt.xlabel('Samples')\n\nplt.show()\n</pre>\n<img alt=\"https://raw.githubusercontent.com/Wramberg/adaptfilt/master/examples/echocancel-input.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9a569518fa5eb3faa3b0d1b2c3cef1fd84b06d59/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f5772616d626572672f616461707466696c742f6d61737465722f6578616d706c65732f6563686f63616e63656c2d696e7075742e706e67\">\n<img alt=\"https://raw.githubusercontent.com/Wramberg/adaptfilt/master/examples/echocancel-error.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b51702c39eaed3352cd3f756a055549e61da2662/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f5772616d626572672f616461707466696c742f6d61737465722f6578616d706c65732f6563686f63616e63656c2d6572726f722e706e67\">\n<img alt=\"https://raw.githubusercontent.com/Wramberg/adaptfilt/master/examples/echocancel-mswe.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/60998953bf9b15e6b2675a66d71d213283f33929/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f5772616d626572672f616461707466696c742f6d61737465722f6578616d706c65732f6563686f63616e63656c2d6d7377652e706e67\">\n<img alt=\"https://raw.githubusercontent.com/Wramberg/adaptfilt/master/examples/echocancel-coeffs.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/322d9e3df6af4f5af4a870bf6be29261f1eeee53/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f5772616d626572672f616461707466696c742f6d61737465722f6578616d706c65732f6563686f63616e63656c2d636f656666732e706e67\">\n</div>\n<div id=\"convergence-comparison\">\n<h3>Convergence comparison</h3>\n<pre>\"\"\"\nConvergence comparison of different adaptive filtering algorithms (with\ndifferent step sizes) in white Gaussian noise.\n\"\"\"\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport adaptfilt as adf\n\n# Generating input and desired signal\nN = 3000\ncoeffs = np.concatenate(([-4, 3.2], np.zeros(20), [0.7], np.zeros(33), [-0.1]))\nu = np.random.randn(N)\nd = np.convolve(u, coeffs)\n\n# Perform filtering\nM = 60  # No. of taps to estimate\nmu1 = 0.0008  # Step size 1 in LMS\nmu2 = 0.0004  # Step size 1 in LMS\nbeta1 = 0.08  # Step size 2 in NLMS and AP\nbeta2 = 0.04  # Step size 2 in NLMS and AP\nK = 3  # Projection order 1 in AP\n\n# LMS\ny_lms1, e_lms1, w_lms1 = adf.lms(u, d, M, mu1, returnCoeffs=True)\ny_lms2, e_lms2, w_lms2 = adf.lms(u, d, M, mu2, returnCoeffs=True)\nmswe_lms1 = adf.mswe(w_lms1, coeffs)\nmswe_lms2 = adf.mswe(w_lms2, coeffs)\n\n# NLMS\ny_nlms1, e_nlms1, w_nlms1 = adf.nlms(u, d, M, beta1, returnCoeffs=True)\ny_nlms2, e_nlms2, w_nlms2 = adf.nlms(u, d, M, beta2, returnCoeffs=True)\nmswe_nlms1 = adf.mswe(w_nlms1, coeffs)\nmswe_nlms2 = adf.mswe(w_nlms2, coeffs)\n\n# AP\ny_ap1, e_ap1, w_ap1 = adf.ap(u, d, M, beta1, K, returnCoeffs=True)\ny_ap2, e_ap2, w_ap2 = adf.ap(u, d, M, beta2, K, returnCoeffs=True)\nmswe_ap1 = adf.mswe(w_ap1, coeffs)\nmswe_ap2 = adf.mswe(w_ap2, coeffs)\n\n# Plot results\nplt.figure()\nplt.title('Convergence comparison of different adaptive filtering algorithms')\nplt.plot(mswe_lms1, 'b', label='LMS with stepsize=%.4f' % mu1)\nplt.plot(mswe_lms2, 'b--', label='LMS with stepsize=%.4f' % mu2)\nplt.plot(mswe_nlms1, 'g', label='NLMS with stepsize=%.2f' % beta1)\nplt.plot(mswe_nlms2, 'g--', label='NLMS with stepsize=%.2f' % beta2)\nplt.plot(mswe_ap1, 'r', label='AP with stepsize=%.2f' % beta1)\nplt.plot(mswe_ap2, 'r--', label='AP with stepsize=%.2f' % beta2)\nplt.legend()\nplt.grid()\nplt.xlabel('Iterations')\nplt.ylabel('Mean-squared weight error')\nplt.show()\n</pre>\n<img alt=\"https://raw.githubusercontent.com/Wramberg/adaptfilt/master/examples/convergence-result.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/dfd61c26e6d3c428279e4780f9826b263127868b/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f5772616d626572672f616461707466696c742f6d61737465722f6578616d706c65732f636f6e76657267656e63652d726573756c742e706e67\">\n</div>\n</div>\n<div id=\"release-history\">\n<h2>Release History</h2>\n<div id=\"id1\">\n<h3>0.2</h3>\n<div>\n<div>Included NLMS filtering function with recursive updates of input energy.</div>\n<div>Included acoustic echo cancellation example</div>\n</div>\n</div>\n<div id=\"id2\">\n<h3>0.1</h3>\n<div>\n<div>Initial module with LMS, NLMS and AP filtering functions.</div>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1308353, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "6b5d1f07140d2de7af93091674559636", "sha256": "81f86fe55670ea3b7d6d7df0f5f88333dc6ad1a7e45996729b696ba8d340bac6"}, "downloads": -1, "filename": "adaptfilt-0.1.tar.gz", "has_sig": false, "md5_digest": "6b5d1f07140d2de7af93091674559636", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8591, "upload_time": "2014-11-07T13:47:55", "upload_time_iso_8601": "2014-11-07T13:47:55.209781Z", "url": "https://files.pythonhosted.org/packages/de/45/57411a8e05b95248772c50f7007f171c50baeeeabb6aeee12b3714c97946/adaptfilt-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "d6ff2b129d00a4d4caab63b147a75f7b", "sha256": "4d339d09f2efcd48d22adef14582c36df40859e44f92b5d3a4bd5999d2f05657"}, "downloads": -1, "filename": "adaptfilt-0.2.tar.gz", "has_sig": false, "md5_digest": "d6ff2b129d00a4d4caab63b147a75f7b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1011526, "upload_time": "2014-11-13T11:21:43", "upload_time_iso_8601": "2014-11-13T11:21:43.710281Z", "url": "https://files.pythonhosted.org/packages/e1/53/90d8b76c783fcf535854538b9abc0f2d65afadcfc6f96e0e90d9fb2b7c17/adaptfilt-0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d6ff2b129d00a4d4caab63b147a75f7b", "sha256": "4d339d09f2efcd48d22adef14582c36df40859e44f92b5d3a4bd5999d2f05657"}, "downloads": -1, "filename": "adaptfilt-0.2.tar.gz", "has_sig": false, "md5_digest": "d6ff2b129d00a4d4caab63b147a75f7b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1011526, "upload_time": "2014-11-13T11:21:43", "upload_time_iso_8601": "2014-11-13T11:21:43.710281Z", "url": "https://files.pythonhosted.org/packages/e1/53/90d8b76c783fcf535854538b9abc0f2d65afadcfc6f96e0e90d9fb2b7c17/adaptfilt-0.2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:23:37 2020"}