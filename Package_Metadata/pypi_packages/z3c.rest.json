{"info": {"author": "Stephan Richter and the Zope Community", "author_email": "zope3-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Internet :: WWW/HTTP"], "description": "This package provides a framework to build REST APIs on top of Zope 3.\n\n\nDetailed Documentation\n**********************\n\n===================================================\nA Framework for Building RESTive Services in Zope 3\n===================================================\n\nThis package implements several components that relate to building RESTive Web\nservices using the Zope publisher. Each set of components is documented in a\ncorresponding text file.\n\n* ``client.txt`` [must read]\n\n  This package also provides a REST Web client, which can be used for testing\n  or for accessing a RESTive API within an application.\n\n* ``null.txt`` [advanced user]\n\n  In order to create new resources, the publisher must be able to traverse to\n  resources/objects that do not yet exist. This file explains how those null\n  resources work.\n\n* ``traverser.txt`` [advanced user]\n\n  The ``traverser`` module contains several traversal helper components for\n  common traversal scenarios, suhc as containers and null resources.\n\n* ``rest.txt`` [informative]\n\n  This document introduces the hooks required to manage RESTive requests in\n  the publisher. It also discusses hwo those components are used by the\n  publisher.\n\n===========\nREST Client\n===========\n\nThe REST client provides a simple Python API to interact easily with RESTive\nWeb services. It was designed to have a similar API to Zope's test\nbrowser.\n\nLet's start by instantiating the the client. Of course we have a version of\nthe client that talks directly to the Zope publisher:\n\n  >>> from z3c.rest import testing\n  >>> client = testing.RESTClient()\n\nFor testing purposes, we have defined a simple REST API for folders. The\nsimplest call is to retrieve the contents of the root folder:\n\n  >>> client.open('http://localhost/')\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <title></title>\n    <items>\n    </items>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nYou can also instantiate the client providing a URL:\n\n  >>> client = testing.RESTClient('http://localhost/')\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <title></title>\n    <items>\n    </items>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nHTTPS URLs are also supported\n\n  >>> client = testing.RESTClient('https://localhost/')\n  Using SSL\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <title></title>\n    <items>\n    </items>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\n\nGetting Resources\n-----------------\n\nThe ``open()`` method implicitely uses the \"GET\" HTTP method. An alternative\nwould be to use this:\n\n  >>> client.get('http://localhost/')\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <title></title>\n    <items>\n    </items>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nThere are several other pieces of information of the response that are\navailable:\n\n  >>> client.url\n  'http://localhost/'\n  >>> client.status\n  200\n  >>> client.reason\n  'Ok'\n  >>> client.fullStatus\n  '200 Ok'\n  >>> client.headers\n  [('X-Powered-By', 'Zope (www.zope.org), Python (www.python.org)'),\n   ('Content-Length', '204'),\n   ('Content-Type', 'text/xml;charset=utf-8')]\n\nIf we try to access a non-existent resource, no exception is raised, but the\nstatus is '404' (not found) of course:\n\n  >>> client.get('http://localhost/unknown')\n  >>> client.fullStatus\n  '404 Not Found'\n  >>> client.contents\n  ''\n  >>> client.headers\n  [('X-Powered-By', 'Zope (www.zope.org), Python (www.python.org)'),\n   ('Content-Length', '0')]\n\nAs in the original test browser, I can turn off the Zope error handling and\nthe Python exception will propagate through the publisher:\n\n  >>> client.handleErrors = False\n  >>> client.get('http://localhost/unknown')\n  Traceback (most recent call last):\n  ...\n  NotFound: Object: <zope.site.folder.Folder ...>, name: u'unknown'\n\n  >>> client.handleErrors = True\n\nAs RESTive APIs often use query string key-value pairs to parameterize the\nrequest, this REST client has strong support for it. For example, you can\nsimply specify the parameters in the URL:\n\n  >>> client.get('http://localhost/?noitems=1')\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <title></title>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nYou can also specify the parameter via an argument:\n\n  >>> client.get('http://localhost/', params={'noitems': 1})\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <title></title>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nYou can even combine the two methods of specifying parameters:\n\n  >>> client.get('http://localhost/?noitems=1', params={'notitle': 1})\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nBut our little demo API can do more. Parameters can also be specified as a\nheader with a special prefix. Headers can be globally specified and are then\nused for every request:\n\n  >>> client.requestHeaders['demo-noitems'] = 'on'\n  >>> client.get('http://localhost/')\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <title></title>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nThere is also a headers argument to the \"open\" methods that specify the header\nonce:\n\n  >>> client.get('http://localhost/', headers={'demo-notitle': 1})\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\n  >>> del client.requestHeaders['demo-noitems']\n\nFinally, when dealing with a real site, a socket error might occur. The error\nis propagated, but the error number and message are recorded:\n\n  >>> from z3c.rest.client import RESTClient\n  >>> realClient = RESTClient()\n  >>> realClient.open('http://localhost:65000')\n  Traceback (most recent call last):\n  ...\n  error: (61, 'Connection refused')\n\n  >>> realClient.fullStatus\n  '61 Connection refused'\n\n\nCreating new resources\n----------------------\n\nLet's now create a new resource in the server root. Our little sample\napplication will simply create another collection:\n\n  >>> client.put(\n  ...     'http://localhost/folder1',\n  ...     '''<?xml version=\"1.0\" ?>\n  ...        <folder />''')\n\n  >>> client.fullStatus\n  '401 Unauthorized'\n\nAccessing the folder resource is available to everyone. But if you want to\nmodify any resource, you have to log in:\n\n  >>> client.setCredentials('globalmgr', 'globalmgrpw')\n\nSo let's try this again:\n\n  >>> client.put(\n  ...     'http://localhost/folder1',\n  ...     '''<?xml version=\"1.0\" ?>\n  ...        <folder />''')\n\n  >>> client.fullStatus\n  '201 Created'\n  >>> client.headers\n  [('X-Powered-By', 'Zope (www.zope.org), Python (www.python.org)'),\n   ('Content-Length', '0'),\n   ('Location', 'http://localhost/folder1')]\n\nWe can now look at the root container and see the item there:\n\n  >>> client.get('http://localhost/')\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <title></title>\n    <items>\n      <item xlink:type=\"simple\"\n            xlink:href=\"http://localhost/folder1\"\n            xlink:title=\"folder1\"/>\n    </items>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nBy the way, you can now use a relative URL to access the `folder1` resource:\n\n  >>> client.get('folder1')\n\n  >>> client.url\n  'http://localhost/folder1'\n\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name>folder1</name>\n    <title></title>\n    <items>\n    </items>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nWhen we try to create a resource on top of a non-existent resource, we get a\n404 error:\n\n  >>> client.put(\n  ...     'http://localhost/folder2/folder21',\n  ...     '''<?xml version=\"1.0\" ?>\n  ...        <folder />''')\n\n  >>> client.fullStatus\n  '404 Not Found'\n\n\nModifying Resources\n-------------------\n\nModifying a given resource can be done via POST or PUT, but they have different\nsemantics. Let's have a look at POST first. We would now like to change the\ntitle of the folder; this can be done as follows:\n\n  >>> client.post(\n  ...     'http://localhost/folder1',\n  ...     '''<?xml version=\"1.0\" ?>\n  ...        <folder>\n  ...          <title>My Folder 1</title>\n  ...        </folder>''')\n\n  >>> client.fullStatus\n  '200 Ok'\n\n  >>> client.get()\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name>folder1</name>\n    <title>My Folder 1</title>\n    <items>\n    </items>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nAs mentioned above, it must also work for PUT:\n\n  >>> client.put(\n  ...     'http://localhost/folder1',\n  ...     '''<?xml version=\"1.0\" ?>\n  ...        <folder>\n  ...          <title>Folder 1</title>\n  ...        </folder>''')\n\n  >>> client.fullStatus\n  '200 Ok'\n\n  >>> client.get()\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name>folder1</name>\n    <title>Folder 1</title>\n    <items>\n    </items>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\n\nDeleting Resources\n------------------\n\nDeleting a resource is as simple as all of the other methods. Let's delete our\n`folder1`:\n\n  >>> client.delete('http://localhost/folder1')\n\n  >>> client.fullStatus\n  '200 Ok'\n\nSo the resource is really gone:\n\n  >>> client.get()\n  >>> client.fullStatus\n  '404 Not Found'\n\nIt should not be possible to delete a non-existing resource:\n\n  >>> client.delete('http://localhost/folder2')\n  >>> client.fullStatus\n  '404 Not Found'\n\nAlso, we cannot delete the root folder:\n\n  >>> client.delete('http://localhost/')\n  >>> client.fullStatus\n  '405 Method Not Allowed'\n\n\nSearching the Response Data\n---------------------------\n\nWhile not required, most REST services are XML-based. Thus, the client\nsupports inspecting the result XML using XPath. Let's create a couple of\nfolders for this to be more interesting:\n\n  >>> client.put(\n  ...     'http://localhost/folder1',\n  ...     '''<?xml version=\"1.0\" ?>\n  ...        <folder />''')\n\n  >>> client.put(\n  ...     'http://localhost/folder2',\n  ...     '''<?xml version=\"1.0\" ?>\n  ...        <folder />''')\n\nNext we get the root folder resource:\n\n  >>> client.get('http://localhost/')\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <title></title>\n    <items>\n      <item xlink:type=\"simple\"\n            xlink:href=\"http://localhost/folder1\"\n            xlink:title=\"folder1\"/>\n      <item xlink:type=\"simple\"\n            xlink:href=\"http://localhost/folder2\"\n            xlink:title=\"folder2\"/>\n    </items>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nBut in general, inspecting the XML output on the string level is tedious. So\nlet's write a cool XPath expression that extracts the xlink title of all\nitems:\n\n  >>> nsmap = {'xlink': \"http://www.w3.org/1999/xlink\"}\n  >>> client.xpath('//folder/items/item/@xlink:title', nsmap)\n  ['folder1', 'folder2']\n\nOftentimes, however, we specifically query for one result. In those cases we\ndo not want to receive a list:\n\n  >>> client.xpath('//folder/items/item[@xlink:title=\"folder1\"]', nsmap, True)\n  <Element item ...>\n\nNow, if multiple matches are detected, even though we only expect one, then a\n``ValueError`` is raised:\n\n  >>> client.xpath('//folder/items/item', nsmap, True)\n  Traceback (most recent call last):\n  ...\n  ValueError: XPath expression returned more than one result.\n\n\nAccessing Links\n---------------\n\nSince we want the REST client to behave like a browser -- at least a little\nbit -- we can also use the ``getLink()`` method to access links:\n\n  >>> client.getLink('folder1')\n  <XLink title='folder1' url='http://localhost/folder1'>\n\nBy default, the link is looked up by title. But you can also look it up by\nURL:\n\n  >>> client.getLink(url='http://localhost/folder1')\n  <XLink title='folder1' url='http://localhost/folder1'>\n\nIf you forget to specify a title or URL, you receive a ``ValueError``:\n\n  >>> client.getLink()\n  Traceback (most recent call last):\n  ...\n  ValueError: You must specify a title or URL.\n\nLinks can also be relative, such as the one for ACL:\n\n  >>> client.open('http://localhost/folder1')\n  >>> client.getLink('ACL')\n  <XLink title='ACL' url='http://localhost/folder1/acl'>\n\n  >>> client.open('http://localhost/folder1/')\n  >>> client.getLink('ACL')\n  <XLink title='ACL' url='http://localhost/folder1/acl'>\n\nThe cool part about the link is that you can click it:\n\n  >>> client.open('http://localhost/')\n  >>> client.url\n  'http://localhost/'\n\n  >>> client.getLink('folder1').click()\n\n  >>> client.url\n  'http://localhost/folder1'\n\n\nMoving through time\n-------------------\n\nLike in a real browser, you can go back to a previous state. For example,\ncurrently we are looking at `folder1`, ...\n\n  >>> client.url\n  'http://localhost/folder1'\n\nbut if I go back one step, I am back at the root folder:\n\n  >>> client.goBack()\n\n  >>> client.url\n  'http://localhost/'\n\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <title></title>\n    <items>\n      <item xlink:type=\"simple\"\n            xlink:href=\"http://localhost/folder1\"\n            xlink:title=\"folder1\"/>\n      <item xlink:type=\"simple\"\n            xlink:href=\"http://localhost/folder2\"\n            xlink:title=\"folder2\"/>\n    </items>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nBut going back in history is only cool, if you can also reload. So let's\ndelete `folder2`:\n\n  >>> client.getLink('folder2').click()\n  >>> client.delete()\n\nNow we go back 2 steps:\n\n  >>> client.goBack(2)\n\n  >>> client.url\n  'http://localhost/'\n\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <title></title>\n    <items>\n      <item xlink:type=\"simple\"\n            xlink:href=\"http://localhost/folder1\"\n            xlink:title=\"folder1\"/>\n      <item xlink:type=\"simple\"\n            xlink:href=\"http://localhost/folder2\"\n            xlink:title=\"folder2\"/>\n    </items>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nAs expected, the contents has not changed yet. So let's reload:\n\n  >>> client.reload()\n\n  >>> client.url\n  'http://localhost/'\n\n  >>> print client.contents\n  <?xml version=\"1.0\" ?>\n  <folder xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <name></name>\n    <title></title>\n    <items>\n      <item xlink:type=\"simple\"\n            xlink:href=\"http://localhost/folder1\"\n            xlink:title=\"folder1\"/>\n    </items>\n    <acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/>\n  </folder>\n\nNote that going back zero steps does nothing:\n\n  >>> client.url\n  'http://localhost/'\n\n  >>> client.getLink('folder1').click()\n  >>> client.goBack(0)\n\n  >>> client.url\n  'http://localhost/folder1'\n\nAlso, if you try to go back beyond the beginning of time, a value error is\nraised:\n\n  >>> client.goBack(1000)\n  Traceback (most recent call last):\n  ...\n  ValueError: There is not enough history.\n\n\nAbsolute URLs\n-------------\n\nAs mentioned above, we allow specifying relative URLs, a call with an absolute\nURL has been made. A function called ``absoluteURL()`` is used to compute the\nnew absolute URL.\n\n  >>> from z3c.rest.client import absoluteURL\n\nThe basic functionality is simple:\n\n  >>> absoluteURL('http://localhost/folder1/', 'folder11')\n  'http://localhost/folder1/folder11'\n\nIt also detects, if the new part of the URL is absolute, in which case it\nreplaces the original base URL:\n\n  >>> absoluteURL('http://einstein/folder1', 'http://localhost/folder11')\n  'http://localhost/folder11'\n\nIf the base URL does not have a trailing slash, it is added automatically:\n\n  >>> absoluteURL('http://localhost/folder1', 'folder11')\n  'http://localhost/folder1/folder11'\n\nAny slashes at the end of the new URL are preserved:\n\n  >>> absoluteURL('http://localhost/folder1', 'folder11/')\n  'http://localhost/folder1/folder11/'\n\n  >>> absoluteURL('http://einstein/folder1', 'http://localhost/folder11/')\n  'http://localhost/folder11/'\n\nThe function also handles more complex URLs containing a query string\ncorrectly:\n\n  >>> absoluteURL('http://localhost/folder1', 'folder11?max=1')\n  'http://localhost/folder1/folder11?max=1'\n\n  >>> absoluteURL('http://localhost/folder1', 'folder11/?max=1')\n  'http://localhost/folder1/folder11/?max=1'\n\nIf the base URL contains a query string, the resulting URL will as well:\n\n  >>> absoluteURL('http://localhost/folder1?max=1', 'folder11/')\n  'http://localhost/folder1/folder11/?max=1'\n\n  >>> absoluteURL('http://localhost/folder1/?max=1', 'folder11/')\n  'http://localhost/folder1/folder11/?max=1'\n\n  >>> absoluteURL('http://localhost/folder1?max=1', 'folder11')\n  'http://localhost/folder1/folder11?max=1'\n\n  >>> absoluteURL('http://localhost/folder1/?max=1', 'folder11')\n  'http://localhost/folder1/folder11?max=1'\n\nIf both, the base and relative URL provide query strings, they are merged:\n\n  >>> absoluteURL('http://localhost/folder1/?max=1', 'folder11?min=0')\n  'http://localhost/folder1/folder11?max=1&min=0'\n\n  >>> absoluteURL('http://localhost/folder1/?max=1', 'folder11?min=0&start=0')\n  'http://localhost/folder1/folder11?max=1&min=0&start=0'\n\n  >>> absoluteURL('http://localhost/folder1/?max=1&start=0', 'folder11?min=0')\n  'http://localhost/folder1/folder11?max=1&start=0&min=0'\n\n\n==============\nNull Resources\n==============\n\nIt is sometimes necessary to traverse to resources that do not yet exist. In\nparticular, this is needed when creating resources using \"PUT\" or \"POST\". It\nis the responsibility of the traverser to handle those cases correctly and\nproduce the null resources. This document only describes their behavior.\n\nA null resource is easily instantiated using the container and the name of the\nresource:\n\n  >>> class Folder(object):\n  ...     __parent__ = __name__ = None\n  ...     child = None\n  ...\n  ...     def __init__(self, name=''):\n  ...         self.name = self.__name__ = name\n  ...\n  ...     def __repr__(self):\n  ...         return '<Folder %r>' %self.name\n  >>> folder = Folder()\n\n  >>> from z3c.rest import null\n  >>> resource = null.NullResource(folder, 'resource')\n\n  >>> from zope.app.http.interfaces import INullResource\n  >>> INullResource.providedBy(resource)\n  True\n\nNull resources are locations, so security is available:\n\n  >>> from zope.location.interfaces import ILocation\n  >>> ILocation.providedBy(resource)\n  True\n\nThe container is also the parent:\n\n  >>> resource.container\n  <Folder ''>\n  >>> resource.__parent__\n  <Folder ''>\n\nThe name of the resource is available at:\n\n  >>> resource.name\n  'resource'\n  >>> resource.__name__\n  'resource'\n\nThere is a special implementation of \"PUT\" for null resources. It works by\nlooking up a view called \"NullPUT\" for the container. This way, one null\nresource implementation can be used for all container implementations.\n\n  >>> import StringIO\n  >>> from z3c.rest import rest\n  >>> request = rest.RESTRequest(StringIO.StringIO(), {})\n\n  >>> nullPut = null.NullPUT(resource, request)\n  >>> nullPut.PUT()\n\nSince no view called \"NullPUT\" exists for our `Folder` class, we get a 501\nreturn status:\n\n  >>> request.response.getStatusString()\n  '501 Not Implemented'\n\nLet's now register a simple NullPUT view:\n\n  >>> class FolderAPI(rest.RESTView):\n  ...\n  ...     def NullPUT(self, resource):\n  ...         self.context.child = Folder(resource.name)\n  ...         self.context.child.__parent__ = self.context\n  ...         return self.context.child\n\n  >>> import zope.component\n  >>> from z3c.rest import interfaces\n  >>> zope.component.provideAdapter(\n  ...     FolderAPI, (Folder, interfaces.IRESTRequest), name='NullPUT')\n\nLet's make sure our location structure is correctly setup, so that absolute\nURL will work:\n\n  >>> from zope.traversing.interfaces import IContainmentRoot\n  >>> import zope.interface\n  >>> zope.interface.alsoProvides(folder, IContainmentRoot)\n\nNow we are ready to PUT the new resource:\n\n  >>> request = rest.RESTRequest(\n  ...     StringIO.StringIO(), {'SERVER_URL': 'http://localhost/'})\n\n  >>> nullPut = null.NullPUT(resource, request)\n  >>> nullPut.PUT()\n\n  >>> request.response.getStatusString()\n  '201 Created'\n  >>> request.response.getHeader('Location')\n  'http://localhost/resource'\n\n  >>> folder.child\n  <Folder 'resource'>\n\n=========================\nREST Traverser Components\n=========================\n\nBeing able to control and extend traversal is essential to any RESTive\nAPI. This package uses the pluggable traverser implementation of the\n``z3c.traverser`` package to provide a flexible traversal mechanism.\n\n\nREST Pluggable Traverser\n------------------------\n\nThe REST pluggable traverser is registered for all types of components. Its\nimplementation is fully tested in the ``z3c.traverser`` package.\n\n  >>> from z3c.rest import traverser\n\n  >>> import StringIO\n  >>> from z3c.rest import rest\n  >>> request = rest.RESTRequest(StringIO.StringIO(), {})\n\n  >>> pluggable = traverser.RESTPluggableTraverser(object(), request)\n  >>> pluggable\n  <z3c.rest.traverser.RESTPluggableTraverser object at ...>\n\n\nItem Container Traverser Plugin\n-------------------------------\n\nThe item mapping interface -- from which item container inherits -- is the\nmost minimal mapping interface in Python. Thus, once traversing through this\nitem container is implemented, it can be used by all other container\ninterfaces and implementations.\n\nLet's start by creating a very simple item container implementation:\n\n  >>> import zope.interface\n  >>> from zope.app.container.interfaces import IItemContainer\n\n  >>> class SimpleContainer(dict):\n  ...     zope.interface.implements(IItemContainer)\n  ...     def __init__(self, name=''):\n  ...         self.name = name\n  ...     def __repr__(self):\n  ...         return '<Container name=%s>' %self.name\n\n  >>> container = SimpleContainer()\n\n  >>> container['sub1'] = SimpleContainer('sub1')\n  >>> container['sub2'] = SimpleContainer('sub2')\n\nAfter creating a traverser plugin instance,\n\n  >>> request = rest.RESTRequest(StringIO.StringIO(), {})\n\n  >>> containerTraverser = traverser.ContainerItemTraverserPlugin(\n  ...     container, request)\n\nwe can traverse to a sub-object of that container:\n\n  >>> containerTraverser.publishTraverse(request, 'sub1')\n  <Container name=sub1>\n\nIf no proper sub-item can be found, some interesting can happen. In a normal\ncase, ``NotFound`` is raised:\n\n  >>> containerTraverser.publishTraverse(request, 'unknown')\n  Traceback (most recent call last):\n  ...\n  NotFound: Object: <Container name=>, name: 'unknown'\n\nHowever, if the request is a PUT request, we must generate a null resource:\n\n  >>> request.method = 'PUT'\n  >>> containerTraverser.publishTraverse(request, 'unknown')\n  <NullResource 'unknown'>\n\nHowever, a null resource is only created, if the current resource is the last\none in the traversal stack:\n\n  >>> request.setTraversalStack(('sub11',))\n  >>> containerTraverser.publishTraverse(request, 'unknown')\n  Traceback (most recent call last):\n  ...\n  NotFound: Object: <Container name=>, name: 'unknown'\n\nAnd that's it.\n\n=================================\nPublisher Hooks for REST Requests\n=================================\n\nReading this document requires -- to some extend -- that the reader is\nfamiliar with the basic steps of the publication process.\n\n\nThe Publication Request Factory\n-------------------------------\n\nThe Zope publication process starts when a WSGI server sends the request\nenvironment and response initialization callable to the Zope WSGI Publisher\napplication _[1]. The WSGI publisher application is then responsible for\nprocessing the request in the publisher and stream out the result.\n\nIn order to process a request in the publisher, we have to create a valid\npublisher request object. The WSGI publisher application uses a request\nfactory for this purpose. This package implements this factory to ensure that\na special REST request (based on HTTP Request) is created at all times.\n\nThe request factory is instantiated using a ZODB database object:\n\n  >>> from ZODB.DB import DB\n  >>> from ZODB.DemoStorage import DemoStorage\n  >>> db = DB(DemoStorage())\n\nLet's now create the factory:\n\n  >>> from z3c.rest import rest\n  >>> RequestFactory = rest.RESTPublicationRequestFactory(db)\n\nWhen a request comes in from the server, the request is created as follows:\n\n  >>> import StringIO\n  >>> inStream = StringIO.StringIO('Input stream')\n\n  >>> env = {'HTTP_ACCEPT_LANGUAGE': 'en-US,en',\n  ...        'SERVER_URL': 'http://localhost:8080/'}\n\n  >>> request = RequestFactory(inStream, env)\n\nWe now got a valid request that we can send through the publisher:\n\n  >>> request\n  <z3c.rest.rest.RESTRequest instance URL=http://localhost:8080>\n\nThe request, however, is only responsible for representing the network request\nin the publisher and has no direct knowledge of the application. But the\nrequest connects to an application-specific -- in this case Zope 3 --\ncomponent known as the publication.\n\n  >>> request.publication\n  <zope.app.publication.http.HTTPPublication object at ...>\n\nSince we do not need a special REST publication, we are simply reusing the\nmore generic HTTP version. The publication will be the same for all\nrequests. It also contains the reference to the database:\n\n  >>> request.publication.db\n  <ZODB.DB.DB object at ...>\n\nUnfortunately, it takes a lot more setup to send the request through the\npublisher successfully. The publication requires many other aspects of\npublishing to be available, including traversal, security, and a properly\nconstructed database. However, we can still see a failure:\n\n  >>> from zope.publisher import publish\n  >>> publish.publish(request)\n  <z3c.rest.rest.RESTRequest instance URL=http://localhost:8080>\n  >>> print request.response.consumeBody()\n  <?xml version=\"1.0\" ?>\n  <error>\n    <name>ComponentLookupError</name>\n    <explanation>(&lt;InterfaceClass ...IAuthentication&gt;, u'')</explanation>\n  </error>\n\nLet' unwind a bit. Originally, we started with the desire to create a\nPublisher WSGI Application instance that internally uses a REST request. All\nthat you need to do is:\n\n  >>> from zope.app import wsgi\n  >>> app = wsgi.WSGIPublisherApplication(\n  ...     db, rest.RESTPublicationRequestFactory)\n  >>> app\n  <zope.app.wsgi.WSGIPublisherApplication object at ...>\n\nWhen the WSGI server sends a request to the WSGI application, the following\nhappens:\n\n  >>> status = None\n  >>> headers = None\n  >>> def start_response(s, h):\n  ...     global status\n  ...     global headers\n  ...     status, headers = s, h\n\n  >>> wsgiEnv = {'wsgi.input': inStream}\n  >>> wsgiEnv.update(env)\n\n  >>> print '\\n'.join(app(wsgiEnv, start_response))\n  <?xml version=\"1.0\" ?>\n  <error>\n    <name>ComponentLookupError</name>\n    <explanation>(&lt;InterfaceClass ...IAuthentication&gt;, u'')</explanation>\n  </error>\n\n\n.. [1]: ``zope.app.wsgi.WSGIPublisherApplication.__call__``\n\n\nThe REST Request\n----------------\n\nFor most parts, the REST request is identical to the HTTP request, so I won't\ngo into too much detail about the HTTP request API.\n\nThe REST request mainly extends the HTTP request in that it parses the query\nstring of the URL into a set of parameters. This happens during\n``processInputs()``.\n\nIf there is no query string, the paramaters mapping is empty:\n\n  >>> request = RequestFactory(\n  ...     StringIO.StringIO(), {})\n  >>> request.processInputs()\n  >>> request.parameters\n  {}\n\nSo let's now pass a few parameters:\n\n  >>> request = RequestFactory(\n  ...     StringIO.StringIO(),\n  ...     {'QUERY_STRING': 'format=html&action=delete&item=1&item=3'})\n  >>> request.processInputs()\n  >>> pprint(request.parameters)\n  {'action': 'delete',\n   'format': 'html',\n   'item': ['1',\n            '3']}\n\nWe also override some of the request's mapping methods, so that the parameters\nand environment values are available as part of the request:\n\n  >>> sorted(request.keys())\n  ['QUERY_STRING', 'action', 'format', 'item']\n\n  >>> request.get('QUERY_STRING')\n  'format=html&action=delete&item=1&item=3'\n  >>> request.get('action')\n  'delete'\n  >>> request.get('unknwon', 'default')\n  'default'\n\n\nThe REST Response\n-----------------\n\nThe REST Response is pretty much identical to the HTTP Response, except that\nits exception handler returns XML instead of HTML. This method, however, is\nonly used for classic and string exceptions.\n\nStarting with a response, ...\n\n  >>> response = rest.RESTResponse()\n\n... we can now call the handler:\n\n  >>> class MyException(Exception):\n  ...     pass\n\n  >>> response.handleException((MyException, MyException(), None))\n  >>> response._status\n  500\n  >>> response._reason\n  'Internal Server Error'\n  >>> print '\\n'.join(response._result)\n  <?xml version=\"1.0\" ?>\n  <error>\n    <name>MyException</name>\n    <explanation></explanation>\n  </error>\n\nLet's try a string exception too:\n\n  >>> response.handleException(('StringException', 'Some details', None))\n  >>> response._status\n  500\n  >>> response._reason\n  'Internal Server Error'\n  >>> print '\\n'.join(response._result)\n  <?xml version=\"1.0\" ?>\n  <error>\n    <name>StringException</name>\n    <explanation>Some details</explanation>\n  </error>\n\nThe `Redirect` exception is special. It actuaually causes the request to be\nredirected.\n\n  >>> response._request = rest.RESTRequest(None, {})\n\n  >>> from zope.publisher.interfaces import Redirect\n  >>> response.handleException(\n  ...     (Redirect, Redirect('http://localhost'), None), trusted=True)\n  >>> response._status\n  302\n  >>> response._reason\n  'Moved Temporarily'\n  >>> response._headers['location']\n  ['http://localhost']\n\n\nREST Views\n----------\n\nUnlike browser views, a REST view does *not* represent its own sub-resource\n(such as \"index.html\"). Instead it merely defines the behavior of the HTTP\nmethods for a particular content component.\n\nHere is an example:\n\n  >>> class ObjectAPI(rest.RESTView):\n  ...\n  ...     def GET(self):\n  ...          return str(self.context)\n\nThe ``RESTView`` base class provides a suitable constructor:\n\n  >>> class Object(object):\n  ...     def __repr__(self):\n  ...         return '<Object>'\n  >>> myobj = Object()\n\n  >>> request = RequestFactory(\n  ...     StringIO.StringIO(), {'SERVER_URL': 'http://localhost:8080/myobj'})\n\n  >>> view = ObjectAPI(myobj, request)\n\nWhen the publisher traverses to `myobj`, it will look up a view based on the\nHTTP mehtod, such as \"GET\". It then also expects to find a method of that same\nname and calls it _[2].\n\n  >>> view.GET()\n  '<Object>'\n\nThe REST View, like all other views, exposes its context and the request:\n\n  >>> view.context\n  <Object>\n  >>> view.request\n  <z3c.rest.rest.RESTRequest instance URL=http://localhost:8080/myobj>\n\nAlso, a view must be located, so it has a parent as well:\n\n  >>> view.__parent__\n  <Object>\n\nYou can set it to something else of course:\n\n  >>> view.__parent__ = 1\n  >>> view.__parent__\n  1\n\n.. [2]: ``zope.app.publication.HTTPPublication.callObject``\n\n\n=======\nCHANGES\n=======\n\n0.4.0 (2010-10-05)\n------------------\n\n- Added undeclared but necessary install dependency on `zope.app.http`.\n\n0.3.0 (2010-10-05)\n------------------\n\n- Added not declared test dependencies.\n\n- Updated test set up and fixed tests to run with ZTK 1.0.\n\n- Using Python's ``doctest`` module instead of depreacted\n  ``zope.testing.doctest``.\n\n\n0.2.5 (2008-09-16)\n------------------\n\n- Bug/Misfeature: Finally get handling of URL merging working as desired. Also\n  added extensive tests to document the behavior.\n\n\n0.2.4 (2008-09-04)\n------------------\n\n- RESTClient() now correctly interprets `https://` URLs.\n\n\n0.2.3 (2008-03-20)\n------------------\n\n- Bug/Misfeature: Sigh, getting the trailing slash handled correctly turned\n  out to be a big pain. I really hope I got it working the way it should be\n  for a REST client now.\n\n\n0.2.2 (2008-03-19)\n------------------\n\n- Bug/Misfeature: The client always added a slash to the end of the URL. But\n  some REST APIs are very sensitive to this. Now the slash is only preserved\n  if present, but nothing will be added otherwise.\n\n\n0.2.1 (2008-03-06)\n------------------\n\n- Bug: Sometimes the response body was not read and the contents of the client\n  was empty. Unfortunately, this problem could not be reliably reproduced, but\n  debugging showed that the connection was closed to early. (Roy Mathew)\n\n- Feature: Make the package Python 2.4 and 2.5 compatible.\n\n- Feature: Require lxml 2.0 for z3c.rest.\n\n\n0.2.0 (2008-03-03)\n------------------\n\n- Feature: Made the HTTP caller pluggable for the REST client, allowing\n  request types other than ``RESTRequest``.\n\n\n0.1.0 (2008-03-03)\n------------------\n\n- Initial Release\n\n  * Publisher hooks to build dedicated REST servers\n\n  * Error view support\n\n  * Pluggable REST traverser based on `z3c.traverser`\n\n  * REST client\n\n  * Minimal sample application", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://cheeseshop.python.org/pypi/z3c.rest", "keywords": "zope3 form widget", "license": "ZPL 2.1", "maintainer": null, "maintainer_email": null, "name": "z3c.rest", "package_url": "https://pypi.org/project/z3c.rest/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/z3c.rest/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://cheeseshop.python.org/pypi/z3c.rest"}, "release_url": "https://pypi.org/project/z3c.rest/0.4.0/", "requires_dist": null, "requires_python": null, "summary": "A REST Framework for Zope 3 Applications", "version": "0.4.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This package provides a framework to build REST APIs on top of Zope 3.</p>\n<div id=\"detailed-documentation\">\n<h2>Detailed Documentation</h2>\n<div id=\"a-framework-for-building-restive-services-in-zope-3\">\n<h3>A Framework for Building RESTive Services in Zope 3</h3>\n<p>This package implements several components that relate to building RESTive Web\nservices using the Zope publisher. Each set of components is documented in a\ncorresponding text file.</p>\n<ul>\n<li><p><tt>client.txt</tt> [must read]</p>\n<p>This package also provides a REST Web client, which can be used for testing\nor for accessing a RESTive API within an application.</p>\n</li>\n<li><p><tt>null.txt</tt> [advanced user]</p>\n<p>In order to create new resources, the publisher must be able to traverse to\nresources/objects that do not yet exist. This file explains how those null\nresources work.</p>\n</li>\n<li><p><tt>traverser.txt</tt> [advanced user]</p>\n<p>The <tt>traverser</tt> module contains several traversal helper components for\ncommon traversal scenarios, suhc as containers and null resources.</p>\n</li>\n<li><p><tt>rest.txt</tt> [informative]</p>\n<p>This document introduces the hooks required to manage RESTive requests in\nthe publisher. It also discusses hwo those components are used by the\npublisher.</p>\n</li>\n</ul>\n</div>\n<div id=\"rest-client\">\n<h3>REST Client</h3>\n<p>The REST client provides a simple Python API to interact easily with RESTive\nWeb services. It was designed to have a similar API to Zope\u2019s test\nbrowser.</p>\n<p>Let\u2019s start by instantiating the the client. Of course we have a version of\nthe client that talks directly to the Zope publisher:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.rest import testing\n&gt;&gt;&gt; client = testing.RESTClient()\n</pre>\n</blockquote>\n<p>For testing purposes, we have defined a simple REST API for folders. The\nsimplest call is to retrieve the contents of the root folder:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.open('http://localhost/')\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;items&gt;\n  &lt;/items&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>You can also instantiate the client providing a URL:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client = testing.RESTClient('http://localhost/')\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;items&gt;\n  &lt;/items&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>HTTPS URLs are also supported</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client = testing.RESTClient('https://localhost/')\nUsing SSL\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;items&gt;\n  &lt;/items&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<div id=\"getting-resources\">\n<h4>Getting Resources</h4>\n<p>The <tt>open()</tt> method implicitely uses the \u201cGET\u201d HTTP method. An alternative\nwould be to use this:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.get('http://localhost/')\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;items&gt;\n  &lt;/items&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>There are several other pieces of information of the response that are\navailable:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.url\n'http://localhost/'\n&gt;&gt;&gt; client.status\n200\n&gt;&gt;&gt; client.reason\n'Ok'\n&gt;&gt;&gt; client.fullStatus\n'200 Ok'\n&gt;&gt;&gt; client.headers\n[('X-Powered-By', 'Zope (www.zope.org), Python (www.python.org)'),\n ('Content-Length', '204'),\n ('Content-Type', 'text/xml;charset=utf-8')]\n</pre>\n</blockquote>\n<p>If we try to access a non-existent resource, no exception is raised, but the\nstatus is \u2018404\u2019 (not found) of course:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.get('http://localhost/unknown')\n&gt;&gt;&gt; client.fullStatus\n'404 Not Found'\n&gt;&gt;&gt; client.contents\n''\n&gt;&gt;&gt; client.headers\n[('X-Powered-By', 'Zope (www.zope.org), Python (www.python.org)'),\n ('Content-Length', '0')]\n</pre>\n</blockquote>\n<p>As in the original test browser, I can turn off the Zope error handling and\nthe Python exception will propagate through the publisher:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.handleErrors = False\n&gt;&gt;&gt; client.get('http://localhost/unknown')\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;zope.site.folder.Folder ...&gt;, name: u'unknown'\n</pre>\n<pre>&gt;&gt;&gt; client.handleErrors = True\n</pre>\n</blockquote>\n<p>As RESTive APIs often use query string key-value pairs to parameterize the\nrequest, this REST client has strong support for it. For example, you can\nsimply specify the parameters in the URL:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.get('http://localhost/?noitems=1')\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>You can also specify the parameter via an argument:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.get('http://localhost/', params={'noitems': 1})\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>You can even combine the two methods of specifying parameters:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.get('http://localhost/?noitems=1', params={'notitle': 1})\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>But our little demo API can do more. Parameters can also be specified as a\nheader with a special prefix. Headers can be globally specified and are then\nused for every request:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.requestHeaders['demo-noitems'] = 'on'\n&gt;&gt;&gt; client.get('http://localhost/')\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>There is also a headers argument to the \u201copen\u201d methods that specify the header\nonce:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.get('http://localhost/', headers={'demo-notitle': 1})\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n<pre>&gt;&gt;&gt; del client.requestHeaders['demo-noitems']\n</pre>\n</blockquote>\n<p>Finally, when dealing with a real site, a socket error might occur. The error\nis propagated, but the error number and message are recorded:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.rest.client import RESTClient\n&gt;&gt;&gt; realClient = RESTClient()\n&gt;&gt;&gt; realClient.open('http://localhost:65000')\nTraceback (most recent call last):\n...\nerror: (61, 'Connection refused')\n</pre>\n<pre>&gt;&gt;&gt; realClient.fullStatus\n'61 Connection refused'\n</pre>\n</blockquote>\n</div>\n<div id=\"creating-new-resources\">\n<h4>Creating new resources</h4>\n<p>Let\u2019s now create a new resource in the server root. Our little sample\napplication will simply create another collection:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.put(\n...     'http://localhost/folder1',\n...     '''&lt;?xml version=\"1.0\" ?&gt;\n...        &lt;folder /&gt;''')\n</pre>\n<pre>&gt;&gt;&gt; client.fullStatus\n'401 Unauthorized'\n</pre>\n</blockquote>\n<p>Accessing the folder resource is available to everyone. But if you want to\nmodify any resource, you have to log in:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.setCredentials('globalmgr', 'globalmgrpw')\n</pre>\n</blockquote>\n<p>So let\u2019s try this again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.put(\n...     'http://localhost/folder1',\n...     '''&lt;?xml version=\"1.0\" ?&gt;\n...        &lt;folder /&gt;''')\n</pre>\n<pre>&gt;&gt;&gt; client.fullStatus\n'201 Created'\n&gt;&gt;&gt; client.headers\n[('X-Powered-By', 'Zope (www.zope.org), Python (www.python.org)'),\n ('Content-Length', '0'),\n ('Location', 'http://localhost/folder1')]\n</pre>\n</blockquote>\n<p>We can now look at the root container and see the item there:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.get('http://localhost/')\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;items&gt;\n    &lt;item xlink:type=\"simple\"\n          xlink:href=\"http://localhost/folder1\"\n          xlink:title=\"folder1\"/&gt;\n  &lt;/items&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>By the way, you can now use a relative URL to access the <cite>folder1</cite> resource:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.get('folder1')\n</pre>\n<pre>&gt;&gt;&gt; client.url\n'http://localhost/folder1'\n</pre>\n<pre>&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;folder1&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;items&gt;\n  &lt;/items&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>When we try to create a resource on top of a non-existent resource, we get a\n404 error:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.put(\n...     'http://localhost/folder2/folder21',\n...     '''&lt;?xml version=\"1.0\" ?&gt;\n...        &lt;folder /&gt;''')\n</pre>\n<pre>&gt;&gt;&gt; client.fullStatus\n'404 Not Found'\n</pre>\n</blockquote>\n</div>\n<div id=\"modifying-resources\">\n<h4>Modifying Resources</h4>\n<p>Modifying a given resource can be done via POST or PUT, but they have different\nsemantics. Let\u2019s have a look at POST first. We would now like to change the\ntitle of the folder; this can be done as follows:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.post(\n...     'http://localhost/folder1',\n...     '''&lt;?xml version=\"1.0\" ?&gt;\n...        &lt;folder&gt;\n...          &lt;title&gt;My Folder 1&lt;/title&gt;\n...        &lt;/folder&gt;''')\n</pre>\n<pre>&gt;&gt;&gt; client.fullStatus\n'200 Ok'\n</pre>\n<pre>&gt;&gt;&gt; client.get()\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;folder1&lt;/name&gt;\n  &lt;title&gt;My Folder 1&lt;/title&gt;\n  &lt;items&gt;\n  &lt;/items&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>As mentioned above, it must also work for PUT:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.put(\n...     'http://localhost/folder1',\n...     '''&lt;?xml version=\"1.0\" ?&gt;\n...        &lt;folder&gt;\n...          &lt;title&gt;Folder 1&lt;/title&gt;\n...        &lt;/folder&gt;''')\n</pre>\n<pre>&gt;&gt;&gt; client.fullStatus\n'200 Ok'\n</pre>\n<pre>&gt;&gt;&gt; client.get()\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;folder1&lt;/name&gt;\n  &lt;title&gt;Folder 1&lt;/title&gt;\n  &lt;items&gt;\n  &lt;/items&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"deleting-resources\">\n<h4>Deleting Resources</h4>\n<p>Deleting a resource is as simple as all of the other methods. Let\u2019s delete our\n<cite>folder1</cite>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.delete('http://localhost/folder1')\n</pre>\n<pre>&gt;&gt;&gt; client.fullStatus\n'200 Ok'\n</pre>\n</blockquote>\n<p>So the resource is really gone:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.get()\n&gt;&gt;&gt; client.fullStatus\n'404 Not Found'\n</pre>\n</blockquote>\n<p>It should not be possible to delete a non-existing resource:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.delete('http://localhost/folder2')\n&gt;&gt;&gt; client.fullStatus\n'404 Not Found'\n</pre>\n</blockquote>\n<p>Also, we cannot delete the root folder:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.delete('http://localhost/')\n&gt;&gt;&gt; client.fullStatus\n'405 Method Not Allowed'\n</pre>\n</blockquote>\n</div>\n<div id=\"searching-the-response-data\">\n<h4>Searching the Response Data</h4>\n<p>While not required, most REST services are XML-based. Thus, the client\nsupports inspecting the result XML using XPath. Let\u2019s create a couple of\nfolders for this to be more interesting:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.put(\n...     'http://localhost/folder1',\n...     '''&lt;?xml version=\"1.0\" ?&gt;\n...        &lt;folder /&gt;''')\n</pre>\n<pre>&gt;&gt;&gt; client.put(\n...     'http://localhost/folder2',\n...     '''&lt;?xml version=\"1.0\" ?&gt;\n...        &lt;folder /&gt;''')\n</pre>\n</blockquote>\n<p>Next we get the root folder resource:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.get('http://localhost/')\n&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;items&gt;\n    &lt;item xlink:type=\"simple\"\n          xlink:href=\"http://localhost/folder1\"\n          xlink:title=\"folder1\"/&gt;\n    &lt;item xlink:type=\"simple\"\n          xlink:href=\"http://localhost/folder2\"\n          xlink:title=\"folder2\"/&gt;\n  &lt;/items&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>But in general, inspecting the XML output on the string level is tedious. So\nlet\u2019s write a cool XPath expression that extracts the xlink title of all\nitems:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; nsmap = {'xlink': \"http://www.w3.org/1999/xlink\"}\n&gt;&gt;&gt; client.xpath('//folder/items/item/@xlink:title', nsmap)\n['folder1', 'folder2']\n</pre>\n</blockquote>\n<p>Oftentimes, however, we specifically query for one result. In those cases we\ndo not want to receive a list:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.xpath('//folder/items/item[@xlink:title=\"folder1\"]', nsmap, True)\n&lt;Element item ...&gt;\n</pre>\n</blockquote>\n<p>Now, if multiple matches are detected, even though we only expect one, then a\n<tt>ValueError</tt> is raised:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.xpath('//folder/items/item', nsmap, True)\nTraceback (most recent call last):\n...\nValueError: XPath expression returned more than one result.\n</pre>\n</blockquote>\n</div>\n<div id=\"accessing-links\">\n<h4>Accessing Links</h4>\n<p>Since we want the REST client to behave like a browser \u2013 at least a little\nbit \u2013 we can also use the <tt>getLink()</tt> method to access links:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.getLink('folder1')\n&lt;XLink title='folder1' url='http://localhost/folder1'&gt;\n</pre>\n</blockquote>\n<p>By default, the link is looked up by title. But you can also look it up by\nURL:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.getLink(url='http://localhost/folder1')\n&lt;XLink title='folder1' url='http://localhost/folder1'&gt;\n</pre>\n</blockquote>\n<p>If you forget to specify a title or URL, you receive a <tt>ValueError</tt>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.getLink()\nTraceback (most recent call last):\n...\nValueError: You must specify a title or URL.\n</pre>\n</blockquote>\n<p>Links can also be relative, such as the one for ACL:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.open('http://localhost/folder1')\n&gt;&gt;&gt; client.getLink('ACL')\n&lt;XLink title='ACL' url='http://localhost/folder1/acl'&gt;\n</pre>\n<pre>&gt;&gt;&gt; client.open('http://localhost/folder1/')\n&gt;&gt;&gt; client.getLink('ACL')\n&lt;XLink title='ACL' url='http://localhost/folder1/acl'&gt;\n</pre>\n</blockquote>\n<p>The cool part about the link is that you can click it:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.open('http://localhost/')\n&gt;&gt;&gt; client.url\n'http://localhost/'\n</pre>\n<pre>&gt;&gt;&gt; client.getLink('folder1').click()\n</pre>\n<pre>&gt;&gt;&gt; client.url\n'http://localhost/folder1'\n</pre>\n</blockquote>\n</div>\n<div id=\"moving-through-time\">\n<h4>Moving through time</h4>\n<p>Like in a real browser, you can go back to a previous state. For example,\ncurrently we are looking at <cite>folder1</cite>, \u2026</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.url\n'http://localhost/folder1'\n</pre>\n</blockquote>\n<p>but if I go back one step, I am back at the root folder:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.goBack()\n</pre>\n<pre>&gt;&gt;&gt; client.url\n'http://localhost/'\n</pre>\n<pre>&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;items&gt;\n    &lt;item xlink:type=\"simple\"\n          xlink:href=\"http://localhost/folder1\"\n          xlink:title=\"folder1\"/&gt;\n    &lt;item xlink:type=\"simple\"\n          xlink:href=\"http://localhost/folder2\"\n          xlink:title=\"folder2\"/&gt;\n  &lt;/items&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>But going back in history is only cool, if you can also reload. So let\u2019s\ndelete <cite>folder2</cite>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.getLink('folder2').click()\n&gt;&gt;&gt; client.delete()\n</pre>\n</blockquote>\n<p>Now we go back 2 steps:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.goBack(2)\n</pre>\n<pre>&gt;&gt;&gt; client.url\n'http://localhost/'\n</pre>\n<pre>&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;items&gt;\n    &lt;item xlink:type=\"simple\"\n          xlink:href=\"http://localhost/folder1\"\n          xlink:title=\"folder1\"/&gt;\n    &lt;item xlink:type=\"simple\"\n          xlink:href=\"http://localhost/folder2\"\n          xlink:title=\"folder2\"/&gt;\n  &lt;/items&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>As expected, the contents has not changed yet. So let\u2019s reload:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.reload()\n</pre>\n<pre>&gt;&gt;&gt; client.url\n'http://localhost/'\n</pre>\n<pre>&gt;&gt;&gt; print client.contents\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;folder xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt;\n  &lt;name&gt;&lt;/name&gt;\n  &lt;title&gt;&lt;/title&gt;\n  &lt;items&gt;\n    &lt;item xlink:type=\"simple\"\n          xlink:href=\"http://localhost/folder1\"\n          xlink:title=\"folder1\"/&gt;\n  &lt;/items&gt;\n  &lt;acl xlink:type=\"simple\" xlink:href=\"acl\" xlink:title=\"ACL\"/&gt;\n&lt;/folder&gt;\n</pre>\n</blockquote>\n<p>Note that going back zero steps does nothing:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.url\n'http://localhost/'\n</pre>\n<pre>&gt;&gt;&gt; client.getLink('folder1').click()\n&gt;&gt;&gt; client.goBack(0)\n</pre>\n<pre>&gt;&gt;&gt; client.url\n'http://localhost/folder1'\n</pre>\n</blockquote>\n<p>Also, if you try to go back beyond the beginning of time, a value error is\nraised:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; client.goBack(1000)\nTraceback (most recent call last):\n...\nValueError: There is not enough history.\n</pre>\n</blockquote>\n</div>\n<div id=\"absolute-urls\">\n<h4>Absolute URLs</h4>\n<p>As mentioned above, we allow specifying relative URLs, a call with an absolute\nURL has been made. A function called <tt>absoluteURL()</tt> is used to compute the\nnew absolute URL.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.rest.client import absoluteURL\n</pre>\n</blockquote>\n<p>The basic functionality is simple:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; absoluteURL('http://localhost/folder1/', 'folder11')\n'http://localhost/folder1/folder11'\n</pre>\n</blockquote>\n<p>It also detects, if the new part of the URL is absolute, in which case it\nreplaces the original base URL:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; absoluteURL('http://einstein/folder1', 'http://localhost/folder11')\n'http://localhost/folder11'\n</pre>\n</blockquote>\n<p>If the base URL does not have a trailing slash, it is added automatically:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; absoluteURL('http://localhost/folder1', 'folder11')\n'http://localhost/folder1/folder11'\n</pre>\n</blockquote>\n<p>Any slashes at the end of the new URL are preserved:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; absoluteURL('http://localhost/folder1', 'folder11/')\n'http://localhost/folder1/folder11/'\n</pre>\n<pre>&gt;&gt;&gt; absoluteURL('http://einstein/folder1', 'http://localhost/folder11/')\n'http://localhost/folder11/'\n</pre>\n</blockquote>\n<p>The function also handles more complex URLs containing a query string\ncorrectly:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; absoluteURL('http://localhost/folder1', 'folder11?max=1')\n'http://localhost/folder1/folder11?max=1'\n</pre>\n<pre>&gt;&gt;&gt; absoluteURL('http://localhost/folder1', 'folder11/?max=1')\n'http://localhost/folder1/folder11/?max=1'\n</pre>\n</blockquote>\n<p>If the base URL contains a query string, the resulting URL will as well:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; absoluteURL('http://localhost/folder1?max=1', 'folder11/')\n'http://localhost/folder1/folder11/?max=1'\n</pre>\n<pre>&gt;&gt;&gt; absoluteURL('http://localhost/folder1/?max=1', 'folder11/')\n'http://localhost/folder1/folder11/?max=1'\n</pre>\n<pre>&gt;&gt;&gt; absoluteURL('http://localhost/folder1?max=1', 'folder11')\n'http://localhost/folder1/folder11?max=1'\n</pre>\n<pre>&gt;&gt;&gt; absoluteURL('http://localhost/folder1/?max=1', 'folder11')\n'http://localhost/folder1/folder11?max=1'\n</pre>\n</blockquote>\n<p>If both, the base and relative URL provide query strings, they are merged:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; absoluteURL('http://localhost/folder1/?max=1', 'folder11?min=0')\n'http://localhost/folder1/folder11?max=1&amp;min=0'\n</pre>\n<pre>&gt;&gt;&gt; absoluteURL('http://localhost/folder1/?max=1', 'folder11?min=0&amp;start=0')\n'http://localhost/folder1/folder11?max=1&amp;min=0&amp;start=0'\n</pre>\n<pre>&gt;&gt;&gt; absoluteURL('http://localhost/folder1/?max=1&amp;start=0', 'folder11?min=0')\n'http://localhost/folder1/folder11?max=1&amp;start=0&amp;min=0'\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"null-resources\">\n<h3>Null Resources</h3>\n<p>It is sometimes necessary to traverse to resources that do not yet exist. In\nparticular, this is needed when creating resources using \u201cPUT\u201d or \u201cPOST\u201d. It\nis the responsibility of the traverser to handle those cases correctly and\nproduce the null resources. This document only describes their behavior.</p>\n<p>A null resource is easily instantiated using the container and the name of the\nresource:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Folder(object):\n...     __parent__ = __name__ = None\n...     child = None\n...\n...     def __init__(self, name=''):\n...         self.name = self.__name__ = name\n...\n...     def __repr__(self):\n...         return '&lt;Folder %r&gt;' %self.name\n&gt;&gt;&gt; folder = Folder()\n</pre>\n<pre>&gt;&gt;&gt; from z3c.rest import null\n&gt;&gt;&gt; resource = null.NullResource(folder, 'resource')\n</pre>\n<pre>&gt;&gt;&gt; from zope.app.http.interfaces import INullResource\n&gt;&gt;&gt; INullResource.providedBy(resource)\nTrue\n</pre>\n</blockquote>\n<p>Null resources are locations, so security is available:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.location.interfaces import ILocation\n&gt;&gt;&gt; ILocation.providedBy(resource)\nTrue\n</pre>\n</blockquote>\n<p>The container is also the parent:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; resource.container\n&lt;Folder ''&gt;\n&gt;&gt;&gt; resource.__parent__\n&lt;Folder ''&gt;\n</pre>\n</blockquote>\n<p>The name of the resource is available at:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; resource.name\n'resource'\n&gt;&gt;&gt; resource.__name__\n'resource'\n</pre>\n</blockquote>\n<p>There is a special implementation of \u201cPUT\u201d for null resources. It works by\nlooking up a view called \u201cNullPUT\u201d for the container. This way, one null\nresource implementation can be used for all container implementations.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import StringIO\n&gt;&gt;&gt; from z3c.rest import rest\n&gt;&gt;&gt; request = rest.RESTRequest(StringIO.StringIO(), {})\n</pre>\n<pre>&gt;&gt;&gt; nullPut = null.NullPUT(resource, request)\n&gt;&gt;&gt; nullPut.PUT()\n</pre>\n</blockquote>\n<p>Since no view called \u201cNullPUT\u201d exists for our <cite>Folder</cite> class, we get a 501\nreturn status:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request.response.getStatusString()\n'501 Not Implemented'\n</pre>\n</blockquote>\n<p>Let\u2019s now register a simple NullPUT view:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class FolderAPI(rest.RESTView):\n...\n...     def NullPUT(self, resource):\n...         self.context.child = Folder(resource.name)\n...         self.context.child.__parent__ = self.context\n...         return self.context.child\n</pre>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from z3c.rest import interfaces\n&gt;&gt;&gt; zope.component.provideAdapter(\n...     FolderAPI, (Folder, interfaces.IRESTRequest), name='NullPUT')\n</pre>\n</blockquote>\n<p>Let\u2019s make sure our location structure is correctly setup, so that absolute\nURL will work:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.traversing.interfaces import IContainmentRoot\n&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; zope.interface.alsoProvides(folder, IContainmentRoot)\n</pre>\n</blockquote>\n<p>Now we are ready to PUT the new resource:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = rest.RESTRequest(\n...     StringIO.StringIO(), {'SERVER_URL': 'http://localhost/'})\n</pre>\n<pre>&gt;&gt;&gt; nullPut = null.NullPUT(resource, request)\n&gt;&gt;&gt; nullPut.PUT()\n</pre>\n<pre>&gt;&gt;&gt; request.response.getStatusString()\n'201 Created'\n&gt;&gt;&gt; request.response.getHeader('Location')\n'http://localhost/resource'\n</pre>\n<pre>&gt;&gt;&gt; folder.child\n&lt;Folder 'resource'&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"rest-traverser-components\">\n<h3>REST Traverser Components</h3>\n<p>Being able to control and extend traversal is essential to any RESTive\nAPI. This package uses the pluggable traverser implementation of the\n<tt>z3c.traverser</tt> package to provide a flexible traversal mechanism.</p>\n<div id=\"rest-pluggable-traverser\">\n<h4>REST Pluggable Traverser</h4>\n<p>The REST pluggable traverser is registered for all types of components. Its\nimplementation is fully tested in the <tt>z3c.traverser</tt> package.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.rest import traverser\n</pre>\n<pre>&gt;&gt;&gt; import StringIO\n&gt;&gt;&gt; from z3c.rest import rest\n&gt;&gt;&gt; request = rest.RESTRequest(StringIO.StringIO(), {})\n</pre>\n<pre>&gt;&gt;&gt; pluggable = traverser.RESTPluggableTraverser(object(), request)\n&gt;&gt;&gt; pluggable\n&lt;z3c.rest.traverser.RESTPluggableTraverser object at ...&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"item-container-traverser-plugin\">\n<h4>Item Container Traverser Plugin</h4>\n<p>The item mapping interface \u2013 from which item container inherits \u2013 is the\nmost minimal mapping interface in Python. Thus, once traversing through this\nitem container is implemented, it can be used by all other container\ninterfaces and implementations.</p>\n<p>Let\u2019s start by creating a very simple item container implementation:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; from zope.app.container.interfaces import IItemContainer\n</pre>\n<pre>&gt;&gt;&gt; class SimpleContainer(dict):\n...     zope.interface.implements(IItemContainer)\n...     def __init__(self, name=''):\n...         self.name = name\n...     def __repr__(self):\n...         return '&lt;Container name=%s&gt;' %self.name\n</pre>\n<pre>&gt;&gt;&gt; container = SimpleContainer()\n</pre>\n<pre>&gt;&gt;&gt; container['sub1'] = SimpleContainer('sub1')\n&gt;&gt;&gt; container['sub2'] = SimpleContainer('sub2')\n</pre>\n</blockquote>\n<p>After creating a traverser plugin instance,</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = rest.RESTRequest(StringIO.StringIO(), {})\n</pre>\n<pre>&gt;&gt;&gt; containerTraverser = traverser.ContainerItemTraverserPlugin(\n...     container, request)\n</pre>\n</blockquote>\n<p>we can traverse to a sub-object of that container:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; containerTraverser.publishTraverse(request, 'sub1')\n&lt;Container name=sub1&gt;\n</pre>\n</blockquote>\n<p>If no proper sub-item can be found, some interesting can happen. In a normal\ncase, <tt>NotFound</tt> is raised:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; containerTraverser.publishTraverse(request, 'unknown')\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;Container name=&gt;, name: 'unknown'\n</pre>\n</blockquote>\n<p>However, if the request is a PUT request, we must generate a null resource:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request.method = 'PUT'\n&gt;&gt;&gt; containerTraverser.publishTraverse(request, 'unknown')\n&lt;NullResource 'unknown'&gt;\n</pre>\n</blockquote>\n<p>However, a null resource is only created, if the current resource is the last\none in the traversal stack:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request.setTraversalStack(('sub11',))\n&gt;&gt;&gt; containerTraverser.publishTraverse(request, 'unknown')\nTraceback (most recent call last):\n...\nNotFound: Object: &lt;Container name=&gt;, name: 'unknown'\n</pre>\n</blockquote>\n<p>And that\u2019s it.</p>\n</div>\n</div>\n<div id=\"publisher-hooks-for-rest-requests\">\n<h3>Publisher Hooks for REST Requests</h3>\n<p>Reading this document requires \u2013 to some extend \u2013 that the reader is\nfamiliar with the basic steps of the publication process.</p>\n<div id=\"the-publication-request-factory\">\n<h4>The Publication Request Factory</h4>\n<p>The Zope publication process starts when a WSGI server sends the request\nenvironment and response initialization callable to the Zope WSGI Publisher\napplication _[1]. The WSGI publisher application is then responsible for\nprocessing the request in the publisher and stream out the result.</p>\n<p>In order to process a request in the publisher, we have to create a valid\npublisher request object. The WSGI publisher application uses a request\nfactory for this purpose. This package implements this factory to ensure that\na special REST request (based on HTTP Request) is created at all times.</p>\n<p>The request factory is instantiated using a ZODB database object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from ZODB.DB import DB\n&gt;&gt;&gt; from ZODB.DemoStorage import DemoStorage\n&gt;&gt;&gt; db = DB(DemoStorage())\n</pre>\n</blockquote>\n<p>Let\u2019s now create the factory:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.rest import rest\n&gt;&gt;&gt; RequestFactory = rest.RESTPublicationRequestFactory(db)\n</pre>\n</blockquote>\n<p>When a request comes in from the server, the request is created as follows:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import StringIO\n&gt;&gt;&gt; inStream = StringIO.StringIO('Input stream')\n</pre>\n<pre>&gt;&gt;&gt; env = {'HTTP_ACCEPT_LANGUAGE': 'en-US,en',\n...        'SERVER_URL': 'http://localhost:8080/'}\n</pre>\n<pre>&gt;&gt;&gt; request = RequestFactory(inStream, env)\n</pre>\n</blockquote>\n<p>We now got a valid request that we can send through the publisher:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request\n&lt;z3c.rest.rest.RESTRequest instance URL=http://localhost:8080&gt;\n</pre>\n</blockquote>\n<p>The request, however, is only responsible for representing the network request\nin the publisher and has no direct knowledge of the application. But the\nrequest connects to an application-specific \u2013 in this case Zope 3 \u2013\ncomponent known as the publication.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request.publication\n&lt;zope.app.publication.http.HTTPPublication object at ...&gt;\n</pre>\n</blockquote>\n<p>Since we do not need a special REST publication, we are simply reusing the\nmore generic HTTP version. The publication will be the same for all\nrequests. It also contains the reference to the database:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request.publication.db\n&lt;ZODB.DB.DB object at ...&gt;\n</pre>\n</blockquote>\n<p>Unfortunately, it takes a lot more setup to send the request through the\npublisher successfully. The publication requires many other aspects of\npublishing to be available, including traversal, security, and a properly\nconstructed database. However, we can still see a failure:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher import publish\n&gt;&gt;&gt; publish.publish(request)\n&lt;z3c.rest.rest.RESTRequest instance URL=http://localhost:8080&gt;\n&gt;&gt;&gt; print request.response.consumeBody()\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;error&gt;\n  &lt;name&gt;ComponentLookupError&lt;/name&gt;\n  &lt;explanation&gt;(&amp;lt;InterfaceClass ...IAuthentication&amp;gt;, u'')&lt;/explanation&gt;\n&lt;/error&gt;\n</pre>\n</blockquote>\n<p>Let\u2019 unwind a bit. Originally, we started with the desire to create a\nPublisher WSGI Application instance that internally uses a REST request. All\nthat you need to do is:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.app import wsgi\n&gt;&gt;&gt; app = wsgi.WSGIPublisherApplication(\n...     db, rest.RESTPublicationRequestFactory)\n&gt;&gt;&gt; app\n&lt;zope.app.wsgi.WSGIPublisherApplication object at ...&gt;\n</pre>\n</blockquote>\n<p>When the WSGI server sends a request to the WSGI application, the following\nhappens:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; status = None\n&gt;&gt;&gt; headers = None\n&gt;&gt;&gt; def start_response(s, h):\n...     global status\n...     global headers\n...     status, headers = s, h\n</pre>\n<pre>&gt;&gt;&gt; wsgiEnv = {'wsgi.input': inStream}\n&gt;&gt;&gt; wsgiEnv.update(env)\n</pre>\n<pre>&gt;&gt;&gt; print '\\n'.join(app(wsgiEnv, start_response))\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;error&gt;\n  &lt;name&gt;ComponentLookupError&lt;/name&gt;\n  &lt;explanation&gt;(&amp;lt;InterfaceClass ...IAuthentication&amp;gt;, u'')&lt;/explanation&gt;\n&lt;/error&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"the-rest-request\">\n<h4>The REST Request</h4>\n<p>For most parts, the REST request is identical to the HTTP request, so I won\u2019t\ngo into too much detail about the HTTP request API.</p>\n<p>The REST request mainly extends the HTTP request in that it parses the query\nstring of the URL into a set of parameters. This happens during\n<tt>processInputs()</tt>.</p>\n<p>If there is no query string, the paramaters mapping is empty:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = RequestFactory(\n...     StringIO.StringIO(), {})\n&gt;&gt;&gt; request.processInputs()\n&gt;&gt;&gt; request.parameters\n{}\n</pre>\n</blockquote>\n<p>So let\u2019s now pass a few parameters:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = RequestFactory(\n...     StringIO.StringIO(),\n...     {'QUERY_STRING': 'format=html&amp;action=delete&amp;item=1&amp;item=3'})\n&gt;&gt;&gt; request.processInputs()\n&gt;&gt;&gt; pprint(request.parameters)\n{'action': 'delete',\n 'format': 'html',\n 'item': ['1',\n          '3']}\n</pre>\n</blockquote>\n<p>We also override some of the request\u2019s mapping methods, so that the parameters\nand environment values are available as part of the request:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(request.keys())\n['QUERY_STRING', 'action', 'format', 'item']\n</pre>\n<pre>&gt;&gt;&gt; request.get('QUERY_STRING')\n'format=html&amp;action=delete&amp;item=1&amp;item=3'\n&gt;&gt;&gt; request.get('action')\n'delete'\n&gt;&gt;&gt; request.get('unknwon', 'default')\n'default'\n</pre>\n</blockquote>\n</div>\n<div id=\"the-rest-response\">\n<h4>The REST Response</h4>\n<p>The REST Response is pretty much identical to the HTTP Response, except that\nits exception handler returns XML instead of HTML. This method, however, is\nonly used for classic and string exceptions.</p>\n<p>Starting with a response, \u2026</p>\n<blockquote>\n<pre>&gt;&gt;&gt; response = rest.RESTResponse()\n</pre>\n</blockquote>\n<p>\u2026 we can now call the handler:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class MyException(Exception):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; response.handleException((MyException, MyException(), None))\n&gt;&gt;&gt; response._status\n500\n&gt;&gt;&gt; response._reason\n'Internal Server Error'\n&gt;&gt;&gt; print '\\n'.join(response._result)\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;error&gt;\n  &lt;name&gt;MyException&lt;/name&gt;\n  &lt;explanation&gt;&lt;/explanation&gt;\n&lt;/error&gt;\n</pre>\n</blockquote>\n<p>Let\u2019s try a string exception too:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; response.handleException(('StringException', 'Some details', None))\n&gt;&gt;&gt; response._status\n500\n&gt;&gt;&gt; response._reason\n'Internal Server Error'\n&gt;&gt;&gt; print '\\n'.join(response._result)\n&lt;?xml version=\"1.0\" ?&gt;\n&lt;error&gt;\n  &lt;name&gt;StringException&lt;/name&gt;\n  &lt;explanation&gt;Some details&lt;/explanation&gt;\n&lt;/error&gt;\n</pre>\n</blockquote>\n<p>The <cite>Redirect</cite> exception is special. It actuaually causes the request to be\nredirected.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; response._request = rest.RESTRequest(None, {})\n</pre>\n<pre>&gt;&gt;&gt; from zope.publisher.interfaces import Redirect\n&gt;&gt;&gt; response.handleException(\n...     (Redirect, Redirect('http://localhost'), None), trusted=True)\n&gt;&gt;&gt; response._status\n302\n&gt;&gt;&gt; response._reason\n'Moved Temporarily'\n&gt;&gt;&gt; response._headers['location']\n['http://localhost']\n</pre>\n</blockquote>\n</div>\n<div id=\"rest-views\">\n<h4>REST Views</h4>\n<p>Unlike browser views, a REST view does <em>not</em> represent its own sub-resource\n(such as \u201cindex.html\u201d). Instead it merely defines the behavior of the HTTP\nmethods for a particular content component.</p>\n<p>Here is an example:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class ObjectAPI(rest.RESTView):\n...\n...     def GET(self):\n...          return str(self.context)\n</pre>\n</blockquote>\n<p>The <tt>RESTView</tt> base class provides a suitable constructor:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Object(object):\n...     def __repr__(self):\n...         return '&lt;Object&gt;'\n&gt;&gt;&gt; myobj = Object()\n</pre>\n<pre>&gt;&gt;&gt; request = RequestFactory(\n...     StringIO.StringIO(), {'SERVER_URL': 'http://localhost:8080/myobj'})\n</pre>\n<pre>&gt;&gt;&gt; view = ObjectAPI(myobj, request)\n</pre>\n</blockquote>\n<p>When the publisher traverses to <cite>myobj</cite>, it will look up a view based on the\nHTTP mehtod, such as \u201cGET\u201d. It then also expects to find a method of that same\nname and calls it _[2].</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view.GET()\n'&lt;Object&gt;'\n</pre>\n</blockquote>\n<p>The REST View, like all other views, exposes its context and the request:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view.context\n&lt;Object&gt;\n&gt;&gt;&gt; view.request\n&lt;z3c.rest.rest.RESTRequest instance URL=http://localhost:8080/myobj&gt;\n</pre>\n</blockquote>\n<p>Also, a view must be located, so it has a parent as well:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view.__parent__\n&lt;Object&gt;\n</pre>\n</blockquote>\n<p>You can set it to something else of course:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; view.__parent__ = 1\n&gt;&gt;&gt; view.__parent__\n1\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"changes\">\n<h3>CHANGES</h3>\n<div id=\"id1\">\n<h4>0.4.0 (2010-10-05)</h4>\n<ul>\n<li>Added undeclared but necessary install dependency on <cite>zope.app.http</cite>.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h4>0.3.0 (2010-10-05)</h4>\n<ul>\n<li>Added not declared test dependencies.</li>\n<li>Updated test set up and fixed tests to run with ZTK 1.0.</li>\n<li>Using Python\u2019s <tt>doctest</tt> module instead of depreacted\n<tt>zope.testing.doctest</tt>.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h4>0.2.5 (2008-09-16)</h4>\n<ul>\n<li>Bug/Misfeature: Finally get handling of URL merging working as desired. Also\nadded extensive tests to document the behavior.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h4>0.2.4 (2008-09-04)</h4>\n<ul>\n<li>RESTClient() now correctly interprets <cite>https://</cite> URLs.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h4>0.2.3 (2008-03-20)</h4>\n<ul>\n<li>Bug/Misfeature: Sigh, getting the trailing slash handled correctly turned\nout to be a big pain. I really hope I got it working the way it should be\nfor a REST client now.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h4>0.2.2 (2008-03-19)</h4>\n<ul>\n<li>Bug/Misfeature: The client always added a slash to the end of the URL. But\nsome REST APIs are very sensitive to this. Now the slash is only preserved\nif present, but nothing will be added otherwise.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h4>0.2.1 (2008-03-06)</h4>\n<ul>\n<li>Bug: Sometimes the response body was not read and the contents of the client\nwas empty. Unfortunately, this problem could not be reliably reproduced, but\ndebugging showed that the connection was closed to early. (Roy Mathew)</li>\n<li>Feature: Make the package Python 2.4 and 2.5 compatible.</li>\n<li>Feature: Require lxml 2.0 for z3c.rest.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h4>0.2.0 (2008-03-03)</h4>\n<ul>\n<li>Feature: Made the HTTP caller pluggable for the REST client, allowing\nrequest types other than <tt>RESTRequest</tt>.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h4>0.1.0 (2008-03-03)</h4>\n<ul>\n<li>Initial Release<ul>\n<li>Publisher hooks to build dedicated REST servers</li>\n<li>Error view support</li>\n<li>Pluggable REST traverser based on <cite>z3c.traverser</cite></li>\n<li>REST client</li>\n<li>Minimal sample application</li>\n</ul>\n</li>\n</ul>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 802099, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "cafa903e91692129b715ec50bbf2a996", "sha256": "fe995c84b269533a869fab13d0b74fa648f49efe53a876dd558ea90f261db96a"}, "downloads": -1, "filename": "z3c.rest-0.1.0.tar.gz", "has_sig": false, "md5_digest": "cafa903e91692129b715ec50bbf2a996", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36003, "upload_time": "2008-03-03T14:53:35", "upload_time_iso_8601": "2008-03-03T14:53:35Z", "url": "https://files.pythonhosted.org/packages/16/fd/90169ebdd69b63534ad951bb57973651caa52ebfa4c05f9efcfc23d932db/z3c.rest-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "c7161bdce5b033face7e22fd8c514e70", "sha256": "313c974d2d891d42e6bd2c0b14e3b837279d0cef126aa9a1589d48be26e2ce62"}, "downloads": -1, "filename": "z3c.rest-0.2.0.tar.gz", "has_sig": false, "md5_digest": "c7161bdce5b033face7e22fd8c514e70", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36142, "upload_time": "2008-03-03T21:09:25", "upload_time_iso_8601": "2008-03-03T21:09:25Z", "url": "https://files.pythonhosted.org/packages/b3/84/5119f98ece337191d933949d3cb30fba60519bab61f1d3a3e1228f185ea1/z3c.rest-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "b0ecbaedcd6cd86073f118bd65143a56", "sha256": "cf21dcc030330167ac5c29df66d4e5d946e9afebc175e2fde47b386bd7e5ba9b"}, "downloads": -1, "filename": "z3c.rest-0.2.1.tar.gz", "has_sig": false, "md5_digest": "b0ecbaedcd6cd86073f118bd65143a56", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36455, "upload_time": "2008-03-06T08:02:44", "upload_time_iso_8601": "2008-03-06T08:02:44Z", "url": "https://files.pythonhosted.org/packages/75/2f/05847d0a91f71a08fa410d55416cacdf2dcd47424e17bd1fa89d478b74af/z3c.rest-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "57f784e3c2d47e80254979176f34eb39", "sha256": "7ae569c5a0556c7f0756eb625339724e7e538cf9ccc3417cc1a78ce67e1464e7"}, "downloads": -1, "filename": "z3c.rest-0.2.2.tar.gz", "has_sig": false, "md5_digest": "57f784e3c2d47e80254979176f34eb39", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36745, "upload_time": "2008-03-19T23:51:26", "upload_time_iso_8601": "2008-03-19T23:51:26Z", "url": "https://files.pythonhosted.org/packages/36/f7/41d9b3b781920c5040b895c317f0afcdba45252b13c5f910c70d8433c32f/z3c.rest-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "2825f237787f3cbd284e695d43c8cde8", "sha256": "09f918c3caba85a7b3b26f62a65e1ca4250e538d8aff40a1b68d2fbb2a810ebf"}, "downloads": -1, "filename": "z3c.rest-0.2.3.tar.gz", "has_sig": false, "md5_digest": "2825f237787f3cbd284e695d43c8cde8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37628, "upload_time": "2008-03-20T18:08:46", "upload_time_iso_8601": "2008-03-20T18:08:46Z", "url": "https://files.pythonhosted.org/packages/78/bd/a890cedc4c9af407d84aa038dbab146cb003b37e63221d5a1a2eae1faac2/z3c.rest-0.2.3.tar.gz", "yanked": false}], "0.2.4": [{"comment_text": "", "digests": {"md5": "51ca293ccc8a02fbc42474f58e28c951", "sha256": "533e87e1d52fab30635b991915fdfa77d91d8cd8f18951fb155fccb5a2c05a94"}, "downloads": -1, "filename": "z3c.rest-0.2.4.tar.gz", "has_sig": false, "md5_digest": "51ca293ccc8a02fbc42474f58e28c951", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35795, "upload_time": "2008-09-04T20:01:33", "upload_time_iso_8601": "2008-09-04T20:01:33Z", "url": "https://files.pythonhosted.org/packages/d9/42/9f68e57eb016a4c26ad7dc8f054a6883ea89ea320e32a56ab14b4a31d114/z3c.rest-0.2.4.tar.gz", "yanked": false}], "0.2.5": [{"comment_text": "", "digests": {"md5": "5c9fe9151b380785bb0a351700a5d254", "sha256": "7b25ec3799bb098931b9bb3f0ead50307d1cd7ce257672ce519602fdbcdc24f5"}, "downloads": -1, "filename": "z3c.rest-0.2.5.tar.gz", "has_sig": false, "md5_digest": "5c9fe9151b380785bb0a351700a5d254", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39479, "upload_time": "2008-09-16T22:35:49", "upload_time_iso_8601": "2008-09-16T22:35:49Z", "url": "https://files.pythonhosted.org/packages/4f/b3/3fd77f42ef9d9945a796fa388eeb7fb1621384cc26fe145ec7964cc4abbc/z3c.rest-0.2.5.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "8e62cd10fec7a265f2cb730ccfe409ee", "sha256": "cfa564e2936efcc1f22c7287112994070ebd77d3f7934034a6f026e593c4b55c"}, "downloads": -1, "filename": "z3c.rest-0.3.0.tar.gz", "has_sig": false, "md5_digest": "8e62cd10fec7a265f2cb730ccfe409ee", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40361, "upload_time": "2010-10-05T08:45:05", "upload_time_iso_8601": "2010-10-05T08:45:05.685525Z", "url": "https://files.pythonhosted.org/packages/3c/d1/42545ea0654046a33913ae0ed4b7d8b1fce6b583853f52ea4f5e54708391/z3c.rest-0.3.0.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "bae65e621c87bd3e6db30bccaa3762bd", "sha256": "08015b3cce2b933cf67efe7c800b8fd7762552bc898e9c00566757faeb9418aa"}, "downloads": -1, "filename": "z3c.rest-0.4.0.tar.gz", "has_sig": false, "md5_digest": "bae65e621c87bd3e6db30bccaa3762bd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 41393, "upload_time": "2010-10-05T08:58:57", "upload_time_iso_8601": "2010-10-05T08:58:57.284989Z", "url": "https://files.pythonhosted.org/packages/7a/00/3e8c672038746b4a42e043603fb7576b530360cf3009aaf63f294c01259a/z3c.rest-0.4.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bae65e621c87bd3e6db30bccaa3762bd", "sha256": "08015b3cce2b933cf67efe7c800b8fd7762552bc898e9c00566757faeb9418aa"}, "downloads": -1, "filename": "z3c.rest-0.4.0.tar.gz", "has_sig": false, "md5_digest": "bae65e621c87bd3e6db30bccaa3762bd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 41393, "upload_time": "2010-10-05T08:58:57", "upload_time_iso_8601": "2010-10-05T08:58:57.284989Z", "url": "https://files.pythonhosted.org/packages/7a/00/3e8c672038746b4a42e043603fb7576b530360cf3009aaf63f294c01259a/z3c.rest-0.4.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:20:34 2020"}