{"info": {"author": "Jacob Morris", "author_email": "blendingjake@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Topic :: Database", "Topic :: Utilities"], "description": "# JTools\n>JTools is a robust library for interacting with JSON-like objects:\n>providing the ability to quickly query, format, and filter JSON-like data.\n>\n>There are three main components:\n * `Query`: Extract and transform the value of nested fields.\n   * `Query(\"data.timestamp.$parse_timestamp.$attr('year')\").many(items)`\n * `Filter`: Combine the querying capabilities of `Query` with the ability\n to define filtering conditions to find just the elements you want.\n   * `Filter(Key(\"data.timestamp.$parse_timestamp.$attr('year')\") > 2015).many(data)`\n * `Formatter`: Take multiple queries and format them into a string\n   * `Formatter(\"Item @data.id was released in @data.timestamp.$parse_timestamp.$attr('year')\").single(data[0])`\n>\n>A companion to the JavaScript version of this package: [@blending_jake/jtools](#https://www.npmjs.com/package/@blending_jake/jtools).\n>The JavaScript version supports almost the exact same specials, filters, and formatting specification, with the\n>goal of making it a seamless experience to go from querying/filtering/formatting in JavaScript to Python and back.\n\n## Recent Changes\n * `1.1.3`\n  * Changed the behavior of `Query(\"\")`, from returning the fallback value, to returning the source data element itself.\n  For example, `Query(\"\").single(data) == data`.\n  * Added `SpecialNotFoundError`, which is raised when an invalid special is queried. Can be imported as \n  `from jtools import SpecialNotFoundError`\n  * Added new specials\n   * `$store_as(name)` Store the current query value in the current context for later use in the query. This does not \n   change the underlying data being queried.\n   * `$group_by(key=\"\", count=false)` Take an incoming list and group the values by the specified key.\n   Any valid JQL query can be used for the key, so `\"\"` means the value itself. The result by default will be\n   keys to a list of values. However, if `count=true`, then the result will be keys to the number of elements with each \n   key.\n   * `$sort(key=\"\", reverse=false)` Sort an incoming list of values by a given key which can be any valid JQL query.\n   By default, `key=\"\"` means the top-level value will be sorted on.\n   * `$dict` Take an incoming list of `(key, value)` pairs and make a dict out of them.\n   * `$join_arg(arg, sep=', ')` Similar to `$join` except this operates on an argument instead of the query value.\n   Essentially a shortened form of `$inject(arg).$join(sep)`.\n  * Changed the underlying special function definition to now include the keyword argument `context`. This argument is \n  implemented to only be accessed by name to avoid collision if the user provides too many arguments in their query. \n  The purpose of the context is to support specials adding values temporarily to the data\n  namespace of the query, like `$store_as` does.\n\n## Glossary\n * [`Installation`](#install)\n * [`JQL`](#jql)\n * [`Query`](#query)\n   * [`Specials`](#specials)\n * [`Filter`](#filter)\n   * [`Key`](#key)\n   * [`Condition`](#condition)\n * [`Formatter`](#formatter)\n * [`Performance`](#performance)\n * [`Changelog`](#changelog)\n\n## <a name=\"install\">Installation</a>\n`pip install jtools`\n```python\n# import\nfrom jtools import Query, Filter, Key, Condition, Formatter\n```\n\n## <a name=\"jql\">`JQL`</a>\n>`JQL` or the `JSON Query Language` is a custom built query language for `JTools` which supports powerful features\n>like accessing nested fields, transforming values, and even using nested queries as arguments. \n>The basic format of the language is: \n```\n(<field> | $<special>) (. (<field> | $<special>))*\nEX: 'data', 'data.timestamp', 'data.$split', '$split.0'\n```\n#### field\nA field is just a value that can be used as an index, like a string or integer key for a map/dict, or an integer for an\narray. By default, any field that can be treated as an integer will be. However, this assumes that any field containing \nonly digits was intended to be an integer index, which isn't always the desired behavior. To stop digit-only \nstrings from becoming integers, set `convert_ints=False` when creating the query/filter/formatter.\n\nFields can only contain the following characters: `[-a-zA-Z0-9_]`. However, fields with prohibited characters can still\nbe indexed by using the `$index` special, so to index `range[0]` use `$index(\"range[0]\")`.\n\n#### $special\nA special is a function that is applied to the value that has been queried so far. There is a complete list of specials\n[here](#specials). These specials can be passed arguments, which is one of the most powerful features\nof `JQL`. The syntax is similar to most programming languages: `$<special>(<value>(, <value>)*)`. Just to note, `$<special>()`\nis valid, as is `$<special>`. Many of the specials don't require any arguments, or have default values, allowing\nthe parenthesis to be left off.\n\n##### value\nA `<value>` can be:\n```\n[] or [<value>(, <value>)*] - List\n{} or {<value>(, <value>)*} - Set\n{:} or {<key>: <value>(, <key>: <value>)*} - Map/Dict/Object (see below for <key> spec)\nInteger\nFloat\nString w/ '' or \"\"\ntrue\nfalse\nnull\n@<query> - Yep! Nested queries!\n\n<key>:\n    @<query>    \n    Integer\n    Float\n    String\n    true\n    false\n    null\n``` \nAs shown above, values and queries can be nested, so `[[1, 2], [\"bob\"], {\"Ann\", 'Ralph'}, {'key': 4, 23: 5}]`\nis valid. Additionally, the support for nesting queries is extremely powerful and allows for queries like:\n`item.tag.$lookup(@table.colors)`, which, for `{\"item\": {\"tag\": \"product\"}, \"table\": {\"colors\": {\"product\": \"red\"}}}`\nresults in `\"red\"`\n\n## <a name=\"query\">Query</a>\n>`Query` takes the power of `JQL` and puts it into practice querying and transforming values\n>in JSON-like data. \n\n### `Query(query, convert_ints=True, fallback=None)`\n* `query`: `str | List[str]` The field or fields to query\n* `convert_ints`: Whether or not to convert any valid fields to integers\n* `fallback`: The value that will result if a non-existent field is queried\n\n#### `.single(item)`\n>Take a single item and query it using the query(ies) provided\n>\n>`Query(field).single(...) -> result`\n>\n>`Query([field, field, ...]).single(...) -> [result, result, ...]`\n\n#### `.many(items)`\n>Take a list of items, and query each item using the query(ies) provided\n>\n>`Query(field).many(...) -> [result, result, ...]`\n>\n>`Query([field, field, ...]).many(...) -> [[result, result, ...], [result, result, ...], ...]`\n\n### Notes\n * Lists can be indexed as long as `Query(..., convert_ints=True)`,\n which is set to `True` by default. This allows paths like `friends.0`. However, `convert_ints=False`\n should be used if trying to access fields whose keys are strings containing digits, like\n `{\"index\": {\"0\": ...}}`. Use `$index` if you have mixed data where there are some cases where you need to use\n an integer and other times where the digits-only string needs to stay as a string, like in:\n `Query(\"item.0.$index(0)\").single({\"item\": {\"0\": [\"tag\"])}) -> 'tag'`\n\n * Fields can be indexed after specials, so `$split.0` is completely valid\n\n * You don't have to use `()` at the end of a special if there aren't any \n arguments, or the default arguments are acceptable.\n\n * More specials can be added by using the class attribute `.register_special()` \n like so: `Query.register_special(<name>, <func>)`. The function should take\n at least one argument positional argument, which is the current value in the query string,\n and the keyword argument 'context' at the end: `lambda value, *args, context: ...`\n\n### <a name=\"specials\">Specials</a>\n>Below is a list of all of the specials that can be used. Additionally, more can be added\n>as discussed above. \n\nGeneral\n  * `$length -> int`\n  * `$lookup(map: dict, fallback=None) -> any`: Lookup the current value in the provided map/dict \n  * `$inject(value: any) -> any`: Inject a value into the query\n  * `$print -> any`: Print the current query value before continuing to pass that value along\n  * `store_as(name: str) -> any`: Store the current query value in the current context for later use in the query. This does not \n   change the underlying data being queried.\n  * `group_by(key=\"\", count=false) -> Dict[any, Union[List[any], int]]`: Take an incoming list and group the values \n  by the specified key. Any valid JQL query can be used for the key, so `\"\"` means the value itself. \n  The result by default will be keys to a list of values. However, if `count=true`, then the result will be keys \n  to the number of elements with each key.\n\nMaps\n  * `$keys -> list`\n  * `$values -> list`\n  * `$items -> List[tuple]`\n  * `$wildcard(next, just_value=true) -> List[any]`: On a given map or list, go through all values and see if `next` is\n  a defined field. If it is, then return just the value of `next` on that item, if `just_value=true`, or the entire \n  item otherwise. This special allows a nested field to be extracted across multiple items where it it present. \n  For example: \n```python\ndata = {\n    \"a\": {\"tag\": \"run\"},\n    \"b\": {\"tag\": \"to-do\", \"other\": \"task\"},\n    \"meta\": None\n}\nQuery('$wildcard(\"tag\")').single(data)  # => [\"run\", \"to-do\"]\nQuery('$wildcard(\"tag\", false)').single(data) # => [{\"tag\": \"run\"}, {\"tag\": \"to-do\", \"other\": \"task\"}]\n```\n\nType Conversions\n  * `$set -> set`\n  * `$float -> float`\n  * `$string -> str`\n  * `$dict -> dict`: Take an incoming list of `(key, value)` pairs and make a dict out of them.\n  * `$int -> int`\n  * `$not -> bool`: Returns `!value`\n  * `$fallback(fallback) -> value or fallback`: If the value is None, then it will be replaced with `fallback`.\n  * `$ternary(if_true, if_false, strict=false) -> any`: Return `if_true` if the value is `truish`, otherwise,\n  return `if_false`. Pass `true` for `strict` if the value must be `True` and not just `truish`.\n\nDatetime \n  * `$parse_timestamp -> datetime`: Take a Unix timestamp in seconds and return a corresponding datetime object\n  * `$strptime(fmt=null) -> datetime`: Parse a datetime string and return a corresponding datetime object.\n  If `fmt=null`, then common formats will be tried. Refer to \n  https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior for formatting instructions\n  * `$timestamp -> float`: Dump a datetime object to a UTC timestamp as a float\n  * `$strftime(fmt=\"%Y-%m-%dT%H:%M:%SZ\") -> str`: Format a datetime object as a string using `fmt`.\n  Refer to https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior for formatting instructions\n\nMath / Numbers\n  * `$add(num) -> Union[int, float]`\n  * `$subtract(num) -> Union[int, float]`\n  * `$multiply(num) -> Union[int, float]`\n  * `$divide(num) -> float`\n  * `$pow(num) -> Union[int, float]`\n  * `$abs(num) -> Union[int, float]`\n  * `$distance(other) -> float`: Euler distance in N-dimensions\n  * `$math(attr) -> any`: Returns `math.<attr>(value)`, which can be used for\n  operations like `floor`, `cos`, `sin`, etc.\n  * `$round(n=2) -> float`\n\nStrings\n  * `$prefix(prefix) -> str`: Prefix the value with the specified string\n  * `$suffix(suffix) -> str`: Concatenate a string to the end of the value\n  * `$wrap(prefix, suffix) -> str`: Wrap a string with a prefix and suffix. Combines features of above two specials.\n  * `$strip -> str`: Strip leading and trailing whitespace\n  * `$replace(old, new) -> str`: Replace all occurrences of a string \n  * `$trim(length=50, suffix=\"...\") -> str`: Trim the length of a string\n  * `$split(on=\" \") -> List[str]`: Split a string\n\nLists\n  * `$sum -> Union[float, int]`: Return the sum of the items in the value\n  * `$join(sep=\", \") -> str`: Join a list using the specified separator\n  * `$join_arg(arg: list, sep=\", \")`: Similar to `$join` except this operates on an argument instead of the query value.\n  Essentially a shortened form of `$inject(arg).$join(sep)`.\n  * `$index(index, fallback=null) -> any`: Index a list. Negative indices are allowed.\n  * `$range(start, end=null) -> `: Get a sublist. Defaults to `value[start:]`, \n  but an end value can be specified. Negative indices are allowed.\n  * `$remove_nulls -> List[any]`: Remove any values that are `None`\n  * `$sort(key=\"\", reverse=false)`: Sort an incoming list of values by a given key which can be any valid JQL query.\n  By default, `key=\"\"` means the top-level value will be sorted on.\n  * `$map(special, *args) -> list`: Apply `special` to every element in the \n  value. Arguments can be passed through to the special being used, like `$map(\"index\", \"name\")`\n\nAttributes\n  * `$call(func, *args) -> any`: Call a function that is on the current value, implemented as `getattr(value, func)(*args)`\n  * `$attr(attr) -> any`: Access an attribute of the given object, implemented as `getattr(value, attr)`\n\n## <a name=\"filter\">Filter</a>\n>`Filter` takes the power of `JQL` and combines it with \n>filtering conditions to allow lists of items to be filtered down to just those of \n>interest. The filters can be manually built, or the `Key` and `Condition` classes can \n>be used to simplify your code.\n\n### `Filter(filters, convert_ints=True, empty_filters_response=True, missing_field_response=False)`\n * `filters`: `Condition | List[dict]` The filters to apply to any data. If `List[dict]`, then the\n filters should be formatted as shown below.\n```\n[\n    {\"field\": <field>, \"operator\": <op>, \"value\": <value>},\n\n    OR\n\n    {\"or\": <nested outer structure>},\n\n    OR\n\n    {\"not\": <nested outer structure>},\n\n    ...\n]\n<field>: any valid `JQL` query\n<op>: See list below\n<value>: Anything that makes sense for the operator\n``` \n * `convert_ints`: `bool` Corresponds with the argument with the same name in `Query`. Determines\n whether digit only fields are treated as integers or strings. Defaults to `True`.\n * `empty_filters_response`: `bool` Determines what gets returned when no filters are supplied.\n * `missing_field_response`: `bool` Determines the result of a filter where the field could not be found.\n\n#### `.single(item)`\n>Take a single item and determine whether it satisfies the filters or not\n>\n>`Filter(filters).single(...) -> True/False`\n\n#### `.many(items)`\n>Take a list of items, and returns only those which satisfy the filters\n>\n>`Filter(filters).many(...) -> [result, result, ...]`\n\n### Notes\n```\n{\"or\": [ \n    [ {filter1}, {filter2} ], \n    {filter3} \n]} === (filter1 AND filter2) OR filter3\n``` \n>Nesting in an `or` will cause those filters\n>to be `AND'd` and then everything in the toplevel of that `or` will be `OR'd`.\n\nOperators:\n * `>`\n * `<`\n * `>=`\n * `<=`\n * `==`\n * `!=`\n * `===`: same as `==` in Python\n * `!==`: same as `!=` in Python\n * `in`: `<field> in <value>`\n * `!in`\n * `contains`: `<value> in <field>`\n * `!contains`\n * `interval`: `<field> in interval [value[0], value[1]]` (closed/inclusive interval)\n * `!interval`: `<field> not in interval [value[0], value[1]]` \n * `startswith`\n * `endswith`\n * `present`\n * `!present`\n\n#### <a name=\"key\">Key</a>\n>Intended to simplify having to write `{\"field\": <field>, \"operator\": <operator>, \"value\": value}` \n>a lot. The basic usage is: `Key(<field>).<op>(<value>)`, or for the first six \n>operators, the actual Python operators can be used, so `Key(<field>) <op> <value>`.\n>For example: `Key(\"meta.id\").eq(12)` is the same as `Key(\"meta.id\") == 12`,\n>which is the same as `{\"field\": \"meta.id\", \"operator\": \"==\", \"value\": 12}`.\n\n>The table below describes all of the functions which map to the underlying conditions, but, in\n>addition, there is the `.operator(op: str)` function which can be use to build a filter.\n>For example: `Key(<field>).operator(<op>).value(<value>)` is the same as \n>`{\"field\": <field>, \"operator\": <op>, \"value\": <value>}`\n\nOperators: \n\n| underlying operator | `Key` function | `Python` operator |\n| ------------------- | -------- | -------- |\n| `>` | `gt` | `>` | \n| `<` | `lt` | `<` | \n| `<=` | `lte` | `<=` | \n| `>=` | `gte` | `>=` | \n| `==` | `eq` | `==` | \n| `!=` | `ne` | `!=` | \n| `===` | `seq` | N/A |\n| `!==` | `sne` | N/A\n| `in` | `in_` | N/A | \n| `!in` | `nin` | N/A | \n| `contains` | `contains` | N/A | \n| `!contains` | `not_contains` | N/A | \n| `interval` | `interval` | N/A |\n| `!interval` | `not_interval` | N/A |\n| `startswith` | `startswith` | N/A | \n| `endswith` | `endswith` | N/A | \n| `present` | `present` | N/A | \n| `!present` | `not_present` | N/A | \n\n#### <a name=\"condition\">Condition</a>\n>Intended to be used in combination with `Key` to make creating filters\n>easier than manually creating the `JSON`. There are three conditions supported:\n>`and`, `or`, and `not`. They can be manually accessed via `and_(*args)`, `or_(*args)`, and `not_()`, \n>or through the overloaded operators `&`, `|`, and `~`, respectively.\n\n**Caution: `&` and `|` bind tighter than the comparisons operators and `~` binds the tightest**\n`Key(\"first_name\") == \"John\" | Key(\"first_name\") == \"Bill\"` is actually\n`(Key(\"first_name\") == (\"John\" | Key(\"first_name\"))) == \"Bill\"`, not\n`(Key(\"first_name\") == \"John\") | (Key(\"first_name\") == \"Bill\")`\n\n> Examples\n```python\nKey(\"state\").eq(\"Texas\") | Key(\"city\").eq(\"New York\")\n\n(Key(\"gender\") == \"male\") & (Key(\"age\") >= 18) & (Key(\"selective_service\") == False)\n\nKey('creation_time.$parse_timestamp.$attr(\"year\")').lt(2005).or_(\n    Key('creation_time.$parse_timestamp.$attr(\"year\")').gt(2015)\n).and_(\n    Key(\"product_id\") == 15\n)\n# (year < 2005 OR year > 2015) AND product_id == 15\n```\n\n## <a name=\"formatter\">Formatter</a>\n> `Formatter` allows fields to be queried from an object and then formatted into a string. \n>Any JQL queries in a format string should be prefixed with `@`. For example, \n>`Formatter('Name: @name}').single({\"name\": \"John Smith\"})` results in\n>`Name: John Smith`.\n\n### `Formatter(spec, fallback=\"<missing>\", convert_ints=True)`\n * `spec`: `str` The format string\n * `fallback`: `str` The value that will be used in the formatted string if a query could not be performed.\n For example, if the field `missing` does exist, then the query `\"Age: @missing\"` will result in `\"Age: <missing>\"`\n * `convert_ints`: `bool` Whether digit-only fields get treated as integers or strings\n\n#### `.single(item)`\n> Return a formatted string or the fallback value if the query fails\n\n#### `.many(items)`\n> Return a list of formatted strings or the fallback value.\n\n### Notes\n>The differences between `Query` and `Formatter` are:\n * `Query` can return a value of any type, `Formatter` just returns strings\n * `Formatter` supports multiple queries, end-to-end, `Query` does not\n * All queries must be prefixed with `@` with `Formatter`, not just when used as an argument like with `Query`\n * Both support all the features of `JQL`\n * `Query` actually can theoretically do everything `Formatter` does by using `$prefix`, `$suffix`, and `$string`. \n For example, `'@name @age'` -> `'name.$suffix(\" \").$suffix(@age)'`. However, the latter is much longer than the former.\n\nExample (flattening operations):\n```python\nerrors = {\n    \"errors\": {\n        \"Process Error\": \"Could not communicate with the subprocess\",\n        \"Connection Error\": \"Could not connect with the database instance\"\n    }\n}\n\nFormatter('Errors: \\n@errors.$items.$map(\"join\", \": \\\\n\\\\t\").$join(\"\\\\n\")').single(errors)\n# Errors:\n# Process Error: \n#   Could not communicate with the subprocess\n# Connection Error: \n#   Could not connect with the database instance\n```\n>The above example shows a powerful usage of flattening `errors` into its items,\n>then joining each item; splitting the error name and message between lines, then\n>joining all the errors together.\n\nExample (nested replacement):\n```python\nitem = {\n    \"x1\": 1,\n    \"y1\": 1,\n    \"x2\": 12,\n    \"y2\": 54\n}\n\nFormatter(\n    \"Midpoint: [@x2.$subtract(@x1).$divide(2), @y2.$subtract(@y1).$divide(2)]\"\n)\n# Midpoint: [5.5, 26.5]\n```\n>Additionally, the speed of formatting is very quick. The above statement \n>can be preformed 10,000 times in around 0.36 seconds.\n\n## <a name=\"performance\">Performance</a>\n>There are several ways to increase the performance of querying, filtering, and formatting. The performance gains can be had\n>by limiting the amount of times a query string has to be parsed. This means that using a `Query`,\n>`Filter`, or `Formatter` object multiple times will be faster then creating a new object every time. \n>\n>For example:\n```python\n# slower\nfor item in items:\n    f = Query(\"timestamp.$parse_timestamp\").single(item)\n    # do other stuff\n\n# faster\nquery = Query(\"timestamp.$parse_timestamp\")\nfor item in items:\n    f = query.single(item)\n    # do other stuff\n```\n\n>Across 10,000 runs:\n * reusing `Query` can improve performance by 302x\n * reusing `Filter` can improve performance by 132x\n * reusing `Formatter` can improve performance by 377x.\n\n## <a name=\"changelog\">Changelog</a>  \n * `1.1.2`\n    * Minor changes to documentation\n    * Mostly just to get version back on track with repository \n\n * `1.1.1`\n   * Add `antlr4-python3` requirement to `setup.py` so that installation will get the needed dependencies\n   * Change `JQL` so that field and special names must only contain `[-a-zA-Z0-9_]`. `$index` can be used to get fields\n   with prohibited characters. The change was to support more formatting use-cases, like `Age: @age, DOB: @dob`, which \n   previously would have failed because the `,` would have been considered part of the field name.\n   * Change `Formatter` so that `fallback` is just a string that is substituted for invalid queries, instead of being\n   the entire return value. Previously, `\"Age: @missing\"` would result in `None`, not it results in `\"Age: <missing>\"`.\n   This change allows for better debugging as it becomes clear exactly which queries are failing.\n   * Add function docstrings\n\n * `1.1.0`\n   * Rename `Getter` to `Query` to more accurately describe what the class does\n   * Migrate queries to use `JQL`\n     * The migration opens the door to nested queries in `Query`, allowing queries, prefixed with `@` to be used\n     as arguments to specials, or even as values in the supported argument data structures\n     * Special arguments are no longer parsed as `JSON`, allowing features like sets, query nesting, and support\n     for single and double quoted strings.\n     * Formatter no longer uses `{{}}` to surround queries. Instead, all queries must be prefixed with `@`, so\n     `\"{{name}} {{age}}\"` -> `\"@name @age\"`. `@@` must be used to get a literal `@` in a formatted string:\n     `\"bob@@gmail.com\"` -> `\"bob@gmail.com\"`\n     * Formatter got about a 2x performance boost\n   * Added `$wrap(prefix, suffix)` to combine `$prefix` and `$suffix`\n   * Added `$remove_nulls`\n   * Added `$lookup(map, fallback=None)`\n   * Added `$wildcard(next, just_value=True)`, which allows level of nesting to be \"skipped\", such that a list\n   of sub-values where `next` is present\n   * Added a `fallback` argument to `$index`\n   * Added `$print` to display the current value in the query\n   * Added `$inject` to allow any valid argument value to be injected into the query to be\n  accessed and transformed by subsequent fields and specials\n\n * `1.0.6`\n   * Add `===` and `!==` to match the strict equality checking needed in the JS version. \n   The methods `seq` and `sne` have been added to `Key` to correspond with the new filters.\n   `===` is the same as `==` and `!==` in the same as `!=` in the Python version.\n   * Rename `null` -> `!present` and `!null` -> `present`. Corresponding methods have been renamed\n   to `not_present` and `present`. This filter will catch values that are `null` or `undefined`.\n   * Make membership filters (`in`, `contains`, `!in` and `!contains`) work properly with \n   strings, lists, dicts, and sets.\n   * Remove `$datetime`. See below for replacement.\n   * Add `$call` and `$attr` for calling a function and accessing an attribute. Can be used to replace\n   `$datetime` functionality.\n   * Remove `Formatter.format` and add `Formatter.single` and `Formatter.many` to be consistent across\n   other classes and support formatting arrays of items.\n   * Add more tests to increase coverage and do basic performance testing\n\n * `1.0.5`\n   * Query strings can now start with specials to allow operations on the entire\n   object being passed.\n   * Bug fixes and more unit tests\n\n * `1.0.4`\n   * Added new specials, mostly relating to time\n     * `$parse_timestamp`\n     * `$datetime`\n     * `$strptime`\n     * `$strftime`\n   * Added `not` filtering and the `interval` and `!interval` operators\n   * Made `Filter` consistent with `Query` by removing `.filter()` and adding\n   `.single()` and `.many()`\n   * Added `fallback` to `Getter`\n   * added numerous unit tests\n\n * `1.0.3`\n   * Rename `Getter.get` to `Getter.single`\n   * Add `Getter.many`\n   * Support getting multiple fields at once by changing `Getter` to allow\n   `Getter(<field>)` and `Getter([<field>, <field>, ...])`\n   * Change `Filter`'s before for when there are no filters. Now, by default,\n   all items will be returned unless `Filter(..., empty_filters_response=False)`\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/BlendingJake/JTools-Py", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "jtools", "package_url": "https://pypi.org/project/jtools/", "platform": "", "project_url": "https://pypi.org/project/jtools/", "project_urls": {"Homepage": "https://github.com/BlendingJake/JTools-Py"}, "release_url": "https://pypi.org/project/jtools/1.1.3/", "requires_dist": ["python-dateutil (>=2)", "antlr4-python3-runtime (>=4.8)"], "requires_python": ">=3.5", "summary": "A Python module that aids filtering, formatting, and transforming JSON-like objects", "version": "1.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>JTools</h1>\n<blockquote>\n<p>JTools is a robust library for interacting with JSON-like objects:\nproviding the ability to quickly query, format, and filter JSON-like data.</p>\n<p>There are three main components:</p>\n</blockquote>\n<ul>\n<li><code>Query</code>: Extract and transform the value of nested fields.\n<ul>\n<li><code>Query(\"data.timestamp.$parse_timestamp.$attr('year')\").many(items)</code></li>\n</ul>\n</li>\n<li><code>Filter</code>: Combine the querying capabilities of <code>Query</code> with the ability\nto define filtering conditions to find just the elements you want.\n<ul>\n<li><code>Filter(Key(\"data.timestamp.$parse_timestamp.$attr('year')\") &gt; 2015).many(data)</code></li>\n</ul>\n</li>\n<li><code>Formatter</code>: Take multiple queries and format them into a string\n<ul>\n<li><code>Formatter(\"Item @data.id was released in @data.timestamp.$parse_timestamp.$attr('year')\").single(data[0])</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>A companion to the JavaScript version of this package: <a href=\"#https://www.npmjs.com/package/@blending_jake/jtools\" rel=\"nofollow\">@blending_jake/jtools</a>.\nThe JavaScript version supports almost the exact same specials, filters, and formatting specification, with the\ngoal of making it a seamless experience to go from querying/filtering/formatting in JavaScript to Python and back.</p>\n</blockquote>\n<h2>Recent Changes</h2>\n<ul>\n<li><code>1.1.3</code></li>\n<li>Changed the behavior of <code>Query(\"\")</code>, from returning the fallback value, to returning the source data element itself.\nFor example, <code>Query(\"\").single(data) == data</code>.</li>\n<li>Added <code>SpecialNotFoundError</code>, which is raised when an invalid special is queried. Can be imported as\n<code>from jtools import SpecialNotFoundError</code></li>\n<li>Added new specials</li>\n<li><code>$store_as(name)</code> Store the current query value in the current context for later use in the query. This does not\nchange the underlying data being queried.</li>\n<li><code>$group_by(key=\"\", count=false)</code> Take an incoming list and group the values by the specified key.\nAny valid JQL query can be used for the key, so <code>\"\"</code> means the value itself. The result by default will be\nkeys to a list of values. However, if <code>count=true</code>, then the result will be keys to the number of elements with each\nkey.</li>\n<li><code>$sort(key=\"\", reverse=false)</code> Sort an incoming list of values by a given key which can be any valid JQL query.\nBy default, <code>key=\"\"</code> means the top-level value will be sorted on.</li>\n<li><code>$dict</code> Take an incoming list of <code>(key, value)</code> pairs and make a dict out of them.</li>\n<li><code>$join_arg(arg, sep=', ')</code> Similar to <code>$join</code> except this operates on an argument instead of the query value.\nEssentially a shortened form of <code>$inject(arg).$join(sep)</code>.</li>\n<li>Changed the underlying special function definition to now include the keyword argument <code>context</code>. This argument is\nimplemented to only be accessed by name to avoid collision if the user provides too many arguments in their query.\nThe purpose of the context is to support specials adding values temporarily to the data\nnamespace of the query, like <code>$store_as</code> does.</li>\n</ul>\n<h2>Glossary</h2>\n<ul>\n<li><a href=\"#install\" rel=\"nofollow\"><code>Installation</code></a></li>\n<li><a href=\"#jql\" rel=\"nofollow\"><code>JQL</code></a></li>\n<li><a href=\"#query\" rel=\"nofollow\"><code>Query</code></a>\n<ul>\n<li><a href=\"#specials\" rel=\"nofollow\"><code>Specials</code></a></li>\n</ul>\n</li>\n<li><a href=\"#filter\" rel=\"nofollow\"><code>Filter</code></a>\n<ul>\n<li><a href=\"#key\" rel=\"nofollow\"><code>Key</code></a></li>\n<li><a href=\"#condition\" rel=\"nofollow\"><code>Condition</code></a></li>\n</ul>\n</li>\n<li><a href=\"#formatter\" rel=\"nofollow\"><code>Formatter</code></a></li>\n<li><a href=\"#performance\" rel=\"nofollow\"><code>Performance</code></a></li>\n<li><a href=\"#changelog\" rel=\"nofollow\"><code>Changelog</code></a></li>\n</ul>\n<h2><a>Installation</a></h2>\n<p><code>pip install jtools</code></p>\n<pre><span class=\"c1\"># import</span>\n<span class=\"kn\">from</span> <span class=\"nn\">jtools</span> <span class=\"kn\">import</span> <span class=\"n\">Query</span><span class=\"p\">,</span> <span class=\"n\">Filter</span><span class=\"p\">,</span> <span class=\"n\">Key</span><span class=\"p\">,</span> <span class=\"n\">Condition</span><span class=\"p\">,</span> <span class=\"n\">Formatter</span>\n</pre>\n<h2><a><code>JQL</code></a></h2>\n<blockquote>\n<p><code>JQL</code> or the <code>JSON Query Language</code> is a custom built query language for <code>JTools</code> which supports powerful features\nlike accessing nested fields, transforming values, and even using nested queries as arguments.\nThe basic format of the language is:</p>\n</blockquote>\n<pre><code>(&lt;field&gt; | $&lt;special&gt;) (. (&lt;field&gt; | $&lt;special&gt;))*\nEX: 'data', 'data.timestamp', 'data.$split', '$split.0'\n</code></pre>\n<h4>field</h4>\n<p>A field is just a value that can be used as an index, like a string or integer key for a map/dict, or an integer for an\narray. By default, any field that can be treated as an integer will be. However, this assumes that any field containing\nonly digits was intended to be an integer index, which isn't always the desired behavior. To stop digit-only\nstrings from becoming integers, set <code>convert_ints=False</code> when creating the query/filter/formatter.</p>\n<p>Fields can only contain the following characters: <code>[-a-zA-Z0-9_]</code>. However, fields with prohibited characters can still\nbe indexed by using the <code>$index</code> special, so to index <code>range[0]</code> use <code>$index(\"range[0]\")</code>.</p>\n<h4>$special</h4>\n<p>A special is a function that is applied to the value that has been queried so far. There is a complete list of specials\n<a href=\"#specials\" rel=\"nofollow\">here</a>. These specials can be passed arguments, which is one of the most powerful features\nof <code>JQL</code>. The syntax is similar to most programming languages: <code>$&lt;special&gt;(&lt;value&gt;(, &lt;value&gt;)*)</code>. Just to note, <code>$&lt;special&gt;()</code>\nis valid, as is <code>$&lt;special&gt;</code>. Many of the specials don't require any arguments, or have default values, allowing\nthe parenthesis to be left off.</p>\n<h5>value</h5>\n<p>A <code>&lt;value&gt;</code> can be:</p>\n<pre><code>[] or [&lt;value&gt;(, &lt;value&gt;)*] - List\n{} or {&lt;value&gt;(, &lt;value&gt;)*} - Set\n{:} or {&lt;key&gt;: &lt;value&gt;(, &lt;key&gt;: &lt;value&gt;)*} - Map/Dict/Object (see below for &lt;key&gt; spec)\nInteger\nFloat\nString w/ '' or \"\"\ntrue\nfalse\nnull\n@&lt;query&gt; - Yep! Nested queries!\n\n&lt;key&gt;:\n    @&lt;query&gt;    \n    Integer\n    Float\n    String\n    true\n    false\n    null\n</code></pre>\n<p>As shown above, values and queries can be nested, so <code>[[1, 2], [\"bob\"], {\"Ann\", 'Ralph'}, {'key': 4, 23: 5}]</code>\nis valid. Additionally, the support for nesting queries is extremely powerful and allows for queries like:\n<code>item.tag.$lookup(@table.colors)</code>, which, for <code>{\"item\": {\"tag\": \"product\"}, \"table\": {\"colors\": {\"product\": \"red\"}}}</code>\nresults in <code>\"red\"</code></p>\n<h2><a>Query</a></h2>\n<blockquote>\n<p><code>Query</code> takes the power of <code>JQL</code> and puts it into practice querying and transforming values\nin JSON-like data.</p>\n</blockquote>\n<h3><code>Query(query, convert_ints=True, fallback=None)</code></h3>\n<ul>\n<li><code>query</code>: <code>str | List[str]</code> The field or fields to query</li>\n<li><code>convert_ints</code>: Whether or not to convert any valid fields to integers</li>\n<li><code>fallback</code>: The value that will result if a non-existent field is queried</li>\n</ul>\n<h4><code>.single(item)</code></h4>\n<blockquote>\n<p>Take a single item and query it using the query(ies) provided</p>\n<p><code>Query(field).single(...) -&gt; result</code></p>\n<p><code>Query([field, field, ...]).single(...) -&gt; [result, result, ...]</code></p>\n</blockquote>\n<h4><code>.many(items)</code></h4>\n<blockquote>\n<p>Take a list of items, and query each item using the query(ies) provided</p>\n<p><code>Query(field).many(...) -&gt; [result, result, ...]</code></p>\n<p><code>Query([field, field, ...]).many(...) -&gt; [[result, result, ...], [result, result, ...], ...]</code></p>\n</blockquote>\n<h3>Notes</h3>\n<ul>\n<li>\n<p>Lists can be indexed as long as <code>Query(..., convert_ints=True)</code>,\nwhich is set to <code>True</code> by default. This allows paths like <code>friends.0</code>. However, <code>convert_ints=False</code>\nshould be used if trying to access fields whose keys are strings containing digits, like\n<code>{\"index\": {\"0\": ...}}</code>. Use <code>$index</code> if you have mixed data where there are some cases where you need to use\nan integer and other times where the digits-only string needs to stay as a string, like in:\n<code>Query(\"item.0.$index(0)\").single({\"item\": {\"0\": [\"tag\"])}) -&gt; 'tag'</code></p>\n</li>\n<li>\n<p>Fields can be indexed after specials, so <code>$split.0</code> is completely valid</p>\n</li>\n<li>\n<p>You don't have to use <code>()</code> at the end of a special if there aren't any\narguments, or the default arguments are acceptable.</p>\n</li>\n<li>\n<p>More specials can be added by using the class attribute <code>.register_special()</code>\nlike so: <code>Query.register_special(&lt;name&gt;, &lt;func&gt;)</code>. The function should take\nat least one argument positional argument, which is the current value in the query string,\nand the keyword argument 'context' at the end: <code>lambda value, *args, context: ...</code></p>\n</li>\n</ul>\n<h3><a>Specials</a></h3>\n<blockquote>\n<p>Below is a list of all of the specials that can be used. Additionally, more can be added\nas discussed above.</p>\n</blockquote>\n<p>General</p>\n<ul>\n<li><code>$length -&gt; int</code></li>\n<li><code>$lookup(map: dict, fallback=None) -&gt; any</code>: Lookup the current value in the provided map/dict</li>\n<li><code>$inject(value: any) -&gt; any</code>: Inject a value into the query</li>\n<li><code>$print -&gt; any</code>: Print the current query value before continuing to pass that value along</li>\n<li><code>store_as(name: str) -&gt; any</code>: Store the current query value in the current context for later use in the query. This does not\nchange the underlying data being queried.</li>\n<li><code>group_by(key=\"\", count=false) -&gt; Dict[any, Union[List[any], int]]</code>: Take an incoming list and group the values\nby the specified key. Any valid JQL query can be used for the key, so <code>\"\"</code> means the value itself.\nThe result by default will be keys to a list of values. However, if <code>count=true</code>, then the result will be keys\nto the number of elements with each key.</li>\n</ul>\n<p>Maps</p>\n<ul>\n<li><code>$keys -&gt; list</code></li>\n<li><code>$values -&gt; list</code></li>\n<li><code>$items -&gt; List[tuple]</code></li>\n<li><code>$wildcard(next, just_value=true) -&gt; List[any]</code>: On a given map or list, go through all values and see if <code>next</code> is\na defined field. If it is, then return just the value of <code>next</code> on that item, if <code>just_value=true</code>, or the entire\nitem otherwise. This special allows a nested field to be extracted across multiple items where it it present.\nFor example:</li>\n</ul>\n<pre><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"a\"</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s2\">\"tag\"</span><span class=\"p\">:</span> <span class=\"s2\">\"run\"</span><span class=\"p\">},</span>\n    <span class=\"s2\">\"b\"</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s2\">\"tag\"</span><span class=\"p\">:</span> <span class=\"s2\">\"to-do\"</span><span class=\"p\">,</span> <span class=\"s2\">\"other\"</span><span class=\"p\">:</span> <span class=\"s2\">\"task\"</span><span class=\"p\">},</span>\n    <span class=\"s2\">\"meta\"</span><span class=\"p\">:</span> <span class=\"kc\">None</span>\n<span class=\"p\">}</span>\n<span class=\"n\">Query</span><span class=\"p\">(</span><span class=\"s1\">'$wildcard(\"tag\")'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">single</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>  <span class=\"c1\"># =&gt; [\"run\", \"to-do\"]</span>\n<span class=\"n\">Query</span><span class=\"p\">(</span><span class=\"s1\">'$wildcard(\"tag\", false)'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">single</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"c1\"># =&gt; [{\"tag\": \"run\"}, {\"tag\": \"to-do\", \"other\": \"task\"}]</span>\n</pre>\n<p>Type Conversions</p>\n<ul>\n<li><code>$set -&gt; set</code></li>\n<li><code>$float -&gt; float</code></li>\n<li><code>$string -&gt; str</code></li>\n<li><code>$dict -&gt; dict</code>: Take an incoming list of <code>(key, value)</code> pairs and make a dict out of them.</li>\n<li><code>$int -&gt; int</code></li>\n<li><code>$not -&gt; bool</code>: Returns <code>!value</code></li>\n<li><code>$fallback(fallback) -&gt; value or fallback</code>: If the value is None, then it will be replaced with <code>fallback</code>.</li>\n<li><code>$ternary(if_true, if_false, strict=false) -&gt; any</code>: Return <code>if_true</code> if the value is <code>truish</code>, otherwise,\nreturn <code>if_false</code>. Pass <code>true</code> for <code>strict</code> if the value must be <code>True</code> and not just <code>truish</code>.</li>\n</ul>\n<p>Datetime</p>\n<ul>\n<li><code>$parse_timestamp -&gt; datetime</code>: Take a Unix timestamp in seconds and return a corresponding datetime object</li>\n<li><code>$strptime(fmt=null) -&gt; datetime</code>: Parse a datetime string and return a corresponding datetime object.\nIf <code>fmt=null</code>, then common formats will be tried. Refer to\n<a href=\"https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior\" rel=\"nofollow\">https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior</a> for formatting instructions</li>\n<li><code>$timestamp -&gt; float</code>: Dump a datetime object to a UTC timestamp as a float</li>\n<li><code>$strftime(fmt=\"%Y-%m-%dT%H:%M:%SZ\") -&gt; str</code>: Format a datetime object as a string using <code>fmt</code>.\nRefer to <a href=\"https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior\" rel=\"nofollow\">https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior</a> for formatting instructions</li>\n</ul>\n<p>Math / Numbers</p>\n<ul>\n<li><code>$add(num) -&gt; Union[int, float]</code></li>\n<li><code>$subtract(num) -&gt; Union[int, float]</code></li>\n<li><code>$multiply(num) -&gt; Union[int, float]</code></li>\n<li><code>$divide(num) -&gt; float</code></li>\n<li><code>$pow(num) -&gt; Union[int, float]</code></li>\n<li><code>$abs(num) -&gt; Union[int, float]</code></li>\n<li><code>$distance(other) -&gt; float</code>: Euler distance in N-dimensions</li>\n<li><code>$math(attr) -&gt; any</code>: Returns <code>math.&lt;attr&gt;(value)</code>, which can be used for\noperations like <code>floor</code>, <code>cos</code>, <code>sin</code>, etc.</li>\n<li><code>$round(n=2) -&gt; float</code></li>\n</ul>\n<p>Strings</p>\n<ul>\n<li><code>$prefix(prefix) -&gt; str</code>: Prefix the value with the specified string</li>\n<li><code>$suffix(suffix) -&gt; str</code>: Concatenate a string to the end of the value</li>\n<li><code>$wrap(prefix, suffix) -&gt; str</code>: Wrap a string with a prefix and suffix. Combines features of above two specials.</li>\n<li><code>$strip -&gt; str</code>: Strip leading and trailing whitespace</li>\n<li><code>$replace(old, new) -&gt; str</code>: Replace all occurrences of a string</li>\n<li><code>$trim(length=50, suffix=\"...\") -&gt; str</code>: Trim the length of a string</li>\n<li><code>$split(on=\" \") -&gt; List[str]</code>: Split a string</li>\n</ul>\n<p>Lists</p>\n<ul>\n<li><code>$sum -&gt; Union[float, int]</code>: Return the sum of the items in the value</li>\n<li><code>$join(sep=\", \") -&gt; str</code>: Join a list using the specified separator</li>\n<li><code>$join_arg(arg: list, sep=\", \")</code>: Similar to <code>$join</code> except this operates on an argument instead of the query value.\nEssentially a shortened form of <code>$inject(arg).$join(sep)</code>.</li>\n<li><code>$index(index, fallback=null) -&gt; any</code>: Index a list. Negative indices are allowed.</li>\n<li><code>$range(start, end=null) -&gt;</code>: Get a sublist. Defaults to <code>value[start:]</code>,\nbut an end value can be specified. Negative indices are allowed.</li>\n<li><code>$remove_nulls -&gt; List[any]</code>: Remove any values that are <code>None</code></li>\n<li><code>$sort(key=\"\", reverse=false)</code>: Sort an incoming list of values by a given key which can be any valid JQL query.\nBy default, <code>key=\"\"</code> means the top-level value will be sorted on.</li>\n<li><code>$map(special, *args) -&gt; list</code>: Apply <code>special</code> to every element in the\nvalue. Arguments can be passed through to the special being used, like <code>$map(\"index\", \"name\")</code></li>\n</ul>\n<p>Attributes</p>\n<ul>\n<li><code>$call(func, *args) -&gt; any</code>: Call a function that is on the current value, implemented as <code>getattr(value, func)(*args)</code></li>\n<li><code>$attr(attr) -&gt; any</code>: Access an attribute of the given object, implemented as <code>getattr(value, attr)</code></li>\n</ul>\n<h2><a>Filter</a></h2>\n<blockquote>\n<p><code>Filter</code> takes the power of <code>JQL</code> and combines it with\nfiltering conditions to allow lists of items to be filtered down to just those of\ninterest. The filters can be manually built, or the <code>Key</code> and <code>Condition</code> classes can\nbe used to simplify your code.</p>\n</blockquote>\n<h3><code>Filter(filters, convert_ints=True, empty_filters_response=True, missing_field_response=False)</code></h3>\n<ul>\n<li><code>filters</code>: <code>Condition | List[dict]</code> The filters to apply to any data. If <code>List[dict]</code>, then the\nfilters should be formatted as shown below.</li>\n</ul>\n<pre><code>[\n    {\"field\": &lt;field&gt;, \"operator\": &lt;op&gt;, \"value\": &lt;value&gt;},\n\n    OR\n\n    {\"or\": &lt;nested outer structure&gt;},\n\n    OR\n\n    {\"not\": &lt;nested outer structure&gt;},\n\n    ...\n]\n&lt;field&gt;: any valid `JQL` query\n&lt;op&gt;: See list below\n&lt;value&gt;: Anything that makes sense for the operator\n</code></pre>\n<ul>\n<li><code>convert_ints</code>: <code>bool</code> Corresponds with the argument with the same name in <code>Query</code>. Determines\nwhether digit only fields are treated as integers or strings. Defaults to <code>True</code>.</li>\n<li><code>empty_filters_response</code>: <code>bool</code> Determines what gets returned when no filters are supplied.</li>\n<li><code>missing_field_response</code>: <code>bool</code> Determines the result of a filter where the field could not be found.</li>\n</ul>\n<h4><code>.single(item)</code></h4>\n<blockquote>\n<p>Take a single item and determine whether it satisfies the filters or not</p>\n<p><code>Filter(filters).single(...) -&gt; True/False</code></p>\n</blockquote>\n<h4><code>.many(items)</code></h4>\n<blockquote>\n<p>Take a list of items, and returns only those which satisfy the filters</p>\n<p><code>Filter(filters).many(...) -&gt; [result, result, ...]</code></p>\n</blockquote>\n<h3>Notes</h3>\n<pre><code>{\"or\": [ \n    [ {filter1}, {filter2} ], \n    {filter3} \n]} === (filter1 AND filter2) OR filter3\n</code></pre>\n<blockquote>\n<p>Nesting in an <code>or</code> will cause those filters\nto be <code>AND'd</code> and then everything in the toplevel of that <code>or</code> will be <code>OR'd</code>.</p>\n</blockquote>\n<p>Operators:</p>\n<ul>\n<li><code>&gt;</code></li>\n<li><code>&lt;</code></li>\n<li><code>&gt;=</code></li>\n<li><code>&lt;=</code></li>\n<li><code>==</code></li>\n<li><code>!=</code></li>\n<li><code>===</code>: same as <code>==</code> in Python</li>\n<li><code>!==</code>: same as <code>!=</code> in Python</li>\n<li><code>in</code>: <code>&lt;field&gt; in &lt;value&gt;</code></li>\n<li><code>!in</code></li>\n<li><code>contains</code>: <code>&lt;value&gt; in &lt;field&gt;</code></li>\n<li><code>!contains</code></li>\n<li><code>interval</code>: <code>&lt;field&gt; in interval [value[0], value[1]]</code> (closed/inclusive interval)</li>\n<li><code>!interval</code>: <code>&lt;field&gt; not in interval [value[0], value[1]]</code></li>\n<li><code>startswith</code></li>\n<li><code>endswith</code></li>\n<li><code>present</code></li>\n<li><code>!present</code></li>\n</ul>\n<h4><a>Key</a></h4>\n<blockquote>\n<p>Intended to simplify having to write <code>{\"field\": &lt;field&gt;, \"operator\": &lt;operator&gt;, \"value\": value}</code>\na lot. The basic usage is: <code>Key(&lt;field&gt;).&lt;op&gt;(&lt;value&gt;)</code>, or for the first six\noperators, the actual Python operators can be used, so <code>Key(&lt;field&gt;) &lt;op&gt; &lt;value&gt;</code>.\nFor example: <code>Key(\"meta.id\").eq(12)</code> is the same as <code>Key(\"meta.id\") == 12</code>,\nwhich is the same as <code>{\"field\": \"meta.id\", \"operator\": \"==\", \"value\": 12}</code>.</p>\n</blockquote>\n<blockquote>\n<p>The table below describes all of the functions which map to the underlying conditions, but, in\naddition, there is the <code>.operator(op: str)</code> function which can be use to build a filter.\nFor example: <code>Key(&lt;field&gt;).operator(&lt;op&gt;).value(&lt;value&gt;)</code> is the same as\n<code>{\"field\": &lt;field&gt;, \"operator\": &lt;op&gt;, \"value\": &lt;value&gt;}</code></p>\n</blockquote>\n<p>Operators:</p>\n<table>\n<thead>\n<tr>\n<th>underlying operator</th>\n<th><code>Key</code> function</th>\n<th><code>Python</code> operator</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&gt;</code></td>\n<td><code>gt</code></td>\n<td><code>&gt;</code></td>\n</tr>\n<tr>\n<td><code>&lt;</code></td>\n<td><code>lt</code></td>\n<td><code>&lt;</code></td>\n</tr>\n<tr>\n<td><code>&lt;=</code></td>\n<td><code>lte</code></td>\n<td><code>&lt;=</code></td>\n</tr>\n<tr>\n<td><code>&gt;=</code></td>\n<td><code>gte</code></td>\n<td><code>&gt;=</code></td>\n</tr>\n<tr>\n<td><code>==</code></td>\n<td><code>eq</code></td>\n<td><code>==</code></td>\n</tr>\n<tr>\n<td><code>!=</code></td>\n<td><code>ne</code></td>\n<td><code>!=</code></td>\n</tr>\n<tr>\n<td><code>===</code></td>\n<td><code>seq</code></td>\n<td>N/A</td>\n</tr>\n<tr>\n<td><code>!==</code></td>\n<td><code>sne</code></td>\n<td>N/A</td>\n</tr>\n<tr>\n<td><code>in</code></td>\n<td><code>in_</code></td>\n<td>N/A</td>\n</tr>\n<tr>\n<td><code>!in</code></td>\n<td><code>nin</code></td>\n<td>N/A</td>\n</tr>\n<tr>\n<td><code>contains</code></td>\n<td><code>contains</code></td>\n<td>N/A</td>\n</tr>\n<tr>\n<td><code>!contains</code></td>\n<td><code>not_contains</code></td>\n<td>N/A</td>\n</tr>\n<tr>\n<td><code>interval</code></td>\n<td><code>interval</code></td>\n<td>N/A</td>\n</tr>\n<tr>\n<td><code>!interval</code></td>\n<td><code>not_interval</code></td>\n<td>N/A</td>\n</tr>\n<tr>\n<td><code>startswith</code></td>\n<td><code>startswith</code></td>\n<td>N/A</td>\n</tr>\n<tr>\n<td><code>endswith</code></td>\n<td><code>endswith</code></td>\n<td>N/A</td>\n</tr>\n<tr>\n<td><code>present</code></td>\n<td><code>present</code></td>\n<td>N/A</td>\n</tr>\n<tr>\n<td><code>!present</code></td>\n<td><code>not_present</code></td>\n<td>N/A</td>\n</tr></tbody></table>\n<h4><a>Condition</a></h4>\n<blockquote>\n<p>Intended to be used in combination with <code>Key</code> to make creating filters\neasier than manually creating the <code>JSON</code>. There are three conditions supported:\n<code>and</code>, <code>or</code>, and <code>not</code>. They can be manually accessed via <code>and_(*args)</code>, <code>or_(*args)</code>, and <code>not_()</code>,\nor through the overloaded operators <code>&amp;</code>, <code>|</code>, and <code>~</code>, respectively.</p>\n</blockquote>\n<p><strong>Caution: <code>&amp;</code> and <code>|</code> bind tighter than the comparisons operators and <code>~</code> binds the tightest</strong>\n<code>Key(\"first_name\") == \"John\" | Key(\"first_name\") == \"Bill\"</code> is actually\n<code>(Key(\"first_name\") == (\"John\" | Key(\"first_name\"))) == \"Bill\"</code>, not\n<code>(Key(\"first_name\") == \"John\") | (Key(\"first_name\") == \"Bill\")</code></p>\n<blockquote>\n<p>Examples</p>\n</blockquote>\n<pre><span class=\"n\">Key</span><span class=\"p\">(</span><span class=\"s2\">\"state\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">eq</span><span class=\"p\">(</span><span class=\"s2\">\"Texas\"</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">Key</span><span class=\"p\">(</span><span class=\"s2\">\"city\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">eq</span><span class=\"p\">(</span><span class=\"s2\">\"New York\"</span><span class=\"p\">)</span>\n\n<span class=\"p\">(</span><span class=\"n\">Key</span><span class=\"p\">(</span><span class=\"s2\">\"gender\"</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s2\">\"male\"</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"p\">(</span><span class=\"n\">Key</span><span class=\"p\">(</span><span class=\"s2\">\"age\"</span><span class=\"p\">)</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">18</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"p\">(</span><span class=\"n\">Key</span><span class=\"p\">(</span><span class=\"s2\">\"selective_service\"</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">False</span><span class=\"p\">)</span>\n\n<span class=\"n\">Key</span><span class=\"p\">(</span><span class=\"s1\">'creation_time.$parse_timestamp.$attr(\"year\")'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">lt</span><span class=\"p\">(</span><span class=\"mi\">2005</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">or_</span><span class=\"p\">(</span>\n    <span class=\"n\">Key</span><span class=\"p\">(</span><span class=\"s1\">'creation_time.$parse_timestamp.$attr(\"year\")'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">gt</span><span class=\"p\">(</span><span class=\"mi\">2015</span><span class=\"p\">)</span>\n<span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">and_</span><span class=\"p\">(</span>\n    <span class=\"n\">Key</span><span class=\"p\">(</span><span class=\"s2\">\"product_id\"</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">15</span>\n<span class=\"p\">)</span>\n<span class=\"c1\"># (year &lt; 2005 OR year &gt; 2015) AND product_id == 15</span>\n</pre>\n<h2><a>Formatter</a></h2>\n<blockquote>\n<p><code>Formatter</code> allows fields to be queried from an object and then formatted into a string.\nAny JQL queries in a format string should be prefixed with <code>@</code>. For example,\n<code>Formatter('Name: @name}').single({\"name\": \"John Smith\"})</code> results in\n<code>Name: John Smith</code>.</p>\n</blockquote>\n<h3><code>Formatter(spec, fallback=\"&lt;missing&gt;\", convert_ints=True)</code></h3>\n<ul>\n<li><code>spec</code>: <code>str</code> The format string</li>\n<li><code>fallback</code>: <code>str</code> The value that will be used in the formatted string if a query could not be performed.\nFor example, if the field <code>missing</code> does exist, then the query <code>\"Age: @missing\"</code> will result in <code>\"Age: &lt;missing&gt;\"</code></li>\n<li><code>convert_ints</code>: <code>bool</code> Whether digit-only fields get treated as integers or strings</li>\n</ul>\n<h4><code>.single(item)</code></h4>\n<blockquote>\n<p>Return a formatted string or the fallback value if the query fails</p>\n</blockquote>\n<h4><code>.many(items)</code></h4>\n<blockquote>\n<p>Return a list of formatted strings or the fallback value.</p>\n</blockquote>\n<h3>Notes</h3>\n<blockquote>\n<p>The differences between <code>Query</code> and <code>Formatter</code> are:</p>\n</blockquote>\n<ul>\n<li><code>Query</code> can return a value of any type, <code>Formatter</code> just returns strings</li>\n<li><code>Formatter</code> supports multiple queries, end-to-end, <code>Query</code> does not</li>\n<li>All queries must be prefixed with <code>@</code> with <code>Formatter</code>, not just when used as an argument like with <code>Query</code></li>\n<li>Both support all the features of <code>JQL</code></li>\n<li><code>Query</code> actually can theoretically do everything <code>Formatter</code> does by using <code>$prefix</code>, <code>$suffix</code>, and <code>$string</code>.\nFor example, <code>'@name @age'</code> -&gt; <code>'name.$suffix(\" \").$suffix(@age)'</code>. However, the latter is much longer than the former.</li>\n</ul>\n<p>Example (flattening operations):</p>\n<pre><span class=\"n\">errors</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"errors\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s2\">\"Process Error\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Could not communicate with the subprocess\"</span><span class=\"p\">,</span>\n        <span class=\"s2\">\"Connection Error\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Could not connect with the database instance\"</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Formatter</span><span class=\"p\">(</span><span class=\"s1\">'Errors: </span><span class=\"se\">\\n</span><span class=\"s1\">@errors.$items.$map(\"join\", \": </span><span class=\"se\">\\\\</span><span class=\"s1\">n</span><span class=\"se\">\\\\</span><span class=\"s1\">t\").$join(\"</span><span class=\"se\">\\\\</span><span class=\"s1\">n\")'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">single</span><span class=\"p\">(</span><span class=\"n\">errors</span><span class=\"p\">)</span>\n<span class=\"c1\"># Errors:</span>\n<span class=\"c1\"># Process Error: </span>\n<span class=\"c1\">#   Could not communicate with the subprocess</span>\n<span class=\"c1\"># Connection Error: </span>\n<span class=\"c1\">#   Could not connect with the database instance</span>\n</pre>\n<blockquote>\n<p>The above example shows a powerful usage of flattening <code>errors</code> into its items,\nthen joining each item; splitting the error name and message between lines, then\njoining all the errors together.</p>\n</blockquote>\n<p>Example (nested replacement):</p>\n<pre><span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"x1\"</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"y1\"</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"x2\"</span><span class=\"p\">:</span> <span class=\"mi\">12</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"y2\"</span><span class=\"p\">:</span> <span class=\"mi\">54</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Formatter</span><span class=\"p\">(</span>\n    <span class=\"s2\">\"Midpoint: [@x2.$subtract(@x1).$divide(2), @y2.$subtract(@y1).$divide(2)]\"</span>\n<span class=\"p\">)</span>\n<span class=\"c1\"># Midpoint: [5.5, 26.5]</span>\n</pre>\n<blockquote>\n<p>Additionally, the speed of formatting is very quick. The above statement\ncan be preformed 10,000 times in around 0.36 seconds.</p>\n</blockquote>\n<h2><a>Performance</a></h2>\n<blockquote>\n<p>There are several ways to increase the performance of querying, filtering, and formatting. The performance gains can be had\nby limiting the amount of times a query string has to be parsed. This means that using a <code>Query</code>,\n<code>Filter</code>, or <code>Formatter</code> object multiple times will be faster then creating a new object every time.</p>\n<p>For example:</p>\n</blockquote>\n<pre><span class=\"c1\"># slower</span>\n<span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">items</span><span class=\"p\">:</span>\n    <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">Query</span><span class=\"p\">(</span><span class=\"s2\">\"timestamp.$parse_timestamp\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">single</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span>\n    <span class=\"c1\"># do other stuff</span>\n\n<span class=\"c1\"># faster</span>\n<span class=\"n\">query</span> <span class=\"o\">=</span> <span class=\"n\">Query</span><span class=\"p\">(</span><span class=\"s2\">\"timestamp.$parse_timestamp\"</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">items</span><span class=\"p\">:</span>\n    <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">query</span><span class=\"o\">.</span><span class=\"n\">single</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span>\n    <span class=\"c1\"># do other stuff</span>\n</pre>\n<blockquote>\n<p>Across 10,000 runs:</p>\n</blockquote>\n<ul>\n<li>reusing <code>Query</code> can improve performance by 302x</li>\n<li>reusing <code>Filter</code> can improve performance by 132x</li>\n<li>reusing <code>Formatter</code> can improve performance by 377x.</li>\n</ul>\n<h2><a>Changelog</a></h2>\n<ul>\n<li>\n<p><code>1.1.2</code></p>\n<ul>\n<li>Minor changes to documentation</li>\n<li>Mostly just to get version back on track with repository</li>\n</ul>\n</li>\n<li>\n<p><code>1.1.1</code></p>\n<ul>\n<li>Add <code>antlr4-python3</code> requirement to <code>setup.py</code> so that installation will get the needed dependencies</li>\n<li>Change <code>JQL</code> so that field and special names must only contain <code>[-a-zA-Z0-9_]</code>. <code>$index</code> can be used to get fields\nwith prohibited characters. The change was to support more formatting use-cases, like <code>Age: @age, DOB: @dob</code>, which\npreviously would have failed because the <code>,</code> would have been considered part of the field name.</li>\n<li>Change <code>Formatter</code> so that <code>fallback</code> is just a string that is substituted for invalid queries, instead of being\nthe entire return value. Previously, <code>\"Age: @missing\"</code> would result in <code>None</code>, not it results in <code>\"Age: &lt;missing&gt;\"</code>.\nThis change allows for better debugging as it becomes clear exactly which queries are failing.</li>\n<li>Add function docstrings</li>\n</ul>\n</li>\n<li>\n<p><code>1.1.0</code></p>\n<ul>\n<li>Rename <code>Getter</code> to <code>Query</code> to more accurately describe what the class does</li>\n<li>Migrate queries to use <code>JQL</code>\n<ul>\n<li>The migration opens the door to nested queries in <code>Query</code>, allowing queries, prefixed with <code>@</code> to be used\nas arguments to specials, or even as values in the supported argument data structures</li>\n<li>Special arguments are no longer parsed as <code>JSON</code>, allowing features like sets, query nesting, and support\nfor single and double quoted strings.</li>\n<li>Formatter no longer uses <code>{{}}</code> to surround queries. Instead, all queries must be prefixed with <code>@</code>, so\n<code>\"{{name}} {{age}}\"</code> -&gt; <code>\"@name @age\"</code>. <code>@@</code> must be used to get a literal <code>@</code> in a formatted string:\n<code>\"bob@@gmail.com\"</code> -&gt; <code>\"bob@gmail.com\"</code></li>\n<li>Formatter got about a 2x performance boost</li>\n</ul>\n</li>\n<li>Added <code>$wrap(prefix, suffix)</code> to combine <code>$prefix</code> and <code>$suffix</code></li>\n<li>Added <code>$remove_nulls</code></li>\n<li>Added <code>$lookup(map, fallback=None)</code></li>\n<li>Added <code>$wildcard(next, just_value=True)</code>, which allows level of nesting to be \"skipped\", such that a list\nof sub-values where <code>next</code> is present</li>\n<li>Added a <code>fallback</code> argument to <code>$index</code></li>\n<li>Added <code>$print</code> to display the current value in the query</li>\n<li>Added <code>$inject</code> to allow any valid argument value to be injected into the query to be\naccessed and transformed by subsequent fields and specials</li>\n</ul>\n</li>\n<li>\n<p><code>1.0.6</code></p>\n<ul>\n<li>Add <code>===</code> and <code>!==</code> to match the strict equality checking needed in the JS version.\nThe methods <code>seq</code> and <code>sne</code> have been added to <code>Key</code> to correspond with the new filters.\n<code>===</code> is the same as <code>==</code> and <code>!==</code> in the same as <code>!=</code> in the Python version.</li>\n<li>Rename <code>null</code> -&gt; <code>!present</code> and <code>!null</code> -&gt; <code>present</code>. Corresponding methods have been renamed\nto <code>not_present</code> and <code>present</code>. This filter will catch values that are <code>null</code> or <code>undefined</code>.</li>\n<li>Make membership filters (<code>in</code>, <code>contains</code>, <code>!in</code> and <code>!contains</code>) work properly with\nstrings, lists, dicts, and sets.</li>\n<li>Remove <code>$datetime</code>. See below for replacement.</li>\n<li>Add <code>$call</code> and <code>$attr</code> for calling a function and accessing an attribute. Can be used to replace\n<code>$datetime</code> functionality.</li>\n<li>Remove <code>Formatter.format</code> and add <code>Formatter.single</code> and <code>Formatter.many</code> to be consistent across\nother classes and support formatting arrays of items.</li>\n<li>Add more tests to increase coverage and do basic performance testing</li>\n</ul>\n</li>\n<li>\n<p><code>1.0.5</code></p>\n<ul>\n<li>Query strings can now start with specials to allow operations on the entire\nobject being passed.</li>\n<li>Bug fixes and more unit tests</li>\n</ul>\n</li>\n<li>\n<p><code>1.0.4</code></p>\n<ul>\n<li>Added new specials, mostly relating to time\n<ul>\n<li><code>$parse_timestamp</code></li>\n<li><code>$datetime</code></li>\n<li><code>$strptime</code></li>\n<li><code>$strftime</code></li>\n</ul>\n</li>\n<li>Added <code>not</code> filtering and the <code>interval</code> and <code>!interval</code> operators</li>\n<li>Made <code>Filter</code> consistent with <code>Query</code> by removing <code>.filter()</code> and adding\n<code>.single()</code> and <code>.many()</code></li>\n<li>Added <code>fallback</code> to <code>Getter</code></li>\n<li>added numerous unit tests</li>\n</ul>\n</li>\n<li>\n<p><code>1.0.3</code></p>\n<ul>\n<li>Rename <code>Getter.get</code> to <code>Getter.single</code></li>\n<li>Add <code>Getter.many</code></li>\n<li>Support getting multiple fields at once by changing <code>Getter</code> to allow\n<code>Getter(&lt;field&gt;)</code> and <code>Getter([&lt;field&gt;, &lt;field&gt;, ...])</code></li>\n<li>Change <code>Filter</code>'s before for when there are no filters. Now, by default,\nall items will be returned unless <code>Filter(..., empty_filters_response=False)</code></li>\n</ul>\n</li>\n</ul>\n\n          </div>"}, "last_serial": 6909349, "releases": {"1.0.1": [{"comment_text": "", "digests": {"md5": "b067bda353d8b2d3a47feffe20c60a46", "sha256": "8cbb1e30347159fec3a68dab4e4edc654de403644a26909b661668c0a561e22e"}, "downloads": -1, "filename": "jtools-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "b067bda353d8b2d3a47feffe20c60a46", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 10366, "upload_time": "2020-01-20T01:48:50", "upload_time_iso_8601": "2020-01-20T01:48:50.638783Z", "url": "https://files.pythonhosted.org/packages/14/fe/7ecfe96452a62898e50c9c0802bf9e2906fbb809f8d93fb6087256686913/jtools-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "004a863fd0059c55df0805ab073a6184", "sha256": "af4851e11a62a60494546f35a66b341a1f24f8cc0cbf69b0aa30931a4a7988dd"}, "downloads": -1, "filename": "jtools-1.0.1.tar.gz", "has_sig": false, "md5_digest": "004a863fd0059c55df0805ab073a6184", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 13095, "upload_time": "2020-01-20T01:48:53", "upload_time_iso_8601": "2020-01-20T01:48:53.148884Z", "url": "https://files.pythonhosted.org/packages/47/63/e063ca230ba8b50ad7e98e3a6a50447a0c6c79cb988e526e3a29707f6756/jtools-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "da60b963f74a60d888427d7beafc6abe", "sha256": "e61361aaf022dd17f2044c312ca938caf88a846129c5ebbdddaaa9f4fae76be0"}, "downloads": -1, "filename": "jtools-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "da60b963f74a60d888427d7beafc6abe", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 11351, "upload_time": "2020-01-22T01:54:05", "upload_time_iso_8601": "2020-01-22T01:54:05.670138Z", "url": "https://files.pythonhosted.org/packages/47/60/53c38aa9de3528639aaae8b3e6d4d1866081c0d82080a220db64f8e1a412/jtools-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "de7f01ca3da65631b60a5e2ae4710418", "sha256": "0030c1f1765706e5f7ccdc50bb5c11b9a2c6c11a9130367d0cb89d70cb740663"}, "downloads": -1, "filename": "jtools-1.0.2.tar.gz", "has_sig": false, "md5_digest": "de7f01ca3da65631b60a5e2ae4710418", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 14570, "upload_time": "2020-01-22T01:54:09", "upload_time_iso_8601": "2020-01-22T01:54:09.238474Z", "url": "https://files.pythonhosted.org/packages/41/c5/5aedc73dd1135b8e58e81ef71ca99bdde87b63a1fa54681d4eda194dc326/jtools-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "170bed79008afdea7c3ba636359491b0", "sha256": "6eb8d41536e0722305ee93ddeb13750d13a53fd65d04782bcca7833f7b0ddeb5"}, "downloads": -1, "filename": "jtools-1.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "170bed79008afdea7c3ba636359491b0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 11986, "upload_time": "2020-01-23T00:47:58", "upload_time_iso_8601": "2020-01-23T00:47:58.499822Z", "url": "https://files.pythonhosted.org/packages/2a/6b/f64d53fbe7ea4bcf3543561188da302ac271f9074dd83b63d42eb7c92c3c/jtools-1.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "76b8d0cb25e0869d23186aec9bc5fd48", "sha256": "a9d320d1b30abceefd70df91d92669dbb7c608bfbab280afbda81e912ca2eb17"}, "downloads": -1, "filename": "jtools-1.0.3.tar.gz", "has_sig": false, "md5_digest": "76b8d0cb25e0869d23186aec9bc5fd48", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 15509, "upload_time": "2020-01-23T00:47:59", "upload_time_iso_8601": "2020-01-23T00:47:59.803623Z", "url": "https://files.pythonhosted.org/packages/cb/3d/3b5bf0555aadf40c84ac3dffb27b46b7e8a15c39cafd2ade6f3b64582c35/jtools-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "658f374deb1f9e18513d2e9d085adea5", "sha256": "0d90937930c71e72ebe2c7ada199432f335314ce3de79fc8886dcdfa1c5d3ce7"}, "downloads": -1, "filename": "jtools-1.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "658f374deb1f9e18513d2e9d085adea5", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 13116, "upload_time": "2020-02-04T02:09:50", "upload_time_iso_8601": "2020-02-04T02:09:50.337723Z", "url": "https://files.pythonhosted.org/packages/7a/98/baba5c9682b811f456b8e7952f0efe737238972ddfb1b802d06f790c8a26/jtools-1.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4681febc4f627f51dbc9efe4f314ea9b", "sha256": "446eebc8f2cd97c4d7efcd1171dc3880e8b217389d448aff89a2656d17aff4d6"}, "downloads": -1, "filename": "jtools-1.0.4.tar.gz", "has_sig": false, "md5_digest": "4681febc4f627f51dbc9efe4f314ea9b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 17864, "upload_time": "2020-02-04T02:09:51", "upload_time_iso_8601": "2020-02-04T02:09:51.432094Z", "url": "https://files.pythonhosted.org/packages/ba/2c/ef0627cf0694723524b83f940dc477c9b4d6f87ee4bf84c89db2c72f85af/jtools-1.0.4.tar.gz", "yanked": false}], "1.0.5": [{"comment_text": "", "digests": {"md5": "475220b502584cc737730a1d5c93dd4d", "sha256": "ae44a74da51103a2e93e81830d9c35d9cf87ea30e59db19003db4fbc109b7695"}, "downloads": -1, "filename": "jtools-1.0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "475220b502584cc737730a1d5c93dd4d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 15501, "upload_time": "2020-02-18T00:50:07", "upload_time_iso_8601": "2020-02-18T00:50:07.700462Z", "url": "https://files.pythonhosted.org/packages/7f/42/26f77db549defdad975ea48c7c38b1d623c881a2dfe2256d85585f833e63/jtools-1.0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "94dcbfcdc870a11d80b349ddb93bd7c8", "sha256": "524c8fb943cd6e761ab4f7ebdf0aa6217e08d6a5ba97ddae2625a7399abf34e5"}, "downloads": -1, "filename": "jtools-1.0.5.tar.gz", "has_sig": false, "md5_digest": "94dcbfcdc870a11d80b349ddb93bd7c8", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 19427, "upload_time": "2020-02-18T00:50:08", "upload_time_iso_8601": "2020-02-18T00:50:08.974882Z", "url": "https://files.pythonhosted.org/packages/da/14/3d17dda701015b93bf79317dce4916fab8041243f63b6b0f6e286ba38dad/jtools-1.0.5.tar.gz", "yanked": false}], "1.0.6": [{"comment_text": "", "digests": {"md5": "a51db29217e031702ffeb8208dc0fca1", "sha256": "f88081d0fea66d3be55942eb74bb0326fd42a510ebc7ef90ed10cb4f773b6eca"}, "downloads": -1, "filename": "jtools-1.0.6-py3-none-any.whl", "has_sig": false, "md5_digest": "a51db29217e031702ffeb8208dc0fca1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 20892, "upload_time": "2020-02-23T01:07:18", "upload_time_iso_8601": "2020-02-23T01:07:18.516035Z", "url": "https://files.pythonhosted.org/packages/6a/36/503a2fd2b49f0c8b6fafe839fc9bb96e7bc39634f8d18e7f942f79fd2cbf/jtools-1.0.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "579a0c4e8e309c18e956636945e92066", "sha256": "4e5211241c955daa07c36461a4e4fb2375d0dd12be4efb148fa85c6aaa439bb5"}, "downloads": -1, "filename": "jtools-1.0.6.tar.gz", "has_sig": false, "md5_digest": "579a0c4e8e309c18e956636945e92066", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 24958, "upload_time": "2020-02-23T01:07:19", "upload_time_iso_8601": "2020-02-23T01:07:19.895155Z", "url": "https://files.pythonhosted.org/packages/53/2b/e4c66d07a9b3381b6417dd4feee67385b87a030406e39ed86f499eadef53/jtools-1.0.6.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "b25328ee7a5c0a514d70dd15bdf4dc33", "sha256": "9e61a6c9bfcc73a8ea2efc6be897935a15c6b9c0c4c31506cffbbc7e8e4ab238"}, "downloads": -1, "filename": "jtools-1.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "b25328ee7a5c0a514d70dd15bdf4dc33", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 37858, "upload_time": "2020-03-13T17:52:37", "upload_time_iso_8601": "2020-03-13T17:52:37.481555Z", "url": "https://files.pythonhosted.org/packages/c6/e0/781f149c67e5056a818abdda8683656dd33c67a4680482fe194b6333f8d6/jtools-1.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "83eaaf25ef5dd1746185d198c0f328d4", "sha256": "6bbfe82c9c7a784a2ddd943c813f542a6ab55aa4275dd70a8520d7401a17547a"}, "downloads": -1, "filename": "jtools-1.1.0.tar.gz", "has_sig": false, "md5_digest": "83eaaf25ef5dd1746185d198c0f328d4", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 41336, "upload_time": "2020-03-13T17:52:39", "upload_time_iso_8601": "2020-03-13T17:52:39.051737Z", "url": "https://files.pythonhosted.org/packages/0f/a5/11011d984f29720fad1ca4af30dd8552f4e0711d65007537509d0575da17/jtools-1.1.0.tar.gz", "yanked": false}], "1.1.1": [{"comment_text": "", "digests": {"md5": "5c359489e816791bcfe92b65e1cc5bdb", "sha256": "6cea4501ca6dec3360d656e9f16e383cf79d030421a4ec746368b2f94c1c2d38"}, "downloads": -1, "filename": "jtools-1.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "5c359489e816791bcfe92b65e1cc5bdb", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 38502, "upload_time": "2020-03-21T15:10:44", "upload_time_iso_8601": "2020-03-21T15:10:44.692238Z", "url": "https://files.pythonhosted.org/packages/83/23/c1665573c75cfcc695f5ef57683b322a4a4327865c06c46f0e7475f3694b/jtools-1.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "87d62e5e62680e79f3b64118ba949fce", "sha256": "5f8a978863cf5ca0b6eca0486a9b76ee40c7649708c4df1c62c0693460a3951e"}, "downloads": -1, "filename": "jtools-1.1.1.tar.gz", "has_sig": false, "md5_digest": "87d62e5e62680e79f3b64118ba949fce", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 43134, "upload_time": "2020-03-21T15:10:45", "upload_time_iso_8601": "2020-03-21T15:10:45.733481Z", "url": "https://files.pythonhosted.org/packages/a9/95/3c17adaa58fad57aef4a87f4c53a76983fcf8c8f5f4185bb67d59d6f3ec6/jtools-1.1.1.tar.gz", "yanked": false}], "1.1.2": [{"comment_text": "", "digests": {"md5": "2a4918f581def90596097e5d72dab62e", "sha256": "e19745972cdac87dffdab5615732cee44c329b639a18f29c6559e729a18fafb0"}, "downloads": -1, "filename": "jtools-1.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "2a4918f581def90596097e5d72dab62e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 38669, "upload_time": "2020-03-22T18:10:09", "upload_time_iso_8601": "2020-03-22T18:10:09.559210Z", "url": "https://files.pythonhosted.org/packages/0a/da/a5a75f104c7e63794c38797ba75745dc53e93fba650c9dfd659b2fa87f7d/jtools-1.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3e0c1bdf4a1d25a73a0bf89ba421321c", "sha256": "ca6413e1650ab27bf8bc3cc165a8e75624d341d020855003a602df3d050cdb74"}, "downloads": -1, "filename": "jtools-1.1.2.tar.gz", "has_sig": false, "md5_digest": "3e0c1bdf4a1d25a73a0bf89ba421321c", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 43421, "upload_time": "2020-03-22T18:10:10", "upload_time_iso_8601": "2020-03-22T18:10:10.882323Z", "url": "https://files.pythonhosted.org/packages/5d/8d/8fc920dc05ad51b41c1cad4c3970729a1034c307522b30350b16247df743/jtools-1.1.2.tar.gz", "yanked": false}], "1.1.3": [{"comment_text": "", "digests": {"md5": "6946642976ab311376dc4c7c9a26ea9b", "sha256": "fd10f2d7067f1178572f6e7b024b9567202091b1bdaa416c4f8d4f5be34fd2a9"}, "downloads": -1, "filename": "jtools-1.1.3-py3-none-any.whl", "has_sig": false, "md5_digest": "6946642976ab311376dc4c7c9a26ea9b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 40643, "upload_time": "2020-03-30T00:12:43", "upload_time_iso_8601": "2020-03-30T00:12:43.970701Z", "url": "https://files.pythonhosted.org/packages/cb/72/bbb78779c284cfcbd06cc69cfd1524cf6377eb1b75632c279252cdb4cb2b/jtools-1.1.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ad6af21e7dcbd217eeb75e50359fa9bf", "sha256": "b836c5996e1813ba6f0893e392bd6205b7a477ed327ef2545d01490349186330"}, "downloads": -1, "filename": "jtools-1.1.3.tar.gz", "has_sig": false, "md5_digest": "ad6af21e7dcbd217eeb75e50359fa9bf", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 45371, "upload_time": "2020-03-30T00:12:45", "upload_time_iso_8601": "2020-03-30T00:12:45.925525Z", "url": "https://files.pythonhosted.org/packages/dd/d1/eeb99df8467ab441dfcde2c2bd286c5e291c3a1b85ab7ebbca417659aaaf/jtools-1.1.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6946642976ab311376dc4c7c9a26ea9b", "sha256": "fd10f2d7067f1178572f6e7b024b9567202091b1bdaa416c4f8d4f5be34fd2a9"}, "downloads": -1, "filename": "jtools-1.1.3-py3-none-any.whl", "has_sig": false, "md5_digest": "6946642976ab311376dc4c7c9a26ea9b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 40643, "upload_time": "2020-03-30T00:12:43", "upload_time_iso_8601": "2020-03-30T00:12:43.970701Z", "url": "https://files.pythonhosted.org/packages/cb/72/bbb78779c284cfcbd06cc69cfd1524cf6377eb1b75632c279252cdb4cb2b/jtools-1.1.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ad6af21e7dcbd217eeb75e50359fa9bf", "sha256": "b836c5996e1813ba6f0893e392bd6205b7a477ed327ef2545d01490349186330"}, "downloads": -1, "filename": "jtools-1.1.3.tar.gz", "has_sig": false, "md5_digest": "ad6af21e7dcbd217eeb75e50359fa9bf", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 45371, "upload_time": "2020-03-30T00:12:45", "upload_time_iso_8601": "2020-03-30T00:12:45.925525Z", "url": "https://files.pythonhosted.org/packages/dd/d1/eeb99df8467ab441dfcde2c2bd286c5e291c3a1b85ab7ebbca417659aaaf/jtools-1.1.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:29 2020"}