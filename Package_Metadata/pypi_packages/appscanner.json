{"info": {"author": "Thijs van Ede", "author_email": "t.s.vanede@utwente.nl", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# AppScanner\nThis code was implemented as part of the NDSS FlowPrint [1] paper, it implements the Single Large Random Forest Classifier of AppScanner [2]. We ask people to cite both works when using the software for academic research papers.\n\n## Installation\n\n### Using pip\nThe easiest way to install `appscanner` is using pip\n```\npip install appscanner\n```\n\n### Manually\nIf you would like to install appscanner manually, please make sure you have installed the required dependencies.\n\n#### Dependencies\nThis code is written in Python3 and depends on the following libraries:\n * Numpy\n * Pandas\n * Scikit-learn\n * Scapy\n\nTo install these use the following command\n```\npip install -U scapy numpy pandas scikit-learn\n```\n\n## Usage\nThe AppScanner implementation can be tested with the `main.py` script. This script allows you to specify .pcap files to load. After loading, the script splits the data into training and testing data and evaluates the performance. See `main.py --help` for more information.\n\n### API\nIt is also possible to directly use the AppScanner code as an API. There are two main classes which need to be understood.\n * `appscanner.preprocessor.Preprocessor` for extracting features from `.pcap` files.\n * `appscanner.appscanner.AppScanner` for applying the AppScanner detection.\n\n#### Preprocessor\nThe `Preprocessor` object is used to extract data from `.pcap` files and label them. To this end, it uses the `process` function which requires a list of files and a list of labels. The list of files must be pathnames to pcap files. The list of labels must be labels corresponding to each file. The example below shows how the `Preprocessor` can be used.\n\n##### Example\n```python\nfrom appscanner.preprocessor import Preprocessor\n\n# Create object\npreprocessor = Preprocessor()\n# Load from files\nX, y = preprocessor.process(['<path_file_1>', ..., '<path_file_n>'],\n                            ['<label_1>'    , ..., '<label_n>'])\n```\n\n#### AppScanner\nThe `AppScanner` object is used to find known applications in network traffic. AppScanner requires a confidence `threshold` (default=0.9). The threshold means AppScanner only returns labels for which it is confident enough or `-1` otherwise, a threshold of 0 gives labels for every predicted sample. It can be `fit` with `X_train` and `y_train` arrays obtained by the `Preprocessor`. After it has been `fit`, the `AppScanner` is able to `predict` unknown samples `X_test`. The example below shows how `AppScanner` can be used.\n\n##### Example\n```python\nfrom appscanner.appscanner import AppScanner\n\n# Create object\nscanner = AppScanner(threshold=0.9)\n\n# Fit scanner\nscanner.fit(X_train, y_train)\n# Predict labels of test data\ny_pred = scanner.predict(X_test)\n```\n\n## References\n[1] `van Ede, T., Bortolameotti, R., Continella, A., Ren, J., Dubois, D. J., Lindorfer, M., Choffnes, D., van Steen, M. & Peter, A. (2020, February). FlowPrint: Semi-Supervised Mobile-App Fingerprinting on Encrypted Network Traffic. In 2020 NDSS. The Internet Society.`\n\n\n[2] `Taylor, V. F., Spolaor, R., Conti, M., & Martinovic, I. (2016, March). Appscanner: Automatic fingerprinting of smartphone apps from encrypted network traffic. In 2016 IEEE European Symposium on Security and Privacy (EuroS&P) (pp. 439-454). IEEE.`\n\n### Bibtex\n```\n@inproceedings{vanede2020flowprint,\n  title={{FlowPrint: Semi-Supervised Mobile-App Fingerprinting on Encrypted Network Traffic}},\n  author={van Ede, Thijs and Bortolameotti, Riccardo and Continella, Andrea and Ren, Jingjing and Dubois, Daniel J. and Lindorfer, Martina and Choffness, David and van Steen, Maarten, and Peter, Andreas}\n  booktitle={NDSS},\n  year={2020},\n  organization={The Internet Society}\n}\n```\n\n```\n@inproceedings{taylor2016appscanner,\n  title={Appscanner: Automatic fingerprinting of smartphone apps from encrypted network traffic},\n  author={Taylor, Vincent F and Spolaor, Riccardo and Conti, Mauro and Martinovic, Ivan},\n  booktitle={2016 IEEE European Symposium on Security and Privacy (EuroS\\&P)},\n  pages={439--454},\n  year={2016},\n  organization={IEEE}\n}\n```\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Thijsvanede/AppScanner", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "appscanner", "package_url": "https://pypi.org/project/appscanner/", "platform": "", "project_url": "https://pypi.org/project/appscanner/", "project_urls": {"Homepage": "https://github.com/Thijsvanede/AppScanner"}, "release_url": "https://pypi.org/project/appscanner/1.0.2/", "requires_dist": null, "requires_python": "", "summary": "AppScanner: Automatic Fingerprinting of Smartphone Apps from Encrypted Network Traffic", "version": "1.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>AppScanner</h1>\n<p>This code was implemented as part of the NDSS FlowPrint [1] paper, it implements the Single Large Random Forest Classifier of AppScanner [2]. We ask people to cite both works when using the software for academic research papers.</p>\n<h2>Installation</h2>\n<h3>Using pip</h3>\n<p>The easiest way to install <code>appscanner</code> is using pip</p>\n<pre><code>pip install appscanner\n</code></pre>\n<h3>Manually</h3>\n<p>If you would like to install appscanner manually, please make sure you have installed the required dependencies.</p>\n<h4>Dependencies</h4>\n<p>This code is written in Python3 and depends on the following libraries:</p>\n<ul>\n<li>Numpy</li>\n<li>Pandas</li>\n<li>Scikit-learn</li>\n<li>Scapy</li>\n</ul>\n<p>To install these use the following command</p>\n<pre><code>pip install -U scapy numpy pandas scikit-learn\n</code></pre>\n<h2>Usage</h2>\n<p>The AppScanner implementation can be tested with the <code>main.py</code> script. This script allows you to specify .pcap files to load. After loading, the script splits the data into training and testing data and evaluates the performance. See <code>main.py --help</code> for more information.</p>\n<h3>API</h3>\n<p>It is also possible to directly use the AppScanner code as an API. There are two main classes which need to be understood.</p>\n<ul>\n<li><code>appscanner.preprocessor.Preprocessor</code> for extracting features from <code>.pcap</code> files.</li>\n<li><code>appscanner.appscanner.AppScanner</code> for applying the AppScanner detection.</li>\n</ul>\n<h4>Preprocessor</h4>\n<p>The <code>Preprocessor</code> object is used to extract data from <code>.pcap</code> files and label them. To this end, it uses the <code>process</code> function which requires a list of files and a list of labels. The list of files must be pathnames to pcap files. The list of labels must be labels corresponding to each file. The example below shows how the <code>Preprocessor</code> can be used.</p>\n<h5>Example</h5>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">appscanner.preprocessor</span> <span class=\"kn\">import</span> <span class=\"n\">Preprocessor</span>\n\n<span class=\"c1\"># Create object</span>\n<span class=\"n\">preprocessor</span> <span class=\"o\">=</span> <span class=\"n\">Preprocessor</span><span class=\"p\">()</span>\n<span class=\"c1\"># Load from files</span>\n<span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">preprocessor</span><span class=\"o\">.</span><span class=\"n\">process</span><span class=\"p\">([</span><span class=\"s1\">'&lt;path_file_1&gt;'</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"s1\">'&lt;path_file_n&gt;'</span><span class=\"p\">],</span>\n                            <span class=\"p\">[</span><span class=\"s1\">'&lt;label_1&gt;'</span>    <span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"s1\">'&lt;label_n&gt;'</span><span class=\"p\">])</span>\n</pre>\n<h4>AppScanner</h4>\n<p>The <code>AppScanner</code> object is used to find known applications in network traffic. AppScanner requires a confidence <code>threshold</code> (default=0.9). The threshold means AppScanner only returns labels for which it is confident enough or <code>-1</code> otherwise, a threshold of 0 gives labels for every predicted sample. It can be <code>fit</code> with <code>X_train</code> and <code>y_train</code> arrays obtained by the <code>Preprocessor</code>. After it has been <code>fit</code>, the <code>AppScanner</code> is able to <code>predict</code> unknown samples <code>X_test</code>. The example below shows how <code>AppScanner</code> can be used.</p>\n<h5>Example</h5>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">appscanner.appscanner</span> <span class=\"kn\">import</span> <span class=\"n\">AppScanner</span>\n\n<span class=\"c1\"># Create object</span>\n<span class=\"n\">scanner</span> <span class=\"o\">=</span> <span class=\"n\">AppScanner</span><span class=\"p\">(</span><span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mf\">0.9</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Fit scanner</span>\n<span class=\"n\">scanner</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">X_train</span><span class=\"p\">,</span> <span class=\"n\">y_train</span><span class=\"p\">)</span>\n<span class=\"c1\"># Predict labels of test data</span>\n<span class=\"n\">y_pred</span> <span class=\"o\">=</span> <span class=\"n\">scanner</span><span class=\"o\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">X_test</span><span class=\"p\">)</span>\n</pre>\n<h2>References</h2>\n<p>[1] <code>van Ede, T., Bortolameotti, R., Continella, A., Ren, J., Dubois, D. J., Lindorfer, M., Choffnes, D., van Steen, M. &amp; Peter, A. (2020, February). FlowPrint: Semi-Supervised Mobile-App Fingerprinting on Encrypted Network Traffic. In 2020 NDSS. The Internet Society.</code></p>\n<p>[2] <code>Taylor, V. F., Spolaor, R., Conti, M., &amp; Martinovic, I. (2016, March). Appscanner: Automatic fingerprinting of smartphone apps from encrypted network traffic. In 2016 IEEE European Symposium on Security and Privacy (EuroS&amp;P) (pp. 439-454). IEEE.</code></p>\n<h3>Bibtex</h3>\n<pre><code>@inproceedings{vanede2020flowprint,\n  title={{FlowPrint: Semi-Supervised Mobile-App Fingerprinting on Encrypted Network Traffic}},\n  author={van Ede, Thijs and Bortolameotti, Riccardo and Continella, Andrea and Ren, Jingjing and Dubois, Daniel J. and Lindorfer, Martina and Choffness, David and van Steen, Maarten, and Peter, Andreas}\n  booktitle={NDSS},\n  year={2020},\n  organization={The Internet Society}\n}\n</code></pre>\n<pre><code>@inproceedings{taylor2016appscanner,\n  title={Appscanner: Automatic fingerprinting of smartphone apps from encrypted network traffic},\n  author={Taylor, Vincent F and Spolaor, Riccardo and Conti, Mauro and Martinovic, Ivan},\n  booktitle={2016 IEEE European Symposium on Security and Privacy (EuroS\\&amp;P)},\n  pages={439--454},\n  year={2016},\n  organization={IEEE}\n}\n</code></pre>\n\n          </div>"}, "last_serial": 6564438, "releases": {"1.0.1": [{"comment_text": "", "digests": {"md5": "b9e809309732a63928d95a6d47966c08", "sha256": "3d7a02982ca9e7667a1554e8ef76a9d2aa504da252816102e10c70a4fc906b17"}, "downloads": -1, "filename": "appscanner-1.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "b9e809309732a63928d95a6d47966c08", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10782, "upload_time": "2020-02-03T19:31:32", "upload_time_iso_8601": "2020-02-03T19:31:32.333420Z", "url": "https://files.pythonhosted.org/packages/ca/92/772b543352bd7d29bb8db13ec74ebffe7bda3972cee273afa31b6e999fd7/appscanner-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "63cdac5a81bbf5de036b747a24bf822a", "sha256": "297b0e221d6327427a089a7f233e65df68c7c1026e439cf5df13b7cd610fca70"}, "downloads": -1, "filename": "appscanner-1.0.1.tar.gz", "has_sig": false, "md5_digest": "63cdac5a81bbf5de036b747a24bf822a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7374, "upload_time": "2020-02-03T19:31:34", "upload_time_iso_8601": "2020-02-03T19:31:34.381759Z", "url": "https://files.pythonhosted.org/packages/28/d4/cfd0f791646bf3d993ec79730c5a6b793f921b4093e5f55c06eb36ca1107/appscanner-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "29ee0725893ceb2c8dd99147d843ddd7", "sha256": "b30f85a999a68f27fdf47fd1f4a094dd88e2818c6c915105f2255ee4d424870d"}, "downloads": -1, "filename": "appscanner-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "29ee0725893ceb2c8dd99147d843ddd7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10985, "upload_time": "2020-02-03T19:45:02", "upload_time_iso_8601": "2020-02-03T19:45:02.793035Z", "url": "https://files.pythonhosted.org/packages/50/fd/6cd08bfdc9825a2c4ed714cebb08cf081f6eab4897a1d91220e2dfbce5cc/appscanner-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b241259abbc58aefff75858bc6be1eed", "sha256": "d92d0a873286db711780b49a99a705ee4105fcd61a1a17d1867d234bc5e76fa8"}, "downloads": -1, "filename": "appscanner-1.0.2.tar.gz", "has_sig": false, "md5_digest": "b241259abbc58aefff75858bc6be1eed", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7657, "upload_time": "2020-02-03T19:45:04", "upload_time_iso_8601": "2020-02-03T19:45:04.772081Z", "url": "https://files.pythonhosted.org/packages/c3/b4/2e52d03757583dca059595072d92d933f7f202ad76cbbe1de8260724041f/appscanner-1.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "29ee0725893ceb2c8dd99147d843ddd7", "sha256": "b30f85a999a68f27fdf47fd1f4a094dd88e2818c6c915105f2255ee4d424870d"}, "downloads": -1, "filename": "appscanner-1.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "29ee0725893ceb2c8dd99147d843ddd7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10985, "upload_time": "2020-02-03T19:45:02", "upload_time_iso_8601": "2020-02-03T19:45:02.793035Z", "url": "https://files.pythonhosted.org/packages/50/fd/6cd08bfdc9825a2c4ed714cebb08cf081f6eab4897a1d91220e2dfbce5cc/appscanner-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b241259abbc58aefff75858bc6be1eed", "sha256": "d92d0a873286db711780b49a99a705ee4105fcd61a1a17d1867d234bc5e76fa8"}, "downloads": -1, "filename": "appscanner-1.0.2.tar.gz", "has_sig": false, "md5_digest": "b241259abbc58aefff75858bc6be1eed", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7657, "upload_time": "2020-02-03T19:45:04", "upload_time_iso_8601": "2020-02-03T19:45:04.772081Z", "url": "https://files.pythonhosted.org/packages/c3/b4/2e52d03757583dca059595072d92d933f7f202ad76cbbe1de8260724041f/appscanner-1.0.2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:17:35 2020"}