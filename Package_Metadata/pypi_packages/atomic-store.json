{"info": {"author": "Ben Wiederhake", "author_email": "BenWiederhake.GitHub@gmx.de", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "# atomic_store\n\n> Easier than a DBMS, but more fault-resistant than just a file.\n\nSometimes you need to manage a bit of state across executions.\nSometimes, a fully-blown database is just too much.\n\nThis library makes it easy to keep a *store* of stuff in a JSON file,\nin an atomic and fault-resistant manner.\n\nOther formats (like pickle and bson) are also supported,\nand arbitrary formats are possible.\n\n## Table of Contents\n\n- [Install](#install)\n- [Usage](#usage)\n- [TODOs](#todos)\n- [NOTDOs](#notdos)\n- [Contribute](#contribute)\n\n## Install\n\nJust `pip install atomic_store`.  Or, if you must, `pip install -r requirements.txt`\n\nNote that the only dependency is `atomicwrites`, which has no dependencies.\n\n## Usage\n\nBy default, the store is encoded as json, written to a temporary file,\nand then atomically replaces the old file.  When reading, if the file does\nnot exist, a default value is used.  The default default value is `None`.\n\n### Context Manager\n\nThis program remembers all start times:\n\n```python3\nimport atomic_store\nimport time\n\nwith atomic_store.open('runs.json', default=[]) as store:\n    print('Previous executions:')\n    print(store.value)\n    new_entry = time.strftime('%Y-%m-%d %H:%M:%S%z')\n    store.value.append(new_entry)\n```\n\nLeaving the context manager takes care of all writes.\nNo intermediate values get written to disk.\n\nThis is ideal if the task runs short, and in case of any error\nyou only want to keep the old state anyway.\n\nFor advanced uses, also see the subsection on [reentrancy](#reentrancy).\n\n### Manual control\n\nThis program remembers all start times:\n\n```python3\nimport atomic_store\n\nmy_store = atomic_store.open('gathered.json', default=dict())\n\nmy_store.value['state'] = 'running'\nmy_store.value['thought'] = 'I would not eat green eggs and ham.'\nmy_store.commit()\n# ... some calculations ...\nmy_store.value['state'] = 'done'\nmy_store.value['thought'] = 'I do so like Green eggs and ham!'\nmy_store.commit()\n```\n\nOnly calls to `commit()` cause writes to the disk.\nAgain, no intermediate values get written to disk.\n\nThis is ideal if you have a long-running job with clear steps,\nand each step's output is valuable.\n\nNote that `commit()` is also available in the context manager.\n\n### Format tweaks\n\nIf you're using the json backend, and want to keep the JSON file as small as possible,\nyou can call `open` with `dump_kwargs=dict(separators=(',', ':'))`.\nThe keyword `load_kwargs` also exists.\n\n### Non-JSON formats\n\nYou can use arbitrary other formats, using the `format` keyword:\n\n```python\natomic_store.open('runs.json', default=[], format=MY_FORMAT)\n```\n\nSupported values are `None` (for JSON), `'json'`, `'pickle'`,\n`'bson'` (requires bson to be installed), and also any module or object\nproviding `dump/load` or `dumps/loads`.\nBy default, `atomic_store` assumes you operate on binary files, except when JSON is involved.\nTo override this, you can set `is_binary`.\nNote that this means you can use the modules `json`, `pickle`, and `bson` as they are.\n\nFor convenience, you can also override the abstract classes\n`atomic_store.AbstractFormatFile` or `atomic_store.AbstractFormatBstr`.\n\nIn all cases, `load_kwargs` and `dump_kwargs` are still supported.\n\n### Reentrancy\n\nIf the same `atomic_store` is used as a context manager more than once,\nthe default behavior is to write the file only when the last `with` is exited:\n\n```python\n# Assume `state.json` contains only `\"before\"`.\nmngr = atomic_store.open('mystate.json', default=[])\nwith mngr as store:\n    store.value = 'outer'\n    # File contains `\"before\"`: We haven't exited any context manager yet.\n    with mngr as store:\n        store.value = 'inner'\n        # File contains `\"before\"`: We haven't exited any context manager yet.\n    # File now contains `\"inner\"`, because the inner `with`-statement wrote it.\n    # Read the Reentrancy section if you consider this undesired behavior.\n# File now contains `\"inner\"`, because the outer `with`-statement wrote it again.\n```\n\nIf you consider this behavior undesirable, you can either just use multiple context managers (by calling `atomic_store.open` multiple times), or by using the keyword `ignore_inner_exits=True`, like this:\n\n```python\n# Assume `state.json` contains only `\"before\"`.\nmngr = atomic_store.open('mystate.json', default=[], ignore_inner_exits=True)\nwith mngr as store:\n    store.value = 'outer'\n    # File contains `\"before\"`: We haven't exited any context manager yet.\n    with mngr as store:\n        store.value = 'inner'\n        # File contains `\"before\"`: We haven't exited any context manager yet.\n    # File *still* contains `\"before\"`, as the manager detected that it is still active.\n# File now contains `\"outer\"`, because the outer `with`-statement wrote it.\n```\n\n### Atomic is not magic\n\nThis library is not magical.\n\nIf two threads (or two processes, or whatever) open a store,\nmodify something, and then write concurrently, one of the results may be lost.\nHowever, the writes are guaranteed to be atomic,\nso the data is merely lost, but not corrupted.\n\n## TODOs\n\n* Figure out how to make `bson` optional\n* Publish on PyPI\n\n## NOTDOs\n\nHere are some things this project will not support:\n* Any DB backend.\n* Any multi-file backend.\n* More advanced semantics than just `commit`.\n* This includes rollback.  It's just not obvious which behavior is desired when the file does not exist (Re-use `default` value?  What if it was modified, as it happens with lists and dicts?), and with stacked context managers (should it rollback to the file's state?  Or to the beginning of the `with`?)\n\n## Contribute\n\nFeel free to dive in! [Open an issue](https://github.com/BenWiederhake/atomic_store/issues/new) or submit PRs.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/BenWiederhake/atomic_store", "keywords": "atomic store", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "atomic-store", "package_url": "https://pypi.org/project/atomic-store/", "platform": "Any", "project_url": "https://pypi.org/project/atomic-store/", "project_urls": {"Homepage": "https://github.com/BenWiederhake/atomic_store"}, "release_url": "https://pypi.org/project/atomic-store/0.0.1/", "requires_dist": ["atomicwrites (>=1.3.0)", "bson (>=0.5.8)"], "requires_python": "", "summary": "A robust, atomic single-file value store", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>atomic_store</h1>\n<blockquote>\n<p>Easier than a DBMS, but more fault-resistant than just a file.</p>\n</blockquote>\n<p>Sometimes you need to manage a bit of state across executions.\nSometimes, a fully-blown database is just too much.</p>\n<p>This library makes it easy to keep a <em>store</em> of stuff in a JSON file,\nin an atomic and fault-resistant manner.</p>\n<p>Other formats (like pickle and bson) are also supported,\nand arbitrary formats are possible.</p>\n<h2>Table of Contents</h2>\n<ul>\n<li><a href=\"#install\" rel=\"nofollow\">Install</a></li>\n<li><a href=\"#usage\" rel=\"nofollow\">Usage</a></li>\n<li><a href=\"#todos\" rel=\"nofollow\">TODOs</a></li>\n<li><a href=\"#notdos\" rel=\"nofollow\">NOTDOs</a></li>\n<li><a href=\"#contribute\" rel=\"nofollow\">Contribute</a></li>\n</ul>\n<h2>Install</h2>\n<p>Just <code>pip install atomic_store</code>.  Or, if you must, <code>pip install -r requirements.txt</code></p>\n<p>Note that the only dependency is <code>atomicwrites</code>, which has no dependencies.</p>\n<h2>Usage</h2>\n<p>By default, the store is encoded as json, written to a temporary file,\nand then atomically replaces the old file.  When reading, if the file does\nnot exist, a default value is used.  The default default value is <code>None</code>.</p>\n<h3>Context Manager</h3>\n<p>This program remembers all start times:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">atomic_store</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"k\">with</span> <span class=\"n\">atomic_store</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s1\">'runs.json'</span><span class=\"p\">,</span> <span class=\"n\">default</span><span class=\"o\">=</span><span class=\"p\">[])</span> <span class=\"k\">as</span> <span class=\"n\">store</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Previous executions:'</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">)</span>\n    <span class=\"n\">new_entry</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">strftime</span><span class=\"p\">(</span><span class=\"s1\">'%Y-%m-</span><span class=\"si\">%d</span><span class=\"s1\"> %H:%M:%S%z'</span><span class=\"p\">)</span>\n    <span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">new_entry</span><span class=\"p\">)</span>\n</pre>\n<p>Leaving the context manager takes care of all writes.\nNo intermediate values get written to disk.</p>\n<p>This is ideal if the task runs short, and in case of any error\nyou only want to keep the old state anyway.</p>\n<p>For advanced uses, also see the subsection on <a href=\"#reentrancy\" rel=\"nofollow\">reentrancy</a>.</p>\n<h3>Manual control</h3>\n<p>This program remembers all start times:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">atomic_store</span>\n\n<span class=\"n\">my_store</span> <span class=\"o\">=</span> <span class=\"n\">atomic_store</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s1\">'gathered.json'</span><span class=\"p\">,</span> <span class=\"n\">default</span><span class=\"o\">=</span><span class=\"nb\">dict</span><span class=\"p\">())</span>\n\n<span class=\"n\">my_store</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">[</span><span class=\"s1\">'state'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'running'</span>\n<span class=\"n\">my_store</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">[</span><span class=\"s1\">'thought'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'I would not eat green eggs and ham.'</span>\n<span class=\"n\">my_store</span><span class=\"o\">.</span><span class=\"n\">commit</span><span class=\"p\">()</span>\n<span class=\"c1\"># ... some calculations ...</span>\n<span class=\"n\">my_store</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">[</span><span class=\"s1\">'state'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'done'</span>\n<span class=\"n\">my_store</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">[</span><span class=\"s1\">'thought'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'I do so like Green eggs and ham!'</span>\n<span class=\"n\">my_store</span><span class=\"o\">.</span><span class=\"n\">commit</span><span class=\"p\">()</span>\n</pre>\n<p>Only calls to <code>commit()</code> cause writes to the disk.\nAgain, no intermediate values get written to disk.</p>\n<p>This is ideal if you have a long-running job with clear steps,\nand each step's output is valuable.</p>\n<p>Note that <code>commit()</code> is also available in the context manager.</p>\n<h3>Format tweaks</h3>\n<p>If you're using the json backend, and want to keep the JSON file as small as possible,\nyou can call <code>open</code> with <code>dump_kwargs=dict(separators=(',', ':'))</code>.\nThe keyword <code>load_kwargs</code> also exists.</p>\n<h3>Non-JSON formats</h3>\n<p>You can use arbitrary other formats, using the <code>format</code> keyword:</p>\n<pre><span class=\"n\">atomic_store</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s1\">'runs.json'</span><span class=\"p\">,</span> <span class=\"n\">default</span><span class=\"o\">=</span><span class=\"p\">[],</span> <span class=\"nb\">format</span><span class=\"o\">=</span><span class=\"n\">MY_FORMAT</span><span class=\"p\">)</span>\n</pre>\n<p>Supported values are <code>None</code> (for JSON), <code>'json'</code>, <code>'pickle'</code>,\n<code>'bson'</code> (requires bson to be installed), and also any module or object\nproviding <code>dump/load</code> or <code>dumps/loads</code>.\nBy default, <code>atomic_store</code> assumes you operate on binary files, except when JSON is involved.\nTo override this, you can set <code>is_binary</code>.\nNote that this means you can use the modules <code>json</code>, <code>pickle</code>, and <code>bson</code> as they are.</p>\n<p>For convenience, you can also override the abstract classes\n<code>atomic_store.AbstractFormatFile</code> or <code>atomic_store.AbstractFormatBstr</code>.</p>\n<p>In all cases, <code>load_kwargs</code> and <code>dump_kwargs</code> are still supported.</p>\n<h3>Reentrancy</h3>\n<p>If the same <code>atomic_store</code> is used as a context manager more than once,\nthe default behavior is to write the file only when the last <code>with</code> is exited:</p>\n<pre><span class=\"c1\"># Assume `state.json` contains only `\"before\"`.</span>\n<span class=\"n\">mngr</span> <span class=\"o\">=</span> <span class=\"n\">atomic_store</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s1\">'mystate.json'</span><span class=\"p\">,</span> <span class=\"n\">default</span><span class=\"o\">=</span><span class=\"p\">[])</span>\n<span class=\"k\">with</span> <span class=\"n\">mngr</span> <span class=\"k\">as</span> <span class=\"n\">store</span><span class=\"p\">:</span>\n    <span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"s1\">'outer'</span>\n    <span class=\"c1\"># File contains `\"before\"`: We haven't exited any context manager yet.</span>\n    <span class=\"k\">with</span> <span class=\"n\">mngr</span> <span class=\"k\">as</span> <span class=\"n\">store</span><span class=\"p\">:</span>\n        <span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"s1\">'inner'</span>\n        <span class=\"c1\"># File contains `\"before\"`: We haven't exited any context manager yet.</span>\n    <span class=\"c1\"># File now contains `\"inner\"`, because the inner `with`-statement wrote it.</span>\n    <span class=\"c1\"># Read the Reentrancy section if you consider this undesired behavior.</span>\n<span class=\"c1\"># File now contains `\"inner\"`, because the outer `with`-statement wrote it again.</span>\n</pre>\n<p>If you consider this behavior undesirable, you can either just use multiple context managers (by calling <code>atomic_store.open</code> multiple times), or by using the keyword <code>ignore_inner_exits=True</code>, like this:</p>\n<pre><span class=\"c1\"># Assume `state.json` contains only `\"before\"`.</span>\n<span class=\"n\">mngr</span> <span class=\"o\">=</span> <span class=\"n\">atomic_store</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s1\">'mystate.json'</span><span class=\"p\">,</span> <span class=\"n\">default</span><span class=\"o\">=</span><span class=\"p\">[],</span> <span class=\"n\">ignore_inner_exits</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">mngr</span> <span class=\"k\">as</span> <span class=\"n\">store</span><span class=\"p\">:</span>\n    <span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"s1\">'outer'</span>\n    <span class=\"c1\"># File contains `\"before\"`: We haven't exited any context manager yet.</span>\n    <span class=\"k\">with</span> <span class=\"n\">mngr</span> <span class=\"k\">as</span> <span class=\"n\">store</span><span class=\"p\">:</span>\n        <span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"s1\">'inner'</span>\n        <span class=\"c1\"># File contains `\"before\"`: We haven't exited any context manager yet.</span>\n    <span class=\"c1\"># File *still* contains `\"before\"`, as the manager detected that it is still active.</span>\n<span class=\"c1\"># File now contains `\"outer\"`, because the outer `with`-statement wrote it.</span>\n</pre>\n<h3>Atomic is not magic</h3>\n<p>This library is not magical.</p>\n<p>If two threads (or two processes, or whatever) open a store,\nmodify something, and then write concurrently, one of the results may be lost.\nHowever, the writes are guaranteed to be atomic,\nso the data is merely lost, but not corrupted.</p>\n<h2>TODOs</h2>\n<ul>\n<li>Figure out how to make <code>bson</code> optional</li>\n<li>Publish on PyPI</li>\n</ul>\n<h2>NOTDOs</h2>\n<p>Here are some things this project will not support:</p>\n<ul>\n<li>Any DB backend.</li>\n<li>Any multi-file backend.</li>\n<li>More advanced semantics than just <code>commit</code>.</li>\n<li>This includes rollback.  It's just not obvious which behavior is desired when the file does not exist (Re-use <code>default</code> value?  What if it was modified, as it happens with lists and dicts?), and with stacked context managers (should it rollback to the file's state?  Or to the beginning of the <code>with</code>?)</li>\n</ul>\n<h2>Contribute</h2>\n<p>Feel free to dive in! <a href=\"https://github.com/BenWiederhake/atomic_store/issues/new\" rel=\"nofollow\">Open an issue</a> or submit PRs.</p>\n\n          </div>"}, "last_serial": 5531975, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "ca013d36b81267aaddac8e63b4283b62", "sha256": "c6228ad6a631249ee50c181b25fdd852a2df43812385306b355c975b8c07e2cb"}, "downloads": -1, "filename": "atomic_store-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "ca013d36b81267aaddac8e63b4283b62", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 8017, "upload_time": "2019-07-14T20:29:20", "upload_time_iso_8601": "2019-07-14T20:29:20.853009Z", "url": "https://files.pythonhosted.org/packages/fa/a9/3a41a6128c62036f4690ae4f5b25477711b5f95d53e9f0246e94cffae57f/atomic_store-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "662660607425ad6223d791b78f9c2ad0", "sha256": "3ce00b2819f3ee3207de79c2aeb66aee1566a4c1fdbae317c72d0ff20a3729e5"}, "downloads": -1, "filename": "atomic_store-0.0.1.tar.gz", "has_sig": false, "md5_digest": "662660607425ad6223d791b78f9c2ad0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6640, "upload_time": "2019-07-14T20:29:22", "upload_time_iso_8601": "2019-07-14T20:29:22.917517Z", "url": "https://files.pythonhosted.org/packages/e4/4a/934ebb885d353c63d2b3f2eeda6c7fc01e254685a07c4e16947224754114/atomic_store-0.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ca013d36b81267aaddac8e63b4283b62", "sha256": "c6228ad6a631249ee50c181b25fdd852a2df43812385306b355c975b8c07e2cb"}, "downloads": -1, "filename": "atomic_store-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "ca013d36b81267aaddac8e63b4283b62", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 8017, "upload_time": "2019-07-14T20:29:20", "upload_time_iso_8601": "2019-07-14T20:29:20.853009Z", "url": "https://files.pythonhosted.org/packages/fa/a9/3a41a6128c62036f4690ae4f5b25477711b5f95d53e9f0246e94cffae57f/atomic_store-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "662660607425ad6223d791b78f9c2ad0", "sha256": "3ce00b2819f3ee3207de79c2aeb66aee1566a4c1fdbae317c72d0ff20a3729e5"}, "downloads": -1, "filename": "atomic_store-0.0.1.tar.gz", "has_sig": false, "md5_digest": "662660607425ad6223d791b78f9c2ad0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6640, "upload_time": "2019-07-14T20:29:22", "upload_time_iso_8601": "2019-07-14T20:29:22.917517Z", "url": "https://files.pythonhosted.org/packages/e4/4a/934ebb885d353c63d2b3f2eeda6c7fc01e254685a07c4e16947224754114/atomic_store-0.0.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:16:33 2020"}