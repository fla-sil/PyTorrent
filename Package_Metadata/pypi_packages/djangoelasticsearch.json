{"info": {"author": "Robin Tissot", "author_email": "aj3sshh@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "django_elasticsearch is a wrapper around py-elasticsearch that automates the indexation and search of django models.  \n**Note**: if your elasticsearch documents/mappings are not close to django models, this package is probably not for you.\n\nINSTALL\n=======\n\n* Install django_elasticsearch\n    ```shell\n    pip install djangoelasticsearch\n    ```\n\n\nELASTICSEARCH VERSION COMPATIBILITY\n===================================\n\nAs stated in the python elasticsearch module documentation:\n\n\n>There are two branches for development - master and 0.4. Master branch is used to track all the changes for Elasticsearch 1.0 and beyond whereas 0.4 tracks Elasticsearch 0.90.\n>\n>Releases with major version 1 (1.X.Y) are to be used with Elasticsearch 1.* and later, 0.4 releases are meant to work with Elasticsearch 0.90.*.\n\ndjango_elasticsearch has only been tested with Elasticsearch 1.3.9 and it's corresponding python interface version 1.2.0, but since [the API hasn't change](https://elasticsearch-py.readthedocs.org/en/master/Changelog.html) i'm quite positive that newer and older versions should work fine too, as long as you use the right python module for your Elasticsearch version. [See the official docs on the matter](https://elasticsearch-py.readthedocs.org/en/master/#compatibility).\n\nUSAGE\n=====\n\nSubclass the models you wish to index/search with ```django_elasticsearch.models.EsIndexable```.\n```python\nfrom django.db import models\nfrom django_elasticsearch.models import EsIndexable\n\n\nMyModel(EsIndexable, models.Model):\n    foo = models.CharField(max_length=64)\n    [...]\n\n```\n\nThen you can do:\n```python\n>>> q = MyModel.es.search('value')\n>>> q\n[{'id': 1, 'foo': 'A value'}, {'id': 2, 'foo': 'Another value'}, ...]\n>>> q.deserialize()\n[<MyModel #1>, <MyModel #2>, ...]\n>>> MyModel.es.get(id=1)\n{'id': 1, 'foo': 'A value'}\n```\nThe elasticsearch manager methods (all, search, mlt) returns an instance of a EsQueryset, it's like a django Queryset but it queries elasticsearch instead of your db.  \nLike a regular Queryset, an EsQueryset is lazy, and if evaluated, returns a list of documents. The ```.deserialize()``` method makes the queryset return instances of models instead of dicts.\n\n> django-elasticsearch **DOES NOT** index documents by itself unless told to, either set settings.ELASTICSEARCH_AUTO_INDEX to True to index your models when you save them, or call directly myinstance.es.do_index().\n\nTo specify the size of output of documents, it is necessary to make a slice of data, for example:\n\n```\nlen(list(MyModel.es.search('value')))\n>>> 10\nlen(list(MyModel.es.search('value')[0:100]))\n>>> 42\n```\n\nCONFIGURATION\n=============\nProject scope configuration (django settings):\n----------------------------------------------\n\n* **ELASTICSEARCH_URL**  \n    Defaults to 'http://localhost:9200'  \n    The url of your elasticsearch cluster/instance.\n\n* **ELASTICSEARCH_AUTO_INDEX**  \n    Defaults to False  \n    Set to True if you **don't** want to handle the elasticsearch operations yourself. In that case the creation of the index, the indexation and deletions are hooked respectively to the post_syncdb, post_save and post_delete signals.     Should probably only be used in a dev environment or for small scale databases.\n    If you have already done a syncdb, you can just call ```MyModel.es.create_index()``` to create the index/mapping.\n\n* **ELASTICSEARCH_DEFAULT_INDEX**  \n    Defaults to 'django'  \n    The default index name used for every document, can be overrided for a model with the ```model.Meta.Elasticsearch.index``` attribute.\n\n* **ELASTICSEARCH_SETTINGS**  \n    No defaults  \n    If set, will be passed when creating any index [as is](http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-create-index.html#create-index-settings).\n\n* **ELASTICSEARCH_FUZZINESS**  \n    Defaults to 0.5  \n    Will be applied to any es.search query, See the [fuzziness section](http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/common-options.html#fuzziness) of the elasticsearch documentation.\n\n* **ELASTICSEARCH_CONNECTION_KWARGS**  \n    Defaults to {}  \n    Additional kwargs to be passed to at the instantiation of the elasticsearch client. Useful to manage HTTPS connection for example ([Reference](http://elasticsearch-py.readthedocs.org/en/master/api.html#elasticsearch.Elasticsearch)).\n\nModel scope configuration:\n--------------------------\n\nEach EsIndexable model receive an Elasticsearch class that contains its options (just like the Model.Meta class).\n\n* **index**  \n    Defaults to 'django'  \n    The elasticsearch index in which this model(document type) will be indexed.\n\n* **doc_type**  \n    Defaults to 'model-{model_name}'  \n    The elasticsearch type in which this model will be indexed.\n\n* **fields**  \n    Defaults to None  \n    The fields to be indexed by elasticsearch, if left to None, all models fields will be indexed.\n\n* **mappings**  \n    Defaults to None  \n    You can override some or all of the fields mapping with this dictionary\n    Example:  \n\n    ```python\n\n    MyModel(EsIndexable, models.Model):\n        title = models.CharField(max_length=64)\n\n        class Elasticsearch(EsIndexable.Elasticsearch):\n            mappings = {'title': {'boost': 2.0}}\n    ```\n    In this example we only override the 'boost' attribute of the 'title' field, but there are plenty of possible configurations, see [the docs](http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-put-mapping.html).\n\n* **serializer_class**  \n    Defaults to EsJsonSerializer  \n    This is the class used to translate from the django model to elasticsearch document both ways.\n\n* **facets_fields**  \n    Defaults to None  \n    Can be set to a list of fields to return as facets when doing a search query on the model, if not set explicitly in the query itself.\n\n* **facets_limits**  \n    Defaults to None  \n    The maximum number of facets to return per query, if None, use the elasticsearch setting.\n\n* **suggest_fields**  \n    Defaults to None  \n    A dictionary of fields to add in the suggestions, if not set at a search level.\n\n* **suggest_limit**  \n    Defaults to None  \n    The maximum number of suggestions to return, if None, use the elasticsearch setting.\n\n* **completion_fields**  \n    Defaults to None  \n    The fields on which to activate auto-completion (needs a specific mapping).\n\nAPI\n===\n\nEsIndexable API:\n----------------\n\nThe Elasticsearch manager is available from the 'es' attribute of EsIndexable Model classes or instances. Some methods requires an instance though.  \n\n**Manager methods that returns a EsQueryset instance**  \n\n* **es.search**(query,\n            facets=None,\n            facets_limit=None,\n            global_facets=True,\n            suggest_fields=None,\n            suggest_limit=None,\n            fuzziness=None)  \n    Returns a configured EsQueryset with the given options, or the defaults set in ```EsIndexable.Elasticsearch```.  \n\n* **es.all**()  \n    Proxy to an empty query ```.search(\"\")```.\n\n* **es.mlt** *needs_instance*  \n    Returns an EsQueryset of documents that are 'like' the given instance's document. See the [more like this api](http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-more-like-this.html).\n\n**Other Manager methods**  \n* **es.count**()  \n    Returns the number of documents in the model's doc_type.\n\n* **es.get**() *needs_instance*  \n    Returns the elasticsearch document of the model instance.\n\n* **es.delete**() *needs_instance*  \n    Delete the given instance's document.\n\n* **es.do_index**() *needs_instance*  \n    Serialize and index the given instance.\n\n* **es.complete**(field_name, query)  \n    Returns a list of suggestions from elasticsearch for the given field and query.\n    **Note**: field_name must be present in ```Elasticsearch.completion_fields``` because it needs a specific mapping. \n    Example:\n    ```\n    >>>MyModel.es.complete('title', 'tset')\n    ['test',]\n    ```\n\n* **es.do_update**()  \n    Refresh the whole index of the model. This should probably be only used in a TestCase. See the [refresh api](http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-refresh.html).\n\n* **es.get_mapping**()  \n    Returns the current mapping for the model's document type.\n\n* **es.get_settings**()  \n    Returns the current settings for the model's index.\n\n* **es.diff**()  \n    Returns a dict containing differences between the db instance and the elasticsearch instance.\n\n* **es.check_cluster**()  \n    Returns True if the elasticsearch cluster is alive.\n\n* **es.reindex_all**(queryset=None)  \n    queryset defaults to ```self.model.objects.all()```   \n    Calls ```es.do_index()``` for every instance in queryset.\n\n* **es.flush**()  \n    Deletes the model's index and then reindex all instances of it.\n\n\nEsQueryset API:\n---------------\nThis class is as close as possible to a standard relational db Queryset, however the db operations (update and delete) are deactivated (i'm open for discussion on if and how to implement these). Note that just like regular Querysets, EsQuerysets are lazy, they can be ordered, filtered and faceted.  \n\nNote that the return value of the queryset is higly dependent on your mapping, for example, if you want to be able to do an exact filtering with filter() you need a field with {\"index\" : \"not_analyzed\"}.\nAlso by default, filters are case insensitive, if you have a case sensitive tokenizer, you need to instantiate EsQueryset with ignore_case=False.\n\nAn EsQueryset acts a lot like a regular Queryset:\n```\n>>> q = MyModel.es.queryset.all()\n>>> q = q.filter(title='foo')\n>>> q = q.search('test')\n>>> q  # only now is the query evaluated\n[{'title': 'foo', 'some_content': 'this is a test.'}]\n```\n\nIf you need models methods or attributes, you can get model instances instead of documents (dicts) by calling the deserialize method on the query before evaluating it. See the Serializer API below.\n\nTo access the facets you can use the facets property of the EsQueryset:\n```python\n>>> MyModel.Elasticsearch.default_facets_fields\n['author']\n>>> q = MyModel.es.search('woot', facets=['foo'])  # returns a lazy EsQueryset instance\n>>> q = MyModel.es.search('woot').facet(['foo'])  # is exactly the same\n>>> q.facets  # evals the query and returns the facets\n{u'doc_count': 45,\n u'foo': {u'buckets': [\n {u'doc_count': 13, u'key': u'bar'},\n]}}\n```\nNote that es.search automatically add the default facets set on the model to the query, but you can also set them manually with the ```facets``` and ```facets_limit``` parameters.\n\n**Available methods** all of those are chainable.\n* **es.queryset.search**(query)  \n\n* **es.queryset.all**()  \n\n* **es.queryset.facet**(fields, limit=None, use_globals=True)  \n    If ```use_globals``` is set to False, the facets will be filtered like the documents.\n\n* **es.queryset.suggest**(fields, limit)  \n    Add ```fields``` for suggestions.\n\n* **es.queryset.order_by**(**kwargs)  \n\n* **es.queryset.filter**(**kwargs)  \n    Accepted lookups are: __exact, __should, __contains, __gt, __gte, __lt, __lte, __range  \n    Just like in django, the default lookup is __exact.  \n    See the [bool query](http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html) for a difference between __exact (which maps to 'must') and __should.  \n\n* **es.queryset.exclude**(**kwargs)  \n\n* **es.queryset.mlt**(id)  \n    See the [more like this api](http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-more-like-this.html).\n\n* **es.queryset.deserialize**()\n    Makes the queryset return model instances instead of documents.\n\n* **es.queryset.extra**(body)\n    Blindly updates the elasticsearch query body with ```body``` allowing to use any non-implemented elasticsearch feature.\n\n**Does not return an EsQueryset** and thus are not chainable.  \n* **es.queryset.count**()\n\n* **es.queryset.get**(pk=X)\n\n* **es.queryset.complete**(field_name, query)\n\n\nSerializer API:\n---------------\n\nThe serializer's role is to format django model instances to something indexable by elasticsearch : json. The only mandatory method for a serializer is the ```serialize(instance)``` method, deserializing is only an option.  \n\nThe default serializer does a little bit more though:  \nFor each indexed fields, look for either ```serialize_{field_name}``` or ```serialize_{field_type}``` methods, and fallback on ```getattr(instance, field_name)```. Also allow naive nested serialization, by looking for an Elasticsearch class attribute on the target model class of the related field, or falling back on ```dict(id=instance.id, value=unicode(instance))```.  \nLet's look at a bit complex example:  \n\nmy_app.models.py  \n```python\nfrom django.db import models\nfrom django_elasticsearch.models import EsIndexable\nfrom my_app.serializers import MyModelEsSerializer\n\nclass MyModel(models.Model):\n      some_content = models.CharField(max_length=255)\n      more_content = models.TextField()\n      a_date = models.DateTimeField(auto_now_add=True)\n      another_date = models.DateTimeField(auto_now=True)\n      some_relation = models.ForeignKey(AnotherModel)\n\n      class Elasticsearch(EsIndexable.Elasticsearch):\n            serializer_class = MyModelEsSerializer\n            fields = ['some_content', 'more_content', 'content_length', 'a_date', 'some_relation']\n            mappings = {'content_length': {'type': 'long'},\n                        'a_date': {'type': 'object'}}\n\n```\n\nNote that since ```content_length``` is an abstract field (not present in db), and ```a_date``` is serialized to a dict instead of it's default (datetime), we need to tell elasticsearch their types in the mappings attribute.  \n\nserializers.py  \n```python\nfrom django_elasticsearch.serializers import EsJsonSerializer\n\nclass MyModelEsSerializer(EsJsonSerializer):\n    def serialize_more_content(self, instance, field_name):\n        # Specific attribute serializer\n        return getattr(instance, field_name)[:5]\n\n    def serialize_content_length(self, instance, field_name):\n        # Abstract field serializer\n        content = getattr(instance, 'some_content')\n        return len(content)\n\n    def serialize_type_datetimefield(self, instance, field_name):\n        # Specific field type serializer\n        d = getattr(instance, field_name)\n        # A rather typical api output,\n        # The reasons for indexing dates as this are debatable, but it's just an example\n        return {\n            'timestamp': d and d.strftime('%s'),\n            'date': d and d.date().isoformat(),\n            'time': d and d.time().isoformat()[:5]\n        }\n```\n\noutput\n```python\n>>> instance = MyModel(some_content=u\"This is some minimalist content.\",\n                       more_content=u\"And that too.\")\n<MyModel >\n>>> instance.es.serialize()\n\"{'some_content': 'This is some minimalist content.',\n  'more_content': 'And t',\n  'content_length': 32,\n  'a_date': {\n     'timestamp': '1434452101',\n     'date': '2015-06-16',\n     'time': '05:53:56.626532'\n  },\n  'some_relation': {'id': 15, 'value': 'something something'}\n}\"\n```\n\nCONTRIB\n=======\n\n* **restframework.ElasticsearchFilterBackend**  \n    A filter backend for [rest framework](http://www.django-rest-framework.org/) that returns a EsQueryset.  \n\n* **restframework.FacetedListModelMixin**  \n    A viewset mixin that adds the facets to the response data in case the ElasticsearchFilterBackend was used.  \n\nLOGGING\n=======\n\nTwo loggers are available 'elasticsearch' and 'elasticsearch.trace'.\n\n\nFAILING GRACEFULLY\n==================\n\nYou can catch ```elasticsearch.ConnectionError``` and ```elasticsearch.TransportError``` if you want to recover from an error on elasticsearch side. There is an example of it in ```django_elasticsearch.views.ElasticsearchListView```.\nYou can also use the ```MyModel.es.check_cluster()``` method which returns True if the cluster is available, in case you want to make sure of it before doing anything.\n\n\nTESTS\n=====\n\nDjango-elasticsearch has a 95% test coverage, and tests pass for django 1.4 to 1.9.\n\nUsing tox\n---------\n\nInstall [tox](https://testrun.org/tox/), then:\n```shell\ncd test_project\ntox\n```\n\nOr to test one specific python/django version combo:\n```\ntox -e py27-django16\n```\n\nOr a specific test case / unit test, with a weird syntax:\nDjango 1.4\n```\ntox -epy27-django14 -- .EsQuerysetTestCase\ntox -epy27-django14 -- .EsQuerysetTestCase.test_use_cache\n```\n\nDjango >1.6\n```\ntox -epy27-django16 -- .tests.test_qs.EsQuerysetTestCase\ntox -epy27-django16 -- .tests.test_qs.EsQuerysetTestCase.test_use_cache\n```\n\n\nThe old way\n-----------\n\n```\n$ cd test_project\n$ virtualenv env\n$ . env/bin/activate\n$ pip install -r ../requirements.txt  # app requirements\n$ pip install -r requirements.txt  # tests requirements\n$ python manage.py test django_elasticsearch\n```\n\nCoverage\n--------\n\n```\ncoverage run --source=django_elasticsearch --omit='*tests*','*migrations*' manage.py test django_elasticsearch\n```\n\nNOTES\n=====\n\nWhy not make a django database backend ? Because django *does not* support non relational databases, which means that the db backend API is very heavily designed around SQL. I'm usually in favor of hiding the complexity, but in this case for every bit that feels right - auto db and test db creation, client handling, .. - there is one that feels wrong and keeping up with the api changes makes it worse. There is an avorted prototype branch (feature/db-backend) going this way though.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/liberation/django_elasticsearch", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "djangoelasticsearch", "package_url": "https://pypi.org/project/djangoelasticsearch/", "platform": "", "project_url": "https://pypi.org/project/djangoelasticsearch/", "project_urls": {"Homepage": "https://github.com/liberation/django_elasticsearch"}, "release_url": "https://pypi.org/project/djangoelasticsearch/0.5.1/", "requires_dist": ["elasticsearch (==2.3.0)", "elasticsearch-dsl (==5.4.0)"], "requires_python": "", "summary": "Simple wrapper around py-elasticsearch to index/search a django Model.", "version": "0.5.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>django_elasticsearch is a wrapper around py-elasticsearch that automates the indexation and search of django models.<br>\n<strong>Note</strong>: if your elasticsearch documents/mappings are not close to django models, this package is probably not for you.</p>\n<h1>INSTALL</h1>\n<ul>\n<li>Install django_elasticsearch\n<pre>pip install djangoelasticsearch\n</pre>\n</li>\n</ul>\n<h1>ELASTICSEARCH VERSION COMPATIBILITY</h1>\n<p>As stated in the python elasticsearch module documentation:</p>\n<blockquote>\n<p>There are two branches for development - master and 0.4. Master branch is used to track all the changes for Elasticsearch 1.0 and beyond whereas 0.4 tracks Elasticsearch 0.90.</p>\n<p>Releases with major version 1 (1.X.Y) are to be used with Elasticsearch 1.* and later, 0.4 releases are meant to work with Elasticsearch 0.90.*.</p>\n</blockquote>\n<p>django_elasticsearch has only been tested with Elasticsearch 1.3.9 and it's corresponding python interface version 1.2.0, but since <a href=\"https://elasticsearch-py.readthedocs.org/en/master/Changelog.html\" rel=\"nofollow\">the API hasn't change</a> i'm quite positive that newer and older versions should work fine too, as long as you use the right python module for your Elasticsearch version. <a href=\"https://elasticsearch-py.readthedocs.org/en/master/#compatibility\" rel=\"nofollow\">See the official docs on the matter</a>.</p>\n<h1>USAGE</h1>\n<p>Subclass the models you wish to index/search with <code>django_elasticsearch.models.EsIndexable</code>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">django.db</span> <span class=\"kn\">import</span> <span class=\"n\">models</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django_elasticsearch.models</span> <span class=\"kn\">import</span> <span class=\"n\">EsIndexable</span>\n\n\n<span class=\"n\">MyModel</span><span class=\"p\">(</span><span class=\"n\">EsIndexable</span><span class=\"p\">,</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">foo</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">)</span>\n    <span class=\"p\">[</span><span class=\"o\">...</span><span class=\"p\">]</span>\n</pre>\n<p>Then you can do:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"n\">MyModel</span><span class=\"o\">.</span><span class=\"n\">es</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"p\">(</span><span class=\"s1\">'value'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">q</span>\n<span class=\"p\">[{</span><span class=\"s1\">'id'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"s1\">'A value'</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"s1\">'id'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"s1\">'Another value'</span><span class=\"p\">},</span> <span class=\"o\">...</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">q</span><span class=\"o\">.</span><span class=\"n\">deserialize</span><span class=\"p\">()</span>\n<span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">MyModel</span> <span class=\"c1\">#1&gt;, &lt;MyModel #2&gt;, ...]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">MyModel</span><span class=\"o\">.</span><span class=\"n\">es</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"nb\">id</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">{</span><span class=\"s1\">'id'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"s1\">'A value'</span><span class=\"p\">}</span>\n</pre>\n<p>The elasticsearch manager methods (all, search, mlt) returns an instance of a EsQueryset, it's like a django Queryset but it queries elasticsearch instead of your db.<br>\nLike a regular Queryset, an EsQueryset is lazy, and if evaluated, returns a list of documents. The <code>.deserialize()</code> method makes the queryset return instances of models instead of dicts.</p>\n<blockquote>\n<p>django-elasticsearch <strong>DOES NOT</strong> index documents by itself unless told to, either set settings.ELASTICSEARCH_AUTO_INDEX to True to index your models when you save them, or call directly myinstance.es.do_index().</p>\n</blockquote>\n<p>To specify the size of output of documents, it is necessary to make a slice of data, for example:</p>\n<pre><code>len(list(MyModel.es.search('value')))\n&gt;&gt;&gt; 10\nlen(list(MyModel.es.search('value')[0:100]))\n&gt;&gt;&gt; 42\n</code></pre>\n<h1>CONFIGURATION</h1>\n<h2>Project scope configuration (django settings):</h2>\n<ul>\n<li>\n<p><strong>ELASTICSEARCH_URL</strong><br>\nDefaults to '<a href=\"http://localhost:9200\" rel=\"nofollow\">http://localhost:9200</a>'<br>\nThe url of your elasticsearch cluster/instance.</p>\n</li>\n<li>\n<p><strong>ELASTICSEARCH_AUTO_INDEX</strong><br>\nDefaults to False<br>\nSet to True if you <strong>don't</strong> want to handle the elasticsearch operations yourself. In that case the creation of the index, the indexation and deletions are hooked respectively to the post_syncdb, post_save and post_delete signals.     Should probably only be used in a dev environment or for small scale databases.\nIf you have already done a syncdb, you can just call <code>MyModel.es.create_index()</code> to create the index/mapping.</p>\n</li>\n<li>\n<p><strong>ELASTICSEARCH_DEFAULT_INDEX</strong><br>\nDefaults to 'django'<br>\nThe default index name used for every document, can be overrided for a model with the <code>model.Meta.Elasticsearch.index</code> attribute.</p>\n</li>\n<li>\n<p><strong>ELASTICSEARCH_SETTINGS</strong><br>\nNo defaults<br>\nIf set, will be passed when creating any index <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-create-index.html#create-index-settings\" rel=\"nofollow\">as is</a>.</p>\n</li>\n<li>\n<p><strong>ELASTICSEARCH_FUZZINESS</strong><br>\nDefaults to 0.5<br>\nWill be applied to any es.search query, See the <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/common-options.html#fuzziness\" rel=\"nofollow\">fuzziness section</a> of the elasticsearch documentation.</p>\n</li>\n<li>\n<p><strong>ELASTICSEARCH_CONNECTION_KWARGS</strong><br>\nDefaults to {}<br>\nAdditional kwargs to be passed to at the instantiation of the elasticsearch client. Useful to manage HTTPS connection for example (<a href=\"http://elasticsearch-py.readthedocs.org/en/master/api.html#elasticsearch.Elasticsearch\" rel=\"nofollow\">Reference</a>).</p>\n</li>\n</ul>\n<h2>Model scope configuration:</h2>\n<p>Each EsIndexable model receive an Elasticsearch class that contains its options (just like the Model.Meta class).</p>\n<ul>\n<li>\n<p><strong>index</strong><br>\nDefaults to 'django'<br>\nThe elasticsearch index in which this model(document type) will be indexed.</p>\n</li>\n<li>\n<p><strong>doc_type</strong><br>\nDefaults to 'model-{model_name}'<br>\nThe elasticsearch type in which this model will be indexed.</p>\n</li>\n<li>\n<p><strong>fields</strong><br>\nDefaults to None<br>\nThe fields to be indexed by elasticsearch, if left to None, all models fields will be indexed.</p>\n</li>\n<li>\n<p><strong>mappings</strong><br>\nDefaults to None<br>\nYou can override some or all of the fields mapping with this dictionary\nExample:</p>\n<pre><span class=\"n\">MyModel</span><span class=\"p\">(</span><span class=\"n\">EsIndexable</span><span class=\"p\">,</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">)</span>\n\n    <span class=\"k\">class</span> <span class=\"nc\">Elasticsearch</span><span class=\"p\">(</span><span class=\"n\">EsIndexable</span><span class=\"o\">.</span><span class=\"n\">Elasticsearch</span><span class=\"p\">):</span>\n        <span class=\"n\">mappings</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'title'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'boost'</span><span class=\"p\">:</span> <span class=\"mf\">2.0</span><span class=\"p\">}}</span>\n</pre>\n<p>In this example we only override the 'boost' attribute of the 'title' field, but there are plenty of possible configurations, see <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-put-mapping.html\" rel=\"nofollow\">the docs</a>.</p>\n</li>\n<li>\n<p><strong>serializer_class</strong><br>\nDefaults to EsJsonSerializer<br>\nThis is the class used to translate from the django model to elasticsearch document both ways.</p>\n</li>\n<li>\n<p><strong>facets_fields</strong><br>\nDefaults to None<br>\nCan be set to a list of fields to return as facets when doing a search query on the model, if not set explicitly in the query itself.</p>\n</li>\n<li>\n<p><strong>facets_limits</strong><br>\nDefaults to None<br>\nThe maximum number of facets to return per query, if None, use the elasticsearch setting.</p>\n</li>\n<li>\n<p><strong>suggest_fields</strong><br>\nDefaults to None<br>\nA dictionary of fields to add in the suggestions, if not set at a search level.</p>\n</li>\n<li>\n<p><strong>suggest_limit</strong><br>\nDefaults to None<br>\nThe maximum number of suggestions to return, if None, use the elasticsearch setting.</p>\n</li>\n<li>\n<p><strong>completion_fields</strong><br>\nDefaults to None<br>\nThe fields on which to activate auto-completion (needs a specific mapping).</p>\n</li>\n</ul>\n<h1>API</h1>\n<h2>EsIndexable API:</h2>\n<p>The Elasticsearch manager is available from the 'es' attribute of EsIndexable Model classes or instances. Some methods requires an instance though.</p>\n<p><strong>Manager methods that returns a EsQueryset instance</strong></p>\n<ul>\n<li>\n<p><strong>es.search</strong>(query,\nfacets=None,\nfacets_limit=None,\nglobal_facets=True,\nsuggest_fields=None,\nsuggest_limit=None,\nfuzziness=None)<br>\nReturns a configured EsQueryset with the given options, or the defaults set in <code>EsIndexable.Elasticsearch</code>.</p>\n</li>\n<li>\n<p><strong>es.all</strong>()<br>\nProxy to an empty query <code>.search(\"\")</code>.</p>\n</li>\n<li>\n<p><strong>es.mlt</strong> <em>needs_instance</em><br>\nReturns an EsQueryset of documents that are 'like' the given instance's document. See the <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-more-like-this.html\" rel=\"nofollow\">more like this api</a>.</p>\n</li>\n</ul>\n<p><strong>Other Manager methods</strong></p>\n<ul>\n<li>\n<p><strong>es.count</strong>()<br>\nReturns the number of documents in the model's doc_type.</p>\n</li>\n<li>\n<p><strong>es.get</strong>() <em>needs_instance</em><br>\nReturns the elasticsearch document of the model instance.</p>\n</li>\n<li>\n<p><strong>es.delete</strong>() <em>needs_instance</em><br>\nDelete the given instance's document.</p>\n</li>\n<li>\n<p><strong>es.do_index</strong>() <em>needs_instance</em><br>\nSerialize and index the given instance.</p>\n</li>\n<li>\n<p><strong>es.complete</strong>(field_name, query)<br>\nReturns a list of suggestions from elasticsearch for the given field and query.\n<strong>Note</strong>: field_name must be present in <code>Elasticsearch.completion_fields</code> because it needs a specific mapping.\nExample:</p>\n<pre><code>&gt;&gt;&gt;MyModel.es.complete('title', 'tset')\n['test',]\n</code></pre>\n</li>\n<li>\n<p><strong>es.do_update</strong>()<br>\nRefresh the whole index of the model. This should probably be only used in a TestCase. See the <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/indices-refresh.html\" rel=\"nofollow\">refresh api</a>.</p>\n</li>\n<li>\n<p><strong>es.get_mapping</strong>()<br>\nReturns the current mapping for the model's document type.</p>\n</li>\n<li>\n<p><strong>es.get_settings</strong>()<br>\nReturns the current settings for the model's index.</p>\n</li>\n<li>\n<p><strong>es.diff</strong>()<br>\nReturns a dict containing differences between the db instance and the elasticsearch instance.</p>\n</li>\n<li>\n<p><strong>es.check_cluster</strong>()<br>\nReturns True if the elasticsearch cluster is alive.</p>\n</li>\n<li>\n<p><strong>es.reindex_all</strong>(queryset=None)<br>\nqueryset defaults to <code>self.model.objects.all()</code><br>\nCalls <code>es.do_index()</code> for every instance in queryset.</p>\n</li>\n<li>\n<p><strong>es.flush</strong>()<br>\nDeletes the model's index and then reindex all instances of it.</p>\n</li>\n</ul>\n<h2>EsQueryset API:</h2>\n<p>This class is as close as possible to a standard relational db Queryset, however the db operations (update and delete) are deactivated (i'm open for discussion on if and how to implement these). Note that just like regular Querysets, EsQuerysets are lazy, they can be ordered, filtered and faceted.</p>\n<p>Note that the return value of the queryset is higly dependent on your mapping, for example, if you want to be able to do an exact filtering with filter() you need a field with {\"index\" : \"not_analyzed\"}.\nAlso by default, filters are case insensitive, if you have a case sensitive tokenizer, you need to instantiate EsQueryset with ignore_case=False.</p>\n<p>An EsQueryset acts a lot like a regular Queryset:</p>\n<pre><code>&gt;&gt;&gt; q = MyModel.es.queryset.all()\n&gt;&gt;&gt; q = q.filter(title='foo')\n&gt;&gt;&gt; q = q.search('test')\n&gt;&gt;&gt; q  # only now is the query evaluated\n[{'title': 'foo', 'some_content': 'this is a test.'}]\n</code></pre>\n<p>If you need models methods or attributes, you can get model instances instead of documents (dicts) by calling the deserialize method on the query before evaluating it. See the Serializer API below.</p>\n<p>To access the facets you can use the facets property of the EsQueryset:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">MyModel</span><span class=\"o\">.</span><span class=\"n\">Elasticsearch</span><span class=\"o\">.</span><span class=\"n\">default_facets_fields</span>\n<span class=\"p\">[</span><span class=\"s1\">'author'</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"n\">MyModel</span><span class=\"o\">.</span><span class=\"n\">es</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"p\">(</span><span class=\"s1\">'woot'</span><span class=\"p\">,</span> <span class=\"n\">facets</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'foo'</span><span class=\"p\">])</span>  <span class=\"c1\"># returns a lazy EsQueryset instance</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"n\">MyModel</span><span class=\"o\">.</span><span class=\"n\">es</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"p\">(</span><span class=\"s1\">'woot'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">facet</span><span class=\"p\">([</span><span class=\"s1\">'foo'</span><span class=\"p\">])</span>  <span class=\"c1\"># is exactly the same</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">q</span><span class=\"o\">.</span><span class=\"n\">facets</span>  <span class=\"c1\"># evals the query and returns the facets</span>\n<span class=\"p\">{</span><span class=\"sa\">u</span><span class=\"s1\">'doc_count'</span><span class=\"p\">:</span> <span class=\"mi\">45</span><span class=\"p\">,</span>\n <span class=\"sa\">u</span><span class=\"s1\">'foo'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"sa\">u</span><span class=\"s1\">'buckets'</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n <span class=\"p\">{</span><span class=\"sa\">u</span><span class=\"s1\">'doc_count'</span><span class=\"p\">:</span> <span class=\"mi\">13</span><span class=\"p\">,</span> <span class=\"sa\">u</span><span class=\"s1\">'key'</span><span class=\"p\">:</span> <span class=\"sa\">u</span><span class=\"s1\">'bar'</span><span class=\"p\">},</span>\n<span class=\"p\">]}}</span>\n</pre>\n<p>Note that es.search automatically add the default facets set on the model to the query, but you can also set them manually with the <code>facets</code> and <code>facets_limit</code> parameters.</p>\n<p><strong>Available methods</strong> all of those are chainable.</p>\n<ul>\n<li>\n<p><strong>es.queryset.search</strong>(query)</p>\n</li>\n<li>\n<p><strong>es.queryset.all</strong>()</p>\n</li>\n<li>\n<p><strong>es.queryset.facet</strong>(fields, limit=None, use_globals=True)<br>\nIf <code>use_globals</code> is set to False, the facets will be filtered like the documents.</p>\n</li>\n<li>\n<p><strong>es.queryset.suggest</strong>(fields, limit)<br>\nAdd <code>fields</code> for suggestions.</p>\n</li>\n<li>\n<p><strong>es.queryset.order_by</strong>(**kwargs)</p>\n</li>\n<li>\n<p><strong>es.queryset.filter</strong>(**kwargs)<br>\nAccepted lookups are: __exact, __should, __contains, __gt, __gte, __lt, __lte, __range<br>\nJust like in django, the default lookup is __exact.<br>\nSee the <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html\" rel=\"nofollow\">bool query</a> for a difference between __exact (which maps to 'must') and __should.</p>\n</li>\n<li>\n<p><strong>es.queryset.exclude</strong>(**kwargs)</p>\n</li>\n<li>\n<p><strong>es.queryset.mlt</strong>(id)<br>\nSee the <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/search-more-like-this.html\" rel=\"nofollow\">more like this api</a>.</p>\n</li>\n<li>\n<p><strong>es.queryset.deserialize</strong>()\nMakes the queryset return model instances instead of documents.</p>\n</li>\n<li>\n<p><strong>es.queryset.extra</strong>(body)\nBlindly updates the elasticsearch query body with <code>body</code> allowing to use any non-implemented elasticsearch feature.</p>\n</li>\n</ul>\n<p><strong>Does not return an EsQueryset</strong> and thus are not chainable.</p>\n<ul>\n<li>\n<p><strong>es.queryset.count</strong>()</p>\n</li>\n<li>\n<p><strong>es.queryset.get</strong>(pk=X)</p>\n</li>\n<li>\n<p><strong>es.queryset.complete</strong>(field_name, query)</p>\n</li>\n</ul>\n<h2>Serializer API:</h2>\n<p>The serializer's role is to format django model instances to something indexable by elasticsearch : json. The only mandatory method for a serializer is the <code>serialize(instance)</code> method, deserializing is only an option.</p>\n<p>The default serializer does a little bit more though:<br>\nFor each indexed fields, look for either <code>serialize_{field_name}</code> or <code>serialize_{field_type}</code> methods, and fallback on <code>getattr(instance, field_name)</code>. Also allow naive nested serialization, by looking for an Elasticsearch class attribute on the target model class of the related field, or falling back on <code>dict(id=instance.id, value=unicode(instance))</code>.<br>\nLet's look at a bit complex example:</p>\n<p>my_app.models.py</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">django.db</span> <span class=\"kn\">import</span> <span class=\"n\">models</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django_elasticsearch.models</span> <span class=\"kn\">import</span> <span class=\"n\">EsIndexable</span>\n<span class=\"kn\">from</span> <span class=\"nn\">my_app.serializers</span> <span class=\"kn\">import</span> <span class=\"n\">MyModelEsSerializer</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModel</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n      <span class=\"n\">some_content</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">255</span><span class=\"p\">)</span>\n      <span class=\"n\">more_content</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">TextField</span><span class=\"p\">()</span>\n      <span class=\"n\">a_date</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">DateTimeField</span><span class=\"p\">(</span><span class=\"n\">auto_now_add</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n      <span class=\"n\">another_date</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">DateTimeField</span><span class=\"p\">(</span><span class=\"n\">auto_now</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n      <span class=\"n\">some_relation</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">ForeignKey</span><span class=\"p\">(</span><span class=\"n\">AnotherModel</span><span class=\"p\">)</span>\n\n      <span class=\"k\">class</span> <span class=\"nc\">Elasticsearch</span><span class=\"p\">(</span><span class=\"n\">EsIndexable</span><span class=\"o\">.</span><span class=\"n\">Elasticsearch</span><span class=\"p\">):</span>\n            <span class=\"n\">serializer_class</span> <span class=\"o\">=</span> <span class=\"n\">MyModelEsSerializer</span>\n            <span class=\"n\">fields</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'some_content'</span><span class=\"p\">,</span> <span class=\"s1\">'more_content'</span><span class=\"p\">,</span> <span class=\"s1\">'content_length'</span><span class=\"p\">,</span> <span class=\"s1\">'a_date'</span><span class=\"p\">,</span> <span class=\"s1\">'some_relation'</span><span class=\"p\">]</span>\n            <span class=\"n\">mappings</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'content_length'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'type'</span><span class=\"p\">:</span> <span class=\"s1\">'long'</span><span class=\"p\">},</span>\n                        <span class=\"s1\">'a_date'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'type'</span><span class=\"p\">:</span> <span class=\"s1\">'object'</span><span class=\"p\">}}</span>\n</pre>\n<p>Note that since <code>content_length</code> is an abstract field (not present in db), and <code>a_date</code> is serialized to a dict instead of it's default (datetime), we need to tell elasticsearch their types in the mappings attribute.</p>\n<p>serializers.py</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">django_elasticsearch.serializers</span> <span class=\"kn\">import</span> <span class=\"n\">EsJsonSerializer</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModelEsSerializer</span><span class=\"p\">(</span><span class=\"n\">EsJsonSerializer</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">serialize_more_content</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"n\">field_name</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Specific attribute serializer</span>\n        <span class=\"k\">return</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"n\">field_name</span><span class=\"p\">)[:</span><span class=\"mi\">5</span><span class=\"p\">]</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">serialize_content_length</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"n\">field_name</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Abstract field serializer</span>\n        <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"s1\">'some_content'</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">serialize_type_datetimefield</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"n\">field_name</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Specific field type serializer</span>\n        <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"nb\">getattr</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"n\">field_name</span><span class=\"p\">)</span>\n        <span class=\"c1\"># A rather typical api output,</span>\n        <span class=\"c1\"># The reasons for indexing dates as this are debatable, but it's just an example</span>\n        <span class=\"k\">return</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'timestamp'</span><span class=\"p\">:</span> <span class=\"n\">d</span> <span class=\"ow\">and</span> <span class=\"n\">d</span><span class=\"o\">.</span><span class=\"n\">strftime</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"si\">%s</span><span class=\"s1\">'</span><span class=\"p\">),</span>\n            <span class=\"s1\">'date'</span><span class=\"p\">:</span> <span class=\"n\">d</span> <span class=\"ow\">and</span> <span class=\"n\">d</span><span class=\"o\">.</span><span class=\"n\">date</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">isoformat</span><span class=\"p\">(),</span>\n            <span class=\"s1\">'time'</span><span class=\"p\">:</span> <span class=\"n\">d</span> <span class=\"ow\">and</span> <span class=\"n\">d</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">isoformat</span><span class=\"p\">()[:</span><span class=\"mi\">5</span><span class=\"p\">]</span>\n        <span class=\"p\">}</span>\n</pre>\n<p>output</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"n\">MyModel</span><span class=\"p\">(</span><span class=\"n\">some_content</span><span class=\"o\">=</span><span class=\"sa\">u</span><span class=\"s2\">\"This is some minimalist content.\"</span><span class=\"p\">,</span>\n                       <span class=\"n\">more_content</span><span class=\"o\">=</span><span class=\"sa\">u</span><span class=\"s2\">\"And that too.\"</span><span class=\"p\">)</span>\n<span class=\"o\">&lt;</span><span class=\"n\">MyModel</span> <span class=\"o\">&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">instance</span><span class=\"o\">.</span><span class=\"n\">es</span><span class=\"o\">.</span><span class=\"n\">serialize</span><span class=\"p\">()</span>\n<span class=\"s2\">\"{'some_content': 'This is some minimalist content.',</span>\n  <span class=\"s1\">'more_content'</span><span class=\"p\">:</span> <span class=\"s1\">'And t'</span><span class=\"p\">,</span>\n  <span class=\"s1\">'content_length'</span><span class=\"p\">:</span> <span class=\"mi\">32</span><span class=\"p\">,</span>\n  <span class=\"s1\">'a_date'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n     <span class=\"s1\">'timestamp'</span><span class=\"p\">:</span> <span class=\"s1\">'1434452101'</span><span class=\"p\">,</span>\n     <span class=\"s1\">'date'</span><span class=\"p\">:</span> <span class=\"s1\">'2015-06-16'</span><span class=\"p\">,</span>\n     <span class=\"s1\">'time'</span><span class=\"p\">:</span> <span class=\"s1\">'05:53:56.626532'</span>\n  <span class=\"p\">},</span>\n  <span class=\"s1\">'some_relation'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'id'</span><span class=\"p\">:</span> <span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"s1\">'value'</span><span class=\"p\">:</span> <span class=\"s1\">'something something'</span><span class=\"p\">}</span>\n<span class=\"p\">}</span><span class=\"s2\">\"</span>\n</pre>\n<h1>CONTRIB</h1>\n<ul>\n<li>\n<p><strong>restframework.ElasticsearchFilterBackend</strong><br>\nA filter backend for <a href=\"http://www.django-rest-framework.org/\" rel=\"nofollow\">rest framework</a> that returns a EsQueryset.</p>\n</li>\n<li>\n<p><strong>restframework.FacetedListModelMixin</strong><br>\nA viewset mixin that adds the facets to the response data in case the ElasticsearchFilterBackend was used.</p>\n</li>\n</ul>\n<h1>LOGGING</h1>\n<p>Two loggers are available 'elasticsearch' and 'elasticsearch.trace'.</p>\n<h1>FAILING GRACEFULLY</h1>\n<p>You can catch <code>elasticsearch.ConnectionError</code> and <code>elasticsearch.TransportError</code> if you want to recover from an error on elasticsearch side. There is an example of it in <code>django_elasticsearch.views.ElasticsearchListView</code>.\nYou can also use the <code>MyModel.es.check_cluster()</code> method which returns True if the cluster is available, in case you want to make sure of it before doing anything.</p>\n<h1>TESTS</h1>\n<p>Django-elasticsearch has a 95% test coverage, and tests pass for django 1.4 to 1.9.</p>\n<h2>Using tox</h2>\n<p>Install <a href=\"https://testrun.org/tox/\" rel=\"nofollow\">tox</a>, then:</p>\n<pre><span class=\"nb\">cd</span> test_project\ntox\n</pre>\n<p>Or to test one specific python/django version combo:</p>\n<pre><code>tox -e py27-django16\n</code></pre>\n<p>Or a specific test case / unit test, with a weird syntax:\nDjango 1.4</p>\n<pre><code>tox -epy27-django14 -- .EsQuerysetTestCase\ntox -epy27-django14 -- .EsQuerysetTestCase.test_use_cache\n</code></pre>\n<p>Django &gt;1.6</p>\n<pre><code>tox -epy27-django16 -- .tests.test_qs.EsQuerysetTestCase\ntox -epy27-django16 -- .tests.test_qs.EsQuerysetTestCase.test_use_cache\n</code></pre>\n<h2>The old way</h2>\n<pre><code>$ cd test_project\n$ virtualenv env\n$ . env/bin/activate\n$ pip install -r ../requirements.txt  # app requirements\n$ pip install -r requirements.txt  # tests requirements\n$ python manage.py test django_elasticsearch\n</code></pre>\n<h2>Coverage</h2>\n<pre><code>coverage run --source=django_elasticsearch --omit='*tests*','*migrations*' manage.py test django_elasticsearch\n</code></pre>\n<h1>NOTES</h1>\n<p>Why not make a django database backend ? Because django <em>does not</em> support non relational databases, which means that the db backend API is very heavily designed around SQL. I'm usually in favor of hiding the complexity, but in this case for every bit that feels right - auto db and test db creation, client handling, .. - there is one that feels wrong and keeping up with the api changes makes it worse. There is an avorted prototype branch (feature/db-backend) going this way though.</p>\n\n          </div>"}, "last_serial": 5094624, "releases": {"0.5": [{"comment_text": "", "digests": {"md5": "0b49b66c1b29f69a89481b58147903b6", "sha256": "092be68790085ec94be2ecd530350cb95fb775d3ac78041a52a10c353130b54e"}, "downloads": -1, "filename": "djangoelasticsearch-0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "0b49b66c1b29f69a89481b58147903b6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 36082, "upload_time": "2019-04-04T04:55:26", "upload_time_iso_8601": "2019-04-04T04:55:26.490783Z", "url": "https://files.pythonhosted.org/packages/5a/65/00122626b3e7d81c547267ef4b99770734647fd921fee4922400caed4dd3/djangoelasticsearch-0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b52145293d43ed69a076cbdc1600d149", "sha256": "9f4b709bc87dafee32b38886f2e5610cb343b0d8c1ad48be999ae97cc955b453"}, "downloads": -1, "filename": "djangoelasticsearch-0.5.tar.gz", "has_sig": false, "md5_digest": "b52145293d43ed69a076cbdc1600d149", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26060, "upload_time": "2019-04-04T04:55:29", "upload_time_iso_8601": "2019-04-04T04:55:29.258168Z", "url": "https://files.pythonhosted.org/packages/cc/da/41655bdc7319c5245a8b8961775aedcbca259c1e2ebde97291d6eab77bf3/djangoelasticsearch-0.5.tar.gz", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "913d86e045946d06e2123d0e31c03e65", "sha256": "2b76e0ac1f322da0f1770c01828d25b80abfa605ef34a4e7fb54bf93e5fe549d"}, "downloads": -1, "filename": "djangoelasticsearch-0.5.1-py3-none-any.whl", "has_sig": false, "md5_digest": "913d86e045946d06e2123d0e31c03e65", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 36026, "upload_time": "2019-04-04T05:00:02", "upload_time_iso_8601": "2019-04-04T05:00:02.663209Z", "url": "https://files.pythonhosted.org/packages/65/57/bd004e8ae19280da2b5fd677468026e6daadb75f8c8a2fe7fcc33cb1f160/djangoelasticsearch-0.5.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0e6cd137b58ebf56ac126352d396b03f", "sha256": "fe99937b87fa0748cf752ca5f4673caa95fe81b0724532456e032991a0eb4888"}, "downloads": -1, "filename": "djangoelasticsearch-0.5.1.tar.gz", "has_sig": false, "md5_digest": "0e6cd137b58ebf56ac126352d396b03f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25986, "upload_time": "2019-04-04T05:00:05", "upload_time_iso_8601": "2019-04-04T05:00:05.529592Z", "url": "https://files.pythonhosted.org/packages/a5/06/ff7e304e3554c1e184bf90faa54483708525553297979121d9589aa732b7/djangoelasticsearch-0.5.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "913d86e045946d06e2123d0e31c03e65", "sha256": "2b76e0ac1f322da0f1770c01828d25b80abfa605ef34a4e7fb54bf93e5fe549d"}, "downloads": -1, "filename": "djangoelasticsearch-0.5.1-py3-none-any.whl", "has_sig": false, "md5_digest": "913d86e045946d06e2123d0e31c03e65", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 36026, "upload_time": "2019-04-04T05:00:02", "upload_time_iso_8601": "2019-04-04T05:00:02.663209Z", "url": "https://files.pythonhosted.org/packages/65/57/bd004e8ae19280da2b5fd677468026e6daadb75f8c8a2fe7fcc33cb1f160/djangoelasticsearch-0.5.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0e6cd137b58ebf56ac126352d396b03f", "sha256": "fe99937b87fa0748cf752ca5f4673caa95fe81b0724532456e032991a0eb4888"}, "downloads": -1, "filename": "djangoelasticsearch-0.5.1.tar.gz", "has_sig": false, "md5_digest": "0e6cd137b58ebf56ac126352d396b03f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25986, "upload_time": "2019-04-04T05:00:05", "upload_time_iso_8601": "2019-04-04T05:00:05.529592Z", "url": "https://files.pythonhosted.org/packages/a5/06/ff7e304e3554c1e184bf90faa54483708525553297979121d9589aa732b7/djangoelasticsearch-0.5.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:36:25 2020"}