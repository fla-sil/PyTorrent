{"info": {"author": "Nischal Padmanabha, Mauricio Villegas", "author_email": "nischal@omnius.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: MacOS", "Operating System :: POSIX :: Linux", "Operating System :: Unix", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3 :: Only"], "description": ".. image:: https://circleci.com/gh/omni-us/reconplogger.svg?style=svg\n    :target: https://circleci.com/gh/omni-us/reconplogger\n.. image:: https://codecov.io/gh/omni-us/reconplogger/branch/master/graph/badge.svg\n    :target: https://codecov.io/gh/omni-us/reconplogger\n.. image:: https://badge.fury.io/py/reconplogger.svg\n    :target: https://badge.fury.io/py/reconplogger\n.. image:: https://img.shields.io/badge/contributions-welcome-brightgreen.svg\n    :target: https://github.com/omni-us/reconplogger\n\nreconplogger - omni:us python logger\n====================================\n\nThis repository contains the code of reconplogger, a python package intended to\nease the standardization of logging within omni:us. The main design decision of\nreconplogger is to allow total freedom to reconfigure loggers without hard\ncoding anything.\n\nThe package contains essentially three things:\n\n- A default logging configuration.\n- A function for loading logging configuration for regular python code.\n- A function for loading logging configuration for flask-based microservices.\n- Lower level functions for:\n\n  - Loading logging configuration from any of: config file, environment variable, or default.\n  - Replacing the handlers of an existing Logger object.\n  - Function to add a file handler to a logger.\n\n\nHow to use\n==========\n\nThere are two main use cases reconplogger targets. One is for logging in regular\ngeneric python code and the second one is logging in microservices. See the two\nstandardizing sections below for a detailed explanation of the two use cases.\n\n\nAdd as requirement\n------------------\n\nThe first step to use reconplogger is adding it as a requirement in the\nrespective package where it will be used. This means adding it in the file\n`setup.cfg` as an item in :code:`install_requires` or in an\n:code:`extras_require` depending on whether reconplogger is intended to be a\ncore or an optional requirement.\n\nNote: It is highly discouraged to develop packages in which requirements are\nadded directly to `setup.py` or to have an ambiguous `requirements.txt` file.\nSee the `setup.cfg` file in the reconplogger source code for reference.\n\n\nDefault logging configuration\n-----------------------------\n\nA feature that reconplogger provides is the possibility of externally setting\nthe logging configuration without having to change code or implement any parsing\nof configuration. However, if a logging configuration is not given externally,\nreconplogger provides a default configuration.\n\nThe default configuration defines three handlers, two of which are stream\nhandlers and are set to DEBUG log level. The first handler called\n:code:`plain_handler` uses a simple plain text formatter, and the second handler\ncalled :code:`json_handler` as the name suggests outputs in json format, using\nthe `logmatic <https://pypi.org/project/logmatic-python/>`_ JsonFormatter class.\nThe third handler called :code:`null_handler` is useful to disable all logging.\n\nFor each handler the default configuration defines a corresponding logger:\n:code:`plain_logger`, :code:`json_logger` and :code:`null_logger`.\n\n\nStandardizing logging in regular python\n---------------------------------------\n\nOne objective of reconplogger is to ease the use of logging and standardize the\nway it is done across all omni:us python code. The use of reconplogger comes\ndown to calling one function to get the logger object. For regular python code\n(i.e. not a microservice) the function to use is\n`reconplogger.logger_setup`.\n\nThe following code snippet illustrates the use:\n\n.. code-block:: python\n\n    import reconplogger\n\n    # Default plain logger\n    logger = reconplogger.logger_setup()\n    logger.info('My log message')\n\n    # Json logger and custom prefix\n    logger = reconplogger.logger_setup('json_logger', env_prefix='MYAPP')\n    logger.info('My log message in json format')\n\nThis function gives you the ability to set the default logger to use\n(:code:`logger_name` argument whose default value is :code:`plain_logger`) and\noptionally provide a logging :code:`config` and/or a logging :code:`level` that\noverrides the level in the config.\n\nAll of these values can be overridden via environment variables whose names are\nprefixed by the value of the :code:`env_prefix` argument. The environment\nvariables supported are: :code:`{env_prefix}_CFG`, :code:`{env_prefix}_NAME` and\n:code:`{env_prefix}_LEVEL`. Note that the environment variable names are not\nrequired to be prefixed by the default :code:`env_prefix='LOGGER'`. The prefix\ncan be chosen by the user for each particular application.\n\nFor functions or classes that receive logger object as an argument, it might be\ndesired to set a non-logging default so that it can be called without specifying\none. For this reconplogger defines :code:`null logger` that could be used as\nfollows:\n\n.. code-block:: python\n\n    from reconplogger import null_logger\n\n    ...\n\n    def my_func(arg1, arg2, logger=null_logger):\n\n    ...\n\n\nStandardizing logging in flask-based microservices\n--------------------------------------------------\n\nThe most important objective of reconplogger is to allow standardization of a\nstructured logging format for all microservices developed. Thus, the logging\nfrom all microservices should be configured like explained here. The use is\nanalogous to the previous case, but using the function\n`reconplogger.flask_app_logger_setup` instead, and giving as first argument\nthe flask app object. Additional to the previous case, this function replaces\nthe flask app and werkzeug loggers to use a reconplogger configured one. The usage\nwould be as follows:\n\n.. code-block:: python\n\n    import reconplogger\n    from flask import Flask\n\n    ...\n\n    app = Flask(__name__)\n\n    ...\n\n    logger = reconplogger.flask_app_logger_setup(app, level='DEBUG')\n\n    ## NOTE: do not change logger beyond this point!\n\n    ...\n\n    ## Use logger in code\n    myclass = MyClass(..., logger=logger)\n\n    ...\n\nAn important note is that after configuring the logger, the code should not\nmodify the logger configuration. For example, the logging level should not be\nmodified. Adding an additional handler to the logger is not a problem. This\ncould be desired for example to additionally log to a file.\n\nIn the helm `values.yaml` file of the microservice, the default values for the\nenvironment variables should be set as:\n\n.. code-block:: yaml\n\n    LOGGER_CFG:\n    LOGGER_NAME: json_logger\n    LOGGER_LEVEL: DEBUG\n\nWith the :code:`json_logger` logger, the format of the logs should look\nsomething like the following::\n\n    {\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"INFO\", \"filename\": \"test_formatter.py\", \"lineno\": 5, \"message\": \"Hello world\"}\n    {\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"DEBUG\", \"filename\": \"test_formatter.py\", \"lineno\": 9, \"message\": \"Hello world\"}\n    {\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"ERROR\", \"filename\": \"test_formatter.py\", \"lineno\": 13, \"message\": \"Hello world\"}\n    {\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"CRITICAL\", \"filename\": \"test_formatter.py\", \"lineno\": 17, \"message\": \"Hello world\"}\n    {\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"ERROR\", \"filename\": \"test_formatter.py\", \"lineno\": 25, \"message\": \"division by zero\"}\n    {\"asctime\": \"2018-09-05 17:38:38,138\", \"levelname\": \"ERROR\", \"filename\": \"test_formatter.py\", \"lineno\": 33, \"message\": \"Exception has occured\", \"exc_info\": \"Traceback (most recent call last):\\n  File \\\"reconplogger/tests/test_formatter.py\\\", line 31, in test_exception_with_trace\\n    b = 100 / 0\\nZeroDivisionError: division by zero\"}\n    {\"asctime\": \"2018-09-05 17:38:38,138\", \"levelname\": \"INFO\", \"filename\": \"test_formatter.py\", \"lineno\": 37, \"message\": \"Hello world\", \"context check\": \"check\"}\n\n\nUse of the logger object\n------------------------\n\nThe logger objects returned by the setup functions are normal python\n:code:`logging.Logger` objects, so all the standard logging functionalities\nshould be used. Please refer to the `logging package documentation\n<https://docs.python.org/3/howto/logging.html>`_ for details.\n\nA couple of logging features that should be very commonly used are the\nfollowing. To add additional structured information to a log, the :code:`extra`\nargument should be used. A simple example could be::\n\n    logger.info('Successfully processed document', extra={'uuid': uuid})\n\nWhen an exception occurs the :code:`exc_info=True` argument should be used, for\nexample::\n\n    try:\n        ...\n    except:\n        logger.critical('Failed to run task', exc_info=True)\n\n\nAdding a file handler\n---------------------\n\nIn some circumstances it is desired to add to a logger a file handler so that\nthe logging messages are also saved to a file. This normally requires at least\nthree lines of code, thus to simplify things reconplogger provides the\n`reconplogger.add_file_handler` function to do the same with a single line\nof code. The use is quite straightforward as::\n\n    reconplogger.add_file_handler(logger, '/path/to/log/file.log')\n\n\nOverriding logging configuration\n--------------------------------\n\nAn important feature of reconplogger is that the logging configuration of apps\nthat use it can be easily changed via the environment variables. First set the\nenvironment variables with the desired logging configuration and logger name:\n\n.. code-block:: bash\n\n    export LOGGER_NAME=\"example_logger\"\n\n    export LOGGER_CFG='{\n        \"version\": 1,\n        \"formatters\": {\n            \"verbose\": {\n                \"format\": \"%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s\"\n            }\n        },\n        \"handlers\": {\n            \"console\":{\n                \"level\":\"DEBUG\",\n                \"class\":\"logging.StreamHandler\",\n                \"formatter\": \"verbose\"\n            }\n        },\n        \"loggers\": {\n            \"example_logger\": {\n                \"handlers\": [\"console\"],\n                \"level\": \"ERROR\",\n            }\n        }\n    }'\n\nThen, in the python code the logger would be used as follows:\n\n.. code-block:: python\n\n    >>> import reconplogger\n    >>> logger = reconplogger.logger_setup(env_prefix='LOGGER')\n    >>> logger.error('My error message')\n    ERROR 2019-10-18 14:45:22,629 <stdin> 16876 139918773925696 My error message\n\n\nLow level functions\n===================\n\n\nLoading configuration\n---------------------\n\nThe `reconplogger.load_config` function allows loading of a python logging\nconfiguration. The format config can be either json or yaml. The loading of\nconfiguration can be from a file (giving its path), from an environment variable\n(giving the variable name), a raw configuration string, or loading the default\nconfiguration that comes with reconplogger. See below examples of loading for\neach of the cases:\n\n.. code-block:: python\n\n    import reconplogger\n\n    ## Load from config file\n    reconplogger.load_config('/path/to/config.yaml')\n\n    ## Load from environment variable\n    reconplogger.load_config('LOGGER_CFG')\n\n    ## Load default config\n    reconplogger.load_config('reconplogger_default_cfg')\n\n\nReplacing logger handlers\n-------------------------\n\nIn some cases it might be needed to replace the handlers of some already\nexisting logger. For this reconplogger provides the\n`reconplogger.replace_logger_handlers` function. To use it, simply provide\nthe logger in which to replace the handlers and the logger from where to get the\nhandlers. The procedure would be as follows:\n\n.. code-block:: python\n\n    import reconplogger\n\n    logger = reconplogger.logger_setup('json_logger')\n    reconplogger.replace_logger_handlers('some_logger_name', logger)\n\n\nContributing\n============\n\nContributions to this package are very welcome. When you plan to work with the\nsource code, note that this project does not include a `requirements.txt` file.\nThis is by intention. To make it very clear what are the requirements for\ndifferent use cases, all the requirements of the project are stored in the file\n`setup.cfg`. The basic runtime requirements are defined in section\n:code:`[options]` in the :code:`install_requires` entry. All optional\nrequirements are stored in section :code:`[options.extras_require]`. There are\n:code:`test`, :code:`dev` and :code:`doc` extras require to be used by\ndevelopers (e.g. requirements to run the unit tests) and an :code:`all` extras\nrequire for optional runtime requirements, namely Flask support.\n\nThe recommended way to work with the source code is the following. First clone\nthe repository, then create a virtual environment, activate it and finally\ninstall the development requirements. More precisely the steps would be:\n\n.. code-block:: bash\n\n    git clone https://github.com/omni-us/reconplogger.git\n    cd reconplogger\n    virtualenv -p python3 venv\n    . venv/bin/activate\n\nThe crucial step is installing the requirements which would be done by running:\n\n.. code-block:: bash\n\n    pip3 install --editable .[dev,doc,test,all]\n\nAfter changing the code, always run unit tests as follows:\n\n.. code-block:: bash\n\n    ./setup.py test\n\n\nPull requests\n-------------\n\n- To contribute it is required to create and push to a new branch and issue a\n  pull request.\n\n- A pull request will only be accepted if:\n\n    - All python files pass pylint checks.\n    - All unit tests run successfully.\n    - New code has docstrings and gets included in the html documentation.\n\n- When developing, after cloning be sure to run the githook-pre-commit to setup\n  the pre-commit hook. This will help you by automatically running pylint before\n  every commit.\n\nUsing bump version\n------------------\n\nOnly the maintainer of this repo should bump versions and this should be done\nonly on the master branch. To bump the version it is required to use the\nbumpversion command that should already be installed if :code:`pip3 install\n--editable .[dev,doc,test,all]` was run as previously instructed.\n\n.. code-block:: bash\n\n    bumpversion major/minor/patch\n\nPush the tags to the repository as well.\n\n.. code-block:: bash\n\n    git push; git push --tags\n\nWhen the version tags are pushed, circleci will automatically build the wheel\nfile, test it and if successful, push the package to pypi.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://omni-us.github.io/reconplogger", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "reconplogger", "package_url": "https://pypi.org/project/reconplogger/", "platform": "any", "project_url": "https://pypi.org/project/reconplogger/", "project_urls": {"CircleCI": "https://circleci.com/gh/omni-us/reconplogger", "Documentation": "https://omni-us.github.io/reconplogger", "GitHub": "https://github.com/omni-us/reconplogger", "Homepage": "https://omni-us.github.io/reconplogger", "PyPI": "https://pypi.org/project/reconplogger"}, "release_url": "https://pypi.org/project/reconplogger/4.2.0/", "requires_dist": ["logmatic-python (>=0.1.7)", "PyYAML (>=3.13)", "Flask (>=1.1.1) ; extra == 'all'", "pylint (>=1.8.3) ; extra == 'dev'", "bump2version (>=0.5.11) ; extra == 'dev'", "Sphinx (>=1.7.9) ; extra == 'doc'", "sphinx-rtd-theme (>=0.4.3) ; extra == 'doc'", "autodocsumm (>=0.1.10) ; extra == 'doc'", "testfixtures (>=6.10.0) ; extra == 'test'", "wheel-inspect (>=1.3.0) ; extra == 'test'", "coverage (>=4.5.1) ; extra == 'test'", "codecov (>=2.0.15) ; extra == 'test'", "junitxml (>=0.7) ; extra == 'test'", "python-subunit (>=1.3.0) ; extra == 'test'"], "requires_python": ">=3.5", "summary": "omni:us python logging package", "version": "4.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://circleci.com/gh/omni-us/reconplogger\" rel=\"nofollow\"><img alt=\"https://circleci.com/gh/omni-us/reconplogger.svg?style=svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e94124fef9eab8cc026dbfc77089ee0f2b352ec9/68747470733a2f2f636972636c6563692e636f6d2f67682f6f6d6e692d75732f7265636f6e706c6f676765722e7376673f7374796c653d737667\"></a>\n<a href=\"https://codecov.io/gh/omni-us/reconplogger\" rel=\"nofollow\"><img alt=\"https://codecov.io/gh/omni-us/reconplogger/branch/master/graph/badge.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3326c33bf4d681c594bb74ff9f1f0fed2c521f68/68747470733a2f2f636f6465636f762e696f2f67682f6f6d6e692d75732f7265636f6e706c6f676765722f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://badge.fury.io/py/reconplogger\" rel=\"nofollow\"><img alt=\"https://badge.fury.io/py/reconplogger.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/87bbe512bf87a73ab1b8d3e3097a0e0a78a420dc/68747470733a2f2f62616467652e667572792e696f2f70792f7265636f6e706c6f676765722e737667\"></a>\n<a href=\"https://github.com/omni-us/reconplogger\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/contributions-welcome-brightgreen.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/220aa3f89f789ec18b3b3c9096a2a11ab994fd90/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f6e747269627574696f6e732d77656c636f6d652d627269676874677265656e2e737667\"></a>\n<div id=\"reconplogger-omni-us-python-logger\">\n<h2>reconplogger - omni:us python logger</h2>\n<p>This repository contains the code of reconplogger, a python package intended to\nease the standardization of logging within omni:us. The main design decision of\nreconplogger is to allow total freedom to reconfigure loggers without hard\ncoding anything.</p>\n<p>The package contains essentially three things:</p>\n<ul>\n<li>A default logging configuration.</li>\n<li>A function for loading logging configuration for regular python code.</li>\n<li>A function for loading logging configuration for flask-based microservices.</li>\n<li>Lower level functions for:<ul>\n<li>Loading logging configuration from any of: config file, environment variable, or default.</li>\n<li>Replacing the handlers of an existing Logger object.</li>\n<li>Function to add a file handler to a logger.</li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"how-to-use\">\n<h2>How to use</h2>\n<p>There are two main use cases reconplogger targets. One is for logging in regular\ngeneric python code and the second one is logging in microservices. See the two\nstandardizing sections below for a detailed explanation of the two use cases.</p>\n<div id=\"add-as-requirement\">\n<h3>Add as requirement</h3>\n<p>The first step to use reconplogger is adding it as a requirement in the\nrespective package where it will be used. This means adding it in the file\n<cite>setup.cfg</cite> as an item in <code>install_requires</code> or in an\n<code>extras_require</code> depending on whether reconplogger is intended to be a\ncore or an optional requirement.</p>\n<p>Note: It is highly discouraged to develop packages in which requirements are\nadded directly to <cite>setup.py</cite> or to have an ambiguous <cite>requirements.txt</cite> file.\nSee the <cite>setup.cfg</cite> file in the reconplogger source code for reference.</p>\n</div>\n<div id=\"default-logging-configuration\">\n<h3>Default logging configuration</h3>\n<p>A feature that reconplogger provides is the possibility of externally setting\nthe logging configuration without having to change code or implement any parsing\nof configuration. However, if a logging configuration is not given externally,\nreconplogger provides a default configuration.</p>\n<p>The default configuration defines three handlers, two of which are stream\nhandlers and are set to DEBUG log level. The first handler called\n<code>plain_handler</code> uses a simple plain text formatter, and the second handler\ncalled <code>json_handler</code> as the name suggests outputs in json format, using\nthe <a href=\"https://pypi.org/project/logmatic-python/\" rel=\"nofollow\">logmatic</a> JsonFormatter class.\nThe third handler called <code>null_handler</code> is useful to disable all logging.</p>\n<p>For each handler the default configuration defines a corresponding logger:\n<code>plain_logger</code>, <code>json_logger</code> and <code>null_logger</code>.</p>\n</div>\n<div id=\"standardizing-logging-in-regular-python\">\n<h3>Standardizing logging in regular python</h3>\n<p>One objective of reconplogger is to ease the use of logging and standardize the\nway it is done across all omni:us python code. The use of reconplogger comes\ndown to calling one function to get the logger object. For regular python code\n(i.e. not a microservice) the function to use is\n<cite>reconplogger.logger_setup</cite>.</p>\n<p>The following code snippet illustrates the use:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">reconplogger</span>\n\n<span class=\"c1\"># Default plain logger</span>\n<span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">reconplogger</span><span class=\"o\">.</span><span class=\"n\">logger_setup</span><span class=\"p\">()</span>\n<span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">'My log message'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Json logger and custom prefix</span>\n<span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">reconplogger</span><span class=\"o\">.</span><span class=\"n\">logger_setup</span><span class=\"p\">(</span><span class=\"s1\">'json_logger'</span><span class=\"p\">,</span> <span class=\"n\">env_prefix</span><span class=\"o\">=</span><span class=\"s1\">'MYAPP'</span><span class=\"p\">)</span>\n<span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">info</span><span class=\"p\">(</span><span class=\"s1\">'My log message in json format'</span><span class=\"p\">)</span>\n</pre>\n<p>This function gives you the ability to set the default logger to use\n(<code>logger_name</code> argument whose default value is <code>plain_logger</code>) and\noptionally provide a logging <code>config</code> and/or a logging <code>level</code> that\noverrides the level in the config.</p>\n<p>All of these values can be overridden via environment variables whose names are\nprefixed by the value of the <code>env_prefix</code> argument. The environment\nvariables supported are: <code>{env_prefix}_CFG</code>, <code>{env_prefix}_NAME</code> and\n<code>{env_prefix}_LEVEL</code>. Note that the environment variable names are not\nrequired to be prefixed by the default <code>env_prefix='LOGGER'</code>. The prefix\ncan be chosen by the user for each particular application.</p>\n<p>For functions or classes that receive logger object as an argument, it might be\ndesired to set a non-logging default so that it can be called without specifying\none. For this reconplogger defines <code>null logger</code> that could be used as\nfollows:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">reconplogger</span> <span class=\"kn\">import</span> <span class=\"n\">null_logger</span>\n\n<span class=\"o\">...</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">my_func</span><span class=\"p\">(</span><span class=\"n\">arg1</span><span class=\"p\">,</span> <span class=\"n\">arg2</span><span class=\"p\">,</span> <span class=\"n\">logger</span><span class=\"o\">=</span><span class=\"n\">null_logger</span><span class=\"p\">):</span>\n\n<span class=\"o\">...</span>\n</pre>\n</div>\n<div id=\"standardizing-logging-in-flask-based-microservices\">\n<h3>Standardizing logging in flask-based microservices</h3>\n<p>The most important objective of reconplogger is to allow standardization of a\nstructured logging format for all microservices developed. Thus, the logging\nfrom all microservices should be configured like explained here. The use is\nanalogous to the previous case, but using the function\n<cite>reconplogger.flask_app_logger_setup</cite> instead, and giving as first argument\nthe flask app object. Additional to the previous case, this function replaces\nthe flask app and werkzeug loggers to use a reconplogger configured one. The usage\nwould be as follows:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">reconplogger</span>\n<span class=\"kn\">from</span> <span class=\"nn\">flask</span> <span class=\"kn\">import</span> <span class=\"n\">Flask</span>\n\n<span class=\"o\">...</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Flask</span><span class=\"p\">(</span><span class=\"vm\">__name__</span><span class=\"p\">)</span>\n\n<span class=\"o\">...</span>\n\n<span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">reconplogger</span><span class=\"o\">.</span><span class=\"n\">flask_app_logger_setup</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"p\">,</span> <span class=\"n\">level</span><span class=\"o\">=</span><span class=\"s1\">'DEBUG'</span><span class=\"p\">)</span>\n\n<span class=\"c1\">## NOTE: do not change logger beyond this point!</span>\n\n<span class=\"o\">...</span>\n\n<span class=\"c1\">## Use logger in code</span>\n<span class=\"n\">myclass</span> <span class=\"o\">=</span> <span class=\"n\">MyClass</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">logger</span><span class=\"o\">=</span><span class=\"n\">logger</span><span class=\"p\">)</span>\n\n<span class=\"o\">...</span>\n</pre>\n<p>An important note is that after configuring the logger, the code should not\nmodify the logger configuration. For example, the logging level should not be\nmodified. Adding an additional handler to the logger is not a problem. This\ncould be desired for example to additionally log to a file.</p>\n<p>In the helm <cite>values.yaml</cite> file of the microservice, the default values for the\nenvironment variables should be set as:</p>\n<pre><span class=\"nt\">LOGGER_CFG</span><span class=\"p\">:</span>\n<span class=\"nt\">LOGGER_NAME</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">json_logger</span>\n<span class=\"nt\">LOGGER_LEVEL</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">DEBUG</span>\n</pre>\n<p>With the <code>json_logger</code> logger, the format of the logs should look\nsomething like the following:</p>\n<pre>{\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"INFO\", \"filename\": \"test_formatter.py\", \"lineno\": 5, \"message\": \"Hello world\"}\n{\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"DEBUG\", \"filename\": \"test_formatter.py\", \"lineno\": 9, \"message\": \"Hello world\"}\n{\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"ERROR\", \"filename\": \"test_formatter.py\", \"lineno\": 13, \"message\": \"Hello world\"}\n{\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"CRITICAL\", \"filename\": \"test_formatter.py\", \"lineno\": 17, \"message\": \"Hello world\"}\n{\"asctime\": \"2018-09-05 17:38:38,137\", \"levelname\": \"ERROR\", \"filename\": \"test_formatter.py\", \"lineno\": 25, \"message\": \"division by zero\"}\n{\"asctime\": \"2018-09-05 17:38:38,138\", \"levelname\": \"ERROR\", \"filename\": \"test_formatter.py\", \"lineno\": 33, \"message\": \"Exception has occured\", \"exc_info\": \"Traceback (most recent call last):\\n  File \\\"reconplogger/tests/test_formatter.py\\\", line 31, in test_exception_with_trace\\n    b = 100 / 0\\nZeroDivisionError: division by zero\"}\n{\"asctime\": \"2018-09-05 17:38:38,138\", \"levelname\": \"INFO\", \"filename\": \"test_formatter.py\", \"lineno\": 37, \"message\": \"Hello world\", \"context check\": \"check\"}\n</pre>\n</div>\n<div id=\"use-of-the-logger-object\">\n<h3>Use of the logger object</h3>\n<p>The logger objects returned by the setup functions are normal python\n<code>logging.Logger</code> objects, so all the standard logging functionalities\nshould be used. Please refer to the <a href=\"https://docs.python.org/3/howto/logging.html\" rel=\"nofollow\">logging package documentation</a> for details.</p>\n<p>A couple of logging features that should be very commonly used are the\nfollowing. To add additional structured information to a log, the <code>extra</code>\nargument should be used. A simple example could be:</p>\n<pre>logger.info('Successfully processed document', extra={'uuid': uuid})\n</pre>\n<p>When an exception occurs the <code>exc_info=True</code> argument should be used, for\nexample:</p>\n<pre>try:\n    ...\nexcept:\n    logger.critical('Failed to run task', exc_info=True)\n</pre>\n</div>\n<div id=\"adding-a-file-handler\">\n<h3>Adding a file handler</h3>\n<p>In some circumstances it is desired to add to a logger a file handler so that\nthe logging messages are also saved to a file. This normally requires at least\nthree lines of code, thus to simplify things reconplogger provides the\n<cite>reconplogger.add_file_handler</cite> function to do the same with a single line\nof code. The use is quite straightforward as:</p>\n<pre>reconplogger.add_file_handler(logger, '/path/to/log/file.log')\n</pre>\n</div>\n<div id=\"overriding-logging-configuration\">\n<h3>Overriding logging configuration</h3>\n<p>An important feature of reconplogger is that the logging configuration of apps\nthat use it can be easily changed via the environment variables. First set the\nenvironment variables with the desired logging configuration and logger name:</p>\n<pre><span class=\"nb\">export</span> <span class=\"nv\">LOGGER_NAME</span><span class=\"o\">=</span><span class=\"s2\">\"example_logger\"</span>\n\n<span class=\"nb\">export</span> <span class=\"nv\">LOGGER_CFG</span><span class=\"o\">=</span><span class=\"s1\">'{\n    \"version\": 1,\n    \"formatters\": {\n        \"verbose\": {\n            \"format\": \"%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s\"\n        }\n    },\n    \"handlers\": {\n        \"console\":{\n            \"level\":\"DEBUG\",\n            \"class\":\"logging.StreamHandler\",\n            \"formatter\": \"verbose\"\n        }\n    },\n    \"loggers\": {\n        \"example_logger\": {\n            \"handlers\": [\"console\"],\n            \"level\": \"ERROR\",\n        }\n    }\n}'</span>\n</pre>\n<p>Then, in the python code the logger would be used as follows:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">reconplogger</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">reconplogger</span><span class=\"o\">.</span><span class=\"n\">logger_setup</span><span class=\"p\">(</span><span class=\"n\">env_prefix</span><span class=\"o\">=</span><span class=\"s1\">'LOGGER'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">error</span><span class=\"p\">(</span><span class=\"s1\">'My error message'</span><span class=\"p\">)</span>\n<span class=\"n\">ERROR</span> <span class=\"mi\">2019</span><span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"o\">-</span><span class=\"mi\">18</span> <span class=\"mi\">14</span><span class=\"p\">:</span><span class=\"mi\">45</span><span class=\"p\">:</span><span class=\"mi\">22</span><span class=\"p\">,</span><span class=\"mi\">629</span> <span class=\"o\">&lt;</span><span class=\"n\">stdin</span><span class=\"o\">&gt;</span> <span class=\"mi\">16876</span> <span class=\"mi\">139918773925696</span> <span class=\"n\">My</span> <span class=\"n\">error</span> <span class=\"n\">message</span>\n</pre>\n</div>\n</div>\n<div id=\"low-level-functions\">\n<h2>Low level functions</h2>\n<div id=\"loading-configuration\">\n<h3>Loading configuration</h3>\n<p>The <cite>reconplogger.load_config</cite> function allows loading of a python logging\nconfiguration. The format config can be either json or yaml. The loading of\nconfiguration can be from a file (giving its path), from an environment variable\n(giving the variable name), a raw configuration string, or loading the default\nconfiguration that comes with reconplogger. See below examples of loading for\neach of the cases:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">reconplogger</span>\n\n<span class=\"c1\">## Load from config file</span>\n<span class=\"n\">reconplogger</span><span class=\"o\">.</span><span class=\"n\">load_config</span><span class=\"p\">(</span><span class=\"s1\">'/path/to/config.yaml'</span><span class=\"p\">)</span>\n\n<span class=\"c1\">## Load from environment variable</span>\n<span class=\"n\">reconplogger</span><span class=\"o\">.</span><span class=\"n\">load_config</span><span class=\"p\">(</span><span class=\"s1\">'LOGGER_CFG'</span><span class=\"p\">)</span>\n\n<span class=\"c1\">## Load default config</span>\n<span class=\"n\">reconplogger</span><span class=\"o\">.</span><span class=\"n\">load_config</span><span class=\"p\">(</span><span class=\"s1\">'reconplogger_default_cfg'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"replacing-logger-handlers\">\n<h3>Replacing logger handlers</h3>\n<p>In some cases it might be needed to replace the handlers of some already\nexisting logger. For this reconplogger provides the\n<cite>reconplogger.replace_logger_handlers</cite> function. To use it, simply provide\nthe logger in which to replace the handlers and the logger from where to get the\nhandlers. The procedure would be as follows:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">reconplogger</span>\n\n<span class=\"n\">logger</span> <span class=\"o\">=</span> <span class=\"n\">reconplogger</span><span class=\"o\">.</span><span class=\"n\">logger_setup</span><span class=\"p\">(</span><span class=\"s1\">'json_logger'</span><span class=\"p\">)</span>\n<span class=\"n\">reconplogger</span><span class=\"o\">.</span><span class=\"n\">replace_logger_handlers</span><span class=\"p\">(</span><span class=\"s1\">'some_logger_name'</span><span class=\"p\">,</span> <span class=\"n\">logger</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"contributing\">\n<h2>Contributing</h2>\n<p>Contributions to this package are very welcome. When you plan to work with the\nsource code, note that this project does not include a <cite>requirements.txt</cite> file.\nThis is by intention. To make it very clear what are the requirements for\ndifferent use cases, all the requirements of the project are stored in the file\n<cite>setup.cfg</cite>. The basic runtime requirements are defined in section\n<code>[options]</code> in the <code>install_requires</code> entry. All optional\nrequirements are stored in section <code>[options.extras_require]</code>. There are\n<code>test</code>, <code>dev</code> and <code>doc</code> extras require to be used by\ndevelopers (e.g. requirements to run the unit tests) and an <code>all</code> extras\nrequire for optional runtime requirements, namely Flask support.</p>\n<p>The recommended way to work with the source code is the following. First clone\nthe repository, then create a virtual environment, activate it and finally\ninstall the development requirements. More precisely the steps would be:</p>\n<pre>git clone https://github.com/omni-us/reconplogger.git\n<span class=\"nb\">cd</span> reconplogger\nvirtualenv -p python3 venv\n. venv/bin/activate\n</pre>\n<p>The crucial step is installing the requirements which would be done by running:</p>\n<pre>pip3 install --editable .<span class=\"o\">[</span>dev,doc,test,all<span class=\"o\">]</span>\n</pre>\n<p>After changing the code, always run unit tests as follows:</p>\n<pre>./setup.py <span class=\"nb\">test</span>\n</pre>\n<div id=\"pull-requests\">\n<h3>Pull requests</h3>\n<ul>\n<li><p>To contribute it is required to create and push to a new branch and issue a\npull request.</p>\n</li>\n<li><p>A pull request will only be accepted if:</p>\n<blockquote>\n<ul>\n<li>All python files pass pylint checks.</li>\n<li>All unit tests run successfully.</li>\n<li>New code has docstrings and gets included in the html documentation.</li>\n</ul>\n</blockquote>\n</li>\n<li><p>When developing, after cloning be sure to run the githook-pre-commit to setup\nthe pre-commit hook. This will help you by automatically running pylint before\nevery commit.</p>\n</li>\n</ul>\n</div>\n<div id=\"using-bump-version\">\n<h3>Using bump version</h3>\n<p>Only the maintainer of this repo should bump versions and this should be done\nonly on the master branch. To bump the version it is required to use the\nbumpversion command that should already be installed if <code>pip3 install\n--editable .[dev,doc,test,all]</code> was run as previously instructed.</p>\n<pre>bumpversion major/minor/patch\n</pre>\n<p>Push the tags to the repository as well.</p>\n<pre>git push<span class=\"p\">;</span> git push --tags\n</pre>\n<p>When the version tags are pushed, circleci will automatically build the wheel\nfile, test it and if successful, push the package to pypi.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6776696, "releases": {"3.0.0": [{"comment_text": "", "digests": {"md5": "768fd5ca5fdb45b27cc58c30dfc4f5cf", "sha256": "6c3af4f677428b802080002c9ebe5cdc0c4458615b455b2d820a889a843d5eca"}, "downloads": -1, "filename": "reconplogger-3.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "768fd5ca5fdb45b27cc58c30dfc4f5cf", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 9863, "upload_time": "2020-01-27T15:40:42", "upload_time_iso_8601": "2020-01-27T15:40:42.229343Z", "url": "https://files.pythonhosted.org/packages/e9/a0/b519b2fa726fcf0e1ea3c2771a3762dca41d7b8d70f0e93b114558aa1438/reconplogger-3.0.0-py3-none-any.whl", "yanked": false}], "3.1.0": [{"comment_text": "", "digests": {"md5": "6b9a6b9f54a9fa80832c6a7cced41215", "sha256": "f72f0ae9730c5f974ae3020aab87b76a68e882fc6ca9ad715ea6838be5a7588b"}, "downloads": -1, "filename": "reconplogger-3.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "6b9a6b9f54a9fa80832c6a7cced41215", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 10191, "upload_time": "2020-01-28T16:05:45", "upload_time_iso_8601": "2020-01-28T16:05:45.146727Z", "url": "https://files.pythonhosted.org/packages/1c/71/b16fa25be95fb5fb01ba8284cb6f91b6af1317135a3ac8c47ed0edb40883/reconplogger-3.1.0-py3-none-any.whl", "yanked": false}], "4.0.0": [{"comment_text": "", "digests": {"md5": "db3ccd8f1d0b1f25a27b090b7bd31d6d", "sha256": "8364b6be98ae9beefc536348149361ce227f6b3955d61016afd0a8bda7fec796"}, "downloads": -1, "filename": "reconplogger-4.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "db3ccd8f1d0b1f25a27b090b7bd31d6d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 10698, "upload_time": "2020-02-18T12:52:27", "upload_time_iso_8601": "2020-02-18T12:52:27.575114Z", "url": "https://files.pythonhosted.org/packages/1c/0e/c1772b8c1d482dc7071644bd71298a000c1ccca1ce034fee6cf0d050482d/reconplogger-4.0.0-py3-none-any.whl", "yanked": false}], "4.1.0": [{"comment_text": "", "digests": {"md5": "7b6dc31e135abea73d52042fad0429f6", "sha256": "3618d64a13cb9ca3696cd49053fa94c7db9f22f1a3121732983e5e21e21328b6"}, "downloads": -1, "filename": "reconplogger-4.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "7b6dc31e135abea73d52042fad0429f6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 10960, "upload_time": "2020-02-25T12:52:01", "upload_time_iso_8601": "2020-02-25T12:52:01.036842Z", "url": "https://files.pythonhosted.org/packages/7d/90/ae9607487ba71ca453a703eae9db6391ddd20e5a637c94e5e35079a64b22/reconplogger-4.1.0-py3-none-any.whl", "yanked": false}], "4.2.0": [{"comment_text": "", "digests": {"md5": "a37c189d71f45e4c6fb104214319b4e7", "sha256": "03e492bb9b78f0df32a306ca9c9a35d3be75928ef77a23ded189778905109b79"}, "downloads": -1, "filename": "reconplogger-4.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "a37c189d71f45e4c6fb104214319b4e7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 11375, "upload_time": "2020-03-09T12:33:29", "upload_time_iso_8601": "2020-03-09T12:33:29.422795Z", "url": "https://files.pythonhosted.org/packages/9c/e8/c841860821eea0010eb01210b8472579fd7fa6d3dc3877a513d0e6230c9e/reconplogger-4.2.0-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a37c189d71f45e4c6fb104214319b4e7", "sha256": "03e492bb9b78f0df32a306ca9c9a35d3be75928ef77a23ded189778905109b79"}, "downloads": -1, "filename": "reconplogger-4.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "a37c189d71f45e4c6fb104214319b4e7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 11375, "upload_time": "2020-03-09T12:33:29", "upload_time_iso_8601": "2020-03-09T12:33:29.422795Z", "url": "https://files.pythonhosted.org/packages/9c/e8/c841860821eea0010eb01210b8472579fd7fa6d3dc3877a513d0e6230c9e/reconplogger-4.2.0-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 03:06:09 2020"}