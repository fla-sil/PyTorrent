{"info": {"author": "Valentin", "author_email": "", "bugtrack_url": null, "classifiers": [], "description": "Taskpacker\n===========\n\n.. image:: https://raw.githubusercontent.com/Edinburgh-Genome-Foundry/Taskpacker/master/docs/_static/images/title.png\n   :alt: [logo]\n   :align: center\n   :width: 600px\n\nTaskpacker is a generic schedule optimization and visualization library for Python.\nFor instance, below is the optimized schedule of 20 batches of 96 DNA assemblies,\nassuming a robotic foundry running 24/7:\n\n.. image:: https://raw.githubusercontent.com/Edinburgh-Genome-Foundry/Taskpacker/master/examples/dna_assembly.png\n :alt: [dna_assembly.png]\n :align: center\n :width: 600px\n\nSuch plots enable you to spot the bottlenecks of your factory. In this example,\nit appears that ovens are the limiting elements (the only machines packed full\nwith no downtime) and that buying a third oven will increase your factory's\nthroughput.\n\nMain features\n--------------\n\nTaskpacker was built as a toy project to have an easily-extensible scheduling tool in Python.\nOnly Python2 is supported right now (sorry for that, there is a complex bug with Numberjack in Python3).\nIt is pretty simple and limited (the core code is ~200 lines) but comes with enough features to cover many cases:\n\n- Supports resources (typically, people or robots) and resource capacity\n  (= how much jobs a resource can do at the same time)\n- Supports tasks dependencies (some tasks must be finished before other tasks\n  can be started) and maximum waiting time (i.e. some tasks must be started at the\n  latest X minutes after their *parents* are completed)\n- Supports pre-scheduled tasks (such as breaks for human operators, scheduled robotic maintenance etc.)\n\nWork in progress - contribute !\n------------------------------------------\n\nTaskpacker is an open-source software originally written to optimize the robot-operated DNA assembly operations at the `Edinburgh Genome Foundry <http://www.genomefoundry.io>`_. It is `released on Github <https://github.com/Edinburgh-Genome-Foundry/plateo>`_\nunder the MIT licence (\u00a2 Edinburgh Genome Foundry), with no warranties: this is\nan experimental piece of software which we hope will be as useful for you as it was for us.\nAnd everyone is welcome to contribute !\n\nInstallation\n--------------\n\nTaskpacker can be installed by unzipping the source code in one directory and using this command: ::\n\n    sudo python setup.py install\n\nYou can also install it directly from the Python Package Index with this command: ::\n\n    sudo pip taskpacker install\n\n\nBasic Example\n--------------\n\nIn this example two labbies have been assigned a list of chores.\nAlice will visit the GMO plants, cook the hamsters, and feed the gremlins.\nBob will clean the scalpels, dice the hamsters once they are cooked, then\nassist Alice in gremlins feeding (a task that takes two people).\nCertain tasks can only be done after other tasks have been completed.\nAlice has a stereotypical predisposition to multitasking: she can do 2 jobs at\nthe same time, while Bob can't.\n\nHere is how you would use Taskpacker to find when they will do each task so as\nto finish as early as possible:\n\n.. code:: python\n\n    from taskpacker import Task, Resource, numberjack_scheduler, plot_schedule\n    alice = Resource(\"Alice\", capacity=2)\n    bob = Resource(\"Bob\", capacity=1)\n\n\n\n    clean_scalpels = Task(\"Clean the scalpels\", resources=[bob], duration=20,\n                          color=\"white\")\n    visit_plants = Task(\"Visit the plants\", resources=[alice], duration=60,\n                         color=\"yellow\")\n    cook_hamsters = Task(\"Cook the hamsters\", resources=[alice], duration=30,\n                         color=\"red\")\n    dice_hamsters = Task(\"Dice the hamsters\", resources=[bob], duration=40,\n                         color=\"blue\", follows=[cook_hamsters, clean_scalpels])\n    feed_gremlins = Task(\"Feed the gremlins\", resources=[alice, bob], duration=50,\n                         color=\"orange\", follows=[dice_hamsters])\n\n\n    all_tasks = [clean_scalpels, visit_plants, cook_hamsters, dice_hamsters,\n                 feed_gremlins]\n    scheduled_tasks = numberjack_scheduler(all_tasks)\n    fig, ax = plot_schedule(scheduled_tasks)\n    ax.figure.set_size_inches(7, 3)\n    ax.figure.savefig(\"alice_and_bod.png\", bbox_inches=\"tight\")\n\n## Modeling tasks and reources with spreadsheets\n\nAssume that you have a process consisting in several tasks, each task depending\non some resources to be available, and possibly on other tasks. Such process can\nbe summarized in a spreadsheet like this one `this file <>`_, which is loaded in\nTaskpacker as follows:\n\n.. code:: python\n\n    from taskpacker import (get_resources_from_spreadsheet,\n                            get_process_from_spreadsheet)\n\n    resources = get_resources_from_spreadsheet(\n        spreadsheet_path=\"path/to/spreadsheet.xls\", sheetname=\"resources\")\n\n    process_tasks = get_process_from_spreadsheet(\n        spreadsheet_path=\"path/to/spreadsheet.xls\",\n        sheetname=\"process\",\n        resources_dict=resources\n    )\n\n\nThen you can for instance plot the dependency graph of the tasks:\n\n.. code:: python\n\n    from taskpacker import plot_tasks_dependency_graph\n    plot_tasks_dependency_graph(process_tasks)\n\n.. image:: https://raw.githubusercontent.com/Edinburgh-Genome-Foundry/Taskpacker/master/docs/_static/images/process_plan.png\n   :alt: [logo]\n   :align: center\n   :width: 600px\n\nOr simply schedule the tasks:\n\n.. code:: python\n\n    from taskpacker import numberjack_scheduler\n    scheduled_tasks = numberjack_scheduler(process_tasks)\n\n\nThroughput estimations\n-----------------------\n\nGiven a list of tasks forming a process, you might ask \"how many of these processes\ncan my factory run in a day ?\". The following code loads 20 of these processes\nand asks Taskpacker to stack them one by one as compactly as possible:\n\n.. code:: python\n\n    from taskpacker import (get_process_from_spreadsheet,\n                            get_resources_from_spreadsheet,\n                            schedule_processes_series,\n                            plot_tasks_dependency_tree,\n                            plot_schedule, Task)\n    import matplotlib.cm as cm\n\n\n    colors = [cm.Paired(0.21 * i % 1.0) for i in range(30)]\n\n    resources = get_resources_from_spreadsheet(\n        spreadsheet_path=\"path/to/spreadsheet.xls\", sheetname=\"resources\")\n\n    processes = [\n        get_process_from_spreadsheet(spreadsheet_path=\"path/to/spreadsheet.xls\",\n                                     sheetname=\"process\",\n                                     resources_dict=resources,\n                                     tasks_color=colors[i],\n                                     task_name_prefix=\"WU%d_\" % (i + 1))\n        for i in range(20)\n    ]\n\n    # OPTIMIZE THE SCHEDULE\n    new_processes = schedule_processes_series(\n        processes, est_process_duration=5000, time_limit=5)\n\n    # PLOT THE OPTIMIZED SCHEDULE\n\n    all_tasks = [t for process in new_processes for t in process]\n    fig, ax = plot_schedule(all_tasks)\n    ax.set_xlabel(\"time (min)\")\n    ax.figure.savefig(\"dna_assembly_schedule.png\", bbox_inches=\"tight\")\n\n.. image:: https://raw.githubusercontent.com/Edinburgh-Genome-Foundry/Taskpacker/master/examples/dna_assembly.png\n :alt: [dna_assembly.png]\n :align: center\n :width: 600px\n\nNote that it is also possible to add scheduled breaks so that your Igor can rest:\n\n.. code:: python\n\n    scheduled_breaks = [\n        Task(\"break_%03d\" % i,\n             resources=[resources[\"igor\"]],\n             scheduled_resource={resources[\"igor\"]: 1},\n             duration=12 * 60, # The break lasts 12H\n             scheduled_start=24 * 60 * i, # The break happens every 24H\n             color='white')\n        for i in range(6)\n    ]\n\n    new_processes = schedule_processes_series(\n        processes, est_process_duration=5000, time_limit=5,\n        scheduled_tasks=scheduled_breaks)\n\n.. image:: https://raw.githubusercontent.com/Edinburgh-Genome-Foundry/Taskpacker/master/examples/dna_assembly_with_breaks.png\n :alt: [dna_assembly_with_breaks.png]\n :align: center\n :width: 600px\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "taskpacker", "package_url": "https://pypi.org/project/taskpacker/", "platform": "", "project_url": "https://pypi.org/project/taskpacker/", "project_urls": null, "release_url": "https://pypi.org/project/taskpacker/0.1.1/", "requires_dist": null, "requires_python": "", "summary": "", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            Taskpacker<br>===========<br><br>.. image:: https://raw.githubusercontent.com/Edinburgh-Genome-Foundry/Taskpacker/master/docs/_static/images/title.png<br>   :alt: [logo]<br>   :align: center<br>   :width: 600px<br><br>Taskpacker is a generic schedule optimization and visualization library for Python.<br>For instance, below is the optimized schedule of 20 batches of 96 DNA assemblies,<br>assuming a robotic foundry running 24/7:<br><br>.. image:: https://raw.githubusercontent.com/Edinburgh-Genome-Foundry/Taskpacker/master/examples/dna_assembly.png<br> :alt: [dna_assembly.png]<br> :align: center<br> :width: 600px<br><br>Such plots enable you to spot the bottlenecks of your factory. In this example,<br>it appears that ovens are the limiting elements (the only machines packed full<br>with no downtime) and that buying a third oven will increase your factory's<br>throughput.<br><br>Main features<br>--------------<br><br>Taskpacker was built as a toy project to have an easily-extensible scheduling tool in Python.<br>Only Python2 is supported right now (sorry for that, there is a complex bug with Numberjack in Python3).<br>It is pretty simple and limited (the core code is ~200 lines) but comes with enough features to cover many cases:<br><br>- Supports resources (typically, people or robots) and resource capacity<br>  (= how much jobs a resource can do at the same time)<br>- Supports tasks dependencies (some tasks must be finished before other tasks<br>  can be started) and maximum waiting time (i.e. some tasks must be started at the<br>  latest X minutes after their *parents* are completed)<br>- Supports pre-scheduled tasks (such as breaks for human operators, scheduled robotic maintenance etc.)<br><br>Work in progress - contribute !<br>------------------------------------------<br><br>Taskpacker is an open-source software originally written to optimize the robot-operated DNA assembly operations at the `Edinburgh Genome Foundry &lt;http://www.genomefoundry.io&gt;`_. It is `released on Github &lt;https://github.com/Edinburgh-Genome-Foundry/plateo&gt;`_<br>under the MIT licence (\u00a2 Edinburgh Genome Foundry), with no warranties: this is<br>an experimental piece of software which we hope will be as useful for you as it was for us.<br>And everyone is welcome to contribute !<br><br>Installation<br>--------------<br><br>Taskpacker can be installed by unzipping the source code in one directory and using this command: ::<br><br>    sudo python setup.py install<br><br>You can also install it directly from the Python Package Index with this command: ::<br><br>    sudo pip taskpacker install<br><br><br>Basic Example<br>--------------<br><br>In this example two labbies have been assigned a list of chores.<br>Alice will visit the GMO plants, cook the hamsters, and feed the gremlins.<br>Bob will clean the scalpels, dice the hamsters once they are cooked, then<br>assist Alice in gremlins feeding (a task that takes two people).<br>Certain tasks can only be done after other tasks have been completed.<br>Alice has a stereotypical predisposition to multitasking: she can do 2 jobs at<br>the same time, while Bob can't.<br><br>Here is how you would use Taskpacker to find when they will do each task so as<br>to finish as early as possible:<br><br>.. code:: python<br><br>    from taskpacker import Task, Resource, numberjack_scheduler, plot_schedule<br>    alice = Resource(\"Alice\", capacity=2)<br>    bob = Resource(\"Bob\", capacity=1)<br><br><br><br>    clean_scalpels = Task(\"Clean the scalpels\", resources=[bob], duration=20,<br>                          color=\"white\")<br>    visit_plants = Task(\"Visit the plants\", resources=[alice], duration=60,<br>                         color=\"yellow\")<br>    cook_hamsters = Task(\"Cook the hamsters\", resources=[alice], duration=30,<br>                         color=\"red\")<br>    dice_hamsters = Task(\"Dice the hamsters\", resources=[bob], duration=40,<br>                         color=\"blue\", follows=[cook_hamsters, clean_scalpels])<br>    feed_gremlins = Task(\"Feed the gremlins\", resources=[alice, bob], duration=50,<br>                         color=\"orange\", follows=[dice_hamsters])<br><br><br>    all_tasks = [clean_scalpels, visit_plants, cook_hamsters, dice_hamsters,<br>                 feed_gremlins]<br>    scheduled_tasks = numberjack_scheduler(all_tasks)<br>    fig, ax = plot_schedule(scheduled_tasks)<br>    ax.figure.set_size_inches(7, 3)<br>    ax.figure.savefig(\"alice_and_bod.png\", bbox_inches=\"tight\")<br><br>## Modeling tasks and reources with spreadsheets<br><br>Assume that you have a process consisting in several tasks, each task depending<br>on some resources to be available, and possibly on other tasks. Such process can<br>be summarized in a spreadsheet like this one `this file &lt;&gt;`_, which is loaded in<br>Taskpacker as follows:<br><br>.. code:: python<br><br>    from taskpacker import (get_resources_from_spreadsheet,<br>                            get_process_from_spreadsheet)<br><br>    resources = get_resources_from_spreadsheet(<br>        spreadsheet_path=\"path/to/spreadsheet.xls\", sheetname=\"resources\")<br><br>    process_tasks = get_process_from_spreadsheet(<br>        spreadsheet_path=\"path/to/spreadsheet.xls\",<br>        sheetname=\"process\",<br>        resources_dict=resources<br>    )<br><br><br>Then you can for instance plot the dependency graph of the tasks:<br><br>.. code:: python<br><br>    from taskpacker import plot_tasks_dependency_graph<br>    plot_tasks_dependency_graph(process_tasks)<br><br>.. image:: https://raw.githubusercontent.com/Edinburgh-Genome-Foundry/Taskpacker/master/docs/_static/images/process_plan.png<br>   :alt: [logo]<br>   :align: center<br>   :width: 600px<br><br>Or simply schedule the tasks:<br><br>.. code:: python<br><br>    from taskpacker import numberjack_scheduler<br>    scheduled_tasks = numberjack_scheduler(process_tasks)<br><br><br>Throughput estimations<br>-----------------------<br><br>Given a list of tasks forming a process, you might ask \"how many of these processes<br>can my factory run in a day ?\". The following code loads 20 of these processes<br>and asks Taskpacker to stack them one by one as compactly as possible:<br><br>.. code:: python<br><br>    from taskpacker import (get_process_from_spreadsheet,<br>                            get_resources_from_spreadsheet,<br>                            schedule_processes_series,<br>                            plot_tasks_dependency_tree,<br>                            plot_schedule, Task)<br>    import matplotlib.cm as cm<br><br><br>    colors = [cm.Paired(0.21 * i % 1.0) for i in range(30)]<br><br>    resources = get_resources_from_spreadsheet(<br>        spreadsheet_path=\"path/to/spreadsheet.xls\", sheetname=\"resources\")<br><br>    processes = [<br>        get_process_from_spreadsheet(spreadsheet_path=\"path/to/spreadsheet.xls\",<br>                                     sheetname=\"process\",<br>                                     resources_dict=resources,<br>                                     tasks_color=colors[i],<br>                                     task_name_prefix=\"WU%d_\" % (i + 1))<br>        for i in range(20)<br>    ]<br><br>    # OPTIMIZE THE SCHEDULE<br>    new_processes = schedule_processes_series(<br>        processes, est_process_duration=5000, time_limit=5)<br><br>    # PLOT THE OPTIMIZED SCHEDULE<br><br>    all_tasks = [t for process in new_processes for t in process]<br>    fig, ax = plot_schedule(all_tasks)<br>    ax.set_xlabel(\"time (min)\")<br>    ax.figure.savefig(\"dna_assembly_schedule.png\", bbox_inches=\"tight\")<br><br>.. image:: https://raw.githubusercontent.com/Edinburgh-Genome-Foundry/Taskpacker/master/examples/dna_assembly.png<br> :alt: [dna_assembly.png]<br> :align: center<br> :width: 600px<br><br>Note that it is also possible to add scheduled breaks so that your Igor can rest:<br><br>.. code:: python<br><br>    scheduled_breaks = [<br>        Task(\"break_%03d\" % i,<br>             resources=[resources[\"igor\"]],<br>             scheduled_resource={resources[\"igor\"]: 1},<br>             duration=12 * 60, # The break lasts 12H<br>             scheduled_start=24 * 60 * i, # The break happens every 24H<br>             color='white')<br>        for i in range(6)<br>    ]<br><br>    new_processes = schedule_processes_series(<br>        processes, est_process_duration=5000, time_limit=5,<br>        scheduled_tasks=scheduled_breaks)<br><br>.. image:: https://raw.githubusercontent.com/Edinburgh-Genome-Foundry/Taskpacker/master/examples/dna_assembly_with_breaks.png<br> :alt: [dna_assembly_with_breaks.png]<br> :align: center<br> :width: 600px<br>\n          </div>"}, "last_serial": 3349688, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "761fa5114f59836cc1fcd53bb452dd3d", "sha256": "481af41c70c56eec2055eccb67f8354d282aed35b3b6b4be4480df77bfeb9905"}, "downloads": -1, "filename": "taskpacker-0.1.0.tar.gz", "has_sig": false, "md5_digest": "761fa5114f59836cc1fcd53bb452dd3d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 191103, "upload_time": "2017-06-01T17:55:03", "upload_time_iso_8601": "2017-06-01T17:55:03.390657Z", "url": "https://files.pythonhosted.org/packages/30/0f/7fbb33edbaaff47d45505856a092baa42b6e2c8771eb77c20819919768c4/taskpacker-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "e5505a15499672155d8ecfe7378bc401", "sha256": "91c679785fa444001ead0fb9b28fc30d2f0cc53c84d54c81f54ec67885369599"}, "downloads": -1, "filename": "taskpacker-0.1.1.tar.gz", "has_sig": false, "md5_digest": "e5505a15499672155d8ecfe7378bc401", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 212032, "upload_time": "2017-11-20T17:01:10", "upload_time_iso_8601": "2017-11-20T17:01:10.476179Z", "url": "https://files.pythonhosted.org/packages/e0/e1/f7bad5f6528322f9d16ea5dc7327192073372fc31e29db5b63e4a7309263/taskpacker-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e5505a15499672155d8ecfe7378bc401", "sha256": "91c679785fa444001ead0fb9b28fc30d2f0cc53c84d54c81f54ec67885369599"}, "downloads": -1, "filename": "taskpacker-0.1.1.tar.gz", "has_sig": false, "md5_digest": "e5505a15499672155d8ecfe7378bc401", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 212032, "upload_time": "2017-11-20T17:01:10", "upload_time_iso_8601": "2017-11-20T17:01:10.476179Z", "url": "https://files.pythonhosted.org/packages/e0/e1/f7bad5f6528322f9d16ea5dc7327192073372fc31e29db5b63e4a7309263/taskpacker-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:57:45 2020"}