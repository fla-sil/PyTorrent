{"info": {"author": "Zope Corporation and Contributors", "author_email": "zope3-dev@zope.org", "bugtrack_url": null, "classifiers": ["Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Programming Language :: Python", "Topic :: Internet :: WWW/HTTP", "Topic :: Software Development :: Testing"], "description": "Overview\n========\n\nThe zc.testbrowser package provides web user agents (browsers) with\nprogrammatic interfaces designed to be used for testing web applications,\nespecially in conjunction with doctests.\n\nThere are currently two type of testbrowser provided.  One for accessing web\nsites via HTTP (zc.testbrowser.browser) and one that controls a Firefox web\nbrowser (zc.testbrowser.real).  All flavors of testbrowser have the same API.\n\nThis project originates in the Zope 3 community, but is not Zope-specific (the\nzc namespace package stands for \"Zope Corporation\").\nChanges\n=======\n\n1.0a5 (2008-05-??)\n------------------\n\n- Bugfix: Fixed setting the value on text area for the real test\n  browser. Thanks to Taylor Sittler for the bug report and fix.\n\n- Bugfix: Fixed handling of named anchor links in mechanize implementation.\n\n- Bugfix: Added test for named anchor links.\n\n- Bugfix: Added tests for the ``click()`` method of item controls.\n\n- Bugfix: Implemented item control's ``click()`` method for the real browser\n  implementation. Also handles disabled controls correctly now.\n\n- Bugfix: Correctly implement ``tb_set_checked()`` Javascript function for all\n  cases of item controls.\n\n- Bugfix: Added <DOCTYPE and <html> node to browser.contents of real.Browser.\n\n- Feature: Improved test handler for HTTP to handle simple forms and multipart\n  forms.\n\n- Feature: Improved test of file upload element; now the passed in file contents\n  will be submitted and the submission is tested.\n\n- Feature: Correctly implemented the ``add_file()`` method of the control\n  object for the real testbrowser implementation.\n\n- Feature: Support for Firefox 3 and Mozlab 0.1.9. Testbrowser does not work\n  with Mozlab 0.1.8 anymore due to API changes.\n\n\n1.0a4 (2008-03-06)\n------------------\n\n- Bugfix: Fix some packaging bugs.\n\n\n1.0a3 (2008-03-06)\n------------------\n\n- Restructure: Break out some interfaces so the various Browser\n  implementations can tell fewer lies.\n\n- Restructure: Make waiting for asynchronous events (like page loads) explicit.\n\n\n1.0a2 (2008-02-15)\n------------------\n\n- Bugfix: removed pdb invocation on javascript error\n\n- Bugfix: text content types where wrapped in html tags in ``testbrowser.real``\n\n- Bugfix: ``getLink()`` did not wait until page is loaded in\n  ``testbrowser.real``\n\n\n1.0a1 (2007-09-28)\n------------------\n\n- First release under new name (non Zope-specific code extracted from\n  zope.testbrowser)\n.. contents::\n\n\nDetailed Documentation\n======================\n\nBefore being of much interest, we need to open a web page.  ``Browser``\ninstances have a ``base`` attribute that sets the URL from which ``open``-ed\nURLs are relative.  This lets you target tests at servers running in various,\nor even variable locations (like using randomly chosen ports).\n\n    >>> browser = Browser()\n    >>> browser.base = 'http://localhost:%s/' % TEST_PORT\n\n    >>> browser.open('index.html')\n    >>> browser.url\n    'http://localhost:.../index.html'\n\nOnce you have opened a web page initially, best practice for writing\ntestbrowser doctests suggests using `click` to navigate further (as discussed\nbelow), except in unusual circumstances.\n\nThe test browser complies with the IBrowser interface; see\n``zc.testbrowser.interfaces`` for full details on the interface.\n\n    >>> import zc.testbrowser.interfaces\n    >>> from zope.interface.verify import verifyObject\n    >>> zc.testbrowser.interfaces.IBrowser.providedBy(browser)\n    True\n    >>> verifyObject(zc.testbrowser.interfaces.IBrowser, browser)\n    True\n\n\nPage Contents\n-------------\n\nThe contents of the current page are available:\n\n    >>> browser.contents\n    '...<h1>Simple Page</h1>...'\n\nNote: Unfortunately, ellipsis (...) cannot be used at the beginning of the\noutput (this is a limitation of doctest).\n\nMaking assertions about page contents is easy.\n\n    >>> '<h1>Simple Page</h1>' in browser.contents\n    True\n\n\nThe doctype and <html> node are also part of the contents:\n\n    >>> browser.open('doctype.html')\n    >>> print browser.contents\n    <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n    <html>\n    <head>...\n\n\nChecking for HTML\n-----------------\n\nNot all URLs return HTML.  Of course our simple page does:\n\n    >>> browser.isHtml\n    True\n\nBut if we load an image (or other binary file), we do not get HTML:\n\n    >>> browser.open('zope3logo.gif')\n    >>> browser.isHtml\n    False\n\nText types are also handled.\n\n    >>> browser.open('test.txt')\n    >>> browser.isHtml\n    False\n    >>> print browser.contents\n    Some text\n    >>> browser.open('test.css')\n    >>> browser.isHtml\n    False\n    >>> print browser.contents\n    * {\n        margin: 0;\n        padding: 0;\n    }\n\n\n\nHTML Page Title\n----------------\n\nAnother useful helper property is the title:\n\n    >>> browser.open('index.html')\n    >>> browser.title\n    'Simple Page'\n\nIf a page does not provide a title, it is simply ``None``:\n\n    >>> browser.open('notitle.html')\n    >>> browser.title\n\nHowever, if the output is not HTML, then an error will occur trying to access\nthe title:\n\n    >>> browser.open('zope3logo.gif')\n    >>> browser.title\n    Traceback (most recent call last):\n    ...\n    BrowserStateError: not viewing HTML\n\n\nNavigation and Link Objects\n---------------------------\n\nIf you want to simulate clicking on a link, get the link and call its `click`\nmethod.  In the `navigate.html` file there are several links set up to\ndemonstrate the capabilities of the link objects and their `click` method.\n\nThe simplest way to get a link is via the anchor text.  In other words\nthe text you would see in a browser:\n\n    >>> browser.open('navigate.html')\n    >>> browser.contents\n    '...<a href=\"target.html\">Link Text</a>...'\n    >>> link = browser.getLink('Link Text')\n    >>> link\n    <Link text='Link Text' url='http://localhost:.../target.html'>\n\nLink objects comply with the `ILink` interface.\n\n    >>> verifyObject(zc.testbrowser.interfaces.ILink, link)\n    True\n\nLinks expose several attributes for easy access.\n\n    >>> link.text\n    'Link Text'\n\nLinks can be \"clicked\" and the browser will navigate to the referenced URL.\n\n    >>> link.click()\n    >>> browser.wait()\n    >>> browser.url\n    'http://localhost:.../target.html'\n    >>> browser.contents\n    '...This page is the target of a link...'\n\nNote that whenever you click on a link that causes a page to be reloaded, you\nneed to wait for the browser to finish loading the page. You do this by\ncalling the `wait()` method of the browser. When you click on a link that\nsimply brings you to a named anchor, `wait()` should not be called, since the\npage is not reloaded and the result is immediate:\n\n    >>> browser.open('navigate.html')\n    >>> link = browser.getLink('Link to Named Target')\n    >>> link\n    <Link text='Link to Named Target'\n          url='http://localhost:.../navigate.html#target'>\n    >>> link.click()\n    >>> link.url\n    'http://localhost:.../navigate.html#target'\n\nWhen finding a link by its text, whitespace is normalized.\n\n    >>> browser.open('navigate.html')\n    >>> browser.contents\n    '...> Link Text \\n    with     Whitespace\\tNormalization (and parens) </...'\n    >>> link = browser.getLink('Link Text with Whitespace Normalization '\n    ...                        '(and parens)')\n    >>> link\n    <Link text='Link Text with Whitespace Normalization (and parens)'...>\n    >>> link.text\n    'Link Text with Whitespace Normalization (and parens)'\n    >>> link.click()\n    >>> browser.wait()\n    >>> browser.url\n    'http://localhost:.../target.html'\n\nWhen a link text matches more than one link, by default the first one is\nchosen. You can, however, specify the index of the link and thus retrieve a\nlater matching link:\n\n    >>> browser.open('navigate.html')\n    >>> browser.getLink('Link Text')\n    <Link text='Link Text' ...>\n\n    >>> browser.getLink('Link Text', index=1)\n    <Link text='Link Text with Whitespace Normalization (and parens)' ...>\n\nNote that clicking a link object after its browser page has expired will\ngenerate an error.\n\n    >>> link.click()\n    Traceback (most recent call last):\n    ...\n    ExpiredError\n\nYou can also find links by URL,\n\n    >>> browser.open('navigate.html')\n    >>> browser.getLink(url='target.html').click()\n    >>> browser.wait()\n    >>> browser.url\n    'http://localhost:.../target.html'\n\nor its id:\n\n    >>> browser.open('navigate.html')\n    >>> browser.contents\n    '...<a href=\"target.html\" id=\"anchorid\">By Anchor Id</a>...'\n\n    >>> browser.getLink(id='anchorid').click()\n    >>> browser.wait()\n    >>> browser.url\n    'http://localhost:.../target.html'\n\nYou thought we were done here? Not so quickly.  The `getLink` method also\nsupports image maps, though not by specifying the coordinates, but using the\narea's id:\n\n    >>> browser.open('navigate.html')\n    >>> link = browser.getLink(id='zope3')\n    >>> link.click()\n    >>> browser.wait()\n    >>> browser.url\n    'http://localhost:.../target.html'\n\nGetting a nonexistent link raises an exception.\n\n    >>> browser.open('navigate.html')\n    >>> browser.getLink('This does not exist')\n    Traceback (most recent call last):\n    ...\n    LinkNotFoundError\n\n\nOther Navigation\n----------------\n\nLike in any normal browser, you can reload a page:\n\n    >>> browser.open('index.html')\n    >>> browser.url\n    'http://localhost:.../index.html'\n    >>> browser.reload()\n    >>> browser.url\n    'http://localhost:.../index.html'\n\nYou can also go back:\n\n    >>> browser.open('notitle.html')\n    >>> browser.url\n    'http://localhost:.../notitle.html'\n    >>> browser.goBack()\n    >>> browser.url\n    'http://localhost:.../index.html'\n\n\nControls\n--------\n\nOne of the most important features of the browser is the ability to inspect\nand fill in values for the controls of input forms.  To do so, let's first open\na page that has a bunch of controls:\n\n    >>> browser.open('controls.html')\n\nObtaining a Control\n~~~~~~~~~~~~~~~~~~~\n\nYou look up browser controls with the `getControl` method.  The default first\nargument is `label`, and looks up the form on the basis of any associated\nlabel.\n\n    >>> control = browser.getControl('Text Control')\n    >>> control\n    <Control name='text-value' type='text'>\n    >>> browser.getControl(label='Text Control') # equivalent\n    <Control name='text-value' type='text'>\n\nIf you request a control that doesn't exist, the code raises a `LookupError`:\n\n    >>> browser.getControl('Does Not Exist')\n    Traceback (most recent call last):\n    ...\n    LookupError: label 'Does Not Exist'\n\nIf you request a control with an ambiguous lookup, the code raises an\n`AmbiguityError`.\n\n    >>> browser.getControl('Ambiguous Control')\n    Traceback (most recent call last):\n    ...\n    AmbiguityError: label 'Ambiguous Control'\n\nThis is also true if an option in a control is ambiguous in relation to\nthe control itself.\n\n    >>> browser.getControl('Sub-control Ambiguity')\n    Traceback (most recent call last):\n    ...\n    AmbiguityError: label 'Sub-control Ambiguity'\n\nAmbiguous controls may be specified using an index value.  We use the control's\nvalue attribute to show the two controls; this attribute is properly introduced\nbelow.\n\n    >>> browser.getControl('Ambiguous Control', index=0)\n    <Control name='ambiguous-control-name' type='text'>\n    >>> browser.getControl('Ambiguous Control', index=0).value\n    'First'\n    >>> browser.getControl('Ambiguous Control', index=1).value\n    'Second'\n    >>> browser.getControl('Sub-control Ambiguity', index=0)\n    <ListControl name='ambiguous-subcontrol' type='select'>\n    >>> browser.getControl('Sub-control Ambiguity', index=1).optionValue\n    'ambiguous'\n\nLabel searches are against stripped, whitespace-normalized, no-tag versions of\nthe text. Text applied to searches is also stripped and whitespace normalized.\nThe search finds results if the text search finds the whole words of your\ntext in a label.  Thus, for instance, a search for `Add` will match the label\n`Add a Client` but not `Address`.  Case is honored.\n\n    >>> browser.getControl('Label Needs Whitespace Normalization')\n    <Control name='label-needs-normalization' type='text'>\n    >>> browser.getControl('label needs whitespace normalization')\n    Traceback (most recent call last):\n    ...\n    LookupError: label 'label needs whitespace normalization'\n    >>> browser.getControl(' Label  Needs Whitespace    ')\n    <Control name='label-needs-normalization' type='text'>\n    >>> browser.getControl('Whitespace')\n    <Control name='label-needs-normalization' type='text'>\n    >>> browser.getControl('hitespace')\n    Traceback (most recent call last):\n    ...\n    LookupError: label 'hitespace'\n    >>> browser.getControl('[non word characters should not confuse]')\n    <Control name='non-word-characters' type='text'>\n\nMultiple labels can refer to the same control (simply because that is possible\nin the HTML 4.0 spec).\n\n    >>> browser.getControl('Multiple labels really')\n    <Control name='two-labels' type='text'>\n\n    >>> browser.getControl('really are possible')\n    <Control name='two-labels' type='text'>\n\n    >>> # OK: ambiguous labels, but not ambiguous control\n    >>> browser.getControl('really')\n    <Control name='two-labels' type='text'>\n\nA label can be connected with a control using the `for` attribute and also by\ncontaining a control.\n\n    >>> browser.getControl(\n    ...     'Labels can be connected by containing their respective fields')\n    <Control name='contained-in-label' type='text'>\n\nGet also accepts one other search argument, `name`.  Only one of `label` and\n`name` may be used at a time.  The 'name' keyword searches form field names.\n\n    >>> browser.getControl(name='text-value')\n    <Control name='text-value' type='text'>\n    >>> browser.getControl(name='ambiguous-control-name')\n    Traceback (most recent call last):\n    ...\n    AmbiguityError: name 'ambiguous-control-name'\n    >>> browser.getControl(name='does-not-exist')\n    Traceback (most recent call last):\n    ...\n    LookupError: name 'does-not-exist'\n    >>> browser.getControl(name='ambiguous-control-name', index=1).value\n    'Second'\n\nCombining 'label' and 'name' raises a ValueError, as does supplying neither of\nthem.\n\n    >>> browser.getControl(\n    ...     label='Ambiguous Control', name='ambiguous-control-name')\n    Traceback (most recent call last):\n    ...\n    ValueError: Supply one and only one of \"label\" and \"name\" as arguments\n    >>> browser.getControl()\n    Traceback (most recent call last):\n    ...\n    ValueError: Supply one and only one of \"label\" and \"name\" as arguments\n\nRadio and checkbox fields are unusual in that their labels and names may point\nto different objects: names point to logical collections of radio buttons or\ncheckboxes, but labels may only be used for individual choices within the\nlogical collection.  This means that obtaining a radio button by label gets a\ndifferent object than obtaining the radio collection by name.  Select options\nmay also be searched by label.\n\n    >>> browser.getControl(name='radio-value')\n    <ListControl name='radio-value' type='radio'>\n    >>> browser.getControl('Zwei')\n    <ItemControl name='radio-value' type='radio' optionValue='2' selected=True>\n    >>> browser.getControl('One')\n    <ItemControl name='multi-checkbox-value' type='checkbox'\n                 optionValue='1' selected=True>\n    >>> browser.getControl('Tres')\n    <ItemControl name='single-select-value' type='select'\n                 optionValue='3' selected=False>\n\nCharacteristics of controls and subcontrols are discussed below.\n\nControl Objects\n~~~~~~~~~~~~~~~\n\nControls provide IControl.\n\n    >>> ctrl = browser.getControl('Text Control')\n    >>> ctrl\n    <Control name='text-value' type='text'>\n    >>> verifyObject(zc.testbrowser.interfaces.IControl, ctrl)\n    True\n\nThey have several useful attributes:\n\n  - the name as which the control is known to the form:\n\n    >>> ctrl.name\n    'text-value'\n\n  - the value of the control, which may also be set:\n\n    >>> ctrl.value\n    'Some Text'\n    >>> ctrl.value = 'More Text'\n    >>> ctrl.value\n    'More Text'\n\n  - the type of the control:\n\n    >>> ctrl.type\n    'text'\n\n  - a flag describing whether the control is disabled:\n\n    >>> ctrl.disabled\n    False\n\n  - and a flag to tell us whether the control can have multiple values:\n\n    >>> ctrl.multiple\n    False\n\nAdditionally, controllers for select, radio, and checkbox provide\n`IListControl`.  These fields have four other attributes and an additional\nmethod:\n\n    >>> ctrl = browser.getControl('Multiple Select Control')\n\n    >>> ctrl\n    <ListControl name='multi-select-value' type='select'>\n    >>> ctrl.disabled\n    False\n\n    >>> ctrl.multiple\n    True\n\n    >>> verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)\n    True\n\n  - 'options' lists all available value options.\n\n    >>> [unicode(o) for o in ctrl.options]\n    [u'1', u'2', u'3']\n\n  - 'displayOptions' lists all available options by label.  The 'label'\n    attribute on an option has precedence over its contents, which is why\n    our last option is 'Third' in the display.\n\n    >>> ctrl.displayOptions\n    ['Un', 'Deux', 'Third']\n\n  - 'displayValue' lets you get and set the displayed values of the control\n    of the select box, rather than the actual values.\n\n    >>> ctrl.value\n    []\n    >>> ctrl.displayValue\n    []\n    >>> ctrl.displayValue = ['Un', 'Deux']\n    >>> ctrl.displayValue\n    ['Un', 'Deux']\n    >>> [unicode(v) for v in ctrl.value]\n    [u'1', u'2']\n\n  - 'controls' gives you a list of the subcontrol objects in the control\n    (subcontrols are discussed below).\n\n    >>> ctrl.controls\n    [<ItemControl name='multi-select-value' type='select'\n                  optionValue='1' selected=True>,\n     <ItemControl name='multi-select-value' type='select'\n                  optionValue='2' selected=True>,\n     <ItemControl name='multi-select-value' type='select'\n                  optionValue='3' selected=False>]\n\n  - The `getControl()` method lets you get subcontrols by their label or their\n    value.\n\n    >>> ctrl.getControl('Un')\n    <ItemControl name='multi-select-value' type='select'\n                 optionValue='1' selected=True>\n    >>> ctrl.getControl('Deux')\n    <ItemControl name='multi-select-value' type='select'\n                 optionValue='2' selected=True>\n    >>> ctrl.getControl('Trois') # label attribute\n    <ItemControl name='multi-select-value' type='select'\n                 optionValue='3' selected=False>\n    >>> ctrl.getControl('Third') # contents\n    <ItemControl name='multi-select-value' type='select'\n                 optionValue='3' selected=False>\n    >>> browser.getControl('Third') # ambiguous in the browser, so useful\n    Traceback (most recent call last):\n    ...\n    AmbiguityError: label 'Third'\n\nFinally, submit controls provide `ISubmitControl`, and image controls provide\n`IImageSubmitControl`, which extents `ISubmitControl`.  These both simply add a\n`click()` method.  For image submit controls, you may also provide a coordinates\nargument, which is a tuple of (x, y).  These submit the forms, and are\ndemonstrated below as we examine each control individually.\n\nItemControl Objects\n~~~~~~~~~~~~~~~~~~~\n\nAs introduced briefly above, using labels to obtain elements of a logical\nradio button or checkbox collection returns item controls, which are parents.\nManipulating the value of these controls affects the parent control.\n\n    >>> [unicode(v) for v in browser.getControl(name='radio-value').value]\n    [u'2']\n    >>> browser.getControl('Zwei').optionValue # read-only.\n    '2'\n    >>> browser.getControl('Zwei').selected\n    True\n\n    >>> verifyObject(zc.testbrowser.interfaces.IItemControl,\n    ...     browser.getControl('Zwei'))\n    True\n    >>> browser.getControl('Ein').selected\n    False\n    >>> browser.getControl('Ein').selected = True\n    >>> browser.getControl('Ein').selected\n    True\n\nOf course at this point the previously selected \"Zwei\" will be unselected\nsince only one radio button can be selected.\n\n    >>> browser.getControl('Zwei').selected\n    False\n\n    >>> browser.getControl('Zwei').selected\n    False\n    >>> [unicode(v) for v in browser.getControl(name='radio-value').value]\n    [u'1']\n\nThis test is not valid because it is impossible (with the browser) to\nunselect a radio box ... one radio box (must always remain selected).  This\nused to be a test for mechanize and used to pass because mechanize didn't\nrealize.  And by running the level 3 tests we are running these tests\nunder both mechanize and the \"real\" browser testing.\n::\n\n    browser.getControl('Ein').selected = False\n    browser.getControl('Ein').selected\n    False\n\n    browser.getControl(name='radio-value').value\n    []\n\n    >>> browser.getControl('Zwei').selected = True\n\nCheckbox collections behave similarly, as shown below.\n\nControls with subcontrols--\n\nVarious Controls\n~~~~~~~~~~~~~~~~\n\nThe various types of controls are demonstrated here.\n\n  - Text Control\n\n    The text control we already introduced above.\n\n  - Password Control\n\n    >>> ctrl = browser.getControl('Password Control')\n    >>> ctrl\n    <Control name='password-value' type='password'>\n    >>> verifyObject(zc.testbrowser.interfaces.IControl, ctrl)\n    True\n    >>> ctrl.value\n    'Password'\n    >>> ctrl.value = 'pass now'\n    >>> ctrl.value\n    'pass now'\n    >>> ctrl.disabled\n    False\n    >>> ctrl.multiple\n    False\n\n  - Hidden Control\n\n    >>> ctrl = browser.getControl(name='hidden-value')\n    >>> ctrl\n    <Control name='hidden-value' type='hidden'>\n    >>> verifyObject(zc.testbrowser.interfaces.IControl, ctrl)\n    True\n    >>> ctrl.value\n    'Hidden'\n    >>> ctrl.value = 'More Hidden'\n    >>> ctrl.disabled\n    False\n    >>> ctrl.multiple\n    False\n\n  - Text Area Control\n\n    >>> ctrl = browser.getControl('Text Area Control')\n    >>> ctrl\n    <Control name='textarea-value' type='textarea'>\n    >>> verifyObject(zc.testbrowser.interfaces.IControl, ctrl)\n    True\n    >>> ctrl.value\n    '        Text inside\\n        area!\\n      '\n    >>> ctrl.value = 'A lot of\\n text.'\n    >>> ctrl.value\n    'A lot of\\n text.'\n    >>> ctrl.disabled\n    False\n    >>> ctrl.multiple\n    False\n\n  - File Control\n\n    File controls are used when a form has a file-upload field.\n    To specify data, call the add_file method, passing:\n\n    - A file-like object\n\n    - a content type, and\n\n    - a file name\n\n    >>> ctrl = browser.getControl('File Control')\n    >>> ctrl\n    <Control name='file-value' type='file'>\n    >>> verifyObject(zc.testbrowser.interfaces.IControl, ctrl)\n    True\n    >>> ctrl.value is None\n    True\n    >>> import cStringIO\n\n    >>> ctrl.add_file(cStringIO.StringIO('File contents'),\n    ...               'text/plain', 'test.txt')\n\n    The file control (like the other controls) also knows if it is disabled\n    or if it can have multiple values.\n\n    >>> ctrl.disabled\n    False\n    >>> ctrl.multiple\n    False\n\n  - Selection Control (Single-Valued)\n\n    >>> ctrl = browser.getControl('Single Select Control')\n    >>> ctrl\n    <ListControl name='single-select-value' type='select'>\n    >>> verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)\n    True\n    >>> [unicode(v) for v in ctrl.value]\n    [u'1']\n    >>> ctrl.value = ['2']\n    >>> ctrl.disabled\n    False\n    >>> ctrl.multiple\n    False\n    >>> [unicode(o) for o in ctrl.options]\n    [u'1', u'2', u'3']\n    >>> ctrl.displayOptions\n    ['Uno', 'Dos', 'Third']\n    >>> ctrl.displayValue\n    ['Dos']\n    >>> ctrl.displayValue = ['Tres']\n    >>> ctrl.displayValue\n    ['Third']\n    >>> ctrl.displayValue = ['Dos']\n    >>> ctrl.displayValue\n    ['Dos']\n    >>> ctrl.displayValue = ['Third']\n    >>> ctrl.displayValue\n    ['Third']\n    >>> [unicode(v) for v in ctrl.value]\n    [u'3']\n\n    >>> ctrl.getControl('Dos')\n    <ItemControl name='single-select-value' type='select'\n                 optionValue='2' selected=False>\n\n    >>> ctrl.getControl('Dos').click()\n    >>> ctrl.getControl('Dos')\n    <ItemControl name='single-select-value' type='select'\n                 optionValue='2' selected=True>\n\n    >>> ctrl.getControl('Tres').click()\n    >>> ctrl.getControl('Dos')\n    <ItemControl name='single-select-value' type='select'\n                 optionValue='2' selected=False>\n    >>> ctrl.getControl('Tres')\n    <ItemControl name='single-select-value' type='select'\n                 optionValue='3' selected=True>\n\n    >>> ctrl.getControl('Tres').click()\n    >>> ctrl.getControl('Tres')\n    <ItemControl name='single-select-value' type='select'\n                 optionValue='3' selected=False>\n\n  - Selection Control (Multi-Valued)\n\n    >>> ctrl = browser.getControl('Multiple Select Control')\n    >>> ctrl\n    <ListControl name='multi-select-value' type='select'>\n    >>> verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)\n    True\n\n    >>> [unicode(v) for v in ctrl.value]\n    [u'1', u'2']\n\n    >>> ctrl.value = ['1', '3']\n    >>> [unicode(v) for v in ctrl.displayValue]\n    [u'Un', u'Third']\n\n    >>> ctrl.value = []\n\n    >>> ctrl.getControl('Deux').click()\n    >>> ctrl.getControl('Deux')\n    <ItemControl name='multi-select-value' type='select'\n                 optionValue='2' selected=True>\n\n    >>> ctrl.getControl('Trois').click()\n    >>> ctrl.getControl('Deux')\n    <ItemControl name='multi-select-value' type='select'\n                 optionValue='2' selected=True>\n    >>> ctrl.getControl('Trois')\n    <ItemControl name='multi-select-value' type='select'\n                 optionValue='3' selected=True>\n\n    >>> ctrl.getControl('Trois').click()\n    >>> ctrl.getControl('Trois')\n    <ItemControl name='multi-select-value' type='select'\n                 optionValue='3' selected=False>\n\n  - Checkbox Control (Single-Valued; Unvalued)\n\n    >>> ctrl = browser.getControl(name='single-unvalued-checkbox-value')\n    >>> ctrl\n    <ListControl name='single-unvalued-checkbox-value' type='checkbox'>\n    >>> verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)\n    True\n    >>> ctrl.value\n    True\n    >>> ctrl.value = False\n    >>> ctrl.disabled\n    False\n    >>> ctrl.multiple\n    True\n    >>> ctrl.options\n    [True]\n    >>> ctrl.displayOptions\n    ['Single Unvalued Checkbox']\n    >>> ctrl.displayValue\n    []\n    >>> verifyObject(\n    ...     zc.testbrowser.interfaces.IItemControl,\n    ...     browser.getControl('Single Unvalued Checkbox'))\n    True\n    >>> browser.getControl('Single Unvalued Checkbox').optionValue\n    'on'\n    >>> browser.getControl('Single Unvalued Checkbox').selected\n    False\n    >>> ctrl.displayValue = ['Single Unvalued Checkbox']\n    >>> ctrl.displayValue\n    ['Single Unvalued Checkbox']\n\n    >>> subctrl = ctrl.getControl('Single Unvalued Checkbox')\n    >>> subctrl.selected\n    True\n    >>> subctrl.selected = False\n    >>> subctrl.selected\n    False\n    >>> ctrl.displayValue\n    []\n\n    >>> subctrl.click()\n    >>> subctrl.selected\n    True\n    >>> subctrl.click()\n    >>> subctrl.selected\n    False\n\n    >>> disabledCtrl = browser.getControl(\n    ...     name='single-disabled-unvalued-checkbox-value')\n    >>> disabledCtrl\n    <ListControl name='single-disabled-unvalued-checkbox-value' type='checkbox'>\n    >>> disabledCtrl.disabled\n    True\n    >>> disabledCtrl.getControl('Single Disabled Unvalued Checkbox').click()\n    Traceback (most recent call last):\n    ...\n    AttributeError: item is disabled\n\n  - Checkbox Control (Single-Valued, Valued)\n\n    >>> ctrl = browser.getControl(name='single-valued-checkbox-value')\n    >>> ctrl\n    <ListControl name='single-valued-checkbox-value' type='checkbox'>\n    >>> verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)\n    True\n    >>> [unicode(v) for v in ctrl.value]\n    [u'1']\n    >>> ctrl.value = []\n    >>> ctrl.disabled\n    False\n    >>> ctrl.multiple\n    True\n    >>> [unicode(o) for o in ctrl.options]\n    [u'1']\n    >>> ctrl.displayOptions\n    ['Single Valued Checkbox']\n    >>> ctrl.displayValue\n    []\n    >>> verifyObject(\n    ...     zc.testbrowser.interfaces.IItemControl,\n    ...     browser.getControl('Single Valued Checkbox'))\n    True\n    >>> browser.getControl('Single Valued Checkbox').selected\n    False\n    >>> browser.getControl('Single Valued Checkbox').optionValue\n    '1'\n    >>> ctrl.displayValue = ['Single Valued Checkbox']\n    >>> ctrl.displayValue\n    ['Single Valued Checkbox']\n    >>> browser.getControl('Single Valued Checkbox').selected\n    True\n    >>> browser.getControl('Single Valued Checkbox').selected = False\n    >>> browser.getControl('Single Valued Checkbox').selected\n    False\n    >>> ctrl.displayValue\n    []\n\n    >>> subctrl = ctrl.getControl('Single Valued Checkbox')\n    >>> subctrl.selected\n    False\n\n    >>> subctrl.click()\n    >>> subctrl.selected\n    True\n    >>> subctrl.click()\n    >>> subctrl.selected\n    False\n\n  - Checkbox Control (Multi-Valued)\n\n    >>> ctrl = browser.getControl(name='multi-checkbox-value')\n    >>> ctrl\n    <ListControl name='multi-checkbox-value' type='checkbox'>\n    >>> verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)\n    True\n    >>> [unicode(v) for v in ctrl.value]\n    [u'1', u'3']\n    >>> ctrl.value = ['1', '2']\n    >>> ctrl.disabled\n    False\n    >>> ctrl.multiple\n    True\n    >>> [unicode(o) for o in ctrl.options]\n    [u'1', u'2', u'3']\n    >>> ctrl.displayOptions\n    ['One', 'Two', 'Three']\n    >>> ctrl.displayValue\n    ['One', 'Two']\n    >>> ctrl.displayValue = ['Two']\n    >>> [unicode(v) for v in ctrl.value]\n    [u'2']\n    >>> browser.getControl('Two').optionValue\n    '2'\n    >>> browser.getControl('Two').selected\n    True\n    >>> verifyObject(zc.testbrowser.interfaces.IItemControl,\n    ...     browser.getControl('Two'))\n    True\n    >>> browser.getControl('Three').selected = True\n    >>> browser.getControl('Three').selected\n    True\n    >>> browser.getControl('Two').selected\n    True\n    >>> [unicode(v) for v in ctrl.value]\n    [u'2', u'3']\n    >>> browser.getControl('Two').selected = False\n    >>> [unicode(v) for v in ctrl.value]\n    [u'3']\n    >>> browser.getControl('Three').selected = False\n    >>> ctrl.value\n    []\n\n    >>> subctrl3 = browser.getControl('Three')\n    >>> subctrl3.selected\n    False\n\n    >>> subctrl3.click()\n    >>> subctrl3.selected\n    True\n    >>> subctrl3.click()\n    >>> subctrl3.selected\n    False\n\n    >>> browser.getControl('Two').click()\n    >>> browser.getControl('Three').click()\n\n    >>> browser.getControl('Two').selected\n    True\n    >>> browser.getControl('Three').selected\n    True\n\n  - Radio Control\n\n    This is how you get a radio button based control:\n\n    >>> ctrl = browser.getControl(name='radio-value')\n\n    This shows the existing value of the control, as it was in the\n    HTML received from the server:\n\n    >>> [unicode(v) for v in ctrl.value]\n    [u'2']\n\n    We can then unselect it:\n\n    >>> ctrl.value = []\n    >>> ctrl.value\n    []\n\n    We can also reselect it:\n\n    >>> ctrl.value = ['2']\n    >>> [unicode(v) for v in ctrl.value]\n    [u'2']\n\n    displayValue shows the text the user would see next to the\n    control:\n\n    >>> ctrl.displayValue\n    ['Zwei']\n\n    This is just unit testing:\n\n    >>> ctrl\n    <ListControl name='radio-value' type='radio'>\n    >>> verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)\n    True\n    >>> ctrl.disabled\n    False\n    >>> ctrl.multiple\n    False\n    >>> [unicode(o) for o in ctrl.options]\n    [u'1', u'2', u'3']\n    >>> ctrl.displayOptions\n    ['Ein', 'Zwei', 'Drei']\n    >>> ctrl.displayValue = ['Ein']\n    >>> [unicode(v) for v in ctrl.value]\n    [u'1']\n    >>> ctrl.displayValue\n    ['Ein']\n\n    The radio control subcontrols were illustrated above.\n\n    >>> subctrl = browser.getControl('Ein')\n    >>> subctrl.selected\n    True\n\n    >>> subctrl2 = browser.getControl('Zwei')\n    >>> subctrl2.selected\n    False\n\n    >>> subctrl2.click()\n    >>> subctrl2.selected\n    True\n    >>> subctrl.selected\n    False\n\n\n  - Image Control\n\n    >>> ctrl = browser.getControl(name='image-value')\n    >>> ctrl\n    <ImageControl name='image-value' type='image'>\n    >>> verifyObject(zc.testbrowser.interfaces.IImageSubmitControl, ctrl)\n    True\n    >>> ctrl.value\n    ''\n    >>> ctrl.disabled\n    False\n    >>> ctrl.multiple\n    False\n\n  - Submit Control\n\n    >>> ctrl = browser.getControl(name='submit-value')\n    >>> ctrl\n    <SubmitControl name='submit-value' type='submit'>\n\n    >>> browser.getControl('Submit This') # value of submit button is a label\n    <SubmitControl name='submit-value' type='submit'>\n    >>> browser.getControl('Standard Submit Control') # label tag is legal\n    <SubmitControl name='submit-value' type='submit'>\n\n    >>> browser.getControl('Submit') # multiple labels, but same control\n    <SubmitControl name='submit-value' type='submit'>\n    >>> verifyObject(zc.testbrowser.interfaces.ISubmitControl, ctrl)\n    True\n    >>> ctrl.value\n    'Submit This'\n    >>> ctrl.disabled\n    False\n    >>> ctrl.multiple\n    False\n\nUsing Submitting Controls\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBoth the submit and image type should be clickable and submit the form:\n\n    >>> browser.getControl('Text Control').value = 'Other Text'\n    >>> browser.getControl('Submit').click()\n    >>> browser.wait()\n    >>> browser.contents\n    \"...'text-value': ['Other Text']...\"\n\nNote that if you click a submit object after the associated page has expired,\nyou will get an error.\n\n    >>> browser.open('controls.html')\n    >>> ctrl = browser.getControl('Submit')\n    >>> ctrl.click()\n    >>> ctrl.click()\n    Traceback (most recent call last):\n    ...\n    ExpiredError\n\nAll the above also holds true for the image control:\n\n    >>> browser.open('controls.html')\n    >>> browser.getControl('Text Control').value = 'Other Text'\n    >>> browser.getControl(name='image-value').click()\n    >>> browser.wait()\n    >>> browser.contents\n    \"...'text-value': ['Other Text']...\"\n\n    >>> browser.open('controls.html')\n    >>> ctrl = browser.getControl(name='image-value')\n    >>> ctrl.click()\n    >>> ctrl.click()\n    Traceback (most recent call last):\n    ...\n    ExpiredError\n\nBut when sending an image, you can also specify the coordinate you clicked:\n\n#    >>> browser.open('controls.html')\n#    >>> browser.getControl(name='image-value').click((50,25))\n#    >>> browser.contents\n#    \"...'image-value.x': ['50']...'image-value.y': ['25']...\"\n\nAnother interesting aspect of submitting a form is the correct submission of\nthe file data.\n\n    >>> browser.open('controls.html')\n    >>> ctrl = browser.getControl('File Control')\n    >>> import cStringIO\n    >>> ctrl.add_file(cStringIO.StringIO('File contents'),\n    ...               'text/plain', 'test.txt')\n    >>> browser.getControl('Submit This').click()\n    >>> browser.wait()\n    >>> browser.contents\n    \"...'file-value': ['File contents'],...\"\n\nForms\n-----\n\nBecause pages can have multiple forms with like-named controls, it is sometimes\nnecessary to access forms by name or id.  The browser's `forms` attribute can\nbe used to do so.  The key value is the form's name or id.  If more than one\nform has the same name or id, the first one will be returned.\n\n    >>> browser.open('forms.html')\n    >>> form = browser.getForm(name='one')\n\nForm instances conform to the IForm interface.\n\n    >>> verifyObject(zc.testbrowser.interfaces.IForm, form)\n    True\n\nThe form exposes several attributes related to forms:\n\n  - The name of the form:\n\n    >>> unicode(form.name)\n    u'one'\n\n  - The id of the form:\n\n    >>> unicode(form.id)\n    u'1'\n\n  - The action (target URL) when the form is submitted:\n\n    >>> unicode(form.action)\n    u'http://localhost:.../forms.html'\n\n  - The method (HTTP verb) used to transmit the form data:\n\n    >>> unicode(form.method)\n    u'POST'\n\n  - The encoding type of the form data:\n\n    >>> unicode(form.enctype)\n    u'application/x-www-form-urlencoded'\n\nBesides those attributes, you have also a couple of methods.  Like for the\nbrowser, you can get control objects, but limited to the current form...\n\n    >>> form.getControl(name='text-value')\n    <Control name='text-value' type='text'>\n\n...and submit the form.\n\n    >>> form.submit('Submit')\n    >>> browser.contents\n    \"...'text-value': ['First Text']...\"\n\nSubmitting also works without specifying a control, as shown below, which is\nit's primary reason for existing in competition with the control submission\ndiscussed above.\n\nNow let me show you briefly that looking up forms is sometimes important.  In\nthe `forms.html` template, we have four forms all having a text control named\n`text-value`.  Now, if I use the browser's `get` method,\n\n    >>> browser.open('forms.html')\n    >>> browser.getControl(name='text-value')\n    Traceback (most recent call last):\n    ...\n    AmbiguityError: name 'text-value'\n    >>> browser.getControl('Text Control')\n    Traceback (most recent call last):\n    ...\n    AmbiguityError: label 'Text Control'\n\nI'll always get an ambiguous form field.  I can use the index argument, or\nwith the `getForm` method I can disambiguate by searching only within a given\nform:\n\n    >>> form = browser.getForm('2')\n    >>> form.getControl(name='text-value').value\n    'Second Text'\n    >>> form.submit('Submit')\n    >>> browser.contents\n    \"...'text-value': ['Second Text']...\"\n    >>> browser.open('forms.html')\n    >>> form = browser.getForm('2')\n    >>> form.getControl('Submit').click()\n    >>> browser.wait()\n    >>> browser.contents\n    \"...'text-value': ['Second Text']...\"\n    >>> browser.open('forms.html')\n    >>> browser.getForm('3').getControl('Text Control').value\n    'Third Text'\n\nThe last form on the page does not have a name, an id, or a submit button.\nWorking with it is still easy, thanks to a index attribute that guarantees\norder.  (Forms without submit buttons are sometimes useful for JavaScript.)\n\n    >>> form = browser.getForm(index=3)\n    >>> form.submit()\n    >>> browser.contents\n    \"...'text-value': ['Fourth Text']...\"\n\nIf a form is requested that does not exists, an exception will be raised.\n\n    >>> browser.open('forms.html')\n    >>> form = browser.getForm('does-not-exist')\n    Traceback (most recent call last):\n    LookupError\n\nIf the HTML page contains only one form, no arguments to `getForm` are\nneeded:\n\n    >>> browser.open('oneform.html')\n    >>> browser.getForm()\n    <zc.testbrowser...Form object at ...>\n\nIf the HTML page contains more than one form, `index` is needed to\ndisambiguate if no other arguments are provided:\n\n    >>> browser.open('forms.html')\n    >>> browser.getForm()\n    Traceback (most recent call last):\n    ValueError: if no other arguments are given, index is required.\n\n\nHand-Holding\n------------\n\nInstances of the various objects ensure that users don't set incorrect\ninstance attributes accidentally.\n\n    >>> browser.nonexistant = None\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'Browser' object has no attribute 'nonexistant'\n\n    >>> form.nonexistant = None\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'Form' object has no attribute 'nonexistant'\n\n    >>> control.nonexistant = None\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'Control' object has no attribute 'nonexistant'\n\n    >>> link.nonexistant = None\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'Link' object has no attribute 'nonexistant'\n\n\nFixed Bugs\n----------\n\nThis section includes tests for bugs that were found and then fixed that don't\nfit into the more documentation-centric sections above.\n\nSpaces in URL\n~~~~~~~~~~~~~\n\nWhen URLs have spaces in them, they're handled correctly (before the bug was\nfixed, you'd get \"ValueError: too many values to unpack\"):\n\n    >>> browser.open('navigate.html')\n    >>> browser.getLink('Spaces in the URL').click()\n    >>> browser.wait()\n\n.goBack() Truncation\n~~~~~~~~~~~~~~~~~~~~\n\nThe .goBack() method used to truncate the .contents.\n\n    >>> browser.open('navigate.html')\n    >>> actual_length = len(browser.contents)\n\n    >>> browser.open('navigate.html')\n    >>> browser.open('index.html')\n    >>> browser.goBack()\n    >>> len(browser.contents) == actual_length\n    True\n\n\nAuthors\n-------\n\nBenji York created testbrowser (originally zope.testbrowser) in 2005 with Gary\nPoster and Stephan Richter making large contributions.\n\nThe zc.testbrowser.real version was conceptualized by Benji York in 2007 and\nafter an initial implementation sketch, brought to fruition by Stephan\nRichter, Rocky Burt, Justas Sadzevicius, and others at the Foliage Zope 3\nsprint in Boston, MA during the week of September 24, 2007.\n\nThere have been many other contributions from users of testbrowser that are\ngreatly appreciated.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/zc.testbrowser", "keywords": null, "license": "ZPL 2.1", "maintainer": null, "maintainer_email": null, "name": "zc.testbrowser", "package_url": "https://pypi.org/project/zc.testbrowser/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/zc.testbrowser/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/zc.testbrowser"}, "release_url": "https://pypi.org/project/zc.testbrowser/1.0.0a5/", "requires_dist": null, "requires_python": null, "summary": "Programmable web browser for functional black-box testing of web applications", "version": "1.0.0a5", "yanked": false, "html_description": "<div class=\"project-description\">\n            Overview<br>========<br><br>The zc.testbrowser package provides web user agents (browsers) with<br>programmatic interfaces designed to be used for testing web applications,<br>especially in conjunction with doctests.<br><br>There are currently two type of testbrowser provided.  One for accessing web<br>sites via HTTP (zc.testbrowser.browser) and one that controls a Firefox web<br>browser (zc.testbrowser.real).  All flavors of testbrowser have the same API.<br><br>This project originates in the Zope 3 community, but is not Zope-specific (the<br>zc namespace package stands for \"Zope Corporation\").<br>Changes<br>=======<br><br>1.0a5 (2008-05-??)<br>------------------<br><br>- Bugfix: Fixed setting the value on text area for the real test<br>  browser. Thanks to Taylor Sittler for the bug report and fix.<br><br>- Bugfix: Fixed handling of named anchor links in mechanize implementation.<br><br>- Bugfix: Added test for named anchor links.<br><br>- Bugfix: Added tests for the ``click()`` method of item controls.<br><br>- Bugfix: Implemented item control's ``click()`` method for the real browser<br>  implementation. Also handles disabled controls correctly now.<br><br>- Bugfix: Correctly implement ``tb_set_checked()`` Javascript function for all<br>  cases of item controls.<br><br>- Bugfix: Added &lt;DOCTYPE and &lt;html&gt; node to browser.contents of real.Browser.<br><br>- Feature: Improved test handler for HTTP to handle simple forms and multipart<br>  forms.<br><br>- Feature: Improved test of file upload element; now the passed in file contents<br>  will be submitted and the submission is tested.<br><br>- Feature: Correctly implemented the ``add_file()`` method of the control<br>  object for the real testbrowser implementation.<br><br>- Feature: Support for Firefox 3 and Mozlab 0.1.9. Testbrowser does not work<br>  with Mozlab 0.1.8 anymore due to API changes.<br><br><br>1.0a4 (2008-03-06)<br>------------------<br><br>- Bugfix: Fix some packaging bugs.<br><br><br>1.0a3 (2008-03-06)<br>------------------<br><br>- Restructure: Break out some interfaces so the various Browser<br>  implementations can tell fewer lies.<br><br>- Restructure: Make waiting for asynchronous events (like page loads) explicit.<br><br><br>1.0a2 (2008-02-15)<br>------------------<br><br>- Bugfix: removed pdb invocation on javascript error<br><br>- Bugfix: text content types where wrapped in html tags in ``testbrowser.real``<br><br>- Bugfix: ``getLink()`` did not wait until page is loaded in<br>  ``testbrowser.real``<br><br><br>1.0a1 (2007-09-28)<br>------------------<br><br>- First release under new name (non Zope-specific code extracted from<br>  zope.testbrowser)<br>.. contents::<br><br><br>Detailed Documentation<br>======================<br><br>Before being of much interest, we need to open a web page.  ``Browser``<br>instances have a ``base`` attribute that sets the URL from which ``open``-ed<br>URLs are relative.  This lets you target tests at servers running in various,<br>or even variable locations (like using randomly chosen ports).<br><br>    &gt;&gt;&gt; browser = Browser()<br>    &gt;&gt;&gt; browser.base = 'http://localhost:%s/' % TEST_PORT<br><br>    &gt;&gt;&gt; browser.open('index.html')<br>    &gt;&gt;&gt; browser.url<br>    'http://localhost:.../index.html'<br><br>Once you have opened a web page initially, best practice for writing<br>testbrowser doctests suggests using `click` to navigate further (as discussed<br>below), except in unusual circumstances.<br><br>The test browser complies with the IBrowser interface; see<br>``zc.testbrowser.interfaces`` for full details on the interface.<br><br>    &gt;&gt;&gt; import zc.testbrowser.interfaces<br>    &gt;&gt;&gt; from zope.interface.verify import verifyObject<br>    &gt;&gt;&gt; zc.testbrowser.interfaces.IBrowser.providedBy(browser)<br>    True<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IBrowser, browser)<br>    True<br><br><br>Page Contents<br>-------------<br><br>The contents of the current page are available:<br><br>    &gt;&gt;&gt; browser.contents<br>    '...&lt;h1&gt;Simple Page&lt;/h1&gt;...'<br><br>Note: Unfortunately, ellipsis (...) cannot be used at the beginning of the<br>output (this is a limitation of doctest).<br><br>Making assertions about page contents is easy.<br><br>    &gt;&gt;&gt; '&lt;h1&gt;Simple Page&lt;/h1&gt;' in browser.contents<br>    True<br><br><br>The doctype and &lt;html&gt; node are also part of the contents:<br><br>    &gt;&gt;&gt; browser.open('doctype.html')<br>    &gt;&gt;&gt; print browser.contents<br>    &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;<br>    &lt;html&gt;<br>    &lt;head&gt;...<br><br><br>Checking for HTML<br>-----------------<br><br>Not all URLs return HTML.  Of course our simple page does:<br><br>    &gt;&gt;&gt; browser.isHtml<br>    True<br><br>But if we load an image (or other binary file), we do not get HTML:<br><br>    &gt;&gt;&gt; browser.open('zope3logo.gif')<br>    &gt;&gt;&gt; browser.isHtml<br>    False<br><br>Text types are also handled.<br><br>    &gt;&gt;&gt; browser.open('test.txt')<br>    &gt;&gt;&gt; browser.isHtml<br>    False<br>    &gt;&gt;&gt; print browser.contents<br>    Some text<br>    &gt;&gt;&gt; browser.open('test.css')<br>    &gt;&gt;&gt; browser.isHtml<br>    False<br>    &gt;&gt;&gt; print browser.contents<br>    * {<br>        margin: 0;<br>        padding: 0;<br>    }<br><br><br><br>HTML Page Title<br>----------------<br><br>Another useful helper property is the title:<br><br>    &gt;&gt;&gt; browser.open('index.html')<br>    &gt;&gt;&gt; browser.title<br>    'Simple Page'<br><br>If a page does not provide a title, it is simply ``None``:<br><br>    &gt;&gt;&gt; browser.open('notitle.html')<br>    &gt;&gt;&gt; browser.title<br><br>However, if the output is not HTML, then an error will occur trying to access<br>the title:<br><br>    &gt;&gt;&gt; browser.open('zope3logo.gif')<br>    &gt;&gt;&gt; browser.title<br>    Traceback (most recent call last):<br>    ...<br>    BrowserStateError: not viewing HTML<br><br><br>Navigation and Link Objects<br>---------------------------<br><br>If you want to simulate clicking on a link, get the link and call its `click`<br>method.  In the `navigate.html` file there are several links set up to<br>demonstrate the capabilities of the link objects and their `click` method.<br><br>The simplest way to get a link is via the anchor text.  In other words<br>the text you would see in a browser:<br><br>    &gt;&gt;&gt; browser.open('navigate.html')<br>    &gt;&gt;&gt; browser.contents<br>    '...&lt;a href=\"target.html\"&gt;Link Text&lt;/a&gt;...'<br>    &gt;&gt;&gt; link = browser.getLink('Link Text')<br>    &gt;&gt;&gt; link<br>    &lt;Link text='Link Text' url='http://localhost:.../target.html'&gt;<br><br>Link objects comply with the `ILink` interface.<br><br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.ILink, link)<br>    True<br><br>Links expose several attributes for easy access.<br><br>    &gt;&gt;&gt; link.text<br>    'Link Text'<br><br>Links can be \"clicked\" and the browser will navigate to the referenced URL.<br><br>    &gt;&gt;&gt; link.click()<br>    &gt;&gt;&gt; browser.wait()<br>    &gt;&gt;&gt; browser.url<br>    'http://localhost:.../target.html'<br>    &gt;&gt;&gt; browser.contents<br>    '...This page is the target of a link...'<br><br>Note that whenever you click on a link that causes a page to be reloaded, you<br>need to wait for the browser to finish loading the page. You do this by<br>calling the `wait()` method of the browser. When you click on a link that<br>simply brings you to a named anchor, `wait()` should not be called, since the<br>page is not reloaded and the result is immediate:<br><br>    &gt;&gt;&gt; browser.open('navigate.html')<br>    &gt;&gt;&gt; link = browser.getLink('Link to Named Target')<br>    &gt;&gt;&gt; link<br>    &lt;Link text='Link to Named Target'<br>          url='http://localhost:.../navigate.html#target'&gt;<br>    &gt;&gt;&gt; link.click()<br>    &gt;&gt;&gt; link.url<br>    'http://localhost:.../navigate.html#target'<br><br>When finding a link by its text, whitespace is normalized.<br><br>    &gt;&gt;&gt; browser.open('navigate.html')<br>    &gt;&gt;&gt; browser.contents<br>    '...&gt; Link Text \\n    with     Whitespace\\tNormalization (and parens) &lt;/...'<br>    &gt;&gt;&gt; link = browser.getLink('Link Text with Whitespace Normalization '<br>    ...                        '(and parens)')<br>    &gt;&gt;&gt; link<br>    &lt;Link text='Link Text with Whitespace Normalization (and parens)'...&gt;<br>    &gt;&gt;&gt; link.text<br>    'Link Text with Whitespace Normalization (and parens)'<br>    &gt;&gt;&gt; link.click()<br>    &gt;&gt;&gt; browser.wait()<br>    &gt;&gt;&gt; browser.url<br>    'http://localhost:.../target.html'<br><br>When a link text matches more than one link, by default the first one is<br>chosen. You can, however, specify the index of the link and thus retrieve a<br>later matching link:<br><br>    &gt;&gt;&gt; browser.open('navigate.html')<br>    &gt;&gt;&gt; browser.getLink('Link Text')<br>    &lt;Link text='Link Text' ...&gt;<br><br>    &gt;&gt;&gt; browser.getLink('Link Text', index=1)<br>    &lt;Link text='Link Text with Whitespace Normalization (and parens)' ...&gt;<br><br>Note that clicking a link object after its browser page has expired will<br>generate an error.<br><br>    &gt;&gt;&gt; link.click()<br>    Traceback (most recent call last):<br>    ...<br>    ExpiredError<br><br>You can also find links by URL,<br><br>    &gt;&gt;&gt; browser.open('navigate.html')<br>    &gt;&gt;&gt; browser.getLink(url='target.html').click()<br>    &gt;&gt;&gt; browser.wait()<br>    &gt;&gt;&gt; browser.url<br>    'http://localhost:.../target.html'<br><br>or its id:<br><br>    &gt;&gt;&gt; browser.open('navigate.html')<br>    &gt;&gt;&gt; browser.contents<br>    '...&lt;a href=\"target.html\" id=\"anchorid\"&gt;By Anchor Id&lt;/a&gt;...'<br><br>    &gt;&gt;&gt; browser.getLink(id='anchorid').click()<br>    &gt;&gt;&gt; browser.wait()<br>    &gt;&gt;&gt; browser.url<br>    'http://localhost:.../target.html'<br><br>You thought we were done here? Not so quickly.  The `getLink` method also<br>supports image maps, though not by specifying the coordinates, but using the<br>area's id:<br><br>    &gt;&gt;&gt; browser.open('navigate.html')<br>    &gt;&gt;&gt; link = browser.getLink(id='zope3')<br>    &gt;&gt;&gt; link.click()<br>    &gt;&gt;&gt; browser.wait()<br>    &gt;&gt;&gt; browser.url<br>    'http://localhost:.../target.html'<br><br>Getting a nonexistent link raises an exception.<br><br>    &gt;&gt;&gt; browser.open('navigate.html')<br>    &gt;&gt;&gt; browser.getLink('This does not exist')<br>    Traceback (most recent call last):<br>    ...<br>    LinkNotFoundError<br><br><br>Other Navigation<br>----------------<br><br>Like in any normal browser, you can reload a page:<br><br>    &gt;&gt;&gt; browser.open('index.html')<br>    &gt;&gt;&gt; browser.url<br>    'http://localhost:.../index.html'<br>    &gt;&gt;&gt; browser.reload()<br>    &gt;&gt;&gt; browser.url<br>    'http://localhost:.../index.html'<br><br>You can also go back:<br><br>    &gt;&gt;&gt; browser.open('notitle.html')<br>    &gt;&gt;&gt; browser.url<br>    'http://localhost:.../notitle.html'<br>    &gt;&gt;&gt; browser.goBack()<br>    &gt;&gt;&gt; browser.url<br>    'http://localhost:.../index.html'<br><br><br>Controls<br>--------<br><br>One of the most important features of the browser is the ability to inspect<br>and fill in values for the controls of input forms.  To do so, let's first open<br>a page that has a bunch of controls:<br><br>    &gt;&gt;&gt; browser.open('controls.html')<br><br>Obtaining a Control<br>~~~~~~~~~~~~~~~~~~~<br><br>You look up browser controls with the `getControl` method.  The default first<br>argument is `label`, and looks up the form on the basis of any associated<br>label.<br><br>    &gt;&gt;&gt; control = browser.getControl('Text Control')<br>    &gt;&gt;&gt; control<br>    &lt;Control name='text-value' type='text'&gt;<br>    &gt;&gt;&gt; browser.getControl(label='Text Control') # equivalent<br>    &lt;Control name='text-value' type='text'&gt;<br><br>If you request a control that doesn't exist, the code raises a `LookupError`:<br><br>    &gt;&gt;&gt; browser.getControl('Does Not Exist')<br>    Traceback (most recent call last):<br>    ...<br>    LookupError: label 'Does Not Exist'<br><br>If you request a control with an ambiguous lookup, the code raises an<br>`AmbiguityError`.<br><br>    &gt;&gt;&gt; browser.getControl('Ambiguous Control')<br>    Traceback (most recent call last):<br>    ...<br>    AmbiguityError: label 'Ambiguous Control'<br><br>This is also true if an option in a control is ambiguous in relation to<br>the control itself.<br><br>    &gt;&gt;&gt; browser.getControl('Sub-control Ambiguity')<br>    Traceback (most recent call last):<br>    ...<br>    AmbiguityError: label 'Sub-control Ambiguity'<br><br>Ambiguous controls may be specified using an index value.  We use the control's<br>value attribute to show the two controls; this attribute is properly introduced<br>below.<br><br>    &gt;&gt;&gt; browser.getControl('Ambiguous Control', index=0)<br>    &lt;Control name='ambiguous-control-name' type='text'&gt;<br>    &gt;&gt;&gt; browser.getControl('Ambiguous Control', index=0).value<br>    'First'<br>    &gt;&gt;&gt; browser.getControl('Ambiguous Control', index=1).value<br>    'Second'<br>    &gt;&gt;&gt; browser.getControl('Sub-control Ambiguity', index=0)<br>    &lt;ListControl name='ambiguous-subcontrol' type='select'&gt;<br>    &gt;&gt;&gt; browser.getControl('Sub-control Ambiguity', index=1).optionValue<br>    'ambiguous'<br><br>Label searches are against stripped, whitespace-normalized, no-tag versions of<br>the text. Text applied to searches is also stripped and whitespace normalized.<br>The search finds results if the text search finds the whole words of your<br>text in a label.  Thus, for instance, a search for `Add` will match the label<br>`Add a Client` but not `Address`.  Case is honored.<br><br>    &gt;&gt;&gt; browser.getControl('Label Needs Whitespace Normalization')<br>    &lt;Control name='label-needs-normalization' type='text'&gt;<br>    &gt;&gt;&gt; browser.getControl('label needs whitespace normalization')<br>    Traceback (most recent call last):<br>    ...<br>    LookupError: label 'label needs whitespace normalization'<br>    &gt;&gt;&gt; browser.getControl(' Label  Needs Whitespace    ')<br>    &lt;Control name='label-needs-normalization' type='text'&gt;<br>    &gt;&gt;&gt; browser.getControl('Whitespace')<br>    &lt;Control name='label-needs-normalization' type='text'&gt;<br>    &gt;&gt;&gt; browser.getControl('hitespace')<br>    Traceback (most recent call last):<br>    ...<br>    LookupError: label 'hitespace'<br>    &gt;&gt;&gt; browser.getControl('[non word characters should not confuse]')<br>    &lt;Control name='non-word-characters' type='text'&gt;<br><br>Multiple labels can refer to the same control (simply because that is possible<br>in the HTML 4.0 spec).<br><br>    &gt;&gt;&gt; browser.getControl('Multiple labels really')<br>    &lt;Control name='two-labels' type='text'&gt;<br><br>    &gt;&gt;&gt; browser.getControl('really are possible')<br>    &lt;Control name='two-labels' type='text'&gt;<br><br>    &gt;&gt;&gt; # OK: ambiguous labels, but not ambiguous control<br>    &gt;&gt;&gt; browser.getControl('really')<br>    &lt;Control name='two-labels' type='text'&gt;<br><br>A label can be connected with a control using the `for` attribute and also by<br>containing a control.<br><br>    &gt;&gt;&gt; browser.getControl(<br>    ...     'Labels can be connected by containing their respective fields')<br>    &lt;Control name='contained-in-label' type='text'&gt;<br><br>Get also accepts one other search argument, `name`.  Only one of `label` and<br>`name` may be used at a time.  The 'name' keyword searches form field names.<br><br>    &gt;&gt;&gt; browser.getControl(name='text-value')<br>    &lt;Control name='text-value' type='text'&gt;<br>    &gt;&gt;&gt; browser.getControl(name='ambiguous-control-name')<br>    Traceback (most recent call last):<br>    ...<br>    AmbiguityError: name 'ambiguous-control-name'<br>    &gt;&gt;&gt; browser.getControl(name='does-not-exist')<br>    Traceback (most recent call last):<br>    ...<br>    LookupError: name 'does-not-exist'<br>    &gt;&gt;&gt; browser.getControl(name='ambiguous-control-name', index=1).value<br>    'Second'<br><br>Combining 'label' and 'name' raises a ValueError, as does supplying neither of<br>them.<br><br>    &gt;&gt;&gt; browser.getControl(<br>    ...     label='Ambiguous Control', name='ambiguous-control-name')<br>    Traceback (most recent call last):<br>    ...<br>    ValueError: Supply one and only one of \"label\" and \"name\" as arguments<br>    &gt;&gt;&gt; browser.getControl()<br>    Traceback (most recent call last):<br>    ...<br>    ValueError: Supply one and only one of \"label\" and \"name\" as arguments<br><br>Radio and checkbox fields are unusual in that their labels and names may point<br>to different objects: names point to logical collections of radio buttons or<br>checkboxes, but labels may only be used for individual choices within the<br>logical collection.  This means that obtaining a radio button by label gets a<br>different object than obtaining the radio collection by name.  Select options<br>may also be searched by label.<br><br>    &gt;&gt;&gt; browser.getControl(name='radio-value')<br>    &lt;ListControl name='radio-value' type='radio'&gt;<br>    &gt;&gt;&gt; browser.getControl('Zwei')<br>    &lt;ItemControl name='radio-value' type='radio' optionValue='2' selected=True&gt;<br>    &gt;&gt;&gt; browser.getControl('One')<br>    &lt;ItemControl name='multi-checkbox-value' type='checkbox'<br>                 optionValue='1' selected=True&gt;<br>    &gt;&gt;&gt; browser.getControl('Tres')<br>    &lt;ItemControl name='single-select-value' type='select'<br>                 optionValue='3' selected=False&gt;<br><br>Characteristics of controls and subcontrols are discussed below.<br><br>Control Objects<br>~~~~~~~~~~~~~~~<br><br>Controls provide IControl.<br><br>    &gt;&gt;&gt; ctrl = browser.getControl('Text Control')<br>    &gt;&gt;&gt; ctrl<br>    &lt;Control name='text-value' type='text'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IControl, ctrl)<br>    True<br><br>They have several useful attributes:<br><br>  - the name as which the control is known to the form:<br><br>    &gt;&gt;&gt; ctrl.name<br>    'text-value'<br><br>  - the value of the control, which may also be set:<br><br>    &gt;&gt;&gt; ctrl.value<br>    'Some Text'<br>    &gt;&gt;&gt; ctrl.value = 'More Text'<br>    &gt;&gt;&gt; ctrl.value<br>    'More Text'<br><br>  - the type of the control:<br><br>    &gt;&gt;&gt; ctrl.type<br>    'text'<br><br>  - a flag describing whether the control is disabled:<br><br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br><br>  - and a flag to tell us whether the control can have multiple values:<br><br>    &gt;&gt;&gt; ctrl.multiple<br>    False<br><br>Additionally, controllers for select, radio, and checkbox provide<br>`IListControl`.  These fields have four other attributes and an additional<br>method:<br><br>    &gt;&gt;&gt; ctrl = browser.getControl('Multiple Select Control')<br><br>    &gt;&gt;&gt; ctrl<br>    &lt;ListControl name='multi-select-value' type='select'&gt;<br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br><br>    &gt;&gt;&gt; ctrl.multiple<br>    True<br><br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)<br>    True<br><br>  - 'options' lists all available value options.<br><br>    &gt;&gt;&gt; [unicode(o) for o in ctrl.options]<br>    [u'1', u'2', u'3']<br><br>  - 'displayOptions' lists all available options by label.  The 'label'<br>    attribute on an option has precedence over its contents, which is why<br>    our last option is 'Third' in the display.<br><br>    &gt;&gt;&gt; ctrl.displayOptions<br>    ['Un', 'Deux', 'Third']<br><br>  - 'displayValue' lets you get and set the displayed values of the control<br>    of the select box, rather than the actual values.<br><br>    &gt;&gt;&gt; ctrl.value<br>    []<br>    &gt;&gt;&gt; ctrl.displayValue<br>    []<br>    &gt;&gt;&gt; ctrl.displayValue = ['Un', 'Deux']<br>    &gt;&gt;&gt; ctrl.displayValue<br>    ['Un', 'Deux']<br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.value]<br>    [u'1', u'2']<br><br>  - 'controls' gives you a list of the subcontrol objects in the control<br>    (subcontrols are discussed below).<br><br>    &gt;&gt;&gt; ctrl.controls<br>    [&lt;ItemControl name='multi-select-value' type='select'<br>                  optionValue='1' selected=True&gt;,<br>     &lt;ItemControl name='multi-select-value' type='select'<br>                  optionValue='2' selected=True&gt;,<br>     &lt;ItemControl name='multi-select-value' type='select'<br>                  optionValue='3' selected=False&gt;]<br><br>  - The `getControl()` method lets you get subcontrols by their label or their<br>    value.<br><br>    &gt;&gt;&gt; ctrl.getControl('Un')<br>    &lt;ItemControl name='multi-select-value' type='select'<br>                 optionValue='1' selected=True&gt;<br>    &gt;&gt;&gt; ctrl.getControl('Deux')<br>    &lt;ItemControl name='multi-select-value' type='select'<br>                 optionValue='2' selected=True&gt;<br>    &gt;&gt;&gt; ctrl.getControl('Trois') # label attribute<br>    &lt;ItemControl name='multi-select-value' type='select'<br>                 optionValue='3' selected=False&gt;<br>    &gt;&gt;&gt; ctrl.getControl('Third') # contents<br>    &lt;ItemControl name='multi-select-value' type='select'<br>                 optionValue='3' selected=False&gt;<br>    &gt;&gt;&gt; browser.getControl('Third') # ambiguous in the browser, so useful<br>    Traceback (most recent call last):<br>    ...<br>    AmbiguityError: label 'Third'<br><br>Finally, submit controls provide `ISubmitControl`, and image controls provide<br>`IImageSubmitControl`, which extents `ISubmitControl`.  These both simply add a<br>`click()` method.  For image submit controls, you may also provide a coordinates<br>argument, which is a tuple of (x, y).  These submit the forms, and are<br>demonstrated below as we examine each control individually.<br><br>ItemControl Objects<br>~~~~~~~~~~~~~~~~~~~<br><br>As introduced briefly above, using labels to obtain elements of a logical<br>radio button or checkbox collection returns item controls, which are parents.<br>Manipulating the value of these controls affects the parent control.<br><br>    &gt;&gt;&gt; [unicode(v) for v in browser.getControl(name='radio-value').value]<br>    [u'2']<br>    &gt;&gt;&gt; browser.getControl('Zwei').optionValue # read-only.<br>    '2'<br>    &gt;&gt;&gt; browser.getControl('Zwei').selected<br>    True<br><br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IItemControl,<br>    ...     browser.getControl('Zwei'))<br>    True<br>    &gt;&gt;&gt; browser.getControl('Ein').selected<br>    False<br>    &gt;&gt;&gt; browser.getControl('Ein').selected = True<br>    &gt;&gt;&gt; browser.getControl('Ein').selected<br>    True<br><br>Of course at this point the previously selected \"Zwei\" will be unselected<br>since only one radio button can be selected.<br><br>    &gt;&gt;&gt; browser.getControl('Zwei').selected<br>    False<br><br>    &gt;&gt;&gt; browser.getControl('Zwei').selected<br>    False<br>    &gt;&gt;&gt; [unicode(v) for v in browser.getControl(name='radio-value').value]<br>    [u'1']<br><br>This test is not valid because it is impossible (with the browser) to<br>unselect a radio box ... one radio box (must always remain selected).  This<br>used to be a test for mechanize and used to pass because mechanize didn't<br>realize.  And by running the level 3 tests we are running these tests<br>under both mechanize and the \"real\" browser testing.<br>::<br><br>    browser.getControl('Ein').selected = False<br>    browser.getControl('Ein').selected<br>    False<br><br>    browser.getControl(name='radio-value').value<br>    []<br><br>    &gt;&gt;&gt; browser.getControl('Zwei').selected = True<br><br>Checkbox collections behave similarly, as shown below.<br><br>Controls with subcontrols--<br><br>Various Controls<br>~~~~~~~~~~~~~~~~<br><br>The various types of controls are demonstrated here.<br><br>  - Text Control<br><br>    The text control we already introduced above.<br><br>  - Password Control<br><br>    &gt;&gt;&gt; ctrl = browser.getControl('Password Control')<br>    &gt;&gt;&gt; ctrl<br>    &lt;Control name='password-value' type='password'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IControl, ctrl)<br>    True<br>    &gt;&gt;&gt; ctrl.value<br>    'Password'<br>    &gt;&gt;&gt; ctrl.value = 'pass now'<br>    &gt;&gt;&gt; ctrl.value<br>    'pass now'<br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br>    &gt;&gt;&gt; ctrl.multiple<br>    False<br><br>  - Hidden Control<br><br>    &gt;&gt;&gt; ctrl = browser.getControl(name='hidden-value')<br>    &gt;&gt;&gt; ctrl<br>    &lt;Control name='hidden-value' type='hidden'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IControl, ctrl)<br>    True<br>    &gt;&gt;&gt; ctrl.value<br>    'Hidden'<br>    &gt;&gt;&gt; ctrl.value = 'More Hidden'<br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br>    &gt;&gt;&gt; ctrl.multiple<br>    False<br><br>  - Text Area Control<br><br>    &gt;&gt;&gt; ctrl = browser.getControl('Text Area Control')<br>    &gt;&gt;&gt; ctrl<br>    &lt;Control name='textarea-value' type='textarea'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IControl, ctrl)<br>    True<br>    &gt;&gt;&gt; ctrl.value<br>    '        Text inside\\n        area!\\n      '<br>    &gt;&gt;&gt; ctrl.value = 'A lot of\\n text.'<br>    &gt;&gt;&gt; ctrl.value<br>    'A lot of\\n text.'<br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br>    &gt;&gt;&gt; ctrl.multiple<br>    False<br><br>  - File Control<br><br>    File controls are used when a form has a file-upload field.<br>    To specify data, call the add_file method, passing:<br><br>    - A file-like object<br><br>    - a content type, and<br><br>    - a file name<br><br>    &gt;&gt;&gt; ctrl = browser.getControl('File Control')<br>    &gt;&gt;&gt; ctrl<br>    &lt;Control name='file-value' type='file'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IControl, ctrl)<br>    True<br>    &gt;&gt;&gt; ctrl.value is None<br>    True<br>    &gt;&gt;&gt; import cStringIO<br><br>    &gt;&gt;&gt; ctrl.add_file(cStringIO.StringIO('File contents'),<br>    ...               'text/plain', 'test.txt')<br><br>    The file control (like the other controls) also knows if it is disabled<br>    or if it can have multiple values.<br><br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br>    &gt;&gt;&gt; ctrl.multiple<br>    False<br><br>  - Selection Control (Single-Valued)<br><br>    &gt;&gt;&gt; ctrl = browser.getControl('Single Select Control')<br>    &gt;&gt;&gt; ctrl<br>    &lt;ListControl name='single-select-value' type='select'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)<br>    True<br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.value]<br>    [u'1']<br>    &gt;&gt;&gt; ctrl.value = ['2']<br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br>    &gt;&gt;&gt; ctrl.multiple<br>    False<br>    &gt;&gt;&gt; [unicode(o) for o in ctrl.options]<br>    [u'1', u'2', u'3']<br>    &gt;&gt;&gt; ctrl.displayOptions<br>    ['Uno', 'Dos', 'Third']<br>    &gt;&gt;&gt; ctrl.displayValue<br>    ['Dos']<br>    &gt;&gt;&gt; ctrl.displayValue = ['Tres']<br>    &gt;&gt;&gt; ctrl.displayValue<br>    ['Third']<br>    &gt;&gt;&gt; ctrl.displayValue = ['Dos']<br>    &gt;&gt;&gt; ctrl.displayValue<br>    ['Dos']<br>    &gt;&gt;&gt; ctrl.displayValue = ['Third']<br>    &gt;&gt;&gt; ctrl.displayValue<br>    ['Third']<br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.value]<br>    [u'3']<br><br>    &gt;&gt;&gt; ctrl.getControl('Dos')<br>    &lt;ItemControl name='single-select-value' type='select'<br>                 optionValue='2' selected=False&gt;<br><br>    &gt;&gt;&gt; ctrl.getControl('Dos').click()<br>    &gt;&gt;&gt; ctrl.getControl('Dos')<br>    &lt;ItemControl name='single-select-value' type='select'<br>                 optionValue='2' selected=True&gt;<br><br>    &gt;&gt;&gt; ctrl.getControl('Tres').click()<br>    &gt;&gt;&gt; ctrl.getControl('Dos')<br>    &lt;ItemControl name='single-select-value' type='select'<br>                 optionValue='2' selected=False&gt;<br>    &gt;&gt;&gt; ctrl.getControl('Tres')<br>    &lt;ItemControl name='single-select-value' type='select'<br>                 optionValue='3' selected=True&gt;<br><br>    &gt;&gt;&gt; ctrl.getControl('Tres').click()<br>    &gt;&gt;&gt; ctrl.getControl('Tres')<br>    &lt;ItemControl name='single-select-value' type='select'<br>                 optionValue='3' selected=False&gt;<br><br>  - Selection Control (Multi-Valued)<br><br>    &gt;&gt;&gt; ctrl = browser.getControl('Multiple Select Control')<br>    &gt;&gt;&gt; ctrl<br>    &lt;ListControl name='multi-select-value' type='select'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)<br>    True<br><br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.value]<br>    [u'1', u'2']<br><br>    &gt;&gt;&gt; ctrl.value = ['1', '3']<br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.displayValue]<br>    [u'Un', u'Third']<br><br>    &gt;&gt;&gt; ctrl.value = []<br><br>    &gt;&gt;&gt; ctrl.getControl('Deux').click()<br>    &gt;&gt;&gt; ctrl.getControl('Deux')<br>    &lt;ItemControl name='multi-select-value' type='select'<br>                 optionValue='2' selected=True&gt;<br><br>    &gt;&gt;&gt; ctrl.getControl('Trois').click()<br>    &gt;&gt;&gt; ctrl.getControl('Deux')<br>    &lt;ItemControl name='multi-select-value' type='select'<br>                 optionValue='2' selected=True&gt;<br>    &gt;&gt;&gt; ctrl.getControl('Trois')<br>    &lt;ItemControl name='multi-select-value' type='select'<br>                 optionValue='3' selected=True&gt;<br><br>    &gt;&gt;&gt; ctrl.getControl('Trois').click()<br>    &gt;&gt;&gt; ctrl.getControl('Trois')<br>    &lt;ItemControl name='multi-select-value' type='select'<br>                 optionValue='3' selected=False&gt;<br><br>  - Checkbox Control (Single-Valued; Unvalued)<br><br>    &gt;&gt;&gt; ctrl = browser.getControl(name='single-unvalued-checkbox-value')<br>    &gt;&gt;&gt; ctrl<br>    &lt;ListControl name='single-unvalued-checkbox-value' type='checkbox'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)<br>    True<br>    &gt;&gt;&gt; ctrl.value<br>    True<br>    &gt;&gt;&gt; ctrl.value = False<br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br>    &gt;&gt;&gt; ctrl.multiple<br>    True<br>    &gt;&gt;&gt; ctrl.options<br>    [True]<br>    &gt;&gt;&gt; ctrl.displayOptions<br>    ['Single Unvalued Checkbox']<br>    &gt;&gt;&gt; ctrl.displayValue<br>    []<br>    &gt;&gt;&gt; verifyObject(<br>    ...     zc.testbrowser.interfaces.IItemControl,<br>    ...     browser.getControl('Single Unvalued Checkbox'))<br>    True<br>    &gt;&gt;&gt; browser.getControl('Single Unvalued Checkbox').optionValue<br>    'on'<br>    &gt;&gt;&gt; browser.getControl('Single Unvalued Checkbox').selected<br>    False<br>    &gt;&gt;&gt; ctrl.displayValue = ['Single Unvalued Checkbox']<br>    &gt;&gt;&gt; ctrl.displayValue<br>    ['Single Unvalued Checkbox']<br><br>    &gt;&gt;&gt; subctrl = ctrl.getControl('Single Unvalued Checkbox')<br>    &gt;&gt;&gt; subctrl.selected<br>    True<br>    &gt;&gt;&gt; subctrl.selected = False<br>    &gt;&gt;&gt; subctrl.selected<br>    False<br>    &gt;&gt;&gt; ctrl.displayValue<br>    []<br><br>    &gt;&gt;&gt; subctrl.click()<br>    &gt;&gt;&gt; subctrl.selected<br>    True<br>    &gt;&gt;&gt; subctrl.click()<br>    &gt;&gt;&gt; subctrl.selected<br>    False<br><br>    &gt;&gt;&gt; disabledCtrl = browser.getControl(<br>    ...     name='single-disabled-unvalued-checkbox-value')<br>    &gt;&gt;&gt; disabledCtrl<br>    &lt;ListControl name='single-disabled-unvalued-checkbox-value' type='checkbox'&gt;<br>    &gt;&gt;&gt; disabledCtrl.disabled<br>    True<br>    &gt;&gt;&gt; disabledCtrl.getControl('Single Disabled Unvalued Checkbox').click()<br>    Traceback (most recent call last):<br>    ...<br>    AttributeError: item is disabled<br><br>  - Checkbox Control (Single-Valued, Valued)<br><br>    &gt;&gt;&gt; ctrl = browser.getControl(name='single-valued-checkbox-value')<br>    &gt;&gt;&gt; ctrl<br>    &lt;ListControl name='single-valued-checkbox-value' type='checkbox'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)<br>    True<br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.value]<br>    [u'1']<br>    &gt;&gt;&gt; ctrl.value = []<br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br>    &gt;&gt;&gt; ctrl.multiple<br>    True<br>    &gt;&gt;&gt; [unicode(o) for o in ctrl.options]<br>    [u'1']<br>    &gt;&gt;&gt; ctrl.displayOptions<br>    ['Single Valued Checkbox']<br>    &gt;&gt;&gt; ctrl.displayValue<br>    []<br>    &gt;&gt;&gt; verifyObject(<br>    ...     zc.testbrowser.interfaces.IItemControl,<br>    ...     browser.getControl('Single Valued Checkbox'))<br>    True<br>    &gt;&gt;&gt; browser.getControl('Single Valued Checkbox').selected<br>    False<br>    &gt;&gt;&gt; browser.getControl('Single Valued Checkbox').optionValue<br>    '1'<br>    &gt;&gt;&gt; ctrl.displayValue = ['Single Valued Checkbox']<br>    &gt;&gt;&gt; ctrl.displayValue<br>    ['Single Valued Checkbox']<br>    &gt;&gt;&gt; browser.getControl('Single Valued Checkbox').selected<br>    True<br>    &gt;&gt;&gt; browser.getControl('Single Valued Checkbox').selected = False<br>    &gt;&gt;&gt; browser.getControl('Single Valued Checkbox').selected<br>    False<br>    &gt;&gt;&gt; ctrl.displayValue<br>    []<br><br>    &gt;&gt;&gt; subctrl = ctrl.getControl('Single Valued Checkbox')<br>    &gt;&gt;&gt; subctrl.selected<br>    False<br><br>    &gt;&gt;&gt; subctrl.click()<br>    &gt;&gt;&gt; subctrl.selected<br>    True<br>    &gt;&gt;&gt; subctrl.click()<br>    &gt;&gt;&gt; subctrl.selected<br>    False<br><br>  - Checkbox Control (Multi-Valued)<br><br>    &gt;&gt;&gt; ctrl = browser.getControl(name='multi-checkbox-value')<br>    &gt;&gt;&gt; ctrl<br>    &lt;ListControl name='multi-checkbox-value' type='checkbox'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)<br>    True<br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.value]<br>    [u'1', u'3']<br>    &gt;&gt;&gt; ctrl.value = ['1', '2']<br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br>    &gt;&gt;&gt; ctrl.multiple<br>    True<br>    &gt;&gt;&gt; [unicode(o) for o in ctrl.options]<br>    [u'1', u'2', u'3']<br>    &gt;&gt;&gt; ctrl.displayOptions<br>    ['One', 'Two', 'Three']<br>    &gt;&gt;&gt; ctrl.displayValue<br>    ['One', 'Two']<br>    &gt;&gt;&gt; ctrl.displayValue = ['Two']<br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.value]<br>    [u'2']<br>    &gt;&gt;&gt; browser.getControl('Two').optionValue<br>    '2'<br>    &gt;&gt;&gt; browser.getControl('Two').selected<br>    True<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IItemControl,<br>    ...     browser.getControl('Two'))<br>    True<br>    &gt;&gt;&gt; browser.getControl('Three').selected = True<br>    &gt;&gt;&gt; browser.getControl('Three').selected<br>    True<br>    &gt;&gt;&gt; browser.getControl('Two').selected<br>    True<br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.value]<br>    [u'2', u'3']<br>    &gt;&gt;&gt; browser.getControl('Two').selected = False<br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.value]<br>    [u'3']<br>    &gt;&gt;&gt; browser.getControl('Three').selected = False<br>    &gt;&gt;&gt; ctrl.value<br>    []<br><br>    &gt;&gt;&gt; subctrl3 = browser.getControl('Three')<br>    &gt;&gt;&gt; subctrl3.selected<br>    False<br><br>    &gt;&gt;&gt; subctrl3.click()<br>    &gt;&gt;&gt; subctrl3.selected<br>    True<br>    &gt;&gt;&gt; subctrl3.click()<br>    &gt;&gt;&gt; subctrl3.selected<br>    False<br><br>    &gt;&gt;&gt; browser.getControl('Two').click()<br>    &gt;&gt;&gt; browser.getControl('Three').click()<br><br>    &gt;&gt;&gt; browser.getControl('Two').selected<br>    True<br>    &gt;&gt;&gt; browser.getControl('Three').selected<br>    True<br><br>  - Radio Control<br><br>    This is how you get a radio button based control:<br><br>    &gt;&gt;&gt; ctrl = browser.getControl(name='radio-value')<br><br>    This shows the existing value of the control, as it was in the<br>    HTML received from the server:<br><br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.value]<br>    [u'2']<br><br>    We can then unselect it:<br><br>    &gt;&gt;&gt; ctrl.value = []<br>    &gt;&gt;&gt; ctrl.value<br>    []<br><br>    We can also reselect it:<br><br>    &gt;&gt;&gt; ctrl.value = ['2']<br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.value]<br>    [u'2']<br><br>    displayValue shows the text the user would see next to the<br>    control:<br><br>    &gt;&gt;&gt; ctrl.displayValue<br>    ['Zwei']<br><br>    This is just unit testing:<br><br>    &gt;&gt;&gt; ctrl<br>    &lt;ListControl name='radio-value' type='radio'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IListControl, ctrl)<br>    True<br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br>    &gt;&gt;&gt; ctrl.multiple<br>    False<br>    &gt;&gt;&gt; [unicode(o) for o in ctrl.options]<br>    [u'1', u'2', u'3']<br>    &gt;&gt;&gt; ctrl.displayOptions<br>    ['Ein', 'Zwei', 'Drei']<br>    &gt;&gt;&gt; ctrl.displayValue = ['Ein']<br>    &gt;&gt;&gt; [unicode(v) for v in ctrl.value]<br>    [u'1']<br>    &gt;&gt;&gt; ctrl.displayValue<br>    ['Ein']<br><br>    The radio control subcontrols were illustrated above.<br><br>    &gt;&gt;&gt; subctrl = browser.getControl('Ein')<br>    &gt;&gt;&gt; subctrl.selected<br>    True<br><br>    &gt;&gt;&gt; subctrl2 = browser.getControl('Zwei')<br>    &gt;&gt;&gt; subctrl2.selected<br>    False<br><br>    &gt;&gt;&gt; subctrl2.click()<br>    &gt;&gt;&gt; subctrl2.selected<br>    True<br>    &gt;&gt;&gt; subctrl.selected<br>    False<br><br><br>  - Image Control<br><br>    &gt;&gt;&gt; ctrl = browser.getControl(name='image-value')<br>    &gt;&gt;&gt; ctrl<br>    &lt;ImageControl name='image-value' type='image'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IImageSubmitControl, ctrl)<br>    True<br>    &gt;&gt;&gt; ctrl.value<br>    ''<br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br>    &gt;&gt;&gt; ctrl.multiple<br>    False<br><br>  - Submit Control<br><br>    &gt;&gt;&gt; ctrl = browser.getControl(name='submit-value')<br>    &gt;&gt;&gt; ctrl<br>    &lt;SubmitControl name='submit-value' type='submit'&gt;<br><br>    &gt;&gt;&gt; browser.getControl('Submit This') # value of submit button is a label<br>    &lt;SubmitControl name='submit-value' type='submit'&gt;<br>    &gt;&gt;&gt; browser.getControl('Standard Submit Control') # label tag is legal<br>    &lt;SubmitControl name='submit-value' type='submit'&gt;<br><br>    &gt;&gt;&gt; browser.getControl('Submit') # multiple labels, but same control<br>    &lt;SubmitControl name='submit-value' type='submit'&gt;<br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.ISubmitControl, ctrl)<br>    True<br>    &gt;&gt;&gt; ctrl.value<br>    'Submit This'<br>    &gt;&gt;&gt; ctrl.disabled<br>    False<br>    &gt;&gt;&gt; ctrl.multiple<br>    False<br><br>Using Submitting Controls<br>~~~~~~~~~~~~~~~~~~~~~~~~~<br><br>Both the submit and image type should be clickable and submit the form:<br><br>    &gt;&gt;&gt; browser.getControl('Text Control').value = 'Other Text'<br>    &gt;&gt;&gt; browser.getControl('Submit').click()<br>    &gt;&gt;&gt; browser.wait()<br>    &gt;&gt;&gt; browser.contents<br>    \"...'text-value': ['Other Text']...\"<br><br>Note that if you click a submit object after the associated page has expired,<br>you will get an error.<br><br>    &gt;&gt;&gt; browser.open('controls.html')<br>    &gt;&gt;&gt; ctrl = browser.getControl('Submit')<br>    &gt;&gt;&gt; ctrl.click()<br>    &gt;&gt;&gt; ctrl.click()<br>    Traceback (most recent call last):<br>    ...<br>    ExpiredError<br><br>All the above also holds true for the image control:<br><br>    &gt;&gt;&gt; browser.open('controls.html')<br>    &gt;&gt;&gt; browser.getControl('Text Control').value = 'Other Text'<br>    &gt;&gt;&gt; browser.getControl(name='image-value').click()<br>    &gt;&gt;&gt; browser.wait()<br>    &gt;&gt;&gt; browser.contents<br>    \"...'text-value': ['Other Text']...\"<br><br>    &gt;&gt;&gt; browser.open('controls.html')<br>    &gt;&gt;&gt; ctrl = browser.getControl(name='image-value')<br>    &gt;&gt;&gt; ctrl.click()<br>    &gt;&gt;&gt; ctrl.click()<br>    Traceback (most recent call last):<br>    ...<br>    ExpiredError<br><br>But when sending an image, you can also specify the coordinate you clicked:<br><br>#    &gt;&gt;&gt; browser.open('controls.html')<br>#    &gt;&gt;&gt; browser.getControl(name='image-value').click((50,25))<br>#    &gt;&gt;&gt; browser.contents<br>#    \"...'image-value.x': ['50']...'image-value.y': ['25']...\"<br><br>Another interesting aspect of submitting a form is the correct submission of<br>the file data.<br><br>    &gt;&gt;&gt; browser.open('controls.html')<br>    &gt;&gt;&gt; ctrl = browser.getControl('File Control')<br>    &gt;&gt;&gt; import cStringIO<br>    &gt;&gt;&gt; ctrl.add_file(cStringIO.StringIO('File contents'),<br>    ...               'text/plain', 'test.txt')<br>    &gt;&gt;&gt; browser.getControl('Submit This').click()<br>    &gt;&gt;&gt; browser.wait()<br>    &gt;&gt;&gt; browser.contents<br>    \"...'file-value': ['File contents'],...\"<br><br>Forms<br>-----<br><br>Because pages can have multiple forms with like-named controls, it is sometimes<br>necessary to access forms by name or id.  The browser's `forms` attribute can<br>be used to do so.  The key value is the form's name or id.  If more than one<br>form has the same name or id, the first one will be returned.<br><br>    &gt;&gt;&gt; browser.open('forms.html')<br>    &gt;&gt;&gt; form = browser.getForm(name='one')<br><br>Form instances conform to the IForm interface.<br><br>    &gt;&gt;&gt; verifyObject(zc.testbrowser.interfaces.IForm, form)<br>    True<br><br>The form exposes several attributes related to forms:<br><br>  - The name of the form:<br><br>    &gt;&gt;&gt; unicode(form.name)<br>    u'one'<br><br>  - The id of the form:<br><br>    &gt;&gt;&gt; unicode(form.id)<br>    u'1'<br><br>  - The action (target URL) when the form is submitted:<br><br>    &gt;&gt;&gt; unicode(form.action)<br>    u'http://localhost:.../forms.html'<br><br>  - The method (HTTP verb) used to transmit the form data:<br><br>    &gt;&gt;&gt; unicode(form.method)<br>    u'POST'<br><br>  - The encoding type of the form data:<br><br>    &gt;&gt;&gt; unicode(form.enctype)<br>    u'application/x-www-form-urlencoded'<br><br>Besides those attributes, you have also a couple of methods.  Like for the<br>browser, you can get control objects, but limited to the current form...<br><br>    &gt;&gt;&gt; form.getControl(name='text-value')<br>    &lt;Control name='text-value' type='text'&gt;<br><br>...and submit the form.<br><br>    &gt;&gt;&gt; form.submit('Submit')<br>    &gt;&gt;&gt; browser.contents<br>    \"...'text-value': ['First Text']...\"<br><br>Submitting also works without specifying a control, as shown below, which is<br>it's primary reason for existing in competition with the control submission<br>discussed above.<br><br>Now let me show you briefly that looking up forms is sometimes important.  In<br>the `forms.html` template, we have four forms all having a text control named<br>`text-value`.  Now, if I use the browser's `get` method,<br><br>    &gt;&gt;&gt; browser.open('forms.html')<br>    &gt;&gt;&gt; browser.getControl(name='text-value')<br>    Traceback (most recent call last):<br>    ...<br>    AmbiguityError: name 'text-value'<br>    &gt;&gt;&gt; browser.getControl('Text Control')<br>    Traceback (most recent call last):<br>    ...<br>    AmbiguityError: label 'Text Control'<br><br>I'll always get an ambiguous form field.  I can use the index argument, or<br>with the `getForm` method I can disambiguate by searching only within a given<br>form:<br><br>    &gt;&gt;&gt; form = browser.getForm('2')<br>    &gt;&gt;&gt; form.getControl(name='text-value').value<br>    'Second Text'<br>    &gt;&gt;&gt; form.submit('Submit')<br>    &gt;&gt;&gt; browser.contents<br>    \"...'text-value': ['Second Text']...\"<br>    &gt;&gt;&gt; browser.open('forms.html')<br>    &gt;&gt;&gt; form = browser.getForm('2')<br>    &gt;&gt;&gt; form.getControl('Submit').click()<br>    &gt;&gt;&gt; browser.wait()<br>    &gt;&gt;&gt; browser.contents<br>    \"...'text-value': ['Second Text']...\"<br>    &gt;&gt;&gt; browser.open('forms.html')<br>    &gt;&gt;&gt; browser.getForm('3').getControl('Text Control').value<br>    'Third Text'<br><br>The last form on the page does not have a name, an id, or a submit button.<br>Working with it is still easy, thanks to a index attribute that guarantees<br>order.  (Forms without submit buttons are sometimes useful for JavaScript.)<br><br>    &gt;&gt;&gt; form = browser.getForm(index=3)<br>    &gt;&gt;&gt; form.submit()<br>    &gt;&gt;&gt; browser.contents<br>    \"...'text-value': ['Fourth Text']...\"<br><br>If a form is requested that does not exists, an exception will be raised.<br><br>    &gt;&gt;&gt; browser.open('forms.html')<br>    &gt;&gt;&gt; form = browser.getForm('does-not-exist')<br>    Traceback (most recent call last):<br>    LookupError<br><br>If the HTML page contains only one form, no arguments to `getForm` are<br>needed:<br><br>    &gt;&gt;&gt; browser.open('oneform.html')<br>    &gt;&gt;&gt; browser.getForm()<br>    &lt;zc.testbrowser...Form object at ...&gt;<br><br>If the HTML page contains more than one form, `index` is needed to<br>disambiguate if no other arguments are provided:<br><br>    &gt;&gt;&gt; browser.open('forms.html')<br>    &gt;&gt;&gt; browser.getForm()<br>    Traceback (most recent call last):<br>    ValueError: if no other arguments are given, index is required.<br><br><br>Hand-Holding<br>------------<br><br>Instances of the various objects ensure that users don't set incorrect<br>instance attributes accidentally.<br><br>    &gt;&gt;&gt; browser.nonexistant = None<br>    Traceback (most recent call last):<br>    ...<br>    AttributeError: 'Browser' object has no attribute 'nonexistant'<br><br>    &gt;&gt;&gt; form.nonexistant = None<br>    Traceback (most recent call last):<br>    ...<br>    AttributeError: 'Form' object has no attribute 'nonexistant'<br><br>    &gt;&gt;&gt; control.nonexistant = None<br>    Traceback (most recent call last):<br>    ...<br>    AttributeError: 'Control' object has no attribute 'nonexistant'<br><br>    &gt;&gt;&gt; link.nonexistant = None<br>    Traceback (most recent call last):<br>    ...<br>    AttributeError: 'Link' object has no attribute 'nonexistant'<br><br><br>Fixed Bugs<br>----------<br><br>This section includes tests for bugs that were found and then fixed that don't<br>fit into the more documentation-centric sections above.<br><br>Spaces in URL<br>~~~~~~~~~~~~~<br><br>When URLs have spaces in them, they're handled correctly (before the bug was<br>fixed, you'd get \"ValueError: too many values to unpack\"):<br><br>    &gt;&gt;&gt; browser.open('navigate.html')<br>    &gt;&gt;&gt; browser.getLink('Spaces in the URL').click()<br>    &gt;&gt;&gt; browser.wait()<br><br>.goBack() Truncation<br>~~~~~~~~~~~~~~~~~~~~<br><br>The .goBack() method used to truncate the .contents.<br><br>    &gt;&gt;&gt; browser.open('navigate.html')<br>    &gt;&gt;&gt; actual_length = len(browser.contents)<br><br>    &gt;&gt;&gt; browser.open('navigate.html')<br>    &gt;&gt;&gt; browser.open('index.html')<br>    &gt;&gt;&gt; browser.goBack()<br>    &gt;&gt;&gt; len(browser.contents) == actual_length<br>    True<br><br><br>Authors<br>-------<br><br>Benji York created testbrowser (originally zope.testbrowser) in 2005 with Gary<br>Poster and Stephan Richter making large contributions.<br><br>The zc.testbrowser.real version was conceptualized by Benji York in 2007 and<br>after an initial implementation sketch, brought to fruition by Stephan<br>Richter, Rocky Burt, Justas Sadzevicius, and others at the Foliage Zope 3<br>sprint in Boston, MA during the week of September 24, 2007.<br><br>There have been many other contributions from users of testbrowser that are<br>greatly appreciated.\n          </div>"}, "last_serial": 802211, "releases": {"1.0.0a3-dev": [{"comment_text": "", "digests": {"md5": "006b9c59c4dd58c2346ec199b2e66526", "sha256": "7d42a5d091b9e6824891c520a788115d403437db181056391985e73a16a17d23"}, "downloads": -1, "filename": "zc.testbrowser-1.0.0a3-dev.tar.gz", "has_sig": false, "md5_digest": "006b9c59c4dd58c2346ec199b2e66526", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52770, "upload_time": "2008-03-06T19:29:24", "upload_time_iso_8601": "2008-03-06T19:29:24Z", "url": "https://files.pythonhosted.org/packages/c7/03/af4379282c64f6da3404f9d7e6767d913744b79920d392994d9094394e11/zc.testbrowser-1.0.0a3-dev.tar.gz", "yanked": false}], "1.0.0a4": [{"comment_text": "", "digests": {"md5": "96d2dc6e45ab16c0cd546543057bbf5e", "sha256": "8085f2aa6d9fff51f18cf8c4143b1794ad6ad66f0dd76ee1c8a4b490f8d07b9e"}, "downloads": -1, "filename": "zc.testbrowser-1.0.0a4.tar.gz", "has_sig": false, "md5_digest": "96d2dc6e45ab16c0cd546543057bbf5e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52966, "upload_time": "2008-03-06T20:06:03", "upload_time_iso_8601": "2008-03-06T20:06:03Z", "url": "https://files.pythonhosted.org/packages/d8/c3/f72bf1eb8fb42f4999f3b80af3af76627fbf12604b871ea3fac7a4c1804b/zc.testbrowser-1.0.0a4.tar.gz", "yanked": false}], "1.0.0a5": [{"comment_text": "", "digests": {"md5": "c0f4d81b3ddcd7527275f3750cba45db", "sha256": "587656ba98eeb19f692a5202177816ca3e6d68bae1334378eebe670761846170"}, "downloads": -1, "filename": "zc.testbrowser-1.0.0a5.tar.gz", "has_sig": false, "md5_digest": "c0f4d81b3ddcd7527275f3750cba45db", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 57121, "upload_time": "2009-03-21T01:44:45", "upload_time_iso_8601": "2009-03-21T01:44:45.246990Z", "url": "https://files.pythonhosted.org/packages/d5/32/ef3b97585766937c947beacbcf7c2bb9d5f63ccfcbe7d8e183564d64f6e3/zc.testbrowser-1.0.0a5.tar.gz", "yanked": false}], "1.0a1": [{"comment_text": "", "digests": {"md5": "69e1a5d8443fe348e7a625e5289f5df7", "sha256": "dd0f9fe43bd38a898367b24ca11d25671fd2c0cc759a0d26939c3353100061f1"}, "downloads": -1, "filename": "zc.testbrowser-1.0a1.tar.gz", "has_sig": false, "md5_digest": "69e1a5d8443fe348e7a625e5289f5df7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51974, "upload_time": "2007-09-28T13:47:40", "upload_time_iso_8601": "2007-09-28T13:47:40Z", "url": "https://files.pythonhosted.org/packages/52/95/9e8a4d25074672b6a522b80700e58c77f8af6ae8203c6c878734c3a1bf51/zc.testbrowser-1.0a1.tar.gz", "yanked": false}], "1.0a2": [{"comment_text": "", "digests": {"md5": "9cb92be8d85dbf5d2596aaafdc780bc1", "sha256": "aa446ca8ef0eda78271d935003032e413cc2439a9c049616fe25bf0c70c2b4d5"}, "downloads": -1, "filename": "zc.testbrowser-1.0a2.tar.gz", "has_sig": false, "md5_digest": "9cb92be8d85dbf5d2596aaafdc780bc1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52870, "upload_time": "2008-02-15T13:53:53", "upload_time_iso_8601": "2008-02-15T13:53:53Z", "url": "https://files.pythonhosted.org/packages/7f/cb/2ac76823db1ec1c116694c37504bf641e2c8665c0cefe5d41f2fdfb0fbfa/zc.testbrowser-1.0a2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c0f4d81b3ddcd7527275f3750cba45db", "sha256": "587656ba98eeb19f692a5202177816ca3e6d68bae1334378eebe670761846170"}, "downloads": -1, "filename": "zc.testbrowser-1.0.0a5.tar.gz", "has_sig": false, "md5_digest": "c0f4d81b3ddcd7527275f3750cba45db", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 57121, "upload_time": "2009-03-21T01:44:45", "upload_time_iso_8601": "2009-03-21T01:44:45.246990Z", "url": "https://files.pythonhosted.org/packages/d5/32/ef3b97585766937c947beacbcf7c2bb9d5f63ccfcbe7d8e183564d64f6e3/zc.testbrowser-1.0.0a5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:18:54 2020"}