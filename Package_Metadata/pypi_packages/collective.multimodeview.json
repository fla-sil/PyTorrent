{"info": {"author": "Zest Software", "author_email": "info@zestsoftware.nl", "bugtrack_url": null, "classifiers": ["Framework :: Plone", "Framework :: Plone :: 3.3", "Programming Language :: Python", "Programming Language :: Python :: 2.4"], "description": "Introduction\n============\n\ncollective.multimode view is a Plone package to ease creation of views\n(or viewlets) which can be in several states, for example a page\ncontaining a form or a guide with several steps.\n\nThis products can not be used alone, you need to manually define the\npages has you would do usually when creating browser views.\n\nThis README will show three simple examples on how to use the\nproduct. All samples can be found in the sources in the samples\ndirectory.\n\n\nCompatibility\n=============\n\nThis has been tested with Plone 3.3.5.\n\n\nSamples of views\n================\n\nSample 1: a simple view with two states\n---------------------------------------\n\nLet's say you want to define a view that displays the conditions to\nuse the site  or the engagments you are taking with the data provided\nby the user.\n\nFirst we need to define the Python view::\n\n  from collective.multimodeview.browser import MultiModeView\n\n  class Sample1View(MultiModeView):\n      modes = ['conditions',\n               'data_use']\n      default_mode = 'conditions'\n      view_name = 'multimodeview_sample1'\n\n'modes' is the list of modes that the view can take. For simple cases, a\nlist is enough. The next samples will show the use of a dictionnary\nfor more complex cases.\n'default_mode' is, as you can guess, the mode that will be displayed\nby default for this page.\n'view_name' is the name of the view as defined in the zcml file (we'll\nsee it after). It is needed to be able to define the base url for the\npage or when using Ajax to fetch the content (mainly for viewlets).\n\nThe second step is to define a template for our page::\n\n  <html xmlns=\"http://www.w3.org/1999/xhtml\"\n        xmlns:tal=\"http://xml.zope.org/namespaces/tal\"\n        xmlns:metal=\"http://xml.zope.org/namespaces/metal\"\n        xmlns:i18n=\"http://xml.zope.org/namespaces/i18n\"\n        metal:use-macro=\"here/main_template/macros/master\"\n        xml:lang=\"en\"\n        lang=\"en\"\n        i18n:domain=\"collective.multimodeview\">\n    <body>\n      <div metal:fill-slot=\"main\">\n        <div tal:condition=\"view/is_conditions_mode\">\n          <p>By using this site, you agree on the fact that you will\n          not do stupid things.</p>\n\n          <p class=\"discreet\">\n            <a tal:attributes=\"href view/data_use_link\">See how we use your data</a>\n          </p>\n        </div>\n        <div tal:condition=\"view/is_data_use_mode\">\n          <p>We will sell your email to all known spam database, we need money.</p>\n\n          <p class=\"discreet\">\n            <a tal:attributes=\"href view/conditions_link\">See the conditions to use the site</a>\n          </p>\n        </div>\n      </div>\n    </body>\n  </html>\n\nWith this example, we can see two examples of auto-generated\nattributes for the multimodeviews.\n'is_conditions_mode': provides a boolean telling if the view is in the\n'conditions' mode. For each mode you defined, you can use this\nshortcut ('is_xxx_mode', where 'xxx' is the name defined for you\nmode).\n'conditions_link': provides a link to swtich the page in 'conditions'\nmode. This can be used for any mode, except if you have a mode called\n'make' (it conflicts with the 'make_link' method). If you have a\n'make' mode, then you'll have to manually use 'make_link' (that will\nbe described later).\n\nNow you can define your view in the zcml file::\n\n  <browser:page\n      for=\"*\"\n      name=\"multimodeview_sample1\"\n      class=\".views.Sample1View\"\n      template=\"sample1.pt\"\n      permission=\"zope2.View\"\n      />\n\nAnd that's all, you can now access this  view and switch between the\ntwo modes.\n\nNow let's go for something a bit more interresting.\n\nSample 2: playing with forms\n----------------------------\n\nThe first sample was pretty basic and could have been simply done by\nusing two pages or browser views.\nThe second example will show how to manage some data with a view. We\nwill add some annotations on the portal object (basically a simple\nlist of string). The view will be able to list, add, edit and delete\nthose notes.\nWe consider we have a view called 'multimodeview_notes_sample', that\nprovides an API to list, add, edit and delete notes (see\nsamples/notes_view.py).\n\nAs usual, we first define the view::\n\n  class Sample2View(MultiModeView):\n      \"\"\" A view that adds annotations on the portal.\n      \"\"\"\n      modes = ['list',\n               'add',\n               'delete']\n      default_mode = 'list'\n      view_name = 'multimodeview_sample2'\n\n      @property\n      def notes_view(self):\n          return self.context.restrictedTraverse('@@multimodeview_notes_sample')\n\n      def _get_note_id(self):\n          \"\"\" Extracts the note_id from the form, cast it\n\t  to an int.\n\t  Returns None if there is no corresponding note.\n\t  \"\"\"\n\n      def _check_add_form(self):\n          if not self.request.form.get('title'):\n              self.errors['title'] = 'You must provide a title'\n\n          return True\n\n      def _check_edit_form(self):\n          if self._get_note_id() is None:\n              return\n\n          return self._check_add_form()\n\n      def _check_delete_form(self):\n          return self._get_note_id() is not None\n\n      def _process_add_form(self):\n          self.notes_view.add_note(self.request.form.get('title'))\n\n      def _process_edit_form(self):\n          self.notes_view.edit_note(\n              self._get_note_id(),\n              self.request.form.get('title'))\n\n      def _process_delete_form(self):\n          self.notes_view.delete_note(self._get_note_id())\n\nLike for the previous example, we have defined our list of modes, the\ndefault mode and the name of the view.\nWe also defined some helpful functions (see the source for the\ncomplete code, I removed it from here to focus on the important part)\nto manage the notes.\n\nThe important functions are _check_xxx_form and _process_xxx_form.\n\nThe first one (_check_xxx_form) checks if the form submitted does not\ncontain errors. If an error is found, it is added to the 'errors'\ndictionnary of the class, as we can see in '_check_add_form' if the\ntitle is empty. \nThe method always returns True, except if something wrong hapenned to\nthe form (some fields have not been submitted, or a value that the\nuser can not change in normal use case is wrong). In this case, the\nmethod returns 'False' or None. A different message will be shown to\nthe user. We can see an example in '_check_delete_form', which only\nchecks that the note_id provided is correct.\n\nThe second one (_process_xxx_form) executes the code for the given\nmode. It is only called if the corresponding check method returned\nTrue and did not find any error.\nIf needed, it can return a 'mode' name so the view switch back to this\nmode once the form is proceeded. By default, it switches to the\ndefault mode.\n\nThe second step is to define the template for this view. We first\ncreate the div (or whatever else) that is shown by default::\n\n  <div tal:condition=\"view/is_list_mode\">\n    <tal:block tal:define=\"notes view/notes_view/get_notes;\n                           note_exists python: bool([n for n in notes if n])\">\n      <table class=\"listing\"\n             tal:condition=\"note_exists\">\n        <thead>\n          <tr>\n            <th colspan=\"3\">\n              Notes\n            </th>\n          </tr>\n        </thead>\n        <tbody>\n          <tal:block tal:repeat=\"note python: enumerate(notes)\">\n            <tr tal:define=\"note_id python: note[0];\n                            note_text python: note[1]\"\n                tal:condition=\"note_text\">\n              <td tal:content=\"note_text\" />\n              <td>\n                <a tal:attributes=\"href python: view.make_link('edit', {'note_id': note_id})\"\n                   title=\"edit this note\">\n                  <img tal:attributes=\"src python: '%s/edit.gif' % context.absolute_url()\"\n                       alt=\"edit\" />\n                </a>\n              </td>\n              <td>\n                <a tal:attributes=\"href python: view.make_link('delete', {'note_id': note_id})\"\n                   title=\"delete this note\">\n                  <img tal:attributes=\"src python: '%s/delete_icon.gif' % context.absolute_url()\"\n                       alt=\"delete\" />\n                </a>\n              </td>\n            </tr>\n          </tal:block>\n        </tbody>\n      </table>\n\n      <p tal:condition=\"not: note_exists\">\n        You do not have any notes for the moment.\n      </p>\n\n      <a tal:attributes=\"href view/add_link\">\n        Add a new note\n      </a>\n    </tal:block>\n  </div>\n\nIn this short sample, we can see the use of the 'make_link' method. We\nuse it to create the link to edit or delete a note. We could not use\n'edit_link' or 'delete_link', as we also need to specify the note we\nwant to edit or delete.\nusing view.make_link('edit', {'note_id': note_id}) will generate a\nlink like this: http://..../multimodeview_sample2?mode=edit&note_id=2.\n\nNow let's complete our template with the form to add a note::\n\n  <div tal:condition=\"not: view/is_list_mode\">\n    <form name=\"manage_notes_form\"\n          method=\"POST\"\n          tal:define=\"notes view/notes_view/get_notes;\n                      note_id view/_get_note_id;\n                      note_text python: (note_id is not None) and notes[note_id] or '';\"\n          tal:attributes=\"action view/get_form_action\">\n      <tal:block tal:condition=\"view/is_add_mode\">\n        <div tal:attributes=\"class python: view.class_for_field('title')\">\n          <label for=\"title\">Title</label>\n          <div class=\"error_msg\"\n               tal:condition=\"view/errors/title|nothing\"\n               tal:content=\"view/errors/title\" />\n          <input type=\"text\"\n                 name=\"title\"\n                 tal:attributes=\"value view/request/form/title | nothing\" />\n        </div>\n\n        <span tal:replace=\"structure view/make_form_extras\" />\n\n        <input type=\"submit\"\n               name=\"form_submitted\"\n               value=\"Add note\" />\n        <input type=\"submit\"\n               name=\"form_cancelled\"\n               value=\"Cancel\" />\n      </tal:block>\n    </form>\n  </div>\n\nIn this code we can see a few usefull methods provided by\nmultimodeview:\n\n - 'view/get_for_action': provides the action that should be used for\n   the form.\n\n - 'view.class_for_field(field)': this methods returns 'field' if\n   there is no error found for this field, or 'field error' if an error\n   was found. Those class names are the default ones provided by\n   Archetype, so an error will appear in red with a default Plone theme.\n\n - 'view/make_form_extras': this method should be used in every form \n   in multimode page. It adds some hidden fields such as the mode\n   currently is use.\n\nWe can also see some specificities in the form:\n\n - the method should always be 'POST': if you do not use a 'POST'\n   method, the form will not be processed.\n\n - the submit input to process the form is called 'form_submitted'.\n\n - the sumbit input to cancel is called 'form_cancelled'. If you use\n   other names, the form will not be processed.\n\nWe can now complete the template to also be able to manage the 'edit'\nand 'delete' modes::\n\n  <tal:block tal:condition=\"view/is_edit_mode\">\n    <div tal:attributes=\"class python: view.class_for_field('title')\">\n      <label for=\"title\">Title</label>\n      <div class=\"error_msg\"\n           tal:condition=\"view/errors/title|nothing\"\n           tal:content=\"view/errors/title\" />\n      <input type=\"text\"\n             name=\"title\"\n             tal:attributes=\"value view/request/form/title | note_text\" />\n      <input type=\"hidden\"\n             name=\"note_id\"\n             tal:attributes=\"value note_id\" />\n    </div>\n\n    <span tal:replace=\"structure view/make_form_extras\" />\n    <input type=\"submit\"\n           name=\"form_submitted\"\n           value=\"Edit note\" />\n    <input type=\"submit\"\n           name=\"form_cancelled\"\n           value=\"Cancel\" />\n  </tal:block>\n\n  <tal:block tal:condition=\"view/is_delete_mode\">\n    <p>Are you sure you want to delete this note ?</p>\n    <p class=\"discreet\" tal:content=\"note_text\" />\n\n    <input type=\"hidden\"\n           name=\"note_id\"\n           tal:attributes=\"value note_id\" />\n\n    <span tal:replace=\"structure view/make_form_extras\" />\n    <input type=\"submit\"\n           name=\"form_submitted\"\n           value=\"Delete note\" />\n    <input type=\"submit\"\n           name=\"form_cancelled\"\n           value=\"Cancel\" />\n  </tal:block>\n\nNothing really new in this new code but at least we are now able to\nmanage the notes.\n\nNow that the system is complete, we can see some problems incoming:\n\n - there is some repetitions in the template code, mainly for the\n   submit buttons. The one to cancel could be factorized but the one to\n   process the form has a different name everytime.\n\n - the messages always say 'Your changes have been saved', whatever\n   you do.\n\nLet's improve this quiclky.\n\nSample 2.1: using a dictionnary for modes\n-----------------------------------------\n\nThe two problems seen before can be quickly fixed when defining a list\nof modes with a dictionnary.\n\nLet's define the new view, inheriting from the prevous one::\n\n  class Sample21View(Sample2View):\n      \"\"\" A view that adds annotations on the portal.\n      \"\"\"\n      modes = {'list': {},\n               'add': {'success_msg': 'The note has been added',\n                       'error_msg': 'Impossible to add a note: please correct the form',\n                       'submit_label': 'Add note'},\n               'edit': {'success_msg': 'The note has been edited',\n                       'submit_label': 'Edit note'},\n               'delete': {'success_msg': 'The note has been deleted',\n                          'submit_label': 'Delete note'}\n               }\n\n      view_name = 'multimodeview_sample21'\n\nAs you can see, for each mode, a dictionnary is provided with three\nvalues:\n\n - success_msg: the message displayed when the form is successfuly\n   processed.\n\n - error_msg: the message shown when errors are found in the form.\n \n - submit_label: the title for the button to submit the form.\n\nNow we can also update our template. The part for listing the notes\ndoes not change, we only update the form::\n\n  <form name=\"manage_notes_form\"\n        method=\"POST\"\n        tal:define=\"notes view/notes_view/get_notes;\n                    note_id view/_get_note_id;\n                    note_text python: (note_id is not None) and notes[note_id] or '';\"\n        tal:attributes=\"action view/get_form_action\">\n    <tal:block tal:condition=\"view/is_add_mode\">\n      <div tal:attributes=\"class python: view.class_for_field('title')\">\n        <label for=\"title\">Title</label>\n        <div class=\"error_msg\"\n             tal:condition=\"view/errors/title|nothing\"\n             tal:content=\"view/errors/title\" />\n        <input type=\"text\"\n               name=\"title\"\n               tal:attributes=\"value view/request/form/title | nothing\" />\n      </div>\n    </tal:block>\n\n    <tal:block tal:condition=\"view/is_edit_mode\">\n      <div tal:attributes=\"class python: view.class_for_field('title')\">\n        <label for=\"title\">Title</label>\n        <div class=\"error_msg\"\n             tal:condition=\"view/errors/title|nothing\"\n             tal:content=\"view/errors/title\" />\n        <input type=\"text\"\n               name=\"title\"\n               tal:attributes=\"value view/request/form/title | note_text\" />\n        <input type=\"hidden\"\n               name=\"note_id\"\n               tal:attributes=\"value note_id\" />\n      </div>\n    </tal:block>\n\n    <tal:block tal:condition=\"view/is_delete_mode\">\n      <p>Are you sure you want to delete this note ?</p>\n      <p class=\"discreet\" tal:content=\"note_text\" />\n\n      <input type=\"hidden\"\n             name=\"note_id\"\n             tal:attributes=\"value note_id\" />\n    </tal:block>\n\n    <span tal:replace=\"structure view/make_form_extras\" />\n  </form>\n\nAs we can see, this version is much shorter than the previous one. We\ncould even have factorized the input for the title, but this has\nnothing to see with multimodeview, it is normal Zope/Plone/TAL coding.\n\nThe question you may have now is \"Where are my input defined ?\". It is\nthe view/make_form_extras that creates them. If no label for the\nsubmit button is found, it will not show any button. If a label is\nfound, it automatically generates the two submit buttons.\n\nSample 3: Creating a multi-step form\n------------------------------------\n\nThis last example shows how to handle a form in multiple steps. The\nmethod used here is not the best one, as we pass the data from one\npage to the other using hidden input. It would be better to use\nsession, cookies or even local storage for HTML5 fans, but the goal\nhere is more to shown how to navigate from one mode to another.\n\nAs usual, we first define the view::\n\n  class Sample3View(MultiModeView):\n      modes = {'step1': {'submit_label': 'Go to step 2'},\n               'step2': {'submit_label': 'Go to step 3'},\n               'step3': {'submit_label': 'Go to step 4'},\n               'step4': {'submit_label': 'Go to step 5'},\n               'step5': {}}\n\n      default_mode = 'step1'\n      view_name = 'multimodeview_sample3'\n\n      def check_form(self):\n          return True\n\n      def _process_step1_form(self):\n          return 'step2'\n\n      def _process_step2_form(self):\n          return 'step3'\n\n      def _process_step3_form(self):\n          return 'step4'\n\n      def _process_step4_form(self):\n          return 'step5'\n\n      def _process_step5_form(self):\n          return 'step5'\n\n      @property\n      def cancel_mode(self):\n          mapping = {'step1': 'step1',\n                     'step2': 'step1',\n                     'step3': 'step2',\n                     'step4': 'step3',\n                     'step5': 'step4'}\n          return mapping.get(self.mode)\n\n\nWe have overriden the 'check_form' method so it always returns True\n(we do not really care about the values here).\nThe _process_xxx_form methods now returns the step to which the user\nis sent when completing the step. So once the 1st step is done, the\nsecond one is displayed and so on.\n\nThe 'cancel_mode' attribute has been defined has a property, so the\nvalue can change depending on the current mode used by the view. You\ncan also define it has a simple attribute, but in this case it will\nalways return to the same mode when cancelling.\n\nNow we can define a simple template for our view::\n\n  <form method=\"POST\"\n        tal:attributes=\"action view/get_form_action\">\n    <input type=\"hidden\"\n           name=\"step1_value\"\n           tal:attributes=\"value view/request/form/step1_value|nothing\"\n           tal:condition=\"not: view/is_step1_mode\" />\n\n    <input type=\"hidden\"\n           name=\"step2_value\"\n           tal:attributes=\"value view/request/form/step2_value|nothing\"\n           tal:condition=\"not: view/is_step2_mode\" />\n\n    <input type=\"hidden\"\n           name=\"step3_value\"\n           tal:attributes=\"value view/request/form/step3_value|nothing\"\n           tal:condition=\"not: view/is_step3_mode\" />\n\n    <input type=\"hidden\"\n           name=\"step4_value\"\n           tal:attributes=\"value view/request/form/step4_value|nothing\"\n           tal:condition=\"not: view/is_step4_mode\" />\n\n    <div class=\"field\"\n         tal:condition=\"view/is_step1_mode\">\n      <label for=\"step1\">What is your name?</label>\n      <input type=\"text\"\n             name=\"step1_value\"\n             tal:attributes=\"value view/request/form/step1_value|nothing\" />\n    </div>\n\n    <div class=\"field\"\n         tal:condition=\"view/is_step2_mode\">\n      <label for=\"step1\">What is your quest?</label>\n      <input type=\"text\"\n             name=\"step2_value\"\n             tal:attributes=\"value view/request/form/step2_value|nothing\" />\n    </div>\n\n    <div class=\"field\"\n         tal:condition=\"view/is_step3_mode\">\n      <label for=\"step1\">What is your favorite color?</label>\n      <input type=\"text\"\n             name=\"step3_value\"\n             tal:attributes=\"value view/request/form/step3_value|nothing\" />\n    </div>\n\n    <div class=\"field\"\n         tal:condition=\"view/is_step4_mode\">\n      <label for=\"step1\">What is the air-speed velocity of an unladen swallow?</label>\n      <input type=\"text\"\n             name=\"step4_value\"\n             tal:attributes=\"value view/request/form/step4_value|nothing\" />\n    </div>\n\n    <div tal:condition=\"view/is_step5_mode\">\n      <p>Yer answers to the questions were:</p>\n      <ul>\n        <li>What is your name? <span tal:replace=\"view/request/form/step1_value|nothing\" /></li>\n        <li>What is your quest? <span tal:replace=\"view/request/form/step2_value|nothing\" /></li>\n        <li>What is your favorite color? <span tal:replace=\"view/request/form/step3_value|nothing\" /></li>\n        <li>What is the air-speed velocity of an unladen swallow? <span tal:replace=\"view/request/form/step4_value|nothing\" /></li>\n      </ul>\n    </div>\n\n    <span tal:replace=\"structure view/make_form_extras\" />\n  </form>\n\nAs told previously, this code is far from perfect, but shows how easy\nit is to navigate from one form to the other by returning the next\nmode in '_process_xxx_form' and overriding the 'cancel_mode' property.\n\nBut let's make it cleaner (again).\n\nSample 3.1: Navigating between mode again\n-----------------------------------------\n\nWe'll use the same template than for the previous view, but update a\nfew things:\n\n - the cancel message wil differ in each mode.\n\n - the cancel mode will be defined in the 'modes' dictionnary\n\n - the next mode to use will also be defined there.\n\n\nAs previously, we override the 'check_form' to avoid having to define a\n_check_stepx_form method for each step. We define empty methods to\nprocess each step::\n\n  class Sample31View(MultiModeView):\n      modes = {'step1': {'submit_label': 'Go to step 2',\n                         'cancel_label': 'Cancel',\n                         'success_mode': 'step2',\n                         'cancel_mode': 'step1',\n                         'cancel_msg': 'You can not go back, mwahaha'}},\n               'step2': {'submit_label': 'Go to step 3',\n                         'cancel_label': 'Back to step 1',\n                         'success_mode': 'step3',\n                         'cancel_mode': 'step1'},\n               'step3': {'submit_label': 'Go to step 4',\n                         'cancel_label': 'Back to step 2',\n                         'success_mode': 'step4',\n                         'cancel_mode': 'step2'},\n               'step4': {'submit_label': 'Go to step 5',\n                         'cancel_label': 'Back to step 3',\n                         'success_mode': 'step5',\n                         'cancel_mode': 'step3'},\n               'step5': {}}\n\n      default_mode = 'step1'\n      view_name = 'multimodeview_sample31'\n\n      def check_form(self):\n          return True\n\n      def _process_step1_form(self):\n          pass\n\n      def _process_step2_form(self):\n          pass\n\n      def _process_step3_form(self):\n          pass\n\n      def _process_step4_form(self):\n          pass\n\nYou might have seen that for step1, we also defined a\n'cancel_msg'. This has the same effect than 'success_msg' or\n'error_msg' shown in sample 2.1, except it is shown when the user cancels.\n\nSamples with viewlets\n=====================\n\nThere is currently no samples with the viewlets, for the good reason\nthat they work the exact same way than the views, except for two\npoints:\n\n - the class must inherit\n   collective.multimodeview.browser.MultiModeViewlet instead of\n   collective.multimodeview.browser.MultiModeView.\n - you must define a 'widget_id' attribute for the class, so there is\n   no conflict when processing the form on page that have multiple\n   viewlets defined.\n\nSamples will be added when the automated Ajax version for viewlets\nwill be integrated.\n\nChangelog\n=========\n\n\n0.3 (2015-08-27)\n----------------\n\n- Code cleanup.\n  [maurits]\n\n\n0.2 (2013-09-24)\n----------------\n\n- the 'add_portal_message' now only displays a message if there is\n  one. It allows for example to set an empty success message for a\n  given mode. [vincent]\n\n- added auto_process to mode. When declaring this kind of mode, the\n  form is automatically processed when switching to this\n  mode. [vincent]\n\n- added possibility for modes to automatically redirect to another\n  page. [vincent]\n\n\n0.1 (2011-02-25)\n----------------\n\n- added the possibility to define a custom label for the cancel button\n  and a custom cancel message for each mode. [vincent]\n\n- you can now defined the modes to swtich to once form is processed or\n  user cancelled in the 'modes' dictionnary. [vincent]\n\n- added samples + README. [vincent]\n\n- extracted code from Products.plonehrm. [vincent]", "description_content_type": null, "docs_url": null, "download_url": null, "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/zestsoftware/collective.multimodeview", "keywords": "multimode view", "license": "GPL", "maintainer": null, "maintainer_email": null, "name": "collective.multimodeview", "package_url": "https://pypi.org/project/collective.multimodeview/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/collective.multimodeview/", "project_urls": {"Homepage": "https://github.com/zestsoftware/collective.multimodeview"}, "release_url": "https://pypi.org/project/collective.multimodeview/0.3/", "requires_dist": null, "requires_python": null, "summary": "Simple package to manage views with multiple modes.", "version": "0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>collective.multimode view is a Plone package to ease creation of views\n(or viewlets) which can be in several states, for example a page\ncontaining a form or a guide with several steps.</p>\n<p>This products can not be used alone, you need to manually define the\npages has you would do usually when creating browser views.</p>\n<p>This README will show three simple examples on how to use the\nproduct. All samples can be found in the sources in the samples\ndirectory.</p>\n</div>\n<div id=\"compatibility\">\n<h2>Compatibility</h2>\n<p>This has been tested with Plone 3.3.5.</p>\n</div>\n<div id=\"samples-of-views\">\n<h2>Samples of views</h2>\n<div id=\"sample-1-a-simple-view-with-two-states\">\n<h3>Sample 1: a simple view with two states</h3>\n<p>Let\u2019s say you want to define a view that displays the conditions to\nuse the site  or the engagments you are taking with the data provided\nby the user.</p>\n<p>First we need to define the Python view:</p>\n<pre>from collective.multimodeview.browser import MultiModeView\n\nclass Sample1View(MultiModeView):\n    modes = ['conditions',\n             'data_use']\n    default_mode = 'conditions'\n    view_name = 'multimodeview_sample1'\n</pre>\n<p>\u2018modes\u2019 is the list of modes that the view can take. For simple cases, a\nlist is enough. The next samples will show the use of a dictionnary\nfor more complex cases.\n\u2018default_mode\u2019 is, as you can guess, the mode that will be displayed\nby default for this page.\n\u2018view_name\u2019 is the name of the view as defined in the zcml file (we\u2019ll\nsee it after). It is needed to be able to define the base url for the\npage or when using Ajax to fetch the content (mainly for viewlets).</p>\n<p>The second step is to define a template for our page:</p>\n<pre>&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:tal=\"http://xml.zope.org/namespaces/tal\"\n      xmlns:metal=\"http://xml.zope.org/namespaces/metal\"\n      xmlns:i18n=\"http://xml.zope.org/namespaces/i18n\"\n      metal:use-macro=\"here/main_template/macros/master\"\n      xml:lang=\"en\"\n      lang=\"en\"\n      i18n:domain=\"collective.multimodeview\"&gt;\n  &lt;body&gt;\n    &lt;div metal:fill-slot=\"main\"&gt;\n      &lt;div tal:condition=\"view/is_conditions_mode\"&gt;\n        &lt;p&gt;By using this site, you agree on the fact that you will\n        not do stupid things.&lt;/p&gt;\n\n        &lt;p class=\"discreet\"&gt;\n          &lt;a tal:attributes=\"href view/data_use_link\"&gt;See how we use your data&lt;/a&gt;\n        &lt;/p&gt;\n      &lt;/div&gt;\n      &lt;div tal:condition=\"view/is_data_use_mode\"&gt;\n        &lt;p&gt;We will sell your email to all known spam database, we need money.&lt;/p&gt;\n\n        &lt;p class=\"discreet\"&gt;\n          &lt;a tal:attributes=\"href view/conditions_link\"&gt;See the conditions to use the site&lt;/a&gt;\n        &lt;/p&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</pre>\n<p>With this example, we can see two examples of auto-generated\nattributes for the multimodeviews.\n\u2018is_conditions_mode\u2019: provides a boolean telling if the view is in the\n\u2018conditions\u2019 mode. For each mode you defined, you can use this\nshortcut (\u2018is_xxx_mode\u2019, where \u2018xxx\u2019 is the name defined for you\nmode).\n\u2018conditions_link\u2019: provides a link to swtich the page in \u2018conditions\u2019\nmode. This can be used for any mode, except if you have a mode called\n\u2018make\u2019 (it conflicts with the \u2018make_link\u2019 method). If you have a\n\u2018make\u2019 mode, then you\u2019ll have to manually use \u2018make_link\u2019 (that will\nbe described later).</p>\n<p>Now you can define your view in the zcml file:</p>\n<pre>&lt;browser:page\n    for=\"*\"\n    name=\"multimodeview_sample1\"\n    class=\".views.Sample1View\"\n    template=\"sample1.pt\"\n    permission=\"zope2.View\"\n    /&gt;\n</pre>\n<p>And that\u2019s all, you can now access this  view and switch between the\ntwo modes.</p>\n<p>Now let\u2019s go for something a bit more interresting.</p>\n</div>\n<div id=\"sample-2-playing-with-forms\">\n<h3>Sample 2: playing with forms</h3>\n<p>The first sample was pretty basic and could have been simply done by\nusing two pages or browser views.\nThe second example will show how to manage some data with a view. We\nwill add some annotations on the portal object (basically a simple\nlist of string). The view will be able to list, add, edit and delete\nthose notes.\nWe consider we have a view called \u2018multimodeview_notes_sample\u2019, that\nprovides an API to list, add, edit and delete notes (see\nsamples/notes_view.py).</p>\n<p>As usual, we first define the view:</p>\n<pre>class Sample2View(MultiModeView):\n    \"\"\" A view that adds annotations on the portal.\n    \"\"\"\n    modes = ['list',\n             'add',\n             'delete']\n    default_mode = 'list'\n    view_name = 'multimodeview_sample2'\n\n    @property\n    def notes_view(self):\n        return self.context.restrictedTraverse('@@multimodeview_notes_sample')\n\n    def _get_note_id(self):\n        \"\"\" Extracts the note_id from the form, cast it\n        to an int.\n        Returns None if there is no corresponding note.\n        \"\"\"\n\n    def _check_add_form(self):\n        if not self.request.form.get('title'):\n            self.errors['title'] = 'You must provide a title'\n\n        return True\n\n    def _check_edit_form(self):\n        if self._get_note_id() is None:\n            return\n\n        return self._check_add_form()\n\n    def _check_delete_form(self):\n        return self._get_note_id() is not None\n\n    def _process_add_form(self):\n        self.notes_view.add_note(self.request.form.get('title'))\n\n    def _process_edit_form(self):\n        self.notes_view.edit_note(\n            self._get_note_id(),\n            self.request.form.get('title'))\n\n    def _process_delete_form(self):\n        self.notes_view.delete_note(self._get_note_id())\n</pre>\n<p>Like for the previous example, we have defined our list of modes, the\ndefault mode and the name of the view.\nWe also defined some helpful functions (see the source for the\ncomplete code, I removed it from here to focus on the important part)\nto manage the notes.</p>\n<p>The important functions are _check_xxx_form and _process_xxx_form.</p>\n<p>The first one (_check_xxx_form) checks if the form submitted does not\ncontain errors. If an error is found, it is added to the \u2018errors\u2019\ndictionnary of the class, as we can see in \u2018_check_add_form\u2019 if the\ntitle is empty.\nThe method always returns True, except if something wrong hapenned to\nthe form (some fields have not been submitted, or a value that the\nuser can not change in normal use case is wrong). In this case, the\nmethod returns \u2018False\u2019 or None. A different message will be shown to\nthe user. We can see an example in \u2018_check_delete_form\u2019, which only\nchecks that the note_id provided is correct.</p>\n<p>The second one (_process_xxx_form) executes the code for the given\nmode. It is only called if the corresponding check method returned\nTrue and did not find any error.\nIf needed, it can return a \u2018mode\u2019 name so the view switch back to this\nmode once the form is proceeded. By default, it switches to the\ndefault mode.</p>\n<p>The second step is to define the template for this view. We first\ncreate the div (or whatever else) that is shown by default:</p>\n<pre>&lt;div tal:condition=\"view/is_list_mode\"&gt;\n  &lt;tal:block tal:define=\"notes view/notes_view/get_notes;\n                         note_exists python: bool([n for n in notes if n])\"&gt;\n    &lt;table class=\"listing\"\n           tal:condition=\"note_exists\"&gt;\n      &lt;thead&gt;\n        &lt;tr&gt;\n          &lt;th colspan=\"3\"&gt;\n            Notes\n          &lt;/th&gt;\n        &lt;/tr&gt;\n      &lt;/thead&gt;\n      &lt;tbody&gt;\n        &lt;tal:block tal:repeat=\"note python: enumerate(notes)\"&gt;\n          &lt;tr tal:define=\"note_id python: note[0];\n                          note_text python: note[1]\"\n              tal:condition=\"note_text\"&gt;\n            &lt;td tal:content=\"note_text\" /&gt;\n            &lt;td&gt;\n              &lt;a tal:attributes=\"href python: view.make_link('edit', {'note_id': note_id})\"\n                 title=\"edit this note\"&gt;\n                &lt;img tal:attributes=\"src python: '%s/edit.gif' % context.absolute_url()\"\n                     alt=\"edit\" /&gt;\n              &lt;/a&gt;\n            &lt;/td&gt;\n            &lt;td&gt;\n              &lt;a tal:attributes=\"href python: view.make_link('delete', {'note_id': note_id})\"\n                 title=\"delete this note\"&gt;\n                &lt;img tal:attributes=\"src python: '%s/delete_icon.gif' % context.absolute_url()\"\n                     alt=\"delete\" /&gt;\n              &lt;/a&gt;\n            &lt;/td&gt;\n          &lt;/tr&gt;\n        &lt;/tal:block&gt;\n      &lt;/tbody&gt;\n    &lt;/table&gt;\n\n    &lt;p tal:condition=\"not: note_exists\"&gt;\n      You do not have any notes for the moment.\n    &lt;/p&gt;\n\n    &lt;a tal:attributes=\"href view/add_link\"&gt;\n      Add a new note\n    &lt;/a&gt;\n  &lt;/tal:block&gt;\n&lt;/div&gt;\n</pre>\n<p>In this short sample, we can see the use of the \u2018make_link\u2019 method. We\nuse it to create the link to edit or delete a note. We could not use\n\u2018edit_link\u2019 or \u2018delete_link\u2019, as we also need to specify the note we\nwant to edit or delete.\nusing view.make_link(\u2018edit\u2019, {\u2018note_id\u2019: note_id}) will generate a\nlink like this: <a href=\"http://..../multimodeview_sample2?mode=edit&amp;note_id=2\" rel=\"nofollow\">http://\u2026./multimodeview_sample2?mode=edit&amp;note_id=2</a>.</p>\n<p>Now let\u2019s complete our template with the form to add a note:</p>\n<pre>&lt;div tal:condition=\"not: view/is_list_mode\"&gt;\n  &lt;form name=\"manage_notes_form\"\n        method=\"POST\"\n        tal:define=\"notes view/notes_view/get_notes;\n                    note_id view/_get_note_id;\n                    note_text python: (note_id is not None) and notes[note_id] or '';\"\n        tal:attributes=\"action view/get_form_action\"&gt;\n    &lt;tal:block tal:condition=\"view/is_add_mode\"&gt;\n      &lt;div tal:attributes=\"class python: view.class_for_field('title')\"&gt;\n        &lt;label for=\"title\"&gt;Title&lt;/label&gt;\n        &lt;div class=\"error_msg\"\n             tal:condition=\"view/errors/title|nothing\"\n             tal:content=\"view/errors/title\" /&gt;\n        &lt;input type=\"text\"\n               name=\"title\"\n               tal:attributes=\"value view/request/form/title | nothing\" /&gt;\n      &lt;/div&gt;\n\n      &lt;span tal:replace=\"structure view/make_form_extras\" /&gt;\n\n      &lt;input type=\"submit\"\n             name=\"form_submitted\"\n             value=\"Add note\" /&gt;\n      &lt;input type=\"submit\"\n             name=\"form_cancelled\"\n             value=\"Cancel\" /&gt;\n    &lt;/tal:block&gt;\n  &lt;/form&gt;\n&lt;/div&gt;\n</pre>\n<p>In this code we can see a few usefull methods provided by\nmultimodeview:</p>\n<blockquote>\n<ul>\n<li>\u2018view/get_for_action\u2019: provides the action that should be used for\nthe form.</li>\n<li>\u2018view.class_for_field(field)\u2019: this methods returns \u2018field\u2019 if\nthere is no error found for this field, or \u2018field error\u2019 if an error\nwas found. Those class names are the default ones provided by\nArchetype, so an error will appear in red with a default Plone theme.</li>\n<li>\u2018view/make_form_extras\u2019: this method should be used in every form\nin multimode page. It adds some hidden fields such as the mode\ncurrently is use.</li>\n</ul>\n</blockquote>\n<p>We can also see some specificities in the form:</p>\n<blockquote>\n<ul>\n<li>the method should always be \u2018POST\u2019: if you do not use a \u2018POST\u2019\nmethod, the form will not be processed.</li>\n<li>the submit input to process the form is called \u2018form_submitted\u2019.</li>\n<li>the sumbit input to cancel is called \u2018form_cancelled\u2019. If you use\nother names, the form will not be processed.</li>\n</ul>\n</blockquote>\n<p>We can now complete the template to also be able to manage the \u2018edit\u2019\nand \u2018delete\u2019 modes:</p>\n<pre>&lt;tal:block tal:condition=\"view/is_edit_mode\"&gt;\n  &lt;div tal:attributes=\"class python: view.class_for_field('title')\"&gt;\n    &lt;label for=\"title\"&gt;Title&lt;/label&gt;\n    &lt;div class=\"error_msg\"\n         tal:condition=\"view/errors/title|nothing\"\n         tal:content=\"view/errors/title\" /&gt;\n    &lt;input type=\"text\"\n           name=\"title\"\n           tal:attributes=\"value view/request/form/title | note_text\" /&gt;\n    &lt;input type=\"hidden\"\n           name=\"note_id\"\n           tal:attributes=\"value note_id\" /&gt;\n  &lt;/div&gt;\n\n  &lt;span tal:replace=\"structure view/make_form_extras\" /&gt;\n  &lt;input type=\"submit\"\n         name=\"form_submitted\"\n         value=\"Edit note\" /&gt;\n  &lt;input type=\"submit\"\n         name=\"form_cancelled\"\n         value=\"Cancel\" /&gt;\n&lt;/tal:block&gt;\n\n&lt;tal:block tal:condition=\"view/is_delete_mode\"&gt;\n  &lt;p&gt;Are you sure you want to delete this note ?&lt;/p&gt;\n  &lt;p class=\"discreet\" tal:content=\"note_text\" /&gt;\n\n  &lt;input type=\"hidden\"\n         name=\"note_id\"\n         tal:attributes=\"value note_id\" /&gt;\n\n  &lt;span tal:replace=\"structure view/make_form_extras\" /&gt;\n  &lt;input type=\"submit\"\n         name=\"form_submitted\"\n         value=\"Delete note\" /&gt;\n  &lt;input type=\"submit\"\n         name=\"form_cancelled\"\n         value=\"Cancel\" /&gt;\n&lt;/tal:block&gt;\n</pre>\n<p>Nothing really new in this new code but at least we are now able to\nmanage the notes.</p>\n<p>Now that the system is complete, we can see some problems incoming:</p>\n<blockquote>\n<ul>\n<li>there is some repetitions in the template code, mainly for the\nsubmit buttons. The one to cancel could be factorized but the one to\nprocess the form has a different name everytime.</li>\n<li>the messages always say \u2018Your changes have been saved\u2019, whatever\nyou do.</li>\n</ul>\n</blockquote>\n<p>Let\u2019s improve this quiclky.</p>\n</div>\n<div id=\"sample-2-1-using-a-dictionnary-for-modes\">\n<h3>Sample 2.1: using a dictionnary for modes</h3>\n<p>The two problems seen before can be quickly fixed when defining a list\nof modes with a dictionnary.</p>\n<p>Let\u2019s define the new view, inheriting from the prevous one:</p>\n<pre>class Sample21View(Sample2View):\n    \"\"\" A view that adds annotations on the portal.\n    \"\"\"\n    modes = {'list': {},\n             'add': {'success_msg': 'The note has been added',\n                     'error_msg': 'Impossible to add a note: please correct the form',\n                     'submit_label': 'Add note'},\n             'edit': {'success_msg': 'The note has been edited',\n                     'submit_label': 'Edit note'},\n             'delete': {'success_msg': 'The note has been deleted',\n                        'submit_label': 'Delete note'}\n             }\n\n    view_name = 'multimodeview_sample21'\n</pre>\n<p>As you can see, for each mode, a dictionnary is provided with three\nvalues:</p>\n<blockquote>\n<ul>\n<li>success_msg: the message displayed when the form is successfuly\nprocessed.</li>\n<li>error_msg: the message shown when errors are found in the form.</li>\n<li>submit_label: the title for the button to submit the form.</li>\n</ul>\n</blockquote>\n<p>Now we can also update our template. The part for listing the notes\ndoes not change, we only update the form:</p>\n<pre>&lt;form name=\"manage_notes_form\"\n      method=\"POST\"\n      tal:define=\"notes view/notes_view/get_notes;\n                  note_id view/_get_note_id;\n                  note_text python: (note_id is not None) and notes[note_id] or '';\"\n      tal:attributes=\"action view/get_form_action\"&gt;\n  &lt;tal:block tal:condition=\"view/is_add_mode\"&gt;\n    &lt;div tal:attributes=\"class python: view.class_for_field('title')\"&gt;\n      &lt;label for=\"title\"&gt;Title&lt;/label&gt;\n      &lt;div class=\"error_msg\"\n           tal:condition=\"view/errors/title|nothing\"\n           tal:content=\"view/errors/title\" /&gt;\n      &lt;input type=\"text\"\n             name=\"title\"\n             tal:attributes=\"value view/request/form/title | nothing\" /&gt;\n    &lt;/div&gt;\n  &lt;/tal:block&gt;\n\n  &lt;tal:block tal:condition=\"view/is_edit_mode\"&gt;\n    &lt;div tal:attributes=\"class python: view.class_for_field('title')\"&gt;\n      &lt;label for=\"title\"&gt;Title&lt;/label&gt;\n      &lt;div class=\"error_msg\"\n           tal:condition=\"view/errors/title|nothing\"\n           tal:content=\"view/errors/title\" /&gt;\n      &lt;input type=\"text\"\n             name=\"title\"\n             tal:attributes=\"value view/request/form/title | note_text\" /&gt;\n      &lt;input type=\"hidden\"\n             name=\"note_id\"\n             tal:attributes=\"value note_id\" /&gt;\n    &lt;/div&gt;\n  &lt;/tal:block&gt;\n\n  &lt;tal:block tal:condition=\"view/is_delete_mode\"&gt;\n    &lt;p&gt;Are you sure you want to delete this note ?&lt;/p&gt;\n    &lt;p class=\"discreet\" tal:content=\"note_text\" /&gt;\n\n    &lt;input type=\"hidden\"\n           name=\"note_id\"\n           tal:attributes=\"value note_id\" /&gt;\n  &lt;/tal:block&gt;\n\n  &lt;span tal:replace=\"structure view/make_form_extras\" /&gt;\n&lt;/form&gt;\n</pre>\n<p>As we can see, this version is much shorter than the previous one. We\ncould even have factorized the input for the title, but this has\nnothing to see with multimodeview, it is normal Zope/Plone/TAL coding.</p>\n<p>The question you may have now is \u201cWhere are my input defined ?\u201d. It is\nthe view/make_form_extras that creates them. If no label for the\nsubmit button is found, it will not show any button. If a label is\nfound, it automatically generates the two submit buttons.</p>\n</div>\n<div id=\"sample-3-creating-a-multi-step-form\">\n<h3>Sample 3: Creating a multi-step form</h3>\n<p>This last example shows how to handle a form in multiple steps. The\nmethod used here is not the best one, as we pass the data from one\npage to the other using hidden input. It would be better to use\nsession, cookies or even local storage for HTML5 fans, but the goal\nhere is more to shown how to navigate from one mode to another.</p>\n<p>As usual, we first define the view:</p>\n<pre>class Sample3View(MultiModeView):\n    modes = {'step1': {'submit_label': 'Go to step 2'},\n             'step2': {'submit_label': 'Go to step 3'},\n             'step3': {'submit_label': 'Go to step 4'},\n             'step4': {'submit_label': 'Go to step 5'},\n             'step5': {}}\n\n    default_mode = 'step1'\n    view_name = 'multimodeview_sample3'\n\n    def check_form(self):\n        return True\n\n    def _process_step1_form(self):\n        return 'step2'\n\n    def _process_step2_form(self):\n        return 'step3'\n\n    def _process_step3_form(self):\n        return 'step4'\n\n    def _process_step4_form(self):\n        return 'step5'\n\n    def _process_step5_form(self):\n        return 'step5'\n\n    @property\n    def cancel_mode(self):\n        mapping = {'step1': 'step1',\n                   'step2': 'step1',\n                   'step3': 'step2',\n                   'step4': 'step3',\n                   'step5': 'step4'}\n        return mapping.get(self.mode)\n</pre>\n<p>We have overriden the \u2018check_form\u2019 method so it always returns True\n(we do not really care about the values here).\nThe _process_xxx_form methods now returns the step to which the user\nis sent when completing the step. So once the 1st step is done, the\nsecond one is displayed and so on.</p>\n<p>The \u2018cancel_mode\u2019 attribute has been defined has a property, so the\nvalue can change depending on the current mode used by the view. You\ncan also define it has a simple attribute, but in this case it will\nalways return to the same mode when cancelling.</p>\n<p>Now we can define a simple template for our view:</p>\n<pre>&lt;form method=\"POST\"\n      tal:attributes=\"action view/get_form_action\"&gt;\n  &lt;input type=\"hidden\"\n         name=\"step1_value\"\n         tal:attributes=\"value view/request/form/step1_value|nothing\"\n         tal:condition=\"not: view/is_step1_mode\" /&gt;\n\n  &lt;input type=\"hidden\"\n         name=\"step2_value\"\n         tal:attributes=\"value view/request/form/step2_value|nothing\"\n         tal:condition=\"not: view/is_step2_mode\" /&gt;\n\n  &lt;input type=\"hidden\"\n         name=\"step3_value\"\n         tal:attributes=\"value view/request/form/step3_value|nothing\"\n         tal:condition=\"not: view/is_step3_mode\" /&gt;\n\n  &lt;input type=\"hidden\"\n         name=\"step4_value\"\n         tal:attributes=\"value view/request/form/step4_value|nothing\"\n         tal:condition=\"not: view/is_step4_mode\" /&gt;\n\n  &lt;div class=\"field\"\n       tal:condition=\"view/is_step1_mode\"&gt;\n    &lt;label for=\"step1\"&gt;What is your name?&lt;/label&gt;\n    &lt;input type=\"text\"\n           name=\"step1_value\"\n           tal:attributes=\"value view/request/form/step1_value|nothing\" /&gt;\n  &lt;/div&gt;\n\n  &lt;div class=\"field\"\n       tal:condition=\"view/is_step2_mode\"&gt;\n    &lt;label for=\"step1\"&gt;What is your quest?&lt;/label&gt;\n    &lt;input type=\"text\"\n           name=\"step2_value\"\n           tal:attributes=\"value view/request/form/step2_value|nothing\" /&gt;\n  &lt;/div&gt;\n\n  &lt;div class=\"field\"\n       tal:condition=\"view/is_step3_mode\"&gt;\n    &lt;label for=\"step1\"&gt;What is your favorite color?&lt;/label&gt;\n    &lt;input type=\"text\"\n           name=\"step3_value\"\n           tal:attributes=\"value view/request/form/step3_value|nothing\" /&gt;\n  &lt;/div&gt;\n\n  &lt;div class=\"field\"\n       tal:condition=\"view/is_step4_mode\"&gt;\n    &lt;label for=\"step1\"&gt;What is the air-speed velocity of an unladen swallow?&lt;/label&gt;\n    &lt;input type=\"text\"\n           name=\"step4_value\"\n           tal:attributes=\"value view/request/form/step4_value|nothing\" /&gt;\n  &lt;/div&gt;\n\n  &lt;div tal:condition=\"view/is_step5_mode\"&gt;\n    &lt;p&gt;Yer answers to the questions were:&lt;/p&gt;\n    &lt;ul&gt;\n      &lt;li&gt;What is your name? &lt;span tal:replace=\"view/request/form/step1_value|nothing\" /&gt;&lt;/li&gt;\n      &lt;li&gt;What is your quest? &lt;span tal:replace=\"view/request/form/step2_value|nothing\" /&gt;&lt;/li&gt;\n      &lt;li&gt;What is your favorite color? &lt;span tal:replace=\"view/request/form/step3_value|nothing\" /&gt;&lt;/li&gt;\n      &lt;li&gt;What is the air-speed velocity of an unladen swallow? &lt;span tal:replace=\"view/request/form/step4_value|nothing\" /&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n\n  &lt;span tal:replace=\"structure view/make_form_extras\" /&gt;\n&lt;/form&gt;\n</pre>\n<p>As told previously, this code is far from perfect, but shows how easy\nit is to navigate from one form to the other by returning the next\nmode in \u2018_process_xxx_form\u2019 and overriding the \u2018cancel_mode\u2019 property.</p>\n<p>But let\u2019s make it cleaner (again).</p>\n</div>\n<div id=\"sample-3-1-navigating-between-mode-again\">\n<h3>Sample 3.1: Navigating between mode again</h3>\n<p>We\u2019ll use the same template than for the previous view, but update a\nfew things:</p>\n<blockquote>\n<ul>\n<li>the cancel message wil differ in each mode.</li>\n<li>the cancel mode will be defined in the \u2018modes\u2019 dictionnary</li>\n<li>the next mode to use will also be defined there.</li>\n</ul>\n</blockquote>\n<p>As previously, we override the \u2018check_form\u2019 to avoid having to define a\n_check_stepx_form method for each step. We define empty methods to\nprocess each step:</p>\n<pre>class Sample31View(MultiModeView):\n    modes = {'step1': {'submit_label': 'Go to step 2',\n                       'cancel_label': 'Cancel',\n                       'success_mode': 'step2',\n                       'cancel_mode': 'step1',\n                       'cancel_msg': 'You can not go back, mwahaha'}},\n             'step2': {'submit_label': 'Go to step 3',\n                       'cancel_label': 'Back to step 1',\n                       'success_mode': 'step3',\n                       'cancel_mode': 'step1'},\n             'step3': {'submit_label': 'Go to step 4',\n                       'cancel_label': 'Back to step 2',\n                       'success_mode': 'step4',\n                       'cancel_mode': 'step2'},\n             'step4': {'submit_label': 'Go to step 5',\n                       'cancel_label': 'Back to step 3',\n                       'success_mode': 'step5',\n                       'cancel_mode': 'step3'},\n             'step5': {}}\n\n    default_mode = 'step1'\n    view_name = 'multimodeview_sample31'\n\n    def check_form(self):\n        return True\n\n    def _process_step1_form(self):\n        pass\n\n    def _process_step2_form(self):\n        pass\n\n    def _process_step3_form(self):\n        pass\n\n    def _process_step4_form(self):\n        pass\n</pre>\n<p>You might have seen that for step1, we also defined a\n\u2018cancel_msg\u2019. This has the same effect than \u2018success_msg\u2019 or\n\u2018error_msg\u2019 shown in sample 2.1, except it is shown when the user cancels.</p>\n</div>\n</div>\n<div id=\"samples-with-viewlets\">\n<h2>Samples with viewlets</h2>\n<p>There is currently no samples with the viewlets, for the good reason\nthat they work the exact same way than the views, except for two\npoints:</p>\n<blockquote>\n<ul>\n<li>the class must inherit\ncollective.multimodeview.browser.MultiModeViewlet instead of\ncollective.multimodeview.browser.MultiModeView.</li>\n<li>you must define a \u2018widget_id\u2019 attribute for the class, so there is\nno conflict when processing the form on page that have multiple\nviewlets defined.</li>\n</ul>\n</blockquote>\n<p>Samples will be added when the automated Ajax version for viewlets\nwill be integrated.</p>\n</div>\n<div id=\"changelog\">\n<h2>Changelog</h2>\n<div id=\"id1\">\n<h3>0.3 (2015-08-27)</h3>\n<ul>\n<li>Code cleanup.\n[maurits]</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>0.2 (2013-09-24)</h3>\n<ul>\n<li>the \u2018add_portal_message\u2019 now only displays a message if there is\none. It allows for example to set an empty success message for a\ngiven mode. [vincent]</li>\n<li>added auto_process to mode. When declaring this kind of mode, the\nform is automatically processed when switching to this\nmode. [vincent]</li>\n<li>added possibility for modes to automatically redirect to another\npage. [vincent]</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>0.1 (2011-02-25)</h3>\n<ul>\n<li>added the possibility to define a custom label for the cancel button\nand a custom cancel message for each mode. [vincent]</li>\n<li>you can now defined the modes to swtich to once form is processed or\nuser cancelled in the \u2018modes\u2019 dictionnary. [vincent]</li>\n<li>added samples + README. [vincent]</li>\n<li>extracted code from Products.plonehrm. [vincent]</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1695472, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "810cb7fe0fb1731ee2d70205149cd1b7", "sha256": "f39cf9d6178338691bca54da3a9cbff018275b2b8e34a0fa7cf423f89971d9ae"}, "downloads": -1, "filename": "collective.multimodeview-0.1.zip", "has_sig": false, "md5_digest": "810cb7fe0fb1731ee2d70205149cd1b7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52311, "upload_time": "2011-02-25T20:18:37", "upload_time_iso_8601": "2011-02-25T20:18:37.849599Z", "url": "https://files.pythonhosted.org/packages/34/0c/446d78584ebe2621106204211653ac4f866ad8b4b1d3259b7c59903a142e/collective.multimodeview-0.1.zip", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "f9ff5d04c696c597df6fc072cfcc6b0f", "sha256": "9e07318a63debed6491695be2d66d214e741604406cc662341f927f4b9865512"}, "downloads": -1, "filename": "collective.multimodeview-0.2.zip", "has_sig": false, "md5_digest": "f9ff5d04c696c597df6fc072cfcc6b0f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 56997, "upload_time": "2013-09-24T12:28:56", "upload_time_iso_8601": "2013-09-24T12:28:56.700859Z", "url": "https://files.pythonhosted.org/packages/5b/c9/37c669c9c5d4855bb13b2ba58b3dd6a8bda1355ba2ae89b81b23028f74e2/collective.multimodeview-0.2.zip", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "dce136410c7f7a1f8007eea50aa977d6", "sha256": "319f8abf2d058ed108188501da87395cc2aaddab7912717b2f4419c451c870aa"}, "downloads": -1, "filename": "collective.multimodeview-0.3.tar.gz", "has_sig": false, "md5_digest": "dce136410c7f7a1f8007eea50aa977d6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35384, "upload_time": "2015-08-26T23:01:51", "upload_time_iso_8601": "2015-08-26T23:01:51.030072Z", "url": "https://files.pythonhosted.org/packages/73/9e/ae019571baf614e8f45ed923af37c14d9111023d8497a76a1bd48f888218/collective.multimodeview-0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "dce136410c7f7a1f8007eea50aa977d6", "sha256": "319f8abf2d058ed108188501da87395cc2aaddab7912717b2f4419c451c870aa"}, "downloads": -1, "filename": "collective.multimodeview-0.3.tar.gz", "has_sig": false, "md5_digest": "dce136410c7f7a1f8007eea50aa977d6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35384, "upload_time": "2015-08-26T23:01:51", "upload_time_iso_8601": "2015-08-26T23:01:51.030072Z", "url": "https://files.pythonhosted.org/packages/73/9e/ae019571baf614e8f45ed923af37c14d9111023d8497a76a1bd48f888218/collective.multimodeview-0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:45:05 2020"}