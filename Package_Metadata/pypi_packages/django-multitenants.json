{"info": {"author": "Bernardo Ojengwa", "author_email": "bernardojengwa@gmail.com", "bugtrack_url": null, "classifiers": ["Framework :: Django", "License :: OSI Approved :: MIT License", "Programming Language :: Python"], "description": "django-tenant-schemas\n=====================\n\n|PyPi version| |PyPi downloads|\n\nThis application enables `django`_ powered websites to have multiple\ntenants via `PostgreSQL schemas`_. A vital feature for every\nSoftware-as-a-Service website.\n\nDjango provides currently no simple way to support multiple tenants\nusing the same project instance, even when only the data is different.\nBecause we don\u2019t want you running many copies of your project, you\u2019ll be\nable to have:\n\n-  Multiple customers running on the same instance\n-  Shared and Tenant-Specific data\n-  Tenant View-Routing\n\nWhat are schemas\n----------------\n\nA schema can be seen as a directory in an operating system, each\ndirectory (schema) with it\u2019s own set of files (tables and objects). This\nallows the same table name and objects to be used in different schemas\nwithout conflict. For an accurate description on schemas, see\n`PostgreSQL\u2019s official documentation on schemas`_.\n\nWhy schemas\n-----------\n\nThere are typically three solutions for solving the multitenancy\nproblem.\n\n1. Isolated Approach: Separate Databases. Each tenant has it\u2019s own\n   database.\n\n2. Semi Isolated Approach: Shared Database, Separate Schemas. One\n   database for all tenants, but one schema per tenant.\n\n3. Shared Approach: Shared Database, Shared Schema. All tenants share\n   the same database and schema. There is a main tenant-table, where all\n   other tables have a foreign key pointing to.\n\nThis application implements the second approach, which in our opinion,\nrepresents the ideal compromise between simplicity and performance.\n\n-  Simplicity: barely make any changes to your current code to support\n   multitenancy. Plus, you only manage one database.\n-  Performance: make use of shared connections, buffers and memory.\n\nEach solution has it\u2019s up and down sides, for a more in-depth\ndiscussion, see Microsoft\u2019s excellent article on `Multi-Tenant Data\nArchitecture`_.\n\nHow it works\n------------\n\nTenants are identified via their host name (i.e tenant.domain.com). This\ninformation is stored on a table on the ``public`` schema. Whenever a\nrequest is made, the host name is used to match a tenant in the\ndatabase. If there\u2019s a match, the search path is updated to use this\ntenant\u2019s schema. So from now on all queries will take place at the\ntenant\u2019s schema. For example, suppose you have a tenant ``customer`` at\nhttp://customer.example.com. Any request incoming at\n``customer.example.com`` will automatically use ``customer``\\ \u2019s schema\nand make the tenant available at the request. If no tenant is found, a\n404 error is raised. This also means you should have a tenant for your\nmain domain, typically using the ``public`` schema. For more information\nplease read the `setup`_ section.\n\nWhat can this app do?\n---------------------\n\nAs many tenants as you want\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nEach tenant has its data on a specific schema. Use a single project\ninstance to serve as many as you want.\n\nTenant-specific and shared apps\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nTenant-specific apps do not share their data between tenants, but you\ncan also have shared apps where the information is always available and\nshared between all.\n\nTenant View-Routing\n~~~~~~~~~~~~~~~~~~~\n\nYou can have different views for ``http://customer.example.com/`` and\n``http://example.com/``, even though Django only uses the string after\nthe host name to identify which view to serve.\n\nMagic\n~~~~~\n\nEveryone loves magic! You\u2019ll be able to have all this barely having to\nchange your code!\n\nSetup & Documentation\n---------------------\n\n**This is just a short setup guide**, it is **strongly** recommended\nthat you read the complete version at\n`django-tenant-schemas.readthedocs.org`_.\n\nYour ``DATABASE_ENGINE`` setting needs to be changed to\n\n.. code-block:: python\n\n    DATABASES = {\n        'default': {\n            'ENGINE': 'tenant_schemas.postgresql_backend',\n            # ..\n        }\n    }    \n\nAdd the middleware ``tenant_schemas.middleware.TenantMiddleware`` to the\ntop of ``MIDDLEWARE_CLASSES``, so that each request can be set to use\nthe correct schema.\n\n.. code-block:: python\n\n    MIDDLEWARE_CLASSES = (\n        'tenant_schemas.middleware.TenantMiddleware',\n        #...\n    )\n    \nAdd ``tenant_schemas.routers.TenantSyncRouter`` to your `DATABASE_ROUTERS` \nsetting, so that the correct apps can be synced, depending on what's \nbeing synced (shared or tenant).\n\n.. code-block:: python\n\n    DATABASE_ROUTERS = (\n        'tenant_schemas.routers.TenantSyncRouter',\n    )\n\nAdd ``tenant_schemas`` to your ``INSTALLED_APPS``.\n\nCreate your tenant model\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block:: python\n\n    from django.db import models\n    from tenant_schemas.models import TenantMixin\n\n    class Client(TenantMixin):\n        name = models.CharField(max_length=100)\n        paid_until =  models.DateField()\n        on_trial = models.BooleanField()\n        created_on = models.DateField(auto_now_add=True)\n\nDefine on ``settings.py`` which model is your tenant model. Assuming you\ncreated ``Client`` inside an app named ``customers``, your\n``TENANT_MODEL`` should look like this:\n\n.. code-block:: python\n\n    TENANT_MODEL = \"customers.Client\" # app.Model\n\nNow run ``migrate_schemas`` (``sync_schemas`` if you're on Django 1.6 and older), \nthis will sync your apps to the ``public`` schema.\n\n::\n\n    python manage.py migrate_schemas --shared\n\nCreate your tenants just like a normal django model. Calling ``save``\nwill automatically create and sync/migrate the schema.\n\n.. code-block:: python\n\n    from customers.models import Client\n\n    # create your public tenant\n    tenant = Client(domain_url='tenant.my-domain.com',\n                    schema_name='tenant1',\n                    name='My First Tenant',\n                    paid_until='2014-12-05',\n                    on_trial=True)\n    tenant.save()\n\nAny request made to ``tenant.my-domain.com`` will now automatically set\nyour PostgreSQL\u2019s ``search_path`` to ``tenant1`` and ``public``, making\nshared apps available too. This means that any call to the methods\n``filter``, ``get``, ``save``, ``delete`` or any other function\ninvolving a database connection will now be done at the tenant\u2019s schema,\nso you shouldn\u2019t need to change anything at your views.\n\nYou\u2019re all set, but we have left key details outside of this short\ntutorial, such as creating the public tenant and configuring shared and\ntenant specific apps. Complete instructions can be found at\n`django-tenant-schemas.readthedocs.org`_.\n\n\n\n.. _django: https://www.djangoproject.com/\n.. _PostgreSQL schemas: http://www.postgresql.org/docs/9.1/static/ddl-schemas.html\n.. _PostgreSQL\u2019s official documentation on schemas: http://www.postgresql.org/docs/9.1/static/ddl-schemas.html\n.. _Multi-Tenant Data Architecture: http://msdn.microsoft.com/en-us/library/aa479086.aspx\n\n.. |PyPi version| image:: https://img.shields.io/pypi/v/django-tenant-schemas.svg\n   :target: https://pypi.python.org/pypi/django-tenant-schemas\n.. |PyPi downloads| image:: https://img.shields.io/pypi/dm/django-tenant-schemas.svg\n   :target: https://pypi.python.org/pypi/django-tenant-schemas\n.. _setup: https://django-tenant-schemas.readthedocs.org/en/latest/install.html\n.. _django-tenant-schemas.readthedocs.org: https://django-tenant-schemas.readthedocs.org/en/latest/", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ojengwa/django-multitenants.git", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "django-multitenants", "package_url": "https://pypi.org/project/django-multitenants/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/django-multitenants/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/ojengwa/django-multitenants.git"}, "release_url": "https://pypi.org/project/django-multitenants/1.0.0/", "requires_dist": null, "requires_python": null, "summary": "Tenant support for Django using PostgreSQL schemas. Supports url patterns as well as sub-domains. Inspired by django-tenant-schemas.", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://pypi.python.org/pypi/django-tenant-schemas\" rel=\"nofollow\"><img alt=\"PyPi version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/496454b8c912c292ef81f0d3783126b556bb50e3/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f646a616e676f2d74656e616e742d736368656d61732e737667\"></a> <a href=\"https://pypi.python.org/pypi/django-tenant-schemas\" rel=\"nofollow\"><img alt=\"PyPi downloads\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/81d1eec0a08d4612c02782f4223a78a0a536f712/68747470733a2f2f696d672e736869656c64732e696f2f707970692f646d2f646a616e676f2d74656e616e742d736368656d61732e737667\"></a></p>\n<p>This application enables <a href=\"https://www.djangoproject.com/\" rel=\"nofollow\">django</a> powered websites to have multiple\ntenants via <a href=\"http://www.postgresql.org/docs/9.1/static/ddl-schemas.html\" rel=\"nofollow\">PostgreSQL schemas</a>. A vital feature for every\nSoftware-as-a-Service website.</p>\n<p>Django provides currently no simple way to support multiple tenants\nusing the same project instance, even when only the data is different.\nBecause we don\u2019t want you running many copies of your project, you\u2019ll be\nable to have:</p>\n<ul>\n<li>Multiple customers running on the same instance</li>\n<li>Shared and Tenant-Specific data</li>\n<li>Tenant View-Routing</li>\n</ul>\n<div id=\"what-are-schemas\">\n<h2>What are schemas</h2>\n<p>A schema can be seen as a directory in an operating system, each\ndirectory (schema) with it\u2019s own set of files (tables and objects). This\nallows the same table name and objects to be used in different schemas\nwithout conflict. For an accurate description on schemas, see\n<a href=\"http://www.postgresql.org/docs/9.1/static/ddl-schemas.html\" rel=\"nofollow\">PostgreSQL\u2019s official documentation on schemas</a>.</p>\n</div>\n<div id=\"why-schemas\">\n<h2>Why schemas</h2>\n<p>There are typically three solutions for solving the multitenancy\nproblem.</p>\n<ol>\n<li>Isolated Approach: Separate Databases. Each tenant has it\u2019s own\ndatabase.</li>\n<li>Semi Isolated Approach: Shared Database, Separate Schemas. One\ndatabase for all tenants, but one schema per tenant.</li>\n<li>Shared Approach: Shared Database, Shared Schema. All tenants share\nthe same database and schema. There is a main tenant-table, where all\nother tables have a foreign key pointing to.</li>\n</ol>\n<p>This application implements the second approach, which in our opinion,\nrepresents the ideal compromise between simplicity and performance.</p>\n<ul>\n<li>Simplicity: barely make any changes to your current code to support\nmultitenancy. Plus, you only manage one database.</li>\n<li>Performance: make use of shared connections, buffers and memory.</li>\n</ul>\n<p>Each solution has it\u2019s up and down sides, for a more in-depth\ndiscussion, see Microsoft\u2019s excellent article on <a href=\"http://msdn.microsoft.com/en-us/library/aa479086.aspx\" rel=\"nofollow\">Multi-Tenant Data\nArchitecture</a>.</p>\n</div>\n<div id=\"how-it-works\">\n<h2>How it works</h2>\n<p>Tenants are identified via their host name (i.e tenant.domain.com). This\ninformation is stored on a table on the <tt>public</tt> schema. Whenever a\nrequest is made, the host name is used to match a tenant in the\ndatabase. If there\u2019s a match, the search path is updated to use this\ntenant\u2019s schema. So from now on all queries will take place at the\ntenant\u2019s schema. For example, suppose you have a tenant <tt>customer</tt> at\n<a href=\"http://customer.example.com\" rel=\"nofollow\">http://customer.example.com</a>. Any request incoming at\n<tt>customer.example.com</tt> will automatically use <tt>customer</tt>\u2019s schema\nand make the tenant available at the request. If no tenant is found, a\n404 error is raised. This also means you should have a tenant for your\nmain domain, typically using the <tt>public</tt> schema. For more information\nplease read the <a href=\"https://django-tenant-schemas.readthedocs.org/en/latest/install.html\" rel=\"nofollow\">setup</a> section.</p>\n</div>\n<div id=\"what-can-this-app-do\">\n<h2>What can this app do?</h2>\n<div id=\"as-many-tenants-as-you-want\">\n<h3>As many tenants as you want</h3>\n<p>Each tenant has its data on a specific schema. Use a single project\ninstance to serve as many as you want.</p>\n</div>\n<div id=\"tenant-specific-and-shared-apps\">\n<h3>Tenant-specific and shared apps</h3>\n<p>Tenant-specific apps do not share their data between tenants, but you\ncan also have shared apps where the information is always available and\nshared between all.</p>\n</div>\n<div id=\"tenant-view-routing\">\n<h3>Tenant View-Routing</h3>\n<p>You can have different views for <tt><span class=\"pre\">http://customer.example.com/</span></tt> and\n<tt><span class=\"pre\">http://example.com/</span></tt>, even though Django only uses the string after\nthe host name to identify which view to serve.</p>\n</div>\n<div id=\"magic\">\n<h3>Magic</h3>\n<p>Everyone loves magic! You\u2019ll be able to have all this barely having to\nchange your code!</p>\n</div>\n</div>\n<div id=\"setup-documentation\">\n<h2>Setup &amp; Documentation</h2>\n<p><strong>This is just a short setup guide</strong>, it is <strong>strongly</strong> recommended\nthat you read the complete version at\n<a href=\"https://django-tenant-schemas.readthedocs.org/en/latest/\" rel=\"nofollow\">django-tenant-schemas.readthedocs.org</a>.</p>\n<p>Your <tt>DATABASE_ENGINE</tt> setting needs to be changed to</p>\n<pre><span class=\"n\">DATABASES</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'default'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'ENGINE'</span><span class=\"p\">:</span> <span class=\"s1\">'tenant_schemas.postgresql_backend'</span><span class=\"p\">,</span>\n        <span class=\"c1\"># ..</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n<p>Add the middleware <tt>tenant_schemas.middleware.TenantMiddleware</tt> to the\ntop of <tt>MIDDLEWARE_CLASSES</tt>, so that each request can be set to use\nthe correct schema.</p>\n<pre><span class=\"n\">MIDDLEWARE_CLASSES</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n    <span class=\"s1\">'tenant_schemas.middleware.TenantMiddleware'</span><span class=\"p\">,</span>\n    <span class=\"c1\">#...</span>\n<span class=\"p\">)</span>\n</pre>\n<p>Add <tt>tenant_schemas.routers.TenantSyncRouter</tt> to your <cite>DATABASE_ROUTERS</cite>\nsetting, so that the correct apps can be synced, depending on what\u2019s\nbeing synced (shared or tenant).</p>\n<pre><span class=\"n\">DATABASE_ROUTERS</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n    <span class=\"s1\">'tenant_schemas.routers.TenantSyncRouter'</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n</pre>\n<p>Add <tt>tenant_schemas</tt> to your <tt>INSTALLED_APPS</tt>.</p>\n<div id=\"create-your-tenant-model\">\n<h3>Create your tenant model</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">django.db</span> <span class=\"kn\">import</span> <span class=\"n\">models</span>\n<span class=\"kn\">from</span> <span class=\"nn\">tenant_schemas.models</span> <span class=\"kn\">import</span> <span class=\"n\">TenantMixin</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Client</span><span class=\"p\">(</span><span class=\"n\">TenantMixin</span><span class=\"p\">):</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n    <span class=\"n\">paid_until</span> <span class=\"o\">=</span>  <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">DateField</span><span class=\"p\">()</span>\n    <span class=\"n\">on_trial</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">BooleanField</span><span class=\"p\">()</span>\n    <span class=\"n\">created_on</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">DateField</span><span class=\"p\">(</span><span class=\"n\">auto_now_add</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>Define on <tt>settings.py</tt> which model is your tenant model. Assuming you\ncreated <tt>Client</tt> inside an app named <tt>customers</tt>, your\n<tt>TENANT_MODEL</tt> should look like this:</p>\n<pre><span class=\"n\">TENANT_MODEL</span> <span class=\"o\">=</span> <span class=\"s2\">\"customers.Client\"</span> <span class=\"c1\"># app.Model</span>\n</pre>\n<p>Now run <tt>migrate_schemas</tt> (<tt>sync_schemas</tt> if you\u2019re on Django 1.6 and older),\nthis will sync your apps to the <tt>public</tt> schema.</p>\n<pre>python manage.py migrate_schemas --shared\n</pre>\n<p>Create your tenants just like a normal django model. Calling <tt>save</tt>\nwill automatically create and sync/migrate the schema.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">customers.models</span> <span class=\"kn\">import</span> <span class=\"n\">Client</span>\n\n<span class=\"c1\"># create your public tenant</span>\n<span class=\"n\">tenant</span> <span class=\"o\">=</span> <span class=\"n\">Client</span><span class=\"p\">(</span><span class=\"n\">domain_url</span><span class=\"o\">=</span><span class=\"s1\">'tenant.my-domain.com'</span><span class=\"p\">,</span>\n                <span class=\"n\">schema_name</span><span class=\"o\">=</span><span class=\"s1\">'tenant1'</span><span class=\"p\">,</span>\n                <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'My First Tenant'</span><span class=\"p\">,</span>\n                <span class=\"n\">paid_until</span><span class=\"o\">=</span><span class=\"s1\">'2014-12-05'</span><span class=\"p\">,</span>\n                <span class=\"n\">on_trial</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">tenant</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">()</span>\n</pre>\n<p>Any request made to <tt><span class=\"pre\">tenant.my-domain.com</span></tt> will now automatically set\nyour PostgreSQL\u2019s <tt>search_path</tt> to <tt>tenant1</tt> and <tt>public</tt>, making\nshared apps available too. This means that any call to the methods\n<tt>filter</tt>, <tt>get</tt>, <tt>save</tt>, <tt>delete</tt> or any other function\ninvolving a database connection will now be done at the tenant\u2019s schema,\nso you shouldn\u2019t need to change anything at your views.</p>\n<p>You\u2019re all set, but we have left key details outside of this short\ntutorial, such as creating the public tenant and configuring shared and\ntenant specific apps. Complete instructions can be found at\n<a href=\"https://django-tenant-schemas.readthedocs.org/en/latest/\" rel=\"nofollow\">django-tenant-schemas.readthedocs.org</a>.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 2008982, "releases": {"1.0.0": []}, "urls": [], "timestamp": "Fri May  8 00:55:47 2020"}