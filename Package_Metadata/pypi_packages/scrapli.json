{"info": {"author": "Carl Montanari", "author_email": "carl.r.montanari@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: MacOS", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "![](https://github.com/carlmontanari/scrapli/workflows/Weekly%20Build/badge.svg)\n[![PyPI version](https://badge.fury.io/py/scrapli.svg)](https://badge.fury.io/py/scrapli)\n[![Python 3.6](https://img.shields.io/badge/python-3.6-blue.svg)](https://www.python.org/downloads/release/python-360/)\n[![Python 3.7](https://img.shields.io/badge/python-3.7-blue.svg)](https://www.python.org/downloads/release/python-370/)\n[![Python 3.8](https://img.shields.io/badge/python-3.8-blue.svg)](https://www.python.org/downloads/release/python-380/)\n[![Code Style](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/ambv/black)\n\n\nscrapli\n=======\n\nscrapli -- scrap(e c)li --  is a python library focused on connecting to devices, specifically network devices\n (routers/switches/firewalls/etc.) via SSH or Telnet. The name scrapli -- is just \"scrape cli\" (as in screen scrape)\n squished together! scrapli's goal is to be as fast and flexible as possible, while providing a thoroughly tested, well\n  typed, well documented, simple API.\n\n\n# Table of Contents\n\n- [Quick Start Guide](#quick-start-guide)\n  - [Installation](#installation)\n  - [A Simple Example](#a-simple-example)\n  - [More Examples](#more-examples)\n- [scrapli: What is it](#scrapli-what-is-it)\n- [Documentation](#documentation)\n- [Supported Platforms](#supported-platforms)\n- [Advanced Installation](#advanced-installation)\n- [Basic Usage](#basic-usage)\n  - [Picking the right Driver](#picking-the-right-driver)\n  - [Basic Driver Arguments](#basic-driver-arguments)\n  - [Opening and Closing a Connection](#opening-and-closing-a-connection)\n  - [Sending Commands](#sending-commands)\n  - [Response Object](#response-object)\n  - [Sending Configurations](#sending-configurations)\n  - [Textfsm/NTC-Templates Integration](#textfsmntc-templates-integration)\n  - [Cisco Genie Integration](#cisco-genie-integration)\n  - [Handling Prompts](#handling-prompts)\n  - [Telnet](#telnet)\n  - [SSH Config Support](#ssh-config-support)\n- [Advanced Usage](#advanced-usage)\n  - [All Driver Arguments](#all-driver-arguments)\n  - [Platform Regex](#platform-regex)\n  - [On Open](#on-open)\n  - [On Close](#on-close)\n  - [Timeouts](#timeouts)\n  - [Driver Privilege Levels](#driver-privilege-levels)\n  - [Using Scrape Directly](#using-scrape-directly)\n  - [Using the GenericDriver](#using-the-genericdriver)\n  - [Using a Different Transport](#using-a-different-transport)\n  - [Auth Bypass](#auth-bypass)\n  - [Transport Options](#transport-options)\n- [FAQ](#faq)\n- [Transport Notes, Caveats, and Known Issues](#transport-notes-caveats-and-known-issues)\n  - [Paramiko](#paramiko)\n  - [SSH2-Python](#ssh2-python)\n  - [System SSH](#system)\n  - [Telnet](#telnet)\n- [Linting and Testing](#linting-and-testing)\n  - [Linting](#linting)\n  - [Testing](#testing)\n- [Todo and Roadmap](#todo-and-roadmap)\n  - [Todo](#todo)\n  - [Roadmap](#roadmap)\n\n\n# Quick Start Guide\n\n## Installation\n\nIn most cases installation via pip is the simplest and best way to install scrapli.\nSee below or [here](#advanced-installation) for advanced installation details.\n\n```\npip install scrapli\n```\n\n## A Simple Example\n\n```python\nfrom scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nconn = IOSXEDriver(**my_device)\nconn.open()\nresponse = conn.send_command(\"show run\")\nprint(response.result)\n```\n\n```\n$ python my_scrapli_script.py\nBuilding configuration...\n\nCurrent configuration : 7584 bytes\n!\n! Last configuration change at 19:24:38 PST Sat Feb 29 2020 by carl\n! NVRAM config last updated at 19:00:28 PST Fri Feb 7 2020 by carl\n!\nversion 15.2\nservice nagle\nno service pad\nservice tcp-keepalives-in\nservice tcp-keepalives-out\nservice timestamps debug datetime msec\nno service password-encryption\n!\n<SNIP>\n!\nend\n```\n\n## More Examples\n\n- [Basic \"native\" Scrape operations](/examples/basic_usage/scrapli_driver.py)\n- [Basic \"GenericDriver\" operations](/examples/basic_usage/generic_driver.py)\n- [Basic \"core\" Driver operations](/examples/basic_usage/iosxe_driver.py)\n- [Setting up basic logging](/examples/logging/basic_logging.py)\n- [Using SSH Key for authentication](/examples/ssh_keys/ssh_keys.py)\n- [Using SSH config file](/examples/ssh_config_files/ssh_config_file.py)\n- [Parse output with TextFSM/ntc-templates](/examples/structured_data/structured_data_textfsm.py)\n- [Parse output with Genie](/examples/structured_data/structured_data_genie.py)\n- [Transport Options](examples/transport_options/system_ssh_args.py)\n\n\n# scrapli: What is it\n\nAs stated, scrapli is a python library focused on connecting to devices, specifically network devices via SSH or Telnet.\n\nscrapli is built primarily in three parts: transport, channel, and driver. The transport layer is responsible for\n providing a file-like interface to the target server. The channel layer is responsible for reading and writing\n  to the provided file-like interface. Finally, the driver provides the user facing API/interface to scrapli.\n\nThere are two available \"transports\" in scrapli \"core\" -- both of which inherit from a base transport class\n and provide the same file-like interface to the upstream channel. There are also (currently!) two transport plugins\n  available -- both of which are installable as optional extras. The transport options are:\n\n- [paramiko](https://github.com/paramiko/paramiko) (optional extra)\n- [ssh2-python](https://github.com/ParallelSSH/ssh2-python) (optional extra)\n- OpenSSH/System available SSH\n- telnetlib\n\nA good question to ask at this point is probably \"why?\". Why multiple transport options? Why not just use paramiko\n like most folks do? Historically the reason for moving away from paramiko was simply speed. ssh2-python is a wrapper\n  around the libssh2 C library, and as such is very very fast. In a prior project\n   ([ssh2net](https://github.com/carlmontanari/ssh2net)), of which scrapli is the successor/evolution, ssh2-python\n    was used with great success, however, it is a bit feature-limited, and development seems to have stalled.\n\nThis led to moving back to paramiko, which of course is a fantastic project with tons and tons of feature support\n. Paramiko, however, does not provide \"direct\" OpenSSH support (as in -- auto-magically like when you ssh on your\n normal shell), and I don't believe it provides 100% full OpenSSH support either (ex: ControlPersist). Fully\n  supporting an OpenSSH config file would be an ideal end goal for scrapli, something that may not be possible with\n   Paramiko - ControlPersist in particular is very interesting to me.\n\nWith the goal of supporting all of the OpenSSH configuration options the primary transport driver option is simply\n native system local SSH. The implementation of using system SSH is of course a little bit messy, however scrapli\n  takes care of that for you so you don't need to care about it! The payoff of using system SSH is of course that\n   OpenSSH config files simply \"work\" -- no passing it to scrapli, no selective support, no need to set username or\n    ports or any of the other config items that may reside in your SSH config file. This driver will likely be the\n     focus of most development for this project, though I will try to keep the other transport drivers -- in\n      particular ssh2-python -- as close to parity as is possible/practical.\n\nThe last transport is telnet via telnetlib. This was trivial to add in as the interface is basically the same as\n SystemSSH, and it turns out telnet is still actually useful for things like terminal servers and the like!\n\nThe final piece of scrapli is the actual \"driver\" -- or the component that binds the transport and channel together and\n deals with instantiation of an scrapli object. There is a \"base\" driver object -- `Scrape` -- which provides essentially\n  a \"raw\" SSH (or telnet) connection that is created by instantiating a Transport object, and a Channel object\n  . `Scrape` provides (via Channel) read/write methods and not much else -- this should feel familiar if you have\n   used paramiko in the past. More specific \"drivers\" can inherit from this class to extend functionality of the\n    driver to make it more friendly for network devices. In fact, there is a `GenericDriver` class that inherits from\n     `Scrape` and provides a base driver to work with if you need to interact with a device not represented by one of\n      the \"core\" drivers. Next, the `NetworkDriver` abstract base class inherits from `GenericDriver` This\n       `NetworkDriver` isn't really meant to be used directly though (hence why it is an ABC), but to be further\n        extended and built upon instead. As this library is focused on interacting with network devices, an example\n         scrapli driver (built on the `NetworkDriver`) would be the `IOSXEDriver` -- to, as you may have guessed\n         , interact with devices running Cisco's IOS-XE operating system.\n\n\n# Documentation\n\nDocumentation is auto-generated [using pdoc3](https://github.com/pdoc3/pdoc). Documentation is linted (see Linting and\n Testing section) via [pydocstyle](https://github.com/PyCQA/pydocstyle/) and\n [darglint](https://github.com/terrencepreilly/darglint).\n\nDocumentation is hosted via GitHub Pages and can be found\n[here](https://carlmontanari.github.io/scrapli/docs/scrapli/index.html). You can also view this readme as a web page\n [here](https://carlmontanari.github.io/scrapli/).\n\nTo regenerate documentation locally, use the following make command:\n\n```\nmake docs\n```\n\n\n# Supported Platforms\n\nscrapli \"core\" drivers cover basically the [NAPALM](https://github.com/napalm-automation/napalm) platforms -- Cisco\n IOS-XE, IOS-XR, NX-OS, Arista EOS, and Juniper JunOS. These drivers provide an interface tailored to network device\n  \"screen-scraping\" rather than just a generic SSH connection/channel. Below are the core driver platforms and\n   currently tested version.\n\n- Cisco IOS-XE (tested on: 16.04.01)\n- Cisco NX-OS (tested on: 9.2.4)\n- Juniper JunOS (tested on: 17.3R2.10)\n- Cisco IOS-XR (tested on: 6.5.3)\n- Arista EOS (tested on: 4.22.1F)\n\nIn the future it would be possible for folks to contribute additional \"community\" drivers, however, is unlikely that any\n additional \"core\" platforms would be added.\n\nThe \"driver\" pattern is pretty much exactly like the implementation in NAPALM. The driver extends the base class\n (`Scrape`) and the base networking driver class (`NetworkDriver`) with device specific functionality such as privilege\n  escalation/de-escalation, setting appropriate prompts to search for, and picking out appropriate\n  [ntc templates](https://github.com/networktocode/ntc-templates) for use with TextFSM, and so on.\n\nAll of this is focused on network device type Telnet/SSH cli interfaces, but should work on pretty much any SSH\n connection (though there are almost certainly better options for non-network type devices!). The \"base\" (`Scrape\n `) and `GenericDriver` connections do not handle any kind of device-specific operations such as privilege\n  escalation or saving configurations, they are simply intended to be a bare bones connection that can interact with\n   nearly any device/platform if you are willing to send/parse inputs/outputs manually. In most cases it is assumed\n    that users will use one of the \"core\" drivers.\n\nThe goal for all \"core\" devices will be to include functional tests that can run against\n[vrnetlab](https://github.com/plajjan/vrnetlab) containers to ensure that the \"core\" devices are as thoroughly tested\n as is practical. \n\n\n# Advanced Installation\n\nAs outlined in the quick start, you should be able to pip install scrapli \"normally\":\n\n```\npip install scrapli\n```\n\nTo install from this repositories master branch:\n\n```\npip install git+https://github.com/carlmontanari/scrapli\n```\n\nTo install from this repositories develop branch:\n\n```\npip install -e git+https://github.com/carlmontanari/scrapli.git@develop#egg=scrapli\n```\n\nTo install from source:\n\n```\ngit clone https://github.com/carlmontanari/scrapli\ncd scrapli\npython setup.py install\n```\n\nscrapli has made an effort to have as few dependencies as possible -- in fact to have ZERO dependencies! The \"core\" of\n scrapli can run with nothing other than standard library! If for any reason you wish to use paramiko or ssh2-python\n  as a driver, however, you of course need to install those. These \"extras\" can be installed via pip:\n\n```\npip install scrapli[paramiko]\n```\n\nThe available optional installation extras options are:\n\n- paramiko (paramiko and the scrapli_paramiko transport)\n- ssh2 (ssh2-python and the scrapli_ssh2 transport)\n- textfsm (textfsm and ntc-templates)\n- genie (genie/pyats)\n\nAs for platforms to *run* scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any\n POSIX system. Windows is now being tested very minimally via GitHub Actions builds, however it is important to note\n  that if you wish to use Windows you will need to use paramiko or ssh2-python as the transport driver. It is\n   *strongly* recommended/preferred for folks to use WSL/Cygwin and stick with \"system\" as the transport. \n\n\n# Basic Usage\n\n## Picking the right Driver\n\nAssuming you are using scrapli to connect to one of the five \"core\" platforms, you should almost always use the\n provided corresponding \"core\" driver. For example if you are connecting to an Arista EOS device, you should use the\n  `EOSDriver`:\n\n```python\nfrom scrapli.driver.core import EOSDriver\n```\n\nThe core drivers and associated platforms are outlined below:\n\n| Platform/OS   | Scrapli Driver  |\n|---------------|-----------------|\n| Cisco IOS-XE  | IOSXEDriver     |\n| Cisco NX-OS   | NXOSDriver      |\n| Cisco IOS-XR  | IOSXRDriver     |\n| Arista EOS    | EOSDriver       |\n| Juniper JunOS | JunosDriver     |\n\nAll drivers can be imported from `scrapli.driver.core`.\n\nIf you are working with a platform not listed above, you have two options: you can use the `Scrape` driver directly\n, which you can read about [here](#using-scrape-directly) or you can use the `GenericDriver` which which you can read\n about [here](#using-the-genericdriver). In general you should probably use the `GenericDriver` and not mess about\n  using `Scrape` directly.\n\n\n## Basic Driver Arguments\n\nThe drivers of course need some information about the device you are trying to connect to. The most common arguments\n to provide to the driver are outlined below:\n\n| Argument         | Purpose/Value                                               |\n|------------------|-------------------------------------------------------------|\n| host             | name/ip of host to connect to                               |\n| port             | port of host to connect to (defaults to port 22)            |\n| auth_username    | username for authentication                                 |\n| auth_password    | password for authentication                                 |\n| auth_secondary   | password for secondary authentication (enable password)     |\n| auth_private_key | private key for authentication                              |\n| auth_strict_key  | strict key checking -- TRUE by default!                     |\n| ssh_config_file  | True/False or path to ssh config file to use                |\n\nThese arguments may be passed as keyword arguments to the driver of your choice, or, commonly are passed via\n dictionary unpacking as show below:\n\n```python\nfrom scrapli.driver.core import IOSXRDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nconn = IOSXRDriver(**my_device)\nconn.open()\n```\n\n*NOTE* that scrapli enables strict host key checking by default!\n\n## Opening and Closing a Connection\n\nscrapli does *not* open the connection for you when creating your scrapli connection object in normal operations, you\n must manually call the `open` method prior to sending any commands to the device as shown below.\n\n ```python\nfrom scrapli.driver.core import IOSXRDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nconn = IOSXRDriver(**my_device)\nconn.open()\nresponse = conn.send_command(\"show version\")\n```\n\nConnections can be closed by calling the `close` method:\n\n```python\nconn.close()\n```\n\nscrapli also supports using a context manager (`with` block), when using the context manager the connection will be\n automatically opened and closed for you. \n\n```python\nfrom scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    response = conn.send_command(\"show version\")\n```\n\n## Sending Commands\n\nWhen using any of the core network drivers (`JunosDriver`, `EOSDriver`, etc.) or the `GenericDriver`, the `send_command\n` and `send_commands` methods will respectively send a single command or list of commands to the device.\n\nWhen using the core network drivers, the command(s) will be sent at the `default_desired_priv` level which is\n typically \"privilege exec\" (or equivalent) privilege level. Please see [Driver Privilege Levels](#driver-privilege\n -levels) in the advanced usage section for more details on privilege levels. As the `GenericDriver` doesn't know or\n  care about privilege levels you would need to manually handle acquiring the appropriate privilege level for you\n   command yourself if using that driver.\n\nNote the different methods for sending a single command versus a list of commands!\n\n```python\nfrom scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nconn = IOSXEDriver(**my_device)\nconn.open()\nresponse = conn.send_command(\"show version\")\nresponses = conn.send_commands([\"show run\", \"show ip int brief\"])\n```\n\nFinally, if you prefer to have a list of commands to send, there is a `send_commands_from_file` method. This method\n excepts the provided file to have a single command to send per line in the file.\n\n## Response Object\n\nAll command/config operations that happen in the `GenericDriver` or any of the drivers inheriting from the\n `NetworkDriver` result in a `Response` object being created. The `Response` object contains attributes for the\n  command sent (`channel_input`), start/end/elapsed time, and of course the result of the command sent.\n\n```python\nfrom scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nconn = IOSXEDriver(**my_device)\nconn.open()\nresponse = conn.send_command(\"show version\")\nprint(response.elapsed_time)\nprint(response.result)\n```\n\nIf using `send_commands` (plural!) then scrapli will return a list of Response objects.\n\nIn addition to containing the input and output of the command(s) that you sent, the `Response` object also contains a\n method `textfsm_parse_output` (for more on TextFSM support see\n [Textfsm/NTC-Templates Integration](#textfsmntc-templates-integration)) which will attempt to parse and return the\n  received output. If parsing fails, the value returned will be an empty list -- meaning you will *always* get\n   \"structured data\" returned, however it will just be an empty object if parsing fails.\n\n```python\n>>> structured_result = response.textfsm_parse_output()\n>>> print(structured_result)\n[['16.4.1', 'IOS-XE', 'csr1000v', '2 days, 22 hours, 10 minutes', 'reload', 'packages.conf', ['CSR1000V'], ['9FKLJWM5EB0'], '0x2102', []]]\n```\n\n## Sending Configurations\n\nWhen using any of the core drivers, you can send configurations via the `send_configs` method which will handle\n privilege escalation and de-escalation for you. `send_configs` accepts a single string or a list of strings to\n  send in \"config mode\".\n\n```python\nfrom scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    conn.send_configs([\"interface loopback123\", \"description configured by scrapli\"])\n```\n\nThere is also a `send_configs_from_file` method that behaves exactly like the commands version, but sends the\n commands in configuration mode as you would expect.\n\n## Textfsm/NTC-Templates Integration\n\nscrapli supports parsing output with TextFSM and ntc-templates. This of course requires installing TextFSM and having\n ntc-templates somewhere on your system. When using a platform driver (i.e. `IOSXEDriver`) the textfsm-platform will be\n set for you (based on the driver device type). If you wish to parse the output of your send commands, you can use the\n  `textfsm_parse_output` method of the response object. This method will attempt to find the template for you\n   -- based on the textfsm-platform and the channel-input (the command sent). If textfsm parsing succeeds, the\n    structured result is returned. If textfsm parsing fails, an empty list is returned.\n\n```python\nfrom scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    response = conn.send_command(\"show version\")\n    structured_result = response.textfsm_parse_output()\n    print(structured_result)\n```\n\nscrapli also supports passing in templates manually (meaning not using the pip installed ntc-templates directory to\n find templates) if desired. The `scrapli.helper.textfsm_parse` function accepts a string or loaded (TextIOWrapper\n ) template and output to parse. This can be useful if you have custom or one off templates or don't want to pip\n  install ntc-templates.\n\n```python\nfrom scrapli.driver.core import IOSXEDriver\nfrom scrapli.helper import textfsm_parse\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    response = conn.send_command(\"show version\")\n    structured_result = textfsm_parse(\"/path/to/my/template\", response.result)\n```\n\n*NOTE*: If a template does not return structured data an empty list will be returned!\n\n*NOTE*: Textfsm and ntc-templates is an optional extra for scrapli; you can install these modules manually or using\n the optional extras install via pip:\n\n`pip install scrapli[textfsm]`\n\n\n## Cisco Genie Integration\n\nVery much the same as the textfsm/ntc-templates integration, scrapli has optional integration with Cisco's PyATS\n/Genie parsing library for parsing show command output. While there are parsers for non-Cisco platforms, this is\n currently just an option for Cisco platforms within scrapli.\n\n```python\nfrom scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    response = conn.send_command(\"show version\")\n    structured_result = response.genie_parse_output()\n    print(structured_result)\n```\n\n*NOTE*: If a parser does not return structured data an empty list will be returned!\n\n*NOTE*: PyATS and Genie is an optional extra for scrapli; you can install these modules manually or using\n the optional extras install via pip:\n\n`pip install scrapli[genie]`\n\n\n## Handling Prompts\n\nIn some cases you may need to run an \"interactive\" command on your device. The `send_interactive` method of the\n `GenericDriver` or its sub-classes (`NetworkDriver` and \"core\" drivers) can be used to accomplish this. This method\n  accepts a list of \"interact_events\" -- or basically commands you would like to send, and their expected resulting\n   prompt. A third, optional, element is available for each \"interaction\", this last element is a bool that indicates\n    weather or not the input that you are sending to the device is \"hidden\" or obfuscated by the device. This is\n     typically used for password prompts where the input that is sent does not show up on the screen (if you as a\n      human are sitting on a terminal typing).\n\nThis method can accept one or N \"events\" and thus can be used to deal with any number of subsequent prompts. \n\n```python\nfrom scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    interactive = conn.send_interactive(\n        [\n            (\"copy flash: scp:\", \"Source filename []?\", False),\n            (\"somefile.txt\", \"Address or name of remote host []?\", False),\n            (\"172.31.254.100\", \"Destination username [carl]?\", False),\n            (\"scrapli\", \"Password:\", False),\n            (\"super_secure_password\", \"csr1000v#\", True),\n        ]\n    )\n```\n\n\n## Telnet\n\nscrapli supports telnet as a transport driver via the standard library module `telnetlib`. Telnet is a bit of a\n special case for scrapli, here are the things you need to know if you wish to use Telnet:\n\n- Currently, you *must* set the port number. At the moment scrapli assumes SSH and defaults to port 22, even if you\n specify the telnet driver. This could obviously change in the future but for now, specify your telnet port!\n- You can set the username and password prompt expect string after your connection object instantiation\n and before calling the `open` method -- this means if you have non-default prompts you cannot use scrapli with a\n  context manager and Telnet (because the context manager calls open for you). You can set the prompts using the\n   following attributes of the `Scrape` object:\n  - `username_prompt`\n  - `password_prompt`\n\nIf telnet for some reason becomes an important use case, the telnet Transport layer can be improved/augmented.\n\n## SSH Config Support\n\nscrapli supports using OpenSSH configuration files in a few ways. For \"system\" SSH transport (default setting\n), passing a path to a config file will simply make scrapli \"point\" to that file, and therefore use that\n configuration files attributes (because it is just exec'ing system SSH!). See the [Transport Notes](#transport-notes\n -caveats-and-known-issues) section for details about what Transport supports what configuration options. You can\n  also pass `True` to let scrapli search in system default locations for an ssh config file (`~/.ssh/config` and\n   `/etc/ssh/ssh_config`.)\n\n*NOTE* -- scrapli does NOT disable strict host checking by default. Obviously this is the \"smart\" behavior, but it\n can be overridden on a per host basis in your SSH config file, or by passing `False` to the \"auth_strict_key\n \" argument on object instantiation.\n\n```python\nfrom scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n    \"ssh_config_file\": \"~/my_ssh_config\",\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    print(conn.get_prompt())\n```\n\n\n# Advanced Usage\n\n## All Driver Arguments\n\nThe basic usage section outlined the most commonly used driver arguments, this outlines all of the base driver\n arguments.\n\n| Argument                        | Purpose/Value                                               | Class             |\n|---------------------------------|-------------------------------------------------------------|-------------------|\n| host                            | name/ip of host to connect to                               | Scrape            |                             \n| port                            | port of host to connect to (defaults to port 22)            | Scrape            |                             \n| auth_username                   | username for authentication                                 | Scrape            |                             \n| auth_password                   | password for authentication                                 | Scrape            |                             \n| auth_secondary                  | password for secondary authentication (enable password)     | NetworkDriver     |                  \n| auth_private_key                | private key for authentication                              | Scrape            |                   \n| auth_strict_key                 | strict key checking -- TRUE by default!                     | Scrape            |    \n| auth_bypass                     | bypass ssh auth prompts after ssh establishment             | Scrape            |                           \n| timeout_socket                  | timeout value for initial socket connection                 | Scrape            |                   \n| timeout_transport               | timeout value for transport (i.e. paramiko)                 | Scrape            |                   \n| timeout_ops                     | timeout value for individual operations                     | Scrape            |                   \n| timeout_exit                    | True/False exit on timeout ops exceeded                     | Scrape            |                   \n| keepalive                       | True/False send keepalives to the remote host               | Scrape            |                   \n| keepalive_interval              | interval in seconds for keepalives                          | Scrape            |                   \n| keepalive_type                  | network or standard; see keepalive section for details      | Scrape            |                   \n| keepalive_pattern               | if network keepalive; pattern to send                       | Scrape            |                   \n| comms_prompt_pattern            | regex pattern for matching prompt(s); see platform regex    | Scrape            |                   \n| comms_return_char               | return char to use on the channel; default `\\n`             | Scrape            |                   \n| comms_ansi                      | True/False strip ansi from returned output                  | Scrape            |                   \n| ssh_config_file                 | True/False or path to ssh config file to use                | Scrape            |                   \n| ssh_known_hosts_file            | True/False or path to ssh known hosts file to use           | Scrape            |                   \n| on_open                         | callable to execute \"on open\"                               | Scrape            |                   \n| on_close                        | callable to execute \"on exit\"                               | Scrape            |                   \n| transport                       | system (default), paramiko, ssh2, or telnet                 | Scrape            |  \n| transport_options               | dictionary of transport-specific arguments                  | Scrape            |                \n| default_desired_privilege_level | privilege level for \"show\" commands to be executed at       | NetworkDriver     |\n\nMost of these attributes actually get passed from the `Scrape` (or sub-class such as `NXOSDriver`) into the\n `Transport` and `Channel` classes, so if you need to modify any of these values after instantiation you should do so\n  on the appropriate object -- i.e. `conn.channel.comms_prompt_pattern`.\n\n## Platform Regex\n\nDue to the nature of Telnet/SSH there is no good way to know when a command has completed execution. Put another way\n, when sending any command, data is returned over a socket, that socket doesn't ever tell us when it is \"done\n\" sending the output from the command that was executed. In order to know when the session is \"back at the base\n prompt/starting point\" scrapli uses a regular expression pattern to find that base prompt.\n\nThis pattern is contained in the `comms_prompt_pattern` setting, and is perhaps the most important argument to getting\n scrapli working!\n\nThe \"base\" (default, but changeable) pattern is:\n\n`\"^[a-z0-9.\\-@()/:]{1,20}[#>$]\\s*$\"`\n\n*NOTE* all `comms_prompt_pattern` \"should\" use the start and end of line anchors as all regex searches in scrapli are\n multi-line (this is an important piece to making this all work!). While you don't *need* to use the line anchors its\n  probably a really good idea! Also note that most devices seem to leave at least one white space after the final\n   character of the prompt, so make sure to account for this! Last important note -- the core drivers all have reliable\n    patterns set for you, so you hopefully don't need to bother with this too much!\n\nThe above pattern works on all \"core\" platforms listed above for at the very least basic usage. Custom prompts or\n host names could in theory break this, so be careful!\n\nIf you do not wish to match Cisco \"config\" level prompts you could use a `comms_prompt_pattern` such as:\n\n`\"^[a-z0-9.-@]{1,20}[#>$]\\s*$\"`\n\nIf you use a platform driver, the base prompt is set in the driver so you don't really need to worry about this!\n\nThe `comms_prompt_pattern` pattern can be changed at any time at or after instantiation of an scrapli object, and is\n done so by modifying `conn.channel.comms_prompt_pattern` where `conn` is your scrapli connection object. Changing\n this *can* break things though, so be careful!\n\n## On Open\n\nLots of times when connecting to a device there are \"things\" that need to happen immediately after getting connected\n. In the context of network devices the most obvious/common example would be disabling paging (i.e. sending `terminal\n length 0` on a Cisco-type device). While scrapli `Scrape` (the base driver) and `GenericDriver` do not know or care\n  about disabling paging or any other on connect type activities, scrapli of course provides a mechanism for allowing\n   users to handle these types of tasks. Even better yet, if you are using any of the core drivers (`IOSXEDriver\n   `, `IOSXRDriver`, etc.), scrapli will automatically have some sane default \"on connect\" actions (namely disabling\n    paging).\n\nIf you were so inclined to create some of your own \"on connect\" actions, you can simply pass those to the `on_open\n` argument of `Scrape` or any of its sub-classes (`NetworkDriver`, `IOSXEDriver`, etc.). The value of this argument\n must be a callable that accepts the reference to the connection object. This allows for the user to send commands or\n  do really anything that needs to happen prior to \"normal\" operations. The core network drivers disable paging\n   functions all call directly into the channel object `send_inputs` method -- this is a good practice to follow as\n    this will avoid any of the `NetworkDriver` overhead such as trying to attain privilege levels -- things like this\n     may not be \"ready\" until *after* your `on_open` function is executed.\n\nBelow is an example of creating an \"on connect\" function and passing it to scrapli. Immediately after authentication\n is handled this function will be called and disable paging (in this example):\n\n```python\nfrom scrapli.driver.core import IOSXEDriver\n\ndef iosxe_disable_paging(conn):\n    conn.channel.send_inputs(\"term length 0\")\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n    \"on_connect\": iosxe_disable_paging\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    print(conn.get_prompt())\n```\n\nNote that this section has talked almost exclusively about disabling paging, but any other \"things\" that need to\n happen in the channel can be handled here. If there is a prompt/banner to accept you should be able to handle it\n  here. The goal of this \"on connect\" function is to allow for lots of flexibility for dealing with whatever needs to\n   happen for devices -- thus decoupling the challenge of addressing all of the possible options from scrapli itself\n    and allowing users to handle things specific for their environment.\n\n## On Close\n\nAs you may have guessed, `on_close` is very similar to `on_open` with the obvious difference that it happens just\n prior to disconnecting from the device. Just like `on_open`, `on_close` functions should accept a single argument\n  that is a reference to the object itself. As with most things scrapli, there are sane defaults for the `on_close\n  ` functions, but you are welcome to override them with your own function if you so chose! \n\n## Timeouts\n\nscrapli supports several timeout options:\n\n- `timeout_socket`\n- `timeout_transport`\n- `timeout_ops`\n\n`timeout_socket` is exactly what it sounds where possible. For the ssh2 and paramiko transports we create our own\n socket and pass this to the created object (paramiko or ssh2 object). The socket is created with the timeout value\n  set in the `timeout_socket` attribute. For telnet and system transports we do not create a socket ourselves so this\n   value is used slightly differently.\n\nFor telnet, the `timeout_socket` is used as the timeout for telnet session creation. After the telnet session is\n created the timeout is reset to the `timeout_transport` value (more on that in a second).\n\nFor system transport, `timeout_socket` governs the `ConnectTimeout` ssh argument -- which seems to be very similar to\n socket timeout in paramiko/ssh2.\n\n`timeout_transport` is intended to govern the timeout for the actual transport mechanism itself. For paramiko and\n ssh2, this is set to the respective libraries timeout attributes. For telnet, this is set to the telnetlib timeout\n  value after the initial telnet session is stood up. For system transport, this value is used as the timeout value\n   for read and write operations (handled by operation timeout decorator). \n\nFinally, `timeout_ops` sets a timeout value for individual operations -- or put another way, the timeout for each\n send_input operation.\n\n## Keepalives\n\nIn some cases it may be desirable to have a long running connection to a device, however it is generally a bad idea\n to allow for very long timeouts/exec sessions on devices. To cope with this scrapli supports sending \"keepalives\n \". For \"normal\" ssh devices this could be basic SSH keepalives (with ssh2-python and system transports). As scrapli\n  is generally focused on networking devices, and most networking devices don't support standard keepalives, scrapli\n   also has the ability to send \"network\" keepalives.\n\nIn either case -- \"standard\" or \"network\" -- scrapli spawns a keepalive thread. This thread then sends either\n standard keepalive messages or \"in band\" keepalive messages in the case of \"network\" keepalives.\n\n\"network\" keepalives default to sending u\"\\005\" which is equivalent of sending `CTRL-E` (jump to end (right side) of\n line). This is generally an innocuous command, and furthermore is never sent unless the keepalive thread can acquire\n  a channel lock. This should allow scrapli to keep sessions alive as long as needed.\n\n## Driver Privilege Levels\n\nThe \"core\" drivers understand the basic privilege levels of their respective device types. As mentioned previously\n, the drivers will automatically attain the \"privilege_exec\" (or equivalent) privilege level prior to executing \"show\n\" commands. If you don't want this \"auto-magic\" you can use the base driver (`Scrape`) or the `GenericDriver`. The\n privileges for each device are outlined in named tuples in the platforms `driver.py` file. \n\nAs an example, the following privilege levels are supported by the `IOSXEDriver`:\n\n1. \"exec\"\n2. \"privilege_exec\"\n3. \"configuration\"\n\nEach privilege level has the following attributes:\n\n- pattern: regex pattern to associate prompt to privilege level with\n- name: name of the priv level, i.e. \"exec\"\n- previous_priv: name of the \"lower\"/\"previous\" privilege level\n- deescalate: command used to deescalate *from* this privilege level (or an empty string if no lower privilege)\n- escalate: command used to escalate *to* this privilege level (from the lower/previous privilege)\n- escalate_auth: True/False there is auth required to escalate to this privilege level\n- escalate_prompt: pattern to expect when escalating to this privilege level, i.e. \"Password:\" or any empty string\n\nIf you wish to manually enter a privilege level you can use the `acquire_priv` method, passing in the name of the\n privilege level you would like to enter. In general you probably won't need this too often though as the driver\n  should handle much of this for you.\n\n```python\nfrom scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\nwith IOSXEDriver(**my_device) as conn:\n    conn.acquire_priv(\"configuration\")\n```\n\n## Using `Scrape` Directly\n\nAll examples in this readme have shown using the \"core\" network drivers such as `IOSXEDriver`. These core network\n drivers are actually sub-classes of an ABC called `NetworkDriver` which itself is a sub-class of the `GenericDriver\n ` which is a sub-class of the base `Scrape` class -- the namesake for this library. The `Scrape` object can be used\n  directly if you prefer to have a much less opinionated or less \"auto-magic\" type experience. `Scrape` does not\n   provide the same `send_command`/`send_commands`/`send_configs` methods, nor does it disable paging, or handle any\n    kind of privilege escalation/de-escalation. `Scrape` is a much more basic \"paramiko\"-like experience. Below is a\n     brief example of using the `Scrape` object directly:\n\n```python\nfrom scrapli import Scrape\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nwith Scrape(**my_device) as conn:\n    conn.channel.send_input(\"terminal length 0\")\n    response = conn.channel.send_input(\"show version\")\n    responses = conn.channel.send_inputs([\"show version\", \"show run\"])\n```\n\nWithout the `send_command` and similar methods, you must directly access the `Channel` object when sending inputs\n with `Scrape`.\n\n\n## Using the `GenericDriver`\n\nUsing the `Scrape` driver directly is nice enough, however you may not want to have to change the prompt pattern, or\n deal with accessing the channel to send commands to the device. In this case there is a `GenericDriver` available to\n  you. This driver has a *very* broad pattern that it matches for base prompts, has no concept of disabling paging or\n   privilege levels (like `Scrape`), but does provide `send_command`, `send_commands`, `send_interact`, and\n    `get_prompt` methods for a more NetworkDriver-like experience. \n\nHopefully this `GenericDriver` can be used as a starting point for devices that don't fall under the core supported\n platforms list.\n\n```python\nfrom scrapli.driver import GenericDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n}\n\nwith GenericDriver(**my_device) as conn:\n    conn.send_command(\"terminal length 0\")\n    response = conn.send_command(\"show version\")\n    responses = conn.send_commands([\"show version\", \"show run\"])\n```\n\n\n## Using a Different Transport\n\nscrapli is built to be very flexible, including being flexible enough to use different libraries for \"transport\n\" -- or the actual Telnet/SSH communication. By default scrapli uses the \"system\" transport which quite literally\n uses the ssh binary on your system (`/usr/bin/ssh`). This \"system\" transport means that scrapli has no external\n  dependencies as it just relies on what is available on the machine running the scrapli script.\n\nIn the spirit of being highly flexible, scrapli allows users to swap out this \"system\" transport with another\n transport mechanism. The other supported transport mechanisms are `paramiko`, `ssh2-python` and `telnetlib\n `. `paramiko` and `ssh2-python` were originally part of the core of scrapli, but have since been moved to their own\n  repositories to be used as plugins to keep the codebase as simple as possible. The transport selection can be made\n   when instantiating the scrapli connection object by passing in `paramiko`, `ssh2`, or `telnet` to force scrapli to\n    use the corresponding transport mechanism.\n\nWhile it will be a goal to ensure that these other transport mechanisms are supported and useful, the focus of\n scrapli development will be on the \"system\" SSH transport.\n\nExample using `paramiko` as the transport:\n\n```python\nfrom scrapli.driver.core import IOSXEDriver\n\nmy_device = {\n    \"host\": \"172.18.0.11\",\n    \"auth_username\": \"vrnetlab\",\n    \"auth_password\": \"VR-netlab9\",\n    \"auth_strict_key\": False,\n    \"transport\": \"paramiko\"\n}\n\nwith IOSXEDriver(**my_device) as conn:\n    print(conn.get_prompt())\n```\n\nCurrently the only reason I can think of to use anything other than \"system\" as the transport would be to test\n scrapli on a Windows host or to use telnet. If there are other good reasons please do let me know!\n\n\n## Auth Bypass\n\n*NOTE* Currently only supported with system transport!\n\nSome devices, such as Cisco WLC, have no \"true\" SSH authentication, and instead prompt for credentials (or perhaps\n not even that) after session establishment. In order to cope with this corner case, the `auth_bypass` flag can be\n  set to `True` which will cause scrapli to skip all authentication steps. Typically this flag would be set and a\n   custom `on_open` function set to handle whatever prompts the device has upon SSH session establishment.\n\nIn the future this functionality will likely be extended to the telnet transport, and may be extended to paramiko and\n ssh2 transports.\n\nSee the [non core device example](/examples/non_core_device/wlc.py) to see this in action.\n\n\n## Transport Options\n\nBecause each transport has different options/features available, it doesn't make sense to try to put all possible\n arguments in the `Scrape` or `NetworkDriver` drivers, to address this an argument `transport_options` has been added\n . This is exactly what it sounds like -- arguments that can be passed to the selected transport class. As these\n  arguments will be transport-specific, please check the docs/docstrings for your preferred transport to see what is\n   available.\n\nA simple example of passing additional SSH arguments to the `SystemSSHTransport` class is available\n [here](examples/transport_options/system_ssh_args.py).\n\n\n# FAQ\n\n- Question: Why build this? Netmiko exists, Paramiko exists, Ansible exists, etc...?\n  - Answer: I built `ssh2net` to learn -- to have a goal/target for writing some code. scrapli is an evolution of the\n   lessons learned building ssh2net. About mid-way through building `ssh2net` I realized it may actually be kinda good\n    at doing... stuff. So, sure there are other tools out there, but I think scrapli its pretty snazzy and fills in some\n     of the gaps in other tools. For example scrapli is 100% compliant with strict mypy type checking, very uniformly\n      documented/linted, contains a results object for every operation, is very very fast, is very flexible, and in\n       general pretty awesome! Finally, while I think in general that SSH \"screen scraping\" is not \"sexy\" or even\n        \"good\", it is the lowest common denominator for automation in the networking world. So I figured I could try\n         to make the fastest, most flexible library around for SSH network automation! \n- Question: Is this better than Netmiko/Paramiko/Ansible?\n  - Answer: Nope! It is different though! The main focus is just to be stupid fast. It is very much that. It *should* be\n  super reliable too as the timeouts are very easy/obvious to control, and it should also be very very very easy to\n   adapt to any other network-y type CLI by virtue of flexible prompt finding and easily modifiable on connect\n    functions.\n- Question: Is this easy to use?\n  - Answer: Yep! The base usage with `Scrape` is pretty straight forward -- the thing to remember is that it doesn't\n   do \"things\" for you like Netmiko does for example, so its a lot more like Paramiko in that regard this just means\n    that you need to disable paging yourself (or pass an `on_open` callable to do so), handle privilege modes and\n     things like that. That said you can use one of the available drivers to have a more Netmiko-like experience -OR\n     - write your own driver as this has been built with the thought of being easily extended.\n- Why do I get a \"conn (or your object name here) has no attribute channel\" exception?\n  - Answer: Connection objects do not \"auto open\", and the channel attribute is not assigned until opening the\n   connection. Call `conn.open()` (or your object name in place of conn) to open the session and assign the channel\n    attribute. Alternatively you can use any of the drivers with a context manager (see what I did there? WITH... get\n     it?) which will auto-magically open and close the connections for you.\n- I wanna go fast!\n  - Hmmm... not a question but I dig it. If you wanna go fast you gotta learn to drive with the fear... ok, enough\n   Talladega Nights quoting for now. In theory using the `ssh2` transport is the gateway to speed... being a very\n    thin wrapper around libssh2 means that its basically all C and that means its probably about as fast as we're\n     reasonably going to get. All that said, scrapli by default uses the `system` transport which is really just\n      using your system ssh.... which is almost certainly libssh2/openssh which is also C. There is a thin layer of\n       abstraction between scrapli and your system ssh but really its just reading/writing to a file which Python\n        should be doing in C anyway I would think. In summary... while `ssh2` is probably the fastest you can go with\n         scrapli, the difference between `ssh2` and `system` transports in limited testing is microscopic, and the\n          benefits of using system transport (native ssh config file support!!) probably should outweigh the speed of\n           ssh2 -- especially if you have control persist and can take advantage of that with system transport!\n- Other questions? Ask away!\n\n\n# Transport Notes, Caveats, and Known Issues\n\n## paramiko\n\n- Currently there seems to be a cosmetic bug where there is an error message about some socket error... but\n everything seems to work as expected.\n\n### SSH Config Supported Arguments\n\n- user\n- port\n- identity_file\n\n### Known Issues\n\n- None yet!\n\n## ssh2-python\n\n### SSH Config Supported Arguments\n\n- user\n- port\n- identity_file\n\n### Known Issues\n\n- Arista EOS uses keyboard interactive authentication which is currently broken in the pip-installable version\n of ssh2-python (as of January 2020). GitHub user [Red-M](https://github.com/Red-M) has contributed to and fixed this\n  particular issue but the fix has not been merged. If you would like to use ssh2-python with EOS I suggest cloning\n   and installing via Red-M's repository or my fork of Red-M's fork!\n  - Windows users using python3.8 may need to use Red-M's fork, quick testing in GitHub actions for py3.8 on Windows\n   had install failures for ssh2-python.\n- Use the context manager where possible! More testing needs to be done to confirm/troubleshoot, but limited testing\n seems to indicate that without properly closing the connection there appears to be a bug that causes Python to crash\n  on MacOS at least. More to come on this as I have time to poke it more! I believe this is only occurring on the\n   latest branch/update (i.e. not on the pip installable version). (April 2020 -- this may be fixed... need to retest\n   ...)\n\n## system\n\n- Any arguments passed to the `SystemSSHTransport` class will override arguments in your ssh config file. This is\n because the arguments get crafted into an \"open_cmd\" (the command that actually fires off the ssh session), and\n  these cli arguments take precedence over the config file arguments.\n- If you set `ssh_config_file` to `False` the `SystemSSHTransport` class will set the config file used to `/dev/null\n` so that no ssh config file configs are accidentally used.\n- There is zero Windows support for system ssh transport - I would strongly encourage the use of WSL or cygwin and\n sticking with systemssh instead of using paramiko/ssh2 natively in Windows -- system ssh is very much the focus of\n  development for scrapli!\n\n### SSH Config Supported Arguments\n\n- literally whatever your system supports as scrapli just execs SSH on your system!\n\n### Known Issues\n\n- None yet!\n\n## telnet\n\n- See the telnet section!\n\n### SSH Config Supported Arguments\n\n- Obviously none!\n\n### Known Issues\n\n- None yet!\n\n\n# Linting and Testing\n\n## Linting\n\nThis project uses [black](https://github.com/psf/black) for auto-formatting. In addition to black, tox will execute\n [pylama](https://github.com/klen/pylama), and [pydocstyle](https://github.com/PyCQA/pydocstyle) for linting purposes\n . Tox will also run  [mypy](https://github.com/python/mypy), with strict type checking. Docstring linting with\n  [darglint](https://github.com/terrencepreilly/darglint) which has been quite handy!\n\nAll commits to this repository will trigger a GitHub action which runs tox, but of course its nicer to just run that\n before making a commit to ensure that it will pass all tests!\n\n### Typing\n\nAs stated, this project is 100% type checked and will remain that way. The value this adds for IDE auto-completion\n and just general sanity checking/forcing writing of more type-check-able code is worth the small overhead in effort.\n\n## Testing\n\nTesting is broken into two main categories -- unit and functional. Unit is what you would expect -- unit testing the\n code. Functional testing connects to virtual devices in order to more accurately test the code. Unit tests cover\n  quite a bit of the code base due to mocking the FileIO that the channel reads/writes to. This gives a pretty high\n   level of confidence that at least object instantiation and channel read/writes will generally work... Functional\n    tests against virtual devices helps reinforce that and gets coverage for the transport classes.\n\nFor more ad-hoc type testing there is a `smoke` folder in the tests directory -- for \"smoke tests\". These are simple\n scripts that don't really \"test\" (as in no assertions or pytest or anything), but are useful for basic testing that\n  things have not gotten broken while working on new features. These have been handy for spot testing during\n   development so rather than leave them in a private directory they are included here in case they are useful for\n    anyone else!\n\n### Unit Tests\n\nUnit tests can be executed via pytest:\n\n```\npython -m pytest tests/unit/\n```\n\nOr using the following make command:\n\n```\nmake test_unit\n```\n\nIf you would like to see the coverage report and generate the html coverage report:\n\n```\nmake cov_unit\n```\n\n### Setting up Functional Test Environment\n\nExecuting the functional tests is a bit more complicated! First, thank you to Kristian Larsson for his great tool\n [vrnetlab](https://github.com/plajjan/vrnetlab)! All functional tests are built on this awesome platform that allows\n  for easy creation of containerized network devices.\n\nBasic functional tests exist for all \"core\" platform types (IOSXE, NXOS, IOSXR, EOS, Junos) as well as basic testing\n for Linux. Vrnetlab currently only supports the older emulation style NX-OS devices, and *not* the newer VM image\n  n9kv. I have made some very minor tweaks to vrnetlab locally in order to get the n9kv image running. I also have\n   made some changes to enable scp-server for IOSXE/NXOS devices to allow for config replaces with NAPALM right out\n    of the box. You can get these tweaks in my fork of vrnetlab. Getting going with vrnetlab is fairly\n     straightforward -- simply follow Kristian's great readme docs.\n\nFor the Arista EOS image -- prior to creating the container you should boot the device and enter the `zerotouch\n disable` command. This allows for the config to actually be saved and prevents the interfaces from cycling through\n  interface types in the container (I'm not clear why it does that but executing this command before building the\n   container \"fixes\" this!). An example qemu command to boot up the EOS device is:\n\n```\nqemu-system-x86_64 -enable-kvm -display none -machine pc -monitor tcp:0.0.0.0:4999,server,nowait -m 4096 -serial telnet:0.0.0.0:5999,server,nowait -drive if=ide,file=vEOS-lab-4.22.1F.vmdk -device pci-bridge,chassis_nr=1,id=pci.1 -device e1000,netdev=p00,mac=52:54:00:54:e9:00 -netdev user,id=p00,net=10.0.0.0/24,tftp=/tftpboot,hostfwd=tcp::2022-10.0.0.15:22,hostfwd=tcp::2023-10.0.0.15:23,hostfwd=udp::2161-10.0.0.15:161,hostfwd=tcp::2830-10.0.0.15:830,hostfwd=tcp::2080-10.0.0.15:80,hostfwd=tcp::2443-10.0.0.15:443\n```\n\nOnce booted, connect to the device (telnet to container IP on port 5999 if using above command), issue the command\n `zerotouch disable`, save the config and then you can shut it down, and make the container.\n\nThe docker-compose file here will be looking for the container images matching this pattern, so this is an important\n bit! The container image names should be:\n\n```\nscrapli-cisco-iosxe\nscrapli-cisco-nxos\nscrapli-cisco-iosxr\nscrapli-arista-eos\nscrapli-juniper-junos\n```\n\nYou can tag the image names on creation (following the vrnetlab readme docs), or create a new tag once the image is built:\n\n```\ndocker tag [TAG OF IMAGE CREATED] scrapli-[VENDOR]-[OS]\n```\n\n*NOTE* If you are going to test scrapli, use [my fork of vrnetlab](https://github.com/carlmontanari/vrnetlab) -- I've\n enabled telnet, set ports, taken care of setting things up so that NAPALM can config replace, etc.\n\n\n### Functional Tests\n\nOnce you have created the images, you can start all of the containers with a make command:\n\n```\nmake start_dev_env\n```\n\nConversely you can terminate the containers:\n\n```\nmake stop_dev_env\n```\n\nTo start a specific platform container:\n\n```\nmake start_dev_env_iosxe\n```\n\nSubstitute \"iosxe\" for the platform type you want to start.\n\nMost of the containers don't take too long to fire up, maybe a few minutes (running on my old macmini with Ubuntu, so\n not exactly a powerhouse!). That said, the IOS-XR device takes about 15 minutes to go to \"healthy\" status. Once\n  booted up you can connect to their console or via SSH:\n\n| Device        | Local IP      |\n| --------------|---------------|\n| iosxe         | 172.18.0.11   |\n| nxos          | 172.18.0.12   |\n| iosxr         | 172.18.0.13   |\n| eos           | 172.18.0.14   |\n| junos         | 172.18.0.15   |\n| linux         | 172.18.0.20   |\n\nThe console port for all devices is 5000, so to connect to the console of the iosxe device you can simply telnet to\n that port locally:\n\n```\ntelnet 172.18.0.11 5000\n```\n\nCredentials for all devices use the default vrnetlab credentials:\n\nUsername: `vrnetlab`\n\nPassword: `VR-netlab9`\n\nYou should also run the `prepare_devices` script in the functional tests, or use the Make commands to do so for you\n. This script will deploy the base config needed for testing. The make commands for this step follow the same pattern\n as the others:\n\n- `prepare_dev_env` will push the base config to all devices\n- `prepare_dev_env_XYZ` where XYZ == \"iosxe\", \"nxos\", etc. will push the base config for the specified device.\n\nOnce the container(s) are ready, you can use the make commands to execute tests as needed:\n\n- `test` will execute all currently implemented functional tests as well as the unit tests\n- `test_functional` will execute all currently implemented functional tests\n- `test_iosxe` will execute all unit tests and iosxe functional tests\n- `test_nxos` will execute all unit tests and nxos functional tests\n- `test_iosxr` will execute all unit tests and iosxr functional tests\n- `test_eos` will execute all unit tests and eos functional tests\n- `test_junos` will execute all unit tests and junos functional tests\n- `test_linux` will execute all unit tests and basic linux functional tests (this is really intended to test the base\n `Scrape` driver instead of the network drivers)\n\n### Other Functional Test Info\n\nIOSXE is the only platform that is testing SSH key based authentication at the moment. The key is pushed via NAPALM in\n the setup phase. This was mostly done out of laziness, and in the future the other platforms may be tested with key\n  based auth as well, but for now IOSXE is representative enough to provide some faith that key based auth works! \n\n\n# Todo and Roadmap\n\nThis section may not get updated much, but will hopefully reflect the priority items for short term (todo) and longer\n term (roadmap) for scrapli.\n\n## Todo\n\n- Investigate setter methods for setting user/pass/and other attrs on base scrape object... they should be able to be\n set at that level and have the transport updated if it can be done reasonably\n- Refresh the keepalive stuff -- how/where keepalives get kicked off needs to be reevaluated, particularly for\n systemssh \"standard\" keepalives as this should really be happening in the open command (systemssh will probably have\n  to override some Transport methods basically), get all of this under functional testing as well\n- Add tests for timeouts if possible\n- Add more tests for auth failures\n- Add tests for custom on open/close functions\n- Remove as much as possible from the vendor'd `ptyprocess` code. Type hint it, add docstrings everywhere, add tests\n if possible (and remove from ignore for test coverage and darglint).\n- Add darglint back in if it gets faster\n\n## Roadmap\n\n- Async support. This is a bit of a question mark as I personally don't know even where to start to implement this\n, and have no real current use case... that said I think it would be cool if for no other reason than to learn!\n- Plugins -- build framework to allow for others to easily build driver plugins if desired\n- Ensure v6 stuff works as expected.\n- Continue to add/support ssh config file things.\n- Maybe make this into a netconf driver as well? ncclient is just built on paramiko so it seems doable...?\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/carlmontanari/scrapli", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "scrapli", "package_url": "https://pypi.org/project/scrapli/", "platform": "", "project_url": "https://pypi.org/project/scrapli/", "project_urls": {"Homepage": "https://github.com/carlmontanari/scrapli"}, "release_url": "https://pypi.org/project/scrapli/2020.4.30/", "requires_dist": ["genie (>=20.2) ; extra == 'genie'", "pyats (>=20.2) ; extra == 'genie'", "scrapli-paramiko (>=2020.04.30) ; extra == 'paramiko'", "scrapli-ssh2 (>=2020.04.30) ; extra == 'ssh2'", "textfsm (>=1.1.0) ; extra == 'textfsm'", "ntc-templates (>=1.1.0) ; extra == 'textfsm'"], "requires_python": ">=3.6", "summary": "Screen scraping (ssh|telnet) client focused on network devices", "version": "2020.4.30", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/af23b93e518c8b72792d7a6748080ee243435a10/68747470733a2f2f6769746875622e636f6d2f6361726c6d6f6e74616e6172692f73637261706c692f776f726b666c6f77732f5765656b6c792532304275696c642f62616467652e737667\">\n<a href=\"https://badge.fury.io/py/scrapli\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0f30e7e364e62e15dabebed0402c6ea3000bd6f6/68747470733a2f2f62616467652e667572792e696f2f70792f73637261706c692e737667\"></a>\n<a href=\"https://www.python.org/downloads/release/python-360/\" rel=\"nofollow\"><img alt=\"Python 3.6\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/01419d339114693587408dd14856677a4789006a/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f707974686f6e2d332e362d626c75652e737667\"></a>\n<a href=\"https://www.python.org/downloads/release/python-370/\" rel=\"nofollow\"><img alt=\"Python 3.7\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/99a5180f32db379110e9948c7de1aaf8f77bf2e8/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f707974686f6e2d332e372d626c75652e737667\"></a>\n<a href=\"https://www.python.org/downloads/release/python-380/\" rel=\"nofollow\"><img alt=\"Python 3.8\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7f8a5f68d8d76185564998e2d4814ac79bc72a7c/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f707974686f6e2d332e382d626c75652e737667\"></a>\n<a href=\"https://github.com/ambv/black\" rel=\"nofollow\"><img alt=\"Code Style\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fbfdc7754183ecf079bc71ddeabaf88f6cbc5c00/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e737667\"></a></p>\n<h1>scrapli</h1>\n<p>scrapli -- scrap(e c)li --  is a python library focused on connecting to devices, specifically network devices\n(routers/switches/firewalls/etc.) via SSH or Telnet. The name scrapli -- is just \"scrape cli\" (as in screen scrape)\nsquished together! scrapli's goal is to be as fast and flexible as possible, while providing a thoroughly tested, well\ntyped, well documented, simple API.</p>\n<h1>Table of Contents</h1>\n<ul>\n<li><a href=\"#quick-start-guide\" rel=\"nofollow\">Quick Start Guide</a>\n<ul>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#a-simple-example\" rel=\"nofollow\">A Simple Example</a></li>\n<li><a href=\"#more-examples\" rel=\"nofollow\">More Examples</a></li>\n</ul>\n</li>\n<li><a href=\"#scrapli-what-is-it\" rel=\"nofollow\">scrapli: What is it</a></li>\n<li><a href=\"#documentation\" rel=\"nofollow\">Documentation</a></li>\n<li><a href=\"#supported-platforms\" rel=\"nofollow\">Supported Platforms</a></li>\n<li><a href=\"#advanced-installation\" rel=\"nofollow\">Advanced Installation</a></li>\n<li><a href=\"#basic-usage\" rel=\"nofollow\">Basic Usage</a>\n<ul>\n<li><a href=\"#picking-the-right-driver\" rel=\"nofollow\">Picking the right Driver</a></li>\n<li><a href=\"#basic-driver-arguments\" rel=\"nofollow\">Basic Driver Arguments</a></li>\n<li><a href=\"#opening-and-closing-a-connection\" rel=\"nofollow\">Opening and Closing a Connection</a></li>\n<li><a href=\"#sending-commands\" rel=\"nofollow\">Sending Commands</a></li>\n<li><a href=\"#response-object\" rel=\"nofollow\">Response Object</a></li>\n<li><a href=\"#sending-configurations\" rel=\"nofollow\">Sending Configurations</a></li>\n<li><a href=\"#textfsmntc-templates-integration\" rel=\"nofollow\">Textfsm/NTC-Templates Integration</a></li>\n<li><a href=\"#cisco-genie-integration\" rel=\"nofollow\">Cisco Genie Integration</a></li>\n<li><a href=\"#handling-prompts\" rel=\"nofollow\">Handling Prompts</a></li>\n<li><a href=\"#telnet\" rel=\"nofollow\">Telnet</a></li>\n<li><a href=\"#ssh-config-support\" rel=\"nofollow\">SSH Config Support</a></li>\n</ul>\n</li>\n<li><a href=\"#advanced-usage\" rel=\"nofollow\">Advanced Usage</a>\n<ul>\n<li><a href=\"#all-driver-arguments\" rel=\"nofollow\">All Driver Arguments</a></li>\n<li><a href=\"#platform-regex\" rel=\"nofollow\">Platform Regex</a></li>\n<li><a href=\"#on-open\" rel=\"nofollow\">On Open</a></li>\n<li><a href=\"#on-close\" rel=\"nofollow\">On Close</a></li>\n<li><a href=\"#timeouts\" rel=\"nofollow\">Timeouts</a></li>\n<li><a href=\"#driver-privilege-levels\" rel=\"nofollow\">Driver Privilege Levels</a></li>\n<li><a href=\"#using-scrape-directly\" rel=\"nofollow\">Using Scrape Directly</a></li>\n<li><a href=\"#using-the-genericdriver\" rel=\"nofollow\">Using the GenericDriver</a></li>\n<li><a href=\"#using-a-different-transport\" rel=\"nofollow\">Using a Different Transport</a></li>\n<li><a href=\"#auth-bypass\" rel=\"nofollow\">Auth Bypass</a></li>\n<li><a href=\"#transport-options\" rel=\"nofollow\">Transport Options</a></li>\n</ul>\n</li>\n<li><a href=\"#faq\" rel=\"nofollow\">FAQ</a></li>\n<li><a href=\"#transport-notes-caveats-and-known-issues\" rel=\"nofollow\">Transport Notes, Caveats, and Known Issues</a>\n<ul>\n<li><a href=\"#paramiko\" rel=\"nofollow\">Paramiko</a></li>\n<li><a href=\"#ssh2-python\" rel=\"nofollow\">SSH2-Python</a></li>\n<li><a href=\"#system\" rel=\"nofollow\">System SSH</a></li>\n<li><a href=\"#telnet\" rel=\"nofollow\">Telnet</a></li>\n</ul>\n</li>\n<li><a href=\"#linting-and-testing\" rel=\"nofollow\">Linting and Testing</a>\n<ul>\n<li><a href=\"#linting\" rel=\"nofollow\">Linting</a></li>\n<li><a href=\"#testing\" rel=\"nofollow\">Testing</a></li>\n</ul>\n</li>\n<li><a href=\"#todo-and-roadmap\" rel=\"nofollow\">Todo and Roadmap</a>\n<ul>\n<li><a href=\"#todo\" rel=\"nofollow\">Todo</a></li>\n<li><a href=\"#roadmap\" rel=\"nofollow\">Roadmap</a></li>\n</ul>\n</li>\n</ul>\n<h1>Quick Start Guide</h1>\n<h2>Installation</h2>\n<p>In most cases installation via pip is the simplest and best way to install scrapli.\nSee below or <a href=\"#advanced-installation\" rel=\"nofollow\">here</a> for advanced installation details.</p>\n<pre><code>pip install scrapli\n</code></pre>\n<h2>A Simple Example</h2>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">conn</span> <span class=\"o\">=</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span>\n<span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">()</span>\n<span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_command</span><span class=\"p\">(</span><span class=\"s2\">\"show run\"</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<pre><code>$ python my_scrapli_script.py\nBuilding configuration...\n\nCurrent configuration : 7584 bytes\n!\n! Last configuration change at 19:24:38 PST Sat Feb 29 2020 by carl\n! NVRAM config last updated at 19:00:28 PST Fri Feb 7 2020 by carl\n!\nversion 15.2\nservice nagle\nno service pad\nservice tcp-keepalives-in\nservice tcp-keepalives-out\nservice timestamps debug datetime msec\nno service password-encryption\n!\n&lt;SNIP&gt;\n!\nend\n</code></pre>\n<h2>More Examples</h2>\n<ul>\n<li><a href=\"/examples/basic_usage/scrapli_driver.py\" rel=\"nofollow\">Basic \"native\" Scrape operations</a></li>\n<li><a href=\"/examples/basic_usage/generic_driver.py\" rel=\"nofollow\">Basic \"GenericDriver\" operations</a></li>\n<li><a href=\"/examples/basic_usage/iosxe_driver.py\" rel=\"nofollow\">Basic \"core\" Driver operations</a></li>\n<li><a href=\"/examples/logging/basic_logging.py\" rel=\"nofollow\">Setting up basic logging</a></li>\n<li><a href=\"/examples/ssh_keys/ssh_keys.py\" rel=\"nofollow\">Using SSH Key for authentication</a></li>\n<li><a href=\"/examples/ssh_config_files/ssh_config_file.py\" rel=\"nofollow\">Using SSH config file</a></li>\n<li><a href=\"/examples/structured_data/structured_data_textfsm.py\" rel=\"nofollow\">Parse output with TextFSM/ntc-templates</a></li>\n<li><a href=\"/examples/structured_data/structured_data_genie.py\" rel=\"nofollow\">Parse output with Genie</a></li>\n<li><a href=\"examples/transport_options/system_ssh_args.py\" rel=\"nofollow\">Transport Options</a></li>\n</ul>\n<h1>scrapli: What is it</h1>\n<p>As stated, scrapli is a python library focused on connecting to devices, specifically network devices via SSH or Telnet.</p>\n<p>scrapli is built primarily in three parts: transport, channel, and driver. The transport layer is responsible for\nproviding a file-like interface to the target server. The channel layer is responsible for reading and writing\nto the provided file-like interface. Finally, the driver provides the user facing API/interface to scrapli.</p>\n<p>There are two available \"transports\" in scrapli \"core\" -- both of which inherit from a base transport class\nand provide the same file-like interface to the upstream channel. There are also (currently!) two transport plugins\navailable -- both of which are installable as optional extras. The transport options are:</p>\n<ul>\n<li><a href=\"https://github.com/paramiko/paramiko\" rel=\"nofollow\">paramiko</a> (optional extra)</li>\n<li><a href=\"https://github.com/ParallelSSH/ssh2-python\" rel=\"nofollow\">ssh2-python</a> (optional extra)</li>\n<li>OpenSSH/System available SSH</li>\n<li>telnetlib</li>\n</ul>\n<p>A good question to ask at this point is probably \"why?\". Why multiple transport options? Why not just use paramiko\nlike most folks do? Historically the reason for moving away from paramiko was simply speed. ssh2-python is a wrapper\naround the libssh2 C library, and as such is very very fast. In a prior project\n(<a href=\"https://github.com/carlmontanari/ssh2net\" rel=\"nofollow\">ssh2net</a>), of which scrapli is the successor/evolution, ssh2-python\nwas used with great success, however, it is a bit feature-limited, and development seems to have stalled.</p>\n<p>This led to moving back to paramiko, which of course is a fantastic project with tons and tons of feature support\n. Paramiko, however, does not provide \"direct\" OpenSSH support (as in -- auto-magically like when you ssh on your\nnormal shell), and I don't believe it provides 100% full OpenSSH support either (ex: ControlPersist). Fully\nsupporting an OpenSSH config file would be an ideal end goal for scrapli, something that may not be possible with\nParamiko - ControlPersist in particular is very interesting to me.</p>\n<p>With the goal of supporting all of the OpenSSH configuration options the primary transport driver option is simply\nnative system local SSH. The implementation of using system SSH is of course a little bit messy, however scrapli\ntakes care of that for you so you don't need to care about it! The payoff of using system SSH is of course that\nOpenSSH config files simply \"work\" -- no passing it to scrapli, no selective support, no need to set username or\nports or any of the other config items that may reside in your SSH config file. This driver will likely be the\nfocus of most development for this project, though I will try to keep the other transport drivers -- in\nparticular ssh2-python -- as close to parity as is possible/practical.</p>\n<p>The last transport is telnet via telnetlib. This was trivial to add in as the interface is basically the same as\nSystemSSH, and it turns out telnet is still actually useful for things like terminal servers and the like!</p>\n<p>The final piece of scrapli is the actual \"driver\" -- or the component that binds the transport and channel together and\ndeals with instantiation of an scrapli object. There is a \"base\" driver object -- <code>Scrape</code> -- which provides essentially\na \"raw\" SSH (or telnet) connection that is created by instantiating a Transport object, and a Channel object\n. <code>Scrape</code> provides (via Channel) read/write methods and not much else -- this should feel familiar if you have\nused paramiko in the past. More specific \"drivers\" can inherit from this class to extend functionality of the\ndriver to make it more friendly for network devices. In fact, there is a <code>GenericDriver</code> class that inherits from\n<code>Scrape</code> and provides a base driver to work with if you need to interact with a device not represented by one of\nthe \"core\" drivers. Next, the <code>NetworkDriver</code> abstract base class inherits from <code>GenericDriver</code> This\n<code>NetworkDriver</code> isn't really meant to be used directly though (hence why it is an ABC), but to be further\nextended and built upon instead. As this library is focused on interacting with network devices, an example\nscrapli driver (built on the <code>NetworkDriver</code>) would be the <code>IOSXEDriver</code> -- to, as you may have guessed\n, interact with devices running Cisco's IOS-XE operating system.</p>\n<h1>Documentation</h1>\n<p>Documentation is auto-generated <a href=\"https://github.com/pdoc3/pdoc\" rel=\"nofollow\">using pdoc3</a>. Documentation is linted (see Linting and\nTesting section) via <a href=\"https://github.com/PyCQA/pydocstyle/\" rel=\"nofollow\">pydocstyle</a> and\n<a href=\"https://github.com/terrencepreilly/darglint\" rel=\"nofollow\">darglint</a>.</p>\n<p>Documentation is hosted via GitHub Pages and can be found\n<a href=\"https://carlmontanari.github.io/scrapli/docs/scrapli/index.html\" rel=\"nofollow\">here</a>. You can also view this readme as a web page\n<a href=\"https://carlmontanari.github.io/scrapli/\" rel=\"nofollow\">here</a>.</p>\n<p>To regenerate documentation locally, use the following make command:</p>\n<pre><code>make docs\n</code></pre>\n<h1>Supported Platforms</h1>\n<p>scrapli \"core\" drivers cover basically the <a href=\"https://github.com/napalm-automation/napalm\" rel=\"nofollow\">NAPALM</a> platforms -- Cisco\nIOS-XE, IOS-XR, NX-OS, Arista EOS, and Juniper JunOS. These drivers provide an interface tailored to network device\n\"screen-scraping\" rather than just a generic SSH connection/channel. Below are the core driver platforms and\ncurrently tested version.</p>\n<ul>\n<li>Cisco IOS-XE (tested on: 16.04.01)</li>\n<li>Cisco NX-OS (tested on: 9.2.4)</li>\n<li>Juniper JunOS (tested on: 17.3R2.10)</li>\n<li>Cisco IOS-XR (tested on: 6.5.3)</li>\n<li>Arista EOS (tested on: 4.22.1F)</li>\n</ul>\n<p>In the future it would be possible for folks to contribute additional \"community\" drivers, however, is unlikely that any\nadditional \"core\" platforms would be added.</p>\n<p>The \"driver\" pattern is pretty much exactly like the implementation in NAPALM. The driver extends the base class\n(<code>Scrape</code>) and the base networking driver class (<code>NetworkDriver</code>) with device specific functionality such as privilege\nescalation/de-escalation, setting appropriate prompts to search for, and picking out appropriate\n<a href=\"https://github.com/networktocode/ntc-templates\" rel=\"nofollow\">ntc templates</a> for use with TextFSM, and so on.</p>\n<p>All of this is focused on network device type Telnet/SSH cli interfaces, but should work on pretty much any SSH\nconnection (though there are almost certainly better options for non-network type devices!). The \"base\" (<code>Scrape</code>) and <code>GenericDriver</code> connections do not handle any kind of device-specific operations such as privilege\nescalation or saving configurations, they are simply intended to be a bare bones connection that can interact with\nnearly any device/platform if you are willing to send/parse inputs/outputs manually. In most cases it is assumed\nthat users will use one of the \"core\" drivers.</p>\n<p>The goal for all \"core\" devices will be to include functional tests that can run against\n<a href=\"https://github.com/plajjan/vrnetlab\" rel=\"nofollow\">vrnetlab</a> containers to ensure that the \"core\" devices are as thoroughly tested\nas is practical.</p>\n<h1>Advanced Installation</h1>\n<p>As outlined in the quick start, you should be able to pip install scrapli \"normally\":</p>\n<pre><code>pip install scrapli\n</code></pre>\n<p>To install from this repositories master branch:</p>\n<pre><code>pip install git+https://github.com/carlmontanari/scrapli\n</code></pre>\n<p>To install from this repositories develop branch:</p>\n<pre><code>pip install -e git+https://github.com/carlmontanari/scrapli.git@develop#egg=scrapli\n</code></pre>\n<p>To install from source:</p>\n<pre><code>git clone https://github.com/carlmontanari/scrapli\ncd scrapli\npython setup.py install\n</code></pre>\n<p>scrapli has made an effort to have as few dependencies as possible -- in fact to have ZERO dependencies! The \"core\" of\nscrapli can run with nothing other than standard library! If for any reason you wish to use paramiko or ssh2-python\nas a driver, however, you of course need to install those. These \"extras\" can be installed via pip:</p>\n<pre><code>pip install scrapli[paramiko]\n</code></pre>\n<p>The available optional installation extras options are:</p>\n<ul>\n<li>paramiko (paramiko and the scrapli_paramiko transport)</li>\n<li>ssh2 (ssh2-python and the scrapli_ssh2 transport)</li>\n<li>textfsm (textfsm and ntc-templates)</li>\n<li>genie (genie/pyats)</li>\n</ul>\n<p>As for platforms to <em>run</em> scrapli on -- it has and will be tested on MacOS and Ubuntu regularly and should work on any\nPOSIX system. Windows is now being tested very minimally via GitHub Actions builds, however it is important to note\nthat if you wish to use Windows you will need to use paramiko or ssh2-python as the transport driver. It is\n<em>strongly</em> recommended/preferred for folks to use WSL/Cygwin and stick with \"system\" as the transport.</p>\n<h1>Basic Usage</h1>\n<h2>Picking the right Driver</h2>\n<p>Assuming you are using scrapli to connect to one of the five \"core\" platforms, you should almost always use the\nprovided corresponding \"core\" driver. For example if you are connecting to an Arista EOS device, you should use the\n<code>EOSDriver</code>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">EOSDriver</span>\n</pre>\n<p>The core drivers and associated platforms are outlined below:</p>\n<table>\n<thead>\n<tr>\n<th>Platform/OS</th>\n<th>Scrapli Driver</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Cisco IOS-XE</td>\n<td>IOSXEDriver</td>\n</tr>\n<tr>\n<td>Cisco NX-OS</td>\n<td>NXOSDriver</td>\n</tr>\n<tr>\n<td>Cisco IOS-XR</td>\n<td>IOSXRDriver</td>\n</tr>\n<tr>\n<td>Arista EOS</td>\n<td>EOSDriver</td>\n</tr>\n<tr>\n<td>Juniper JunOS</td>\n<td>JunosDriver</td>\n</tr></tbody></table>\n<p>All drivers can be imported from <code>scrapli.driver.core</code>.</p>\n<p>If you are working with a platform not listed above, you have two options: you can use the <code>Scrape</code> driver directly\n, which you can read about <a href=\"#using-scrape-directly\" rel=\"nofollow\">here</a> or you can use the <code>GenericDriver</code> which which you can read\nabout <a href=\"#using-the-genericdriver\" rel=\"nofollow\">here</a>. In general you should probably use the <code>GenericDriver</code> and not mess about\nusing <code>Scrape</code> directly.</p>\n<h2>Basic Driver Arguments</h2>\n<p>The drivers of course need some information about the device you are trying to connect to. The most common arguments\nto provide to the driver are outlined below:</p>\n<table>\n<thead>\n<tr>\n<th>Argument</th>\n<th>Purpose/Value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>host</td>\n<td>name/ip of host to connect to</td>\n</tr>\n<tr>\n<td>port</td>\n<td>port of host to connect to (defaults to port 22)</td>\n</tr>\n<tr>\n<td>auth_username</td>\n<td>username for authentication</td>\n</tr>\n<tr>\n<td>auth_password</td>\n<td>password for authentication</td>\n</tr>\n<tr>\n<td>auth_secondary</td>\n<td>password for secondary authentication (enable password)</td>\n</tr>\n<tr>\n<td>auth_private_key</td>\n<td>private key for authentication</td>\n</tr>\n<tr>\n<td>auth_strict_key</td>\n<td>strict key checking -- TRUE by default!</td>\n</tr>\n<tr>\n<td>ssh_config_file</td>\n<td>True/False or path to ssh config file to use</td>\n</tr></tbody></table>\n<p>These arguments may be passed as keyword arguments to the driver of your choice, or, commonly are passed via\ndictionary unpacking as show below:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXRDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">conn</span> <span class=\"o\">=</span> <span class=\"n\">IOSXRDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span>\n<span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">()</span>\n</pre>\n<p><em>NOTE</em> that scrapli enables strict host key checking by default!</p>\n<h2>Opening and Closing a Connection</h2>\n<p>scrapli does <em>not</em> open the connection for you when creating your scrapli connection object in normal operations, you\nmust manually call the <code>open</code> method prior to sending any commands to the device as shown below.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXRDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n   <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n   <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n   <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n   <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">conn</span> <span class=\"o\">=</span> <span class=\"n\">IOSXRDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span>\n<span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">()</span>\n<span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_command</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n</pre>\n<p>Connections can be closed by calling the <code>close</code> method:</p>\n<pre><span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n</pre>\n<p>scrapli also supports using a context manager (<code>with</code> block), when using the context manager the connection will be\nautomatically opened and closed for you.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_command</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n</pre>\n<h2>Sending Commands</h2>\n<p>When using any of the core network drivers (<code>JunosDriver</code>, <code>EOSDriver</code>, etc.) or the <code>GenericDriver</code>, the <code>send_command</code> and <code>send_commands</code> methods will respectively send a single command or list of commands to the device.</p>\n<p>When using the core network drivers, the command(s) will be sent at the <code>default_desired_priv</code> level which is\ntypically \"privilege exec\" (or equivalent) privilege level. Please see [Driver Privilege Levels](#driver-privilege\n-levels) in the advanced usage section for more details on privilege levels. As the <code>GenericDriver</code> doesn't know or\ncare about privilege levels you would need to manually handle acquiring the appropriate privilege level for you\ncommand yourself if using that driver.</p>\n<p>Note the different methods for sending a single command versus a list of commands!</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">conn</span> <span class=\"o\">=</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span>\n<span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">()</span>\n<span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_command</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n<span class=\"n\">responses</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_commands</span><span class=\"p\">([</span><span class=\"s2\">\"show run\"</span><span class=\"p\">,</span> <span class=\"s2\">\"show ip int brief\"</span><span class=\"p\">])</span>\n</pre>\n<p>Finally, if you prefer to have a list of commands to send, there is a <code>send_commands_from_file</code> method. This method\nexcepts the provided file to have a single command to send per line in the file.</p>\n<h2>Response Object</h2>\n<p>All command/config operations that happen in the <code>GenericDriver</code> or any of the drivers inheriting from the\n<code>NetworkDriver</code> result in a <code>Response</code> object being created. The <code>Response</code> object contains attributes for the\ncommand sent (<code>channel_input</code>), start/end/elapsed time, and of course the result of the command sent.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">conn</span> <span class=\"o\">=</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span>\n<span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">()</span>\n<span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_command</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">elapsed_time</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<p>If using <code>send_commands</code> (plural!) then scrapli will return a list of Response objects.</p>\n<p>In addition to containing the input and output of the command(s) that you sent, the <code>Response</code> object also contains a\nmethod <code>textfsm_parse_output</code> (for more on TextFSM support see\n<a href=\"#textfsmntc-templates-integration\" rel=\"nofollow\">Textfsm/NTC-Templates Integration</a>) which will attempt to parse and return the\nreceived output. If parsing fails, the value returned will be an empty list -- meaning you will <em>always</em> get\n\"structured data\" returned, however it will just be an empty object if parsing fails.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">structured_result</span> <span class=\"o\">=</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">textfsm_parse_output</span><span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">structured_result</span><span class=\"p\">)</span>\n<span class=\"p\">[[</span><span class=\"s1\">'16.4.1'</span><span class=\"p\">,</span> <span class=\"s1\">'IOS-XE'</span><span class=\"p\">,</span> <span class=\"s1\">'csr1000v'</span><span class=\"p\">,</span> <span class=\"s1\">'2 days, 22 hours, 10 minutes'</span><span class=\"p\">,</span> <span class=\"s1\">'reload'</span><span class=\"p\">,</span> <span class=\"s1\">'packages.conf'</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">'CSR1000V'</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"s1\">'9FKLJWM5EB0'</span><span class=\"p\">],</span> <span class=\"s1\">'0x2102'</span><span class=\"p\">,</span> <span class=\"p\">[]]]</span>\n</pre>\n<h2>Sending Configurations</h2>\n<p>When using any of the core drivers, you can send configurations via the <code>send_configs</code> method which will handle\nprivilege escalation and de-escalation for you. <code>send_configs</code> accepts a single string or a list of strings to\nsend in \"config mode\".</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_configs</span><span class=\"p\">([</span><span class=\"s2\">\"interface loopback123\"</span><span class=\"p\">,</span> <span class=\"s2\">\"description configured by scrapli\"</span><span class=\"p\">])</span>\n</pre>\n<p>There is also a <code>send_configs_from_file</code> method that behaves exactly like the commands version, but sends the\ncommands in configuration mode as you would expect.</p>\n<h2>Textfsm/NTC-Templates Integration</h2>\n<p>scrapli supports parsing output with TextFSM and ntc-templates. This of course requires installing TextFSM and having\nntc-templates somewhere on your system. When using a platform driver (i.e. <code>IOSXEDriver</code>) the textfsm-platform will be\nset for you (based on the driver device type). If you wish to parse the output of your send commands, you can use the\n<code>textfsm_parse_output</code> method of the response object. This method will attempt to find the template for you\n-- based on the textfsm-platform and the channel-input (the command sent). If textfsm parsing succeeds, the\nstructured result is returned. If textfsm parsing fails, an empty list is returned.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_command</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n    <span class=\"n\">structured_result</span> <span class=\"o\">=</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">textfsm_parse_output</span><span class=\"p\">()</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">structured_result</span><span class=\"p\">)</span>\n</pre>\n<p>scrapli also supports passing in templates manually (meaning not using the pip installed ntc-templates directory to\nfind templates) if desired. The <code>scrapli.helper.textfsm_parse</code> function accepts a string or loaded (TextIOWrapper\n) template and output to parse. This can be useful if you have custom or one off templates or don't want to pip\ninstall ntc-templates.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n<span class=\"kn\">from</span> <span class=\"nn\">scrapli.helper</span> <span class=\"kn\">import</span> <span class=\"n\">textfsm_parse</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_command</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n    <span class=\"n\">structured_result</span> <span class=\"o\">=</span> <span class=\"n\">textfsm_parse</span><span class=\"p\">(</span><span class=\"s2\">\"/path/to/my/template\"</span><span class=\"p\">,</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<p><em>NOTE</em>: If a template does not return structured data an empty list will be returned!</p>\n<p><em>NOTE</em>: Textfsm and ntc-templates is an optional extra for scrapli; you can install these modules manually or using\nthe optional extras install via pip:</p>\n<p><code>pip install scrapli[textfsm]</code></p>\n<h2>Cisco Genie Integration</h2>\n<p>Very much the same as the textfsm/ntc-templates integration, scrapli has optional integration with Cisco's PyATS\n/Genie parsing library for parsing show command output. While there are parsers for non-Cisco platforms, this is\ncurrently just an option for Cisco platforms within scrapli.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_command</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n    <span class=\"n\">structured_result</span> <span class=\"o\">=</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">genie_parse_output</span><span class=\"p\">()</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">structured_result</span><span class=\"p\">)</span>\n</pre>\n<p><em>NOTE</em>: If a parser does not return structured data an empty list will be returned!</p>\n<p><em>NOTE</em>: PyATS and Genie is an optional extra for scrapli; you can install these modules manually or using\nthe optional extras install via pip:</p>\n<p><code>pip install scrapli[genie]</code></p>\n<h2>Handling Prompts</h2>\n<p>In some cases you may need to run an \"interactive\" command on your device. The <code>send_interactive</code> method of the\n<code>GenericDriver</code> or its sub-classes (<code>NetworkDriver</code> and \"core\" drivers) can be used to accomplish this. This method\naccepts a list of \"interact_events\" -- or basically commands you would like to send, and their expected resulting\nprompt. A third, optional, element is available for each \"interaction\", this last element is a bool that indicates\nweather or not the input that you are sending to the device is \"hidden\" or obfuscated by the device. This is\ntypically used for password prompts where the input that is sent does not show up on the screen (if you as a\nhuman are sitting on a terminal typing).</p>\n<p>This method can accept one or N \"events\" and thus can be used to deal with any number of subsequent prompts.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">interactive</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_interactive</span><span class=\"p\">(</span>\n        <span class=\"p\">[</span>\n            <span class=\"p\">(</span><span class=\"s2\">\"copy flash: scp:\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Source filename []?\"</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">),</span>\n            <span class=\"p\">(</span><span class=\"s2\">\"somefile.txt\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Address or name of remote host []?\"</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">),</span>\n            <span class=\"p\">(</span><span class=\"s2\">\"172.31.254.100\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Destination username [carl]?\"</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">),</span>\n            <span class=\"p\">(</span><span class=\"s2\">\"scrapli\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Password:\"</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">),</span>\n            <span class=\"p\">(</span><span class=\"s2\">\"super_secure_password\"</span><span class=\"p\">,</span> <span class=\"s2\">\"csr1000v#\"</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">),</span>\n        <span class=\"p\">]</span>\n    <span class=\"p\">)</span>\n</pre>\n<h2>Telnet</h2>\n<p>scrapli supports telnet as a transport driver via the standard library module <code>telnetlib</code>. Telnet is a bit of a\nspecial case for scrapli, here are the things you need to know if you wish to use Telnet:</p>\n<ul>\n<li>Currently, you <em>must</em> set the port number. At the moment scrapli assumes SSH and defaults to port 22, even if you\nspecify the telnet driver. This could obviously change in the future but for now, specify your telnet port!</li>\n<li>You can set the username and password prompt expect string after your connection object instantiation\nand before calling the <code>open</code> method -- this means if you have non-default prompts you cannot use scrapli with a\ncontext manager and Telnet (because the context manager calls open for you). You can set the prompts using the\nfollowing attributes of the <code>Scrape</code> object:\n<ul>\n<li><code>username_prompt</code></li>\n<li><code>password_prompt</code></li>\n</ul>\n</li>\n</ul>\n<p>If telnet for some reason becomes an important use case, the telnet Transport layer can be improved/augmented.</p>\n<h2>SSH Config Support</h2>\n<p>scrapli supports using OpenSSH configuration files in a few ways. For \"system\" SSH transport (default setting\n), passing a path to a config file will simply make scrapli \"point\" to that file, and therefore use that\nconfiguration files attributes (because it is just exec'ing system SSH!). See the [Transport Notes](#transport-notes\n-caveats-and-known-issues) section for details about what Transport supports what configuration options. You can\nalso pass <code>True</code> to let scrapli search in system default locations for an ssh config file (<code>~/.ssh/config</code> and\n<code>/etc/ssh/ssh_config</code>.)</p>\n<p><em>NOTE</em> -- scrapli does NOT disable strict host checking by default. Obviously this is the \"smart\" behavior, but it\ncan be overridden on a per host basis in your SSH config file, or by passing <code>False</code> to the \"auth_strict_key\n\" argument on object instantiation.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"ssh_config_file\"</span><span class=\"p\">:</span> <span class=\"s2\">\"~/my_ssh_config\"</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">get_prompt</span><span class=\"p\">())</span>\n</pre>\n<h1>Advanced Usage</h1>\n<h2>All Driver Arguments</h2>\n<p>The basic usage section outlined the most commonly used driver arguments, this outlines all of the base driver\narguments.</p>\n<table>\n<thead>\n<tr>\n<th>Argument</th>\n<th>Purpose/Value</th>\n<th>Class</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>host</td>\n<td>name/ip of host to connect to</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>port</td>\n<td>port of host to connect to (defaults to port 22)</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>auth_username</td>\n<td>username for authentication</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>auth_password</td>\n<td>password for authentication</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>auth_secondary</td>\n<td>password for secondary authentication (enable password)</td>\n<td>NetworkDriver</td>\n</tr>\n<tr>\n<td>auth_private_key</td>\n<td>private key for authentication</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>auth_strict_key</td>\n<td>strict key checking -- TRUE by default!</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>auth_bypass</td>\n<td>bypass ssh auth prompts after ssh establishment</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>timeout_socket</td>\n<td>timeout value for initial socket connection</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>timeout_transport</td>\n<td>timeout value for transport (i.e. paramiko)</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>timeout_ops</td>\n<td>timeout value for individual operations</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>timeout_exit</td>\n<td>True/False exit on timeout ops exceeded</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>keepalive</td>\n<td>True/False send keepalives to the remote host</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>keepalive_interval</td>\n<td>interval in seconds for keepalives</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>keepalive_type</td>\n<td>network or standard; see keepalive section for details</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>keepalive_pattern</td>\n<td>if network keepalive; pattern to send</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>comms_prompt_pattern</td>\n<td>regex pattern for matching prompt(s); see platform regex</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>comms_return_char</td>\n<td>return char to use on the channel; default <code>\\n</code></td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>comms_ansi</td>\n<td>True/False strip ansi from returned output</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>ssh_config_file</td>\n<td>True/False or path to ssh config file to use</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>ssh_known_hosts_file</td>\n<td>True/False or path to ssh known hosts file to use</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>on_open</td>\n<td>callable to execute \"on open\"</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>on_close</td>\n<td>callable to execute \"on exit\"</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>transport</td>\n<td>system (default), paramiko, ssh2, or telnet</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>transport_options</td>\n<td>dictionary of transport-specific arguments</td>\n<td>Scrape</td>\n</tr>\n<tr>\n<td>default_desired_privilege_level</td>\n<td>privilege level for \"show\" commands to be executed at</td>\n<td>NetworkDriver</td>\n</tr></tbody></table>\n<p>Most of these attributes actually get passed from the <code>Scrape</code> (or sub-class such as <code>NXOSDriver</code>) into the\n<code>Transport</code> and <code>Channel</code> classes, so if you need to modify any of these values after instantiation you should do so\non the appropriate object -- i.e. <code>conn.channel.comms_prompt_pattern</code>.</p>\n<h2>Platform Regex</h2>\n<p>Due to the nature of Telnet/SSH there is no good way to know when a command has completed execution. Put another way\n, when sending any command, data is returned over a socket, that socket doesn't ever tell us when it is \"done\n\" sending the output from the command that was executed. In order to know when the session is \"back at the base\nprompt/starting point\" scrapli uses a regular expression pattern to find that base prompt.</p>\n<p>This pattern is contained in the <code>comms_prompt_pattern</code> setting, and is perhaps the most important argument to getting\nscrapli working!</p>\n<p>The \"base\" (default, but changeable) pattern is:</p>\n<p><code>\"^[a-z0-9.\\-@()/:]{1,20}[#&gt;$]\\s*$\"</code></p>\n<p><em>NOTE</em> all <code>comms_prompt_pattern</code> \"should\" use the start and end of line anchors as all regex searches in scrapli are\nmulti-line (this is an important piece to making this all work!). While you don't <em>need</em> to use the line anchors its\nprobably a really good idea! Also note that most devices seem to leave at least one white space after the final\ncharacter of the prompt, so make sure to account for this! Last important note -- the core drivers all have reliable\npatterns set for you, so you hopefully don't need to bother with this too much!</p>\n<p>The above pattern works on all \"core\" platforms listed above for at the very least basic usage. Custom prompts or\nhost names could in theory break this, so be careful!</p>\n<p>If you do not wish to match Cisco \"config\" level prompts you could use a <code>comms_prompt_pattern</code> such as:</p>\n<p><code>\"^[a-z0-9.-@]{1,20}[#&gt;$]\\s*$\"</code></p>\n<p>If you use a platform driver, the base prompt is set in the driver so you don't really need to worry about this!</p>\n<p>The <code>comms_prompt_pattern</code> pattern can be changed at any time at or after instantiation of an scrapli object, and is\ndone so by modifying <code>conn.channel.comms_prompt_pattern</code> where <code>conn</code> is your scrapli connection object. Changing\nthis <em>can</em> break things though, so be careful!</p>\n<h2>On Open</h2>\n<p>Lots of times when connecting to a device there are \"things\" that need to happen immediately after getting connected\n. In the context of network devices the most obvious/common example would be disabling paging (i.e. sending <code>terminal length 0</code> on a Cisco-type device). While scrapli <code>Scrape</code> (the base driver) and <code>GenericDriver</code> do not know or care\nabout disabling paging or any other on connect type activities, scrapli of course provides a mechanism for allowing\nusers to handle these types of tasks. Even better yet, if you are using any of the core drivers (<code>IOSXEDriver</code>, <code>IOSXRDriver</code>, etc.), scrapli will automatically have some sane default \"on connect\" actions (namely disabling\npaging).</p>\n<p>If you were so inclined to create some of your own \"on connect\" actions, you can simply pass those to the <code>on_open</code> argument of <code>Scrape</code> or any of its sub-classes (<code>NetworkDriver</code>, <code>IOSXEDriver</code>, etc.). The value of this argument\nmust be a callable that accepts the reference to the connection object. This allows for the user to send commands or\ndo really anything that needs to happen prior to \"normal\" operations. The core network drivers disable paging\nfunctions all call directly into the channel object <code>send_inputs</code> method -- this is a good practice to follow as\nthis will avoid any of the <code>NetworkDriver</code> overhead such as trying to attain privilege levels -- things like this\nmay not be \"ready\" until <em>after</em> your <code>on_open</code> function is executed.</p>\n<p>Below is an example of creating an \"on connect\" function and passing it to scrapli. Immediately after authentication\nis handled this function will be called and disable paging (in this example):</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">iosxe_disable_paging</span><span class=\"p\">(</span><span class=\"n\">conn</span><span class=\"p\">):</span>\n    <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">channel</span><span class=\"o\">.</span><span class=\"n\">send_inputs</span><span class=\"p\">(</span><span class=\"s2\">\"term length 0\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"on_connect\"</span><span class=\"p\">:</span> <span class=\"n\">iosxe_disable_paging</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">get_prompt</span><span class=\"p\">())</span>\n</pre>\n<p>Note that this section has talked almost exclusively about disabling paging, but any other \"things\" that need to\nhappen in the channel can be handled here. If there is a prompt/banner to accept you should be able to handle it\nhere. The goal of this \"on connect\" function is to allow for lots of flexibility for dealing with whatever needs to\nhappen for devices -- thus decoupling the challenge of addressing all of the possible options from scrapli itself\nand allowing users to handle things specific for their environment.</p>\n<h2>On Close</h2>\n<p>As you may have guessed, <code>on_close</code> is very similar to <code>on_open</code> with the obvious difference that it happens just\nprior to disconnecting from the device. Just like <code>on_open</code>, <code>on_close</code> functions should accept a single argument\nthat is a reference to the object itself. As with most things scrapli, there are sane defaults for the <code>on_close</code> functions, but you are welcome to override them with your own function if you so chose!</p>\n<h2>Timeouts</h2>\n<p>scrapli supports several timeout options:</p>\n<ul>\n<li><code>timeout_socket</code></li>\n<li><code>timeout_transport</code></li>\n<li><code>timeout_ops</code></li>\n</ul>\n<p><code>timeout_socket</code> is exactly what it sounds where possible. For the ssh2 and paramiko transports we create our own\nsocket and pass this to the created object (paramiko or ssh2 object). The socket is created with the timeout value\nset in the <code>timeout_socket</code> attribute. For telnet and system transports we do not create a socket ourselves so this\nvalue is used slightly differently.</p>\n<p>For telnet, the <code>timeout_socket</code> is used as the timeout for telnet session creation. After the telnet session is\ncreated the timeout is reset to the <code>timeout_transport</code> value (more on that in a second).</p>\n<p>For system transport, <code>timeout_socket</code> governs the <code>ConnectTimeout</code> ssh argument -- which seems to be very similar to\nsocket timeout in paramiko/ssh2.</p>\n<p><code>timeout_transport</code> is intended to govern the timeout for the actual transport mechanism itself. For paramiko and\nssh2, this is set to the respective libraries timeout attributes. For telnet, this is set to the telnetlib timeout\nvalue after the initial telnet session is stood up. For system transport, this value is used as the timeout value\nfor read and write operations (handled by operation timeout decorator).</p>\n<p>Finally, <code>timeout_ops</code> sets a timeout value for individual operations -- or put another way, the timeout for each\nsend_input operation.</p>\n<h2>Keepalives</h2>\n<p>In some cases it may be desirable to have a long running connection to a device, however it is generally a bad idea\nto allow for very long timeouts/exec sessions on devices. To cope with this scrapli supports sending \"keepalives\n\". For \"normal\" ssh devices this could be basic SSH keepalives (with ssh2-python and system transports). As scrapli\nis generally focused on networking devices, and most networking devices don't support standard keepalives, scrapli\nalso has the ability to send \"network\" keepalives.</p>\n<p>In either case -- \"standard\" or \"network\" -- scrapli spawns a keepalive thread. This thread then sends either\nstandard keepalive messages or \"in band\" keepalive messages in the case of \"network\" keepalives.</p>\n<p>\"network\" keepalives default to sending u\"\\005\" which is equivalent of sending <code>CTRL-E</code> (jump to end (right side) of\nline). This is generally an innocuous command, and furthermore is never sent unless the keepalive thread can acquire\na channel lock. This should allow scrapli to keep sessions alive as long as needed.</p>\n<h2>Driver Privilege Levels</h2>\n<p>The \"core\" drivers understand the basic privilege levels of their respective device types. As mentioned previously\n, the drivers will automatically attain the \"privilege_exec\" (or equivalent) privilege level prior to executing \"show\n\" commands. If you don't want this \"auto-magic\" you can use the base driver (<code>Scrape</code>) or the <code>GenericDriver</code>. The\nprivileges for each device are outlined in named tuples in the platforms <code>driver.py</code> file.</p>\n<p>As an example, the following privilege levels are supported by the <code>IOSXEDriver</code>:</p>\n<ol>\n<li>\"exec\"</li>\n<li>\"privilege_exec\"</li>\n<li>\"configuration\"</li>\n</ol>\n<p>Each privilege level has the following attributes:</p>\n<ul>\n<li>pattern: regex pattern to associate prompt to privilege level with</li>\n<li>name: name of the priv level, i.e. \"exec\"</li>\n<li>previous_priv: name of the \"lower\"/\"previous\" privilege level</li>\n<li>deescalate: command used to deescalate <em>from</em> this privilege level (or an empty string if no lower privilege)</li>\n<li>escalate: command used to escalate <em>to</em> this privilege level (from the lower/previous privilege)</li>\n<li>escalate_auth: True/False there is auth required to escalate to this privilege level</li>\n<li>escalate_prompt: pattern to expect when escalating to this privilege level, i.e. \"Password:\" or any empty string</li>\n</ul>\n<p>If you wish to manually enter a privilege level you can use the <code>acquire_priv</code> method, passing in the name of the\nprivilege level you would like to enter. In general you probably won't need this too often though as the driver\nshould handle much of this for you.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">acquire_priv</span><span class=\"p\">(</span><span class=\"s2\">\"configuration\"</span><span class=\"p\">)</span>\n</pre>\n<h2>Using <code>Scrape</code> Directly</h2>\n<p>All examples in this readme have shown using the \"core\" network drivers such as <code>IOSXEDriver</code>. These core network\ndrivers are actually sub-classes of an ABC called <code>NetworkDriver</code> which itself is a sub-class of the <code>GenericDriver</code> which is a sub-class of the base <code>Scrape</code> class -- the namesake for this library. The <code>Scrape</code> object can be used\ndirectly if you prefer to have a much less opinionated or less \"auto-magic\" type experience. <code>Scrape</code> does not\nprovide the same <code>send_command</code>/<code>send_commands</code>/<code>send_configs</code> methods, nor does it disable paging, or handle any\nkind of privilege escalation/de-escalation. <code>Scrape</code> is a much more basic \"paramiko\"-like experience. Below is a\nbrief example of using the <code>Scrape</code> object directly:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli</span> <span class=\"kn\">import</span> <span class=\"n\">Scrape</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">Scrape</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">channel</span><span class=\"o\">.</span><span class=\"n\">send_input</span><span class=\"p\">(</span><span class=\"s2\">\"terminal length 0\"</span><span class=\"p\">)</span>\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">channel</span><span class=\"o\">.</span><span class=\"n\">send_input</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n    <span class=\"n\">responses</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">channel</span><span class=\"o\">.</span><span class=\"n\">send_inputs</span><span class=\"p\">([</span><span class=\"s2\">\"show version\"</span><span class=\"p\">,</span> <span class=\"s2\">\"show run\"</span><span class=\"p\">])</span>\n</pre>\n<p>Without the <code>send_command</code> and similar methods, you must directly access the <code>Channel</code> object when sending inputs\nwith <code>Scrape</code>.</p>\n<h2>Using the <code>GenericDriver</code></h2>\n<p>Using the <code>Scrape</code> driver directly is nice enough, however you may not want to have to change the prompt pattern, or\ndeal with accessing the channel to send commands to the device. In this case there is a <code>GenericDriver</code> available to\nyou. This driver has a <em>very</em> broad pattern that it matches for base prompts, has no concept of disabling paging or\nprivilege levels (like <code>Scrape</code>), but does provide <code>send_command</code>, <code>send_commands</code>, <code>send_interact</code>, and\n<code>get_prompt</code> methods for a more NetworkDriver-like experience.</p>\n<p>Hopefully this <code>GenericDriver</code> can be used as a starting point for devices that don't fall under the core supported\nplatforms list.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver</span> <span class=\"kn\">import</span> <span class=\"n\">GenericDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">GenericDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_command</span><span class=\"p\">(</span><span class=\"s2\">\"terminal length 0\"</span><span class=\"p\">)</span>\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_command</span><span class=\"p\">(</span><span class=\"s2\">\"show version\"</span><span class=\"p\">)</span>\n    <span class=\"n\">responses</span> <span class=\"o\">=</span> <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">send_commands</span><span class=\"p\">([</span><span class=\"s2\">\"show version\"</span><span class=\"p\">,</span> <span class=\"s2\">\"show run\"</span><span class=\"p\">])</span>\n</pre>\n<h2>Using a Different Transport</h2>\n<p>scrapli is built to be very flexible, including being flexible enough to use different libraries for \"transport\n\" -- or the actual Telnet/SSH communication. By default scrapli uses the \"system\" transport which quite literally\nuses the ssh binary on your system (<code>/usr/bin/ssh</code>). This \"system\" transport means that scrapli has no external\ndependencies as it just relies on what is available on the machine running the scrapli script.</p>\n<p>In the spirit of being highly flexible, scrapli allows users to swap out this \"system\" transport with another\ntransport mechanism. The other supported transport mechanisms are <code>paramiko</code>, <code>ssh2-python</code> and <code>telnetlib</code>. <code>paramiko</code> and <code>ssh2-python</code> were originally part of the core of scrapli, but have since been moved to their own\nrepositories to be used as plugins to keep the codebase as simple as possible. The transport selection can be made\nwhen instantiating the scrapli connection object by passing in <code>paramiko</code>, <code>ssh2</code>, or <code>telnet</code> to force scrapli to\nuse the corresponding transport mechanism.</p>\n<p>While it will be a goal to ensure that these other transport mechanisms are supported and useful, the focus of\nscrapli development will be on the \"system\" SSH transport.</p>\n<p>Example using <code>paramiko</code> as the transport:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">scrapli.driver.core</span> <span class=\"kn\">import</span> <span class=\"n\">IOSXEDriver</span>\n\n<span class=\"n\">my_device</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"host\"</span><span class=\"p\">:</span> <span class=\"s2\">\"172.18.0.11\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_username\"</span><span class=\"p\">:</span> <span class=\"s2\">\"vrnetlab\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_password\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VR-netlab9\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"auth_strict_key\"</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"transport\"</span><span class=\"p\">:</span> <span class=\"s2\">\"paramiko\"</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">with</span> <span class=\"n\">IOSXEDriver</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">my_device</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">get_prompt</span><span class=\"p\">())</span>\n</pre>\n<p>Currently the only reason I can think of to use anything other than \"system\" as the transport would be to test\nscrapli on a Windows host or to use telnet. If there are other good reasons please do let me know!</p>\n<h2>Auth Bypass</h2>\n<p><em>NOTE</em> Currently only supported with system transport!</p>\n<p>Some devices, such as Cisco WLC, have no \"true\" SSH authentication, and instead prompt for credentials (or perhaps\nnot even that) after session establishment. In order to cope with this corner case, the <code>auth_bypass</code> flag can be\nset to <code>True</code> which will cause scrapli to skip all authentication steps. Typically this flag would be set and a\ncustom <code>on_open</code> function set to handle whatever prompts the device has upon SSH session establishment.</p>\n<p>In the future this functionality will likely be extended to the telnet transport, and may be extended to paramiko and\nssh2 transports.</p>\n<p>See the <a href=\"/examples/non_core_device/wlc.py\" rel=\"nofollow\">non core device example</a> to see this in action.</p>\n<h2>Transport Options</h2>\n<p>Because each transport has different options/features available, it doesn't make sense to try to put all possible\narguments in the <code>Scrape</code> or <code>NetworkDriver</code> drivers, to address this an argument <code>transport_options</code> has been added\n. This is exactly what it sounds like -- arguments that can be passed to the selected transport class. As these\narguments will be transport-specific, please check the docs/docstrings for your preferred transport to see what is\navailable.</p>\n<p>A simple example of passing additional SSH arguments to the <code>SystemSSHTransport</code> class is available\n<a href=\"examples/transport_options/system_ssh_args.py\" rel=\"nofollow\">here</a>.</p>\n<h1>FAQ</h1>\n<ul>\n<li>Question: Why build this? Netmiko exists, Paramiko exists, Ansible exists, etc...?\n<ul>\n<li>Answer: I built <code>ssh2net</code> to learn -- to have a goal/target for writing some code. scrapli is an evolution of the\nlessons learned building ssh2net. About mid-way through building <code>ssh2net</code> I realized it may actually be kinda good\nat doing... stuff. So, sure there are other tools out there, but I think scrapli its pretty snazzy and fills in some\nof the gaps in other tools. For example scrapli is 100% compliant with strict mypy type checking, very uniformly\ndocumented/linted, contains a results object for every operation, is very very fast, is very flexible, and in\ngeneral pretty awesome! Finally, while I think in general that SSH \"screen scraping\" is not \"sexy\" or even\n\"good\", it is the lowest common denominator for automation in the networking world. So I figured I could try\nto make the fastest, most flexible library around for SSH network automation!</li>\n</ul>\n</li>\n<li>Question: Is this better than Netmiko/Paramiko/Ansible?\n<ul>\n<li>Answer: Nope! It is different though! The main focus is just to be stupid fast. It is very much that. It <em>should</em> be\nsuper reliable too as the timeouts are very easy/obvious to control, and it should also be very very very easy to\nadapt to any other network-y type CLI by virtue of flexible prompt finding and easily modifiable on connect\nfunctions.</li>\n</ul>\n</li>\n<li>Question: Is this easy to use?\n<ul>\n<li>Answer: Yep! The base usage with <code>Scrape</code> is pretty straight forward -- the thing to remember is that it doesn't\ndo \"things\" for you like Netmiko does for example, so its a lot more like Paramiko in that regard this just means\nthat you need to disable paging yourself (or pass an <code>on_open</code> callable to do so), handle privilege modes and\nthings like that. That said you can use one of the available drivers to have a more Netmiko-like experience -OR\n<ul>\n<li>write your own driver as this has been built with the thought of being easily extended.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Why do I get a \"conn (or your object name here) has no attribute channel\" exception?\n<ul>\n<li>Answer: Connection objects do not \"auto open\", and the channel attribute is not assigned until opening the\nconnection. Call <code>conn.open()</code> (or your object name in place of conn) to open the session and assign the channel\nattribute. Alternatively you can use any of the drivers with a context manager (see what I did there? WITH... get\nit?) which will auto-magically open and close the connections for you.</li>\n</ul>\n</li>\n<li>I wanna go fast!\n<ul>\n<li>Hmmm... not a question but I dig it. If you wanna go fast you gotta learn to drive with the fear... ok, enough\nTalladega Nights quoting for now. In theory using the <code>ssh2</code> transport is the gateway to speed... being a very\nthin wrapper around libssh2 means that its basically all C and that means its probably about as fast as we're\nreasonably going to get. All that said, scrapli by default uses the <code>system</code> transport which is really just\nusing your system ssh.... which is almost certainly libssh2/openssh which is also C. There is a thin layer of\nabstraction between scrapli and your system ssh but really its just reading/writing to a file which Python\nshould be doing in C anyway I would think. In summary... while <code>ssh2</code> is probably the fastest you can go with\nscrapli, the difference between <code>ssh2</code> and <code>system</code> transports in limited testing is microscopic, and the\nbenefits of using system transport (native ssh config file support!!) probably should outweigh the speed of\nssh2 -- especially if you have control persist and can take advantage of that with system transport!</li>\n</ul>\n</li>\n<li>Other questions? Ask away!</li>\n</ul>\n<h1>Transport Notes, Caveats, and Known Issues</h1>\n<h2>paramiko</h2>\n<ul>\n<li>Currently there seems to be a cosmetic bug where there is an error message about some socket error... but\neverything seems to work as expected.</li>\n</ul>\n<h3>SSH Config Supported Arguments</h3>\n<ul>\n<li>user</li>\n<li>port</li>\n<li>identity_file</li>\n</ul>\n<h3>Known Issues</h3>\n<ul>\n<li>None yet!</li>\n</ul>\n<h2>ssh2-python</h2>\n<h3>SSH Config Supported Arguments</h3>\n<ul>\n<li>user</li>\n<li>port</li>\n<li>identity_file</li>\n</ul>\n<h3>Known Issues</h3>\n<ul>\n<li>Arista EOS uses keyboard interactive authentication which is currently broken in the pip-installable version\nof ssh2-python (as of January 2020). GitHub user <a href=\"https://github.com/Red-M\" rel=\"nofollow\">Red-M</a> has contributed to and fixed this\nparticular issue but the fix has not been merged. If you would like to use ssh2-python with EOS I suggest cloning\nand installing via Red-M's repository or my fork of Red-M's fork!\n<ul>\n<li>Windows users using python3.8 may need to use Red-M's fork, quick testing in GitHub actions for py3.8 on Windows\nhad install failures for ssh2-python.</li>\n</ul>\n</li>\n<li>Use the context manager where possible! More testing needs to be done to confirm/troubleshoot, but limited testing\nseems to indicate that without properly closing the connection there appears to be a bug that causes Python to crash\non MacOS at least. More to come on this as I have time to poke it more! I believe this is only occurring on the\nlatest branch/update (i.e. not on the pip installable version). (April 2020 -- this may be fixed... need to retest\n...)</li>\n</ul>\n<h2>system</h2>\n<ul>\n<li>Any arguments passed to the <code>SystemSSHTransport</code> class will override arguments in your ssh config file. This is\nbecause the arguments get crafted into an \"open_cmd\" (the command that actually fires off the ssh session), and\nthese cli arguments take precedence over the config file arguments.</li>\n<li>If you set <code>ssh_config_file</code> to <code>False</code> the <code>SystemSSHTransport</code> class will set the config file used to <code>/dev/null</code> so that no ssh config file configs are accidentally used.</li>\n<li>There is zero Windows support for system ssh transport - I would strongly encourage the use of WSL or cygwin and\nsticking with systemssh instead of using paramiko/ssh2 natively in Windows -- system ssh is very much the focus of\ndevelopment for scrapli!</li>\n</ul>\n<h3>SSH Config Supported Arguments</h3>\n<ul>\n<li>literally whatever your system supports as scrapli just execs SSH on your system!</li>\n</ul>\n<h3>Known Issues</h3>\n<ul>\n<li>None yet!</li>\n</ul>\n<h2>telnet</h2>\n<ul>\n<li>See the telnet section!</li>\n</ul>\n<h3>SSH Config Supported Arguments</h3>\n<ul>\n<li>Obviously none!</li>\n</ul>\n<h3>Known Issues</h3>\n<ul>\n<li>None yet!</li>\n</ul>\n<h1>Linting and Testing</h1>\n<h2>Linting</h2>\n<p>This project uses <a href=\"https://github.com/psf/black\" rel=\"nofollow\">black</a> for auto-formatting. In addition to black, tox will execute\n<a href=\"https://github.com/klen/pylama\" rel=\"nofollow\">pylama</a>, and <a href=\"https://github.com/PyCQA/pydocstyle\" rel=\"nofollow\">pydocstyle</a> for linting purposes\n. Tox will also run  <a href=\"https://github.com/python/mypy\" rel=\"nofollow\">mypy</a>, with strict type checking. Docstring linting with\n<a href=\"https://github.com/terrencepreilly/darglint\" rel=\"nofollow\">darglint</a> which has been quite handy!</p>\n<p>All commits to this repository will trigger a GitHub action which runs tox, but of course its nicer to just run that\nbefore making a commit to ensure that it will pass all tests!</p>\n<h3>Typing</h3>\n<p>As stated, this project is 100% type checked and will remain that way. The value this adds for IDE auto-completion\nand just general sanity checking/forcing writing of more type-check-able code is worth the small overhead in effort.</p>\n<h2>Testing</h2>\n<p>Testing is broken into two main categories -- unit and functional. Unit is what you would expect -- unit testing the\ncode. Functional testing connects to virtual devices in order to more accurately test the code. Unit tests cover\nquite a bit of the code base due to mocking the FileIO that the channel reads/writes to. This gives a pretty high\nlevel of confidence that at least object instantiation and channel read/writes will generally work... Functional\ntests against virtual devices helps reinforce that and gets coverage for the transport classes.</p>\n<p>For more ad-hoc type testing there is a <code>smoke</code> folder in the tests directory -- for \"smoke tests\". These are simple\nscripts that don't really \"test\" (as in no assertions or pytest or anything), but are useful for basic testing that\nthings have not gotten broken while working on new features. These have been handy for spot testing during\ndevelopment so rather than leave them in a private directory they are included here in case they are useful for\nanyone else!</p>\n<h3>Unit Tests</h3>\n<p>Unit tests can be executed via pytest:</p>\n<pre><code>python -m pytest tests/unit/\n</code></pre>\n<p>Or using the following make command:</p>\n<pre><code>make test_unit\n</code></pre>\n<p>If you would like to see the coverage report and generate the html coverage report:</p>\n<pre><code>make cov_unit\n</code></pre>\n<h3>Setting up Functional Test Environment</h3>\n<p>Executing the functional tests is a bit more complicated! First, thank you to Kristian Larsson for his great tool\n<a href=\"https://github.com/plajjan/vrnetlab\" rel=\"nofollow\">vrnetlab</a>! All functional tests are built on this awesome platform that allows\nfor easy creation of containerized network devices.</p>\n<p>Basic functional tests exist for all \"core\" platform types (IOSXE, NXOS, IOSXR, EOS, Junos) as well as basic testing\nfor Linux. Vrnetlab currently only supports the older emulation style NX-OS devices, and <em>not</em> the newer VM image\nn9kv. I have made some very minor tweaks to vrnetlab locally in order to get the n9kv image running. I also have\nmade some changes to enable scp-server for IOSXE/NXOS devices to allow for config replaces with NAPALM right out\nof the box. You can get these tweaks in my fork of vrnetlab. Getting going with vrnetlab is fairly\nstraightforward -- simply follow Kristian's great readme docs.</p>\n<p>For the Arista EOS image -- prior to creating the container you should boot the device and enter the <code>zerotouch disable</code> command. This allows for the config to actually be saved and prevents the interfaces from cycling through\ninterface types in the container (I'm not clear why it does that but executing this command before building the\ncontainer \"fixes\" this!). An example qemu command to boot up the EOS device is:</p>\n<pre><code>qemu-system-x86_64 -enable-kvm -display none -machine pc -monitor tcp:0.0.0.0:4999,server,nowait -m 4096 -serial telnet:0.0.0.0:5999,server,nowait -drive if=ide,file=vEOS-lab-4.22.1F.vmdk -device pci-bridge,chassis_nr=1,id=pci.1 -device e1000,netdev=p00,mac=52:54:00:54:e9:00 -netdev user,id=p00,net=10.0.0.0/24,tftp=/tftpboot,hostfwd=tcp::2022-10.0.0.15:22,hostfwd=tcp::2023-10.0.0.15:23,hostfwd=udp::2161-10.0.0.15:161,hostfwd=tcp::2830-10.0.0.15:830,hostfwd=tcp::2080-10.0.0.15:80,hostfwd=tcp::2443-10.0.0.15:443\n</code></pre>\n<p>Once booted, connect to the device (telnet to container IP on port 5999 if using above command), issue the command\n<code>zerotouch disable</code>, save the config and then you can shut it down, and make the container.</p>\n<p>The docker-compose file here will be looking for the container images matching this pattern, so this is an important\nbit! The container image names should be:</p>\n<pre><code>scrapli-cisco-iosxe\nscrapli-cisco-nxos\nscrapli-cisco-iosxr\nscrapli-arista-eos\nscrapli-juniper-junos\n</code></pre>\n<p>You can tag the image names on creation (following the vrnetlab readme docs), or create a new tag once the image is built:</p>\n<pre><code>docker tag [TAG OF IMAGE CREATED] scrapli-[VENDOR]-[OS]\n</code></pre>\n<p><em>NOTE</em> If you are going to test scrapli, use <a href=\"https://github.com/carlmontanari/vrnetlab\" rel=\"nofollow\">my fork of vrnetlab</a> -- I've\nenabled telnet, set ports, taken care of setting things up so that NAPALM can config replace, etc.</p>\n<h3>Functional Tests</h3>\n<p>Once you have created the images, you can start all of the containers with a make command:</p>\n<pre><code>make start_dev_env\n</code></pre>\n<p>Conversely you can terminate the containers:</p>\n<pre><code>make stop_dev_env\n</code></pre>\n<p>To start a specific platform container:</p>\n<pre><code>make start_dev_env_iosxe\n</code></pre>\n<p>Substitute \"iosxe\" for the platform type you want to start.</p>\n<p>Most of the containers don't take too long to fire up, maybe a few minutes (running on my old macmini with Ubuntu, so\nnot exactly a powerhouse!). That said, the IOS-XR device takes about 15 minutes to go to \"healthy\" status. Once\nbooted up you can connect to their console or via SSH:</p>\n<table>\n<thead>\n<tr>\n<th>Device</th>\n<th>Local IP</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>iosxe</td>\n<td>172.18.0.11</td>\n</tr>\n<tr>\n<td>nxos</td>\n<td>172.18.0.12</td>\n</tr>\n<tr>\n<td>iosxr</td>\n<td>172.18.0.13</td>\n</tr>\n<tr>\n<td>eos</td>\n<td>172.18.0.14</td>\n</tr>\n<tr>\n<td>junos</td>\n<td>172.18.0.15</td>\n</tr>\n<tr>\n<td>linux</td>\n<td>172.18.0.20</td>\n</tr></tbody></table>\n<p>The console port for all devices is 5000, so to connect to the console of the iosxe device you can simply telnet to\nthat port locally:</p>\n<pre><code>telnet 172.18.0.11 5000\n</code></pre>\n<p>Credentials for all devices use the default vrnetlab credentials:</p>\n<p>Username: <code>vrnetlab</code></p>\n<p>Password: <code>VR-netlab9</code></p>\n<p>You should also run the <code>prepare_devices</code> script in the functional tests, or use the Make commands to do so for you\n. This script will deploy the base config needed for testing. The make commands for this step follow the same pattern\nas the others:</p>\n<ul>\n<li><code>prepare_dev_env</code> will push the base config to all devices</li>\n<li><code>prepare_dev_env_XYZ</code> where XYZ == \"iosxe\", \"nxos\", etc. will push the base config for the specified device.</li>\n</ul>\n<p>Once the container(s) are ready, you can use the make commands to execute tests as needed:</p>\n<ul>\n<li><code>test</code> will execute all currently implemented functional tests as well as the unit tests</li>\n<li><code>test_functional</code> will execute all currently implemented functional tests</li>\n<li><code>test_iosxe</code> will execute all unit tests and iosxe functional tests</li>\n<li><code>test_nxos</code> will execute all unit tests and nxos functional tests</li>\n<li><code>test_iosxr</code> will execute all unit tests and iosxr functional tests</li>\n<li><code>test_eos</code> will execute all unit tests and eos functional tests</li>\n<li><code>test_junos</code> will execute all unit tests and junos functional tests</li>\n<li><code>test_linux</code> will execute all unit tests and basic linux functional tests (this is really intended to test the base\n<code>Scrape</code> driver instead of the network drivers)</li>\n</ul>\n<h3>Other Functional Test Info</h3>\n<p>IOSXE is the only platform that is testing SSH key based authentication at the moment. The key is pushed via NAPALM in\nthe setup phase. This was mostly done out of laziness, and in the future the other platforms may be tested with key\nbased auth as well, but for now IOSXE is representative enough to provide some faith that key based auth works!</p>\n<h1>Todo and Roadmap</h1>\n<p>This section may not get updated much, but will hopefully reflect the priority items for short term (todo) and longer\nterm (roadmap) for scrapli.</p>\n<h2>Todo</h2>\n<ul>\n<li>Investigate setter methods for setting user/pass/and other attrs on base scrape object... they should be able to be\nset at that level and have the transport updated if it can be done reasonably</li>\n<li>Refresh the keepalive stuff -- how/where keepalives get kicked off needs to be reevaluated, particularly for\nsystemssh \"standard\" keepalives as this should really be happening in the open command (systemssh will probably have\nto override some Transport methods basically), get all of this under functional testing as well</li>\n<li>Add tests for timeouts if possible</li>\n<li>Add more tests for auth failures</li>\n<li>Add tests for custom on open/close functions</li>\n<li>Remove as much as possible from the vendor'd <code>ptyprocess</code> code. Type hint it, add docstrings everywhere, add tests\nif possible (and remove from ignore for test coverage and darglint).</li>\n<li>Add darglint back in if it gets faster</li>\n</ul>\n<h2>Roadmap</h2>\n<ul>\n<li>Async support. This is a bit of a question mark as I personally don't know even where to start to implement this\n, and have no real current use case... that said I think it would be cool if for no other reason than to learn!</li>\n<li>Plugins -- build framework to allow for others to easily build driver plugins if desired</li>\n<li>Ensure v6 stuff works as expected.</li>\n<li>Continue to add/support ssh config file things.</li>\n<li>Maybe make this into a netconf driver as well? ncclient is just built on paramiko so it seems doable...?</li>\n</ul>\n\n          </div>"}, "last_serial": 7142050, "releases": {"2020.2.14": [{"comment_text": "", "digests": {"md5": "da88be8bfb074075882b71f37c929962", "sha256": "fd2d4c4bf56a110720754411652eb16e551a70fd907c40813bb4d5bed14ad7b5"}, "downloads": -1, "filename": "scrapli-2020.2.14-py3-none-any.whl", "has_sig": false, "md5_digest": "da88be8bfb074075882b71f37c929962", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 89704, "upload_time": "2020-02-15T03:18:35", "upload_time_iso_8601": "2020-02-15T03:18:35.250552Z", "url": "https://files.pythonhosted.org/packages/bd/3b/c522be2fe7907c16cb504fa00f4e104ea102a7bc5cddaa89b1d9b5b06aa0/scrapli-2020.2.14-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f830a35f917956bac5862a51961f76d0", "sha256": "e2b2abca8c670887ce4717f6edcba964d1d22eda98160c1a87643db46fec6c83"}, "downloads": -1, "filename": "scrapli-2020.2.14.tar.gz", "has_sig": false, "md5_digest": "f830a35f917956bac5862a51961f76d0", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 90385, "upload_time": "2020-02-15T03:18:37", "upload_time_iso_8601": "2020-02-15T03:18:37.137697Z", "url": "https://files.pythonhosted.org/packages/9d/84/0e2a354af0bdc183e09ff202deea7cf76893926cb63c8dca1144fced42bf/scrapli-2020.2.14.tar.gz", "yanked": false}], "2020.2.17": [{"comment_text": "", "digests": {"md5": "d379d44acfbff4ef0a5e5f2c056c33cb", "sha256": "afe865d0b7ff24c4519d40ea8224c28de85f978e8028286fb82b3d8cbbd88de3"}, "downloads": -1, "filename": "scrapli-2020.2.17-py3-none-any.whl", "has_sig": false, "md5_digest": "d379d44acfbff4ef0a5e5f2c056c33cb", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 92056, "upload_time": "2020-02-18T01:53:06", "upload_time_iso_8601": "2020-02-18T01:53:06.143488Z", "url": "https://files.pythonhosted.org/packages/23/64/30d7500c8cc615f19b9435d4a2061210b41ad047d71c9543b4445f8abb1e/scrapli-2020.2.17-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "880577109a79c2909c2546152dcc28eb", "sha256": "10e918483e5a0ba493a7e6dd7882c66a89f3373107ea6eccfec2b6b663f2f180"}, "downloads": -1, "filename": "scrapli-2020.2.17.tar.gz", "has_sig": false, "md5_digest": "880577109a79c2909c2546152dcc28eb", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 91995, "upload_time": "2020-02-18T01:53:07", "upload_time_iso_8601": "2020-02-18T01:53:07.701333Z", "url": "https://files.pythonhosted.org/packages/67/d5/d9d6ecda7a6d72da2ce4524f3ca125fb8aded2d7b0efbbdd4d416b3a7cd6/scrapli-2020.2.17.tar.gz", "yanked": false}], "2020.2.23": [{"comment_text": "", "digests": {"md5": "f2ff8b238083fadbeaf9cbed65a47cb9", "sha256": "f406bdffee64018d2f47a91c48990b7af7f8e50a6daa27146c5666db1a9b8601"}, "downloads": -1, "filename": "scrapli-2020.2.23-py3-none-any.whl", "has_sig": false, "md5_digest": "f2ff8b238083fadbeaf9cbed65a47cb9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 100220, "upload_time": "2020-02-24T01:32:00", "upload_time_iso_8601": "2020-02-24T01:32:00.894468Z", "url": "https://files.pythonhosted.org/packages/f8/80/cdffd15eec3403d476f797dd7211247eb3c740f78326fb70a174c7982d29/scrapli-2020.2.23-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "30fcc45fa718c84b9d5730f56b024c5f", "sha256": "4c8074b30d112cf713ce9c993fa77f40d32725af0c20f4c2dad2715897d191cf"}, "downloads": -1, "filename": "scrapli-2020.2.23.tar.gz", "has_sig": false, "md5_digest": "30fcc45fa718c84b9d5730f56b024c5f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 98300, "upload_time": "2020-02-24T01:32:03", "upload_time_iso_8601": "2020-02-24T01:32:03.564181Z", "url": "https://files.pythonhosted.org/packages/f9/8d/043a709eb72e744215964681dfb9662258dd5bd92ad168bfca8c0c94f88e/scrapli-2020.2.23.tar.gz", "yanked": false}], "2020.2.9": [{"comment_text": "", "digests": {"md5": "ec21f941bdc3dbf83fab10b8ac86e521", "sha256": "82f98b1c4e61babbde8d853364721bc72f99389e3eacb12e5f11025cfde7c3b0"}, "downloads": -1, "filename": "scrapli-2020.2.9-py3-none-any.whl", "has_sig": false, "md5_digest": "ec21f941bdc3dbf83fab10b8ac86e521", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 80897, "upload_time": "2020-02-10T04:36:43", "upload_time_iso_8601": "2020-02-10T04:36:43.447201Z", "url": "https://files.pythonhosted.org/packages/50/5c/40592238e3fc8fb524092424909f942cf7cad485cc27b1c9116d2d37e38b/scrapli-2020.2.9-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8cc260c13991a0b9fe0856b8a80d8d5b", "sha256": "30b2b570e756bfad236ecc90ab0068d539508632bf800bf7848827bfe16667f5"}, "downloads": -1, "filename": "scrapli-2020.2.9.tar.gz", "has_sig": false, "md5_digest": "8cc260c13991a0b9fe0856b8a80d8d5b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 77752, "upload_time": "2020-02-10T04:36:45", "upload_time_iso_8601": "2020-02-10T04:36:45.709149Z", "url": "https://files.pythonhosted.org/packages/6d/33/9334509f7d97e9aa7a3c799945f4460469e0984a29b02383b402ac9274f4/scrapli-2020.2.9.tar.gz", "yanked": false}], "2020.3.21": [{"comment_text": "", "digests": {"md5": "95852091c7b96b8d11efc14bffdf535a", "sha256": "061a7d1a59da20f7be6e15b6eea16611ed0e7ada5818f88abe98339e1cd785a7"}, "downloads": -1, "filename": "scrapli-2020.3.21-py3-none-any.whl", "has_sig": false, "md5_digest": "95852091c7b96b8d11efc14bffdf535a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 109568, "upload_time": "2020-03-21T23:10:48", "upload_time_iso_8601": "2020-03-21T23:10:48.737802Z", "url": "https://files.pythonhosted.org/packages/67/1e/d116b06102c229236825ef76c586cf8dac42a9166c3c4e0391c7efca946a/scrapli-2020.3.21-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b89d84144aa66f2561de0c79c392e322", "sha256": "e5d8aeba7ae58e15104ab39e29c93a709b3c216ff0a1e7632878a32971b7d50a"}, "downloads": -1, "filename": "scrapli-2020.3.21.tar.gz", "has_sig": false, "md5_digest": "b89d84144aa66f2561de0c79c392e322", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 111492, "upload_time": "2020-03-21T23:10:50", "upload_time_iso_8601": "2020-03-21T23:10:50.423194Z", "url": "https://files.pythonhosted.org/packages/49/e6/362e85a886917d2430a8daa40c90fed1a0b493b106f289f0f411e559b9a1/scrapli-2020.3.21.tar.gz", "yanked": false}], "2020.3.29": [{"comment_text": "", "digests": {"md5": "d34aefc68d80654fda2824233c9ea611", "sha256": "2f3fa57077b2534f087bae6c6fef74060622ab59445c656f1a24a1a960934e29"}, "downloads": -1, "filename": "scrapli-2020.3.29-py3-none-any.whl", "has_sig": false, "md5_digest": "d34aefc68d80654fda2824233c9ea611", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 114659, "upload_time": "2020-03-29T19:05:29", "upload_time_iso_8601": "2020-03-29T19:05:29.656025Z", "url": "https://files.pythonhosted.org/packages/80/ef/2706cdebf7734144429b59a4d19ceb17dc74574ef9c104d6081d37ee8418/scrapli-2020.3.29-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9c16a239812430230381570f7a32421b", "sha256": "3a9fd823aee1977c5d636040b2b8ac5f7118ffd440b2634fd4f20f8442157609"}, "downloads": -1, "filename": "scrapli-2020.3.29.tar.gz", "has_sig": false, "md5_digest": "9c16a239812430230381570f7a32421b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 116293, "upload_time": "2020-03-29T19:05:31", "upload_time_iso_8601": "2020-03-29T19:05:31.192963Z", "url": "https://files.pythonhosted.org/packages/4a/9c/9c8f60e87e35de4c553a7411dd9529de8676a4cd222392597cd479866ced/scrapli-2020.3.29.tar.gz", "yanked": false}], "2020.3.5": [{"comment_text": "", "digests": {"md5": "79c7e57417c19fd392f9adb135853617", "sha256": "34334d558e269e224ab41113332e5a5e620699b8aca27b728cb9d0749d959772"}, "downloads": -1, "filename": "scrapli-2020.3.5-py3-none-any.whl", "has_sig": false, "md5_digest": "79c7e57417c19fd392f9adb135853617", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 106583, "upload_time": "2020-03-05T16:09:38", "upload_time_iso_8601": "2020-03-05T16:09:38.118731Z", "url": "https://files.pythonhosted.org/packages/d3/7b/75e809a88176488c0b7e8f8f4cca6d0bd6a6d99284c80b01d076af1776ba/scrapli-2020.3.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d099e0afb1efadcf44d2ac7143c7f65a", "sha256": "ad3a2e9b54fceeb9124cbcc11c568e4b44de02cf1b592eb38a644b3d319c8e5a"}, "downloads": -1, "filename": "scrapli-2020.3.5.tar.gz", "has_sig": false, "md5_digest": "d099e0afb1efadcf44d2ac7143c7f65a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 102839, "upload_time": "2020-03-05T16:09:39", "upload_time_iso_8601": "2020-03-05T16:09:39.865880Z", "url": "https://files.pythonhosted.org/packages/d9/fd/48b7947eba9e632e3b86a47096d605ceaa2e9a6bb91bb4fd955962f10e2b/scrapli-2020.3.5.tar.gz", "yanked": false}], "2020.3.8": [{"comment_text": "", "digests": {"md5": "762d582ec44abd4e0cfc9a987c875b54", "sha256": "fe4b98d1f84d3579911027c8bfa7500136aabfff9eac1435c1f9cc8fb1940e62"}, "downloads": -1, "filename": "scrapli-2020.3.8-py3-none-any.whl", "has_sig": false, "md5_digest": "762d582ec44abd4e0cfc9a987c875b54", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 103989, "upload_time": "2020-03-08T23:33:13", "upload_time_iso_8601": "2020-03-08T23:33:13.661186Z", "url": "https://files.pythonhosted.org/packages/32/86/470cb6dab8f4a6f5d5d45a4ec192b3fc7acbd201b20fe455f6b6053c90a7/scrapli-2020.3.8-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "06786b5e8c7fb3e0915c5f0cbbef3273", "sha256": "a24a65b53cbb6af0ab304f05ee08d286b4f0bf65e0609d04ab0dcaf9eec68e05"}, "downloads": -1, "filename": "scrapli-2020.3.8.tar.gz", "has_sig": false, "md5_digest": "06786b5e8c7fb3e0915c5f0cbbef3273", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 106735, "upload_time": "2020-03-08T23:33:15", "upload_time_iso_8601": "2020-03-08T23:33:15.402635Z", "url": "https://files.pythonhosted.org/packages/74/f7/b4f5358465bed82b95cb233276766a58ca21dc5b70b46506eda75703e2c7/scrapli-2020.3.8.tar.gz", "yanked": false}], "2020.4.11": [{"comment_text": "", "digests": {"md5": "c466e9210dfb3a769a0cc8c73b4de048", "sha256": "0fe6866c0dad13ff9cfe419c68fb4c3db0c6d2964085bf143d618781eeebc0a4"}, "downloads": -1, "filename": "scrapli-2020.4.11-py3-none-any.whl", "has_sig": false, "md5_digest": "c466e9210dfb3a769a0cc8c73b4de048", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 119349, "upload_time": "2020-04-11T18:21:09", "upload_time_iso_8601": "2020-04-11T18:21:09.152281Z", "url": "https://files.pythonhosted.org/packages/c3/35/5d33ce9fd609fd5133ee19c3d434ecca9c64cfd1880c44f96b921f849728/scrapli-2020.4.11-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "edcb67556e17f26964da0cf5ed4db134", "sha256": "dfe3de859c7216eb624671523092ac2d526ba47c57965e45f900a7e175a7fc41"}, "downloads": -1, "filename": "scrapli-2020.4.11.tar.gz", "has_sig": false, "md5_digest": "edcb67556e17f26964da0cf5ed4db134", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 121834, "upload_time": "2020-04-11T18:21:10", "upload_time_iso_8601": "2020-04-11T18:21:10.863169Z", "url": "https://files.pythonhosted.org/packages/54/c1/bf7f0f370c1cc238e10ce3cdb1b0c258d29c1304e269b8375dadd4abbec5/scrapli-2020.4.11.tar.gz", "yanked": false}], "2020.4.19": [{"comment_text": "", "digests": {"md5": "e6d7afc0569bb2e0e999ac81778e40c2", "sha256": "de511a73b0f36463f70a8fe22f4922ab7c5af9e6b406170613fe4d2ed6ffcfbb"}, "downloads": -1, "filename": "scrapli-2020.4.19-py3-none-any.whl", "has_sig": false, "md5_digest": "e6d7afc0569bb2e0e999ac81778e40c2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 113316, "upload_time": "2020-04-20T00:54:11", "upload_time_iso_8601": "2020-04-20T00:54:11.558716Z", "url": "https://files.pythonhosted.org/packages/df/d1/63b4161163c6ddce3037c6294c6adbafb995618b5ffebfa24101fc91fd5f/scrapli-2020.4.19-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "682a0ed2d3060965ea70ca3b59168459", "sha256": "3640b1be3e56975bb24b7d530ec167114e11c1c6662e3a3eef0cd14478a80f78"}, "downloads": -1, "filename": "scrapli-2020.4.19.tar.gz", "has_sig": false, "md5_digest": "682a0ed2d3060965ea70ca3b59168459", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 119897, "upload_time": "2020-04-20T00:54:13", "upload_time_iso_8601": "2020-04-20T00:54:13.368523Z", "url": "https://files.pythonhosted.org/packages/56/64/2bb36500e1b1c08cd5df16db42a220e132116154457dcfcdba86da3fee39/scrapli-2020.4.19.tar.gz", "yanked": false}], "2020.4.30": [{"comment_text": "", "digests": {"md5": "fbde1c6e7ad495b231e0562da63dbed7", "sha256": "45dedbe99e94b428b7dc312e9de02e58d2642772de5b7dbd0768abecf3327de3"}, "downloads": -1, "filename": "scrapli-2020.4.30-py3-none-any.whl", "has_sig": false, "md5_digest": "fbde1c6e7ad495b231e0562da63dbed7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 115996, "upload_time": "2020-05-01T01:16:59", "upload_time_iso_8601": "2020-05-01T01:16:59.510099Z", "url": "https://files.pythonhosted.org/packages/85/d2/016ffd331e94a04185e67caa0155e16bddcf64a88ca53afec054065502ab/scrapli-2020.4.30-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "774fae7d366e958c4117c99316eaf968", "sha256": "b81d6f0ba9eb3b3334f99324ab4d6f63a2928d50455dd5d4af5ef97d02ab75fd"}, "downloads": -1, "filename": "scrapli-2020.4.30.tar.gz", "has_sig": false, "md5_digest": "774fae7d366e958c4117c99316eaf968", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 125045, "upload_time": "2020-05-01T01:17:01", "upload_time_iso_8601": "2020-05-01T01:17:01.039336Z", "url": "https://files.pythonhosted.org/packages/f1/16/15cd038b4d7970358d0f1d5b1e23b9fd106b1f5f6eb0c330e8f544286980/scrapli-2020.4.30.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fbde1c6e7ad495b231e0562da63dbed7", "sha256": "45dedbe99e94b428b7dc312e9de02e58d2642772de5b7dbd0768abecf3327de3"}, "downloads": -1, "filename": "scrapli-2020.4.30-py3-none-any.whl", "has_sig": false, "md5_digest": "fbde1c6e7ad495b231e0562da63dbed7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 115996, "upload_time": "2020-05-01T01:16:59", "upload_time_iso_8601": "2020-05-01T01:16:59.510099Z", "url": "https://files.pythonhosted.org/packages/85/d2/016ffd331e94a04185e67caa0155e16bddcf64a88ca53afec054065502ab/scrapli-2020.4.30-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "774fae7d366e958c4117c99316eaf968", "sha256": "b81d6f0ba9eb3b3334f99324ab4d6f63a2928d50455dd5d4af5ef97d02ab75fd"}, "downloads": -1, "filename": "scrapli-2020.4.30.tar.gz", "has_sig": false, "md5_digest": "774fae7d366e958c4117c99316eaf968", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 125045, "upload_time": "2020-05-01T01:17:01", "upload_time_iso_8601": "2020-05-01T01:17:01.039336Z", "url": "https://files.pythonhosted.org/packages/f1/16/15cd038b4d7970358d0f1d5b1e23b9fd106b1f5f6eb0c330e8f544286980/scrapli-2020.4.30.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:56:51 2020"}