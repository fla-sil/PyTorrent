{"info": {"author": "Steven Herbst", "author_email": "sgherbst@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)"], "description": "# svreal\n[![Actions Status](https://github.com/sgherbst/svreal/workflows/Regression/badge.svg)](https://github.com/sgherbst/svreal/actions)\n[![BuildKite Status](https://badge.buildkite.com/45ed712ae8720e9a3e7c040d2e3bc441a18b6ef269e4573723.svg)](https://buildkite.com/stanford-aha/svreal)\n[![Code Coverage](https://codecov.io/gh/sgherbst/svreal/branch/master/graph/badge.svg)](https://codecov.io/gh/sgherbst/svreal)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n[![PyPI version](https://badge.fury.io/py/svreal.svg)](https://badge.fury.io/py/svreal)\n\n**svreal** is a single-file SystemVerilog library that makes it easy to perform fixed-point operations in a synthesizable fashion in SystemVerilog.  The exponent and alignment details are handled automatically, so the user is free to customize the format of each fixed-point signal in the design without inconvenience.  For debugging range/resolution issues, the user can switch all signal types to a floating-point representation using a single **define** command-line option.  Supported fixed-point operations include addition, subtraction, negation, multiplication, comparison, and conditional assignment.\n\n# Installation\n\n```shell\n> pip install svreal\n```\n\nIf you get a permissions error when running the **pip** command, you can try adding the **--user** flag.  This will cause **pip** to install packages in your user directory rather than to a system-wide location.\n\n# Introduction\n\n## Simple example\n\nHere's a simple **svreal** example to get started.  Note that we only have to include a single file, \"svreal.sv\".  That file is stored in the **site-packages/svreal** directory; its location can be accessed programmatically using the function **svreal.get\\_svreal\\_header()**.\n```verilog\n`include \"svreal.sv\"\n`MAKE_REAL(a, 5.0);\n`MAKE_GENERIC_REAL(b, 10.0, 42);\n`ADD_REAL(a, b, c);\ninitial begin\n    `FORCE_REAL(1.23, a);\n    `FORCE_REAL(4.56, b);\n    #(1ns);\n    `PRINT_REAL(c);\nend\n```\nThis creates fixed-point signals **a**, **b**, and **c** and instantiates an adder that sums **a** and **b** into **c**.  In the **initial** block, the values of **a** and **b** are set to \"1.23\" and \"4.56\" and then the value of \"c\" is printed.  Hence, we'd expect that the value of **c** is around \"5.79\".\n\n## Fixed-point formatting\n\nIn **svreal**, fixed-point formats are generally determined automatically from the range of the signals they represent.  In this case, the range of **a** is set to +/- 5.0, and the range of **b** is set to +/- 10.0.  The width of **a** is not specified, so it defaults to **\\`LONG_WIDTH_REAL** (which is 25 unless overridden by the user).  For **b**, the user has explicitly specified a width of 42 bits.  In both cases, the exponent used in the representation is automatically determined from the the width and range, using the formula:\n\n```code\nexponent = int(ceil(log2(range/(2^(width-1)-1))))\n```\n\nThis method of selecting the exponent guarantees that the user-specified range can be represented given the width of the fixed-point value.\n\nSince the user has not provided any formatting information for **c**, its range is automatically determined from the ranges of **a** and **b**.  Since **a** is +/- 5.0 and **b** is +/- 10.0, the range of **c** is +/- 15.0.  The width of **c** defaults to **\\`LONG_WIDTH_REAL**, and its exponent is calculated using the formula above.\n\n## Debugging\n\nSuppose that the range of **a** is not sufficient to contain the value being assigned to it.  Then **a** may contain an entirely wrong value due to overflow.  In order to debug this problem, define the **FLOAT_REAL** flag (for example, using **+define+FLOAT_REAL**).  This switches the real number representation from fixed-point to float-point, which helps the user to identify whether the fixed-point representation is the cause of the problem, or whether it is something else.  In addition, this flag adds assertions to check if any real-number signal exceeds its specified range.\n\nIt is also possible to debug underflow issues using **svreal**.  First set the **FLOAT_REAL** flag to switch to a floating-point representation.  If the problem goes away, but there are no assertion errors indicating overflows, then the problem is likely due to inadequate resolution in one or more **svreal** signals.  This theory can be validated by increasing **\\`LONG_WIDTH_REAL** and/or **\\`SHORT_WIDTH_REAL**.  If increasing **\\`SHORT_WIDTH_REAL** helps, then one or more multiplication constants need to have higher resolution.  Otherwise, one or more fixed-point signals or additive constants need more resolution.\n\n## Operations available\n\nHere is a partial list of operations that can be performed with **svreal**:\n\n### Assignment, negation, and absolute value\n\n```verilog\n`ASSIGN_REAL(in, out);\n`NEGATE_REAL(in, out);\n`ABS_REAL(in, out)\n```\n\nThese operations take one input (first argument) and produce one output (second argument).  Note that \\`ASSIGN_REAL should *always* be used in place of a raw **assign** statement.  This is because \\`ASSIGN_REAL performs alignment as necessary.\n\n### Arithmetic operations\n\n```verilog\n`MIN_REAL(a, b, out);\n`MAX_REAL(a, b, out);\n`ADD_REAL(a, b, out);\n`SUB_REAL(a, b, out);\n`MUL_REAL(a, b, out);\n```\n\nThese operations take two inputs (first and second arguments) and produce one output (third argument).  Note the ordering of the subtraction operation: \\`SUB_REAL(a, b, out) means \"out := a - b\".\n\n### Mux operations\n\n```verilog\n`ITE_REAL(cond, val_if_true, val_if_false, out);\n```\n\nThis is a handy operation when constructing conditional operations: if **cond** is \"1\", then **val_if_true** is muxed to **out**, otherwise if **cond** is \"0\", then **val_if_false** is muxed to **out**.  Note that this is not implemented as a literal mux, but instead performs alignment as necessary. Hence, the formats of all three fixed-point numbers can be different.\n\n### Real <-> integer conversion\n\n```verilog\n`REAL_TO_INT(in, $size(out), out);\n`INT_TO_REAL(in, $size(in), out);\n```\n\nSometimes it is necessary to convert a signed integer into an **svreal** type or vice versa.\n\nThe macro \\`REAL_TO_INT takes as its first argument an **svreal** type and as its third argument a **logic signed** type.  The second argument is the width of the **logic signed** type (it's left up to the user whether this comes from **$size**, **$bits**, or from a parameter due to simulator quirks).\n\nThe macro \\`INT_TO_REAL takes as its first argument a **logic signed** type and as its third argument an **svreal** type.  The third argument is the width of the **logic signed** type (it's left up to the user whether this comes from **$size**, **$bits**, or from a parameter due to simulator quirks).\n\n### Comparisons\n\n```verilog\n`LT_REAL(lhs, rhs, out);\n`LE_REAL(lhs, rhs, out);\n`GT_REAL(lhs, rhs, out);\n`GE_REAL(lhs, rhs, out);\n`EQ_REAL(lhs, rhs, out);\n`NE_REAL(lhs, rhs, out);\n```\n\nComparisons always take two fixed-point numbers as the first two arguments, ordered as the left-hand side followed by the right-hand side.  The third macro argument is the output, which is a single bit (type **logic**) with value \"1\" if the comparison is true and \"0\" if it is false.\n\n### Working with constants\n\n```verilog\n`MAKE_CONST_REAL(const, name);\n`ASSIGN_CONST_REAL(const, name);\n`ADD_CONST_REAL(const, in, out);\n`MUL_CONST_REAL(const, in, out);\n```\n\nSeveral functions are available to work with numeric constants.  **\\`MAKE_CONST_REAL** creates a new **svreal** type and assigns the given real-number constant to it.  Its width defaults to **\\`LONG_WIDTH_REAL** and the exponent is selected automatically based on the constant value.  **\\`ASSIGN_CONST_REAL** is similar but does not declare a new **svreal** type; it simply assigns the constant to an existing fixed-point signal (performing the floating-to-fixed conversion at compile time).\n\n**\\`ADD_CONST_REAL** and **\\`MUL_CONST_REAL** allow the user to add a constant to a number or multiply a constant by a number, respectively.  There is one special caveat for **\\`MUL_CONST_REAL**, which is that it represents the constant with a fixed-point number of width **\\`SHORT_WIDTH_REAL** (18 unless overridden by the user).  As a result, the user can cause **\\`MUL_CONST_REAL** to consume exactly one DSP block by picking **\\`LONG_WIDTH_REAL** and **\\`SHORT_WIDTH_REAL** to be the operand widths of the target FPGA's DSP multipliers.\n\n### Memory\n\n```verilog\n`DFF_REAL(d, q, rst, clk, cke, init);\n```\n\nFixed-point memory is implemented as a generic D-type flip-flop (DFF).  The input to this flip-flop is **d**, and the output is **q**.  Both are fixed-point types, but it's fine if they can have different formats.\n\nThe **rst** signals is a single active-high bit (type **logic**).  It's a synchronous reset, and when active it causes **q** to take the value of **init**.  **init** is simply a real-number value like \"1.23\".\n\nFinally, **clk** and **cke** are single bit signals (type **logic**).  **clk** is the clock input of the DFF (active on the rising edge), and **cke** is the clock enable signal (active high). \n\n### Assigning results to existing signals\n\nMost operations have an alternate form that allows the user to assign the result of an operation to an existing fixed-point signal.  This is indicated by the word **INTO** in the macro name.  For example, suppose that we have defined three signals, **a**, **b**, and **c**, and want to assign the sum of **a** and **b** into **c**:\n\n```verilog\n`MAKE_REAL(a, 10.0); // i.e., +/- 10\n`MAKE_REAL(b, 21.0); // i.e., +/- 21\n`MAKE_REAL(c, 32.0); // i.e., +/- 32\n`ADD_INTO_REAL(a, b, c);\n```\n\nThis special form of the \"add\" operation will not declare a new signal **c**, but instead will assign the result of the addition to the existing signal called **c** (performing alignment shifts as necessary, of course).\n\nIn this case, there is a risk that **c** may have been declared with insufficient range to hold the result.  As mentioned before, this can be debugged using the **FLOAT_REAL** flag, which adds range assertions.  So why would a user ever want to use the **INTO** form of the **svreal** macros?  The most common case is that they are assigning to a signal that appears on the I/O list of the module.  Alternatively, they may want to manually specify the range or resolution of the output signal.  However, a better way to accomplish that is to use the **GENERIC** form of operations, as described in the next section.\n\n### Specifying output resolution\n\nMost operations have an alternate form ending with **GENERIC** that allows the user to specify the width of the result.  Since the range of the operation is determined automatically, this effectively controls the resolution of the operation.  As an example, suppose we want to multiply two signals, but represent the output with more precision than the default.  In that case we could write\n\n```verilog\n`MAKE_REAL(a, 10.0); // i.e., +/- 10\n`MAKE_REAL(b, 21.0); // i.e., +/- 21\n`MUL_REAL_GENERIC(a, b, c, 40);\n```\n\nThis means: multiply **a** and **b** and store the result in **c** with the appropriate alignment.  The width of **c** is given the custom value \"40\", and the range of **c** is still determined automatically.  As a result, the user can control the precision of intermediate results, and this in turn is useful when debugging underflow issues.\n\n## Passing fixed-point signals\n\nSince compile-time parameters are used to store some of the fixed-point formatting information, some care must be taken when passing **svreal** signals through a hierarchy to ensure that information is not lost.  Consider this example, in which an outer block instantiates a module that multiplies together two signals to produce an output:\n\n```verilog\n`include \"svreal.sv\"\nmodule inner #(\n    `DECL_REAL(in0),\n    `DECL_REAL(in1),\n    `DECL_REAL(out)\n) (\n    `INPUT_REAL(in0),\n    `INPUT_REAL(in1),\n    `OUTPUT_REAL(out)\n);\n    `MUL_INTO_REAL(in0, in1, out);\nendmodule\nmodule outer;\n    `MAKE_REAL(a, 10.0); // i.e., +/- 10\n    `MAKE_REAL(b, 21.0); // i.e., +/- 21\n    `MAKE_REAL(c, 32.0); // i.e., +/- 32\n\n    inner #(\n        `PASS_REAL(in0, a),\n        `PASS_REAL(in1, b),\n        `PASS_REAL(out, c)\n    ) inner_i (\n        .in0(a),\n        .in1(b),\n        .out(c)\n    );\n    ...\nendmodule\n```\n\nThere are a few things to observe here.  First, the parameters and I/O list of the inner module, which has fixed-point I/O, has to be declared in a certain way.  Every fixed-point number in the I/O list (regardless of whether it is an input or an output) needs to have a corresponding **\\`DECL_REAL** statement in the parameter list for the module.  This declares all of the parameters needed for that fixed-point signal.  Then, in the I/O list for the module, fixed-point inputs and outputs should be declared using **\\`INPUT_REAL** and **\\`OUTPUT_REAL**, respectively.\n\nGoing up one level to the outer block, observe that a special macro **\\`PASS_REAL** is needed to pass parameter information for the fixed-point signals **a**, **b**, and **c** into the inner module.  The syntax of **\\`PASS_REAL** is meant to mimick using dot-notation to connect signals to a module instance; that is, the name of the port on the inner module comes first, followed by the name of the local signal.  Finally, note that fixed-point signals are wired up in the I/O list using standard dot notation.\n\n## Using interfaces\n\nSuppose you want to bundle **svreal** signals into an interface.  This might make it easier to pass around groups of fixed-point numbers, or allow you to pass digital control signals along with the fixed point numbers.  This task can be achieved using a set of special **svreal** macros.\n\nHere's the simplest such interface, containing a single **svreal** signal and nothing else: \n\n```verilog\n`include \"svreal.sv\"\ninterface svreal #(\n    `INTF_DECL_REAL(value)\n);\n    `INTF_MAKE_REAL(value);\n    modport in(`MODPORT_IN_REAL(value));\n    modport out(`MODPORT_OUT_REAL(value));\nendinterface\n```\n\nIt looks similar to a module declaration that includes **svreal** signals, but there are a few key differences:\n  1.  **INTF_DECL_REAL** is used instead of **DECL_REAL**.\n  2.  Each **svreal** signal that has been declared in the parameter list needs a corresponding **INTF_MAKE_REAL** statement in the body of the interface.\n  3.  When declaring modports for the interface, the **\\`MODPORT_IN_REAL** and **\\`MODPORT_OUT_REAL** macros must be used to specify that a given **svreal** signal should be treated as an input or an output. \n\nTo work with an **svreal** signal contained in an interface, there are two options: alias the signal to a local name, or pass the signal into a submodule.  Both methods are illustrated below.\n\n### Aliasing an svreal signal contained in an interface to a local name\n\nThis is likely the simpler method to use for handwritten code.  As shown in the code sample below, the I/O list for **mymod** directly uses the modports of the **svreal** interface described in the previous section; the macros **DECL_REAL**, **INPUT_REAL**, and **OUTPUT_REAL** are not used.  Inside the module body, however, the \"value\" signals are aliased to local names using the macros **INTF_INPUT_TO_REAL** and **INTF_OUTPUT_TO_REAL**, at which point all normal **svreal** macros can be used on the local names.  \n\nCrucially, the body of **mymod** needs to be wrapped in a **generate** block.  This is required to avoid bugs in some simulator and synthesis tools related to reading properties out of interfaces.\n\n```verilog\nmodule mymod (\n    svreal.in a,\n    svreal.in b,\n    svreal.out c\n); \n    generate\n        `INTF_INPUT_TO_REAL(a.value, a_value);\n        `INTF_INPUT_TO_REAL(b.value, b_value);\n        `INTF_OUTPUT_TO_REAL(c.value, c_value);\n        `MUL_INTO_REAL(a_value, b_value, c_value); \n    endgenerate\nendmodule\n\n```\n\n### Passing an svreal signal contained in an interface to a submodule\n\nThis method is more useful when automatically generating models that use **svreal**.  In the code example below, observe that the **outer** module is just a wrapper for the **inner** module; it breaks out the **svreal** signals contained in interfaces and passes them through to the **inner** module directly.  Hence, there is nothing special about the **inner** module; it contains no references to interfaces or interface macros.\n\nIn the **outer** module, however, there are two special requirements.  First, as with the previous method, the body of the module must be wrapped in a **generate** block to ensure proper tool behavior.  Second, when passing signals contained in interfaces, the **INTF_PASS_REAL** macro must be used instead of **PASS_REAL**.\n\nEven though this method is more verbose, it can be handy for generated code, because it decouples implementation of the real-number module from the details of how the incoming signals are bundled.  This allows for two simpler generators (model generator + wrapper generator) rather than one complicated generator.\n\n```verilog\nmodule inner #(\n    `DECL_REAL(a),\n    `DECL_REAL(b),\n    `DECL_REAL(c)\n) (\n    `INPUT_REAL(a),\n    `INPUT_REAL(b),\n    `OUTPUT_REAL(c)\n);\n    `MUL_INTO_REAL(a, b, c); \nendmodule\nmodule outer (\n    svreal.in a,\n    svreal.in b,\n    svreal.out c\n);\n    generate\n        inner #(\n            `INTF_PASS_REAL(a, a.value),\n            `INTF_PASS_REAL(b, b.value),\n            `INTF_PASS_REAL(c, c.value)\n        ) inner_i (\n            .a(a.value),\n            .b(b.value),\n            .c(c.value)\n        );\n    endgenerate\nendmodule\n```\n\n# Running the Tests\n\nTo test **svreal**, please make sure that at least one of the following simulators is in the system path: \n1. vivado\n2. ncsim\n3. vcs\n4. iverilog\n\nThen make sure that **pytest** is installed.  If it's not, run the following command:\n```shell\n> pip install pytest\n```\n\nFinally, run **pytest** on the **tests** directory (the \"-xs\" flag means \"stop if there are any failures, and print output from tests as it is available.\"):\n```shell\n> pytest -xs tests/\n```\nThis will run as many tests as possible given the tools installed on your system.  For example, if **vivado** is installed, synthesis tests will be run, but if not, only the simulation-based tests will be run.\n\nYou can run a specific test of interest like this:\n```shell\n> pytest -xs tests/test_ops.py\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/sgherbst/svreal/archive/v0.2.2.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/sgherbst/svreal", "keywords": "fixed-point,fixed point,verilog,system-verilog,system verilog,synthesizable,fpga", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "svreal", "package_url": "https://pypi.org/project/svreal/", "platform": "", "project_url": "https://pypi.org/project/svreal/", "project_urls": {"Download": "https://github.com/sgherbst/svreal/archive/v0.2.2.tar.gz", "Homepage": "https://github.com/sgherbst/svreal"}, "release_url": "https://pypi.org/project/svreal/0.2.2/", "requires_dist": null, "requires_python": ">=3.7", "summary": "Library for working with fixed-point numbers in SystemVerilog", "version": "0.2.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>svreal</h1>\n<p><a href=\"https://github.com/sgherbst/svreal/actions\" rel=\"nofollow\"><img alt=\"Actions Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/45b01104d8febf10f195b9e46dcca8ba3806a8d1/68747470733a2f2f6769746875622e636f6d2f73676865726273742f73767265616c2f776f726b666c6f77732f52656772657373696f6e2f62616467652e737667\"></a>\n<a href=\"https://buildkite.com/stanford-aha/svreal\" rel=\"nofollow\"><img alt=\"BuildKite Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2676bb27ad56f34bf63961219d2e6bd34dc480df/68747470733a2f2f62616467652e6275696c646b6974652e636f6d2f34356564373132616538373230653961336537633034306432653362633434316131386236656632363965343537333732332e737667\"></a>\n<a href=\"https://codecov.io/gh/sgherbst/svreal\" rel=\"nofollow\"><img alt=\"Code Coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/838fd5ec4728fc0815f5d672885765612afd9cd8/68747470733a2f2f636f6465636f762e696f2f67682f73676865726273742f73767265616c2f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://opensource.org/licenses/MIT\" rel=\"nofollow\"><img alt=\"License: MIT\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8645b002dd7ec1b54275a80574942e7a318e03c6/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d79656c6c6f772e737667\"></a>\n<a href=\"https://badge.fury.io/py/svreal\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b16b037735e8dd0497a62bf9b199d79b24a42f6d/68747470733a2f2f62616467652e667572792e696f2f70792f73767265616c2e737667\"></a></p>\n<p><strong>svreal</strong> is a single-file SystemVerilog library that makes it easy to perform fixed-point operations in a synthesizable fashion in SystemVerilog.  The exponent and alignment details are handled automatically, so the user is free to customize the format of each fixed-point signal in the design without inconvenience.  For debugging range/resolution issues, the user can switch all signal types to a floating-point representation using a single <strong>define</strong> command-line option.  Supported fixed-point operations include addition, subtraction, negation, multiplication, comparison, and conditional assignment.</p>\n<h1>Installation</h1>\n<pre>&gt; pip install svreal\n</pre>\n<p>If you get a permissions error when running the <strong>pip</strong> command, you can try adding the <strong>--user</strong> flag.  This will cause <strong>pip</strong> to install packages in your user directory rather than to a system-wide location.</p>\n<h1>Introduction</h1>\n<h2>Simple example</h2>\n<p>Here's a simple <strong>svreal</strong> example to get started.  Note that we only have to include a single file, \"svreal.sv\".  That file is stored in the <strong>site-packages/svreal</strong> directory; its location can be accessed programmatically using the function <strong>svreal.get_svreal_header()</strong>.</p>\n<pre><span class=\"no\">`include</span> <span class=\"s\">\"svreal.sv\"</span>\n<span class=\"no\">`MAKE_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"mf\">5.0</span><span class=\"p\">);</span>\n<span class=\"no\">`MAKE_GENERIC_REAL</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span><span class=\"p\">,</span> <span class=\"mh\">42</span><span class=\"p\">);</span>\n<span class=\"no\">`ADD_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n<span class=\"k\">initial</span> <span class=\"k\">begin</span>\n    <span class=\"no\">`FORCE_REAL</span><span class=\"p\">(</span><span class=\"mf\">1.23</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">);</span>\n    <span class=\"no\">`FORCE_REAL</span><span class=\"p\">(</span><span class=\"mf\">4.56</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">);</span>\n    <span class=\"p\">#(</span><span class=\"mh\">1</span><span class=\"n\">ns</span><span class=\"p\">);</span>\n    <span class=\"no\">`PRINT_REAL</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">);</span>\n<span class=\"k\">end</span>\n</pre>\n<p>This creates fixed-point signals <strong>a</strong>, <strong>b</strong>, and <strong>c</strong> and instantiates an adder that sums <strong>a</strong> and <strong>b</strong> into <strong>c</strong>.  In the <strong>initial</strong> block, the values of <strong>a</strong> and <strong>b</strong> are set to \"1.23\" and \"4.56\" and then the value of \"c\" is printed.  Hence, we'd expect that the value of <strong>c</strong> is around \"5.79\".</p>\n<h2>Fixed-point formatting</h2>\n<p>In <strong>svreal</strong>, fixed-point formats are generally determined automatically from the range of the signals they represent.  In this case, the range of <strong>a</strong> is set to +/- 5.0, and the range of <strong>b</strong> is set to +/- 10.0.  The width of <strong>a</strong> is not specified, so it defaults to <strong>`LONG_WIDTH_REAL</strong> (which is 25 unless overridden by the user).  For <strong>b</strong>, the user has explicitly specified a width of 42 bits.  In both cases, the exponent used in the representation is automatically determined from the the width and range, using the formula:</p>\n<pre>exponent = int(ceil(log2(range/(2^(width-1)-1))))\n</pre>\n<p>This method of selecting the exponent guarantees that the user-specified range can be represented given the width of the fixed-point value.</p>\n<p>Since the user has not provided any formatting information for <strong>c</strong>, its range is automatically determined from the ranges of <strong>a</strong> and <strong>b</strong>.  Since <strong>a</strong> is +/- 5.0 and <strong>b</strong> is +/- 10.0, the range of <strong>c</strong> is +/- 15.0.  The width of <strong>c</strong> defaults to <strong>`LONG_WIDTH_REAL</strong>, and its exponent is calculated using the formula above.</p>\n<h2>Debugging</h2>\n<p>Suppose that the range of <strong>a</strong> is not sufficient to contain the value being assigned to it.  Then <strong>a</strong> may contain an entirely wrong value due to overflow.  In order to debug this problem, define the <strong>FLOAT_REAL</strong> flag (for example, using <strong>+define+FLOAT_REAL</strong>).  This switches the real number representation from fixed-point to float-point, which helps the user to identify whether the fixed-point representation is the cause of the problem, or whether it is something else.  In addition, this flag adds assertions to check if any real-number signal exceeds its specified range.</p>\n<p>It is also possible to debug underflow issues using <strong>svreal</strong>.  First set the <strong>FLOAT_REAL</strong> flag to switch to a floating-point representation.  If the problem goes away, but there are no assertion errors indicating overflows, then the problem is likely due to inadequate resolution in one or more <strong>svreal</strong> signals.  This theory can be validated by increasing <strong>`LONG_WIDTH_REAL</strong> and/or <strong>`SHORT_WIDTH_REAL</strong>.  If increasing <strong>`SHORT_WIDTH_REAL</strong> helps, then one or more multiplication constants need to have higher resolution.  Otherwise, one or more fixed-point signals or additive constants need more resolution.</p>\n<h2>Operations available</h2>\n<p>Here is a partial list of operations that can be performed with <strong>svreal</strong>:</p>\n<h3>Assignment, negation, and absolute value</h3>\n<pre><span class=\"no\">`ASSIGN_REAL</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`NEGATE_REAL</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`ABS_REAL</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">)</span>\n</pre>\n<p>These operations take one input (first argument) and produce one output (second argument).  Note that `ASSIGN_REAL should <em>always</em> be used in place of a raw <strong>assign</strong> statement.  This is because `ASSIGN_REAL performs alignment as necessary.</p>\n<h3>Arithmetic operations</h3>\n<pre><span class=\"no\">`MIN_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`MAX_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`ADD_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`SUB_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`MUL_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n</pre>\n<p>These operations take two inputs (first and second arguments) and produce one output (third argument).  Note the ordering of the subtraction operation: `SUB_REAL(a, b, out) means \"out := a - b\".</p>\n<h3>Mux operations</h3>\n<pre><span class=\"no\">`ITE_REAL</span><span class=\"p\">(</span><span class=\"n\">cond</span><span class=\"p\">,</span> <span class=\"n\">val_if_true</span><span class=\"p\">,</span> <span class=\"n\">val_if_false</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n</pre>\n<p>This is a handy operation when constructing conditional operations: if <strong>cond</strong> is \"1\", then <strong>val_if_true</strong> is muxed to <strong>out</strong>, otherwise if <strong>cond</strong> is \"0\", then <strong>val_if_false</strong> is muxed to <strong>out</strong>.  Note that this is not implemented as a literal mux, but instead performs alignment as necessary. Hence, the formats of all three fixed-point numbers can be different.</p>\n<h3>Real &lt;-&gt; integer conversion</h3>\n<pre><span class=\"no\">`REAL_TO_INT</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">$size</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">),</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`INT_TO_REAL</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">$size</span><span class=\"p\">(</span><span class=\"n\">in</span><span class=\"p\">),</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n</pre>\n<p>Sometimes it is necessary to convert a signed integer into an <strong>svreal</strong> type or vice versa.</p>\n<p>The macro `REAL_TO_INT takes as its first argument an <strong>svreal</strong> type and as its third argument a <strong>logic signed</strong> type.  The second argument is the width of the <strong>logic signed</strong> type (it's left up to the user whether this comes from <strong>$size</strong>, <strong>$bits</strong>, or from a parameter due to simulator quirks).</p>\n<p>The macro `INT_TO_REAL takes as its first argument a <strong>logic signed</strong> type and as its third argument an <strong>svreal</strong> type.  The third argument is the width of the <strong>logic signed</strong> type (it's left up to the user whether this comes from <strong>$size</strong>, <strong>$bits</strong>, or from a parameter due to simulator quirks).</p>\n<h3>Comparisons</h3>\n<pre><span class=\"no\">`LT_REAL</span><span class=\"p\">(</span><span class=\"n\">lhs</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`LE_REAL</span><span class=\"p\">(</span><span class=\"n\">lhs</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`GT_REAL</span><span class=\"p\">(</span><span class=\"n\">lhs</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`GE_REAL</span><span class=\"p\">(</span><span class=\"n\">lhs</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`EQ_REAL</span><span class=\"p\">(</span><span class=\"n\">lhs</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`NE_REAL</span><span class=\"p\">(</span><span class=\"n\">lhs</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n</pre>\n<p>Comparisons always take two fixed-point numbers as the first two arguments, ordered as the left-hand side followed by the right-hand side.  The third macro argument is the output, which is a single bit (type <strong>logic</strong>) with value \"1\" if the comparison is true and \"0\" if it is false.</p>\n<h3>Working with constants</h3>\n<pre><span class=\"no\">`MAKE_CONST_REAL</span><span class=\"p\">(</span><span class=\"k\">const</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">);</span>\n<span class=\"no\">`ASSIGN_CONST_REAL</span><span class=\"p\">(</span><span class=\"k\">const</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">);</span>\n<span class=\"no\">`ADD_CONST_REAL</span><span class=\"p\">(</span><span class=\"k\">const</span><span class=\"p\">,</span> <span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"no\">`MUL_CONST_REAL</span><span class=\"p\">(</span><span class=\"k\">const</span><span class=\"p\">,</span> <span class=\"n\">in</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n</pre>\n<p>Several functions are available to work with numeric constants.  <strong>`MAKE_CONST_REAL</strong> creates a new <strong>svreal</strong> type and assigns the given real-number constant to it.  Its width defaults to <strong>`LONG_WIDTH_REAL</strong> and the exponent is selected automatically based on the constant value.  <strong>`ASSIGN_CONST_REAL</strong> is similar but does not declare a new <strong>svreal</strong> type; it simply assigns the constant to an existing fixed-point signal (performing the floating-to-fixed conversion at compile time).</p>\n<p><strong>`ADD_CONST_REAL</strong> and <strong>`MUL_CONST_REAL</strong> allow the user to add a constant to a number or multiply a constant by a number, respectively.  There is one special caveat for <strong>`MUL_CONST_REAL</strong>, which is that it represents the constant with a fixed-point number of width <strong>`SHORT_WIDTH_REAL</strong> (18 unless overridden by the user).  As a result, the user can cause <strong>`MUL_CONST_REAL</strong> to consume exactly one DSP block by picking <strong>`LONG_WIDTH_REAL</strong> and <strong>`SHORT_WIDTH_REAL</strong> to be the operand widths of the target FPGA's DSP multipliers.</p>\n<h3>Memory</h3>\n<pre><span class=\"no\">`DFF_REAL</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">,</span> <span class=\"n\">rst</span><span class=\"p\">,</span> <span class=\"n\">clk</span><span class=\"p\">,</span> <span class=\"n\">cke</span><span class=\"p\">,</span> <span class=\"n\">init</span><span class=\"p\">);</span>\n</pre>\n<p>Fixed-point memory is implemented as a generic D-type flip-flop (DFF).  The input to this flip-flop is <strong>d</strong>, and the output is <strong>q</strong>.  Both are fixed-point types, but it's fine if they can have different formats.</p>\n<p>The <strong>rst</strong> signals is a single active-high bit (type <strong>logic</strong>).  It's a synchronous reset, and when active it causes <strong>q</strong> to take the value of <strong>init</strong>.  <strong>init</strong> is simply a real-number value like \"1.23\".</p>\n<p>Finally, <strong>clk</strong> and <strong>cke</strong> are single bit signals (type <strong>logic</strong>).  <strong>clk</strong> is the clock input of the DFF (active on the rising edge), and <strong>cke</strong> is the clock enable signal (active high).</p>\n<h3>Assigning results to existing signals</h3>\n<p>Most operations have an alternate form that allows the user to assign the result of an operation to an existing fixed-point signal.  This is indicated by the word <strong>INTO</strong> in the macro name.  For example, suppose that we have defined three signals, <strong>a</strong>, <strong>b</strong>, and <strong>c</strong>, and want to assign the sum of <strong>a</strong> and <strong>b</strong> into <strong>c</strong>:</p>\n<pre><span class=\"no\">`MAKE_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span><span class=\"p\">);</span> <span class=\"c1\">// i.e., +/- 10</span>\n<span class=\"no\">`MAKE_REAL</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"mf\">21.0</span><span class=\"p\">);</span> <span class=\"c1\">// i.e., +/- 21</span>\n<span class=\"no\">`MAKE_REAL</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"mf\">32.0</span><span class=\"p\">);</span> <span class=\"c1\">// i.e., +/- 32</span>\n<span class=\"no\">`ADD_INTO_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n</pre>\n<p>This special form of the \"add\" operation will not declare a new signal <strong>c</strong>, but instead will assign the result of the addition to the existing signal called <strong>c</strong> (performing alignment shifts as necessary, of course).</p>\n<p>In this case, there is a risk that <strong>c</strong> may have been declared with insufficient range to hold the result.  As mentioned before, this can be debugged using the <strong>FLOAT_REAL</strong> flag, which adds range assertions.  So why would a user ever want to use the <strong>INTO</strong> form of the <strong>svreal</strong> macros?  The most common case is that they are assigning to a signal that appears on the I/O list of the module.  Alternatively, they may want to manually specify the range or resolution of the output signal.  However, a better way to accomplish that is to use the <strong>GENERIC</strong> form of operations, as described in the next section.</p>\n<h3>Specifying output resolution</h3>\n<p>Most operations have an alternate form ending with <strong>GENERIC</strong> that allows the user to specify the width of the result.  Since the range of the operation is determined automatically, this effectively controls the resolution of the operation.  As an example, suppose we want to multiply two signals, but represent the output with more precision than the default.  In that case we could write</p>\n<pre><span class=\"no\">`MAKE_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span><span class=\"p\">);</span> <span class=\"c1\">// i.e., +/- 10</span>\n<span class=\"no\">`MAKE_REAL</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"mf\">21.0</span><span class=\"p\">);</span> <span class=\"c1\">// i.e., +/- 21</span>\n<span class=\"no\">`MUL_REAL_GENERIC</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"mh\">40</span><span class=\"p\">);</span>\n</pre>\n<p>This means: multiply <strong>a</strong> and <strong>b</strong> and store the result in <strong>c</strong> with the appropriate alignment.  The width of <strong>c</strong> is given the custom value \"40\", and the range of <strong>c</strong> is still determined automatically.  As a result, the user can control the precision of intermediate results, and this in turn is useful when debugging underflow issues.</p>\n<h2>Passing fixed-point signals</h2>\n<p>Since compile-time parameters are used to store some of the fixed-point formatting information, some care must be taken when passing <strong>svreal</strong> signals through a hierarchy to ensure that information is not lost.  Consider this example, in which an outer block instantiates a module that multiplies together two signals to produce an output:</p>\n<pre><span class=\"no\">`include</span> <span class=\"s\">\"svreal.sv\"</span>\n<span class=\"k\">module</span> <span class=\"n\">inner</span> <span class=\"p\">#(</span>\n    <span class=\"no\">`DECL_REAL</span><span class=\"p\">(</span><span class=\"n\">in0</span><span class=\"p\">),</span>\n    <span class=\"no\">`DECL_REAL</span><span class=\"p\">(</span><span class=\"n\">in1</span><span class=\"p\">),</span>\n    <span class=\"no\">`DECL_REAL</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">)</span>\n<span class=\"p\">)</span> <span class=\"p\">(</span>\n    <span class=\"no\">`INPUT_REAL</span><span class=\"p\">(</span><span class=\"n\">in0</span><span class=\"p\">),</span>\n    <span class=\"no\">`INPUT_REAL</span><span class=\"p\">(</span><span class=\"n\">in1</span><span class=\"p\">),</span>\n    <span class=\"no\">`OUTPUT_REAL</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">)</span>\n<span class=\"p\">);</span>\n    <span class=\"no\">`MUL_INTO_REAL</span><span class=\"p\">(</span><span class=\"n\">in0</span><span class=\"p\">,</span> <span class=\"n\">in1</span><span class=\"p\">,</span> <span class=\"n\">out</span><span class=\"p\">);</span>\n<span class=\"k\">endmodule</span>\n<span class=\"k\">module</span> <span class=\"n\">outer</span><span class=\"p\">;</span>\n    <span class=\"no\">`MAKE_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span><span class=\"p\">);</span> <span class=\"c1\">// i.e., +/- 10</span>\n    <span class=\"no\">`MAKE_REAL</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"mf\">21.0</span><span class=\"p\">);</span> <span class=\"c1\">// i.e., +/- 21</span>\n    <span class=\"no\">`MAKE_REAL</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"mf\">32.0</span><span class=\"p\">);</span> <span class=\"c1\">// i.e., +/- 32</span>\n\n    <span class=\"n\">inner</span> <span class=\"p\">#(</span>\n        <span class=\"no\">`PASS_REAL</span><span class=\"p\">(</span><span class=\"n\">in0</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">),</span>\n        <span class=\"no\">`PASS_REAL</span><span class=\"p\">(</span><span class=\"n\">in1</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">),</span>\n        <span class=\"no\">`PASS_REAL</span><span class=\"p\">(</span><span class=\"n\">out</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">)</span>\n    <span class=\"p\">)</span> <span class=\"n\">inner_i</span> <span class=\"p\">(</span>\n        <span class=\"p\">.</span><span class=\"n\">in0</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">),</span>\n        <span class=\"p\">.</span><span class=\"n\">in1</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">),</span>\n        <span class=\"p\">.</span><span class=\"n\">out</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span>\n    <span class=\"p\">);</span>\n    <span class=\"p\">...</span>\n<span class=\"k\">endmodule</span>\n</pre>\n<p>There are a few things to observe here.  First, the parameters and I/O list of the inner module, which has fixed-point I/O, has to be declared in a certain way.  Every fixed-point number in the I/O list (regardless of whether it is an input or an output) needs to have a corresponding <strong>`DECL_REAL</strong> statement in the parameter list for the module.  This declares all of the parameters needed for that fixed-point signal.  Then, in the I/O list for the module, fixed-point inputs and outputs should be declared using <strong>`INPUT_REAL</strong> and <strong>`OUTPUT_REAL</strong>, respectively.</p>\n<p>Going up one level to the outer block, observe that a special macro <strong>`PASS_REAL</strong> is needed to pass parameter information for the fixed-point signals <strong>a</strong>, <strong>b</strong>, and <strong>c</strong> into the inner module.  The syntax of <strong>`PASS_REAL</strong> is meant to mimick using dot-notation to connect signals to a module instance; that is, the name of the port on the inner module comes first, followed by the name of the local signal.  Finally, note that fixed-point signals are wired up in the I/O list using standard dot notation.</p>\n<h2>Using interfaces</h2>\n<p>Suppose you want to bundle <strong>svreal</strong> signals into an interface.  This might make it easier to pass around groups of fixed-point numbers, or allow you to pass digital control signals along with the fixed point numbers.  This task can be achieved using a set of special <strong>svreal</strong> macros.</p>\n<p>Here's the simplest such interface, containing a single <strong>svreal</strong> signal and nothing else:</p>\n<pre><span class=\"no\">`include</span> <span class=\"s\">\"svreal.sv\"</span>\n<span class=\"n\">interface</span> <span class=\"n\">svreal</span> <span class=\"p\">#(</span>\n    <span class=\"no\">`INTF_DECL_REAL</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n<span class=\"p\">);</span>\n    <span class=\"no\">`INTF_MAKE_REAL</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">);</span>\n    <span class=\"n\">modport</span> <span class=\"n\">in</span><span class=\"p\">(</span><span class=\"no\">`MODPORT_IN_REAL</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">));</span>\n    <span class=\"n\">modport</span> <span class=\"n\">out</span><span class=\"p\">(</span><span class=\"no\">`MODPORT_OUT_REAL</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">));</span>\n<span class=\"n\">endinterface</span>\n</pre>\n<p>It looks similar to a module declaration that includes <strong>svreal</strong> signals, but there are a few key differences:</p>\n<ol>\n<li><strong>INTF_DECL_REAL</strong> is used instead of <strong>DECL_REAL</strong>.</li>\n<li>Each <strong>svreal</strong> signal that has been declared in the parameter list needs a corresponding <strong>INTF_MAKE_REAL</strong> statement in the body of the interface.</li>\n<li>When declaring modports for the interface, the <strong>`MODPORT_IN_REAL</strong> and <strong>`MODPORT_OUT_REAL</strong> macros must be used to specify that a given <strong>svreal</strong> signal should be treated as an input or an output.</li>\n</ol>\n<p>To work with an <strong>svreal</strong> signal contained in an interface, there are two options: alias the signal to a local name, or pass the signal into a submodule.  Both methods are illustrated below.</p>\n<h3>Aliasing an svreal signal contained in an interface to a local name</h3>\n<p>This is likely the simpler method to use for handwritten code.  As shown in the code sample below, the I/O list for <strong>mymod</strong> directly uses the modports of the <strong>svreal</strong> interface described in the previous section; the macros <strong>DECL_REAL</strong>, <strong>INPUT_REAL</strong>, and <strong>OUTPUT_REAL</strong> are not used.  Inside the module body, however, the \"value\" signals are aliased to local names using the macros <strong>INTF_INPUT_TO_REAL</strong> and <strong>INTF_OUTPUT_TO_REAL</strong>, at which point all normal <strong>svreal</strong> macros can be used on the local names.</p>\n<p>Crucially, the body of <strong>mymod</strong> needs to be wrapped in a <strong>generate</strong> block.  This is required to avoid bugs in some simulator and synthesis tools related to reading properties out of interfaces.</p>\n<pre><span class=\"k\">module</span> <span class=\"n\">mymod</span> <span class=\"p\">(</span>\n    <span class=\"n\">svreal</span><span class=\"p\">.</span><span class=\"n\">in</span> <span class=\"n\">a</span><span class=\"p\">,</span>\n    <span class=\"n\">svreal</span><span class=\"p\">.</span><span class=\"n\">in</span> <span class=\"n\">b</span><span class=\"p\">,</span>\n    <span class=\"n\">svreal</span><span class=\"p\">.</span><span class=\"n\">out</span> <span class=\"n\">c</span>\n<span class=\"p\">);</span> \n    <span class=\"k\">generate</span>\n        <span class=\"no\">`INTF_INPUT_TO_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">a_value</span><span class=\"p\">);</span>\n        <span class=\"no\">`INTF_INPUT_TO_REAL</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">b_value</span><span class=\"p\">);</span>\n        <span class=\"no\">`INTF_OUTPUT_TO_REAL</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">c_value</span><span class=\"p\">);</span>\n        <span class=\"no\">`MUL_INTO_REAL</span><span class=\"p\">(</span><span class=\"n\">a_value</span><span class=\"p\">,</span> <span class=\"n\">b_value</span><span class=\"p\">,</span> <span class=\"n\">c_value</span><span class=\"p\">);</span> \n    <span class=\"k\">endgenerate</span>\n<span class=\"k\">endmodule</span>\n</pre>\n<h3>Passing an svreal signal contained in an interface to a submodule</h3>\n<p>This method is more useful when automatically generating models that use <strong>svreal</strong>.  In the code example below, observe that the <strong>outer</strong> module is just a wrapper for the <strong>inner</strong> module; it breaks out the <strong>svreal</strong> signals contained in interfaces and passes them through to the <strong>inner</strong> module directly.  Hence, there is nothing special about the <strong>inner</strong> module; it contains no references to interfaces or interface macros.</p>\n<p>In the <strong>outer</strong> module, however, there are two special requirements.  First, as with the previous method, the body of the module must be wrapped in a <strong>generate</strong> block to ensure proper tool behavior.  Second, when passing signals contained in interfaces, the <strong>INTF_PASS_REAL</strong> macro must be used instead of <strong>PASS_REAL</strong>.</p>\n<p>Even though this method is more verbose, it can be handy for generated code, because it decouples implementation of the real-number module from the details of how the incoming signals are bundled.  This allows for two simpler generators (model generator + wrapper generator) rather than one complicated generator.</p>\n<pre><span class=\"k\">module</span> <span class=\"n\">inner</span> <span class=\"p\">#(</span>\n    <span class=\"no\">`DECL_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">),</span>\n    <span class=\"no\">`DECL_REAL</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">),</span>\n    <span class=\"no\">`DECL_REAL</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span>\n<span class=\"p\">)</span> <span class=\"p\">(</span>\n    <span class=\"no\">`INPUT_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">),</span>\n    <span class=\"no\">`INPUT_REAL</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">),</span>\n    <span class=\"no\">`OUTPUT_REAL</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span>\n<span class=\"p\">);</span>\n    <span class=\"no\">`MUL_INTO_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span> \n<span class=\"k\">endmodule</span>\n<span class=\"k\">module</span> <span class=\"n\">outer</span> <span class=\"p\">(</span>\n    <span class=\"n\">svreal</span><span class=\"p\">.</span><span class=\"n\">in</span> <span class=\"n\">a</span><span class=\"p\">,</span>\n    <span class=\"n\">svreal</span><span class=\"p\">.</span><span class=\"n\">in</span> <span class=\"n\">b</span><span class=\"p\">,</span>\n    <span class=\"n\">svreal</span><span class=\"p\">.</span><span class=\"n\">out</span> <span class=\"n\">c</span>\n<span class=\"p\">);</span>\n    <span class=\"k\">generate</span>\n        <span class=\"n\">inner</span> <span class=\"p\">#(</span>\n            <span class=\"no\">`INTF_PASS_REAL</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">),</span>\n            <span class=\"no\">`INTF_PASS_REAL</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">),</span>\n            <span class=\"no\">`INTF_PASS_REAL</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"p\">)</span> <span class=\"n\">inner_i</span> <span class=\"p\">(</span>\n            <span class=\"p\">.</span><span class=\"n\">a</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">),</span>\n            <span class=\"p\">.</span><span class=\"n\">b</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">),</span>\n            <span class=\"p\">.</span><span class=\"n\">c</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"p\">);</span>\n    <span class=\"k\">endgenerate</span>\n<span class=\"k\">endmodule</span>\n</pre>\n<h1>Running the Tests</h1>\n<p>To test <strong>svreal</strong>, please make sure that at least one of the following simulators is in the system path:</p>\n<ol>\n<li>vivado</li>\n<li>ncsim</li>\n<li>vcs</li>\n<li>iverilog</li>\n</ol>\n<p>Then make sure that <strong>pytest</strong> is installed.  If it's not, run the following command:</p>\n<pre>&gt; pip install pytest\n</pre>\n<p>Finally, run <strong>pytest</strong> on the <strong>tests</strong> directory (the \"-xs\" flag means \"stop if there are any failures, and print output from tests as it is available.\"):</p>\n<pre>&gt; pytest -xs tests/\n</pre>\n<p>This will run as many tests as possible given the tools installed on your system.  For example, if <strong>vivado</strong> is installed, synthesis tests will be run, but if not, only the simulation-based tests will be run.</p>\n<p>You can run a specific test of interest like this:</p>\n<pre>&gt; pytest -xs tests/test_ops.py\n</pre>\n\n          </div>"}, "last_serial": 6833176, "releases": {"0.1.2": [{"comment_text": "", "digests": {"md5": "8b3b27b1716352d85ce3fab5ef71fdab", "sha256": "36dea8f92324b9b1075e15fde078bfcfdee933e4103ac76aebaf43158c0bb292"}, "downloads": -1, "filename": "svreal-0.1.2.tar.gz", "has_sig": false, "md5_digest": "8b3b27b1716352d85ce3fab5ef71fdab", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 897, "upload_time": "2020-01-16T21:56:40", "upload_time_iso_8601": "2020-01-16T21:56:40.254891Z", "url": "https://files.pythonhosted.org/packages/05/6f/c8706079d94aa652dfc77a0522f4d44627f8f14d91310b13fdc7b6e34dad/svreal-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "516d844a9c026525508015778fe8be77", "sha256": "4009fe15476191ff23cdcfd536e5bf0088f8fff66feca51aa82d91b3c109fdd8"}, "downloads": -1, "filename": "svreal-0.1.3.tar.gz", "has_sig": false, "md5_digest": "516d844a9c026525508015778fe8be77", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 10100, "upload_time": "2020-01-16T22:16:08", "upload_time_iso_8601": "2020-01-16T22:16:08.225310Z", "url": "https://files.pythonhosted.org/packages/bf/77/968e85b94707321d0ded686e91ea379706bba3c0d6dec540071c1107f866/svreal-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "efafa8d15358f26d5ea2b920f11d86be", "sha256": "fc0b971b0fd0791439f4264cf974a6551afc95b55d57f1edad5cb7b249e65663"}, "downloads": -1, "filename": "svreal-0.1.4.tar.gz", "has_sig": false, "md5_digest": "efafa8d15358f26d5ea2b920f11d86be", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 14545, "upload_time": "2020-01-16T22:22:12", "upload_time_iso_8601": "2020-01-16T22:22:12.210818Z", "url": "https://files.pythonhosted.org/packages/32/a9/9a29cf02b0518f5dee8f08aa3f3ad2eff52f838f31933139d3a646d36df2/svreal-0.1.4.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "b18ee6c1ae5b8bdbce3fe800e6ba4798", "sha256": "ec8eb786f816ddaf94a9afe6aa3091e209c91ba478c7bc7fa836704e2855e352"}, "downloads": -1, "filename": "svreal-0.1.5.tar.gz", "has_sig": false, "md5_digest": "b18ee6c1ae5b8bdbce3fe800e6ba4798", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 19492, "upload_time": "2020-01-16T22:36:05", "upload_time_iso_8601": "2020-01-16T22:36:05.155928Z", "url": "https://files.pythonhosted.org/packages/71/67/5bb9e9db28f65541c8f378292feee1b9c126b4683ec4b04e099e69e12444/svreal-0.1.5.tar.gz", "yanked": false}], "0.1.6": [{"comment_text": "", "digests": {"md5": "462ae36758169a96a3ee67fd72c94b05", "sha256": "6ddbee85a248e335da8b28d69282bc3bfbda176ce5e0c0167844b5c4e8619365"}, "downloads": -1, "filename": "svreal-0.1.6.tar.gz", "has_sig": false, "md5_digest": "462ae36758169a96a3ee67fd72c94b05", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 19482, "upload_time": "2020-01-16T22:46:04", "upload_time_iso_8601": "2020-01-16T22:46:04.790114Z", "url": "https://files.pythonhosted.org/packages/88/66/39e607f6221da24ace31c38861b76e5f45da37565cc2624f735a786836f2/svreal-0.1.6.tar.gz", "yanked": false}], "0.1.7": [{"comment_text": "", "digests": {"md5": "3dfe05a3b2b004f62e4639c7a9125287", "sha256": "2f389f640467c89ee19cec3cd76a26416589adf41963de29012b924dfab59c30"}, "downloads": -1, "filename": "svreal-0.1.7.tar.gz", "has_sig": false, "md5_digest": "3dfe05a3b2b004f62e4639c7a9125287", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 22932, "upload_time": "2020-01-17T01:16:17", "upload_time_iso_8601": "2020-01-17T01:16:17.822038Z", "url": "https://files.pythonhosted.org/packages/d5/fb/e054c3bbdbf903fe8ed781bf6e519b163c148ce9c1fde822b50eaf9816bf/svreal-0.1.7.tar.gz", "yanked": false}], "0.1.8": [{"comment_text": "", "digests": {"md5": "0b02ed70284356be8600e8b8d59b2e51", "sha256": "7abe4daec4ee7a06dc535ad16980c537614be84809200c86897a8f1a651d2458"}, "downloads": -1, "filename": "svreal-0.1.8.tar.gz", "has_sig": false, "md5_digest": "0b02ed70284356be8600e8b8d59b2e51", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 19486, "upload_time": "2020-01-21T00:13:55", "upload_time_iso_8601": "2020-01-21T00:13:55.626592Z", "url": "https://files.pythonhosted.org/packages/b0/91/d695c7566ea7c36d9ef26b4c64f41e591f7023b4f844efbf630c765f889b/svreal-0.1.8.tar.gz", "yanked": false}], "0.1.9": [{"comment_text": "", "digests": {"md5": "e917ed45252c61599376ce671837a47a", "sha256": "02b51818002184162442d368f6b50d718d981026991b43995028d156f977a76e"}, "downloads": -1, "filename": "svreal-0.1.9.tar.gz", "has_sig": false, "md5_digest": "e917ed45252c61599376ce671837a47a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 19501, "upload_time": "2020-01-21T02:33:51", "upload_time_iso_8601": "2020-01-21T02:33:51.231251Z", "url": "https://files.pythonhosted.org/packages/0e/bd/e167cec88ffe1e7fe1de2547e889d35ae527704c867d1345ee0b0e6db4cf/svreal-0.1.9.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "2bf2264faa9f71baf99c9f2a9e603d75", "sha256": "0c4f02e8833e663002756120b67792a1f3d3012c8d0fb37a568d0f8dbcfba24c"}, "downloads": -1, "filename": "svreal-0.2.0.tar.gz", "has_sig": false, "md5_digest": "2bf2264faa9f71baf99c9f2a9e603d75", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 19485, "upload_time": "2020-02-29T04:16:57", "upload_time_iso_8601": "2020-02-29T04:16:57.059357Z", "url": "https://files.pythonhosted.org/packages/97/28/cff4e53d39ca27efbb2e3fb059e10ca7d135cf4de522a5acb80e712c5953/svreal-0.2.0.tar.gz", "yanked": false}], "0.2.0.dev1": [{"comment_text": "", "digests": {"md5": "fb4ba375503d5cdd392a2ace226a9789", "sha256": "5aa2bcf3b99519908e568a4b1acc9963ca956b1c682de8cc4761fa7e2804581e"}, "downloads": -1, "filename": "svreal-0.2.0.dev1.tar.gz", "has_sig": false, "md5_digest": "fb4ba375503d5cdd392a2ace226a9789", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 19517, "upload_time": "2020-01-31T00:23:37", "upload_time_iso_8601": "2020-01-31T00:23:37.803650Z", "url": "https://files.pythonhosted.org/packages/1b/3e/bb2e930cacda64ab9da5969d9952c8598c02dd7d7ef93c16753618bcc95f/svreal-0.2.0.dev1.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "15c6645414c2dc0bc4a5f98e3c5ef22b", "sha256": "9795790968d0892159b10a80b6a26cd0dee3d2a04d986d4b888c4b9b9631f4e9"}, "downloads": -1, "filename": "svreal-0.2.1.tar.gz", "has_sig": false, "md5_digest": "15c6645414c2dc0bc4a5f98e3c5ef22b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 20026, "upload_time": "2020-03-14T03:09:04", "upload_time_iso_8601": "2020-03-14T03:09:04.619708Z", "url": "https://files.pythonhosted.org/packages/ea/43/6e361813707c0f099072b50932d0d883c6739644911578a02dc7e7599d66/svreal-0.2.1.tar.gz", "yanked": false}], "0.2.1.dev1": [{"comment_text": "", "digests": {"md5": "6a5b2ba1bd69e4b1e4d88b80ba423301", "sha256": "d34ee46ae46d360160359e5cf0ffe63ab98f65352205272533f56582ffc34c11"}, "downloads": -1, "filename": "svreal-0.2.1.dev1.tar.gz", "has_sig": false, "md5_digest": "6a5b2ba1bd69e4b1e4d88b80ba423301", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 20044, "upload_time": "2020-03-13T23:46:22", "upload_time_iso_8601": "2020-03-13T23:46:22.916088Z", "url": "https://files.pythonhosted.org/packages/a7/75/2cc69d31b38bee81b4354a66bd676148d4d07788eb7ecc7f0a43facc4144/svreal-0.2.1.dev1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "8be31fa3e750302a5cbf1a78ff061931", "sha256": "0d5d80ecf1cb0a73cb39c251dc5e2db02baf42b0ec37e106b05ee5480e20ee55"}, "downloads": -1, "filename": "svreal-0.2.2.tar.gz", "has_sig": false, "md5_digest": "8be31fa3e750302a5cbf1a78ff061931", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 20053, "upload_time": "2020-03-18T03:42:32", "upload_time_iso_8601": "2020-03-18T03:42:32.695890Z", "url": "https://files.pythonhosted.org/packages/3e/ab/839b7b5cb8588a29850eb869e824fa55e96d1548733e66adac7345d70daa/svreal-0.2.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "8be31fa3e750302a5cbf1a78ff061931", "sha256": "0d5d80ecf1cb0a73cb39c251dc5e2db02baf42b0ec37e106b05ee5480e20ee55"}, "downloads": -1, "filename": "svreal-0.2.2.tar.gz", "has_sig": false, "md5_digest": "8be31fa3e750302a5cbf1a78ff061931", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 20053, "upload_time": "2020-03-18T03:42:32", "upload_time_iso_8601": "2020-03-18T03:42:32.695890Z", "url": "https://files.pythonhosted.org/packages/3e/ab/839b7b5cb8588a29850eb869e824fa55e96d1548733e66adac7345d70daa/svreal-0.2.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:59:47 2020"}