{"info": {"author": "Wouter Boomsma", "author_email": "wb@di.ku.dk", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: C++", "Programming Language :: Cython", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6"], "description": "[![Build Status](https://travis-ci.org/wouterboomsma/eigency.svg?branch=master)](https://travis-ci.org/wouterboomsma/eigency)\n\n# Eigency\nEigency is a Cython interface between Numpy arrays and Matrix/Array\nobjects from the Eigen C++ library. It is intended to simplify the\nprocess of writing C++ extensions using the Eigen library. Eigency is\ndesigned to reuse the underlying storage of the arrays when passing\ndata back and forth, and will thus avoid making unnecessary copies\nwhenever possible. Only in cases where copies are explicitly requested\nby your C++ code will they be made.\n\nBelow is a description of a range of common usage scenarios. A full working\nexample of both setup and these different use cases is available in the\n`test` directory distributed with the this package.\n\n## Setup\nTo import eigency functionality, add the following to your `.pyx` file:\n```\nfrom eigency.core cimport *\n```\nIn addition, in the `setup.py` file, the include directories must be\nset up to include the eigency includes. This can be done by calling\nthe `get_includes` function in the `eigency` module:\n```\nimport eigency\n...\nextensions = [\n    Extension(\"module-dir-name/module-name\", [\"module-dir-name/module-name.pyx\"],\n              include_dirs = [\".\", \"module-dir-name\"] + eigency.get_includes()\n              ),\n]\n```\nEigency includes a version of the Eigen library, and the `get_includes` function will include the path to this directory. If you\nhave your own version of Eigen, just set the `include_eigen` option to False, and add your own path instead:\n\n```\n    include_dirs = [\".\", \"module-dir-name\", 'path-to-own-eigen'] + eigency.get_includes(include_eigen=False)\n```\n\n## From Numpy to Eigen\nAssume we are writing a Cython interface to the following C++ function:\n\n```c++\nvoid function_w_mat_arg(const Eigen::Map<Eigen::MatrixXd> &mat) {\n    std::cout << mat << \"\\n\";\n}\n```\n\nNote that we use `Eigen::Map` to ensure that we can reuse the storage\nof the numpy array, thus avoiding making a copy. Assuming the C++ code\nis in a file called `functions.h`, the corresponding `.pyx` entry could look like this:\n\n```\ncdef extern from \"functions.h\":\n     cdef void _function_w_mat_arg \"function_w_mat_arg\"(Map[MatrixXd] &)\n\n# This will be exposed to Python\ndef function_w_mat_arg(np.ndarray array):\n    return _function_w_mat_arg(Map[MatrixXd](array))\n```\n\nThe last line contains the actual conversion. `Map` is an Eigency\ntype that derives from the real Eigen map, and will take care of\nthe conversion from the numpy array to the corresponding Eigen type. \n\nWe can now call the C++ function directly from Python:\n```python\n>>> import numpy as np\n>>> import eigency_tests\n>>> x = np.array([[1.1, 2.2], [3.3, 4.4]])\n>>> eigency_tests.function_w_mat_arg(x)\n1.1 3.3\n2.2 4.4\n```\n(if you are wondering about why the matrix is transposed, please \nsee the Storage layout section below).\n\n## Types matter\n\nThe basic idea behind eigency is to share the underlying representation of a \nnumpy array between Python and C++. This means that somewhere in the process, \nwe need to make explicit which numerical types we are dealing with. In the\nfunction above, we specify that we expect an Eigen MatrixXd, which means\nthat the numpy array must also contain double (i.e. float64) values. If we instead provide\na numpy array of ints, we will get strange results. \n\n```python\n>>> import numpy as np\n>>> import eigency_tests\n>>> x = np.array([[1, 2], [3, 4]])\n>>> eigency_tests.function_w_mat_arg(x)\n4.94066e-324  1.4822e-323\n9.88131e-324 1.97626e-323\n```\nThis is because we are explicitly asking C++ to interpret out python integer\nvalues as floats. \n\nTo avoid this type of error, you can force your cython function to\naccept only numpy arrays of a specific type:\n\n```\ncdef extern from \"functions.h\":\n     cdef void _function_w_mat_arg \"function_w_mat_arg\"(Map[MatrixXd] &)\n\n# This will be exposed to Python\ndef function_w_mat_arg(np.ndarray[np.float64_t, ndim=2] array):\n    return _function_w_mat_arg(Map[MatrixXd](array))\n```\n\n(Note that when using this technique to select the type, you also need to specify \nthe dimensions of the array (this will default to 1)). Using this new definition, \nusers will get an error when passing arrays of the wrong type:\n\n```python\n>>> import numpy as np\n>>> import eigency_tests\n>>> x = np.array([[1, 2], [3, 4]])\n>>> eigency_tests.function_w_mat_arg(x)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  File \"eigency_tests/eigency_tests.pyx\", line 87, in eigency_tests.eigency_tests.function_w_mat_arg\nValueError: Buffer dtype mismatch, expected 'float64_t' but got 'long'\n```\n\nSince it avoids many surprises, it is strongly recommended to use this technique\nto specify the full types of numpy arrays in your cython code whenever \npossible.\n\n\n## Writing Eigen Map types in Cython\n\nSince Cython does not support nested fused types, you cannot write types like `Map[Matrix[double, 2, 2]]`. In most cases, you won't need to, since you can just use Eigens convenience typedefs, such as `Map[VectorXd]`. If you need the additional flexibility of the full specification, you can use the `FlattenedMap` type, where all type arguments can be specified at top level, for instance `FlattenedMap[Matrix, double, _2, _3]` or `FlattenedMap[Matrix, double, _2, Dynamic]`. Note that dimensions must be prefixed with an underscore.\n\nUsing full specifications of the Eigen types, the previous example would look like this:\n```\ncdef extern from \"functions.h\":\n     cdef void _function_w_mat_arg \"function_w_mat_arg\" (FlattenedMap[Matrix, double, Dynamic, Dynamic] &)\n\n# This will be exposed to Python\ndef function_w_mat_arg(np.ndarray[np.float64_t, ndim=2] array):\n    return _function_w_mat_arg(FlattenedMap[Matrix, double, Dynamic, Dynamic](array))\n```\n\n`FlattenedType` takes four template parameters: arraytype, scalartype,\nrows and cols.  Eigen supports a few other template arguments for\nsetting the storage layout and Map strides. Since cython does not\nsupport default template arguments for fused types, we have instead\ndefined separate types for this purpose. These are called\n`FlattenedMapWithOrder` and `FlattenedMapWithStride` with five and eight\ntemplate arguments, respectively. For details on their use, see the section\nabout storage layout below.\n\n## From Numpy to Eigen (insisting on a copy)\n\nEigency will not complain if the C++ function you interface with does\nnot take a Eigen Map object, but instead a regular Eigen Matrix or\nArray. However, in such cases, a copy will be made. Actually, the\nprocedure is exactly the same as above. In the `.pyx` file, you still\ndefine everything exactly the same way as for the Map case described above.\n\nFor instance, given the following C++ function:\n```c++\nvoid function_w_vec_arg_no_map(const Eigen::VectorXd &vec);\n```\n\nThe Cython definitions would still look like this:\n\n```\ncdef extern from \"functions.h\":\n     cdef void _function_w_vec_arg_no_map \"function_w_vec_arg_no_map\"(Map[VectorXd] &)\n\n# This will be exposed to Python\ndef function_w_vec_arg_no_map(np.ndarray[np.float64_t] array):\n    return _function_w_vec_arg_no_map(Map[VectorXd](array))\n```\n\nCython will not mind the fact that the argument type in the extern\ndeclaration (a Map type) differs from the actual one in the `.h` file,\nas long as one can be assigned to the other. Since Map objects can be\nassigned to their corresponding Matrix/Array types this works\nseemlessly. But keep in mind that this assignment will make a copy of\nthe underlying data.\n\n## Eigen to Numpy\n\nC++ functions returning a reference to an Eigen Matrix/Array can also\nbe transferred to numpy arrays without copying their content.  Assume\nwe have a class with a single getter function that returns an Eigen\nmatrix member:\n\n```c++\nclass MyClass {\npublic:\n    MyClass():\n        matrix(Eigen::Matrix3d::Constant(3.)) {\n    }\n    Eigen::MatrixXd &get_matrix() {\n        return this->matrix;\n    }\nprivate:\n    Eigen::Matrix3d matrix;\n};\n```\n\nThe Cython C++ class interface is specified as usual:\n\n```\n     cdef cppclass _MyClass \"MyClass\":\n         _MyClass \"MyClass\"() except +\n         Matrix3d &get_matrix()\n```\n\nAnd the corresponding Python wrapper:\n\n```python\ncdef class MyClass:\n    cdef _MyClass *thisptr;\n\n    def __cinit__(self):\n        self.thisptr = new _MyClass()\n\n    def __dealloc__(self):\n        del self.thisptr\n\n    def get_matrix(self):\n        return ndarray(self.thisptr.get_matrix())\n```\n\nThis last line contains the actual conversion. Again, eigency has its\nown version of `ndarray`, that will take care of the conversion for\nyou.\n\nDue to limitations in Cython, Eigency cannot deal with full\nMatrix/Array template specifications as return types\n(e.g. `Matrix[double, 4, 2]`). However, as a workaround, you can use\n`PlainObjectBase` as a return type in such cases (or in all cases if\nyou prefer):\n\n```\n         PlainObjectBase &get_matrix()\n```\n\n## Overriding default behavior\n\nThe `ndarray` conversion type specifier will attempt do guess whether you want a copy\nor a view, depending on the return type. Most of the time, this is\nprobably what you want. However, there might be cases where you want\nto override this behavior. For instance, functions returning const\nreferences will result in a copy of the array, since the const-ness\ncannot be enforced in Python. However, you can always override the\ndefault behavior by using the `ndarray_copy` or `ndarray_view`\nfunctions.\n\nExpanding the `MyClass` example from before:\n\n```c++\nclass MyClass {\npublic:\n    ...\n    const Eigen::MatrixXd &get_const_matrix() {\n        return this->matrix;\n    }\n    ...\n};\n```\n\nWith the corresponding cython interface specification\nThe Cython C++ class interface is specified as usual:\n\n```\n     cdef cppclass _MyClass \"MyClass\":\n         ...\n         const Matrix3d &get_const_matrix()\n```\n\nThe following would return a copy\n\n```python\ncdef class MyClass:\n    ...\n    def get_const_matrix(self):\n        return ndarray(self.thisptr.get_const_matrix())\n```\n\nwhile the following would force it to return a view\n\n```python\ncdef class MyClass:\n    ...\n    def get_const_matrix(self):\n        return ndarray_view(self.thisptr.get_const_matrix())\n```\n\n## Eigen to Numpy (non-reference return values)\n\nFunctions returning an Eigen object (not a reference), are specified\nin a similar way. For instance, given the following C++ function:\n\n```c++\nEigen::Matrix3d function_w_mat_retval();\n```\n\nThe Cython code could be written as:\n\n```\ncdef extern from \"functions.h\":\n     cdef Matrix3d _function_w_mat_retval \"function_w_mat_retval\" ()\n\n# This will be exposed to Python\ndef function_w_mat_retval():\n    return ndarray_copy(_function_w_mat_retval())\n```\n\nAs mentioned above, you can replace `Matrix3d` (or any other Eigen return type) with\n`PlainObjectBase`, which is especially relevant when working with\nEigen object that do not have an associated convenience typedef.\n\nNote that we use `ndarray_copy` instead of `ndarray` to explicitly\nstate that a copy should be made. In c++11 compliant compilers, it\nwill detect the rvalue reference and automatically make a copy even if\nyou just use `ndarray` (see next section), but to ensure that it works\nalso with older compilers it is recommended to always use\n`ndarray_copy` when returning newly constructed eigen values.\n\n\n## Corrupt data when returning non-map types\nThe tendency of Eigency to avoid copies whenever possible can lead\nto corrupted data when returning non-map Eigen arrays. For instance,\nin the `function_w_mat_retval` from the previous section, a temporary\nvalue will be returned from C++, and we have to take care to make\na copy of this data instead of letting the resulting numpy array\nrefer directly to this memory. In C++11, this situation can be\ndetected directly using rvalue references, and it will therefore\nautomatically make a copy: \n```\ndef function_w_mat_retval():\n    # This works in C++11, because it detects the rvalue reference\n    return ndarray(_function_w_mat_retval()) \n```\n\nHowever, to make sure it works with older compilers,\nit is recommended to use the `ndarray_copy` conversion:\n\n```\ndef function_w_mat_retval():\n    # Explicit request for copy - this always works\n    return ndarray_copy(_function_w_mat_retval()) \n```\n\n\n\n## Storage layout - why arrays are sometimes transposed\n\nThe default storage layout used in numpy and Eigen differ. Numpy uses\na row-major layout (C-style) per default while Eigen uses a\ncolumn-major layout (Fortran style) by default.  In Eigency, we prioritize to\navoid copying of data whenever possible, which can have unexpected\nconsequences in some cases: There is no problem when passing values\nfrom C++ to Python - we just adjust the storage layout of the returned\nnumpy array to match that of Eigen. However, since the storage layout\nis encoded into the _type_ of the Eigen array (or the type of the\nMap), we cannot automatically change the layout in the Python to C++ direction. In\nEigency, we have therefore opted to return the transposed array/matrix\nin such cases. This provides the user with the flexibility to deal\nwith the problem either in Python (use order=\"F\" when constructing\nyour numpy array), or on the C++ side: (1) explicitly define your\nargument to have the row-major storage layout, 2) manually set the Map\nstride, or 3) just call `.transpose()` on the received\narray/matrix). \n\nAs an example, consider the case of a C++ function that both receives\nand returns a Eigen Map type, thus acting as a filter:\n\n```c++\nEigen::Map<Eigen::ArrayXXd> function_filter(Eigen::Map<Eigen::ArrayXXd> &mat) {\n    return mat;\n}\n```\n\nThe Cython code could be:\n\n```\ncdef extern from \"functions.h\":\n    ...\n    cdef Map[ArrayXXd] &_function_filter1 \"function_filter1\" (Map[ArrayXXd] &)\n\ndef function_filter1(np.ndarray[np.float64_t, ndim=2] array):\n    return ndarray(_function_filter1(Map[ArrayXXd](array)))\n\n```\n\nIf we call this function from Python in the standard way, we will\nsee that the array is transposed on the way from Python to C++, and\nremains that way when it is again returned to Python:\n\n```python\n>>> x = np.array([[1., 2., 3., 4.], [5., 6., 7., 8.]])\n>>> y = function_filter1(x)\n>>> print x\n[[ 1.  2.  3.  4.]\n [ 5.  6.  7.  8.]]\n>>> print y\n[[ 1.  5.]\n [ 2.  6.]\n [ 3.  7.]\n [ 4.  8.]]\n```\n\nThe simplest way to avoid this is to tell numpy to use a\ncolumn-major array layout instead of the default row-major\nlayout. This can be done using the order='F' option:\n\n```python\n>>> x = np.array([[1., 2., 3., 4.], [5., 6., 7., 8.]], order='F')\n>>> y = function_filter1(x)\n>>> print x\n[[ 1.  2.  3.  4.]\n [ 5.  6.  7.  8.]]\n>>> print y\n[[ 1.  2.  3.  4.]\n [ 5.  6.  7.  8.]]\n```\n\nThe other alternative is to tell Eigen to use RowMajor layout. This\nrequires changing the C++ function definition:\n\n```c++\ntypedef Eigen::Map<Eigen::Array<double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor> > RowMajorArrayMap;\n\nRowMajorArrayMap &function_filter2(RowMajorArrayMap &mat) {\n    return mat;\n}\n```\n\nTo write the corresponding Cython definition, we need the expanded version of\n`FlattenedMap` called `FlattenedMapWithOrder`, which allows us to specify\nthe storage order:\n\n```\ncdef extern from \"functions.h\":\n    ...\n    cdef PlainObjectBase _function_filter2 \"function_filter2\" (FlattenedMapWithOrder[Array, double, Dynamic, Dynamic, RowMajor])\n\ndef function_filter2(np.ndarray[np.float64_t, ndim=2] array):\n    return ndarray(_function_filter2(FlattenedMapWithOrder[Array, double, Dynamic, Dynamic, RowMajor](array)))\n```\n\nAnother alternative is to keep the array itself in RowMajor format,\nbut use different stride values for the Map type:\n\n```c++\ntypedef Eigen::Map<Eigen::ArrayXXd, Eigen::Unaligned, Eigen::Stride<1, Eigen::Dynamic> > CustomStrideMap;\n\nCustomStrideMap &function_filter3(CustomStrideMap &);\n```\n\nIn this case, in Cython, we need to use the even more extended\n`FlattenedMap` type called `FlattenedMapWithStride`, taking eight\narguments:\n\n```\ncdef extern from \"functions.h\":\n    ...\n    cdef PlainObjectBase _function_filter3 \"function_filter3\" (FlattenedMapWithStride[Array, double, Dynamic, Dynamic, ColMajor, Unaligned, _1, Dynamic])\n\ndef function_filter3(np.ndarray[np.float64_t, ndim=2] array):\n    return ndarray(_function_filter3(FlattenedMapWithStride[Array, double, Dynamic, Dynamic, ColMajor, Unaligned, _1, Dynamic](array)))\n```\n\nIn all three cases, the returned array will now be of the same shape\nas the original.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/wouterboomsma/eigency", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "rmjarvis.eigency", "package_url": "https://pypi.org/project/rmjarvis.eigency/", "platform": "", "project_url": "https://pypi.org/project/rmjarvis.eigency/", "project_urls": {"Homepage": "https://github.com/wouterboomsma/eigency"}, "release_url": "https://pypi.org/project/rmjarvis.eigency/1.77.1/", "requires_dist": null, "requires_python": "", "summary": "Cython interface between the numpy arrays and the Matrix/Array classes of the Eigen C++ library", "version": "1.77.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            [![Build Status](https://travis-ci.org/wouterboomsma/eigency.svg?branch=master)](https://travis-ci.org/wouterboomsma/eigency)<br><br># Eigency<br>Eigency is a Cython interface between Numpy arrays and Matrix/Array<br>objects from the Eigen C++ library. It is intended to simplify the<br>process of writing C++ extensions using the Eigen library. Eigency is<br>designed to reuse the underlying storage of the arrays when passing<br>data back and forth, and will thus avoid making unnecessary copies<br>whenever possible. Only in cases where copies are explicitly requested<br>by your C++ code will they be made.<br><br>Below is a description of a range of common usage scenarios. A full working<br>example of both setup and these different use cases is available in the<br>`test` directory distributed with the this package.<br><br>## Setup<br>To import eigency functionality, add the following to your `.pyx` file:<br>```<br>from eigency.core cimport *<br>```<br>In addition, in the `setup.py` file, the include directories must be<br>set up to include the eigency includes. This can be done by calling<br>the `get_includes` function in the `eigency` module:<br>```<br>import eigency<br>...<br>extensions = [<br>    Extension(\"module-dir-name/module-name\", [\"module-dir-name/module-name.pyx\"],<br>              include_dirs = [\".\", \"module-dir-name\"] + eigency.get_includes()<br>              ),<br>]<br>```<br>Eigency includes a version of the Eigen library, and the `get_includes` function will include the path to this directory. If you<br>have your own version of Eigen, just set the `include_eigen` option to False, and add your own path instead:<br><br>```<br>    include_dirs = [\".\", \"module-dir-name\", 'path-to-own-eigen'] + eigency.get_includes(include_eigen=False)<br>```<br><br>## From Numpy to Eigen<br>Assume we are writing a Cython interface to the following C++ function:<br><br>```c++<br>void function_w_mat_arg(const Eigen::Map&lt;Eigen::MatrixXd&gt; &amp;mat) {<br>    std::cout &lt;&lt; mat &lt;&lt; \"\\n\";<br>}<br>```<br><br>Note that we use `Eigen::Map` to ensure that we can reuse the storage<br>of the numpy array, thus avoiding making a copy. Assuming the C++ code<br>is in a file called `functions.h`, the corresponding `.pyx` entry could look like this:<br><br>```<br>cdef extern from \"functions.h\":<br>     cdef void _function_w_mat_arg \"function_w_mat_arg\"(Map[MatrixXd] &amp;)<br><br># This will be exposed to Python<br>def function_w_mat_arg(np.ndarray array):<br>    return _function_w_mat_arg(Map[MatrixXd](array))<br>```<br><br>The last line contains the actual conversion. `Map` is an Eigency<br>type that derives from the real Eigen map, and will take care of<br>the conversion from the numpy array to the corresponding Eigen type. <br><br>We can now call the C++ function directly from Python:<br>```python<br>&gt;&gt;&gt; import numpy as np<br>&gt;&gt;&gt; import eigency_tests<br>&gt;&gt;&gt; x = np.array([[1.1, 2.2], [3.3, 4.4]])<br>&gt;&gt;&gt; eigency_tests.function_w_mat_arg(x)<br>1.1 3.3<br>2.2 4.4<br>```<br>(if you are wondering about why the matrix is transposed, please <br>see the Storage layout section below).<br><br>## Types matter<br><br>The basic idea behind eigency is to share the underlying representation of a <br>numpy array between Python and C++. This means that somewhere in the process, <br>we need to make explicit which numerical types we are dealing with. In the<br>function above, we specify that we expect an Eigen MatrixXd, which means<br>that the numpy array must also contain double (i.e. float64) values. If we instead provide<br>a numpy array of ints, we will get strange results. <br><br>```python<br>&gt;&gt;&gt; import numpy as np<br>&gt;&gt;&gt; import eigency_tests<br>&gt;&gt;&gt; x = np.array([[1, 2], [3, 4]])<br>&gt;&gt;&gt; eigency_tests.function_w_mat_arg(x)<br>4.94066e-324  1.4822e-323<br>9.88131e-324 1.97626e-323<br>```<br>This is because we are explicitly asking C++ to interpret out python integer<br>values as floats. <br><br>To avoid this type of error, you can force your cython function to<br>accept only numpy arrays of a specific type:<br><br>```<br>cdef extern from \"functions.h\":<br>     cdef void _function_w_mat_arg \"function_w_mat_arg\"(Map[MatrixXd] &amp;)<br><br># This will be exposed to Python<br>def function_w_mat_arg(np.ndarray[np.float64_t, ndim=2] array):<br>    return _function_w_mat_arg(Map[MatrixXd](array))<br>```<br><br>(Note that when using this technique to select the type, you also need to specify <br>the dimensions of the array (this will default to 1)). Using this new definition, <br>users will get an error when passing arrays of the wrong type:<br><br>```python<br>&gt;&gt;&gt; import numpy as np<br>&gt;&gt;&gt; import eigency_tests<br>&gt;&gt;&gt; x = np.array([[1, 2], [3, 4]])<br>&gt;&gt;&gt; eigency_tests.function_w_mat_arg(x)<br>Traceback (most recent call last):<br>  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;<br>  File \"eigency_tests/eigency_tests.pyx\", line 87, in eigency_tests.eigency_tests.function_w_mat_arg<br>ValueError: Buffer dtype mismatch, expected 'float64_t' but got 'long'<br>```<br><br>Since it avoids many surprises, it is strongly recommended to use this technique<br>to specify the full types of numpy arrays in your cython code whenever <br>possible.<br><br><br>## Writing Eigen Map types in Cython<br><br>Since Cython does not support nested fused types, you cannot write types like `Map[Matrix[double, 2, 2]]`. In most cases, you won't need to, since you can just use Eigens convenience typedefs, such as `Map[VectorXd]`. If you need the additional flexibility of the full specification, you can use the `FlattenedMap` type, where all type arguments can be specified at top level, for instance `FlattenedMap[Matrix, double, _2, _3]` or `FlattenedMap[Matrix, double, _2, Dynamic]`. Note that dimensions must be prefixed with an underscore.<br><br>Using full specifications of the Eigen types, the previous example would look like this:<br>```<br>cdef extern from \"functions.h\":<br>     cdef void _function_w_mat_arg \"function_w_mat_arg\" (FlattenedMap[Matrix, double, Dynamic, Dynamic] &amp;)<br><br># This will be exposed to Python<br>def function_w_mat_arg(np.ndarray[np.float64_t, ndim=2] array):<br>    return _function_w_mat_arg(FlattenedMap[Matrix, double, Dynamic, Dynamic](array))<br>```<br><br>`FlattenedType` takes four template parameters: arraytype, scalartype,<br>rows and cols.  Eigen supports a few other template arguments for<br>setting the storage layout and Map strides. Since cython does not<br>support default template arguments for fused types, we have instead<br>defined separate types for this purpose. These are called<br>`FlattenedMapWithOrder` and `FlattenedMapWithStride` with five and eight<br>template arguments, respectively. For details on their use, see the section<br>about storage layout below.<br><br>## From Numpy to Eigen (insisting on a copy)<br><br>Eigency will not complain if the C++ function you interface with does<br>not take a Eigen Map object, but instead a regular Eigen Matrix or<br>Array. However, in such cases, a copy will be made. Actually, the<br>procedure is exactly the same as above. In the `.pyx` file, you still<br>define everything exactly the same way as for the Map case described above.<br><br>For instance, given the following C++ function:<br>```c++<br>void function_w_vec_arg_no_map(const Eigen::VectorXd &amp;vec);<br>```<br><br>The Cython definitions would still look like this:<br><br>```<br>cdef extern from \"functions.h\":<br>     cdef void _function_w_vec_arg_no_map \"function_w_vec_arg_no_map\"(Map[VectorXd] &amp;)<br><br># This will be exposed to Python<br>def function_w_vec_arg_no_map(np.ndarray[np.float64_t] array):<br>    return _function_w_vec_arg_no_map(Map[VectorXd](array))<br>```<br><br>Cython will not mind the fact that the argument type in the extern<br>declaration (a Map type) differs from the actual one in the `.h` file,<br>as long as one can be assigned to the other. Since Map objects can be<br>assigned to their corresponding Matrix/Array types this works<br>seemlessly. But keep in mind that this assignment will make a copy of<br>the underlying data.<br><br>## Eigen to Numpy<br><br>C++ functions returning a reference to an Eigen Matrix/Array can also<br>be transferred to numpy arrays without copying their content.  Assume<br>we have a class with a single getter function that returns an Eigen<br>matrix member:<br><br>```c++<br>class MyClass {<br>public:<br>    MyClass():<br>        matrix(Eigen::Matrix3d::Constant(3.)) {<br>    }<br>    Eigen::MatrixXd &amp;get_matrix() {<br>        return this-&gt;matrix;<br>    }<br>private:<br>    Eigen::Matrix3d matrix;<br>};<br>```<br><br>The Cython C++ class interface is specified as usual:<br><br>```<br>     cdef cppclass _MyClass \"MyClass\":<br>         _MyClass \"MyClass\"() except +<br>         Matrix3d &amp;get_matrix()<br>```<br><br>And the corresponding Python wrapper:<br><br>```python<br>cdef class MyClass:<br>    cdef _MyClass *thisptr;<br><br>    def __cinit__(self):<br>        self.thisptr = new _MyClass()<br><br>    def __dealloc__(self):<br>        del self.thisptr<br><br>    def get_matrix(self):<br>        return ndarray(self.thisptr.get_matrix())<br>```<br><br>This last line contains the actual conversion. Again, eigency has its<br>own version of `ndarray`, that will take care of the conversion for<br>you.<br><br>Due to limitations in Cython, Eigency cannot deal with full<br>Matrix/Array template specifications as return types<br>(e.g. `Matrix[double, 4, 2]`). However, as a workaround, you can use<br>`PlainObjectBase` as a return type in such cases (or in all cases if<br>you prefer):<br><br>```<br>         PlainObjectBase &amp;get_matrix()<br>```<br><br>## Overriding default behavior<br><br>The `ndarray` conversion type specifier will attempt do guess whether you want a copy<br>or a view, depending on the return type. Most of the time, this is<br>probably what you want. However, there might be cases where you want<br>to override this behavior. For instance, functions returning const<br>references will result in a copy of the array, since the const-ness<br>cannot be enforced in Python. However, you can always override the<br>default behavior by using the `ndarray_copy` or `ndarray_view`<br>functions.<br><br>Expanding the `MyClass` example from before:<br><br>```c++<br>class MyClass {<br>public:<br>    ...<br>    const Eigen::MatrixXd &amp;get_const_matrix() {<br>        return this-&gt;matrix;<br>    }<br>    ...<br>};<br>```<br><br>With the corresponding cython interface specification<br>The Cython C++ class interface is specified as usual:<br><br>```<br>     cdef cppclass _MyClass \"MyClass\":<br>         ...<br>         const Matrix3d &amp;get_const_matrix()<br>```<br><br>The following would return a copy<br><br>```python<br>cdef class MyClass:<br>    ...<br>    def get_const_matrix(self):<br>        return ndarray(self.thisptr.get_const_matrix())<br>```<br><br>while the following would force it to return a view<br><br>```python<br>cdef class MyClass:<br>    ...<br>    def get_const_matrix(self):<br>        return ndarray_view(self.thisptr.get_const_matrix())<br>```<br><br>## Eigen to Numpy (non-reference return values)<br><br>Functions returning an Eigen object (not a reference), are specified<br>in a similar way. For instance, given the following C++ function:<br><br>```c++<br>Eigen::Matrix3d function_w_mat_retval();<br>```<br><br>The Cython code could be written as:<br><br>```<br>cdef extern from \"functions.h\":<br>     cdef Matrix3d _function_w_mat_retval \"function_w_mat_retval\" ()<br><br># This will be exposed to Python<br>def function_w_mat_retval():<br>    return ndarray_copy(_function_w_mat_retval())<br>```<br><br>As mentioned above, you can replace `Matrix3d` (or any other Eigen return type) with<br>`PlainObjectBase`, which is especially relevant when working with<br>Eigen object that do not have an associated convenience typedef.<br><br>Note that we use `ndarray_copy` instead of `ndarray` to explicitly<br>state that a copy should be made. In c++11 compliant compilers, it<br>will detect the rvalue reference and automatically make a copy even if<br>you just use `ndarray` (see next section), but to ensure that it works<br>also with older compilers it is recommended to always use<br>`ndarray_copy` when returning newly constructed eigen values.<br><br><br>## Corrupt data when returning non-map types<br>The tendency of Eigency to avoid copies whenever possible can lead<br>to corrupted data when returning non-map Eigen arrays. For instance,<br>in the `function_w_mat_retval` from the previous section, a temporary<br>value will be returned from C++, and we have to take care to make<br>a copy of this data instead of letting the resulting numpy array<br>refer directly to this memory. In C++11, this situation can be<br>detected directly using rvalue references, and it will therefore<br>automatically make a copy: <br>```<br>def function_w_mat_retval():<br>    # This works in C++11, because it detects the rvalue reference<br>    return ndarray(_function_w_mat_retval()) <br>```<br><br>However, to make sure it works with older compilers,<br>it is recommended to use the `ndarray_copy` conversion:<br><br>```<br>def function_w_mat_retval():<br>    # Explicit request for copy - this always works<br>    return ndarray_copy(_function_w_mat_retval()) <br>```<br><br><br><br>## Storage layout - why arrays are sometimes transposed<br><br>The default storage layout used in numpy and Eigen differ. Numpy uses<br>a row-major layout (C-style) per default while Eigen uses a<br>column-major layout (Fortran style) by default.  In Eigency, we prioritize to<br>avoid copying of data whenever possible, which can have unexpected<br>consequences in some cases: There is no problem when passing values<br>from C++ to Python - we just adjust the storage layout of the returned<br>numpy array to match that of Eigen. However, since the storage layout<br>is encoded into the _type_ of the Eigen array (or the type of the<br>Map), we cannot automatically change the layout in the Python to C++ direction. In<br>Eigency, we have therefore opted to return the transposed array/matrix<br>in such cases. This provides the user with the flexibility to deal<br>with the problem either in Python (use order=\"F\" when constructing<br>your numpy array), or on the C++ side: (1) explicitly define your<br>argument to have the row-major storage layout, 2) manually set the Map<br>stride, or 3) just call `.transpose()` on the received<br>array/matrix). <br><br>As an example, consider the case of a C++ function that both receives<br>and returns a Eigen Map type, thus acting as a filter:<br><br>```c++<br>Eigen::Map&lt;Eigen::ArrayXXd&gt; function_filter(Eigen::Map&lt;Eigen::ArrayXXd&gt; &amp;mat) {<br>    return mat;<br>}<br>```<br><br>The Cython code could be:<br><br>```<br>cdef extern from \"functions.h\":<br>    ...<br>    cdef Map[ArrayXXd] &amp;_function_filter1 \"function_filter1\" (Map[ArrayXXd] &amp;)<br><br>def function_filter1(np.ndarray[np.float64_t, ndim=2] array):<br>    return ndarray(_function_filter1(Map[ArrayXXd](array)))<br><br>```<br><br>If we call this function from Python in the standard way, we will<br>see that the array is transposed on the way from Python to C++, and<br>remains that way when it is again returned to Python:<br><br>```python<br>&gt;&gt;&gt; x = np.array([[1., 2., 3., 4.], [5., 6., 7., 8.]])<br>&gt;&gt;&gt; y = function_filter1(x)<br>&gt;&gt;&gt; print x<br>[[ 1.  2.  3.  4.]<br> [ 5.  6.  7.  8.]]<br>&gt;&gt;&gt; print y<br>[[ 1.  5.]<br> [ 2.  6.]<br> [ 3.  7.]<br> [ 4.  8.]]<br>```<br><br>The simplest way to avoid this is to tell numpy to use a<br>column-major array layout instead of the default row-major<br>layout. This can be done using the order='F' option:<br><br>```python<br>&gt;&gt;&gt; x = np.array([[1., 2., 3., 4.], [5., 6., 7., 8.]], order='F')<br>&gt;&gt;&gt; y = function_filter1(x)<br>&gt;&gt;&gt; print x<br>[[ 1.  2.  3.  4.]<br> [ 5.  6.  7.  8.]]<br>&gt;&gt;&gt; print y<br>[[ 1.  2.  3.  4.]<br> [ 5.  6.  7.  8.]]<br>```<br><br>The other alternative is to tell Eigen to use RowMajor layout. This<br>requires changing the C++ function definition:<br><br>```c++<br>typedef Eigen::Map&lt;Eigen::Array&lt;double, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor&gt; &gt; RowMajorArrayMap;<br><br>RowMajorArrayMap &amp;function_filter2(RowMajorArrayMap &amp;mat) {<br>    return mat;<br>}<br>```<br><br>To write the corresponding Cython definition, we need the expanded version of<br>`FlattenedMap` called `FlattenedMapWithOrder`, which allows us to specify<br>the storage order:<br><br>```<br>cdef extern from \"functions.h\":<br>    ...<br>    cdef PlainObjectBase _function_filter2 \"function_filter2\" (FlattenedMapWithOrder[Array, double, Dynamic, Dynamic, RowMajor])<br><br>def function_filter2(np.ndarray[np.float64_t, ndim=2] array):<br>    return ndarray(_function_filter2(FlattenedMapWithOrder[Array, double, Dynamic, Dynamic, RowMajor](array)))<br>```<br><br>Another alternative is to keep the array itself in RowMajor format,<br>but use different stride values for the Map type:<br><br>```c++<br>typedef Eigen::Map&lt;Eigen::ArrayXXd, Eigen::Unaligned, Eigen::Stride&lt;1, Eigen::Dynamic&gt; &gt; CustomStrideMap;<br><br>CustomStrideMap &amp;function_filter3(CustomStrideMap &amp;);<br>```<br><br>In this case, in Cython, we need to use the even more extended<br>`FlattenedMap` type called `FlattenedMapWithStride`, taking eight<br>arguments:<br><br>```<br>cdef extern from \"functions.h\":<br>    ...<br>    cdef PlainObjectBase _function_filter3 \"function_filter3\" (FlattenedMapWithStride[Array, double, Dynamic, Dynamic, ColMajor, Unaligned, _1, Dynamic])<br><br>def function_filter3(np.ndarray[np.float64_t, ndim=2] array):<br>    return ndarray(_function_filter3(FlattenedMapWithStride[Array, double, Dynamic, Dynamic, ColMajor, Unaligned, _1, Dynamic](array)))<br>```<br><br>In all three cases, the returned array will now be of the same shape<br>as the original.<br><br><br>\n          </div>"}, "last_serial": 4886021, "releases": {"1.77.1": [{"comment_text": "", "digests": {"md5": "0ed640df22df6b43822e3ed3aae81cff", "sha256": "0f7850cf86354a8be133f5431921476f91276782fd1f0b018fdd7074cc2e019d"}, "downloads": -1, "filename": "rmjarvis.eigency-1.77.1.tar.gz", "has_sig": false, "md5_digest": "0ed640df22df6b43822e3ed3aae81cff", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 852785, "upload_time": "2019-03-01T18:11:02", "upload_time_iso_8601": "2019-03-01T18:11:02.409642Z", "url": "https://files.pythonhosted.org/packages/a1/05/cdd690b63c45c5ecc9dba22b54de22cce2751ca7557f81c6a72188587a7b/rmjarvis.eigency-1.77.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0ed640df22df6b43822e3ed3aae81cff", "sha256": "0f7850cf86354a8be133f5431921476f91276782fd1f0b018fdd7074cc2e019d"}, "downloads": -1, "filename": "rmjarvis.eigency-1.77.1.tar.gz", "has_sig": false, "md5_digest": "0ed640df22df6b43822e3ed3aae81cff", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 852785, "upload_time": "2019-03-01T18:11:02", "upload_time_iso_8601": "2019-03-01T18:11:02.409642Z", "url": "https://files.pythonhosted.org/packages/a1/05/cdd690b63c45c5ecc9dba22b54de22cce2751ca7557f81c6a72188587a7b/rmjarvis.eigency-1.77.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:13 2020"}