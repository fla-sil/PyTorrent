{"info": {"author": "Kenneth S Goodman", "author_email": "kennethsgoodman@yahoo.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "\n[![Build Status](https://travis-ci.org/kennethgoodman/lazy_numpy.svg?branch=master)](https://travis-ci.org/kennethgoodman/lazy_numpy)\n[![codecov](https://codecov.io/gh/kennethgoodman/lazy_numpy/branch/master/graph/badge.svg)](https://codecov.io/gh/kennethgoodman/lazy_numpy)\n\n# lazynumpy\na lazy evaluated wrapper around numpy\n\nWhat is gained?\n\n* Chained matrix multiplication will be minimized by keeping the values of the other arrays in memory and solving the associative problem that minimizes the number of computations.\n  - only keeps one copy of each matrix [Memory optimization in progress]\n* Allow partial matrix returns withou calculating the entire matrix [In Progress]\n\n\nIf you have three matrices with dimensions as below there are two ways to do the matrix multiplication to find the answer:\n\n<a href=\"https://www.codecogs.com/eqnedit.php?latex=A_{1000\\&space;*\\1}&space;*&space;B_{1\\&space;*\\1000}&space;*&space;C_{1000\\&space;*\\1000}&space;=&space;D_{1000\\&space;*\\1000}\" target=\"_blank\"><img src=\"https://latex.codecogs.com/gif.latex?A_{1000\\&space;*\\1}&space;*&space;B_{1\\&space;*\\1000}&space;*&space;C_{1000\\&space;*\\1000}&space;=&space;D_{1000\\&space;*\\1000}\" title=\"A_{1000\\ *\\1} * B_{1\\ *\\1000} * C_{1000\\ *\\1000} = D_{1000\\ *\\1000}\" /></a>\n\nEither:\n\n<a href=\"https://www.codecogs.com/eqnedit.php?latex=[1]\\&space;\\&space;(A_{1000\\&space;*\\1}&space;*&space;B_{1\\&space;*\\1000})&space;*&space;C_{1000\\&space;*\\1000}&space;=&space;D_{1000\\&space;*\\1000}\" target=\"_blank\"><img src=\"https://latex.codecogs.com/gif.latex?[1]\\&space;\\&space;(A_{1000\\&space;*\\1}&space;*&space;B_{1\\&space;*\\1000})&space;*&space;C_{1000\\&space;*\\1000}&space;=&space;D_{1000\\&space;*\\1000}\" title=\"[1]\\ \\ (A_{1000\\ *\\1} * B_{1\\ *\\1000}) * C_{1000\\ *\\1000} = D_{1000\\ *\\1000}\" /></a>\n\nor\n\n<a href=\"https://www.codecogs.com/eqnedit.php?latex=[2]\\&space;\\&space;A_{1000\\&space;*\\1}&space;*&space;(B_{1\\&space;*\\1000}&space;*&space;C_{1000\\&space;*\\1000})&space;=&space;D_{100\\10001000}\" target=\"_blank\"><img src=\"https://latex.codecogs.com/gif.latex?[2]\\&space;\\&space;A_{1000\\&space;*\\1}&space;*&space;(B_{1\\&space;*\\1000}&space;*&space;C_{1000\\&space;*\\1000})&space;=&space;D_{100\\10001000}\" title=\"[2]\\ \\ A_{1000\\ *\\1} * (B_{1\\ *\\1000} * C_{1000\\ *\\1000}) = D_{100\\10001000}\" /></a>\n\n[1] will take `1000 * 1 * 1000` operations to calculate `A * B` plus `1000 * 1000 * 1000` operations to calculate `(A * B) * C`. The total sum to calculate `A * B * C` is equal to `1000^3 + 1000^2`.\n\n[2] will take `1 * 1000 * 1000` operations to calculate `B * C` plus `1000 * 1 * 1000` operations to calculate `A * (B * C)`. The total sum to calculate `A * B * C` is equal to `1000^2 + 1000^2` which means the optimal multiplication order will be ~500 faster.\n\nIf you run [the simple example](https://github.com/kennethgoodman/lazynumpy/blob/master/examples/simple_faster_calculation.py) you should see a significant speed up. On my computer there is a 50x speedup with only three matrix calculations.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kennethgoodman/lazynumpy", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "lazynumpy", "package_url": "https://pypi.org/project/lazynumpy/", "platform": "", "project_url": "https://pypi.org/project/lazynumpy/", "project_urls": {"Homepage": "https://github.com/kennethgoodman/lazynumpy"}, "release_url": "https://pypi.org/project/lazynumpy/0.0.1/", "requires_dist": null, "requires_python": "", "summary": "A wrapper around numpy that does lazy evaluations to optimize for chained matrix multiplication", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://travis-ci.org/kennethgoodman/lazy_numpy\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bd926dda8fec1c3ed8bc9c24a5ad9374e7aa413d/68747470733a2f2f7472617669732d63692e6f72672f6b656e6e657468676f6f646d616e2f6c617a795f6e756d70792e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/kennethgoodman/lazy_numpy\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0a87675c75ccec3d9d1e3f93fb2ccd6b83976c5c/68747470733a2f2f636f6465636f762e696f2f67682f6b656e6e657468676f6f646d616e2f6c617a795f6e756d70792f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a></p>\n<h1>lazynumpy</h1>\n<p>a lazy evaluated wrapper around numpy</p>\n<p>What is gained?</p>\n<ul>\n<li>Chained matrix multiplication will be minimized by keeping the values of the other arrays in memory and solving the associative problem that minimizes the number of computations.\n<ul>\n<li>only keeps one copy of each matrix [Memory optimization in progress]</li>\n</ul>\n</li>\n<li>Allow partial matrix returns withou calculating the entire matrix [In Progress]</li>\n</ul>\n<p>If you have three matrices with dimensions as below there are two ways to do the matrix multiplication to find the answer:</p>\n<p><a href=\"https://www.codecogs.com/eqnedit.php?latex=A_%7B1000%5C&amp;space;*%5C1%7D&amp;space;*&amp;space;B_%7B1%5C&amp;space;*%5C1000%7D&amp;space;*&amp;space;C_%7B1000%5C&amp;space;*%5C1000%7D&amp;space;=&amp;space;D_%7B1000%5C&amp;space;*%5C1000%7D\" rel=\"nofollow\"><img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2cd7d95d330b68d775015758c5a1a28188925725/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f415f7b313030305c2673706163653b2a5c317d2673706163653b2a2673706163653b425f7b315c2673706163653b2a5c313030307d2673706163653b2a2673706163653b435f7b313030305c2673706163653b2a5c313030307d2673706163653b3d2673706163653b445f7b313030305c2673706163653b2a5c313030307d\"></a></p>\n<p>Either:</p>\n<p><a href=\"https://www.codecogs.com/eqnedit.php?latex=%5B1%5D%5C&amp;space;%5C&amp;space;(A_%7B1000%5C&amp;space;*%5C1%7D&amp;space;*&amp;space;B_%7B1%5C&amp;space;*%5C1000%7D)&amp;space;*&amp;space;C_%7B1000%5C&amp;space;*%5C1000%7D&amp;space;=&amp;space;D_%7B1000%5C&amp;space;*%5C1000%7D\" rel=\"nofollow\"><img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/21f6eb79bfe7154cd292caaa5e6fa2b7ea2222c8/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f5b315d5c2673706163653b5c2673706163653b28415f7b313030305c2673706163653b2a5c317d2673706163653b2a2673706163653b425f7b315c2673706163653b2a5c313030307d292673706163653b2a2673706163653b435f7b313030305c2673706163653b2a5c313030307d2673706163653b3d2673706163653b445f7b313030305c2673706163653b2a5c313030307d\"></a></p>\n<p>or</p>\n<p><a href=\"https://www.codecogs.com/eqnedit.php?latex=%5B2%5D%5C&amp;space;%5C&amp;space;A_%7B1000%5C&amp;space;*%5C1%7D&amp;space;*&amp;space;(B_%7B1%5C&amp;space;*%5C1000%7D&amp;space;*&amp;space;C_%7B1000%5C&amp;space;*%5C1000%7D)&amp;space;=&amp;space;D_%7B100%5C10001000%7D\" rel=\"nofollow\"><img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e3fd49c168c14fe74353cff38960255a2a2297bc/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f5b325d5c2673706163653b5c2673706163653b415f7b313030305c2673706163653b2a5c317d2673706163653b2a2673706163653b28425f7b315c2673706163653b2a5c313030307d2673706163653b2a2673706163653b435f7b313030305c2673706163653b2a5c313030307d292673706163653b3d2673706163653b445f7b3130305c31303030313030307d\"></a></p>\n<p>[1] will take <code>1000 * 1 * 1000</code> operations to calculate <code>A * B</code> plus <code>1000 * 1000 * 1000</code> operations to calculate <code>(A * B) * C</code>. The total sum to calculate <code>A * B * C</code> is equal to <code>1000^3 + 1000^2</code>.</p>\n<p>[2] will take <code>1 * 1000 * 1000</code> operations to calculate <code>B * C</code> plus <code>1000 * 1 * 1000</code> operations to calculate <code>A * (B * C)</code>. The total sum to calculate <code>A * B * C</code> is equal to <code>1000^2 + 1000^2</code> which means the optimal multiplication order will be ~500 faster.</p>\n<p>If you run <a href=\"https://github.com/kennethgoodman/lazynumpy/blob/master/examples/simple_faster_calculation.py\" rel=\"nofollow\">the simple example</a> you should see a significant speed up. On my computer there is a 50x speedup with only three matrix calculations.</p>\n\n          </div>"}, "last_serial": 4723359, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "a96d43eb047bea30b9cfd5795e4416e0", "sha256": "be3bc493a48ed1e580f60ffaf1579da58f3fd27934952b80bfc053e9c6758458"}, "downloads": -1, "filename": "lazynumpy-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "a96d43eb047bea30b9cfd5795e4416e0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 8657, "upload_time": "2019-01-21T21:26:22", "upload_time_iso_8601": "2019-01-21T21:26:22.600276Z", "url": "https://files.pythonhosted.org/packages/f5/58/71b57c8d75bd4a95d882fe4e64e1d69d16aa34bd77c763e88ecd40718ae3/lazynumpy-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a9e6556176f035128ab0ad2891817698", "sha256": "02b44607b7070bb02e769962a818bbeed7c2be1b1ca333227d8a90f2c90c9f01"}, "downloads": -1, "filename": "lazynumpy-0.0.1.tar.gz", "has_sig": false, "md5_digest": "a9e6556176f035128ab0ad2891817698", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5812, "upload_time": "2019-01-21T21:26:24", "upload_time_iso_8601": "2019-01-21T21:26:24.451260Z", "url": "https://files.pythonhosted.org/packages/d6/fc/dc9cfc701faa2b080da06ba62c2fddff00e6041928de86c15fa5cb8e128d/lazynumpy-0.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a96d43eb047bea30b9cfd5795e4416e0", "sha256": "be3bc493a48ed1e580f60ffaf1579da58f3fd27934952b80bfc053e9c6758458"}, "downloads": -1, "filename": "lazynumpy-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "a96d43eb047bea30b9cfd5795e4416e0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 8657, "upload_time": "2019-01-21T21:26:22", "upload_time_iso_8601": "2019-01-21T21:26:22.600276Z", "url": "https://files.pythonhosted.org/packages/f5/58/71b57c8d75bd4a95d882fe4e64e1d69d16aa34bd77c763e88ecd40718ae3/lazynumpy-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a9e6556176f035128ab0ad2891817698", "sha256": "02b44607b7070bb02e769962a818bbeed7c2be1b1ca333227d8a90f2c90c9f01"}, "downloads": -1, "filename": "lazynumpy-0.0.1.tar.gz", "has_sig": false, "md5_digest": "a9e6556176f035128ab0ad2891817698", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5812, "upload_time": "2019-01-21T21:26:24", "upload_time_iso_8601": "2019-01-21T21:26:24.451260Z", "url": "https://files.pythonhosted.org/packages/d6/fc/dc9cfc701faa2b080da06ba62c2fddff00e6041928de86c15fa5cb8e128d/lazynumpy-0.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:47:36 2020"}