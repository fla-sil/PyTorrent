{"info": {"author": "Azavea, Inc.", "author_email": "info@azavea.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Django", "Framework :: Django :: 1.11", "Framework :: Django :: 1.8", "Framework :: Django :: 2.0", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Database", "Topic :: Database :: Database Engines/Servers", "Topic :: Database :: Front-Ends", "Topic :: Internet :: WWW/HTTP", "Topic :: Internet :: WWW/HTTP :: Dynamic Content", "Topic :: Internet :: WWW/HTTP :: WSGI", "Topic :: Internet :: WWW/HTTP :: WSGI :: Server", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: Libraries :: Application Frameworks"], "description": "# Grout \n\n[![Build Status](https://travis-ci.org/azavea/grout.svg?branch=develop)](https://travis-ci.org/azavea/grout)\n\nGrout is a flexible-schema framework for geospatial data, powered by Django and PostgreSQL. Think: NoSQL database server, but with schema validation and PostGIS support.\n\n## Contents\n\n- [**Introduction**](#introduction)\n- [**Getting started**](#getting-started)\n    - [Django](#django)\n        - [Requirements](#requirements)\n        - [Installation](#installation)\n        - [Configuration](#configuration)\n        - [More examples](#more-examples)\n    - [Non-Django applications](#non-django-applications)\n- [**Concepts**](#concepts)\n    - [Data model](#data-model)\n    - [Versioned schemas](#versioned-schemas)\n- [**API documentation**](#api-documentation)\n    - [Request and response formats](#request-and-response-formats)\n    - [Pagination](#pagination)\n    - [Resources](#resources)\n        - [RecordTypes](#recordtypes)\n        - [RecordSchemas](#recordschemas)\n        - [Records](#records)\n        - [Boundaries](#boundaries)\n        - [BoundaryPolygons](#boundarypolygons)\n- [**Developing**](#developing)\n    - [Requirements](#requirements-1)\n    - [Installation](#installation-1)\n    - [Running tests](#running-tests)\n        - [Cleaning up](#cleaning-up)\n    - [Making migrations](#making-migrations)\n- [**Resources**](#resources)\n    - [Grout suite](#grout-suite)\n    - [Historical documents](#historical-documents)\n    - [Roadmap](#roadmap)\n\n## Introduction\n\nGrout combines the flexibility of NoSQL databases with the geospatial muscle of\n[PostGIS](http://postgis.org/), allowing you to make migration-free edits to\nyour database schema while still having access to powerful geospatial queries.\n\nGrout will help you:\n\n- **Define, edit, and validate schemas** for records in your application\n- **Keep track of changes to schemas** using a built-in versioning system\n- Perform **fast filtering of user-defined fields**\n- Run **complex geospatial queries**, even on records stored with unstructured data\n\nGrout is the core library of the _Grout suite_, a toolkit for easily building\nflexible-schema apps on top of Grout. You can use Grout by installing it as an app\nin a Django project, or you can deploy it as a [standalone API\nserver](https://github.com/azavea/grout-server) with an optional [admin\nbackend](https://github.com/azavea/grout-schema-editor).\n\nReady for more? To get started using Grout with Django, see [Getting\nstarted](#getting-started). To get started using Grout with another\nstack, see [Non-Django applications](#non-django-applications). For more\nbackground on how Grout works, see [Concepts](#concepts).\n\n## Getting started\n\n### Django\n\nIf you're developing a Django project, you can install Grout as a Django app and\nuse it in your project.\n\n#### Requirements\n\nGrout supports the following versions of Python and Django:\n\n- **Python**: 2.7, 3.4, 3.5, 3.6, 3.7\n- **Django**: 1.11, 2.0\n\nCertain versions of Django only support certain versions of Python. To ensure\nthat your Python and Django versions work together, see the Django FAQ: [What\nPython version can I use with\nDjango?](https://docs.djangoproject.com/en/2.1/faq/install/#what-python-version-can-i-use-with-django)\n\n#### Installation\n\nInstall the Grout library from PyPi using `pip`.\n\n```bash\n$ pip install grout\n```\n\nTo use the development version of Grout, install it from GitHub.\n\n```bash\n$ git clone git@github.com:azavea/grout.git\n```\n\nMake sure Grout is included in `INSTALLED_APPS` in your project's `settings.py`.\n\n```python\n# settings.py\n\nINSTALLED_APPS = (\n    ...\n    'grout',\n)\n```\n\nTo use Grout as an API server, you need to incorporate the API views into your\n`urls.py` file. The following example will include Grout views under the\n`/grout` endpoint. \n\n```python\n# urls.py\n\nurlpatterns = [\n    url(r'^grout/', include('grout.urls'))\n]\n```\n\nNote that Grout automatically nests views under the `/api/` endpoint, meaning\nthat the setting above would create URLs like `hostname.com/grout/api/records`.\nIf you'd prefer Grout views to live under a top-level `/api/` endpoint (like\n`hostname.com/api/records`), you can import the Grout `urlpatterns` directly.\n\n```python\n# urls.py\n\nfrom grout import urlpatterns as grout_urlpatterns\n\nurlpatterns = grout_urlpatterns\n```\n\n#### Configuration\n\nGrout requires that the `GROUT` configuration variable be defined in your `settings.py` file\nin order to work properly. The `GROUT` variable is a dictionary of configuration\ndirectives for the app.\n\nCurrently, `'SRID'` is the only required key in the `GROUT` dictionary. `'SRID'` is an integer\ncorresponding to the [spatial reference\nidentifier](https://en.wikipedia.org/wiki/Spatial_reference_system#Identifier)\nthat Grout should use to store geometries. `4326` is the most common SRID, and\nis a good default for projects.\n\nHere's an example configuration for a development project:\n\n```python\n# settings.py\n\n# The projection for geometries stored in Grout.\nGROUT = { 'SRID': 4326 }\n```\n\nNote that Grout uses [Django REST Framework](http://www.django-rest-framework.org/)\nunder the hood to provide API endpoints. To configure DRF-specific settings like\nauthentication, see the [DRF docs](http://www.django-rest-framework.org/).\n\n#### More examples\n\n[Grout Server](https://github.com/azavea/grout-server) is a simple deployment\nof a Grout API server designed to be used as a standalone app. It also serves\nas a good example of how to incorporate Grout into a Django project, and\nincludes a preconfigured authentication module to boot. If you're\nhaving trouble installing or configuring Grout in your project, [Grout\nServer](https://github.com/azavea/grout-server)\nis a good resource for troubleshooting.\n\n### Non-Django applications\n\nIf you're not a Django developer, you can still use Grout as a standalone\nAPI server using the [Grout Server](https://github.com/azavea/grout-server)\nproject. See the [Grout Server docs](https://github.com/azavea/grout-server)\nfor details on how to install a Grout Server instance.\n\n## Concepts\n\n### Data model\n\n![The Grout data model centers around Records, each of which has an associated\nRecordSchema and RecordType.](./docs/images/grout-data-model.png).\n\nGrout is centered around _Records_, which are just **entities in your database**.\nA Record can be any type of thing or event in the world, although Grout is most\nuseful when your Records have some geospatial and temporal component.\n\nEvery Record contains a reference to a _RecordSchema_, which catalogs the\n**versioned schema** of the Record that points to it. This schema is stored as\n[JSONSchema](http://json-schema.org/), a specification for describing data models in JSON.\n\nFinally, each RecordSchema contains a reference to a _RecordType_, which is\na **simple container for organizing Records**. The RecordType exposes a way to\nreliably access a set of Records that represent the same type of thing, even if\nthey have different schemas. As we\u2019ll see shortly, RecordTypes are useful access\npoints to Records because RecordSchemas can change at any moment.\n\n### Versioned schemas\n\nIn Grout, RecordSchemas are append-only, meaning that they cannot be deleted.\nInstead, when you want to change the schema of a Record, you create a new\nRecordSchema and update the `version` attribute.\n\nFor a quick example, say that we have a RecordSchema describing data stored on\na `cat` RecordType. The RecordSchema might look something like this:\n\n```json\n{\n  \"version\": 1,\n  \"next_version\": null,\n  \"schema\": {\n    \"type\": \"object\",\n    \"title\": \"Initial Schema\",\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"properties\": {\n      \"catDetails\": {\n        \"$ref\": \"#/definitions/driverPosterDetails\"\n      },\n    \"definitions\": {\n      \"catDetails\": {\n        \"type\": \"object\",\n        \"title\": \"Cat Details\",\n        \"properties\": {\n          \"Name\": {\n            \"type\": \"string\",\n            \"fieldType\": \"text\",\n            \"isSearchable\": true,\n            \"propertyOrder\": 1\n          },\n          \"Age\": {\n            \"type\": \"integer\",\n            \"fieldType\": \"integer\",\n            \"minimum\": 0,\n            \"maximum\": 100,\n            \"isSearchable\": true,\n            \"propertyOrder\": 2\n          },\n          \"Color\": {\n            \"type\": \"string\",\n            \"fieldType\": \"text\",\n            \"isSearchable\": true,\n            \"propertyOrder\": 3\n          },\n          \"Breed\": {\n            \"type\": \"select\",\n            \"fieldType\": \"selectlist\",\n            \"enum\": [\n              \"Tabby\",\n              \"Bobtail\",\n              \"Abyssinian\"\n            ],\n            \"isSearchable\": true,\n            \"propertyOrder\": 4\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nA few things to note about this RecordSchema object:\n\n- This is the first version of the schema (its `version` is `1`)\n- There is no more recent version than this one (its `next_version` is `null`)\n- The schema definition itself is stored as a JSONSchema object on the `schema`\n  attribute\n- All of the available fields are namespaced by the `catDetails` attribute, which\n  we sometimes refer to as a _form_ or _related content_\n\nNow say we want to change the `Age` field to a `Date of Birth` field. Instead of\nchanging the schema directly, we'll create a new schema. Grout will automatically\nset `version: 2` and `next_version: null` for this updated schema:\n\n```json\n{\n  \"version\": 2,\n  \"next_version\": null,\n  \"schema\": {\n    \"type\": \"object\",\n    \"title\": \"Initial Schema\",\n    \"$schema\": \"http://json-schema.org/draft-04/schema#\",\n    \"properties\": {\n      \"catDetails\": {\n        \"$ref\": \"#/definitions/driverPosterDetails\"\n      },\n      \"definitions\": {\n        \"catDetails\": {\n          \"type\": \"object\",\n          \"title\": \"Cat Details\",\n          \"properties\": {\n            \"Name\": {\n              \"type\": \"string\",\n              \"fieldType\": \"text\",\n              \"isSearchable\": true,\n              \"propertyOrder\": 1\n            },\n            \"Age\": {\n              \"type\": \"integer\",\n              \"fieldType\": \"integer\",\n              \"minimum\": 0,\n              \"maximum\": 100,\n              \"isSearchable\": true,\n              \"propertyOrder\": 2\n            },\n            \"Date of Birth\": {\n              \"type\": \"string\",\n              \"format\": \"datetime\",\n              \"fieldType\": \"text\",\n              \"isSearchable\": true,\n              \"propertyOrder\": 3\n            },\n            \"Color\": {\n              \"type\": \"string\",\n              \"fieldType\": \"text\",\n              \"isSearchable\": true,\n              \"propertyOrder\": 4\n            },\n            \"Breed\": {\n              \"type\": \"select\",\n              \"fieldType\": \"selectlist\",\n              \"enum\": [\n                \"Tabby\",\n                \"Bobtail\",\n                \"Abyssinian\"\n              ],\n              \"isSearchable\": true,\n              \"propertyOrder\": 5\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\nIn addition, Grout will update the initial schema to set `next_version: 2`:\n\n```\n{\n  \"version\": 1,\n  \"next_version\": 2,\n  \"schema\": {\n    ...\n  }\n}\n```\n\nNow, when a user searches for Records in the `cat` RecordType, Grout can find\nthe most recent schema by looking for the RecordSchema where `next_version: null`.\nThis preserves a full audit trail of the RecordSchema, allowing us to\ninspect how the schema has changed over time.\n\nFor a closer look at the Grout data model, see the [`models.py` file in the Grout\nlibrary](https://github.com/azavea/grout/blob/develop/grout/models.py).\n\n## API documentation\n\n### Request and response formats\n\nCommunication with the API generally follows the principles of RESTful API design.\nAPI paths correspond to resources, `GET` requests are used to retrieve objects, `POST`\nrequests are used to create new objects, and `PATCH` requests are used to update\nexisting objects. This pattern is followed in nearly all cases; any exceptions\nwill be noted in the documentation.\n\nResponses from the API are exclusively JSON.\n\nEndpoint behavior can be configured using query parameters for `GET` requests,\nwhile `POST` requests require a payload in JSON format.\n\n### Pagination\n\nAll API endpoints that return lists of resources are paginated. The pagination takes the following format:\n\n```\n{\n    \"count\": 57624,\n    \"next\": \"http://localhost:8000/api/records/?offset=20\",\n    \"previous\": \"http://localhost:7000/api/records/\",\n    \"results\": [\n        ...\n    ]\n}\n```\n\nIn a real response, the domain and port for the `next` and `previous` fields\nwill be that of the server responding to the request.\n\nThis format applies to the API endpoints below and will not be repeated in the\ndocumentation for each individual endpoint.\n\n### Resources\n\n#### RecordTypes\n\nBecause the RecordSchema for a set of Records can change at any time, the RecordType API\nendpoint provides a consistent access point for retrieving a set of Records.\nUse the RecordType endpoints to discover the most recent RecordSchema for the Records\nyou are interested in before performing further queries.\n\nPaths:\n\n* List: `/api/recordtypes/`\n* Detail: `/api/recordtypes/{uuid}/`\n\nQuery parameters:\n\n* `active`: Boolean\n    * Filter for only RecordTypes with an `active` value of True.\n      Generally, you will want to limit yourself to active RecordTypes.\n\nResults fields:\n\n| Field name | Type | Description |\n| ---------- | ---- | ----------- |\n| `uuid` | UUID | Unique identifier for this RecordType. |\n| `current_schema` | UUID | The most recent RecordSchema for this RecordType. |\n| `created` | Timestamp | The date and time when this RecordType was created. |\n| `modified` | Timestamp | The date and time when this RecordType was last modified. |\n| `label` | String | The name of this RecordType. |\n| `plural_label` | String | The plural version of the name of this RecordType. |\n| `description` | String | A short description of this RecordType. |\n| `active` | Boolean | Whether or not this RecordType is active. This field allows RecordTypes to be deactivated rather than deleted. |\n| `geometry_type` | String | The geometry type supported for Records of this RecordType. One of `point`, `polygon`, `multipolygon`, `linestring`, or `none`. | \n| `temporal` | Boolean | Whether or not Records of this RecordType should store datetime data in the `occurred_from` and `occurred_to` fields. |\n\n#### RecordSchemas\n\nThe RecordSchema API endpoint can help you discover the fields that\nshould be available on a given Record. This can be useful for automatically generating filters\nbased on a Record's fields, or for running custom validation on a Record's\nschema.\n\nPaths:\n\n* List: `/api/recordschemas/`\n* Detail: `/api/recordschemas/{uuid}/`\n\nResults fields:\n\n| Field name | Type | Description |\n| ---------- | ---- | ----------- |\n| `uuid` | UUID | Unique identifier for this RecordSchema. |\n| `created` | Timestamp | The date and time when this RecordSchema was created. |\n| `modified` | Timestamp | The date and time when this RecordSchema was last modified. |\n| `version` | Integer | A sequential number indicating what version of the RecordType's schema this is. Starts at 1. |\n| `next_version` | UUID | Unique identifier of the RecordSchema with the next-highest version number for this schema's RecordType. If this is the most recent version of the schema, this field will be `null`. |\n| `record_type` | UUID | Unique identifier of the RecordType that this RecordSchema refers to. |\n| `schema` | Object | A [JSONSchema](http://json-schema.org/) object that should validate Records that refer to this RecordSchema. |\n\n#### Records\n\nRecords are the heart of a Grout project: the entities in your database. The\nRecords API endpoint provides a way of retrieving these objects for analysis\nor display to an end user.\n\nPaths:\n\n* List: `/api/records/`\n* Detail: `/api/records/{uuid}/`\n\nQuery Parameters:\n\n* `archived`: Boolean\n    * Records can be \"archived\" to denote that they are no longer current, as an\n      alternative to deletion. Pass `True` (case-sensitive) to this parameter to return archived\n      Records only, and pass `False` (case-sensitive) to return current Records only.\n      Omitting this parameter returns both types.\n\n* `details_only`: Boolean\n    * In the [Grout Schema Editor](https://github.com/azavea/grout-schema-editor),\n      every Record is automatically generated with a `<record_type>Details`\n      form which is intended to contain a basic summary of information about the Record.\n      Passing `True` (case-sensitive) to this parameter will omit any other\n      forms which may exist on the Record. This is useful for limiting the size\n      of the payload returned when only a summary view is needed.\n\n* `record_type`: UUID\n    * Limit the response to Records matching the passed RecordType UUID.\n      This is optional in theory, but for most applications it is a good idea\n      to include this parameter by default. It is considered rare that it will\n      be useful to return two different types of Records in a single request.\n      It is usually a better idea to make a separate request for each RecordType.\n\n* `jsonb`: Object\n    * Query the data fields of the object and filter on the result.\n    * Keys in this object mimic the search paths to filter on a particular object\n      field. However, in place of values, a filter rule definition is used. Example:\n`{ \"accidentDetails\": {\n    \"Main+cause\": {\n        \"_rule_type\": \"containment\",\n        \"contains\": [\n            \"Vehicle+defect\",\n            \"Road+defect\",\n            [\"Vehicle+defect\"],\n            [\"Road+defect\"]\n        ]\n    },\n    \"Num+driver+casualties\": {\n        \"_rule_type\": \"intrange\",\n        \"min\": 1,\n        \"max\": 3\n    }\n}}`. This query defines the following two filters:\n        * `accidentDetails -> \"Main cause\" == \"Vehicle defect\" OR accidentDetails -> \"Main cause\" == \"Road defect\"`\n        * `accidentDetails -> \"Num driver casualties\" >= 1 AND accidentDetails -> \"Num driver casualties\" <= 3`\n    * There is a third filter rule type available: `containment_multiple`.\n      This is used when searching a form of which there can be several on a single Record.\n      Here's an example:\n`{\"person\":{\"Injury\":{\"_rule_type\":\"containment_multiple\",\"contains\":[\"Fatal\"]}}}`\n\n* `occurred_min`: Timestamp\n    * Filter to Records occurring after this date.\n\n* `occurred_max`: Timestamp\n    * Filter to Records occurring before this date.\n\n* `polygon_id`: UUID\n    * Filter to Records which occurred within the Polygon identified by the\n      UUID. The value must refer to a [Boundary](#boundaries) in the database.\n\n* `polygon`: GeoJSON\n    * Filter to Records which occurred within the bounds of a valid GeoJSON\n      object.\n\nResults fields:\n\n| Field name | Type | Description |\n| ---------- | ---- | ----------- |\n| `uuid` | UUID | Unique identifier for this Record. |\n| `created` | Timestamp | The date and time when this Record was created. |\n| `modified` | Timestamp | The date and time when this Record was last modified. |\n| `occurred_from` | Timestamp | The earliest time at which this Record might have occurred. |\n| `occurred_to` | Timestamp | The latest time at which this Record might have occurred. Note that this field is mandatory for temporal Records: if a Record only occurred at one moment in time, the `occurred_from` field and the `occurred_to` field will have the same value.  |\n| `geom` | GeoJSON | Geometry representing the location associated with this Record. |\n| `location_text` | String | A description of the location where this Record occurred, typically an address. |\n| `archived` | Boolean | A way of hiding records without deleting them completely. `True` indicates the Record is archived. |\n| `schema` | UUID | References the RecordSchema which was used to create this Record. |\n| `data` | Object | A JSON object representing the flexible data fields associated with this Record. It is always true that the object stored in `data` conforms to the RecordSchema referenced by the `schema` UUID. |\n\n#### Boundaries\n\nBoundaries provide a quick way of storing Shapefile data in Grout without\nhaving to create separate RecordTypes. Using a Boundary, you can upload\nand retrieve Shapefile data for things like administrative borders and focus\nareas in your application.\n\nPaths:\n\n* List: `/api/boundaries/`\n* Detail: `/api/boundaries/{uuid}/`\n\nResults fields:\n\n| Field name | Type | Description |\n| ---------- | ---- | ----------- |\n| `uuid` | UUID | Unique identifier for this Boundary. |\n| `created` | Timestamp | The date and time when this Boundary was created. |\n| `modified` | Timestamp | The date and time when this Boundary was last modified. |\n| `label` | String | Label of this Boundary, for display. |\n| `color` | String | Color preference to use for rendering this Boundary. |\n| `display_field` | String | Which field of the imported Shapefile to use for display. |\n| `data_fields` | Array | List of the names of the fields contained in the imported Shapefile. |\n| `errors` | Array | A possible list of errors raised when importing the Shapefile. |\n| `status` | String | Import status of the Shapefile. |\n| `source_file` | String | URI of the Shapefile that was originally used to generate this Boundary. |\n\nNotes:\n\nCreating a new Boundary and its [BoundaryPolygon](#boundarypolygon) correctly is a two-step process.\n\n1. `POST` to `/api/boundaries/` with a zipped Shapefile attached; you will need\n   to include the label as form data. You should receive a 201 response which\n   contains a fully-fledged Boundary object, including a list of available\n   data fields in `data_fields`.\n\n2. The response from the previous request will have a blank `display_field`.\n   Select one of the fields in `data_fields` and make a `PATCH` request to\n   `/api/boundaries/{uuid}/` with that value in `display_field`.\n   You are now ready to use this Boundary and its associated BoundaryPolygon.\n\n#### BoundaryPolygons\n\nBoundaryPolygons store the Shapefile data associated with a [Boundary](#boundaries),\nincluding geometry and metadata.\n\nPaths:\n\n* List: `/api/boundarypolygons/`\n* Detail: `/api/boundarypolygons/{uuid}/`\n\nQuery Parameters:\n\n* `boundary`: UUID\n    * Filter to Polygons associated with this parent Boundary.\n\n* `nogeom`: Boolean\n    * When passed with any value, causes the geometry field to be replaced with\n      a bbox field. This reduces the response size and is sufficient for many purposes.\n\nResults fields:\n\n| Field name | Type | Description |\n| ---------- | ---- | ----------- |\n| `uuid` | UUID | Unique identifier for this BoundaryPolygon. |\n| `created` | Timestamp | The date and time when this BoundaryPolygon was created. |\n| `modified` | Timestamp | The date and time when this BoundaryPolygon was last modified. |\n| `data` | Object | Each key in this Object will correspond to one of the `data_fields` in the parent Boundary, and will store the value for that field for this Polygon. |\n| `boundary` | UUID | Unique identifier of the parent Boundary for this BoundaryPolygon. |\n| `bbox` | Array | Minimum bounding box containing this Polygon's geometry, as an Array of lat/lon points. This field is optional -- see the `nogeom` parameter above for more details. |\n| `geometry` | GeoJSON | GeoJSON representation of this Polygon. This field is optional -- see the `nogeom` parameter above for more details. |\n\n## Developing\n\nThese instructions will help you set up a development version of Grout and\ncontribute changes back upstream.\n\n### Requirements\n\nThe Grout development environment is containerized with Docker to ensure similar\nenvironments across platforms. In order to develop with Docker, you need the\nfollowing dependencies:\n\n- [Docker CE Engine](https://docs.docker.com/install/) >= 1.13.0 (must be\n  compatible with [Docker Compose file v3\n  syntax](https://docs.docker.com/compose/compose-file/#compose-and-docker-compatibility-matrix))\n- [Docker Compose](https://docs.docker.com/compose/install/)\n\n### Installation\n\nClone the repo with git.\n\n```bash\n$ git clone git@github.com:azavea/grout.git\n$ cd grout\n```\n\nRun the `update` script to set up your development environment.\n\n```bash\n$ ./scripts/update\n```\n\n### Running tests\n\nOnce your environment is up to date, you can use the `scripts/test` script to\nrun the Grout unit test suite.\n\n```bash\n$ ./scripts/test\n```\n\nThis command will run a matrix of tests for **every supported version of Python and\nDjango** in the project. If you're developing locally and you just want to run\na subset of the tests, you can specify the version of Python\nthat you want to use to run tests: \n\n```bash\n# Only run tests for Python 2.7 (this will test Django 1.8).\n$ ./scripts/test app py27\n\n# Only run tests for Python 3.7 (this will test Django 2.0).\n$ ./scripts/test app py37\n```\n\nFor a list of available Python versions, see the `envlist` directive in the [`tox.ini`\nfile](./tox.ini). \n\n#### Cleaning up\n\nTox creates a new virtualenv for every combination of Python and Django versions\nused by the test suite. In order to clean up stopped containers and\nremove these virtualenvs, use the `clean` script:\n\n```bash\n$ ./scripts/clean\n```\n\nNote that `clean` will remove **all dangling images, stopped containers, and \nunused volumes** on your machine. If you don't want to remove these artifacts,\n[view the `clean` script](./scripts/clean) and run only the command that\ninterests you.\n\n### Making migrations\n\nIf you edit the data model in `grout/models.py`, you'll need to create a new\nmigration for the app. You can use the `django-admin` script in the `scripts`\ndirectory to automatically generate the migration:\n\n```bash\n$ ./scripts/django-admin makemigrations\n```\n\nMake sure to register the new migrations file with Git:\n\n```bash\n$ git add grout/migrations\n```\n\n## Resources \n\nThe following resources provide helpful tips for deploying and using Grout.\n\n### Grout suite\n\n- [Grout Server](https://github.com/azavea/grout-server): An easily-deployable\n  standalone instance of a Grout API server.\n- [Grout Schema Editor](https://github.com/azavea/grout-schema-editor): A\n  purely static app that can read and write flexible schemas from a Grout API.\n- [Demo app](https://github.com/jeancochrane/philly-fliers/): A demo project\n  providing an example of incorporating the Grout suite into a Vue.js app.\n\n### Historical documents\n\n- [Concept map](./docs/concept-map.md): An early description of the Grout suite\n  (formerly known as Ashlar) from an Open Source Fellow working on it during the summer\n  of 2018. Describes the conceptual architecture of the suite, and summarizes\n  ideas for future directions.\n\n- [Renaming the package to Grout](./docs/rename-package.md): An ADR documenting\n  the decision to rename the package from \"Ashlar\" to \"Grout\".\n\n- [Evaluating Record-to-Record references](./docs/foreign-keys.md): An ADR\n  documenting the reasons and requirements for implementing a Record-to-Record\n  foreign key field. See also [the pull request\n  thread](https://github.com/azavea/grout-2018-fellowship/pull/34) for further\n  discussion.\n\n- [Evaluating alternate backends](./docs/nosql-backends.md): An ADR presenting\n  research into possible NoSQL backends and service providers for Grout.\n\n- [Grout 2018 Fellowship](https://github.com/azavea/grout-2018-fellowship): A\n  project management repo for working on Grout during Azavea's Summer 2018\n  [Open Source Fellowship](https://fellowship.azavea.com). Useful for\n  documentation around the motivation and trajectory of the project.\n\n### Roadmap\n\nWant to know where Grout is headed? See the [Roadmap](./docs/roadmap.md) to\nget a picture of future development.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/azavea/grout", "keywords": "gis jsonschema", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "grout", "package_url": "https://pypi.org/project/grout/", "platform": "", "project_url": "https://pypi.org/project/grout/", "project_urls": {"Homepage": "https://github.com/azavea/grout"}, "release_url": "https://pypi.org/project/grout/2.0.1/", "requires_dist": null, "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*", "summary": "A flexible schema framework for geospatial data.", "version": "2.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Grout</h1>\n<p><a href=\"https://travis-ci.org/azavea/grout\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cc16a486a04d7876715f1b1ba90335fb70c92266/68747470733a2f2f7472617669732d63692e6f72672f617a617665612f67726f75742e7376673f6272616e63683d646576656c6f70\"></a></p>\n<p>Grout is a flexible-schema framework for geospatial data, powered by Django and PostgreSQL. Think: NoSQL database server, but with schema validation and PostGIS support.</p>\n<h2>Contents</h2>\n<ul>\n<li><a href=\"#introduction\" rel=\"nofollow\"><strong>Introduction</strong></a></li>\n<li><a href=\"#getting-started\" rel=\"nofollow\"><strong>Getting started</strong></a>\n<ul>\n<li><a href=\"#django\" rel=\"nofollow\">Django</a>\n<ul>\n<li><a href=\"#requirements\" rel=\"nofollow\">Requirements</a></li>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#configuration\" rel=\"nofollow\">Configuration</a></li>\n<li><a href=\"#more-examples\" rel=\"nofollow\">More examples</a></li>\n</ul>\n</li>\n<li><a href=\"#non-django-applications\" rel=\"nofollow\">Non-Django applications</a></li>\n</ul>\n</li>\n<li><a href=\"#concepts\" rel=\"nofollow\"><strong>Concepts</strong></a>\n<ul>\n<li><a href=\"#data-model\" rel=\"nofollow\">Data model</a></li>\n<li><a href=\"#versioned-schemas\" rel=\"nofollow\">Versioned schemas</a></li>\n</ul>\n</li>\n<li><a href=\"#api-documentation\" rel=\"nofollow\"><strong>API documentation</strong></a>\n<ul>\n<li><a href=\"#request-and-response-formats\" rel=\"nofollow\">Request and response formats</a></li>\n<li><a href=\"#pagination\" rel=\"nofollow\">Pagination</a></li>\n<li><a href=\"#resources\" rel=\"nofollow\">Resources</a>\n<ul>\n<li><a href=\"#recordtypes\" rel=\"nofollow\">RecordTypes</a></li>\n<li><a href=\"#recordschemas\" rel=\"nofollow\">RecordSchemas</a></li>\n<li><a href=\"#records\" rel=\"nofollow\">Records</a></li>\n<li><a href=\"#boundaries\" rel=\"nofollow\">Boundaries</a></li>\n<li><a href=\"#boundarypolygons\" rel=\"nofollow\">BoundaryPolygons</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#developing\" rel=\"nofollow\"><strong>Developing</strong></a>\n<ul>\n<li><a href=\"#requirements-1\" rel=\"nofollow\">Requirements</a></li>\n<li><a href=\"#installation-1\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#running-tests\" rel=\"nofollow\">Running tests</a>\n<ul>\n<li><a href=\"#cleaning-up\" rel=\"nofollow\">Cleaning up</a></li>\n</ul>\n</li>\n<li><a href=\"#making-migrations\" rel=\"nofollow\">Making migrations</a></li>\n</ul>\n</li>\n<li><a href=\"#resources\" rel=\"nofollow\"><strong>Resources</strong></a>\n<ul>\n<li><a href=\"#grout-suite\" rel=\"nofollow\">Grout suite</a></li>\n<li><a href=\"#historical-documents\" rel=\"nofollow\">Historical documents</a></li>\n<li><a href=\"#roadmap\" rel=\"nofollow\">Roadmap</a></li>\n</ul>\n</li>\n</ul>\n<h2>Introduction</h2>\n<p>Grout combines the flexibility of NoSQL databases with the geospatial muscle of\n<a href=\"http://postgis.org/\" rel=\"nofollow\">PostGIS</a>, allowing you to make migration-free edits to\nyour database schema while still having access to powerful geospatial queries.</p>\n<p>Grout will help you:</p>\n<ul>\n<li><strong>Define, edit, and validate schemas</strong> for records in your application</li>\n<li><strong>Keep track of changes to schemas</strong> using a built-in versioning system</li>\n<li>Perform <strong>fast filtering of user-defined fields</strong></li>\n<li>Run <strong>complex geospatial queries</strong>, even on records stored with unstructured data</li>\n</ul>\n<p>Grout is the core library of the <em>Grout suite</em>, a toolkit for easily building\nflexible-schema apps on top of Grout. You can use Grout by installing it as an app\nin a Django project, or you can deploy it as a <a href=\"https://github.com/azavea/grout-server\" rel=\"nofollow\">standalone API\nserver</a> with an optional <a href=\"https://github.com/azavea/grout-schema-editor\" rel=\"nofollow\">admin\nbackend</a>.</p>\n<p>Ready for more? To get started using Grout with Django, see <a href=\"#getting-started\" rel=\"nofollow\">Getting\nstarted</a>. To get started using Grout with another\nstack, see <a href=\"#non-django-applications\" rel=\"nofollow\">Non-Django applications</a>. For more\nbackground on how Grout works, see <a href=\"#concepts\" rel=\"nofollow\">Concepts</a>.</p>\n<h2>Getting started</h2>\n<h3>Django</h3>\n<p>If you're developing a Django project, you can install Grout as a Django app and\nuse it in your project.</p>\n<h4>Requirements</h4>\n<p>Grout supports the following versions of Python and Django:</p>\n<ul>\n<li><strong>Python</strong>: 2.7, 3.4, 3.5, 3.6, 3.7</li>\n<li><strong>Django</strong>: 1.11, 2.0</li>\n</ul>\n<p>Certain versions of Django only support certain versions of Python. To ensure\nthat your Python and Django versions work together, see the Django FAQ: <a href=\"https://docs.djangoproject.com/en/2.1/faq/install/#what-python-version-can-i-use-with-django\" rel=\"nofollow\">What\nPython version can I use with\nDjango?</a></p>\n<h4>Installation</h4>\n<p>Install the Grout library from PyPi using <code>pip</code>.</p>\n<pre>$ pip install grout\n</pre>\n<p>To use the development version of Grout, install it from GitHub.</p>\n<pre>$ git clone git@github.com:azavea/grout.git\n</pre>\n<p>Make sure Grout is included in <code>INSTALLED_APPS</code> in your project's <code>settings.py</code>.</p>\n<pre><span class=\"c1\"># settings.py</span>\n\n<span class=\"n\">INSTALLED_APPS</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n    <span class=\"o\">...</span>\n    <span class=\"s1\">'grout'</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n</pre>\n<p>To use Grout as an API server, you need to incorporate the API views into your\n<code>urls.py</code> file. The following example will include Grout views under the\n<code>/grout</code> endpoint.</p>\n<pre><span class=\"c1\"># urls.py</span>\n\n<span class=\"n\">urlpatterns</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"n\">url</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'^grout/'</span><span class=\"p\">,</span> <span class=\"n\">include</span><span class=\"p\">(</span><span class=\"s1\">'grout.urls'</span><span class=\"p\">))</span>\n<span class=\"p\">]</span>\n</pre>\n<p>Note that Grout automatically nests views under the <code>/api/</code> endpoint, meaning\nthat the setting above would create URLs like <code>hostname.com/grout/api/records</code>.\nIf you'd prefer Grout views to live under a top-level <code>/api/</code> endpoint (like\n<code>hostname.com/api/records</code>), you can import the Grout <code>urlpatterns</code> directly.</p>\n<pre><span class=\"c1\"># urls.py</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">grout</span> <span class=\"kn\">import</span> <span class=\"n\">urlpatterns</span> <span class=\"k\">as</span> <span class=\"n\">grout_urlpatterns</span>\n\n<span class=\"n\">urlpatterns</span> <span class=\"o\">=</span> <span class=\"n\">grout_urlpatterns</span>\n</pre>\n<h4>Configuration</h4>\n<p>Grout requires that the <code>GROUT</code> configuration variable be defined in your <code>settings.py</code> file\nin order to work properly. The <code>GROUT</code> variable is a dictionary of configuration\ndirectives for the app.</p>\n<p>Currently, <code>'SRID'</code> is the only required key in the <code>GROUT</code> dictionary. <code>'SRID'</code> is an integer\ncorresponding to the <a href=\"https://en.wikipedia.org/wiki/Spatial_reference_system#Identifier\" rel=\"nofollow\">spatial reference\nidentifier</a>\nthat Grout should use to store geometries. <code>4326</code> is the most common SRID, and\nis a good default for projects.</p>\n<p>Here's an example configuration for a development project:</p>\n<pre><span class=\"c1\"># settings.py</span>\n\n<span class=\"c1\"># The projection for geometries stored in Grout.</span>\n<span class=\"n\">GROUT</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"s1\">'SRID'</span><span class=\"p\">:</span> <span class=\"mi\">4326</span> <span class=\"p\">}</span>\n</pre>\n<p>Note that Grout uses <a href=\"http://www.django-rest-framework.org/\" rel=\"nofollow\">Django REST Framework</a>\nunder the hood to provide API endpoints. To configure DRF-specific settings like\nauthentication, see the <a href=\"http://www.django-rest-framework.org/\" rel=\"nofollow\">DRF docs</a>.</p>\n<h4>More examples</h4>\n<p><a href=\"https://github.com/azavea/grout-server\" rel=\"nofollow\">Grout Server</a> is a simple deployment\nof a Grout API server designed to be used as a standalone app. It also serves\nas a good example of how to incorporate Grout into a Django project, and\nincludes a preconfigured authentication module to boot. If you're\nhaving trouble installing or configuring Grout in your project, <a href=\"https://github.com/azavea/grout-server\" rel=\"nofollow\">Grout\nServer</a>\nis a good resource for troubleshooting.</p>\n<h3>Non-Django applications</h3>\n<p>If you're not a Django developer, you can still use Grout as a standalone\nAPI server using the <a href=\"https://github.com/azavea/grout-server\" rel=\"nofollow\">Grout Server</a>\nproject. See the <a href=\"https://github.com/azavea/grout-server\" rel=\"nofollow\">Grout Server docs</a>\nfor details on how to install a Grout Server instance.</p>\n<h2>Concepts</h2>\n<h3>Data model</h3>\n<p><img alt=\"The Grout data model centers around Records, each of which has an associated RecordSchema and RecordType.\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bd7ecaf7953e19b3f6c4538e6af5fa2d1c85c005/2e2f646f63732f696d616765732f67726f75742d646174612d6d6f64656c2e706e67\">.</p>\n<p>Grout is centered around <em>Records</em>, which are just <strong>entities in your database</strong>.\nA Record can be any type of thing or event in the world, although Grout is most\nuseful when your Records have some geospatial and temporal component.</p>\n<p>Every Record contains a reference to a <em>RecordSchema</em>, which catalogs the\n<strong>versioned schema</strong> of the Record that points to it. This schema is stored as\n<a href=\"http://json-schema.org/\" rel=\"nofollow\">JSONSchema</a>, a specification for describing data models in JSON.</p>\n<p>Finally, each RecordSchema contains a reference to a <em>RecordType</em>, which is\na <strong>simple container for organizing Records</strong>. The RecordType exposes a way to\nreliably access a set of Records that represent the same type of thing, even if\nthey have different schemas. As we\u2019ll see shortly, RecordTypes are useful access\npoints to Records because RecordSchemas can change at any moment.</p>\n<h3>Versioned schemas</h3>\n<p>In Grout, RecordSchemas are append-only, meaning that they cannot be deleted.\nInstead, when you want to change the schema of a Record, you create a new\nRecordSchema and update the <code>version</code> attribute.</p>\n<p>For a quick example, say that we have a RecordSchema describing data stored on\na <code>cat</code> RecordType. The RecordSchema might look something like this:</p>\n<pre><span class=\"p\">{</span>\n  <span class=\"nt\">\"version\"</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n  <span class=\"nt\">\"next_version\"</span><span class=\"p\">:</span> <span class=\"kc\">null</span><span class=\"p\">,</span>\n  <span class=\"nt\">\"schema\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"object\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"title\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Initial Schema\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"$schema\"</span><span class=\"p\">:</span> <span class=\"s2\">\"http://json-schema.org/draft-04/schema#\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"properties\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n      <span class=\"nt\">\"catDetails\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">\"$ref\"</span><span class=\"p\">:</span> <span class=\"s2\">\"#/definitions/driverPosterDetails\"</span>\n      <span class=\"p\">},</span>\n    <span class=\"nt\">\"definitions\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n      <span class=\"nt\">\"catDetails\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"object\"</span><span class=\"p\">,</span>\n        <span class=\"nt\">\"title\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Cat Details\"</span><span class=\"p\">,</span>\n        <span class=\"nt\">\"properties\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n          <span class=\"nt\">\"Name\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"string\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"fieldType\"</span><span class=\"p\">:</span> <span class=\"s2\">\"text\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"isSearchable\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"propertyOrder\"</span><span class=\"p\">:</span> <span class=\"mi\">1</span>\n          <span class=\"p\">},</span>\n          <span class=\"nt\">\"Age\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"integer\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"fieldType\"</span><span class=\"p\">:</span> <span class=\"s2\">\"integer\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"minimum\"</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"maximum\"</span><span class=\"p\">:</span> <span class=\"mi\">100</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"isSearchable\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"propertyOrder\"</span><span class=\"p\">:</span> <span class=\"mi\">2</span>\n          <span class=\"p\">},</span>\n          <span class=\"nt\">\"Color\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"string\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"fieldType\"</span><span class=\"p\">:</span> <span class=\"s2\">\"text\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"isSearchable\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"propertyOrder\"</span><span class=\"p\">:</span> <span class=\"mi\">3</span>\n          <span class=\"p\">},</span>\n          <span class=\"nt\">\"Breed\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"select\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"fieldType\"</span><span class=\"p\">:</span> <span class=\"s2\">\"selectlist\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"enum\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n              <span class=\"s2\">\"Tabby\"</span><span class=\"p\">,</span>\n              <span class=\"s2\">\"Bobtail\"</span><span class=\"p\">,</span>\n              <span class=\"s2\">\"Abyssinian\"</span>\n            <span class=\"p\">],</span>\n            <span class=\"nt\">\"isSearchable\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"propertyOrder\"</span><span class=\"p\">:</span> <span class=\"mi\">4</span>\n          <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n<p>A few things to note about this RecordSchema object:</p>\n<ul>\n<li>This is the first version of the schema (its <code>version</code> is <code>1</code>)</li>\n<li>There is no more recent version than this one (its <code>next_version</code> is <code>null</code>)</li>\n<li>The schema definition itself is stored as a JSONSchema object on the <code>schema</code>\nattribute</li>\n<li>All of the available fields are namespaced by the <code>catDetails</code> attribute, which\nwe sometimes refer to as a <em>form</em> or <em>related content</em></li>\n</ul>\n<p>Now say we want to change the <code>Age</code> field to a <code>Date of Birth</code> field. Instead of\nchanging the schema directly, we'll create a new schema. Grout will automatically\nset <code>version: 2</code> and <code>next_version: null</code> for this updated schema:</p>\n<pre><span class=\"p\">{</span>\n  <span class=\"nt\">\"version\"</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span>\n  <span class=\"nt\">\"next_version\"</span><span class=\"p\">:</span> <span class=\"kc\">null</span><span class=\"p\">,</span>\n  <span class=\"nt\">\"schema\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"object\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"title\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Initial Schema\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"$schema\"</span><span class=\"p\">:</span> <span class=\"s2\">\"http://json-schema.org/draft-04/schema#\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"properties\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n      <span class=\"nt\">\"catDetails\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">\"$ref\"</span><span class=\"p\">:</span> <span class=\"s2\">\"#/definitions/driverPosterDetails\"</span>\n      <span class=\"p\">},</span>\n      <span class=\"nt\">\"definitions\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">\"catDetails\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n          <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"object\"</span><span class=\"p\">,</span>\n          <span class=\"nt\">\"title\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Cat Details\"</span><span class=\"p\">,</span>\n          <span class=\"nt\">\"properties\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"nt\">\"Name\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n              <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"string\"</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"fieldType\"</span><span class=\"p\">:</span> <span class=\"s2\">\"text\"</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"isSearchable\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"propertyOrder\"</span><span class=\"p\">:</span> <span class=\"mi\">1</span>\n            <span class=\"p\">},</span>\n            <span class=\"nt\">\"Age\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n              <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"integer\"</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"fieldType\"</span><span class=\"p\">:</span> <span class=\"s2\">\"integer\"</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"minimum\"</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"maximum\"</span><span class=\"p\">:</span> <span class=\"mi\">100</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"isSearchable\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"propertyOrder\"</span><span class=\"p\">:</span> <span class=\"mi\">2</span>\n            <span class=\"p\">},</span>\n            <span class=\"nt\">\"Date of Birth\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n              <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"string\"</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"format\"</span><span class=\"p\">:</span> <span class=\"s2\">\"datetime\"</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"fieldType\"</span><span class=\"p\">:</span> <span class=\"s2\">\"text\"</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"isSearchable\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"propertyOrder\"</span><span class=\"p\">:</span> <span class=\"mi\">3</span>\n            <span class=\"p\">},</span>\n            <span class=\"nt\">\"Color\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n              <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"string\"</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"fieldType\"</span><span class=\"p\">:</span> <span class=\"s2\">\"text\"</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"isSearchable\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"propertyOrder\"</span><span class=\"p\">:</span> <span class=\"mi\">4</span>\n            <span class=\"p\">},</span>\n            <span class=\"nt\">\"Breed\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n              <span class=\"nt\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"select\"</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"fieldType\"</span><span class=\"p\">:</span> <span class=\"s2\">\"selectlist\"</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"enum\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n                <span class=\"s2\">\"Tabby\"</span><span class=\"p\">,</span>\n                <span class=\"s2\">\"Bobtail\"</span><span class=\"p\">,</span>\n                <span class=\"s2\">\"Abyssinian\"</span>\n              <span class=\"p\">],</span>\n              <span class=\"nt\">\"isSearchable\"</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n              <span class=\"nt\">\"propertyOrder\"</span><span class=\"p\">:</span> <span class=\"mi\">5</span>\n            <span class=\"p\">}</span>\n          <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n<p>In addition, Grout will update the initial schema to set <code>next_version: 2</code>:</p>\n<pre><code>{\n  \"version\": 1,\n  \"next_version\": 2,\n  \"schema\": {\n    ...\n  }\n}\n</code></pre>\n<p>Now, when a user searches for Records in the <code>cat</code> RecordType, Grout can find\nthe most recent schema by looking for the RecordSchema where <code>next_version: null</code>.\nThis preserves a full audit trail of the RecordSchema, allowing us to\ninspect how the schema has changed over time.</p>\n<p>For a closer look at the Grout data model, see the <a href=\"https://github.com/azavea/grout/blob/develop/grout/models.py\" rel=\"nofollow\"><code>models.py</code> file in the Grout\nlibrary</a>.</p>\n<h2>API documentation</h2>\n<h3>Request and response formats</h3>\n<p>Communication with the API generally follows the principles of RESTful API design.\nAPI paths correspond to resources, <code>GET</code> requests are used to retrieve objects, <code>POST</code>\nrequests are used to create new objects, and <code>PATCH</code> requests are used to update\nexisting objects. This pattern is followed in nearly all cases; any exceptions\nwill be noted in the documentation.</p>\n<p>Responses from the API are exclusively JSON.</p>\n<p>Endpoint behavior can be configured using query parameters for <code>GET</code> requests,\nwhile <code>POST</code> requests require a payload in JSON format.</p>\n<h3>Pagination</h3>\n<p>All API endpoints that return lists of resources are paginated. The pagination takes the following format:</p>\n<pre><code>{\n    \"count\": 57624,\n    \"next\": \"http://localhost:8000/api/records/?offset=20\",\n    \"previous\": \"http://localhost:7000/api/records/\",\n    \"results\": [\n        ...\n    ]\n}\n</code></pre>\n<p>In a real response, the domain and port for the <code>next</code> and <code>previous</code> fields\nwill be that of the server responding to the request.</p>\n<p>This format applies to the API endpoints below and will not be repeated in the\ndocumentation for each individual endpoint.</p>\n<h3>Resources</h3>\n<h4>RecordTypes</h4>\n<p>Because the RecordSchema for a set of Records can change at any time, the RecordType API\nendpoint provides a consistent access point for retrieving a set of Records.\nUse the RecordType endpoints to discover the most recent RecordSchema for the Records\nyou are interested in before performing further queries.</p>\n<p>Paths:</p>\n<ul>\n<li>List: <code>/api/recordtypes/</code></li>\n<li>Detail: <code>/api/recordtypes/{uuid}/</code></li>\n</ul>\n<p>Query parameters:</p>\n<ul>\n<li><code>active</code>: Boolean\n<ul>\n<li>Filter for only RecordTypes with an <code>active</code> value of True.\nGenerally, you will want to limit yourself to active RecordTypes.</li>\n</ul>\n</li>\n</ul>\n<p>Results fields:</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>uuid</code></td>\n<td>UUID</td>\n<td>Unique identifier for this RecordType.</td>\n</tr>\n<tr>\n<td><code>current_schema</code></td>\n<td>UUID</td>\n<td>The most recent RecordSchema for this RecordType.</td>\n</tr>\n<tr>\n<td><code>created</code></td>\n<td>Timestamp</td>\n<td>The date and time when this RecordType was created.</td>\n</tr>\n<tr>\n<td><code>modified</code></td>\n<td>Timestamp</td>\n<td>The date and time when this RecordType was last modified.</td>\n</tr>\n<tr>\n<td><code>label</code></td>\n<td>String</td>\n<td>The name of this RecordType.</td>\n</tr>\n<tr>\n<td><code>plural_label</code></td>\n<td>String</td>\n<td>The plural version of the name of this RecordType.</td>\n</tr>\n<tr>\n<td><code>description</code></td>\n<td>String</td>\n<td>A short description of this RecordType.</td>\n</tr>\n<tr>\n<td><code>active</code></td>\n<td>Boolean</td>\n<td>Whether or not this RecordType is active. This field allows RecordTypes to be deactivated rather than deleted.</td>\n</tr>\n<tr>\n<td><code>geometry_type</code></td>\n<td>String</td>\n<td>The geometry type supported for Records of this RecordType. One of <code>point</code>, <code>polygon</code>, <code>multipolygon</code>, <code>linestring</code>, or <code>none</code>.</td>\n</tr>\n<tr>\n<td><code>temporal</code></td>\n<td>Boolean</td>\n<td>Whether or not Records of this RecordType should store datetime data in the <code>occurred_from</code> and <code>occurred_to</code> fields.</td>\n</tr></tbody></table>\n<h4>RecordSchemas</h4>\n<p>The RecordSchema API endpoint can help you discover the fields that\nshould be available on a given Record. This can be useful for automatically generating filters\nbased on a Record's fields, or for running custom validation on a Record's\nschema.</p>\n<p>Paths:</p>\n<ul>\n<li>List: <code>/api/recordschemas/</code></li>\n<li>Detail: <code>/api/recordschemas/{uuid}/</code></li>\n</ul>\n<p>Results fields:</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>uuid</code></td>\n<td>UUID</td>\n<td>Unique identifier for this RecordSchema.</td>\n</tr>\n<tr>\n<td><code>created</code></td>\n<td>Timestamp</td>\n<td>The date and time when this RecordSchema was created.</td>\n</tr>\n<tr>\n<td><code>modified</code></td>\n<td>Timestamp</td>\n<td>The date and time when this RecordSchema was last modified.</td>\n</tr>\n<tr>\n<td><code>version</code></td>\n<td>Integer</td>\n<td>A sequential number indicating what version of the RecordType's schema this is. Starts at 1.</td>\n</tr>\n<tr>\n<td><code>next_version</code></td>\n<td>UUID</td>\n<td>Unique identifier of the RecordSchema with the next-highest version number for this schema's RecordType. If this is the most recent version of the schema, this field will be <code>null</code>.</td>\n</tr>\n<tr>\n<td><code>record_type</code></td>\n<td>UUID</td>\n<td>Unique identifier of the RecordType that this RecordSchema refers to.</td>\n</tr>\n<tr>\n<td><code>schema</code></td>\n<td>Object</td>\n<td>A <a href=\"http://json-schema.org/\" rel=\"nofollow\">JSONSchema</a> object that should validate Records that refer to this RecordSchema.</td>\n</tr></tbody></table>\n<h4>Records</h4>\n<p>Records are the heart of a Grout project: the entities in your database. The\nRecords API endpoint provides a way of retrieving these objects for analysis\nor display to an end user.</p>\n<p>Paths:</p>\n<ul>\n<li>List: <code>/api/records/</code></li>\n<li>Detail: <code>/api/records/{uuid}/</code></li>\n</ul>\n<p>Query Parameters:</p>\n<ul>\n<li>\n<p><code>archived</code>: Boolean</p>\n<ul>\n<li>Records can be \"archived\" to denote that they are no longer current, as an\nalternative to deletion. Pass <code>True</code> (case-sensitive) to this parameter to return archived\nRecords only, and pass <code>False</code> (case-sensitive) to return current Records only.\nOmitting this parameter returns both types.</li>\n</ul>\n</li>\n<li>\n<p><code>details_only</code>: Boolean</p>\n<ul>\n<li>In the <a href=\"https://github.com/azavea/grout-schema-editor\" rel=\"nofollow\">Grout Schema Editor</a>,\nevery Record is automatically generated with a <code>&lt;record_type&gt;Details</code>\nform which is intended to contain a basic summary of information about the Record.\nPassing <code>True</code> (case-sensitive) to this parameter will omit any other\nforms which may exist on the Record. This is useful for limiting the size\nof the payload returned when only a summary view is needed.</li>\n</ul>\n</li>\n<li>\n<p><code>record_type</code>: UUID</p>\n<ul>\n<li>Limit the response to Records matching the passed RecordType UUID.\nThis is optional in theory, but for most applications it is a good idea\nto include this parameter by default. It is considered rare that it will\nbe useful to return two different types of Records in a single request.\nIt is usually a better idea to make a separate request for each RecordType.</li>\n</ul>\n</li>\n<li>\n<p><code>jsonb</code>: Object</p>\n<ul>\n<li>Query the data fields of the object and filter on the result.</li>\n<li>Keys in this object mimic the search paths to filter on a particular object\nfield. However, in place of values, a filter rule definition is used. Example:\n<code>{ \"accidentDetails\": { \"Main+cause\": { \"_rule_type\": \"containment\", \"contains\": [ \"Vehicle+defect\", \"Road+defect\", [\"Vehicle+defect\"], [\"Road+defect\"] ] }, \"Num+driver+casualties\": { \"_rule_type\": \"intrange\", \"min\": 1, \"max\": 3 } }}</code>. This query defines the following two filters:\n<ul>\n<li><code>accidentDetails -&gt; \"Main cause\" == \"Vehicle defect\" OR accidentDetails -&gt; \"Main cause\" == \"Road defect\"</code></li>\n<li><code>accidentDetails -&gt; \"Num driver casualties\" &gt;= 1 AND accidentDetails -&gt; \"Num driver casualties\" &lt;= 3</code></li>\n</ul>\n</li>\n<li>There is a third filter rule type available: <code>containment_multiple</code>.\nThis is used when searching a form of which there can be several on a single Record.\nHere's an example:\n<code>{\"person\":{\"Injury\":{\"_rule_type\":\"containment_multiple\",\"contains\":[\"Fatal\"]}}}</code></li>\n</ul>\n</li>\n<li>\n<p><code>occurred_min</code>: Timestamp</p>\n<ul>\n<li>Filter to Records occurring after this date.</li>\n</ul>\n</li>\n<li>\n<p><code>occurred_max</code>: Timestamp</p>\n<ul>\n<li>Filter to Records occurring before this date.</li>\n</ul>\n</li>\n<li>\n<p><code>polygon_id</code>: UUID</p>\n<ul>\n<li>Filter to Records which occurred within the Polygon identified by the\nUUID. The value must refer to a <a href=\"#boundaries\" rel=\"nofollow\">Boundary</a> in the database.</li>\n</ul>\n</li>\n<li>\n<p><code>polygon</code>: GeoJSON</p>\n<ul>\n<li>Filter to Records which occurred within the bounds of a valid GeoJSON\nobject.</li>\n</ul>\n</li>\n</ul>\n<p>Results fields:</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>uuid</code></td>\n<td>UUID</td>\n<td>Unique identifier for this Record.</td>\n</tr>\n<tr>\n<td><code>created</code></td>\n<td>Timestamp</td>\n<td>The date and time when this Record was created.</td>\n</tr>\n<tr>\n<td><code>modified</code></td>\n<td>Timestamp</td>\n<td>The date and time when this Record was last modified.</td>\n</tr>\n<tr>\n<td><code>occurred_from</code></td>\n<td>Timestamp</td>\n<td>The earliest time at which this Record might have occurred.</td>\n</tr>\n<tr>\n<td><code>occurred_to</code></td>\n<td>Timestamp</td>\n<td>The latest time at which this Record might have occurred. Note that this field is mandatory for temporal Records: if a Record only occurred at one moment in time, the <code>occurred_from</code> field and the <code>occurred_to</code> field will have the same value.</td>\n</tr>\n<tr>\n<td><code>geom</code></td>\n<td>GeoJSON</td>\n<td>Geometry representing the location associated with this Record.</td>\n</tr>\n<tr>\n<td><code>location_text</code></td>\n<td>String</td>\n<td>A description of the location where this Record occurred, typically an address.</td>\n</tr>\n<tr>\n<td><code>archived</code></td>\n<td>Boolean</td>\n<td>A way of hiding records without deleting them completely. <code>True</code> indicates the Record is archived.</td>\n</tr>\n<tr>\n<td><code>schema</code></td>\n<td>UUID</td>\n<td>References the RecordSchema which was used to create this Record.</td>\n</tr>\n<tr>\n<td><code>data</code></td>\n<td>Object</td>\n<td>A JSON object representing the flexible data fields associated with this Record. It is always true that the object stored in <code>data</code> conforms to the RecordSchema referenced by the <code>schema</code> UUID.</td>\n</tr></tbody></table>\n<h4>Boundaries</h4>\n<p>Boundaries provide a quick way of storing Shapefile data in Grout without\nhaving to create separate RecordTypes. Using a Boundary, you can upload\nand retrieve Shapefile data for things like administrative borders and focus\nareas in your application.</p>\n<p>Paths:</p>\n<ul>\n<li>List: <code>/api/boundaries/</code></li>\n<li>Detail: <code>/api/boundaries/{uuid}/</code></li>\n</ul>\n<p>Results fields:</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>uuid</code></td>\n<td>UUID</td>\n<td>Unique identifier for this Boundary.</td>\n</tr>\n<tr>\n<td><code>created</code></td>\n<td>Timestamp</td>\n<td>The date and time when this Boundary was created.</td>\n</tr>\n<tr>\n<td><code>modified</code></td>\n<td>Timestamp</td>\n<td>The date and time when this Boundary was last modified.</td>\n</tr>\n<tr>\n<td><code>label</code></td>\n<td>String</td>\n<td>Label of this Boundary, for display.</td>\n</tr>\n<tr>\n<td><code>color</code></td>\n<td>String</td>\n<td>Color preference to use for rendering this Boundary.</td>\n</tr>\n<tr>\n<td><code>display_field</code></td>\n<td>String</td>\n<td>Which field of the imported Shapefile to use for display.</td>\n</tr>\n<tr>\n<td><code>data_fields</code></td>\n<td>Array</td>\n<td>List of the names of the fields contained in the imported Shapefile.</td>\n</tr>\n<tr>\n<td><code>errors</code></td>\n<td>Array</td>\n<td>A possible list of errors raised when importing the Shapefile.</td>\n</tr>\n<tr>\n<td><code>status</code></td>\n<td>String</td>\n<td>Import status of the Shapefile.</td>\n</tr>\n<tr>\n<td><code>source_file</code></td>\n<td>String</td>\n<td>URI of the Shapefile that was originally used to generate this Boundary.</td>\n</tr></tbody></table>\n<p>Notes:</p>\n<p>Creating a new Boundary and its <a href=\"#boundarypolygon\" rel=\"nofollow\">BoundaryPolygon</a> correctly is a two-step process.</p>\n<ol>\n<li>\n<p><code>POST</code> to <code>/api/boundaries/</code> with a zipped Shapefile attached; you will need\nto include the label as form data. You should receive a 201 response which\ncontains a fully-fledged Boundary object, including a list of available\ndata fields in <code>data_fields</code>.</p>\n</li>\n<li>\n<p>The response from the previous request will have a blank <code>display_field</code>.\nSelect one of the fields in <code>data_fields</code> and make a <code>PATCH</code> request to\n<code>/api/boundaries/{uuid}/</code> with that value in <code>display_field</code>.\nYou are now ready to use this Boundary and its associated BoundaryPolygon.</p>\n</li>\n</ol>\n<h4>BoundaryPolygons</h4>\n<p>BoundaryPolygons store the Shapefile data associated with a <a href=\"#boundaries\" rel=\"nofollow\">Boundary</a>,\nincluding geometry and metadata.</p>\n<p>Paths:</p>\n<ul>\n<li>List: <code>/api/boundarypolygons/</code></li>\n<li>Detail: <code>/api/boundarypolygons/{uuid}/</code></li>\n</ul>\n<p>Query Parameters:</p>\n<ul>\n<li>\n<p><code>boundary</code>: UUID</p>\n<ul>\n<li>Filter to Polygons associated with this parent Boundary.</li>\n</ul>\n</li>\n<li>\n<p><code>nogeom</code>: Boolean</p>\n<ul>\n<li>When passed with any value, causes the geometry field to be replaced with\na bbox field. This reduces the response size and is sufficient for many purposes.</li>\n</ul>\n</li>\n</ul>\n<p>Results fields:</p>\n<table>\n<thead>\n<tr>\n<th>Field name</th>\n<th>Type</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>uuid</code></td>\n<td>UUID</td>\n<td>Unique identifier for this BoundaryPolygon.</td>\n</tr>\n<tr>\n<td><code>created</code></td>\n<td>Timestamp</td>\n<td>The date and time when this BoundaryPolygon was created.</td>\n</tr>\n<tr>\n<td><code>modified</code></td>\n<td>Timestamp</td>\n<td>The date and time when this BoundaryPolygon was last modified.</td>\n</tr>\n<tr>\n<td><code>data</code></td>\n<td>Object</td>\n<td>Each key in this Object will correspond to one of the <code>data_fields</code> in the parent Boundary, and will store the value for that field for this Polygon.</td>\n</tr>\n<tr>\n<td><code>boundary</code></td>\n<td>UUID</td>\n<td>Unique identifier of the parent Boundary for this BoundaryPolygon.</td>\n</tr>\n<tr>\n<td><code>bbox</code></td>\n<td>Array</td>\n<td>Minimum bounding box containing this Polygon's geometry, as an Array of lat/lon points. This field is optional -- see the <code>nogeom</code> parameter above for more details.</td>\n</tr>\n<tr>\n<td><code>geometry</code></td>\n<td>GeoJSON</td>\n<td>GeoJSON representation of this Polygon. This field is optional -- see the <code>nogeom</code> parameter above for more details.</td>\n</tr></tbody></table>\n<h2>Developing</h2>\n<p>These instructions will help you set up a development version of Grout and\ncontribute changes back upstream.</p>\n<h3>Requirements</h3>\n<p>The Grout development environment is containerized with Docker to ensure similar\nenvironments across platforms. In order to develop with Docker, you need the\nfollowing dependencies:</p>\n<ul>\n<li><a href=\"https://docs.docker.com/install/\" rel=\"nofollow\">Docker CE Engine</a> &gt;= 1.13.0 (must be\ncompatible with <a href=\"https://docs.docker.com/compose/compose-file/#compose-and-docker-compatibility-matrix\" rel=\"nofollow\">Docker Compose file v3\nsyntax</a>)</li>\n<li><a href=\"https://docs.docker.com/compose/install/\" rel=\"nofollow\">Docker Compose</a></li>\n</ul>\n<h3>Installation</h3>\n<p>Clone the repo with git.</p>\n<pre>$ git clone git@github.com:azavea/grout.git\n$ <span class=\"nb\">cd</span> grout\n</pre>\n<p>Run the <code>update</code> script to set up your development environment.</p>\n<pre>$ ./scripts/update\n</pre>\n<h3>Running tests</h3>\n<p>Once your environment is up to date, you can use the <code>scripts/test</code> script to\nrun the Grout unit test suite.</p>\n<pre>$ ./scripts/test\n</pre>\n<p>This command will run a matrix of tests for <strong>every supported version of Python and\nDjango</strong> in the project. If you're developing locally and you just want to run\na subset of the tests, you can specify the version of Python\nthat you want to use to run tests:</p>\n<pre><span class=\"c1\"># Only run tests for Python 2.7 (this will test Django 1.8).</span>\n$ ./scripts/test app py27\n\n<span class=\"c1\"># Only run tests for Python 3.7 (this will test Django 2.0).</span>\n$ ./scripts/test app py37\n</pre>\n<p>For a list of available Python versions, see the <code>envlist</code> directive in the <a href=\"./tox.ini\" rel=\"nofollow\"><code>tox.ini</code>\nfile</a>.</p>\n<h4>Cleaning up</h4>\n<p>Tox creates a new virtualenv for every combination of Python and Django versions\nused by the test suite. In order to clean up stopped containers and\nremove these virtualenvs, use the <code>clean</code> script:</p>\n<pre>$ ./scripts/clean\n</pre>\n<p>Note that <code>clean</code> will remove <strong>all dangling images, stopped containers, and\nunused volumes</strong> on your machine. If you don't want to remove these artifacts,\n<a href=\"./scripts/clean\" rel=\"nofollow\">view the <code>clean</code> script</a> and run only the command that\ninterests you.</p>\n<h3>Making migrations</h3>\n<p>If you edit the data model in <code>grout/models.py</code>, you'll need to create a new\nmigration for the app. You can use the <code>django-admin</code> script in the <code>scripts</code>\ndirectory to automatically generate the migration:</p>\n<pre>$ ./scripts/django-admin makemigrations\n</pre>\n<p>Make sure to register the new migrations file with Git:</p>\n<pre>$ git add grout/migrations\n</pre>\n<h2>Resources</h2>\n<p>The following resources provide helpful tips for deploying and using Grout.</p>\n<h3>Grout suite</h3>\n<ul>\n<li><a href=\"https://github.com/azavea/grout-server\" rel=\"nofollow\">Grout Server</a>: An easily-deployable\nstandalone instance of a Grout API server.</li>\n<li><a href=\"https://github.com/azavea/grout-schema-editor\" rel=\"nofollow\">Grout Schema Editor</a>: A\npurely static app that can read and write flexible schemas from a Grout API.</li>\n<li><a href=\"https://github.com/jeancochrane/philly-fliers/\" rel=\"nofollow\">Demo app</a>: A demo project\nproviding an example of incorporating the Grout suite into a Vue.js app.</li>\n</ul>\n<h3>Historical documents</h3>\n<ul>\n<li>\n<p><a href=\"./docs/concept-map.md\" rel=\"nofollow\">Concept map</a>: An early description of the Grout suite\n(formerly known as Ashlar) from an Open Source Fellow working on it during the summer\nof 2018. Describes the conceptual architecture of the suite, and summarizes\nideas for future directions.</p>\n</li>\n<li>\n<p><a href=\"./docs/rename-package.md\" rel=\"nofollow\">Renaming the package to Grout</a>: An ADR documenting\nthe decision to rename the package from \"Ashlar\" to \"Grout\".</p>\n</li>\n<li>\n<p><a href=\"./docs/foreign-keys.md\" rel=\"nofollow\">Evaluating Record-to-Record references</a>: An ADR\ndocumenting the reasons and requirements for implementing a Record-to-Record\nforeign key field. See also <a href=\"https://github.com/azavea/grout-2018-fellowship/pull/34\" rel=\"nofollow\">the pull request\nthread</a> for further\ndiscussion.</p>\n</li>\n<li>\n<p><a href=\"./docs/nosql-backends.md\" rel=\"nofollow\">Evaluating alternate backends</a>: An ADR presenting\nresearch into possible NoSQL backends and service providers for Grout.</p>\n</li>\n<li>\n<p><a href=\"https://github.com/azavea/grout-2018-fellowship\" rel=\"nofollow\">Grout 2018 Fellowship</a>: A\nproject management repo for working on Grout during Azavea's Summer 2018\n<a href=\"https://fellowship.azavea.com\" rel=\"nofollow\">Open Source Fellowship</a>. Useful for\ndocumentation around the motivation and trajectory of the project.</p>\n</li>\n</ul>\n<h3>Roadmap</h3>\n<p>Want to know where Grout is headed? See the <a href=\"./docs/roadmap.md\" rel=\"nofollow\">Roadmap</a> to\nget a picture of future development.</p>\n\n          </div>"}, "last_serial": 4737167, "releases": {"0.0.0": [{"comment_text": "", "digests": {"md5": "c1a787a11668900328234195f9790401", "sha256": "0eb5d5a973a0fa7753240f8aaffd5a36d6556be8ee63623af059583ca3c8ccd9"}, "downloads": -1, "filename": "grout-0.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "c1a787a11668900328234195f9790401", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 1996, "upload_time": "2018-07-10T18:04:11", "upload_time_iso_8601": "2018-07-10T18:04:11.407271Z", "url": "https://files.pythonhosted.org/packages/0f/b2/865981c241567d4a78a3ad5d35f49ab9881d5d2b30eb559fb1e244d7af46/grout-0.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1bc11d169024fcce9ba91d41d0bdcd56", "sha256": "0ec05bc9a371919b69a293ab19bf994e5680d7d1cfb20a282d2db8889f2c1e9a"}, "downloads": -1, "filename": "grout-0.0.0.tar.gz", "has_sig": false, "md5_digest": "1bc11d169024fcce9ba91d41d0bdcd56", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 932, "upload_time": "2018-07-10T18:04:12", "upload_time_iso_8601": "2018-07-10T18:04:12.616745Z", "url": "https://files.pythonhosted.org/packages/8e/e7/e49281e9f1450078cbef6bdaeee307ac425e6f5a98dfb78eb62e97dd5d71/grout-0.0.0.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "e590816f4eaac4517291f34ac7cf05f8", "sha256": "87a60aad55f6668034f84931eb4576397fcbb9e44e48ec0132ea5c6e2eb261dc"}, "downloads": -1, "filename": "grout-1.0.0.tar.gz", "has_sig": false, "md5_digest": "e590816f4eaac4517291f34ac7cf05f8", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*", "size": 445048, "upload_time": "2018-07-13T15:24:47", "upload_time_iso_8601": "2018-07-13T15:24:47.791838Z", "url": "https://files.pythonhosted.org/packages/45/f6/359746da209d2f9e318a8aa327fabcbdebec9f8ca6a4ddb258ac4b6bc827/grout-1.0.0.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "c351ae1dbc8ac3dc9019809744d0c633", "sha256": "145186b1d76b47f316e8820ae82248d2974718404e041d06db9e3a9bd6b89dcf"}, "downloads": -1, "filename": "grout-2.0.0.tar.gz", "has_sig": false, "md5_digest": "c351ae1dbc8ac3dc9019809744d0c633", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*", "size": 485615, "upload_time": "2018-08-28T18:55:25", "upload_time_iso_8601": "2018-08-28T18:55:25.606714Z", "url": "https://files.pythonhosted.org/packages/3d/53/0f24578272c607c61734717470518564005c485f66dc19ab7c41410e3b55/grout-2.0.0.tar.gz", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "c10cb4318684175b1ff8e01856c4846b", "sha256": "c27273ce305ff5df0782495218555965f059e337c360765ab0f17c8cade4eab3"}, "downloads": -1, "filename": "grout-2.0.1.tar.gz", "has_sig": false, "md5_digest": "c10cb4318684175b1ff8e01856c4846b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*", "size": 486423, "upload_time": "2019-01-24T20:00:07", "upload_time_iso_8601": "2019-01-24T20:00:07.144514Z", "url": "https://files.pythonhosted.org/packages/64/19/4248c2376d8800023a6b364b29e30ef0324e7115f445e4b4ad6a2b311750/grout-2.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c10cb4318684175b1ff8e01856c4846b", "sha256": "c27273ce305ff5df0782495218555965f059e337c360765ab0f17c8cade4eab3"}, "downloads": -1, "filename": "grout-2.0.1.tar.gz", "has_sig": false, "md5_digest": "c10cb4318684175b1ff8e01856c4846b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*", "size": 486423, "upload_time": "2019-01-24T20:00:07", "upload_time_iso_8601": "2019-01-24T20:00:07.144514Z", "url": "https://files.pythonhosted.org/packages/64/19/4248c2376d8800023a6b364b29e30ef0324e7115f445e4b4ad6a2b311750/grout-2.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:02 2020"}