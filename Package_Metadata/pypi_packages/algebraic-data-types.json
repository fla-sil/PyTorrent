{"info": {"author": "Justin Spahr-Summers", "author_email": "justin@jspahrsummers.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3 :: Only", "Topic :: Software Development :: Libraries :: Python Modules", "Typing :: Typed"], "description": "# adt [![CircleCI](https://circleci.com/gh/jspahrsummers/adt.svg?style=svg&circle-token=2652421c13c636b5da0c992d77ec2fb0b128dd49)](https://circleci.com/gh/jspahrsummers/adt)\n\n`adt` is a library providing [algebraic data types](https://en.wikipedia.org/wiki/Algebraic_data_type) in Python, with a clean, intuitive syntax, and support for [`typing`](https://docs.python.org/3/library/typing.html) through a [mypy plugin](#mypy-plugin).\n\n**Table of contents:**\n\n1. [What are algebraic data types?](#what-are-algebraic-data-types)\n    1. [Pattern matching](#pattern-matching)\n    1. [Compared to Enums](#compared-to-enums)\n    1. [Compared to inheritance](#compared-to-inheritance)\n    1. [Examples in other programming languages](#examples-in-other-programming-languages)\n1. [Installation](#installation)\n    1. [mypy plugin](#mypy-plugin)\n1. [Defining an ADT](#defining-an-adt)\n    1. [Generated functionality](#generated-functionality)\n    1. [Custom methods](#custom-methods)\n\n# What are algebraic data types?\n\nAn [algebraic data type](https://en.wikipedia.org/wiki/Algebraic_data_type) (also known as an ADT) is a way to represent multiple variants of a single type, each of which can have some data associated with it. The idea is very similar to [tagged unions and sum types](https://en.wikipedia.org/wiki/Tagged_union), which in Python are represented as [Enums](#compared-to-enums).\n\nADTs are useful for a variety of data structures, including binary trees:\n\n```python\n@adt\nclass Tree:\n    EMPTY: Case\n    LEAF: Case[int]\n    NODE: Case[\"Tree\", \"Tree\"]\n```\n\nAbstract syntax trees (like you might implement as part of a parser, compiler, or interpreter):\n\n```python\n@adt\nclass Expression:\n    LITERAL: Case[float]\n    UNARY_MINUS: Case[\"Expression\"]\n    ADD: Case[\"Expression\", \"Expression\"]\n    MINUS: Case[\"Expression\", \"Expression\"]\n    MULTIPLY: Case[\"Expression\", \"Expression\"]\n    DIVIDE: Case[\"Expression\", \"Expression\"]\n```\n\nOr more generic versions of a variant type, like an `Either` type that represents a type A or a type B, but not both:\n\n```python\nL = TypeVar('L')\nR = TypeVar('R')\n\n@adt\nclass Either(Generic[L, R]):\n    LEFT: Case[L]\n    RIGHT: Case[R]\n```\n\n## Pattern matching\n\nNow, defining a type isn't that interesting by itself. A lot of the expressivity of ADTs arises when you [pattern match](https://en.wikipedia.org/wiki/Pattern_matching) over them (sometimes known as \"destructuring\").\n\nFor example, we could use the `Either` ADT from above to implement a sort of error handling:\n\n```python\n# Defined in some other module, perhaps\ndef some_operation() -> Either[Exception, int]:\n    return Either.RIGHT(22)  # Example of building a constructor\n\n# Run some_operation, and handle the success or failure\ndefault_value = 5\nunpacked_result = some_operation().match(\n    # In this case, we're going to ignore any exception we receive\n    left=lambda ex: default_value,\n    right=lambda result: result)\n```\n\n_Aside: this is very similar to how error handling is implemented in languages like [Haskell](https://www.haskell.org/), because it avoids the unpredictable control flow of raising and catching exceptions, and ensures that callers need to make an explicit decision about what to do in an error case._\n\nOne can do the same thing with the `Expression` type above (just more cases to match):\n\n```python\ndef handle_expression(e: Expression):\n    return e.match(\n        literal=lambda n: ...,\n        unary_minus=lambda expr: ...,\n        add=lambda lhs, rhs: ...,\n        minus=lambda lhs, rhs: ...,\n        multiply=lambda lhs, rhs: ...,\n        divide=lambda lhs, rhs: ...)\n```\n\n## Compared to Enums\n\nADTs are somewhat similar to [`Enum`s](https://docs.python.org/3/library/enum.html) from the Python standard library (in fact, the uppercase naming convention is purposely similar).\n\nFor example, an `Enum` version of `Expression` might look like:\n\n```python\nfrom enum import Enum, auto\nclass EnumExpression(Enum):\n    LITERAL = auto()\n    UNARY_MINUS = auto()\n    ADD = auto()\n    MINUS = auto()\n    MULTIPLY = auto()\n    DIVIDE = auto()\n```\n\nHowever, this doesn't allow data to be associated with each of these enum values. A particular value of `Expression` will tell you about a _kind_ of expression that exists, but the operands to the expressions still have to be stored elsewhere.\n\nFrom this perspective, ADTs are like `Enum`s that can optionally have data associated with each case.\n\n## Compared to inheritance\n\nAlgebraic data types are a relatively recent introduction to object-oriented programming languages, for the simple reason that inheritance can replicate the same behavior.\n\nContinuing our examples with the `Expression` ADT, here's how one might represent it with inheritance in Python:\n\n```python\nfrom abc import ABC\nclass ABCExpression(ABC):\n    pass\n\nclass LiteralExpression(ABCExpression):\n    def __init__(self, value: float):\n        pass\n\nclass UnaryMinusExpression(ABCExpression):\n    def __init__(self, inner: ABCExpression):\n        pass\n\nclass AddExpression(ABCExpression):\n    def __init__(self, lhs: ABCExpression, rhs: ABCExpression):\n        pass\n\nclass MinusExpression(ABCExpression):\n    def __init__(self, lhs: ABCExpression, rhs: ABCExpression):\n        pass\n\nclass MultiplyExpression(ABCExpression):\n    def __init__(self, lhs: ABCExpression, rhs: ABCExpression):\n        pass\n\nclass DivideExpression(ABCExpression):\n    def __init__(self, lhs: ABCExpression, rhs: ABCExpression):\n        pass\n```\n\nThis is noticeably more verbose, and the code to consume these types gets much more complex as well:\n\n```python\ne: ABCExpression = UnaryMinusExpression(LiteralExpression(3))  # Example of creating an expression\n\nif isinstance(e, LiteralExpression):\n    result = ... # do something with e.value\nelif isinstance(e, UnaryMinusExpression):\n    result = ... # do something with e.inner\nelif isinstance(e, AddExpression):\n    result = ... # do something with e.lhs and e.rhs\nelif isinstance(e, MinusExpression):\n    result = ... # do something with e.lhs and e.rhs\nelif isinstance(e, MultiplyExpression):\n    result = ... # do something with e.lhs and e.rhs\nelif isinstance(e, DivideExpression):\n    result = ... # do something with e.lhs and e.rhs\nelse:\n    raise ValueError(f'Unexpected type of expression: {e}')\n```\n\nADTs offer a simple way to define a type which is _one of a set of possible cases_, and allowing data to be associated with each case and packed/unpacked along with it.\n\n## Examples in other programming languages\n\nAlgebraic data types are very common in functional programming languages, like [Haskell](https://www.haskell.org/) or [Scala](https://www.scala-lang.org/), but they're gaining increasing acceptance in \"mainstream\" programming languages as well.\n\nHere are a few examples.\n\n### [Rust](https://www.rust-lang.org/)\n\nRust `enum`s are actually full-fledged ADTs. Here's how an `Either` ADT could be defined:\n\n```rust\nenum Either<L, R> {\n    Left(L),\n    Right(R),\n}\n```\n\n### [Swift](https://developer.apple.com/swift/)\n\n[Swift enumerations](https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html) are very similar to Rust's, and behave like algebraic data types through their support of \"associated values.\"\n\n```swift\nenum Either<L, R> {\n    case Left(L)\n    case Right(R)\n}\n```\n\n### [TypeScript](https://en.wikipedia.org/wiki/Microsoft_TypeScript)\n\n[TypeScript](https://en.wikipedia.org/wiki/Microsoft_TypeScript) offers ADTs through a language feature known as [\"discriminated unions\"](https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions).\n\nSee this example from their documentation:\n\n```typescript\ninterface Square {\n    kind: \"square\";\n    size: number;\n}\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n\ntype Shape = Square | Rectangle | Circle;\n```\n\n# Installation\n\nTo add `adt` as a library in your Python project, simply run `pip` (or `pip3`, as it may be named on your system):\n\n```\npip install algebraic-data-types\n```\n\nThis will install [the latest version from PyPI](https://pypi.org/project/algebraic-data-types/).\n\n## mypy plugin\n\nThe library also comes with a plugin for [mypy](http://mypy-lang.org/) that enables typechecking of `@adt` definitions. **If you are already using mypy, the plugin is required to avoid nonsensical type errors.**\n\nTo enable the `adt` typechecking plugin, add the following to a `mypy.ini` file in your project's working directory:\n\n```\n[mypy]\nplugins = adt.mypy_plugin\n```\n\n# Defining an ADT\n\nTo begin defining your own data type, import the `@adt` decorator and `Case[\u2026]` annotation:\n\n[//]: # (README_TEST:AT_TOP)\n```python\nfrom adt import adt, Case\n```\n\nThen, define a new Python class, upon which you apply the `@adt` decorator:\n\n```python\n@adt\nclass MyADT1:\n    pass\n```\n\nFor each case (variant) that your ADT will have, declare a field with the `Case` annotation. It's conventional to declare your fields with ALL_UPPERCASE names, but the only true restriction is that they _cannot_ be lowercase.\n\n```python\n@adt\nclass MyADT2:\n    FIRST_CASE: Case\n    SECOND_CASE: Case\n```\n\nIf you want to associate some data with a particular case, list the type of that data in brackets after `Case` (similar to the `Generic[\u2026]` and `Tuple[\u2026]` annotations from `typing`). For example, to add a case with an associated string:\n\n```python\n@adt\nclass MyADT3:\n    FIRST_CASE: Case\n    SECOND_CASE: Case\n    STRING_CASE: Case[str]\n```\n\nYou can build cases with arbitrarily many associated pieces of data, as long as all the types are listed:\n\n```python\n@adt\nclass MyADT4:\n    FIRST_CASE: Case\n    SECOND_CASE: Case\n    STRING_CASE: Case[str]\n    LOTS_OF_DATA_CASE: Case[int, str, str, Dict[int, int]]\n```\n\nADTs can also be recursive\u2014i.e., an ADT can itself be stored alongside a specific case\u2014though the class name has to be provided in double quotes (a restriction which also applies to `typing`).\n\nA typical example of a recursive ADT is a linked list. Here, the list is also made generic over a type `T`:\n\n```python\nT = TypeVar('T')\n\n@adt\nclass LinkedList(Generic[T]):\n    NIL: Case\n    CONS: Case[T, \"LinkedList[T]\"]\n```\n\nSee the library's [tests](tests/) for more examples of complete ADT definitions.\n\n## Generated functionality\n\nGiven an ADT defined as follows:\n\n```python\n@adt\nclass MyADT5:\n    EMPTY: Case\n    INTEGER: Case[int]\n    STRING_PAIR: Case[str, str]\n```\n\nThe `@adt` decorator will automatically generate accessor methods of the following form:\n\n```python\n    def empty(self) -> None:\n        return None\n\n    def integer(self) -> int:\n        ... # unpacks int value and returns it\n\n    def string_pair(self) -> Tuple[str, str]:\n        ... # unpacks strings and returns them in a tuple\n```\n\nThese accessors can be used to obtain the data associated with the ADT case, but **accessors will throw an exception if the ADT was not constructed with the matching case**. This is a shorthand when you already know the case of an ADT object.\n\n`@adt` will also automatically generate a pattern-matching method, which can be used when you _don't_ know which case you have ahead of time:\n\n[//]: # (README_TEST:IGNORE)\n```python\n    Result = TypeVar('Result')\n\n    def match(self,\n              empty: Callable[[], Result],\n              integer: Callable[[int], Result],\n              string_pair: Callable[[str, str], Result]) -> Result:\n        if ... self was constructed as EMPTY ...:\n            return empty()\n        elif ... self was constructed as INTEGER ...:\n            return integer(self.integer())\n        elif ... self was constructed as STRING_PAIR ...:\n            return string_pair(*self.string_pair())\n\n        # if pattern match is incomplete, an exception is raised\n```\n\nSee the library's [tests](tests/) for examples of using these generated methods.\n\n`@adt` will also generate `__repr__`, `__str__`, and `__eq__` methods (only if they are not [defined already](#custom-methods)), to make ADTs convenient to use by default.\n\n## Custom methods\n\nArbitrary methods can be defined on ADTs by simply including them in the class definition as normal.\n\nFor example, to build \"safe\" versions of the default accessors on `ExampleADT`, which return `None` instead of throwing an exception when the case is incorrect:\n\n```python\n@adt\nclass ExampleADT:\n    EMPTY: Case\n    INTEGER: Case[int]\n    STRING_PAIR: Case[str, str]\n\n    @property\n    def safe_integer(self) -> Optional[int]:\n        return self.match(empty=lambda: None,\n                          integer=lambda n: n,\n                          string_pair=lambda _a, _b: None)\n\n    @property\n    def safe_string_pair(self) -> Optional[Tuple[str, str]]:\n        return self.match(empty=lambda: None,\n                          integer=lambda: None,\n                          string_pair=lambda a, b: tuple(a, b))\n```\n\nHowever, additional fields _must not_ be added to the class, as the decorator will attempt to interpret them as ADT `Case`s (which will fail).\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/jspahrsummers/adt", "keywords": "adt algebraic data types sum union tagged", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "algebraic-data-types", "package_url": "https://pypi.org/project/algebraic-data-types/", "platform": "", "project_url": "https://pypi.org/project/algebraic-data-types/", "project_urls": {"Homepage": "https://github.com/jspahrsummers/adt"}, "release_url": "https://pypi.org/project/algebraic-data-types/0.1.3/", "requires_dist": null, "requires_python": "", "summary": "Algebraic data types for Python", "version": "0.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>adt <a href=\"https://circleci.com/gh/jspahrsummers/adt\" rel=\"nofollow\"><img alt=\"CircleCI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c483dd33435010049c1bcd41c926f871323eccc6/68747470733a2f2f636972636c6563692e636f6d2f67682f6a737061687273756d6d6572732f6164742e7376673f7374796c653d73766726636972636c652d746f6b656e3d32363532343231633133633633366235646130633939326437376563326662306231323864643439\"></a></h1>\n<p><code>adt</code> is a library providing <a href=\"https://en.wikipedia.org/wiki/Algebraic_data_type\" rel=\"nofollow\">algebraic data types</a> in Python, with a clean, intuitive syntax, and support for <a href=\"https://docs.python.org/3/library/typing.html\" rel=\"nofollow\"><code>typing</code></a> through a <a href=\"#mypy-plugin\" rel=\"nofollow\">mypy plugin</a>.</p>\n<p><strong>Table of contents:</strong></p>\n<ol>\n<li><a href=\"#what-are-algebraic-data-types\" rel=\"nofollow\">What are algebraic data types?</a>\n<ol>\n<li><a href=\"#pattern-matching\" rel=\"nofollow\">Pattern matching</a></li>\n<li><a href=\"#compared-to-enums\" rel=\"nofollow\">Compared to Enums</a></li>\n<li><a href=\"#compared-to-inheritance\" rel=\"nofollow\">Compared to inheritance</a></li>\n<li><a href=\"#examples-in-other-programming-languages\" rel=\"nofollow\">Examples in other programming languages</a></li>\n</ol>\n</li>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a>\n<ol>\n<li><a href=\"#mypy-plugin\" rel=\"nofollow\">mypy plugin</a></li>\n</ol>\n</li>\n<li><a href=\"#defining-an-adt\" rel=\"nofollow\">Defining an ADT</a>\n<ol>\n<li><a href=\"#generated-functionality\" rel=\"nofollow\">Generated functionality</a></li>\n<li><a href=\"#custom-methods\" rel=\"nofollow\">Custom methods</a></li>\n</ol>\n</li>\n</ol>\n<h1>What are algebraic data types?</h1>\n<p>An <a href=\"https://en.wikipedia.org/wiki/Algebraic_data_type\" rel=\"nofollow\">algebraic data type</a> (also known as an ADT) is a way to represent multiple variants of a single type, each of which can have some data associated with it. The idea is very similar to <a href=\"https://en.wikipedia.org/wiki/Tagged_union\" rel=\"nofollow\">tagged unions and sum types</a>, which in Python are represented as <a href=\"#compared-to-enums\" rel=\"nofollow\">Enums</a>.</p>\n<p>ADTs are useful for a variety of data structures, including binary trees:</p>\n<pre><span class=\"nd\">@adt</span>\n<span class=\"k\">class</span> <span class=\"nc\">Tree</span><span class=\"p\">:</span>\n    <span class=\"n\">EMPTY</span><span class=\"p\">:</span> <span class=\"n\">Case</span>\n    <span class=\"n\">LEAF</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>\n    <span class=\"n\">NODE</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"s2\">\"Tree\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Tree\"</span><span class=\"p\">]</span>\n</pre>\n<p>Abstract syntax trees (like you might implement as part of a parser, compiler, or interpreter):</p>\n<pre><span class=\"nd\">@adt</span>\n<span class=\"k\">class</span> <span class=\"nc\">Expression</span><span class=\"p\">:</span>\n    <span class=\"n\">LITERAL</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>\n    <span class=\"n\">UNARY_MINUS</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"s2\">\"Expression\"</span><span class=\"p\">]</span>\n    <span class=\"n\">ADD</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"s2\">\"Expression\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Expression\"</span><span class=\"p\">]</span>\n    <span class=\"n\">MINUS</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"s2\">\"Expression\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Expression\"</span><span class=\"p\">]</span>\n    <span class=\"n\">MULTIPLY</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"s2\">\"Expression\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Expression\"</span><span class=\"p\">]</span>\n    <span class=\"n\">DIVIDE</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"s2\">\"Expression\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Expression\"</span><span class=\"p\">]</span>\n</pre>\n<p>Or more generic versions of a variant type, like an <code>Either</code> type that represents a type A or a type B, but not both:</p>\n<pre><span class=\"n\">L</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'L'</span><span class=\"p\">)</span>\n<span class=\"n\">R</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'R'</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@adt</span>\n<span class=\"k\">class</span> <span class=\"nc\">Either</span><span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">[</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">]):</span>\n    <span class=\"n\">LEFT</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"n\">L</span><span class=\"p\">]</span>\n    <span class=\"n\">RIGHT</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"n\">R</span><span class=\"p\">]</span>\n</pre>\n<h2>Pattern matching</h2>\n<p>Now, defining a type isn't that interesting by itself. A lot of the expressivity of ADTs arises when you <a href=\"https://en.wikipedia.org/wiki/Pattern_matching\" rel=\"nofollow\">pattern match</a> over them (sometimes known as \"destructuring\").</p>\n<p>For example, we could use the <code>Either</code> ADT from above to implement a sort of error handling:</p>\n<pre><span class=\"c1\"># Defined in some other module, perhaps</span>\n<span class=\"k\">def</span> <span class=\"nf\">some_operation</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Either</span><span class=\"p\">[</span><span class=\"ne\">Exception</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]:</span>\n    <span class=\"k\">return</span> <span class=\"n\">Either</span><span class=\"o\">.</span><span class=\"n\">RIGHT</span><span class=\"p\">(</span><span class=\"mi\">22</span><span class=\"p\">)</span>  <span class=\"c1\"># Example of building a constructor</span>\n\n<span class=\"c1\"># Run some_operation, and handle the success or failure</span>\n<span class=\"n\">default_value</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>\n<span class=\"n\">unpacked_result</span> <span class=\"o\">=</span> <span class=\"n\">some_operation</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span>\n    <span class=\"c1\"># In this case, we're going to ignore any exception we receive</span>\n    <span class=\"n\">left</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">ex</span><span class=\"p\">:</span> <span class=\"n\">default_value</span><span class=\"p\">,</span>\n    <span class=\"n\">right</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">result</span><span class=\"p\">:</span> <span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<p><em>Aside: this is very similar to how error handling is implemented in languages like <a href=\"https://www.haskell.org/\" rel=\"nofollow\">Haskell</a>, because it avoids the unpredictable control flow of raising and catching exceptions, and ensures that callers need to make an explicit decision about what to do in an error case.</em></p>\n<p>One can do the same thing with the <code>Expression</code> type above (just more cases to match):</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">handle_expression</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"n\">Expression</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span>\n        <span class=\"n\">literal</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"o\">...</span><span class=\"p\">,</span>\n        <span class=\"n\">unary_minus</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">expr</span><span class=\"p\">:</span> <span class=\"o\">...</span><span class=\"p\">,</span>\n        <span class=\"n\">add</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">lhs</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">:</span> <span class=\"o\">...</span><span class=\"p\">,</span>\n        <span class=\"n\">minus</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">lhs</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">:</span> <span class=\"o\">...</span><span class=\"p\">,</span>\n        <span class=\"n\">multiply</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">lhs</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">:</span> <span class=\"o\">...</span><span class=\"p\">,</span>\n        <span class=\"n\">divide</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">lhs</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">:</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n<h2>Compared to Enums</h2>\n<p>ADTs are somewhat similar to <a href=\"https://docs.python.org/3/library/enum.html\" rel=\"nofollow\"><code>Enum</code>s</a> from the Python standard library (in fact, the uppercase naming convention is purposely similar).</p>\n<p>For example, an <code>Enum</code> version of <code>Expression</code> might look like:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">enum</span> <span class=\"kn\">import</span> <span class=\"n\">Enum</span><span class=\"p\">,</span> <span class=\"n\">auto</span>\n<span class=\"k\">class</span> <span class=\"nc\">EnumExpression</span><span class=\"p\">(</span><span class=\"n\">Enum</span><span class=\"p\">):</span>\n    <span class=\"n\">LITERAL</span> <span class=\"o\">=</span> <span class=\"n\">auto</span><span class=\"p\">()</span>\n    <span class=\"n\">UNARY_MINUS</span> <span class=\"o\">=</span> <span class=\"n\">auto</span><span class=\"p\">()</span>\n    <span class=\"n\">ADD</span> <span class=\"o\">=</span> <span class=\"n\">auto</span><span class=\"p\">()</span>\n    <span class=\"n\">MINUS</span> <span class=\"o\">=</span> <span class=\"n\">auto</span><span class=\"p\">()</span>\n    <span class=\"n\">MULTIPLY</span> <span class=\"o\">=</span> <span class=\"n\">auto</span><span class=\"p\">()</span>\n    <span class=\"n\">DIVIDE</span> <span class=\"o\">=</span> <span class=\"n\">auto</span><span class=\"p\">()</span>\n</pre>\n<p>However, this doesn't allow data to be associated with each of these enum values. A particular value of <code>Expression</code> will tell you about a <em>kind</em> of expression that exists, but the operands to the expressions still have to be stored elsewhere.</p>\n<p>From this perspective, ADTs are like <code>Enum</code>s that can optionally have data associated with each case.</p>\n<h2>Compared to inheritance</h2>\n<p>Algebraic data types are a relatively recent introduction to object-oriented programming languages, for the simple reason that inheritance can replicate the same behavior.</p>\n<p>Continuing our examples with the <code>Expression</code> ADT, here's how one might represent it with inheritance in Python:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">abc</span> <span class=\"kn\">import</span> <span class=\"n\">ABC</span>\n<span class=\"k\">class</span> <span class=\"nc\">ABCExpression</span><span class=\"p\">(</span><span class=\"n\">ABC</span><span class=\"p\">):</span>\n    <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">LiteralExpression</span><span class=\"p\">(</span><span class=\"n\">ABCExpression</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">UnaryMinusExpression</span><span class=\"p\">(</span><span class=\"n\">ABCExpression</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">inner</span><span class=\"p\">:</span> <span class=\"n\">ABCExpression</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">AddExpression</span><span class=\"p\">(</span><span class=\"n\">ABCExpression</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">lhs</span><span class=\"p\">:</span> <span class=\"n\">ABCExpression</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">:</span> <span class=\"n\">ABCExpression</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MinusExpression</span><span class=\"p\">(</span><span class=\"n\">ABCExpression</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">lhs</span><span class=\"p\">:</span> <span class=\"n\">ABCExpression</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">:</span> <span class=\"n\">ABCExpression</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MultiplyExpression</span><span class=\"p\">(</span><span class=\"n\">ABCExpression</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">lhs</span><span class=\"p\">:</span> <span class=\"n\">ABCExpression</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">:</span> <span class=\"n\">ABCExpression</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">DivideExpression</span><span class=\"p\">(</span><span class=\"n\">ABCExpression</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">lhs</span><span class=\"p\">:</span> <span class=\"n\">ABCExpression</span><span class=\"p\">,</span> <span class=\"n\">rhs</span><span class=\"p\">:</span> <span class=\"n\">ABCExpression</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n</pre>\n<p>This is noticeably more verbose, and the code to consume these types gets much more complex as well:</p>\n<pre><span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"n\">ABCExpression</span> <span class=\"o\">=</span> <span class=\"n\">UnaryMinusExpression</span><span class=\"p\">(</span><span class=\"n\">LiteralExpression</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">))</span>  <span class=\"c1\"># Example of creating an expression</span>\n\n<span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">LiteralExpression</span><span class=\"p\">):</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">...</span> <span class=\"c1\"># do something with e.value</span>\n<span class=\"k\">elif</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">UnaryMinusExpression</span><span class=\"p\">):</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">...</span> <span class=\"c1\"># do something with e.inner</span>\n<span class=\"k\">elif</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">AddExpression</span><span class=\"p\">):</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">...</span> <span class=\"c1\"># do something with e.lhs and e.rhs</span>\n<span class=\"k\">elif</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">MinusExpression</span><span class=\"p\">):</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">...</span> <span class=\"c1\"># do something with e.lhs and e.rhs</span>\n<span class=\"k\">elif</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">MultiplyExpression</span><span class=\"p\">):</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">...</span> <span class=\"c1\"># do something with e.lhs and e.rhs</span>\n<span class=\"k\">elif</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">DivideExpression</span><span class=\"p\">):</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">...</span> <span class=\"c1\"># do something with e.lhs and e.rhs</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'Unexpected type of expression: </span><span class=\"si\">{</span><span class=\"n\">e</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n</pre>\n<p>ADTs offer a simple way to define a type which is <em>one of a set of possible cases</em>, and allowing data to be associated with each case and packed/unpacked along with it.</p>\n<h2>Examples in other programming languages</h2>\n<p>Algebraic data types are very common in functional programming languages, like <a href=\"https://www.haskell.org/\" rel=\"nofollow\">Haskell</a> or <a href=\"https://www.scala-lang.org/\" rel=\"nofollow\">Scala</a>, but they're gaining increasing acceptance in \"mainstream\" programming languages as well.</p>\n<p>Here are a few examples.</p>\n<h3><a href=\"https://www.rust-lang.org/\" rel=\"nofollow\">Rust</a></h3>\n<p>Rust <code>enum</code>s are actually full-fledged ADTs. Here's how an <code>Either</code> ADT could be defined:</p>\n<pre><span class=\"k\">enum</span> <span class=\"nc\">Either</span><span class=\"o\">&lt;</span><span class=\"n\">L</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">R</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Left</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">Right</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">),</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</pre>\n<h3><a href=\"https://developer.apple.com/swift/\" rel=\"nofollow\">Swift</a></h3>\n<p><a href=\"https://docs.swift.org/swift-book/LanguageGuide/Enumerations.html\" rel=\"nofollow\">Swift enumerations</a> are very similar to Rust's, and behave like algebraic data types through their support of \"associated values.\"</p>\n<pre><span class=\"kd\">enum</span> <span class=\"nc\">Either</span><span class=\"p\">&lt;</span><span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">R</span><span class=\"p\">&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">case</span> <span class=\"n\">Left</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">)</span>\n    <span class=\"k\">case</span> <span class=\"n\">Right</span><span class=\"p\">(</span><span class=\"n\">R</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</pre>\n<h3><a href=\"https://en.wikipedia.org/wiki/Microsoft_TypeScript\" rel=\"nofollow\">TypeScript</a></h3>\n<p><a href=\"https://en.wikipedia.org/wiki/Microsoft_TypeScript\" rel=\"nofollow\">TypeScript</a> offers ADTs through a language feature known as <a href=\"https://www.typescriptlang.org/docs/handbook/advanced-types.html#discriminated-unions\" rel=\"nofollow\">\"discriminated unions\"</a>.</p>\n<p>See this example from their documentation:</p>\n<pre><span class=\"kr\">interface</span> <span class=\"nx\">Square</span> <span class=\"p\">{</span>\n    <span class=\"nx\">kind</span><span class=\"o\">:</span> <span class=\"s2\">\"square\"</span><span class=\"p\">;</span>\n    <span class=\"nx\">size</span>: <span class=\"kt\">number</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"kr\">interface</span> <span class=\"nx\">Rectangle</span> <span class=\"p\">{</span>\n    <span class=\"nx\">kind</span><span class=\"o\">:</span> <span class=\"s2\">\"rectangle\"</span><span class=\"p\">;</span>\n    <span class=\"nx\">width</span>: <span class=\"kt\">number</span><span class=\"p\">;</span>\n    <span class=\"nx\">height</span>: <span class=\"kt\">number</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"kr\">interface</span> <span class=\"nx\">Circle</span> <span class=\"p\">{</span>\n    <span class=\"nx\">kind</span><span class=\"o\">:</span> <span class=\"s2\">\"circle\"</span><span class=\"p\">;</span>\n    <span class=\"nx\">radius</span>: <span class=\"kt\">number</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">type</span> <span class=\"nx\">Shape</span> <span class=\"o\">=</span> <span class=\"nx\">Square</span> <span class=\"o\">|</span> <span class=\"nx\">Rectangle</span> <span class=\"o\">|</span> <span class=\"nx\">Circle</span><span class=\"p\">;</span>\n</pre>\n<h1>Installation</h1>\n<p>To add <code>adt</code> as a library in your Python project, simply run <code>pip</code> (or <code>pip3</code>, as it may be named on your system):</p>\n<pre><code>pip install algebraic-data-types\n</code></pre>\n<p>This will install <a href=\"https://pypi.org/project/algebraic-data-types/\" rel=\"nofollow\">the latest version from PyPI</a>.</p>\n<h2>mypy plugin</h2>\n<p>The library also comes with a plugin for <a href=\"http://mypy-lang.org/\" rel=\"nofollow\">mypy</a> that enables typechecking of <code>@adt</code> definitions. <strong>If you are already using mypy, the plugin is required to avoid nonsensical type errors.</strong></p>\n<p>To enable the <code>adt</code> typechecking plugin, add the following to a <code>mypy.ini</code> file in your project's working directory:</p>\n<pre><code>[mypy]\nplugins = adt.mypy_plugin\n</code></pre>\n<h1>Defining an ADT</h1>\n<p>To begin defining your own data type, import the <code>@adt</code> decorator and <code>Case[\u2026]</code> annotation:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">adt</span> <span class=\"kn\">import</span> <span class=\"n\">adt</span><span class=\"p\">,</span> <span class=\"n\">Case</span>\n</pre>\n<p>Then, define a new Python class, upon which you apply the <code>@adt</code> decorator:</p>\n<pre><span class=\"nd\">@adt</span>\n<span class=\"k\">class</span> <span class=\"nc\">MyADT1</span><span class=\"p\">:</span>\n    <span class=\"k\">pass</span>\n</pre>\n<p>For each case (variant) that your ADT will have, declare a field with the <code>Case</code> annotation. It's conventional to declare your fields with ALL_UPPERCASE names, but the only true restriction is that they <em>cannot</em> be lowercase.</p>\n<pre><span class=\"nd\">@adt</span>\n<span class=\"k\">class</span> <span class=\"nc\">MyADT2</span><span class=\"p\">:</span>\n    <span class=\"n\">FIRST_CASE</span><span class=\"p\">:</span> <span class=\"n\">Case</span>\n    <span class=\"n\">SECOND_CASE</span><span class=\"p\">:</span> <span class=\"n\">Case</span>\n</pre>\n<p>If you want to associate some data with a particular case, list the type of that data in brackets after <code>Case</code> (similar to the <code>Generic[\u2026]</code> and <code>Tuple[\u2026]</code> annotations from <code>typing</code>). For example, to add a case with an associated string:</p>\n<pre><span class=\"nd\">@adt</span>\n<span class=\"k\">class</span> <span class=\"nc\">MyADT3</span><span class=\"p\">:</span>\n    <span class=\"n\">FIRST_CASE</span><span class=\"p\">:</span> <span class=\"n\">Case</span>\n    <span class=\"n\">SECOND_CASE</span><span class=\"p\">:</span> <span class=\"n\">Case</span>\n    <span class=\"n\">STRING_CASE</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>\n</pre>\n<p>You can build cases with arbitrarily many associated pieces of data, as long as all the types are listed:</p>\n<pre><span class=\"nd\">@adt</span>\n<span class=\"k\">class</span> <span class=\"nc\">MyADT4</span><span class=\"p\">:</span>\n    <span class=\"n\">FIRST_CASE</span><span class=\"p\">:</span> <span class=\"n\">Case</span>\n    <span class=\"n\">SECOND_CASE</span><span class=\"p\">:</span> <span class=\"n\">Case</span>\n    <span class=\"n\">STRING_CASE</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>\n    <span class=\"n\">LOTS_OF_DATA_CASE</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>\n</pre>\n<p>ADTs can also be recursive\u2014i.e., an ADT can itself be stored alongside a specific case\u2014though the class name has to be provided in double quotes (a restriction which also applies to <code>typing</code>).</p>\n<p>A typical example of a recursive ADT is a linked list. Here, the list is also made generic over a type <code>T</code>:</p>\n<pre><span class=\"n\">T</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'T'</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@adt</span>\n<span class=\"k\">class</span> <span class=\"nc\">LinkedList</span><span class=\"p\">(</span><span class=\"n\">Generic</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]):</span>\n    <span class=\"n\">NIL</span><span class=\"p\">:</span> <span class=\"n\">Case</span>\n    <span class=\"n\">CONS</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"s2\">\"LinkedList[T]\"</span><span class=\"p\">]</span>\n</pre>\n<p>See the library's <a href=\"tests/\" rel=\"nofollow\">tests</a> for more examples of complete ADT definitions.</p>\n<h2>Generated functionality</h2>\n<p>Given an ADT defined as follows:</p>\n<pre><span class=\"nd\">@adt</span>\n<span class=\"k\">class</span> <span class=\"nc\">MyADT5</span><span class=\"p\">:</span>\n    <span class=\"n\">EMPTY</span><span class=\"p\">:</span> <span class=\"n\">Case</span>\n    <span class=\"n\">INTEGER</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>\n    <span class=\"n\">STRING_PAIR</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>\n</pre>\n<p>The <code>@adt</code> decorator will automatically generate accessor methods of the following form:</p>\n<pre>    <span class=\"k\">def</span> <span class=\"nf\">empty</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"kc\">None</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">integer</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"o\">...</span> <span class=\"c1\"># unpacks int value and returns it</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">string_pair</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]:</span>\n        <span class=\"o\">...</span> <span class=\"c1\"># unpacks strings and returns them in a tuple</span>\n</pre>\n<p>These accessors can be used to obtain the data associated with the ADT case, but <strong>accessors will throw an exception if the ADT was not constructed with the matching case</strong>. This is a shorthand when you already know the case of an ADT object.</p>\n<p><code>@adt</code> will also automatically generate a pattern-matching method, which can be used when you <em>don't</em> know which case you have ahead of time:</p>\n<pre>    <span class=\"n\">Result</span> <span class=\"o\">=</span> <span class=\"n\">TypeVar</span><span class=\"p\">(</span><span class=\"s1\">'Result'</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">match</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span>\n              <span class=\"n\">empty</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[],</span> <span class=\"n\">Result</span><span class=\"p\">],</span>\n              <span class=\"n\">integer</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Result</span><span class=\"p\">],</span>\n              <span class=\"n\">string_pair</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">Result</span><span class=\"p\">])</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Result</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"o\">...</span> <span class=\"bp\">self</span> <span class=\"n\">was</span> <span class=\"n\">constructed</span> <span class=\"k\">as</span> <span class=\"n\">EMPTY</span> <span class=\"o\">...</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">empty</span><span class=\"p\">()</span>\n        <span class=\"k\">elif</span> <span class=\"o\">...</span> <span class=\"bp\">self</span> <span class=\"n\">was</span> <span class=\"n\">constructed</span> <span class=\"k\">as</span> <span class=\"n\">INTEGER</span> <span class=\"o\">...</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">integer</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">integer</span><span class=\"p\">())</span>\n        <span class=\"k\">elif</span> <span class=\"o\">...</span> <span class=\"bp\">self</span> <span class=\"n\">was</span> <span class=\"n\">constructed</span> <span class=\"k\">as</span> <span class=\"n\">STRING_PAIR</span> <span class=\"o\">...</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">string_pair</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">string_pair</span><span class=\"p\">())</span>\n\n        <span class=\"c1\"># if pattern match is incomplete, an exception is raised</span>\n</pre>\n<p>See the library's <a href=\"tests/\" rel=\"nofollow\">tests</a> for examples of using these generated methods.</p>\n<p><code>@adt</code> will also generate <code>__repr__</code>, <code>__str__</code>, and <code>__eq__</code> methods (only if they are not <a href=\"#custom-methods\" rel=\"nofollow\">defined already</a>), to make ADTs convenient to use by default.</p>\n<h2>Custom methods</h2>\n<p>Arbitrary methods can be defined on ADTs by simply including them in the class definition as normal.</p>\n<p>For example, to build \"safe\" versions of the default accessors on <code>ExampleADT</code>, which return <code>None</code> instead of throwing an exception when the case is incorrect:</p>\n<pre><span class=\"nd\">@adt</span>\n<span class=\"k\">class</span> <span class=\"nc\">ExampleADT</span><span class=\"p\">:</span>\n    <span class=\"n\">EMPTY</span><span class=\"p\">:</span> <span class=\"n\">Case</span>\n    <span class=\"n\">INTEGER</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>\n    <span class=\"n\">STRING_PAIR</span><span class=\"p\">:</span> <span class=\"n\">Case</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span>\n\n    <span class=\"nd\">@property</span>\n    <span class=\"k\">def</span> <span class=\"nf\">safe_integer</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]:</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span><span class=\"n\">empty</span><span class=\"o\">=</span><span class=\"k\">lambda</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span>\n                          <span class=\"n\">integer</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"n\">n</span><span class=\"p\">,</span>\n                          <span class=\"n\">string_pair</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">_a</span><span class=\"p\">,</span> <span class=\"n\">_b</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@property</span>\n    <span class=\"k\">def</span> <span class=\"nf\">safe_string_pair</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]]:</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span><span class=\"n\">empty</span><span class=\"o\">=</span><span class=\"k\">lambda</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span>\n                          <span class=\"n\">integer</span><span class=\"o\">=</span><span class=\"k\">lambda</span><span class=\"p\">:</span> <span class=\"kc\">None</span><span class=\"p\">,</span>\n                          <span class=\"n\">string_pair</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">))</span>\n</pre>\n<p>However, additional fields <em>must not</em> be added to the class, as the decorator will attempt to interpret them as ADT <code>Case</code>s (which will fail).</p>\n\n          </div>"}, "last_serial": 6726246, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "18b67133987107c898122e12c2698014", "sha256": "0a8458e17bb770f79b233b74dcb1a2c4a800ae386e9bbeda95b928e430cca17c"}, "downloads": -1, "filename": "algebraic_data_types-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "18b67133987107c898122e12c2698014", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17126, "upload_time": "2019-07-10T17:58:35", "upload_time_iso_8601": "2019-07-10T17:58:35.695023Z", "url": "https://files.pythonhosted.org/packages/95/df/80c4b04ac37b03d89d6faa80e354432e955478aca21b4890af9a07947d1b/algebraic_data_types-0.1.0-py3-none-any.whl", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "35d87a198ca6029b61c6c9a46b6b506f", "sha256": "fb5559921e5037a261ad1625bbb14ab7dcfade42f59727879c29d46db0e7c5ee"}, "downloads": -1, "filename": "algebraic_data_types-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "35d87a198ca6029b61c6c9a46b6b506f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17280, "upload_time": "2019-09-15T19:42:25", "upload_time_iso_8601": "2019-09-15T19:42:25.387924Z", "url": "https://files.pythonhosted.org/packages/33/de/e6fa9c1e1988aef133661d362d97a94882d2839fdb78565c2e508b34c132/algebraic_data_types-0.1.1-py3-none-any.whl", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "a9488ce39f3afd2fe933a929f9e18690", "sha256": "55ceac4b305cca6d1d2d8302611d3c011356b8fb54abae43d7ab514a6b8613b8"}, "downloads": -1, "filename": "algebraic_data_types-0.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "a9488ce39f3afd2fe933a929f9e18690", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17282, "upload_time": "2019-12-18T19:03:38", "upload_time_iso_8601": "2019-12-18T19:03:38.814869Z", "url": "https://files.pythonhosted.org/packages/91/ab/b5a414de4af1fb325bb011024c42a21aadc153cc283922790c0665bf0beb/algebraic_data_types-0.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "aa3852fc71437dbd82e6088753bdf4ef", "sha256": "e090ac05e8e243e901c0476475c91f0dff691d174b4feade9204b57c255bc49b"}, "downloads": -1, "filename": "algebraic-data-types-0.1.2.tar.gz", "has_sig": false, "md5_digest": "aa3852fc71437dbd82e6088753bdf4ef", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18220, "upload_time": "2019-12-18T19:03:40", "upload_time_iso_8601": "2019-12-18T19:03:40.314467Z", "url": "https://files.pythonhosted.org/packages/fb/43/af1e62c46161aeffa1fdd1a59d84d2fd1cd7731808dc38d5fa1669de2aa4/algebraic-data-types-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "3a6ad008ead375feb21ba1772feba7c4", "sha256": "bbaf314d236977a020df4b5bdb1aeb03a30ec9c2e4053ae280565aa3c449a700"}, "downloads": -1, "filename": "algebraic_data_types-0.1.3-py3-none-any.whl", "has_sig": false, "md5_digest": "3a6ad008ead375feb21ba1772feba7c4", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21831, "upload_time": "2020-02-29T22:44:11", "upload_time_iso_8601": "2020-02-29T22:44:11.282259Z", "url": "https://files.pythonhosted.org/packages/7b/89/92808682e44bcf571cba04dc4cb4683421080657c4d8137e898dd0ee4641/algebraic_data_types-0.1.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2bedb38e4ab1583515b4f5ac22b85f54", "sha256": "3c4df6625a6889a5b64e85f973c6d12da411da9a485095aec99b7e1e36bb50b0"}, "downloads": -1, "filename": "algebraic-data-types-0.1.3.tar.gz", "has_sig": false, "md5_digest": "2bedb38e4ab1583515b4f5ac22b85f54", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21317, "upload_time": "2020-02-29T22:44:12", "upload_time_iso_8601": "2020-02-29T22:44:12.668549Z", "url": "https://files.pythonhosted.org/packages/a9/11/7c47688fe3f87c6964670f022a75530a5acb48871b8bc297d7047af7782c/algebraic-data-types-0.1.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3a6ad008ead375feb21ba1772feba7c4", "sha256": "bbaf314d236977a020df4b5bdb1aeb03a30ec9c2e4053ae280565aa3c449a700"}, "downloads": -1, "filename": "algebraic_data_types-0.1.3-py3-none-any.whl", "has_sig": false, "md5_digest": "3a6ad008ead375feb21ba1772feba7c4", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 21831, "upload_time": "2020-02-29T22:44:11", "upload_time_iso_8601": "2020-02-29T22:44:11.282259Z", "url": "https://files.pythonhosted.org/packages/7b/89/92808682e44bcf571cba04dc4cb4683421080657c4d8137e898dd0ee4641/algebraic_data_types-0.1.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2bedb38e4ab1583515b4f5ac22b85f54", "sha256": "3c4df6625a6889a5b64e85f973c6d12da411da9a485095aec99b7e1e36bb50b0"}, "downloads": -1, "filename": "algebraic-data-types-0.1.3.tar.gz", "has_sig": false, "md5_digest": "2bedb38e4ab1583515b4f5ac22b85f54", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21317, "upload_time": "2020-02-29T22:44:12", "upload_time_iso_8601": "2020-02-29T22:44:12.668549Z", "url": "https://files.pythonhosted.org/packages/a9/11/7c47688fe3f87c6964670f022a75530a5acb48871b8bc297d7047af7782c/algebraic-data-types-0.1.3.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:19:52 2020"}