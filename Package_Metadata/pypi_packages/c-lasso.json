{"info": {"author": "Leo Simpson", "author_email": "leo.bill.simpson@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "Constrained sparse regression functions in Python\n\nTo install the package : \n    pip install c_lasso\n\nTo import the package :\n    import classo\n\n\n1) Different type of problem : \n\t- Least square :             min || Ax-y ||^2 + lambda * ||x||_1\t\t\t\n\t- Huber  :                   min  h_rho(Ax-y) + lambda * ||x||_1\t\n\t- Concomitant Least square : min || Ax-y ||^2/sigma + n*sigma + lambda * ||x||_1\n\t- Concomitant Huber :        min h_rho( (Ax-y)/sigma ) + n)*sigma + lambda * ||x||_1\n\n\n\n2) Different methods for solving the problems : \n\n    Four main methods have been implemented for those.\n\n\n        Forward Backward splitting method:\n            Standard way to solve a convex minimisation problem with an addition of\n            smooth and non-smooth function : Projected Proximal Gradient Descent. This\n            method only works with the two non concomitants problems. For the huber\n            problem, we use the second formulation.\n\n        No-proj method\n            Similar to the Projected Proximal Gradient Descent, but which does not involve\n            a projection, which can be difficult to compute for some matrix C. Only for\n            non concomitant problems.\n\n        Double prox method\n            Use of Doulgas Rachford splitting algorithm which use the proximal operator of\n            both functions. It also solves concomitant problems, but it is usefull even in the\n            non concomitant case because it is usually more efficient than forward backward\n            splitting method. For the huber problem, we use the second formulation, then\n            we change it into a Least square problem of dimension m (m + d) instead of m d.\n\n        ODE method  \n            From the KKT conditions, we can derive an simple ODE for the solution of\n            the non concomitants problems, which shows that the solution is piecewise-\n            affine. For the least square, as the problem can always be reported to a a non\n            concomitant problem for another lambda, one can use the whole non-concomitant-\n            path computed with the ODE method to then solve the concomitant-path.\n\n\n\n3) Two main functions \n\n    For solving the problem for a fix \\lambda : \n\n    fixlasso (matrix, lam, typ ='LS ', meth ='choose ', plot_time =True, plot_sol =True, plot_sigm =True, rho = 1.345)\n\n         -matrix\n            Matrices (A;C; y) of the problem.\n\n         -lam\n            Lambda/lambdamax in [0; 1] where lambdamax is a majoration of the lambda when the solution is null \n            (depends on the type of problem).\n\n         -typ\n            Type of problem : 'Huber', 'Concomitant' , 'Concomitant Huber' or 'LS'. \n            Any other string will set the type of problem to Least Square.\n\n         -meth\n            Method to solve the problem. If wrong input, the algorithm choose the method according to lambda\n                - Possibilities for types 'LS' and 'Huber' : 'FB', 'Noproj', '2prox', 'ODE'.\n                - Possibilities for type 'Concomitant' : '2prox', 'ODE'.\n                - Possibilities for type 'Concomitant Huber' : '2prox'.\n\n         -plot_time\n            If set to True : prints the running time.\n\n         -plot_sol\n            If set to True : plots the solution in a bars diagram.\n\n         -plot_sigm\n            If set to True and the type we solve a concomitant problem : prints sigma/sigmamax.\n\n         -rho\n            Normalized rho for non-concomitant Huber problem : rho * sqrt(m) / norm_inf(y)\n            Unormalized sigma for concomitant Huber problem.\n\n\n         -returns\n            The function returns : \n                An 'numpy.ndarray' type vector representing the solution betafor non concomitant problems, \n                A tuple containing beta and sigma for the concomitant problems.\n\n\n\n\n\n\n    For solving the problem for the whole path :\n\n    pathlasso (matrix, lambdas ='choose ', lamin =1e -2, typ='LS ', meth ='ODE ', plot_time =True, plot_sol =True, plot_sigm =True, rho = 1.345, compare = False )\n\n\n\n        -matrix\n            Matrices (A;C; y) of the problem.\n\n        -lambdas\n            Gives the list of lambda/lambdamax in [0; 1] where we need the problem to be solved. \n            If a boolean is given, it is the next parameter that will give the path.\n\n        -lamin\n            If lambdas is a boolean, it gives the lambda/lambdamax minimum : \n            the algorithm will solve the problem for all lambda in [lamin * lambdamax; lambdamax] \n            (with 100 points).\t\n\n        -typ\n            Type of problem : 'Huber', 'Concomitant' , 'Concomitant Huber' or 'LS'. \n            Any other string will set the type of problem to Least Square.\n\n        -meth\n            Method to solve the problem. If wrong input, the algorithm choose the method according to lambda.\n                - Possibilities for types 'LS' and 'Huber' : 'FB', 'Noproj', '2prox', 'ODE'.\n                - Possibilities for type 'Concomitant' : '2prox', 'ODE'.\n                - Possibilities for type 'Concomitant Huber' : '2prox'.\n\n            For each case except 'ODE', the algorithm solves the problem for each lambda of the path using warm starts.\n\n\n        -plot_time\n            If set to True : prints the running time.\n\n        -plot_sol\n            If set to True : plots the solution in a bars diagram.\n\n        -plot_sigm\n            If set to True and the type we solve a concomitant problem : prints sigma/sigmamax.\n\n        -rho\n            Normalized rho for non-concomitant Huber problem : rho * sqrt(m) / norm_inf(y)\n            Unormalized sigma for concomitant Huber problem.\n\n\n        -returns\n            The function returns :  \n                a list 'numpy.ndarray' type vector representing the solution beta for each lambda ;\n                the list of lambda corresponding (unormalized), \n                also the list of sigmas for the concomitant problems.\n\n\n\n\n\n4) Little functions :\n\n    For computing the theoretical lambda/lambdamax in the case of concomitant problems :  \n\n        model_selection(m,d)\n\n            Where m is the number of sample and d the number of parameter, it returns : lam0 = sqrt(2/m) invPhi(1-t), with invPhi the quantile function for the standard normal distribution, and t is the solution to the equation t*p = invPhi(1-t)**4 + 2*invPhi(1-t)**2\n\n\n\n    For computing the solution using cross-validation and the previous main functions : \n\n        CV(matrices,k=5,typ='LS',test=0.4,lamin=1e-2, print_lam= True)\n\n            Where k is the number of 'cluster' used, test is the proportion of sample kept for testing, and print lam tells us if the function also print the lambda/lambdamax used. The function returns the solution Beta as a 'numpy.ndarray'.\n\n\n\n\n\n\n\n\n\n\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Leo-Simpson/CLasso", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "c-lasso", "package_url": "https://pypi.org/project/c-lasso/", "platform": "", "project_url": "https://pypi.org/project/c-lasso/", "project_urls": {"Homepage": "https://github.com/Leo-Simpson/CLasso"}, "release_url": "https://pypi.org/project/c-lasso/0.1/", "requires_dist": null, "requires_python": "", "summary": "Algorithms for constrained Lasso problems", "version": "0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Constrained sparse regression functions in Python</p>\n<dl>\n<dt>To install the package :</dt>\n<dd>pip install c_lasso</dd>\n<dt>To import the package :</dt>\n<dd>import classo</dd>\n</dl>\n<ol>\n<li><dl>\n<dt>Different type of problem :</dt>\n<dd><ul>\n<li>Least square :             min || Ax-y ||^2 + lambda * ||x||_1</li>\n<li>Huber  :                   min  h_rho(Ax-y) + lambda * ||x||_1</li>\n<li>Concomitant Least square : min || Ax-y ||^2/sigma + n*sigma + lambda * ||x||_1</li>\n<li>Concomitant Huber :        min h_rho( (Ax-y)/sigma ) + n)*sigma + lambda * ||x||_1</li>\n</ul>\n</dd>\n</dl>\n</li>\n<li><p>Different methods for solving the problems :</p>\n<blockquote>\n<p>Four main methods have been implemented for those.</p>\n<blockquote>\n<dl>\n<dt>Forward Backward splitting method:</dt>\n<dd><p>Standard way to solve a convex minimisation problem with an addition of\nsmooth and non-smooth function : Projected Proximal Gradient Descent. This\nmethod only works with the two non concomitants problems. For the huber\nproblem, we use the second formulation.</p>\n</dd>\n<dt>No-proj method</dt>\n<dd><p>Similar to the Projected Proximal Gradient Descent, but which does not involve\na projection, which can be difficult to compute for some matrix C. Only for\nnon concomitant problems.</p>\n</dd>\n<dt>Double prox method</dt>\n<dd><p>Use of Doulgas Rachford splitting algorithm which use the proximal operator of\nboth functions. It also solves concomitant problems, but it is usefull even in the\nnon concomitant case because it is usually more efficient than forward backward\nsplitting method. For the huber problem, we use the second formulation, then\nwe change it into a Least square problem of dimension m (m + d) instead of m d.</p>\n</dd>\n<dt>ODE method</dt>\n<dd><p>From the KKT conditions, we can derive an simple ODE for the solution of\nthe non concomitants problems, which shows that the solution is piecewise-\naffine. For the least square, as the problem can always be reported to a a non\nconcomitant problem for another lambda, one can use the whole non-concomitant-\npath computed with the ODE method to then solve the concomitant-path.</p>\n</dd>\n</dl>\n</blockquote>\n</blockquote>\n</li>\n<li><p>Two main functions</p>\n<blockquote>\n<p>For solving the problem for a fix lambda :</p>\n<p>fixlasso (matrix, lam, typ =\u2019LS \u2018, meth =\u2019choose \u2018, plot_time =True, plot_sol =True, plot_sigm =True, rho = 1.345)</p>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><td>\n<kbd><span class=\"option\">-m<var>atrix</var></span></kbd></td>\n<td><p>Matrices (A;C; y) of the problem.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-l<var>am</var></span></kbd></td>\n<td><p>Lambda/lambdamax in [0; 1] where lambdamax is a majoration of the lambda when the solution is null\n(depends on the type of problem).</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-t<var>yp</var></span></kbd></td>\n<td><p>Type of problem : \u2018Huber\u2019, \u2018Concomitant\u2019 , \u2018Concomitant Huber\u2019 or \u2018LS\u2019.\nAny other string will set the type of problem to Least Square.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-m<var>eth</var></span></kbd></td>\n<td><dl>\n<dt>Method to solve the problem. If wrong input, the algorithm choose the method according to lambda</dt>\n<dd><ul>\n<li>Possibilities for types \u2018LS\u2019 and \u2018Huber\u2019 : \u2018FB\u2019, \u2018Noproj\u2019, \u20182prox\u2019, \u2018ODE\u2019.</li>\n<li>Possibilities for type \u2018Concomitant\u2019 : \u20182prox\u2019, \u2018ODE\u2019.</li>\n<li>Possibilities for type \u2018Concomitant Huber\u2019 : \u20182prox\u2019.</li>\n</ul>\n</dd>\n</dl>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-p<var>lot_time</var></span></kbd></td>\n<td><p>If set to True : prints the running time.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-p<var>lot_sol</var></span></kbd></td>\n<td><p>If set to True : plots the solution in a bars diagram.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-p<var>lot_sigm</var></span></kbd></td>\n<td><p>If set to True and the type we solve a concomitant problem : prints sigma/sigmamax.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-r<var>ho</var></span></kbd></td>\n<td><p>Normalized rho for non-concomitant Huber problem : rho * sqrt(m) / norm_inf(y)\nUnormalized sigma for concomitant Huber problem.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-r<var>eturns</var></span></kbd></td>\n<td><dl>\n<dt>The function returns :</dt>\n<dd><p>An \u2018numpy.ndarray\u2019 type vector representing the solution betafor non concomitant problems,\nA tuple containing beta and sigma for the concomitant problems.</p>\n</dd>\n</dl>\n</td></tr>\n</tbody>\n</table>\n</blockquote>\n<p>For solving the problem for the whole path :</p>\n<p>pathlasso (matrix, lambdas =\u2019choose \u2018, lamin =1e -2, typ=\u2019LS \u2018, meth =\u2019ODE \u2018, plot_time =True, plot_sol =True, plot_sigm =True, rho = 1.345, compare = False )</p>\n<blockquote>\n<table>\n<col>\n<col>\n<tbody>\n<tr><td>\n<kbd><span class=\"option\">-m<var>atrix</var></span></kbd></td>\n<td><p>Matrices (A;C; y) of the problem.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-l<var>ambdas</var></span></kbd></td>\n<td><p>Gives the list of lambda/lambdamax in [0; 1] where we need the problem to be solved.\nIf a boolean is given, it is the next parameter that will give the path.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-l<var>amin</var></span></kbd></td>\n<td><p>If lambdas is a boolean, it gives the lambda/lambdamax minimum :\nthe algorithm will solve the problem for all lambda in [lamin * lambdamax; lambdamax]\n(with 100 points).</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-t<var>yp</var></span></kbd></td>\n<td><p>Type of problem : \u2018Huber\u2019, \u2018Concomitant\u2019 , \u2018Concomitant Huber\u2019 or \u2018LS\u2019.\nAny other string will set the type of problem to Least Square.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-m<var>eth</var></span></kbd></td>\n<td><dl>\n<dt>Method to solve the problem. If wrong input, the algorithm choose the method according to lambda.</dt>\n<dd><ul>\n<li>Possibilities for types \u2018LS\u2019 and \u2018Huber\u2019 : \u2018FB\u2019, \u2018Noproj\u2019, \u20182prox\u2019, \u2018ODE\u2019.</li>\n<li>Possibilities for type \u2018Concomitant\u2019 : \u20182prox\u2019, \u2018ODE\u2019.</li>\n<li>Possibilities for type \u2018Concomitant Huber\u2019 : \u20182prox\u2019.</li>\n</ul>\n</dd>\n</dl>\n<p>For each case except \u2018ODE\u2019, the algorithm solves the problem for each lambda of the path using warm starts.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-p<var>lot_time</var></span></kbd></td>\n<td><p>If set to True : prints the running time.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-p<var>lot_sol</var></span></kbd></td>\n<td><p>If set to True : plots the solution in a bars diagram.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-p<var>lot_sigm</var></span></kbd></td>\n<td><p>If set to True and the type we solve a concomitant problem : prints sigma/sigmamax.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-r<var>ho</var></span></kbd></td>\n<td><p>Normalized rho for non-concomitant Huber problem : rho * sqrt(m) / norm_inf(y)\nUnormalized sigma for concomitant Huber problem.</p>\n</td></tr>\n<tr><td>\n<kbd><span class=\"option\">-r<var>eturns</var></span></kbd></td>\n<td><dl>\n<dt>The function returns :</dt>\n<dd><p>a list \u2018numpy.ndarray\u2019 type vector representing the solution beta for each lambda ;\nthe list of lambda corresponding (unormalized),\nalso the list of sigmas for the concomitant problems.</p>\n</dd>\n</dl>\n</td></tr>\n</tbody>\n</table>\n</blockquote>\n</blockquote>\n</li>\n<li><p>Little functions :</p>\n<blockquote>\n<p>For computing the theoretical lambda/lambdamax in the case of concomitant problems :</p>\n<blockquote>\n<p>model_selection(m,d)</p>\n<blockquote>\n<p>Where m is the number of sample and d the number of parameter, it returns : lam0 = sqrt(2/m) invPhi(1-t), with invPhi the quantile function for the standard normal distribution, and t is the solution to the equation t*p = invPhi(1-t)**4 + 2*invPhi(1-t)**2</p>\n</blockquote>\n</blockquote>\n<p>For computing the solution using cross-validation and the previous main functions :</p>\n<blockquote>\n<p>CV(matrices,k=5,typ=\u2019LS\u2019,test=0.4,lamin=1e-2, print_lam= True)</p>\n<blockquote>\n<p>Where k is the number of \u2018cluster\u2019 used, test is the proportion of sample kept for testing, and print lam tells us if the function also print the lambda/lambdamax used. The function returns the solution Beta as a \u2018numpy.ndarray\u2019.</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</li>\n</ol>\n\n          </div>"}, "last_serial": 5579024, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "f1f0b15bd80101b60b106bddc767d2e9", "sha256": "f52e4e3a3a29bb7c5198464248a4b650be49d7ac876e997ba568dafab3694e47"}, "downloads": -1, "filename": "c_lasso-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "f1f0b15bd80101b60b106bddc767d2e9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 29180, "upload_time": "2019-07-19T00:09:41", "upload_time_iso_8601": "2019-07-19T00:09:41.281372Z", "url": "https://files.pythonhosted.org/packages/3f/82/539ad5c753b456fb0e54b42bf03816edf2f6b11cb994be3ed9f1900847a7/c_lasso-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "08d4d050eaac3a0c36398e6a37544567", "sha256": "4c033448dc3a83b813a7f4c3dc458cdb021dce303993ecb4890c1a276a80b2f8"}, "downloads": -1, "filename": "c_lasso-0.1.tar.gz", "has_sig": false, "md5_digest": "08d4d050eaac3a0c36398e6a37544567", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17710, "upload_time": "2019-07-19T00:09:44", "upload_time_iso_8601": "2019-07-19T00:09:44.438214Z", "url": "https://files.pythonhosted.org/packages/57/13/6d90e37a5afce90d7b55ddf22ae733c18e6bd259a29e165b8da797cc6a27/c_lasso-0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f1f0b15bd80101b60b106bddc767d2e9", "sha256": "f52e4e3a3a29bb7c5198464248a4b650be49d7ac876e997ba568dafab3694e47"}, "downloads": -1, "filename": "c_lasso-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "f1f0b15bd80101b60b106bddc767d2e9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 29180, "upload_time": "2019-07-19T00:09:41", "upload_time_iso_8601": "2019-07-19T00:09:41.281372Z", "url": "https://files.pythonhosted.org/packages/3f/82/539ad5c753b456fb0e54b42bf03816edf2f6b11cb994be3ed9f1900847a7/c_lasso-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "08d4d050eaac3a0c36398e6a37544567", "sha256": "4c033448dc3a83b813a7f4c3dc458cdb021dce303993ecb4890c1a276a80b2f8"}, "downloads": -1, "filename": "c_lasso-0.1.tar.gz", "has_sig": false, "md5_digest": "08d4d050eaac3a0c36398e6a37544567", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17710, "upload_time": "2019-07-19T00:09:44", "upload_time_iso_8601": "2019-07-19T00:09:44.438214Z", "url": "https://files.pythonhosted.org/packages/57/13/6d90e37a5afce90d7b55ddf22ae733c18e6bd259a29e165b8da797cc6a27/c_lasso-0.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:19:08 2020"}