{"info": {"author": "Bj\u00f6rn Puttmann", "author_email": "nospam@poitin.de", "bugtrack_url": null, "classifiers": ["Intended Audience :: System Administrators", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: System :: Logging"], "description": ".. image:: https://readthedocs.org/projects/lumbermill/badge/?version=latest\n   :target: http://lumbermill.readthedocs.org/en/latest/?badge=latest\n   :alt: Documentation Status\n.. image:: https://travis-ci.org/dstore-dbap/LumberMill.svg?branch=master\n   :target: https://travis-ci.org/dstore-dbap/LumberMill\n.. image:: https://coveralls.io/repos/dstore-dbap/LumberMill/badge.svg?branch=master&service=github :target: https://coveralls.io/github/dstore-dbap/LumberMill?branch=master\n\nLumberMill\n===========\n\nIntroduction\n''''''''''''\n\nCollect, parse and store logs with a configurable set of modules.\nInspired by `logstash <https://github.com/elasticsearch/logstash>`_ but\nwith a smaller memory footprint and faster startup time.\n\nCompatibility and Performance\n'''''''''''''''''''''''''''''\nTo run LumberMill you will need Python 2.7+.\nFor better performance, I heartly recommend running LumberMill with pypy.\nThe performance gain can be up to 5-6 times events/s throughput running single processed.\nTested with pypy-2.4, pypy-2.5 and pypy-4.1.\nA small benchmark comparing the performance of different python/pypy versions and logstash-1.4.2 can be found `here  <http://www.netprojects.de/simple-benchmark-of-lumbermill/>`_.\n\nInstallation\n''''''''''''\n\n**via pypi**\n\n::\n\n   pip install LumberMill\n\n**manually**\n\nClone the github repository to /opt/LumberMill (or any other location that fits you better :):\n\n::\n\n     git clone https://github.com/dstore-dbap/LumberMill.git /opt/LumberMill\n\nInstall the dependencies with pip:\n\n::\n\n     cd /opt/LumberMill\n     python setup.py install\n\nYou may need the MaxMind geo database. Install it with:\n\n::\n\n    mkdir /usr/share/GeoIP\n    cd /usr/share/GeoIP\n    wget \"http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz\"\n    gunzip GeoLiteCity.dat.gz\n\nNow you can give LumberMill a testdrive with:\n\n::\n\n    wget https://raw.githubusercontent.com/dstore-dbap/LumberMill/master/conf/example-stdin.conf\n    echo \"I'm a lumberjack, and I'm okay\" | lumbermill -c ./example-stdin.conf\n\nIf you get a \"command not found\" please check your pythonpath setting. Depending on how you installed LumberMill,\nthe executable can either be found in the bin dir of your python environment (e.g. /usr/lib64/pypy-2.4.0/bin/lumbermill)\nor in your default path (e.g. /usr/local/bin/lumbermill).\n\nOther basic configuration examples: https://github.com/dstore-dbap/LumberMill/tree/master/conf/.\n\nFor a how-to running LumberMill, Elasticsearch and Kibana on CentOS, feel free to visit\nhttp://www.netprojects.de/collect-visualize-your-logs-with-lumbermill-and-elasticsearch-on-centos/.\n\nConfiguration example (with explanations)\n'''''''''''''''''''''''''''''''''''''''''\n\nTo give a short introduction of how LumberMill works, here is a sample\nconfiguration.\nIts receiving apache and nginx access logs via syslog messages from a\nsyslog server and msgpacked events from\n`python-beaver <https://github.com/josegonzalez/python-beaver>`_ and\nstores them in an elasticsearch backend.\nBelow, I will explain each section in more detail.\n\n::\n\n    # Sets number of parallel LumberMill processes.\n    - Global:\n       workers: 2\n\n    # Listen on all interfaces, port 5151.\n    - TcpServer:\n       port: 5151\n       receivers:\n        - RegexParser\n\n    # Listen on all interfaces, port 5152.\n    - TcpServer:\n       port: 5152\n       mode: stream\n       chunksize: 32768\n\n    # Decode msgpacked data.\n    - MsgPackParser:\n       mode: stream\n\n    # Extract fields.\n    - RegexParser:\n       source_field: data\n       hot_rules_first: True\n       field_extraction_patterns:\n        - httpd_access_log: '(?P<remote_ip>\\d+\\.\\d+\\.\\d+\\.\\d+)\\s+(?P<identd>\\w+|-)\\s+(?P<user>\\w+|-)\\s+\\[(?P<datetime>\\d+\\/\\w+\\/\\d+:\\d+:\\d+:\\d+\\s.\\d+)\\]\\s+\\\"(?P<url>.*)\\\"\\s+(?P<http_status>\\d+)\\s+(?P<bytes_send>\\d+)'\n        - http_common_access_log: '(?P<remote_ip>\\d+\\.\\d+\\.\\d+\\.\\d+)\\s(?P<x_forwarded_for>\\d+\\.\\d+\\.\\d+\\.\\d+)\\s(?P<identd>\\w+|-)\\s(?P<user>\\w+|-)\\s\\[(?P<datetime>\\d+\\/\\w+\\/\\d+:\\d+:\\d+:\\d+\\s.\\d+)\\]\\s\\\"(?P<url>.*)\\\"\\s(?P<http_status>\\d+)\\s(?P<bytes_send>\\d+)'\n        - iptables: '(?P<syslog_prival>\\<\\d+\\>)(?P<log_timestamp>\\w+\\s+\\d+\\s+\\d+:\\d+:\\d+)\\s+(?P<host>[\\w\\-\\._]+)\\s+kernel:.*?\\ iptables\\ (?P<iptables_action>.*?)\\ :\\ IN=(?P<iptables_in_int>.*?)\\ OUT=(?P<iptables_out_int>.*?)\\ SRC=(?P<iptables_src>.*?)\\ DST=(?P<iptables_dst>.*?)\\ LEN=(?P<iptables_len>.*?)\\ .*?PROTO=(?P<iptables_proto>.*?)\\ SPT=(?P<iptables_spt>.*?)\\ DPT=(?P<iptables_dpt>.*?)\\ WINDOW=.*'\n       receivers:\n        - SimpleStats:\n           filter: $(lumbermill.event_type) != 'Unknown'\n        # Print out messages that did not match\n        - StdOutSink:\n           filter: $(lumbermill.event_type) == 'Unknown'\n\n    # Print out some stats every 10 seconds.\n    - SimpleStats:\n       interval: 10\n\n    # Extract the syslog prival from events received via syslog.\n    - SyslogPrivalParser:\n       source_field: syslog_prival\n\n    # Add a timestamp field.\n    - AddDateTime:\n       format: '%Y-%m-%dT%H:%M:%S.%f'\n       target_field: \"@timestamp\"\n\n    # Add geo info based on the lookup_fields. The first field in <source_fields> that yields a result from geoip will be used.\n    - AddGeoInfo:\n       geoip_dat_path: /usr/share/GeoIP/GeoLiteCity.dat\n       source_fields: [x_forwarded_for, remote_ip]\n       geo_info_fields: ['latitude', 'longitude', 'country_code']\n\n    # Nginx logs request time in seconds with milliseconds as float. Apache logs microseconds as int.\n    # At least cast nginx to integer.\n    - Math:\n       filter: if $(server_type) == \"nginx\"\n       target_field: request_time\n       function: float($(request_time)) * 1000\n\n    # Map field values of <source_field> to values in <map>.\n    - ModifyFields:\n       filter: if $(http_status)\n       action: map\n       source_field: http_status\n       map: {100: 'Continue', 200: 'OK', 301: 'Moved Permanently', 302: 'Found', 304: 'Not Modified', 400: 'Bad Request', 401: 'Unauthorized', 403: 'Forbidden', 404: 'Not Found', 500: 'Internal Server Error', 502: 'Bad Gateway'}\n\n    # Kibana\u2019s \u2018bettermap\u2019 panel needs an array of floats in order to plot events on map.\n    - ModifyFields:\n       filter: if $(latitude)\n       action: merge\n       source_fields: [longitude, latitude]\n       target_field: geoip\n\n    # Extarct some fields from the user agent data.\n    - UserAgentParser:\n       source_fields: user_agent\n\n    # Parse the url into its components.\n    - UrlParser:\n       source_field: uri\n       target_field: uri_parsed\n       parse_querystring: True\n       querystring_target_field: params\n\n    # Store events in elastic search.\n    - ElasticSearchSink:\n       nodes: [localhost]\n       store_interval_in_secs: 5\n\n    - StdOutSink\n\nLet me explain it in more detail:\n\n::\n\n    # Sets number of parallel LumberMill processes.\n    - Global:\n       workers: 2\n\nThe Global section lets you configure some global properties of\nLumberMill. Here the number of parallel processes is set. In order to\nbe able to use multiple cores with python (yay to the\n`GIL <http://www.dabeaz.com/GIL/>`_) LumberMill can be started with\nmultiple parallel processes.\nDefault number of workers is CPU\\_COUNT - 1.\n\n::\n\n    # Listen on all interfaces, port 5151.\n    - TcpServer:\n       port: 5151\n       receivers:\n        - RegexParser\n\nStarts a tcp server listening on all local interfaces port 5151. Each\nmodule comes with a set of default values, so you only need to provide\nsettings you need to customize.\nFor a description of the default values of a module, refer to the\nREADME.md in the modules directory or its docstring.\nBy default, a module will send its output to the next module in the\nconfiguration. To set a custom receiver, set the receivers value.\nThis module will send its output directly to RegexParser.\n\n::\n\n    # Listen on all interfaces, port 5152.\n    - TcpServer:\n       port: 5152\n       mode: stream\n       chunksize: 32768\n\nAlso starts a tcp server, listening on port 5152. The first tcp server\nuses newline as separator (which is the default) for each received\nevent.\nHere, the sever reads in max. 32k of data and passes this on to the next\nmodule.\n\n::\n\n    # Decode msgpacked data.\n    - MsgPackParser:\n       mode: stream\n\nDecode the received data from the above tcp server in msgpack format.\nThis can be used to e.g. handle data send via\n`python-beaver <https://github.com/josegonzalez/python-beaver>`_\n\n::\n\n    # Extract fields.\n    - RegexParser:\n       source_field: data\n       hot_rules_first: True\n       field_extraction_patterns:\n        - httpd_access_log: '(?P<remote_ip>\\d+\\.\\d+\\.\\d+\\.\\d+)\\s+(?P<identd>\\w+|-)\\s+(?P<user>\\w+|-)\\s+\\[(?P<datetime>\\d+\\/\\w+\\/\\d+:\\d+:\\d+:\\d+\\s.\\d+)\\]\\s+\\\"(?P<url>.*)\\\"\\s+(?P<http_status>\\d+)\\s+(?P<bytes_send>\\d+)'\n        - http_common_access_log: '(?P<remote_ip>\\d+\\.\\d+\\.\\d+\\.\\d+)\\s(?P<x_forwarded_for>\\d+\\.\\d+\\.\\d+\\.\\d+)\\s(?P<identd>\\w+|-)\\s(?P<user>\\w+|-)\\s\\[(?P<datetime>\\d+\\/\\w+\\/\\d+:\\d+:\\d+:\\d+\\s.\\d+)\\]\\s\\\"(?P<url>.*)\\\"\\s(?P<http_status>\\d+)\\s(?P<bytes_send>\\d+)'\n        - iptables: '(?P<syslog_prival>\\<\\d+\\>)(?P<log_timestamp>\\w+\\s+\\d+\\s+\\d+:\\d+:\\d+)\\s+(?P<host>[\\w\\-\\._]+)\\s+kernel:.*?\\ iptables\\ (?P<iptables_action>.*?)\\ :\\ IN=(?P<iptables_in_int>.*?)\\ OUT=(?P<iptables_out_int>.*?)\\ SRC=(?P<iptables_src>.*?)\\ DST=(?P<iptables_dst>.*?)\\ LEN=(?P<iptables_len>.*?)\\ .*?PROTO=(?P<iptables_proto>.*?)\\ SPT=(?P<iptables_spt>.*?)\\ DPT=(?P<iptables_dpt>.*?)\\ WINDOW=.*'\n       receivers:\n        - SimpleStats:\n           filter: $(lumbermill.event_type) != 'Unknown'\n        # Print out messages that did not match\n        - StdOutSink:\n           filter: $(lumbermill.event_type) == 'Unknown'\n\nUse regular expressions to extract fields from a log event.\nsource\\_field sets the field to apply the regex to.\nWith hot\\_rules\\_first set to True, the expressions will be applied in\norder of their hit counts.\nhttpd\\_access\\_log will set the event type to \"httpd\\_access\\_log\" if\nthe expression matches.\nNamed groups are used to set the field names. Grok patterns from\nLogstash can also be used.\nIn the receivers section, we can find output filters. These can be used\nto only send selected events to the receiving module.\nAs to the notation of event fields in such filters, please refer to the\n\"Event field notation\" section later in this document.\nIn this example the output filter uses the event metadata lumbermill\nfield. This data is set by LumberMill for every event received and\nwould look like this:\n\n::\n\n       'lumbermill': {'event_id': '90818a85f3aa3af302390bbe77fbc1c87800',\n                       'event_type': 'Unknown',\n                       'pid': 7800,\n                       'received_by': 'vagrant-centos65.vagrantup.com',\n                       'received_from': '127.0.0.1:61430',\n                       'source_module': 'TcpServer'}}\n\nThis data is stored in a separate field to make it easier to drop it\nprior to store it in some backend.\n\n::\n\n    # Print out some stats every 10 seconds.\n    - SimpleStats:\n       interval: 10\n\nPrints out some simple stats every interval seconds.\n\n::\n\n    # Extract the syslog prival from events received via syslog.\n    - SyslogPrivalParser:\n       source_field: syslog_prival\n\nParses syslog prival values to human readable ones based on\n`RFC5424 <http://tools.ietf.org/html/rfc5424>`_.\n\n::\n\n    # Add a timestamp field.\n    - AddDateTime:\n       format: '%Y-%m-%dT%H:%M:%S.%f'\n       target_field: \"@timestamp\"\n\nAdds a timestamp field to the event. When you want to use kibana to view\nyour event data, this field is required.\n\n::\n\n    # Add geo info based on the lookup_fields. The first field in <source_fields> that yields a result from geoip will be used.\n    - AddGeoInfo:\n       geoip_dat_path: /usr/share/GeoIP/GeoLiteCity.dat\n       source_fields: [x_forwarded_for, remote_ip]\n       geo_info_fields: ['latitude', 'longitude', 'country_code']\n\nAdds geo information fields to the event based on ip addresses found in\nsource\\_fields. The first ip address in source\\_fields that yields a\nresult will be used.\n\n::\n\n    # Nginx logs request time in seconds with milliseconds as float. Apache logs microseconds as int.\n    # At least cast nginx to integer.\n    - Math:\n       filter: if $(server_type) == \"nginx\"\n       target_field: request_time\n       function: float($(request_time)) * 1000\n\nAs it says in the comment. Nginx and apache use different time formats\nfor the request time field. This module lets you adjust the field to\naccommodate for that.\nAlso an input filter is used here. Only matching events will be modified\nby this module.\n\n::\n\n    # Map field values of <source_field> to values in <map>.\n    - ModifyFields:\n       filter: if $(http_status)\n       action: map\n       source_field: http_status\n       map: {100: 'Continue', 200: 'OK', 301: 'Moved Permanently', 302: 'Found', 304: 'Not Modified', 400: 'Bad Request', 401: 'Unauthorized', 403: 'Forbidden', 404: 'Not Found', 500: 'Internal Server Error', 502: 'Bad Gateway'}\n\nThis module shows how you can map event fields to new values. In this\nexample numeric http status codes are mapped to human readable values.\n\n::\n\n    # Kibana\u2019s \u2018bettermap\u2019 panel needs an array of floats in order to plot events on map.\n    - ModifyFields:\n       filter: if $(latitude)\n       action: merge\n       source_fields: [longitude, latitude]\n       target_field: geoip\n\nKibanas bettermap module expects the geodata to be found in one single\nfield. With this module the fields longitude and latitude are merged\ninto the geoip field.\n\n::\n\n    # Extarct some fields from the user agent data.\n    - UserAgentParser:\n       source_fields: user_agent\n       target_field: user_agent_info\n\nExtract user agent information from the user\\_agent field. This module\nwill set fields like user\\_agent\\_info.bot,\nuser\\_agent\\_info.browser.name etc.\n\n::\n\n    # Parse the url into its components.\n    - UrlParser:\n       source_field: uri\n       target_field: uri_parsed\n       parse_querystring: True\n       querystring_target_field: params\n\nExtract details from the uri field. This module will set fields like\nuri\\_parsed.scheme, uri\\_parsed.path, uri\\_parsed.query etc.\n\n::\n\n    # Store events in elastic search.\n    - ElasticSearchSink:\n       nodes: [localhost]\n       store_interval_in_secs: 5\n\nSend the received events to elasticsearch servers. nodes will set the\nnodes to connect to.\n\n::\n\n    - StdOutSink\n\nEvents received by this module will be printed out to stdout. The\nRegexParser module was configured to send unmatched events to this\nmodule.\n\nThe different modules can be combined in any order.\n\nTo run LumberMill you will need Python 2.5+.\nFor better performance I recommend running LumberMill with pypy. Tested\nwith pypy-2.0.2, pypy-2.2.1, pypy-2.3 and pypy-2.4.\nFor IPC ZeroMq is used instead of the default multiprocessing.Queue.\nThis resulted in nearly 3 times of the performance with\nmultiprocessing.Queue.\n\nWorking modules\n'''''''''''''''\n\nEvent inputs\n^^^^^^^^^^^^\n\n-  ElasticSearch, get documents from elasticsearch.\n-  Kafka, receive events from apache kafka.\n-  NmapScanner, scan network with nmap and emit result as new event.\n-  RedisChannel, read events from redis channels.\n-  RedisList, read events from redis lists.\n-  Sniffer, sniff network traffic.\n-  Spam, what it says on the can - spams LumberMill for testing.\n-  SQS, read messages from amazons simple queue service.\n-  StdIn, read stream from standard in.\n-  TcpServer, read stream from a tcp socket.\n-  UdpServer, read data from udp socket.\n-  UnixSocket, read stream from a named socket on unix like systems.\n-  Zmq, read events from a zeromq.\n\nEvent parsers\n^^^^^^^^^^^^^\n\n-  Base64Parser, parse base64 data.\n-  CollectdParser, parse collectd binary protocol data.\n-  CSVParser, parse a char separated string.\n-  DomainNameParser, parse a domain name or url to tld, subdomain etc. parts.\n-  InflateParser, inflates any fields with supported compression codecs.\n-  JsonParser, parse a json formatted string.\n-  LineParser, split lines at a seperator and emit each line as new\n   event.\n-  MsgPackParser, parse a msgpack encoded string.\n-  RegexParser, parse a string using regular expressions and named\n   capturing groups.\n-  SyslogPrivalParser, parse the syslog prival value (RFC5424).\n-  UrlParser, parse the query string from an url.\n-  UserAgentParser, parse a http user agent string.\n-  XPathParser, parse an XML document via an xpath expression.\n\nEvent modifiers\n^^^^^^^^^^^^^^^\n\n-  AddDateTime, adds a timestamp field.\n-  AddDnsLookup. adds dns data.\n-  AddGeoInfo, adds geo info fields.\n-  DropEvent, discards event.\n-  ExecPython, execute custom python code.\n-  Facet, collect all encountered variations of en event value over a\n   configurable period of time.\n-  HttpRequest, execute an arbritrary http request and store result.\n-  Math, execute arbitrary math functions.\n-  MergeEvent, merge multiple events to one single event.\n-  ModifyFields, some methods to change extracted fields, e.g. insert,\n   delete, replace, castToInteger etc.\n-  Permutate, takes a list in the event data emits events for all\n   possible permutations of that list.\n\nOutputs\n^^^^^^^\n\n-  DevNullSink, discards all data that it receives.\n-  ElasticSearchSink, stores data entries in an elasticsearch index.\n-  FileSink, store events in a file.\n-  GraphiteSink, send metrics to graphite server.\n-  LoggerSink, sends data to lumbermill internal logger for output.\n-  MongoDbSink, stores data entries in a mongodb index.\n-  RedisChannelSink, publish incoming events to redis channel.\n-  RedisListSink, publish incoming events to redis list.\n-  StdOutSink, prints all received data to standard out.\n-  SQSSink, sends events to amazons simple queue service.\n-  SyslogSink, send events to syslog.\n-  WebHdfsSink, store events in hdfs via webhdfs.\n-  ZmqSink, sends incoming event to zeromq.\n\nMisc modules\n^^^^^^^^^^^^\n\n-  EventBuffer, store received events in a persistent backend until the\n   event was successfully handled.\n-  KeyValueStore, simple wrapper around the python simplekv module.\n-  RedisStore, use redis to store and retrieve values, e.g. to store the\n   result of the XPathParser modul.\n-  SimpleStats, simple statistic module just for event rates etc.\n-  Statistics, more versatile. Configurable fields for collecting\n   statistic data.\n-  Tarpit, slows event propagation down - for testing.\n-  Throttle, throttle event count over a given time period.\n\nCluster modules\n^^^^^^^^^^^^^^^\n\n-  Pack, base pack module. Handles pack leader and pack member\n   discovery.\n-  PackConfiguration, syncs leader configuration to pack members.\n\nWebserver modules\n^^^^^^^^^^^^^^^^^\n\n-  WebGui, a web interface to LumberMill.\n-  WebserverTornado, base webserver module. Handles all incoming\n   requests.\n\nEvent flow basics\n'''''''''''''''''\n\n-  an input module receives an event.\n-  the event data will be wrapped in a default event dictionary of the\n   following structure: { \"data\": payload, \"lumbermill\": { \"event\\_id\":\n   unique event id, \"event\\_type\": \"Unknown\", \"received\\_from\": ip\n   address of sender, \"source\\_module\": caller\\_class\\_name, } }\n-  the input module sends the new event to its receivers. Either by\n   adding it to a queue or by calling the receivers handleEvent method.\n-  if no receivers are configured, the next module in config will be the\n   default receiver.\n-  each following module will process the event via its handleEvent\n   method and pass it on to its receivers.\n-  each module can have an input filter and an output filter to manage\n   event propagation through the modules.\n-  output modules can not have receivers.\n\nConfiguration basics\n''''''''''''''''''''\n\nThe configuration is stored in a yaml formatted file. Each module\nconfiguration follows the same pattern:\n\n::\n\n    - SomeModuleName:\n        id: AliasModuleName                     # <default: \"\"; type: string; is: optional>\n        filter: if $(cache_status) == \"-\"\n        add_fields: {'my_new_field': 'my_new_value'}\n        delete_fields: ['drop_this_field', 'drop_that_field']\n        event_type: my_custom_type\n        receivers:\n         - ModuleName\n         - ModuleAlias:\n             filter: if $('event_type') == 'httpd_access_log'\n\n-  module: specifies the module name and maps to the class name of the\n   module.\n-  id: use to set an alias name if you run more than just one instance\n   of a module.\n-  filter: apply a filter to incoming events. Only matching events will\n   be handled by this module.\n-  add\\_fields: if the event is handled by the module add this fields to\n   the event.\n-  delete\\_fields: if the event is handled by the module delete this\n   fields from the event.\n-  event\\_type: if the event is handled by the module set event\\_type to\n   this value.\n-  receivers: ModuleName or id of the receiving modules. If a filter is\n   provided, only matching events will be send to receiver. If no\n   receivers are configured, the next module in config will be the\n   default receiver.\n\nFor modules that support the storage of intermediate values in redis: \\*\nconfiguration['redis-client']: name of the redis client as set in the\nconfiguration. \\* configuration['redis-key']: key used to store the data\nin redis. \\* configuration['redis-ttl']: ttl of the stored data in\nredis.\n\nFor configuration details of each module refer to its docstring.\n\nEvent field notation\n''''''''''''''''''''\n\nThe following examples refer to this event data:\n\n::\n\n    {'bytes_send': '3395',\n     'data': '192.168.2.20 - - [28/Jul/2006:10:27:10 -0300] \"GET /wiki/Monty_Python/?spanish=inquisition HTTP/1.0\" 200 3395\\n',\n     'datetime': '28/Jul/2006:10:27:10 -0300',\n     'lumbermill': {\n                    'event_id': '715bd321b1016a442bf046682722c78e',\n                    'event_type': 'httpd_access_log',\n                    \"received_from\": '127.0.0.1',\n                    \"source_module\": 'StdIn',\n      },\n     'http_status': '200',\n     'identd': '-',\n     'remote_ip': '192.168.2.20',\n     'url': 'GET /wiki/Monty_Python/?spanish=inquisition HTTP/1.0',\n     'fields': ['nobody', 'expects', 'the'],\n     'params':  { u'spanish': [u'inquisition']},\n     'user': '-'}\n\nNotation in configuration fields like source\\_field or target\\_field\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nJust use the field name. If referring to a nested dict or a list, use\ndots:\n\n::\n\n    - RegexParser:\n        source_field: fields.2\n\n    - RegexParser:\n        source_field: params.spanish\n\nNotation in strings\n^^^^^^^^^^^^^^^^^^^\n\nUse $(variable\\_name) notation. If referring to a nested dict or a list,\nuse dots:\n\n::\n\n    - ElasticSearchSink:\n        index_name: 1perftests\n        doc_id: $(fields.0)-$(params.spanish.0)\n\nNotation in module filters\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUse $(variable\\_name) notation. If referring to a nested dict, use dots:\n\n::\n\n    - StdOutSink:\n        filter: if $(fields.0) == \"nobody\" and $(params.spanish.0) == 'inquisition'\n\nFilters\n-------\n\nModules can have an input filter:\n\n::\n\n    - StdOutSink:\n        filter: if $(remote_ip) == '192.168.2.20' and re.match('^GET', $(url))\n\nModules can have an output filter:\n\n::\n\n    - RegexParser:\n        ...\n        receivers:\n          - StdOutSink:\n              filter: if $(remote_ip) == '192.168.2.20' and re.match('^GET', $(url))\n\n\n\nA rough sketch for using LumberMill with syslog-ng\n'''''''''''''''''''''''''''''''''''''''''''''''''''\n\nSend e.g. apache access logs to syslog (/etc/httpd/conf/httpd.conf):\n\n::\n\n    ...\n    CustomLog \"| /usr/bin/logger -p local1.info -t apache2\" common\n    ...\n\nConfigure the linux syslog-ng service to send data to a tcp address\n(/etc/syslog-ng.conf):\n\n::\n\n    ...\n    destination d_gambolputty { tcp( localhost port(5151) ); };\n    filter f_httpd_access { facility(local1); };\n    log { source(s_sys); filter(f_httpd_access); destination(d_gambolputty); flags(final);};\n    ... \n\nConfigure LumberMill to listen on localhost\n5151(./conf/lumbermill.conf):\n\n::\n\n    ...\n    - TcpServer:\n        interface: localhost\n        port: 5151\n    ...", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/dstore-dbap/LumberMill/", "keywords": null, "license": "LICENSE", "maintainer": null, "maintainer_email": null, "name": "LumberMill", "package_url": "https://pypi.org/project/LumberMill/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/LumberMill/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/dstore-dbap/LumberMill/"}, "release_url": "https://pypi.org/project/LumberMill/0.9.0.2/", "requires_dist": null, "requires_python": null, "summary": "A logparser with module support.", "version": "0.9.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"http://lumbermill.readthedocs.org/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/184217a9e13a8cc86636c1f62bfa9a75d023c90d/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f6c756d6265726d696c6c2f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<a href=\"https://travis-ci.org/dstore-dbap/LumberMill\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/dstore-dbap/LumberMill.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1c5b1c5fcddd0c5945ad50cc54c5282a40cc1da2/68747470733a2f2f7472617669732d63692e6f72672f6473746f72652d646261702f4c756d6265724d696c6c2e7376673f6272616e63683d6d6173746572\"></a>\n<img alt=\"https://coveralls.io/repos/dstore-dbap/LumberMill/badge.svg?branch=master&amp;service=github:target:https://coveralls.io/github/dstore-dbap/LumberMill?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8efcf0bdfcee5ec40ddaf9e254de9e85608517b7/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6473746f72652d646261702f4c756d6265724d696c6c2f62616467652e7376673f6272616e63683d6d617374657226736572766963653d6769746875623a7461726765743a68747470733a2f2f636f766572616c6c732e696f2f6769746875622f6473746f72652d646261702f4c756d6265724d696c6c3f6272616e63683d6d6173746572\">\n<div id=\"lumbermill\">\n<h2>LumberMill</h2>\n<div id=\"introduction\">\n<h3>Introduction</h3>\n<p>Collect, parse and store logs with a configurable set of modules.\nInspired by <a href=\"https://github.com/elasticsearch/logstash\" rel=\"nofollow\">logstash</a> but\nwith a smaller memory footprint and faster startup time.</p>\n</div>\n<div id=\"compatibility-and-performance\">\n<h3>Compatibility and Performance</h3>\n<p>To run LumberMill you will need Python 2.7+.\nFor better performance, I heartly recommend running LumberMill with pypy.\nThe performance gain can be up to 5-6 times events/s throughput running single processed.\nTested with pypy-2.4, pypy-2.5 and pypy-4.1.\nA small benchmark comparing the performance of different python/pypy versions and logstash-1.4.2 can be found <a href=\"http://www.netprojects.de/simple-benchmark-of-lumbermill/\" rel=\"nofollow\">here</a>.</p>\n</div>\n<div id=\"installation\">\n<h3>Installation</h3>\n<p><strong>via pypi</strong></p>\n<pre>pip install LumberMill\n</pre>\n<p><strong>manually</strong></p>\n<p>Clone the github repository to /opt/LumberMill (or any other location that fits you better :):</p>\n<pre>git clone https://github.com/dstore-dbap/LumberMill.git /opt/LumberMill\n</pre>\n<p>Install the dependencies with pip:</p>\n<pre>cd /opt/LumberMill\npython setup.py install\n</pre>\n<p>You may need the MaxMind geo database. Install it with:</p>\n<pre>mkdir /usr/share/GeoIP\ncd /usr/share/GeoIP\nwget \"http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz\"\ngunzip GeoLiteCity.dat.gz\n</pre>\n<p>Now you can give LumberMill a testdrive with:</p>\n<pre>wget https://raw.githubusercontent.com/dstore-dbap/LumberMill/master/conf/example-stdin.conf\necho \"I'm a lumberjack, and I'm okay\" | lumbermill -c ./example-stdin.conf\n</pre>\n<p>If you get a \u201ccommand not found\u201d please check your pythonpath setting. Depending on how you installed LumberMill,\nthe executable can either be found in the bin dir of your python environment (e.g. /usr/lib64/pypy-2.4.0/bin/lumbermill)\nor in your default path (e.g. /usr/local/bin/lumbermill).</p>\n<p>Other basic configuration examples: <a href=\"https://github.com/dstore-dbap/LumberMill/tree/master/conf/\" rel=\"nofollow\">https://github.com/dstore-dbap/LumberMill/tree/master/conf/</a>.</p>\n<p>For a how-to running LumberMill, Elasticsearch and Kibana on CentOS, feel free to visit\n<a href=\"http://www.netprojects.de/collect-visualize-your-logs-with-lumbermill-and-elasticsearch-on-centos/\" rel=\"nofollow\">http://www.netprojects.de/collect-visualize-your-logs-with-lumbermill-and-elasticsearch-on-centos/</a>.</p>\n</div>\n<div id=\"configuration-example-with-explanations\">\n<h3>Configuration example (with explanations)</h3>\n<p>To give a short introduction of how LumberMill works, here is a sample\nconfiguration.\nIts receiving apache and nginx access logs via syslog messages from a\nsyslog server and msgpacked events from\n<a href=\"https://github.com/josegonzalez/python-beaver\" rel=\"nofollow\">python-beaver</a> and\nstores them in an elasticsearch backend.\nBelow, I will explain each section in more detail.</p>\n<pre># Sets number of parallel LumberMill processes.\n- Global:\n   workers: 2\n\n# Listen on all interfaces, port 5151.\n- TcpServer:\n   port: 5151\n   receivers:\n    - RegexParser\n\n# Listen on all interfaces, port 5152.\n- TcpServer:\n   port: 5152\n   mode: stream\n   chunksize: 32768\n\n# Decode msgpacked data.\n- MsgPackParser:\n   mode: stream\n\n# Extract fields.\n- RegexParser:\n   source_field: data\n   hot_rules_first: True\n   field_extraction_patterns:\n    - httpd_access_log: '(?P&lt;remote_ip&gt;\\d+\\.\\d+\\.\\d+\\.\\d+)\\s+(?P&lt;identd&gt;\\w+|-)\\s+(?P&lt;user&gt;\\w+|-)\\s+\\[(?P&lt;datetime&gt;\\d+\\/\\w+\\/\\d+:\\d+:\\d+:\\d+\\s.\\d+)\\]\\s+\\\"(?P&lt;url&gt;.*)\\\"\\s+(?P&lt;http_status&gt;\\d+)\\s+(?P&lt;bytes_send&gt;\\d+)'\n    - http_common_access_log: '(?P&lt;remote_ip&gt;\\d+\\.\\d+\\.\\d+\\.\\d+)\\s(?P&lt;x_forwarded_for&gt;\\d+\\.\\d+\\.\\d+\\.\\d+)\\s(?P&lt;identd&gt;\\w+|-)\\s(?P&lt;user&gt;\\w+|-)\\s\\[(?P&lt;datetime&gt;\\d+\\/\\w+\\/\\d+:\\d+:\\d+:\\d+\\s.\\d+)\\]\\s\\\"(?P&lt;url&gt;.*)\\\"\\s(?P&lt;http_status&gt;\\d+)\\s(?P&lt;bytes_send&gt;\\d+)'\n    - iptables: '(?P&lt;syslog_prival&gt;\\&lt;\\d+\\&gt;)(?P&lt;log_timestamp&gt;\\w+\\s+\\d+\\s+\\d+:\\d+:\\d+)\\s+(?P&lt;host&gt;[\\w\\-\\._]+)\\s+kernel:.*?\\ iptables\\ (?P&lt;iptables_action&gt;.*?)\\ :\\ IN=(?P&lt;iptables_in_int&gt;.*?)\\ OUT=(?P&lt;iptables_out_int&gt;.*?)\\ SRC=(?P&lt;iptables_src&gt;.*?)\\ DST=(?P&lt;iptables_dst&gt;.*?)\\ LEN=(?P&lt;iptables_len&gt;.*?)\\ .*?PROTO=(?P&lt;iptables_proto&gt;.*?)\\ SPT=(?P&lt;iptables_spt&gt;.*?)\\ DPT=(?P&lt;iptables_dpt&gt;.*?)\\ WINDOW=.*'\n   receivers:\n    - SimpleStats:\n       filter: $(lumbermill.event_type) != 'Unknown'\n    # Print out messages that did not match\n    - StdOutSink:\n       filter: $(lumbermill.event_type) == 'Unknown'\n\n# Print out some stats every 10 seconds.\n- SimpleStats:\n   interval: 10\n\n# Extract the syslog prival from events received via syslog.\n- SyslogPrivalParser:\n   source_field: syslog_prival\n\n# Add a timestamp field.\n- AddDateTime:\n   format: '%Y-%m-%dT%H:%M:%S.%f'\n   target_field: \"@timestamp\"\n\n# Add geo info based on the lookup_fields. The first field in &lt;source_fields&gt; that yields a result from geoip will be used.\n- AddGeoInfo:\n   geoip_dat_path: /usr/share/GeoIP/GeoLiteCity.dat\n   source_fields: [x_forwarded_for, remote_ip]\n   geo_info_fields: ['latitude', 'longitude', 'country_code']\n\n# Nginx logs request time in seconds with milliseconds as float. Apache logs microseconds as int.\n# At least cast nginx to integer.\n- Math:\n   filter: if $(server_type) == \"nginx\"\n   target_field: request_time\n   function: float($(request_time)) * 1000\n\n# Map field values of &lt;source_field&gt; to values in &lt;map&gt;.\n- ModifyFields:\n   filter: if $(http_status)\n   action: map\n   source_field: http_status\n   map: {100: 'Continue', 200: 'OK', 301: 'Moved Permanently', 302: 'Found', 304: 'Not Modified', 400: 'Bad Request', 401: 'Unauthorized', 403: 'Forbidden', 404: 'Not Found', 500: 'Internal Server Error', 502: 'Bad Gateway'}\n\n# Kibana\u2019s \u2018bettermap\u2019 panel needs an array of floats in order to plot events on map.\n- ModifyFields:\n   filter: if $(latitude)\n   action: merge\n   source_fields: [longitude, latitude]\n   target_field: geoip\n\n# Extarct some fields from the user agent data.\n- UserAgentParser:\n   source_fields: user_agent\n\n# Parse the url into its components.\n- UrlParser:\n   source_field: uri\n   target_field: uri_parsed\n   parse_querystring: True\n   querystring_target_field: params\n\n# Store events in elastic search.\n- ElasticSearchSink:\n   nodes: [localhost]\n   store_interval_in_secs: 5\n\n- StdOutSink\n</pre>\n<p>Let me explain it in more detail:</p>\n<pre># Sets number of parallel LumberMill processes.\n- Global:\n   workers: 2\n</pre>\n<p>The Global section lets you configure some global properties of\nLumberMill. Here the number of parallel processes is set. In order to\nbe able to use multiple cores with python (yay to the\n<a href=\"http://www.dabeaz.com/GIL/\" rel=\"nofollow\">GIL</a>) LumberMill can be started with\nmultiple parallel processes.\nDefault number of workers is CPU_COUNT - 1.</p>\n<pre># Listen on all interfaces, port 5151.\n- TcpServer:\n   port: 5151\n   receivers:\n    - RegexParser\n</pre>\n<p>Starts a tcp server listening on all local interfaces port 5151. Each\nmodule comes with a set of default values, so you only need to provide\nsettings you need to customize.\nFor a description of the default values of a module, refer to the\nREADME.md in the modules directory or its docstring.\nBy default, a module will send its output to the next module in the\nconfiguration. To set a custom receiver, set the receivers value.\nThis module will send its output directly to RegexParser.</p>\n<pre># Listen on all interfaces, port 5152.\n- TcpServer:\n   port: 5152\n   mode: stream\n   chunksize: 32768\n</pre>\n<p>Also starts a tcp server, listening on port 5152. The first tcp server\nuses newline as separator (which is the default) for each received\nevent.\nHere, the sever reads in max. 32k of data and passes this on to the next\nmodule.</p>\n<pre># Decode msgpacked data.\n- MsgPackParser:\n   mode: stream\n</pre>\n<p>Decode the received data from the above tcp server in msgpack format.\nThis can be used to e.g. handle data send via\n<a href=\"https://github.com/josegonzalez/python-beaver\" rel=\"nofollow\">python-beaver</a></p>\n<pre># Extract fields.\n- RegexParser:\n   source_field: data\n   hot_rules_first: True\n   field_extraction_patterns:\n    - httpd_access_log: '(?P&lt;remote_ip&gt;\\d+\\.\\d+\\.\\d+\\.\\d+)\\s+(?P&lt;identd&gt;\\w+|-)\\s+(?P&lt;user&gt;\\w+|-)\\s+\\[(?P&lt;datetime&gt;\\d+\\/\\w+\\/\\d+:\\d+:\\d+:\\d+\\s.\\d+)\\]\\s+\\\"(?P&lt;url&gt;.*)\\\"\\s+(?P&lt;http_status&gt;\\d+)\\s+(?P&lt;bytes_send&gt;\\d+)'\n    - http_common_access_log: '(?P&lt;remote_ip&gt;\\d+\\.\\d+\\.\\d+\\.\\d+)\\s(?P&lt;x_forwarded_for&gt;\\d+\\.\\d+\\.\\d+\\.\\d+)\\s(?P&lt;identd&gt;\\w+|-)\\s(?P&lt;user&gt;\\w+|-)\\s\\[(?P&lt;datetime&gt;\\d+\\/\\w+\\/\\d+:\\d+:\\d+:\\d+\\s.\\d+)\\]\\s\\\"(?P&lt;url&gt;.*)\\\"\\s(?P&lt;http_status&gt;\\d+)\\s(?P&lt;bytes_send&gt;\\d+)'\n    - iptables: '(?P&lt;syslog_prival&gt;\\&lt;\\d+\\&gt;)(?P&lt;log_timestamp&gt;\\w+\\s+\\d+\\s+\\d+:\\d+:\\d+)\\s+(?P&lt;host&gt;[\\w\\-\\._]+)\\s+kernel:.*?\\ iptables\\ (?P&lt;iptables_action&gt;.*?)\\ :\\ IN=(?P&lt;iptables_in_int&gt;.*?)\\ OUT=(?P&lt;iptables_out_int&gt;.*?)\\ SRC=(?P&lt;iptables_src&gt;.*?)\\ DST=(?P&lt;iptables_dst&gt;.*?)\\ LEN=(?P&lt;iptables_len&gt;.*?)\\ .*?PROTO=(?P&lt;iptables_proto&gt;.*?)\\ SPT=(?P&lt;iptables_spt&gt;.*?)\\ DPT=(?P&lt;iptables_dpt&gt;.*?)\\ WINDOW=.*'\n   receivers:\n    - SimpleStats:\n       filter: $(lumbermill.event_type) != 'Unknown'\n    # Print out messages that did not match\n    - StdOutSink:\n       filter: $(lumbermill.event_type) == 'Unknown'\n</pre>\n<p>Use regular expressions to extract fields from a log event.\nsource_field sets the field to apply the regex to.\nWith hot_rules_first set to True, the expressions will be applied in\norder of their hit counts.\nhttpd_access_log will set the event type to \u201chttpd_access_log\u201d if\nthe expression matches.\nNamed groups are used to set the field names. Grok patterns from\nLogstash can also be used.\nIn the receivers section, we can find output filters. These can be used\nto only send selected events to the receiving module.\nAs to the notation of event fields in such filters, please refer to the\n\u201cEvent field notation\u201d section later in this document.\nIn this example the output filter uses the event metadata lumbermill\nfield. This data is set by LumberMill for every event received and\nwould look like this:</p>\n<pre>'lumbermill': {'event_id': '90818a85f3aa3af302390bbe77fbc1c87800',\n                'event_type': 'Unknown',\n                'pid': 7800,\n                'received_by': 'vagrant-centos65.vagrantup.com',\n                'received_from': '127.0.0.1:61430',\n                'source_module': 'TcpServer'}}\n</pre>\n<p>This data is stored in a separate field to make it easier to drop it\nprior to store it in some backend.</p>\n<pre># Print out some stats every 10 seconds.\n- SimpleStats:\n   interval: 10\n</pre>\n<p>Prints out some simple stats every interval seconds.</p>\n<pre># Extract the syslog prival from events received via syslog.\n- SyslogPrivalParser:\n   source_field: syslog_prival\n</pre>\n<p>Parses syslog prival values to human readable ones based on\n<a href=\"http://tools.ietf.org/html/rfc5424\" rel=\"nofollow\">RFC5424</a>.</p>\n<pre># Add a timestamp field.\n- AddDateTime:\n   format: '%Y-%m-%dT%H:%M:%S.%f'\n   target_field: \"@timestamp\"\n</pre>\n<p>Adds a timestamp field to the event. When you want to use kibana to view\nyour event data, this field is required.</p>\n<pre># Add geo info based on the lookup_fields. The first field in &lt;source_fields&gt; that yields a result from geoip will be used.\n- AddGeoInfo:\n   geoip_dat_path: /usr/share/GeoIP/GeoLiteCity.dat\n   source_fields: [x_forwarded_for, remote_ip]\n   geo_info_fields: ['latitude', 'longitude', 'country_code']\n</pre>\n<p>Adds geo information fields to the event based on ip addresses found in\nsource_fields. The first ip address in source_fields that yields a\nresult will be used.</p>\n<pre># Nginx logs request time in seconds with milliseconds as float. Apache logs microseconds as int.\n# At least cast nginx to integer.\n- Math:\n   filter: if $(server_type) == \"nginx\"\n   target_field: request_time\n   function: float($(request_time)) * 1000\n</pre>\n<p>As it says in the comment. Nginx and apache use different time formats\nfor the request time field. This module lets you adjust the field to\naccommodate for that.\nAlso an input filter is used here. Only matching events will be modified\nby this module.</p>\n<pre># Map field values of &lt;source_field&gt; to values in &lt;map&gt;.\n- ModifyFields:\n   filter: if $(http_status)\n   action: map\n   source_field: http_status\n   map: {100: 'Continue', 200: 'OK', 301: 'Moved Permanently', 302: 'Found', 304: 'Not Modified', 400: 'Bad Request', 401: 'Unauthorized', 403: 'Forbidden', 404: 'Not Found', 500: 'Internal Server Error', 502: 'Bad Gateway'}\n</pre>\n<p>This module shows how you can map event fields to new values. In this\nexample numeric http status codes are mapped to human readable values.</p>\n<pre># Kibana\u2019s \u2018bettermap\u2019 panel needs an array of floats in order to plot events on map.\n- ModifyFields:\n   filter: if $(latitude)\n   action: merge\n   source_fields: [longitude, latitude]\n   target_field: geoip\n</pre>\n<p>Kibanas bettermap module expects the geodata to be found in one single\nfield. With this module the fields longitude and latitude are merged\ninto the geoip field.</p>\n<pre># Extarct some fields from the user agent data.\n- UserAgentParser:\n   source_fields: user_agent\n   target_field: user_agent_info\n</pre>\n<p>Extract user agent information from the user_agent field. This module\nwill set fields like user_agent_info.bot,\nuser_agent_info.browser.name etc.</p>\n<pre># Parse the url into its components.\n- UrlParser:\n   source_field: uri\n   target_field: uri_parsed\n   parse_querystring: True\n   querystring_target_field: params\n</pre>\n<p>Extract details from the uri field. This module will set fields like\nuri_parsed.scheme, uri_parsed.path, uri_parsed.query etc.</p>\n<pre># Store events in elastic search.\n- ElasticSearchSink:\n   nodes: [localhost]\n   store_interval_in_secs: 5\n</pre>\n<p>Send the received events to elasticsearch servers. nodes will set the\nnodes to connect to.</p>\n<pre>- StdOutSink\n</pre>\n<p>Events received by this module will be printed out to stdout. The\nRegexParser module was configured to send unmatched events to this\nmodule.</p>\n<p>The different modules can be combined in any order.</p>\n<p>To run LumberMill you will need Python 2.5+.\nFor better performance I recommend running LumberMill with pypy. Tested\nwith pypy-2.0.2, pypy-2.2.1, pypy-2.3 and pypy-2.4.\nFor IPC ZeroMq is used instead of the default multiprocessing.Queue.\nThis resulted in nearly 3 times of the performance with\nmultiprocessing.Queue.</p>\n</div>\n<div id=\"working-modules\">\n<h3>Working modules</h3>\n<div id=\"event-inputs\">\n<h4>Event inputs</h4>\n<ul>\n<li>ElasticSearch, get documents from elasticsearch.</li>\n<li>Kafka, receive events from apache kafka.</li>\n<li>NmapScanner, scan network with nmap and emit result as new event.</li>\n<li>RedisChannel, read events from redis channels.</li>\n<li>RedisList, read events from redis lists.</li>\n<li>Sniffer, sniff network traffic.</li>\n<li>Spam, what it says on the can - spams LumberMill for testing.</li>\n<li>SQS, read messages from amazons simple queue service.</li>\n<li>StdIn, read stream from standard in.</li>\n<li>TcpServer, read stream from a tcp socket.</li>\n<li>UdpServer, read data from udp socket.</li>\n<li>UnixSocket, read stream from a named socket on unix like systems.</li>\n<li>Zmq, read events from a zeromq.</li>\n</ul>\n</div>\n<div id=\"event-parsers\">\n<h4>Event parsers</h4>\n<ul>\n<li>Base64Parser, parse base64 data.</li>\n<li>CollectdParser, parse collectd binary protocol data.</li>\n<li>CSVParser, parse a char separated string.</li>\n<li>DomainNameParser, parse a domain name or url to tld, subdomain etc. parts.</li>\n<li>InflateParser, inflates any fields with supported compression codecs.</li>\n<li>JsonParser, parse a json formatted string.</li>\n<li>LineParser, split lines at a seperator and emit each line as new\nevent.</li>\n<li>MsgPackParser, parse a msgpack encoded string.</li>\n<li>RegexParser, parse a string using regular expressions and named\ncapturing groups.</li>\n<li>SyslogPrivalParser, parse the syslog prival value (RFC5424).</li>\n<li>UrlParser, parse the query string from an url.</li>\n<li>UserAgentParser, parse a http user agent string.</li>\n<li>XPathParser, parse an XML document via an xpath expression.</li>\n</ul>\n</div>\n<div id=\"event-modifiers\">\n<h4>Event modifiers</h4>\n<ul>\n<li>AddDateTime, adds a timestamp field.</li>\n<li>AddDnsLookup. adds dns data.</li>\n<li>AddGeoInfo, adds geo info fields.</li>\n<li>DropEvent, discards event.</li>\n<li>ExecPython, execute custom python code.</li>\n<li>Facet, collect all encountered variations of en event value over a\nconfigurable period of time.</li>\n<li>HttpRequest, execute an arbritrary http request and store result.</li>\n<li>Math, execute arbitrary math functions.</li>\n<li>MergeEvent, merge multiple events to one single event.</li>\n<li>ModifyFields, some methods to change extracted fields, e.g. insert,\ndelete, replace, castToInteger etc.</li>\n<li>Permutate, takes a list in the event data emits events for all\npossible permutations of that list.</li>\n</ul>\n</div>\n<div id=\"outputs\">\n<h4>Outputs</h4>\n<ul>\n<li>DevNullSink, discards all data that it receives.</li>\n<li>ElasticSearchSink, stores data entries in an elasticsearch index.</li>\n<li>FileSink, store events in a file.</li>\n<li>GraphiteSink, send metrics to graphite server.</li>\n<li>LoggerSink, sends data to lumbermill internal logger for output.</li>\n<li>MongoDbSink, stores data entries in a mongodb index.</li>\n<li>RedisChannelSink, publish incoming events to redis channel.</li>\n<li>RedisListSink, publish incoming events to redis list.</li>\n<li>StdOutSink, prints all received data to standard out.</li>\n<li>SQSSink, sends events to amazons simple queue service.</li>\n<li>SyslogSink, send events to syslog.</li>\n<li>WebHdfsSink, store events in hdfs via webhdfs.</li>\n<li>ZmqSink, sends incoming event to zeromq.</li>\n</ul>\n</div>\n<div id=\"misc-modules\">\n<h4>Misc modules</h4>\n<ul>\n<li>EventBuffer, store received events in a persistent backend until the\nevent was successfully handled.</li>\n<li>KeyValueStore, simple wrapper around the python simplekv module.</li>\n<li>RedisStore, use redis to store and retrieve values, e.g. to store the\nresult of the XPathParser modul.</li>\n<li>SimpleStats, simple statistic module just for event rates etc.</li>\n<li>Statistics, more versatile. Configurable fields for collecting\nstatistic data.</li>\n<li>Tarpit, slows event propagation down - for testing.</li>\n<li>Throttle, throttle event count over a given time period.</li>\n</ul>\n</div>\n<div id=\"cluster-modules\">\n<h4>Cluster modules</h4>\n<ul>\n<li>Pack, base pack module. Handles pack leader and pack member\ndiscovery.</li>\n<li>PackConfiguration, syncs leader configuration to pack members.</li>\n</ul>\n</div>\n<div id=\"webserver-modules\">\n<h4>Webserver modules</h4>\n<ul>\n<li>WebGui, a web interface to LumberMill.</li>\n<li>WebserverTornado, base webserver module. Handles all incoming\nrequests.</li>\n</ul>\n</div>\n</div>\n<div id=\"event-flow-basics\">\n<h3>Event flow basics</h3>\n<ul>\n<li>an input module receives an event.</li>\n<li>the event data will be wrapped in a default event dictionary of the\nfollowing structure: { \u201cdata\u201d: payload, \u201clumbermill\u201d: { \u201cevent_id\u201d:\nunique event id, \u201cevent_type\u201d: \u201cUnknown\u201d, \u201creceived_from\u201d: ip\naddress of sender, \u201csource_module\u201d: caller_class_name, } }</li>\n<li>the input module sends the new event to its receivers. Either by\nadding it to a queue or by calling the receivers handleEvent method.</li>\n<li>if no receivers are configured, the next module in config will be the\ndefault receiver.</li>\n<li>each following module will process the event via its handleEvent\nmethod and pass it on to its receivers.</li>\n<li>each module can have an input filter and an output filter to manage\nevent propagation through the modules.</li>\n<li>output modules can not have receivers.</li>\n</ul>\n</div>\n<div id=\"configuration-basics\">\n<h3>Configuration basics</h3>\n<p>The configuration is stored in a yaml formatted file. Each module\nconfiguration follows the same pattern:</p>\n<pre>- SomeModuleName:\n    id: AliasModuleName                     # &lt;default: \"\"; type: string; is: optional&gt;\n    filter: if $(cache_status) == \"-\"\n    add_fields: {'my_new_field': 'my_new_value'}\n    delete_fields: ['drop_this_field', 'drop_that_field']\n    event_type: my_custom_type\n    receivers:\n     - ModuleName\n     - ModuleAlias:\n         filter: if $('event_type') == 'httpd_access_log'\n</pre>\n<ul>\n<li>module: specifies the module name and maps to the class name of the\nmodule.</li>\n<li>id: use to set an alias name if you run more than just one instance\nof a module.</li>\n<li>filter: apply a filter to incoming events. Only matching events will\nbe handled by this module.</li>\n<li>add_fields: if the event is handled by the module add this fields to\nthe event.</li>\n<li>delete_fields: if the event is handled by the module delete this\nfields from the event.</li>\n<li>event_type: if the event is handled by the module set event_type to\nthis value.</li>\n<li>receivers: ModuleName or id of the receiving modules. If a filter is\nprovided, only matching events will be send to receiver. If no\nreceivers are configured, the next module in config will be the\ndefault receiver.</li>\n</ul>\n<p>For modules that support the storage of intermediate values in redis: *\nconfiguration[\u2018redis-client\u2019]: name of the redis client as set in the\nconfiguration. * configuration[\u2018redis-key\u2019]: key used to store the data\nin redis. * configuration[\u2018redis-ttl\u2019]: ttl of the stored data in\nredis.</p>\n<p>For configuration details of each module refer to its docstring.</p>\n</div>\n<div id=\"event-field-notation\">\n<h3>Event field notation</h3>\n<p>The following examples refer to this event data:</p>\n<pre>{'bytes_send': '3395',\n 'data': '192.168.2.20 - - [28/Jul/2006:10:27:10 -0300] \"GET /wiki/Monty_Python/?spanish=inquisition HTTP/1.0\" 200 3395\\n',\n 'datetime': '28/Jul/2006:10:27:10 -0300',\n 'lumbermill': {\n                'event_id': '715bd321b1016a442bf046682722c78e',\n                'event_type': 'httpd_access_log',\n                \"received_from\": '127.0.0.1',\n                \"source_module\": 'StdIn',\n  },\n 'http_status': '200',\n 'identd': '-',\n 'remote_ip': '192.168.2.20',\n 'url': 'GET /wiki/Monty_Python/?spanish=inquisition HTTP/1.0',\n 'fields': ['nobody', 'expects', 'the'],\n 'params':  { u'spanish': [u'inquisition']},\n 'user': '-'}\n</pre>\n<div id=\"notation-in-configuration-fields-like-source-field-or-target-field\">\n<h4>Notation in configuration fields like source_field or target_field</h4>\n<p>Just use the field name. If referring to a nested dict or a list, use\ndots:</p>\n<pre>- RegexParser:\n    source_field: fields.2\n\n- RegexParser:\n    source_field: params.spanish\n</pre>\n</div>\n<div id=\"notation-in-strings\">\n<h4>Notation in strings</h4>\n<p>Use $(variable_name) notation. If referring to a nested dict or a list,\nuse dots:</p>\n<pre>- ElasticSearchSink:\n    index_name: 1perftests\n    doc_id: $(fields.0)-$(params.spanish.0)\n</pre>\n</div>\n<div id=\"notation-in-module-filters\">\n<h4>Notation in module filters</h4>\n<p>Use $(variable_name) notation. If referring to a nested dict, use dots:</p>\n<pre>- StdOutSink:\n    filter: if $(fields.0) == \"nobody\" and $(params.spanish.0) == 'inquisition'\n</pre>\n<div id=\"filters\">\n<h5>Filters</h5>\n<p>Modules can have an input filter:</p>\n<pre>- StdOutSink:\n    filter: if $(remote_ip) == '192.168.2.20' and re.match('^GET', $(url))\n</pre>\n<p>Modules can have an output filter:</p>\n<pre>- RegexParser:\n    ...\n    receivers:\n      - StdOutSink:\n          filter: if $(remote_ip) == '192.168.2.20' and re.match('^GET', $(url))\n</pre>\n</div>\n</div>\n</div>\n<div id=\"a-rough-sketch-for-using-lumbermill-with-syslog-ng\">\n<h3>A rough sketch for using LumberMill with syslog-ng</h3>\n<p>Send e.g. apache access logs to syslog (/etc/httpd/conf/httpd.conf):</p>\n<pre>...\nCustomLog \"| /usr/bin/logger -p local1.info -t apache2\" common\n...\n</pre>\n<p>Configure the linux syslog-ng service to send data to a tcp address\n(/etc/syslog-ng.conf):</p>\n<pre>...\ndestination d_gambolputty { tcp( localhost port(5151) ); };\nfilter f_httpd_access { facility(local1); };\nlog { source(s_sys); filter(f_httpd_access); destination(d_gambolputty); flags(final);};\n...\n</pre>\n<p>Configure LumberMill to listen on localhost\n5151(./conf/lumbermill.conf):</p>\n<pre>...\n- TcpServer:\n    interface: localhost\n    port: 5151\n...\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 2088823, "releases": {"0.8.9": [{"comment_text": "", "digests": {"md5": "ad42a387bed2e0c5754744c4cd116353", "sha256": "d8b6220cf24f0b95bc7337c1259cde79bc4b71f105d6ca4181ffcdab6f5032ee"}, "downloads": -1, "filename": "LumberMill-0.8.9.tar.gz", "has_sig": false, "md5_digest": "ad42a387bed2e0c5754744c4cd116353", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 315431, "upload_time": "2015-12-11T15:12:38", "upload_time_iso_8601": "2015-12-11T15:12:38.598109Z", "url": "https://files.pythonhosted.org/packages/55/35/438d9aae50360011110e2a252552f4ef70d778ee6ff83ceb08509e5bb23a/LumberMill-0.8.9.tar.gz", "yanked": false}], "0.9.0.1": [{"comment_text": "", "digests": {"md5": "abd784e2f09aab90b223ea7bc270d7f5", "sha256": "8c1d613ffba8c94b372415c3fdd1642d6f89346e1092e4f8703561d4b590ede0"}, "downloads": -1, "filename": "LumberMill-0.9.0.1.tar.gz", "has_sig": false, "md5_digest": "abd784e2f09aab90b223ea7bc270d7f5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 317985, "upload_time": "2015-12-18T14:08:40", "upload_time_iso_8601": "2015-12-18T14:08:40.903941Z", "url": "https://files.pythonhosted.org/packages/34/fc/161af520e3cc3f7b7cee2d76541179661745f91b829d1e748b9a1091ceb7/LumberMill-0.9.0.1.tar.gz", "yanked": false}], "0.9.0.2": [{"comment_text": "", "digests": {"md5": "a6b1c79ef5108f75a01f12518ac0aa52", "sha256": "fa12fd3f37a2ad97312cd5dcf4767b2ce93e1ede6a57bb113567ffec813db281"}, "downloads": -1, "filename": "LumberMill-0.9.0.2.tar.gz", "has_sig": false, "md5_digest": "a6b1c79ef5108f75a01f12518ac0aa52", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 320640, "upload_time": "2016-04-28T14:18:09", "upload_time_iso_8601": "2016-04-28T14:18:09.840091Z", "url": "https://files.pythonhosted.org/packages/a7/28/f83efcf06f819a01293b602902845b06e3615a9ae69e87cac33222533a94/LumberMill-0.9.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a6b1c79ef5108f75a01f12518ac0aa52", "sha256": "fa12fd3f37a2ad97312cd5dcf4767b2ce93e1ede6a57bb113567ffec813db281"}, "downloads": -1, "filename": "LumberMill-0.9.0.2.tar.gz", "has_sig": false, "md5_digest": "a6b1c79ef5108f75a01f12518ac0aa52", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 320640, "upload_time": "2016-04-28T14:18:09", "upload_time_iso_8601": "2016-04-28T14:18:09.840091Z", "url": "https://files.pythonhosted.org/packages/a7/28/f83efcf06f819a01293b602902845b06e3615a9ae69e87cac33222533a94/LumberMill-0.9.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:43:07 2020"}