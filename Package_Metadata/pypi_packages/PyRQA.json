{"info": {"author": "Tobias Rawald", "author_email": "pyrqa@gmx.net", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: Financial and Insurance Industry", "Intended Audience :: Healthcare Industry", "Intended Audience :: Manufacturing", "Intended Audience :: Science/Research", "License :: OSI Approved :: Apache Software License", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering :: Artificial Intelligence", "Topic :: Scientific/Engineering :: Mathematics", "Topic :: Scientific/Engineering :: Physics"], "description": "PyRQA\n=====\n\nHighlights\n----------\n\n-  Perform recurrence analysis on long time series in a time efficient\n   manner using the OpenCL framework.\n-  Conduct recurrence quantification analysis (*RQA*) and cross\n   recurrence quantification analysis (*CRQA*).\n-  Compute recurrence plots (*RP*) and cross recurrence plots (*CRP*).\n-  Compute unthresholded recurrence plots (*URP*) and unthresholded\n   cross recurrence plots (*UCRP*).\n-  Conduct joint recurrence quantification analysis (*JRQA*) and compute\n   joint recurrence plots (*JRP*).\n-  Employ the euclidean, maximum or taxicab metric for determining state\n   similarity.\n-  Choose the fixed radius or radius corridor neighbourhood condition.\n-  Select either the half, single or double floating point precision for\n   conducting the analytical computations.\n-  Leverage machine learning techniques that automatically choose the\n   fastest from a set of implementations.\n-  Apply the computing capabilities of GPUs, CPUs and other computing\n   platforms that support OpenCL.\n-  Use multiple computing devices of the same or different type in\n   parallel.\n\nTable of Contents\n-----------------\n\n1.  `General Information <#general-information>`__\n2.  `Recommended Citation <#recommended-citation>`__\n3.  `Installation <#installation>`__\n4.  `OpenCL Setup <#opencl-setup>`__\n5.  `Usage <#usage>`__\n6.  `Performance Tuning <#performance-tuning>`__\n7.  `Testing <#testing>`__\n8.  `Origin <#origin>`__\n9.  `Acknowledgements <#acknowledgements>`__\n10. `Publications <#publications>`__\n11. `Release Notes <#release-notes>`__\n\nGeneral Information\n-------------------\n\nPyRQA is a tool to conduct recurrence analysis in a massively parallel\nmanner using the OpenCL framework. It is designed to efficiently process\ntime series consisting of hundreds of thousands of data points.\n\nPyRQA supports the computation of the following quantitative measures:\n\n-  Recurrence rate (*RR*)\n-  Determinism (*DET*)\n-  Average diagonal line length (*L*)\n-  Longest diagonal line length (*L\\_max*)\n-  Divergence (*DIV*)\n-  Entropy diagonal lines (*L\\_entr*)\n-  Laminarity (*LAM*)\n-  Trapping time (*TT*)\n-  Longest vertical line length (*V\\_max*)\n-  Entropy vertical lines (*V\\_entr*)\n-  Average white vertical line length (*W*)\n-  Longest white vertical line length (*W\\_max*)\n-  Longest white vertical line length divergence (*W\\_div*)\n-  Entropy white vertical lines (*W\\_entr*)\n\nPyRQA additionally allows to compute the corresponding recurrence plot,\nwhich can be exported as an image file.\n\nRecommended Citation\n--------------------\n\nPlease acknowledge the use of PyRQA by citing the following publication.\n\n    Rawald, T., Sips, M., Marwan, N. (2017): PyRQA - Conducting\n    Recurrence Quantification Analysis on Very Long Time Series\n    Efficiently. - Computers and Geosciences, 104, pp. 101-108.\n\nInstallation\n------------\n\nPyRQA and all of its dependencies can be installed via the following\ncommand.\n\n.. code:: bash\n\n    pip install PyRQA\n\nOpenCL Setup\n------------\n\nThe analytical implementations provided by PyRQA rely on features that\nare part of OpenCL 1.1, which is a fairly mature standard and supported\nby a large number of platforms. The OpenCL computing devices employed\nneed to support at least this version to being able to use PyRQA.\n\nIt may be required to install additional software, e.g., runtimes or\ndrivers, to execute PyRQA on computing devices such as GPUs and CPUs.\nReferences to vendor-specific information is presented below.\n\n*AMD*:\n\n-  https://www.amd.com/en/support\n-  https://github.com/RadeonOpenCompute/ROCm\n-  https://community.amd.com/community/devgurus/opencl\n-  https://www.amd.com/en/support/kb/release-notes/amdgpu-installation\n\n*ARM*:\n\n-  https://developer.arm.com/docs/100614/0312\n\n*Intel*:\n\n-  https://software.intel.com/en-us/articles/opencl-drivers\n-  https://software.intel.com/en-us/articles/sdk-for-opencl-gsg\n\n*NVIDIA*:\n\n-  https://developer.nvidia.com/opencl\n-  https://developer.nvidia.com/cuda-downloads\n\n*Vendor-independent*:\n\n-  http://portablecl.org\n\nUsage\n-----\n\nBasic Computations\n~~~~~~~~~~~~~~~~~~\n\nRQA computations are conducted as follows.\n\n.. code:: python\n\n    from pyrqa.time_series import TimeSeries\n    from pyrqa.settings import Settings\n    from pyrqa.analysis_type import Classic\n    from pyrqa.neighbourhood import FixedRadius\n    from pyrqa.metric import EuclideanMetric\n    from pyrqa.computation import RQAComputation\n    data_points = [0.1, 0.5, 1.3, 0.7, 0.8, 1.4, 1.6, 1.2, 0.4, 1.1, 0.8, 0.2, 1.3]\n    time_series = TimeSeries(data_points,\n                             embedding_dimension=2,\n                             time_delay=2)\n    settings = Settings(time_series,\n                        analysis_type=Classic,\n                        neighbourhood=FixedRadius(0.65),\n                        similarity_measure=EuclideanMetric,\n                        theiler_corrector=1)\n    computation = RQAComputation.create(settings,\n                                        verbose=True)\n    result = computation.run()\n    result.min_diagonal_line_length = 2\n    result.min_vertical_line_length = 2\n    result.min_white_vertical_line_length = 2\n    print(result)\n\nThe following output is expected.\n\n::\n\n    RQA Result:\n    ===========\n\n    Minimum diagonal line length (L_min): 2\n    Minimum vertical line length (V_min): 2\n    Minimum white vertical line length (W_min): 2\n\n    Recurrence rate (RR): 0.371901\n    Determinism (DET): 0.411765\n    Average diagonal line length (L): 2.333333\n    Longest diagonal line length (L_max): 3\n    Divergence (DIV): 0.333333\n    Entropy diagonal lines (L_entr): 0.636514\n    Laminarity (LAM): 0.400000\n    Trapping time (TT): 2.571429\n    Longest vertical line length (V_max): 4\n    Entropy vertical lines (V_entr): 0.955700\n    Average white vertical line length (W): 2.538462\n    Longest white vertical line length (W_max): 6\n    Longest white vertical line length inverse (W_div): 0.166667\n    Entropy white vertical lines (W_entr): 0.839796\n\n    Ratio determinism / recurrence rate (DET/RR): 1.107190\n    Ratio laminarity / determinism (LAM/DET): 0.971429\n\nThe corresponding recurrence plot is computed likewise. Note that the\n``theiler_corrector`` is ignored regarding the creation of the plot.\n\n.. code:: python\n\n    from pyrqa.computation import RPComputation\n    from pyrqa.image_generator import ImageGenerator\n    computation = RPComputation.create(settings)\n    result = computation.run()\n    ImageGenerator.save_recurrence_plot(result.recurrence_matrix_reverse,\n                                        'recurrence_plot.png')\n\nCross Recurrence Analysis\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPyRQA further offers the opportunity to conduct cross recurrence\nanalysis (*CRQA* and *CRP*), in addition to the classic recurrence\nanalysis (*RQA* and *RP*). For this purpose, two time series of\npotentially different length are provided as input. Note that the\ncorresponding computations require to set the same value regarding the\nembedding dimension. Two different time delay values may be used\nregarding the first and the second time series. To enable cross\nrecurrence analysis, the ``analysis_type`` argument has to be changed\nfrom ``Classic`` to ``Cross``, when creating the ``Settings`` object. A\n*CRQA* example is given below.\n\n.. code:: python\n\n    from pyrqa.analysis_type import Cross\n    data_points_x = [0.9, 0.1, 0.2, 0.3, 0.5, 1.7, 0.4, 0.8, 1.5]\n    time_series_x = TimeSeries(data_points_x,\n                               embedding_dimension=2,\n                               time_delay=1)\n    data_points_y = [0.3, 1.3, 0.6, 0.2, 1.1, 1.9, 1.3, 0.4, 0.7, 0.9, 1.6]\n    time_series_y = TimeSeries(data_points_y,\n                               embedding_dimension=2,\n                               time_delay=2)\n    time_series = (time_series_x,\n                   time_series_y)\n    settings = Settings(time_series,\n                        analysis_type=Cross,\n                        neighbourhood=FixedRadius(0.73),\n                        similarity_measure=EuclideanMetric,\n                        theiler_corrector=0)\n    computation = RQAComputation.create(settings,\n                                        verbose=True)\n    result = computation.run()\n    result.min_diagonal_line_length = 2\n    result.min_vertical_line_length = 2\n    result.min_white_vertical_line_length = 2\n    print(result)\n\nThe following output is expected.\n\n::\n\n    CRQA Result:\n    ============\n\n    Minimum diagonal line length (L_min): 2\n    Minimum vertical line length (V_min): 2\n    Minimum white vertical line length (W_min): 2\n\n    Recurrence rate (RR): 0.319444\n    Determinism (DET): 0.521739\n    Average diagonal line length (L): 2.400000\n    Longest diagonal line length (L_max): 3\n    Divergence (DIV): 0.333333\n    Entropy diagonal lines (L_entr): 0.673012\n    Laminarity (LAM): 0.434783\n    Trapping time (TT): 2.500000\n    Longest vertical line length (V_max): 3\n    Entropy vertical lines (V_entr): 0.693147\n    Average white vertical line length (W): 3.500000\n    Longest white vertical line length (W_max): 8\n    Longest white vertical line length inverse (W_div): 0.125000\n    Entropy white vertical lines (W_entr): 1.424130\n\n    Ratio determinism / recurrence rate (DET/RR): 1.633270\n    Ratio laminarity / determinism (LAM/DET): 0.833333\n\nThe corresponding cross recurrence plot is computed likewise.\n\n.. code:: python\n\n    from pyrqa.computation import RPComputation\n    from pyrqa.image_generator import ImageGenerator\n    computation = RPComputation.create(settings)\n    result = computation.run()\n    ImageGenerator.save_recurrence_plot(result.recurrence_matrix_reverse,\n                                        'cross_recurrence_plot.png')\n\nNeighbourhood Condition Selection\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPyRQA currently supports the fixed radius as well as the radius corridor\nneighbourhood condition. While the first refers to a single radius, the\nlatter requires the assignment of an inner and outer radius. The\nspecific condition is passed as ``neighbourhood`` argument to the\nconstructor of a ``Settings`` object. The creation of a fixed radius and\na radius corridor neighbourhood is presented below.\n\n.. code:: python\n\n    from pyrqa.neighbourhood import FixedRadius, RadiusCorridor\n    fixed_radius = FixedRadius(radius=0.43)\n    radius_corridor = RadiusCorridor(inner_radius=0.32, \n                                     outer_radius=0.86)          \n\nUnthresholded Recurrence Plots\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nPyRQA allows to create unthresholded *RP*\\ s and *CRP*\\ s by selecting\nthe ``Unthresholded`` neighbourhood condition. This results in a\nnon-binary matrix, containing the mutual distances between the system\nstates, based on the similarity measure selected. Functionality is\nprovided to normalize these distances to values between ``0`` and ``1``.\nThe normalized matrix can further be represented as a grayscale image.\nDarker shades of grey indicate smaller distances whereas lighter shades\nof grey indicate larger distances. An example on how to create an\nunthresholded cross recurrence plot is given below.\n\n.. code:: python\n\n    from pyrqa.neighbourhood import Unthresholded\n    settings = Settings(time_series,\n                        analysis_type=Cross,\n                        neighbourhood=Unthresholded(),\n                        similarity_measure=EuclideanMetric)\n    computation = RPComputation.create(settings)\n    result = computation.run()\n    ImageGenerator.save_unthresholded_recurrence_plot(result.recurrence_matrix_reverse_normalized,\n                                                      'unthresholded_cross_recurrence_plot.png')\n\nJoint Recurrence Analysis\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIn addition to classic and cross recurrence analysis, PyRQA provides\nfunctionality to conduct joint recurrence analysis. This includes in\nparticular joint recurrence plots (*JRP*) as well as joint recurrence\nquantification analysis (*JRQA*). On an abstract level, a joint\nrecurrence plot is a combination of two individual plots, both having\nthe same extent regarding the *X* and *Y* axis. Each of those two plots\nmay either be of the analysis type ``Classic`` or ``Cross``, potentially\nhaving different characteristics regarding:\n\n-  Time series data,\n-  Embedding dimension,\n-  Time delay,\n-  Neighbourhood condition, and\n-  Similarity measure.\n\nIn contrast, the same value for ``theiler_corrector`` is expected\nregarding the quantitative analysis. Note that a joint recurrence plot\nby definition relies on thresholded input plots, eliminating the\napplication of the ``Unthresholded`` neighbourhood condition.\n\nThe settings of the two individual plots are encapsulated in a\n``JointSettings`` object. The quantification of joint recurrence plots\nis based on the same measures as for recurrence plots and cross\nrecurrence plots. An example on how to conduct *JRQA* is given below.\n\n.. code:: python\n\n    from pyrqa.computation import JRQAComputation\n    from pyrqa.metric import MaximumMetric, TaxicabMetric\n    from pyrqa.settings import JointSettings\n    data_points_1 = [1.0, 0.7, 0.5, 0.1, 1.7, 1.5, 1.2, 0.4, 0.6, 1.5, 0.8, 0.3]\n    time_series_1 = TimeSeries(data_points,\n                               embedding_dimension=3,\n                               time_delay=1)\n    settings_1 = Settings(time_series_1,\n                          analysis_type=Classic,\n                          neighbourhood=RadiusCorridor(inner_radius=0.14,\n                                                       outer_radius=0.97),\n                          similarity_measure=MaximumMetric,\n                          theiler_corrector=1)\n    data_points_2_x = [0.7, 0.1, 1.1, 1.4, 1.0, 0.5, 1.0, 1.9, 1.7, 0.9, 1.5, 0.6]\n    time_series_2_x = TimeSeries(data_points_2_x,\n                                 embedding_dimension=2,\n                                 time_delay=1)\n    data_points_2_y = [0.4, 0.7, 0.9, 0.3, 1.9, 1.3, 1.2, 0.2, 1.1, 0.6, 0.8, 0.1, 0.5]\n    time_series_2_y = TimeSeries(data_points_2_y,\n                                 embedding_dimension=2,\n                                 time_delay=2)\n    time_series_2 = (time_series_2_x,\n                     time_series_2_y)\n    settings_2 = Settings(time_series_2,\n                          analysis_type=Cross,\n                          neighbourhood=FixedRadius(0.83),\n                          similarity_measure=TaxicabMetric,\n                          theiler_corrector=1)\n    joint_settings = JointSettings(settings_1,\n                                   settings_2)\n    computation = JRQAComputation.create(joint_settings,\n                                         verbose=True)\n    result = computation.run()\n    result.min_diagonal_line_length = 2\n    result.min_vertical_line_length = 1\n    result.min_white_vertical_line_length = 2\n    print(result)\n\nThe following output is expected.\n\n::\n\n    JRQA Result:\n    ============\n\n    Minimum diagonal line length (L_min): 2\n    Minimum vertical line length (V_min): 1\n    Minimum white vertical line length (W_min): 2\n\n    Recurrence rate (RR): 0.157025\n    Determinism (DET): 0.263158\n    Average diagonal line length (L): 2.500000\n    Longest diagonal line length (L_max): 3\n    Divergence (DIV): 0.333333\n    Entropy diagonal lines (L_entr): 0.693147\n    Laminarity (LAM): 1.000000\n    Trapping time (TT): 1.000000\n    Longest vertical line length (V_max): 1\n    Entropy vertical lines (V_entr): 0.000000\n    Average white vertical line length (W): 3.960000\n    Longest white vertical line length (W_max): 11\n    Longest white vertical line length inverse (W_div): 0.090909\n    Entropy white vertical lines (W_entr): 1.588760\n\n    Ratio determinism / recurrence rate (DET/RR): 1.675900\n    Ratio laminarity / determinism (LAM/DET): 3.800000\n\nThe corresponding joint recurrence plot is computed likewise.\n\n.. code:: python\n\n    from pyrqa.computation import JRPComputation\n    computation = JRPComputation.create(joint_settings)\n    result = computation.run()\n    ImageGenerator.save_recurrence_plot(result.recurrence_matrix_reverse,\n                                        'joint_recurrence_plot.png')\n\nCustom OpenCL Environment\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe previous examples use the default OpenCL environment. A custom\nenvironment can also be created via command line input. For this\npurpose, the ``command_line`` argument has to be set to ``True``, when\ncreating an ``OpenCL`` object.\n\n.. code:: python\n\n    from pyrqa.opencl import OpenCL\n    opencl = OpenCL(command_line=True)\n\nThe OpenCL platform as well as the computing devices can also be\nselected manually using their identifiers.\n\n.. code:: python\n\n    opencl = OpenCL(platform_id=0,\n                    device_ids=(0,))\n    computation = RPComputation.create(settings,\n                                       verbose=True,\n                                       opencl=opencl)\n\nFloating Point Precision\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nIt is possible to specify the precision of the time series data, which\nin turn determines the precision of the computations conducted by the\nOpenCL devices. Currently, the following precisions are supported by\nPyRQA:\n\n-  Half precision (16-bit),\n-  Single precision (32-bit), and\n-  Double precision (64-bit).\n\nBy default, the single precision is applied. Note that not all\nprecisions may be supported by the OpenCL devices employed. Furthermore,\nthe selected precision influences the performance of the computations on\na particular device.\n\nThe precision is set by specifying the corresponding data type, short\n``dtype``, of the time series data. The following example depicts the\nusage of double precision floating point values.\n\n.. code:: python\n\n    import numpy as np\n    time_series = TimeSeries(data_points,\n                             embedding_dimension=2,\n                             time_delay=2,\n                             dtype=np.float64)\n\nPerformance Tuning\n------------------\n\nOpenCL Compiler Optimisations Enablement\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOpenCL compiler optimisations aim at improving the performance of the\noperations conducted by the computing devices. Regarding PyRQA, they are\ndisabled by default to ensure the comparability of the analytical\nresults. They can be enabled by assigning the value ``True`` to the\ncorresponding keyword argument ``optimisations_enabled``.\n\n.. code:: python\n\n    computation = RPComputation.create(settings,\n                                       variants_kwargs={'optimisations_enabled': True})\n\nAdaptive Implementation Selection\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAdaptive implementation selection allows to automatically select well\nperforming implementations regarding RQA and recurrence plot\ncomputations, provided by PyRQA. The approach dynamically adapts the\nselection to the current computational scenario as well as the\nproperties of the OpenCL devices employed. The selection is performed\nusing one of multiple strategies, each referred to as ``selector``. They\nrely on a set of customized implementation ``variants``, which may be\nparameterized using a set of keyword arguments called\n``variants_kwargs``. Note that the same selection strategies can be used\nfor *RQA* and *CRQA*, *RP* and *CRP*, *URP* and *UCRP* as well as *JRQA*\nand *JRP* computations.\n\n.. code:: python\n\n    from pyrqa.variants.rqa.radius.column_materialisation_bit_no_recycling import ColumnMaterialisationBitNoRecycling\n    from pyrqa.variants.rqa.radius.column_materialisation_bit_recycling import ColumnMaterialisationBitRecycling\n    from pyrqa.variants.rqa.radius.column_materialisation_byte_no_recycling import ColumnMaterialisationByteNoRecycling\n    from pyrqa.variants.rqa.radius.column_materialisation_byte_recycling import ColumnMaterialisationByteRecycling\n    from pyrqa.variants.rqa.radius.column_no_materialisation import ColumnNoMaterialisation\n    from pyrqa.selector import EpsilonGreedySelector\n    data_points = [0.1, 0.5, 1.3, 0.7, 0.8, 1.4, 1.6, 1.2, 0.4, 1.1, 0.8, 0.2, 1.3]\n    time_series = TimeSeries(data_points,\n                             embedding_dimension=2,\n                             time_delay=2)\n    settings = Settings(time_series,\n                        analysis_type=Classic,\n                        neighbourhood=FixedRadius(0.65),\n                        similarity_measure=EuclideanMetric,\n                        theiler_corrector=1)\n    computation = RQAComputation.create(settings,\n                                        selector=EpsilonGreedySelector(explore=10),\n                                        variants=(ColumnMaterialisationBitNoRecycling,\n                                                  ColumnMaterialisationBitRecycling,\n                                                  ColumnMaterialisationByteNoRecycling,\n                                                  ColumnMaterialisationByteRecycling,\n                                                  ColumnNoMaterialisation),\n                                        variants_kwargs={'optimisations_enabled': True})\n\nTesting\n-------\n\nPyRQA provides a single-threaded baseline implementation for each\nanalytical method. These implementations do not use OpenCL\nfunctionality. They serve as a ground truth regarding the analytical\ncomputations. The basic tests for all supported analytical methods can\nbe executed cumulatively.\n\n.. code:: bash\n\n    python -m pyrqa.test\n\nThe complete set of tests can be executed by adding the option\n``--all``.\n\n.. code:: bash\n\n    python -m pyrqa.test --all\n\nNote that there might occur minor deviations regarding the analytical\nresults. These deviations may stem from varying precisions regarding the\ncomputing devices employed.\n\nOrigin\n------\n\nThe PyRQA package was initiated by computer scientists from the\nHumboldt-Universit\u00e4t zu Berlin (https://www.hu-berlin.de) and the GFZ\nGerman Research Centre for Geosciences (https://www.gfz-potsdam.de).\n\nAcknowledgements\n----------------\n\nWe would like to thank Norbert Marwan from the Potsdam Institute for\nClimate Impact Research (https://www.pik-potsdam.de) for his continuous\nsupport of the project. Please visit his website\nhttp://recurrence-plot.tk/ for further information on recurrence\nanalysis. Initial research and development of PyRQA was funded by the\nDeutsche Forschungsgemeinschaft (https://www.dfg.de/).\n\nPublications\n------------\n\nThe underlying computational approach of PyRQA is described in detail\nwithin the following thesis, which is openly accessible at\nhttps://edoc.hu-berlin.de/handle/18452/19518.\n\n    Rawald, T. (2018): Scalable and Efficient Analysis of Large\n    High-Dimensional Data Sets in the Context of Recurrence Analysis,\n    PhD Thesis, Berlin : Humboldt-Universit\u00e4t zu Berlin, 299 p.\n\nSelected aspects of the computational approach are presented within the\nfollowing publications.\n\n    Rawald, T., Sips, M., Marwan, N., Dransch, D. (2014): Fast\n    Computation of Recurrences in Long Time Series. - In: Marwan, N.,\n    Riley, M., Guiliani, A., Webber, C. (Eds.), Translational\n    Recurrences. From Mathematical Theory to Real-World Applications,\n    (Springer Proceedings in Mathematics and Statistics ; 103), p.\n    17-29.\n\n    Rawald, T., Sips, M., Marwan, N., Leser, U. (2015): Massively\n    Parallel Analysis of Similarity Matrices on Heterogeneous Hardware.\n    - In: Fischer, P. M., Alonso, G., Arenas, M., Geerts, F. (Eds.),\n    Proceedings of the Workshops of the EDBT/ICDT 2015 Joint Conference\n    (EDBT/ICDT), (CEUR Workshop Proceedings ; 1330), p. 56-62.\n\nRelease Notes\n-------------\n\n6.0.0\n~~~~~\n\n-  Addition of the joint recurrence quantification analysis (*JRQA*) and\n   joint recurrence plot (*JRP*) computations.\n-  Refactoring of the test implementation.\n-  Refactoring of the public API.\n-  Updated documentation.\n\n5.1.0\n~~~~~\n\n-  Addition of the unthresholded recurrence plot (*URP*) and\n   unthresholded cross recurrence plot (*UCRP*) computations.\n-  Updated documentation.\n\n5.0.0\n~~~~~\n\n-  Refactoring of the public API.\n-  Updated documentation.\n\n4.1.0\n~~~~~\n\n-  Usage of two different time delay values regarding the cross\n   recurrence plot (*CRP*) and cross recurrence quantification analysis\n   (*CRQA*).\n-  Updated documentation.\n\n4.0.0\n~~~~~\n\n-  Addition of the cross recurrence plot (*CRP*) and cross recurrence\n   quantification analysis (*CRQA*) computations.\n-  Addition of the radius corridor neighbourhood condition for\n   determining state similarity.\n-  Addition of an additional variant regarding recurrence plot\n   computations.\n-  Renaming of directories and classes referring to recurrence plot\n   computations.\n-  Removal of obsolete source code.\n-  Updated documentation.\n\n3.0.0\n~~~~~\n\n-  Source code cleanup.\n-  Renaming of the implementation variants regarding RQA and recurrence\n   plot processing.\n-  Removal of the module ``file_reader.py``. Please refer for example to\n   ``numpy.genfromtxt`` to read data from files (see\n   https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html).\n-  Updated documentation.\n\n2.0.1\n~~~~~\n\n-  Updated documentation.\n\n2.0.0\n~~~~~\n\n-  Major refactoring.\n-  Removal of operator and variant implementations that do not refer to\n   OpenCL brute force computing.\n-  Time series data may be represented using half, single and double\n   precision floating point values, which is reflected in the\n   computations on the OpenCL devices.\n-  Several changes to the public API.\n\n1.0.6\n~~~~~\n\n-  Changes to the public API have been made, e.g., to the definition of\n   the settings. This leads to an increase in the major version number\n   (see https://semver.org/).\n-  Time series objects either consist of one or multiple series. The\n   former requires to specify a value for the embedding delay as well as\n   the time delay parameter.\n-  Regarding the RQA computations, minimum line lengths are now\n   specified on the result object. This allows to compute quantitative\n   results using different lengths without having to inspect the matrix\n   using the same parametrisation multiple times.\n-  Modules for selecting well-performing implementations based on greedy\n   selection strategies have been added. By default, the selection pool\n   consists of a single pre-defined implementation.\n-  Operators and implementation variants based on multidimensional\n   search trees and grid data structures have been added.\n-  The diagonal line based quantitative measures are modified regarding\n   the semantics of the Theiler corrector.\n-  The creation of the OpenCL environment now supports device fission.\n\n0.1.0\n~~~~~\n\n-  Initial release.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "time series analysis,recurrence quantification analysis,RQA,cross recurrence quantification analysis,CRQA,joint recurrence quantification analysis,JRQA,recurrence plot,RP,cross recurrence plot,CRP,joint recurrence plot,JRP", "license": "Apache License 2.0", "maintainer": "", "maintainer_email": "", "name": "PyRQA", "package_url": "https://pypi.org/project/PyRQA/", "platform": "", "project_url": "https://pypi.org/project/PyRQA/", "project_urls": null, "release_url": "https://pypi.org/project/PyRQA/6.0.0/", "requires_dist": null, "requires_python": "", "summary": "A tool to conduct recurrence analysis in a massively parallel manner using the OpenCL framework.", "version": "6.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"highlights\">\n<h2>Highlights</h2>\n<ul>\n<li>Perform recurrence analysis on long time series in a time efficient\nmanner using the OpenCL framework.</li>\n<li>Conduct recurrence quantification analysis (<em>RQA</em>) and cross\nrecurrence quantification analysis (<em>CRQA</em>).</li>\n<li>Compute recurrence plots (<em>RP</em>) and cross recurrence plots (<em>CRP</em>).</li>\n<li>Compute unthresholded recurrence plots (<em>URP</em>) and unthresholded\ncross recurrence plots (<em>UCRP</em>).</li>\n<li>Conduct joint recurrence quantification analysis (<em>JRQA</em>) and compute\njoint recurrence plots (<em>JRP</em>).</li>\n<li>Employ the euclidean, maximum or taxicab metric for determining state\nsimilarity.</li>\n<li>Choose the fixed radius or radius corridor neighbourhood condition.</li>\n<li>Select either the half, single or double floating point precision for\nconducting the analytical computations.</li>\n<li>Leverage machine learning techniques that automatically choose the\nfastest from a set of implementations.</li>\n<li>Apply the computing capabilities of GPUs, CPUs and other computing\nplatforms that support OpenCL.</li>\n<li>Use multiple computing devices of the same or different type in\nparallel.</li>\n</ul>\n</div>\n<div id=\"table-of-contents\">\n<h2>Table of Contents</h2>\n<ol>\n<li><a href=\"#general-information\" rel=\"nofollow\">General Information</a></li>\n<li><a href=\"#recommended-citation\" rel=\"nofollow\">Recommended Citation</a></li>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#opencl-setup\" rel=\"nofollow\">OpenCL Setup</a></li>\n<li><a href=\"#usage\" rel=\"nofollow\">Usage</a></li>\n<li><a href=\"#performance-tuning\" rel=\"nofollow\">Performance Tuning</a></li>\n<li><a href=\"#testing\" rel=\"nofollow\">Testing</a></li>\n<li><a href=\"#origin\" rel=\"nofollow\">Origin</a></li>\n<li><a href=\"#acknowledgements\" rel=\"nofollow\">Acknowledgements</a></li>\n<li><a href=\"#publications\" rel=\"nofollow\">Publications</a></li>\n<li><a href=\"#release-notes\" rel=\"nofollow\">Release Notes</a></li>\n</ol>\n</div>\n<div id=\"general-information\">\n<h2>General Information</h2>\n<p>PyRQA is a tool to conduct recurrence analysis in a massively parallel\nmanner using the OpenCL framework. It is designed to efficiently process\ntime series consisting of hundreds of thousands of data points.</p>\n<p>PyRQA supports the computation of the following quantitative measures:</p>\n<ul>\n<li>Recurrence rate (<em>RR</em>)</li>\n<li>Determinism (<em>DET</em>)</li>\n<li>Average diagonal line length (<em>L</em>)</li>\n<li>Longest diagonal line length (<em>L_max</em>)</li>\n<li>Divergence (<em>DIV</em>)</li>\n<li>Entropy diagonal lines (<em>L_entr</em>)</li>\n<li>Laminarity (<em>LAM</em>)</li>\n<li>Trapping time (<em>TT</em>)</li>\n<li>Longest vertical line length (<em>V_max</em>)</li>\n<li>Entropy vertical lines (<em>V_entr</em>)</li>\n<li>Average white vertical line length (<em>W</em>)</li>\n<li>Longest white vertical line length (<em>W_max</em>)</li>\n<li>Longest white vertical line length divergence (<em>W_div</em>)</li>\n<li>Entropy white vertical lines (<em>W_entr</em>)</li>\n</ul>\n<p>PyRQA additionally allows to compute the corresponding recurrence plot,\nwhich can be exported as an image file.</p>\n</div>\n<div id=\"recommended-citation\">\n<h2>Recommended Citation</h2>\n<p>Please acknowledge the use of PyRQA by citing the following publication.</p>\n<blockquote>\nRawald, T., Sips, M., Marwan, N. (2017): PyRQA - Conducting\nRecurrence Quantification Analysis on Very Long Time Series\nEfficiently. - Computers and Geosciences, 104, pp. 101-108.</blockquote>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>PyRQA and all of its dependencies can be installed via the following\ncommand.</p>\n<pre>pip install PyRQA\n</pre>\n</div>\n<div id=\"opencl-setup\">\n<h2>OpenCL Setup</h2>\n<p>The analytical implementations provided by PyRQA rely on features that\nare part of OpenCL 1.1, which is a fairly mature standard and supported\nby a large number of platforms. The OpenCL computing devices employed\nneed to support at least this version to being able to use PyRQA.</p>\n<p>It may be required to install additional software, e.g., runtimes or\ndrivers, to execute PyRQA on computing devices such as GPUs and CPUs.\nReferences to vendor-specific information is presented below.</p>\n<p><em>AMD</em>:</p>\n<ul>\n<li><a href=\"https://www.amd.com/en/support\" rel=\"nofollow\">https://www.amd.com/en/support</a></li>\n<li><a href=\"https://github.com/RadeonOpenCompute/ROCm\" rel=\"nofollow\">https://github.com/RadeonOpenCompute/ROCm</a></li>\n<li><a href=\"https://community.amd.com/community/devgurus/opencl\" rel=\"nofollow\">https://community.amd.com/community/devgurus/opencl</a></li>\n<li><a href=\"https://www.amd.com/en/support/kb/release-notes/amdgpu-installation\" rel=\"nofollow\">https://www.amd.com/en/support/kb/release-notes/amdgpu-installation</a></li>\n</ul>\n<p><em>ARM</em>:</p>\n<ul>\n<li><a href=\"https://developer.arm.com/docs/100614/0312\" rel=\"nofollow\">https://developer.arm.com/docs/100614/0312</a></li>\n</ul>\n<p><em>Intel</em>:</p>\n<ul>\n<li><a href=\"https://software.intel.com/en-us/articles/opencl-drivers\" rel=\"nofollow\">https://software.intel.com/en-us/articles/opencl-drivers</a></li>\n<li><a href=\"https://software.intel.com/en-us/articles/sdk-for-opencl-gsg\" rel=\"nofollow\">https://software.intel.com/en-us/articles/sdk-for-opencl-gsg</a></li>\n</ul>\n<p><em>NVIDIA</em>:</p>\n<ul>\n<li><a href=\"https://developer.nvidia.com/opencl\" rel=\"nofollow\">https://developer.nvidia.com/opencl</a></li>\n<li><a href=\"https://developer.nvidia.com/cuda-downloads\" rel=\"nofollow\">https://developer.nvidia.com/cuda-downloads</a></li>\n</ul>\n<p><em>Vendor-independent</em>:</p>\n<ul>\n<li><a href=\"http://portablecl.org\" rel=\"nofollow\">http://portablecl.org</a></li>\n</ul>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<div id=\"basic-computations\">\n<h3>Basic Computations</h3>\n<p>RQA computations are conducted as follows.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyrqa.time_series</span> <span class=\"kn\">import</span> <span class=\"n\">TimeSeries</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.settings</span> <span class=\"kn\">import</span> <span class=\"n\">Settings</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.analysis_type</span> <span class=\"kn\">import</span> <span class=\"n\">Classic</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.neighbourhood</span> <span class=\"kn\">import</span> <span class=\"n\">FixedRadius</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.metric</span> <span class=\"kn\">import</span> <span class=\"n\">EuclideanMetric</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.computation</span> <span class=\"kn\">import</span> <span class=\"n\">RQAComputation</span>\n<span class=\"n\">data_points</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"mf\">1.4</span><span class=\"p\">,</span> <span class=\"mf\">1.6</span><span class=\"p\">,</span> <span class=\"mf\">1.2</span><span class=\"p\">,</span> <span class=\"mf\">0.4</span><span class=\"p\">,</span> <span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">1.3</span><span class=\"p\">]</span>\n<span class=\"n\">time_series</span> <span class=\"o\">=</span> <span class=\"n\">TimeSeries</span><span class=\"p\">(</span><span class=\"n\">data_points</span><span class=\"p\">,</span>\n                         <span class=\"n\">embedding_dimension</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n                         <span class=\"n\">time_delay</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">settings</span> <span class=\"o\">=</span> <span class=\"n\">Settings</span><span class=\"p\">(</span><span class=\"n\">time_series</span><span class=\"p\">,</span>\n                    <span class=\"n\">analysis_type</span><span class=\"o\">=</span><span class=\"n\">Classic</span><span class=\"p\">,</span>\n                    <span class=\"n\">neighbourhood</span><span class=\"o\">=</span><span class=\"n\">FixedRadius</span><span class=\"p\">(</span><span class=\"mf\">0.65</span><span class=\"p\">),</span>\n                    <span class=\"n\">similarity_measure</span><span class=\"o\">=</span><span class=\"n\">EuclideanMetric</span><span class=\"p\">,</span>\n                    <span class=\"n\">theiler_corrector</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">computation</span> <span class=\"o\">=</span> <span class=\"n\">RQAComputation</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">settings</span><span class=\"p\">,</span>\n                                    <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">computation</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n<span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">min_diagonal_line_length</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">min_vertical_line_length</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">min_white_vertical_line_length</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<p>The following output is expected.</p>\n<pre>RQA Result:\n===========\n\nMinimum diagonal line length (L_min): 2\nMinimum vertical line length (V_min): 2\nMinimum white vertical line length (W_min): 2\n\nRecurrence rate (RR): 0.371901\nDeterminism (DET): 0.411765\nAverage diagonal line length (L): 2.333333\nLongest diagonal line length (L_max): 3\nDivergence (DIV): 0.333333\nEntropy diagonal lines (L_entr): 0.636514\nLaminarity (LAM): 0.400000\nTrapping time (TT): 2.571429\nLongest vertical line length (V_max): 4\nEntropy vertical lines (V_entr): 0.955700\nAverage white vertical line length (W): 2.538462\nLongest white vertical line length (W_max): 6\nLongest white vertical line length inverse (W_div): 0.166667\nEntropy white vertical lines (W_entr): 0.839796\n\nRatio determinism / recurrence rate (DET/RR): 1.107190\nRatio laminarity / determinism (LAM/DET): 0.971429\n</pre>\n<p>The corresponding recurrence plot is computed likewise. Note that the\n<tt>theiler_corrector</tt> is ignored regarding the creation of the plot.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyrqa.computation</span> <span class=\"kn\">import</span> <span class=\"n\">RPComputation</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.image_generator</span> <span class=\"kn\">import</span> <span class=\"n\">ImageGenerator</span>\n<span class=\"n\">computation</span> <span class=\"o\">=</span> <span class=\"n\">RPComputation</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">settings</span><span class=\"p\">)</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">computation</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n<span class=\"n\">ImageGenerator</span><span class=\"o\">.</span><span class=\"n\">save_recurrence_plot</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">recurrence_matrix_reverse</span><span class=\"p\">,</span>\n                                    <span class=\"s1\">'recurrence_plot.png'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"cross-recurrence-analysis\">\n<h3>Cross Recurrence Analysis</h3>\n<p>PyRQA further offers the opportunity to conduct cross recurrence\nanalysis (<em>CRQA</em> and <em>CRP</em>), in addition to the classic recurrence\nanalysis (<em>RQA</em> and <em>RP</em>). For this purpose, two time series of\npotentially different length are provided as input. Note that the\ncorresponding computations require to set the same value regarding the\nembedding dimension. Two different time delay values may be used\nregarding the first and the second time series. To enable cross\nrecurrence analysis, the <tt>analysis_type</tt> argument has to be changed\nfrom <tt>Classic</tt> to <tt>Cross</tt>, when creating the <tt>Settings</tt> object. A\n<em>CRQA</em> example is given below.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyrqa.analysis_type</span> <span class=\"kn\">import</span> <span class=\"n\">Cross</span>\n<span class=\"n\">data_points_x</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">1.7</span><span class=\"p\">,</span> <span class=\"mf\">0.4</span><span class=\"p\">,</span> <span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">]</span>\n<span class=\"n\">time_series_x</span> <span class=\"o\">=</span> <span class=\"n\">TimeSeries</span><span class=\"p\">(</span><span class=\"n\">data_points_x</span><span class=\"p\">,</span>\n                           <span class=\"n\">embedding_dimension</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n                           <span class=\"n\">time_delay</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">data_points_y</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"mf\">0.6</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"mf\">1.9</span><span class=\"p\">,</span> <span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"mf\">0.4</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"mf\">1.6</span><span class=\"p\">]</span>\n<span class=\"n\">time_series_y</span> <span class=\"o\">=</span> <span class=\"n\">TimeSeries</span><span class=\"p\">(</span><span class=\"n\">data_points_y</span><span class=\"p\">,</span>\n                           <span class=\"n\">embedding_dimension</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n                           <span class=\"n\">time_delay</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">time_series</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">time_series_x</span><span class=\"p\">,</span>\n               <span class=\"n\">time_series_y</span><span class=\"p\">)</span>\n<span class=\"n\">settings</span> <span class=\"o\">=</span> <span class=\"n\">Settings</span><span class=\"p\">(</span><span class=\"n\">time_series</span><span class=\"p\">,</span>\n                    <span class=\"n\">analysis_type</span><span class=\"o\">=</span><span class=\"n\">Cross</span><span class=\"p\">,</span>\n                    <span class=\"n\">neighbourhood</span><span class=\"o\">=</span><span class=\"n\">FixedRadius</span><span class=\"p\">(</span><span class=\"mf\">0.73</span><span class=\"p\">),</span>\n                    <span class=\"n\">similarity_measure</span><span class=\"o\">=</span><span class=\"n\">EuclideanMetric</span><span class=\"p\">,</span>\n                    <span class=\"n\">theiler_corrector</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">computation</span> <span class=\"o\">=</span> <span class=\"n\">RQAComputation</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">settings</span><span class=\"p\">,</span>\n                                    <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">computation</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n<span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">min_diagonal_line_length</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">min_vertical_line_length</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">min_white_vertical_line_length</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<p>The following output is expected.</p>\n<pre>CRQA Result:\n============\n\nMinimum diagonal line length (L_min): 2\nMinimum vertical line length (V_min): 2\nMinimum white vertical line length (W_min): 2\n\nRecurrence rate (RR): 0.319444\nDeterminism (DET): 0.521739\nAverage diagonal line length (L): 2.400000\nLongest diagonal line length (L_max): 3\nDivergence (DIV): 0.333333\nEntropy diagonal lines (L_entr): 0.673012\nLaminarity (LAM): 0.434783\nTrapping time (TT): 2.500000\nLongest vertical line length (V_max): 3\nEntropy vertical lines (V_entr): 0.693147\nAverage white vertical line length (W): 3.500000\nLongest white vertical line length (W_max): 8\nLongest white vertical line length inverse (W_div): 0.125000\nEntropy white vertical lines (W_entr): 1.424130\n\nRatio determinism / recurrence rate (DET/RR): 1.633270\nRatio laminarity / determinism (LAM/DET): 0.833333\n</pre>\n<p>The corresponding cross recurrence plot is computed likewise.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyrqa.computation</span> <span class=\"kn\">import</span> <span class=\"n\">RPComputation</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.image_generator</span> <span class=\"kn\">import</span> <span class=\"n\">ImageGenerator</span>\n<span class=\"n\">computation</span> <span class=\"o\">=</span> <span class=\"n\">RPComputation</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">settings</span><span class=\"p\">)</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">computation</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n<span class=\"n\">ImageGenerator</span><span class=\"o\">.</span><span class=\"n\">save_recurrence_plot</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">recurrence_matrix_reverse</span><span class=\"p\">,</span>\n                                    <span class=\"s1\">'cross_recurrence_plot.png'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"neighbourhood-condition-selection\">\n<h3>Neighbourhood Condition Selection</h3>\n<p>PyRQA currently supports the fixed radius as well as the radius corridor\nneighbourhood condition. While the first refers to a single radius, the\nlatter requires the assignment of an inner and outer radius. The\nspecific condition is passed as <tt>neighbourhood</tt> argument to the\nconstructor of a <tt>Settings</tt> object. The creation of a fixed radius and\na radius corridor neighbourhood is presented below.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyrqa.neighbourhood</span> <span class=\"kn\">import</span> <span class=\"n\">FixedRadius</span><span class=\"p\">,</span> <span class=\"n\">RadiusCorridor</span>\n<span class=\"n\">fixed_radius</span> <span class=\"o\">=</span> <span class=\"n\">FixedRadius</span><span class=\"p\">(</span><span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"mf\">0.43</span><span class=\"p\">)</span>\n<span class=\"n\">radius_corridor</span> <span class=\"o\">=</span> <span class=\"n\">RadiusCorridor</span><span class=\"p\">(</span><span class=\"n\">inner_radius</span><span class=\"o\">=</span><span class=\"mf\">0.32</span><span class=\"p\">,</span>\n                                 <span class=\"n\">outer_radius</span><span class=\"o\">=</span><span class=\"mf\">0.86</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"unthresholded-recurrence-plots\">\n<h3>Unthresholded Recurrence Plots</h3>\n<p>PyRQA allows to create unthresholded <em>RP</em>s and <em>CRP</em>s by selecting\nthe <tt>Unthresholded</tt> neighbourhood condition. This results in a\nnon-binary matrix, containing the mutual distances between the system\nstates, based on the similarity measure selected. Functionality is\nprovided to normalize these distances to values between <tt>0</tt> and <tt>1</tt>.\nThe normalized matrix can further be represented as a grayscale image.\nDarker shades of grey indicate smaller distances whereas lighter shades\nof grey indicate larger distances. An example on how to create an\nunthresholded cross recurrence plot is given below.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyrqa.neighbourhood</span> <span class=\"kn\">import</span> <span class=\"n\">Unthresholded</span>\n<span class=\"n\">settings</span> <span class=\"o\">=</span> <span class=\"n\">Settings</span><span class=\"p\">(</span><span class=\"n\">time_series</span><span class=\"p\">,</span>\n                    <span class=\"n\">analysis_type</span><span class=\"o\">=</span><span class=\"n\">Cross</span><span class=\"p\">,</span>\n                    <span class=\"n\">neighbourhood</span><span class=\"o\">=</span><span class=\"n\">Unthresholded</span><span class=\"p\">(),</span>\n                    <span class=\"n\">similarity_measure</span><span class=\"o\">=</span><span class=\"n\">EuclideanMetric</span><span class=\"p\">)</span>\n<span class=\"n\">computation</span> <span class=\"o\">=</span> <span class=\"n\">RPComputation</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">settings</span><span class=\"p\">)</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">computation</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n<span class=\"n\">ImageGenerator</span><span class=\"o\">.</span><span class=\"n\">save_unthresholded_recurrence_plot</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">recurrence_matrix_reverse_normalized</span><span class=\"p\">,</span>\n                                                  <span class=\"s1\">'unthresholded_cross_recurrence_plot.png'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"joint-recurrence-analysis\">\n<h3>Joint Recurrence Analysis</h3>\n<p>In addition to classic and cross recurrence analysis, PyRQA provides\nfunctionality to conduct joint recurrence analysis. This includes in\nparticular joint recurrence plots (<em>JRP</em>) as well as joint recurrence\nquantification analysis (<em>JRQA</em>). On an abstract level, a joint\nrecurrence plot is a combination of two individual plots, both having\nthe same extent regarding the <em>X</em> and <em>Y</em> axis. Each of those two plots\nmay either be of the analysis type <tt>Classic</tt> or <tt>Cross</tt>, potentially\nhaving different characteristics regarding:</p>\n<ul>\n<li>Time series data,</li>\n<li>Embedding dimension,</li>\n<li>Time delay,</li>\n<li>Neighbourhood condition, and</li>\n<li>Similarity measure.</li>\n</ul>\n<p>In contrast, the same value for <tt>theiler_corrector</tt> is expected\nregarding the quantitative analysis. Note that a joint recurrence plot\nby definition relies on thresholded input plots, eliminating the\napplication of the <tt>Unthresholded</tt> neighbourhood condition.</p>\n<p>The settings of the two individual plots are encapsulated in a\n<tt>JointSettings</tt> object. The quantification of joint recurrence plots\nis based on the same measures as for recurrence plots and cross\nrecurrence plots. An example on how to conduct <em>JRQA</em> is given below.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyrqa.computation</span> <span class=\"kn\">import</span> <span class=\"n\">JRQAComputation</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.metric</span> <span class=\"kn\">import</span> <span class=\"n\">MaximumMetric</span><span class=\"p\">,</span> <span class=\"n\">TaxicabMetric</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.settings</span> <span class=\"kn\">import</span> <span class=\"n\">JointSettings</span>\n<span class=\"n\">data_points_1</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">1.7</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"mf\">1.2</span><span class=\"p\">,</span> <span class=\"mf\">0.4</span><span class=\"p\">,</span> <span class=\"mf\">0.6</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">]</span>\n<span class=\"n\">time_series_1</span> <span class=\"o\">=</span> <span class=\"n\">TimeSeries</span><span class=\"p\">(</span><span class=\"n\">data_points</span><span class=\"p\">,</span>\n                           <span class=\"n\">embedding_dimension</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span>\n                           <span class=\"n\">time_delay</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">settings_1</span> <span class=\"o\">=</span> <span class=\"n\">Settings</span><span class=\"p\">(</span><span class=\"n\">time_series_1</span><span class=\"p\">,</span>\n                      <span class=\"n\">analysis_type</span><span class=\"o\">=</span><span class=\"n\">Classic</span><span class=\"p\">,</span>\n                      <span class=\"n\">neighbourhood</span><span class=\"o\">=</span><span class=\"n\">RadiusCorridor</span><span class=\"p\">(</span><span class=\"n\">inner_radius</span><span class=\"o\">=</span><span class=\"mf\">0.14</span><span class=\"p\">,</span>\n                                                   <span class=\"n\">outer_radius</span><span class=\"o\">=</span><span class=\"mf\">0.97</span><span class=\"p\">),</span>\n                      <span class=\"n\">similarity_measure</span><span class=\"o\">=</span><span class=\"n\">MaximumMetric</span><span class=\"p\">,</span>\n                      <span class=\"n\">theiler_corrector</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">data_points_2_x</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"mf\">1.4</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.9</span><span class=\"p\">,</span> <span class=\"mf\">1.7</span><span class=\"p\">,</span> <span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"mf\">0.6</span><span class=\"p\">]</span>\n<span class=\"n\">time_series_2_x</span> <span class=\"o\">=</span> <span class=\"n\">TimeSeries</span><span class=\"p\">(</span><span class=\"n\">data_points_2_x</span><span class=\"p\">,</span>\n                             <span class=\"n\">embedding_dimension</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n                             <span class=\"n\">time_delay</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">data_points_2_y</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.4</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mf\">1.9</span><span class=\"p\">,</span> <span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"mf\">1.2</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"mf\">0.6</span><span class=\"p\">,</span> <span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">]</span>\n<span class=\"n\">time_series_2_y</span> <span class=\"o\">=</span> <span class=\"n\">TimeSeries</span><span class=\"p\">(</span><span class=\"n\">data_points_2_y</span><span class=\"p\">,</span>\n                             <span class=\"n\">embedding_dimension</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n                             <span class=\"n\">time_delay</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">time_series_2</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">time_series_2_x</span><span class=\"p\">,</span>\n                 <span class=\"n\">time_series_2_y</span><span class=\"p\">)</span>\n<span class=\"n\">settings_2</span> <span class=\"o\">=</span> <span class=\"n\">Settings</span><span class=\"p\">(</span><span class=\"n\">time_series_2</span><span class=\"p\">,</span>\n                      <span class=\"n\">analysis_type</span><span class=\"o\">=</span><span class=\"n\">Cross</span><span class=\"p\">,</span>\n                      <span class=\"n\">neighbourhood</span><span class=\"o\">=</span><span class=\"n\">FixedRadius</span><span class=\"p\">(</span><span class=\"mf\">0.83</span><span class=\"p\">),</span>\n                      <span class=\"n\">similarity_measure</span><span class=\"o\">=</span><span class=\"n\">TaxicabMetric</span><span class=\"p\">,</span>\n                      <span class=\"n\">theiler_corrector</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">joint_settings</span> <span class=\"o\">=</span> <span class=\"n\">JointSettings</span><span class=\"p\">(</span><span class=\"n\">settings_1</span><span class=\"p\">,</span>\n                               <span class=\"n\">settings_2</span><span class=\"p\">)</span>\n<span class=\"n\">computation</span> <span class=\"o\">=</span> <span class=\"n\">JRQAComputation</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">joint_settings</span><span class=\"p\">,</span>\n                                     <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">computation</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n<span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">min_diagonal_line_length</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">min_vertical_line_length</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">min_white_vertical_line_length</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">)</span>\n</pre>\n<p>The following output is expected.</p>\n<pre>JRQA Result:\n============\n\nMinimum diagonal line length (L_min): 2\nMinimum vertical line length (V_min): 1\nMinimum white vertical line length (W_min): 2\n\nRecurrence rate (RR): 0.157025\nDeterminism (DET): 0.263158\nAverage diagonal line length (L): 2.500000\nLongest diagonal line length (L_max): 3\nDivergence (DIV): 0.333333\nEntropy diagonal lines (L_entr): 0.693147\nLaminarity (LAM): 1.000000\nTrapping time (TT): 1.000000\nLongest vertical line length (V_max): 1\nEntropy vertical lines (V_entr): 0.000000\nAverage white vertical line length (W): 3.960000\nLongest white vertical line length (W_max): 11\nLongest white vertical line length inverse (W_div): 0.090909\nEntropy white vertical lines (W_entr): 1.588760\n\nRatio determinism / recurrence rate (DET/RR): 1.675900\nRatio laminarity / determinism (LAM/DET): 3.800000\n</pre>\n<p>The corresponding joint recurrence plot is computed likewise.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyrqa.computation</span> <span class=\"kn\">import</span> <span class=\"n\">JRPComputation</span>\n<span class=\"n\">computation</span> <span class=\"o\">=</span> <span class=\"n\">JRPComputation</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">joint_settings</span><span class=\"p\">)</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">computation</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n<span class=\"n\">ImageGenerator</span><span class=\"o\">.</span><span class=\"n\">save_recurrence_plot</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">recurrence_matrix_reverse</span><span class=\"p\">,</span>\n                                    <span class=\"s1\">'joint_recurrence_plot.png'</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"custom-opencl-environment\">\n<h3>Custom OpenCL Environment</h3>\n<p>The previous examples use the default OpenCL environment. A custom\nenvironment can also be created via command line input. For this\npurpose, the <tt>command_line</tt> argument has to be set to <tt>True</tt>, when\ncreating an <tt>OpenCL</tt> object.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyrqa.opencl</span> <span class=\"kn\">import</span> <span class=\"n\">OpenCL</span>\n<span class=\"n\">opencl</span> <span class=\"o\">=</span> <span class=\"n\">OpenCL</span><span class=\"p\">(</span><span class=\"n\">command_line</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>The OpenCL platform as well as the computing devices can also be\nselected manually using their identifiers.</p>\n<pre><span class=\"n\">opencl</span> <span class=\"o\">=</span> <span class=\"n\">OpenCL</span><span class=\"p\">(</span><span class=\"n\">platform_id</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n                <span class=\"n\">device_ids</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,))</span>\n<span class=\"n\">computation</span> <span class=\"o\">=</span> <span class=\"n\">RPComputation</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">settings</span><span class=\"p\">,</span>\n                                   <span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n                                   <span class=\"n\">opencl</span><span class=\"o\">=</span><span class=\"n\">opencl</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"floating-point-precision\">\n<h3>Floating Point Precision</h3>\n<p>It is possible to specify the precision of the time series data, which\nin turn determines the precision of the computations conducted by the\nOpenCL devices. Currently, the following precisions are supported by\nPyRQA:</p>\n<ul>\n<li>Half precision (16-bit),</li>\n<li>Single precision (32-bit), and</li>\n<li>Double precision (64-bit).</li>\n</ul>\n<p>By default, the single precision is applied. Note that not all\nprecisions may be supported by the OpenCL devices employed. Furthermore,\nthe selected precision influences the performance of the computations on\na particular device.</p>\n<p>The precision is set by specifying the corresponding data type, short\n<tt>dtype</tt>, of the time series data. The following example depicts the\nusage of double precision floating point values.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"n\">time_series</span> <span class=\"o\">=</span> <span class=\"n\">TimeSeries</span><span class=\"p\">(</span><span class=\"n\">data_points</span><span class=\"p\">,</span>\n                         <span class=\"n\">embedding_dimension</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n                         <span class=\"n\">time_delay</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n                         <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"performance-tuning\">\n<h2>Performance Tuning</h2>\n<div id=\"opencl-compiler-optimisations-enablement\">\n<h3>OpenCL Compiler Optimisations Enablement</h3>\n<p>OpenCL compiler optimisations aim at improving the performance of the\noperations conducted by the computing devices. Regarding PyRQA, they are\ndisabled by default to ensure the comparability of the analytical\nresults. They can be enabled by assigning the value <tt>True</tt> to the\ncorresponding keyword argument <tt>optimisations_enabled</tt>.</p>\n<pre><span class=\"n\">computation</span> <span class=\"o\">=</span> <span class=\"n\">RPComputation</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">settings</span><span class=\"p\">,</span>\n                                   <span class=\"n\">variants_kwargs</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'optimisations_enabled'</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">})</span>\n</pre>\n</div>\n<div id=\"adaptive-implementation-selection\">\n<h3>Adaptive Implementation Selection</h3>\n<p>Adaptive implementation selection allows to automatically select well\nperforming implementations regarding RQA and recurrence plot\ncomputations, provided by PyRQA. The approach dynamically adapts the\nselection to the current computational scenario as well as the\nproperties of the OpenCL devices employed. The selection is performed\nusing one of multiple strategies, each referred to as <tt>selector</tt>. They\nrely on a set of customized implementation <tt>variants</tt>, which may be\nparameterized using a set of keyword arguments called\n<tt>variants_kwargs</tt>. Note that the same selection strategies can be used\nfor <em>RQA</em> and <em>CRQA</em>, <em>RP</em> and <em>CRP</em>, <em>URP</em> and <em>UCRP</em> as well as <em>JRQA</em>\nand <em>JRP</em> computations.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pyrqa.variants.rqa.radius.column_materialisation_bit_no_recycling</span> <span class=\"kn\">import</span> <span class=\"n\">ColumnMaterialisationBitNoRecycling</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.variants.rqa.radius.column_materialisation_bit_recycling</span> <span class=\"kn\">import</span> <span class=\"n\">ColumnMaterialisationBitRecycling</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.variants.rqa.radius.column_materialisation_byte_no_recycling</span> <span class=\"kn\">import</span> <span class=\"n\">ColumnMaterialisationByteNoRecycling</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.variants.rqa.radius.column_materialisation_byte_recycling</span> <span class=\"kn\">import</span> <span class=\"n\">ColumnMaterialisationByteRecycling</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.variants.rqa.radius.column_no_materialisation</span> <span class=\"kn\">import</span> <span class=\"n\">ColumnNoMaterialisation</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyrqa.selector</span> <span class=\"kn\">import</span> <span class=\"n\">EpsilonGreedySelector</span>\n<span class=\"n\">data_points</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">1.3</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"mf\">1.4</span><span class=\"p\">,</span> <span class=\"mf\">1.6</span><span class=\"p\">,</span> <span class=\"mf\">1.2</span><span class=\"p\">,</span> <span class=\"mf\">0.4</span><span class=\"p\">,</span> <span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">1.3</span><span class=\"p\">]</span>\n<span class=\"n\">time_series</span> <span class=\"o\">=</span> <span class=\"n\">TimeSeries</span><span class=\"p\">(</span><span class=\"n\">data_points</span><span class=\"p\">,</span>\n                         <span class=\"n\">embedding_dimension</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n                         <span class=\"n\">time_delay</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">settings</span> <span class=\"o\">=</span> <span class=\"n\">Settings</span><span class=\"p\">(</span><span class=\"n\">time_series</span><span class=\"p\">,</span>\n                    <span class=\"n\">analysis_type</span><span class=\"o\">=</span><span class=\"n\">Classic</span><span class=\"p\">,</span>\n                    <span class=\"n\">neighbourhood</span><span class=\"o\">=</span><span class=\"n\">FixedRadius</span><span class=\"p\">(</span><span class=\"mf\">0.65</span><span class=\"p\">),</span>\n                    <span class=\"n\">similarity_measure</span><span class=\"o\">=</span><span class=\"n\">EuclideanMetric</span><span class=\"p\">,</span>\n                    <span class=\"n\">theiler_corrector</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">computation</span> <span class=\"o\">=</span> <span class=\"n\">RQAComputation</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">settings</span><span class=\"p\">,</span>\n                                    <span class=\"n\">selector</span><span class=\"o\">=</span><span class=\"n\">EpsilonGreedySelector</span><span class=\"p\">(</span><span class=\"n\">explore</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">),</span>\n                                    <span class=\"n\">variants</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">ColumnMaterialisationBitNoRecycling</span><span class=\"p\">,</span>\n                                              <span class=\"n\">ColumnMaterialisationBitRecycling</span><span class=\"p\">,</span>\n                                              <span class=\"n\">ColumnMaterialisationByteNoRecycling</span><span class=\"p\">,</span>\n                                              <span class=\"n\">ColumnMaterialisationByteRecycling</span><span class=\"p\">,</span>\n                                              <span class=\"n\">ColumnNoMaterialisation</span><span class=\"p\">),</span>\n                                    <span class=\"n\">variants_kwargs</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'optimisations_enabled'</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">})</span>\n</pre>\n</div>\n</div>\n<div id=\"testing\">\n<h2>Testing</h2>\n<p>PyRQA provides a single-threaded baseline implementation for each\nanalytical method. These implementations do not use OpenCL\nfunctionality. They serve as a ground truth regarding the analytical\ncomputations. The basic tests for all supported analytical methods can\nbe executed cumulatively.</p>\n<pre>python -m pyrqa.test\n</pre>\n<p>The complete set of tests can be executed by adding the option\n<tt><span class=\"pre\">--all</span></tt>.</p>\n<pre>python -m pyrqa.test --all\n</pre>\n<p>Note that there might occur minor deviations regarding the analytical\nresults. These deviations may stem from varying precisions regarding the\ncomputing devices employed.</p>\n</div>\n<div id=\"origin\">\n<h2>Origin</h2>\n<p>The PyRQA package was initiated by computer scientists from the\nHumboldt-Universit\u00e4t zu Berlin (<a href=\"https://www.hu-berlin.de\" rel=\"nofollow\">https://www.hu-berlin.de</a>) and the GFZ\nGerman Research Centre for Geosciences (<a href=\"https://www.gfz-potsdam.de\" rel=\"nofollow\">https://www.gfz-potsdam.de</a>).</p>\n</div>\n<div id=\"acknowledgements\">\n<h2>Acknowledgements</h2>\n<p>We would like to thank Norbert Marwan from the Potsdam Institute for\nClimate Impact Research (<a href=\"https://www.pik-potsdam.de\" rel=\"nofollow\">https://www.pik-potsdam.de</a>) for his continuous\nsupport of the project. Please visit his website\n<a href=\"http://recurrence-plot.tk/\" rel=\"nofollow\">http://recurrence-plot.tk/</a> for further information on recurrence\nanalysis. Initial research and development of PyRQA was funded by the\nDeutsche Forschungsgemeinschaft (<a href=\"https://www.dfg.de/\" rel=\"nofollow\">https://www.dfg.de/</a>).</p>\n</div>\n<div id=\"publications\">\n<h2>Publications</h2>\n<p>The underlying computational approach of PyRQA is described in detail\nwithin the following thesis, which is openly accessible at\n<a href=\"https://edoc.hu-berlin.de/handle/18452/19518\" rel=\"nofollow\">https://edoc.hu-berlin.de/handle/18452/19518</a>.</p>\n<blockquote>\nRawald, T. (2018): Scalable and Efficient Analysis of Large\nHigh-Dimensional Data Sets in the Context of Recurrence Analysis,\nPhD Thesis, Berlin : Humboldt-Universit\u00e4t zu Berlin, 299 p.</blockquote>\n<p>Selected aspects of the computational approach are presented within the\nfollowing publications.</p>\n<blockquote>\n<p>Rawald, T., Sips, M., Marwan, N., Dransch, D. (2014): Fast\nComputation of Recurrences in Long Time Series. - In: Marwan, N.,\nRiley, M., Guiliani, A., Webber, C. (Eds.), Translational\nRecurrences. From Mathematical Theory to Real-World Applications,\n(Springer Proceedings in Mathematics and Statistics ; 103), p.\n17-29.</p>\n<p>Rawald, T., Sips, M., Marwan, N., Leser, U. (2015): Massively\nParallel Analysis of Similarity Matrices on Heterogeneous Hardware.\n- In: Fischer, P. M., Alonso, G., Arenas, M., Geerts, F. (Eds.),\nProceedings of the Workshops of the EDBT/ICDT 2015 Joint Conference\n(EDBT/ICDT), (CEUR Workshop Proceedings ; 1330), p. 56-62.</p>\n</blockquote>\n</div>\n<div id=\"release-notes\">\n<h2>Release Notes</h2>\n<div id=\"id1\">\n<h3>6.0.0</h3>\n<ul>\n<li>Addition of the joint recurrence quantification analysis (<em>JRQA</em>) and\njoint recurrence plot (<em>JRP</em>) computations.</li>\n<li>Refactoring of the test implementation.</li>\n<li>Refactoring of the public API.</li>\n<li>Updated documentation.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>5.1.0</h3>\n<ul>\n<li>Addition of the unthresholded recurrence plot (<em>URP</em>) and\nunthresholded cross recurrence plot (<em>UCRP</em>) computations.</li>\n<li>Updated documentation.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>5.0.0</h3>\n<ul>\n<li>Refactoring of the public API.</li>\n<li>Updated documentation.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>4.1.0</h3>\n<ul>\n<li>Usage of two different time delay values regarding the cross\nrecurrence plot (<em>CRP</em>) and cross recurrence quantification analysis\n(<em>CRQA</em>).</li>\n<li>Updated documentation.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3>4.0.0</h3>\n<ul>\n<li>Addition of the cross recurrence plot (<em>CRP</em>) and cross recurrence\nquantification analysis (<em>CRQA</em>) computations.</li>\n<li>Addition of the radius corridor neighbourhood condition for\ndetermining state similarity.</li>\n<li>Addition of an additional variant regarding recurrence plot\ncomputations.</li>\n<li>Renaming of directories and classes referring to recurrence plot\ncomputations.</li>\n<li>Removal of obsolete source code.</li>\n<li>Updated documentation.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3>3.0.0</h3>\n<ul>\n<li>Source code cleanup.</li>\n<li>Renaming of the implementation variants regarding RQA and recurrence\nplot processing.</li>\n<li>Removal of the module <tt>file_reader.py</tt>. Please refer for example to\n<tt>numpy.genfromtxt</tt> to read data from files (see\n<a href=\"https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html\" rel=\"nofollow\">https://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html</a>).</li>\n<li>Updated documentation.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3>2.0.1</h3>\n<ul>\n<li>Updated documentation.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3>2.0.0</h3>\n<ul>\n<li>Major refactoring.</li>\n<li>Removal of operator and variant implementations that do not refer to\nOpenCL brute force computing.</li>\n<li>Time series data may be represented using half, single and double\nprecision floating point values, which is reflected in the\ncomputations on the OpenCL devices.</li>\n<li>Several changes to the public API.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3>1.0.6</h3>\n<ul>\n<li>Changes to the public API have been made, e.g., to the definition of\nthe settings. This leads to an increase in the major version number\n(see <a href=\"https://semver.org/\" rel=\"nofollow\">https://semver.org/</a>).</li>\n<li>Time series objects either consist of one or multiple series. The\nformer requires to specify a value for the embedding delay as well as\nthe time delay parameter.</li>\n<li>Regarding the RQA computations, minimum line lengths are now\nspecified on the result object. This allows to compute quantitative\nresults using different lengths without having to inspect the matrix\nusing the same parametrisation multiple times.</li>\n<li>Modules for selecting well-performing implementations based on greedy\nselection strategies have been added. By default, the selection pool\nconsists of a single pre-defined implementation.</li>\n<li>Operators and implementation variants based on multidimensional\nsearch trees and grid data structures have been added.</li>\n<li>The diagonal line based quantitative measures are modified regarding\nthe semantics of the Theiler corrector.</li>\n<li>The creation of the OpenCL environment now supports device fission.</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3>0.1.0</h3>\n<ul>\n<li>Initial release.</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 7131042, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "b37236bea985352cf256f326ca3f9f7a", "sha256": "957894bb11598bd34451014e919a939437554f38ee4469d58e4f995173f8942f"}, "downloads": -1, "filename": "PyRQA-0.1.0.tar.gz", "has_sig": false, "md5_digest": "b37236bea985352cf256f326ca3f9f7a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 43864, "upload_time": "2015-07-29T12:56:19", "upload_time_iso_8601": "2015-07-29T12:56:19.638686Z", "url": "https://files.pythonhosted.org/packages/31/7d/dee51c852ad8a4d23c8a1184df779499863b80978349fef574c024a19f91/PyRQA-0.1.0.tar.gz", "yanked": false}], "1.0.6": [{"comment_text": "", "digests": {"md5": "0b8ed5c63eca77f0bbac24267a2143fc", "sha256": "51ef476c904a832f533a44cd2f6d5d547a830626ce0ce6f675684dd650f68dc9"}, "downloads": -1, "filename": "PyRQA-1.0.6.tar.gz", "has_sig": false, "md5_digest": "0b8ed5c63eca77f0bbac24267a2143fc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 68578, "upload_time": "2018-09-14T23:19:35", "upload_time_iso_8601": "2018-09-14T23:19:35.982229Z", "url": "https://files.pythonhosted.org/packages/44/da/1d21750c6d9750655167d662702a37155f9838f467747d5e26e3c2e148f6/PyRQA-1.0.6.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "53ee829492755c8cc12b06b1ebd7b981", "sha256": "0664b2a16e91db95f32d81d3c195ceda6d892912ca5bb51ece594a2ca982e337"}, "downloads": -1, "filename": "PyRQA-2.0.0.tar.gz", "has_sig": false, "md5_digest": "53ee829492755c8cc12b06b1ebd7b981", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 57227, "upload_time": "2018-12-19T21:19:53", "upload_time_iso_8601": "2018-12-19T21:19:53.480321Z", "url": "https://files.pythonhosted.org/packages/8c/af/83d38daab097d0deb3b9c254090ddd98ed3f1e70d00a405c765111890662/PyRQA-2.0.0.tar.gz", "yanked": false}], "2.0.1": [{"comment_text": "", "digests": {"md5": "d53dc2a14473aa78e3a868f7d8a6795e", "sha256": "8976cb8fe68617f7c9bf5fe7aba0f162b46c44770f5797ea6d3f4e0311ff0477"}, "downloads": -1, "filename": "PyRQA-2.0.1.tar.gz", "has_sig": false, "md5_digest": "d53dc2a14473aa78e3a868f7d8a6795e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 57803, "upload_time": "2019-02-02T15:21:22", "upload_time_iso_8601": "2019-02-02T15:21:22.111284Z", "url": "https://files.pythonhosted.org/packages/2b/73/1fcc91ae4ca0d6db828a83b0f6320ab50ae204c425bb2e0582c1a5acc979/PyRQA-2.0.1.tar.gz", "yanked": false}], "3.0.0": [{"comment_text": "", "digests": {"md5": "f36da0bdc0c02cbacad1a713de76bf61", "sha256": "b59a6fd6b5cfe64c2fc4b8afe860c84fe9a3542414a59e92229fab60c1c39874"}, "downloads": -1, "filename": "PyRQA-3.0.0.tar.gz", "has_sig": false, "md5_digest": "f36da0bdc0c02cbacad1a713de76bf61", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 55957, "upload_time": "2019-04-06T20:20:54", "upload_time_iso_8601": "2019-04-06T20:20:54.324163Z", "url": "https://files.pythonhosted.org/packages/9b/0c/45f68282cd84b886a6bf8767523c43f03f34d64eb89a67bef89ca15eeec2/PyRQA-3.0.0.tar.gz", "yanked": false}], "4.0.0": [{"comment_text": "", "digests": {"md5": "1cd31dfa8736c708e77a10b9b8d4fd6f", "sha256": "1de307d314ee3ba883cd37f289f533d75e182546632922c36df5d82b89514e5f"}, "downloads": -1, "filename": "PyRQA-4.0.0.tar.gz", "has_sig": false, "md5_digest": "1cd31dfa8736c708e77a10b9b8d4fd6f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 62199, "upload_time": "2019-07-26T20:29:16", "upload_time_iso_8601": "2019-07-26T20:29:16.404027Z", "url": "https://files.pythonhosted.org/packages/43/90/1f458ba9cd67b9226e89f8a3d87eb4af8ed7001a109b270b813781e3a3e9/PyRQA-4.0.0.tar.gz", "yanked": false}], "4.1.0": [{"comment_text": "", "digests": {"md5": "05aa50db558796d64cbe25a8b305bb57", "sha256": "ed6a44c3da4a570407a40783fd6b375211d676ab26c45209e84695165a4f07a1"}, "downloads": -1, "filename": "PyRQA-4.1.0.tar.gz", "has_sig": false, "md5_digest": "05aa50db558796d64cbe25a8b305bb57", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 62740, "upload_time": "2019-11-10T11:37:25", "upload_time_iso_8601": "2019-11-10T11:37:25.086343Z", "url": "https://files.pythonhosted.org/packages/e4/a6/1b0bde8e880644237a1ce9e05bd8c989eff9dceaef03881183ab5e0ebb3f/PyRQA-4.1.0.tar.gz", "yanked": false}], "5.0.0": [{"comment_text": "", "digests": {"md5": "1b1ae64a4e439555a0e6ad72014434bc", "sha256": "d6aa839b2fb0582437e5833c7a80232828cc753cd177290bcc891c3c17fd273f"}, "downloads": -1, "filename": "PyRQA-5.0.0.tar.gz", "has_sig": false, "md5_digest": "1b1ae64a4e439555a0e6ad72014434bc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 62325, "upload_time": "2020-02-17T17:18:38", "upload_time_iso_8601": "2020-02-17T17:18:38.021819Z", "url": "https://files.pythonhosted.org/packages/c6/5f/24204b1723aa4179cc0734ac1896df5130f7ed44786a59032be86345e301/PyRQA-5.0.0.tar.gz", "yanked": false}], "5.1.0": [{"comment_text": "", "digests": {"md5": "eee4fa30a83a807c4efeca06ac541c33", "sha256": "7f488517ba94e075eb60c890ed097468121e727330b7d9308de87a7920c7eaac"}, "downloads": -1, "filename": "PyRQA-5.1.0.tar.gz", "has_sig": false, "md5_digest": "eee4fa30a83a807c4efeca06ac541c33", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 67921, "upload_time": "2020-04-03T18:05:50", "upload_time_iso_8601": "2020-04-03T18:05:50.109120Z", "url": "https://files.pythonhosted.org/packages/ad/16/2668edb2320aadd35728a307501d18e5655513c20bdd75199ec84458d741/PyRQA-5.1.0.tar.gz", "yanked": false}], "6.0.0": [{"comment_text": "", "digests": {"md5": "456ad370e7f076f28f0c046339e7b63a", "sha256": "e51cc3341ca8bebdf660719f47bf9d853841cc37d3e54296275f54715d678fd9"}, "downloads": -1, "filename": "PyRQA-6.0.0.tar.gz", "has_sig": false, "md5_digest": "456ad370e7f076f28f0c046339e7b63a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 77522, "upload_time": "2020-04-29T18:16:16", "upload_time_iso_8601": "2020-04-29T18:16:16.096817Z", "url": "https://files.pythonhosted.org/packages/b3/78/332fdc6b9a1618670166ca5dc59649a3acefe3a3e81674bff7f9f8b0eef0/PyRQA-6.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "456ad370e7f076f28f0c046339e7b63a", "sha256": "e51cc3341ca8bebdf660719f47bf9d853841cc37d3e54296275f54715d678fd9"}, "downloads": -1, "filename": "PyRQA-6.0.0.tar.gz", "has_sig": false, "md5_digest": "456ad370e7f076f28f0c046339e7b63a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 77522, "upload_time": "2020-04-29T18:16:16", "upload_time_iso_8601": "2020-04-29T18:16:16.096817Z", "url": "https://files.pythonhosted.org/packages/b3/78/332fdc6b9a1618670166ca5dc59649a3acefe3a3e81674bff7f9f8b0eef0/PyRQA-6.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:57:34 2020"}