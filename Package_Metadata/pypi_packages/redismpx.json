{"info": {"author": "Loris Cro", "author_email": "kappaloris@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# RedisMPX\nRedisMPX is a Redis Pub/Sub multiplexer library written in multiple languages and [live coded on Twitch](https://twitch.tv/kristoff_it).\n\n## Abstract\nWhen bridging multiple application instances through Redis Pub/Sub it's easy to end up needing\nsupport for multiplexing. RedisMPX streamlines this process in a consistent way across multiple\nlanguages by offering a consistent set of features that cover the most common use cases.\n\nThe library works under the assumption that you are going to create separate subscriptions\nfor each client connected to your service (e.g. WebSockets clients):\n\n- ChannelSubscription allows you to add and remove individual Redis\n  PubSub channels similarly to how a multi-room chat application would need to.\n- PatternSubscription allows you to subscribe to a single Redis Pub/Sub pattern.\n- PromiseSubscription allows you to create a networked promise system.\n\n\n## Installation\nRequires Python 3.7+, based on [aio-libs/aioredis](https://github.com/aio-libs/aioredis),\nan AsyncIO Redis client.\n\n`pip install redismpx`\n\n## Features\n- Simple channel subscriptions\n- Pattern subscriptions\n- **[Networked promise system](https://python-mpx.readthedocs.io/en/latest/#redismpx.Multiplexer.new_promise_subscription)**\n- Automatic reconnection with exponetial backoff + jitter\n\n## Documentation\n- [API Reference](https://python-mpx.readthedocs.io/en/latest/)\n- [Examples](/examples/)\n\n## Usage\n```python\nfrom redismpx import Multiplexer\n\n# Pass to Multiplexer the same connection options that\n# aioredis.create_connection() would accept.\nmpx = Multiplexer('redis://localhost') \n\n# on_message is a callback (can be async)\n# that accepts a channel name and a message.\nasync def my_on_message(channel: bytes, message: bytes):\n    await websocket.send(f\"ch: {channel} msg: {message}\")\n\n# on_disconnect is a callback (can be async) \n# that accepts the error that caused the disconnection.\ndef my_on_disconnect(error: Exception):\n    print(\"oh no!\")\n\n# on_activation is a callback (can be async)\n# that accepts the name of the channel or pattern\n# whose subscription just became active (depends\n# on whether it's attached to a ChannelSubscription\n# or a PatternSubscription).\ndef my_on_activation(name: bytes):\n    print(\"activated:\", name)\n\n# you can also pass None in place of `on_disconnect`\n# and `on_activation` if you're not interested in \n# reacting to those events.\n\n# Use `mpx` to create new subscriptions.\nchannel_sub = mpx.new_channel_subcription(\n    my_on_message, my_on_disconnect, None) \npattern_sub = mpx.new_pattern_subscription(\"hello-*\", \n    my_on_message, None, my_on_activation)\npromise_sub = mpx.new_promise_subscription(\"hello-\")\n```\n\n### ChannelSubscription\n```python\n# Create the ChannelSubscription.\nchannel_sub = mpx.new_channel_subcription(\n    lambda ch, msg: print(f\"Message @ {ch}: {msg}\"),\n    lambda e: print(f\"Network Error: {type(e)}: {e}\"),\n    lambda s: print(f\"Subscription now active: {s}\")) \n\n# Add channels\nchannel_sub.add(\"chan1\")\nchannel_sub.add(\"chan2\")\nchannel_sub.add(\"chan3\")\n\n# Remove a channel\nchannel_sub.remove(\"chan2\")\n\n# Close the subscription\nchannel_sub.close()\n```\n\n### PatternSubscription\n```python\n# Create the PatternSubscription.\n# Note how it also requires the pattern.\npattern_sub = mpx.new_pattern_subcription(\n    \"notifications:*\",\n    lambda ch, msg: print(f\"Message @ {ch}: {msg}\"),\n    lambda e: print(f\"Network Error: {type(e)}: {e}\"),\n    lambda s: print(f\"Subscription now active: {s}\")) \n\n# PatternSubscriptions can only be closed\npattern_sub.close()\n```\n\n### PromiseSubscription\n```python\n# Create the subscription. \n# Note how it doesn't accept any callback.\npromise_sub = mpx.new_promise_subscription(\"hello-\")\n\n# When first created (and after a network error that causes \n# a reconnection), a PromiseSubscription is not immediately \n# able to create new promises as it first needs the underlying\n# PatternSubscription to become active. This async function\n# waits for that event.\nawait promise_sub.wait_for_activation()\n\n\n# Create a new promise. It might fail if the subscription is \n# not active.\ntry:\n    promise = promise_sub.new_promise(\"world\", 10)\n    # The provided suffix will be composed with the subscription's\n    # prefix to create the final Redis Pub/Sub channel from which\n    # the message is expected to come. In this example, to fullfill\n    # the promise you could send, using redis-cli (or any other client):\n    #\n    #   > PUBLISH hello-world \"your-promise-payload\"\n    #\nexcept redismpx.InactiveSubscription:\n    # Wait and then Retry? Return an error to the user? Up to you.\n\n# A way of creating a promise that ensures no InactiveSubscription error \n# will trigger. Note that this method needs to be awaited.\n# The timer will start only after the promise has been created.\npromise = await promise_sub.wait_for_new_promise(\"world\", 10)\n\n# A Promise represents a timed, uninterrupted, single-message \n# subscription to a Redis Pub/Sub channel. If network \n# connectivity gets lost, thus causing an interruption, \n# the Promise will be failed (unless already fullfilled). \n\n# Resolve the promise\ntry:\n    result = await promise\n    print(result) # prints b'your-promise-payload'\nexcept asyncio.TimeoutError:\n    # The promise timed out.\nexcept asyncio.CancelledError:\n    # The promise was canceled. This happens when\n    # a reconnection event triggers while the promise\n    # is not yet resolved. \n\n# Close the subscription (will automatically cancel all\n# outstanding promises and unlock all `wait_for_*` waiters).\npromise_sub.close()\n```\n\n## WebSocket Example\nThis is a more realistic example of how to use RedisMPX.\n\n### Code\nThis code is also available in [examples/channel.py](/examples/channel.py).\n\n```python\n# channel.py\n\nimport asyncio\nimport aioredis\nfrom starlette.applications import Starlette\nfrom starlette.routing import WebSocketRoute\nfrom redismpx import Multiplexer\n\n# Pass to Multiplexer the same connection options that\n# aioredis.create_redis() would accept.\nmpx = Multiplexer('redis://localhost')\n\npub_conn = None\n\nasync def handle_ws(ws):\n    global pub_conn\n    await ws.accept()\n\n    # Create a separate connection for publishing messages:\n    if pub_conn is None:\n        pub_conn = await aioredis.create_redis('redis://localhost')\n\n    # Define a callback that sends messages to this websocket\n    async def on_message(channel: bytes, message: bytes):\n        await ws.send_text(f\"ch: [{channel.decode()}] msg: [{message.decode()}]\\n\")\n\n    # Create a subscription for this websocket\n    sub = mpx.new_channel_subscription(on_message, \n        lambda e: print(f\"Network Error: {type(e)}: {e}\"),\n        lambda s: print(f\"Subscription now active: {s}\"))\n\n    # Keep reading from the websocket, use the messages sent by the user\n    # to add and remove channels from the subscription.\n    # Use +channel to join a channel, -channel to leave.\n    # Sending !channel will send the next message to said channel.\n    await ws.send_text('# Use +channel to join a channel, -channel to leave.')\n    await ws.send_text('# Sending !channel will send the next message to said channel.')\n    await ws.send_text('# To see a message sent to a given channel, you must have joined it beforehand.')\n\n    while True:\n        msg = None\n        try:\n            msg = await ws.receive_text()\n        except:\n            print('ws disconnected')\n            sub.close()\n            return\n        prefix, chan = msg[0], msg[1:]\n        if prefix == \"+\": \n            sub.add(chan)\n        elif prefix == \"-\":\n            sub.remove(chan)\n        elif prefix == '!':\n            # Send the next message to the given channel\n            await pub_conn.publish(chan, await ws.receive_text())\n\n\napp = Starlette(debug=True, routes=[\n    WebSocketRoute('/ws', endpoint=handle_ws),\n])\n```\n\n### Dependences\n`pip install redismpx aioredis starlette uvcorn`\n\n### Launching the example\n`$ uvicorn websocket:app`\n\n### Interacting with the example\nThe application works like a simple WebSocket chat application that \nexpects commands from the user.\n\n- Sending `+hello` will subscribe you to channel `hello`, while `-hello` will do the opposite.\n- Sending `!hello` will broadcast the next message you send to `hello`.\n- You can use whatever channel name you like.\n\nTo send those commands you can use a browser:\n```js\n// To create a websocket connection to localhost\n// you will need to deal with the browser's security\n// policies. Opening a file on the local filesystem\n// and typing these commands in the console should\n// do the trick.\nlet ws = new WebSocket(\"ws://localhost:8000/ws\")\nws.onmessage = (x) => console.log(\"message:\", x.data)\nws.send(\"+test\")\nws.send(\"!test\")\nws.send(\"hello world!\")\n```\nA more handy way of interacting with websockets are command-line clients:\n- https://github.com/hashrocket/ws (recommended)\n- https://github.com/esphen/wsta\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/RedisMPX/python-mpx", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "redismpx", "package_url": "https://pypi.org/project/redismpx/", "platform": "", "project_url": "https://pypi.org/project/redismpx/", "project_urls": {"Homepage": "https://github.com/RedisMPX/python-mpx"}, "release_url": "https://pypi.org/project/redismpx/0.5.2/", "requires_dist": ["aioredis"], "requires_python": ">=3.7", "summary": "A Redis Pub/Sub multiplexer.", "version": "0.5.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>RedisMPX</h1>\n<p>RedisMPX is a Redis Pub/Sub multiplexer library written in multiple languages and <a href=\"https://twitch.tv/kristoff_it\" rel=\"nofollow\">live coded on Twitch</a>.</p>\n<h2>Abstract</h2>\n<p>When bridging multiple application instances through Redis Pub/Sub it's easy to end up needing\nsupport for multiplexing. RedisMPX streamlines this process in a consistent way across multiple\nlanguages by offering a consistent set of features that cover the most common use cases.</p>\n<p>The library works under the assumption that you are going to create separate subscriptions\nfor each client connected to your service (e.g. WebSockets clients):</p>\n<ul>\n<li>ChannelSubscription allows you to add and remove individual Redis\nPubSub channels similarly to how a multi-room chat application would need to.</li>\n<li>PatternSubscription allows you to subscribe to a single Redis Pub/Sub pattern.</li>\n<li>PromiseSubscription allows you to create a networked promise system.</li>\n</ul>\n<h2>Installation</h2>\n<p>Requires Python 3.7+, based on <a href=\"https://github.com/aio-libs/aioredis\" rel=\"nofollow\">aio-libs/aioredis</a>,\nan AsyncIO Redis client.</p>\n<p><code>pip install redismpx</code></p>\n<h2>Features</h2>\n<ul>\n<li>Simple channel subscriptions</li>\n<li>Pattern subscriptions</li>\n<li><strong><a href=\"https://python-mpx.readthedocs.io/en/latest/#redismpx.Multiplexer.new_promise_subscription\" rel=\"nofollow\">Networked promise system</a></strong></li>\n<li>Automatic reconnection with exponetial backoff + jitter</li>\n</ul>\n<h2>Documentation</h2>\n<ul>\n<li><a href=\"https://python-mpx.readthedocs.io/en/latest/\" rel=\"nofollow\">API Reference</a></li>\n<li><a href=\"/examples/\" rel=\"nofollow\">Examples</a></li>\n</ul>\n<h2>Usage</h2>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">redismpx</span> <span class=\"kn\">import</span> <span class=\"n\">Multiplexer</span>\n\n<span class=\"c1\"># Pass to Multiplexer the same connection options that</span>\n<span class=\"c1\"># aioredis.create_connection() would accept.</span>\n<span class=\"n\">mpx</span> <span class=\"o\">=</span> <span class=\"n\">Multiplexer</span><span class=\"p\">(</span><span class=\"s1\">'redis://localhost'</span><span class=\"p\">)</span> \n\n<span class=\"c1\"># on_message is a callback (can be async)</span>\n<span class=\"c1\"># that accepts a channel name and a message.</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">my_on_message</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span><span class=\"p\">):</span>\n    <span class=\"k\">await</span> <span class=\"n\">websocket</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"ch: </span><span class=\"si\">{</span><span class=\"n\">channel</span><span class=\"si\">}</span><span class=\"s2\"> msg: </span><span class=\"si\">{</span><span class=\"n\">message</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># on_disconnect is a callback (can be async) </span>\n<span class=\"c1\"># that accepts the error that caused the disconnection.</span>\n<span class=\"k\">def</span> <span class=\"nf\">my_on_disconnect</span><span class=\"p\">(</span><span class=\"n\">error</span><span class=\"p\">:</span> <span class=\"ne\">Exception</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"oh no!\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># on_activation is a callback (can be async)</span>\n<span class=\"c1\"># that accepts the name of the channel or pattern</span>\n<span class=\"c1\"># whose subscription just became active (depends</span>\n<span class=\"c1\"># on whether it's attached to a ChannelSubscription</span>\n<span class=\"c1\"># or a PatternSubscription).</span>\n<span class=\"k\">def</span> <span class=\"nf\">my_on_activation</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"activated:\"</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># you can also pass None in place of `on_disconnect`</span>\n<span class=\"c1\"># and `on_activation` if you're not interested in </span>\n<span class=\"c1\"># reacting to those events.</span>\n\n<span class=\"c1\"># Use `mpx` to create new subscriptions.</span>\n<span class=\"n\">channel_sub</span> <span class=\"o\">=</span> <span class=\"n\">mpx</span><span class=\"o\">.</span><span class=\"n\">new_channel_subcription</span><span class=\"p\">(</span>\n    <span class=\"n\">my_on_message</span><span class=\"p\">,</span> <span class=\"n\">my_on_disconnect</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)</span> \n<span class=\"n\">pattern_sub</span> <span class=\"o\">=</span> <span class=\"n\">mpx</span><span class=\"o\">.</span><span class=\"n\">new_pattern_subscription</span><span class=\"p\">(</span><span class=\"s2\">\"hello-*\"</span><span class=\"p\">,</span> \n    <span class=\"n\">my_on_message</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">my_on_activation</span><span class=\"p\">)</span>\n<span class=\"n\">promise_sub</span> <span class=\"o\">=</span> <span class=\"n\">mpx</span><span class=\"o\">.</span><span class=\"n\">new_promise_subscription</span><span class=\"p\">(</span><span class=\"s2\">\"hello-\"</span><span class=\"p\">)</span>\n</pre>\n<h3>ChannelSubscription</h3>\n<pre><span class=\"c1\"># Create the ChannelSubscription.</span>\n<span class=\"n\">channel_sub</span> <span class=\"o\">=</span> <span class=\"n\">mpx</span><span class=\"o\">.</span><span class=\"n\">new_channel_subcription</span><span class=\"p\">(</span>\n    <span class=\"k\">lambda</span> <span class=\"n\">ch</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">:</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Message @ </span><span class=\"si\">{</span><span class=\"n\">ch</span><span class=\"si\">}</span><span class=\"s2\">: </span><span class=\"si\">{</span><span class=\"n\">msg</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">),</span>\n    <span class=\"k\">lambda</span> <span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Network Error: </span><span class=\"si\">{</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"si\">}</span><span class=\"s2\">: </span><span class=\"si\">{</span><span class=\"n\">e</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">),</span>\n    <span class=\"k\">lambda</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Subscription now active: </span><span class=\"si\">{</span><span class=\"n\">s</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">))</span> \n\n<span class=\"c1\"># Add channels</span>\n<span class=\"n\">channel_sub</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"s2\">\"chan1\"</span><span class=\"p\">)</span>\n<span class=\"n\">channel_sub</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"s2\">\"chan2\"</span><span class=\"p\">)</span>\n<span class=\"n\">channel_sub</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"s2\">\"chan3\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Remove a channel</span>\n<span class=\"n\">channel_sub</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"s2\">\"chan2\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Close the subscription</span>\n<span class=\"n\">channel_sub</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n</pre>\n<h3>PatternSubscription</h3>\n<pre><span class=\"c1\"># Create the PatternSubscription.</span>\n<span class=\"c1\"># Note how it also requires the pattern.</span>\n<span class=\"n\">pattern_sub</span> <span class=\"o\">=</span> <span class=\"n\">mpx</span><span class=\"o\">.</span><span class=\"n\">new_pattern_subcription</span><span class=\"p\">(</span>\n    <span class=\"s2\">\"notifications:*\"</span><span class=\"p\">,</span>\n    <span class=\"k\">lambda</span> <span class=\"n\">ch</span><span class=\"p\">,</span> <span class=\"n\">msg</span><span class=\"p\">:</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Message @ </span><span class=\"si\">{</span><span class=\"n\">ch</span><span class=\"si\">}</span><span class=\"s2\">: </span><span class=\"si\">{</span><span class=\"n\">msg</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">),</span>\n    <span class=\"k\">lambda</span> <span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Network Error: </span><span class=\"si\">{</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"si\">}</span><span class=\"s2\">: </span><span class=\"si\">{</span><span class=\"n\">e</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">),</span>\n    <span class=\"k\">lambda</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Subscription now active: </span><span class=\"si\">{</span><span class=\"n\">s</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">))</span> \n\n<span class=\"c1\"># PatternSubscriptions can only be closed</span>\n<span class=\"n\">pattern_sub</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n</pre>\n<h3>PromiseSubscription</h3>\n<pre><span class=\"c1\"># Create the subscription. </span>\n<span class=\"c1\"># Note how it doesn't accept any callback.</span>\n<span class=\"n\">promise_sub</span> <span class=\"o\">=</span> <span class=\"n\">mpx</span><span class=\"o\">.</span><span class=\"n\">new_promise_subscription</span><span class=\"p\">(</span><span class=\"s2\">\"hello-\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># When first created (and after a network error that causes </span>\n<span class=\"c1\"># a reconnection), a PromiseSubscription is not immediately </span>\n<span class=\"c1\"># able to create new promises as it first needs the underlying</span>\n<span class=\"c1\"># PatternSubscription to become active. This async function</span>\n<span class=\"c1\"># waits for that event.</span>\n<span class=\"k\">await</span> <span class=\"n\">promise_sub</span><span class=\"o\">.</span><span class=\"n\">wait_for_activation</span><span class=\"p\">()</span>\n\n\n<span class=\"c1\"># Create a new promise. It might fail if the subscription is </span>\n<span class=\"c1\"># not active.</span>\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"n\">promise</span> <span class=\"o\">=</span> <span class=\"n\">promise_sub</span><span class=\"o\">.</span><span class=\"n\">new_promise</span><span class=\"p\">(</span><span class=\"s2\">\"world\"</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n    <span class=\"c1\"># The provided suffix will be composed with the subscription's</span>\n    <span class=\"c1\"># prefix to create the final Redis Pub/Sub channel from which</span>\n    <span class=\"c1\"># the message is expected to come. In this example, to fullfill</span>\n    <span class=\"c1\"># the promise you could send, using redis-cli (or any other client):</span>\n    <span class=\"c1\">#</span>\n    <span class=\"c1\">#   &gt; PUBLISH hello-world \"your-promise-payload\"</span>\n    <span class=\"c1\">#</span>\n<span class=\"k\">except</span> <span class=\"n\">redismpx</span><span class=\"o\">.</span><span class=\"n\">InactiveSubscription</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Wait and then Retry? Return an error to the user? Up to you.</span>\n\n<span class=\"c1\"># A way of creating a promise that ensures no InactiveSubscription error </span>\n<span class=\"c1\"># will trigger. Note that this method needs to be awaited.</span>\n<span class=\"c1\"># The timer will start only after the promise has been created.</span>\n<span class=\"n\">promise</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">promise_sub</span><span class=\"o\">.</span><span class=\"n\">wait_for_new_promise</span><span class=\"p\">(</span><span class=\"s2\">\"world\"</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># A Promise represents a timed, uninterrupted, single-message </span>\n<span class=\"c1\"># subscription to a Redis Pub/Sub channel. If network </span>\n<span class=\"c1\"># connectivity gets lost, thus causing an interruption, </span>\n<span class=\"c1\"># the Promise will be failed (unless already fullfilled). </span>\n\n<span class=\"c1\"># Resolve the promise</span>\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">promise</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">)</span> <span class=\"c1\"># prints b'your-promise-payload'</span>\n<span class=\"k\">except</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">TimeoutError</span><span class=\"p\">:</span>\n    <span class=\"c1\"># The promise timed out.</span>\n<span class=\"k\">except</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">CancelledError</span><span class=\"p\">:</span>\n    <span class=\"c1\"># The promise was canceled. This happens when</span>\n    <span class=\"c1\"># a reconnection event triggers while the promise</span>\n    <span class=\"c1\"># is not yet resolved. </span>\n\n<span class=\"c1\"># Close the subscription (will automatically cancel all</span>\n<span class=\"c1\"># outstanding promises and unlock all `wait_for_*` waiters).</span>\n<span class=\"n\">promise_sub</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n</pre>\n<h2>WebSocket Example</h2>\n<p>This is a more realistic example of how to use RedisMPX.</p>\n<h3>Code</h3>\n<p>This code is also available in <a href=\"/examples/channel.py\" rel=\"nofollow\">examples/channel.py</a>.</p>\n<pre><span class=\"c1\"># channel.py</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">import</span> <span class=\"nn\">aioredis</span>\n<span class=\"kn\">from</span> <span class=\"nn\">starlette.applications</span> <span class=\"kn\">import</span> <span class=\"n\">Starlette</span>\n<span class=\"kn\">from</span> <span class=\"nn\">starlette.routing</span> <span class=\"kn\">import</span> <span class=\"n\">WebSocketRoute</span>\n<span class=\"kn\">from</span> <span class=\"nn\">redismpx</span> <span class=\"kn\">import</span> <span class=\"n\">Multiplexer</span>\n\n<span class=\"c1\"># Pass to Multiplexer the same connection options that</span>\n<span class=\"c1\"># aioredis.create_redis() would accept.</span>\n<span class=\"n\">mpx</span> <span class=\"o\">=</span> <span class=\"n\">Multiplexer</span><span class=\"p\">(</span><span class=\"s1\">'redis://localhost'</span><span class=\"p\">)</span>\n\n<span class=\"n\">pub_conn</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handle_ws</span><span class=\"p\">(</span><span class=\"n\">ws</span><span class=\"p\">):</span>\n    <span class=\"k\">global</span> <span class=\"n\">pub_conn</span>\n    <span class=\"k\">await</span> <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">accept</span><span class=\"p\">()</span>\n\n    <span class=\"c1\"># Create a separate connection for publishing messages:</span>\n    <span class=\"k\">if</span> <span class=\"n\">pub_conn</span> <span class=\"ow\">is</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">pub_conn</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">aioredis</span><span class=\"o\">.</span><span class=\"n\">create_redis</span><span class=\"p\">(</span><span class=\"s1\">'redis://localhost'</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Define a callback that sends messages to this websocket</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">on_message</span><span class=\"p\">(</span><span class=\"n\">channel</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span><span class=\"p\">):</span>\n        <span class=\"k\">await</span> <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">send_text</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"ch: [</span><span class=\"si\">{</span><span class=\"n\">channel</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">()</span><span class=\"si\">}</span><span class=\"s2\">] msg: [</span><span class=\"si\">{</span><span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">()</span><span class=\"si\">}</span><span class=\"s2\">]</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Create a subscription for this websocket</span>\n    <span class=\"n\">sub</span> <span class=\"o\">=</span> <span class=\"n\">mpx</span><span class=\"o\">.</span><span class=\"n\">new_channel_subscription</span><span class=\"p\">(</span><span class=\"n\">on_message</span><span class=\"p\">,</span> \n        <span class=\"k\">lambda</span> <span class=\"n\">e</span><span class=\"p\">:</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Network Error: </span><span class=\"si\">{</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span><span class=\"si\">}</span><span class=\"s2\">: </span><span class=\"si\">{</span><span class=\"n\">e</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">),</span>\n        <span class=\"k\">lambda</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Subscription now active: </span><span class=\"si\">{</span><span class=\"n\">s</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">))</span>\n\n    <span class=\"c1\"># Keep reading from the websocket, use the messages sent by the user</span>\n    <span class=\"c1\"># to add and remove channels from the subscription.</span>\n    <span class=\"c1\"># Use +channel to join a channel, -channel to leave.</span>\n    <span class=\"c1\"># Sending !channel will send the next message to said channel.</span>\n    <span class=\"k\">await</span> <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">send_text</span><span class=\"p\">(</span><span class=\"s1\">'# Use +channel to join a channel, -channel to leave.'</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">send_text</span><span class=\"p\">(</span><span class=\"s1\">'# Sending !channel will send the next message to said channel.'</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">send_text</span><span class=\"p\">(</span><span class=\"s1\">'# To see a message sent to a given channel, you must have joined it beforehand.'</span><span class=\"p\">)</span>\n\n    <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n        <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">receive_text</span><span class=\"p\">()</span>\n        <span class=\"k\">except</span><span class=\"p\">:</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'ws disconnected'</span><span class=\"p\">)</span>\n            <span class=\"n\">sub</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n            <span class=\"k\">return</span>\n        <span class=\"n\">prefix</span><span class=\"p\">,</span> <span class=\"n\">chan</span> <span class=\"o\">=</span> <span class=\"n\">msg</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">msg</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:]</span>\n        <span class=\"k\">if</span> <span class=\"n\">prefix</span> <span class=\"o\">==</span> <span class=\"s2\">\"+\"</span><span class=\"p\">:</span> \n            <span class=\"n\">sub</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">chan</span><span class=\"p\">)</span>\n        <span class=\"k\">elif</span> <span class=\"n\">prefix</span> <span class=\"o\">==</span> <span class=\"s2\">\"-\"</span><span class=\"p\">:</span>\n            <span class=\"n\">sub</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"n\">chan</span><span class=\"p\">)</span>\n        <span class=\"k\">elif</span> <span class=\"n\">prefix</span> <span class=\"o\">==</span> <span class=\"s1\">'!'</span><span class=\"p\">:</span>\n            <span class=\"c1\"># Send the next message to the given channel</span>\n            <span class=\"k\">await</span> <span class=\"n\">pub_conn</span><span class=\"o\">.</span><span class=\"n\">publish</span><span class=\"p\">(</span><span class=\"n\">chan</span><span class=\"p\">,</span> <span class=\"k\">await</span> <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">receive_text</span><span class=\"p\">())</span>\n\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Starlette</span><span class=\"p\">(</span><span class=\"n\">debug</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">routes</span><span class=\"o\">=</span><span class=\"p\">[</span>\n    <span class=\"n\">WebSocketRoute</span><span class=\"p\">(</span><span class=\"s1\">'/ws'</span><span class=\"p\">,</span> <span class=\"n\">endpoint</span><span class=\"o\">=</span><span class=\"n\">handle_ws</span><span class=\"p\">),</span>\n<span class=\"p\">])</span>\n</pre>\n<h3>Dependences</h3>\n<p><code>pip install redismpx aioredis starlette uvcorn</code></p>\n<h3>Launching the example</h3>\n<p><code>$ uvicorn websocket:app</code></p>\n<h3>Interacting with the example</h3>\n<p>The application works like a simple WebSocket chat application that\nexpects commands from the user.</p>\n<ul>\n<li>Sending <code>+hello</code> will subscribe you to channel <code>hello</code>, while <code>-hello</code> will do the opposite.</li>\n<li>Sending <code>!hello</code> will broadcast the next message you send to <code>hello</code>.</li>\n<li>You can use whatever channel name you like.</li>\n</ul>\n<p>To send those commands you can use a browser:</p>\n<pre><span class=\"c1\">// To create a websocket connection to localhost</span>\n<span class=\"c1\">// you will need to deal with the browser's security</span>\n<span class=\"c1\">// policies. Opening a file on the local filesystem</span>\n<span class=\"c1\">// and typing these commands in the console should</span>\n<span class=\"c1\">// do the trick.</span>\n<span class=\"kd\">let</span> <span class=\"nx\">ws</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">WebSocket</span><span class=\"p\">(</span><span class=\"s2\">\"ws://localhost:8000/ws\"</span><span class=\"p\">)</span>\n<span class=\"nx\">ws</span><span class=\"p\">.</span><span class=\"nx\">onmessage</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">\"message:\"</span><span class=\"p\">,</span> <span class=\"nx\">x</span><span class=\"p\">.</span><span class=\"nx\">data</span><span class=\"p\">)</span>\n<span class=\"nx\">ws</span><span class=\"p\">.</span><span class=\"nx\">send</span><span class=\"p\">(</span><span class=\"s2\">\"+test\"</span><span class=\"p\">)</span>\n<span class=\"nx\">ws</span><span class=\"p\">.</span><span class=\"nx\">send</span><span class=\"p\">(</span><span class=\"s2\">\"!test\"</span><span class=\"p\">)</span>\n<span class=\"nx\">ws</span><span class=\"p\">.</span><span class=\"nx\">send</span><span class=\"p\">(</span><span class=\"s2\">\"hello world!\"</span><span class=\"p\">)</span>\n</pre>\n<p>A more handy way of interacting with websockets are command-line clients:</p>\n<ul>\n<li><a href=\"https://github.com/hashrocket/ws\" rel=\"nofollow\">https://github.com/hashrocket/ws</a> (recommended)</li>\n<li><a href=\"https://github.com/esphen/wsta\" rel=\"nofollow\">https://github.com/esphen/wsta</a></li>\n</ul>\n\n          </div>"}, "last_serial": 6947209, "releases": {"0.0.2": [{"comment_text": "", "digests": {"md5": "4fc1aaa565526dec8d0b9c5903100ebb", "sha256": "98179902c611058e82342be0642e22db314fb0b2be0c3c3d4887d7d44a80709e"}, "downloads": -1, "filename": "redismpx-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "4fc1aaa565526dec8d0b9c5903100ebb", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 2526, "upload_time": "2020-03-26T20:06:39", "upload_time_iso_8601": "2020-03-26T20:06:39.337418Z", "url": "https://files.pythonhosted.org/packages/be/4e/1ea02b8ec6beb214b46662abfe2edf4bc039270c202b3dde019b69315095/redismpx-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "aa6647400f2335c4181b3f4ace2f1046", "sha256": "ddd9a0b02ad5dcd9dc2c31220ec7f5a1987319c6f51168bf40d23668a0f2363e"}, "downloads": -1, "filename": "redismpx-0.0.2.tar.gz", "has_sig": false, "md5_digest": "aa6647400f2335c4181b3f4ace2f1046", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 1161, "upload_time": "2020-03-26T20:06:40", "upload_time_iso_8601": "2020-03-26T20:06:40.706648Z", "url": "https://files.pythonhosted.org/packages/4c/86/2db9ff8844f7a1a80a5716d8eb1b5e48a812e54d64ad423f622ef2bf86bd/redismpx-0.0.2.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "51c007d67f90b2f1a40b65de2f579f57", "sha256": "cc967f1c15f1efa031169a41d05d470b7eaba91b0dafcc9645df330e2f5680b3"}, "downloads": -1, "filename": "redismpx-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "51c007d67f90b2f1a40b65de2f579f57", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 10409, "upload_time": "2020-03-28T03:18:52", "upload_time_iso_8601": "2020-03-28T03:18:52.442122Z", "url": "https://files.pythonhosted.org/packages/6a/78/bd36182ed310e77b326131449064a347a13e5053efc8b4794fcaff04653b/redismpx-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "91c82c05b5216963f9f28c56049719c1", "sha256": "53de62d29479abf13b37ae42a06d0b0585b15d2efa393f9a4e26fb5ec15a3ac2"}, "downloads": -1, "filename": "redismpx-0.1.0.tar.gz", "has_sig": false, "md5_digest": "91c82c05b5216963f9f28c56049719c1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6739, "upload_time": "2020-03-28T03:18:53", "upload_time_iso_8601": "2020-03-28T03:18:53.789650Z", "url": "https://files.pythonhosted.org/packages/b2/4c/94d8d3a89a1265937ada166e7d347206ea40198f040266a5bbc2a4179339/redismpx-0.1.0.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "51b07d11078d3f6917ba28ef92bc55b2", "sha256": "b3df2728528d7ee92722ca9d2daf7ca2df6d83bda6fcbabb79ac4f41d332a351"}, "downloads": -1, "filename": "redismpx-0.4.0-py3-none-any.whl", "has_sig": false, "md5_digest": "51b07d11078d3f6917ba28ef92bc55b2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 13273, "upload_time": "2020-03-29T08:41:38", "upload_time_iso_8601": "2020-03-29T08:41:38.864325Z", "url": "https://files.pythonhosted.org/packages/ee/04/2dc882055a41a0927714443656ff990b4e86fa9940f071c3902a12a399c0/redismpx-0.4.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "19df9ed39edff0a74b87f4690ae45a1b", "sha256": "16585a83268068b94d1ebf544e2c60a7e1d6c7af994b9c88e434ad72dece0b29"}, "downloads": -1, "filename": "redismpx-0.4.0.tar.gz", "has_sig": false, "md5_digest": "19df9ed39edff0a74b87f4690ae45a1b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 12745, "upload_time": "2020-03-29T08:41:40", "upload_time_iso_8601": "2020-03-29T08:41:40.062514Z", "url": "https://files.pythonhosted.org/packages/89/ec/581873b238a0c5ff9a0dc2ae0d25e0e156b57abae39849aecfc9a8337dcf/redismpx-0.4.0.tar.gz", "yanked": false}], "0.4.3": [{"comment_text": "", "digests": {"md5": "82835e203443d9b1f6c78371cc47659e", "sha256": "5eef2e04d497762ffe629828fe8e31b91d26dccc1dadd23728c1c1e663b1ebe5"}, "downloads": -1, "filename": "redismpx-0.4.3-py3-none-any.whl", "has_sig": false, "md5_digest": "82835e203443d9b1f6c78371cc47659e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 13263, "upload_time": "2020-03-29T09:11:08", "upload_time_iso_8601": "2020-03-29T09:11:08.040818Z", "url": "https://files.pythonhosted.org/packages/0c/5f/0bc7468658ed97f262b9bf3bbdc1e6b514441fdc61d5c179f106d29b6ce5/redismpx-0.4.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "77047a14417e870ac323bbb56d5e47c2", "sha256": "777107382b65477a1ed7e53aeb21ec125894c0ac52b04846c6ee20e82cbe1226"}, "downloads": -1, "filename": "redismpx-0.4.3.tar.gz", "has_sig": false, "md5_digest": "77047a14417e870ac323bbb56d5e47c2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 12732, "upload_time": "2020-03-29T09:11:09", "upload_time_iso_8601": "2020-03-29T09:11:09.300967Z", "url": "https://files.pythonhosted.org/packages/e4/b6/df7d5ed90641cf2a077bf05f01614dcc17f2b6393a19ba8147c40148d4a8/redismpx-0.4.3.tar.gz", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "1d4917f763e383a503167421141e4d7b", "sha256": "467efc6c653832b83f8675fe5ccf639a53641b93866b884398f165d77a1b5104"}, "downloads": -1, "filename": "redismpx-0.5.1-py3-none-any.whl", "has_sig": false, "md5_digest": "1d4917f763e383a503167421141e4d7b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 14226, "upload_time": "2020-04-03T23:40:56", "upload_time_iso_8601": "2020-04-03T23:40:56.990153Z", "url": "https://files.pythonhosted.org/packages/94/32/d73d3923fc756b61592128aafe559c50cfd71c042cd9e9ee8e536ff8c118/redismpx-0.5.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d246faea1a6f3208c17c96ec02cacd0b", "sha256": "f61a9df88885dbbd5f0eef85e4bef250b2a85d0ceb69485ef262c8b28d3ec401"}, "downloads": -1, "filename": "redismpx-0.5.1.tar.gz", "has_sig": false, "md5_digest": "d246faea1a6f3208c17c96ec02cacd0b", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 13353, "upload_time": "2020-04-03T23:40:58", "upload_time_iso_8601": "2020-04-03T23:40:58.213227Z", "url": "https://files.pythonhosted.org/packages/ea/b4/97b4eceec7e7c3a9aa55de756b55aeac7e756cbe264252de6e0c251b5c4c/redismpx-0.5.1.tar.gz", "yanked": false}], "0.5.2": [{"comment_text": "", "digests": {"md5": "0ea4966d3dbcbd6acb4de8e0f75f2dfe", "sha256": "453e7ce552e532ecc87b45554447ce148b1975e9b22dbe72fa0c4946e8ac3aeb"}, "downloads": -1, "filename": "redismpx-0.5.2-py3-none-any.whl", "has_sig": false, "md5_digest": "0ea4966d3dbcbd6acb4de8e0f75f2dfe", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 14297, "upload_time": "2020-04-03T23:45:07", "upload_time_iso_8601": "2020-04-03T23:45:07.403763Z", "url": "https://files.pythonhosted.org/packages/f5/49/3a7d5c50634d03e14f167b9bec16337b042eaf5547a71a09fa75aef06e93/redismpx-0.5.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "70949147364b88daf249d0b42913cc8a", "sha256": "c63008f965e3d72f59c7854ea8c9b5d42a6e8a1d3fa1881228775c37999b2187"}, "downloads": -1, "filename": "redismpx-0.5.2.tar.gz", "has_sig": false, "md5_digest": "70949147364b88daf249d0b42913cc8a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 13491, "upload_time": "2020-04-03T23:45:08", "upload_time_iso_8601": "2020-04-03T23:45:08.656511Z", "url": "https://files.pythonhosted.org/packages/4e/6a/0ca7b04947029832f014104a0dfc4581d85a828ca2cba9a874cdca4aa8bc/redismpx-0.5.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0ea4966d3dbcbd6acb4de8e0f75f2dfe", "sha256": "453e7ce552e532ecc87b45554447ce148b1975e9b22dbe72fa0c4946e8ac3aeb"}, "downloads": -1, "filename": "redismpx-0.5.2-py3-none-any.whl", "has_sig": false, "md5_digest": "0ea4966d3dbcbd6acb4de8e0f75f2dfe", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 14297, "upload_time": "2020-04-03T23:45:07", "upload_time_iso_8601": "2020-04-03T23:45:07.403763Z", "url": "https://files.pythonhosted.org/packages/f5/49/3a7d5c50634d03e14f167b9bec16337b042eaf5547a71a09fa75aef06e93/redismpx-0.5.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "70949147364b88daf249d0b42913cc8a", "sha256": "c63008f965e3d72f59c7854ea8c9b5d42a6e8a1d3fa1881228775c37999b2187"}, "downloads": -1, "filename": "redismpx-0.5.2.tar.gz", "has_sig": false, "md5_digest": "70949147364b88daf249d0b42913cc8a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 13491, "upload_time": "2020-04-03T23:45:08", "upload_time_iso_8601": "2020-04-03T23:45:08.656511Z", "url": "https://files.pythonhosted.org/packages/4e/6a/0ca7b04947029832f014104a0dfc4581d85a828ca2cba9a874cdca4aa8bc/redismpx-0.5.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:05:48 2020"}