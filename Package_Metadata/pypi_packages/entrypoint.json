{"info": {"author": "Conrad Irwin", "author_email": "conrad.irwin@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "This is a decorator library that helps one to write small scripts in Python. \n\nThere are three main features that it provides:\n\n * Automatically running a function when a script is called directly, but\n   not when it is included as a module.\n\n * Automatically generating argument parsers from function signatures and\n   docstrings\n\n * Automatically opening and closing files (with a codec or as binary) when\n   a function is called and returns.\n\nThe raison d'\u00eatre of this library is to be convenient, and it makes some\nsacrifices in other areas. Notably there are some stringent conditions on \nthe order of application of decorators.\n\nFor further information, see the explanations below, and the docstrings of the\nfunctions. To report errors, request features, or submit patches, please email\nconrad.irwin@gmail.com.\n\n\nI've tried to comment-out sections of the documentation that are less relevant\nto people trying to simply use the library. They contain background information\nor extra interfaces for re-using components.\n\n1) Automatically running a function when the library has been called directly.\n    This is conventionally done in Python using:\n\n    >>> def main():\n    ...     pass\n\n    >>> if __name__ == '__main__':\n    ...     main();\n\n    And can be re-written to\n\n    >>> @autorun\n    ... def main():\n    ...     pass\n\n    WARNING: This will not work as expected unless it is the \"outermost\"\n    decorator, i.e. the decorator that is listed first in the file and\n    applied last to the function. If you only have one decorator, that\n    should be fine - and that's why the library also provides @entrypoint,\n    @entrywithfile and @runwithfile (see table below) so that you only\n    need one decorator.\n\n    # Specifically, this decorator will call the function as part of the\n    # process of decorating. Thus any decorators that are applied after\n    # this one will not have been applied in the case the function is \n    # called later.\n\n    # autorun can also be used as a standalone function, which is necessary if\n    # you would like to use this functionality as part of another library.\n    # In such a case you need to pass it a second parameter indicating how far\n    # many levels above in the stack frame within autorun you would expect for \n    # __name__ to equal '__main__'.\n\n    # >>> def autorunwithone(func):\n    # ...     autorun(lambda: func(1), 2)\n    # >>> @autorunwithone\n    # ... def puts(y):\n    # ...     print y\n\n\n\n2) Automatically opening and closing files with the appropriate encoding.\n\n    This is conventionally done using:\n\n    >>> from __future__ import with_statement\n    >>> def main(filename):\n    ...     with codecs.open(filename, 'r', 'utf-8') as openfile:\n    ...         pass\n\n    And can be re-written to\n\n    >>> @withfile('r')\n    ... def main(openfile):\n    ...     pass\n\n    It is possible to pass a codec's name as the first positional argument\n    (or as __encoding) to @withfile. The default encoding is stored in\n    entrypoint.ENCODING and is set to 'utf-8'.\n\n    >>> @withfile('utf-16', 'w')\n    ... def main(openfile):\n    ...     pass\n\n    Or to open files in \"binary\" mode, with no codec, just suffix the\n    spec with a 'b':\n\n    >>> @withfile('rb', 'a')\n    ... def main(binaryfile, logfile):\n    ...     print >>logfile, process(binaryfile.read())\n\n    WARNING: Default arguments to functions are opened and closed on each entry\n    to that function, when a function will be called more than once used 'a'\n    instead of 'w' so that later calls don't overwrite the contents.\n\n    >>> @withfile('r', 'a')\n    ... def main(readfile, log='/tmp/python.log'):\n    ...     log.write(\"Reading %s\" % readfile.name)   \n\n    For clarity, it is possible to give keyword arguments to @withfile, and\n    it is necessary to do so if you wish to open all the arguments provided to\n    the function's *args or **kwargs:\n\n    >>> @withfile('w', args='r', stderr='a')\n    ... def main(catfile, *args, **kwargs):\n    ...     if args:\n    ...         catfile.write(\"\\n\".join(arg.read() for arg in args))\n    ...     elif 'stderr' in kwargs:\n    ...         print >>kwargs['stderr'], \"Nothing to cat\"\n\n    Finally, following the convention of many command line tools, the special\n    filename '-' is used to refer to sys.stdin for reading, and sys.stdout for\n    writing and appending. Again this can be a default parameter or passed in\n    by the caller:\n\n    >>> @withfile('r', 'w')\n    ... def main(input, output='-'):\n    ...     pass\n\n    WARNING: The files are opened on entry to the function, not when you need them,\n    if you open a file for writing, it will be created on disk, even if you don't\n    write anything to it.\n\n3) Automatically parsing command-line arguments from a function's signature,\n    and, if possible, from its doc-string.\n    \n    Internally, this uses the argparse module, but removes the tedious syntax\n    needed to get the most simple arguments parsed.\n\n    At its most basic, it simply converts a function that takes several\n    positional arguments (**kwargs is not supported) into a function that takes\n    an optional array of arguments, and defaults to sys.argv[1:]\n\n    >>> @acceptsargv\n    ... def main(arg1, arg2):\n    ...     pass\n    ...\n    ... main()\n    ... main(sys.argv[1:])\n    ... main(['arg1', 'arg2'])\n\n    This can be coupled with the other magic above, so that the function is\n    called automatically when it is defined:\n\n    >>> sys.argv[1:] = ['arg1', 'arg2']\n    >>> @entrypoint\n    ... def main(arg1, arg2)\n    ...     pass\n\n    The argument parser will abort the program if the arguments don't match, and\n    print a usage message. More detail can be found by passing -h or --help at\n    the command line as is normal.\n\n    >>> @entrypoint\n    ... def main(arg1, arg2):\n    ...     pass\n\n    usage: test.py [-h] arg1 arg2\n    : error: too few arguments\n\n    In addition to compulsary, positional, arguments as demonstrate above it is\n    possible to add flag arguments. Flag arguments are signified by providing a\n    default value for the parameter, of the same type as you wish the user to\n    input. Positional arguments, and flags with a default value of None are\n    always decoded as unicode strings. If the type conversion fails, it is\n    presented to the user as an error.\n    \n    >>> @entrypoint\n    ... def main(filename, priority=1): \n    ...     assert isinstance(priority, int)\n\n    usage: [-h] [--priority PRIORITY] filename\n\n    If the default value is True or False, the flag will be treated as a toggle\n    to flip that value:\n\n    >>> @entrypoint\n    ... def main(filename, verbose=False):\n    ...     if verbose:\n    ...         print filename\n\n    usage: [-h] [--verbose] filename\n\n    It is also possible to use the *args of a function:\n\n    >>> @entrypoint\n    ... def main(output, *input):\n    ...     print \", \".join(filenames)\n\n    usage: [-h] output [input [input ...]]\n\n    In addition to being able to parse the arguments automatically, @acceptargv\n    can also be used to provide user-facing documentation in the same manner as\n    argparse. It does this by parsing the function's doc string in the following\n    ways:\n\n    >>> def main(filename, flag=True, verbosity=3):\n    ...     \"\"\"\n    ...         Introductory paragraph.\n    ...\n    ...         Description and clarification of arguments.\n    ...\n    ...         Epilogue\n    ...\n    ...         ----\n    ...\n    ...         Internal documentation\n    ...     \"\"\"\n    ...     pass\n\n    All parts are optional. The introductory paragraph and the epilogue are\n    shown before and after the summary of arguments generated by argparse. The\n    internal documentation (below the ----) is not displayed at all.\n\n    <argument> = <clarification>:<description>\n    <clarification> = [-<letter>[,] ] --<flagname> [=<varname>]\n                    = <argname> [/<displayname>]\n\n    The description can span multiple lines, and will be re-formed when\n    displayed.\n\n    In the first case, the -<letter> gives a one-letter/number abbreviation for setting\n    the flag:\n\n    >>> def main(flag=True):\n    ...     \"\"\"\n    ...         -f --flag: Set the flag\n    ...     \"\"\"\n\n    <argname>, <flagname>, <varname>, and <displayname> are limited to\n    [a-zA-Z][a-zA-Z0-9_-]*\n\n    The flagname and the argname should match the actual name used in the\n    function argument definition, while the displayname and varname are simply\n    for displaying to the user.\n\n    Finally, any function that is wrapped in this manner can throw an\n    entrypoint.UsageError, the first parameter of which will be displayed to\n    the user as an error.\n\nSeveral combinations are available as pre-defined decorators:\n\n                      Run      Signature      Open\n                 Automatically   Parser      Files\n\n    @autorun           X\n\n    @entrypoint        X           X           \n\n    @entrywithfile     X           X           X*\n\n    @runwithfile       X                       X\n\n    @withfile                                  X\n\n    @withuserfile                              X*\n\n    @acceptargv                    X\n\n* Denotes that FileUsageErrors will be thrown instead of IOErrors to provide more\n  user-friendly error reporting\n\nA set of tests can be run by calling \"python test.py\"", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "UNKNOWN", "keywords": "argparse decorator optparse signature command-line", "license": "Python license", "maintainer": null, "maintainer_email": null, "name": "entrypoint", "package_url": "https://pypi.org/project/entrypoint/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/entrypoint/", "project_urls": {"Download": "UNKNOWN", "Homepage": "UNKNOWN"}, "release_url": "https://pypi.org/project/entrypoint/0.1.5dev/", "requires_dist": null, "requires_python": null, "summary": "A decorator to interact with argparse based on function signature.", "version": "0.1.5dev", "yanked": false, "html_description": "<div class=\"project-description\">\n            This is a decorator library that helps one to write small scripts in Python. <br><br>There are three main features that it provides:<br><br> * Automatically running a function when a script is called directly, but<br>   not when it is included as a module.<br><br> * Automatically generating argument parsers from function signatures and<br>   docstrings<br><br> * Automatically opening and closing files (with a codec or as binary) when<br>   a function is called and returns.<br><br>The raison d'\u00eatre of this library is to be convenient, and it makes some<br>sacrifices in other areas. Notably there are some stringent conditions on <br>the order of application of decorators.<br><br>For further information, see the explanations below, and the docstrings of the<br>functions. To report errors, request features, or submit patches, please email<br>conrad.irwin@gmail.com.<br><br><br>I've tried to comment-out sections of the documentation that are less relevant<br>to people trying to simply use the library. They contain background information<br>or extra interfaces for re-using components.<br><br>1) Automatically running a function when the library has been called directly.<br>    This is conventionally done in Python using:<br><br>    &gt;&gt;&gt; def main():<br>    ...     pass<br><br>    &gt;&gt;&gt; if __name__ == '__main__':<br>    ...     main();<br><br>    And can be re-written to<br><br>    &gt;&gt;&gt; @autorun<br>    ... def main():<br>    ...     pass<br><br>    WARNING: This will not work as expected unless it is the \"outermost\"<br>    decorator, i.e. the decorator that is listed first in the file and<br>    applied last to the function. If you only have one decorator, that<br>    should be fine - and that's why the library also provides @entrypoint,<br>    @entrywithfile and @runwithfile (see table below) so that you only<br>    need one decorator.<br><br>    # Specifically, this decorator will call the function as part of the<br>    # process of decorating. Thus any decorators that are applied after<br>    # this one will not have been applied in the case the function is <br>    # called later.<br><br>    # autorun can also be used as a standalone function, which is necessary if<br>    # you would like to use this functionality as part of another library.<br>    # In such a case you need to pass it a second parameter indicating how far<br>    # many levels above in the stack frame within autorun you would expect for <br>    # __name__ to equal '__main__'.<br><br>    # &gt;&gt;&gt; def autorunwithone(func):<br>    # ...     autorun(lambda: func(1), 2)<br>    # &gt;&gt;&gt; @autorunwithone<br>    # ... def puts(y):<br>    # ...     print y<br><br><br><br>2) Automatically opening and closing files with the appropriate encoding.<br><br>    This is conventionally done using:<br><br>    &gt;&gt;&gt; from __future__ import with_statement<br>    &gt;&gt;&gt; def main(filename):<br>    ...     with codecs.open(filename, 'r', 'utf-8') as openfile:<br>    ...         pass<br><br>    And can be re-written to<br><br>    &gt;&gt;&gt; @withfile('r')<br>    ... def main(openfile):<br>    ...     pass<br><br>    It is possible to pass a codec's name as the first positional argument<br>    (or as __encoding) to @withfile. The default encoding is stored in<br>    entrypoint.ENCODING and is set to 'utf-8'.<br><br>    &gt;&gt;&gt; @withfile('utf-16', 'w')<br>    ... def main(openfile):<br>    ...     pass<br><br>    Or to open files in \"binary\" mode, with no codec, just suffix the<br>    spec with a 'b':<br><br>    &gt;&gt;&gt; @withfile('rb', 'a')<br>    ... def main(binaryfile, logfile):<br>    ...     print &gt;&gt;logfile, process(binaryfile.read())<br><br>    WARNING: Default arguments to functions are opened and closed on each entry<br>    to that function, when a function will be called more than once used 'a'<br>    instead of 'w' so that later calls don't overwrite the contents.<br><br>    &gt;&gt;&gt; @withfile('r', 'a')<br>    ... def main(readfile, log='/tmp/python.log'):<br>    ...     log.write(\"Reading %s\" % readfile.name)   <br><br>    For clarity, it is possible to give keyword arguments to @withfile, and<br>    it is necessary to do so if you wish to open all the arguments provided to<br>    the function's *args or **kwargs:<br><br>    &gt;&gt;&gt; @withfile('w', args='r', stderr='a')<br>    ... def main(catfile, *args, **kwargs):<br>    ...     if args:<br>    ...         catfile.write(\"\\n\".join(arg.read() for arg in args))<br>    ...     elif 'stderr' in kwargs:<br>    ...         print &gt;&gt;kwargs['stderr'], \"Nothing to cat\"<br><br>    Finally, following the convention of many command line tools, the special<br>    filename '-' is used to refer to sys.stdin for reading, and sys.stdout for<br>    writing and appending. Again this can be a default parameter or passed in<br>    by the caller:<br><br>    &gt;&gt;&gt; @withfile('r', 'w')<br>    ... def main(input, output='-'):<br>    ...     pass<br><br>    WARNING: The files are opened on entry to the function, not when you need them,<br>    if you open a file for writing, it will be created on disk, even if you don't<br>    write anything to it.<br><br>3) Automatically parsing command-line arguments from a function's signature,<br>    and, if possible, from its doc-string.<br>    <br>    Internally, this uses the argparse module, but removes the tedious syntax<br>    needed to get the most simple arguments parsed.<br><br>    At its most basic, it simply converts a function that takes several<br>    positional arguments (**kwargs is not supported) into a function that takes<br>    an optional array of arguments, and defaults to sys.argv[1:]<br><br>    &gt;&gt;&gt; @acceptsargv<br>    ... def main(arg1, arg2):<br>    ...     pass<br>    ...<br>    ... main()<br>    ... main(sys.argv[1:])<br>    ... main(['arg1', 'arg2'])<br><br>    This can be coupled with the other magic above, so that the function is<br>    called automatically when it is defined:<br><br>    &gt;&gt;&gt; sys.argv[1:] = ['arg1', 'arg2']<br>    &gt;&gt;&gt; @entrypoint<br>    ... def main(arg1, arg2)<br>    ...     pass<br><br>    The argument parser will abort the program if the arguments don't match, and<br>    print a usage message. More detail can be found by passing -h or --help at<br>    the command line as is normal.<br><br>    &gt;&gt;&gt; @entrypoint<br>    ... def main(arg1, arg2):<br>    ...     pass<br><br>    usage: test.py [-h] arg1 arg2<br>    : error: too few arguments<br><br>    In addition to compulsary, positional, arguments as demonstrate above it is<br>    possible to add flag arguments. Flag arguments are signified by providing a<br>    default value for the parameter, of the same type as you wish the user to<br>    input. Positional arguments, and flags with a default value of None are<br>    always decoded as unicode strings. If the type conversion fails, it is<br>    presented to the user as an error.<br>    <br>    &gt;&gt;&gt; @entrypoint<br>    ... def main(filename, priority=1): <br>    ...     assert isinstance(priority, int)<br><br>    usage: [-h] [--priority PRIORITY] filename<br><br>    If the default value is True or False, the flag will be treated as a toggle<br>    to flip that value:<br><br>    &gt;&gt;&gt; @entrypoint<br>    ... def main(filename, verbose=False):<br>    ...     if verbose:<br>    ...         print filename<br><br>    usage: [-h] [--verbose] filename<br><br>    It is also possible to use the *args of a function:<br><br>    &gt;&gt;&gt; @entrypoint<br>    ... def main(output, *input):<br>    ...     print \", \".join(filenames)<br><br>    usage: [-h] output [input [input ...]]<br><br>    In addition to being able to parse the arguments automatically, @acceptargv<br>    can also be used to provide user-facing documentation in the same manner as<br>    argparse. It does this by parsing the function's doc string in the following<br>    ways:<br><br>    &gt;&gt;&gt; def main(filename, flag=True, verbosity=3):<br>    ...     \"\"\"<br>    ...         Introductory paragraph.<br>    ...<br>    ...         Description and clarification of arguments.<br>    ...<br>    ...         Epilogue<br>    ...<br>    ...         ----<br>    ...<br>    ...         Internal documentation<br>    ...     \"\"\"<br>    ...     pass<br><br>    All parts are optional. The introductory paragraph and the epilogue are<br>    shown before and after the summary of arguments generated by argparse. The<br>    internal documentation (below the ----) is not displayed at all.<br><br>    &lt;argument&gt; = &lt;clarification&gt;:&lt;description&gt;<br>    &lt;clarification&gt; = [-&lt;letter&gt;[,] ] --&lt;flagname&gt; [=&lt;varname&gt;]<br>                    = &lt;argname&gt; [/&lt;displayname&gt;]<br><br>    The description can span multiple lines, and will be re-formed when<br>    displayed.<br><br>    In the first case, the -&lt;letter&gt; gives a one-letter/number abbreviation for setting<br>    the flag:<br><br>    &gt;&gt;&gt; def main(flag=True):<br>    ...     \"\"\"<br>    ...         -f --flag: Set the flag<br>    ...     \"\"\"<br><br>    &lt;argname&gt;, &lt;flagname&gt;, &lt;varname&gt;, and &lt;displayname&gt; are limited to<br>    [a-zA-Z][a-zA-Z0-9_-]*<br><br>    The flagname and the argname should match the actual name used in the<br>    function argument definition, while the displayname and varname are simply<br>    for displaying to the user.<br><br>    Finally, any function that is wrapped in this manner can throw an<br>    entrypoint.UsageError, the first parameter of which will be displayed to<br>    the user as an error.<br><br>Several combinations are available as pre-defined decorators:<br><br>                      Run      Signature      Open<br>                 Automatically   Parser      Files<br><br>    @autorun           X<br><br>    @entrypoint        X           X           <br><br>    @entrywithfile     X           X           X*<br><br>    @runwithfile       X                       X<br><br>    @withfile                                  X<br><br>    @withuserfile                              X*<br><br>    @acceptargv                    X<br><br>* Denotes that FileUsageErrors will be thrown instead of IOErrors to provide more<br>  user-friendly error reporting<br><br>A set of tests can be run by calling \"python test.py\"\n          </div>"}, "last_serial": 791662, "releases": {"0.1.5dev": [{"comment_text": "", "digests": {"md5": "346be5201e5f5744d34507defaafac03", "sha256": "c6b2d65851aa76537bea05127fe4eb38b95ba0f657da15677b3a2fb47808a5e8"}, "downloads": -1, "filename": "entrypoint-0.1.5dev.tar.gz", "has_sig": false, "md5_digest": "346be5201e5f5744d34507defaafac03", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10605, "upload_time": "2010-09-17T21:50:14", "upload_time_iso_8601": "2010-09-17T21:50:14.330888Z", "url": "https://files.pythonhosted.org/packages/a7/a2/c2fc7ef35272988ae8eb7b346635e627022a820251da8d21f9caa86e15f7/entrypoint-0.1.5dev.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "346be5201e5f5744d34507defaafac03", "sha256": "c6b2d65851aa76537bea05127fe4eb38b95ba0f657da15677b3a2fb47808a5e8"}, "downloads": -1, "filename": "entrypoint-0.1.5dev.tar.gz", "has_sig": false, "md5_digest": "346be5201e5f5744d34507defaafac03", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10605, "upload_time": "2010-09-17T21:50:14", "upload_time_iso_8601": "2010-09-17T21:50:14.330888Z", "url": "https://files.pythonhosted.org/packages/a7/a2/c2fc7ef35272988ae8eb7b346635e627022a820251da8d21f9caa86e15f7/entrypoint-0.1.5dev.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:46:13 2020"}