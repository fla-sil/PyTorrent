{"info": {"author": "Roger Ineichen and the Zope Community", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Internet :: WWW/HTTP"], "description": "This package provides an IAuthentication implementation for Zope3. Note that\nthis implementation is independent of zope.app.authentication and it doesn't\ndepend on that package. This means it doesn't even use the credential or\nauthentication plugins offered from zope.app.authentication package.\n\n\n.. contents::\n\n=======================\nIAuthentication Utility\n=======================\n\nThe Authenticator package provides a framework for authenticating principals\nand associating information with them. It uses plugins and subscribers to get\nits work done.\n\nFor a simple authentication utility to be used, it should be registered as a\nutility providing the `zope.authentication.interfaces.IAuthentication` interface.\n\nOur target is to support a handy IAuthentication utility which offers a simple\nAPI for custom IUser implementations and does not depend on the default\nzope.app.authentication implementation.\n\n\nSecurity\n--------\n\nThe Authenticator supports unique id tokens for principals. This means\nprincipal that get deleted and again added with the same id, login etc. do\nnot have the same id again. We support this by generate a user id token\ngenerated by the host id, timestamp, a random string and the login attribute.\n\n\nWhat's different from PluggableAuthentication\n---------------------------------------------\n\nWe use a different pattern for IAuthenticatorPlugins in this implementation\nthan used in PluggableAuthentication from zope.app.authentication,\nbecause the pluggable authentication is not very handy when it comes to\nimplementing custom principal information. The IPrincipalInfo hook supporting\nnot propagate the password of a IInternalPrincipal is droped in this\nimplementation.\n\nIn our implementation we offer a IFoundPrincipal and IAuthenticatedPrincipal\nwhich are implemented as adapters for a IUser. These adapters do not offer\ntheir context which is the real IUser.\n\nThe Authenticator doesn't use a prefix. The usage of a prefix is only\nimplemented in the IGroupContainer.\n\nWe do not use a prefix in the IUserContainer because of the used unique user\nid tokens. This will make sure that the same principal id doesn't get used at\na later time (common criteria). There is a ``add`` method which creates\nthis id for you based on the login. The __setitem__ should not get used\ndirectly for adding IUser instances anymore. We heavily restricted the\nusage of this method. See the inline doc tests in __setitem__ for more info.\n\n\nAuthentication\n==============\n\nThe primary job of Authenticator is to authenticate principals. It uses\ntwo types of plug-ins in its work:\n\n  - Credentials Plugins\n\n  - Authenticator Plugins\n\nCredentials plugins are responsible for extracting user credentials from a\nrequest. A credentials plugin may in some cases issue a 'challenge' to obtain\ncredentials. For example, a 'session' credentials plugin reads credentials\nfrom a session (the \"extraction\"). If it cannot find credentials, it will\nredirect the user to a login form in order to provide them (the \"challenge\").\n\nAuthenticator plugins are responsible for authenticating the credentials\nextracted by a credentials plugin. They are also typically able to create\nprincipal objects for credentials they successfully authenticate.\n\nGiven a request object, the Authenticator returns a principal object, if it\ncan. The Authenticator utility does this by first iterating through its\ncredentials plugins to obtain a set of credentials. If it gets credentials, it\niterates through its authenticator plugins to authenticate them.\n\nIf an authenticator succeeds in authenticating a set of credentials, the\nAuthenticator uses the authenticator to create a principal\ncorresponding to the credentials. The authenticator notifies subscribers if\nan authenticated principal is created. Subscribers are responsible for adding\ndata, especially groups, to the principal. Typically, if a subscriber adds\ndata, it should also add corresponding interface declarations.\n\n\nFAQ\n---\n\nHere some useful hints:\n\nHow should I set permission for principals?\n\n  You can apply roles to groups\n  and apply permissions to roles. Or you can directly apply local permisssions\n  to groups or to principals. After setting up these mappings you can grant roles to\n  groups. I always recommend a principal - group and permission - role mapping,\n  this gives you the most possible abstraction which is useful if it comes\n  to managing permissions and principals without directly invoking principals and\n  permissions themselves. But of course you can grant permissions to groups or the\n  worst thing, directly to principals. Granting permissions to principals is only\n  useful if it comes to selective local permission settings for selected\n  principals, e.g. an ownership-like permission setup.\n\nHow can I set permissions for all principals?\n\n  You can register one\n  group as IEveryone utility. This IGroup utility get applied to all principals.\n\nCan I apply local groups to unauthenticated principals?\n\n  Yes this will work.\n  Since the last refactoring I refactored the IGroup implementation which makes\n  it compatible with the principalregistry API. This means you can now register\n  one local group as an unnamed IUnauthenticatedGroup. You can also register one\n  local group as an unnamed IAuthenticatedGroup utility which will get applied\n  to every authenticated principal or an unnamed utility for\n  IUnauthenticatedGroup.\n\nCan I apply a local group to every principal?\n\n  Yes, this is possible if you\n  register a local unnamed utility providing IEveryoneGroup.\n\n\nPrincipal\n---------\n\nFirst we create a principal:\n\n  >>> from z3c.authenticator import interfaces\n  >>> from z3c.authenticator.user import User\n  >>> login = u'bob'\n  >>> password = u'secret'\n  >>> title = u'Bob'\n  >>> p = User(login, password, title)\n\nSuch a principal provides the following attributes be default\n\n  >>> p.login\n  u'bob'\n\n  >>> p.password.decode('utf-8')\n  u'secret'\n\n  >>> p.title\n  u'Bob'\n\nand IUser:\n\n  >>> interfaces.IUser.providedBy(p)\n  True\n\n\nAuthenticator Plugin\n--------------------\n\nFirst set up a UserContainer which will store the principals:\n\n  >>> from z3c.authenticator.user import UserContainer\n  >>> authPlugin = UserContainer()\n\nNow we have a UserContainer that provides an IUserContainer:\n\n  >>> interfaces.IUserContainer.providedBy(authPlugin)\n  True\n\nNow we will add the created principal to the principal container using the\ncontainer's ``add`` method:\n\n  >>> uid, user = authPlugin.add(p)\n\nThe method returns the user id and the user object. The id gets generated\nfrom the host IP address, the time, a random string and the user login attr.\nThis token should be unique and guaranteed that it will never get generated twice.\nThis allows us to add, delete and add the same user again without having such a\nuser inheriting existing permissions. We can test this token by comparing it\nonly with the __name__ of the object in this test since the token will be\ndifferent every test run.\n\n  >>> user.__name__ == uid\n  True\n\nThe returned user is still our previous added IUser\n\n  >>> user is p\n  True\n\n  >>> len(user.__name__)\n  32\n\n  >>> user.login\n  u'bob'\n\n  >>> user.password.decode('utf-8')\n  u'secret'\n\n  >>> user.title\n  u'Bob'\n\nLet's register the UserContainer as a named IAuthenticatorPlugin utility:\n\n  >>> import zope.component\n  >>> zope.component.provideUtility(authPlugin,\n  ...     provides=interfaces.IAuthenticatorPlugin,\n  ...     name='My Authenticator Plugin')\n\n\nCredentials Plugin\n------------------\n\nAfter seting up the user and user container, we'll create a simple credentials\nplugin:\n\n  >>> import zope.interface\n  >>> import zope.component\n\n  >>> @zope.interface.implementer(interfaces.ICredentialsPlugin)\n  ... class MyCredentialsPlugin(object):\n  ...\n  ...\n  ...     def extractCredentials(self, request):\n  ...         return {'login': request.get('login', ''),\n  ...                 'password': request.get('password', '')}\n  ...\n  ...     def challenge(self, request):\n  ...         pass # challenge is a no-op for this plugin\n  ...\n  ...     def logout(self, request):\n  ...         pass # logout is a no-op for this plugin\n\nAs a plugin, MyCredentialsPlugin needs to be registered as a named utility or\nit could be stored in the Authenticator attribute credentialsPlugins.\nUse the first and register the plugina utility:\n\n  >>> myCredentialsPlugin = MyCredentialsPlugin()\n  >>> zope.component.provideUtility(myCredentialsPlugin,\n  ...     name='My Credentials Plugin')\n\n\nAuthenticatedPrincipal and FoundPrincipal\n-----------------------------------------\n\nWhile authenticator plugins provide users, they are not responsible for\ncreating principals. This function is performed by the Authenticator:\n\n  >>> from z3c.authenticator.principal import AuthenticatedPrincipal\n  >>> from z3c.authenticator.principal import FoundPrincipal\n  >>> zope.component.provideAdapter(AuthenticatedPrincipal,\n  ...     provides=interfaces.IAuthenticatedPrincipal)\n\n  >>> zope.component.provideAdapter(FoundPrincipal,\n  ...     provides=interfaces.IFoundPrincipal)\n\n\nConfiguring the Authenticator\n-----------------------------\n\nFinally, we'll create the Authenticator itself:\n\n  >>> from z3c.authenticator import authentication\n  >>> auth = authentication.Authenticator()\n\nand configure it with the two plugins:\n\n  >>> auth.credentialsPlugins = ('My Credentials Plugin', )\n  >>> auth.authenticatorPlugins = ('My Authenticator Plugin', )\n\n\nAuthenticate\n------------\n\nWe can now use the Authenticator to authenticate a sample request:\n\n  >>> from zope.publisher.browser import TestRequest\n  >>> print(auth.authenticate(TestRequest()))\n  None\n\nIn this case, we cannot authenticate an empty request. In the same way, we\nwill not be able to authenticate a request with the wrong credentials:\n\n  >>> request = TestRequest(form={'login': 'let me in!', 'password': 'secret'})\n  >>> print(auth.authenticate(request))\n  None\n\nHowever, if we provide the proper credentials:\n\n  >>> request = TestRequest(form={'login': 'bob', 'password': 'secret'})\n  >>> bob = auth.authenticate(request)\n  >>> bob\n  <AuthenticatedPrincipal...>\n\n  >>> interfaces.IAuthenticatedPrincipal.providedBy(bob)\n  True\n\nwe get an authenticated principal.\n\n\nChanging login names\n--------------------\n\nChanging the login (i.e. username) of a principal is always a critical task because such a\nlogin together with a password is the key to our implemenation. Let's try to\nchange the login and check if everything is correct. We can do this by getting the\nprincipal from the UserContainer and changing the login on the IUser\nimplementation:\n\n  >>> internal = authPlugin[bob.id]\n  >>> internal.login = u'bob2'\n\nNow we should be able to login with the new login:\n\n  >>> request = TestRequest(form={'login': 'bob2', 'password': 'secret'})\n  >>> bob2 = auth.authenticate(request)\n  >>> bob2\n  <AuthenticatedPrincipal ...>\n\n  >>> bob2.title\n  u'Bob'\n\nBut not with the old one:\n\n  >>> request = TestRequest(form={'login': 'bob', 'password': 'secret'})\n  >>> auth.authenticate(request) == None\n  True\n\nThe user bob has still the same id as bob2 since the user id token doesn't\nget changed by changing the login:\n\n  >>> bob.id == bob2.id\n  True\n\n\nEvents\n------\n\nAuthenticating a principal will create events.\n\n  >>> from zope.component.eventtesting import getEvents\n  >>> from zope.component.eventtesting import clearEvents\n\nWe can verify that the appropriate event was published:\n\n  >>> clearEvents()\n  >>> request = TestRequest(form={'login': 'bob2', 'password': 'secret'})\n  >>> bobAgain = auth.authenticate(request)\n\nAnd the principal attribute in the event provides the authenticated principal:\n\n  >>> [event] = getEvents(interfaces.IAuthenticatedPrincipalCreated)\n  >>> event.principal is bobAgain\n  True\n\n  >>> event.principal\n  <AuthenticatedPrincipal ...>\n\n  >>> event.request is request\n  True\n\nThe principal has the id, title, and description.\n\n  >>> event.principal.title\n  u'Bob'\n\n  >>> event.principal.id == uid\n  True\n\n  >>> event.principal.description\n  u''\n\nWe provide subscribers to these events that can be used for doing custom\nprocessing. Note, the principal attibute provides an IAuthenticatedPrincipal:\n\n  >>> def addInfo(event):\n  ...     id = event.principal.id\n  ...     event.principal.description = 'Description for: %s' % id\n\n  >>> zope.component.provideHandler(addInfo,\n  ...     [interfaces.IAuthenticatedPrincipalCreated])\n\nNow, if we authenticate a principal, its description is set:\n\n  >>> principal = auth.authenticate(request)\n  >>> principal.description\n  u'Description for: ...'\n\n\nCustomization\n-------------\n\nLet's show you how the existing pattern can get used in a real use case. In\nthe next sample we'd like to provide an additional email attribute for principals.\nFirst we have to define the interfaces declaring the email attribute:\n\n  >>> class IMyEmail(zope.interface.Interface):\n  ...     email = zope.schema.TextLine(\n  ...         title=u'EMail',\n  ...         description=u'The EMail')\n\n  >>> class IMyUser(IMyEmail, interfaces.IUser):\n  ...     \"\"\"Custom IUser interface.\"\"\"\n\n  >>> class IMyFoundPrincipal(IMyEmail, interfaces.IFoundPrincipal):\n  ...     \"\"\"Custom IIMyFoundrincipal interface.\"\"\"\n\n  >>> class IMyAuthenticatedPrincipal(IMyEmail,\n  ...     interfaces.IAuthenticatedPrincipal):\n  ...     \"\"\"Custom IAuthenticatedPrincipal interface.\"\"\"\n\nAfter the schema, we define a custom principal implementation implementing\nthis interface:\n\n  >>> @zope.interface.implementer(IMyUser)\n  ... class MyUser(User):\n  ...     def __init__(self, login, password, title, description, email):\n  ...         super(MyUser, self).__init__(login, password, title,\n  ...                                           description)\n  ...         self.email = email\n\nNow we have to define the AuthenticatedPrincipal for MyUser:\n\n  >>> @zope.interface.implementer(IMyAuthenticatedPrincipal)\n  ... class MyAuthenticatedPrincipal(AuthenticatedPrincipal):\n  ...     def __init__(self, principal):\n  ...         super(MyAuthenticatedPrincipal, self).__init__(principal)\n  ...         self.email = principal.email\n\nAnd we have to define the FoundPrincipal for MyUser:\n\n  >>> @zope.interface.implementer(IMyFoundPrincipal)\n  ... class MyFoundPrincipal(FoundPrincipal):\n  ...     def __init__(self, principal):\n  ...         super(MyFoundPrincipal, self).__init__(principal)\n  ...         self.email = principal.email\n\nNote that you can provide different attributes for the found and authenticated\nprincipals if needed. That's up to you what you like to do with these attributes\nlater.\n\nNow we need to register our custom authenticated and found principal\nadapters:\n\n  >>> zope.component.provideAdapter(MyAuthenticatedPrincipal,\n  ...     provides=interfaces.IAuthenticatedPrincipal)\n\n  >>> zope.component.provideAdapter(MyFoundPrincipal,\n  ...     provides=interfaces.IFoundPrincipal)\n\nNow we can use them without any other event subscribers or other registration\nin our principal container. Let's add a principal to this container:\n\n  >>> p = MyUser(u'max', u'password', u'Max', u'', u'max@foobar.com')\n  >>> token, max = authPlugin.add(p)\n  >>> len(token)\n  32\n\n  >>> max.__name__ == token\n  True\n\n  >>> max.password.decode('utf-8')\n  u'password'\n\n  >>> max.title\n  u'Max'\n\n  >>> max.email\n  u'max@foobar.com'\n\nLet's try to authenticate...\n\n  >>> request = TestRequest(form={'login': 'max', 'password': 'password'})\n  >>> authenticated = auth.authenticate(request)\n\nand check your authenticated principal:\n\n  >>> interfaces.IAuthenticatedPrincipal.providedBy(authenticated)\n  True\n\n  >>> authenticated\n  <MyAuthenticatedPrincipal ...>\n\n  >>> authenticated.id == token\n  True\n\n  >>> authenticated.email\n  u'max@foobar.com'\n\nCheck getUserByLogin:\n\n  >>> max = authPlugin.getUserByLogin('max')\n  >>> max.__class__.__name__\n  'MyUser'\n\n  >>> authPlugin.getUserByLogin('max').login\n  u'max'\n\n  >>> authPlugin.getUserByLogin('max').__name__ == token\n  True\n\n\nA handy feature for migration is that you can set your own ``token``.\nUsually in z.a.authentication the ``token`` == login and we want to keep it\nthat way, unless you want to iterate through all permissions and whatever.\nNote, the __name__ and the id in the container must be the *SAME* object.\n\n  >>> login = u'migrateduser'\n  >>> p = User(login, u'password', u'John')\n\nPreset the ``token``\n\n  >>> p.__name__ = login\n\nWatch out, we use __setitem__ instead of add(), because add() would kill off\nthe preset ``token`` in __name__.\n\n  >>> authPlugin[login] = p\n\nHere we are, the user is set with the non-generated token.\n\n  >>> u'migrateduser' in authPlugin.keys()\n  True\n\n  >>> authPlugin['migrateduser']\n  <z3c.authenticator.user.User object at ...>\n\n  >>> authPlugin.getUserByLogin('migrateduser')\n  <z3c.authenticator.user.User object at ...>\n\n\nEdge cases\n----------\n\nWe can have Users with unicode logins, as we allow this with TextLine in IUser.\n\n  >>> try:\n  ...     unichr = unichr\n  ... except NameError:\n  ...     unichr = chr # PY3\n  >>> p = User(u'bob'+unichr(233), 'password', 'title')\n\nAdding it should not fail:\n\n  >>> uid, user = authPlugin.add(p)\n\n\n\n=====\nGroup\n=====\n\nGroup container provide support for groups information stored in the ZODB. \nThey are persistent, and must be contained within the IAuthentication that \nuse them.\n\n\nGroup\n-----\n\nLike other users, groups are created when they are needed.\n\n  >>> from z3c.authenticator import interfaces\n  >>> from z3c.authenticator.group import Group\n  >>> group1 = Group(u'groups')\n  >>> group1\n  <Group None>\n\n  >>> interfaces.IGroup.providedBy(group1)\n  True\n\n  >>> group1.title\n  u'groups'\n\n  >>> group1.description\n  u''\n\n  >>> group1.principals\n  ()\n\n\nGroupContainer\n--------------\n\nGroup containers contain IGroup objects. A IAuthentication will adapt\nIFoundGroup to this IGroup objects.\n\n  >>> from z3c.authenticator.group import GroupContainer\n  >>> groups = GroupContainer('groups.')\n\n  >>> interfaces.IGroupContainer.providedBy(groups)\n  True\n\nWe can add your previous created group to the group container using the \naddGroup method which returns the group id and group:\n\n  >>> gid, g1 = groups.addGroup(u'g1', group1)\n  >>> gid\n  u'groups.g1'\n\n  >>> interfaces.IGroup.providedBy(g1)\n  True\n\n  >>> g1.__name__\n  u'groups.g1'\n\nNote that when group is added, a GroupAdded event is generated:\n\n  >>> from zope.component.eventtesting import getEvents\n  >>> getEvents(interfaces.IGroupAdded)\n  [<GroupAdded u'groups.g1'>]\n\nGroups are defined with respect to an authentication service. Groups must be \naccessible via an authentication service and can contain principals accessible\nvia an authentication service. To illustrate the group interaction with the \nauthentication service, we will setup a Authenticator utility:\n\n  >>> from z3c.authenticator.authentication import Authenticator\n  >>> authenticator = Authenticator()\n\nGive them a location and register them as a IAuthentication utility :\n\n  >>> import zope.component\n  >>> from zope.authentication.interfaces import IAuthentication\n  >>> rootFolder['authenticator'] = authenticator\n  >>> zope.component.provideUtility(authenticator, IAuthentication)\n\nWe will create and register a new principals utility:\n\n  >>> zope.component.provideUtility(authenticator, IAuthentication)\n\nWe also need to register the group athentication plugin:\n\n  >>> zope.component.provideUtility(groups, \n  ...     provides=interfaces.IAuthenticatorPlugin, \n  ...     name='My Group Plugin')\n\nAfter setup the group and group container, we will create a simple credentials \nplugin and add them to the authentication utility:\n\n  >>> import zope.interface\n  >>> from z3c.authenticator import interfaces\n\n  >>> @zope.interface.implementer(interfaces.ICredentialsPlugin)\n  ... class MyCredentialsPlugin(object):\n  ...\n  ...     def extractCredentials(self, request):\n  ...         return {'login':request.get('login', ''), \n  ...                 'password':request.get('password', '')}\n  ...\n  ...     def challenge(self, request):\n  ...         pass # challenge is a no-op for this plugin\n  ...\n  ...     def logout(self, request):\n  ...         pass # logout is a no-op for this plugin\n\nand configure and add the credential plugin to the Authenticator:\n\n  >>> myCredentialsPlugin = MyCredentialsPlugin()\n  >>> authenticator['credentials'] = myCredentialsPlugin\n  >>> authenticator.credentialsPlugins = ('credentials', )\n\nWe also need a principal and a IAuthenticationPlugin:\n\n  >>> from z3c.authenticator.user import User\n  >>> p1 = User(u'p1', u'password', u'Principal 1')\n  >>> p2 = User(u'p2', u'password', u'Principal 2')\n  >>> p3 = User(u'p3', u'password', u'Principal 3')\n  >>> p4 = User(u'p4', u'password', u'Principal 4')\n\n  >>> from z3c.authenticator.user import UserContainer\n  >>> users = UserContainer()\n  >>> token1, p1 = users.add(p1)\n  >>> token2, p2 = users.add(p2)\n  >>> token3, p3 = users.add(p3)\n  >>> token4, p4 = users.add(p4)\n\nAdd the GroupContainer and UserContainer to the Authenticator and \nset the correct plugin names\n\n  >>> authenticator['users'] = users\n  >>> authenticator['groups'] = groups\n  >>> authenticator.authenticatorPlugins = ('users', 'groups')\n\n\nAdding users to groups\n----------------------\n\nNow we can set the users on the group but first we need to register the\nIFoundPrincipal adapter for groups. The FoundGroup adapter provides this\ninterface:\n\n  >>> from z3c.authenticator.principal import FoundGroup\n  >>> zope.component.provideAdapter(FoundGroup, \n  ...     provides=interfaces.IFoundPrincipal)\n\nAnd we also need to provide the IFoundPrincipal and IAuthenticatedPrincipal\nadapter for IPrincipal objects:\n\n  >>> from z3c.authenticator.principal import AuthenticatedPrincipal\n  >>> from z3c.authenticator.principal import FoundPrincipal\n  >>> zope.component.provideAdapter(AuthenticatedPrincipal, \n  ...     provides=interfaces.IAuthenticatedPrincipal)\n\n  >>> zope.component.provideAdapter(FoundPrincipal, \n  ...     provides=interfaces.IFoundPrincipal)\n\nAnd we need the ``setGroupsForPrincipal`` subscriber:\n\n  >>> from z3c.authenticator.group import setGroupsForPrincipal\n  >>> zope.component.provideHandler(setGroupsForPrincipal, \n  ...     [interfaces.IPrincipalCreated])\n\n  >>> g1.principals = [p1.__name__, p2.__name__]\n  >>> g1.principals\n  (..., ...)\n\n  >>> g1.principals[0] == p1.__name__\n  True\n\n  >>> g1.principals[1] == p2.__name__\n  True\n\nAdding users fires an event.\n\n  >>> getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n  <PrincipalsAddedToGroup [..., ...] u'groups.g1'>\n\nWe can now look up groups for the users:\n\n  >>> groups.getGroupsForPrincipal(p1.__name__)\n  (u'groups.g1',)\n\nNote that the group id is a concatenation of the group-folder prefix\nand the name of the group object within the folder.\n\nIf we delete a group:\n\n  >>> del groups['groups.g1']\n\nthen the groups folder loses the group information for that group's users:\n\n  >>> groups.getGroupsForPrincipal('p1')\n  ()\n\nbut the principal information on the group is unchanged:\n\n  >>> g1.principals\n  (..., ...)\n\n  >>> g1.principals[0] == p1.__name__\n  True\n\n  >>> g1.principals[1] == p2.__name__\n  True\n\nIt also fires an event showing that the users are removed from the groups.\n\n  >>> getEvents(interfaces.IPrincipalsRemovedFromGroup)[-1]\n  <PrincipalsRemovedFromGroup [..., ...] 'groups.g1'>\n\nAdding the group again within a different name will make the groups \navailable for the principal. Let's use a different group name:\n\n  >>> groups['groups.G1'] = g1\n\n  >>> groups.getGroupsForPrincipal(p1.__name__)\n  (u'groups.G1',)\n\nHere we see that the new name is reflected in the group information.\n\nAn event is fired, as usual.\n\n  >>> getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n  <PrincipalsAddedToGroup [..., ...] u'groups.G1'>\n\nIn terms of member events (members added and removed from groups), we have\nnow seen that events are fired when a group object is added and when it is \nremoved from a group container; and we have seen that events are fired\nwhen a principal is added to an already-registered groups.  Events are also\nfired when a principal is removed from an already-registered groups.  Let's\nquickly see some more examples.\n\n  >>> g1.principals = (p1.__name__, p3.__name__, p4.__name__)\n  >>> g1.principals\n  (..., ..., ...)\n\n  >>> g1.principals[0] == p1.__name__\n  True\n\n  >>> g1.principals[1] == p3.__name__\n  True\n\n  >>> g1.principals[2] == p4.__name__\n  True\n\n  >>> getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n  <PrincipalsAddedToGroup [..., ...] u'groups.G1'>\n\n  >>> getEvents(interfaces.IPrincipalsRemovedFromGroup)[-1]\n  <PrincipalsRemovedFromGroup [...] u'groups.G1'>\n\n  >>> g1.principals = (p1.__name__, p2.__name__)\n  >>> g1.principals\n  (..., ...)\n\n  >>> g1.principals[0] == p1.__name__\n  True\n\n  >>> g1.principals[1] == p2.__name__\n  True\n\n  >>> getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n  <PrincipalsAddedToGroup [...] u'groups.G1'>\n\n  >>> getEvents(interfaces.IPrincipalsRemovedFromGroup)[-1]\n  <PrincipalsRemovedFromGroup [..., ...] u'groups.G1'>\n\n  >>> groups.getGroupsForPrincipal(p2.__name__)\n  (u'groups.G1',)\n\n\nGroups in groups\n----------------\n\nGroups can contain groups:\n\n  >>> g2 = Group('Group Two')\n  >>> groups['groups.G2'] = g2\n  >>> g2.principals\n  ()\n  \n  >>> g2.principals = ['groups.G1']\n\n  >>> g2.principals\n  ('groups.G1',)\n\n  >>> groups.getGroupsForPrincipal('groups.G2')\n  ()\n\n  >>> g1.principals\n  (..., ...)\n\n  >>> g1.principals[0] == p1.__name__\n  True\n\n  >>> g1.principals[1] == p2.__name__\n  True\n\n  >>> groups.getGroupsForPrincipal('groups.G1')\n  (u'groups.G2',)\n\n  >>> old = getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n  >>> old\n  <PrincipalsAddedToGroup ['groups.G1'] u'groups.G2'>\n\nGroups cannot contain cycles:\n\n  >>> g1.principals\n  (..., ...)\n\n  >>> g1.principals[0] == p1.__name__\n  True\n\n  >>> g1.principals[1] == p2.__name__\n  True\n\n  >>> g2.principals\n  ('groups.G1',)\n\n  >>> g1.principals = (p1.__name__, p2.__name__, 'groups.G2')\n  Traceback (most recent call last):\n  ...\n  GroupCycle: (...)\n\n  >>> g1.principals\n  (..., ...)\n\n\n  >>> g1.principals[0] == p1.__name__\n  True\n\n  >>> g1.principals[1] == p2.__name__\n  True\n\nTrying to do so does not fire an event.\n\n  >>> getEvents(interfaces.IPrincipalsAddedToGroup)[-1] is old\n  True\n\nThey need not be hierarchical:\n\n  >>> ga = Group(\"Group A\")\n  >>> groups['groups.GA'] = ga\n\n  >>> gb = Group(\"Group B\")\n  >>> groups['groups.GB'] = gb\n  >>> gb.principals = ['groups.GA']\n\n  >>> gc = Group(\"Group C\")\n  >>> groups['groups.GC'] = gc\n  >>> gc.principals = ['groups.GA']\n\n  >>> gd = Group(\"Group D\")\n  >>> groups['groups.GD'] = gd\n  >>> gd.principals = ['groups.GA', 'groups.GB']\n\n  >>> ga.principals = [p1.__name__]\n\nGroup containers provide a very simple search interface.  They perform\nsimple string searches on group titles and descriptions.\n\n  >>> list(groups.search({'search': 'grou'}))\n  [u'groups.G1', u'groups.G2',\n   u'groups.GA', u'groups.GB', u'groups.GC', u'groups.GD']\n\n  >>> list(groups.search({'search': 'two'}))\n  [u'groups.G2']\n\nThey also support batching:\n\n  >>> list(groups.search({'search': 'grou'}, 2, 3))\n  [u'groups.GA', u'groups.GB', u'groups.GC']\n\n\nIf you don't supply a search key, no results will be returned:\n\n  >>> list(groups.search({}))\n  []\n\n\nIdentifying groups\n------------------\n\nThe function, `setGroupsForPrincipal`, is a subscriber to\nprincipal-creation events.  It adds any group-folder-defined groups to\nusers in those groups:\n\n  >>> auth1 = authenticator.getPrincipal(p1.__name__)\n\n  >>> auth1.groups\n  [u'groups.G1', u'groups.GA']\n\nOf course, this applies to groups too:\n\n  >>> g1 = authenticator.getPrincipal('groups.G1')\n  >>> g1.id\n  u'groups.G1'\n\n  >>> g1.groups\n  [u'groups.G2']\n\nA FoundGroup provides IFoundGroup which is inherited from \nIFoundPrincipal and IGroup:\n\n  >>> interfaces.IFoundGroup.providedBy(g1)\n  True\n\n  >>> interfaces.IFoundPrincipal.providedBy(g1)\n  True\n\n  >>> import zope.security.interfaces\n  >>> zope.security.interfaces.IGroup.providedBy(g1)\n  True\n\n\nspecialGroups\n-------------\n\nTwo special groups, IAuthenticatedGroup, and IEveryoneGroup may apply to users\ncreated by the IAuthentication utility.  There is a subscriber called \n``specialGroups``. This subscriber can set this special groups on any \nprincipal if IAuthenticatedGroup, or IEveryoneGroup utilities are \nprovided. The subscriber knows also how to apply local groups to principals.\nNote, principals means IAuthenticatedPrincipal, IFoundPrincipal or IFoundGroup.\n\nIf we notify the subscriber with the principal, nothing will happen\nbecause the groups haven't been defined:\n\n  >>> from z3c.authenticator.principal import FoundPrincipal\n  >>> from z3c.authenticator.event import FoundPrincipalCreated\n  >>> from z3c.authenticator.group import specialGroups\n  >>> x = User('x', 'password', 'X')\n  >>> found = FoundPrincipal(x)\n  >>> event = FoundPrincipalCreated(authenticator, found)\n  >>> specialGroups(event)\n  >>> found.groups\n  []\n\nNow, if we define the Everybody group:\n\n  >>> import zope.authentication.interfaces\n  >>> @zope.interface.implementer(\n  ...        zope.authentication.interfaces.IEveryoneGroup)\n  ... class EverybodyGroup(Group):\n  ...     pass\n\n  >>> all = EverybodyGroup('groups.all')\n  >>> groups['groups.all'] = all\n  >>> zope.component.provideUtility(all,\n  ...     zope.authentication.interfaces.IEveryoneGroup)\n\nThen the group will be added to the principal:\n\n  >>> specialGroups(event)\n  >>> found.groups\n  [u'groups.all']\n\nSimilarly for the authenticated group:\n\n  >>> @zope.interface.implementer(\n  ...         zope.authentication.interfaces.IAuthenticatedGroup)\n  ... class AuthenticatedGroup(Group):\n  ...     pass\n\n  >>> authenticated = AuthenticatedGroup('groups.authenticated')\n  >>> groups['groups.authenticated'] = authenticated\n  >>> zope.component.provideUtility(authenticated,\n  ...     zope.authentication.interfaces.IAuthenticatedGroup)\n\nThen the group will be added to the principal:\n\n  >>> found.groups = []\n  >>> specialGroups(event)\n  >>> found.groups.sort()\n  >>> found.groups\n  [u'groups.all', u'groups.authenticated']\n\nIt is important that we do not apply a group twice since the\nUnauthenticatedPrincipal is a single instance in the securitypolicy. This issue\nis fixed in version 0.6.1 and 0.7.1\n\n  >>> specialGroups(event)\n  >>> found.groups\n  [u'groups.all', u'groups.authenticated']\n\n\nallGroups\n---------\n\nThe `allGroups` attribute is a readonly iterable of the full closure of the\ngroups in the `groups` attribute. Let's define a new principal first:\n\n  >>> p = User(u'p', u'password', u'Principal')\n  >>> token, p = users.add(p)\n\nAnd the groups:\n\n  >>> ga = Group(\"Administrators\")\n  >>> gr = Group(\"Reviewers\")\n  >>> gid, ga = groups.addGroup(u'Administrators', ga)\n  >>> gid, gr = groups.addGroup(u'Reviewers', gr)\n\nIf the principal is a direct member of the 'Administrators' group, \n\n  >>> ga.principals = [p.__name__]\n\nthen getGroupsForPrincipal would be ['Administrators']\n\n  >>> groups.getGroupsForPrincipal(p.__name__)\n  (u'groups.Administrators',)\n  \nand if the 'Administrators' group is a member of the 'Reviewers' group, \n\n  >>> gr.principals = [ga.id]\n\nthen groups would be ['Administrators'] too.\n\n  >>> groups.getGroupsForPrincipal(p.__name__)\n  (u'groups.Administrators',)\n\nnow let's use the setGroupsForPrincipal subscriber which knows how to apply\nthe groups to the found principal:\n\n  >>> pFound = FoundPrincipal(p)\n  >>> event = FoundPrincipalCreated(authenticator, pFound)\n  >>> setGroupsForPrincipal(event)\n\nAs you can see and pFound.groups is ['Administrators'].\n\n  >>> sorted(pFound.groups)\n  [u'groups.Administrators']\n\nAnd pFound.allGroups is ['Administrators', 'Reviewers'].\n\n  >>> sorted(pFound.allGroups)\n  [u'groups.Administrators', u'groups.Reviewers']\n\n\n==========\nVocabulary\n==========\n\nThe vocabulary module provides vocabularies for the authenticator plugins and\nthe credentials plugins.\n\nThe options should include the unique names of all of the plugins that provide\nthe appropriate interface (IAuthentiatorPlugin or ICredentialsPlugin, \nrespectively) for the current context which is expected to be a IAuthenticator \nutility, hereafter referred to as a Authenticator.\n\nThese names may be for objects contained within the Authenticator \n(\"contained plugins\"), or may be utilities registered for the specified \ninterface, found in the context of the Authenticator \n(\"utility plugins\"). Contained plugins mask utility plugins of the same name. \nThey also may be names currently selected in the Authenticator that do \nnot actually have a corresponding plugin at this time.\n\nHere is a short example of how the vocabulary should work.  Let's say we're\nworking with authentication plugins.  We'll create some faux\nauthentication plugins, and register some of them as utilities and put\nothers in a faux Authenticator.\n\n    >>> from z3c.authenticator import interfaces\n    >>> import zope.interface\n    >>> import zope.component\n    >>> @zope.interface.implementer(interfaces.IAuthenticatorPlugin)\n    ... class DemoPlugin(object):\n    ...     def __init__(self, name):\n    ...         self.name = name\n    ...\n    >>> utility_plugins = dict(\n    ...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(4))\n    >>> contained_plugins = dict(\n    ...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(1, 5))\n    >>> sorted(utility_plugins.keys())\n    [0, 1, 2, 3]\n    >>> for p in utility_plugins.values():\n    ...     zope.component.provideUtility(p, name=p.name)\n    ...\n    >>> sorted(contained_plugins.keys()) # 1 will mask utility plugin 1\n    [1, 2, 3, 4]\n    >>> @zope.interface.implementer(interfaces.IAuthenticator)\n    ... class DemoAuth(dict):\n    ...     def __init__(self, *args, **kwargs):\n    ...         super(DemoAuth, self).__init__(*args, **kwargs)\n    ...         self.authenticatorPlugins = (u'Plugin 3', u'Plugin X')\n    ...         self.credentialsPlugins = (u'Plugin 4', u'Plugin X')\n    ...\n    >>> auth = DemoAuth((p.name, p) for p in contained_plugins.values())\n    \n    >>> @zope.component.adapter(zope.interface.Interface)\n    ... @zope.interface.implementer(zope.component.IComponentLookup)\n    ... def getSiteManager(context):\n    ...     return zope.component.getGlobalSiteManager()\n    ...\n    >>> zope.component.provideAdapter(getSiteManager)\n\n\nauthenticatorPlugins\n--------------------\n\nWe are now ready to create a vocabulary that we can use.  The context is\nour faux authentication utility, `auth`.\n\n    >>> from z3c.authenticator import vocabulary\n    >>> vocab = vocabulary.authenticatorPlugins(auth)\n\nIterating over the vocabulary results in all of the terms, in a relatively\narbitrary order of their names.  (This vocabulary should typically use a\nwidget that sorts values on the basis of localized collation order of the\nterm titles.)\n\n    >>> [term.value for term in vocab] # doctest: +NORMALIZE_WHITESPACE\n    [u'Plugin 0', u'Plugin 1', u'Plugin 2', u'Plugin 3', u'Plugin 4',\n     u'Plugin X']\n\nSimilarly, we can use `in` to test for the presence of values in the\nvocabulary.\n\n    >>> ['Plugin %s' % i in vocab for i in range(-1, 6)]\n    [False, True, True, True, True, True, False]\n    >>> 'Plugin X' in vocab\n    True\n\nThe length reports the expected value.\n\n    >>> len(vocab)\n    6\n\nOne can get a term for a given value using `getTerm()`; its token, in\nturn, should also return the same effective term from `getTermByToken`.\n\n    >>> values = ['Plugin 0', 'Plugin 1', 'Plugin 2', 'Plugin 3', 'Plugin 4',\n    ...           'Plugin X']\n    >>> for val in values:\n    ...     term = vocab.getTerm(val)\n    ...     assert term.value == val\n    ...     term2 = vocab.getTermByToken(term.token)\n    ...     assert term2.token == term.token\n    ...     assert term2.value == val\n    ...\n\nThe terms have titles, which are message ids that show the plugin title or id\nand whether the plugin is a utility or just contained in the auth utility.\nWe'll give one of the plugins a dublin core title just to show the\nfunctionality.\n\n    >>> import zope.dublincore.interfaces\n    >>> class ISpecial(zope.interface.Interface):\n    ...     pass\n    ...\n    >>> zope.interface.directlyProvides(contained_plugins[1], ISpecial)\n    >>> @zope.interface.implementer(\n    ...         zope.dublincore.interfaces.IDCDescriptiveProperties)\n    ... class DemoDCAdapter(object):\n    ...     zope.component.adapts(ISpecial)\n    ...     def __init__(self, context):\n    ...         pass\n    ...     title = u'Special Title'\n    ...\n    >>> zope.component.provideAdapter(DemoDCAdapter)\n\nWe need to regenerate the vocabulary, since it calculates all of its data at\nonce.\n\n    >>> vocab = vocabulary.authenticatorPlugins(auth)\n\nNow we'll check the titles.  We'll have to translate them to see what we\nexpect.\n\n    >>> from zope import i18n\n    >>> import pprint\n    >>> pprint.pprint([i18n.translate(term.title) for term in vocab])\n    [u'Plugin 0 (a utility)',\n     u'Special Title (in contents)',\n     u'Plugin 2 (in contents)',\n     u'Plugin 3 (in contents)',\n     u'Plugin 4 (in contents)',\n     u'Plugin X (not found; deselecting will remove)']\n\n\ncredentialsPlugins\n------------------\n\nFor completeness, we'll do the same review of the credentialsPlugins.\n\n    >>> @zope.interface.implementer(interfaces.ICredentialsPlugin)\n    ... class DemoPlugin(object):\n    ...     def __init__(self, name):\n    ...         self.name = name\n    ...\n    >>> utility_plugins = dict(\n    ...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(4))\n    >>> contained_plugins = dict(\n    ...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(1, 5))\n    >>> for p in utility_plugins.values():\n    ...     zope.component.provideUtility(p, name=p.name)\n    ...\n    >>> auth = DemoAuth((p.name, p) for p in contained_plugins.values())\n    >>> vocab = vocabulary.credentialsPlugins(auth)\n\nIterating over the vocabulary results in all of the terms, in a relatively\narbitrary order of their names.  (This vocabulary should typically use a\nwidget that sorts values on the basis of localized collation order of the term\ntitles.) Similarly, we can use `in` to test for the presence of values in the\nvocabulary. The length reports the expected value.\n\n    >>> [term.value for term in vocab] # doctest: +NORMALIZE_WHITESPACE\n    [u'Plugin 0', u'Plugin 1', u'Plugin 2', u'Plugin 3', u'Plugin 4',\n     u'Plugin X']\n    >>> ['Plugin %s' % i in vocab for i in range(-1, 6)]\n    [False, True, True, True, True, True, False]\n    >>> 'Plugin X' in vocab\n    True\n    >>> len(vocab)\n    6\n\nOne can get a term for a given value using `getTerm()`; its token, in\nturn, should also return the same effective term from `getTermByToken`.\n\n    >>> values = ['Plugin 0', 'Plugin 1', 'Plugin 2', 'Plugin 3', 'Plugin 4',\n    ...           'Plugin X']\n    >>> for val in values:\n    ...     term = vocab.getTerm(val)\n    ...     assert term.value == val\n    ...     term2 = vocab.getTermByToken(term.token)\n    ...     assert term2.token == term.token\n    ...     assert term2.value == val\n    ...\n\nThe terms have titles, which are message ids that show the plugin title or id\nand whether the plugin is a utility or just contained in the auth utility.\nWe'll give one of the plugins a dublin core title just to show the\nfunctionality. We need to regenerate the vocabulary, since it calculates all\nof its data at once. Then we'll check the titles.  We'll have to translate\nthem to see what we expect.\n\n    >>> zope.interface.directlyProvides(contained_plugins[1], ISpecial)\n    >>> vocab = vocabulary.credentialsPlugins(auth)\n    >>> pprint.pprint([i18n.translate(term.title) for term in vocab])\n    [u'Plugin 0 (a utility)',\n     u'Special Title (in contents)',\n     u'Plugin 2 (in contents)',\n     u'Plugin 3 (in contents)',\n     u'Plugin 4 (in contents)',\n     u'Plugin X (not found; deselecting will remove)']\n\n\n=======\nCHANGES\n=======\n\n1.0.1 (2018-05-16)\n------------------\n\n- bugfix: remove None from queryNextUtiliy because getNextUtility signature got\n  changed and None was used as name argument.\n\n- cleanup, removed unused imports\n\n- Get rid of deprecation warning. Switch hooks import from zope.site to\n  zope.component\n\n- skip test_exception_in_subscriber_leaves_item_in_place for IAuthenticator\n  container. This zope.container test method left over an event subscriber with\n  zope.container version 4.2.1 which raises an error in other methods. Needs\n  review and probably a tear down in zope.container test method.\n\n\n1.0.0 (2017-04-17)\n------------------\n\n- Ping Python support to 2.7, 3.5, 3.6 and PyPy.\n\n\n1.0.0a5 (2013-03-31)\n--------------------\n\n- More Py3 compatibility bugs in untested code.\n\n\n1.0.0a4 (2013-02-28)\n--------------------\n\n- Removed support for Zope generations. It was not used and application-wide\n  generations make more sense anyways. This removed the\n  ``zope.app.generations`` and ``zope.generations`` dependencies.\n\n- Made ``z3c.configurator`` support optional.\n\n- Cleaned up source code a little bit.\n\n\n1.0.0a3 (2013-02-28)\n--------------------\n\n- Changed manifest to actually include the page templates.\n\n\n1.0.0a2 (2013-02-28)\n--------------------\n\n- Added version Trove classifiers.\n\n\n1.0.0a1 (2013-02-28)\n--------------------\n\n- Dropped support for Python 2.4 and 2.5, added Python 3.3 support.\n\n- Removed dependencies on ``zope.app`` packages.\n\n\n0.8.1 (2011-01-21)\n------------------\n\n- Bugfix: Did not handle unicode IUser.login values.\n\n- Fixed DeprecationWarnings.\n\n\n0.8.0 (2010-01-25)\n------------------\n\n- Security Fix: move camefrom url to a session variable instead of exposing\n  the url in the login form. Because the camefrom url is built at server side\n  based on local information and will always only use internal traversal names.\n  Exposing this camefrom query in the login url gives others only a point to\n  attack because it could be simply set by a unfriendly domain with a custom\n  url. This is much better since such a unfriendly 3rd party domain url doesn't\n  get redirected by default based on the changes in zope.publisher's redirect\n  method. (zope.publisher 3.9.3 does only redirect to urls located in the same\n  domain by default)\n\n  Remove all camefrom widgets and queries in our custom forms if you use any.\n  You can just set and get the camefrom session variable in your custom forms\n  if you need to.\n\n0.7.2 (2010-01-26)\n------------------\n\n- Bugfix: Failed miserably on challenge on pages having non-ASCII names.\n\n0.7.1 (2009-08-19)\n------------------\n\n- Bugfix: the method specialGroups applied groups everytime the method get\n  called even if the group was already applied. This is a problem if the\n  global shared unauthenticated principal instance is used because it will\n  apply similar groups till the server get restarted and a new principal\n  instance is used.\n\n- Feature: added getUserByLogin to IUserContainer\n\n- Added a test for user migration (that they will keep their ID)\n\n\n0.7.0 (2009-05-11)\n------------------\n\n- Update dependencies:\n\n   * Use ``zope.container`` instead of ``zope.app.container``.\n   * Use ``zope.site`` instead of ``zope.app.component``.\n   * Use ``zope.authentication`` and ``zope.principalregistry`` instead\n     of ``zope.app.security``.\n   * Use ``zope.password`` instead of maintaining a copy of password\n     managers.\n\n- Drop dependency on z3c.i18n and recreate a message factory instead.\n\n0.6.2 (2010-01-26)\n------------------\n\n- Bugfix: Failed miserably on challenge on pages having non-ASCII names.\n  (Backport from 0.7.2)\n\n0.6.1 (2009-08-19)\n------------------\n\n- Backport bugfix 0.7.1 to 0.6.1. See branches/roger-0.6.0\n\n  the method specialGroups applied groups everytime the method get\n  called even if the group was already applied. This is a problem if the\n  global shared unauthenticated principal instance is used because it will\n  apply similar groups till the server get restarted and a new principal\n  instance is used.\n\n\n0.6.0 (2009-01-04)\n------------------\n\n- Feature: added support for local IUnauthenticatedPrincipal. This is usefull\n  if you need to apply local roles to IUnauthenticatedPrincipal. This was not\n  possible before and is not possible in zope.app.authentication\n\n- Feature: implemented initial grant view based on ISource widget. Note, this\n  source widget terms implementation which is very complex to understand will\n  get moved to z3c.from if we fixed the ITerm dependency. Which means ITerm\n  needs to get moved out of zope.app.form first.\n\n- Feature: added support for next utility lookup in authenticate call. By\n  default the principals from the global principalregistry get involved now.\n  You can disable this feature by setting includeNextUtilityForAuthenticate to\n  False.\n\n- Feature: added PrincipalRegistryAuthenticatorPlugin which allows to\n  authenticate principals defined in global principal registry.\n\n- Feature: implemented z3c.form prefix support in SessionCredentialsPlugin. Now\n  there is an option called prefixes which can be used for define a list of\n  used z3c.form prefixes. This makes it simpler for supporting different forms\n  and adjust the credential extraction.\n\n- Renamed IGroupPrincipal to IFoundGroup which makes it more understandable\n  why this adapter implementation is needed. The IFoundGroup adapter is now\n  also used for zope.security.interfaces.IGroup principals. This makes it\n  possible to use them in the new principalregistry credential. Provide\n  deprecation message for the old IGroupPrincipal implementation.\n\n- Removed dependency for zapi. But it's not really gone since other packages\n  use zapi too.\n\n- Removed unused InvalidPrincipalIds and InvalidGroupId exceptions\n\n- Removed unused IMemberAwareGroup support. This interface is not used in zope\n  at all.\n\n- Added documentation for Pypi home page.\n\n\n0.5.1 (2008-04-16)\n------------------\n\n- Cleanup imports and adjust dependencies\n\n\n0.5.0 (2008-04-16)\n------------------\n\n- Initial Release\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/z3c.authenticator", "keywords": "zope3 z3c authentication auth group", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "z3c.authenticator", "package_url": "https://pypi.org/project/z3c.authenticator/", "platform": "", "project_url": "https://pypi.org/project/z3c.authenticator/", "project_urls": {"Homepage": "http://pypi.python.org/pypi/z3c.authenticator"}, "release_url": "https://pypi.org/project/z3c.authenticator/1.0.1/", "requires_dist": null, "requires_python": "", "summary": "IAuthentication implementation for for Zope3", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This package provides an IAuthentication implementation for Zope3. Note that\nthis implementation is independent of zope.app.authentication and it doesn\u2019t\ndepend on that package. This means it doesn\u2019t even use the credential or\nauthentication plugins offered from zope.app.authentication package.</p>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#iauthentication-utility\" id=\"id14\" rel=\"nofollow\">IAuthentication Utility</a><ul>\n<li><a href=\"#security\" id=\"id15\" rel=\"nofollow\">Security</a></li>\n<li><a href=\"#what-s-different-from-pluggableauthentication\" id=\"id16\" rel=\"nofollow\">What\u2019s different from PluggableAuthentication</a><ul>\n<li><a href=\"#authentication\" id=\"id17\" rel=\"nofollow\">Authentication</a></li>\n</ul>\n</li>\n<li><a href=\"#faq\" id=\"id18\" rel=\"nofollow\">FAQ</a></li>\n<li><a href=\"#principal\" id=\"id19\" rel=\"nofollow\">Principal</a></li>\n<li><a href=\"#authenticator-plugin\" id=\"id20\" rel=\"nofollow\">Authenticator Plugin</a></li>\n<li><a href=\"#credentials-plugin\" id=\"id21\" rel=\"nofollow\">Credentials Plugin</a></li>\n<li><a href=\"#authenticatedprincipal-and-foundprincipal\" id=\"id22\" rel=\"nofollow\">AuthenticatedPrincipal and FoundPrincipal</a></li>\n<li><a href=\"#configuring-the-authenticator\" id=\"id23\" rel=\"nofollow\">Configuring the Authenticator</a></li>\n<li><a href=\"#authenticate\" id=\"id24\" rel=\"nofollow\">Authenticate</a></li>\n<li><a href=\"#changing-login-names\" id=\"id25\" rel=\"nofollow\">Changing login names</a></li>\n<li><a href=\"#events\" id=\"id26\" rel=\"nofollow\">Events</a></li>\n<li><a href=\"#customization\" id=\"id27\" rel=\"nofollow\">Customization</a></li>\n<li><a href=\"#edge-cases\" id=\"id28\" rel=\"nofollow\">Edge cases</a></li>\n</ul>\n</li>\n<li><a href=\"#group\" id=\"id29\" rel=\"nofollow\">Group</a><ul>\n<li><a href=\"#id1\" id=\"id30\" rel=\"nofollow\">Group</a></li>\n<li><a href=\"#groupcontainer\" id=\"id31\" rel=\"nofollow\">GroupContainer</a></li>\n<li><a href=\"#adding-users-to-groups\" id=\"id32\" rel=\"nofollow\">Adding users to groups</a></li>\n<li><a href=\"#groups-in-groups\" id=\"id33\" rel=\"nofollow\">Groups in groups</a></li>\n<li><a href=\"#identifying-groups\" id=\"id34\" rel=\"nofollow\">Identifying groups</a></li>\n<li><a href=\"#specialgroups\" id=\"id35\" rel=\"nofollow\">specialGroups</a></li>\n<li><a href=\"#allgroups\" id=\"id36\" rel=\"nofollow\">allGroups</a></li>\n</ul>\n</li>\n<li><a href=\"#vocabulary\" id=\"id37\" rel=\"nofollow\">Vocabulary</a><ul>\n<li><a href=\"#authenticatorplugins\" id=\"id38\" rel=\"nofollow\">authenticatorPlugins</a></li>\n<li><a href=\"#credentialsplugins\" id=\"id39\" rel=\"nofollow\">credentialsPlugins</a></li>\n</ul>\n</li>\n<li><a href=\"#changes\" id=\"id40\" rel=\"nofollow\">CHANGES</a><ul>\n<li><a href=\"#id2\" id=\"id41\" rel=\"nofollow\">1.0.1 (2018-05-16)</a></li>\n<li><a href=\"#id3\" id=\"id42\" rel=\"nofollow\">1.0.0 (2017-04-17)</a></li>\n<li><a href=\"#a5-2013-03-31\" id=\"id43\" rel=\"nofollow\">1.0.0a5 (2013-03-31)</a></li>\n<li><a href=\"#a4-2013-02-28\" id=\"id44\" rel=\"nofollow\">1.0.0a4 (2013-02-28)</a></li>\n<li><a href=\"#a3-2013-02-28\" id=\"id45\" rel=\"nofollow\">1.0.0a3 (2013-02-28)</a></li>\n<li><a href=\"#a2-2013-02-28\" id=\"id46\" rel=\"nofollow\">1.0.0a2 (2013-02-28)</a></li>\n<li><a href=\"#a1-2013-02-28\" id=\"id47\" rel=\"nofollow\">1.0.0a1 (2013-02-28)</a></li>\n<li><a href=\"#id4\" id=\"id48\" rel=\"nofollow\">0.8.1 (2011-01-21)</a></li>\n<li><a href=\"#id5\" id=\"id49\" rel=\"nofollow\">0.8.0 (2010-01-25)</a></li>\n<li><a href=\"#id6\" id=\"id50\" rel=\"nofollow\">0.7.2 (2010-01-26)</a></li>\n<li><a href=\"#id7\" id=\"id51\" rel=\"nofollow\">0.7.1 (2009-08-19)</a></li>\n<li><a href=\"#id8\" id=\"id52\" rel=\"nofollow\">0.7.0 (2009-05-11)</a></li>\n<li><a href=\"#id9\" id=\"id53\" rel=\"nofollow\">0.6.2 (2010-01-26)</a></li>\n<li><a href=\"#id10\" id=\"id54\" rel=\"nofollow\">0.6.1 (2009-08-19)</a></li>\n<li><a href=\"#id11\" id=\"id55\" rel=\"nofollow\">0.6.0 (2009-01-04)</a></li>\n<li><a href=\"#id12\" id=\"id56\" rel=\"nofollow\">0.5.1 (2008-04-16)</a></li>\n<li><a href=\"#id13\" id=\"id57\" rel=\"nofollow\">0.5.0 (2008-04-16)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"iauthentication-utility\">\n<h2><a href=\"#id14\" rel=\"nofollow\">IAuthentication Utility</a></h2>\n<p>The Authenticator package provides a framework for authenticating principals\nand associating information with them. It uses plugins and subscribers to get\nits work done.</p>\n<p>For a simple authentication utility to be used, it should be registered as a\nutility providing the <cite>zope.authentication.interfaces.IAuthentication</cite> interface.</p>\n<p>Our target is to support a handy IAuthentication utility which offers a simple\nAPI for custom IUser implementations and does not depend on the default\nzope.app.authentication implementation.</p>\n<div id=\"security\">\n<h3><a href=\"#id15\" rel=\"nofollow\">Security</a></h3>\n<p>The Authenticator supports unique id tokens for principals. This means\nprincipal that get deleted and again added with the same id, login etc. do\nnot have the same id again. We support this by generate a user id token\ngenerated by the host id, timestamp, a random string and the login attribute.</p>\n</div>\n<div id=\"what-s-different-from-pluggableauthentication\">\n<h3><a href=\"#id16\" rel=\"nofollow\">What\u2019s different from PluggableAuthentication</a></h3>\n<p>We use a different pattern for IAuthenticatorPlugins in this implementation\nthan used in PluggableAuthentication from zope.app.authentication,\nbecause the pluggable authentication is not very handy when it comes to\nimplementing custom principal information. The IPrincipalInfo hook supporting\nnot propagate the password of a IInternalPrincipal is droped in this\nimplementation.</p>\n<p>In our implementation we offer a IFoundPrincipal and IAuthenticatedPrincipal\nwhich are implemented as adapters for a IUser. These adapters do not offer\ntheir context which is the real IUser.</p>\n<p>The Authenticator doesn\u2019t use a prefix. The usage of a prefix is only\nimplemented in the IGroupContainer.</p>\n<p>We do not use a prefix in the IUserContainer because of the used unique user\nid tokens. This will make sure that the same principal id doesn\u2019t get used at\na later time (common criteria). There is a <tt>add</tt> method which creates\nthis id for you based on the login. The __setitem__ should not get used\ndirectly for adding IUser instances anymore. We heavily restricted the\nusage of this method. See the inline doc tests in __setitem__ for more info.</p>\n<div id=\"authentication\">\n<h4><a href=\"#id17\" rel=\"nofollow\">Authentication</a></h4>\n<p>The primary job of Authenticator is to authenticate principals. It uses\ntwo types of plug-ins in its work:</p>\n<blockquote>\n<ul>\n<li>Credentials Plugins</li>\n<li>Authenticator Plugins</li>\n</ul>\n</blockquote>\n<p>Credentials plugins are responsible for extracting user credentials from a\nrequest. A credentials plugin may in some cases issue a \u2018challenge\u2019 to obtain\ncredentials. For example, a \u2018session\u2019 credentials plugin reads credentials\nfrom a session (the \u201cextraction\u201d). If it cannot find credentials, it will\nredirect the user to a login form in order to provide them (the \u201cchallenge\u201d).</p>\n<p>Authenticator plugins are responsible for authenticating the credentials\nextracted by a credentials plugin. They are also typically able to create\nprincipal objects for credentials they successfully authenticate.</p>\n<p>Given a request object, the Authenticator returns a principal object, if it\ncan. The Authenticator utility does this by first iterating through its\ncredentials plugins to obtain a set of credentials. If it gets credentials, it\niterates through its authenticator plugins to authenticate them.</p>\n<p>If an authenticator succeeds in authenticating a set of credentials, the\nAuthenticator uses the authenticator to create a principal\ncorresponding to the credentials. The authenticator notifies subscribers if\nan authenticated principal is created. Subscribers are responsible for adding\ndata, especially groups, to the principal. Typically, if a subscriber adds\ndata, it should also add corresponding interface declarations.</p>\n</div>\n</div>\n<div id=\"faq\">\n<h3><a href=\"#id18\" rel=\"nofollow\">FAQ</a></h3>\n<p>Here some useful hints:</p>\n<p>How should I set permission for principals?</p>\n<blockquote>\nYou can apply roles to groups\nand apply permissions to roles. Or you can directly apply local permisssions\nto groups or to principals. After setting up these mappings you can grant roles to\ngroups. I always recommend a principal - group and permission - role mapping,\nthis gives you the most possible abstraction which is useful if it comes\nto managing permissions and principals without directly invoking principals and\npermissions themselves. But of course you can grant permissions to groups or the\nworst thing, directly to principals. Granting permissions to principals is only\nuseful if it comes to selective local permission settings for selected\nprincipals, e.g. an ownership-like permission setup.</blockquote>\n<p>How can I set permissions for all principals?</p>\n<blockquote>\nYou can register one\ngroup as IEveryone utility. This IGroup utility get applied to all principals.</blockquote>\n<p>Can I apply local groups to unauthenticated principals?</p>\n<blockquote>\nYes this will work.\nSince the last refactoring I refactored the IGroup implementation which makes\nit compatible with the principalregistry API. This means you can now register\none local group as an unnamed IUnauthenticatedGroup. You can also register one\nlocal group as an unnamed IAuthenticatedGroup utility which will get applied\nto every authenticated principal or an unnamed utility for\nIUnauthenticatedGroup.</blockquote>\n<p>Can I apply a local group to every principal?</p>\n<blockquote>\nYes, this is possible if you\nregister a local unnamed utility providing IEveryoneGroup.</blockquote>\n</div>\n<div id=\"principal\">\n<h3><a href=\"#id19\" rel=\"nofollow\">Principal</a></h3>\n<p>First we create a principal:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator import interfaces\n&gt;&gt;&gt; from z3c.authenticator.user import User\n&gt;&gt;&gt; login = u'bob'\n&gt;&gt;&gt; password = u'secret'\n&gt;&gt;&gt; title = u'Bob'\n&gt;&gt;&gt; p = User(login, password, title)\n</pre>\n</blockquote>\n<p>Such a principal provides the following attributes be default</p>\n<blockquote>\n<pre>&gt;&gt;&gt; p.login\nu'bob'\n</pre>\n<pre>&gt;&gt;&gt; p.password.decode('utf-8')\nu'secret'\n</pre>\n<pre>&gt;&gt;&gt; p.title\nu'Bob'\n</pre>\n</blockquote>\n<p>and IUser:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interfaces.IUser.providedBy(p)\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"authenticator-plugin\">\n<h3><a href=\"#id20\" rel=\"nofollow\">Authenticator Plugin</a></h3>\n<p>First set up a UserContainer which will store the principals:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator.user import UserContainer\n&gt;&gt;&gt; authPlugin = UserContainer()\n</pre>\n</blockquote>\n<p>Now we have a UserContainer that provides an IUserContainer:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interfaces.IUserContainer.providedBy(authPlugin)\nTrue\n</pre>\n</blockquote>\n<p>Now we will add the created principal to the principal container using the\ncontainer\u2019s <tt>add</tt> method:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; uid, user = authPlugin.add(p)\n</pre>\n</blockquote>\n<p>The method returns the user id and the user object. The id gets generated\nfrom the host IP address, the time, a random string and the user login attr.\nThis token should be unique and guaranteed that it will never get generated twice.\nThis allows us to add, delete and add the same user again without having such a\nuser inheriting existing permissions. We can test this token by comparing it\nonly with the __name__ of the object in this test since the token will be\ndifferent every test run.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; user.__name__ == uid\nTrue\n</pre>\n</blockquote>\n<p>The returned user is still our previous added IUser</p>\n<blockquote>\n<pre>&gt;&gt;&gt; user is p\nTrue\n</pre>\n<pre>&gt;&gt;&gt; len(user.__name__)\n32\n</pre>\n<pre>&gt;&gt;&gt; user.login\nu'bob'\n</pre>\n<pre>&gt;&gt;&gt; user.password.decode('utf-8')\nu'secret'\n</pre>\n<pre>&gt;&gt;&gt; user.title\nu'Bob'\n</pre>\n</blockquote>\n<p>Let\u2019s register the UserContainer as a named IAuthenticatorPlugin utility:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; zope.component.provideUtility(authPlugin,\n...     provides=interfaces.IAuthenticatorPlugin,\n...     name='My Authenticator Plugin')\n</pre>\n</blockquote>\n</div>\n<div id=\"credentials-plugin\">\n<h3><a href=\"#id21\" rel=\"nofollow\">Credentials Plugin</a></h3>\n<p>After seting up the user and user container, we\u2019ll create a simple credentials\nplugin:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; import zope.component\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(interfaces.ICredentialsPlugin)\n... class MyCredentialsPlugin(object):\n...\n...\n...     def extractCredentials(self, request):\n...         return {'login': request.get('login', ''),\n...                 'password': request.get('password', '')}\n...\n...     def challenge(self, request):\n...         pass # challenge is a no-op for this plugin\n...\n...     def logout(self, request):\n...         pass # logout is a no-op for this plugin\n</pre>\n</blockquote>\n<p>As a plugin, MyCredentialsPlugin needs to be registered as a named utility or\nit could be stored in the Authenticator attribute credentialsPlugins.\nUse the first and register the plugina utility:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; myCredentialsPlugin = MyCredentialsPlugin()\n&gt;&gt;&gt; zope.component.provideUtility(myCredentialsPlugin,\n...     name='My Credentials Plugin')\n</pre>\n</blockquote>\n</div>\n<div id=\"authenticatedprincipal-and-foundprincipal\">\n<h3><a href=\"#id22\" rel=\"nofollow\">AuthenticatedPrincipal and FoundPrincipal</a></h3>\n<p>While authenticator plugins provide users, they are not responsible for\ncreating principals. This function is performed by the Authenticator:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator.principal import AuthenticatedPrincipal\n&gt;&gt;&gt; from z3c.authenticator.principal import FoundPrincipal\n&gt;&gt;&gt; zope.component.provideAdapter(AuthenticatedPrincipal,\n...     provides=interfaces.IAuthenticatedPrincipal)\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(FoundPrincipal,\n...     provides=interfaces.IFoundPrincipal)\n</pre>\n</blockquote>\n</div>\n<div id=\"configuring-the-authenticator\">\n<h3><a href=\"#id23\" rel=\"nofollow\">Configuring the Authenticator</a></h3>\n<p>Finally, we\u2019ll create the Authenticator itself:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator import authentication\n&gt;&gt;&gt; auth = authentication.Authenticator()\n</pre>\n</blockquote>\n<p>and configure it with the two plugins:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; auth.credentialsPlugins = ('My Credentials Plugin', )\n&gt;&gt;&gt; auth.authenticatorPlugins = ('My Authenticator Plugin', )\n</pre>\n</blockquote>\n</div>\n<div id=\"authenticate\">\n<h3><a href=\"#id24\" rel=\"nofollow\">Authenticate</a></h3>\n<p>We can now use the Authenticator to authenticate a sample request:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; print(auth.authenticate(TestRequest()))\nNone\n</pre>\n</blockquote>\n<p>In this case, we cannot authenticate an empty request. In the same way, we\nwill not be able to authenticate a request with the wrong credentials:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={'login': 'let me in!', 'password': 'secret'})\n&gt;&gt;&gt; print(auth.authenticate(request))\nNone\n</pre>\n</blockquote>\n<p>However, if we provide the proper credentials:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={'login': 'bob', 'password': 'secret'})\n&gt;&gt;&gt; bob = auth.authenticate(request)\n&gt;&gt;&gt; bob\n&lt;AuthenticatedPrincipal...&gt;\n</pre>\n<pre>&gt;&gt;&gt; interfaces.IAuthenticatedPrincipal.providedBy(bob)\nTrue\n</pre>\n</blockquote>\n<p>we get an authenticated principal.</p>\n</div>\n<div id=\"changing-login-names\">\n<h3><a href=\"#id25\" rel=\"nofollow\">Changing login names</a></h3>\n<p>Changing the login (i.e. username) of a principal is always a critical task because such a\nlogin together with a password is the key to our implemenation. Let\u2019s try to\nchange the login and check if everything is correct. We can do this by getting the\nprincipal from the UserContainer and changing the login on the IUser\nimplementation:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; internal = authPlugin[bob.id]\n&gt;&gt;&gt; internal.login = u'bob2'\n</pre>\n</blockquote>\n<p>Now we should be able to login with the new login:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={'login': 'bob2', 'password': 'secret'})\n&gt;&gt;&gt; bob2 = auth.authenticate(request)\n&gt;&gt;&gt; bob2\n&lt;AuthenticatedPrincipal ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; bob2.title\nu'Bob'\n</pre>\n</blockquote>\n<p>But not with the old one:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={'login': 'bob', 'password': 'secret'})\n&gt;&gt;&gt; auth.authenticate(request) == None\nTrue\n</pre>\n</blockquote>\n<p>The user bob has still the same id as bob2 since the user id token doesn\u2019t\nget changed by changing the login:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; bob.id == bob2.id\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"events\">\n<h3><a href=\"#id26\" rel=\"nofollow\">Events</a></h3>\n<p>Authenticating a principal will create events.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.component.eventtesting import getEvents\n&gt;&gt;&gt; from zope.component.eventtesting import clearEvents\n</pre>\n</blockquote>\n<p>We can verify that the appropriate event was published:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; clearEvents()\n&gt;&gt;&gt; request = TestRequest(form={'login': 'bob2', 'password': 'secret'})\n&gt;&gt;&gt; bobAgain = auth.authenticate(request)\n</pre>\n</blockquote>\n<p>And the principal attribute in the event provides the authenticated principal:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; [event] = getEvents(interfaces.IAuthenticatedPrincipalCreated)\n&gt;&gt;&gt; event.principal is bobAgain\nTrue\n</pre>\n<pre>&gt;&gt;&gt; event.principal\n&lt;AuthenticatedPrincipal ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; event.request is request\nTrue\n</pre>\n</blockquote>\n<p>The principal has the id, title, and description.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; event.principal.title\nu'Bob'\n</pre>\n<pre>&gt;&gt;&gt; event.principal.id == uid\nTrue\n</pre>\n<pre>&gt;&gt;&gt; event.principal.description\nu''\n</pre>\n</blockquote>\n<p>We provide subscribers to these events that can be used for doing custom\nprocessing. Note, the principal attibute provides an IAuthenticatedPrincipal:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def addInfo(event):\n...     id = event.principal.id\n...     event.principal.description = 'Description for: %s' % id\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideHandler(addInfo,\n...     [interfaces.IAuthenticatedPrincipalCreated])\n</pre>\n</blockquote>\n<p>Now, if we authenticate a principal, its description is set:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principal = auth.authenticate(request)\n&gt;&gt;&gt; principal.description\nu'Description for: ...'\n</pre>\n</blockquote>\n</div>\n<div id=\"customization\">\n<h3><a href=\"#id27\" rel=\"nofollow\">Customization</a></h3>\n<p>Let\u2019s show you how the existing pattern can get used in a real use case. In\nthe next sample we\u2019d like to provide an additional email attribute for principals.\nFirst we have to define the interfaces declaring the email attribute:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class IMyEmail(zope.interface.Interface):\n...     email = zope.schema.TextLine(\n...         title=u'EMail',\n...         description=u'The EMail')\n</pre>\n<pre>&gt;&gt;&gt; class IMyUser(IMyEmail, interfaces.IUser):\n...     \"\"\"Custom IUser interface.\"\"\"\n</pre>\n<pre>&gt;&gt;&gt; class IMyFoundPrincipal(IMyEmail, interfaces.IFoundPrincipal):\n...     \"\"\"Custom IIMyFoundrincipal interface.\"\"\"\n</pre>\n<pre>&gt;&gt;&gt; class IMyAuthenticatedPrincipal(IMyEmail,\n...     interfaces.IAuthenticatedPrincipal):\n...     \"\"\"Custom IAuthenticatedPrincipal interface.\"\"\"\n</pre>\n</blockquote>\n<p>After the schema, we define a custom principal implementation implementing\nthis interface:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(IMyUser)\n... class MyUser(User):\n...     def __init__(self, login, password, title, description, email):\n...         super(MyUser, self).__init__(login, password, title,\n...                                           description)\n...         self.email = email\n</pre>\n</blockquote>\n<p>Now we have to define the AuthenticatedPrincipal for MyUser:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(IMyAuthenticatedPrincipal)\n... class MyAuthenticatedPrincipal(AuthenticatedPrincipal):\n...     def __init__(self, principal):\n...         super(MyAuthenticatedPrincipal, self).__init__(principal)\n...         self.email = principal.email\n</pre>\n</blockquote>\n<p>And we have to define the FoundPrincipal for MyUser:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(IMyFoundPrincipal)\n... class MyFoundPrincipal(FoundPrincipal):\n...     def __init__(self, principal):\n...         super(MyFoundPrincipal, self).__init__(principal)\n...         self.email = principal.email\n</pre>\n</blockquote>\n<p>Note that you can provide different attributes for the found and authenticated\nprincipals if needed. That\u2019s up to you what you like to do with these attributes\nlater.</p>\n<p>Now we need to register our custom authenticated and found principal\nadapters:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(MyAuthenticatedPrincipal,\n...     provides=interfaces.IAuthenticatedPrincipal)\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(MyFoundPrincipal,\n...     provides=interfaces.IFoundPrincipal)\n</pre>\n</blockquote>\n<p>Now we can use them without any other event subscribers or other registration\nin our principal container. Let\u2019s add a principal to this container:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; p = MyUser(u'max', u'password', u'Max', u'', u'max@foobar.com')\n&gt;&gt;&gt; token, max = authPlugin.add(p)\n&gt;&gt;&gt; len(token)\n32\n</pre>\n<pre>&gt;&gt;&gt; max.__name__ == token\nTrue\n</pre>\n<pre>&gt;&gt;&gt; max.password.decode('utf-8')\nu'password'\n</pre>\n<pre>&gt;&gt;&gt; max.title\nu'Max'\n</pre>\n<pre>&gt;&gt;&gt; max.email\nu'max@foobar.com'\n</pre>\n</blockquote>\n<p>Let\u2019s try to authenticate\u2026</p>\n<blockquote>\n<pre>&gt;&gt;&gt; request = TestRequest(form={'login': 'max', 'password': 'password'})\n&gt;&gt;&gt; authenticated = auth.authenticate(request)\n</pre>\n</blockquote>\n<p>and check your authenticated principal:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interfaces.IAuthenticatedPrincipal.providedBy(authenticated)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; authenticated\n&lt;MyAuthenticatedPrincipal ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; authenticated.id == token\nTrue\n</pre>\n<pre>&gt;&gt;&gt; authenticated.email\nu'max@foobar.com'\n</pre>\n</blockquote>\n<p>Check getUserByLogin:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; max = authPlugin.getUserByLogin('max')\n&gt;&gt;&gt; max.__class__.__name__\n'MyUser'\n</pre>\n<pre>&gt;&gt;&gt; authPlugin.getUserByLogin('max').login\nu'max'\n</pre>\n<pre>&gt;&gt;&gt; authPlugin.getUserByLogin('max').__name__ == token\nTrue\n</pre>\n</blockquote>\n<p>A handy feature for migration is that you can set your own <tt>token</tt>.\nUsually in z.a.authentication the <tt>token</tt> == login and we want to keep it\nthat way, unless you want to iterate through all permissions and whatever.\nNote, the __name__ and the id in the container must be the <em>SAME</em> object.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; login = u'migrateduser'\n&gt;&gt;&gt; p = User(login, u'password', u'John')\n</pre>\n</blockquote>\n<p>Preset the <tt>token</tt></p>\n<blockquote>\n<pre>&gt;&gt;&gt; p.__name__ = login\n</pre>\n</blockquote>\n<p>Watch out, we use __setitem__ instead of add(), because add() would kill off\nthe preset <tt>token</tt> in __name__.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; authPlugin[login] = p\n</pre>\n</blockquote>\n<p>Here we are, the user is set with the non-generated token.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; u'migrateduser' in authPlugin.keys()\nTrue\n</pre>\n<pre>&gt;&gt;&gt; authPlugin['migrateduser']\n&lt;z3c.authenticator.user.User object at ...&gt;\n</pre>\n<pre>&gt;&gt;&gt; authPlugin.getUserByLogin('migrateduser')\n&lt;z3c.authenticator.user.User object at ...&gt;\n</pre>\n</blockquote>\n</div>\n<div id=\"edge-cases\">\n<h3><a href=\"#id28\" rel=\"nofollow\">Edge cases</a></h3>\n<p>We can have Users with unicode logins, as we allow this with TextLine in IUser.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; try:\n...     unichr = unichr\n... except NameError:\n...     unichr = chr # PY3\n&gt;&gt;&gt; p = User(u'bob'+unichr(233), 'password', 'title')\n</pre>\n</blockquote>\n<p>Adding it should not fail:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; uid, user = authPlugin.add(p)\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"group\">\n<h2><a href=\"#id29\" rel=\"nofollow\">Group</a></h2>\n<p>Group container provide support for groups information stored in the ZODB.\nThey are persistent, and must be contained within the IAuthentication that\nuse them.</p>\n<div id=\"id1\">\n<h3><a href=\"#id30\" rel=\"nofollow\">Group</a></h3>\n<p>Like other users, groups are created when they are needed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator import interfaces\n&gt;&gt;&gt; from z3c.authenticator.group import Group\n&gt;&gt;&gt; group1 = Group(u'groups')\n&gt;&gt;&gt; group1\n&lt;Group None&gt;\n</pre>\n<pre>&gt;&gt;&gt; interfaces.IGroup.providedBy(group1)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; group1.title\nu'groups'\n</pre>\n<pre>&gt;&gt;&gt; group1.description\nu''\n</pre>\n<pre>&gt;&gt;&gt; group1.principals\n()\n</pre>\n</blockquote>\n</div>\n<div id=\"groupcontainer\">\n<h3><a href=\"#id31\" rel=\"nofollow\">GroupContainer</a></h3>\n<p>Group containers contain IGroup objects. A IAuthentication will adapt\nIFoundGroup to this IGroup objects.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator.group import GroupContainer\n&gt;&gt;&gt; groups = GroupContainer('groups.')\n</pre>\n<pre>&gt;&gt;&gt; interfaces.IGroupContainer.providedBy(groups)\nTrue\n</pre>\n</blockquote>\n<p>We can add your previous created group to the group container using the\naddGroup method which returns the group id and group:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; gid, g1 = groups.addGroup(u'g1', group1)\n&gt;&gt;&gt; gid\nu'groups.g1'\n</pre>\n<pre>&gt;&gt;&gt; interfaces.IGroup.providedBy(g1)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; g1.__name__\nu'groups.g1'\n</pre>\n</blockquote>\n<p>Note that when group is added, a GroupAdded event is generated:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.component.eventtesting import getEvents\n&gt;&gt;&gt; getEvents(interfaces.IGroupAdded)\n[&lt;GroupAdded u'groups.g1'&gt;]\n</pre>\n</blockquote>\n<p>Groups are defined with respect to an authentication service. Groups must be\naccessible via an authentication service and can contain principals accessible\nvia an authentication service. To illustrate the group interaction with the\nauthentication service, we will setup a Authenticator utility:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator.authentication import Authenticator\n&gt;&gt;&gt; authenticator = Authenticator()\n</pre>\n</blockquote>\n<p>Give them a location and register them as a IAuthentication utility :</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from zope.authentication.interfaces import IAuthentication\n&gt;&gt;&gt; rootFolder['authenticator'] = authenticator\n&gt;&gt;&gt; zope.component.provideUtility(authenticator, IAuthentication)\n</pre>\n</blockquote>\n<p>We will create and register a new principals utility:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.provideUtility(authenticator, IAuthentication)\n</pre>\n</blockquote>\n<p>We also need to register the group athentication plugin:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.component.provideUtility(groups,\n...     provides=interfaces.IAuthenticatorPlugin,\n...     name='My Group Plugin')\n</pre>\n</blockquote>\n<p>After setup the group and group container, we will create a simple credentials\nplugin and add them to the authentication utility:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; from z3c.authenticator import interfaces\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(interfaces.ICredentialsPlugin)\n... class MyCredentialsPlugin(object):\n...\n...     def extractCredentials(self, request):\n...         return {'login':request.get('login', ''),\n...                 'password':request.get('password', '')}\n...\n...     def challenge(self, request):\n...         pass # challenge is a no-op for this plugin\n...\n...     def logout(self, request):\n...         pass # logout is a no-op for this plugin\n</pre>\n</blockquote>\n<p>and configure and add the credential plugin to the Authenticator:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; myCredentialsPlugin = MyCredentialsPlugin()\n&gt;&gt;&gt; authenticator['credentials'] = myCredentialsPlugin\n&gt;&gt;&gt; authenticator.credentialsPlugins = ('credentials', )\n</pre>\n</blockquote>\n<p>We also need a principal and a IAuthenticationPlugin:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator.user import User\n&gt;&gt;&gt; p1 = User(u'p1', u'password', u'Principal 1')\n&gt;&gt;&gt; p2 = User(u'p2', u'password', u'Principal 2')\n&gt;&gt;&gt; p3 = User(u'p3', u'password', u'Principal 3')\n&gt;&gt;&gt; p4 = User(u'p4', u'password', u'Principal 4')\n</pre>\n<pre>&gt;&gt;&gt; from z3c.authenticator.user import UserContainer\n&gt;&gt;&gt; users = UserContainer()\n&gt;&gt;&gt; token1, p1 = users.add(p1)\n&gt;&gt;&gt; token2, p2 = users.add(p2)\n&gt;&gt;&gt; token3, p3 = users.add(p3)\n&gt;&gt;&gt; token4, p4 = users.add(p4)\n</pre>\n</blockquote>\n<p>Add the GroupContainer and UserContainer to the Authenticator and\nset the correct plugin names</p>\n<blockquote>\n<pre>&gt;&gt;&gt; authenticator['users'] = users\n&gt;&gt;&gt; authenticator['groups'] = groups\n&gt;&gt;&gt; authenticator.authenticatorPlugins = ('users', 'groups')\n</pre>\n</blockquote>\n</div>\n<div id=\"adding-users-to-groups\">\n<h3><a href=\"#id32\" rel=\"nofollow\">Adding users to groups</a></h3>\n<p>Now we can set the users on the group but first we need to register the\nIFoundPrincipal adapter for groups. The FoundGroup adapter provides this\ninterface:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator.principal import FoundGroup\n&gt;&gt;&gt; zope.component.provideAdapter(FoundGroup,\n...     provides=interfaces.IFoundPrincipal)\n</pre>\n</blockquote>\n<p>And we also need to provide the IFoundPrincipal and IAuthenticatedPrincipal\nadapter for IPrincipal objects:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator.principal import AuthenticatedPrincipal\n&gt;&gt;&gt; from z3c.authenticator.principal import FoundPrincipal\n&gt;&gt;&gt; zope.component.provideAdapter(AuthenticatedPrincipal,\n...     provides=interfaces.IAuthenticatedPrincipal)\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(FoundPrincipal,\n...     provides=interfaces.IFoundPrincipal)\n</pre>\n</blockquote>\n<p>And we need the <tt>setGroupsForPrincipal</tt> subscriber:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator.group import setGroupsForPrincipal\n&gt;&gt;&gt; zope.component.provideHandler(setGroupsForPrincipal,\n...     [interfaces.IPrincipalCreated])\n</pre>\n<pre>&gt;&gt;&gt; g1.principals = [p1.__name__, p2.__name__]\n&gt;&gt;&gt; g1.principals\n(..., ...)\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[0] == p1.__name__\nTrue\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[1] == p2.__name__\nTrue\n</pre>\n</blockquote>\n<p>Adding users fires an event.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n&lt;PrincipalsAddedToGroup [..., ...] u'groups.g1'&gt;\n</pre>\n</blockquote>\n<p>We can now look up groups for the users:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; groups.getGroupsForPrincipal(p1.__name__)\n(u'groups.g1',)\n</pre>\n</blockquote>\n<p>Note that the group id is a concatenation of the group-folder prefix\nand the name of the group object within the folder.</p>\n<p>If we delete a group:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; del groups['groups.g1']\n</pre>\n</blockquote>\n<p>then the groups folder loses the group information for that group\u2019s users:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; groups.getGroupsForPrincipal('p1')\n()\n</pre>\n</blockquote>\n<p>but the principal information on the group is unchanged:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; g1.principals\n(..., ...)\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[0] == p1.__name__\nTrue\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[1] == p2.__name__\nTrue\n</pre>\n</blockquote>\n<p>It also fires an event showing that the users are removed from the groups.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; getEvents(interfaces.IPrincipalsRemovedFromGroup)[-1]\n&lt;PrincipalsRemovedFromGroup [..., ...] 'groups.g1'&gt;\n</pre>\n</blockquote>\n<p>Adding the group again within a different name will make the groups\navailable for the principal. Let\u2019s use a different group name:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; groups['groups.G1'] = g1\n</pre>\n<pre>&gt;&gt;&gt; groups.getGroupsForPrincipal(p1.__name__)\n(u'groups.G1',)\n</pre>\n</blockquote>\n<p>Here we see that the new name is reflected in the group information.</p>\n<p>An event is fired, as usual.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n&lt;PrincipalsAddedToGroup [..., ...] u'groups.G1'&gt;\n</pre>\n</blockquote>\n<p>In terms of member events (members added and removed from groups), we have\nnow seen that events are fired when a group object is added and when it is\nremoved from a group container; and we have seen that events are fired\nwhen a principal is added to an already-registered groups.  Events are also\nfired when a principal is removed from an already-registered groups.  Let\u2019s\nquickly see some more examples.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; g1.principals = (p1.__name__, p3.__name__, p4.__name__)\n&gt;&gt;&gt; g1.principals\n(..., ..., ...)\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[0] == p1.__name__\nTrue\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[1] == p3.__name__\nTrue\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[2] == p4.__name__\nTrue\n</pre>\n<pre>&gt;&gt;&gt; getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n&lt;PrincipalsAddedToGroup [..., ...] u'groups.G1'&gt;\n</pre>\n<pre>&gt;&gt;&gt; getEvents(interfaces.IPrincipalsRemovedFromGroup)[-1]\n&lt;PrincipalsRemovedFromGroup [...] u'groups.G1'&gt;\n</pre>\n<pre>&gt;&gt;&gt; g1.principals = (p1.__name__, p2.__name__)\n&gt;&gt;&gt; g1.principals\n(..., ...)\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[0] == p1.__name__\nTrue\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[1] == p2.__name__\nTrue\n</pre>\n<pre>&gt;&gt;&gt; getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n&lt;PrincipalsAddedToGroup [...] u'groups.G1'&gt;\n</pre>\n<pre>&gt;&gt;&gt; getEvents(interfaces.IPrincipalsRemovedFromGroup)[-1]\n&lt;PrincipalsRemovedFromGroup [..., ...] u'groups.G1'&gt;\n</pre>\n<pre>&gt;&gt;&gt; groups.getGroupsForPrincipal(p2.__name__)\n(u'groups.G1',)\n</pre>\n</blockquote>\n</div>\n<div id=\"groups-in-groups\">\n<h3><a href=\"#id33\" rel=\"nofollow\">Groups in groups</a></h3>\n<p>Groups can contain groups:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; g2 = Group('Group Two')\n&gt;&gt;&gt; groups['groups.G2'] = g2\n&gt;&gt;&gt; g2.principals\n()\n</pre>\n<pre>&gt;&gt;&gt; g2.principals = ['groups.G1']\n</pre>\n<pre>&gt;&gt;&gt; g2.principals\n('groups.G1',)\n</pre>\n<pre>&gt;&gt;&gt; groups.getGroupsForPrincipal('groups.G2')\n()\n</pre>\n<pre>&gt;&gt;&gt; g1.principals\n(..., ...)\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[0] == p1.__name__\nTrue\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[1] == p2.__name__\nTrue\n</pre>\n<pre>&gt;&gt;&gt; groups.getGroupsForPrincipal('groups.G1')\n(u'groups.G2',)\n</pre>\n<pre>&gt;&gt;&gt; old = getEvents(interfaces.IPrincipalsAddedToGroup)[-1]\n&gt;&gt;&gt; old\n&lt;PrincipalsAddedToGroup ['groups.G1'] u'groups.G2'&gt;\n</pre>\n</blockquote>\n<p>Groups cannot contain cycles:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; g1.principals\n(..., ...)\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[0] == p1.__name__\nTrue\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[1] == p2.__name__\nTrue\n</pre>\n<pre>&gt;&gt;&gt; g2.principals\n('groups.G1',)\n</pre>\n<pre>&gt;&gt;&gt; g1.principals = (p1.__name__, p2.__name__, 'groups.G2')\nTraceback (most recent call last):\n...\nGroupCycle: (...)\n</pre>\n<pre>&gt;&gt;&gt; g1.principals\n(..., ...)\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[0] == p1.__name__\nTrue\n</pre>\n<pre>&gt;&gt;&gt; g1.principals[1] == p2.__name__\nTrue\n</pre>\n</blockquote>\n<p>Trying to do so does not fire an event.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; getEvents(interfaces.IPrincipalsAddedToGroup)[-1] is old\nTrue\n</pre>\n</blockquote>\n<p>They need not be hierarchical:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ga = Group(\"Group A\")\n&gt;&gt;&gt; groups['groups.GA'] = ga\n</pre>\n<pre>&gt;&gt;&gt; gb = Group(\"Group B\")\n&gt;&gt;&gt; groups['groups.GB'] = gb\n&gt;&gt;&gt; gb.principals = ['groups.GA']\n</pre>\n<pre>&gt;&gt;&gt; gc = Group(\"Group C\")\n&gt;&gt;&gt; groups['groups.GC'] = gc\n&gt;&gt;&gt; gc.principals = ['groups.GA']\n</pre>\n<pre>&gt;&gt;&gt; gd = Group(\"Group D\")\n&gt;&gt;&gt; groups['groups.GD'] = gd\n&gt;&gt;&gt; gd.principals = ['groups.GA', 'groups.GB']\n</pre>\n<pre>&gt;&gt;&gt; ga.principals = [p1.__name__]\n</pre>\n</blockquote>\n<p>Group containers provide a very simple search interface.  They perform\nsimple string searches on group titles and descriptions.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(groups.search({'search': 'grou'}))\n[u'groups.G1', u'groups.G2',\n u'groups.GA', u'groups.GB', u'groups.GC', u'groups.GD']\n</pre>\n<pre>&gt;&gt;&gt; list(groups.search({'search': 'two'}))\n[u'groups.G2']\n</pre>\n</blockquote>\n<p>They also support batching:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(groups.search({'search': 'grou'}, 2, 3))\n[u'groups.GA', u'groups.GB', u'groups.GC']\n</pre>\n</blockquote>\n<p>If you don\u2019t supply a search key, no results will be returned:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; list(groups.search({}))\n[]\n</pre>\n</blockquote>\n</div>\n<div id=\"identifying-groups\">\n<h3><a href=\"#id34\" rel=\"nofollow\">Identifying groups</a></h3>\n<p>The function, <cite>setGroupsForPrincipal</cite>, is a subscriber to\nprincipal-creation events.  It adds any group-folder-defined groups to\nusers in those groups:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; auth1 = authenticator.getPrincipal(p1.__name__)\n</pre>\n<pre>&gt;&gt;&gt; auth1.groups\n[u'groups.G1', u'groups.GA']\n</pre>\n</blockquote>\n<p>Of course, this applies to groups too:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; g1 = authenticator.getPrincipal('groups.G1')\n&gt;&gt;&gt; g1.id\nu'groups.G1'\n</pre>\n<pre>&gt;&gt;&gt; g1.groups\n[u'groups.G2']\n</pre>\n</blockquote>\n<p>A FoundGroup provides IFoundGroup which is inherited from\nIFoundPrincipal and IGroup:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interfaces.IFoundGroup.providedBy(g1)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; interfaces.IFoundPrincipal.providedBy(g1)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; import zope.security.interfaces\n&gt;&gt;&gt; zope.security.interfaces.IGroup.providedBy(g1)\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"specialgroups\">\n<h3><a href=\"#id35\" rel=\"nofollow\">specialGroups</a></h3>\n<p>Two special groups, IAuthenticatedGroup, and IEveryoneGroup may apply to users\ncreated by the IAuthentication utility.  There is a subscriber called\n<tt>specialGroups</tt>. This subscriber can set this special groups on any\nprincipal if IAuthenticatedGroup, or IEveryoneGroup utilities are\nprovided. The subscriber knows also how to apply local groups to principals.\nNote, principals means IAuthenticatedPrincipal, IFoundPrincipal or IFoundGroup.</p>\n<p>If we notify the subscriber with the principal, nothing will happen\nbecause the groups haven\u2019t been defined:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator.principal import FoundPrincipal\n&gt;&gt;&gt; from z3c.authenticator.event import FoundPrincipalCreated\n&gt;&gt;&gt; from z3c.authenticator.group import specialGroups\n&gt;&gt;&gt; x = User('x', 'password', 'X')\n&gt;&gt;&gt; found = FoundPrincipal(x)\n&gt;&gt;&gt; event = FoundPrincipalCreated(authenticator, found)\n&gt;&gt;&gt; specialGroups(event)\n&gt;&gt;&gt; found.groups\n[]\n</pre>\n</blockquote>\n<p>Now, if we define the Everybody group:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.authentication.interfaces\n&gt;&gt;&gt; @zope.interface.implementer(\n...        zope.authentication.interfaces.IEveryoneGroup)\n... class EverybodyGroup(Group):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; all = EverybodyGroup('groups.all')\n&gt;&gt;&gt; groups['groups.all'] = all\n&gt;&gt;&gt; zope.component.provideUtility(all,\n...     zope.authentication.interfaces.IEveryoneGroup)\n</pre>\n</blockquote>\n<p>Then the group will be added to the principal:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; specialGroups(event)\n&gt;&gt;&gt; found.groups\n[u'groups.all']\n</pre>\n</blockquote>\n<p>Similarly for the authenticated group:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(\n...         zope.authentication.interfaces.IAuthenticatedGroup)\n... class AuthenticatedGroup(Group):\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; authenticated = AuthenticatedGroup('groups.authenticated')\n&gt;&gt;&gt; groups['groups.authenticated'] = authenticated\n&gt;&gt;&gt; zope.component.provideUtility(authenticated,\n...     zope.authentication.interfaces.IAuthenticatedGroup)\n</pre>\n</blockquote>\n<p>Then the group will be added to the principal:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; found.groups = []\n&gt;&gt;&gt; specialGroups(event)\n&gt;&gt;&gt; found.groups.sort()\n&gt;&gt;&gt; found.groups\n[u'groups.all', u'groups.authenticated']\n</pre>\n</blockquote>\n<p>It is important that we do not apply a group twice since the\nUnauthenticatedPrincipal is a single instance in the securitypolicy. This issue\nis fixed in version 0.6.1 and 0.7.1</p>\n<blockquote>\n<pre>&gt;&gt;&gt; specialGroups(event)\n&gt;&gt;&gt; found.groups\n[u'groups.all', u'groups.authenticated']\n</pre>\n</blockquote>\n</div>\n<div id=\"allgroups\">\n<h3><a href=\"#id36\" rel=\"nofollow\">allGroups</a></h3>\n<p>The <cite>allGroups</cite> attribute is a readonly iterable of the full closure of the\ngroups in the <cite>groups</cite> attribute. Let\u2019s define a new principal first:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; p = User(u'p', u'password', u'Principal')\n&gt;&gt;&gt; token, p = users.add(p)\n</pre>\n</blockquote>\n<p>And the groups:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ga = Group(\"Administrators\")\n&gt;&gt;&gt; gr = Group(\"Reviewers\")\n&gt;&gt;&gt; gid, ga = groups.addGroup(u'Administrators', ga)\n&gt;&gt;&gt; gid, gr = groups.addGroup(u'Reviewers', gr)\n</pre>\n</blockquote>\n<p>If the principal is a direct member of the \u2018Administrators\u2019 group,</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ga.principals = [p.__name__]\n</pre>\n</blockquote>\n<p>then getGroupsForPrincipal would be [\u2018Administrators\u2019]</p>\n<blockquote>\n<pre>&gt;&gt;&gt; groups.getGroupsForPrincipal(p.__name__)\n(u'groups.Administrators',)\n</pre>\n</blockquote>\n<p>and if the \u2018Administrators\u2019 group is a member of the \u2018Reviewers\u2019 group,</p>\n<blockquote>\n<pre>&gt;&gt;&gt; gr.principals = [ga.id]\n</pre>\n</blockquote>\n<p>then groups would be [\u2018Administrators\u2019] too.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; groups.getGroupsForPrincipal(p.__name__)\n(u'groups.Administrators',)\n</pre>\n</blockquote>\n<p>now let\u2019s use the setGroupsForPrincipal subscriber which knows how to apply\nthe groups to the found principal:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; pFound = FoundPrincipal(p)\n&gt;&gt;&gt; event = FoundPrincipalCreated(authenticator, pFound)\n&gt;&gt;&gt; setGroupsForPrincipal(event)\n</pre>\n</blockquote>\n<p>As you can see and pFound.groups is [\u2018Administrators\u2019].</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(pFound.groups)\n[u'groups.Administrators']\n</pre>\n</blockquote>\n<p>And pFound.allGroups is [\u2018Administrators\u2019, \u2018Reviewers\u2019].</p>\n<blockquote>\n<pre>&gt;&gt;&gt; sorted(pFound.allGroups)\n[u'groups.Administrators', u'groups.Reviewers']\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"vocabulary\">\n<h2><a href=\"#id37\" rel=\"nofollow\">Vocabulary</a></h2>\n<p>The vocabulary module provides vocabularies for the authenticator plugins and\nthe credentials plugins.</p>\n<p>The options should include the unique names of all of the plugins that provide\nthe appropriate interface (IAuthentiatorPlugin or ICredentialsPlugin,\nrespectively) for the current context which is expected to be a IAuthenticator\nutility, hereafter referred to as a Authenticator.</p>\n<p>These names may be for objects contained within the Authenticator\n(\u201ccontained plugins\u201d), or may be utilities registered for the specified\ninterface, found in the context of the Authenticator\n(\u201cutility plugins\u201d). Contained plugins mask utility plugins of the same name.\nThey also may be names currently selected in the Authenticator that do\nnot actually have a corresponding plugin at this time.</p>\n<p>Here is a short example of how the vocabulary should work.  Let\u2019s say we\u2019re\nworking with authentication plugins.  We\u2019ll create some faux\nauthentication plugins, and register some of them as utilities and put\nothers in a faux Authenticator.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator import interfaces\n&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; @zope.interface.implementer(interfaces.IAuthenticatorPlugin)\n... class DemoPlugin(object):\n...     def __init__(self, name):\n...         self.name = name\n...\n&gt;&gt;&gt; utility_plugins = dict(\n...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(4))\n&gt;&gt;&gt; contained_plugins = dict(\n...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(1, 5))\n&gt;&gt;&gt; sorted(utility_plugins.keys())\n[0, 1, 2, 3]\n&gt;&gt;&gt; for p in utility_plugins.values():\n...     zope.component.provideUtility(p, name=p.name)\n...\n&gt;&gt;&gt; sorted(contained_plugins.keys()) # 1 will mask utility plugin 1\n[1, 2, 3, 4]\n&gt;&gt;&gt; @zope.interface.implementer(interfaces.IAuthenticator)\n... class DemoAuth(dict):\n...     def __init__(self, *args, **kwargs):\n...         super(DemoAuth, self).__init__(*args, **kwargs)\n...         self.authenticatorPlugins = (u'Plugin 3', u'Plugin X')\n...         self.credentialsPlugins = (u'Plugin 4', u'Plugin X')\n...\n&gt;&gt;&gt; auth = DemoAuth((p.name, p) for p in contained_plugins.values())\n</pre>\n<pre>&gt;&gt;&gt; @zope.component.adapter(zope.interface.Interface)\n... @zope.interface.implementer(zope.component.IComponentLookup)\n... def getSiteManager(context):\n...     return zope.component.getGlobalSiteManager()\n...\n&gt;&gt;&gt; zope.component.provideAdapter(getSiteManager)\n</pre>\n</blockquote>\n<div id=\"authenticatorplugins\">\n<h3><a href=\"#id38\" rel=\"nofollow\">authenticatorPlugins</a></h3>\n<p>We are now ready to create a vocabulary that we can use.  The context is\nour faux authentication utility, <cite>auth</cite>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c.authenticator import vocabulary\n&gt;&gt;&gt; vocab = vocabulary.authenticatorPlugins(auth)\n</pre>\n</blockquote>\n<p>Iterating over the vocabulary results in all of the terms, in a relatively\narbitrary order of their names.  (This vocabulary should typically use a\nwidget that sorts values on the basis of localized collation order of the\nterm titles.)</p>\n<blockquote>\n<pre>&gt;&gt;&gt; [term.value for term in vocab] # doctest: +NORMALIZE_WHITESPACE\n[u'Plugin 0', u'Plugin 1', u'Plugin 2', u'Plugin 3', u'Plugin 4',\n u'Plugin X']\n</pre>\n</blockquote>\n<p>Similarly, we can use <cite>in</cite> to test for the presence of values in the\nvocabulary.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ['Plugin %s' % i in vocab for i in range(-1, 6)]\n[False, True, True, True, True, True, False]\n&gt;&gt;&gt; 'Plugin X' in vocab\nTrue\n</pre>\n</blockquote>\n<p>The length reports the expected value.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; len(vocab)\n6\n</pre>\n</blockquote>\n<p>One can get a term for a given value using <cite>getTerm()</cite>; its token, in\nturn, should also return the same effective term from <cite>getTermByToken</cite>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; values = ['Plugin 0', 'Plugin 1', 'Plugin 2', 'Plugin 3', 'Plugin 4',\n...           'Plugin X']\n&gt;&gt;&gt; for val in values:\n...     term = vocab.getTerm(val)\n...     assert term.value == val\n...     term2 = vocab.getTermByToken(term.token)\n...     assert term2.token == term.token\n...     assert term2.value == val\n...\n</pre>\n</blockquote>\n<p>The terms have titles, which are message ids that show the plugin title or id\nand whether the plugin is a utility or just contained in the auth utility.\nWe\u2019ll give one of the plugins a dublin core title just to show the\nfunctionality.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.dublincore.interfaces\n&gt;&gt;&gt; class ISpecial(zope.interface.Interface):\n...     pass\n...\n&gt;&gt;&gt; zope.interface.directlyProvides(contained_plugins[1], ISpecial)\n&gt;&gt;&gt; @zope.interface.implementer(\n...         zope.dublincore.interfaces.IDCDescriptiveProperties)\n... class DemoDCAdapter(object):\n...     zope.component.adapts(ISpecial)\n...     def __init__(self, context):\n...         pass\n...     title = u'Special Title'\n...\n&gt;&gt;&gt; zope.component.provideAdapter(DemoDCAdapter)\n</pre>\n</blockquote>\n<p>We need to regenerate the vocabulary, since it calculates all of its data at\nonce.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; vocab = vocabulary.authenticatorPlugins(auth)\n</pre>\n</blockquote>\n<p>Now we\u2019ll check the titles.  We\u2019ll have to translate them to see what we\nexpect.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope import i18n\n&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; pprint.pprint([i18n.translate(term.title) for term in vocab])\n[u'Plugin 0 (a utility)',\n u'Special Title (in contents)',\n u'Plugin 2 (in contents)',\n u'Plugin 3 (in contents)',\n u'Plugin 4 (in contents)',\n u'Plugin X (not found; deselecting will remove)']\n</pre>\n</blockquote>\n</div>\n<div id=\"credentialsplugins\">\n<h3><a href=\"#id39\" rel=\"nofollow\">credentialsPlugins</a></h3>\n<p>For completeness, we\u2019ll do the same review of the credentialsPlugins.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(interfaces.ICredentialsPlugin)\n... class DemoPlugin(object):\n...     def __init__(self, name):\n...         self.name = name\n...\n&gt;&gt;&gt; utility_plugins = dict(\n...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(4))\n&gt;&gt;&gt; contained_plugins = dict(\n...     (i, DemoPlugin(u'Plugin %d' % i)) for i in range(1, 5))\n&gt;&gt;&gt; for p in utility_plugins.values():\n...     zope.component.provideUtility(p, name=p.name)\n...\n&gt;&gt;&gt; auth = DemoAuth((p.name, p) for p in contained_plugins.values())\n&gt;&gt;&gt; vocab = vocabulary.credentialsPlugins(auth)\n</pre>\n</blockquote>\n<p>Iterating over the vocabulary results in all of the terms, in a relatively\narbitrary order of their names.  (This vocabulary should typically use a\nwidget that sorts values on the basis of localized collation order of the term\ntitles.) Similarly, we can use <cite>in</cite> to test for the presence of values in the\nvocabulary. The length reports the expected value.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; [term.value for term in vocab] # doctest: +NORMALIZE_WHITESPACE\n[u'Plugin 0', u'Plugin 1', u'Plugin 2', u'Plugin 3', u'Plugin 4',\n u'Plugin X']\n&gt;&gt;&gt; ['Plugin %s' % i in vocab for i in range(-1, 6)]\n[False, True, True, True, True, True, False]\n&gt;&gt;&gt; 'Plugin X' in vocab\nTrue\n&gt;&gt;&gt; len(vocab)\n6\n</pre>\n</blockquote>\n<p>One can get a term for a given value using <cite>getTerm()</cite>; its token, in\nturn, should also return the same effective term from <cite>getTermByToken</cite>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; values = ['Plugin 0', 'Plugin 1', 'Plugin 2', 'Plugin 3', 'Plugin 4',\n...           'Plugin X']\n&gt;&gt;&gt; for val in values:\n...     term = vocab.getTerm(val)\n...     assert term.value == val\n...     term2 = vocab.getTermByToken(term.token)\n...     assert term2.token == term.token\n...     assert term2.value == val\n...\n</pre>\n</blockquote>\n<p>The terms have titles, which are message ids that show the plugin title or id\nand whether the plugin is a utility or just contained in the auth utility.\nWe\u2019ll give one of the plugins a dublin core title just to show the\nfunctionality. We need to regenerate the vocabulary, since it calculates all\nof its data at once. Then we\u2019ll check the titles.  We\u2019ll have to translate\nthem to see what we expect.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.interface.directlyProvides(contained_plugins[1], ISpecial)\n&gt;&gt;&gt; vocab = vocabulary.credentialsPlugins(auth)\n&gt;&gt;&gt; pprint.pprint([i18n.translate(term.title) for term in vocab])\n[u'Plugin 0 (a utility)',\n u'Special Title (in contents)',\n u'Plugin 2 (in contents)',\n u'Plugin 3 (in contents)',\n u'Plugin 4 (in contents)',\n u'Plugin X (not found; deselecting will remove)']\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"changes\">\n<h2><a href=\"#id40\" rel=\"nofollow\">CHANGES</a></h2>\n<div id=\"id2\">\n<h3><a href=\"#id41\" rel=\"nofollow\">1.0.1 (2018-05-16)</a></h3>\n<ul>\n<li>bugfix: remove None from queryNextUtiliy because getNextUtility signature got\nchanged and None was used as name argument.</li>\n<li>cleanup, removed unused imports</li>\n<li>Get rid of deprecation warning. Switch hooks import from zope.site to\nzope.component</li>\n<li>skip test_exception_in_subscriber_leaves_item_in_place for IAuthenticator\ncontainer. This zope.container test method left over an event subscriber with\nzope.container version 4.2.1 which raises an error in other methods. Needs\nreview and probably a tear down in zope.container test method.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3><a href=\"#id42\" rel=\"nofollow\">1.0.0 (2017-04-17)</a></h3>\n<ul>\n<li>Ping Python support to 2.7, 3.5, 3.6 and PyPy.</li>\n</ul>\n</div>\n<div id=\"a5-2013-03-31\">\n<h3><a href=\"#id43\" rel=\"nofollow\">1.0.0a5 (2013-03-31)</a></h3>\n<ul>\n<li>More Py3 compatibility bugs in untested code.</li>\n</ul>\n</div>\n<div id=\"a4-2013-02-28\">\n<h3><a href=\"#id44\" rel=\"nofollow\">1.0.0a4 (2013-02-28)</a></h3>\n<ul>\n<li>Removed support for Zope generations. It was not used and application-wide\ngenerations make more sense anyways. This removed the\n<tt>zope.app.generations</tt> and <tt>zope.generations</tt> dependencies.</li>\n<li>Made <tt>z3c.configurator</tt> support optional.</li>\n<li>Cleaned up source code a little bit.</li>\n</ul>\n</div>\n<div id=\"a3-2013-02-28\">\n<h3><a href=\"#id45\" rel=\"nofollow\">1.0.0a3 (2013-02-28)</a></h3>\n<ul>\n<li>Changed manifest to actually include the page templates.</li>\n</ul>\n</div>\n<div id=\"a2-2013-02-28\">\n<h3><a href=\"#id46\" rel=\"nofollow\">1.0.0a2 (2013-02-28)</a></h3>\n<ul>\n<li>Added version Trove classifiers.</li>\n</ul>\n</div>\n<div id=\"a1-2013-02-28\">\n<h3><a href=\"#id47\" rel=\"nofollow\">1.0.0a1 (2013-02-28)</a></h3>\n<ul>\n<li>Dropped support for Python 2.4 and 2.5, added Python 3.3 support.</li>\n<li>Removed dependencies on <tt>zope.app</tt> packages.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3><a href=\"#id48\" rel=\"nofollow\">0.8.1 (2011-01-21)</a></h3>\n<ul>\n<li>Bugfix: Did not handle unicode IUser.login values.</li>\n<li>Fixed DeprecationWarnings.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3><a href=\"#id49\" rel=\"nofollow\">0.8.0 (2010-01-25)</a></h3>\n<ul>\n<li><p>Security Fix: move camefrom url to a session variable instead of exposing\nthe url in the login form. Because the camefrom url is built at server side\nbased on local information and will always only use internal traversal names.\nExposing this camefrom query in the login url gives others only a point to\nattack because it could be simply set by a unfriendly domain with a custom\nurl. This is much better since such a unfriendly 3rd party domain url doesn\u2019t\nget redirected by default based on the changes in zope.publisher\u2019s redirect\nmethod. (zope.publisher 3.9.3 does only redirect to urls located in the same\ndomain by default)</p>\n<p>Remove all camefrom widgets and queries in our custom forms if you use any.\nYou can just set and get the camefrom session variable in your custom forms\nif you need to.</p>\n</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3><a href=\"#id50\" rel=\"nofollow\">0.7.2 (2010-01-26)</a></h3>\n<ul>\n<li>Bugfix: Failed miserably on challenge on pages having non-ASCII names.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3><a href=\"#id51\" rel=\"nofollow\">0.7.1 (2009-08-19)</a></h3>\n<ul>\n<li>Bugfix: the method specialGroups applied groups everytime the method get\ncalled even if the group was already applied. This is a problem if the\nglobal shared unauthenticated principal instance is used because it will\napply similar groups till the server get restarted and a new principal\ninstance is used.</li>\n<li>Feature: added getUserByLogin to IUserContainer</li>\n<li>Added a test for user migration (that they will keep their ID)</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3><a href=\"#id52\" rel=\"nofollow\">0.7.0 (2009-05-11)</a></h3>\n<ul>\n<li><p>Update dependencies:</p>\n<blockquote>\n<ul>\n<li>Use <tt>zope.container</tt> instead of <tt>zope.app.container</tt>.</li>\n<li>Use <tt>zope.site</tt> instead of <tt>zope.app.component</tt>.</li>\n<li>Use <tt>zope.authentication</tt> and <tt>zope.principalregistry</tt> instead\nof <tt>zope.app.security</tt>.</li>\n<li>Use <tt>zope.password</tt> instead of maintaining a copy of password\nmanagers.</li>\n</ul>\n</blockquote>\n</li>\n<li><p>Drop dependency on z3c.i18n and recreate a message factory instead.</p>\n</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3><a href=\"#id53\" rel=\"nofollow\">0.6.2 (2010-01-26)</a></h3>\n<ul>\n<li>Bugfix: Failed miserably on challenge on pages having non-ASCII names.\n(Backport from 0.7.2)</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3><a href=\"#id54\" rel=\"nofollow\">0.6.1 (2009-08-19)</a></h3>\n<ul>\n<li><p>Backport bugfix 0.7.1 to 0.6.1. See branches/roger-0.6.0</p>\n<p>the method specialGroups applied groups everytime the method get\ncalled even if the group was already applied. This is a problem if the\nglobal shared unauthenticated principal instance is used because it will\napply similar groups till the server get restarted and a new principal\ninstance is used.</p>\n</li>\n</ul>\n</div>\n<div id=\"id11\">\n<h3><a href=\"#id55\" rel=\"nofollow\">0.6.0 (2009-01-04)</a></h3>\n<ul>\n<li>Feature: added support for local IUnauthenticatedPrincipal. This is usefull\nif you need to apply local roles to IUnauthenticatedPrincipal. This was not\npossible before and is not possible in zope.app.authentication</li>\n<li>Feature: implemented initial grant view based on ISource widget. Note, this\nsource widget terms implementation which is very complex to understand will\nget moved to z3c.from if we fixed the ITerm dependency. Which means ITerm\nneeds to get moved out of zope.app.form first.</li>\n<li>Feature: added support for next utility lookup in authenticate call. By\ndefault the principals from the global principalregistry get involved now.\nYou can disable this feature by setting includeNextUtilityForAuthenticate to\nFalse.</li>\n<li>Feature: added PrincipalRegistryAuthenticatorPlugin which allows to\nauthenticate principals defined in global principal registry.</li>\n<li>Feature: implemented z3c.form prefix support in SessionCredentialsPlugin. Now\nthere is an option called prefixes which can be used for define a list of\nused z3c.form prefixes. This makes it simpler for supporting different forms\nand adjust the credential extraction.</li>\n<li>Renamed IGroupPrincipal to IFoundGroup which makes it more understandable\nwhy this adapter implementation is needed. The IFoundGroup adapter is now\nalso used for zope.security.interfaces.IGroup principals. This makes it\npossible to use them in the new principalregistry credential. Provide\ndeprecation message for the old IGroupPrincipal implementation.</li>\n<li>Removed dependency for zapi. But it\u2019s not really gone since other packages\nuse zapi too.</li>\n<li>Removed unused InvalidPrincipalIds and InvalidGroupId exceptions</li>\n<li>Removed unused IMemberAwareGroup support. This interface is not used in zope\nat all.</li>\n<li>Added documentation for Pypi home page.</li>\n</ul>\n</div>\n<div id=\"id12\">\n<h3><a href=\"#id56\" rel=\"nofollow\">0.5.1 (2008-04-16)</a></h3>\n<ul>\n<li>Cleanup imports and adjust dependencies</li>\n</ul>\n</div>\n<div id=\"id13\">\n<h3><a href=\"#id57\" rel=\"nofollow\">0.5.0 (2008-04-16)</a></h3>\n<ul>\n<li>Initial Release</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 3868740, "releases": {"0.5.0": [{"comment_text": "", "digests": {"md5": "de02488c046206c27c94619c91d6be10", "sha256": "2adaa2e09aa530b685e70bd7d1b0d9a9b22598a09d779dbd3fcd190ef6640816"}, "downloads": -1, "filename": "z3c.authenticator-0.5.0.zip", "has_sig": false, "md5_digest": "de02488c046206c27c94619c91d6be10", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 59857, "upload_time": "2008-04-16T02:50:24", "upload_time_iso_8601": "2008-04-16T02:50:24Z", "url": "https://files.pythonhosted.org/packages/59/2b/6f6a8cce57f0cd25eddd97e66273dcaca5049b289f3d6a502738fbd634c0/z3c.authenticator-0.5.0.zip", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "99563e6daba0491796e42ab948d18732", "sha256": "297bca3c70834fe93b3b67c4c9a23aa32d470ebc87ebd9af25e4fc4ec5d6a6b7"}, "downloads": -1, "filename": "z3c.authenticator-0.5.1.zip", "has_sig": false, "md5_digest": "99563e6daba0491796e42ab948d18732", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 59776, "upload_time": "2008-04-16T04:22:27", "upload_time_iso_8601": "2008-04-16T04:22:27Z", "url": "https://files.pythonhosted.org/packages/f7/88/696333b025155bd9ce2aaf6820d1fb3754f4a5fd3c549c9e135919607562/z3c.authenticator-0.5.1.zip", "yanked": false}], "0.6.0": [{"comment_text": "", "digests": {"md5": "db468dc80ac5e10ee60eb10a68388619", "sha256": "c4b0520f444e96f1c7dc6781ceee285b1e95d3e84e0186f085112e9f53ec1a98"}, "downloads": -1, "filename": "z3c.authenticator-0.6.0.tar.gz", "has_sig": false, "md5_digest": "db468dc80ac5e10ee60eb10a68388619", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 58593, "upload_time": "2009-01-04T21:09:19", "upload_time_iso_8601": "2009-01-04T21:09:19Z", "url": "https://files.pythonhosted.org/packages/b5/ee/f1418363e3170b51bfccc0ecebdd906e1e0f1ba02a5e880ad3d694e55a97/z3c.authenticator-0.6.0.tar.gz", "yanked": false}], "0.6.1": [{"comment_text": "", "digests": {"md5": "c8139cda1b13c7bf4d32770f33b1b571", "sha256": "219ffd18fe75388c4ce030c9053a46951658d672f59ad16e78016aecbf5843e5"}, "downloads": -1, "filename": "z3c.authenticator-0.6.1.zip", "has_sig": false, "md5_digest": "c8139cda1b13c7bf4d32770f33b1b571", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 85664, "upload_time": "2009-08-19T01:17:02", "upload_time_iso_8601": "2009-08-19T01:17:02.310417Z", "url": "https://files.pythonhosted.org/packages/ce/fc/94ec686fa102b917dd720b8b09b356ab2d1729d2395dfb015360051d5dee/z3c.authenticator-0.6.1.zip", "yanked": false}], "0.6.2": [{"comment_text": "", "digests": {"md5": "196c5d475e826d20229efadbded26b42", "sha256": "db192e3df0c9bd899c4dccc9ef814c86750aca0acf42760b9a5fb437c1c7eb43"}, "downloads": -1, "filename": "z3c.authenticator-0.6.2.tar.gz", "has_sig": false, "md5_digest": "196c5d475e826d20229efadbded26b42", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 61313, "upload_time": "2010-01-26T17:51:35", "upload_time_iso_8601": "2010-01-26T17:51:35.971058Z", "url": "https://files.pythonhosted.org/packages/79/a7/daa86f89b6feacde4f95dec2f4686d80cb148a40410b09a248df268ce971/z3c.authenticator-0.6.2.tar.gz", "yanked": false}], "0.6.3": [{"comment_text": "", "digests": {"md5": "2192824d5dda9d111846fa0806d0d7df", "sha256": "13be013ac3fd6632db562af2a7649f6dda1b8ca60b1f26ac7f83ee66cf201aef"}, "downloads": -1, "filename": "z3c.authenticator-0.6.3.tar.gz", "has_sig": false, "md5_digest": "2192824d5dda9d111846fa0806d0d7df", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 61808, "upload_time": "2010-03-31T10:09:18", "upload_time_iso_8601": "2010-03-31T10:09:18.603118Z", "url": "https://files.pythonhosted.org/packages/ba/29/d843b1e906a5dd55723ca723fbf53f05459e40978c18fa889e4f6814a286/z3c.authenticator-0.6.3.tar.gz", "yanked": false}], "0.7.0": [{"comment_text": "", "digests": {"md5": "e7e4bc06bc3d57e5b50d5ba5037c0903", "sha256": "b853949e852967ef5f5cad6005b95074b84238f3b59ef19a68e2c6818578151a"}, "downloads": -1, "filename": "z3c.authenticator-0.7.0.zip", "has_sig": false, "md5_digest": "e7e4bc06bc3d57e5b50d5ba5037c0903", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 83168, "upload_time": "2009-05-11T17:15:32", "upload_time_iso_8601": "2009-05-11T17:15:32.482388Z", "url": "https://files.pythonhosted.org/packages/2b/ec/a72807d54f1188336cffe67d49b481708575a66a42af5475937cd26f5ec1/z3c.authenticator-0.7.0.zip", "yanked": false}], "0.7.1": [{"comment_text": "", "digests": {"md5": "34b2e5b424f7903b289026bf90470bd6", "sha256": "1357cefc42921756fa751d53a0e0630c33e1ca60e6b5c239e4d647e615fea039"}, "downloads": -1, "filename": "z3c.authenticator-0.7.1.zip", "has_sig": false, "md5_digest": "34b2e5b424f7903b289026bf90470bd6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 85184, "upload_time": "2009-08-19T01:17:19", "upload_time_iso_8601": "2009-08-19T01:17:19.520294Z", "url": "https://files.pythonhosted.org/packages/07/0d/1756002672b3614553e3e0043248616bd2552bfdb4bbd7a7ca6c925888d4/z3c.authenticator-0.7.1.zip", "yanked": false}], "0.7.2": [{"comment_text": "", "digests": {"md5": "256faa0e51d6230c8efb900f365de213", "sha256": "1bc350100cb15c6c51ebe3bb7eebca8111bb18efdca05ded479adb5e528980d7"}, "downloads": -1, "filename": "z3c.authenticator-0.7.2.tar.gz", "has_sig": false, "md5_digest": "256faa0e51d6230c8efb900f365de213", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 61609, "upload_time": "2010-01-26T17:31:21", "upload_time_iso_8601": "2010-01-26T17:31:21.333592Z", "url": "https://files.pythonhosted.org/packages/9b/ca/45ecfe501ba4fa4374eb91b3020fdd8f95c82bc7d0e269a9b6b4ec00480c/z3c.authenticator-0.7.2.tar.gz", "yanked": false}], "0.8.0": [{"comment_text": "", "digests": {"md5": "b3873d1e8248047ed4ee6a8a93b801b9", "sha256": "b9c45353ac6823febbd80b406a823b8311f4fdb89844ac418c5cc269f0cbb92d"}, "downloads": -1, "filename": "z3c.authenticator-0.8.0.tar.gz", "has_sig": false, "md5_digest": "b3873d1e8248047ed4ee6a8a93b801b9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 61727, "upload_time": "2010-01-25T16:15:52", "upload_time_iso_8601": "2010-01-25T16:15:52.001161Z", "url": "https://files.pythonhosted.org/packages/fa/6d/ff2824bfb367c35f9961d78861df0affb424b0fb2e2f158a7aaaa0aa0a14/z3c.authenticator-0.8.0.tar.gz", "yanked": false}], "0.8.1": [{"comment_text": "", "digests": {"md5": "9cb1d954b168e5631c8cc79a2ba3be72", "sha256": "4145c7708b14c54fd19fb88fd80a1a7afafdb7b4dbe1c1ef217163ff741dfbfb"}, "downloads": -1, "filename": "z3c.authenticator-0.8.1.tar.gz", "has_sig": false, "md5_digest": "9cb1d954b168e5631c8cc79a2ba3be72", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 63094, "upload_time": "2011-01-21T08:51:00", "upload_time_iso_8601": "2011-01-21T08:51:00.889018Z", "url": "https://files.pythonhosted.org/packages/cc/52/8e19a94c055e5763225f05bc64b7f4573743045ec026ef806e7c731e1243/z3c.authenticator-0.8.1.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "9038940963c549be3444419c1a588f80", "sha256": "a94875346150fa733f1d100f46ccfab7f975db6a3cdfcde8d4983b20116712e3"}, "downloads": -1, "filename": "z3c.authenticator-1.0.0.tar.gz", "has_sig": false, "md5_digest": "9038940963c549be3444419c1a588f80", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 65923, "upload_time": "2017-04-17T19:06:18", "upload_time_iso_8601": "2017-04-17T19:06:18.966705Z", "url": "https://files.pythonhosted.org/packages/66/e7/e9b4b97c844ff8297589bcc4881507dc09c25af76b08b2e0318a295be8f6/z3c.authenticator-1.0.0.tar.gz", "yanked": false}], "1.0.0a1": [{"comment_text": "", "digests": {"md5": "4894e3fbd1254204a3e7e242f73dcaeb", "sha256": "f8b5fa8f7ed8de333b85aa11aa38d7e4714af6daf65ee6aa1804491dbd2e27cd"}, "downloads": -1, "filename": "z3c.authenticator-1.0.0a1.zip", "has_sig": false, "md5_digest": "4894e3fbd1254204a3e7e242f73dcaeb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 88336, "upload_time": "2013-02-28T18:44:06", "upload_time_iso_8601": "2013-02-28T18:44:06.545832Z", "url": "https://files.pythonhosted.org/packages/cd/d9/53998720a45c60739696c00542dbf500b16100dd01c5fdc25d4c288e030c/z3c.authenticator-1.0.0a1.zip", "yanked": false}], "1.0.0a2": [{"comment_text": "", "digests": {"md5": "67e65799b5b3b0ea659a382a4c119626", "sha256": "504cbd5e6aceff56823e8bb074eef1b895dc56f6c5025e14463d7bbe8b08fe68"}, "downloads": -1, "filename": "z3c.authenticator-1.0.0a2.zip", "has_sig": false, "md5_digest": "67e65799b5b3b0ea659a382a4c119626", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 88637, "upload_time": "2013-03-01T03:31:57", "upload_time_iso_8601": "2013-03-01T03:31:57.902578Z", "url": "https://files.pythonhosted.org/packages/9c/5e/a0f94c940bac6441a68b71a421cfa3d34b4a6899dfa975c09a465a8a3b74/z3c.authenticator-1.0.0a2.zip", "yanked": false}], "1.0.0a3": [{"comment_text": "", "digests": {"md5": "d0df3129a4e4a8a158923deeef0b2f10", "sha256": "4a0fb4356c450ec1d61dca4f83825099bc17374085dc30c68526200ec4a99003"}, "downloads": -1, "filename": "z3c.authenticator-1.0.0a3.zip", "has_sig": false, "md5_digest": "d0df3129a4e4a8a158923deeef0b2f10", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 91581, "upload_time": "2013-03-01T03:48:12", "upload_time_iso_8601": "2013-03-01T03:48:12.253211Z", "url": "https://files.pythonhosted.org/packages/74/82/531c0260f47673a5a748d32aa8ea571268eb6056ba08d6d435640e51fcde/z3c.authenticator-1.0.0a3.zip", "yanked": false}], "1.0.0a4": [{"comment_text": "", "digests": {"md5": "9eab1fe19fb4111fe509e3cbbc205721", "sha256": "e1ef894fdd17e2cce74a3066150a3fe9d4e99a59ca24ac4b6de857c178d8b312"}, "downloads": -1, "filename": "z3c.authenticator-1.0.0a4.zip", "has_sig": false, "md5_digest": "9eab1fe19fb4111fe509e3cbbc205721", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 90670, "upload_time": "2013-03-01T04:45:15", "upload_time_iso_8601": "2013-03-01T04:45:15.976461Z", "url": "https://files.pythonhosted.org/packages/d2/ac/ff332d472e6d1fb24eb3aff25d8e1d9a382ddb4f821e03f1eea8b7613c2e/z3c.authenticator-1.0.0a4.zip", "yanked": false}], "1.0.0a5": [{"comment_text": "", "digests": {"md5": "51b8bbfb8f1f0b33dd3df1ad1d358191", "sha256": "0cd01028b7e3ba0990ef09cb7206ac34faa9704c4b9f6ebaab7ab68c08994d6b"}, "downloads": -1, "filename": "z3c.authenticator-1.0.0a5.zip", "has_sig": false, "md5_digest": "51b8bbfb8f1f0b33dd3df1ad1d358191", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 90781, "upload_time": "2013-03-31T15:20:32", "upload_time_iso_8601": "2013-03-31T15:20:32.403469Z", "url": "https://files.pythonhosted.org/packages/f8/88/70a3164170a25756fd7cd3a45b3806258a23e7166d7afd85870fa0bbd09a/z3c.authenticator-1.0.0a5.zip", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "a4ebf410e1905aa6095e7a249ed4b248", "sha256": "99e08297340c34994a2e6da6a832059be1de9832d11eba155daf7009fa3520b4"}, "downloads": -1, "filename": "z3c.authenticator-1.0.1.tar.gz", "has_sig": false, "md5_digest": "a4ebf410e1905aa6095e7a249ed4b248", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 68007, "upload_time": "2018-05-16T13:52:25", "upload_time_iso_8601": "2018-05-16T13:52:25.231557Z", "url": "https://files.pythonhosted.org/packages/d0/e7/cbef6251210dff9c916127f2a0e2609c60f968fb8acf93594cd7e23b3534/z3c.authenticator-1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a4ebf410e1905aa6095e7a249ed4b248", "sha256": "99e08297340c34994a2e6da6a832059be1de9832d11eba155daf7009fa3520b4"}, "downloads": -1, "filename": "z3c.authenticator-1.0.1.tar.gz", "has_sig": false, "md5_digest": "a4ebf410e1905aa6095e7a249ed4b248", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 68007, "upload_time": "2018-05-16T13:52:25", "upload_time_iso_8601": "2018-05-16T13:52:25.231557Z", "url": "https://files.pythonhosted.org/packages/d0/e7/cbef6251210dff9c916127f2a0e2609c60f968fb8acf93594cd7e23b3534/z3c.authenticator-1.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:21:10 2020"}