{"info": {"author": "Roger Taylor", "author_email": "roger.taylor.email@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Security :: Cryptography", "Topic :: Software Development :: Libraries"], "description": "electrumsv-hosting\n~~~~~~~~~~~~~~~~~~\n\n  Licence: BitcoinSV\n  Maintainers: Roger Taylor, AustEcon\n  Project Lead: Roger Taylor\n  Language: Python (>=3.6)\n  Homepage: https://electrumsv.io/\n\nThis library is intended to encapsulate the protocol used by the ElectrumSV wallet to open\nan encrypted connection with either a hosted service that operates on their behalf, or other\nElectrumSV wallets.\n\nThis library is under development. Until it is integrated into ElectrumSV and released, it may\nchange in ways that break the API it exposes to developers who may wish to use it.\n\nSee the **examples** folder for different examples of the current code in use.\n\nHosted Mailbox\n==================================\nThe mailbox server takes connections from clients via WP42 tunnel and facilitates the delivery of encrypted messages\nto one of their contacts.\n\nThese messages can be delivered to the recipient by:\n\n    a) depositing them in the mailbox for later (the fallback option)\n    b) direct, p2p communication (initially facilitated by the server)\n\nIn either case, the headers, payloads and messaging protocol are the same for both peers.\n\n\nPublic Identity Registration\n#####################################\n\nregister_identity\n******************\nThis endpoint is an exception to the rule in that no headers, signatures or authentication\nare required because an identity public key is required for those things.\n\nA security challenge must be completed, proving control of the identity pubkey\n(e.g. signing a recent unix timestamp - within the last 60 minutes).\n\n\nOverview of Headers and Payloads\n################################\nAll other endpoints (besides public identity registration) are either:\n\n    - **'Client-Server' endpoints** (tunnelled to server but unencrypted payload)\n    - **'Mailbox' messages** (tunnelled to server *and* encrypted payload with wp42 derived shared secret for the p2p relationship)\n\nHeaders\n*******\nThe standardized header is always the same. For some endpoints the receiver_pubkey\nis omitted (e.g. get_id_key, subscribe_to_messagebox, get_message\n\n.. code-block:: python\n\n    'sender_pubkey'\n    'receiver_pubkey' (only applicable for mailbox messages) - hex\n    'sender_nonce'  (8 byte nonce) - hex\n    'payload_hash'  (of utf-8 encoded ciphertext) hex\n    'sender_signature' (signs the above 4 fields - base64 encoded)\n\n\nFor authentication between client and server the sender signature covers the sender_pubkey,\nsender_nonce, payload_hash but **not** the receiver_pubkey for sake of uniformity (receiver_pubkey\nis not always included).\n\nPayload\n*******\nBase64 encoded json +/- encryption (for Mailbox endpoints)\n\nClient-Server Endpoints\n#######################\n\nsubscribe_to_messagebox\n***********************\nReturns an integer ('message_id') that increments for each additional message to a given identity pubkey.\nThe client can then reconcile any missed messages while offline or maintain a real-time feed of inbound messages.\n\nget_message\n***********\nTakes the message_id from the 'subscribe_to_messagebox' endpoint and returns the full message with header and payload.\n\n\nMailbox Messages\n###########################\nThere is **one endpoint** server-side:\n\n    'send_message',\n\nThis is the most interesting endpoint because there can be many different message types embedded in the encrypted\npayload. There could be many alternative p2p protocols co-existing with this service - we do not discriminate.\n\nThe takeaway is that the payloads are encrypted with a shared secret between the two peers. The server is not privy\nto any information contained in the message payload. As such there is minimal risk for clients and minimal liability\nfor the service provider.\n\nsend_message\n************\nThis is a protocol agnostic endpoint. It is a generic container for any encrypted p2p (or mailbox-based) communication\nbetween two parties.\n\nHowever, it is recommended that each party employ techniques from WP0042 for establishing the shared secret for\nencryption. The nonce in the plaintext header (see above) should be used for generating the message hash and\nin turn the derived keys and shared secret.\n\nencryption\n--------------------\nAn optional extension is to use the WP0042 spec. (ref. V1: Hierarchy of Hashes) technique for subsequent messages\n(and perhaps bitcoin transaction keys too). Each peer may agree that the first nonce in the sequence of messages holds special\nsignificance and every new outbound message uses the next nonce in the sequence (rehashing this landmark\nnonce N times for the Nth message of the p2p relationship). This nth hash is then used for shared secret\nderivation and encryption.\n\nAs per the WP0042 spec.\n\n    1) contact_request *encrypts* using V2C and P2S -> S\n    2) receiver *decrypts* with the same shared secret via V2S and P2C -> S\n\nThe sequence continues (As per the WP0042 spec - V1: Hierarchy of Hashes):\n\n    3) contact_request *encrypts* using V2C' and P2S' -> S\n    4) receiver *decrypts* with the same shared secret via V2S' and P2C' -> S\n\n... and so on to V2C'' and V2C''' etc. **re-hashing the original nonce N times to get to the\nNth set of keys**\n\nThe advantage of this approach (if it is used for the bitcoin transaction keys) rather than using\na fresh nonce every time is to do with on-chain backup solutions. With the 'Hierarchy of Hashes'\napproach, everything that is required for full disaster-recovery is contained within the 1st exchange\nof contact information. Furthermore, this model for generating payment scripts sidesteps the problems\nwith the current paymail/bsvalias implementation of having a server that takes responsibility\n(along with the liability of running a secure service) for giving out correct Bip32-derived\npayment scripts/pubpkeys. So as I see it, there are only benefits and no downsides to shifting\nthis responsibility to rest solely in the hands of the two peers.", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/electrumsv/electrumsv-hosting", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "electrumsv-hosting", "package_url": "https://pypi.org/project/electrumsv-hosting/", "platform": "", "project_url": "https://pypi.org/project/electrumsv-hosting/", "project_urls": {"Homepage": "https://github.com/electrumsv/electrumsv-hosting"}, "release_url": "https://pypi.org/project/electrumsv-hosting/0.1.0/", "requires_dist": null, "requires_python": ">=3.6", "summary": "Supporting code for ElectrumSV wallets to communicate using encrypted connections", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <blockquote>\nLicence: BitcoinSV\nMaintainers: Roger Taylor, AustEcon\nProject Lead: Roger Taylor\nLanguage: Python (&gt;=3.6)\nHomepage: <a href=\"https://electrumsv.io/\" rel=\"nofollow\">https://electrumsv.io/</a></blockquote>\n<p>This library is intended to encapsulate the protocol used by the ElectrumSV wallet to open\nan encrypted connection with either a hosted service that operates on their behalf, or other\nElectrumSV wallets.</p>\n<p>This library is under development. Until it is integrated into ElectrumSV and released, it may\nchange in ways that break the API it exposes to developers who may wish to use it.</p>\n<p>See the <strong>examples</strong> folder for different examples of the current code in use.</p>\n<div id=\"hosted-mailbox\">\n<h2>Hosted Mailbox</h2>\n<p>The mailbox server takes connections from clients via WP42 tunnel and facilitates the delivery of encrypted messages\nto one of their contacts.</p>\n<p>These messages can be delivered to the recipient by:</p>\n<blockquote>\n<ol>\n<li>depositing them in the mailbox for later (the fallback option)</li>\n<li>direct, p2p communication (initially facilitated by the server)</li>\n</ol>\n</blockquote>\n<p>In either case, the headers, payloads and messaging protocol are the same for both peers.</p>\n<div id=\"public-identity-registration\">\n<h3>Public Identity Registration</h3>\n<h3 id=\"register-identity\"><span class=\"section-subtitle\">register_identity</span></h3>\n<p>This endpoint is an exception to the rule in that no headers, signatures or authentication\nare required because an identity public key is required for those things.</p>\n<p>A security challenge must be completed, proving control of the identity pubkey\n(e.g. signing a recent unix timestamp - within the last 60 minutes).</p>\n</div>\n<div id=\"overview-of-headers-and-payloads\">\n<h3>Overview of Headers and Payloads</h3>\n<p>All other endpoints (besides public identity registration) are either:</p>\n<blockquote>\n<ul>\n<li><strong>\u2018Client-Server\u2019 endpoints</strong> (tunnelled to server but unencrypted payload)</li>\n<li><strong>\u2018Mailbox\u2019 messages</strong> (tunnelled to server <em>and</em> encrypted payload with wp42 derived shared secret for the p2p relationship)</li>\n</ul>\n</blockquote>\n<div id=\"headers\">\n<h4>Headers</h4>\n<p>The standardized header is always the same. For some endpoints the receiver_pubkey\nis omitted (e.g. get_id_key, subscribe_to_messagebox, get_message</p>\n<pre><span class=\"s1\">'sender_pubkey'</span>\n<span class=\"s1\">'receiver_pubkey'</span> <span class=\"p\">(</span><span class=\"n\">only</span> <span class=\"n\">applicable</span> <span class=\"k\">for</span> <span class=\"n\">mailbox</span> <span class=\"n\">messages</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"nb\">hex</span>\n<span class=\"s1\">'sender_nonce'</span>  <span class=\"p\">(</span><span class=\"mi\">8</span> <span class=\"n\">byte</span> <span class=\"n\">nonce</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"nb\">hex</span>\n<span class=\"s1\">'payload_hash'</span>  <span class=\"p\">(</span><span class=\"n\">of</span> <span class=\"n\">utf</span><span class=\"o\">-</span><span class=\"mi\">8</span> <span class=\"n\">encoded</span> <span class=\"n\">ciphertext</span><span class=\"p\">)</span> <span class=\"nb\">hex</span>\n<span class=\"s1\">'sender_signature'</span> <span class=\"p\">(</span><span class=\"n\">signs</span> <span class=\"n\">the</span> <span class=\"n\">above</span> <span class=\"mi\">4</span> <span class=\"n\">fields</span> <span class=\"o\">-</span> <span class=\"n\">base64</span> <span class=\"n\">encoded</span><span class=\"p\">)</span>\n</pre>\n<p>For authentication between client and server the sender signature covers the sender_pubkey,\nsender_nonce, payload_hash but <strong>not</strong> the receiver_pubkey for sake of uniformity (receiver_pubkey\nis not always included).</p>\n</div>\n<div id=\"payload\">\n<h4>Payload</h4>\n<p>Base64 encoded json +/- encryption (for Mailbox endpoints)</p>\n</div>\n</div>\n<div id=\"client-server-endpoints\">\n<h3>Client-Server Endpoints</h3>\n<div id=\"subscribe-to-messagebox\">\n<h4>subscribe_to_messagebox</h4>\n<p>Returns an integer (\u2018message_id\u2019) that increments for each additional message to a given identity pubkey.\nThe client can then reconcile any missed messages while offline or maintain a real-time feed of inbound messages.</p>\n</div>\n<div id=\"get-message\">\n<h4>get_message</h4>\n<p>Takes the message_id from the \u2018subscribe_to_messagebox\u2019 endpoint and returns the full message with header and payload.</p>\n</div>\n</div>\n<div id=\"mailbox-messages\">\n<h3>Mailbox Messages</h3>\n<p>There is <strong>one endpoint</strong> server-side:</p>\n<blockquote>\n\u2018send_message\u2019,</blockquote>\n<p>This is the most interesting endpoint because there can be many different message types embedded in the encrypted\npayload. There could be many alternative p2p protocols co-existing with this service - we do not discriminate.</p>\n<p>The takeaway is that the payloads are encrypted with a shared secret between the two peers. The server is not privy\nto any information contained in the message payload. As such there is minimal risk for clients and minimal liability\nfor the service provider.</p>\n<div id=\"send-message\">\n<h4>send_message</h4>\n<p>This is a protocol agnostic endpoint. It is a generic container for any encrypted p2p (or mailbox-based) communication\nbetween two parties.</p>\n<p>However, it is recommended that each party employ techniques from WP0042 for establishing the shared secret for\nencryption. The nonce in the plaintext header (see above) should be used for generating the message hash and\nin turn the derived keys and shared secret.</p>\n<div id=\"encryption\">\n<h5>encryption</h5>\n<p>An optional extension is to use the WP0042 spec. (ref. V1: Hierarchy of Hashes) technique for subsequent messages\n(and perhaps bitcoin transaction keys too). Each peer may agree that the first nonce in the sequence of messages holds special\nsignificance and every new outbound message uses the next nonce in the sequence (rehashing this landmark\nnonce N times for the Nth message of the p2p relationship). This nth hash is then used for shared secret\nderivation and encryption.</p>\n<p>As per the WP0042 spec.</p>\n<blockquote>\n<ol>\n<li>contact_request <em>encrypts</em> using V2C and P2S -&gt; S</li>\n<li>receiver <em>decrypts</em> with the same shared secret via V2S and P2C -&gt; S</li>\n</ol>\n</blockquote>\n<p>The sequence continues (As per the WP0042 spec - V1: Hierarchy of Hashes):</p>\n<blockquote>\n<ol>\n<li>contact_request <em>encrypts</em> using V2C\u2019 and P2S\u2019 -&gt; S</li>\n<li>receiver <em>decrypts</em> with the same shared secret via V2S\u2019 and P2C\u2019 -&gt; S</li>\n</ol>\n</blockquote>\n<p>\u2026 and so on to V2C\u2019\u2019 and V2C\u2019\u2019\u2019 etc. <strong>re-hashing the original nonce N times to get to the\nNth set of keys</strong></p>\n<p>The advantage of this approach (if it is used for the bitcoin transaction keys) rather than using\na fresh nonce every time is to do with on-chain backup solutions. With the \u2018Hierarchy of Hashes\u2019\napproach, everything that is required for full disaster-recovery is contained within the 1st exchange\nof contact information. Furthermore, this model for generating payment scripts sidesteps the problems\nwith the current paymail/bsvalias implementation of having a server that takes responsibility\n(along with the liability of running a secure service) for giving out correct Bip32-derived\npayment scripts/pubpkeys. So as I see it, there are only benefits and no downsides to shifting\nthis responsibility to rest solely in the hands of the two peers.</p>\n</div>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 7184446, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "bbfa19bb0837d2d4d478e27c1610d435", "sha256": "245785fac495d4979ddd9be75408e340823472595436f285b62a0bcedaf2ea18"}, "downloads": -1, "filename": "electrumsv-hosting-0.1.0.tar.gz", "has_sig": false, "md5_digest": "bbfa19bb0837d2d4d478e27c1610d435", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 8736, "upload_time": "2020-05-07T00:31:55", "upload_time_iso_8601": "2020-05-07T00:31:55.242758Z", "url": "https://files.pythonhosted.org/packages/90/84/5d3abeae1c4d8689eb4bb2bf9063779b4dc4ce0983fbeb9296fe03103e4e/electrumsv-hosting-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bbfa19bb0837d2d4d478e27c1610d435", "sha256": "245785fac495d4979ddd9be75408e340823472595436f285b62a0bcedaf2ea18"}, "downloads": -1, "filename": "electrumsv-hosting-0.1.0.tar.gz", "has_sig": false, "md5_digest": "bbfa19bb0837d2d4d478e27c1610d435", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 8736, "upload_time": "2020-05-07T00:31:55", "upload_time_iso_8601": "2020-05-07T00:31:55.242758Z", "url": "https://files.pythonhosted.org/packages/90/84/5d3abeae1c4d8689eb4bb2bf9063779b4dc4ce0983fbeb9296fe03103e4e/electrumsv-hosting-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:46:54 2020"}