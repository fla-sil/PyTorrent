{"info": {"author": "Guillaume Grosbois", "author_email": "grosbois.guillaume@gmail.com", "bugtrack_url": null, "classifiers": ["Operating System :: OS Independent", "Programming Language :: Python :: 3.5"], "description": "[![Build Status](https://travis-ci.com/WillFr/rest-helpers.svg?branch=master)](https://travis-ci.com/WillFr/rest-helpers)\n\n[![Coverage Status](https://coveralls.io/repos/github/WillFr/rest-helpers/badge.svg?branch=master)](https://coveralls.io/github/WillFr/rest-helpers?branch=master)\n\n# rest-helpers\n\n## What is Rest-Helpers\nRest-Helpers is a python 3 library that helps you build REST applications quickly, and in a consistent way.\nOverall it provides the following:\n- [automated and consistent route creation via decorator](#route-decorator-section)\n- [REST API versionner to handle various version your API](#versioner-section)\n- [non verbose bindings to parse inputs from query string, body, headers ... including deserialization and validation](#binding-section)\n- [Oauth binding: adding auth to a route is as easy as adding the binding](#oauth-binding-section)\n- binding [validators](#validation-section) and [deserializers](#deserialization-section)\n- [Custom autogenerated swagger UI, fully customizable via method documentation, and integrated with okta](#swagger-section)\n- [Server side filtering via json_path and json_filter query string arguments](#serverside-filtering)\n- [automatic paging for long response payload](#automatic-paging-section)\n- [framework agnostic: it currently supports flask and aiohttp and is easy to extend](#framework-agnostic-section)\n- [JsonApi compliant response type](#json-api-section)\n- [Meaningful default error messages](#error-messages-section)\n\neg: the following code snippet will create an appropriate route, document it in swagger and inject your custom modifications, take care of input binding and return meaningful responses if they are not proper, take care of exception, take care of versionning, handle server side filtering and paging, and return a proper json_api response.\n```python\n@swagger.swagger_object\nclass PlatformResource(Resource):\n    \"\"\"\n    Swagger jsonapi_response:\n        name:\n            type: \"string\"\n            example: \"val_300\"\n        parent:\n            type: \"string\"\n            example: \"candidate_ready\"\n    \"\"\"\n\n    resource_type = \"/worlds/platforms\"\n\n    def __init__(self, **kwargs):\n        self.__dict__.update(kwargs)\n\n@routes.get_all_resources_route(platform_blueprint, PlatformResource, versionner=platform_versionner.AccretePlatformVersionner, exception_handler=exception_handler.common_exception_handler)\ndef accrete_platform(\n        world_name,\n        asof:(as_of_date.AsOfDate,from_query_string)=None,\n        uag:from_header(header_field=\"User-Agent\")=None,\n        include_platform_source:(bool, from_query_string)=False,\n        add_hoc_mixins:(list, from_query_string(as_list=True))= []\n    ):\n    \"\"\"\n    Swagger doc:\n        description: \"Display the platform taking in account the inheritance tree.\"\n    end swagger\n\n    Swagger parameters:\n        User-Agent: null\n    end swagger\n\n    Swagger augment_default:\n    parameters>-: [\"[2]\"]\n\n    Arguments:\n        world_name {str} -- The name of the world to be accreted.\n    \"\"\"\n    return responses.ok(Platform(\"my_platform\"))\n\n```\n<a name=\"route-decorator-section\"></a>\n\n## Automated and consistent route creation via decorator\nRest-Helper follow simple routing principles:\n- GET gets you a resource or an array of resource, and you can reuse the response payload for a PUT request in order to modify the resource\n- Everything else is an 'operation' and therefore uses the POST verb.\n\nSeveral routing decorators are provided\n\n### route decorator\nEg:\n```python\nfrom rest_helper.flask.routes import routes\n\n\n@route(\"/abc\", options={\"methods\": [\"GET\", \"POST\"], doc=True, versionner=None, exception_handler=None)\ndef my_function():\n    return response.ok()\n```\n\nThis is the base decorator. It does not impose any REST related constraint and therefore should be used sparsely. It allows you to define any route.\nIt takes several *optional* arguments, that are going to be similar to other routes:\n- doc : {bool} this indicates whether or not this route should be documented in swagger.\n- versionner : {versionnerType} this versionner is going to modify the route as defined in the versionner, more on this in the versionner section.\n- exception_handler : {exceptionHandlerType} this is going to define how exceptions should be handled.\n\n### resource based route decorator\nEg:\n```python\nfrom rest_helper.flask.routes import routes\nfrom rest_helper.jsonapi_objects import Resource\n\nclass HostResource(Resource):\n    resource_type = \"/clusters/hosts\"\n\n@routes.get_resource_route(HostResource, doc=True, versionner=None, exception_handler=None)\ndef my_function(cluster_name, host_name):\n    return response.ok()\n```\n\nResource decorator takes a resource class as a first argument and create routes based on that resources. They will autogenerate\nthe routing scheme based on the resource_type field that must be present in every class inheriting from Resource.\n\nThe route scheme is generated based on the verb and can be modified by a versionner. Eg: a get_resource route:\n`/resource_type/resource_name/sub_resource_type/sub_resource_name`\n\nIn the example above it will lead to:\n`/clusters/cluster_abc/hosts/host_a`\n\nWith a url_root_versioner it would become:\n`/api_version/resource_type/resource_name/sub_resource_type/sub_resource_name`\n\nThe resource type and sub resource type are extracted from the resource_type field that must be present in every class inheriting from Resource.\n\nRecomandation: resource_type should be plural.\n\nThis decorator will automatically bind resource names to argument named after de-pluralized resource type:\ntype: clusters => cluster_name\ntype: hosts => host_name\ntype: libraries => library_name\n\nIf an argument named resource_id is present, Rest-helpers will bind the resource_id to it.\nIn our example above:\nresource_id => /clusters/cluster_abc/hosts/host_a\n\nA resource id uniquely identifies a resource in the entire API: there must be only one host named host_a in a cluster named \"cluster_abc\".\nA resource name uniquely identifies a resource within the scope of their parent: there can be a host named host_a in another cluster not named \"cluster_abc\".\n\nThis is true for all resource based routing decorators.\n\n### get_resource_route decorator\nEg:\n```python\nfrom rest_helper.flask.routes import routes\nfrom rest_helper.jsonapi_objects import Resource\n\nclass HostResource(Resource):\n    resource_type = \"/clusters/hosts\"\n\n@routes.get_resource_route(HostResource, doc=True, versionner=None, exception_handler=None)\ndef my_function(cluster_name, host_name):\n    return response.ok()\n```\nThis generates a route to get a single resource:\n`GET /resource_type/resource_name/sub_resource_type/sub_resource_name`\n\nIn the example above it will lead to:\n`GET /clusters/cluster_abc/hosts/host_a`\n\nWith a url_root_versioner it would become:\n`GET /api_version/resource_type/resource_name/sub_resource_type/sub_resource_name`\n\n### get_all_resources_route decorator\nEg:\n```python\nfrom rest_helper.flask.routes import routes\nfrom rest_helper.jsonapi_objects import Resource\n\nclass HostResource(Resource):\n    resource_type = \"/clusters/hosts\"\n\n@routes.get_all_resources_route(HostResource, doc=True, versionner=None, page_size=10, exception_handler=None)\ndef my_function(cluster_name):\n    return response.ok()\n```\nThis generates a route to get a list of all resource under a parent (or at the root):\n`GET /resource_type/resource_name/sub_resource_type/`\n\nIn the example above it will lead to:\n`GET /clusters/cluster_abc/hosts/`\n\nWith a url_root_versioner it would become:\n`GET /api_version/resource_type/resource_name/sub_resource_type/`\n\nThis route automatically handle the page_size *optional* argument (infinite by default) if used\nin combination with the Rest-helpers response types. The page_size argument of the route indicate\nthe default value of the page size and can be overriden by a query string argument `page_size`.\n\nIn addition, the resouce_id argument will be bound to the parent resource:\nin the example above: resource_id => /clusters/cluster_abc\n\n### put_resource_route decorator\nEg:\n```python\nfrom rest_helper.flask.routes import routes\nfrom rest_helper.jsonapi_objects import Resource\n\nclass HostResource(Resource):\n    resource_type = \"/clusters/hosts\"\n\n@routes.put_resource_route(HostResource, doc=True, versionner=None, exception_handler=None)\ndef my_function(cluster_name, host_name):\n    return response.ok()\n```\nThis generates a route to PUT a resource in order to modify it:\n`PUT /resource_type/resource_name/sub_resource_type/sub_resource_name`\n\nIn the example above it will lead to:\n`PUT /clusters/cluster_abc/hosts/sub_resource_name`\n\nWith a url_root_versioner it would become:\n`PUT /api_version/resource_type/resource_name/sub_resource_type/sub_resource_name`\n\nput_resource_route is intended to create or modify a resource in an idempotent way.\n\nresource_id is bound similarly to get_resource_route.\n\n\n### patch_resource_route decorator\nEg:\n```python\nfrom rest_helper.flask.routes import routes\nfrom rest_helper.jsonapi_objects import Resource\n\nclass HostResource(Resource):\n    resource_type = \"/clusters/hosts\"\n\n@routes.patch_resource_route(HostResource, doc=True, versionner=None, exception_handler=None)\ndef my_function(cluster_name, host_name):\n    return response.ok()\n```\nThis generates a route to PATCH a resource in order to modify it:\n`PATCH /resource_type/resource_name/sub_resource_type/sub_resource_name`\n\nIn the example above it will lead to:\n`PATCH /clusters/cluster_abc/hosts/sub_resource_name`\n\nWith a url_root_versioner it would become:\n`PATCH /api_version/resource_type/resource_name/sub_resource_type/sub_resource_name`\n\npatch_resource_route is intended to partially update resource in an idempotent way.\n\nresource_id is bound similarly to get_resource_route.\n\n\n\n### operation_resource_route\nEg:\n```python\nfrom rest_helper.flask.routes import routes\nfrom rest_helper.jsonapi_objects import Resource\n\nclass HostResource(Resource):\n    resource_type = \"/clusters/hosts\"\n\n@routes.operation_resource_route(HostResource, operation_name=\"transform\", doc=True, versionner=None, exception_handler=None)\ndef my_function(cluster_name, host_name):\n    return response.ok()\n```\nThis generates a route to PUT a resource in order to modify it:\n`POST /resource_type/resource_name/sub_resource_type/sub_resource_name/transform`\n\nIn the example above it will lead to:\n`POST /clusters/cluster_abc/hosts/sub_resource_name/transform`\n\nWith a url_root_versioner it would become:\n`POST /api_version/resource_type/resource_name/sub_resource_type/sub_resource_name/transform`\n\nOperation routes transform a resource. It can be done in a readonly way, for example a special view of the resource, or\nin a permanent write way where the transformation is applied permanently. Operations can also be used for long running operation, starting a VM for instance.\n\nresource_id is bound similarly to get_resource_route.\n\n### group_operation_resource_route\nEg:\n```python\nfrom rest_helper.flask.routes import routes\nfrom rest_helper.jsonapi_objects import Resource\n\nclass HostResource(Resource):\n    resource_type = \"/clusters/hosts\"\n\n@routes.group_operation_resource_route(HostResource, operation_name=\"transform\", doc=True, versionner=None, exception_handler=None)\ndef my_function(cluster_name):\n    return response.ok()\n```\nThis generates a route to PUT a resource in order to modify it:\n`POST /resource_type/resource_name/sub_resource_type/transform`\n\nIn the example above it will lead to:\n`POST /clusters/cluster_abc/hosts/transform`\n\nWith a url_root_versioner it would become:\n`POST /api_version/resource_type/resource_name/sub_resource_type/transform`\n\nGroup operations are similar to operations, except they are applied to the list of resources returned by the get_all_resources_route.\nresource_id is bound similarly to get_all_resources_route.\n\n### delete_resource_route decorator\nEg:\n```python\nfrom rest_helper.flask.routes import routes\nfrom rest_helper.jsonapi_objects import Resource\n\nclass HostResource(Resource):\n    resource_type = \"/clusters/hosts\"\n\n@routes.put_resource_route(HostResource, doc=True, versionner=None, exception_handler=None)\ndef my_function(cluster_name, host_name):\n    return response.ok()\n```\nThis generates a route to PUT a resource in order to modify it:\n`DELETE /resource_type/resource_name/sub_resource_type/sub_resource_name`\n\nIn the example above it will lead to:\n`DELETE /clusters/cluster_abc/hosts/sub_resource_name`\n\nWith a url_root_versioner it would become:\n`DELETE /api_version/resource_type/resource_name/sub_resource_type/sub_resource_name`\n\nDelete operation are to be used to delete a resource permanently.\nresource_id is bound similarly to get_resource_route.\n\n<a name=\"versioner-section\"></a>\n\n## Versioner\n\nThe versionner allow you to support former versions of your api. It provides several hooks to transform a request and a\nresponse to bring it to a certain version.\n\nEg: My service support v1 and v2, but internally, all the code supports only latest, which is v2.\nA request entering via a route with a versionner will follow this path :\nrequest at v1 -> route -> versionner: transforms a v1 request into a v2 request -> route handler|\nresponse at v1 <- versionner: transforms a v2 response into a v1 response <- route <-|\n\nThe service author defines the logic to transform a v1 request into a v2 request.\n\nThe following hooks are provided:\n- body hook: will take the current request body and return a transformed version\n- body dict hook: similar to body, but act on the JSON deserialized dict body\n- headers hook: will take the request headers and return a transformed version\n- query string args: will take the request query string and return a transformed version\n- response: will take the entire response object and return a transformed version\n- response body dict: will take the response body dictionary and return a transformed version\n\n### How to define a versioner:\nVersioners should inherit from the BaseVersioner class.\n\nThey should:\n- define a static methos `version_route` that takes a route objet in parameter and inject the version into it\n- define inner class named after supported versions and containing hooks definition.\nEg:\n```python\nclass MyVersionner(versioning.BaseVersionner):\n    @staticmethod\n    def version_route(route):\n        route.rule=\"/<rest_helper_version>\"+route.rule\n\n    class v2:\n        pass\n\n    class v1:\n        def response_body_dict(self, response):\n            v2_response[\"Myfield\"] = \"hardcoded back compatible field\"\n\n            return v2_response\n```\n\nNote that you only have to add the hooks that are useful to you.\nComplete list of hook:\n```python\ndef body(self, body):\ndef body_dict(self, body):\ndef response(self, response)\ndef headers(self, headers)\ndef query_string_args(self, query_string_args)\ndef response_body_dict(self, response_body_dict)\n```\n\n### Url versioner\nThe url versionner is a commonly used versioner injecting the version at the root of the route:\n```python\nclass UrlRootVersionner(BaseVersionner):\n    @staticmethod\n    def version_route(route):\n        route.rule=\"/<rest_helper_version>\"+route.rule\n```\n\nBy inheriting from it, you only have to define classes representing each version.\n\n\n<a name=\"bindings-section\"></a>\n\n## Exception handling\nRoutes all provide an exception_handler field that catches exceptions and respond appropriately.\n\nAn exeption handler can be any callable taking exactly one parameter, the exception, and return a response.\nA basic exception handler is provided and will be used by default.\n\neg:\n```python\ndef common_exception_handler(ex):\n    if isinstance(ex, rest_exceptions.NotFoundException):\n        return responses.not_found()\n    elif isinstance(ex, storage.PlatformNotFound):\n        return responses.not_found(\"Platform not found.\")\n    elif isinstance(ex, exception.ExternalExceptionBase) or isinstance(ex, rest_exceptions.InvalidDataException):\n        message = \"\".join(ex.args).replace(\"\\\\n\", \"\\n\")\n        return responses.bad_request(message)\n    elif isinstance(ex, exception.TransactionCheckFailedException):\n        return responses.error(409, \"Conflict\", \"\"\"\n        The client expected the resource ({}) version to be {} but is actually is {}: the latest version\n        of the resource must be used to modify it. Get the resource again before attempting to modify it.\"\"\".format(ex.resource_id, ex.sha_was_expected_to_be, ex.actual_sha))\n    else:\n        return responses.base_exception_handler(ex)\n```\n## Not so verbose bindings\n\nRest-helper bindings leverage python3 syntax to be as light and close to their target as possible.\nEg:\n```python\ndef get_platform(\n        platform_name,\n        asof:(as_of_date.AsOfDate,from_query_string),\n        uag:from_header(header_field=\"User-Agent\")=None\n    ):\n```\n\nIn the above example, platform_name would come from the route, asof would come from the query string and is to be deserialized into an `as_of_date.AsOfDate`\nobject, uag come from the request header named \"User-Agent\". Both asof and uag are optional, uag is optional because it has a default value but asof is not:\nnot passing the asof query string argument will result into a properly formatted 400 response.\n\nArgument decorator can be either a binding or a tuple containing (type, binding). When a type is specified as the first tuple element, it will be used to\ndeserialize the value properly and return an appropriate 400 errors if deserialization fails. Custom types are supported:\n\n```python\nfrom rest_helper import type_deserializers\ntype_deserializers.type_to_deserializer_mapping[as_of_date.AsOfDate] = bindings.as_of_deserializer\n```\n\nEach binding detailed further can be customized via several optional arguments, but default value aim to improve readability, in all case, the foreign field (header_field for instance) will be defaulted to the variable name :\n```python\nasof:(as_of_date.AsOfDate,from_query_string),\n```\nis equivalent to\n```python\nasof:(as_of_date.AsOfDate,from_query_string(query_field=\"asof\")),\n```\n\nYou get bindings for free if you use a route decorator on top of your function. If you want to use only bindings without a route decorator,\nyou need to decorate your function with `bind_hints`.\n\nNote: all bindings are available as individual decorator as well. If that is your usage, do not forget to specify the field value.\n\n### route bindings\nAs mentionned in the route section some arguments are automatically bound from the url path to predictable argument_name. This is based on the resource type: for a resource typed as `/worlds/platforms`:\n- a get_resource_route expect a world_name argument and a platform_name argument parsed from the uri (notice world was unpluralized)\n- a get_all_resource_route expects only a world_name argument because it serves *all* platforms under a specific world.\n- operation_resource_route, put_resource_route, delete_resource_route, patch_resource_route will behave like get_resource_route\n- group_operation_resource_route will behave like get_all_resources_route\n\n### base_binder\nThis is not to be used directly but can be extended to create your own binding.\n\n```python\nbase_binder(field=None, validator=None, deserializer=None, type=None)\n```\n\n`field` is name of the variable to be bound. When the value is extracted it is going to be assigned to a function argument named after `field`\n`validator` offers a simple way to validate the data. If left to `None`, and if a type is specified, a default type validator will be used. When the\nvalidation fails, the user receives a properly formatted 400 error.\nDeserializer will be used to deserialize the data.\nType is a way to infer deserialization logic from the type, more on that on the deserializer section. You cannot specify both type and deserializer.\n\nImportant note: type is automatically infered from the decorator. Since validator and deserializer are generally infered from the type, you typically do not need to specify them. Field is also infered from the variable name. As a result, using the binding looks like :\n```python\ndef my_function(my_arg: (bool, from_query_string))\n```\nThis would leverage provided deserializer and validator to properly deserializing boolean from the query string. All of the following would result in `my_arg` being `True`:\n- /myroute/?my_arg\n- /myroute/?my_arg=True\n- /myroute/?my_arg=TRUE\n- /myroute/?my_arg=true\n\n### from_json_body\nThis binding parses the request body as JSON and assign the result to the decorated argument.\n\neg:\n```python\ndef my_function(\n        data:from_json_body\n)\n```\n\n### field_from_json_body\nThis binding parses the request body as JSON, look for a specific field, and assign the result to the decorated argument.\n\nUse the argument `json_field` to specify the path to be extracted.\neg:\n```python\ndef my_function(\n        data:field_from_json_body(json_field=\"/data/attributes/my_field\")\n)\n```\n\n### from_header\nThis binding parses the specified header and assign the result to the decorated argument.\n\nUse the argument `header_field` to parse from a field not named after the argument.\neg:\n```python\ndef my_function(\n        uag:from_header(header_field=\"User-Agent\")=None\n)\n```\n\n### from_query_string\nThis binding parses the from the query string and assign the result to the decorated argument.\n\nUse the argument `query_field` to parse from a field not named after the argument.\nUse the argument `as_list` (boolean) to specify weather you want the result as a list.\neg:\n```python\ndef my_function(\n        dryrun:(bool,from_query_string)=False\n)\n```\n<a name=\"oauth-binding-section\" ></a>\n\n### from_Oauth\nThis binding parses Oauth headers and verify the token based on the open id protocol: it will decode the JWT token, contact the issuer and verify it was signed properly. It will assign the decoded token to the decorated argument.\neg:\n```python\nokta = {\n    \"allowed_domains\":config[\"okta_allowed_domains\"],\n    \"client_id\":config[\"okta_client_id\"],\n    \"valid_tokens\": config[\"okta_valid_tokens\"],\n    \"validate_options\": {\"verify_at_hash\": False}\n}\n\ndef my_function(\n        user_auth: from_Oauth(**okta),\n)\n```\n\nNote: this binding can take a deserializer that will transform the oauth value into another object.\n\n<a name=\"deserialization-section\"></a>\n\n## Deserialization, in detail\nDeserialization of inputs can be done in two ways :\n- either specified directly in the binding, via the `deserializer` argument\n  eg: `dryrun:(bool,from_query_string(deserializer=MyDeserializer))`\n- or by linking a deserializer to a specific type: the deserializer will then be used every time this type is deserialized.\n  eg:\n```python\nfrom rest_helper import type_deserializers\ntype_deserializers.type_to_deserializer_tuple_list.append((as_of_date.AsOfDate, as_of_deserializer))\n```\n\n### What can be used as a deserializer\nA deserializer can be any callable that takes exactly one parameter, the raw input, and returns a corresponding object.\n\n### How does the type_deserializers.type_to_deserializer_tuple_list work ?\nThis list is pretty flexible. It contains tuples where the first element should be a type, and the second element either a deserializer callable (see above), or\na tuple where the first element can generate a deserializer based on the decorator itself:\n\neg:\n```python\ntype_to_deserializer_tuple_list = [(bool, lambda x: x is not None and (x == \"\" or x.lower() == \"true\" ))]\ndryrun:(bool,from_query_string)\n```\n\neg:\n```python\ntype_to_deserializer_tuple_list = [(MyDeserializer, lambda x: x is not None and (x == \"\" or x.lower() == \"true\" ))]\ndryrun:(bool,MyDeserializer())\n```\n\neg: we want to deserialize differently based on the decorator's `a` field value. If a is equal to 1 we want to deserialize the int to its value\ntime 2, otherwise we want to deserialize the int to its value plus 1\n```python\ntype_to_deserializer_tuple_list = [(MyDeserializer, (lambda decorator: lambda x:x*2 if decorator.a == 1 else lambda x:x+1,))]\ndryrun:(int,MyDeserializer(a=1))\n```\n\nIt is a bit convoluted, but it allows for integration with various framework such as schematics.\n\nNote: type_to_deserializer_tuple_list is a list in order to take advantage of inheritance. The order matters!\nBoth type based deserializer and instance based deserializer will leverage inheritance, meaning that if you have a deserializer for bool,\nit should be *before* the deserializer for int since bool is a subtype of int.\n\n<a name=\"validation-section\"></a>\n\n## Validation, in detail\nValidation works very much alike deserialization.\n\nValidation of inputs can be done in two ways :\n- either specified directly in the binding, via the `validator` argument\n  eg: `dryrun:(bool,from_query_string(validator=MyValidator))`\n- or by linking a validator to a specific type: the validator will then be used every time this type is validated.\n  eg:\n```python\nfrom rest_helper import validators\nvalidators.type_to_validator_tuple_list.append((as_of_date.AsOfDate, as_of_validator))\n```\n\n### How is an input validated\nAn input will be validated twice : a first time before deserialization, and a second time after deserialization.\n\n### What can be used as a validator\nA validator can be any callable taking one argument, the object to be validated, and one optional argument `post`. `post` indicates whether the validator\nis dealing with pre or post deserialization validation.\nA validator must return a tuple where the first element is a boolean indicating whether or not validation was successful, and the second argument should be the\nreason why the object is invalid, in case validation was not successful. The reason will be used to display a meaningful message to the user.\n\n### How does the validators.type_to_validator_tuple_list work ?\nPlease refer to the \"How does the type_deserializers.type_to_deserializer_tuple_list work ?\" section above work as the validators.type_to_validator_tuple_list\nwork exactly the same.\n\n### Provided deserializers and validators\nBy default, the following deserializers are provided:\n- bool\n- int\n- float\n- Decimal\n- str\n- datetime.datetime\n- Model: for schematics\n- types.BaseType: for schematics\n\nBy default, the following validators are provided:\n- Model: for schematics\n- types.BaseType: for schematics\n\n<a name=\"swagger-section\"></a>\n\n## Automated custom swagger page documentation\n\nUsing rest-helpers, you get automated documentation based on routes and bindings. If you use routes and bindings on your entry\npoint, they will be documented in a swagger document and try-able from a swagger UI page.\n\nBecause a lot of APIs will eventually need to integrate with okta, we have added okta integration directly in the swagger UI:\npeople can authenticate with their username and password from the swagger ui without having to generate a token on their own.\n\nNote: you can \"hide\" a route by setting `doc=False` in the route decorator arguments.\n\n### What is a \"custom swagger ui\"? why ?\nThere are two reasons for going with a custom swagger UI:\n- the classic one looks very old and is not the best UX\n- it gives us more control which is useful when adding functionalities such as okta integration, or various other UX improvements.\n\n### How to enable swagger and the swagger UI ?\n\nThe following code snippet will add a swagger ui at `{host}/{basepath}/` and a swagger document at `{host}/{basepath}/swagger.json`\n\n```python\nswagger_service_doc = {\n    \"info\":{\n        \"description\": \"This is the service description.\",\n        \"version\": \"3.0.0\",\n        \"title\": \"My Service\",\n        \"contact\":{\n            \"email\": \"cicdteam@abc.com\"\n        }\n    },\n    \"host\": app.config[\"current_host\"],\n    \"schemes\": [app.config[\"current_scheme\"]],\n    \"basePath\": \"/api\",\n    \"tags\":[{\"name\": \"my_service\"}]\n}\nokta_config= {\n    \"baseUrl\":app.config[\"okta_base_url\"],\n    \"clientId\": app.config[\"okta_client_id\"],\n    \"redirectUri\": app.config[\"okta_redirect_url\"]\n}\nflask.add_default_swagger_routes(app, swagger_service_doc, okta=okta_config)\n```\n### response type\nResponse types are inferred from the route type : it is assumed that a get_resource route will return the associated resource,\nand that a get_all_resource_route will return an array of associated resource (following the json_api spec). Rest-helper *does not8 (yet) automatically detect the response schema, so you *must* document the object type that you are returning. To do so, use the `@swagger.swagger_object` decorator and document the object using yaml syntax.\n\neg:\n```python\n@swagger.swagger_object\nclass LibraryResource(Resource):\n    \"\"\"\n    Swagger jsonapi_response:\n        name:\n            type: \"string\"\n            example: \"service_name\"\n        version_pins:\n            type: dictionary\n            example: {\"shared-version://my_shared_service\": 1.master.1}\n    end swagger\n    \"\"\"\n```\n\nYou do not need to document the json_api part of the response, only the object itself.\n\n*Why not automate this process ?*\nOutside of very specific case, we believe it is next to impossible to automate *good* documentation. Good documentation\nimplies proper examples, explanations etc. We might however provide a *basic* documentation in the future, just like we do\nwith parameters\n\n\n### How to customize a route\n\nThe automated swagger UI is a \"best effort\". There will be some case where you will want to modify what has been\nautomatically created. To do so, rest-helper relies on method documentation, just like we did with Resource object.\n\n5 keywords are used to achieve different goals:\n- doc: gives you a way to update (see the python update function) the entire swagger associated swagger path dictionary. Can be used on route method documentation.\n- parameters: gives you a way to update (see the python update function) a specific parameter dictionary, or to not document it by passing null. eg:\n```\nThis will ensure the user-agent parameter is not documented\nSwagger parameters:\n    User-Agent: null\n```\nCan be used on route method documentation\n- extra_definition: this is to be used to add extra object definitions (not just json_api object, any kind), it is typically useful when you need subobject to defin complex objects. This can be used either in route method documentation or response object documentation.\n- jsonapi_response: this is to be used only to document response object (see previous section)\n- augment_default: this is the most complex and powerful one : its intent is to provide a way to augment the default dictionary *and lists*. It can be applied to either route method or response object and work as follow :\n- - with regular syntax it works like the python update method but also updates nested dictionaries\n- - you can also update a speific index in a list\n- - you can also append to a list with\n- - you can also delete from a list by index or by elem\nTo understand how augment default works, it is best to look at the corresponding tests in the test_swagger.py file\n\nIn the documentation of a route method, use the following to customize its swagger doc:\n```\nSwagger <keyword>:\n<yaml>\nend swagger\n```\n\neg:\n```python\n@routes.operation_resource_route(platform_blueprint, PlatformResource, operation_name=\"accrete\",versionner=platform_versionner.AccretePlatformVersionner, exception_handler=exception_handler.common_exception_handler)\ndef accrete_platform(\n        platform_name,\n        asof:(as_of_date.AsOfDate,from_query_string)=None,\n        uag:from_header(header_field=\"User-Agent\")=None,\n        include_platform_source:(bool, from_query_string)=False,\n        add_hoc_mixins:(list, from_query_string(as_list=True))= []\n    ):\n    \"\"\"\n    Swagger doc:\n        description: \"Display the platform taking in account the inheritance tree.\"\n    end swagger\n\n    Swagger parameters:\n        User-Agent: null\n    end swagger\n\n    Swagger augment_default:\n    parameters>-: [\"[2]\"]\n\n    Arguments:\n        platform_name {str} -- The name of the platform to be accreted.\n    \"\"\"\n\n```\n\n<a name=\"serverside-filtering\"></a>\n\n## Server side filtering\n\nWhen a client is interested only in a very specific part of the response, sending back an entire response is a waste of resource: serializing it, putting it on the network and deserializing it are all significant costs that can be avoided. Specialized libraries like GraphQL do that extremly well but can be heavy to implement. Rest-helper implement a poor man's server side filtering via the json_path query string argument supported on all route methods that return a Response json_api object. While simplistic in nature, it has proven to fit most basic needs.\n\nIt supports key name, list index, `*` (foreach) segments, and filtered foreach segments .\n\neg:\n```\nGET /resources/name\n>>>\n{\n    data:[\n        {\n            \"name\"=\"name_1\"\n            \"value\"={\"a\":1,\"b\":2}\n        },\n        {\n            \"name\"=\"name_2\"\n            \"value\"={\"a\":3,\"b\":4}\n        },\n    ]\n}\n\nGET /resources/name?json_path=/0/value/a\n>>>\n{\n    data:1\n}\n\nGET /resources/name?json_path=/*/value/b\n>>>\n{\n    data:[2,4]\n}\n\nGET /resources/name?json_path=/*:value>a~=(3|4)/value/b\n>>>\n{\n    data:[4]\n}\n```\n\n### How does array filtering work\nIn the last example, we used array filtering to select only some elements of the array.\nWhen traversing an array with `*` you can specify a filter:\n`*:path>to>elements>inside>the>array{operator}{value}`\n\ncurrently the follwing operators are supported:\n- `==` for equality\n- `!=` for different\n- `~=` for regexes\n\nThis is very basic and does not handle cases where the path does not exist on some elements.\n\n<a name=\"automatic-paging-section\"></a>\n\n## Automatic paging\n\nSimilarly to resource filtering, paging is a common use case: returning arrays with thousands of elements is usually a waste of resource. Rest-helpers supports automatic paging for route methods returning a Response object. Paging is based on a page number and a page size. The page number comes from the `page` query string argument. The page size comes from :\n1. the `page_size` query string argument if present\n2. the `page_size` field used in the Response constructor if the query string argument is not present\n3. the `page_size` field used in the route decorator if none of the above is present.\n\nNote: paging will not happen if page_size is not provided somehow.\n\n<a name=\"json-api-section\"></a>\n\n## JSON API responses\n\nRest-helpers offers support for JSON API compliant responses. More details about JSON API here: http://jsonapi.org. This will help to provide standard response schema making service interoperability easier.\n\n### Resource base class\nTo take advantage of the JSON API spec implementation, your resource model object should simply inherit from the `Resource` class and use the super constructor.\n\nThe resource constructor accepts optional arguments to fully support the JSON API spec.\n```python\nclass Resource(object):\n    def __init__(self, resource_type, resource_name, relationships=None, links=None, meta=None, parent=None)\n```\n\n- `relationships` should be a dictionary of related resources, keyed by name\n- `links` should be a dictionaty of related links, keyed by name\n- `meta` can be any object loosely related to the resource\n- `parent` is used in the case of a nested resource\n\nA resource is identified uniquely by the field id constructed as follows:\n```\nid = /grand_parent_type_plural/grand_parent_resource_name/parent_type_plural/parent_name/type_plural/name\ntype = /grand_parent_type_plural/parent_type_plural/type_plural\n```\nA resource can be nested under a parent resource where it makes sense.\nEg:\n```\nid = /authors/mtwain/books/tomsawyer\ntype = /authors/books\n```\ncall: `Resource(\"books\",\"tomsawyer\",parent=MTwainResourceObject)`\n\n### Standard response\nStandard responses are built on top of the JSON API resource and are defined in the `responses` module.\n```python\nresponses.ok(my_resource)\nresponse.created(just_created_resource)\nresponse.bad_request(Exception(\"The body of the request is incorrect\"))\n```\n\n<a name=\"framework-agnostic-section\"></a>\n\n## Framework agnostic\n\nRest-helper attempts to be framework agnostic: we currently support aiohttp and flask and could support any framework that support the ~100 lines adapter created for aiohttp and flask.\n\n### How does it work\nRest helpers implement a combinaition or adapter pattern and proxy pattern. For both flask and aiohttp, we created an adapter\nimplementing the interface defined in `framework_adapter.py`. The rest of the code does not use any framework specific logic, but takes a framework adapter as the first argument of most methods. proxies are used to make this transparent to the end user: when importing the `response` module from `rest_helpers.flask` you actually proxy `rest_helpers.responses` but inject a framework adapter in every call.\n\nThis approach makes the pattern easily extensible, roughly a 100 lines are likely needed to onboard a new framework.\n\n<a name=\"error-messages-section\"></a>\n\n## Meaningful error message\n\nOne of the philosophy behind rest-helper is to automate error messages as much as possible in order to provide meaningful error messages. As much as possible, error case lead to error message that tell the user how to correct it. We try to not respond with a blank 400 or 500 but explain in detail what failed.\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/WillFr/rest-helpers", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "minioc", "package_url": "https://pypi.org/project/minioc/", "platform": "", "project_url": "https://pypi.org/project/minioc/", "project_urls": {"Homepage": "https://github.com/WillFr/rest-helpers"}, "release_url": "https://pypi.org/project/minioc/1.2.1/", "requires_dist": ["setuptools (>=0.5)"], "requires_python": "", "summary": "A mini IOC framework", "version": "1.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            [![Build Status](https://travis-ci.com/WillFr/rest-helpers.svg?branch=master)](https://travis-ci.com/WillFr/rest-helpers)<br><br>[![Coverage Status](https://coveralls.io/repos/github/WillFr/rest-helpers/badge.svg?branch=master)](https://coveralls.io/github/WillFr/rest-helpers?branch=master)<br><br># rest-helpers<br><br>## What is Rest-Helpers<br>Rest-Helpers is a python 3 library that helps you build REST applications quickly, and in a consistent way.<br>Overall it provides the following:<br>- [automated and consistent route creation via decorator](#route-decorator-section)<br>- [REST API versionner to handle various version your API](#versioner-section)<br>- [non verbose bindings to parse inputs from query string, body, headers ... including deserialization and validation](#binding-section)<br>- [Oauth binding: adding auth to a route is as easy as adding the binding](#oauth-binding-section)<br>- binding [validators](#validation-section) and [deserializers](#deserialization-section)<br>- [Custom autogenerated swagger UI, fully customizable via method documentation, and integrated with okta](#swagger-section)<br>- [Server side filtering via json_path and json_filter query string arguments](#serverside-filtering)<br>- [automatic paging for long response payload](#automatic-paging-section)<br>- [framework agnostic: it currently supports flask and aiohttp and is easy to extend](#framework-agnostic-section)<br>- [JsonApi compliant response type](#json-api-section)<br>- [Meaningful default error messages](#error-messages-section)<br><br>eg: the following code snippet will create an appropriate route, document it in swagger and inject your custom modifications, take care of input binding and return meaningful responses if they are not proper, take care of exception, take care of versionning, handle server side filtering and paging, and return a proper json_api response.<br>```python<br>@swagger.swagger_object<br>class PlatformResource(Resource):<br>    \"\"\"<br>    Swagger jsonapi_response:<br>        name:<br>            type: \"string\"<br>            example: \"val_300\"<br>        parent:<br>            type: \"string\"<br>            example: \"candidate_ready\"<br>    \"\"\"<br><br>    resource_type = \"/worlds/platforms\"<br><br>    def __init__(self, **kwargs):<br>        self.__dict__.update(kwargs)<br><br>@routes.get_all_resources_route(platform_blueprint, PlatformResource, versionner=platform_versionner.AccretePlatformVersionner, exception_handler=exception_handler.common_exception_handler)<br>def accrete_platform(<br>        world_name,<br>        asof:(as_of_date.AsOfDate,from_query_string)=None,<br>        uag:from_header(header_field=\"User-Agent\")=None,<br>        include_platform_source:(bool, from_query_string)=False,<br>        add_hoc_mixins:(list, from_query_string(as_list=True))= []<br>    ):<br>    \"\"\"<br>    Swagger doc:<br>        description: \"Display the platform taking in account the inheritance tree.\"<br>    end swagger<br><br>    Swagger parameters:<br>        User-Agent: null<br>    end swagger<br><br>    Swagger augment_default:<br>    parameters&gt;-: [\"[2]\"]<br><br>    Arguments:<br>        world_name {str} -- The name of the world to be accreted.<br>    \"\"\"<br>    return responses.ok(Platform(\"my_platform\"))<br><br>```<br>&lt;a name=\"route-decorator-section\"&gt;&lt;/a&gt;<br><br>## Automated and consistent route creation via decorator<br>Rest-Helper follow simple routing principles:<br>- GET gets you a resource or an array of resource, and you can reuse the response payload for a PUT request in order to modify the resource<br>- Everything else is an 'operation' and therefore uses the POST verb.<br><br>Several routing decorators are provided<br><br>### route decorator<br>Eg:<br>```python<br>from rest_helper.flask.routes import routes<br><br><br>@route(\"/abc\", options={\"methods\": [\"GET\", \"POST\"], doc=True, versionner=None, exception_handler=None)<br>def my_function():<br>    return response.ok()<br>```<br><br>This is the base decorator. It does not impose any REST related constraint and therefore should be used sparsely. It allows you to define any route.<br>It takes several *optional* arguments, that are going to be similar to other routes:<br>- doc : {bool} this indicates whether or not this route should be documented in swagger.<br>- versionner : {versionnerType} this versionner is going to modify the route as defined in the versionner, more on this in the versionner section.<br>- exception_handler : {exceptionHandlerType} this is going to define how exceptions should be handled.<br><br>### resource based route decorator<br>Eg:<br>```python<br>from rest_helper.flask.routes import routes<br>from rest_helper.jsonapi_objects import Resource<br><br>class HostResource(Resource):<br>    resource_type = \"/clusters/hosts\"<br><br>@routes.get_resource_route(HostResource, doc=True, versionner=None, exception_handler=None)<br>def my_function(cluster_name, host_name):<br>    return response.ok()<br>```<br><br>Resource decorator takes a resource class as a first argument and create routes based on that resources. They will autogenerate<br>the routing scheme based on the resource_type field that must be present in every class inheriting from Resource.<br><br>The route scheme is generated based on the verb and can be modified by a versionner. Eg: a get_resource route:<br>`/resource_type/resource_name/sub_resource_type/sub_resource_name`<br><br>In the example above it will lead to:<br>`/clusters/cluster_abc/hosts/host_a`<br><br>With a url_root_versioner it would become:<br>`/api_version/resource_type/resource_name/sub_resource_type/sub_resource_name`<br><br>The resource type and sub resource type are extracted from the resource_type field that must be present in every class inheriting from Resource.<br><br>Recomandation: resource_type should be plural.<br><br>This decorator will automatically bind resource names to argument named after de-pluralized resource type:<br>type: clusters =&gt; cluster_name<br>type: hosts =&gt; host_name<br>type: libraries =&gt; library_name<br><br>If an argument named resource_id is present, Rest-helpers will bind the resource_id to it.<br>In our example above:<br>resource_id =&gt; /clusters/cluster_abc/hosts/host_a<br><br>A resource id uniquely identifies a resource in the entire API: there must be only one host named host_a in a cluster named \"cluster_abc\".<br>A resource name uniquely identifies a resource within the scope of their parent: there can be a host named host_a in another cluster not named \"cluster_abc\".<br><br>This is true for all resource based routing decorators.<br><br>### get_resource_route decorator<br>Eg:<br>```python<br>from rest_helper.flask.routes import routes<br>from rest_helper.jsonapi_objects import Resource<br><br>class HostResource(Resource):<br>    resource_type = \"/clusters/hosts\"<br><br>@routes.get_resource_route(HostResource, doc=True, versionner=None, exception_handler=None)<br>def my_function(cluster_name, host_name):<br>    return response.ok()<br>```<br>This generates a route to get a single resource:<br>`GET /resource_type/resource_name/sub_resource_type/sub_resource_name`<br><br>In the example above it will lead to:<br>`GET /clusters/cluster_abc/hosts/host_a`<br><br>With a url_root_versioner it would become:<br>`GET /api_version/resource_type/resource_name/sub_resource_type/sub_resource_name`<br><br>### get_all_resources_route decorator<br>Eg:<br>```python<br>from rest_helper.flask.routes import routes<br>from rest_helper.jsonapi_objects import Resource<br><br>class HostResource(Resource):<br>    resource_type = \"/clusters/hosts\"<br><br>@routes.get_all_resources_route(HostResource, doc=True, versionner=None, page_size=10, exception_handler=None)<br>def my_function(cluster_name):<br>    return response.ok()<br>```<br>This generates a route to get a list of all resource under a parent (or at the root):<br>`GET /resource_type/resource_name/sub_resource_type/`<br><br>In the example above it will lead to:<br>`GET /clusters/cluster_abc/hosts/`<br><br>With a url_root_versioner it would become:<br>`GET /api_version/resource_type/resource_name/sub_resource_type/`<br><br>This route automatically handle the page_size *optional* argument (infinite by default) if used<br>in combination with the Rest-helpers response types. The page_size argument of the route indicate<br>the default value of the page size and can be overriden by a query string argument `page_size`.<br><br>In addition, the resouce_id argument will be bound to the parent resource:<br>in the example above: resource_id =&gt; /clusters/cluster_abc<br><br>### put_resource_route decorator<br>Eg:<br>```python<br>from rest_helper.flask.routes import routes<br>from rest_helper.jsonapi_objects import Resource<br><br>class HostResource(Resource):<br>    resource_type = \"/clusters/hosts\"<br><br>@routes.put_resource_route(HostResource, doc=True, versionner=None, exception_handler=None)<br>def my_function(cluster_name, host_name):<br>    return response.ok()<br>```<br>This generates a route to PUT a resource in order to modify it:<br>`PUT /resource_type/resource_name/sub_resource_type/sub_resource_name`<br><br>In the example above it will lead to:<br>`PUT /clusters/cluster_abc/hosts/sub_resource_name`<br><br>With a url_root_versioner it would become:<br>`PUT /api_version/resource_type/resource_name/sub_resource_type/sub_resource_name`<br><br>put_resource_route is intended to create or modify a resource in an idempotent way.<br><br>resource_id is bound similarly to get_resource_route.<br><br><br>### patch_resource_route decorator<br>Eg:<br>```python<br>from rest_helper.flask.routes import routes<br>from rest_helper.jsonapi_objects import Resource<br><br>class HostResource(Resource):<br>    resource_type = \"/clusters/hosts\"<br><br>@routes.patch_resource_route(HostResource, doc=True, versionner=None, exception_handler=None)<br>def my_function(cluster_name, host_name):<br>    return response.ok()<br>```<br>This generates a route to PATCH a resource in order to modify it:<br>`PATCH /resource_type/resource_name/sub_resource_type/sub_resource_name`<br><br>In the example above it will lead to:<br>`PATCH /clusters/cluster_abc/hosts/sub_resource_name`<br><br>With a url_root_versioner it would become:<br>`PATCH /api_version/resource_type/resource_name/sub_resource_type/sub_resource_name`<br><br>patch_resource_route is intended to partially update resource in an idempotent way.<br><br>resource_id is bound similarly to get_resource_route.<br><br><br><br>### operation_resource_route<br>Eg:<br>```python<br>from rest_helper.flask.routes import routes<br>from rest_helper.jsonapi_objects import Resource<br><br>class HostResource(Resource):<br>    resource_type = \"/clusters/hosts\"<br><br>@routes.operation_resource_route(HostResource, operation_name=\"transform\", doc=True, versionner=None, exception_handler=None)<br>def my_function(cluster_name, host_name):<br>    return response.ok()<br>```<br>This generates a route to PUT a resource in order to modify it:<br>`POST /resource_type/resource_name/sub_resource_type/sub_resource_name/transform`<br><br>In the example above it will lead to:<br>`POST /clusters/cluster_abc/hosts/sub_resource_name/transform`<br><br>With a url_root_versioner it would become:<br>`POST /api_version/resource_type/resource_name/sub_resource_type/sub_resource_name/transform`<br><br>Operation routes transform a resource. It can be done in a readonly way, for example a special view of the resource, or<br>in a permanent write way where the transformation is applied permanently. Operations can also be used for long running operation, starting a VM for instance.<br><br>resource_id is bound similarly to get_resource_route.<br><br>### group_operation_resource_route<br>Eg:<br>```python<br>from rest_helper.flask.routes import routes<br>from rest_helper.jsonapi_objects import Resource<br><br>class HostResource(Resource):<br>    resource_type = \"/clusters/hosts\"<br><br>@routes.group_operation_resource_route(HostResource, operation_name=\"transform\", doc=True, versionner=None, exception_handler=None)<br>def my_function(cluster_name):<br>    return response.ok()<br>```<br>This generates a route to PUT a resource in order to modify it:<br>`POST /resource_type/resource_name/sub_resource_type/transform`<br><br>In the example above it will lead to:<br>`POST /clusters/cluster_abc/hosts/transform`<br><br>With a url_root_versioner it would become:<br>`POST /api_version/resource_type/resource_name/sub_resource_type/transform`<br><br>Group operations are similar to operations, except they are applied to the list of resources returned by the get_all_resources_route.<br>resource_id is bound similarly to get_all_resources_route.<br><br>### delete_resource_route decorator<br>Eg:<br>```python<br>from rest_helper.flask.routes import routes<br>from rest_helper.jsonapi_objects import Resource<br><br>class HostResource(Resource):<br>    resource_type = \"/clusters/hosts\"<br><br>@routes.put_resource_route(HostResource, doc=True, versionner=None, exception_handler=None)<br>def my_function(cluster_name, host_name):<br>    return response.ok()<br>```<br>This generates a route to PUT a resource in order to modify it:<br>`DELETE /resource_type/resource_name/sub_resource_type/sub_resource_name`<br><br>In the example above it will lead to:<br>`DELETE /clusters/cluster_abc/hosts/sub_resource_name`<br><br>With a url_root_versioner it would become:<br>`DELETE /api_version/resource_type/resource_name/sub_resource_type/sub_resource_name`<br><br>Delete operation are to be used to delete a resource permanently.<br>resource_id is bound similarly to get_resource_route.<br><br>&lt;a name=\"versioner-section\"&gt;&lt;/a&gt;<br><br>## Versioner<br><br>The versionner allow you to support former versions of your api. It provides several hooks to transform a request and a<br>response to bring it to a certain version.<br><br>Eg: My service support v1 and v2, but internally, all the code supports only latest, which is v2.<br>A request entering via a route with a versionner will follow this path :<br>request at v1 -&gt; route -&gt; versionner: transforms a v1 request into a v2 request -&gt; route handler|<br>response at v1 &lt;- versionner: transforms a v2 response into a v1 response &lt;- route &lt;-|<br><br>The service author defines the logic to transform a v1 request into a v2 request.<br><br>The following hooks are provided:<br>- body hook: will take the current request body and return a transformed version<br>- body dict hook: similar to body, but act on the JSON deserialized dict body<br>- headers hook: will take the request headers and return a transformed version<br>- query string args: will take the request query string and return a transformed version<br>- response: will take the entire response object and return a transformed version<br>- response body dict: will take the response body dictionary and return a transformed version<br><br>### How to define a versioner:<br>Versioners should inherit from the BaseVersioner class.<br><br>They should:<br>- define a static methos `version_route` that takes a route objet in parameter and inject the version into it<br>- define inner class named after supported versions and containing hooks definition.<br>Eg:<br>```python<br>class MyVersionner(versioning.BaseVersionner):<br>    @staticmethod<br>    def version_route(route):<br>        route.rule=\"/&lt;rest_helper_version&gt;\"+route.rule<br><br>    class v2:<br>        pass<br><br>    class v1:<br>        def response_body_dict(self, response):<br>            v2_response[\"Myfield\"] = \"hardcoded back compatible field\"<br><br>            return v2_response<br>```<br><br>Note that you only have to add the hooks that are useful to you.<br>Complete list of hook:<br>```python<br>def body(self, body):<br>def body_dict(self, body):<br>def response(self, response)<br>def headers(self, headers)<br>def query_string_args(self, query_string_args)<br>def response_body_dict(self, response_body_dict)<br>```<br><br>### Url versioner<br>The url versionner is a commonly used versioner injecting the version at the root of the route:<br>```python<br>class UrlRootVersionner(BaseVersionner):<br>    @staticmethod<br>    def version_route(route):<br>        route.rule=\"/&lt;rest_helper_version&gt;\"+route.rule<br>```<br><br>By inheriting from it, you only have to define classes representing each version.<br><br><br>&lt;a name=\"bindings-section\"&gt;&lt;/a&gt;<br><br>## Exception handling<br>Routes all provide an exception_handler field that catches exceptions and respond appropriately.<br><br>An exeption handler can be any callable taking exactly one parameter, the exception, and return a response.<br>A basic exception handler is provided and will be used by default.<br><br>eg:<br>```python<br>def common_exception_handler(ex):<br>    if isinstance(ex, rest_exceptions.NotFoundException):<br>        return responses.not_found()<br>    elif isinstance(ex, storage.PlatformNotFound):<br>        return responses.not_found(\"Platform not found.\")<br>    elif isinstance(ex, exception.ExternalExceptionBase) or isinstance(ex, rest_exceptions.InvalidDataException):<br>        message = \"\".join(ex.args).replace(\"\\\\n\", \"\\n\")<br>        return responses.bad_request(message)<br>    elif isinstance(ex, exception.TransactionCheckFailedException):<br>        return responses.error(409, \"Conflict\", \"\"\"<br>        The client expected the resource ({}) version to be {} but is actually is {}: the latest version<br>        of the resource must be used to modify it. Get the resource again before attempting to modify it.\"\"\".format(ex.resource_id, ex.sha_was_expected_to_be, ex.actual_sha))<br>    else:<br>        return responses.base_exception_handler(ex)<br>```<br>## Not so verbose bindings<br><br>Rest-helper bindings leverage python3 syntax to be as light and close to their target as possible.<br>Eg:<br>```python<br>def get_platform(<br>        platform_name,<br>        asof:(as_of_date.AsOfDate,from_query_string),<br>        uag:from_header(header_field=\"User-Agent\")=None<br>    ):<br>```<br><br>In the above example, platform_name would come from the route, asof would come from the query string and is to be deserialized into an `as_of_date.AsOfDate`<br>object, uag come from the request header named \"User-Agent\". Both asof and uag are optional, uag is optional because it has a default value but asof is not:<br>not passing the asof query string argument will result into a properly formatted 400 response.<br><br>Argument decorator can be either a binding or a tuple containing (type, binding). When a type is specified as the first tuple element, it will be used to<br>deserialize the value properly and return an appropriate 400 errors if deserialization fails. Custom types are supported:<br><br>```python<br>from rest_helper import type_deserializers<br>type_deserializers.type_to_deserializer_mapping[as_of_date.AsOfDate] = bindings.as_of_deserializer<br>```<br><br>Each binding detailed further can be customized via several optional arguments, but default value aim to improve readability, in all case, the foreign field (header_field for instance) will be defaulted to the variable name :<br>```python<br>asof:(as_of_date.AsOfDate,from_query_string),<br>```<br>is equivalent to<br>```python<br>asof:(as_of_date.AsOfDate,from_query_string(query_field=\"asof\")),<br>```<br><br>You get bindings for free if you use a route decorator on top of your function. If you want to use only bindings without a route decorator,<br>you need to decorate your function with `bind_hints`.<br><br>Note: all bindings are available as individual decorator as well. If that is your usage, do not forget to specify the field value.<br><br>### route bindings<br>As mentionned in the route section some arguments are automatically bound from the url path to predictable argument_name. This is based on the resource type: for a resource typed as `/worlds/platforms`:<br>- a get_resource_route expect a world_name argument and a platform_name argument parsed from the uri (notice world was unpluralized)<br>- a get_all_resource_route expects only a world_name argument because it serves *all* platforms under a specific world.<br>- operation_resource_route, put_resource_route, delete_resource_route, patch_resource_route will behave like get_resource_route<br>- group_operation_resource_route will behave like get_all_resources_route<br><br>### base_binder<br>This is not to be used directly but can be extended to create your own binding.<br><br>```python<br>base_binder(field=None, validator=None, deserializer=None, type=None)<br>```<br><br>`field` is name of the variable to be bound. When the value is extracted it is going to be assigned to a function argument named after `field`<br>`validator` offers a simple way to validate the data. If left to `None`, and if a type is specified, a default type validator will be used. When the<br>validation fails, the user receives a properly formatted 400 error.<br>Deserializer will be used to deserialize the data.<br>Type is a way to infer deserialization logic from the type, more on that on the deserializer section. You cannot specify both type and deserializer.<br><br>Important note: type is automatically infered from the decorator. Since validator and deserializer are generally infered from the type, you typically do not need to specify them. Field is also infered from the variable name. As a result, using the binding looks like :<br>```python<br>def my_function(my_arg: (bool, from_query_string))<br>```<br>This would leverage provided deserializer and validator to properly deserializing boolean from the query string. All of the following would result in `my_arg` being `True`:<br>- /myroute/?my_arg<br>- /myroute/?my_arg=True<br>- /myroute/?my_arg=TRUE<br>- /myroute/?my_arg=true<br><br>### from_json_body<br>This binding parses the request body as JSON and assign the result to the decorated argument.<br><br>eg:<br>```python<br>def my_function(<br>        data:from_json_body<br>)<br>```<br><br>### field_from_json_body<br>This binding parses the request body as JSON, look for a specific field, and assign the result to the decorated argument.<br><br>Use the argument `json_field` to specify the path to be extracted.<br>eg:<br>```python<br>def my_function(<br>        data:field_from_json_body(json_field=\"/data/attributes/my_field\")<br>)<br>```<br><br>### from_header<br>This binding parses the specified header and assign the result to the decorated argument.<br><br>Use the argument `header_field` to parse from a field not named after the argument.<br>eg:<br>```python<br>def my_function(<br>        uag:from_header(header_field=\"User-Agent\")=None<br>)<br>```<br><br>### from_query_string<br>This binding parses the from the query string and assign the result to the decorated argument.<br><br>Use the argument `query_field` to parse from a field not named after the argument.<br>Use the argument `as_list` (boolean) to specify weather you want the result as a list.<br>eg:<br>```python<br>def my_function(<br>        dryrun:(bool,from_query_string)=False<br>)<br>```<br>&lt;a name=\"oauth-binding-section\" &gt;&lt;/a&gt;<br><br>### from_Oauth<br>This binding parses Oauth headers and verify the token based on the open id protocol: it will decode the JWT token, contact the issuer and verify it was signed properly. It will assign the decoded token to the decorated argument.<br>eg:<br>```python<br>okta = {<br>    \"allowed_domains\":config[\"okta_allowed_domains\"],<br>    \"client_id\":config[\"okta_client_id\"],<br>    \"valid_tokens\": config[\"okta_valid_tokens\"],<br>    \"validate_options\": {\"verify_at_hash\": False}<br>}<br><br>def my_function(<br>        user_auth: from_Oauth(**okta),<br>)<br>```<br><br>Note: this binding can take a deserializer that will transform the oauth value into another object.<br><br>&lt;a name=\"deserialization-section\"&gt;&lt;/a&gt;<br><br>## Deserialization, in detail<br>Deserialization of inputs can be done in two ways :<br>- either specified directly in the binding, via the `deserializer` argument<br>  eg: `dryrun:(bool,from_query_string(deserializer=MyDeserializer))`<br>- or by linking a deserializer to a specific type: the deserializer will then be used every time this type is deserialized.<br>  eg:<br>```python<br>from rest_helper import type_deserializers<br>type_deserializers.type_to_deserializer_tuple_list.append((as_of_date.AsOfDate, as_of_deserializer))<br>```<br><br>### What can be used as a deserializer<br>A deserializer can be any callable that takes exactly one parameter, the raw input, and returns a corresponding object.<br><br>### How does the type_deserializers.type_to_deserializer_tuple_list work ?<br>This list is pretty flexible. It contains tuples where the first element should be a type, and the second element either a deserializer callable (see above), or<br>a tuple where the first element can generate a deserializer based on the decorator itself:<br><br>eg:<br>```python<br>type_to_deserializer_tuple_list = [(bool, lambda x: x is not None and (x == \"\" or x.lower() == \"true\" ))]<br>dryrun:(bool,from_query_string)<br>```<br><br>eg:<br>```python<br>type_to_deserializer_tuple_list = [(MyDeserializer, lambda x: x is not None and (x == \"\" or x.lower() == \"true\" ))]<br>dryrun:(bool,MyDeserializer())<br>```<br><br>eg: we want to deserialize differently based on the decorator's `a` field value. If a is equal to 1 we want to deserialize the int to its value<br>time 2, otherwise we want to deserialize the int to its value plus 1<br>```python<br>type_to_deserializer_tuple_list = [(MyDeserializer, (lambda decorator: lambda x:x*2 if decorator.a == 1 else lambda x:x+1,))]<br>dryrun:(int,MyDeserializer(a=1))<br>```<br><br>It is a bit convoluted, but it allows for integration with various framework such as schematics.<br><br>Note: type_to_deserializer_tuple_list is a list in order to take advantage of inheritance. The order matters!<br>Both type based deserializer and instance based deserializer will leverage inheritance, meaning that if you have a deserializer for bool,<br>it should be *before* the deserializer for int since bool is a subtype of int.<br><br>&lt;a name=\"validation-section\"&gt;&lt;/a&gt;<br><br>## Validation, in detail<br>Validation works very much alike deserialization.<br><br>Validation of inputs can be done in two ways :<br>- either specified directly in the binding, via the `validator` argument<br>  eg: `dryrun:(bool,from_query_string(validator=MyValidator))`<br>- or by linking a validator to a specific type: the validator will then be used every time this type is validated.<br>  eg:<br>```python<br>from rest_helper import validators<br>validators.type_to_validator_tuple_list.append((as_of_date.AsOfDate, as_of_validator))<br>```<br><br>### How is an input validated<br>An input will be validated twice : a first time before deserialization, and a second time after deserialization.<br><br>### What can be used as a validator<br>A validator can be any callable taking one argument, the object to be validated, and one optional argument `post`. `post` indicates whether the validator<br>is dealing with pre or post deserialization validation.<br>A validator must return a tuple where the first element is a boolean indicating whether or not validation was successful, and the second argument should be the<br>reason why the object is invalid, in case validation was not successful. The reason will be used to display a meaningful message to the user.<br><br>### How does the validators.type_to_validator_tuple_list work ?<br>Please refer to the \"How does the type_deserializers.type_to_deserializer_tuple_list work ?\" section above work as the validators.type_to_validator_tuple_list<br>work exactly the same.<br><br>### Provided deserializers and validators<br>By default, the following deserializers are provided:<br>- bool<br>- int<br>- float<br>- Decimal<br>- str<br>- datetime.datetime<br>- Model: for schematics<br>- types.BaseType: for schematics<br><br>By default, the following validators are provided:<br>- Model: for schematics<br>- types.BaseType: for schematics<br><br>&lt;a name=\"swagger-section\"&gt;&lt;/a&gt;<br><br>## Automated custom swagger page documentation<br><br>Using rest-helpers, you get automated documentation based on routes and bindings. If you use routes and bindings on your entry<br>point, they will be documented in a swagger document and try-able from a swagger UI page.<br><br>Because a lot of APIs will eventually need to integrate with okta, we have added okta integration directly in the swagger UI:<br>people can authenticate with their username and password from the swagger ui without having to generate a token on their own.<br><br>Note: you can \"hide\" a route by setting `doc=False` in the route decorator arguments.<br><br>### What is a \"custom swagger ui\"? why ?<br>There are two reasons for going with a custom swagger UI:<br>- the classic one looks very old and is not the best UX<br>- it gives us more control which is useful when adding functionalities such as okta integration, or various other UX improvements.<br><br>### How to enable swagger and the swagger UI ?<br><br>The following code snippet will add a swagger ui at `{host}/{basepath}/` and a swagger document at `{host}/{basepath}/swagger.json`<br><br>```python<br>swagger_service_doc = {<br>    \"info\":{<br>        \"description\": \"This is the service description.\",<br>        \"version\": \"3.0.0\",<br>        \"title\": \"My Service\",<br>        \"contact\":{<br>            \"email\": \"cicdteam@abc.com\"<br>        }<br>    },<br>    \"host\": app.config[\"current_host\"],<br>    \"schemes\": [app.config[\"current_scheme\"]],<br>    \"basePath\": \"/api\",<br>    \"tags\":[{\"name\": \"my_service\"}]<br>}<br>okta_config= {<br>    \"baseUrl\":app.config[\"okta_base_url\"],<br>    \"clientId\": app.config[\"okta_client_id\"],<br>    \"redirectUri\": app.config[\"okta_redirect_url\"]<br>}<br>flask.add_default_swagger_routes(app, swagger_service_doc, okta=okta_config)<br>```<br>### response type<br>Response types are inferred from the route type : it is assumed that a get_resource route will return the associated resource,<br>and that a get_all_resource_route will return an array of associated resource (following the json_api spec). Rest-helper *does not8 (yet) automatically detect the response schema, so you *must* document the object type that you are returning. To do so, use the `@swagger.swagger_object` decorator and document the object using yaml syntax.<br><br>eg:<br>```python<br>@swagger.swagger_object<br>class LibraryResource(Resource):<br>    \"\"\"<br>    Swagger jsonapi_response:<br>        name:<br>            type: \"string\"<br>            example: \"service_name\"<br>        version_pins:<br>            type: dictionary<br>            example: {\"shared-version://my_shared_service\": 1.master.1}<br>    end swagger<br>    \"\"\"<br>```<br><br>You do not need to document the json_api part of the response, only the object itself.<br><br>*Why not automate this process ?*<br>Outside of very specific case, we believe it is next to impossible to automate *good* documentation. Good documentation<br>implies proper examples, explanations etc. We might however provide a *basic* documentation in the future, just like we do<br>with parameters<br><br><br>### How to customize a route<br><br>The automated swagger UI is a \"best effort\". There will be some case where you will want to modify what has been<br>automatically created. To do so, rest-helper relies on method documentation, just like we did with Resource object.<br><br>5 keywords are used to achieve different goals:<br>- doc: gives you a way to update (see the python update function) the entire swagger associated swagger path dictionary. Can be used on route method documentation.<br>- parameters: gives you a way to update (see the python update function) a specific parameter dictionary, or to not document it by passing null. eg:<br>```<br>This will ensure the user-agent parameter is not documented<br>Swagger parameters:<br>    User-Agent: null<br>```<br>Can be used on route method documentation<br>- extra_definition: this is to be used to add extra object definitions (not just json_api object, any kind), it is typically useful when you need subobject to defin complex objects. This can be used either in route method documentation or response object documentation.<br>- jsonapi_response: this is to be used only to document response object (see previous section)<br>- augment_default: this is the most complex and powerful one : its intent is to provide a way to augment the default dictionary *and lists*. It can be applied to either route method or response object and work as follow :<br>- - with regular syntax it works like the python update method but also updates nested dictionaries<br>- - you can also update a speific index in a list<br>- - you can also append to a list with<br>- - you can also delete from a list by index or by elem<br>To understand how augment default works, it is best to look at the corresponding tests in the test_swagger.py file<br><br>In the documentation of a route method, use the following to customize its swagger doc:<br>```<br>Swagger &lt;keyword&gt;:<br>&lt;yaml&gt;<br>end swagger<br>```<br><br>eg:<br>```python<br>@routes.operation_resource_route(platform_blueprint, PlatformResource, operation_name=\"accrete\",versionner=platform_versionner.AccretePlatformVersionner, exception_handler=exception_handler.common_exception_handler)<br>def accrete_platform(<br>        platform_name,<br>        asof:(as_of_date.AsOfDate,from_query_string)=None,<br>        uag:from_header(header_field=\"User-Agent\")=None,<br>        include_platform_source:(bool, from_query_string)=False,<br>        add_hoc_mixins:(list, from_query_string(as_list=True))= []<br>    ):<br>    \"\"\"<br>    Swagger doc:<br>        description: \"Display the platform taking in account the inheritance tree.\"<br>    end swagger<br><br>    Swagger parameters:<br>        User-Agent: null<br>    end swagger<br><br>    Swagger augment_default:<br>    parameters&gt;-: [\"[2]\"]<br><br>    Arguments:<br>        platform_name {str} -- The name of the platform to be accreted.<br>    \"\"\"<br><br>```<br><br>&lt;a name=\"serverside-filtering\"&gt;&lt;/a&gt;<br><br>## Server side filtering<br><br>When a client is interested only in a very specific part of the response, sending back an entire response is a waste of resource: serializing it, putting it on the network and deserializing it are all significant costs that can be avoided. Specialized libraries like GraphQL do that extremly well but can be heavy to implement. Rest-helper implement a poor man's server side filtering via the json_path query string argument supported on all route methods that return a Response json_api object. While simplistic in nature, it has proven to fit most basic needs.<br><br>It supports key name, list index, `*` (foreach) segments, and filtered foreach segments .<br><br>eg:<br>```<br>GET /resources/name<br>&gt;&gt;&gt;<br>{<br>    data:[<br>        {<br>            \"name\"=\"name_1\"<br>            \"value\"={\"a\":1,\"b\":2}<br>        },<br>        {<br>            \"name\"=\"name_2\"<br>            \"value\"={\"a\":3,\"b\":4}<br>        },<br>    ]<br>}<br><br>GET /resources/name?json_path=/0/value/a<br>&gt;&gt;&gt;<br>{<br>    data:1<br>}<br><br>GET /resources/name?json_path=/*/value/b<br>&gt;&gt;&gt;<br>{<br>    data:[2,4]<br>}<br><br>GET /resources/name?json_path=/*:value&gt;a~=(3|4)/value/b<br>&gt;&gt;&gt;<br>{<br>    data:[4]<br>}<br>```<br><br>### How does array filtering work<br>In the last example, we used array filtering to select only some elements of the array.<br>When traversing an array with `*` you can specify a filter:<br>`*:path&gt;to&gt;elements&gt;inside&gt;the&gt;array{operator}{value}`<br><br>currently the follwing operators are supported:<br>- `==` for equality<br>- `!=` for different<br>- `~=` for regexes<br><br>This is very basic and does not handle cases where the path does not exist on some elements.<br><br>&lt;a name=\"automatic-paging-section\"&gt;&lt;/a&gt;<br><br>## Automatic paging<br><br>Similarly to resource filtering, paging is a common use case: returning arrays with thousands of elements is usually a waste of resource. Rest-helpers supports automatic paging for route methods returning a Response object. Paging is based on a page number and a page size. The page number comes from the `page` query string argument. The page size comes from :<br>1. the `page_size` query string argument if present<br>2. the `page_size` field used in the Response constructor if the query string argument is not present<br>3. the `page_size` field used in the route decorator if none of the above is present.<br><br>Note: paging will not happen if page_size is not provided somehow.<br><br>&lt;a name=\"json-api-section\"&gt;&lt;/a&gt;<br><br>## JSON API responses<br><br>Rest-helpers offers support for JSON API compliant responses. More details about JSON API here: http://jsonapi.org. This will help to provide standard response schema making service interoperability easier.<br><br>### Resource base class<br>To take advantage of the JSON API spec implementation, your resource model object should simply inherit from the `Resource` class and use the super constructor.<br><br>The resource constructor accepts optional arguments to fully support the JSON API spec.<br>```python<br>class Resource(object):<br>    def __init__(self, resource_type, resource_name, relationships=None, links=None, meta=None, parent=None)<br>```<br><br>- `relationships` should be a dictionary of related resources, keyed by name<br>- `links` should be a dictionaty of related links, keyed by name<br>- `meta` can be any object loosely related to the resource<br>- `parent` is used in the case of a nested resource<br><br>A resource is identified uniquely by the field id constructed as follows:<br>```<br>id = /grand_parent_type_plural/grand_parent_resource_name/parent_type_plural/parent_name/type_plural/name<br>type = /grand_parent_type_plural/parent_type_plural/type_plural<br>```<br>A resource can be nested under a parent resource where it makes sense.<br>Eg:<br>```<br>id = /authors/mtwain/books/tomsawyer<br>type = /authors/books<br>```<br>call: `Resource(\"books\",\"tomsawyer\",parent=MTwainResourceObject)`<br><br>### Standard response<br>Standard responses are built on top of the JSON API resource and are defined in the `responses` module.<br>```python<br>responses.ok(my_resource)<br>response.created(just_created_resource)<br>response.bad_request(Exception(\"The body of the request is incorrect\"))<br>```<br><br>&lt;a name=\"framework-agnostic-section\"&gt;&lt;/a&gt;<br><br>## Framework agnostic<br><br>Rest-helper attempts to be framework agnostic: we currently support aiohttp and flask and could support any framework that support the ~100 lines adapter created for aiohttp and flask.<br><br>### How does it work<br>Rest helpers implement a combinaition or adapter pattern and proxy pattern. For both flask and aiohttp, we created an adapter<br>implementing the interface defined in `framework_adapter.py`. The rest of the code does not use any framework specific logic, but takes a framework adapter as the first argument of most methods. proxies are used to make this transparent to the end user: when importing the `response` module from `rest_helpers.flask` you actually proxy `rest_helpers.responses` but inject a framework adapter in every call.<br><br>This approach makes the pattern easily extensible, roughly a 100 lines are likely needed to onboard a new framework.<br><br>&lt;a name=\"error-messages-section\"&gt;&lt;/a&gt;<br><br>## Meaningful error message<br><br>One of the philosophy behind rest-helper is to automate error messages as much as possible in order to provide meaningful error messages. As much as possible, error case lead to error message that tell the user how to correct it. We try to not respond with a blank 400 or 500 but explain in detail what failed.<br><br>\n          </div>"}, "last_serial": 4838252, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "4965a1713baff2dcbc227f6ce531885f", "sha256": "5af8c31404a2d11eb31b96ead50d9dac111619e1d6d9018da6492d5835ab0678"}, "downloads": -1, "filename": "minioc-0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "4965a1713baff2dcbc227f6ce531885f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 16297, "upload_time": "2019-02-19T03:44:10", "upload_time_iso_8601": "2019-02-19T03:44:10.027487Z", "url": "https://files.pythonhosted.org/packages/4f/f1/3076e4acc3885a7cf3705d2750fc0f2393ce34a2557250398889cc9aa7dd/minioc-0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d4220ce30b54acd9ba74e8ac5fca27be", "sha256": "9044c7d7bc25b0b4bf97cdc489a2633e5be4d351e336a6b781e46eb193851ee5"}, "downloads": -1, "filename": "minioc-0.1.tar.gz", "has_sig": false, "md5_digest": "d4220ce30b54acd9ba74e8ac5fca27be", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32517, "upload_time": "2019-02-19T03:44:12", "upload_time_iso_8601": "2019-02-19T03:44:12.708466Z", "url": "https://files.pythonhosted.org/packages/f7/06/e77bf21fc7e4f1727794448b0c2e43bb67fa25cf6a81b3331c45cd982c64/minioc-0.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "37eab728441a290ed58b60305ffecf81", "sha256": "203459e866516764711128a851bf9605ddae08ce52267a73051a6ccd9f413df6"}, "downloads": -1, "filename": "minioc-1.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "37eab728441a290ed58b60305ffecf81", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 16353, "upload_time": "2019-02-19T03:55:50", "upload_time_iso_8601": "2019-02-19T03:55:50.632753Z", "url": "https://files.pythonhosted.org/packages/29/93/3df69adf827ea317def6c978e683ae251f343df36d324622c3989da4f635/minioc-1.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c7560f4124b5d3862d04ddd32fc73e3d", "sha256": "fc1f3ec794bcd8ba22fb44f1ef78151ae9648867b729b9b94f3c57702c58e89b"}, "downloads": -1, "filename": "minioc-1.2.tar.gz", "has_sig": false, "md5_digest": "c7560f4124b5d3862d04ddd32fc73e3d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32561, "upload_time": "2019-02-19T03:55:53", "upload_time_iso_8601": "2019-02-19T03:55:53.368060Z", "url": "https://files.pythonhosted.org/packages/d4/30/4077821797d44736e16122a4146c51303821cc0e7391a64eb0c085c45120/minioc-1.2.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "d340e15f0bffc17a16ae86a6012b030e", "sha256": "2828f0f70c9a9fb4e5425bdd582a3dfe5811e12916d49c2c9816fa4d8854ad1d"}, "downloads": -1, "filename": "minioc-1.2.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d340e15f0bffc17a16ae86a6012b030e", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 16382, "upload_time": "2019-02-19T06:20:20", "upload_time_iso_8601": "2019-02-19T06:20:20.582782Z", "url": "https://files.pythonhosted.org/packages/6b/38/aaccebace8b9c9157a4974c7ebe9d756a7eab185c933e5d0fd17df3138d2/minioc-1.2.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f1f96a7c974869c5de79c3c495b3207b", "sha256": "378f451563057a15c995ea1dca11e07cfc875f34d1280c5d0ad325f9659e3275"}, "downloads": -1, "filename": "minioc-1.2.1.tar.gz", "has_sig": false, "md5_digest": "f1f96a7c974869c5de79c3c495b3207b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32590, "upload_time": "2019-02-19T06:20:24", "upload_time_iso_8601": "2019-02-19T06:20:24.698971Z", "url": "https://files.pythonhosted.org/packages/3a/43/d1c61e28c1ff6bd90f9fa06b02b2103632a1ae6948b09025025096377aae/minioc-1.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d340e15f0bffc17a16ae86a6012b030e", "sha256": "2828f0f70c9a9fb4e5425bdd582a3dfe5811e12916d49c2c9816fa4d8854ad1d"}, "downloads": -1, "filename": "minioc-1.2.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d340e15f0bffc17a16ae86a6012b030e", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 16382, "upload_time": "2019-02-19T06:20:20", "upload_time_iso_8601": "2019-02-19T06:20:20.582782Z", "url": "https://files.pythonhosted.org/packages/6b/38/aaccebace8b9c9157a4974c7ebe9d756a7eab185c933e5d0fd17df3138d2/minioc-1.2.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f1f96a7c974869c5de79c3c495b3207b", "sha256": "378f451563057a15c995ea1dca11e07cfc875f34d1280c5d0ad325f9659e3275"}, "downloads": -1, "filename": "minioc-1.2.1.tar.gz", "has_sig": false, "md5_digest": "f1f96a7c974869c5de79c3c495b3207b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32590, "upload_time": "2019-02-19T06:20:24", "upload_time_iso_8601": "2019-02-19T06:20:24.698971Z", "url": "https://files.pythonhosted.org/packages/3a/43/d1c61e28c1ff6bd90f9fa06b02b2103632a1ae6948b09025025096377aae/minioc-1.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:22 2020"}