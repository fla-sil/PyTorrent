{"info": {"author": "Will Breaden Madden", "author_email": "wbm@protonmail.ch", "bugtrack_url": null, "classifiers": [], "description": "lock\n====\n\nThis is a module for enabling file locks. It uses ``fcntl`` to\naccomplish this.\n\nPOSIX operating systems implement advisory file locking. This enables\nconcurrent processes to interact with the same file without conflict,\nprovided they first check for the existence of a lock held by a\ndifferent process. Mandatory file locking can be enabled on POSIX\nsystems by mounting volumes using the ``mount`` ``-o mand`` option and\nmakes the operating system prevent editing of a locked file.\n\nThe ``fcntl`` functionality is implemented in Python by the ``fcntl``\nstandard library module. Using this, a lock can be acquired in a way\nlike the following:\n\n.. code:: python\n\n    lock_file = open(\"data.db\", \"a\")\n    fcntl.lockf(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)\n\nIf the file is locked, the following exception is raised:\n\n.. code:: python\n\n    BlockingIOError: [Errno 11] Resource temporarily unavailable\n\nWith advisory locking, code should test for the existence of a a lock\nbefore editing a file. It is the responsibility of the code, not the\noperating system, to enforce locking correctly. Information about the\nlocks currently held on a file may be retrieved by passing a bytes\nobject as the third argument to the ``fcntl.fcntl`` function (which\ntakes the place of a pointer to the process ID in the fcntl header). The\nlock information can be accessed in a way like the following:\n\n.. code:: python\n\n    lock_data = struct.pack(\"hhllhh\", fcntl.F_WRLCK, 0, 0, 0, 0, 0)\n    fcntl.fcntl(lock_file, fcntl.F_GETLK, lock_data)\n\nThis returns ``lock_data`` unchanged if there is no lock on the file.\n\nexamples\n========\n\nThe following code saves a dictionary to a file in a loop using ``lock``\nto lock the file while the save is happening:\n\n.. code:: python\n\n    import random\n\n    import lock\n\n    while True:\n        config = {\"a\": 1, \"b\": random.randint(1, 2)}\n        lock.save_JSON(\"config.json\", config)\n\nThe following code loads a dictionary from a file in a loop using\n``lock`` to lock the file while the load is happening:\n\n.. code:: python\n\n    import lock\n\n    while True:\n        config = lock.load_JSON(\"config.json\")\n        if config: print(config)\n\nThese two pieces of code can be used concurrently.\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/wdbm/lock", "keywords": "", "license": "GPLv3", "maintainer": "", "maintainer_email": "", "name": "lock", "package_url": "https://pypi.org/project/lock/", "platform": "", "project_url": "https://pypi.org/project/lock/", "project_urls": {"Homepage": "https://github.com/wdbm/lock"}, "release_url": "https://pypi.org/project/lock/2018.3.25.2110/", "requires_dist": null, "requires_python": "", "summary": "module for enabling file locks", "version": "2018.3.25.2110", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"lock\">\n<h2>lock</h2>\n<p>This is a module for enabling file locks. It uses <tt>fcntl</tt> to\naccomplish this.</p>\n<p>POSIX operating systems implement advisory file locking. This enables\nconcurrent processes to interact with the same file without conflict,\nprovided they first check for the existence of a lock held by a\ndifferent process. Mandatory file locking can be enabled on POSIX\nsystems by mounting volumes using the <tt>mount</tt> <tt><span class=\"pre\">-o</span> mand</tt> option and\nmakes the operating system prevent editing of a locked file.</p>\n<p>The <tt>fcntl</tt> functionality is implemented in Python by the <tt>fcntl</tt>\nstandard library module. Using this, a lock can be acquired in a way\nlike the following:</p>\n<pre><span class=\"n\">lock_file</span> <span class=\"o\">=</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s2\">\"data.db\"</span><span class=\"p\">,</span> <span class=\"s2\">\"a\"</span><span class=\"p\">)</span>\n<span class=\"n\">fcntl</span><span class=\"o\">.</span><span class=\"n\">lockf</span><span class=\"p\">(</span><span class=\"n\">lock_file</span><span class=\"p\">,</span> <span class=\"n\">fcntl</span><span class=\"o\">.</span><span class=\"n\">LOCK_EX</span> <span class=\"o\">|</span> <span class=\"n\">fcntl</span><span class=\"o\">.</span><span class=\"n\">LOCK_NB</span><span class=\"p\">)</span>\n</pre>\n<p>If the file is locked, the following exception is raised:</p>\n<pre><span class=\"ne\">BlockingIOError</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">Errno</span> <span class=\"mi\">11</span><span class=\"p\">]</span> <span class=\"n\">Resource</span> <span class=\"n\">temporarily</span> <span class=\"n\">unavailable</span>\n</pre>\n<p>With advisory locking, code should test for the existence of a a lock\nbefore editing a file. It is the responsibility of the code, not the\noperating system, to enforce locking correctly. Information about the\nlocks currently held on a file may be retrieved by passing a bytes\nobject as the third argument to the <tt>fcntl.fcntl</tt> function (which\ntakes the place of a pointer to the process ID in the fcntl header). The\nlock information can be accessed in a way like the following:</p>\n<pre><span class=\"n\">lock_data</span> <span class=\"o\">=</span> <span class=\"n\">struct</span><span class=\"o\">.</span><span class=\"n\">pack</span><span class=\"p\">(</span><span class=\"s2\">\"hhllhh\"</span><span class=\"p\">,</span> <span class=\"n\">fcntl</span><span class=\"o\">.</span><span class=\"n\">F_WRLCK</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">fcntl</span><span class=\"o\">.</span><span class=\"n\">fcntl</span><span class=\"p\">(</span><span class=\"n\">lock_file</span><span class=\"p\">,</span> <span class=\"n\">fcntl</span><span class=\"o\">.</span><span class=\"n\">F_GETLK</span><span class=\"p\">,</span> <span class=\"n\">lock_data</span><span class=\"p\">)</span>\n</pre>\n<p>This returns <tt>lock_data</tt> unchanged if there is no lock on the file.</p>\n</div>\n<div id=\"examples\">\n<h2>examples</h2>\n<p>The following code saves a dictionary to a file in a loop using <tt>lock</tt>\nto lock the file while the save is happening:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">random</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">lock</span>\n\n<span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n    <span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s2\">\"a\"</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s2\">\"b\"</span><span class=\"p\">:</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)}</span>\n    <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"n\">save_JSON</span><span class=\"p\">(</span><span class=\"s2\">\"config.json\"</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"p\">)</span>\n</pre>\n<p>The following code loads a dictionary from a file in a loop using\n<tt>lock</tt> to lock the file while the load is happening:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">lock</span>\n\n<span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n    <span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"n\">load_JSON</span><span class=\"p\">(</span><span class=\"s2\">\"config.json\"</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">config</span><span class=\"p\">:</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">config</span><span class=\"p\">)</span>\n</pre>\n<p>These two pieces of code can be used concurrently.</p>\n</div>\n\n          </div>"}, "last_serial": 3704331, "releases": {"2018.3.25.2110": [{"comment_text": "", "digests": {"md5": "435db9197f018956cbdddb58af977858", "sha256": "cc5ac770930493eed7a8cfd0cf2568a125faf112eb8aa6b6149b3e581523d0c7"}, "downloads": -1, "filename": "lock-2018.3.25.2110.tar.gz", "has_sig": false, "md5_digest": "435db9197f018956cbdddb58af977858", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3049, "upload_time": "2018-03-25T21:12:37", "upload_time_iso_8601": "2018-03-25T21:12:37.084503Z", "url": "https://files.pythonhosted.org/packages/ea/ee/4c7e9740d397abd62b48bfe82f77f57a8984da4f5ba0a3b64930b44ccd8f/lock-2018.3.25.2110.tar.gz", "yanked": false}], "2018.3.8.1911": [{"comment_text": "", "digests": {"md5": "18600d3f1f9611c3bd72f5c2725b83ec", "sha256": "8b599a5165aa0df8b5348dfc091ab45d19a774ec0eb1720f00fffbf57c890922"}, "downloads": -1, "filename": "lock-2018.3.8.1911.tar.gz", "has_sig": false, "md5_digest": "18600d3f1f9611c3bd72f5c2725b83ec", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3050, "upload_time": "2018-03-08T19:47:38", "upload_time_iso_8601": "2018-03-08T19:47:38.806759Z", "url": "https://files.pythonhosted.org/packages/4e/c2/bddf8c5efe7a336c5ab0faea5e635e4e50755f2428f0f7b07d4f8aade57e/lock-2018.3.8.1911.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "435db9197f018956cbdddb58af977858", "sha256": "cc5ac770930493eed7a8cfd0cf2568a125faf112eb8aa6b6149b3e581523d0c7"}, "downloads": -1, "filename": "lock-2018.3.25.2110.tar.gz", "has_sig": false, "md5_digest": "435db9197f018956cbdddb58af977858", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3049, "upload_time": "2018-03-25T21:12:37", "upload_time_iso_8601": "2018-03-25T21:12:37.084503Z", "url": "https://files.pythonhosted.org/packages/ea/ee/4c7e9740d397abd62b48bfe82f77f57a8984da4f5ba0a3b64930b44ccd8f/lock-2018.3.25.2110.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:34 2020"}