{"info": {"author": "Christian Fobel", "author_email": "christian@fobel.net", "bugtrack_url": null, "classifiers": [], "description": "# motor-control #\nControl package for OpenDrop Digital Microfluidics Platform\n\n## Overview ##\n\nThis package contains:\n\n - Firmware compatible with Arduino Uno or Mega2560.\n - Installable Python package for interfacing with Arduino firmware through\n   serial port or i2c (through a serial-to-i2c proxy).\n\n## Install ##\n\nThe Python package can be installed through `pip` using the following command:\n\n    pip install wheeler.motor-control\n\n## Upload firmware ##\n\nTo upload the pre-compiled firmware included in the Python package, run the\nfollowing command:\n\n    python -m motor_control.bin.upload <board type>\n\nreplacing `<board type>` with either `uno` or `mega2560`, depending on the\nmodel of the board.\n\nThis will attempt to upload the firmware by automatically discovering the\nserial port.  On systems with multiple serial ports, use the `-p` command line\nargument to specify the serial port to use.  For example:\n\n    python -m motor_control.bin.upload -p COM3 uno\n\n--------------------------------------------------\n\n## Usage ##\n\nAfter uploading the firmware to the board, the `motor_control.Proxy` class can be\nused to interact with the Arduino device.\n\nSee the session log below for example usage.\n\n### Example interactive session ###\n\n    >>> from serial import Serial\n    >>> from motor_control import Proxy\n\nConnect to serial device.\n\n    >>> serial_device = Serial('/dev/ttyUSB0', baudrate=115200)\n\nInitialize a device proxy using existing serial connection.\n\n    >>> proxy = Proxy(serial_device)\n\nQuery the number of bytes free in device RAM.\n\n    >>> proxy.ram_free()\n    409\n\nQuery descriptive properties of device.\n\n    >>> proxy.properties()\n    base_node_software_version                               0.9.post8.dev141722557\n    name                                                                  motor_control\n    manufacturer                                                        Wheeler Lab\n    url                           http://github.com/wheeler-microfluidics/open-d...\n    software_version                                                            0.1\n    dtype: object\n\nUse Arduino API methods interactively.\n\n    >>> # Set pin 13 as output\n    >>> proxy.pin_mode(13, 1)\n    >>> # Turn led on\n    >>> proxy.digital_write(13, 1)\n    >>> # Turn led off\n    >>> proxy.digital_write(13, 0)\n\nQuery number of available channels.\n\n    >>> proxy.channel_count()\n    40\n\nQuery state of channels array.\n\n    >>> proxy.state_of_channels\n    array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n           0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=uint8)\n\nTurn on every other channel.\n\n    >>> proxy.state_of_channels = 20 * [0, 1]\n\nQuery updated state of channels array.\n\n    >>> proxy.state_of_channels\n    array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n           1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], dtype=uint8)\n\n### Configuration and state ###\n\nThe device stores a *configuration* and a *state*.  The configuration is\nserialized and stored in EEPROM, allowing settings to persist across device\nresets.  The state is stored in device memory and is reinitialized each time\nthe device starts up.\n\nPrint (non-default) configuration values.\n\n    >>> print proxy.config\n    serial_number: 2\n    baud_rate: 115200\n    i2c_address: 17\n\n    >>> proxy.config.\n    proxy.config.max_waveform_frequency  proxy.config.max_waveform_voltage\n    >>> proxy.config.max_waveform_voltage\n    200\n    >>> proxy.config.max_waveform_frequency\n    10000\n\nSet voltage and frequency.\n\n    >>> result_code = proxy.update_state(voltage=100, frequency=1e3)\n    >>> print proxy.state\n    voltage: 100.0\n    frequency: 1000.0\n\n#### Validation ####\n\nNote that negative values are not allowed for voltage or frequency.\n\n    >>> result_code = proxy.update_state(voltage=-1)  # Negative voltage \n    >>> print proxy.state\n    voltage: 100.0\n    frequency: 1000.0\n\nVoltage/frequency updates are restricted to allowable range.\n\n    >>> result_code = proxy.update_state(voltage=300)  # Voltage greater than max\n    >>> print proxy.state  # Voltage remains unchanged\n    voltage: 100.0\n    frequency: 1000.0\n\nMax values can be increased by updating the configuration.\n\n    >>> result_code = proxy.update_config(max_waveform_voltage=300)\n    >>> result_code = proxy.update_state(voltage=300)  # Voltage now <= max\n    >>> print proxy.state  # Voltage changed\n    voltage: 300.0\n    frequency: 1000.0\n\nTo persist changes to configuration across device reset - *not* state - use\n`save_config` method.\n\n    >>> proxy.save_config()\n\n### Other methods ###\n\nBelow is a list of the attributes of the `motor_control.Proxy` Python class.  Note\nthat many of the [Arduino API][1] functions (e.g., `pin_mode`, `digital_write`,\netc.) are exposed through the RPC API.\n\n    >>> proxy.\n    proxy.analog_read                      proxy.microseconds\n    proxy.analog_write                     proxy.milliseconds\n    proxy.array_length                     proxy.name\n    proxy.base_node_software_version       proxy.on_config_baud_rate_changed\n    proxy.begin                            proxy.on_config_i2c_address_changed\n    proxy.buffer_size                      proxy.on_config_serial_number_changed\n    proxy.channel_count                    proxy.on_state_frequency_changed\n    proxy.config                           proxy.on_state_voltage_changed\n    proxy.delay_ms                         proxy.pin_mode\n    proxy.delay_us                         proxy.properties\n    proxy.digital_read                     proxy.ram_free\n    proxy.digital_write                    proxy.read_eeprom_block\n    proxy.echo_array                       proxy.reset_config\n    proxy.get_buffer                       proxy.reset_state\n    proxy.i2c_address                      proxy.save_config\n    proxy.i2c_available                    proxy.serialize_config\n    proxy.i2c_buffer_size                  proxy.serialize_state\n    proxy.i2c_read                         proxy.set_i2c_address\n    proxy.i2c_read_byte                    proxy.set_state_of_channels\n    proxy.i2c_request                      proxy.software_version\n    proxy.i2c_request_from                 proxy.state\n    proxy.i2c_scan                         proxy.state_of_channels\n    proxy.i2c_write                        proxy.str_echo\n    proxy.load_config                      proxy.update_config\n    proxy.manufacturer                     proxy.update_eeprom_block\n    proxy.max_i2c_payload_size             proxy.update_state\n    proxy.max_serial_payload_size          proxy.url\n\n--------------------------------------------------\n\n## Firmware development ##\n\nThe Arduino firmware/sketch is located in the `motor_control/Arduino/motor_control`\ndirectory.  The key functionality is defined in the `motor_control::Node` class in\nthe file `Node.h`.\n\nRunning the following command will build the firmware using [SCons][2] for\nArduino Uno and Arduino Mega2560, and will package the resulting firmware in a\nPython package, ready for distribution.\n\n    paver sdist\n\n### Adding new remote procedure call (RPC) methods ###\n\nNew methods may be added to the RPC API by adding new methods to the\n`motor_control::Node` class in the file `Node.h`.\n\n# Author #\n\nCopyright 2015 Christian Fobel <christian@fobel.net>\n\n\n[1]: https://www.arduino.cc/en/Reference/HomePage\n[2]: http://www.scons.org/\n", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/wheeler-microfluidics/motor-control.git", "keywords": null, "license": "GPLv2", "maintainer": null, "maintainer_email": null, "name": "wheeler.motor-control", "package_url": "https://pypi.org/project/wheeler.motor-control/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/wheeler.motor-control/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/wheeler-microfluidics/motor-control.git"}, "release_url": "https://pypi.org/project/wheeler.motor-control/0.2.post2/", "requires_dist": null, "requires_python": null, "summary": "Arduino RPC node packaged as Python package.", "version": "0.2.post2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p># motor-control #\nControl package for OpenDrop Digital Microfluidics Platform</p>\n<p>## Overview ##</p>\n<p>This package contains:</p>\n<blockquote>\n<ul>\n<li>Firmware compatible with Arduino Uno or Mega2560.</li>\n<li>Installable Python package for interfacing with Arduino firmware through\nserial port or i2c (through a serial-to-i2c proxy).</li>\n</ul>\n</blockquote>\n<p>## Install ##</p>\n<p>The Python package can be installed through <cite>pip</cite> using the following command:</p>\n<blockquote>\npip install wheeler.motor-control</blockquote>\n<p>## Upload firmware ##</p>\n<p>To upload the pre-compiled firmware included in the Python package, run the\nfollowing command:</p>\n<blockquote>\npython -m motor_control.bin.upload &lt;board type&gt;</blockquote>\n<p>replacing <cite>&lt;board type&gt;</cite> with either <cite>uno</cite> or <cite>mega2560</cite>, depending on the\nmodel of the board.</p>\n<p>This will attempt to upload the firmware by automatically discovering the\nserial port.  On systems with multiple serial ports, use the <cite>-p</cite> command line\nargument to specify the serial port to use.  For example:</p>\n<blockquote>\npython -m motor_control.bin.upload -p COM3 uno</blockquote>\n<hr class=\"docutils\">\n<p>## Usage ##</p>\n<p>After uploading the firmware to the board, the <cite>motor_control.Proxy</cite> class can be\nused to interact with the Arduino device.</p>\n<p>See the session log below for example usage.</p>\n<p>### Example interactive session ###</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from serial import Serial\n&gt;&gt;&gt; from motor_control import Proxy\n</pre>\n</blockquote>\n<p>Connect to serial device.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; serial_device = Serial('/dev/ttyUSB0', baudrate=115200)\n</pre>\n</blockquote>\n<p>Initialize a device proxy using existing serial connection.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proxy = Proxy(serial_device)\n</pre>\n</blockquote>\n<p>Query the number of bytes free in device RAM.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proxy.ram_free()\n409\n</pre>\n</blockquote>\n<p>Query descriptive properties of device.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proxy.properties()\nbase_node_software_version                               0.9.post8.dev141722557\nname                                                                  motor_control\nmanufacturer                                                        Wheeler Lab\nurl                           http://github.com/wheeler-microfluidics/open-d...\nsoftware_version                                                            0.1\ndtype: object\n</pre>\n</blockquote>\n<p>Use Arduino API methods interactively.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; # Set pin 13 as output\n&gt;&gt;&gt; proxy.pin_mode(13, 1)\n&gt;&gt;&gt; # Turn led on\n&gt;&gt;&gt; proxy.digital_write(13, 1)\n&gt;&gt;&gt; # Turn led off\n&gt;&gt;&gt; proxy.digital_write(13, 0)\n</pre>\n</blockquote>\n<p>Query number of available channels.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proxy.channel_count()\n40\n</pre>\n</blockquote>\n<p>Query state of channels array.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proxy.state_of_channels\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], dtype=uint8)\n</pre>\n</blockquote>\n<p>Turn on every other channel.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proxy.state_of_channels = 20 * [0, 1]\n</pre>\n</blockquote>\n<p>Query updated state of channels array.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proxy.state_of_channels\narray([0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0,\n       1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], dtype=uint8)\n</pre>\n</blockquote>\n<p>### Configuration and state ###</p>\n<p>The device stores a <em>configuration</em> and a <em>state</em>.  The configuration is\nserialized and stored in EEPROM, allowing settings to persist across device\nresets.  The state is stored in device memory and is reinitialized each time\nthe device starts up.</p>\n<p>Print (non-default) configuration values.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print proxy.config\nserial_number: 2\nbaud_rate: 115200\ni2c_address: 17\n</pre>\n<pre>&gt;&gt;&gt; proxy.config.\nproxy.config.max_waveform_frequency  proxy.config.max_waveform_voltage\n&gt;&gt;&gt; proxy.config.max_waveform_voltage\n200\n&gt;&gt;&gt; proxy.config.max_waveform_frequency\n10000\n</pre>\n</blockquote>\n<p>Set voltage and frequency.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; result_code = proxy.update_state(voltage=100, frequency=1e3)\n&gt;&gt;&gt; print proxy.state\nvoltage: 100.0\nfrequency: 1000.0\n</pre>\n</blockquote>\n<p>#### Validation ####</p>\n<p>Note that negative values are not allowed for voltage or frequency.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; result_code = proxy.update_state(voltage=-1)  # Negative voltage\n&gt;&gt;&gt; print proxy.state\nvoltage: 100.0\nfrequency: 1000.0\n</pre>\n</blockquote>\n<p>Voltage/frequency updates are restricted to allowable range.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; result_code = proxy.update_state(voltage=300)  # Voltage greater than max\n&gt;&gt;&gt; print proxy.state  # Voltage remains unchanged\nvoltage: 100.0\nfrequency: 1000.0\n</pre>\n</blockquote>\n<p>Max values can be increased by updating the configuration.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; result_code = proxy.update_config(max_waveform_voltage=300)\n&gt;&gt;&gt; result_code = proxy.update_state(voltage=300)  # Voltage now &lt;= max\n&gt;&gt;&gt; print proxy.state  # Voltage changed\nvoltage: 300.0\nfrequency: 1000.0\n</pre>\n</blockquote>\n<p>To persist changes to configuration across device reset - <em>not</em> state - use\n<cite>save_config</cite> method.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proxy.save_config()\n</pre>\n</blockquote>\n<p>### Other methods ###</p>\n<p>Below is a list of the attributes of the <cite>motor_control.Proxy</cite> Python class.  Note\nthat many of the [Arduino API][1] functions (e.g., <cite>pin_mode</cite>, <cite>digital_write</cite>,\netc.) are exposed through the RPC API.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; proxy.\nproxy.analog_read                      proxy.microseconds\nproxy.analog_write                     proxy.milliseconds\nproxy.array_length                     proxy.name\nproxy.base_node_software_version       proxy.on_config_baud_rate_changed\nproxy.begin                            proxy.on_config_i2c_address_changed\nproxy.buffer_size                      proxy.on_config_serial_number_changed\nproxy.channel_count                    proxy.on_state_frequency_changed\nproxy.config                           proxy.on_state_voltage_changed\nproxy.delay_ms                         proxy.pin_mode\nproxy.delay_us                         proxy.properties\nproxy.digital_read                     proxy.ram_free\nproxy.digital_write                    proxy.read_eeprom_block\nproxy.echo_array                       proxy.reset_config\nproxy.get_buffer                       proxy.reset_state\nproxy.i2c_address                      proxy.save_config\nproxy.i2c_available                    proxy.serialize_config\nproxy.i2c_buffer_size                  proxy.serialize_state\nproxy.i2c_read                         proxy.set_i2c_address\nproxy.i2c_read_byte                    proxy.set_state_of_channels\nproxy.i2c_request                      proxy.software_version\nproxy.i2c_request_from                 proxy.state\nproxy.i2c_scan                         proxy.state_of_channels\nproxy.i2c_write                        proxy.str_echo\nproxy.load_config                      proxy.update_config\nproxy.manufacturer                     proxy.update_eeprom_block\nproxy.max_i2c_payload_size             proxy.update_state\nproxy.max_serial_payload_size          proxy.url\n</pre>\n</blockquote>\n<hr class=\"docutils\">\n<p>## Firmware development ##</p>\n<p>The Arduino firmware/sketch is located in the <cite>motor_control/Arduino/motor_control</cite>\ndirectory.  The key functionality is defined in the <cite>motor_control::Node</cite> class in\nthe file <cite>Node.h</cite>.</p>\n<p>Running the following command will build the firmware using [SCons][2] for\nArduino Uno and Arduino Mega2560, and will package the resulting firmware in a\nPython package, ready for distribution.</p>\n<blockquote>\npaver sdist</blockquote>\n<p>### Adding new remote procedure call (RPC) methods ###</p>\n<p>New methods may be added to the RPC API by adding new methods to the\n<cite>motor_control::Node</cite> class in the file <cite>Node.h</cite>.</p>\n<p># Author #</p>\n<p>Copyright 2015 Christian Fobel &lt;<a href=\"mailto:christian%40fobel.net\">christian<span>@</span>fobel<span>.</span>net</a>&gt;</p>\n<p>[1]: <a href=\"https://www.arduino.cc/en/Reference/HomePage\" rel=\"nofollow\">https://www.arduino.cc/en/Reference/HomePage</a>\n[2]: <a href=\"http://www.scons.org/\" rel=\"nofollow\">http://www.scons.org/</a></p>\n\n          </div>"}, "last_serial": 1638193, "releases": {"0.2.post2": [{"comment_text": "", "digests": {"md5": "894f1f82afdb36a6e4df87bb01d53f09", "sha256": "4dbcc87afd684d02144fe04b1aa1dbdcb067b93c3fa9d5ec8b3cac49607f7f82"}, "downloads": -1, "filename": "wheeler.motor-control-0.2.post2.tar.gz", "has_sig": false, "md5_digest": "894f1f82afdb36a6e4df87bb01d53f09", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 177416, "upload_time": "2015-07-17T17:28:50", "upload_time_iso_8601": "2015-07-17T17:28:50.040885Z", "url": "https://files.pythonhosted.org/packages/37/62/a8006e89c92577950dddad2ffe611204c923b498ad0f62182871e8e4e4a0/wheeler.motor-control-0.2.post2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "894f1f82afdb36a6e4df87bb01d53f09", "sha256": "4dbcc87afd684d02144fe04b1aa1dbdcb067b93c3fa9d5ec8b3cac49607f7f82"}, "downloads": -1, "filename": "wheeler.motor-control-0.2.post2.tar.gz", "has_sig": false, "md5_digest": "894f1f82afdb36a6e4df87bb01d53f09", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 177416, "upload_time": "2015-07-17T17:28:50", "upload_time_iso_8601": "2015-07-17T17:28:50.040885Z", "url": "https://files.pythonhosted.org/packages/37/62/a8006e89c92577950dddad2ffe611204c923b498ad0f62182871e8e4e4a0/wheeler.motor-control-0.2.post2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:29:52 2020"}