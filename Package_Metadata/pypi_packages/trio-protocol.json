{"info": {"author": "Michael Elsdorfer", "author_email": "michael@elsdorfer.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Internet :: WWW/HTTP"], "description": "# trio-protocol\n\nThis implements the `asyncio.Transport` interface and foundational asyncio classes such as `asyncio.Task` on top of [`trio`](https://github.com/python-trio/trio), to aid porting `asyncio` libraries. The idea is to allow `trio` to run an [`asyncio.Protocol`](https://docs.python.org/3/library/asyncio-protocol.html#protocols), making it possible for a single code base to run on both frameworks.\n\nIt is **not a goal** of `trio-protocol` to let you run `asyncio` code on `trio` without any changes. If you need this, look at [`asyncio-trio`](https://github.com/python-trio/trio-asyncio).\n\n\n#### What is and is not currently supported\n\nThis is an early version. You can use it to support some basic `asyncio` servers. However, it lacks:\n\n- Support for clients (only servers have been tested)\n- A test suite.\n- Robust experience running it in production.\n- Likely, implementations for useful/necessary methods that asyncio code is using in the wild, and should be added.\n\n\n## Usage\n\nLet's say you want to run the [`asyncio-len-prefixed-string-protocol.py` from the python3-samples repository](https://github.com/eliben/python3-samples/blob/master/async/asyncio-len-prefixed-string-protocol.py) on top of `trio`. \n\nIf you follow the link, you see that the module first implements subclass of `asyncio.Protocol`, which it then subclasses further. Ultimately, the protocol as implemented reads strings from the client, prefixed by length, and sends back an `\"ok\"` message.\n\nAt the bottom of the file, you'll find the following code to start the server:\n\n```python\nloop = asyncio.get_event_loop()\ncoro = loop.create_server(MyStringReceiver, '127.0.0.1', 5566)\nserver = loop.run_until_complete(coro)\nprint('serving on {}'.format(server.sockets[0].getsockname()))\n\ntry:\n    loop.run_forever()\nexcept KeyboardInterrupt:\n    print(\"exit\")\nfinally:\n    server.close()\n    loop.close()\n```\n\nThis creates an `asyncio` server running on port `5566`. Every connection to that port will be served by the `MyStringReceiver` protocol. Specifically, `loop.create_server()` will setup the server's socket (since it is an `async` function, it will not do anything until awaited, which in this case we do via `loop.run_until_complete`). Whenever someone connects to the server, asyncio will schedule a task to handle the connection. We run `loop.run_forever()` to have the loop be active and process these tasks.\n\nNow let's run this on `trio` instead. Replace this section of the code with:\n\n```python\nimport trio\nfrom trio_protocol import run_server\n\ntrio.run(run_server, MyStringReceiver, '127.0.0.1', 5566)\n```\n\nAnd that would work! The code is a bit shorter than the original, partly because setting up trio is just less verbose, and partly because we do less: We do not handle `KeyboardInterrupt` cleanly, and we do not print a message once we are ready to accept connections. Instead, `trio_protocol.run_server` is a shortcut that does everything for us: It opens a nursery, starts a server, and runs the `asyncio.Protocol` on that server.\n\nIf we want to copy the original code more exactly, I can do this:\n\n```python\nimport trio\nfrom trio_protocol import create_server\n\nasync def run_server():\n    async with trio.open_nursery() as nursery:\n         server = await create_server(nursery, MyStringReceiver, '127.0.0.1', 5566)\n         print('serving on {}'.format(server.sockets[0].getsockname()))\n\ntry:\n    trio.run(run_server)\nexcept KeyboardInterrupt:\n    print(\"exit\")\n```\n\n```trio_protocol.create_server``` will start listening on the socket. It will return a `trio_protocol.Server` object that is intended to mirror `asyncio.Server`. You are then free to run your own code, with the server running in the background, similar to the `asyncio` version.\n\n>>> Note: To test this server, you can use:\n>>> `python -c \"import struct; print((b'%shello world' % struct.pack('<L', 12)).decode('ascii'))\" | nc localhost 5566`\n\n\n### What if the protocol needs access to the loop\n\nIf the protocol uses the `asyncio` loop, for example to start background tasks, you can use `trio_protocol.Loop` which is a loop-like class that supports some of the commonly used methods such as `call_later` or `create_task`. Most protocols are written to accept a `loop` argument, so you would do:\n\n```python\nimport functools\nimport trio\nfrom trio_protocol import Loop, run_server\n\nasync def run_server():\n    async with trio.open_nursery() as nursery:\n        loop = Loop(nursery)\n        protocol_factory = functools.partial(MyProtocol, loop=loop)\n        await create_server(nursery, protocol_factory, '127.0.0.1', 5566)\n\ntrio.run(run_server)\n```\n\nBackground task the protocol want to spawn now run within the nursery given to `trio_protocol.Loop`.\n\nNote: It is strictly a requirement that the protocol class you want to run uses an explicit loop. Most `asyncio` interfaces are written in such a way that when an explicit loop is not passed, the current global loop will be used automatically. This won't work, because you would end up using the `asyncio` loop.\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/miracle2k/trio-protocol", "keywords": "", "license": "BSD", "maintainer": "", "maintainer_email": "", "name": "trio-protocol", "package_url": "https://pypi.org/project/trio-protocol/", "platform": "", "project_url": "https://pypi.org/project/trio-protocol/", "project_urls": {"Homepage": "https://github.com/miracle2k/trio-protocol"}, "release_url": "https://pypi.org/project/trio-protocol/0.2/", "requires_dist": null, "requires_python": "", "summary": "Trio implementation of asyncio.Protocol", "version": "0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            # trio-protocol<br><br>This implements the `asyncio.Transport` interface and foundational asyncio classes such as `asyncio.Task` on top of [`trio`](https://github.com/python-trio/trio), to aid porting `asyncio` libraries. The idea is to allow `trio` to run an [`asyncio.Protocol`](https://docs.python.org/3/library/asyncio-protocol.html#protocols), making it possible for a single code base to run on both frameworks.<br><br>It is **not a goal** of `trio-protocol` to let you run `asyncio` code on `trio` without any changes. If you need this, look at [`asyncio-trio`](https://github.com/python-trio/trio-asyncio).<br><br><br>#### What is and is not currently supported<br><br>This is an early version. You can use it to support some basic `asyncio` servers. However, it lacks:<br><br>- Support for clients (only servers have been tested)<br>- A test suite.<br>- Robust experience running it in production.<br>- Likely, implementations for useful/necessary methods that asyncio code is using in the wild, and should be added.<br><br><br>## Usage<br><br>Let's say you want to run the [`asyncio-len-prefixed-string-protocol.py` from the python3-samples repository](https://github.com/eliben/python3-samples/blob/master/async/asyncio-len-prefixed-string-protocol.py) on top of `trio`. <br><br>If you follow the link, you see that the module first implements subclass of `asyncio.Protocol`, which it then subclasses further. Ultimately, the protocol as implemented reads strings from the client, prefixed by length, and sends back an `\"ok\"` message.<br><br>At the bottom of the file, you'll find the following code to start the server:<br><br>```python<br>loop = asyncio.get_event_loop()<br>coro = loop.create_server(MyStringReceiver, '127.0.0.1', 5566)<br>server = loop.run_until_complete(coro)<br>print('serving on {}'.format(server.sockets[0].getsockname()))<br><br>try:<br>    loop.run_forever()<br>except KeyboardInterrupt:<br>    print(\"exit\")<br>finally:<br>    server.close()<br>    loop.close()<br>```<br><br>This creates an `asyncio` server running on port `5566`. Every connection to that port will be served by the `MyStringReceiver` protocol. Specifically, `loop.create_server()` will setup the server's socket (since it is an `async` function, it will not do anything until awaited, which in this case we do via `loop.run_until_complete`). Whenever someone connects to the server, asyncio will schedule a task to handle the connection. We run `loop.run_forever()` to have the loop be active and process these tasks.<br><br>Now let's run this on `trio` instead. Replace this section of the code with:<br><br>```python<br>import trio<br>from trio_protocol import run_server<br><br>trio.run(run_server, MyStringReceiver, '127.0.0.1', 5566)<br>```<br><br>And that would work! The code is a bit shorter than the original, partly because setting up trio is just less verbose, and partly because we do less: We do not handle `KeyboardInterrupt` cleanly, and we do not print a message once we are ready to accept connections. Instead, `trio_protocol.run_server` is a shortcut that does everything for us: It opens a nursery, starts a server, and runs the `asyncio.Protocol` on that server.<br><br>If we want to copy the original code more exactly, I can do this:<br><br>```python<br>import trio<br>from trio_protocol import create_server<br><br>async def run_server():<br>    async with trio.open_nursery() as nursery:<br>         server = await create_server(nursery, MyStringReceiver, '127.0.0.1', 5566)<br>         print('serving on {}'.format(server.sockets[0].getsockname()))<br><br>try:<br>    trio.run(run_server)<br>except KeyboardInterrupt:<br>    print(\"exit\")<br>```<br><br>```trio_protocol.create_server``` will start listening on the socket. It will return a `trio_protocol.Server` object that is intended to mirror `asyncio.Server`. You are then free to run your own code, with the server running in the background, similar to the `asyncio` version.<br><br>&gt;&gt;&gt; Note: To test this server, you can use:<br>&gt;&gt;&gt; `python -c \"import struct; print((b'%shello world' % struct.pack('&lt;L', 12)).decode('ascii'))\" | nc localhost 5566`<br><br><br>### What if the protocol needs access to the loop<br><br>If the protocol uses the `asyncio` loop, for example to start background tasks, you can use `trio_protocol.Loop` which is a loop-like class that supports some of the commonly used methods such as `call_later` or `create_task`. Most protocols are written to accept a `loop` argument, so you would do:<br><br>```python<br>import functools<br>import trio<br>from trio_protocol import Loop, run_server<br><br>async def run_server():<br>    async with trio.open_nursery() as nursery:<br>        loop = Loop(nursery)<br>        protocol_factory = functools.partial(MyProtocol, loop=loop)<br>        await create_server(nursery, protocol_factory, '127.0.0.1', 5566)<br><br>trio.run(run_server)<br>```<br><br>Background task the protocol want to spawn now run within the nursery given to `trio_protocol.Loop`.<br><br>Note: It is strictly a requirement that the protocol class you want to run uses an explicit loop. Most `asyncio` interfaces are written in such a way that when an explicit loop is not passed, the current global loop will be used automatically. This won't work, because you would end up using the `asyncio` loop.<br>\n          </div>"}, "last_serial": 4124775, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "0b2619a368a593bdca0bb273afc0b232", "sha256": "d152e53af16a6d20d5f496fe2aec0fc0f91ba6c701e3d9c2cd4e9dfd49006219"}, "downloads": -1, "filename": "trio_protocol-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "0b2619a368a593bdca0bb273afc0b232", "packagetype": "bdist_wheel", "python_version": "3.7", "requires_python": null, "size": 6065, "upload_time": "2018-07-13T17:21:00", "upload_time_iso_8601": "2018-07-13T17:21:00.470700Z", "url": "https://files.pythonhosted.org/packages/d3/67/9492611679fc0ade56420d213ad86373ff0d2ba9e93a90178c40ea901650/trio_protocol-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f01918c63dd7771a482bc86153a7d1d8", "sha256": "d2849b395d9b41535c75d9a6d3c539636fb6540b3eb95842354087791e92e183"}, "downloads": -1, "filename": "trio-protocol-0.1.tar.gz", "has_sig": false, "md5_digest": "f01918c63dd7771a482bc86153a7d1d8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5358, "upload_time": "2018-07-13T17:20:58", "upload_time_iso_8601": "2018-07-13T17:20:58.917676Z", "url": "https://files.pythonhosted.org/packages/3a/c5/1281c6f24ad776bd09f947af57ec2c4322261b3706211ce7141c72585b88/trio-protocol-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "ea349845b66096a36a9d56156d346145", "sha256": "92153fec380df25d94b71dad0328afb15fa7d8e3f61847e79c22bcad2f5023f2"}, "downloads": -1, "filename": "trio-protocol-0.2.tar.gz", "has_sig": false, "md5_digest": "ea349845b66096a36a9d56156d346145", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7860, "upload_time": "2018-08-01T13:24:38", "upload_time_iso_8601": "2018-08-01T13:24:38.824080Z", "url": "https://files.pythonhosted.org/packages/3a/44/598f83ff957ee31d888b8a07eb74965ccd80e56421604a05614222b754ea/trio-protocol-0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ea349845b66096a36a9d56156d346145", "sha256": "92153fec380df25d94b71dad0328afb15fa7d8e3f61847e79c22bcad2f5023f2"}, "downloads": -1, "filename": "trio-protocol-0.2.tar.gz", "has_sig": false, "md5_digest": "ea349845b66096a36a9d56156d346145", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7860, "upload_time": "2018-08-01T13:24:38", "upload_time_iso_8601": "2018-08-01T13:24:38.824080Z", "url": "https://files.pythonhosted.org/packages/3a/44/598f83ff957ee31d888b8a07eb74965ccd80e56421604a05614222b754ea/trio-protocol-0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:47:04 2020"}