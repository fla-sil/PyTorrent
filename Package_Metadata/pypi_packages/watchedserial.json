{"info": {"author": "Eric Oswald", "author_email": "eoswald39@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "=============\r\nwatchedserial\r\n=============\r\n\r\n|build-status| |pypi|\r\n\r\nInstallation\r\n============\r\n\r\n.. code-block:: bash\r\n\r\n        $ pip install watchedserial\r\n\r\n\r\nDescription\r\n===========\r\n``WatchedReaderThread`` is a subclass of pySerial's\r\n``serial.threaded.ReaderThread``. Similar to ``ReaderThread``,\r\n``WatchedReaderThread`` implements a serial port read loop in it's own thread but\r\ninstead of killing the thread on a serial disconnection, it calls a callback and\r\nwaits for the port to become available again before attempting a reconnect. On\r\nreconnect it calls a reconnect callback. This should make writing apps that need to\r\ndeal with unreliable serial connections more seamless and make it easier to write\r\napps that should allow the user to disconnect and reconnect a serial device safely.\r\n\r\nUsage\r\n=====\r\nSubclass ``watchedserial.WatchedReaderThread`` to implement the\r\n``handle_reconnect()`` and ``handle_disconnect()`` callbacks. Both of these\r\nfunctions should be non-blocking (similar to an ISR).\r\n\r\n.. code-block:: python\r\n\r\n\timport time\r\n\r\n\timport serial\r\n\tfrom watchedserial import WatchedReaderThread\r\n\r\n\r\n\tPORT = \"COM3\"\r\n\r\n\tclass MyPacket(serial.threaded.FramedPacket):\r\n\t    def handle_packet(self, packet):\r\n\t\tprint(packet)\r\n\r\n\r\n\tclass MyWatchedReaderThread(WatchedReaderThread):\r\n\t    def handle_reconnect(self):\r\n\t\tprint(\"Reconnected\")\r\n\r\n\t    def handle_disconnect(self, error):\r\n\t\tprint(\"Disconnected\")\r\n\r\n\r\n\tser = serial.Serial(PORT, baudrate=115200)\r\n\twith MyWatchedReaderThread(ser, MyPacket) as protocol:\r\n\t    while True:\r\n\t\ttime.sleep(1)\r\n\r\n\r\n\r\n.. |build-status| image:: https://travis-ci.org/eoswald/watchedserial.svg?branch=master\r\n\r\n.. |pypi| image:: https://img.shields.io/pypi/v/watchedserial.svg?style=flat-square&label=latest%20stable%20version\r\n    :target: https://pypi.python.org/pypi/watchedserial\r\n    :alt: Latest version released on PyPi\r\n\r\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "watchedserial", "package_url": "https://pypi.org/project/watchedserial/", "platform": "", "project_url": "https://pypi.org/project/watchedserial/", "project_urls": null, "release_url": "https://pypi.org/project/watchedserial/1.0.1/", "requires_dist": null, "requires_python": "", "summary": "Module for handling pySerial Serial objects connecting and disconnecting", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><img alt=\"build-status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/106a2234c1b72ab00e3b75eb3a16e122e7d2ec64/68747470733a2f2f7472617669732d63692e6f72672f656f7377616c642f7761746368656473657269616c2e7376673f6272616e63683d6d6173746572\"> <a href=\"https://pypi.python.org/pypi/watchedserial\" rel=\"nofollow\"><img alt=\"Latest version released on PyPi\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/953bc991f8547194d1fa934eb77c2ffbe1573ed9/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f7761746368656473657269616c2e7376673f7374796c653d666c61742d737175617265266c6162656c3d6c6174657374253230737461626c6525323076657273696f6e\"></a></p>\n<div id=\"installation\">\n<h2>Installation</h2>\n<pre>$ pip install watchedserial\n</pre>\n</div>\n<div id=\"description\">\n<h2>Description</h2>\n<p><tt>WatchedReaderThread</tt> is a subclass of pySerial\u2019s\n<tt>serial.threaded.ReaderThread</tt>. Similar to <tt>ReaderThread</tt>,\n<tt>WatchedReaderThread</tt> implements a serial port read loop in it\u2019s own thread but\ninstead of killing the thread on a serial disconnection, it calls a callback and\nwaits for the port to become available again before attempting a reconnect. On\nreconnect it calls a reconnect callback. This should make writing apps that need to\ndeal with unreliable serial connections more seamless and make it easier to write\napps that should allow the user to disconnect and reconnect a serial device safely.</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Subclass <tt>watchedserial.WatchedReaderThread</tt> to implement the\n<tt>handle_reconnect()</tt> and <tt>handle_disconnect()</tt> callbacks. Both of these\nfunctions should be non-blocking (similar to an ISR).</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">serial</span>\n<span class=\"kn\">from</span> <span class=\"nn\">watchedserial</span> <span class=\"kn\">import</span> <span class=\"n\">WatchedReaderThread</span>\n\n\n<span class=\"n\">PORT</span> <span class=\"o\">=</span> <span class=\"s2\">\"COM3\"</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyPacket</span><span class=\"p\">(</span><span class=\"n\">serial</span><span class=\"o\">.</span><span class=\"n\">threaded</span><span class=\"o\">.</span><span class=\"n\">FramedPacket</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">handle_packet</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">packet</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">packet</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyWatchedReaderThread</span><span class=\"p\">(</span><span class=\"n\">WatchedReaderThread</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">handle_reconnect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Reconnected\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">handle_disconnect</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">error</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Disconnected\"</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">ser</span> <span class=\"o\">=</span> <span class=\"n\">serial</span><span class=\"o\">.</span><span class=\"n\">Serial</span><span class=\"p\">(</span><span class=\"n\">PORT</span><span class=\"p\">,</span> <span class=\"n\">baudrate</span><span class=\"o\">=</span><span class=\"mi\">115200</span><span class=\"p\">)</span>\n<span class=\"k\">with</span> <span class=\"n\">MyWatchedReaderThread</span><span class=\"p\">(</span><span class=\"n\">ser</span><span class=\"p\">,</span> <span class=\"n\">MyPacket</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">protocol</span><span class=\"p\">:</span>\n    <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n        <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n</div>\n\n          </div>"}, "last_serial": 2836024, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "ec6258a2281bd6c440ebe1ca54b2f02e", "sha256": "b9d47c02705d6ed65a0e755901b7101ce6fa27194be82a42c12adc00efc09a9e"}, "downloads": -1, "filename": "watchedserial-1.0.0.tar.gz", "has_sig": false, "md5_digest": "ec6258a2281bd6c440ebe1ca54b2f02e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3170, "upload_time": "2017-04-28T01:29:37", "upload_time_iso_8601": "2017-04-28T01:29:37.233688Z", "url": "https://files.pythonhosted.org/packages/2e/d5/3386ff824a32749568ef84773b48c14438bd17bc2f396a423063c27ce5e5/watchedserial-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "0c63cd26aeee8fd8e99c8a05b5775dda", "sha256": "5ce5fb9f986c1571aa313d88a6c6ed693525f313ab19aeef180ab083bedf38bd"}, "downloads": -1, "filename": "watchedserial-1.0.1.tar.gz", "has_sig": false, "md5_digest": "0c63cd26aeee8fd8e99c8a05b5775dda", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3369, "upload_time": "2017-04-28T01:32:21", "upload_time_iso_8601": "2017-04-28T01:32:21.949626Z", "url": "https://files.pythonhosted.org/packages/45/4d/9be97efec8be22b0effdda180afc2348e26cd64f5f622869455edccd2c48/watchedserial-1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0c63cd26aeee8fd8e99c8a05b5775dda", "sha256": "5ce5fb9f986c1571aa313d88a6c6ed693525f313ab19aeef180ab083bedf38bd"}, "downloads": -1, "filename": "watchedserial-1.0.1.tar.gz", "has_sig": false, "md5_digest": "0c63cd26aeee8fd8e99c8a05b5775dda", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3369, "upload_time": "2017-04-28T01:32:21", "upload_time_iso_8601": "2017-04-28T01:32:21.949626Z", "url": "https://files.pythonhosted.org/packages/45/4d/9be97efec8be22b0effdda180afc2348e26cd64f5f622869455edccd2c48/watchedserial-1.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:32:13 2020"}