{"info": {"author": "Travis Swicegood", "author_email": "development@domain51.com", "bugtrack_url": null, "classifiers": [], "description": "steinie\n=======\nA little framework for doing web applications\n\n\nUsage\n-----\nSteinie is built around the concept of routes.  Your application is made up of\none or more routes that guide the web request through your code.  Let's start\nwith the simplest of simple, the Hello World web application.\n\n.. code-block:: python\n\n    from steinie import Steinie\n    app = Steinie()\n\n\n    @app.get(\"/\")\n    def get(request, response):\n        return \"Hello World, from Steinie!\\n\"\n\n\n    if __name__ == \"__main__\":\n        app.run()\n\n\nYou can run this directly using ``python`` if you save this to a file.  This\nstarts up a simple development server on port 5151 that responds to the ``/``\nroute on your local computer.  Give it a try.\n\nSteinie uses `Werkzeug`_ for handling its routes.  This means all of your\nfamiliar route patterns are available to you inside Steinie.\n\nSteinie has built-in decorators for ``GET`` and ``POST`` along with ``DELETE``,\n``HEAD``, ``INFO``, ``OPTIONS``, ``PATCH``, ``PUT``, and ``TRACE``.\n\n\nDealing with Parameters\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\nAnother common need is to provide parameters to your web application.  Lets say\nyou wanted to add a ``username`` to your path, but you wanted it capitalized\n(bear with me for a minute), you can do that with the ``param`` decorator like\nthis:\n\n.. code-block:: python\n\n    from steinie import Steinie\n\n    app = Steinie()\n\n\n    @app.param(\"username\")\n    def capitalize(param):\n        return param.capitalize()\n\n\n    @app.get(\"/<username:some_user>\")\n    def handler(request, response):\n        return \"Hello, %s\\n\" % request.params[\"some_user\"]\n\n\n    if __name__ == \"__main__\":\n        app.run()\n\nUsing the ``param`` decorator, you specify the name of the parameter you want\nto create, then you provide a function specifying what you want to do.  You can\nrun this example, then load ``http://localhost:5151/alice`` and it will respond\nwith \"Hello, Alice!\"\n\nIf you're familiar with Flask's (and by extension, Werkzeug's) converters this\nmight look very familiar.  Again, building off of the Werkzeug base, much of\nwhat's provided here mimics what you might already be used to.\n\nNow that you've seen the basic example, imagine instead if your created a\nfunction that loads a user object from your database and returns that.  Using\nthe ``params`` decorator, you can start to turn basic parameters from your\nincoming request into something that matches the way you've modeled your actual\napplication.\n\n\nGrouping routes and parameters\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\nYou might be wondering how this scales.  A single file with a ton of decorated\nfunctions sound pretty unwieldy to me.  Thankfully, Steinie provides a way to\nbreak up your functionality into logical parts through what it calls a\n``Router``.\n\nLet's enhance the example above.  Most of what's there relates to users, so\nwe're going to create a new ``Route``, then mount it to ``/user``.\n\nFirst, adjust the import statement so it looks like this:\n\n.. code-block:: python\n\n    from steinie import Steinie, Router\n\nNext, create a new ``route`` object from the ``Router`` and adjust your two\ndecorated functions to use that.  It should look like this:\n\n.. code-block:: python\n\n    route = Router()\n\n\n    @route.param(\"username\")\n    def capitalize(param):\n        return param.capitalize()\n\n\n    @route.get(\"/<username:some_user>\")\n    def handler(request, response):\n        return \"Hello, %s\\n\" % request.params[\"some_user\"]\n\n\nFinally, you need to modify your ``app`` object to use this your new route.\nYou do that with the aptly named ``use`` method like this:\n\n.. code-block:: python\n\n    app.use(\"/user\", route)\n\nSave your work, fire up your code, then visit your server again.  If you try\nto go to ``http://localhost:5151/alice`` again you'll get a 404.  Instead, you\nneed to add ``/user`` to the URL so it looks like this:\n``http://localhost:5151/user/alice``.\n\n\nDealing with Middleware\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\nThere's one more part to becoming an expert in Steine: Middleware.  Middleware\ngives you a chance to modify the request or response for every incoming request.\n\nLet's continue to build on our example above.  Instead of using the ``param``\ndecorator, let's create a middleware that capitalizes all ``some_user``\nparameters.\n\nFirst, let's create the middleware.  Steinie expects them to be objects that can\nbe intantiated and provided a ``Router`` instance, then invoked via the\n``__call__`` method.  That's it.  Add this to your file and then you can say\nyou've created your very own Steinie middleware:\n\n.. code-block:: python\n\n    class CapitalizeMiddleware(object):\n        def __init__(self, route):\n            pass\n\n        def __call__(self, request, response, _next):\n            if \"some_user\" in request.params:\n                new = request.params[\"some_user\"].capitalize()\n                request.params[\"some_user\"] = new\n            return _next(request, response)\n\nThere's a couple of things to call out here.  First, we don't need the ``route``\nprovided at instantiation time, so there's no need to store it. If you did, you\ncould set that as an attribute on the class.\n\nNext up, the ``__call__`` method has three arguments.  ``request`` and\n``response`` are familiar from earlier, but ``_next`` is new.  This is a\nfunction generated by Steinie that allows the middleware to control what happens\nwhen it's invoked.  For our purposes here, we want to modify the ``some_user``\nvalue by capitalizing it when it's present, then continue on.  To do that, you\nsimply return the result of ``_next(request, response)``.\n\nThe ability to control what happens here is a key part of Steinie's middleware.\nYou can capture the return value from ``_next`` and do something with it.  Use\ncases that jump to mind for me are a ``CacheMiddleware`` that attempts to load\na request from cache and returns that if its found but will allow the request\nto go through if it hasn't been cached.\n\nThis simple example here is just that, pretty simple.\n\nYou're not quite finished with the middleware yet.  Next you need to tell your\nrouter to use it.  Enter ``router.use`` again:\n\n.. code-block:: python\n\n    route.use(CapitalizeMiddleware)\n\nThis is the same method you used to attach a router to an application, but\nthis time there's no route (the first argument you used above) associated with\nit.  Providing ``router.use`` with a single argument signals to Steinie that\nyou're giving it a middleware that it should execute when dealing with all\nrequests this router attempts to handle.\n\nThe final modification that you should make is to remove the params function\nand adjust your ``get`` route.  When it's finished, it should look like this:\n\n.. code-block:: python\n\n    @route.get(\"/<some_user>\")\n    def handler(request, response):\n        return \"Hello, %s\\n\" % request.params[\"some_user\"]\n\nNow, re-run your code and access it.  You should get the same output, but this\nis a different pattern.  What makes one pattern over the other better?  Funny\nyou should mention it, that's the next topic.\n\n\nMiddleware vs. Parameters\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\nBoth middleware and parameters can be used to acheive very similar goals, but\nthey have distinct roles.\n\nMiddleware\n  These are global and have the chance to modify every incoming request.  They\n  have the full request and have the ability to circumvent the normal response.\n  Use them when you need to modify *every* request that is processed for a given\n  route or you need to do more than change part of the request URL to some other\n  object.\n\nParameters\n  These are localized to routes that have the parameter in the request URL.\n  Unlike middleware, all they can do is transform part of a URL into something\n  else.  They're very useful when translating an ID to an object in the database\n  or some other similar transformation, but they won't let you change the\n  response that Steinie returns.\n\n\nInspiration\n-----------\nSteinie was inspired in heavily by `Express`_ in the server-side JavaScript\nworld.  For the 4.x rewrite, Express started leaning heavily on the router based\nmodel that Steinie uses.\n\n.. _Express: http://expressjs.com/\n.. _Werkzeug: http://werkzeug.pocoo.org/", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "UNKNOWN", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "steinie", "package_url": "https://pypi.org/project/steinie/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/steinie/", "project_urls": {"Download": "UNKNOWN", "Homepage": "UNKNOWN"}, "release_url": "https://pypi.org/project/steinie/1.0.1/", "requires_dist": null, "requires_python": null, "summary": "A little framework for doing web applications", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>A little framework for doing web applications</p>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Steinie is built around the concept of routes.  Your application is made up of\none or more routes that guide the web request through your code.  Let\u2019s start\nwith the simplest of simple, the Hello World web application.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">steinie</span> <span class=\"kn\">import</span> <span class=\"n\">Steinie</span>\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Steinie</span><span class=\"p\">()</span>\n\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"/\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">get</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"n\">response</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"s2\">\"Hello World, from Steinie!</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre>\n<p>You can run this directly using <tt>python</tt> if you save this to a file.  This\nstarts up a simple development server on port 5151 that responds to the <tt>/</tt>\nroute on your local computer.  Give it a try.</p>\n<p>Steinie uses <a href=\"http://werkzeug.pocoo.org/\" rel=\"nofollow\">Werkzeug</a> for handling its routes.  This means all of your\nfamiliar route patterns are available to you inside Steinie.</p>\n<p>Steinie has built-in decorators for <tt>GET</tt> and <tt>POST</tt> along with <tt>DELETE</tt>,\n<tt>HEAD</tt>, <tt>INFO</tt>, <tt>OPTIONS</tt>, <tt>PATCH</tt>, <tt>PUT</tt>, and <tt>TRACE</tt>.</p>\n<div id=\"dealing-with-parameters\">\n<h3>Dealing with Parameters</h3>\n<p>Another common need is to provide parameters to your web application.  Lets say\nyou wanted to add a <tt>username</tt> to your path, but you wanted it capitalized\n(bear with me for a minute), you can do that with the <tt>param</tt> decorator like\nthis:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">steinie</span> <span class=\"kn\">import</span> <span class=\"n\">Steinie</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Steinie</span><span class=\"p\">()</span>\n\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">param</span><span class=\"p\">(</span><span class=\"s2\">\"username\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">capitalize</span><span class=\"p\">(</span><span class=\"n\">param</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">param</span><span class=\"o\">.</span><span class=\"n\">capitalize</span><span class=\"p\">()</span>\n\n\n<span class=\"nd\">@app</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"/&lt;username:some_user&gt;\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"n\">response</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"s2\">\"Hello, </span><span class=\"si\">%s</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span> <span class=\"o\">%</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">params</span><span class=\"p\">[</span><span class=\"s2\">\"some_user\"</span><span class=\"p\">]</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre>\n<p>Using the <tt>param</tt> decorator, you specify the name of the parameter you want\nto create, then you provide a function specifying what you want to do.  You can\nrun this example, then load <tt><span class=\"pre\">http://localhost:5151/alice</span></tt> and it will respond\nwith \u201cHello, Alice!\u201d</p>\n<p>If you\u2019re familiar with Flask\u2019s (and by extension, Werkzeug\u2019s) converters this\nmight look very familiar.  Again, building off of the Werkzeug base, much of\nwhat\u2019s provided here mimics what you might already be used to.</p>\n<p>Now that you\u2019ve seen the basic example, imagine instead if your created a\nfunction that loads a user object from your database and returns that.  Using\nthe <tt>params</tt> decorator, you can start to turn basic parameters from your\nincoming request into something that matches the way you\u2019ve modeled your actual\napplication.</p>\n</div>\n<div id=\"grouping-routes-and-parameters\">\n<h3>Grouping routes and parameters</h3>\n<p>You might be wondering how this scales.  A single file with a ton of decorated\nfunctions sound pretty unwieldy to me.  Thankfully, Steinie provides a way to\nbreak up your functionality into logical parts through what it calls a\n<tt>Router</tt>.</p>\n<p>Let\u2019s enhance the example above.  Most of what\u2019s there relates to users, so\nwe\u2019re going to create a new <tt>Route</tt>, then mount it to <tt>/user</tt>.</p>\n<p>First, adjust the import statement so it looks like this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">steinie</span> <span class=\"kn\">import</span> <span class=\"n\">Steinie</span><span class=\"p\">,</span> <span class=\"n\">Router</span>\n</pre>\n<p>Next, create a new <tt>route</tt> object from the <tt>Router</tt> and adjust your two\ndecorated functions to use that.  It should look like this:</p>\n<pre><span class=\"n\">route</span> <span class=\"o\">=</span> <span class=\"n\">Router</span><span class=\"p\">()</span>\n\n\n<span class=\"nd\">@route</span><span class=\"o\">.</span><span class=\"n\">param</span><span class=\"p\">(</span><span class=\"s2\">\"username\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">capitalize</span><span class=\"p\">(</span><span class=\"n\">param</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">param</span><span class=\"o\">.</span><span class=\"n\">capitalize</span><span class=\"p\">()</span>\n\n\n<span class=\"nd\">@route</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"/&lt;username:some_user&gt;\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"n\">response</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"s2\">\"Hello, </span><span class=\"si\">%s</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span> <span class=\"o\">%</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">params</span><span class=\"p\">[</span><span class=\"s2\">\"some_user\"</span><span class=\"p\">]</span>\n</pre>\n<p>Finally, you need to modify your <tt>app</tt> object to use this your new route.\nYou do that with the aptly named <tt>use</tt> method like this:</p>\n<pre><span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">use</span><span class=\"p\">(</span><span class=\"s2\">\"/user\"</span><span class=\"p\">,</span> <span class=\"n\">route</span><span class=\"p\">)</span>\n</pre>\n<p>Save your work, fire up your code, then visit your server again.  If you try\nto go to <tt><span class=\"pre\">http://localhost:5151/alice</span></tt> again you\u2019ll get a 404.  Instead, you\nneed to add <tt>/user</tt> to the URL so it looks like this:\n<tt><span class=\"pre\">http://localhost:5151/user/alice</span></tt>.</p>\n</div>\n<div id=\"dealing-with-middleware\">\n<h3>Dealing with Middleware</h3>\n<p>There\u2019s one more part to becoming an expert in Steine: Middleware.  Middleware\ngives you a chance to modify the request or response for every incoming request.</p>\n<p>Let\u2019s continue to build on our example above.  Instead of using the <tt>param</tt>\ndecorator, let\u2019s create a middleware that capitalizes all <tt>some_user</tt>\nparameters.</p>\n<p>First, let\u2019s create the middleware.  Steinie expects them to be objects that can\nbe intantiated and provided a <tt>Router</tt> instance, then invoked via the\n<tt>__call__</tt> method.  That\u2019s it.  Add this to your file and then you can say\nyou\u2019ve created your very own Steinie middleware:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">CapitalizeMiddleware</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">route</span><span class=\"p\">):</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__call__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"n\">response</span><span class=\"p\">,</span> <span class=\"n\">_next</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"s2\">\"some_user\"</span> <span class=\"ow\">in</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">params</span><span class=\"p\">:</span>\n            <span class=\"n\">new</span> <span class=\"o\">=</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">params</span><span class=\"p\">[</span><span class=\"s2\">\"some_user\"</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">capitalize</span><span class=\"p\">()</span>\n            <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">params</span><span class=\"p\">[</span><span class=\"s2\">\"some_user\"</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">new</span>\n        <span class=\"k\">return</span> <span class=\"n\">_next</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"n\">response</span><span class=\"p\">)</span>\n</pre>\n<p>There\u2019s a couple of things to call out here.  First, we don\u2019t need the <tt>route</tt>\nprovided at instantiation time, so there\u2019s no need to store it. If you did, you\ncould set that as an attribute on the class.</p>\n<p>Next up, the <tt>__call__</tt> method has three arguments.  <tt>request</tt> and\n<tt>response</tt> are familiar from earlier, but <tt>_next</tt> is new.  This is a\nfunction generated by Steinie that allows the middleware to control what happens\nwhen it\u2019s invoked.  For our purposes here, we want to modify the <tt>some_user</tt>\nvalue by capitalizing it when it\u2019s present, then continue on.  To do that, you\nsimply return the result of <tt>_next(request, response)</tt>.</p>\n<p>The ability to control what happens here is a key part of Steinie\u2019s middleware.\nYou can capture the return value from <tt>_next</tt> and do something with it.  Use\ncases that jump to mind for me are a <tt>CacheMiddleware</tt> that attempts to load\na request from cache and returns that if its found but will allow the request\nto go through if it hasn\u2019t been cached.</p>\n<p>This simple example here is just that, pretty simple.</p>\n<p>You\u2019re not quite finished with the middleware yet.  Next you need to tell your\nrouter to use it.  Enter <tt>router.use</tt> again:</p>\n<pre><span class=\"n\">route</span><span class=\"o\">.</span><span class=\"n\">use</span><span class=\"p\">(</span><span class=\"n\">CapitalizeMiddleware</span><span class=\"p\">)</span>\n</pre>\n<p>This is the same method you used to attach a router to an application, but\nthis time there\u2019s no route (the first argument you used above) associated with\nit.  Providing <tt>router.use</tt> with a single argument signals to Steinie that\nyou\u2019re giving it a middleware that it should execute when dealing with all\nrequests this router attempts to handle.</p>\n<p>The final modification that you should make is to remove the params function\nand adjust your <tt>get</tt> route.  When it\u2019s finished, it should look like this:</p>\n<pre><span class=\"nd\">@route</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s2\">\"/&lt;some_user&gt;\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"n\">response</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"s2\">\"Hello, </span><span class=\"si\">%s</span><span class=\"se\">\\n</span><span class=\"s2\">\"</span> <span class=\"o\">%</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">params</span><span class=\"p\">[</span><span class=\"s2\">\"some_user\"</span><span class=\"p\">]</span>\n</pre>\n<p>Now, re-run your code and access it.  You should get the same output, but this\nis a different pattern.  What makes one pattern over the other better?  Funny\nyou should mention it, that\u2019s the next topic.</p>\n</div>\n<div id=\"middleware-vs-parameters\">\n<h3>Middleware vs. Parameters</h3>\n<p>Both middleware and parameters can be used to acheive very similar goals, but\nthey have distinct roles.</p>\n<dl>\n<dt>Middleware</dt>\n<dd>These are global and have the chance to modify every incoming request.  They\nhave the full request and have the ability to circumvent the normal response.\nUse them when you need to modify <em>every</em> request that is processed for a given\nroute or you need to do more than change part of the request URL to some other\nobject.</dd>\n<dt>Parameters</dt>\n<dd>These are localized to routes that have the parameter in the request URL.\nUnlike middleware, all they can do is transform part of a URL into something\nelse.  They\u2019re very useful when translating an ID to an object in the database\nor some other similar transformation, but they won\u2019t let you change the\nresponse that Steinie returns.</dd>\n</dl>\n</div>\n</div>\n<div id=\"inspiration\">\n<h2>Inspiration</h2>\n<p>Steinie was inspired in heavily by <a href=\"http://expressjs.com/\" rel=\"nofollow\">Express</a> in the server-side JavaScript\nworld.  For the 4.x rewrite, Express started leaning heavily on the router based\nmodel that Steinie uses.</p>\n</div>\n\n          </div>"}, "last_serial": 1498724, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "2f30eba397ff38af5d593745d70b35db", "sha256": "3538e21daca7cd3d97e1ae3c61c65cee76e4944a4b05bf6e0f6cc13361d4010b"}, "downloads": -1, "filename": "steinie-0.1.0.tar.gz", "has_sig": false, "md5_digest": "2f30eba397ff38af5d593745d70b35db", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5848, "upload_time": "2014-07-26T18:51:14", "upload_time_iso_8601": "2014-07-26T18:51:14.663428Z", "url": "https://files.pythonhosted.org/packages/1a/69/b14df6f717583ede45afb0f8ae23aa8671e8386bed7d8281020233689155/steinie-0.1.0.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "f82f03bdad28ebb16130c30d122f7318", "sha256": "0044d4a21d60217cf98384f92086fa85b535935e82b803b1c4ea450f04a305f3"}, "downloads": -1, "filename": "steinie-1.0.0.tar.gz", "has_sig": false, "md5_digest": "f82f03bdad28ebb16130c30d122f7318", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9986, "upload_time": "2015-04-10T07:03:07", "upload_time_iso_8601": "2015-04-10T07:03:07.795177Z", "url": "https://files.pythonhosted.org/packages/2b/f3/d3974608ac89a5f772d01ea9f48d9a8aabb954ca7f25d900538f6b17c74d/steinie-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "e169276880c689cff281b744225e0b68", "sha256": "6116e6b5674c4da71f896268f8f7d497b810fc72e3bb1bd64c0ef35eaca59307"}, "downloads": -1, "filename": "steinie-1.0.1.tar.gz", "has_sig": false, "md5_digest": "e169276880c689cff281b744225e0b68", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10006, "upload_time": "2015-04-10T07:06:32", "upload_time_iso_8601": "2015-04-10T07:06:32.271842Z", "url": "https://files.pythonhosted.org/packages/78/dd/3b82275492a6ed6999cb0e652734f31717b1d8320185e0ea4c794725fa80/steinie-1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e169276880c689cff281b744225e0b68", "sha256": "6116e6b5674c4da71f896268f8f7d497b810fc72e3bb1bd64c0ef35eaca59307"}, "downloads": -1, "filename": "steinie-1.0.1.tar.gz", "has_sig": false, "md5_digest": "e169276880c689cff281b744225e0b68", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10006, "upload_time": "2015-04-10T07:06:32", "upload_time_iso_8601": "2015-04-10T07:06:32.271842Z", "url": "https://files.pythonhosted.org/packages/78/dd/3b82275492a6ed6999cb0e652734f31717b1d8320185e0ea4c794725fa80/steinie-1.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:07 2020"}