{"info": {"author": "Ben Timby, Travis Cunningham, Ryan Johnston, SmartFile", "author_email": "tcunningham@smartfile.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Operating System :: OS Independent", "Programming Language :: C", "Programming Language :: Python", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: System :: Archiving :: Compression"], "description": ".. image:: https://travis-ci.org/smartfile/python-libarchive.svg\n    :target: https://travis-ci.org/smartfile/python-libarchive\n\nA `SmartFile`_ Open Source project. `Read more`_ about how SmartFile\nuses and contributes to Open Source software.\n\n.. figure:: http://www.smartfile.com/images/logo.jpg\n   :alt: SmartFile\n\nOverview\n--------\nA complete wrapper for the libarchive library generated using SWIG.\nAlso included in the package are compatibility layers for the Python\nzipfile and tarfile modules.\n\nLibarchive supports the following:\n\n - Reads a variety of formats, including tar, pax, cpio, zip, xar, lha, ar, cab, mtree, rar, and ISO images.\n - Writes tar, pax, cpio, zip, xar, ar, ISO, mtree, and shar archives.\n - Automatically handles archives compressed with gzip, bzip2, lzip, xz, lzma, or compress.\n\nFor information on installing libarchive and python-libarchive, see the `Building`_.\n\n.. _SmartFile: http://www.smartfile.com/\n.. _Read more: http://www.smartfile.com/open-source.html\n.. _Building: http://code.google.com/p/python-libarchive/wiki/Building\n\n\nIntroduction\n------------\nThere are actually two APIs exposed by this library.\n\nThe first API is a high level pythonic class-based interface that should seem comfortable to Python developers. If you are just getting started with python-libarchive, this is probably where you should start.\n\nThe second API is a low-level wrapper around libarchive. This wrapper provides access to the C API exposed by libarchive. A few additions or changes were made to allow easy consumption from Python, but otherwise, most libarchive example code will work (although with Python syntax). This API will be useful to those familiar with libarchive, or those that need functionality not available in the high level API.\n\nUsing the high-level API\n------------------------\nThe high level API provides a pythonic class-based interface for working with archives. On top of this is a very thin compatibility wrapper for the standard Python zipfile and tarfile modules. Since the standard Python zipfile and tarfile modules both present a different interface, so do the compatibility wrappers.\n\nThese compatibility wrappers are provided so that python-libarchive can be a drop-in replacement for the standard modules. A reason to use libarchive instead of the standard modules is that it provides native performance and better memory consumption. So if you already have code using one of these modules, you can sin many cases just replace the standard module with the libarchive alternative.\n\nHowever, if you are developing a new project, it is recommended that you forgo the compatibility wrappers. Using the high-level API directly means you can support the many archive formats that libarchive does through the same standard interface.\n\nThe workhorse of the high-level API is the Archive class. This is a forward-only iterator that allows you to open an archive of any supported formant and iterate it's contents.\n\n   .. code:: python\n\n        import libarchive\n\n        a = libarchive.Archive('my_archive.zip')\n        for entry in a:\n            print entry.pathname\n        a.close()\n\npython-libarchive is also a context manager, so the above could be written as:\n\n   .. code:: python\n        \n        import libarchive\n\n        with libarchive.Archive('my_archive.zip') as a:\n            for entry in a:\n                print entry.pathname\n\nYou can also extract files. However, you can only extract the current item. Once you have iterated past an entry, there is no going back.\n\n   .. code:: python\n        \n        import libarchive\n\n        with libarchive.Archive('my_archive.zip') as a:\n            for entry in a:\n                if entry.pathname == 'my_file.txt':\n                    print 'File Contents:', a.read()\n\nBesides the read() method, there is also readpath() and readstream(). Readpath() will extract the file to a path or already opened file. Readstream() will return a file-like object that can be used to read chunks of the file. Larger files being read from the archive should probably use one of these functions instead of read() which will read then entire contents into memory.\n\nWriting archives is also straightforward. You open an Archive() class then add files to it using one of the write() methods.\n\n   .. code:: python\n        \n        import libarchive\n\n        with libarchive.Archive('my_archive.zip', 'w') as a:\n            for name in os.listdir('.'):\n                a.write(libarchive.Entry(name), file(name, 'r').read())\n\nAgain, there is also a writepath() method which will write a file-like object or path directly to the archive. The above example could have been written as the following.\n\n   .. code:: python\n        \n        import libarchive\n\n        with libarchive.Archive('my_archive.zip', 'w') as a:\n            for name in os.listdir('.'):\n                a.writepath(libarchive.Entry(name), name)\n\nIn addition to the Archive class. There is also SeekableArchive. This class provides random access when reading an archive. It will remember where entries are located within the archive stream, and will close/reopen the stream and seek to the entry's location. So, you can extract an item directly. The first example can be written as follows.\n\n   .. code:: python\n\n        import libarchive\n\n        with libarchive.SeekableArchive('my_archive.zip') as a:\n            print 'File Contents:', a.read('my_file.txt')\n\nThere is overhead involved in using the SeekableArchive, so it is suggested that you use the Archive in cases that you don't need random access to an archives entries. In fact, the above example was probably better off using the Archive class.\n\nUsing the low-level API\n-----------------------\nUsing the low-level API leaves all the work to you. You will need to be careful to create and free libarchive structures yourself. You will also need to be well-versed in the return codes and expected parameters of libarchive. In fact, if you are not, then you probably should stop reading now.\n\n   .. code:: python\n    \n        from libarchive import _libarchive\n\n        a = _libarchive.archive_read_new()\n        _libarchive.archive_read_support_filter_all(a)\n        _libarchive.archive_read_support_format_all(a)\n        _libarchive.archive_read_open_fd(a, f.fileno(), 10240)\n        while True:\n            e = _libarchive.archive_entry_new()\n            try:\n                r = _libarchive.archive_read_next_header2(a, e)\n                if r != _libarchive.ARCHIVE_OK:\n                    break\n                n = _libarchive.archive_entry_pathname(e)\n                if n != 'my_file.txt':\n                    continue\n                l = _libarchive.archive_entry_size(e)\n                s = _libarchive.archive_read_data_into_str(a, l)\n                print 'File Contents:', s\n            finally:\n                _libarchive.archive_entry_free(e)\n        _libarchive.archive_read_close(a)\n        _libarchive.archive_read_free(a)\n\nAs you can see this is a lot more work for little benefit. But as stated before, you may end up interacting with the low-level API if some of the functionality you require is not covered in the high-level API.\n\nAnd as always, patches are appreciated!\n\n\nInstalling libarchive\n---------------------\n\nMany Linux distributions include libarchive 2. This extension only works with libarchive 3. In these cases, you must install libarchive to a /usr/local. This will allow it to co-exist with the version installed with your distribution. To install libarchive using autoconf, follow the instructions below.\n\nPrerequisites.\n\nYou will need either automake or cmake to install libarchive. Also required is python-dev. In addition, you will also need a compiler and some other tools. To install these prerequisites do the following:\n\nOn Debian/Ubuntu:\n\n   ::\n\n        # Install compiler and tools\n        $ sudo apt-get install build-essential libtool python-dev\n\n        # Install automake\n        $ sudo apt-get install automake\n\n        # Or install cmake\n        $ sudo apt-get install cmake\n\nOr CentOS/Fedora:\n\n   ::\n\n        # Install compiler and tools\n        $ sudo yum groupinstall \"Development Tools\"\n        $ sudo yum install python-devel libtool\n\n        # Install automake\n        $ sudo yum install automake\n\n        # Or install cmake\n        $ sudo yum install cmake\n\nYou should now be able to install libarchive.\n\n   ::\n\n        $ wget http://libarchive.googlecode.com/files/libarchive-3.0.3.tar.gz\n        $ tar xzf libarchive-3.0.3.tar.gz\n\n        # Configure using automake...\n        $ cd libarchive-3.0.3/\n        $ build/autogen.sh\n        $ ./configure --prefix=/usr/local\n\n        # Or configure using cmake...\n        $ mkdir build\n        $ cd build\n        $ cmake -DCMAKE_INSTALL_PREFIX=/usr/local ../libarchive-3.0.3\n\n        # Now compile and install...\n        $ make\n        $ sudo make install\n\nNow that the library is installed, you need to tell ld where to find it. The easiest way to do this is to add /usr/local/lib to the ld.so.conf.\n\n   ::\n\n        $ sudo sh -c 'echo /usr/local/lib > /etc/ld.so.conf.d/libarchive3.conf'\n        $ sudo ldconfig\n\nNow libarchive 3.0.3 is installed into /usr/local/. The next step is to build and install python-libarchive.\n\nInstalling python-libarchive\n----------------------------\n\nNow that libarchive is installed, you can install the python extension using the steps below.\n\n   ::\n\n        $ wget http://python-libarchive.googlecode.com/files/python-libarchive-3.0.3-2.tar.gz\n        $ tar xzf python-libarchive-3.0.3-2.tar.gz\n        $ cd python-libarchive-3.0.3-2/\n        $ sudo python setup.py install\n\nYou can also install using pip.\n\n   ::\n\n        $ pip install python-libarchive\n\nsetup.py will explicitly link against version 3.0.3 of the library.\n\nHacking / Running the Test Suite\n--------------------------------\n\nThe test suite is located in the root directory. This is done purposefully to make hacking easier. If you make changes to the library, you can run the test suite against the local copy in the libarchive/ subdirectory rather than the version installed on your system.\n\nHowever, this means you need to have the extension compiled in this same directory. You will also need SWIG for this step. You can accomplish this using the following commands.\n\nOn Debian/Ubuntu:\n\n   ::\n\n        $ sudo apt-get install swig\n\nOr CentOS/Fedora:\n\n   ::\n        \n        $ sudo yum install swig\n\nNow you can re-SWIG the interface and recompile the extension.\n\n   ::\n\n        $ cd libarchive/\n        $ make\n        $ cd ..\n\nNow you can run the test suite from the main directory.\n\n   ::\n        \n        $ python tests.py", "description_content_type": "", "docs_url": null, "download_url": "http://python-libarchive.googlecode.com/files/python-libarchive-4.0.1-1.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/smartfile/python-libarchive", "keywords": "", "license": "BSD-style license", "maintainer": "", "maintainer_email": "", "name": "python-libarchive", "package_url": "https://pypi.org/project/python-libarchive/", "platform": "any", "project_url": "https://pypi.org/project/python-libarchive/", "project_urls": {"Download": "http://python-libarchive.googlecode.com/files/python-libarchive-4.0.1-1.tar.gz", "Homepage": "https://github.com/smartfile/python-libarchive"}, "release_url": "https://pypi.org/project/python-libarchive/4.0.1.post1/", "requires_dist": null, "requires_python": "", "summary": "A libarchive wrapper for Python.", "version": "4.0.1.post1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/smartfile/python-libarchive\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/smartfile/python-libarchive.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8545957a06c32acf5f4deb17072b3aa6a633edb5/68747470733a2f2f7472617669732d63692e6f72672f736d61727466696c652f707974686f6e2d6c6962617263686976652e737667\"></a>\n<p>A <a href=\"http://www.smartfile.com/\" rel=\"nofollow\">SmartFile</a> Open Source project. <a href=\"http://www.smartfile.com/open-source.html\" rel=\"nofollow\">Read more</a> about how SmartFile\nuses and contributes to Open Source software.</p>\n<div>\n<img alt=\"SmartFile\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5fd914c06d8ea2b4fd9bb0eb0a05dd9e5363dc6c/687474703a2f2f7777772e736d61727466696c652e636f6d2f696d616765732f6c6f676f2e6a7067\">\n</div>\n<div id=\"overview\">\n<h2>Overview</h2>\n<p>A complete wrapper for the libarchive library generated using SWIG.\nAlso included in the package are compatibility layers for the Python\nzipfile and tarfile modules.</p>\n<p>Libarchive supports the following:</p>\n<blockquote>\n<ul>\n<li>Reads a variety of formats, including tar, pax, cpio, zip, xar, lha, ar, cab, mtree, rar, and ISO images.</li>\n<li>Writes tar, pax, cpio, zip, xar, ar, ISO, mtree, and shar archives.</li>\n<li>Automatically handles archives compressed with gzip, bzip2, lzip, xz, lzma, or compress.</li>\n</ul>\n</blockquote>\n<p>For information on installing libarchive and python-libarchive, see the <a href=\"http://code.google.com/p/python-libarchive/wiki/Building\" rel=\"nofollow\">Building</a>.</p>\n</div>\n<div id=\"introduction\">\n<h2>Introduction</h2>\n<p>There are actually two APIs exposed by this library.</p>\n<p>The first API is a high level pythonic class-based interface that should seem comfortable to Python developers. If you are just getting started with python-libarchive, this is probably where you should start.</p>\n<p>The second API is a low-level wrapper around libarchive. This wrapper provides access to the C API exposed by libarchive. A few additions or changes were made to allow easy consumption from Python, but otherwise, most libarchive example code will work (although with Python syntax). This API will be useful to those familiar with libarchive, or those that need functionality not available in the high level API.</p>\n</div>\n<div id=\"using-the-high-level-api\">\n<h2>Using the high-level API</h2>\n<p>The high level API provides a pythonic class-based interface for working with archives. On top of this is a very thin compatibility wrapper for the standard Python zipfile and tarfile modules. Since the standard Python zipfile and tarfile modules both present a different interface, so do the compatibility wrappers.</p>\n<p>These compatibility wrappers are provided so that python-libarchive can be a drop-in replacement for the standard modules. A reason to use libarchive instead of the standard modules is that it provides native performance and better memory consumption. So if you already have code using one of these modules, you can sin many cases just replace the standard module with the libarchive alternative.</p>\n<p>However, if you are developing a new project, it is recommended that you forgo the compatibility wrappers. Using the high-level API directly means you can support the many archive formats that libarchive does through the same standard interface.</p>\n<p>The workhorse of the high-level API is the Archive class. This is a forward-only iterator that allows you to open an archive of any supported formant and iterate it\u2019s contents.</p>\n<blockquote>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">libarchive</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">libarchive</span><span class=\"o\">.</span><span class=\"n\">Archive</span><span class=\"p\">(</span><span class=\"s1\">'my_archive.zip'</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">entry</span> <span class=\"ow\">in</span> <span class=\"n\">a</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span> <span class=\"n\">entry</span><span class=\"o\">.</span><span class=\"n\">pathname</span>\n<span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n</pre>\n</blockquote>\n<p>python-libarchive is also a context manager, so the above could be written as:</p>\n<blockquote>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">libarchive</span>\n\n<span class=\"k\">with</span> <span class=\"n\">libarchive</span><span class=\"o\">.</span><span class=\"n\">Archive</span><span class=\"p\">(</span><span class=\"s1\">'my_archive.zip'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">a</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">entry</span> <span class=\"ow\">in</span> <span class=\"n\">a</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span> <span class=\"n\">entry</span><span class=\"o\">.</span><span class=\"n\">pathname</span>\n</pre>\n</blockquote>\n<p>You can also extract files. However, you can only extract the current item. Once you have iterated past an entry, there is no going back.</p>\n<blockquote>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">libarchive</span>\n\n<span class=\"k\">with</span> <span class=\"n\">libarchive</span><span class=\"o\">.</span><span class=\"n\">Archive</span><span class=\"p\">(</span><span class=\"s1\">'my_archive.zip'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">a</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">entry</span> <span class=\"ow\">in</span> <span class=\"n\">a</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">entry</span><span class=\"o\">.</span><span class=\"n\">pathname</span> <span class=\"o\">==</span> <span class=\"s1\">'my_file.txt'</span><span class=\"p\">:</span>\n            <span class=\"nb\">print</span> <span class=\"s1\">'File Contents:'</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">()</span>\n</pre>\n</blockquote>\n<p>Besides the read() method, there is also readpath() and readstream(). Readpath() will extract the file to a path or already opened file. Readstream() will return a file-like object that can be used to read chunks of the file. Larger files being read from the archive should probably use one of these functions instead of read() which will read then entire contents into memory.</p>\n<p>Writing archives is also straightforward. You open an Archive() class then add files to it using one of the write() methods.</p>\n<blockquote>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">libarchive</span>\n\n<span class=\"k\">with</span> <span class=\"n\">libarchive</span><span class=\"o\">.</span><span class=\"n\">Archive</span><span class=\"p\">(</span><span class=\"s1\">'my_archive.zip'</span><span class=\"p\">,</span> <span class=\"s1\">'w'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">a</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">name</span> <span class=\"ow\">in</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">listdir</span><span class=\"p\">(</span><span class=\"s1\">'.'</span><span class=\"p\">):</span>\n        <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">libarchive</span><span class=\"o\">.</span><span class=\"n\">Entry</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">),</span> <span class=\"n\">file</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"s1\">'r'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">())</span>\n</pre>\n</blockquote>\n<p>Again, there is also a writepath() method which will write a file-like object or path directly to the archive. The above example could have been written as the following.</p>\n<blockquote>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">libarchive</span>\n\n<span class=\"k\">with</span> <span class=\"n\">libarchive</span><span class=\"o\">.</span><span class=\"n\">Archive</span><span class=\"p\">(</span><span class=\"s1\">'my_archive.zip'</span><span class=\"p\">,</span> <span class=\"s1\">'w'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">a</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">name</span> <span class=\"ow\">in</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">listdir</span><span class=\"p\">(</span><span class=\"s1\">'.'</span><span class=\"p\">):</span>\n        <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">writepath</span><span class=\"p\">(</span><span class=\"n\">libarchive</span><span class=\"o\">.</span><span class=\"n\">Entry</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">),</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n</pre>\n</blockquote>\n<p>In addition to the Archive class. There is also SeekableArchive. This class provides random access when reading an archive. It will remember where entries are located within the archive stream, and will close/reopen the stream and seek to the entry\u2019s location. So, you can extract an item directly. The first example can be written as follows.</p>\n<blockquote>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">libarchive</span>\n\n<span class=\"k\">with</span> <span class=\"n\">libarchive</span><span class=\"o\">.</span><span class=\"n\">SeekableArchive</span><span class=\"p\">(</span><span class=\"s1\">'my_archive.zip'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">a</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span> <span class=\"s1\">'File Contents:'</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"s1\">'my_file.txt'</span><span class=\"p\">)</span>\n</pre>\n</blockquote>\n<p>There is overhead involved in using the SeekableArchive, so it is suggested that you use the Archive in cases that you don\u2019t need random access to an archives entries. In fact, the above example was probably better off using the Archive class.</p>\n</div>\n<div id=\"using-the-low-level-api\">\n<h2>Using the low-level API</h2>\n<p>Using the low-level API leaves all the work to you. You will need to be careful to create and free libarchive structures yourself. You will also need to be well-versed in the return codes and expected parameters of libarchive. In fact, if you are not, then you probably should stop reading now.</p>\n<blockquote>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">libarchive</span> <span class=\"kn\">import</span> <span class=\"n\">_libarchive</span>\n\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">archive_read_new</span><span class=\"p\">()</span>\n<span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">archive_read_support_filter_all</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">archive_read_support_format_all</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">archive_read_open_fd</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">fileno</span><span class=\"p\">(),</span> <span class=\"mi\">10240</span><span class=\"p\">)</span>\n<span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n    <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">archive_entry_new</span><span class=\"p\">()</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">archive_read_next_header2</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">e</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">r</span> <span class=\"o\">!=</span> <span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">ARCHIVE_OK</span><span class=\"p\">:</span>\n            <span class=\"k\">break</span>\n        <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">archive_entry_pathname</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"s1\">'my_file.txt'</span><span class=\"p\">:</span>\n            <span class=\"k\">continue</span>\n        <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">archive_entry_size</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span>\n        <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">archive_read_data_into_str</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">)</span>\n        <span class=\"nb\">print</span> <span class=\"s1\">'File Contents:'</span><span class=\"p\">,</span> <span class=\"n\">s</span>\n    <span class=\"k\">finally</span><span class=\"p\">:</span>\n        <span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">archive_entry_free</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span>\n<span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">archive_read_close</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"n\">_libarchive</span><span class=\"o\">.</span><span class=\"n\">archive_read_free</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n</pre>\n</blockquote>\n<p>As you can see this is a lot more work for little benefit. But as stated before, you may end up interacting with the low-level API if some of the functionality you require is not covered in the high-level API.</p>\n<p>And as always, patches are appreciated!</p>\n</div>\n<div id=\"installing-libarchive\">\n<h2>Installing libarchive</h2>\n<p>Many Linux distributions include libarchive 2. This extension only works with libarchive 3. In these cases, you must install libarchive to a /usr/local. This will allow it to co-exist with the version installed with your distribution. To install libarchive using autoconf, follow the instructions below.</p>\n<p>Prerequisites.</p>\n<p>You will need either automake or cmake to install libarchive. Also required is python-dev. In addition, you will also need a compiler and some other tools. To install these prerequisites do the following:</p>\n<p>On Debian/Ubuntu:</p>\n<blockquote>\n<pre># Install compiler and tools\n$ sudo apt-get install build-essential libtool python-dev\n\n# Install automake\n$ sudo apt-get install automake\n\n# Or install cmake\n$ sudo apt-get install cmake\n</pre>\n</blockquote>\n<p>Or CentOS/Fedora:</p>\n<blockquote>\n<pre># Install compiler and tools\n$ sudo yum groupinstall \"Development Tools\"\n$ sudo yum install python-devel libtool\n\n# Install automake\n$ sudo yum install automake\n\n# Or install cmake\n$ sudo yum install cmake\n</pre>\n</blockquote>\n<p>You should now be able to install libarchive.</p>\n<blockquote>\n<pre>$ wget http://libarchive.googlecode.com/files/libarchive-3.0.3.tar.gz\n$ tar xzf libarchive-3.0.3.tar.gz\n\n# Configure using automake...\n$ cd libarchive-3.0.3/\n$ build/autogen.sh\n$ ./configure --prefix=/usr/local\n\n# Or configure using cmake...\n$ mkdir build\n$ cd build\n$ cmake -DCMAKE_INSTALL_PREFIX=/usr/local ../libarchive-3.0.3\n\n# Now compile and install...\n$ make\n$ sudo make install\n</pre>\n</blockquote>\n<p>Now that the library is installed, you need to tell ld where to find it. The easiest way to do this is to add /usr/local/lib to the ld.so.conf.</p>\n<blockquote>\n<pre>$ sudo sh -c 'echo /usr/local/lib &gt; /etc/ld.so.conf.d/libarchive3.conf'\n$ sudo ldconfig\n</pre>\n</blockquote>\n<p>Now libarchive 3.0.3 is installed into /usr/local/. The next step is to build and install python-libarchive.</p>\n</div>\n<div id=\"installing-python-libarchive\">\n<h2>Installing python-libarchive</h2>\n<p>Now that libarchive is installed, you can install the python extension using the steps below.</p>\n<blockquote>\n<pre>$ wget http://python-libarchive.googlecode.com/files/python-libarchive-3.0.3-2.tar.gz\n$ tar xzf python-libarchive-3.0.3-2.tar.gz\n$ cd python-libarchive-3.0.3-2/\n$ sudo python setup.py install\n</pre>\n</blockquote>\n<p>You can also install using pip.</p>\n<blockquote>\n<pre>$ pip install python-libarchive\n</pre>\n</blockquote>\n<p>setup.py will explicitly link against version 3.0.3 of the library.</p>\n</div>\n<div id=\"hacking-running-the-test-suite\">\n<h2>Hacking / Running the Test Suite</h2>\n<p>The test suite is located in the root directory. This is done purposefully to make hacking easier. If you make changes to the library, you can run the test suite against the local copy in the libarchive/ subdirectory rather than the version installed on your system.</p>\n<p>However, this means you need to have the extension compiled in this same directory. You will also need SWIG for this step. You can accomplish this using the following commands.</p>\n<p>On Debian/Ubuntu:</p>\n<blockquote>\n<pre>$ sudo apt-get install swig\n</pre>\n</blockquote>\n<p>Or CentOS/Fedora:</p>\n<blockquote>\n<pre>$ sudo yum install swig\n</pre>\n</blockquote>\n<p>Now you can re-SWIG the interface and recompile the extension.</p>\n<blockquote>\n<pre>$ cd libarchive/\n$ make\n$ cd ..\n</pre>\n</blockquote>\n<p>Now you can run the test suite from the main directory.</p>\n<blockquote>\n<pre>$ python tests.py\n</pre>\n</blockquote>\n</div>\n\n          </div>"}, "last_serial": 6795316, "releases": {"3.0.4-5": [], "3.1.2-1": [{"comment_text": "", "digests": {"md5": "edf2893eecd1a137f361bb1e1a13a2e7", "sha256": "e51a56fd06148a979abddd0a6512dbdd2913a529063adab28cf4015dfccc653b"}, "downloads": -1, "filename": "python-libarchive-3.1.2-1.tar.gz", "has_sig": false, "md5_digest": "edf2893eecd1a137f361bb1e1a13a2e7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 73243, "upload_time": "2013-06-06T01:40:41", "upload_time_iso_8601": "2013-06-06T01:40:41.860024Z", "url": "https://files.pythonhosted.org/packages/c8/a6/3019a11fc89d88d4d3b23d00bd07dc7cfe8601e559c72afaa97901ea61e4/python-libarchive-3.1.2-1.tar.gz", "yanked": false}], "4.0.0.post1": [{"comment_text": "", "digests": {"md5": "4521fc8d00625e106772e37fee052d79", "sha256": "ad42437ccb3541bbf46f7bbc840749fc1608304eac7f64c66fee595760c7422d"}, "downloads": -1, "filename": "python-libarchive-4.0.0.post1.tar.gz", "has_sig": false, "md5_digest": "4521fc8d00625e106772e37fee052d79", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51720, "upload_time": "2020-02-08T23:20:08", "upload_time_iso_8601": "2020-02-08T23:20:08.710268Z", "url": "https://files.pythonhosted.org/packages/9a/6d/f320b0fbf9aa1eb2eead7a4a8cf5d7802d83a9938b527fe6b1df8ac85046/python-libarchive-4.0.0.post1.tar.gz", "yanked": false}], "4.0.1.post1": [{"comment_text": "", "digests": {"md5": "faa9894f554e4c62519cb9d8a93852a5", "sha256": "488b56a6f42927a60a2d8c5d908be286435139ec211c9770f77b5bd133351160"}, "downloads": -1, "filename": "python-libarchive-4.0.1.post1.tar.gz", "has_sig": false, "md5_digest": "faa9894f554e4c62519cb9d8a93852a5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51722, "upload_time": "2020-03-11T20:22:55", "upload_time_iso_8601": "2020-03-11T20:22:55.586481Z", "url": "https://files.pythonhosted.org/packages/eb/da/ed182b7b738c598d6bcae9534bd6c701f87d73404f164dba92709bca9149/python-libarchive-4.0.1.post1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "faa9894f554e4c62519cb9d8a93852a5", "sha256": "488b56a6f42927a60a2d8c5d908be286435139ec211c9770f77b5bd133351160"}, "downloads": -1, "filename": "python-libarchive-4.0.1.post1.tar.gz", "has_sig": false, "md5_digest": "faa9894f554e4c62519cb9d8a93852a5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51722, "upload_time": "2020-03-11T20:22:55", "upload_time_iso_8601": "2020-03-11T20:22:55.586481Z", "url": "https://files.pythonhosted.org/packages/eb/da/ed182b7b738c598d6bcae9534bd6c701f87d73404f164dba92709bca9149/python-libarchive-4.0.1.post1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:16:52 2020"}