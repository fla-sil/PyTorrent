{"info": {"author": "Babylon Health", "author_email": "kristian.boda@babylonhealth.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3.6"], "description": "# Hammurabi [hmrb] \ud83c\udffa\n\nUpholds the law for sequences.\n\n### 1. Installation\n\nTo begin, simply install the package from PyPI:\n```shell\n$ pip install hmrb\n```\n\n### 2. Tests\n\n```shell\n$ make test\n```\n\n### 3. Documentation\n\nDocumentation is currently provided through offline ReadtheDocs.\n\n```shell\n$ pip install -r doc_requirements.txt\n$ pip install -e .\n$ make docs\n$ make help\n```\n\n### 4. Definitions\n\nHammurabi works as a rule engine to parse input using a defined set of rules.\nIt uses a simple and readable syntax to define complex rules to handle phrase matching.\n\nThe engine takes as input any type of sequences of units with associated attributes.\nOur usecase currently is to handle language annotation, but we expect it to work\nequally well on a variety of complex sequence tasks (time-series, logging).\n\nThe attributes do not have to be consistent across all units or between the \nunits and the grammar. The lack of an attribute is simply considered as a \nnon-match.\n\nFeatures:\n- Attribute level rule definitions using key-values pairs\n- Efficient matching of sequence using hash tables with no limit on length\n- Support for nested boolean expressions and wildcard operators similar to regular expressions\n- Variables can be side-loaded and reused throughout different rule sets\n- User-defined rule-level callback functions triggered by a match\n- Labels to tag and retrieve matched sequence segments\n\n#### 4.1 Writing Rules\n\nRules are defined in a custom syntax. The syntax was defined \nwith the aim to keep it simple to read, but expressive at the same time.\n\nThe basic components are `Law` and `Var`. Both `Law` and `Var` declare a sequence of attributes.\nHowever, while a `Law` can be matched on its own, a `Var` defines a sequence that is likely to be reused (a.k.a macros) within `Laws` or other `Vars`. Since a `Var` is never matched on its own, it requires a name and only exists as part of a rule body.\n\nThe example below shows a fictional case of capturing strings such as `\"head is hurting\"` or `\"head hurts\"`.\nNote that the variable `is_hurting` cannot match *is hurting*.\n\n```\nVar is_hurting:\n(\n    optional (lemma: \"be\")\n    (lemma: \"hurt\")\n)\n\nLaw:\n    - package: \"headache\"\n    - callback: \"mark_headache\"\n    - junk_attribute: \"some string\"\n(\n    (lemma: \"head\", pos: \"NOUN\")\n    $is_hurting\n)\n```\n\n#### 4.2 Input format\n\nHammurabi requires a sequence of attribute dictionaries as input. \nIt will attempt to find matching rules in the given input.\nThe most widely-used input format is a simple JSON list of dictionaries:\n\n```json\n[\n    {\"orth\": \"My\", \"lemma\": \"my\", \"pos\": \"PRON\"},\n    {\"orth\": \"head\", \"lemma\": \"head\", \"pos\": \"NOUN\"},\n    {\"orth\": \"hurts\", \"lemma\": \"hurt\", \"pos\": \"VERB\"}\n]\n```\n\n#### 4.3 Callbacks, labels and data\n\nWhen a rule matches an input, the following information is returned as a \n\"match\": the original input, a slice representing the span it was triggered on\nand all the data (labels, callback function and attributes) based on \nthe matched rule. There are two ways to act upon these matches. \nYou can use delegate the execution of the callback function to `hammurabi` \nor you can do the execution yourself. The former is done by passing the input \nto the `__call__` method, which executes callback functions right after \nthe matches are returned. However, this has a slight drawback, which is that \nyour callback functions need to adhere to a specific signature to allow them \nto be called correctly from inside `hammurabi`.\n \n\n```python\n# callback function called from inside hammurabi\ndef mark_headache(input_, slice_, data):\n    print(f'I am acting on span \"{input_[slice_]}\" with data \"{data}\".')\n```\n\nThe callback functions are passed down as a mapping between their string alias\nused in the rule grammar, i.e. how do you refer to it in the `callback` \nattribute of the law that was matched. \n\n```python\ncallbacks = {\n    'mark_headache': mark_headache\n}\n```\n\n### 5. Usage\n\n#### 5.1  Worked-out example with callbacks\n\nThe rule engine is initialized through a `Core` instance. We can pass various optional \nobjects to the constructor of `Core` (callbacks, sets) that we intend to later use in our rules.\n\nThe `Core.load` method adds rules to the engine.\nIt is possible to load multiple rule files sequentially.\n\nThe `Core` library usage pattern allows the user to either get the\nmatches and act on them in a different place through the use of the `match`\nmethod, or to pass a callback mapping and allow `hammurabi` to execute the\ncallbacks through the use of the `__call__` method.\n\n```python\ngrammar = \"\"\"\nVar is_hurting:\n(\n    optional (lemma: \"be\")\n    (lemma: \"hurt\")\n)\n\nLaw:\n    - package: \"headache\"\n    - callback: \"mark_headache\"\n    - junk_attribute: \"some string\"\n(\n    (lemma: \"head\", pos: \"NOUN\")\n    $is_hurting\n)\n\"\"\"\n\ninput_ = [\n    {\"orth\": \"My\", \"lemma\": \"my\", \"pos\": \"PRON\"},\n    {\"orth\": \"head\", \"lemma\": \"head\", \"pos\": \"NOUN\"},\n    {\"orth\": \"hurts\", \"lemma\": \"hurt\", \"pos\": \"VERB\"},\n]\n\n# Library use case\n\nfrom hmrb.core import Core\n\nspans = [(start, input_[start:]) for start in range(len(input_))]\n\nhmb_ext = Core()\nhmb_ext.load(grammar)\n\n# external execution\nfor span, data in hmb_ext._match(spans):\n    print(\"External execution!!!\")\n    slice_ = slice(span[0], span[1])\n    callbacks[data[0][\"callback\"]](input_, slice_, data)\n\n# External execution!!!\n# I am acting on span \"head hurts\" with data \n# \"{\n#      'package': 'headache', \n#      'callback': 'mark_headache', \n#      'junk_attribute': 'some string'\n# }\"\n\n\n# internal execution\nhmb_int = Core(callbacks={\"mark_headache\": mark_headache})\nhmb_int.load(grammar)\nhmb_int(input_)\n#  I am acting on span \"head hurts\" with data\n#  \"{\n#       'package': 'headache',\n#       'callback': 'mark_headache',\n#       'junk_attribute': 'pointless strings I am passing down because I can'\n#  }\"\n```\n\nYou can find this worked out example under `examples/readme.py`.\n\n#### 5.2 spaCy component example (NLP)\n\nThe spaCy component class `SpacyCore` extends the internal execution shown \nabove to allow the use of `hammurabi` in spaCy natural language processing \npipelines. Optionally a function (jsonify) can be passed into the SpacyCore\nto convert the `Token` objects to JSON.\n\n```python\nimport spacy\nfrom hmrb.core import SpacyCore\n\n# This will be used to turn a span (subsequence) of a spaCy document object\n# into a list of dictionaries input representation.\ndef jsonify(span):\n    jsn = []\n    for token in span:\n        jsn.append({\n            'orth': token.orth_,\n            'lemma': token.lemma_,\n            'pos': token.pos_,\n            'tag': token.tag_\n        })\n    return jsn\n\nhmb = SpacyCore(callbacks={'mark_headache': mark_headache}, map_doc=jsonify,\n                sort_length = True)\nhmb.load(grammar)\n\nnlp = spacy.load('en_core_web_sm')\nnlp.add_pipe(hmb, last=True)\nnlp('My head hurts')\n#  I am acting on span \"head hurts\" with data \n#  \"{\n#       'package': 'headache', \n#       'callback': 'mark_headache', \n#       'junk_attribute': 'pointless strings I am passing down because I can'\n#  }\"\n```\n\n### 6. Maintainers\n\n[@bodak](https://github.com/bodak) & [@savkov](https://github.com/savkov)", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/babylonhealth/hmrb", "keywords": "", "license": "Apache License 2.0", "maintainer": "", "maintainer_email": "", "name": "hmrb", "package_url": "https://pypi.org/project/hmrb/", "platform": "", "project_url": "https://pypi.org/project/hmrb/", "project_urls": {"Homepage": "https://github.com/babylonhealth/hmrb"}, "release_url": "https://pypi.org/project/hmrb/1.0.0/", "requires_dist": null, "requires_python": "", "summary": "Hammurabi", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Hammurabi [hmrb] \ud83c\udffa</h1>\n<p>Upholds the law for sequences.</p>\n<h3>1. Installation</h3>\n<p>To begin, simply install the package from PyPI:</p>\n<pre>$ pip install hmrb\n</pre>\n<h3>2. Tests</h3>\n<pre>$ make <span class=\"nb\">test</span>\n</pre>\n<h3>3. Documentation</h3>\n<p>Documentation is currently provided through offline ReadtheDocs.</p>\n<pre>$ pip install -r doc_requirements.txt\n$ pip install -e .\n$ make docs\n$ make <span class=\"nb\">help</span>\n</pre>\n<h3>4. Definitions</h3>\n<p>Hammurabi works as a rule engine to parse input using a defined set of rules.\nIt uses a simple and readable syntax to define complex rules to handle phrase matching.</p>\n<p>The engine takes as input any type of sequences of units with associated attributes.\nOur usecase currently is to handle language annotation, but we expect it to work\nequally well on a variety of complex sequence tasks (time-series, logging).</p>\n<p>The attributes do not have to be consistent across all units or between the\nunits and the grammar. The lack of an attribute is simply considered as a\nnon-match.</p>\n<p>Features:</p>\n<ul>\n<li>Attribute level rule definitions using key-values pairs</li>\n<li>Efficient matching of sequence using hash tables with no limit on length</li>\n<li>Support for nested boolean expressions and wildcard operators similar to regular expressions</li>\n<li>Variables can be side-loaded and reused throughout different rule sets</li>\n<li>User-defined rule-level callback functions triggered by a match</li>\n<li>Labels to tag and retrieve matched sequence segments</li>\n</ul>\n<h4>4.1 Writing Rules</h4>\n<p>Rules are defined in a custom syntax. The syntax was defined\nwith the aim to keep it simple to read, but expressive at the same time.</p>\n<p>The basic components are <code>Law</code> and <code>Var</code>. Both <code>Law</code> and <code>Var</code> declare a sequence of attributes.\nHowever, while a <code>Law</code> can be matched on its own, a <code>Var</code> defines a sequence that is likely to be reused (a.k.a macros) within <code>Laws</code> or other <code>Vars</code>. Since a <code>Var</code> is never matched on its own, it requires a name and only exists as part of a rule body.</p>\n<p>The example below shows a fictional case of capturing strings such as <code>\"head is hurting\"</code> or <code>\"head hurts\"</code>.\nNote that the variable <code>is_hurting</code> cannot match <em>is hurting</em>.</p>\n<pre><code>Var is_hurting:\n(\n    optional (lemma: \"be\")\n    (lemma: \"hurt\")\n)\n\nLaw:\n    - package: \"headache\"\n    - callback: \"mark_headache\"\n    - junk_attribute: \"some string\"\n(\n    (lemma: \"head\", pos: \"NOUN\")\n    $is_hurting\n)\n</code></pre>\n<h4>4.2 Input format</h4>\n<p>Hammurabi requires a sequence of attribute dictionaries as input.\nIt will attempt to find matching rules in the given input.\nThe most widely-used input format is a simple JSON list of dictionaries:</p>\n<pre><span class=\"p\">[</span>\n    <span class=\"p\">{</span><span class=\"nt\">\"orth\"</span><span class=\"p\">:</span> <span class=\"s2\">\"My\"</span><span class=\"p\">,</span> <span class=\"nt\">\"lemma\"</span><span class=\"p\">:</span> <span class=\"s2\">\"my\"</span><span class=\"p\">,</span> <span class=\"nt\">\"pos\"</span><span class=\"p\">:</span> <span class=\"s2\">\"PRON\"</span><span class=\"p\">},</span>\n    <span class=\"p\">{</span><span class=\"nt\">\"orth\"</span><span class=\"p\">:</span> <span class=\"s2\">\"head\"</span><span class=\"p\">,</span> <span class=\"nt\">\"lemma\"</span><span class=\"p\">:</span> <span class=\"s2\">\"head\"</span><span class=\"p\">,</span> <span class=\"nt\">\"pos\"</span><span class=\"p\">:</span> <span class=\"s2\">\"NOUN\"</span><span class=\"p\">},</span>\n    <span class=\"p\">{</span><span class=\"nt\">\"orth\"</span><span class=\"p\">:</span> <span class=\"s2\">\"hurts\"</span><span class=\"p\">,</span> <span class=\"nt\">\"lemma\"</span><span class=\"p\">:</span> <span class=\"s2\">\"hurt\"</span><span class=\"p\">,</span> <span class=\"nt\">\"pos\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VERB\"</span><span class=\"p\">}</span>\n<span class=\"p\">]</span>\n</pre>\n<h4>4.3 Callbacks, labels and data</h4>\n<p>When a rule matches an input, the following information is returned as a\n\"match\": the original input, a slice representing the span it was triggered on\nand all the data (labels, callback function and attributes) based on\nthe matched rule. There are two ways to act upon these matches.\nYou can use delegate the execution of the callback function to <code>hammurabi</code>\nor you can do the execution yourself. The former is done by passing the input\nto the <code>__call__</code> method, which executes callback functions right after\nthe matches are returned. However, this has a slight drawback, which is that\nyour callback functions need to adhere to a specific signature to allow them\nto be called correctly from inside <code>hammurabi</code>.</p>\n<pre><span class=\"c1\"># callback function called from inside hammurabi</span>\n<span class=\"k\">def</span> <span class=\"nf\">mark_headache</span><span class=\"p\">(</span><span class=\"n\">input_</span><span class=\"p\">,</span> <span class=\"n\">slice_</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'I am acting on span \"</span><span class=\"si\">{</span><span class=\"n\">input_</span><span class=\"p\">[</span><span class=\"n\">slice_</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s1\">\" with data \"</span><span class=\"si\">{</span><span class=\"n\">data</span><span class=\"si\">}</span><span class=\"s1\">\".'</span><span class=\"p\">)</span>\n</pre>\n<p>The callback functions are passed down as a mapping between their string alias\nused in the rule grammar, i.e. how do you refer to it in the <code>callback</code>\nattribute of the law that was matched.</p>\n<pre><span class=\"n\">callbacks</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'mark_headache'</span><span class=\"p\">:</span> <span class=\"n\">mark_headache</span>\n<span class=\"p\">}</span>\n</pre>\n<h3>5. Usage</h3>\n<h4>5.1  Worked-out example with callbacks</h4>\n<p>The rule engine is initialized through a <code>Core</code> instance. We can pass various optional\nobjects to the constructor of <code>Core</code> (callbacks, sets) that we intend to later use in our rules.</p>\n<p>The <code>Core.load</code> method adds rules to the engine.\nIt is possible to load multiple rule files sequentially.</p>\n<p>The <code>Core</code> library usage pattern allows the user to either get the\nmatches and act on them in a different place through the use of the <code>match</code>\nmethod, or to pass a callback mapping and allow <code>hammurabi</code> to execute the\ncallbacks through the use of the <code>__call__</code> method.</p>\n<pre><span class=\"n\">grammar</span> <span class=\"o\">=</span> <span class=\"s2\">\"\"\"</span>\n<span class=\"s2\">Var is_hurting:</span>\n<span class=\"s2\">(</span>\n<span class=\"s2\">    optional (lemma: \"be\")</span>\n<span class=\"s2\">    (lemma: \"hurt\")</span>\n<span class=\"s2\">)</span>\n\n<span class=\"s2\">Law:</span>\n<span class=\"s2\">    - package: \"headache\"</span>\n<span class=\"s2\">    - callback: \"mark_headache\"</span>\n<span class=\"s2\">    - junk_attribute: \"some string\"</span>\n<span class=\"s2\">(</span>\n<span class=\"s2\">    (lemma: \"head\", pos: \"NOUN\")</span>\n<span class=\"s2\">    $is_hurting</span>\n<span class=\"s2\">)</span>\n<span class=\"s2\">\"\"\"</span>\n\n<span class=\"n\">input_</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"p\">{</span><span class=\"s2\">\"orth\"</span><span class=\"p\">:</span> <span class=\"s2\">\"My\"</span><span class=\"p\">,</span> <span class=\"s2\">\"lemma\"</span><span class=\"p\">:</span> <span class=\"s2\">\"my\"</span><span class=\"p\">,</span> <span class=\"s2\">\"pos\"</span><span class=\"p\">:</span> <span class=\"s2\">\"PRON\"</span><span class=\"p\">},</span>\n    <span class=\"p\">{</span><span class=\"s2\">\"orth\"</span><span class=\"p\">:</span> <span class=\"s2\">\"head\"</span><span class=\"p\">,</span> <span class=\"s2\">\"lemma\"</span><span class=\"p\">:</span> <span class=\"s2\">\"head\"</span><span class=\"p\">,</span> <span class=\"s2\">\"pos\"</span><span class=\"p\">:</span> <span class=\"s2\">\"NOUN\"</span><span class=\"p\">},</span>\n    <span class=\"p\">{</span><span class=\"s2\">\"orth\"</span><span class=\"p\">:</span> <span class=\"s2\">\"hurts\"</span><span class=\"p\">,</span> <span class=\"s2\">\"lemma\"</span><span class=\"p\">:</span> <span class=\"s2\">\"hurt\"</span><span class=\"p\">,</span> <span class=\"s2\">\"pos\"</span><span class=\"p\">:</span> <span class=\"s2\">\"VERB\"</span><span class=\"p\">},</span>\n<span class=\"p\">]</span>\n\n<span class=\"c1\"># Library use case</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">hmrb.core</span> <span class=\"kn\">import</span> <span class=\"n\">Core</span>\n\n<span class=\"n\">spans</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">input_</span><span class=\"p\">[</span><span class=\"n\">start</span><span class=\"p\">:])</span> <span class=\"k\">for</span> <span class=\"n\">start</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">input_</span><span class=\"p\">))]</span>\n\n<span class=\"n\">hmb_ext</span> <span class=\"o\">=</span> <span class=\"n\">Core</span><span class=\"p\">()</span>\n<span class=\"n\">hmb_ext</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">grammar</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># external execution</span>\n<span class=\"k\">for</span> <span class=\"n\">span</span><span class=\"p\">,</span> <span class=\"n\">data</span> <span class=\"ow\">in</span> <span class=\"n\">hmb_ext</span><span class=\"o\">.</span><span class=\"n\">_match</span><span class=\"p\">(</span><span class=\"n\">spans</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"External execution!!!\"</span><span class=\"p\">)</span>\n    <span class=\"n\">slice_</span> <span class=\"o\">=</span> <span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"n\">span</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">span</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n    <span class=\"n\">callbacks</span><span class=\"p\">[</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"s2\">\"callback\"</span><span class=\"p\">]](</span><span class=\"n\">input_</span><span class=\"p\">,</span> <span class=\"n\">slice_</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># External execution!!!</span>\n<span class=\"c1\"># I am acting on span \"head hurts\" with data </span>\n<span class=\"c1\"># \"{</span>\n<span class=\"c1\">#      'package': 'headache', </span>\n<span class=\"c1\">#      'callback': 'mark_headache', </span>\n<span class=\"c1\">#      'junk_attribute': 'some string'</span>\n<span class=\"c1\"># }\"</span>\n\n\n<span class=\"c1\"># internal execution</span>\n<span class=\"n\">hmb_int</span> <span class=\"o\">=</span> <span class=\"n\">Core</span><span class=\"p\">(</span><span class=\"n\">callbacks</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s2\">\"mark_headache\"</span><span class=\"p\">:</span> <span class=\"n\">mark_headache</span><span class=\"p\">})</span>\n<span class=\"n\">hmb_int</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">grammar</span><span class=\"p\">)</span>\n<span class=\"n\">hmb_int</span><span class=\"p\">(</span><span class=\"n\">input_</span><span class=\"p\">)</span>\n<span class=\"c1\">#  I am acting on span \"head hurts\" with data</span>\n<span class=\"c1\">#  \"{</span>\n<span class=\"c1\">#       'package': 'headache',</span>\n<span class=\"c1\">#       'callback': 'mark_headache',</span>\n<span class=\"c1\">#       'junk_attribute': 'pointless strings I am passing down because I can'</span>\n<span class=\"c1\">#  }\"</span>\n</pre>\n<p>You can find this worked out example under <code>examples/readme.py</code>.</p>\n<h4>5.2 spaCy component example (NLP)</h4>\n<p>The spaCy component class <code>SpacyCore</code> extends the internal execution shown\nabove to allow the use of <code>hammurabi</code> in spaCy natural language processing\npipelines. Optionally a function (jsonify) can be passed into the SpacyCore\nto convert the <code>Token</code> objects to JSON.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">spacy</span>\n<span class=\"kn\">from</span> <span class=\"nn\">hmrb.core</span> <span class=\"kn\">import</span> <span class=\"n\">SpacyCore</span>\n\n<span class=\"c1\"># This will be used to turn a span (subsequence) of a spaCy document object</span>\n<span class=\"c1\"># into a list of dictionaries input representation.</span>\n<span class=\"k\">def</span> <span class=\"nf\">jsonify</span><span class=\"p\">(</span><span class=\"n\">span</span><span class=\"p\">):</span>\n    <span class=\"n\">jsn</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">token</span> <span class=\"ow\">in</span> <span class=\"n\">span</span><span class=\"p\">:</span>\n        <span class=\"n\">jsn</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">({</span>\n            <span class=\"s1\">'orth'</span><span class=\"p\">:</span> <span class=\"n\">token</span><span class=\"o\">.</span><span class=\"n\">orth_</span><span class=\"p\">,</span>\n            <span class=\"s1\">'lemma'</span><span class=\"p\">:</span> <span class=\"n\">token</span><span class=\"o\">.</span><span class=\"n\">lemma_</span><span class=\"p\">,</span>\n            <span class=\"s1\">'pos'</span><span class=\"p\">:</span> <span class=\"n\">token</span><span class=\"o\">.</span><span class=\"n\">pos_</span><span class=\"p\">,</span>\n            <span class=\"s1\">'tag'</span><span class=\"p\">:</span> <span class=\"n\">token</span><span class=\"o\">.</span><span class=\"n\">tag_</span>\n        <span class=\"p\">})</span>\n    <span class=\"k\">return</span> <span class=\"n\">jsn</span>\n\n<span class=\"n\">hmb</span> <span class=\"o\">=</span> <span class=\"n\">SpacyCore</span><span class=\"p\">(</span><span class=\"n\">callbacks</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'mark_headache'</span><span class=\"p\">:</span> <span class=\"n\">mark_headache</span><span class=\"p\">},</span> <span class=\"n\">map_doc</span><span class=\"o\">=</span><span class=\"n\">jsonify</span><span class=\"p\">,</span>\n                <span class=\"n\">sort_length</span> <span class=\"o\">=</span> <span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">hmb</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">grammar</span><span class=\"p\">)</span>\n\n<span class=\"n\">nlp</span> <span class=\"o\">=</span> <span class=\"n\">spacy</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'en_core_web_sm'</span><span class=\"p\">)</span>\n<span class=\"n\">nlp</span><span class=\"o\">.</span><span class=\"n\">add_pipe</span><span class=\"p\">(</span><span class=\"n\">hmb</span><span class=\"p\">,</span> <span class=\"n\">last</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">nlp</span><span class=\"p\">(</span><span class=\"s1\">'My head hurts'</span><span class=\"p\">)</span>\n<span class=\"c1\">#  I am acting on span \"head hurts\" with data </span>\n<span class=\"c1\">#  \"{</span>\n<span class=\"c1\">#       'package': 'headache', </span>\n<span class=\"c1\">#       'callback': 'mark_headache', </span>\n<span class=\"c1\">#       'junk_attribute': 'pointless strings I am passing down because I can'</span>\n<span class=\"c1\">#  }\"</span>\n</pre>\n<h3>6. Maintainers</h3>\n<p><a href=\"https://github.com/bodak\" rel=\"nofollow\">@bodak</a> &amp; <a href=\"https://github.com/savkov\" rel=\"nofollow\">@savkov</a></p>\n\n          </div>"}, "last_serial": 7137805, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "e73254d6aeeb3574826d701ae09fbe03", "sha256": "40a14ebe1810bf39a787706010c0b5f973569672d8e42481933dc71f1deb2f9d"}, "downloads": -1, "filename": "hmrb-1.0.0.tar.gz", "has_sig": false, "md5_digest": "e73254d6aeeb3574826d701ae09fbe03", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 453896, "upload_time": "2020-04-30T14:26:51", "upload_time_iso_8601": "2020-04-30T14:26:51.100357Z", "url": "https://files.pythonhosted.org/packages/36/88/f731358cb44d8db2f65f1b043f192d01dee0db0df70b3d6c843a8e717fe5/hmrb-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e73254d6aeeb3574826d701ae09fbe03", "sha256": "40a14ebe1810bf39a787706010c0b5f973569672d8e42481933dc71f1deb2f9d"}, "downloads": -1, "filename": "hmrb-1.0.0.tar.gz", "has_sig": false, "md5_digest": "e73254d6aeeb3574826d701ae09fbe03", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 453896, "upload_time": "2020-04-30T14:26:51", "upload_time_iso_8601": "2020-04-30T14:26:51.100357Z", "url": "https://files.pythonhosted.org/packages/36/88/f731358cb44d8db2f65f1b043f192d01dee0db0df70b3d6c843a8e717fe5/hmrb-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:50:54 2020"}