{"info": {"author": "Erik Nyquist", "author_email": "eknyquist@gmail.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "Intended Audience :: Education", "Intended Audience :: Information Technology", "Intended Audience :: Science/Research", "License :: OSI Approved :: Apache Software License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7"], "description": "fast Brainfuck interpreter in pure python\n=========================================\n\nThis is a pure python interpreter for the\n`Brainfuck <https://en.wikipedia.org/wiki/Brainfuck>`_ esoteric programming\nlanguage. ``bfi`` implements the standard optimisations for clear loop, copy\nloop, multiply loop and scan loop constructs, and is reasonably fast without\nrequiring any special python implementations or compiled extension modules.\nSupports Python 2x and 3x.\n\nCheck out `BrainfuckIntern <https://github.com/eriknyquist/BrainfuckIntern>`_,\nan implementation of a genetic algorithm that writes Brainfuck programs,\nusing ``bfi`` to provide information for a useful fitness evaluation on generated\nBrainfuck programs\n\nSpeed benchmark\n---------------\n\nHere is a quick comparison between ``bfi`` and two other popular pure-python\nbrainfuck interpreters on github. The time shown is the time that each\ninterpreter took to complete the \"Towers of Hanoi\" program (``hanoi.b``,\navailable in the ``examples`` directory):\n\n+---------------------------------------------------------------------------------+-------------------------------+\n| **Interpreter name**                                                            | **Time to complete hanoi.b**  |\n+=================================================================================+===============================+\n| bfi                                                                             | 1 minute, 9 seconds           |\n+---------------------------------------------------------------------------------+-------------------------------+\n| `pocmo's interpreter <https://github.com/pocmo/Python-Brainfuck>`_              | 28 minutes, 51 seconds        |\n+---------------------------------------------------------------------------------+-------------------------------+\n| `alexprengere's intrepreter <https://github.com/alexprengere/PythonBrainFuck>`_ | 1 hour, 7 minutes, 54 seconds |\n+---------------------------------------------------------------------------------+-------------------------------+\n\n(I should note here that alexprengere's interpreter can actually go\nmuch faster than this, but not without using the alternative PyPy interpreter,\nor compiling some stuff. Speeds here are shown without such modifications.\nAll tests were done using the standard CPython 2.7.14 interpreter)\n\nImplementation details\n----------------------\n\n* No change on EOF\n* Tape size is configurable, default is 30,000 cells\n* Cells are one byte, valid values between 0-255. Overflow/underflow wraps\n  around\n\nInstalling\n----------\n\nUse ``pip`` to install:\n\n::\n\n    pip install bfi\n\nUsing the interpreter from the command-line\n--------------------------------------------\n\nOnce installed, the brainfuck interpreter can be invoked from the command line\nusing the ``bfi`` command. Just run ``bfi`` and pass a brainfuck source file.\nSeveral sample Brainfuck programs are provided in the ``examples`` directory\nwithin the installed package (in your system's python2.7/dist-packages\ndirectory- on linux-based systems, for example, the full path might be\n/usr/local/lib/python2.7/dist-packages/bfi/examples).\n\nIn the sample commands below, we will run \"Lost Kingdom\", a text-based adventure\ngame written in Brainfuck:\n\n::\n\n    $> cd <dist-packages-directory>/bfi/examples\n    $> bfi LostKingdom.b\n\n\nUsing the interpreter in your own code\n--------------------------------------\n\nHere is how you use the ``bfi`` module to execute some Brainfuck code\nnormally (reading data directly from stdin and writing directly to stdout):\n\n::\n\n    >>> import bfi\n    >>> with open('samples/hello_world.b', 'r') as fh:\n    ...     brainfuck_code = fh.read()\n    ...\n    >>> Brainfuck.interpret(brainfuck_code)\n\n    Hello World!\n\n\nHere is how you use the ``bfi`` module to execute some Brainfuck code without\nreading/writing the user's terminal; input is passed a parameter to\n``interpret()``, and any output is returned as a string.\n\n::\n\n    >>> input_data = \"test input\"\n    >>> ret = bfi.interpret(brainfuck_code, stdin=input_data, buffer_stdout=True)\n    >>> print ret\n\n    Hello World!\n\nReference\n---------\n\nDocumentation for the python API is here: `<https://bfi.readthedocs.io>`_\n\nGratuitous unnecessary extras\n-----------------------------\n\nIn order to make Brainfuck code execute more efficiently, it is compiled into\nan intermediate form that takes advantage of common brainfuck idioms and\nconstructs. This intermediate form consists of 11 opcodes, 8 of which are\nsimilar to the original 8 brainfuck instructions. The following table describes\nthe opcodes:\n\n+-----------------------------------+-----------------------------------------+\n|            **Opcode**             |             **Description**             |\n+===================================+=========================================+\n|          ``move <off> <num>``     | Moves the cell pointer by ``<num>``     |\n|                                   | cells. ``<off>`` is unused              |\n+-----------------------------------+-----------------------------------------+\n|          ``sub <off> <num>``      | Moves the cell pointer by ``<off>``, and|\n|                                   | decrements value of current cell by     |\n|                                   | ``<num>`` cells                         |\n+-----------------------------------+-----------------------------------------+\n|          ``add <off> <num>``      | Moves the cell pointer by ``<off>``, and|\n|                                   | increments value of current cell by     |\n|                                   | ``<num>`` cells                         |\n+-----------------------------------+-----------------------------------------+\n|         ``open <off> <location>`` | ``<location>`` is an index into the list|\n|                                   | of program opcodes. If the value of     |\n|                                   | current cell is zero, jump to           |\n|                                   | ``<location>``. Otherwise, continue     |\n|                                   | execution normally (Same functionality  |\n|                                   | as brainfuck \"[\" instruction, except    |\n|                                   | jump location is stored with opcode).   |\n|                                   | ``<off>`` is unused                     |\n+-----------------------------------+-----------------------------------------+\n|         ``close <off> <location>``| ``<location>`` is an index into the list|\n|                                   | of program opcodes. If the value of     |\n|                                   | current cell is zero, continue execution|\n|                                   | normally. Otherwise, jump to            |\n|                                   | ``<location>`` (Same functionality as   |\n|                                   | brainfuck \"]\" instruction, except jump  |\n|                                   | location is stored with opcode). In all |\n|                                   | cases the cell pointer will be moved by |\n|                                   | ``<off>``                               |\n+-----------------------------------+-----------------------------------------+\n|             ``input <off>``       | Moves the cell pointer by ``<off>``,    |\n|                                   | then reads one character of input and   |\n|                                   | writes to current cell                  |\n+-----------------------------------+-----------------------------------------+\n|             ``output <off>``      | Moves the cell pointer by ``<off>``,    |\n|                                   | then prints value of current cell as    |\n|                                   | an ASCII character                      |\n+-----------------------------------+-----------------------------------------+\n|             ``clear <off>``       | Moves the cell pointer by ``<off>``,    |\n|                                   | then sets the value of current cell to  |\n|                                   | zero                                    |\n+-----------------------------------+-----------------------------------------+\n|  ``copy <off> {<o>:<m>,... }``    | Moves the cell pointer by ``<off>``,    |\n|                                   | then for each key/value pair, sets the  |\n|                                   | value of the cell at (current cell +    |\n|                                   | ``<o>``) to be (value of current cell * |\n|                                   | ``<m>``)                                |\n+-----------------------------------+-----------------------------------------+\n|             ``scanl <off>``       | Moves the cell pointer by ``<off>``,    |\n|                                   | then decrements the cell pointer until  |\n|                                   | it points at a cell containing 0        |\n+-----------------------------------+-----------------------------------------+\n|             ``scanr <off>``       | Moves the cell pointer by ``<off>``,    |\n|                                   | then increments the cell pointer until  |\n|                                   | it points at a cell containing 0        |\n+-----------------------------------+-----------------------------------------+\n\nIf you *really want to*, you can actually view a brainfuck program in this\nintermediate form, by using the ``bfi.parse`` method and printing the resulting\nopcodes:\n\n::\n\n    >>> with open('bfi/examples/mandel.b', 'r') as fh:\n    ...     program = fh.read()\n    ... \n    >>> opcodes = bfi.parse(program)\n    >>> for c in opcodes: print c\n    ...\n\n    add 0 13\n    copy 0 {1: 2, 4: 5, 5: 2, 6: 1}\n    add 5 6\n    sub 1 3\n    add 10 15\n    open 0 12\n    open 0 7\n    close 9 6\n    add 0 1\n    open 0 10\n\n    ... (long output, truncated ...)\n\nAnd of course, you can execute the compiled opcodes as many times as you like\nusing ``bfi.execute``.\n\nExample Brainfuck programs\n--------------------------\n\nI have included several random Brainfuck programs that I've found in various\nplaces. I didn't write any of these programs, I just copied them as-is\nfrom other public sources. Descriptive comments (and author's name, in some\ncases) can be seen in the Brainfuck source files themselves.\n\nA description of the example Brainfuck programs included with this package\nfollows:\n\n* **bfcl.bf**: A Brainfuck-to-ELF translator, in Brainfuck. Reads in Brainfuck\n  source from stdin and writes a Linux ELF file to stdout\n\n* **bitwidth.bf** Assorted tests for Brainfuck interpreter/compiler correctness\n\n* **collatz.b** A demonstration of the Collatz problem in Brainfuck\n\n* **eoftest.b** Tests EOF behaviour of brainfuck interpreters/compilers\n\n* **fib.b** Prints a neverending fibonacci sequence\n\n* **gameoflife.b** Conway's Game of Life in Brainfuck\n\n* **hanoi.b** Towers of Hanoi in Brainfuck\n\n* **hello_world.b** Classic \"hello, world!\" in Brainfuck\n\n* **LostKingdom.b** A text-based adventure game in Brainfuck\n\n* **mandel.b** An ASCII  mandelbrot fractal set viewer in Brainfuck\n\n* **numwarp.b** Prints an enlarged ASCII representation of numbers entered by\n  the user\n\n* **primes.bf** Prints prime numbers\n\n* **rot13.b** Prints the ROT13 encoding of the string entered by the user\n\n* **sierpinksi.b** Displays the Sierpinksi triangle\n\n* **TheBrainfuckedLoneWolf.b** ASCII asteroids-inspired top-down shooter game\n  in Brainfuck", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/eriknyquist/bfi", "keywords": "", "license": "Apache 2.0", "maintainer": "", "maintainer_email": "", "name": "bfi", "package_url": "https://pypi.org/project/bfi/", "platform": "", "project_url": "https://pypi.org/project/bfi/", "project_urls": {"Homepage": "http://github.com/eriknyquist/bfi"}, "release_url": "https://pypi.org/project/bfi/1.0.2/", "requires_dist": null, "requires_python": "", "summary": "A fast optimizing Brainfuck interpreter in pure python", "version": "1.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This is a pure python interpreter for the\n<a href=\"https://en.wikipedia.org/wiki/Brainfuck\" rel=\"nofollow\">Brainfuck</a> esoteric programming\nlanguage. <tt>bfi</tt> implements the standard optimisations for clear loop, copy\nloop, multiply loop and scan loop constructs, and is reasonably fast without\nrequiring any special python implementations or compiled extension modules.\nSupports Python 2x and 3x.</p>\n<p>Check out <a href=\"https://github.com/eriknyquist/BrainfuckIntern\" rel=\"nofollow\">BrainfuckIntern</a>,\nan implementation of a genetic algorithm that writes Brainfuck programs,\nusing <tt>bfi</tt> to provide information for a useful fitness evaluation on generated\nBrainfuck programs</p>\n<div id=\"speed-benchmark\">\n<h2>Speed benchmark</h2>\n<p>Here is a quick comparison between <tt>bfi</tt> and two other popular pure-python\nbrainfuck interpreters on github. The time shown is the time that each\ninterpreter took to complete the \u201cTowers of Hanoi\u201d program (<tt>hanoi.b</tt>,\navailable in the <tt>examples</tt> directory):</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th><strong>Interpreter name</strong></th>\n<th><strong>Time to complete hanoi.b</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr><td>bfi</td>\n<td>1 minute, 9 seconds</td>\n</tr>\n<tr><td><a href=\"https://github.com/pocmo/Python-Brainfuck\" rel=\"nofollow\">pocmo\u2019s interpreter</a></td>\n<td>28 minutes, 51 seconds</td>\n</tr>\n<tr><td><a href=\"https://github.com/alexprengere/PythonBrainFuck\" rel=\"nofollow\">alexprengere\u2019s intrepreter</a></td>\n<td>1 hour, 7 minutes, 54 seconds</td>\n</tr>\n</tbody>\n</table>\n<p>(I should note here that alexprengere\u2019s interpreter can actually go\nmuch faster than this, but not without using the alternative PyPy interpreter,\nor compiling some stuff. Speeds here are shown without such modifications.\nAll tests were done using the standard CPython 2.7.14 interpreter)</p>\n</div>\n<div id=\"implementation-details\">\n<h2>Implementation details</h2>\n<ul>\n<li>No change on EOF</li>\n<li>Tape size is configurable, default is 30,000 cells</li>\n<li>Cells are one byte, valid values between 0-255. Overflow/underflow wraps\naround</li>\n</ul>\n</div>\n<div id=\"installing\">\n<h2>Installing</h2>\n<p>Use <tt>pip</tt> to install:</p>\n<pre>pip install bfi\n</pre>\n</div>\n<div id=\"using-the-interpreter-from-the-command-line\">\n<h2>Using the interpreter from the command-line</h2>\n<p>Once installed, the brainfuck interpreter can be invoked from the command line\nusing the <tt>bfi</tt> command. Just run <tt>bfi</tt> and pass a brainfuck source file.\nSeveral sample Brainfuck programs are provided in the <tt>examples</tt> directory\nwithin the installed package (in your system\u2019s python2.7/dist-packages\ndirectory- on linux-based systems, for example, the full path might be\n/usr/local/lib/python2.7/dist-packages/bfi/examples).</p>\n<p>In the sample commands below, we will run \u201cLost Kingdom\u201d, a text-based adventure\ngame written in Brainfuck:</p>\n<pre>$&gt; cd &lt;dist-packages-directory&gt;/bfi/examples\n$&gt; bfi LostKingdom.b\n</pre>\n</div>\n<div id=\"using-the-interpreter-in-your-own-code\">\n<h2>Using the interpreter in your own code</h2>\n<p>Here is how you use the <tt>bfi</tt> module to execute some Brainfuck code\nnormally (reading data directly from stdin and writing directly to stdout):</p>\n<pre>&gt;&gt;&gt; import bfi\n&gt;&gt;&gt; with open('samples/hello_world.b', 'r') as fh:\n...     brainfuck_code = fh.read()\n...\n&gt;&gt;&gt; Brainfuck.interpret(brainfuck_code)\n\nHello World!\n</pre>\n<p>Here is how you use the <tt>bfi</tt> module to execute some Brainfuck code without\nreading/writing the user\u2019s terminal; input is passed a parameter to\n<tt>interpret()</tt>, and any output is returned as a string.</p>\n<pre>&gt;&gt;&gt; input_data = \"test input\"\n&gt;&gt;&gt; ret = bfi.interpret(brainfuck_code, stdin=input_data, buffer_stdout=True)\n&gt;&gt;&gt; print ret\n\nHello World!\n</pre>\n</div>\n<div id=\"reference\">\n<h2>Reference</h2>\n<p>Documentation for the python API is here: <a href=\"https://bfi.readthedocs.io\" rel=\"nofollow\">https://bfi.readthedocs.io</a></p>\n</div>\n<div id=\"gratuitous-unnecessary-extras\">\n<h2>Gratuitous unnecessary extras</h2>\n<p>In order to make Brainfuck code execute more efficiently, it is compiled into\nan intermediate form that takes advantage of common brainfuck idioms and\nconstructs. This intermediate form consists of 11 opcodes, 8 of which are\nsimilar to the original 8 brainfuck instructions. The following table describes\nthe opcodes:</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th><strong>Opcode</strong></th>\n<th><strong>Description</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr><td><tt>move &lt;off&gt; &lt;num&gt;</tt></td>\n<td>Moves the cell pointer by <tt>&lt;num&gt;</tt>\ncells. <tt>&lt;off&gt;</tt> is unused</td>\n</tr>\n<tr><td><tt>sub &lt;off&gt; &lt;num&gt;</tt></td>\n<td>Moves the cell pointer by <tt>&lt;off&gt;</tt>, and\ndecrements value of current cell by\n<tt>&lt;num&gt;</tt> cells</td>\n</tr>\n<tr><td><tt>add &lt;off&gt; &lt;num&gt;</tt></td>\n<td>Moves the cell pointer by <tt>&lt;off&gt;</tt>, and\nincrements value of current cell by\n<tt>&lt;num&gt;</tt> cells</td>\n</tr>\n<tr><td><tt>open &lt;off&gt; &lt;location&gt;</tt></td>\n<td><tt>&lt;location&gt;</tt> is an index into the list\nof program opcodes. If the value of\ncurrent cell is zero, jump to\n<tt>&lt;location&gt;</tt>. Otherwise, continue\nexecution normally (Same functionality\nas brainfuck \u201c[\u201d instruction, except\njump location is stored with opcode).\n<tt>&lt;off&gt;</tt> is unused</td>\n</tr>\n<tr><td><tt>close &lt;off&gt; &lt;location&gt;</tt></td>\n<td><tt>&lt;location&gt;</tt> is an index into the list\nof program opcodes. If the value of\ncurrent cell is zero, continue execution\nnormally. Otherwise, jump to\n<tt>&lt;location&gt;</tt> (Same functionality as\nbrainfuck \u201c]\u201d instruction, except jump\nlocation is stored with opcode). In all\ncases the cell pointer will be moved by\n<tt>&lt;off&gt;</tt></td>\n</tr>\n<tr><td><tt>input &lt;off&gt;</tt></td>\n<td>Moves the cell pointer by <tt>&lt;off&gt;</tt>,\nthen reads one character of input and\nwrites to current cell</td>\n</tr>\n<tr><td><tt>output &lt;off&gt;</tt></td>\n<td>Moves the cell pointer by <tt>&lt;off&gt;</tt>,\nthen prints value of current cell as\nan ASCII character</td>\n</tr>\n<tr><td><tt>clear &lt;off&gt;</tt></td>\n<td>Moves the cell pointer by <tt>&lt;off&gt;</tt>,\nthen sets the value of current cell to\nzero</td>\n</tr>\n<tr><td><tt>copy &lt;off&gt; <span class=\"pre\">{&lt;o&gt;:&lt;m&gt;,...</span> }</tt></td>\n<td>Moves the cell pointer by <tt>&lt;off&gt;</tt>,\nthen for each key/value pair, sets the\nvalue of the cell at (current cell +\n<tt>&lt;o&gt;</tt>) to be (value of current cell *\n<tt>&lt;m&gt;</tt>)</td>\n</tr>\n<tr><td><tt>scanl &lt;off&gt;</tt></td>\n<td>Moves the cell pointer by <tt>&lt;off&gt;</tt>,\nthen decrements the cell pointer until\nit points at a cell containing 0</td>\n</tr>\n<tr><td><tt>scanr &lt;off&gt;</tt></td>\n<td>Moves the cell pointer by <tt>&lt;off&gt;</tt>,\nthen increments the cell pointer until\nit points at a cell containing 0</td>\n</tr>\n</tbody>\n</table>\n<p>If you <em>really want to</em>, you can actually view a brainfuck program in this\nintermediate form, by using the <tt>bfi.parse</tt> method and printing the resulting\nopcodes:</p>\n<pre>&gt;&gt;&gt; with open('bfi/examples/mandel.b', 'r') as fh:\n...     program = fh.read()\n...\n&gt;&gt;&gt; opcodes = bfi.parse(program)\n&gt;&gt;&gt; for c in opcodes: print c\n...\n\nadd 0 13\ncopy 0 {1: 2, 4: 5, 5: 2, 6: 1}\nadd 5 6\nsub 1 3\nadd 10 15\nopen 0 12\nopen 0 7\nclose 9 6\nadd 0 1\nopen 0 10\n\n... (long output, truncated ...)\n</pre>\n<p>And of course, you can execute the compiled opcodes as many times as you like\nusing <tt>bfi.execute</tt>.</p>\n</div>\n<div id=\"example-brainfuck-programs\">\n<h2>Example Brainfuck programs</h2>\n<p>I have included several random Brainfuck programs that I\u2019ve found in various\nplaces. I didn\u2019t write any of these programs, I just copied them as-is\nfrom other public sources. Descriptive comments (and author\u2019s name, in some\ncases) can be seen in the Brainfuck source files themselves.</p>\n<p>A description of the example Brainfuck programs included with this package\nfollows:</p>\n<ul>\n<li><strong>bfcl.bf</strong>: A Brainfuck-to-ELF translator, in Brainfuck. Reads in Brainfuck\nsource from stdin and writes a Linux ELF file to stdout</li>\n<li><strong>bitwidth.bf</strong> Assorted tests for Brainfuck interpreter/compiler correctness</li>\n<li><strong>collatz.b</strong> A demonstration of the Collatz problem in Brainfuck</li>\n<li><strong>eoftest.b</strong> Tests EOF behaviour of brainfuck interpreters/compilers</li>\n<li><strong>fib.b</strong> Prints a neverending fibonacci sequence</li>\n<li><strong>gameoflife.b</strong> Conway\u2019s Game of Life in Brainfuck</li>\n<li><strong>hanoi.b</strong> Towers of Hanoi in Brainfuck</li>\n<li><strong>hello_world.b</strong> Classic \u201chello, world!\u201d in Brainfuck</li>\n<li><strong>LostKingdom.b</strong> A text-based adventure game in Brainfuck</li>\n<li><strong>mandel.b</strong> An ASCII  mandelbrot fractal set viewer in Brainfuck</li>\n<li><strong>numwarp.b</strong> Prints an enlarged ASCII representation of numbers entered by\nthe user</li>\n<li><strong>primes.bf</strong> Prints prime numbers</li>\n<li><strong>rot13.b</strong> Prints the ROT13 encoding of the string entered by the user</li>\n<li><strong>sierpinksi.b</strong> Displays the Sierpinksi triangle</li>\n<li><strong>TheBrainfuckedLoneWolf.b</strong> ASCII asteroids-inspired top-down shooter game\nin Brainfuck</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 4167827, "releases": {"0.2.6": [{"comment_text": "", "digests": {"md5": "b128b14d4602c8bb85ea8ac4924cc39e", "sha256": "ae4ff5f2cf6f8e34a4c308bb441b3f169ac42e6589e04467bb6398c49def37f6"}, "downloads": -1, "filename": "bfi-0.2.6.tar.gz", "has_sig": false, "md5_digest": "b128b14d4602c8bb85ea8ac4924cc39e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 139128, "upload_time": "2017-09-14T05:26:34", "upload_time_iso_8601": "2017-09-14T05:26:34.422770Z", "url": "https://files.pythonhosted.org/packages/2b/5f/5997dde740f27d2cb8c3396aff1ced54e5ee244934afb6ee1b07dc7576e0/bfi-0.2.6.tar.gz", "yanked": false}], "0.2.7": [{"comment_text": "", "digests": {"md5": "19f870ed40d58479cd2d84b8c6a4e753", "sha256": "92f62717974b030cea58dd1234c2ef06b56a034765ceb230c754ca426ccd4899"}, "downloads": -1, "filename": "bfi-0.2.7.tar.gz", "has_sig": false, "md5_digest": "19f870ed40d58479cd2d84b8c6a4e753", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 141812, "upload_time": "2017-09-16T18:57:58", "upload_time_iso_8601": "2017-09-16T18:57:58.880666Z", "url": "https://files.pythonhosted.org/packages/82/01/ca3d3758cdc2bd9a8c3f06aa40a79a4a4e3b4dadb87658513323d1c29f9f/bfi-0.2.7.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "b122a26c9295d2841f13f5cacf150c8a", "sha256": "8ad3d0069f43e1647eeb9103aaaaa539acad49ef2cca81dc65892d442ae5db0c"}, "downloads": -1, "filename": "bfi-0.5.0.tar.gz", "has_sig": false, "md5_digest": "b122a26c9295d2841f13f5cacf150c8a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 143260, "upload_time": "2018-01-29T05:10:56", "upload_time_iso_8601": "2018-01-29T05:10:56.860438Z", "url": "https://files.pythonhosted.org/packages/29/c5/18d1540e4889f3d5f27e96901b2e89a38924cbfc2866fb51337db7d607c2/bfi-0.5.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "c4557be5799e70d933220057f0aef90d", "sha256": "9697f24d76e59edc28c28d80ba2e04861bd8da2e310bab0f2c15ebc2de84ed62"}, "downloads": -1, "filename": "bfi-1.0.1.tar.gz", "has_sig": false, "md5_digest": "c4557be5799e70d933220057f0aef90d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 141094, "upload_time": "2018-08-12T23:25:33", "upload_time_iso_8601": "2018-08-12T23:25:33.938680Z", "url": "https://files.pythonhosted.org/packages/a0/6d/8b3f6be72e6f5e9344c44de64371dd255056ae859e65399a8a1068c1d481/bfi-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "e939e1df72a6ab01ddaab6ade7cb3255", "sha256": "ab690ac2240c3f44e636c5967d2420119e7ab468ac0d926d638c860a1b5d05d7"}, "downloads": -1, "filename": "bfi-1.0.2-py2-none-any.whl", "has_sig": false, "md5_digest": "e939e1df72a6ab01ddaab6ade7cb3255", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 158738, "upload_time": "2018-08-14T05:17:15", "upload_time_iso_8601": "2018-08-14T05:17:15.728073Z", "url": "https://files.pythonhosted.org/packages/29/83/8e288e3f54c62fb01d6d9a16abca41f1bf315b884a47ce2b0eaf29b0e6b7/bfi-1.0.2-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "784b0589799acd88d8e0df83e57c7340", "sha256": "0f11eecb2dcf056b0a6b2a763cf91a05d4a2a5c66af9915bff50c96cab969d0b"}, "downloads": -1, "filename": "bfi-1.0.2.tar.gz", "has_sig": false, "md5_digest": "784b0589799acd88d8e0df83e57c7340", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 140672, "upload_time": "2018-08-14T05:04:54", "upload_time_iso_8601": "2018-08-14T05:04:54.308216Z", "url": "https://files.pythonhosted.org/packages/ae/2f/f1314c9ecbbfe2329a1106d29d269e7d8a878880f6ab06f9411f6c6fdea3/bfi-1.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e939e1df72a6ab01ddaab6ade7cb3255", "sha256": "ab690ac2240c3f44e636c5967d2420119e7ab468ac0d926d638c860a1b5d05d7"}, "downloads": -1, "filename": "bfi-1.0.2-py2-none-any.whl", "has_sig": false, "md5_digest": "e939e1df72a6ab01ddaab6ade7cb3255", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 158738, "upload_time": "2018-08-14T05:17:15", "upload_time_iso_8601": "2018-08-14T05:17:15.728073Z", "url": "https://files.pythonhosted.org/packages/29/83/8e288e3f54c62fb01d6d9a16abca41f1bf315b884a47ce2b0eaf29b0e6b7/bfi-1.0.2-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "784b0589799acd88d8e0df83e57c7340", "sha256": "0f11eecb2dcf056b0a6b2a763cf91a05d4a2a5c66af9915bff50c96cab969d0b"}, "downloads": -1, "filename": "bfi-1.0.2.tar.gz", "has_sig": false, "md5_digest": "784b0589799acd88d8e0df83e57c7340", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 140672, "upload_time": "2018-08-14T05:04:54", "upload_time_iso_8601": "2018-08-14T05:04:54.308216Z", "url": "https://files.pythonhosted.org/packages/ae/2f/f1314c9ecbbfe2329a1106d29d269e7d8a878880f6ab06f9411f6c6fdea3/bfi-1.0.2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:37:40 2020"}