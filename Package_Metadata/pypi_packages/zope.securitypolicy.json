{"info": {"author": "Zope Foundation and Contributors", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Internet :: WWW/HTTP"], "description": "=====================\n zope.securitypolicy\n=====================\n\n.. image:: https://img.shields.io/pypi/v/zope.securitypolicy.svg\n   :target: https://pypi.org/project/zope.securitypolicy/\n   :alt: Latest release\n\n.. image:: https://img.shields.io/pypi/pyversions/zope.securitypolicy.svg\n   :target: https://pypi.org/project/zope.securitypolicy/\n   :alt: Supported Python versions\n\n.. image:: https://travis-ci.org/zopefoundation/zope.securitypolicy.svg?branch=master\n   :target: https://travis-ci.org/zopefoundation/zope.securitypolicy\n\n.. image:: https://coveralls.io/repos/github/zopefoundation/zope.securitypolicy/badge.svg?branch=master\n   :target: https://coveralls.io/github/zopefoundation/zope.securitypolicy?branch=master\n\n\n\nThis package provides an useful security policy for Zope3. It's the\ndefault security policy used in \"zope3 the application\" and many other\nzope-based projects.\n\n\nClassic Zope Security Policy\n============================\n\nThis package implements a role-based security policy similar to the\npolicy found in Zope 2.  The security policy is responsible for\ndeciding whether an interaction has a permission on an object.  This\nsecurity policy does this using grant and denial information.  Managers\ncan grant or deny:\n\n  - roles to principals,\n\n  - permissions to principals, and\n\n  - permissions to roles\n\nGrants and denials are stored as annotations on objects.  To store\ngrants and denials, objects must be annotatable:\n\n  >>> import zope.interface\n  >>> from zope.annotation.interfaces import IAttributeAnnotatable\n  >>> @zope.interface.implementer(IAttributeAnnotatable)\n  ... class Ob:\n  ...     pass\n\n  >>> ob = Ob()\n\nWe use objects to represent principals.  These objects implement an\ninterface named `IPrincipal`, but the security policy only uses the `id`\nand `groups` attributes:\n\n  >>> class Principal:\n  ...     def __init__(self, id):\n  ...         self.id = id\n  ...         self.groups = []\n\n  >>> principal = Principal('bob')\n\nRoles and permissions are also represented by objects, however, for\nthe purposes of the security policy, only string `ids` are used.\n\nThe security policy provides a factory for creating interactions:\n\n  >>> import zope.securitypolicy.zopepolicy\n  >>> interaction = zope.securitypolicy.zopepolicy.ZopeSecurityPolicy()\n\nAn interaction represents a specific interaction between some\nprincipals (normally users) and the system.  Normally, we are only\nconcerned with the interaction of one principal with the system, although\nwe can have interactions of multiple principals.  Multiple-principal\ninteractions normally occur when untrusted users store code on a\nsystem for later execution.  When untrusted code is executing, the\nauthors of the code participate in the interaction.  An\ninteraction has a permission on an object only if all of the\nprincipals participating in the interaction have access to the object.\n\nThe `checkPermission` method on interactions is used to test whether\nan interaction has a permission for an object.  An interaction without\nparticipants always has every permission:\n\n  >>> interaction.checkPermission('P1', ob)\n  True\n\nIn this example, 'P1' is a permission id.\n\nNormally, interactions have participants:\n\n  >>> class Participation:\n  ...     interaction = None\n  >>> participation = Participation()\n  >>> participation.principal = principal\n  >>> interaction.add(participation)\n\nIf we have participants, then we don't have a permission unless there\nare grants:\n\n  >>> interaction.checkPermission('P1', ob)\n  False\n\nNote, however, that we always have the CheckerPublic permission:\n\n  >>> from zope.security.checker import CheckerPublic\n  >>> interaction.checkPermission(CheckerPublic, ob)\n  True\n\nWe make grants and denials on objects by adapting them to various\ngranting interfaces.  The objects returned from the adaptation are \nobject-specific manager objects:\n\n  >>> from zope.securitypolicy import interfaces\n  >>> roleper  = interfaces.IRolePermissionManager(ob)\n  >>> prinrole = interfaces.IPrincipalRoleManager(ob)\n  >>> prinper  = interfaces.IPrincipalPermissionManager(ob)\n\nThe computations involved in checking permissions can be\nsignificant. To reduce the computational cost, caching is used\nextensively. We could invalidate the cache as we make grants, but the\nadapters for making grants will automatically invalidate the cache of\nthe current interaction.  They use the security-management apis to do\nthis. To take advantage of the cache invalidation, we'll need to let\nthe security-management system manage our interactions.  First, we'll\nset our security policy as the default:\n\n  >>> import zope.security.management\n  >>> oldpolicy = zope.security.management.setSecurityPolicy(\n  ...      zope.securitypolicy.zopepolicy.ZopeSecurityPolicy)\n\nand then we'll create a new interaction:\n\n  >>> participation = Participation()\n  >>> participation.principal = principal\n  >>> zope.security.management.newInteraction(participation)\n  >>> interaction = zope.security.management.getInteraction()\n\nWe normally provide access by granting permissions to roles for an object:\n\n  >>> roleper.grantPermissionToRole('P1', 'R1')\n\nand then granting roles to principals for an object (local roles):\n\n  >>> prinrole.assignRoleToPrincipal('R1', 'bob')\n\nThe combination of these grants, which we call a role-based grant,\nprovides the permission:\n\n  >>> interaction.checkPermission('P1', ob)\n  True\n\nWe can also provide a permission directly:\n\n  >>> prinper.grantPermissionToPrincipal('P2', 'bob')\n  >>> interaction.checkPermission('P2', ob)\n  True\n\nPermission grants or denials override role-based grant or denials.  So\nif we deny P1:\n\n  >>> prinper.denyPermissionToPrincipal('P1', 'bob')\n\nwe cause the interaction to lack the permission, despite the role\ngrants:\n\n  >>> interaction.checkPermission('P1', ob)\n  False\n\nSimilarly, even if we have a role-based denial of P2:\n\n  >>> roleper.denyPermissionToRole('P2', 'R1')\n\nwe still have access, because of the permission-based grant:\n\n  >>> interaction.checkPermission('P2', ob)\n  True\n\nA role-based denial doesn't actually deny a permission; rather it\nprevents the granting of a permission. So, if we have both grants and\ndenials based on roles, we have access:\n\n  >>> roleper.grantPermissionToRole('P3', 'R1')\n  >>> roleper.grantPermissionToRole('P3', 'R2')\n  >>> roleper.denyPermissionToRole('P3', 'R3')\n  >>> prinrole.removeRoleFromPrincipal('R2', 'bob')\n  >>> prinrole.assignRoleToPrincipal('R3', 'bob')\n\n  >>> interaction.checkPermission('P3', ob)\n  True\n\nGlobal grants\n-------------\n\nGrants made to an object are said to be \"local\".  We can also make\nglobal grants:\n\n  >>> from zope.securitypolicy.rolepermission import \\\n  ...     rolePermissionManager as roleperG\n  >>> from zope.securitypolicy.principalpermission import \\\n  ...     principalPermissionManager as prinperG\n  >>> from zope.securitypolicy.principalrole import \\\n  ...     principalRoleManager as prinroleG\n\nAnd the same rules apply to global grants and denials.\n\n  >>> roleperG.grantPermissionToRole('P1G', 'R1G', False)\n\nIn these tests, we aren't bothering to define any roles, permissions,\nor principals, so we pass an extra argument that tells the granting\nroutines not to check the validity of the values.\n\n  >>> prinroleG.assignRoleToPrincipal('R1G', 'bob', False)\n  >>> interaction.checkPermission('P1G', ob)\n  True\n\n  >>> prinperG.grantPermissionToPrincipal('P2G', 'bob', False)\n  >>> interaction.checkPermission('P2G', ob)\n  True\n\n  >>> prinperG.denyPermissionToPrincipal('P1G', 'bob', False)\n  >>> interaction.checkPermission('P1G', ob)\n  False\n\n  >>> roleperG.denyPermissionToRole('P2G', 'R1G', False)\n  >>> interaction.checkPermission('P2G', ob)\n  True\n\n  >>> roleperG.grantPermissionToRole('P3G', 'R1G', False)\n  >>> roleperG.grantPermissionToRole('P3G', 'R2G', False)\n  >>> roleperG.denyPermissionToRole('P3G', 'R3G', False)\n  >>> prinroleG.removeRoleFromPrincipal('R2G', 'bob', False)\n  >>> prinroleG.assignRoleToPrincipal('R3G', 'bob', False)\n  >>> interaction.checkPermission('P3G', ob)\n  True\n\nLocal versus global grants\n--------------------------\n\nWe, of course, acquire global grants by default:\n\n  >>> interaction.checkPermission('P1G', ob)\n  False\n  >>> interaction.checkPermission('P2G', ob)\n  True\n  >>> interaction.checkPermission('P3G', ob)\n  True\n\nLocal role-based grants do not override global principal-specific denials:\n\n  >>> roleper.grantPermissionToRole('P1G', 'R1G')\n  >>> prinrole.assignRoleToPrincipal('R1G', 'bob')\n  >>> interaction.checkPermission('P1G', ob)\n  False\n\nAnd local role-based denials don't override global\nprincipal-grants:\n\n  >>> roleper.denyPermissionToRole('P2G', 'R1G')\n  >>> interaction.checkPermission('P2G', ob)\n  True\n\nA local role-based deny can cancel a global role-based grant:\n\n  >>> roleper.denyPermissionToRole('P3G', 'R1G')\n  >>> interaction.checkPermission('P3G', ob)\n  False\n\nand a local role-based grant can override a global role-based denial:\n\n  >>> roleperG.denyPermissionToRole('P4G', 'R1G', False)\n  >>> prinroleG.assignRoleToPrincipal('R1G', \"bob\", False)\n  >>> interaction.checkPermission('P4G', ob)\n  False\n  >>> roleper.grantPermissionToRole('P4G', 'R1G')\n  >>> interaction.checkPermission('P4G', ob)\n  True\n  >>> prinroleG.removeRoleFromPrincipal('R1G', \"bob\", False)\n  >>> interaction.checkPermission('P4G', ob)\n  True\n\nOf course, a local permission-based grant or denial overrides any\nglobal setting and overrides local role-based grants or denials:\n\n  >>> prinper.grantPermissionToPrincipal('P3G', 'bob')\n  >>> interaction.checkPermission('P3G', ob)\n  True\n\n  >>> prinper.denyPermissionToPrincipal('P2G', 'bob')\n  >>> interaction.checkPermission('P2G', ob)\n  False\n\nSublocations\n------------\n\nWe can have sub-locations. A sublocation of a location is an object\nwhose `__parent__` attribute is the location:\n\n  >>> ob2 = Ob()\n  >>> ob2.__parent__ = ob\n\nBy default, sublocations acquire grants from higher locations:\n\n  >>> interaction.checkPermission('P1', ob2)\n  False\n  >>> interaction.checkPermission('P2', ob2)\n  True\n  >>> interaction.checkPermission('P3', ob2)\n  True\n  >>> interaction.checkPermission('P1G', ob2)\n  False\n  >>> interaction.checkPermission('P2G', ob2)\n  False\n  >>> interaction.checkPermission('P3G', ob2)\n  True\n  >>> interaction.checkPermission('P4G', ob2)\n  True\n\nSublocation role-based grants do not override their parent\nprincipal-specific denials:\n\n  >>> roleper2  = interfaces.IRolePermissionManager(ob2)\n  >>> prinrole2 = interfaces.IPrincipalRoleManager(ob2)\n  >>> prinper2  = interfaces.IPrincipalPermissionManager(ob2)\n\n  >>> roleper2.grantPermissionToRole('P1', 'R1')\n  >>> prinrole2.assignRoleToPrincipal('R1', 'bob')\n  >>> interaction.checkPermission('P1', ob2)\n  False\n\nAnd local role-based denials don't override their parents\nprincipal-grant:\n\n  >>> roleper2.denyPermissionToRole('P2', 'R1')\n  >>> interaction.checkPermission('P2', ob2)\n  True\n\nA local role-based deny can cancel a parent role-based grant:\n\n  >>> roleper2.denyPermissionToRole('P3', 'R1')\n  >>> interaction.checkPermission('P3', ob2)\n  False\n\nand a local role-based grant can override a parent role-based denial:\n\n  >>> roleper.denyPermissionToRole('P4', 'R1')\n  >>> prinrole.assignRoleToPrincipal('R1', 'bob')\n  >>> interaction.checkPermission('P4', ob2)\n  False\n  >>> roleper2.grantPermissionToRole('P4', 'R1')\n  >>> interaction.checkPermission('P4', ob2)\n  True\n  >>> prinrole.removeRoleFromPrincipal('R1', 'bob')\n  >>> interaction.checkPermission('P4', ob2)\n  True\n\n\nOf course, a local permission-based grant or denial overrides any\nglobal setting and overrides local role-based grants or denials:\n\n  >>> prinper.grantPermissionToPrincipal('P3', 'bob')\n  >>> interaction.checkPermission('P3', ob2)\n  True\n\n  >>> prinper.denyPermissionToPrincipal('P2', 'bob')\n  >>> interaction.checkPermission('P2', ob2)\n  False\n\nIf an object is not annotatable, but does have a parent, it will get\nits grants from its parent:\n\n  >>> class C:\n  ...     pass\n\n  >>> ob3 = C()\n  >>> ob3.__parent__ = ob\n\n  >>> interaction.checkPermission('P1', ob3)\n  False\n  >>> interaction.checkPermission('P2', ob3)\n  False\n  >>> interaction.checkPermission('P3', ob3)\n  True\n  >>> interaction.checkPermission('P1G', ob3)\n  False\n  >>> interaction.checkPermission('P2G', ob3)\n  False\n  >>> interaction.checkPermission('P3G', ob3)\n  True\n  >>> interaction.checkPermission('P4G', ob3)\n  True\n\nThe same results will be had if there are multiple non-annotatable\nobjects:\n\n  >>> ob3.__parent__ = C()\n  >>> ob3.__parent__.__parent__ = ob\n\n  >>> interaction.checkPermission('P1', ob3)\n  False\n  >>> interaction.checkPermission('P2', ob3)\n  False\n  >>> interaction.checkPermission('P3', ob3)\n  True\n  >>> interaction.checkPermission('P1G', ob3)\n  False\n  >>> interaction.checkPermission('P2G', ob3)\n  False\n  >>> interaction.checkPermission('P3G', ob3)\n  True\n  >>> interaction.checkPermission('P4G', ob3)\n  True\n\nand if an object doesn't have a parent:\n\n  >>> ob4 = C()\n\nit will have whatever grants were made globally:\n\n  >>> interaction.checkPermission('P1', ob4)\n  False\n  >>> interaction.checkPermission('P2', ob4)\n  False\n  >>> interaction.checkPermission('P3', ob4)\n  False\n  >>> interaction.checkPermission('P1G', ob4)\n  False\n  >>> interaction.checkPermission('P2G', ob4)\n  True\n  >>> interaction.checkPermission('P3G', ob4)\n  False\n  >>> interaction.checkPermission('P4G', ob4)\n  False\n\n  >>> prinroleG.assignRoleToPrincipal('R1G', \"bob\", False)\n  >>> interaction.checkPermission('P3G', ob4)\n  True\n\nWe'll get the same result if we have a non-annotatable parent without a\nparent:\n\n  >>> ob3.__parent__ = C()\n\n  >>> interaction.checkPermission('P1', ob3)\n  False\n  >>> interaction.checkPermission('P2', ob3)\n  False\n  >>> interaction.checkPermission('P3', ob3)\n  False\n  >>> interaction.checkPermission('P1G', ob3)\n  False\n  >>> interaction.checkPermission('P2G', ob3)\n  True\n  >>> interaction.checkPermission('P3G', ob3)\n  True\n  >>> interaction.checkPermission('P4G', ob3)\n  False\n\nThe Anonymous role\n------------------\n\nThe security policy defines a special role named \"zope.Anonymous\".  All\nprincipals have this role and the role cannot be taken away.\n\n  >>> roleperG.grantPermissionToRole('P5', 'zope.Anonymous', False)\n  >>> interaction.checkPermission('P5', ob2)\n  True\n\nProxies\n-------\n\nObjects may be proxied:\n\n  >>> from zope.security.checker import ProxyFactory\n  >>> ob = ProxyFactory(ob)\n  >>> interaction.checkPermission('P1', ob)\n  False\n  >>> interaction.checkPermission('P2', ob)\n  False\n  >>> interaction.checkPermission('P3', ob)\n  True\n  >>> interaction.checkPermission('P1G', ob)\n  False\n  >>> interaction.checkPermission('P2G', ob)\n  False\n  >>> interaction.checkPermission('P3G', ob)\n  True\n  >>> interaction.checkPermission('P4G', ob)\n  True\n\nas may their parents:\n\n  >>> ob3 = C()\n  >>> ob3.__parent__ = ob\n\n  >>> interaction.checkPermission('P1', ob3)\n  False\n  >>> interaction.checkPermission('P2', ob3)\n  False\n  >>> interaction.checkPermission('P3', ob3)\n  True\n  >>> interaction.checkPermission('P1G', ob3)\n  False\n  >>> interaction.checkPermission('P2G', ob3)\n  False\n  >>> interaction.checkPermission('P3G', ob3)\n  True\n  >>> interaction.checkPermission('P4G', ob3)\n  True\n\nGroups\n------\n\nPrincipals may have groups.  Groups are also principals (and, thus,\nmay have groups).\n\nIf a principal has groups, the groups are available as group ids in\nthe principal's `groups` attribute.  The interaction has to convert\nthese group ids to group objects, so that it can tell whether the\ngroups have groups.  It does this by calling the `getPrincipal` method\non the principal authentication service, which is responsible for,\namong other things, converting a principal id to a principal.\nFor our examples here, we'll create and register a stub principal\nauthentication service:\n\n  >>> from zope.authentication.interfaces import IAuthentication\n  >>> @zope.interface.implementer(IAuthentication)\n  ... class FauxPrincipals(object):\n  ...     def __init__(self):\n  ...         self.data = {}\n  ...     def __setitem__(self, key, value):\n  ...         self.data[key] = value\n  ...     def __getitem__(self, key):\n  ...         return self.data[key]\n  ...     def getPrincipal(self, id):\n  ...         return self.data[id]\n\n  >>> auth = FauxPrincipals()\n\n  >>> from zope.component import provideUtility\n  >>> provideUtility(auth, IAuthentication)\n\nLet's define a group:\n\n  >>> auth['g1'] = Principal('g1')\n\nLet's put the principal in our group.  We do that by adding the group id\nto the new principals groups:\n\n  >>> principal.groups.append('g1')\n\nOf course, the principal doesn't have permissions not granted:\n\n  >>> interaction.checkPermission('gP1', ob)\n  False\n\nNow, if we grant a permission to the group:\n\n  >>> prinper.grantPermissionToPrincipal('gP1', 'g1')\n\nWe see that our principal has the permission:\n\n  >>> interaction.checkPermission('gP1', ob)\n  True\n\nThis works even if the group grant is global:\n\n  >>> interaction.checkPermission('gP1G', ob)\n  False\n\n  >>> prinperG.grantPermissionToPrincipal('gP1G', 'g1', True)\n\n  >>> interaction.checkPermission('gP1G', ob)\n  True\n\nGrants are, of course, acquired:\n\n  >>> interaction.checkPermission('gP1', ob2)\n  True\n\n  >>> interaction.checkPermission('gP1G', ob2)\n  True\n\nInner grants can override outer grants:\n\n  >>> prinper2.denyPermissionToPrincipal('gP1', 'g1')\n  >>> interaction.checkPermission('gP1', ob2)\n  False\n\nBut principal grants always trump group grants:\n\n  >>> prinper2.grantPermissionToPrincipal('gP1', 'bob')\n  >>> interaction.checkPermission('gP1', ob2)\n  True\n\nGroups can have groups too:\n\n  >>> auth['g2'] = Principal('g2')\n  >>> auth['g1'].groups.append('g2')\n\nIf we grant to the new group:\n\n  >>> prinper.grantPermissionToPrincipal('gP2', 'g2')\n\nThen we, of course have that permission too:\n\n  >>> interaction.checkPermission('gP2', ob2)\n  True\n\nJust as principal grants override group grants, group grants can\noverride other group grants:\n\n  >>> prinper.denyPermissionToPrincipal('gP2', 'g1')\n  >>> interaction.checkPermission('gP2', ob2)\n  False\n\nPrincipals can be in more than one group. Let's define a new group:\n\n  >>> auth['g3'] = Principal('g3')\n  >>> principal.groups.append('g3')\n  >>> prinper.grantPermissionToPrincipal('gP2', 'g3')\n\nNow, the principal has two groups. In one group, the permission 'gP2'\nis denied, but in the other, it is allowed.  In a case like this, the\npermission is allowed:\n\n  >>> interaction.checkPermission('gP2', ob2)\n  True\n\nIn a case where a principal has two or more groups, the group denies\nprevent allows from their parents. They don't prevent the principal\nfrom getting an allow from another principal.\n\nGrants can be inherited from ancestor groups through multiple paths.\nLet's grant a permission to g2 and deny it to g1:\n\n  >>> prinper.grantPermissionToPrincipal('gP3', 'g2')\n  >>> prinper.denyPermissionToPrincipal('gP3', 'g1')\n\nNow, as before, the deny in g1 blocks the grant in g2:\n\n  >>> interaction.checkPermission('gP3', ob2)\n  False\n\nLet's make g2 a group of g3:\n\n  >>> auth['g3'].groups.append('g2')\n\nNow, we get g2's grant through g3, and access is allowed:\n\n  >>> interaction.invalidate_cache()\n  >>> interaction.checkPermission('gP3', ob2)\n  True\n\nWe can assign roles to groups:\n\n  >>> prinrole.assignRoleToPrincipal('gR1', 'g2')\n\nand get permissions through the roles:\n\n  >>> roleper.grantPermissionToRole('gP4', 'gR1')\n  >>> interaction.checkPermission('gP4', ob2)\n  True\n\nwe can override role assignments to groups through subgroups:\n\n  >>> prinrole.removeRoleFromPrincipal('gR1', 'g1')\n  >>> prinrole.removeRoleFromPrincipal('gR1', 'g3')\n  >>> interaction.checkPermission('gP4', ob2)\n  False\n\nand through principals:\n\n  >>> prinrole.assignRoleToPrincipal('gR1', 'bob')\n  >>> interaction.checkPermission('gP4', ob2)\n  True\n\n\nWe clean up the changes we made in these examples:\n\n  >>> zope.security.management.endInteraction()\n  >>> ignore = zope.security.management.setSecurityPolicy(oldpolicy)\n\n\nChanges\n=======\n\n4.3.1 (2018-10-11)\n------------------\n\n- Use current location for `IRegistered` and `IUnregistered` interface.\n\n\n4.3.0 (2018-08-27)\n------------------\n\n- Add support for Python 3.7.\n\n- Drop support for Python 3.3.\n\n- Drop support for ``python setup.py test``.\n\n- Make ``SecurityMap`` and ``AnnotationGrantInfo`` have proper truth\n  behaviour on Python 3; previously they were always true.\n\n- Make ``AnnotationGrantInfo`` consistently return lists instead of\n  dict views on Python 3.\n\n- Make ``AnnotationSecurityMap`` (and objects derived from it, such as\n  ``AnnotationPrincipalPermissionManager`` and the role managers) more\n  efficient when adding or removing cells before they have been\n  persisted. They now avoid some unnecessary object copying.\n\n4.2.0 (2017-08-24)\n------------------\n\n- Add ``<zope:deny>`` directive, which is a mirror of the ``<zope:grant>``\n  directive.\n\n- Add support for Python 3.6.\n\n\n4.1.0 (2016-11-05)\n------------------\n\n- Add support for Python 3.5.\n\n- Drop support for Python 2.6.\n\n- Add support to grant multiple permissions with one ZCML statement. Example::\n\n    <grant\n      role=\"my-role\"\n      permissions=\"zope.foo\n                   zope.bar\" />\n\n\n4.0.0 (2014-12-24)\n------------------\n\n- Add support for PyPy.  (PyPy3 is pending release of a fix for:\n  https://bitbucket.org/pypy/pypy/issue/1946)\n\n- Add support for Python 3.4.\n\n- Add support for testing on Travis.\n\n\n4.0.0a1 (2013-02-22)\n--------------------\n\n- Add support for Python 3.3.\n\n- Replace deprecated ``zope.interface.classProvides`` usage with equivalent\n  ``zope.interface.provider`` decorator.\n\n- Replace deprecated ``zope.interface.implements`` usage with equivalent\n  ``zope.interface.implementer`` decorator.\n\n- Drop support for Python 2.4 and 2.5.\n\n\n3.7.0 (2010-09-25)\n------------------\n\n- LP #131115: Clean up inconsistency in ``getSetting`` interface definitions\n  and actual usage for the various security maps.\n\n- LP #564525:  fix permission moved from ``zope.app.dublincore`` namespace\n  to ``zope.dublincore``.\n\n- Remove unused imports and pep8 cleanup.\n\n- Use doctest module instead of the deprecated zope.testing.doctest.\n\n- AnnotationGrantInfo implements IGrantInfo.\n\n- Add test extra to declare test dependency on ``zope.component [test]``.\n\n- Add an extra named ``dublincore`` to express optional dependency on\n  ``zope.dublincore >= 3.7``.\n\n- Add tests for ZCML files making sure they include everything they need.\n\n\n3.6.1 (2009-07-24)\n------------------\n\n- Make tests work when the default and Zope vocabulary registry compete in the\n  cleanup.\n\n3.6.0 (2009-03-14)\n------------------\n\n- Change ``zope.app.security`` dependency to the new ``zope.authentication``\n  package, dropping a big number of unused dependencies.\n\n- Get rid of ``zope.app.testing`` and other testing dependencices.\n\n- Add ``ZODB3`` to install dependencies, because we use ``Persistent``\n  class. We didn't fail before, because it was installed implicitly.\n\n3.5.1 (2009-03-10)\n------------------\n\n- Don't depend on the ``hook`` extra of zope.component, as we don't need\n  it explicitly.\n\n- Import security settings (Allow, Deny, Unset) in the ``interfaces``\n  module from the ``zope.securitypolicy.settings``, added in previous\n  release instead of old ``zope.app.security.settings``.\n  The ``zope.app.security`` will be adapted to import them from\n  ``zope.securitypolicy.interfaces``.\n\n- Use ``_z_instances`` instead of ``__instances__`` for storing instances\n  for ``zope.securitypolicy.settings.PermissionSetting`` singleton\n  implementation, because __*__ name pattern is reserved for special\n  names in python.\n\n- Add security protections for the ``PermissionSetting``.\n\n- Improve documentation formatting, add it to the package's long\n  description.\n\n- Remove unneeded dependencies.\n\n- Remove old zpkg-related files and zcml slugs.\n\n3.5.0 (2009-01-31)\n------------------\n\n- Include settings that were previously imported from zope.app.security.\n\n3.4.2 (2009-01-28)\n------------------\n\n- Change mailing list address to zope-dev at zope.org. Fix package\n  homepage to the pypi page.\n\n- Fix test in buildout which still depended on zope.app.securitypolicy\n  by mistake.\n\n- Remove explicit dependency on zope.app.form from ``setup.py``; nothing\n  in the code directly depends on this.\n\n3.4.1 (2008-06-02)\n------------------\n\n- Fix reference to deprecated security policy from ZCML.\n\n3.4.0 (2007-09-25)\n------------------\n\n- Initial documented release\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/zopefoundation/zope.securitypolicy", "keywords": "zope3 security policy", "license": "ZPL 2.1", "maintainer": "", "maintainer_email": "", "name": "zope.securitypolicy", "package_url": "https://pypi.org/project/zope.securitypolicy/", "platform": "", "project_url": "https://pypi.org/project/zope.securitypolicy/", "project_urls": {"Homepage": "https://github.com/zopefoundation/zope.securitypolicy"}, "release_url": "https://pypi.org/project/zope.securitypolicy/4.3.1/", "requires_dist": ["persistent", "setuptools", "zope.annotation", "zope.authentication", "zope.component", "zope.configuration", "zope.i18nmessageid", "zope.interface", "zope.location", "zope.schema", "zope.security", "zope.dublincore (>=3.7); extra == 'dublincore'", "zope.testing; extra == 'test'", "zope.testrunner; extra == 'test'"], "requires_python": "", "summary": "Default security policy for Zope3", "version": "4.3.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://pypi.org/project/zope.securitypolicy/\" rel=\"nofollow\"><img alt=\"Latest release\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/164379b504c80a5743114bdce517c300d08ff3d3/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f7a6f70652e7365637572697479706f6c6963792e737667\"></a>\n<a href=\"https://pypi.org/project/zope.securitypolicy/\" rel=\"nofollow\"><img alt=\"Supported Python versions\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f9269e216f06992905e39064fba7504c1d15701c/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f7a6f70652e7365637572697479706f6c6963792e737667\"></a>\n<a href=\"https://travis-ci.org/zopefoundation/zope.securitypolicy\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/zopefoundation/zope.securitypolicy.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/edd32f18ca9821ce9f146125f5de0453eedfd305/68747470733a2f2f7472617669732d63692e6f72672f7a6f7065666f756e646174696f6e2f7a6f70652e7365637572697479706f6c6963792e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/zopefoundation/zope.securitypolicy?branch=master\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/github/zopefoundation/zope.securitypolicy/badge.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1b20897f8086fd9ad7f961ce1a994f42004dee97/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f7a6f7065666f756e646174696f6e2f7a6f70652e7365637572697479706f6c6963792f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<p>This package provides an useful security policy for Zope3. It\u2019s the\ndefault security policy used in \u201czope3 the application\u201d and many other\nzope-based projects.</p>\n<div id=\"classic-zope-security-policy\">\n<h2>Classic Zope Security Policy</h2>\n<p>This package implements a role-based security policy similar to the\npolicy found in Zope 2.  The security policy is responsible for\ndeciding whether an interaction has a permission on an object.  This\nsecurity policy does this using grant and denial information.  Managers\ncan grant or deny:</p>\n<blockquote>\n<ul>\n<li>roles to principals,</li>\n<li>permissions to principals, and</li>\n<li>permissions to roles</li>\n</ul>\n</blockquote>\n<p>Grants and denials are stored as annotations on objects.  To store\ngrants and denials, objects must be annotatable:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n&gt;&gt;&gt; from zope.annotation.interfaces import IAttributeAnnotatable\n&gt;&gt;&gt; @zope.interface.implementer(IAttributeAnnotatable)\n... class Ob:\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; ob = Ob()\n</pre>\n</blockquote>\n<p>We use objects to represent principals.  These objects implement an\ninterface named <cite>IPrincipal</cite>, but the security policy only uses the <cite>id</cite>\nand <cite>groups</cite> attributes:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Principal:\n...     def __init__(self, id):\n...         self.id = id\n...         self.groups = []\n</pre>\n<pre>&gt;&gt;&gt; principal = Principal('bob')\n</pre>\n</blockquote>\n<p>Roles and permissions are also represented by objects, however, for\nthe purposes of the security policy, only string <cite>ids</cite> are used.</p>\n<p>The security policy provides a factory for creating interactions:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.securitypolicy.zopepolicy\n&gt;&gt;&gt; interaction = zope.securitypolicy.zopepolicy.ZopeSecurityPolicy()\n</pre>\n</blockquote>\n<p>An interaction represents a specific interaction between some\nprincipals (normally users) and the system.  Normally, we are only\nconcerned with the interaction of one principal with the system, although\nwe can have interactions of multiple principals.  Multiple-principal\ninteractions normally occur when untrusted users store code on a\nsystem for later execution.  When untrusted code is executing, the\nauthors of the code participate in the interaction.  An\ninteraction has a permission on an object only if all of the\nprincipals participating in the interaction have access to the object.</p>\n<p>The <cite>checkPermission</cite> method on interactions is used to test whether\nan interaction has a permission for an object.  An interaction without\nparticipants always has every permission:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P1', ob)\nTrue\n</pre>\n</blockquote>\n<p>In this example, \u2018P1\u2019 is a permission id.</p>\n<p>Normally, interactions have participants:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Participation:\n...     interaction = None\n&gt;&gt;&gt; participation = Participation()\n&gt;&gt;&gt; participation.principal = principal\n&gt;&gt;&gt; interaction.add(participation)\n</pre>\n</blockquote>\n<p>If we have participants, then we don\u2019t have a permission unless there\nare grants:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P1', ob)\nFalse\n</pre>\n</blockquote>\n<p>Note, however, that we always have the CheckerPublic permission:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.security.checker import CheckerPublic\n&gt;&gt;&gt; interaction.checkPermission(CheckerPublic, ob)\nTrue\n</pre>\n</blockquote>\n<p>We make grants and denials on objects by adapting them to various\ngranting interfaces.  The objects returned from the adaptation are\nobject-specific manager objects:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.securitypolicy import interfaces\n&gt;&gt;&gt; roleper  = interfaces.IRolePermissionManager(ob)\n&gt;&gt;&gt; prinrole = interfaces.IPrincipalRoleManager(ob)\n&gt;&gt;&gt; prinper  = interfaces.IPrincipalPermissionManager(ob)\n</pre>\n</blockquote>\n<p>The computations involved in checking permissions can be\nsignificant. To reduce the computational cost, caching is used\nextensively. We could invalidate the cache as we make grants, but the\nadapters for making grants will automatically invalidate the cache of\nthe current interaction.  They use the security-management apis to do\nthis. To take advantage of the cache invalidation, we\u2019ll need to let\nthe security-management system manage our interactions.  First, we\u2019ll\nset our security policy as the default:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.security.management\n&gt;&gt;&gt; oldpolicy = zope.security.management.setSecurityPolicy(\n...      zope.securitypolicy.zopepolicy.ZopeSecurityPolicy)\n</pre>\n</blockquote>\n<p>and then we\u2019ll create a new interaction:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; participation = Participation()\n&gt;&gt;&gt; participation.principal = principal\n&gt;&gt;&gt; zope.security.management.newInteraction(participation)\n&gt;&gt;&gt; interaction = zope.security.management.getInteraction()\n</pre>\n</blockquote>\n<p>We normally provide access by granting permissions to roles for an object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleper.grantPermissionToRole('P1', 'R1')\n</pre>\n</blockquote>\n<p>and then granting roles to principals for an object (local roles):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinrole.assignRoleToPrincipal('R1', 'bob')\n</pre>\n</blockquote>\n<p>The combination of these grants, which we call a role-based grant,\nprovides the permission:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P1', ob)\nTrue\n</pre>\n</blockquote>\n<p>We can also provide a permission directly:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinper.grantPermissionToPrincipal('P2', 'bob')\n&gt;&gt;&gt; interaction.checkPermission('P2', ob)\nTrue\n</pre>\n</blockquote>\n<p>Permission grants or denials override role-based grant or denials.  So\nif we deny P1:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinper.denyPermissionToPrincipal('P1', 'bob')\n</pre>\n</blockquote>\n<p>we cause the interaction to lack the permission, despite the role\ngrants:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P1', ob)\nFalse\n</pre>\n</blockquote>\n<p>Similarly, even if we have a role-based denial of P2:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleper.denyPermissionToRole('P2', 'R1')\n</pre>\n</blockquote>\n<p>we still have access, because of the permission-based grant:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P2', ob)\nTrue\n</pre>\n</blockquote>\n<p>A role-based denial doesn\u2019t actually deny a permission; rather it\nprevents the granting of a permission. So, if we have both grants and\ndenials based on roles, we have access:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleper.grantPermissionToRole('P3', 'R1')\n&gt;&gt;&gt; roleper.grantPermissionToRole('P3', 'R2')\n&gt;&gt;&gt; roleper.denyPermissionToRole('P3', 'R3')\n&gt;&gt;&gt; prinrole.removeRoleFromPrincipal('R2', 'bob')\n&gt;&gt;&gt; prinrole.assignRoleToPrincipal('R3', 'bob')\n</pre>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P3', ob)\nTrue\n</pre>\n</blockquote>\n<div id=\"global-grants\">\n<h3>Global grants</h3>\n<p>Grants made to an object are said to be \u201clocal\u201d.  We can also make\nglobal grants:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.securitypolicy.rolepermission import \\\n...     rolePermissionManager as roleperG\n&gt;&gt;&gt; from zope.securitypolicy.principalpermission import \\\n...     principalPermissionManager as prinperG\n&gt;&gt;&gt; from zope.securitypolicy.principalrole import \\\n...     principalRoleManager as prinroleG\n</pre>\n</blockquote>\n<p>And the same rules apply to global grants and denials.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleperG.grantPermissionToRole('P1G', 'R1G', False)\n</pre>\n</blockquote>\n<p>In these tests, we aren\u2019t bothering to define any roles, permissions,\nor principals, so we pass an extra argument that tells the granting\nroutines not to check the validity of the values.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinroleG.assignRoleToPrincipal('R1G', 'bob', False)\n&gt;&gt;&gt; interaction.checkPermission('P1G', ob)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; prinperG.grantPermissionToPrincipal('P2G', 'bob', False)\n&gt;&gt;&gt; interaction.checkPermission('P2G', ob)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; prinperG.denyPermissionToPrincipal('P1G', 'bob', False)\n&gt;&gt;&gt; interaction.checkPermission('P1G', ob)\nFalse\n</pre>\n<pre>&gt;&gt;&gt; roleperG.denyPermissionToRole('P2G', 'R1G', False)\n&gt;&gt;&gt; interaction.checkPermission('P2G', ob)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; roleperG.grantPermissionToRole('P3G', 'R1G', False)\n&gt;&gt;&gt; roleperG.grantPermissionToRole('P3G', 'R2G', False)\n&gt;&gt;&gt; roleperG.denyPermissionToRole('P3G', 'R3G', False)\n&gt;&gt;&gt; prinroleG.removeRoleFromPrincipal('R2G', 'bob', False)\n&gt;&gt;&gt; prinroleG.assignRoleToPrincipal('R3G', 'bob', False)\n&gt;&gt;&gt; interaction.checkPermission('P3G', ob)\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"local-versus-global-grants\">\n<h3>Local versus global grants</h3>\n<p>We, of course, acquire global grants by default:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P1G', ob)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2G', ob)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P3G', ob)\nTrue\n</pre>\n</blockquote>\n<p>Local role-based grants do not override global principal-specific denials:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleper.grantPermissionToRole('P1G', 'R1G')\n&gt;&gt;&gt; prinrole.assignRoleToPrincipal('R1G', 'bob')\n&gt;&gt;&gt; interaction.checkPermission('P1G', ob)\nFalse\n</pre>\n</blockquote>\n<p>And local role-based denials don\u2019t override global\nprincipal-grants:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleper.denyPermissionToRole('P2G', 'R1G')\n&gt;&gt;&gt; interaction.checkPermission('P2G', ob)\nTrue\n</pre>\n</blockquote>\n<p>A local role-based deny can cancel a global role-based grant:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleper.denyPermissionToRole('P3G', 'R1G')\n&gt;&gt;&gt; interaction.checkPermission('P3G', ob)\nFalse\n</pre>\n</blockquote>\n<p>and a local role-based grant can override a global role-based denial:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleperG.denyPermissionToRole('P4G', 'R1G', False)\n&gt;&gt;&gt; prinroleG.assignRoleToPrincipal('R1G', \"bob\", False)\n&gt;&gt;&gt; interaction.checkPermission('P4G', ob)\nFalse\n&gt;&gt;&gt; roleper.grantPermissionToRole('P4G', 'R1G')\n&gt;&gt;&gt; interaction.checkPermission('P4G', ob)\nTrue\n&gt;&gt;&gt; prinroleG.removeRoleFromPrincipal('R1G', \"bob\", False)\n&gt;&gt;&gt; interaction.checkPermission('P4G', ob)\nTrue\n</pre>\n</blockquote>\n<p>Of course, a local permission-based grant or denial overrides any\nglobal setting and overrides local role-based grants or denials:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinper.grantPermissionToPrincipal('P3G', 'bob')\n&gt;&gt;&gt; interaction.checkPermission('P3G', ob)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; prinper.denyPermissionToPrincipal('P2G', 'bob')\n&gt;&gt;&gt; interaction.checkPermission('P2G', ob)\nFalse\n</pre>\n</blockquote>\n</div>\n<div id=\"sublocations\">\n<h3>Sublocations</h3>\n<p>We can have sub-locations. A sublocation of a location is an object\nwhose <cite>__parent__</cite> attribute is the location:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ob2 = Ob()\n&gt;&gt;&gt; ob2.__parent__ = ob\n</pre>\n</blockquote>\n<p>By default, sublocations acquire grants from higher locations:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P1', ob2)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2', ob2)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P3', ob2)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P1G', ob2)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2G', ob2)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P3G', ob2)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P4G', ob2)\nTrue\n</pre>\n</blockquote>\n<p>Sublocation role-based grants do not override their parent\nprincipal-specific denials:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleper2  = interfaces.IRolePermissionManager(ob2)\n&gt;&gt;&gt; prinrole2 = interfaces.IPrincipalRoleManager(ob2)\n&gt;&gt;&gt; prinper2  = interfaces.IPrincipalPermissionManager(ob2)\n</pre>\n<pre>&gt;&gt;&gt; roleper2.grantPermissionToRole('P1', 'R1')\n&gt;&gt;&gt; prinrole2.assignRoleToPrincipal('R1', 'bob')\n&gt;&gt;&gt; interaction.checkPermission('P1', ob2)\nFalse\n</pre>\n</blockquote>\n<p>And local role-based denials don\u2019t override their parents\nprincipal-grant:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleper2.denyPermissionToRole('P2', 'R1')\n&gt;&gt;&gt; interaction.checkPermission('P2', ob2)\nTrue\n</pre>\n</blockquote>\n<p>A local role-based deny can cancel a parent role-based grant:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleper2.denyPermissionToRole('P3', 'R1')\n&gt;&gt;&gt; interaction.checkPermission('P3', ob2)\nFalse\n</pre>\n</blockquote>\n<p>and a local role-based grant can override a parent role-based denial:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleper.denyPermissionToRole('P4', 'R1')\n&gt;&gt;&gt; prinrole.assignRoleToPrincipal('R1', 'bob')\n&gt;&gt;&gt; interaction.checkPermission('P4', ob2)\nFalse\n&gt;&gt;&gt; roleper2.grantPermissionToRole('P4', 'R1')\n&gt;&gt;&gt; interaction.checkPermission('P4', ob2)\nTrue\n&gt;&gt;&gt; prinrole.removeRoleFromPrincipal('R1', 'bob')\n&gt;&gt;&gt; interaction.checkPermission('P4', ob2)\nTrue\n</pre>\n</blockquote>\n<p>Of course, a local permission-based grant or denial overrides any\nglobal setting and overrides local role-based grants or denials:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinper.grantPermissionToPrincipal('P3', 'bob')\n&gt;&gt;&gt; interaction.checkPermission('P3', ob2)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; prinper.denyPermissionToPrincipal('P2', 'bob')\n&gt;&gt;&gt; interaction.checkPermission('P2', ob2)\nFalse\n</pre>\n</blockquote>\n<p>If an object is not annotatable, but does have a parent, it will get\nits grants from its parent:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class C:\n...     pass\n</pre>\n<pre>&gt;&gt;&gt; ob3 = C()\n&gt;&gt;&gt; ob3.__parent__ = ob\n</pre>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P1', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P3', ob3)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P1G', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2G', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P3G', ob3)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P4G', ob3)\nTrue\n</pre>\n</blockquote>\n<p>The same results will be had if there are multiple non-annotatable\nobjects:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ob3.__parent__ = C()\n&gt;&gt;&gt; ob3.__parent__.__parent__ = ob\n</pre>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P1', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P3', ob3)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P1G', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2G', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P3G', ob3)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P4G', ob3)\nTrue\n</pre>\n</blockquote>\n<p>and if an object doesn\u2019t have a parent:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ob4 = C()\n</pre>\n</blockquote>\n<p>it will have whatever grants were made globally:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P1', ob4)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2', ob4)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P3', ob4)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P1G', ob4)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2G', ob4)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P3G', ob4)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P4G', ob4)\nFalse\n</pre>\n<pre>&gt;&gt;&gt; prinroleG.assignRoleToPrincipal('R1G', \"bob\", False)\n&gt;&gt;&gt; interaction.checkPermission('P3G', ob4)\nTrue\n</pre>\n</blockquote>\n<p>We\u2019ll get the same result if we have a non-annotatable parent without a\nparent:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ob3.__parent__ = C()\n</pre>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P1', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P3', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P1G', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2G', ob3)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P3G', ob3)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P4G', ob3)\nFalse\n</pre>\n</blockquote>\n</div>\n<div id=\"the-anonymous-role\">\n<h3>The Anonymous role</h3>\n<p>The security policy defines a special role named \u201czope.Anonymous\u201d.  All\nprincipals have this role and the role cannot be taken away.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleperG.grantPermissionToRole('P5', 'zope.Anonymous', False)\n&gt;&gt;&gt; interaction.checkPermission('P5', ob2)\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"proxies\">\n<h3>Proxies</h3>\n<p>Objects may be proxied:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.security.checker import ProxyFactory\n&gt;&gt;&gt; ob = ProxyFactory(ob)\n&gt;&gt;&gt; interaction.checkPermission('P1', ob)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2', ob)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P3', ob)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P1G', ob)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2G', ob)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P3G', ob)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P4G', ob)\nTrue\n</pre>\n</blockquote>\n<p>as may their parents:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ob3 = C()\n&gt;&gt;&gt; ob3.__parent__ = ob\n</pre>\n<pre>&gt;&gt;&gt; interaction.checkPermission('P1', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P3', ob3)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P1G', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P2G', ob3)\nFalse\n&gt;&gt;&gt; interaction.checkPermission('P3G', ob3)\nTrue\n&gt;&gt;&gt; interaction.checkPermission('P4G', ob3)\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"groups\">\n<h3>Groups</h3>\n<p>Principals may have groups.  Groups are also principals (and, thus,\nmay have groups).</p>\n<p>If a principal has groups, the groups are available as group ids in\nthe principal\u2019s <cite>groups</cite> attribute.  The interaction has to convert\nthese group ids to group objects, so that it can tell whether the\ngroups have groups.  It does this by calling the <cite>getPrincipal</cite> method\non the principal authentication service, which is responsible for,\namong other things, converting a principal id to a principal.\nFor our examples here, we\u2019ll create and register a stub principal\nauthentication service:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.authentication.interfaces import IAuthentication\n&gt;&gt;&gt; @zope.interface.implementer(IAuthentication)\n... class FauxPrincipals(object):\n...     def __init__(self):\n...         self.data = {}\n...     def __setitem__(self, key, value):\n...         self.data[key] = value\n...     def __getitem__(self, key):\n...         return self.data[key]\n...     def getPrincipal(self, id):\n...         return self.data[id]\n</pre>\n<pre>&gt;&gt;&gt; auth = FauxPrincipals()\n</pre>\n<pre>&gt;&gt;&gt; from zope.component import provideUtility\n&gt;&gt;&gt; provideUtility(auth, IAuthentication)\n</pre>\n</blockquote>\n<p>Let\u2019s define a group:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; auth['g1'] = Principal('g1')\n</pre>\n</blockquote>\n<p>Let\u2019s put the principal in our group.  We do that by adding the group id\nto the new principals groups:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; principal.groups.append('g1')\n</pre>\n</blockquote>\n<p>Of course, the principal doesn\u2019t have permissions not granted:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('gP1', ob)\nFalse\n</pre>\n</blockquote>\n<p>Now, if we grant a permission to the group:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinper.grantPermissionToPrincipal('gP1', 'g1')\n</pre>\n</blockquote>\n<p>We see that our principal has the permission:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('gP1', ob)\nTrue\n</pre>\n</blockquote>\n<p>This works even if the group grant is global:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('gP1G', ob)\nFalse\n</pre>\n<pre>&gt;&gt;&gt; prinperG.grantPermissionToPrincipal('gP1G', 'g1', True)\n</pre>\n<pre>&gt;&gt;&gt; interaction.checkPermission('gP1G', ob)\nTrue\n</pre>\n</blockquote>\n<p>Grants are, of course, acquired:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('gP1', ob2)\nTrue\n</pre>\n<pre>&gt;&gt;&gt; interaction.checkPermission('gP1G', ob2)\nTrue\n</pre>\n</blockquote>\n<p>Inner grants can override outer grants:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinper2.denyPermissionToPrincipal('gP1', 'g1')\n&gt;&gt;&gt; interaction.checkPermission('gP1', ob2)\nFalse\n</pre>\n</blockquote>\n<p>But principal grants always trump group grants:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinper2.grantPermissionToPrincipal('gP1', 'bob')\n&gt;&gt;&gt; interaction.checkPermission('gP1', ob2)\nTrue\n</pre>\n</blockquote>\n<p>Groups can have groups too:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; auth['g2'] = Principal('g2')\n&gt;&gt;&gt; auth['g1'].groups.append('g2')\n</pre>\n</blockquote>\n<p>If we grant to the new group:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinper.grantPermissionToPrincipal('gP2', 'g2')\n</pre>\n</blockquote>\n<p>Then we, of course have that permission too:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('gP2', ob2)\nTrue\n</pre>\n</blockquote>\n<p>Just as principal grants override group grants, group grants can\noverride other group grants:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinper.denyPermissionToPrincipal('gP2', 'g1')\n&gt;&gt;&gt; interaction.checkPermission('gP2', ob2)\nFalse\n</pre>\n</blockquote>\n<p>Principals can be in more than one group. Let\u2019s define a new group:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; auth['g3'] = Principal('g3')\n&gt;&gt;&gt; principal.groups.append('g3')\n&gt;&gt;&gt; prinper.grantPermissionToPrincipal('gP2', 'g3')\n</pre>\n</blockquote>\n<p>Now, the principal has two groups. In one group, the permission \u2018gP2\u2019\nis denied, but in the other, it is allowed.  In a case like this, the\npermission is allowed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('gP2', ob2)\nTrue\n</pre>\n</blockquote>\n<p>In a case where a principal has two or more groups, the group denies\nprevent allows from their parents. They don\u2019t prevent the principal\nfrom getting an allow from another principal.</p>\n<p>Grants can be inherited from ancestor groups through multiple paths.\nLet\u2019s grant a permission to g2 and deny it to g1:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinper.grantPermissionToPrincipal('gP3', 'g2')\n&gt;&gt;&gt; prinper.denyPermissionToPrincipal('gP3', 'g1')\n</pre>\n</blockquote>\n<p>Now, as before, the deny in g1 blocks the grant in g2:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.checkPermission('gP3', ob2)\nFalse\n</pre>\n</blockquote>\n<p>Let\u2019s make g2 a group of g3:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; auth['g3'].groups.append('g2')\n</pre>\n</blockquote>\n<p>Now, we get g2\u2019s grant through g3, and access is allowed:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; interaction.invalidate_cache()\n&gt;&gt;&gt; interaction.checkPermission('gP3', ob2)\nTrue\n</pre>\n</blockquote>\n<p>We can assign roles to groups:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinrole.assignRoleToPrincipal('gR1', 'g2')\n</pre>\n</blockquote>\n<p>and get permissions through the roles:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; roleper.grantPermissionToRole('gP4', 'gR1')\n&gt;&gt;&gt; interaction.checkPermission('gP4', ob2)\nTrue\n</pre>\n</blockquote>\n<p>we can override role assignments to groups through subgroups:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinrole.removeRoleFromPrincipal('gR1', 'g1')\n&gt;&gt;&gt; prinrole.removeRoleFromPrincipal('gR1', 'g3')\n&gt;&gt;&gt; interaction.checkPermission('gP4', ob2)\nFalse\n</pre>\n</blockquote>\n<p>and through principals:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; prinrole.assignRoleToPrincipal('gR1', 'bob')\n&gt;&gt;&gt; interaction.checkPermission('gP4', ob2)\nTrue\n</pre>\n</blockquote>\n<p>We clean up the changes we made in these examples:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; zope.security.management.endInteraction()\n&gt;&gt;&gt; ignore = zope.security.management.setSecurityPolicy(oldpolicy)\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"changes\">\n<h2>Changes</h2>\n<div id=\"id1\">\n<h3>4.3.1 (2018-10-11)</h3>\n<ul>\n<li>Use current location for <cite>IRegistered</cite> and <cite>IUnregistered</cite> interface.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3>4.3.0 (2018-08-27)</h3>\n<ul>\n<li>Add support for Python 3.7.</li>\n<li>Drop support for Python 3.3.</li>\n<li>Drop support for <tt>python setup.py test</tt>.</li>\n<li>Make <tt>SecurityMap</tt> and <tt>AnnotationGrantInfo</tt> have proper truth\nbehaviour on Python 3; previously they were always true.</li>\n<li>Make <tt>AnnotationGrantInfo</tt> consistently return lists instead of\ndict views on Python 3.</li>\n<li>Make <tt>AnnotationSecurityMap</tt> (and objects derived from it, such as\n<tt>AnnotationPrincipalPermissionManager</tt> and the role managers) more\nefficient when adding or removing cells before they have been\npersisted. They now avoid some unnecessary object copying.</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>4.2.0 (2017-08-24)</h3>\n<ul>\n<li>Add <tt>&lt;zope:deny&gt;</tt> directive, which is a mirror of the <tt>&lt;zope:grant&gt;</tt>\ndirective.</li>\n<li>Add support for Python 3.6.</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>4.1.0 (2016-11-05)</h3>\n<ul>\n<li><p>Add support for Python 3.5.</p>\n</li>\n<li><p>Drop support for Python 2.6.</p>\n</li>\n<li><p>Add support to grant multiple permissions with one ZCML statement. Example:</p>\n<pre>&lt;grant\n  role=\"my-role\"\n  permissions=\"zope.foo\n               zope.bar\" /&gt;\n</pre>\n</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3>4.0.0 (2014-12-24)</h3>\n<ul>\n<li>Add support for PyPy.  (PyPy3 is pending release of a fix for:\n<a href=\"https://bitbucket.org/pypy/pypy/issue/1946\" rel=\"nofollow\">https://bitbucket.org/pypy/pypy/issue/1946</a>)</li>\n<li>Add support for Python 3.4.</li>\n<li>Add support for testing on Travis.</li>\n</ul>\n</div>\n<div id=\"a1-2013-02-22\">\n<h3>4.0.0a1 (2013-02-22)</h3>\n<ul>\n<li>Add support for Python 3.3.</li>\n<li>Replace deprecated <tt>zope.interface.classProvides</tt> usage with equivalent\n<tt>zope.interface.provider</tt> decorator.</li>\n<li>Replace deprecated <tt>zope.interface.implements</tt> usage with equivalent\n<tt>zope.interface.implementer</tt> decorator.</li>\n<li>Drop support for Python 2.4 and 2.5.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3>3.7.0 (2010-09-25)</h3>\n<ul>\n<li>LP #131115: Clean up inconsistency in <tt>getSetting</tt> interface definitions\nand actual usage for the various security maps.</li>\n<li>LP #564525:  fix permission moved from <tt>zope.app.dublincore</tt> namespace\nto <tt>zope.dublincore</tt>.</li>\n<li>Remove unused imports and pep8 cleanup.</li>\n<li>Use doctest module instead of the deprecated zope.testing.doctest.</li>\n<li>AnnotationGrantInfo implements IGrantInfo.</li>\n<li>Add test extra to declare test dependency on <tt>zope.component [test]</tt>.</li>\n<li>Add an extra named <tt>dublincore</tt> to express optional dependency on\n<tt>zope.dublincore &gt;= 3.7</tt>.</li>\n<li>Add tests for ZCML files making sure they include everything they need.</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3>3.6.1 (2009-07-24)</h3>\n<ul>\n<li>Make tests work when the default and Zope vocabulary registry compete in the\ncleanup.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3>3.6.0 (2009-03-14)</h3>\n<ul>\n<li>Change <tt>zope.app.security</tt> dependency to the new <tt>zope.authentication</tt>\npackage, dropping a big number of unused dependencies.</li>\n<li>Get rid of <tt>zope.app.testing</tt> and other testing dependencices.</li>\n<li>Add <tt>ZODB3</tt> to install dependencies, because we use <tt>Persistent</tt>\nclass. We didn\u2019t fail before, because it was installed implicitly.</li>\n</ul>\n</div>\n<div id=\"id9\">\n<h3>3.5.1 (2009-03-10)</h3>\n<ul>\n<li>Don\u2019t depend on the <tt>hook</tt> extra of zope.component, as we don\u2019t need\nit explicitly.</li>\n<li>Import security settings (Allow, Deny, Unset) in the <tt>interfaces</tt>\nmodule from the <tt>zope.securitypolicy.settings</tt>, added in previous\nrelease instead of old <tt>zope.app.security.settings</tt>.\nThe <tt>zope.app.security</tt> will be adapted to import them from\n<tt>zope.securitypolicy.interfaces</tt>.</li>\n<li>Use <tt>_z_instances</tt> instead of <tt>__instances__</tt> for storing instances\nfor <tt>zope.securitypolicy.settings.PermissionSetting</tt> singleton\nimplementation, because __*__ name pattern is reserved for special\nnames in python.</li>\n<li>Add security protections for the <tt>PermissionSetting</tt>.</li>\n<li>Improve documentation formatting, add it to the package\u2019s long\ndescription.</li>\n<li>Remove unneeded dependencies.</li>\n<li>Remove old zpkg-related files and zcml slugs.</li>\n</ul>\n</div>\n<div id=\"id10\">\n<h3>3.5.0 (2009-01-31)</h3>\n<ul>\n<li>Include settings that were previously imported from zope.app.security.</li>\n</ul>\n</div>\n<div id=\"id11\">\n<h3>3.4.2 (2009-01-28)</h3>\n<ul>\n<li>Change mailing list address to zope-dev at zope.org. Fix package\nhomepage to the pypi page.</li>\n<li>Fix test in buildout which still depended on zope.app.securitypolicy\nby mistake.</li>\n<li>Remove explicit dependency on zope.app.form from <tt>setup.py</tt>; nothing\nin the code directly depends on this.</li>\n</ul>\n</div>\n<div id=\"id12\">\n<h3>3.4.1 (2008-06-02)</h3>\n<ul>\n<li>Fix reference to deprecated security policy from ZCML.</li>\n</ul>\n</div>\n<div id=\"id13\">\n<h3>3.4.0 (2007-09-25)</h3>\n<ul>\n<li>Initial documented release</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4364331, "releases": {"3.4.0": [{"comment_text": "", "digests": {"md5": "f8096d0e5501c8d0ba7243abba0c3530", "sha256": "0d5e40e522886ce795b13d69a2193540f978d1d4aa2ebd05a5449ff85a082eb9"}, "downloads": -1, "filename": "zope.securitypolicy-3.4.0.tar.gz", "has_sig": false, "md5_digest": "f8096d0e5501c8d0ba7243abba0c3530", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22001, "upload_time": "2007-09-26T23:25:40", "upload_time_iso_8601": "2007-09-26T23:25:40Z", "url": "https://files.pythonhosted.org/packages/d9/37/1065bed88bb241f4aad436b59b2c192c36288a757719e9ddf2361378af7e/zope.securitypolicy-3.4.0.tar.gz", "yanked": false}], "3.4.1": [{"comment_text": "", "digests": {"md5": "1ce3774fd4f6681a13ee261b7ebc322b", "sha256": "800571202bfd5f73ac943642343dd29ebd98250e696a2bdc604abceb713ed4d8"}, "downloads": -1, "filename": "zope.securitypolicy-3.4.1.tar.gz", "has_sig": false, "md5_digest": "1ce3774fd4f6681a13ee261b7ebc322b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22242, "upload_time": "2008-06-02T15:43:40", "upload_time_iso_8601": "2008-06-02T15:43:40Z", "url": "https://files.pythonhosted.org/packages/8e/7a/7c194f098bf8a99262c85a991dba32e82c7effaab3a522d8acd7b55e6548/zope.securitypolicy-3.4.1.tar.gz", "yanked": false}], "3.4.2": [{"comment_text": "", "digests": {"md5": "e0bec5c0f345ec58d5b9e1cbdd51eedd", "sha256": "394e5b77a56e2daaf542b2a9cadc23e3b06813e5ac2449f25f993f677a1d9d91"}, "downloads": -1, "filename": "zope.securitypolicy-3.4.2.tar.gz", "has_sig": false, "md5_digest": "e0bec5c0f345ec58d5b9e1cbdd51eedd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22869, "upload_time": "2009-01-27T22:37:11", "upload_time_iso_8601": "2009-01-27T22:37:11Z", "url": "https://files.pythonhosted.org/packages/2d/dd/95b7888562221dbf449b46f9c767ba11bcaafd885ea7c1d547ffd6b001f1/zope.securitypolicy-3.4.2.tar.gz", "yanked": false}], "3.4.3": [{"comment_text": "", "digests": {"md5": "50cecf57a7f3ee9451fc629021a59304", "sha256": "32c4a0654a77f034cfadd365d5bfd5321fe3b9a12dc30d8bd8d1fcad1cb9cb1b"}, "downloads": -1, "filename": "zope.securitypolicy-3.4.3.tar.gz", "has_sig": false, "md5_digest": "50cecf57a7f3ee9451fc629021a59304", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22801, "upload_time": "2010-04-16T18:59:09", "upload_time_iso_8601": "2010-04-16T18:59:09.958081Z", "url": "https://files.pythonhosted.org/packages/46/38/ca965c0455bf493ceb4fbb9be9d919bb1185be1b9070dad2560496379ea1/zope.securitypolicy-3.4.3.tar.gz", "yanked": false}], "3.4.4": [{"comment_text": "", "digests": {"md5": "5fbde491710e78d206d88d33a752cbc5", "sha256": "d7bfeec345ea56828649f534fcf2b4ba3ac827077d581f2c56faf85d61f63275"}, "downloads": -1, "filename": "zope.securitypolicy-3.4.4.tar.gz", "has_sig": false, "md5_digest": "5fbde491710e78d206d88d33a752cbc5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22896, "upload_time": "2010-04-19T18:12:57", "upload_time_iso_8601": "2010-04-19T18:12:57.354150Z", "url": "https://files.pythonhosted.org/packages/19/fe/60092f365b387ac228700168017e84ac254f1c7057cf89467f13cb914018/zope.securitypolicy-3.4.4.tar.gz", "yanked": false}], "3.5.0": [{"comment_text": "", "digests": {"md5": "f6f9ed190a16f46441aea8a387ac46f0", "sha256": "4288c1a4e768455ad2420f0d2cfa1a5f4b197726e078b611cc509ac67ac01cc5"}, "downloads": -1, "filename": "zope.securitypolicy-3.5.0.tar.gz", "has_sig": false, "md5_digest": "f6f9ed190a16f46441aea8a387ac46f0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23293, "upload_time": "2009-01-31T14:11:10", "upload_time_iso_8601": "2009-01-31T14:11:10Z", "url": "https://files.pythonhosted.org/packages/62/af/b76d528a7259c20c02ad7e5fad4c4a205c013e919e880f372485df57bfd1/zope.securitypolicy-3.5.0.tar.gz", "yanked": false}], "3.5.1": [{"comment_text": "", "digests": {"md5": "2bceaf48b05eac42d840bc729f22cb4f", "sha256": "f80856fc7ea527116af83c6605ff29ebe808a969fdc96db23d6d19f21ba4a898"}, "downloads": -1, "filename": "zope.securitypolicy-3.5.1.tar.gz", "has_sig": false, "md5_digest": "2bceaf48b05eac42d840bc729f22cb4f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33058, "upload_time": "2009-03-10T03:16:57", "upload_time_iso_8601": "2009-03-10T03:16:57.340067Z", "url": "https://files.pythonhosted.org/packages/8c/a5/091b2749b9a2677c9fc19aa797c84de42baab4c124736d1995c028a5be47/zope.securitypolicy-3.5.1.tar.gz", "yanked": false}], "3.6.0": [{"comment_text": "", "digests": {"md5": "51c3fe475ac2cd30eb72b4bf0555e1cd", "sha256": "34af3bc83d2eb721a7c945d7741a0900ebe04dce6d49e9e2c7ff6ef8fbc17ae0"}, "downloads": -1, "filename": "zope.securitypolicy-3.6.0.tar.gz", "has_sig": false, "md5_digest": "51c3fe475ac2cd30eb72b4bf0555e1cd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33687, "upload_time": "2009-03-14T17:10:22", "upload_time_iso_8601": "2009-03-14T17:10:22.254286Z", "url": "https://files.pythonhosted.org/packages/d9/00/c8e79cb2914882e4c7a1b97d23f48c1588b997458bff26c742bee0412afe/zope.securitypolicy-3.6.0.tar.gz", "yanked": false}], "3.6.1": [{"comment_text": "", "digests": {"md5": "1434dc3e21e1ec3e9355d2945e0d7fb9", "sha256": "3e6825deaaa07edec868f12cc85c38f9913a9614d961cf51b3f769182fa327bd"}, "downloads": -1, "filename": "zope.securitypolicy-3.6.1.tar.gz", "has_sig": false, "md5_digest": "1434dc3e21e1ec3e9355d2945e0d7fb9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33620, "upload_time": "2009-07-24T08:18:46", "upload_time_iso_8601": "2009-07-24T08:18:46.350741Z", "url": "https://files.pythonhosted.org/packages/06/5b/531b5971f2c9ef1ea6089b6d37362999876f60fac5a21bef6cc3fb110794/zope.securitypolicy-3.6.1.tar.gz", "yanked": false}], "3.7.0": [{"comment_text": "", "digests": {"md5": "fe9ba029384c0640b2ba175ba1805cd8", "sha256": "9f07222b86e8186a37bb044465b98c58e2c097185348c7f77d7d3928e1ce648e"}, "downloads": -1, "filename": "zope.securitypolicy-3.7.0.tar.gz", "has_sig": false, "md5_digest": "fe9ba029384c0640b2ba175ba1805cd8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34470, "upload_time": "2010-09-25T13:58:38", "upload_time_iso_8601": "2010-09-25T13:58:38.492648Z", "url": "https://files.pythonhosted.org/packages/90/71/271977dde35ad6f0a1767d7785bff1f9abd1db5fc8613f26f790cd6b9399/zope.securitypolicy-3.7.0.tar.gz", "yanked": false}], "4.0.0": [{"comment_text": "", "digests": {"md5": "b150a9065f649c63ec7f61167f3f8e53", "sha256": "f2cca2046ae1d7259d059412989f4911042b3c4b98b00b187dc78ee67f36d54f"}, "downloads": -1, "filename": "zope.securitypolicy-4.0.0.tar.gz", "has_sig": false, "md5_digest": "b150a9065f649c63ec7f61167f3f8e53", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39111, "upload_time": "2014-12-24T23:13:32", "upload_time_iso_8601": "2014-12-24T23:13:32.474498Z", "url": "https://files.pythonhosted.org/packages/80/f8/114fe9532ed5043e26cc9fe5610af08356b857bcaf1ad64579ce2d320923/zope.securitypolicy-4.0.0.tar.gz", "yanked": false}], "4.0.0a1": [{"comment_text": "", "digests": {"md5": "43b3399e859d4e6c22f6c8585646743e", "sha256": "7bd7e02786207cd5aceec7b215d31b94b39ba86cef19061567b8d30f7390e858"}, "downloads": -1, "filename": "zope.securitypolicy-4.0.0a1.zip", "has_sig": false, "md5_digest": "43b3399e859d4e6c22f6c8585646743e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 66133, "upload_time": "2013-02-22T14:11:54", "upload_time_iso_8601": "2013-02-22T14:11:54.821956Z", "url": "https://files.pythonhosted.org/packages/8a/8e/5c3ec7a7152efbd6c7fef72f227facef3efb693b72b188e2338de05af9f7/zope.securitypolicy-4.0.0a1.zip", "yanked": false}], "4.1.0": [{"comment_text": "", "digests": {"md5": "2b3e36ae4a53cb926a2e6fee2b5edca0", "sha256": "e708208c5b6006a38eb55c54c42193c372389346b2424d5ee15a4d79fa14efca"}, "downloads": -1, "filename": "zope.securitypolicy-4.1.0.tar.gz", "has_sig": false, "md5_digest": "2b3e36ae4a53cb926a2e6fee2b5edca0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37584, "upload_time": "2016-11-05T12:18:39", "upload_time_iso_8601": "2016-11-05T12:18:39.826843Z", "url": "https://files.pythonhosted.org/packages/90/e9/8d950f1b265835104e925671f4b57a236218f7e7fc507049043edb875449/zope.securitypolicy-4.1.0.tar.gz", "yanked": false}], "4.2.0": [{"comment_text": "", "digests": {"md5": "a203a84c47b36a05f6714aa9b5f104db", "sha256": "6285864355990b2d64978187924a54c1e00b5d534e5ecac6255ef2d3b01a97be"}, "downloads": -1, "filename": "zope.securitypolicy-4.2.0.tar.gz", "has_sig": false, "md5_digest": "a203a84c47b36a05f6714aa9b5f104db", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40237, "upload_time": "2017-08-24T17:04:55", "upload_time_iso_8601": "2017-08-24T17:04:55.083505Z", "url": "https://files.pythonhosted.org/packages/f6/f2/e9f68bcf69c5d5559ce175de426d392898123e3e0fff52dc0a84883c16b6/zope.securitypolicy-4.2.0.tar.gz", "yanked": false}], "4.3.0": [{"comment_text": "", "digests": {"md5": "cea891782af4ea863a0dc5cb63cb1b14", "sha256": "08ea7aab44d6fd680b40923328091eee6dd9b7df7531ac530bbef9ac88ee9879"}, "downloads": -1, "filename": "zope.securitypolicy-4.3.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "cea891782af4ea863a0dc5cb63cb1b14", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 54542, "upload_time": "2018-08-27T12:44:48", "upload_time_iso_8601": "2018-08-27T12:44:48.511549Z", "url": "https://files.pythonhosted.org/packages/45/24/d1b200bb0adcb0aeb476d66bba0d60dc59a997c8c85c31617905411093eb/zope.securitypolicy-4.3.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "735295554a41c99cd591d954173fa14e", "sha256": "8679cd23fe968c5d70bf2c74686075fc04c4fc49def0a4e3d4d819bc8ed28dc3"}, "downloads": -1, "filename": "zope.securitypolicy-4.3.0.tar.gz", "has_sig": false, "md5_digest": "735295554a41c99cd591d954173fa14e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40435, "upload_time": "2018-08-27T12:44:50", "upload_time_iso_8601": "2018-08-27T12:44:50.333190Z", "url": "https://files.pythonhosted.org/packages/bb/1e/0b8dcd800fda0724ca237b4f895115226101578725474c0cb4c3c572292a/zope.securitypolicy-4.3.0.tar.gz", "yanked": false}], "4.3.1": [{"comment_text": "", "digests": {"md5": "3ff4a3be4695da0cd6a02a47251b19aa", "sha256": "c1faa82f02f97af66f6bc48b94c86402041ae44383f4b94c75eebce1765851b7"}, "downloads": -1, "filename": "zope.securitypolicy-4.3.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "3ff4a3be4695da0cd6a02a47251b19aa", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 54571, "upload_time": "2018-10-11T13:17:53", "upload_time_iso_8601": "2018-10-11T13:17:53.822506Z", "url": "https://files.pythonhosted.org/packages/ba/49/9364f50958e1fd277999679e262c690e4970cf4293d7bd1f4ef3dff0bb50/zope.securitypolicy-4.3.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "51c04d8750d50c2aab9c52a70ae94d0d", "sha256": "7eaf56b1e156696aba31722cb62efb6a5df934e3af00f96667aa3133161cd55d"}, "downloads": -1, "filename": "zope.securitypolicy-4.3.1.tar.gz", "has_sig": false, "md5_digest": "51c04d8750d50c2aab9c52a70ae94d0d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42629, "upload_time": "2018-10-11T13:17:55", "upload_time_iso_8601": "2018-10-11T13:17:55.790974Z", "url": "https://files.pythonhosted.org/packages/32/94/f6bf40168a79816291c0239188358e8a73e87bef052f9878985cdb590d25/zope.securitypolicy-4.3.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3ff4a3be4695da0cd6a02a47251b19aa", "sha256": "c1faa82f02f97af66f6bc48b94c86402041ae44383f4b94c75eebce1765851b7"}, "downloads": -1, "filename": "zope.securitypolicy-4.3.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "3ff4a3be4695da0cd6a02a47251b19aa", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 54571, "upload_time": "2018-10-11T13:17:53", "upload_time_iso_8601": "2018-10-11T13:17:53.822506Z", "url": "https://files.pythonhosted.org/packages/ba/49/9364f50958e1fd277999679e262c690e4970cf4293d7bd1f4ef3dff0bb50/zope.securitypolicy-4.3.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "51c04d8750d50c2aab9c52a70ae94d0d", "sha256": "7eaf56b1e156696aba31722cb62efb6a5df934e3af00f96667aa3133161cd55d"}, "downloads": -1, "filename": "zope.securitypolicy-4.3.1.tar.gz", "has_sig": false, "md5_digest": "51c04d8750d50c2aab9c52a70ae94d0d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42629, "upload_time": "2018-10-11T13:17:55", "upload_time_iso_8601": "2018-10-11T13:17:55.790974Z", "url": "https://files.pythonhosted.org/packages/32/94/f6bf40168a79816291c0239188358e8a73e87bef052f9878985cdb590d25/zope.securitypolicy-4.3.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:12:35 2020"}