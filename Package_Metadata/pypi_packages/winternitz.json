{"info": {"author": "Harald Heckmann", "author_email": "harald.heckmann93@web.de", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3 :: Only", "Topic :: Security :: Cryptography"], "description": "|Build Status| |Coverage Status| |Documentation Status| |License: MIT|\n\nWinternitz One-Time-Signature\n==============================\n\nPython implementation of Winternitz one-time-signature schemes\n\nDescription\n-----------\n\nWinternitz one-time-signature is an extension of lamport one-time-signature.\nThis python package can be used to execute WOTS operations, including\nkey generation, signature generation and signature verification.\nCurrently WOTS and WOTS+ are implemented.\n\nIntroduction\n------------\nLamport invented an algorithm in 1979 which allowed one to create one-time-signatures\nusing a cryptographically secure one-way function. It is the basis for the Winternitz\none-time-signature algorithm. Winternitz added the possibility to adjust the tradeoff\nbetween time- and space-complexity.\n\nLamport one-time-signature scheme\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nLamport suggested to create two secret keys for each bit of a message which will\nbe signed. One for each value the bit can take. To derive the verification key,\neach secret key is hashed once. Now you have a secret key and a verification key,\nwhich consists of `m` 2-tuples of values, where `m` is the number\nof bits of the message. The verification key is published.\nThe signature consists of `m` values. For each bit of the message you release a secret key from\nthe corresponding secret keys, depending on which value the bit has. All those secret\nkeys form the signature for the message. The verifier hashes each of your secret keys\nonce and compares it to one verification key for this position, depending on the value\nof the bit. The signature is valid, if and only if all derived verification keys match with\nyour published verification key at the correct position of the 2-tuple, which is determined by the value\nof the bit. This algorithm is quite fast\n(comparing it to existing PQC-algorithms), but the signature sizes are huge.\n\nWinternitz extension\n~~~~~~~~~~~~~~~~~~~~\nWinternitz extended lamports algorithm by offering the possiblity to decide\nhow many bits will be signed together. The amount of numbers those bits can\nrepresent is called the Winternitz parameter (`w = 2^{bits}`). This method offers the huge\nadvantage that the user of this algorithm can choose the time and space tradeoff\n(whether speed or storage capacity is more relevant). A fingerprint of the message which\nwill be signed is split into groups of `ceil(log_2(w))` bits. Each of these groups gets one secret key.\nEach verification key is derived by hashing the secret key for each group `2^{w-1}` times. All verification\nkeys will be published and represent one unified verification key. When signing a message, the\nfingerprint of the message is split into groups of `ceil(log2(w))` bits. To create the signature, the\nprivate key for each bit group is hashed `bitgroup_value` times, where `bitgroup_value` is the value\nof the bitgroup. Additionally a (inverse sum) checksum is appended, which denies man-in-the-middle\nattacks. The checksum is calculated from the signature, split into bit groups of `ceil(log2(w))` bits, and\nsigned. To verify the signature, the fingerprint of the message is first split into bit groups of `ceil(log2(w)`\nbits each. The basic idea is to take the signature of each bit group, calculate the verification key\nfrom it and finally compare it to the published verification key. Since the signature was hashed\n`bitgroup_value` times, all you have to do to calculate the verification key from the signature\nis to hash the signature `2^{w-1} - bitgroup_value - 1` times. Besides verifing the message, the verifier\nmust also calculate the checksum and verify it.\n\nSetup\n-----\nRequires: Python >= 3.4\n\n| Install package: ``pip install winternitz``\n| Install test tools: ``pip install winternitz[TEST]``\n| Install linter (for tox tests): ``pip install winternitz[LINT]``\n| Install documentation tools: ``pip install winternitz[DOCS]``\n| Install everything: ``pip install winternitz[ALL]``\n\nTest\n~~~~\n| Without tox (no linter checks): ``python setup.py test``\n| With tox: ``python -m tox``\n\nGenerate documentation\n~~~~~~~~~~~~~~~~~~~~~~\n``python setup.py docs``\n\n\nUsage\n-----\n\nThe package *winternitz* contains a module called *signatures*.\nWithin this package you can find the classes WOTS and WOTSPLUS.\nThose classes can be used out of the box to sign or verify\nmessages\n\nWOTS\n~~~~\n.. code-block:: python\n\n    import winternitz.signatures\n    # Create signature and verify it with the same object\n    wots = winternitz.signatures.WOTS()\n    message = \"My message in bytes format\".encode(\"utf-8\")\n    sig = wots.sign(message)\n    success = wots.verify(message=message, signature=sig[\"signature\"])\n    print(\"Verification success: \" + str(success))\n    # Output: Verification success: True\n\nIf you don't specify any values in the constructor of WOTS, it will use\nthe winternitz parameter 16 and the hash function *sha512* as default parameters.\nThe private key will be generated from entropy. After you received the public key,\neither through ``wots.pubkey`` or inside the dict that is returned by the\n``wots.sign(message)`` function call, you publish it. Verify that it was not modified.\nIn the best case a man-in-the-middle attack to modify your public key is impossible\nby the design of the application. The last step is to publish your message and every\ninformation in the dict that is returned by ``wots.sign(message)``, except the public\nkey (since it was already published). Publishing the fingerprint is optional, since it\nis not essential for the signature verification. The signature dict contains the following\nvalues:\n\n.. code-block:: python\n\n    {\n        \"w\":            winternitz parameter (Type: int),\n        \"fingerprint\":  message hash (Type: bytes),\n        \"hashalgo\":     hash algorithm (Type: str),\n        \"digestsize\":   hash byte count (Type: int),\n        \"pubkey\":       public key (Type: List[bytes]),\n        \"signature\":    signature (Type: List[bytes])\n    }\n\nWith that data, another person can verify the authenticity of your message:\n\n.. code-block:: python\n\n    # Another person or machine wants to verify your signature:\n    # get required hash function by comparing the name\n    # published with local implementaitons\n    if sig[\"hashalgo\"] == \"openssl_sha512\":\n        hashfunc = winternitz.signatures.openssl_sha512\n    elif sig[\"hashalgo\"] == \"openssl_sha256\":\n        hashfunc = winternitz.signautres.openssl_sha256\n    else:\n        raise NotImplementedError(\"Hash function not implemented\")\n\n    wots_other = winternitz.signatures.WOTS(w=sig[\"w\"], hashfunction=hashfunc,\n                                            digestsize=sig[\"digestsize\"], pubkey=sig[\"pubkey\"])\n    success = wots_other.verify(message=message, signature=sig[\"signature\"])\n    print(\"Verification success: \" + str(success))\n    # Output: Verification success: True\n\nIn certain situations it might not be wanted to verify the derived public key with the\npublic key inside the executing WOTS object. For example, this can be this case when\nthe verification happens in a wrapping structure, like a XMSS tree. In such cases\nthe public key can be derived from a message and a signature with the function\n``wots.getPubkeyFromSignature(message=message, signature=signature)``\n\nWOTSPLUS\n~~~~~~~~\n.. code-block:: python\n\n    import winternitz.signatures\n    wotsplus = winternitz.signatures.WOTSPLUS()\n    message = \"My message in bytes format\".encode(\"utf-8\")\n    sig = wotsplus.sign(message)\n    success = wotsplus.verify(message=message, signature=sig[\"signature\"])\n    print(\"Verification success: \" + str(success))\n    # Output: Verification success: True\n\nIf you don't specify any values in the constructor of WOTSPLUS, it will use the winternitz parameter\n16 and the hash function defaults to *sha256*. It further requires a pseudo random function, which defaults\nto *HMAC-sha256*, as well as a seed which is also generated from entropy. For further\ninformations about functions and their parameters, visit the module reference in\nthis the `documentation <https://winternitz-one-time-signature.readthedocs.io/en/latest/?badge=latest>`_.\nSince WOTS+ uses a pseudo random function and a seed to derive signatures and public\nkeys, they have to be published as well. In addition to the signature of WOTS, the returned dict contains\nthe following values:\n\n.. code-block:: python\n\n    {\n        # ...\n        \"prf\":          pseudo random function (Type: str),\n        \"seed\":         Seed used in prf (Type: bytes)\n    }\n\nThose arguments have to be specified in the constructor of WOTSPLUS in addition to those parameters\nspecified in WOTS.\n\nMisc\n~~~~\nThe WOTS classes come with some features that will be explained in the following sections.\n\nFully configurable\n^^^^^^^^^^^^^^^^^^\nThe WOTS classes are fully parameterizable. You can specify anything that is specified\nin the papers describing the algorithm, including the Winternitz parameter, the hash function,\nthe pseudo random function (WOTSPLUS), the seed (WOTSPLUS), the private key and the public key.\nspecifing both a private key and public key results in the public key beeing discarded.\n\nOn-demand generation of keys\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nIf no private key or no public key is specified, they will be set to None. The same\ngoes for the seed in wots+. Only when they are required, they will be generated or\nderived. This means that as long as you don't execute ``repr(obj)``, ``str(obj)``, ``obj1 == obj2``,\n``obj1 != obj2``, ``obj.pubkey``, ``obj.privkey``, ``obj.sign(...)`` or ``obj.verify(...)``, where obj is a\nWOTS object, the keys will stay None.\n\nCode representation of WOTS objects\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nYou can call ``repr(obj)``, where obj is a WOTS object, to get a line of code which contains\nall information to initialize another object so that it is equal to obj. Executing ``obj2 = eval(repr(obj))``\nexecutes that code which is returned by ``repr(obj)`` and ultimately stores a copy of it in ``obj2``.\n\nHuman readable string representation\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nYou can call ``str(obj)`` to get a string which contains a human readable representation of that object.\n\nComparison of objects\n^^^^^^^^^^^^^^^^^^^^^\nYou can compare two objects from this class ``obj1 == obj2`` and ``obj1 != obj2``\n\nOptimizations\n^^^^^^^^^^^^^\nThe code was carefully written to reduce execution times. It surely is not perfect and can still be optimized,\nfurther time-critical sections could be coded as C extensions, but nevertheless in the current state it should\noffer quite an efficient implementation. It defines ``__slots__`` to reduce execution times and storage requirements\nwithin the class. Implementation of parallelization is planned, but it is only usefull when using huge winternitz\nparameters, since python can only execute code in parallel if you spawn a new process and the overhead of forking\na new python interpreter is not negliable.\n\nNote\n----\n\nThis project has been set up using PyScaffold 3.1. For details and usage\ninformation on PyScaffold see `https://pyscaffold.org/`_.\n\n.. _`https://pyscaffold.org/`: https://pyscaffold.org/\n\n.. |Build Status| image:: https://www.travis-ci.com/sea212/winternitz-one-time-signature.svg?branch=master\n   :target: https://www.travis-ci.com/sea212/winternitz-one-time-signature\n.. |Coverage Status| image:: https://coveralls.io/repos/github/sea212/winternitz-one-time-signature/badge.svg?branch=master\n   :target: https://coveralls.io/github/sea212/winternitz-one-time-signature?branch=master\n.. |Documentation Status| image:: https://readthedocs.org/projects/winternitz-one-time-signature/badge/?version=latest\n   :target: https://winternitz-one-time-signature.readthedocs.io/en/latest/?badge=latest\n   :alt: Documentation Status\n.. |License: MIT| image:: https://img.shields.io/badge/License-MIT-yellow.svg\n   :target: https://opensource.org/licenses/MIT\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/sea212/winternitz-one-time-signature", "keywords": "", "license": "mit", "maintainer": "", "maintainer_email": "", "name": "winternitz", "package_url": "https://pypi.org/project/winternitz/", "platform": "any", "project_url": "https://pypi.org/project/winternitz/", "project_urls": {"Homepage": "https://github.com/sea212/winternitz-one-time-signature"}, "release_url": "https://pypi.org/project/winternitz/1.0.2/", "requires_dist": ["recommonmark ; extra == 'all'", "sphinx (>=1.8) ; extra == 'all'", "sphinx-rtd-theme ; extra == 'all'", "isort ; extra == 'all'", "flake8 ; extra == 'all'", "pytest ; extra == 'all'", "pytest-cov ; extra == 'all'", "pytest-runner ; extra == 'all'", "tox ; extra == 'all'", "recommonmark ; extra == 'docs'", "sphinx ; extra == 'docs'", "sphinx-rtd-theme ; extra == 'docs'", "isort ; extra == 'lint'", "flake8 ; extra == 'lint'", "pytest ; extra == 'testing'", "pytest-cov ; extra == 'testing'", "pytest-runner ; extra == 'testing'", "tox ; extra == 'testing'"], "requires_python": "> 3.4", "summary": "Python Winternitz One-Time-Signature(+) implementation", "version": "1.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://www.travis-ci.com/sea212/winternitz-one-time-signature\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/434bf4ff2ec2320f51864da6bf358321fdc712ee/68747470733a2f2f7777772e7472617669732d63692e636f6d2f7365613231322f77696e7465726e69747a2d6f6e652d74696d652d7369676e61747572652e7376673f6272616e63683d6d6173746572\"></a> <a href=\"https://coveralls.io/github/sea212/winternitz-one-time-signature?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d7d9e6be2d215518a090adfd4f673f5783b9d301/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f7365613231322f77696e7465726e69747a2d6f6e652d74696d652d7369676e61747572652f62616467652e7376673f6272616e63683d6d6173746572\"></a> <a href=\"https://winternitz-one-time-signature.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ec0deec8b2b8d8802ee780a2c8023d59a0ca4dcb/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f77696e7465726e69747a2d6f6e652d74696d652d7369676e61747572652f62616467652f3f76657273696f6e3d6c6174657374\"></a> <a href=\"https://opensource.org/licenses/MIT\" rel=\"nofollow\"><img alt=\"License: MIT\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8645b002dd7ec1b54275a80574942e7a318e03c6/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d4d49542d79656c6c6f772e737667\"></a></p>\n<div id=\"winternitz-one-time-signature\">\n<h2>Winternitz One-Time-Signature</h2>\n<p>Python implementation of Winternitz one-time-signature schemes</p>\n<div id=\"description\">\n<h3>Description</h3>\n<p>Winternitz one-time-signature is an extension of lamport one-time-signature.\nThis python package can be used to execute WOTS operations, including\nkey generation, signature generation and signature verification.\nCurrently WOTS and WOTS+ are implemented.</p>\n</div>\n<div id=\"introduction\">\n<h3>Introduction</h3>\n<p>Lamport invented an algorithm in 1979 which allowed one to create one-time-signatures\nusing a cryptographically secure one-way function. It is the basis for the Winternitz\none-time-signature algorithm. Winternitz added the possibility to adjust the tradeoff\nbetween time- and space-complexity.</p>\n<div id=\"lamport-one-time-signature-scheme\">\n<h4>Lamport one-time-signature scheme</h4>\n<p>Lamport suggested to create two secret keys for each bit of a message which will\nbe signed. One for each value the bit can take. To derive the verification key,\neach secret key is hashed once. Now you have a secret key and a verification key,\nwhich consists of <cite>m</cite> 2-tuples of values, where <cite>m</cite> is the number\nof bits of the message. The verification key is published.\nThe signature consists of <cite>m</cite> values. For each bit of the message you release a secret key from\nthe corresponding secret keys, depending on which value the bit has. All those secret\nkeys form the signature for the message. The verifier hashes each of your secret keys\nonce and compares it to one verification key for this position, depending on the value\nof the bit. The signature is valid, if and only if all derived verification keys match with\nyour published verification key at the correct position of the 2-tuple, which is determined by the value\nof the bit. This algorithm is quite fast\n(comparing it to existing PQC-algorithms), but the signature sizes are huge.</p>\n</div>\n<div id=\"winternitz-extension\">\n<h4>Winternitz extension</h4>\n<p>Winternitz extended lamports algorithm by offering the possiblity to decide\nhow many bits will be signed together. The amount of numbers those bits can\nrepresent is called the Winternitz parameter (<cite>w = 2^{bits}</cite>). This method offers the huge\nadvantage that the user of this algorithm can choose the time and space tradeoff\n(whether speed or storage capacity is more relevant). A fingerprint of the message which\nwill be signed is split into groups of <cite>ceil(log_2(w))</cite> bits. Each of these groups gets one secret key.\nEach verification key is derived by hashing the secret key for each group <cite>2^{w-1}</cite> times. All verification\nkeys will be published and represent one unified verification key. When signing a message, the\nfingerprint of the message is split into groups of <cite>ceil(log2(w))</cite> bits. To create the signature, the\nprivate key for each bit group is hashed <cite>bitgroup_value</cite> times, where <cite>bitgroup_value</cite> is the value\nof the bitgroup. Additionally a (inverse sum) checksum is appended, which denies man-in-the-middle\nattacks. The checksum is calculated from the signature, split into bit groups of <cite>ceil(log2(w))</cite> bits, and\nsigned. To verify the signature, the fingerprint of the message is first split into bit groups of <cite>ceil(log2(w)</cite>\nbits each. The basic idea is to take the signature of each bit group, calculate the verification key\nfrom it and finally compare it to the published verification key. Since the signature was hashed\n<cite>bitgroup_value</cite> times, all you have to do to calculate the verification key from the signature\nis to hash the signature <cite>2^{w-1} - bitgroup_value - 1</cite> times. Besides verifing the message, the verifier\nmust also calculate the checksum and verify it.</p>\n</div>\n</div>\n<div id=\"setup\">\n<h3>Setup</h3>\n<p>Requires: Python &gt;= 3.4</p>\n<div>\n<div>Install package: <tt>pip install winternitz</tt></div>\n<div>Install test tools: <tt>pip install winternitz[TEST]</tt></div>\n<div>Install linter (for tox tests): <tt>pip install winternitz[LINT]</tt></div>\n<div>Install documentation tools: <tt>pip install winternitz[DOCS]</tt></div>\n<div>Install everything: <tt>pip install winternitz[ALL]</tt></div>\n</div>\n<div id=\"test\">\n<h4>Test</h4>\n<div>\n<div>Without tox (no linter checks): <tt>python setup.py test</tt></div>\n<div>With tox: <tt>python <span class=\"pre\">-m</span> tox</tt></div>\n</div>\n</div>\n<div id=\"generate-documentation\">\n<h4>Generate documentation</h4>\n<p><tt>python setup.py docs</tt></p>\n</div>\n</div>\n<div id=\"usage\">\n<h3>Usage</h3>\n<p>The package <em>winternitz</em> contains a module called <em>signatures</em>.\nWithin this package you can find the classes WOTS and WOTSPLUS.\nThose classes can be used out of the box to sign or verify\nmessages</p>\n<div id=\"wots\">\n<h4>WOTS</h4>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">winternitz.signatures</span>\n<span class=\"c1\"># Create signature and verify it with the same object</span>\n<span class=\"n\">wots</span> <span class=\"o\">=</span> <span class=\"n\">winternitz</span><span class=\"o\">.</span><span class=\"n\">signatures</span><span class=\"o\">.</span><span class=\"n\">WOTS</span><span class=\"p\">()</span>\n<span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"s2\">\"My message in bytes format\"</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"s2\">\"utf-8\"</span><span class=\"p\">)</span>\n<span class=\"n\">sig</span> <span class=\"o\">=</span> <span class=\"n\">wots</span><span class=\"o\">.</span><span class=\"n\">sign</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">)</span>\n<span class=\"n\">success</span> <span class=\"o\">=</span> <span class=\"n\">wots</span><span class=\"o\">.</span><span class=\"n\">verify</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"n\">message</span><span class=\"p\">,</span> <span class=\"n\">signature</span><span class=\"o\">=</span><span class=\"n\">sig</span><span class=\"p\">[</span><span class=\"s2\">\"signature\"</span><span class=\"p\">])</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Verification success: \"</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">success</span><span class=\"p\">))</span>\n<span class=\"c1\"># Output: Verification success: True</span>\n</pre>\n<p>If you don\u2019t specify any values in the constructor of WOTS, it will use\nthe winternitz parameter 16 and the hash function <em>sha512</em> as default parameters.\nThe private key will be generated from entropy. After you received the public key,\neither through <tt>wots.pubkey</tt> or inside the dict that is returned by the\n<tt>wots.sign(message)</tt> function call, you publish it. Verify that it was not modified.\nIn the best case a man-in-the-middle attack to modify your public key is impossible\nby the design of the application. The last step is to publish your message and every\ninformation in the dict that is returned by <tt>wots.sign(message)</tt>, except the public\nkey (since it was already published). Publishing the fingerprint is optional, since it\nis not essential for the signature verification. The signature dict contains the following\nvalues:</p>\n<pre><span class=\"p\">{</span>\n    <span class=\"s2\">\"w\"</span><span class=\"p\">:</span>            <span class=\"n\">winternitz</span> <span class=\"n\">parameter</span> <span class=\"p\">(</span><span class=\"n\">Type</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">),</span>\n    <span class=\"s2\">\"fingerprint\"</span><span class=\"p\">:</span>  <span class=\"n\">message</span> <span class=\"nb\">hash</span> <span class=\"p\">(</span><span class=\"n\">Type</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span><span class=\"p\">),</span>\n    <span class=\"s2\">\"hashalgo\"</span><span class=\"p\">:</span>     <span class=\"nb\">hash</span> <span class=\"n\">algorithm</span> <span class=\"p\">(</span><span class=\"n\">Type</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">),</span>\n    <span class=\"s2\">\"digestsize\"</span><span class=\"p\">:</span>   <span class=\"nb\">hash</span> <span class=\"n\">byte</span> <span class=\"n\">count</span> <span class=\"p\">(</span><span class=\"n\">Type</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">),</span>\n    <span class=\"s2\">\"pubkey\"</span><span class=\"p\">:</span>       <span class=\"n\">public</span> <span class=\"n\">key</span> <span class=\"p\">(</span><span class=\"n\">Type</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">bytes</span><span class=\"p\">]),</span>\n    <span class=\"s2\">\"signature\"</span><span class=\"p\">:</span>    <span class=\"n\">signature</span> <span class=\"p\">(</span><span class=\"n\">Type</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">bytes</span><span class=\"p\">])</span>\n<span class=\"p\">}</span>\n</pre>\n<p>With that data, another person can verify the authenticity of your message:</p>\n<pre><span class=\"c1\"># Another person or machine wants to verify your signature:</span>\n<span class=\"c1\"># get required hash function by comparing the name</span>\n<span class=\"c1\"># published with local implementaitons</span>\n<span class=\"k\">if</span> <span class=\"n\">sig</span><span class=\"p\">[</span><span class=\"s2\">\"hashalgo\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s2\">\"openssl_sha512\"</span><span class=\"p\">:</span>\n    <span class=\"n\">hashfunc</span> <span class=\"o\">=</span> <span class=\"n\">winternitz</span><span class=\"o\">.</span><span class=\"n\">signatures</span><span class=\"o\">.</span><span class=\"n\">openssl_sha512</span>\n<span class=\"k\">elif</span> <span class=\"n\">sig</span><span class=\"p\">[</span><span class=\"s2\">\"hashalgo\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s2\">\"openssl_sha256\"</span><span class=\"p\">:</span>\n    <span class=\"n\">hashfunc</span> <span class=\"o\">=</span> <span class=\"n\">winternitz</span><span class=\"o\">.</span><span class=\"n\">signautres</span><span class=\"o\">.</span><span class=\"n\">openssl_sha256</span>\n<span class=\"k\">else</span><span class=\"p\">:</span>\n    <span class=\"k\">raise</span> <span class=\"ne\">NotImplementedError</span><span class=\"p\">(</span><span class=\"s2\">\"Hash function not implemented\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">wots_other</span> <span class=\"o\">=</span> <span class=\"n\">winternitz</span><span class=\"o\">.</span><span class=\"n\">signatures</span><span class=\"o\">.</span><span class=\"n\">WOTS</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"o\">=</span><span class=\"n\">sig</span><span class=\"p\">[</span><span class=\"s2\">\"w\"</span><span class=\"p\">],</span> <span class=\"n\">hashfunction</span><span class=\"o\">=</span><span class=\"n\">hashfunc</span><span class=\"p\">,</span>\n                                        <span class=\"n\">digestsize</span><span class=\"o\">=</span><span class=\"n\">sig</span><span class=\"p\">[</span><span class=\"s2\">\"digestsize\"</span><span class=\"p\">],</span> <span class=\"n\">pubkey</span><span class=\"o\">=</span><span class=\"n\">sig</span><span class=\"p\">[</span><span class=\"s2\">\"pubkey\"</span><span class=\"p\">])</span>\n<span class=\"n\">success</span> <span class=\"o\">=</span> <span class=\"n\">wots_other</span><span class=\"o\">.</span><span class=\"n\">verify</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"n\">message</span><span class=\"p\">,</span> <span class=\"n\">signature</span><span class=\"o\">=</span><span class=\"n\">sig</span><span class=\"p\">[</span><span class=\"s2\">\"signature\"</span><span class=\"p\">])</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Verification success: \"</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">success</span><span class=\"p\">))</span>\n<span class=\"c1\"># Output: Verification success: True</span>\n</pre>\n<p>In certain situations it might not be wanted to verify the derived public key with the\npublic key inside the executing WOTS object. For example, this can be this case when\nthe verification happens in a wrapping structure, like a XMSS tree. In such cases\nthe public key can be derived from a message and a signature with the function\n<tt>wots.getPubkeyFromSignature(message=message, signature=signature)</tt></p>\n</div>\n<div id=\"wotsplus\">\n<h4>WOTSPLUS</h4>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">winternitz.signatures</span>\n<span class=\"n\">wotsplus</span> <span class=\"o\">=</span> <span class=\"n\">winternitz</span><span class=\"o\">.</span><span class=\"n\">signatures</span><span class=\"o\">.</span><span class=\"n\">WOTSPLUS</span><span class=\"p\">()</span>\n<span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"s2\">\"My message in bytes format\"</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(</span><span class=\"s2\">\"utf-8\"</span><span class=\"p\">)</span>\n<span class=\"n\">sig</span> <span class=\"o\">=</span> <span class=\"n\">wotsplus</span><span class=\"o\">.</span><span class=\"n\">sign</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">)</span>\n<span class=\"n\">success</span> <span class=\"o\">=</span> <span class=\"n\">wotsplus</span><span class=\"o\">.</span><span class=\"n\">verify</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">=</span><span class=\"n\">message</span><span class=\"p\">,</span> <span class=\"n\">signature</span><span class=\"o\">=</span><span class=\"n\">sig</span><span class=\"p\">[</span><span class=\"s2\">\"signature\"</span><span class=\"p\">])</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Verification success: \"</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">success</span><span class=\"p\">))</span>\n<span class=\"c1\"># Output: Verification success: True</span>\n</pre>\n<p>If you don\u2019t specify any values in the constructor of WOTSPLUS, it will use the winternitz parameter\n16 and the hash function defaults to <em>sha256</em>. It further requires a pseudo random function, which defaults\nto <em>HMAC-sha256</em>, as well as a seed which is also generated from entropy. For further\ninformations about functions and their parameters, visit the module reference in\nthis the <a href=\"https://winternitz-one-time-signature.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\">documentation</a>.\nSince WOTS+ uses a pseudo random function and a seed to derive signatures and public\nkeys, they have to be published as well. In addition to the signature of WOTS, the returned dict contains\nthe following values:</p>\n<pre><span class=\"p\">{</span>\n    <span class=\"c1\"># ...</span>\n    <span class=\"s2\">\"prf\"</span><span class=\"p\">:</span>          <span class=\"n\">pseudo</span> <span class=\"n\">random</span> <span class=\"n\">function</span> <span class=\"p\">(</span><span class=\"n\">Type</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">),</span>\n    <span class=\"s2\">\"seed\"</span><span class=\"p\">:</span>         <span class=\"n\">Seed</span> <span class=\"n\">used</span> <span class=\"ow\">in</span> <span class=\"n\">prf</span> <span class=\"p\">(</span><span class=\"n\">Type</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</pre>\n<p>Those arguments have to be specified in the constructor of WOTSPLUS in addition to those parameters\nspecified in WOTS.</p>\n</div>\n<div id=\"misc\">\n<h4>Misc</h4>\n<p>The WOTS classes come with some features that will be explained in the following sections.</p>\n<div id=\"fully-configurable\">\n<h5>Fully configurable</h5>\n<p>The WOTS classes are fully parameterizable. You can specify anything that is specified\nin the papers describing the algorithm, including the Winternitz parameter, the hash function,\nthe pseudo random function (WOTSPLUS), the seed (WOTSPLUS), the private key and the public key.\nspecifing both a private key and public key results in the public key beeing discarded.</p>\n</div>\n<div id=\"on-demand-generation-of-keys\">\n<h5>On-demand generation of keys</h5>\n<p>If no private key or no public key is specified, they will be set to None. The same\ngoes for the seed in wots+. Only when they are required, they will be generated or\nderived. This means that as long as you don\u2019t execute <tt>repr(obj)</tt>, <tt>str(obj)</tt>, <tt>obj1 == obj2</tt>,\n<tt>obj1 != obj2</tt>, <tt>obj.pubkey</tt>, <tt>obj.privkey</tt>, <tt><span class=\"pre\">obj.sign(...)</span></tt> or <tt><span class=\"pre\">obj.verify(...)</span></tt>, where obj is a\nWOTS object, the keys will stay None.</p>\n</div>\n<div id=\"code-representation-of-wots-objects\">\n<h5>Code representation of WOTS objects</h5>\n<p>You can call <tt>repr(obj)</tt>, where obj is a WOTS object, to get a line of code which contains\nall information to initialize another object so that it is equal to obj. Executing <tt>obj2 = eval(repr(obj))</tt>\nexecutes that code which is returned by <tt>repr(obj)</tt> and ultimately stores a copy of it in <tt>obj2</tt>.</p>\n</div>\n<div id=\"human-readable-string-representation\">\n<h5>Human readable string representation</h5>\n<p>You can call <tt>str(obj)</tt> to get a string which contains a human readable representation of that object.</p>\n</div>\n<div id=\"comparison-of-objects\">\n<h5>Comparison of objects</h5>\n<p>You can compare two objects from this class <tt>obj1 == obj2</tt> and <tt>obj1 != obj2</tt></p>\n</div>\n<div id=\"optimizations\">\n<h5>Optimizations</h5>\n<p>The code was carefully written to reduce execution times. It surely is not perfect and can still be optimized,\nfurther time-critical sections could be coded as C extensions, but nevertheless in the current state it should\noffer quite an efficient implementation. It defines <tt>__slots__</tt> to reduce execution times and storage requirements\nwithin the class. Implementation of parallelization is planned, but it is only usefull when using huge winternitz\nparameters, since python can only execute code in parallel if you spawn a new process and the overhead of forking\na new python interpreter is not negliable.</p>\n</div>\n</div>\n</div>\n<div id=\"note\">\n<h3>Note</h3>\n<p>This project has been set up using PyScaffold 3.1. For details and usage\ninformation on PyScaffold see <a href=\"https://pyscaffold.org/\" rel=\"nofollow\">https://pyscaffold.org/</a>.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4941134, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "aac1a005e0b1f4e5b3655558f2d99f46", "sha256": "8d9fd29eff3cc85e68c0dc980eccfa744291cf148b5cd24afccc0bf69fb5dcb2"}, "downloads": -1, "filename": "winternitz-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "aac1a005e0b1f4e5b3655558f2d99f46", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": "> 3.4", "size": 11311, "upload_time": "2019-03-10T02:11:02", "upload_time_iso_8601": "2019-03-10T02:11:02.943243Z", "url": "https://files.pythonhosted.org/packages/62/d1/13ea46765a5e49089048931f852701588adbb1749127dc66f4465780bd7c/winternitz-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8870ef9bb9acaa1749384d2d72c0332a", "sha256": "09b9869b5bd070992830c928621ac4a4a3711a57e35a8d3d4d6f628405c6062c"}, "downloads": -1, "filename": "winternitz-1.0.0.tar.gz", "has_sig": false, "md5_digest": "8870ef9bb9acaa1749384d2d72c0332a", "packagetype": "sdist", "python_version": "source", "requires_python": "> 3.4", "size": 29598, "upload_time": "2019-03-10T02:11:05", "upload_time_iso_8601": "2019-03-10T02:11:05.449987Z", "url": "https://files.pythonhosted.org/packages/59/ed/58a59bf15ca7c8a33da206247044931f646fa1ce533e2fb92c70f4baf8ad/winternitz-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "6d213fa8aa0aa1547fcefdeaf65fe670", "sha256": "317804fc6a0d0a255f99ea344f72e82f5895b3a5043b9bd1d5351fcab479ca03"}, "downloads": -1, "filename": "winternitz-1.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "6d213fa8aa0aa1547fcefdeaf65fe670", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": "> 3.4", "size": 11898, "upload_time": "2019-03-10T15:18:42", "upload_time_iso_8601": "2019-03-10T15:18:42.248642Z", "url": "https://files.pythonhosted.org/packages/51/af/398e561fda36284a2ca2109e817d3b342e63087f886b30fb9197cca2f310/winternitz-1.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ba5967eb053a15858572bffccfd578e7", "sha256": "16fcb2bb63515c117b3e1559999e6022d35cf319215f5b69984af1c42c00a4eb"}, "downloads": -1, "filename": "winternitz-1.0.1.tar.gz", "has_sig": false, "md5_digest": "ba5967eb053a15858572bffccfd578e7", "packagetype": "sdist", "python_version": "source", "requires_python": "> 3.4", "size": 31383, "upload_time": "2019-03-10T15:18:43", "upload_time_iso_8601": "2019-03-10T15:18:43.718196Z", "url": "https://files.pythonhosted.org/packages/0d/de/34d2b3b590cc45922a99097cdf248b0a95c37f70f7f015971bb50d1ad1a3/winternitz-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "051362623d498332b80a35c6d60d571f", "sha256": "2e54d88a96619a828170019ecd1fd226af4162a531f8852282b1b7e32db15893"}, "downloads": -1, "filename": "winternitz-1.0.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "051362623d498332b80a35c6d60d571f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": "> 3.4", "size": 12467, "upload_time": "2019-03-14T18:35:37", "upload_time_iso_8601": "2019-03-14T18:35:37.218505Z", "url": "https://files.pythonhosted.org/packages/2f/3d/636adf5d3822d05d60c3a8a8e56dd1a99421270b4ddf2154444b25f785a8/winternitz-1.0.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dc32d34c89b1379fa3c92891f475a76d", "sha256": "7eba342ac0c44e37fa2684fec1b3f7883a9d5d12675ba1fd6dabdd520c7da563"}, "downloads": -1, "filename": "winternitz-1.0.2.tar.gz", "has_sig": false, "md5_digest": "dc32d34c89b1379fa3c92891f475a76d", "packagetype": "sdist", "python_version": "source", "requires_python": "> 3.4", "size": 32611, "upload_time": "2019-03-14T18:35:39", "upload_time_iso_8601": "2019-03-14T18:35:39.166779Z", "url": "https://files.pythonhosted.org/packages/bd/c5/a02b7ae3571974a654ffa4b4aaf683bc44e3a0468d7b5f8436c8fa5a0625/winternitz-1.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "051362623d498332b80a35c6d60d571f", "sha256": "2e54d88a96619a828170019ecd1fd226af4162a531f8852282b1b7e32db15893"}, "downloads": -1, "filename": "winternitz-1.0.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "051362623d498332b80a35c6d60d571f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": "> 3.4", "size": 12467, "upload_time": "2019-03-14T18:35:37", "upload_time_iso_8601": "2019-03-14T18:35:37.218505Z", "url": "https://files.pythonhosted.org/packages/2f/3d/636adf5d3822d05d60c3a8a8e56dd1a99421270b4ddf2154444b25f785a8/winternitz-1.0.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dc32d34c89b1379fa3c92891f475a76d", "sha256": "7eba342ac0c44e37fa2684fec1b3f7883a9d5d12675ba1fd6dabdd520c7da563"}, "downloads": -1, "filename": "winternitz-1.0.2.tar.gz", "has_sig": false, "md5_digest": "dc32d34c89b1379fa3c92891f475a76d", "packagetype": "sdist", "python_version": "source", "requires_python": "> 3.4", "size": 32611, "upload_time": "2019-03-14T18:35:39", "upload_time_iso_8601": "2019-03-14T18:35:39.166779Z", "url": "https://files.pythonhosted.org/packages/bd/c5/a02b7ae3571974a654ffa4b4aaf683bc44e3a0468d7b5f8436c8fa5a0625/winternitz-1.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:28:50 2020"}