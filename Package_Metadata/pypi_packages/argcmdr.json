{"info": {"author": "Center for Data Science and Public Policy", "author_email": "datascifellows@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Natural Language :: English", "Programming Language :: Python :: 3.6"], "description": "=======\nargcmdr\n=======\n\nThe thin ``argparse`` wrapper for quick, clear and easy declaration of (hierarchical) console command interfaces via Python.\n\n``argcmdr``:\n\n* handles the boilerplate of CLI\n\n  * while maintaining the clarity and extensibility of your code\n  * without requiring you to learn Yet Another argument-definition syntax\n  * without reinventing the wheel or sacrificing the flexibility of ``argparse``\n\n* enables invocation via\n\n  * executable script (``__name__ == '__main__'``)\n  * ``setuptools`` entrypoint\n  * command-defining module (like the ``Makefile`` of ``make``)\n\n* determines command hierarchy flexibly and cleanly\n\n  * command declarations are nested to indicate CLI hierarchy *or*\n  * commands are decorated to indicate their hierarchy\n\n* includes support for elegant interaction with the operating system, via ``plumbum``\n\nSetup\n=====\n\n``argcmdr`` is developed for Python version 3.6.3 and above, and may be built via ``setuptools``.\n\nPython\n------\n\nIf Python 3.6.3 or greater is not installed on your system, it is available from python.org_.\n\nHowever, depending on your system, you might prefer to install Python via a package manager, such as Homebrew_ on Mac OS X or APT on Debian-based Linux systems.\n\nAlternatively, pyenv_ is highly recommended to manage arbitrary installations of Python, and may be most easily installed via the `pyenv installer`_.\n\nargcmdr\n-------\n\nTo install from PyPI::\n\n    pip install argcmdr\n\nTo install from Github::\n\n    pip install git+https://github.com/dssg/argcmdr.git\n\nTo install from source::\n\n    python setup.py install\n\nTutorial\n========\n\n.. contents::\n    :local:\n\nThe Command\n-----------\n\n``argcmdr`` is built around the base class ``Command``. Your console command extends ``Command``, and optionally defines:\n\n* ``__init__(parser)``, which adds to the parser the arguments that your command requires, as supported by ``argparse`` (see argparse_)\n* ``__call__([args, parser, ...])``, which is invoked when your console command is invoked, and which is expected to implement your command's functionality\n\nFor example, let's define the executable file ``listdir``, a trivial script which prints the current directory's contents::\n\n    #!/usr/bin/env python\n\n    import os\n\n    from argcmdr import Command, main\n\n    class Main(Command):\n        \"\"\"print the current directory's contents\"\"\"\n\n        def __call__(self):\n            print(*os.listdir())\n\n    if __name__ == '__main__':\n        main(Main)\n\nShould we execute this script, it will perform much the same as ``ls -A``.\n\nLet's say, however, that we would like to optionally print each item of the directory's contents on a separate line::\n\n    class Main(Command):\n        \"\"\"print the current directory's contents\"\"\"\n\n        def __init__(self, parser):\n            parser.add_argument(\n                '-1',\n                action='store_const',\n                const='\\n',\n                default=' ',\n                dest='sep',\n                help='list one file per line',\n            )\n\n        def __call__(self, args):\n            print(*os.listdir(), sep=args.sep)\n\nWe now optionally support execution similar to ``ls -A1``, via ``listdir -1``.\n\nFittingly, this is reflected in the script's autogenerated usage text \u2013 ``listdir -h`` prints::\n\n    usage: listdir [-h] [--tb] [-1]\n\n    print the current directory's contents\n\n    optional arguments:\n      -h, --help         show this help message and exit\n      --tb, --traceback  print error tracebacks\n      -1                 list one file per line\n\nThe command decorator\n---------------------\n\nFor particularly trivial commands, the class declaration syntax may be considered verbose and unnecessary. The ``@cmd`` decorator manufactures the appropriate ``Command`` from a decorated function or method.\n\nThe first command may be rewritten to produce an identical result::\n\n    from argcmdr import cmd\n\n    @cmd\n    def main():\n        \"\"\"print the current directory's contents\"\"\"\n        print(*os.listdir())\n\nand, for the second, ``cmd`` optionally accepts an ``argparse`` argument definition::\n\n    @cmd('-1', action='store_const', const='\\n', default=' ', dest='sep', help='list one file per line')\n    def main(args):\n        \"\"\"print the current directory's contents\"\"\"\n        print(*os.listdir(), sep=args.sep)\n\nFurther arguments may be added via additional decoration::\n\n    @cmd('-a', ...)\n    @cmd('-1', ...)\n    def main(args):\n        ...\n\nLocal execution\n---------------\n\nAs much as we gain from Python and its standard library, it's quite typical to need to spawn non-Python subprocesses, and for that matter for your script's purpose to be entirely to orchestrate workflows built from operating system commands. Python's \u2013 and argcmdr's \u2013 benefit is to make this work easier, debuggable, testable and scalable.\n\nIn fact, our above, trivial example could be accomplished easily with direct execution of ``ls``::\n\n    import argparse\n\n    from argcmdr import Local, main\n\n    class Main(Local):\n        \"\"\"list directory contents\"\"\"\n\n        def __init__(self, parser):\n            parser.add_argument(\n                'remainder',\n                metavar='arguments for ls',\n                nargs=argparse.REMAINDER,\n            )\n\n        def __call__(self, args):\n            print(self.local['ls'](args.remainder))\n\n``local``, bound to the ``Local`` base class, is a dictionary which caches path look-ups for system executables.\n\nThis could, however, still be cleaner. For this reason, the ``Local`` command features a parallel invocation interface, ``prepare([args, parser, ...])``::\n\n    class Main(Local):\n        \"\"\"list directory contents\"\"\"\n\n        def __init__(self, parser):\n            parser.add_argument(\n                'remainder',\n                metavar='arguments for ls',\n                nargs=argparse.REMAINDER,\n            )\n\n        def prepare(self, args):\n            return self.local['ls'][args.remainder]\n\nVia the ``prepare`` interface, standard output is printed by default, and your command logic may be tested in a \"dry run,\" as reflected in the usage output of the above::\n\n    usage: listdir [-h] [--tb] [-q] [-d] [-s] [--no-show] ...\n\n    list directory contents\n\n    positional arguments:\n      arguments for ls\n\n    optional arguments:\n      -h, --help         show this help message and exit\n      --tb, --traceback  print error tracebacks\n      -q, --quiet        do not print command output\n      -d, --dry-run      do not execute commands, but print what they are (unless\n                         --no-show is provided)\n      -s, --show         print command expressions (by default not printed unless\n                         dry-run)\n      --no-show          do not print command expressions (by default not printed\n                         unless dry-run)\n\nTo execute multiple local subprocesses, ``prepare`` may either return an iterable (*e.g.* ``list``) of the above ``plumbum`` bound commands, or ``prepare`` may be defined as a generator function, (*i.e.* make repeated use of ``yield`` \u2013 see below).\n\nManaging execution\n~~~~~~~~~~~~~~~~~~\n\nHandling exit codes\n+++++++++++++++++++\n\nSubprocess commands emitted by ``Local.prepare`` are executed in order and, by default, failed execution is interrupted by a raised exception::\n\n    class Release(Local):\n        \"\"\"release the package to pypi\"\"\"\n\n        def __init__(self, parser):\n            parser.add_argument(\n                'part',\n                choices=('major', 'minor', 'patch'),\n                help=\"part of the version to be bumped\",\n            )\n\n        def prepare(self, args):\n            yield self.local['bumpversion'][args.part]\n            yield self.local['python']['setup.py', 'sdist', 'bdist_wheel']\n            yield self.local['twine']['upload', 'dist/*']\n\nShould the ``bumpversion`` command fail, the ``deploy`` command will not proceed.\n\nIn some cases, however, we might like to disable this functionality, and proceed regardless of a subprocess's exit code. We may pass arguments such as ``retcode`` to ``plumbum`` by setting this attribute on the ``prepare`` method::\n\n    def prepare(self, args):\n        yield self.local['bumpversion'][args.part]\n        yield self.local['python']['setup.py', 'sdist', 'bdist_wheel']\n        yield self.local['twine']['upload', 'dist/*']\n\n    prepare.retcode = None\n\nSubprocess commands emitted by the above method will not raise execution exceptions, regardless of their exit code. (To allow only certain exit code(s), set ``retcode`` as appropriate \u2013 see plumbum_.)\n\nInspecting results\n++++++++++++++++++\n\nHaving disabled execution exceptions \u2013 and regardless \u2013 we might need to inspect a subprocess command's exit code, standard output or standard error. As such, (whether we manipulate ``retcode`` or not), ``argcmdr`` communicates these command results with ``prepare`` generator methods::\n\n    def prepare(self, args):\n        (code, out, err) = yield self.local['bumpversion']['--list', args.part]\n\n        yield self.local['python']['setup.py', 'sdist', 'bdist_wheel']\n\n        if out is None:\n            version = 'DRY-RUN'\n        else:\n            (version_match,) = re.finditer(\n                r'^new_version=([\\d.]+)$',\n                out,\n                re.M,\n            )\n            version = version_match.group(1)\n\n        yield self.local['twine']['upload', f'dist/*{version}*']\n\nIn the above, ``prepare`` stores the results of ``bumpversion`` execution, in order to determine from its standard output the version to be released.\n\nHandling exceptions\n+++++++++++++++++++\n\nMoreover, we might like to define special handling for execution errors; and, perhaps rather than manipulate ``retcode`` for all commands emitted by our method, we might like to handle them separately. As such, execution exceptions are also communicated back to ``prepare`` generators::\n\n    def prepare(self, args):\n        try:\n            (_code, out, _err) = yield self.local['bumpversion']['--list', args.part]\n        except self.local.ProcessExecutionError:\n            print(\"execution failed but here's a joke ...\")\n            ...\n\nModifying execution\n+++++++++++++++++++\n\nCommands are run in the foreground by default, their outputs printed, as well as recorded for inspection, via the ``plumbum`` modifier, ``TEE``.\n\nTo execute a command in the background (and continue), we may specify the ``BG`` modifier::\n\n    def prepare(self, args):\n        future = yield (self.local.BG, self.local['bumpversion']['--list', args.part])\n\nAlternatively, we may wish to execute a command in the foreground *only*, (and not record its output) \u2013 *e.g.* to best support processes which require TTY::\n\n    def prepare(self):\n        return (self.local.FG, self.local['ipython']['-i', 'startup.py'])\n\nThe local decorator\n~~~~~~~~~~~~~~~~~~~\n\n``Local`` is an alternate command base class, and a subclass of ``Command``. Any base class may be substituted for ``Command`` when using the command decorator::\n\n    @cmd(base=CustomCommand)\n    def main():\n        ...\n\nMoreover, ``Local`` functionality may be requested via keyword flag ``local``::\n\n    @cmd(local=True)\n    def main(self):\n        ...\n\nAnd in support of the above, common case, the ``@local`` decorator is provided::\n\n    from argcmdr import local\n\n    @local\n    def main(self):\n        ...\n\nNote that in the last two examples, our command function's call signature included ``self``.\n\nDecorated command functions are in fact replaced with manufactured subclasses of ``Command``, and the function is invoked as this command's functionality \u2013 either ``__call__`` or ``prepare``. It is assumed that, by default, this function should be treated as a ``staticmethod``, and given no reference to the manufactured ``Command`` instance. However, in the case of ``local`` decoration, this is not the case; the binding is left up to the decorated object, which, according to Python descriptor rules, means that a decorated function is treated as a \"method\" and receives the instance. This way, ``local`` command functions may access the instance's ``local`` dictionary of operating system executables.\n\nBinding may be explicitly controlled via the decorator keyword ``binding``, *e.g.*::\n\n    @cmd(binding=True, base=CustomCommand)\n    def main(self):\n        ...\n\nSee `Method commands`_ for further examples of decorator-defined commands and alternative bindings.\n\nCommand invocation signature\n----------------------------\n\nNote that in our last trivial examples of listing directory contents, we made our script dependent upon the ``ls`` command in the operating environment. ``argcmdr`` will not, by default, print tracebacks, and it will colorize unhandled exceptions; however, we might prefer to print a far friendlier error message.\n\nOne easy way of printing friendly error messages is to make use of ``argparse.ArgumentParser.error()``. As we've seen, ``Command`` invocation, via either ``__call__`` or ``prepare``, may accept zero arguments, or it may require the parsed arguments ``argparse.Namespace``. Moreover, it may require a second argument, and receive the argument parser::\n\n    class Main(Local):\n        \"\"\"list directory contents\"\"\"\n\n        def __init__(self, parser):\n            parser.add_argument(\n                'remainder',\n                metavar='arguments for ls',\n                nargs=argparse.REMAINDER,\n            )\n\n        def prepare(self, args, parser):\n            try:\n                local_exec = self.local['ls']\n            except self.local.CommandNotFound:\n                parser.error('command not available')\n\n            yield local_exec[args.remainder]\n\nIf ``ls`` is not available, the user is presented the following message upon executing the above::\n\n    usage: listdir [-h] [--tb] [-q] [-d] [-s] [--no-show] ...\n    listdir: error: command not available\n\nAccess to the parsed argument namespace\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe command invocation's parsed arguments are most straight-forwardly accessible as the first argument of the ``Command`` invocation signature, either ``__call__`` or ``prepare``. However, in less-than-trivial implementations, wherein command methods are factored for reusability, passing the argument namespace from method to method may become tedious. To support such scenarios, this object is made additionally available via the ``Command`` *property*, ``args``.\n\nConsider a class of commands which require a database password. We don't want to store this password anywhere in plain text; rather, we expect it to be input, either via (piped) standard input or the TTY::\n\n    class DbSync(Command):\n        \"\"\"sync databases\"\"\"\n\n        def __init__(self, parser):\n            parser.add_argument(\n                '-p', '--password',\n                action='store_true',\n                dest='stdin_password',\n                default=False,\n                help=\"read database password from standard input\",\n            )\n\n        def __call__(self, args):\n            engine = self.dbengine(args)\n            ...\n\n        def dbcreds(self, args):\n            dbcreds = {\n                'username': os.getenv('PGUSER'),\n                'host': os.getenv('PGHOST'),\n                'port': os.getenv('PGPORT'),\n                'database': os.getenv('PGDATABASE'),\n            }\n\n            missing = [key for (key, value) in dbcreds.items() if not value]\n            if missing:\n                raise RuntimeError(\n                    \"database connection information missing from \"\n                    \"environmental configuration: \" + ', '.join(missing)\n                )\n\n            if args.stdin_password:\n                dbcreds['password'] = sys.stdin.read().rstrip('\\n\\r')\n\n                # we're done with the (pipe) stdin, so force it back to TTY for\n                # any subsequent input()\n                sys.stdin = open('/dev/tty')\n            else:\n                dbcreds['password'] = os.getenv('PGPASSWORD')\n                if not dbcreds['password']:\n                    dbcreds['password'] = getpass.getpass(\n                        'enter password for '\n                        + ('{username}@{host}:{port}'.format_map(dbcreds) | colors.bold)\n                        + ': '\n                        | colors.yellow\n                    )\n\n            return dbcreds\n\n        def dburi(self, args):\n            return sqlalchemy.engine.url.URL('postgres', **self.dbcreds(args))\n\n        def dbengine(self, args):\n            return sqlalchemy.create_engine(self.dburi(args))\n\nNot only were we forced to verbosely daisy-chain the arguments namespace, ``args``, from method to method; moreover, we were prevented from (trivially) caching the result of ``dbcreds``, to ensure that the password isn't ever requested more than once.\n\nNow, let's reimplement the above, making use of the property ``args``::\n\n    class DbSync(Command):\n        \"\"\"sync databases\"\"\"\n\n        def __init__(self, parser):\n            parser.add_argument(\n                '-p', '--password',\n                action='store_true',\n                dest='stdin_password',\n                default=False,\n                help=\"read database password from standard input\",\n            )\n\n        def __call__(self):\n            engine = self.dbengine\n            ...\n\n        @cachedproperty\n        def dbcreds(self):\n            dbcreds = {\n                'username': os.getenv('PGUSER'),\n                'host': os.getenv('PGHOST'),\n                'port': os.getenv('PGPORT'),\n                'database': os.getenv('PGDATABASE'),\n            }\n\n            missing = [key for (key, value) in dbcreds.items() if not value]\n            if missing:\n                raise RuntimeError(\n                    \"database connection information missing from \"\n                    \"environmental configuration: \" + ', '.join(missing)\n                )\n\n            if self.args.stdin_password:\n                dbcreds['password'] = sys.stdin.read().rstrip('\\n\\r')\n\n                # we're done with the (pipe) stdin, so force it back to TTY for\n                # any subsequent input()\n                sys.stdin = open('/dev/tty')\n            else:\n                dbcreds['password'] = os.getenv('PGPASSWORD')\n                if not dbcreds['password']:\n                    dbcreds['password'] = getpass.getpass(\n                        'enter password for '\n                        + ('{username}@{host}:{port}'.format_map(dbcreds) | colors.bold)\n                        + ': '\n                        | colors.yellow\n                    )\n\n            return dbcreds\n\n        @property\n        def dburi(self):\n            return sqlalchemy.engine.url.URL('postgres', **self.dbcreds)\n\n        @property\n        def dbengine(self):\n            return sqlalchemy.create_engine(self.dburi)\n\nIn this form, ``args`` needn't be passed from method to method; in fact, methods of the ``DbSync`` command needn't worry about arguments which don't directly interest them at all. And, using ``cachedproperty`` from Dickens_, the database credentials are trivially cached, ensuring they aren't needlessly re-requested.\n\nNote that attempting to access the ``args`` property before invocation arguments have been parsed \u2013 *e.g.* within ``__init__`` \u2013 is not allowed, and will raise ``RuntimeError``.\n\nCommand hierarchy\n-----------------\n\nOur tools should be modular and composable, favoring atomicity over monolithism. Nevertheless, well-designed, -structured and -annotated code and application interfaces pay their users and developers tremendous dividends over time \u2013 no less in the case of more extensive interfaces, and particularly so for project management libraries (consider the ``Makefile``).\n\n``argcmdr`` intends to facilitate the definition of ``argparse``-based interfaces regardless of their structure. But it's in multi-level, or hierarchical, command argumentation that ``argcmdr`` shines.\n\nNested commands\n~~~~~~~~~~~~~~~\n\nRather than procedurally defining subparsers, ``Command`` class declarations may simply be nested.\n\nLet's define an executable file ``manage`` for managing a codebase::\n\n    #!/usr/bin/env python\n\n    import os\n\n    from argcmdr import Local, main\n\n    class Management(Local):\n        \"\"\"manage deployment\"\"\"\n\n        def __init__(self, parser):\n            parser.add_argument(\n                '-e', '--env',\n                choices=('development', 'production'),\n                default='development',\n                help=\"target environment\",\n            )\n\n        class Build(Local):\n            \"\"\"build app\"\"\"\n\n            def prepare(self, args):\n                req_path = os.path.join('requirements', f'{args.env}.txt')\n                yield self.local['pip']['-r', req_path]\n\n        class Deploy(Local):\n            \"\"\"deploy app\"\"\"\n\n            def prepare(self, args):\n                yield self.local['eb']['deploy', args.env]\n\n    if __name__ == '__main__':\n        main(Management)\n\n``Local`` command ``Management``, above, defines no functionality of its own. As such, executing ``manage`` without arguments prints its autogenerated usage::\n\n    usage: manage [-h] [--tb] [-q] [-d] [-s] [--no-show]\n                  [-e {development,production}]\n                  {build,deploy} ...\n\nBecause ``Management`` extends ``Local``, it inherits argumentation controlling whether standard output is printed and offering to run commands in \"dry\" mode. (Note, however, that it could have omitted these options by extending ``Command``. Moreover, it may override class method ``base_parser()``.)\n\n``Management`` adds to the basic interface the optional argument ``--env``. Most important, however, are the related, nested commands ``Build`` and ``Deploy``, which define functionality via ``prepare``. Neither nested command extends its subparser \u2013 though they could; but rather, they depend upon the common argumentation defined by ``Management``.\n\nExploring the interface via ``--help`` tells us a great deal, for example ``manage -h``::\n\n    usage: manage [-h] [--tb] [-q] [-d] [-s] [--no-show]\n                  [-e {development,production}]\n                  {build,deploy} ...\n\n    manage deployment\n\n    optional arguments:\n      -h, --help            show this help message and exit\n      --tb, --traceback     print error tracebacks\n      -q, --quiet           do not print command output\n      -d, --dry-run         do not execute commands, but print what they are\n                            (unless --no-show is provided)\n      -s, --show            print command expressions (by default not printed\n                            unless dry-run)\n      --no-show             do not print command expressions (by default not\n                            printed unless dry-run)\n      -e {development,production}, --env {development,production}\n                            target environment\n\n    management commands:\n      {build,deploy}        available commands\n        build               build app\n        deploy              deploy app\n\nAnd ``manage deploy -h``::\n\n    usage: manage deploy [-h]\n\n    deploy app\n\n    optional arguments:\n      -h, --help  show this help message and exit\n\nAs such, a \"dry run\"::\n\n    manage -de production deploy\n\nprints the following::\n\n    > /home/user/.local/bin/eb deploy production\n\nand without the dry-run flag the above operating system command is executed.\n\nRoot commands\n~~~~~~~~~~~~~\n\nThere is no artificial limit to the number of levels you may add to your command hierarchy. However, application interfaces are commonly \"wider\" than they are \"deep\". For this reason, as an alternative to class-nesting, the hierarchical relationship may be defined by a class decorator provided by the ``RootCommand``.\n\nLet's define the executable file ``git`` with no particular purpose whatsoever::\n\n    #!/usr/bin/env python\n\n    from argcmdr import Command, RootCommand, main\n\n    class Git(RootCommand):\n        \"\"\"another stupid content tracker\"\"\"\n\n        def __init__(self, parser):\n            parser.add_argument(\n                '-C',\n                default='.',\n                dest='path',\n                help=\"run as if git was started in <path> instead of the current \"\n                     \"working directory.\",\n            )\n\n    @Git.register\n    class Stash(Command):\n        \"\"\"stash the changes in a dirty working directory away\"\"\"\n\n        def __call__(self, args):\n            self['save'](args)\n\n        class Save(Command):\n            \"\"\"save your local modifications to a new stash\"\"\"\n\n            def __init__(self, parser):\n                parser.add_argument(\n                    '-p', '--patch',\n                    dest='interactive',\n                    action='store_true',\n                    default=False,\n                    help=\"interactively select hunks from the diff between HEAD \"\n                         \"and the working tree to be stashed\",\n                )\n\n            def __call__(self, args):\n                interactive = getattr(args, 'interactive', False)\n                print(\"stash save\", f\"(interactive: {interactive})\")\n\n        class List(Command):\n            \"\"\"list the stashes that you currently have\"\"\"\n\n            def __call__(self):\n                print(\"stash list\")\n\n    if __name__ == '__main__':\n        main(Git)\n\nWe anticipate adding many subcommands to ``git`` beyond ``stash``; and so, rather than nest all of these command classes under ``Git``:\n\n* we've defined ``Git`` as a ``RootCommand``\n* we've declared ``Stash`` at the module root\n* we've decorated ``Stash`` with ``Git.register``\n\nThe ``RootCommand`` functions identically to the ``Command``; it only adds this ability to extend the listing of its subcommands by those registered via its decorator. (Notably, ``LocalRoot`` composes the functionaliy of ``Local`` and ``RootCommand`` via multiple inheritance.)\n\nThe ``stash`` command, on the other hand, has opted to contain the entirety of its hierarchical functionality, nesting its own subcommands ``list`` and ``save``.\n\nNevertheless, you are not limited to a single ``RootCommand``. Any command whose hierarchy you would like to extend via the ``register`` decorator may inherit it. Moreover, the ``@cmd`` decorator accepts the keyword flag ``root``.\n\nMethod commands\n~~~~~~~~~~~~~~~\n\nDecorator-manufactured commands are no less capable than those derived from class declaration syntax, *except* in that other commands cannot, syntactically, be nested beneath them. (For that reason the ``@cmd`` decorator's ``root`` flag is of note.) Decorator-manufactured commands can nonetheless themselves extend hierarchies, either by being further decorated by ``register`` or nested under command class declarations::\n\n    @Git.register\n    class Stash(Command):\n        \"\"\"stash the changes in a dirty working directory away\"\"\"\n\n        def __call__(self, args):\n            self['save'](args)\n\n        @cmd('-p', '--patch', dest='interactive', action='store_true', default=False,\n             help=\"interactively select hunks from the diff between HEAD \"\n                  \"and the working tree to be stashed\")\n        def save(args):\n            \"\"\"save your local modifications to a new stash\"\"\"\n            interactive = getattr(args, 'interactive', False)\n            print(\"stash save\", f\"(interactive: {interactive})\")\n\n        @cmd\n        def list():\n            \"\"\"list the stashes that you currently have\"\"\"\n            print(\"stash list\")\n\nAbove we've rewritten the trivial ``stash`` commands ``save`` and ``list`` as ``@cmd``-decorated functions.\n\nSay, however, that we needed to invert the factoring of ``save`` logic between that command and its parent::\n\n    @Git.register\n    class Stash(Command):\n        \"\"\"stash the changes in a dirty working directory away\"\"\"\n\n        def perform_save(self, args):\n            interactive = getattr(args, 'interactive', False)\n            print(\"stash save\", f\"(interactive: {interactive})\")\n\n        def __call__(self, args):\n            self.perform_save(args)\n\n        @cmd('-p', '--patch', dest='interactive', action='store_true', default=False,\n             help=\"interactively select hunks from the diff between HEAD \"\n                  \"and the working tree to be stashed\")\n        @cmd(binding=True)\n        def save(self, args):\n            \"\"\"save your local modifications to a new stash\"\"\"\n            self[-1].perform_save(args)\n\n        @cmd\n        def list():\n            \"\"\"list the stashes that you currently have\"\"\"\n            print(\"stash list\")\n\n(Note that ``cmd`` can accept both an ``argparse`` argument specification and command feature-defining arguments at once; however, this is of use mainly to the definition of helpers such as the ``local`` decorator, as this style is difficult to read and otherwise discouraged. Moreover, only the **first** \u2013 *i.e.* inner-most \u2013 ``cmd`` decorator's command features are respected.)\n\nIn this version, ``save`` functionality is shared as a method of ``Stash``. ``save`` is able to access this method only by ascending the command hierarchy. This might make particular sense when multiple nested commands must share functionality, which is defined on the command class under which they are nested. (Note, however, that in such a case as this one, where the shared method *could* be defined as a ``staticmethod``, it is no less advisable to do so, and for nested commands to access it directly as, *e.g.* ``Stash.perform_save``.)\n\nOur above reference to ``self`` in ``save``, however, is at first glance misleading. This command *looks* like an instance method of ``Stash``; yet, it's its own ``Command``, and the ``save`` function receives as its first invocation argument an instance of the ``Command`` class ``save``. Moreover, in this case, ``save`` gains nothing from this self-reference; its class defines no special attributes or functionality of its own beyond argument-parsing.\n\nTo improve on the above, we may instead decorate our command function with ``cmdmethod``::\n\n    @Git.register\n    class Stash(Command):\n        \"\"\"stash the changes in a dirty working directory away\"\"\"\n\n        def perform_save(self, args):\n            interactive = getattr(args, 'interactive', False)\n            print(\"stash save\", f\"(interactive: {interactive})\")\n\n        def __call__(self, args):\n            self.perform_save(args)\n\n        @cmdmethod('-p', '--patch', dest='interactive', action='store_true', default=False,\n                   help=\"interactively select hunks from the diff between HEAD \"\n                        \"and the working tree to be stashed\")\n        def save(self, args):\n            \"\"\"save your local modifications to a new stash\"\"\"\n            self.perform_save(args)\n\nThe ``cmdmethod`` decorator \u2013 as well as the complementary ``localmethod`` decorator \u2013 alter the binding of the decorated function such that it receives the instance of its parent command \u2013 not itself \u2013 upon invocation. Much cleaner.\n\nAs with the ``local`` decorator, ``cmdmethod`` is merely a wrapper of ``cmd``. Identical functionality can be achieved via the ``binding`` keyword, though far more verbosely::\n\n    from argcmdr import CommandDecorator\n\n    @cmd(binding=CommandDecorator.Binding.parent)\n    def save(self, args):\n        ...\n\nWalking the hierachy\n~~~~~~~~~~~~~~~~~~~~\n\nUnlike the base command ``git`` in the example above, the command ``git stash`` \u2013 despite defining its own subcommands \u2013 also defines its own functionality, via ``__call__``. This functionality, however, is merely a shortcut to the ``stash`` command ``save``. Rather than repeat the definition of this functionality, ``Stash`` \"walks\" its hierarchy to access the instantiation of ``Save``, and invokes this command by reference.\n\nMuch of ``argcmdr`` is defined at the class level, and as such many ``Command`` methods are ``classmethod``. In the static or class context, we might walk the command hierarchy by reference, *e.g.* to ``Stash.Save``; or, from a class method of ``Stash``, as ``cls.Save``. Moreover, ``Command`` defines the class-level \"property\" ``subcommands``, which returns a list of ``Command`` classes immediately \"under\" it in the hierarchy.\n\nThe hierarchy of executable command objects, however, is instantiated at runtime and cached within the ``Command`` instance. To facilitate navigation of this hierarchy, the ``Command`` object is itself subscriptable. Look-up keys may be:\n\n* strings \u2013 descend the hierarchy to the named command\n* negative integers \u2013 ascend the hierarchy this many levels\n* a sequence combining the above \u2013 to combine \"steps\" into a single action\n\nIn the above example, ``Stash`` may have (redundantly) accessed ``Save`` with the look-up key::\n\n    (-1, 'stash', 'save')\n\nthat is with the full expression::\n\n    self[-1, 'stash', 'save']\n\n(The single key ``'save'``, however, was far more to the point.)\n\nBecause command look-ups are relative to the current command, ``Command`` also offers the ``property`` ``root``, which returns the base command. As such, our redundant expression could be rewritten::\n\n    self.root['stash', 'save']\n\nThe management file\n-------------------\n\nIn addition to the interface of custom executables, ``argcmdr`` endeavors to improve the generation and maintainability of non-executable but standardized files, intended for management of code development projects and operations.\n\nSimilar to a project's ``Makefile``, we might define our previous codebase-management file as the following Python module, ``manage.py``::\n\n    import os\n\n    from argcmdr import Local, main\n\n    class Management(Local):\n        \"\"\"manage deployment\"\"\"\n\n        def __init__(self, parser):\n            parser.add_argument(\n                '-e', '--env',\n                choices=('development', 'production'),\n                default='development',\n                help=\"target environment\",\n            )\n\n        class Build(Local):\n            \"\"\"build app\"\"\"\n\n            def prepare(self, args):\n                req_path = os.path.join('requirements', f'{args.env}.txt')\n                yield self.local['pip']['-r', req_path]\n\n        class Deploy(Local):\n            \"\"\"deploy app\"\"\"\n\n            def prepare(self, args):\n                yield self.local['eb']['deploy', args.env]\n\nUnlike our original script, ``manage``, ``manage.py`` is not executable, and need define neither an initial shebang line nor a final ``__name__ == '__main__'`` block.\n\nRather, ``argcmdr`` supplies its own, general-purpose ``manage`` executable command, which loads Commands from any ``manage.py`` in the current directory, or as specified by option ``--manage-file PATH``. As such, the usage and functionality of our ``manage.py``, as invoked via argcmdr's installed ``manage`` command, is identical to our original ``manage``. We need only ensure that ``argcmdr`` is installed, in order to make use of it to manage any or all project tasks, in a standard way, with even less boilerplate.\n\nEntrypoint definition\n~~~~~~~~~~~~~~~~~~~~~\n\nIn lieu of an explicitly defined execution path, ``manage`` infers the base command \u2013 and hence the entrypoint \u2013 of the ``manage.py`` management file module.\n\nThe entrypoint of a management file defining \u2013 at the module level \u2013 only one ``Command``, or multiple commands but only one ``RootCommand``, is assumed to be this one command. Otherwise, the intended entrypoint must be decorated with ``@entrypoint``::\n\n    from argcmdr import entrypoint, RootCommand\n\n    class GoodCommand(RootCommand):\n\n        def good_function(self):\n            ...\n\n    @entrypoint\n    class CommandEhh(GoodCommand):\n\n        def __call__(self):\n            self.good_function()\n            ...\n\n    @CommandEhh.register\n    class CommandBeh(GoodCommand):\n\n        def __call__(self):\n            self.good_function()\n            ...\n\nWe may infer from the above that ``GoodCommand`` is merely a base class extension, and that the module's CLI begins with the most \"root\" command, ``CommandEhh``, which is extended by ``CommandBeh``. However, rather than go out on a limb, when presented with these three subclasses of ``Command`` and ``RootCommand``, ``argcmdr`` requires that the intended entrypoint is explicitly marked.\n\nNote, however, that only commands declared at the module, or \"top\" level, are considered potential entrypoints::\n\n    class CommandEhh(Command):\n\n        class CommandBeh(Command):\n\n            ...\n\nPresented with a module containing only the above commands, ``argcmdr`` would identify ``CommandEhh`` as the entrypoint; ``CommandBeh`` would never be considered, even if decorated ``@entrypoint``.\n\nThe management package\n~~~~~~~~~~~~~~~~~~~~~~\n\nPython *packages*, no less than stand-alone modules, may also be defined for use with the ``manage`` command, to aid in maintenance and development.\n\nConsider the following example directory layout::\n\n    manage/\n    \u251c\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 cloud.py\n    \u251c\u2500\u2500 db.py\n    \u251c\u2500\u2500 main.py\n    \u251c\u2500\u2500 morale.py\n    \u251c\u2500\u2500 server.py\n    \u2514\u2500\u2500 util.py\n\n``argcmdr`` will load the above top-level Python module, ``manage``, just as well as it would the ``manage`` module defined by a ``manage.py`` file, (whether these are available on the ``PYTHONPATH`` or not).\n\nFurthermore, detecting that *this* ``manage`` is in fact a package, ``argcmdr`` will *automatically* and *recursively* load all of the modules this package contains.\n\nThis allows the developer to provide ``argcmdr`` the minimum that it requires at ``manage/__init__.py`` \u2013 access to an interface entrypoint, *i.e.* the base ``Command`` \u2013 and to organize the development of that interface in whatever maintainable way suits them.\n\nTo wit, the developer simply might write, in ``manage/__init__.py``::\n\n    from .main import Main  # noqa\n\n(\u2026And they will have no need of the ``@entrypoint`` decorator, as ``argcmdr`` will only see the one top-level command.)\n\nOf course, that top-level command might have been defined in ``__init__.py``, or as you might prefer, in ``manage/main.py``::\n\n    from argcmdr import RootCommand\n\n    class Main(RootCommand):\n        \"\"\"your one-stop shop for devops\"\"\"\n\n        ...\n\nAnd, each subcommand may be defined in a submodule, such as ``manage/cloud.py``::\n\n    from argcmdr import Command\n\n    from .main import Main\n\n    @Main.register\n    class Cloud(Command):\n        \"\"\"manage cloud computing resources\"\"\"\n\n        ...\n\nThanks to automatic loading, the ``Cloud`` subcommand, (which will resolve to ``manage cloud``), will be picked up, without additional boilerplate and without needing to consider circular imports.\n\nTo disable automatic submodule loading, set the following in ``manage/__init__.py``::\n\n    __auto_init_package__ = False\n\nAnd to make (custom) use of this feature, see: ``argcmdr.init_package()``.\n\nBootstrapping\n~~~~~~~~~~~~~\n\nTo ensure that such a friendly \u2013 and *relatively* high-level \u2013 project requirement as ``argcmdr`` is satisfied, consider the expressly low-level utility install-cli_, with which to guide contributors through the process of provisioning your project's most basic requirements.\n\nShell completion\n----------------\n\n``argcmdr`` supports shell command argument completion via ``argcomplete`` (see argcomplete_).\n\nAs explained by its documentation, your user (perhaps in executing the installation of your command), may enable argument completion, either:\n\n* specifically for your shell command\n* or generally for any script containing the string **PYTHON_ARGCOMPLETE_OK** in its first 1024 bytes\n\nFor flexibility, (and, *e.g.*, in support of installation into virtual environments, or otherwise where system- or user-global installation is undesirable or impossible), ``argcmdr`` *does not* currently insist on a particular scheme to enable argument completion.\n\nRather, for example, to enable argument completion system-wide, specifically for the ``manage`` command (provisioned by ``argcmdr``), you might execute the following from a Bash shell (as the root user)::\n\n    register-python-argcomplete --shell bash manage > /etc/bash_completion.d/python-argcomplete-manage.sh\n\nAlternatively, the same argument completion may be enabled, but only for the current user::\n\n    mkdir -p ~/.bash_completion.d\n    register-python-argcomplete --shell bash manage > ~/.bash_completion.d/python-argcomplete-manage.sh\n\nOnly in the latter case, the user must have the file ``~/.bash_completion``, including contents of the following form::\n\n    if [ -d ~/.bash_completion.d/ ] && [ ! -z \"$(ls ~/.bash_completion.d/)\" ]; then\n      for bcfile in ~/.bash_completion.d/*; do\n        . \"$bcfile\"\n      done\n    fi\n\n(Bash will load this file automatically.)\n\nIn the case that neither system-wide nor user-only installation is appropriate, the same argument completion may be enabled, but only for the current shell::\n\n    eval \"$(register-python-argcomplete --shell bash manage)\"\n\nRegardless of the method, having so enabled argument completion (for your command), in your shell, ``argcmdr`` will handle the rest, generating completion suggestions based on your command definition.\n\n.. _argparse: https://docs.python.org/3/library/argparse.html\n.. _python.org: https://www.python.org/downloads/\n.. _Homebrew: https://brew.sh/\n.. _pyenv: https://github.com/pyenv/pyenv\n.. _pyenv installer: https://github.com/pyenv/pyenv-installer#installation--update--uninstallation\n.. _plumbum: https://plumbum.readthedocs.io/en/latest/local_commands.html#exit-codes\n.. _Dickens: https://github.com/dssg/dickens\n.. _install-cli: https://github.com/dssg/install-cli\n.. _argcomplete: https://argcomplete.readthedocs.io/\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/dssg/argcmdr", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "argcmdr", "package_url": "https://pypi.org/project/argcmdr/", "platform": "", "project_url": "https://pypi.org/project/argcmdr/", "project_urls": {"Homepage": "https://github.com/dssg/argcmdr"}, "release_url": "https://pypi.org/project/argcmdr/0.6.0/", "requires_dist": ["argcomplete (==1.9.4)", "Dickens (==1.0.1)", "plumbum (==1.6.4)"], "requires_python": ">=3.6", "summary": "Thin argparse wrapper for quick, clear and easy declaration of hierarchical console command interfaces", "version": "0.6.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>The thin <tt>argparse</tt> wrapper for quick, clear and easy declaration of (hierarchical) console command interfaces via Python.</p>\n<p><tt>argcmdr</tt>:</p>\n<ul>\n<li>handles the boilerplate of CLI<ul>\n<li>while maintaining the clarity and extensibility of your code</li>\n<li>without requiring you to learn Yet Another argument-definition syntax</li>\n<li>without reinventing the wheel or sacrificing the flexibility of <tt>argparse</tt></li>\n</ul>\n</li>\n<li>enables invocation via<ul>\n<li>executable script (<tt>__name__ == '__main__'</tt>)</li>\n<li><tt>setuptools</tt> entrypoint</li>\n<li>command-defining module (like the <tt>Makefile</tt> of <tt>make</tt>)</li>\n</ul>\n</li>\n<li>determines command hierarchy flexibly and cleanly<ul>\n<li>command declarations are nested to indicate CLI hierarchy <em>or</em></li>\n<li>commands are decorated to indicate their hierarchy</li>\n</ul>\n</li>\n<li>includes support for elegant interaction with the operating system, via <tt>plumbum</tt></li>\n</ul>\n<div id=\"setup\">\n<h2>Setup</h2>\n<p><tt>argcmdr</tt> is developed for Python version 3.6.3 and above, and may be built via <tt>setuptools</tt>.</p>\n<div id=\"python\">\n<h3>Python</h3>\n<p>If Python 3.6.3 or greater is not installed on your system, it is available from <a href=\"https://www.python.org/downloads/\" rel=\"nofollow\">python.org</a>.</p>\n<p>However, depending on your system, you might prefer to install Python via a package manager, such as <a href=\"https://brew.sh/\" rel=\"nofollow\">Homebrew</a> on Mac OS X or APT on Debian-based Linux systems.</p>\n<p>Alternatively, <a href=\"https://github.com/pyenv/pyenv\" rel=\"nofollow\">pyenv</a> is highly recommended to manage arbitrary installations of Python, and may be most easily installed via the <a href=\"https://github.com/pyenv/pyenv-installer#installation--update--uninstallation\" rel=\"nofollow\">pyenv installer</a>.</p>\n</div>\n<div id=\"id1\">\n<h3>argcmdr</h3>\n<p>To install from PyPI:</p>\n<pre>pip install argcmdr\n</pre>\n<p>To install from Github:</p>\n<pre>pip install git+https://github.com/dssg/argcmdr.git\n</pre>\n<p>To install from source:</p>\n<pre>python setup.py install\n</pre>\n</div>\n</div>\n<div id=\"tutorial\">\n<h2>Tutorial</h2>\n<div id=\"contents\">\n<ul>\n<li><a href=\"#the-command\" id=\"id2\" rel=\"nofollow\">The Command</a></li>\n<li><a href=\"#the-command-decorator\" id=\"id3\" rel=\"nofollow\">The command decorator</a></li>\n<li><a href=\"#local-execution\" id=\"id4\" rel=\"nofollow\">Local execution</a><ul>\n<li><a href=\"#managing-execution\" id=\"id5\" rel=\"nofollow\">Managing execution</a><ul>\n<li><a href=\"#handling-exit-codes\" id=\"id6\" rel=\"nofollow\">Handling exit codes</a></li>\n<li><a href=\"#inspecting-results\" id=\"id7\" rel=\"nofollow\">Inspecting results</a></li>\n<li><a href=\"#handling-exceptions\" id=\"id8\" rel=\"nofollow\">Handling exceptions</a></li>\n<li><a href=\"#modifying-execution\" id=\"id9\" rel=\"nofollow\">Modifying execution</a></li>\n</ul>\n</li>\n<li><a href=\"#the-local-decorator\" id=\"id10\" rel=\"nofollow\">The local decorator</a></li>\n</ul>\n</li>\n<li><a href=\"#command-invocation-signature\" id=\"id11\" rel=\"nofollow\">Command invocation signature</a><ul>\n<li><a href=\"#access-to-the-parsed-argument-namespace\" id=\"id12\" rel=\"nofollow\">Access to the parsed argument namespace</a></li>\n</ul>\n</li>\n<li><a href=\"#command-hierarchy\" id=\"id13\" rel=\"nofollow\">Command hierarchy</a><ul>\n<li><a href=\"#nested-commands\" id=\"id14\" rel=\"nofollow\">Nested commands</a></li>\n<li><a href=\"#root-commands\" id=\"id15\" rel=\"nofollow\">Root commands</a></li>\n<li><a href=\"#method-commands\" id=\"id16\" rel=\"nofollow\">Method commands</a></li>\n<li><a href=\"#walking-the-hierachy\" id=\"id17\" rel=\"nofollow\">Walking the hierachy</a></li>\n</ul>\n</li>\n<li><a href=\"#the-management-file\" id=\"id18\" rel=\"nofollow\">The management file</a><ul>\n<li><a href=\"#entrypoint-definition\" id=\"id19\" rel=\"nofollow\">Entrypoint definition</a></li>\n<li><a href=\"#the-management-package\" id=\"id20\" rel=\"nofollow\">The management package</a></li>\n<li><a href=\"#bootstrapping\" id=\"id21\" rel=\"nofollow\">Bootstrapping</a></li>\n</ul>\n</li>\n<li><a href=\"#shell-completion\" id=\"id22\" rel=\"nofollow\">Shell completion</a></li>\n</ul>\n</div>\n<div id=\"the-command\">\n<h3><a href=\"#id2\" rel=\"nofollow\">The Command</a></h3>\n<p><tt>argcmdr</tt> is built around the base class <tt>Command</tt>. Your console command extends <tt>Command</tt>, and optionally defines:</p>\n<ul>\n<li><tt>__init__(parser)</tt>, which adds to the parser the arguments that your command requires, as supported by <tt>argparse</tt> (see <a href=\"https://docs.python.org/3/library/argparse.html\" rel=\"nofollow\">argparse</a>)</li>\n<li><tt><span class=\"pre\">__call__([args,</span> parser, <span class=\"pre\">...])</span></tt>, which is invoked when your console command is invoked, and which is expected to implement your command\u2019s functionality</li>\n</ul>\n<p>For example, let\u2019s define the executable file <tt>listdir</tt>, a trivial script which prints the current directory\u2019s contents:</p>\n<pre>#!/usr/bin/env python\n\nimport os\n\nfrom argcmdr import Command, main\n\nclass Main(Command):\n    \"\"\"print the current directory's contents\"\"\"\n\n    def __call__(self):\n        print(*os.listdir())\n\nif __name__ == '__main__':\n    main(Main)\n</pre>\n<p>Should we execute this script, it will perform much the same as <tt>ls <span class=\"pre\">-A</span></tt>.</p>\n<p>Let\u2019s say, however, that we would like to optionally print each item of the directory\u2019s contents on a separate line:</p>\n<pre>class Main(Command):\n    \"\"\"print the current directory's contents\"\"\"\n\n    def __init__(self, parser):\n        parser.add_argument(\n            '-1',\n            action='store_const',\n            const='\\n',\n            default=' ',\n            dest='sep',\n            help='list one file per line',\n        )\n\n    def __call__(self, args):\n        print(*os.listdir(), sep=args.sep)\n</pre>\n<p>We now optionally support execution similar to <tt>ls <span class=\"pre\">-A1</span></tt>, via <tt>listdir <span class=\"pre\">-1</span></tt>.</p>\n<p>Fittingly, this is reflected in the script\u2019s autogenerated usage text \u2013 <tt>listdir <span class=\"pre\">-h</span></tt> prints:</p>\n<pre>usage: listdir [-h] [--tb] [-1]\n\nprint the current directory's contents\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --tb, --traceback  print error tracebacks\n  -1                 list one file per line\n</pre>\n</div>\n<div id=\"the-command-decorator\">\n<h3><a href=\"#id3\" rel=\"nofollow\">The command decorator</a></h3>\n<p>For particularly trivial commands, the class declaration syntax may be considered verbose and unnecessary. The <tt>@cmd</tt> decorator manufactures the appropriate <tt>Command</tt> from a decorated function or method.</p>\n<p>The first command may be rewritten to produce an identical result:</p>\n<pre>from argcmdr import cmd\n\n@cmd\ndef main():\n    \"\"\"print the current directory's contents\"\"\"\n    print(*os.listdir())\n</pre>\n<p>and, for the second, <tt>cmd</tt> optionally accepts an <tt>argparse</tt> argument definition:</p>\n<pre>@cmd('-1', action='store_const', const='\\n', default=' ', dest='sep', help='list one file per line')\ndef main(args):\n    \"\"\"print the current directory's contents\"\"\"\n    print(*os.listdir(), sep=args.sep)\n</pre>\n<p>Further arguments may be added via additional decoration:</p>\n<pre>@cmd('-a', ...)\n@cmd('-1', ...)\ndef main(args):\n    ...\n</pre>\n</div>\n<div id=\"local-execution\">\n<h3><a href=\"#id4\" rel=\"nofollow\">Local execution</a></h3>\n<p>As much as we gain from Python and its standard library, it\u2019s quite typical to need to spawn non-Python subprocesses, and for that matter for your script\u2019s purpose to be entirely to orchestrate workflows built from operating system commands. Python\u2019s \u2013 and argcmdr\u2019s \u2013 benefit is to make this work easier, debuggable, testable and scalable.</p>\n<p>In fact, our above, trivial example could be accomplished easily with direct execution of <tt>ls</tt>:</p>\n<pre>import argparse\n\nfrom argcmdr import Local, main\n\nclass Main(Local):\n    \"\"\"list directory contents\"\"\"\n\n    def __init__(self, parser):\n        parser.add_argument(\n            'remainder',\n            metavar='arguments for ls',\n            nargs=argparse.REMAINDER,\n        )\n\n    def __call__(self, args):\n        print(self.local['ls'](args.remainder))\n</pre>\n<p><tt>local</tt>, bound to the <tt>Local</tt> base class, is a dictionary which caches path look-ups for system executables.</p>\n<p>This could, however, still be cleaner. For this reason, the <tt>Local</tt> command features a parallel invocation interface, <tt><span class=\"pre\">prepare([args,</span> parser, <span class=\"pre\">...])</span></tt>:</p>\n<pre>class Main(Local):\n    \"\"\"list directory contents\"\"\"\n\n    def __init__(self, parser):\n        parser.add_argument(\n            'remainder',\n            metavar='arguments for ls',\n            nargs=argparse.REMAINDER,\n        )\n\n    def prepare(self, args):\n        return self.local['ls'][args.remainder]\n</pre>\n<p>Via the <tt>prepare</tt> interface, standard output is printed by default, and your command logic may be tested in a \u201cdry run,\u201d as reflected in the usage output of the above:</p>\n<pre>usage: listdir [-h] [--tb] [-q] [-d] [-s] [--no-show] ...\n\nlist directory contents\n\npositional arguments:\n  arguments for ls\n\noptional arguments:\n  -h, --help         show this help message and exit\n  --tb, --traceback  print error tracebacks\n  -q, --quiet        do not print command output\n  -d, --dry-run      do not execute commands, but print what they are (unless\n                     --no-show is provided)\n  -s, --show         print command expressions (by default not printed unless\n                     dry-run)\n  --no-show          do not print command expressions (by default not printed\n                     unless dry-run)\n</pre>\n<p>To execute multiple local subprocesses, <tt>prepare</tt> may either return an iterable (<em>e.g.</em> <tt>list</tt>) of the above <tt>plumbum</tt> bound commands, or <tt>prepare</tt> may be defined as a generator function, (<em>i.e.</em> make repeated use of <tt>yield</tt> \u2013 see below).</p>\n<div id=\"managing-execution\">\n<h4><a href=\"#id5\" rel=\"nofollow\">Managing execution</a></h4>\n<div id=\"handling-exit-codes\">\n<h5><a href=\"#id6\" rel=\"nofollow\">Handling exit codes</a></h5>\n<p>Subprocess commands emitted by <tt>Local.prepare</tt> are executed in order and, by default, failed execution is interrupted by a raised exception:</p>\n<pre>class Release(Local):\n    \"\"\"release the package to pypi\"\"\"\n\n    def __init__(self, parser):\n        parser.add_argument(\n            'part',\n            choices=('major', 'minor', 'patch'),\n            help=\"part of the version to be bumped\",\n        )\n\n    def prepare(self, args):\n        yield self.local['bumpversion'][args.part]\n        yield self.local['python']['setup.py', 'sdist', 'bdist_wheel']\n        yield self.local['twine']['upload', 'dist/*']\n</pre>\n<p>Should the <tt>bumpversion</tt> command fail, the <tt>deploy</tt> command will not proceed.</p>\n<p>In some cases, however, we might like to disable this functionality, and proceed regardless of a subprocess\u2019s exit code. We may pass arguments such as <tt>retcode</tt> to <tt>plumbum</tt> by setting this attribute on the <tt>prepare</tt> method:</p>\n<pre>def prepare(self, args):\n    yield self.local['bumpversion'][args.part]\n    yield self.local['python']['setup.py', 'sdist', 'bdist_wheel']\n    yield self.local['twine']['upload', 'dist/*']\n\nprepare.retcode = None\n</pre>\n<p>Subprocess commands emitted by the above method will not raise execution exceptions, regardless of their exit code. (To allow only certain exit code(s), set <tt>retcode</tt> as appropriate \u2013 see <a href=\"https://plumbum.readthedocs.io/en/latest/local_commands.html#exit-codes\" rel=\"nofollow\">plumbum</a>.)</p>\n</div>\n<div id=\"inspecting-results\">\n<h5><a href=\"#id7\" rel=\"nofollow\">Inspecting results</a></h5>\n<p>Having disabled execution exceptions \u2013 and regardless \u2013 we might need to inspect a subprocess command\u2019s exit code, standard output or standard error. As such, (whether we manipulate <tt>retcode</tt> or not), <tt>argcmdr</tt> communicates these command results with <tt>prepare</tt> generator methods:</p>\n<pre>def prepare(self, args):\n    (code, out, err) = yield self.local['bumpversion']['--list', args.part]\n\n    yield self.local['python']['setup.py', 'sdist', 'bdist_wheel']\n\n    if out is None:\n        version = 'DRY-RUN'\n    else:\n        (version_match,) = re.finditer(\n            r'^new_version=([\\d.]+)$',\n            out,\n            re.M,\n        )\n        version = version_match.group(1)\n\n    yield self.local['twine']['upload', f'dist/*{version}*']\n</pre>\n<p>In the above, <tt>prepare</tt> stores the results of <tt>bumpversion</tt> execution, in order to determine from its standard output the version to be released.</p>\n</div>\n<div id=\"handling-exceptions\">\n<h5><a href=\"#id8\" rel=\"nofollow\">Handling exceptions</a></h5>\n<p>Moreover, we might like to define special handling for execution errors; and, perhaps rather than manipulate <tt>retcode</tt> for all commands emitted by our method, we might like to handle them separately. As such, execution exceptions are also communicated back to <tt>prepare</tt> generators:</p>\n<pre>def prepare(self, args):\n    try:\n        (_code, out, _err) = yield self.local['bumpversion']['--list', args.part]\n    except self.local.ProcessExecutionError:\n        print(\"execution failed but here's a joke ...\")\n        ...\n</pre>\n</div>\n<div id=\"modifying-execution\">\n<h5><a href=\"#id9\" rel=\"nofollow\">Modifying execution</a></h5>\n<p>Commands are run in the foreground by default, their outputs printed, as well as recorded for inspection, via the <tt>plumbum</tt> modifier, <tt>TEE</tt>.</p>\n<p>To execute a command in the background (and continue), we may specify the <tt>BG</tt> modifier:</p>\n<pre>def prepare(self, args):\n    future = yield (self.local.BG, self.local['bumpversion']['--list', args.part])\n</pre>\n<p>Alternatively, we may wish to execute a command in the foreground <em>only</em>, (and not record its output) \u2013 <em>e.g.</em> to best support processes which require TTY:</p>\n<pre>def prepare(self):\n    return (self.local.FG, self.local['ipython']['-i', 'startup.py'])\n</pre>\n</div>\n</div>\n<div id=\"the-local-decorator\">\n<h4><a href=\"#id10\" rel=\"nofollow\">The local decorator</a></h4>\n<p><tt>Local</tt> is an alternate command base class, and a subclass of <tt>Command</tt>. Any base class may be substituted for <tt>Command</tt> when using the command decorator:</p>\n<pre>@cmd(base=CustomCommand)\ndef main():\n    ...\n</pre>\n<p>Moreover, <tt>Local</tt> functionality may be requested via keyword flag <tt>local</tt>:</p>\n<pre>@cmd(local=True)\ndef main(self):\n    ...\n</pre>\n<p>And in support of the above, common case, the <tt>@local</tt> decorator is provided:</p>\n<pre>from argcmdr import local\n\n@local\ndef main(self):\n    ...\n</pre>\n<p>Note that in the last two examples, our command function\u2019s call signature included <tt>self</tt>.</p>\n<p>Decorated command functions are in fact replaced with manufactured subclasses of <tt>Command</tt>, and the function is invoked as this command\u2019s functionality \u2013 either <tt>__call__</tt> or <tt>prepare</tt>. It is assumed that, by default, this function should be treated as a <tt>staticmethod</tt>, and given no reference to the manufactured <tt>Command</tt> instance. However, in the case of <tt>local</tt> decoration, this is not the case; the binding is left up to the decorated object, which, according to Python descriptor rules, means that a decorated function is treated as a \u201cmethod\u201d and receives the instance. This way, <tt>local</tt> command functions may access the instance\u2019s <tt>local</tt> dictionary of operating system executables.</p>\n<p>Binding may be explicitly controlled via the decorator keyword <tt>binding</tt>, <em>e.g.</em>:</p>\n<pre>@cmd(binding=True, base=CustomCommand)\ndef main(self):\n    ...\n</pre>\n<p>See <a href=\"#method-commands\" rel=\"nofollow\">Method commands</a> for further examples of decorator-defined commands and alternative bindings.</p>\n</div>\n</div>\n<div id=\"command-invocation-signature\">\n<h3><a href=\"#id11\" rel=\"nofollow\">Command invocation signature</a></h3>\n<p>Note that in our last trivial examples of listing directory contents, we made our script dependent upon the <tt>ls</tt> command in the operating environment. <tt>argcmdr</tt> will not, by default, print tracebacks, and it will colorize unhandled exceptions; however, we might prefer to print a far friendlier error message.</p>\n<p>One easy way of printing friendly error messages is to make use of <tt>argparse.ArgumentParser.error()</tt>. As we\u2019ve seen, <tt>Command</tt> invocation, via either <tt>__call__</tt> or <tt>prepare</tt>, may accept zero arguments, or it may require the parsed arguments <tt>argparse.Namespace</tt>. Moreover, it may require a second argument, and receive the argument parser:</p>\n<pre>class Main(Local):\n    \"\"\"list directory contents\"\"\"\n\n    def __init__(self, parser):\n        parser.add_argument(\n            'remainder',\n            metavar='arguments for ls',\n            nargs=argparse.REMAINDER,\n        )\n\n    def prepare(self, args, parser):\n        try:\n            local_exec = self.local['ls']\n        except self.local.CommandNotFound:\n            parser.error('command not available')\n\n        yield local_exec[args.remainder]\n</pre>\n<p>If <tt>ls</tt> is not available, the user is presented the following message upon executing the above:</p>\n<pre>usage: listdir [-h] [--tb] [-q] [-d] [-s] [--no-show] ...\nlistdir: error: command not available\n</pre>\n<div id=\"access-to-the-parsed-argument-namespace\">\n<h4><a href=\"#id12\" rel=\"nofollow\">Access to the parsed argument namespace</a></h4>\n<p>The command invocation\u2019s parsed arguments are most straight-forwardly accessible as the first argument of the <tt>Command</tt> invocation signature, either <tt>__call__</tt> or <tt>prepare</tt>. However, in less-than-trivial implementations, wherein command methods are factored for reusability, passing the argument namespace from method to method may become tedious. To support such scenarios, this object is made additionally available via the <tt>Command</tt> <em>property</em>, <tt>args</tt>.</p>\n<p>Consider a class of commands which require a database password. We don\u2019t want to store this password anywhere in plain text; rather, we expect it to be input, either via (piped) standard input or the TTY:</p>\n<pre>class DbSync(Command):\n    \"\"\"sync databases\"\"\"\n\n    def __init__(self, parser):\n        parser.add_argument(\n            '-p', '--password',\n            action='store_true',\n            dest='stdin_password',\n            default=False,\n            help=\"read database password from standard input\",\n        )\n\n    def __call__(self, args):\n        engine = self.dbengine(args)\n        ...\n\n    def dbcreds(self, args):\n        dbcreds = {\n            'username': os.getenv('PGUSER'),\n            'host': os.getenv('PGHOST'),\n            'port': os.getenv('PGPORT'),\n            'database': os.getenv('PGDATABASE'),\n        }\n\n        missing = [key for (key, value) in dbcreds.items() if not value]\n        if missing:\n            raise RuntimeError(\n                \"database connection information missing from \"\n                \"environmental configuration: \" + ', '.join(missing)\n            )\n\n        if args.stdin_password:\n            dbcreds['password'] = sys.stdin.read().rstrip('\\n\\r')\n\n            # we're done with the (pipe) stdin, so force it back to TTY for\n            # any subsequent input()\n            sys.stdin = open('/dev/tty')\n        else:\n            dbcreds['password'] = os.getenv('PGPASSWORD')\n            if not dbcreds['password']:\n                dbcreds['password'] = getpass.getpass(\n                    'enter password for '\n                    + ('{username}@{host}:{port}'.format_map(dbcreds) | colors.bold)\n                    + ': '\n                    | colors.yellow\n                )\n\n        return dbcreds\n\n    def dburi(self, args):\n        return sqlalchemy.engine.url.URL('postgres', **self.dbcreds(args))\n\n    def dbengine(self, args):\n        return sqlalchemy.create_engine(self.dburi(args))\n</pre>\n<p>Not only were we forced to verbosely daisy-chain the arguments namespace, <tt>args</tt>, from method to method; moreover, we were prevented from (trivially) caching the result of <tt>dbcreds</tt>, to ensure that the password isn\u2019t ever requested more than once.</p>\n<p>Now, let\u2019s reimplement the above, making use of the property <tt>args</tt>:</p>\n<pre>class DbSync(Command):\n    \"\"\"sync databases\"\"\"\n\n    def __init__(self, parser):\n        parser.add_argument(\n            '-p', '--password',\n            action='store_true',\n            dest='stdin_password',\n            default=False,\n            help=\"read database password from standard input\",\n        )\n\n    def __call__(self):\n        engine = self.dbengine\n        ...\n\n    @cachedproperty\n    def dbcreds(self):\n        dbcreds = {\n            'username': os.getenv('PGUSER'),\n            'host': os.getenv('PGHOST'),\n            'port': os.getenv('PGPORT'),\n            'database': os.getenv('PGDATABASE'),\n        }\n\n        missing = [key for (key, value) in dbcreds.items() if not value]\n        if missing:\n            raise RuntimeError(\n                \"database connection information missing from \"\n                \"environmental configuration: \" + ', '.join(missing)\n            )\n\n        if self.args.stdin_password:\n            dbcreds['password'] = sys.stdin.read().rstrip('\\n\\r')\n\n            # we're done with the (pipe) stdin, so force it back to TTY for\n            # any subsequent input()\n            sys.stdin = open('/dev/tty')\n        else:\n            dbcreds['password'] = os.getenv('PGPASSWORD')\n            if not dbcreds['password']:\n                dbcreds['password'] = getpass.getpass(\n                    'enter password for '\n                    + ('{username}@{host}:{port}'.format_map(dbcreds) | colors.bold)\n                    + ': '\n                    | colors.yellow\n                )\n\n        return dbcreds\n\n    @property\n    def dburi(self):\n        return sqlalchemy.engine.url.URL('postgres', **self.dbcreds)\n\n    @property\n    def dbengine(self):\n        return sqlalchemy.create_engine(self.dburi)\n</pre>\n<p>In this form, <tt>args</tt> needn\u2019t be passed from method to method; in fact, methods of the <tt>DbSync</tt> command needn\u2019t worry about arguments which don\u2019t directly interest them at all. And, using <tt>cachedproperty</tt> from <a href=\"https://github.com/dssg/dickens\" rel=\"nofollow\">Dickens</a>, the database credentials are trivially cached, ensuring they aren\u2019t needlessly re-requested.</p>\n<p>Note that attempting to access the <tt>args</tt> property before invocation arguments have been parsed \u2013 <em>e.g.</em> within <tt>__init__</tt> \u2013 is not allowed, and will raise <tt>RuntimeError</tt>.</p>\n</div>\n</div>\n<div id=\"command-hierarchy\">\n<h3><a href=\"#id13\" rel=\"nofollow\">Command hierarchy</a></h3>\n<p>Our tools should be modular and composable, favoring atomicity over monolithism. Nevertheless, well-designed, -structured and -annotated code and application interfaces pay their users and developers tremendous dividends over time \u2013 no less in the case of more extensive interfaces, and particularly so for project management libraries (consider the <tt>Makefile</tt>).</p>\n<p><tt>argcmdr</tt> intends to facilitate the definition of <tt>argparse</tt>-based interfaces regardless of their structure. But it\u2019s in multi-level, or hierarchical, command argumentation that <tt>argcmdr</tt> shines.</p>\n<div id=\"nested-commands\">\n<h4><a href=\"#id14\" rel=\"nofollow\">Nested commands</a></h4>\n<p>Rather than procedurally defining subparsers, <tt>Command</tt> class declarations may simply be nested.</p>\n<p>Let\u2019s define an executable file <tt>manage</tt> for managing a codebase:</p>\n<pre>#!/usr/bin/env python\n\nimport os\n\nfrom argcmdr import Local, main\n\nclass Management(Local):\n    \"\"\"manage deployment\"\"\"\n\n    def __init__(self, parser):\n        parser.add_argument(\n            '-e', '--env',\n            choices=('development', 'production'),\n            default='development',\n            help=\"target environment\",\n        )\n\n    class Build(Local):\n        \"\"\"build app\"\"\"\n\n        def prepare(self, args):\n            req_path = os.path.join('requirements', f'{args.env}.txt')\n            yield self.local['pip']['-r', req_path]\n\n    class Deploy(Local):\n        \"\"\"deploy app\"\"\"\n\n        def prepare(self, args):\n            yield self.local['eb']['deploy', args.env]\n\nif __name__ == '__main__':\n    main(Management)\n</pre>\n<p><tt>Local</tt> command <tt>Management</tt>, above, defines no functionality of its own. As such, executing <tt>manage</tt> without arguments prints its autogenerated usage:</p>\n<pre>usage: manage [-h] [--tb] [-q] [-d] [-s] [--no-show]\n              [-e {development,production}]\n              {build,deploy} ...\n</pre>\n<p>Because <tt>Management</tt> extends <tt>Local</tt>, it inherits argumentation controlling whether standard output is printed and offering to run commands in \u201cdry\u201d mode. (Note, however, that it could have omitted these options by extending <tt>Command</tt>. Moreover, it may override class method <tt>base_parser()</tt>.)</p>\n<p><tt>Management</tt> adds to the basic interface the optional argument <tt><span class=\"pre\">--env</span></tt>. Most important, however, are the related, nested commands <tt>Build</tt> and <tt>Deploy</tt>, which define functionality via <tt>prepare</tt>. Neither nested command extends its subparser \u2013 though they could; but rather, they depend upon the common argumentation defined by <tt>Management</tt>.</p>\n<p>Exploring the interface via <tt><span class=\"pre\">--help</span></tt> tells us a great deal, for example <tt>manage <span class=\"pre\">-h</span></tt>:</p>\n<pre>usage: manage [-h] [--tb] [-q] [-d] [-s] [--no-show]\n              [-e {development,production}]\n              {build,deploy} ...\n\nmanage deployment\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --tb, --traceback     print error tracebacks\n  -q, --quiet           do not print command output\n  -d, --dry-run         do not execute commands, but print what they are\n                        (unless --no-show is provided)\n  -s, --show            print command expressions (by default not printed\n                        unless dry-run)\n  --no-show             do not print command expressions (by default not\n                        printed unless dry-run)\n  -e {development,production}, --env {development,production}\n                        target environment\n\nmanagement commands:\n  {build,deploy}        available commands\n    build               build app\n    deploy              deploy app\n</pre>\n<p>And <tt>manage deploy <span class=\"pre\">-h</span></tt>:</p>\n<pre>usage: manage deploy [-h]\n\ndeploy app\n\noptional arguments:\n  -h, --help  show this help message and exit\n</pre>\n<p>As such, a \u201cdry run\u201d:</p>\n<pre>manage -de production deploy\n</pre>\n<p>prints the following:</p>\n<pre>&gt; /home/user/.local/bin/eb deploy production\n</pre>\n<p>and without the dry-run flag the above operating system command is executed.</p>\n</div>\n<div id=\"root-commands\">\n<h4><a href=\"#id15\" rel=\"nofollow\">Root commands</a></h4>\n<p>There is no artificial limit to the number of levels you may add to your command hierarchy. However, application interfaces are commonly \u201cwider\u201d than they are \u201cdeep\u201d. For this reason, as an alternative to class-nesting, the hierarchical relationship may be defined by a class decorator provided by the <tt>RootCommand</tt>.</p>\n<p>Let\u2019s define the executable file <tt>git</tt> with no particular purpose whatsoever:</p>\n<pre>#!/usr/bin/env python\n\nfrom argcmdr import Command, RootCommand, main\n\nclass Git(RootCommand):\n    \"\"\"another stupid content tracker\"\"\"\n\n    def __init__(self, parser):\n        parser.add_argument(\n            '-C',\n            default='.',\n            dest='path',\n            help=\"run as if git was started in &lt;path&gt; instead of the current \"\n                 \"working directory.\",\n        )\n\n@Git.register\nclass Stash(Command):\n    \"\"\"stash the changes in a dirty working directory away\"\"\"\n\n    def __call__(self, args):\n        self['save'](args)\n\n    class Save(Command):\n        \"\"\"save your local modifications to a new stash\"\"\"\n\n        def __init__(self, parser):\n            parser.add_argument(\n                '-p', '--patch',\n                dest='interactive',\n                action='store_true',\n                default=False,\n                help=\"interactively select hunks from the diff between HEAD \"\n                     \"and the working tree to be stashed\",\n            )\n\n        def __call__(self, args):\n            interactive = getattr(args, 'interactive', False)\n            print(\"stash save\", f\"(interactive: {interactive})\")\n\n    class List(Command):\n        \"\"\"list the stashes that you currently have\"\"\"\n\n        def __call__(self):\n            print(\"stash list\")\n\nif __name__ == '__main__':\n    main(Git)\n</pre>\n<p>We anticipate adding many subcommands to <tt>git</tt> beyond <tt>stash</tt>; and so, rather than nest all of these command classes under <tt>Git</tt>:</p>\n<ul>\n<li>we\u2019ve defined <tt>Git</tt> as a <tt>RootCommand</tt></li>\n<li>we\u2019ve declared <tt>Stash</tt> at the module root</li>\n<li>we\u2019ve decorated <tt>Stash</tt> with <tt>Git.register</tt></li>\n</ul>\n<p>The <tt>RootCommand</tt> functions identically to the <tt>Command</tt>; it only adds this ability to extend the listing of its subcommands by those registered via its decorator. (Notably, <tt>LocalRoot</tt> composes the functionaliy of <tt>Local</tt> and <tt>RootCommand</tt> via multiple inheritance.)</p>\n<p>The <tt>stash</tt> command, on the other hand, has opted to contain the entirety of its hierarchical functionality, nesting its own subcommands <tt>list</tt> and <tt>save</tt>.</p>\n<p>Nevertheless, you are not limited to a single <tt>RootCommand</tt>. Any command whose hierarchy you would like to extend via the <tt>register</tt> decorator may inherit it. Moreover, the <tt>@cmd</tt> decorator accepts the keyword flag <tt>root</tt>.</p>\n</div>\n<div id=\"method-commands\">\n<h4><a href=\"#id16\" rel=\"nofollow\">Method commands</a></h4>\n<p>Decorator-manufactured commands are no less capable than those derived from class declaration syntax, <em>except</em> in that other commands cannot, syntactically, be nested beneath them. (For that reason the <tt>@cmd</tt> decorator\u2019s <tt>root</tt> flag is of note.) Decorator-manufactured commands can nonetheless themselves extend hierarchies, either by being further decorated by <tt>register</tt> or nested under command class declarations:</p>\n<pre>@Git.register\nclass Stash(Command):\n    \"\"\"stash the changes in a dirty working directory away\"\"\"\n\n    def __call__(self, args):\n        self['save'](args)\n\n    @cmd('-p', '--patch', dest='interactive', action='store_true', default=False,\n         help=\"interactively select hunks from the diff between HEAD \"\n              \"and the working tree to be stashed\")\n    def save(args):\n        \"\"\"save your local modifications to a new stash\"\"\"\n        interactive = getattr(args, 'interactive', False)\n        print(\"stash save\", f\"(interactive: {interactive})\")\n\n    @cmd\n    def list():\n        \"\"\"list the stashes that you currently have\"\"\"\n        print(\"stash list\")\n</pre>\n<p>Above we\u2019ve rewritten the trivial <tt>stash</tt> commands <tt>save</tt> and <tt>list</tt> as <tt>@cmd</tt>-decorated functions.</p>\n<p>Say, however, that we needed to invert the factoring of <tt>save</tt> logic between that command and its parent:</p>\n<pre>@Git.register\nclass Stash(Command):\n    \"\"\"stash the changes in a dirty working directory away\"\"\"\n\n    def perform_save(self, args):\n        interactive = getattr(args, 'interactive', False)\n        print(\"stash save\", f\"(interactive: {interactive})\")\n\n    def __call__(self, args):\n        self.perform_save(args)\n\n    @cmd('-p', '--patch', dest='interactive', action='store_true', default=False,\n         help=\"interactively select hunks from the diff between HEAD \"\n              \"and the working tree to be stashed\")\n    @cmd(binding=True)\n    def save(self, args):\n        \"\"\"save your local modifications to a new stash\"\"\"\n        self[-1].perform_save(args)\n\n    @cmd\n    def list():\n        \"\"\"list the stashes that you currently have\"\"\"\n        print(\"stash list\")\n</pre>\n<p>(Note that <tt>cmd</tt> can accept both an <tt>argparse</tt> argument specification and command feature-defining arguments at once; however, this is of use mainly to the definition of helpers such as the <tt>local</tt> decorator, as this style is difficult to read and otherwise discouraged. Moreover, only the <strong>first</strong> \u2013 <em>i.e.</em> inner-most \u2013 <tt>cmd</tt> decorator\u2019s command features are respected.)</p>\n<p>In this version, <tt>save</tt> functionality is shared as a method of <tt>Stash</tt>. <tt>save</tt> is able to access this method only by ascending the command hierarchy. This might make particular sense when multiple nested commands must share functionality, which is defined on the command class under which they are nested. (Note, however, that in such a case as this one, where the shared method <em>could</em> be defined as a <tt>staticmethod</tt>, it is no less advisable to do so, and for nested commands to access it directly as, <em>e.g.</em> <tt>Stash.perform_save</tt>.)</p>\n<p>Our above reference to <tt>self</tt> in <tt>save</tt>, however, is at first glance misleading. This command <em>looks</em> like an instance method of <tt>Stash</tt>; yet, it\u2019s its own <tt>Command</tt>, and the <tt>save</tt> function receives as its first invocation argument an instance of the <tt>Command</tt> class <tt>save</tt>. Moreover, in this case, <tt>save</tt> gains nothing from this self-reference; its class defines no special attributes or functionality of its own beyond argument-parsing.</p>\n<p>To improve on the above, we may instead decorate our command function with <tt>cmdmethod</tt>:</p>\n<pre>@Git.register\nclass Stash(Command):\n    \"\"\"stash the changes in a dirty working directory away\"\"\"\n\n    def perform_save(self, args):\n        interactive = getattr(args, 'interactive', False)\n        print(\"stash save\", f\"(interactive: {interactive})\")\n\n    def __call__(self, args):\n        self.perform_save(args)\n\n    @cmdmethod('-p', '--patch', dest='interactive', action='store_true', default=False,\n               help=\"interactively select hunks from the diff between HEAD \"\n                    \"and the working tree to be stashed\")\n    def save(self, args):\n        \"\"\"save your local modifications to a new stash\"\"\"\n        self.perform_save(args)\n</pre>\n<p>The <tt>cmdmethod</tt> decorator \u2013 as well as the complementary <tt>localmethod</tt> decorator \u2013 alter the binding of the decorated function such that it receives the instance of its parent command \u2013 not itself \u2013 upon invocation. Much cleaner.</p>\n<p>As with the <tt>local</tt> decorator, <tt>cmdmethod</tt> is merely a wrapper of <tt>cmd</tt>. Identical functionality can be achieved via the <tt>binding</tt> keyword, though far more verbosely:</p>\n<pre>from argcmdr import CommandDecorator\n\n@cmd(binding=CommandDecorator.Binding.parent)\ndef save(self, args):\n    ...\n</pre>\n</div>\n<div id=\"walking-the-hierachy\">\n<h4><a href=\"#id17\" rel=\"nofollow\">Walking the hierachy</a></h4>\n<p>Unlike the base command <tt>git</tt> in the example above, the command <tt>git stash</tt> \u2013 despite defining its own subcommands \u2013 also defines its own functionality, via <tt>__call__</tt>. This functionality, however, is merely a shortcut to the <tt>stash</tt> command <tt>save</tt>. Rather than repeat the definition of this functionality, <tt>Stash</tt> \u201cwalks\u201d its hierarchy to access the instantiation of <tt>Save</tt>, and invokes this command by reference.</p>\n<p>Much of <tt>argcmdr</tt> is defined at the class level, and as such many <tt>Command</tt> methods are <tt>classmethod</tt>. In the static or class context, we might walk the command hierarchy by reference, <em>e.g.</em> to <tt>Stash.Save</tt>; or, from a class method of <tt>Stash</tt>, as <tt>cls.Save</tt>. Moreover, <tt>Command</tt> defines the class-level \u201cproperty\u201d <tt>subcommands</tt>, which returns a list of <tt>Command</tt> classes immediately \u201cunder\u201d it in the hierarchy.</p>\n<p>The hierarchy of executable command objects, however, is instantiated at runtime and cached within the <tt>Command</tt> instance. To facilitate navigation of this hierarchy, the <tt>Command</tt> object is itself subscriptable. Look-up keys may be:</p>\n<ul>\n<li>strings \u2013 descend the hierarchy to the named command</li>\n<li>negative integers \u2013 ascend the hierarchy this many levels</li>\n<li>a sequence combining the above \u2013 to combine \u201csteps\u201d into a single action</li>\n</ul>\n<p>In the above example, <tt>Stash</tt> may have (redundantly) accessed <tt>Save</tt> with the look-up key:</p>\n<pre>(-1, 'stash', 'save')\n</pre>\n<p>that is with the full expression:</p>\n<pre>self[-1, 'stash', 'save']\n</pre>\n<p>(The single key <tt>'save'</tt>, however, was far more to the point.)</p>\n<p>Because command look-ups are relative to the current command, <tt>Command</tt> also offers the <tt>property</tt> <tt>root</tt>, which returns the base command. As such, our redundant expression could be rewritten:</p>\n<pre>self.root['stash', 'save']\n</pre>\n</div>\n</div>\n<div id=\"the-management-file\">\n<h3><a href=\"#id18\" rel=\"nofollow\">The management file</a></h3>\n<p>In addition to the interface of custom executables, <tt>argcmdr</tt> endeavors to improve the generation and maintainability of non-executable but standardized files, intended for management of code development projects and operations.</p>\n<p>Similar to a project\u2019s <tt>Makefile</tt>, we might define our previous codebase-management file as the following Python module, <tt>manage.py</tt>:</p>\n<pre>import os\n\nfrom argcmdr import Local, main\n\nclass Management(Local):\n    \"\"\"manage deployment\"\"\"\n\n    def __init__(self, parser):\n        parser.add_argument(\n            '-e', '--env',\n            choices=('development', 'production'),\n            default='development',\n            help=\"target environment\",\n        )\n\n    class Build(Local):\n        \"\"\"build app\"\"\"\n\n        def prepare(self, args):\n            req_path = os.path.join('requirements', f'{args.env}.txt')\n            yield self.local['pip']['-r', req_path]\n\n    class Deploy(Local):\n        \"\"\"deploy app\"\"\"\n\n        def prepare(self, args):\n            yield self.local['eb']['deploy', args.env]\n</pre>\n<p>Unlike our original script, <tt>manage</tt>, <tt>manage.py</tt> is not executable, and need define neither an initial shebang line nor a final <tt>__name__ == '__main__'</tt> block.</p>\n<p>Rather, <tt>argcmdr</tt> supplies its own, general-purpose <tt>manage</tt> executable command, which loads Commands from any <tt>manage.py</tt> in the current directory, or as specified by option <tt><span class=\"pre\">--manage-file</span> PATH</tt>. As such, the usage and functionality of our <tt>manage.py</tt>, as invoked via argcmdr\u2019s installed <tt>manage</tt> command, is identical to our original <tt>manage</tt>. We need only ensure that <tt>argcmdr</tt> is installed, in order to make use of it to manage any or all project tasks, in a standard way, with even less boilerplate.</p>\n<div id=\"entrypoint-definition\">\n<h4><a href=\"#id19\" rel=\"nofollow\">Entrypoint definition</a></h4>\n<p>In lieu of an explicitly defined execution path, <tt>manage</tt> infers the base command \u2013 and hence the entrypoint \u2013 of the <tt>manage.py</tt> management file module.</p>\n<p>The entrypoint of a management file defining \u2013 at the module level \u2013 only one <tt>Command</tt>, or multiple commands but only one <tt>RootCommand</tt>, is assumed to be this one command. Otherwise, the intended entrypoint must be decorated with <tt>@entrypoint</tt>:</p>\n<pre>from argcmdr import entrypoint, RootCommand\n\nclass GoodCommand(RootCommand):\n\n    def good_function(self):\n        ...\n\n@entrypoint\nclass CommandEhh(GoodCommand):\n\n    def __call__(self):\n        self.good_function()\n        ...\n\n@CommandEhh.register\nclass CommandBeh(GoodCommand):\n\n    def __call__(self):\n        self.good_function()\n        ...\n</pre>\n<p>We may infer from the above that <tt>GoodCommand</tt> is merely a base class extension, and that the module\u2019s CLI begins with the most \u201croot\u201d command, <tt>CommandEhh</tt>, which is extended by <tt>CommandBeh</tt>. However, rather than go out on a limb, when presented with these three subclasses of <tt>Command</tt> and <tt>RootCommand</tt>, <tt>argcmdr</tt> requires that the intended entrypoint is explicitly marked.</p>\n<p>Note, however, that only commands declared at the module, or \u201ctop\u201d level, are considered potential entrypoints:</p>\n<pre>class CommandEhh(Command):\n\n    class CommandBeh(Command):\n\n        ...\n</pre>\n<p>Presented with a module containing only the above commands, <tt>argcmdr</tt> would identify <tt>CommandEhh</tt> as the entrypoint; <tt>CommandBeh</tt> would never be considered, even if decorated <tt>@entrypoint</tt>.</p>\n</div>\n<div id=\"the-management-package\">\n<h4><a href=\"#id20\" rel=\"nofollow\">The management package</a></h4>\n<p>Python <em>packages</em>, no less than stand-alone modules, may also be defined for use with the <tt>manage</tt> command, to aid in maintenance and development.</p>\n<p>Consider the following example directory layout:</p>\n<pre>manage/\n\u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 cloud.py\n\u251c\u2500\u2500 db.py\n\u251c\u2500\u2500 main.py\n\u251c\u2500\u2500 morale.py\n\u251c\u2500\u2500 server.py\n\u2514\u2500\u2500 util.py\n</pre>\n<p><tt>argcmdr</tt> will load the above top-level Python module, <tt>manage</tt>, just as well as it would the <tt>manage</tt> module defined by a <tt>manage.py</tt> file, (whether these are available on the <tt>PYTHONPATH</tt> or not).</p>\n<p>Furthermore, detecting that <em>this</em> <tt>manage</tt> is in fact a package, <tt>argcmdr</tt> will <em>automatically</em> and <em>recursively</em> load all of the modules this package contains.</p>\n<p>This allows the developer to provide <tt>argcmdr</tt> the minimum that it requires at <tt>manage/__init__.py</tt> \u2013 access to an interface entrypoint, <em>i.e.</em> the base <tt>Command</tt> \u2013 and to organize the development of that interface in whatever maintainable way suits them.</p>\n<p>To wit, the developer simply might write, in <tt>manage/__init__.py</tt>:</p>\n<pre>from .main import Main  # noqa\n</pre>\n<p>(\u2026And they will have no need of the <tt>@entrypoint</tt> decorator, as <tt>argcmdr</tt> will only see the one top-level command.)</p>\n<p>Of course, that top-level command might have been defined in <tt>__init__.py</tt>, or as you might prefer, in <tt>manage/main.py</tt>:</p>\n<pre>from argcmdr import RootCommand\n\nclass Main(RootCommand):\n    \"\"\"your one-stop shop for devops\"\"\"\n\n    ...\n</pre>\n<p>And, each subcommand may be defined in a submodule, such as <tt>manage/cloud.py</tt>:</p>\n<pre>from argcmdr import Command\n\nfrom .main import Main\n\n@Main.register\nclass Cloud(Command):\n    \"\"\"manage cloud computing resources\"\"\"\n\n    ...\n</pre>\n<p>Thanks to automatic loading, the <tt>Cloud</tt> subcommand, (which will resolve to <tt>manage cloud</tt>), will be picked up, without additional boilerplate and without needing to consider circular imports.</p>\n<p>To disable automatic submodule loading, set the following in <tt>manage/__init__.py</tt>:</p>\n<pre>__auto_init_package__ = False\n</pre>\n<p>And to make (custom) use of this feature, see: <tt>argcmdr.init_package()</tt>.</p>\n</div>\n<div id=\"bootstrapping\">\n<h4><a href=\"#id21\" rel=\"nofollow\">Bootstrapping</a></h4>\n<p>To ensure that such a friendly \u2013 and <em>relatively</em> high-level \u2013 project requirement as <tt>argcmdr</tt> is satisfied, consider the expressly low-level utility <a href=\"https://github.com/dssg/install-cli\" rel=\"nofollow\">install-cli</a>, with which to guide contributors through the process of provisioning your project\u2019s most basic requirements.</p>\n</div>\n</div>\n<div id=\"shell-completion\">\n<h3><a href=\"#id22\" rel=\"nofollow\">Shell completion</a></h3>\n<p><tt>argcmdr</tt> supports shell command argument completion via <tt>argcomplete</tt> (see <a href=\"https://argcomplete.readthedocs.io/\" rel=\"nofollow\">argcomplete</a>).</p>\n<p>As explained by its documentation, your user (perhaps in executing the installation of your command), may enable argument completion, either:</p>\n<ul>\n<li>specifically for your shell command</li>\n<li>or generally for any script containing the string <strong>PYTHON_ARGCOMPLETE_OK</strong> in its first 1024 bytes</li>\n</ul>\n<p>For flexibility, (and, <em>e.g.</em>, in support of installation into virtual environments, or otherwise where system- or user-global installation is undesirable or impossible), <tt>argcmdr</tt> <em>does not</em> currently insist on a particular scheme to enable argument completion.</p>\n<p>Rather, for example, to enable argument completion system-wide, specifically for the <tt>manage</tt> command (provisioned by <tt>argcmdr</tt>), you might execute the following from a Bash shell (as the root user):</p>\n<pre>register-python-argcomplete --shell bash manage &gt; /etc/bash_completion.d/python-argcomplete-manage.sh\n</pre>\n<p>Alternatively, the same argument completion may be enabled, but only for the current user:</p>\n<pre>mkdir -p ~/.bash_completion.d\nregister-python-argcomplete --shell bash manage &gt; ~/.bash_completion.d/python-argcomplete-manage.sh\n</pre>\n<p>Only in the latter case, the user must have the file <tt><span class=\"pre\">~/.bash_completion</span></tt>, including contents of the following form:</p>\n<pre>if [ -d ~/.bash_completion.d/ ] &amp;&amp; [ ! -z \"$(ls ~/.bash_completion.d/)\" ]; then\n  for bcfile in ~/.bash_completion.d/*; do\n    . \"$bcfile\"\n  done\nfi\n</pre>\n<p>(Bash will load this file automatically.)</p>\n<p>In the case that neither system-wide nor user-only installation is appropriate, the same argument completion may be enabled, but only for the current shell:</p>\n<pre>eval \"$(register-python-argcomplete --shell bash manage)\"\n</pre>\n<p>Regardless of the method, having so enabled argument completion (for your command), in your shell, <tt>argcmdr</tt> will handle the rest, generating completion suggestions based on your command definition.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4150918, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "46a0322c476db18de416ca1847c30716", "sha256": "e1ee57cfa0891156e4c7aa4d6b94db15a3ca923f8749e544cc7f1be7fcaafe80"}, "downloads": -1, "filename": "argcmdr-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "46a0322c476db18de416ca1847c30716", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 17548, "upload_time": "2018-03-15T00:53:31", "upload_time_iso_8601": "2018-03-15T00:53:31.748743Z", "url": "https://files.pythonhosted.org/packages/25/61/87c60defe9d1d622d2c6de502955ae7c2415b43a99c6a10bb36e18ca438d/argcmdr-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e0d1df357df0b55b6d04b12737f813b1", "sha256": "e7c4b18727697ad558c41d78811867d31e0f0db47e254780f6e34865777ed575"}, "downloads": -1, "filename": "argcmdr-0.1.0.tar.gz", "has_sig": false, "md5_digest": "e0d1df357df0b55b6d04b12737f813b1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 14047, "upload_time": "2018-03-15T00:53:33", "upload_time_iso_8601": "2018-03-15T00:53:33.866445Z", "url": "https://files.pythonhosted.org/packages/71/2a/37ec5333104f3756260b4856b268032e2ca6421dd01a1bfef982941e3f59/argcmdr-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "837373a1ea1aefbdc00a65a59bcb4c80", "sha256": "3ba936f2f1c9778406bf515e15d6cb8054d420647713611c554165e61f7e2245"}, "downloads": -1, "filename": "argcmdr-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "837373a1ea1aefbdc00a65a59bcb4c80", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 17555, "upload_time": "2018-03-15T04:38:48", "upload_time_iso_8601": "2018-03-15T04:38:48.509735Z", "url": "https://files.pythonhosted.org/packages/1b/08/cf8957a6e0b82f438fbf23dd07a591cacce9898702860e7baf8e9df5dc23/argcmdr-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "7cc0f981787ff750e51d6ae56a9d6483", "sha256": "2fff9b5c740c409328f3aca032128752fda650b97c564354728440a4f384b0ee"}, "downloads": -1, "filename": "argcmdr-0.1.1.tar.gz", "has_sig": false, "md5_digest": "7cc0f981787ff750e51d6ae56a9d6483", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 14054, "upload_time": "2018-03-15T04:38:49", "upload_time_iso_8601": "2018-03-15T04:38:49.981045Z", "url": "https://files.pythonhosted.org/packages/3c/06/56c15b3684aae0ba082f0fb8e19d09dacd94fa87836526d1a4d9d05de1ca/argcmdr-0.1.1.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "74e2192779c0a69ca02f74e71aebfd8c", "sha256": "2e5e438a4da861f1f6dcab85bae608a8fb1bf60969b9a3975d34a4dae8ecb19b"}, "downloads": -1, "filename": "argcmdr-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "74e2192779c0a69ca02f74e71aebfd8c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 21739, "upload_time": "2018-03-15T22:35:45", "upload_time_iso_8601": "2018-03-15T22:35:45.838800Z", "url": "https://files.pythonhosted.org/packages/bf/39/47efd85be0f61a03c7774ef5f4388c1fe6e9a4de9be70c27a7d3b5498756/argcmdr-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9cdf4b1d645688955c96b82116c1a241", "sha256": "31891c31b4b3fb4e7c76f8fb33c641ee7c30cc1545f570a540762777c0dc3147"}, "downloads": -1, "filename": "argcmdr-0.2.0.tar.gz", "has_sig": false, "md5_digest": "9cdf4b1d645688955c96b82116c1a241", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 18937, "upload_time": "2018-03-15T22:35:47", "upload_time_iso_8601": "2018-03-15T22:35:47.353590Z", "url": "https://files.pythonhosted.org/packages/1e/89/2160b8f559e47a428201f5649a8f3f5ceb695a4121e2ff1c34fa4338dde0/argcmdr-0.2.0.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "271d426cabb9b0399e6693e67cbb26c7", "sha256": "7a9897ccc6942377c6d0c21cb428cb3b4d481a4769a34cb4bfbcd2723d3daf7f"}, "downloads": -1, "filename": "argcmdr-0.3.0-py3-none-any.whl", "has_sig": false, "md5_digest": "271d426cabb9b0399e6693e67cbb26c7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 22088, "upload_time": "2018-04-05T23:33:45", "upload_time_iso_8601": "2018-04-05T23:33:45.780200Z", "url": "https://files.pythonhosted.org/packages/14/f6/e652545dc24f802783fec8e86801de69bd1335e2e9ddc316f799ebd47e40/argcmdr-0.3.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "75ba560f746c6a911613fef11d793cdc", "sha256": "35a53b7982cbaf63f2d561e00250a5eac2dd4ab9f88504b737d5875c1477daaf"}, "downloads": -1, "filename": "argcmdr-0.3.0.tar.gz", "has_sig": false, "md5_digest": "75ba560f746c6a911613fef11d793cdc", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 21382, "upload_time": "2018-04-05T23:33:46", "upload_time_iso_8601": "2018-04-05T23:33:46.726662Z", "url": "https://files.pythonhosted.org/packages/0d/b8/8ddab971092a0e615b18f4e442bacba97a3612f793e5d398c4047254bf8f/argcmdr-0.3.0.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "8d373afdad9c3649b66e0b43aaa09565", "sha256": "f9039f1a5263c641256cf89cea57811bd6072a99043f89e1614b46707155d591"}, "downloads": -1, "filename": "argcmdr-0.4.0-py3-none-any.whl", "has_sig": false, "md5_digest": "8d373afdad9c3649b66e0b43aaa09565", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 28322, "upload_time": "2018-04-10T20:47:49", "upload_time_iso_8601": "2018-04-10T20:47:49.251309Z", "url": "https://files.pythonhosted.org/packages/27/56/529ddc8ec33e7c06f45908dea2157ee1defb3375c51ed2e110fa3409cc51/argcmdr-0.4.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a5524fe53a2d8a04f90fc753ec07d5ad", "sha256": "5ee603daa704c830c60d932a06af4ab8763cb774bda21ee5bbbec59ba6b1b483"}, "downloads": -1, "filename": "argcmdr-0.4.0.tar.gz", "has_sig": false, "md5_digest": "a5524fe53a2d8a04f90fc753ec07d5ad", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 37680, "upload_time": "2018-04-10T20:47:50", "upload_time_iso_8601": "2018-04-10T20:47:50.217771Z", "url": "https://files.pythonhosted.org/packages/c2/84/8b9171500cc492dbd79505ec9a43e967af9ae2ce45191fe0edd15161f1c3/argcmdr-0.4.0.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "de97ad1771f1eee41b49b28e76e93a32", "sha256": "7240b1c1e1176917a16054ae7f8839d83a952b193a80978bf42d2d08752d8119"}, "downloads": -1, "filename": "argcmdr-0.5.0-py3-none-any.whl", "has_sig": false, "md5_digest": "de97ad1771f1eee41b49b28e76e93a32", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 28932, "upload_time": "2018-04-11T17:50:22", "upload_time_iso_8601": "2018-04-11T17:50:22.943450Z", "url": "https://files.pythonhosted.org/packages/e8/9d/28ad318e24b7fb1a73f3a41b9bc31611b59e5d04a68db550ee94e79663cf/argcmdr-0.5.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e3568fda49081ae58d9d82f4fe42562d", "sha256": "fb11a304abf81ef380e20879d95afc3124c115c41b1c16080e0ce111c9e95997"}, "downloads": -1, "filename": "argcmdr-0.5.0.tar.gz", "has_sig": false, "md5_digest": "e3568fda49081ae58d9d82f4fe42562d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 38783, "upload_time": "2018-04-11T17:50:23", "upload_time_iso_8601": "2018-04-11T17:50:23.983636Z", "url": "https://files.pythonhosted.org/packages/1f/71/c4cf5047f19667ac43e400640dbf0812e1d93a2f9ee34b8d8fd3635b069e/argcmdr-0.5.0.tar.gz", "yanked": false}], "0.6.0": [{"comment_text": "", "digests": {"md5": "88a668f6787e3ec90b455b4a4d8e75f3", "sha256": "22750e8c010b733fd6624b21e0d0d1a6c962914feaabb1e6314a1e95bd5f5faa"}, "downloads": -1, "filename": "argcmdr-0.6.0-py3-none-any.whl", "has_sig": false, "md5_digest": "88a668f6787e3ec90b455b4a4d8e75f3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 32276, "upload_time": "2018-08-08T22:13:02", "upload_time_iso_8601": "2018-08-08T22:13:02.759898Z", "url": "https://files.pythonhosted.org/packages/82/39/53deff448c855ff69a9f2ebe3b5e74bfb90117dff87b182230e6ffd93432/argcmdr-0.6.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6fe0c934acdb4f7ac4d236231446325d", "sha256": "785375f2433e218e950ac7105c3828ea28f2a20fc6f1b3aaa30be0c5d976759b"}, "downloads": -1, "filename": "argcmdr-0.6.0.tar.gz", "has_sig": false, "md5_digest": "6fe0c934acdb4f7ac4d236231446325d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 44201, "upload_time": "2018-08-08T22:13:04", "upload_time_iso_8601": "2018-08-08T22:13:04.231028Z", "url": "https://files.pythonhosted.org/packages/30/dd/351cb9e77d85422dd62e27db9d51bb9cdbd7ecabc75ec63d7a7375e004a9/argcmdr-0.6.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "88a668f6787e3ec90b455b4a4d8e75f3", "sha256": "22750e8c010b733fd6624b21e0d0d1a6c962914feaabb1e6314a1e95bd5f5faa"}, "downloads": -1, "filename": "argcmdr-0.6.0-py3-none-any.whl", "has_sig": false, "md5_digest": "88a668f6787e3ec90b455b4a4d8e75f3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 32276, "upload_time": "2018-08-08T22:13:02", "upload_time_iso_8601": "2018-08-08T22:13:02.759898Z", "url": "https://files.pythonhosted.org/packages/82/39/53deff448c855ff69a9f2ebe3b5e74bfb90117dff87b182230e6ffd93432/argcmdr-0.6.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6fe0c934acdb4f7ac4d236231446325d", "sha256": "785375f2433e218e950ac7105c3828ea28f2a20fc6f1b3aaa30be0c5d976759b"}, "downloads": -1, "filename": "argcmdr-0.6.0.tar.gz", "has_sig": false, "md5_digest": "6fe0c934acdb4f7ac4d236231446325d", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 44201, "upload_time": "2018-08-08T22:13:04", "upload_time_iso_8601": "2018-08-08T22:13:04.231028Z", "url": "https://files.pythonhosted.org/packages/30/dd/351cb9e77d85422dd62e27db9d51bb9cdbd7ecabc75ec63d7a7375e004a9/argcmdr-0.6.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:17:19 2020"}