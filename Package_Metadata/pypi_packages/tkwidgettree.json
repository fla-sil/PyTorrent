{"info": {"author": "Staffan Thomen", "author_email": "duck@shangtai.net", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Programming Language :: Python :: 3"], "description": "TkWidgetTree\n============\n\nBuild trees of Tk widgets from a dict structure or use the FileParser class\nto load them from a JSON file.\n\nDetails\n-------\n\nTkWidgetTree is a wrapper for the various Tk widgets (Frames, Buttons, Menu:s,\netc.), it is most conveninetly invoked with the TkWidgetTree.from_dict(tree,\nroot) static method, it builds a tree structure of TkWidgetTree objects from\nnested dicts with the input to the TkWidgetTree constructor.\n\nThe parameters to the constructor are:\n\nname\t\t- The Tk widget class to create or the name of the widget\nparent*\t\t- The Tk widget that will be used as the parent\n\t\t  (tk.Button(parent, ...)\nid*\t\t- A tree-unique name for this widget, for when you want to\n\t\t  find it for setting callbacks or fetching values (or whatever)\noptions*\t- A dict containing the options passed to the widget creation\n\t\t  (tk.Button(parent, **options))\npack*\t\t- A dict containing the options to give to the pack method. This\n\t\t  class only supports the pack arrangement method for the\n\t\t  moment.\nchildren*\t- A list of child TkWidgetTree:s. The widgets in this list will\n\t\t  get this widget set as the parent when render()ing.\n\n[*] Optional\n\nYou can then run the render() method on the root of your tree and they will\nbe recursively created. Once you've rendred all the widgets, you can set up\nyour callbacks by first finding your buttons/sliders whatnot by calling the\nfind method and using the TkWidgetTree.widget parameter to further set up\nthe widgets.\n\n...\nconfig={\n\t'name': 'Frame',\n\t'children': [\n\t\t{\n\t\t\t'id': 'mybutton',\n\t\t\t'name': 'Button',\n\t\t\t'options': { 'text': 'Hello World' },\n\t\t\t'pack: { 'side': tk.LEFT }\n\t\t}\n\t]\n}\n\ntree = TkWidgetTree.from_dict(config)\ntree.render()\n\nbutton = tree.find('mybutton')\n\nbutton.widget.config(callback=do_stuff)\n\ntree.mainloop()\n...\n\nLoading from a file\n-------------------\n\nBut keeping a chunky dict of your application in the source is still pretty\nclunky, so why not put the structure in a file instead? That's where the\nFileParser class comes in. It essentially reads a JSON-serialized version of\nthe above structure, with one small twist; any Tk constants you might want to\nuse are set as strings, with the key prefixed by an @-sign.\n\n... \"pack\": { \"@side\": \"LEFT\" } ...", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/sthomen/tkwidgettree", "keywords": "Tk tkinter widget builder", "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "tkwidgettree", "package_url": "https://pypi.org/project/tkwidgettree/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/tkwidgettree/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/sthomen/tkwidgettree"}, "release_url": "https://pypi.org/project/tkwidgettree/1.0.0b2/", "requires_dist": null, "requires_python": null, "summary": "Convenience class for building Tk widgets trees from a dict or a JSON file", "version": "1.0.0b2", "yanked": false, "html_description": "<div class=\"project-description\">\n            TkWidgetTree<br>============<br><br>Build trees of Tk widgets from a dict structure or use the FileParser class<br>to load them from a JSON file.<br><br>Details<br>-------<br><br>TkWidgetTree is a wrapper for the various Tk widgets (Frames, Buttons, Menu:s,<br>etc.), it is most conveninetly invoked with the TkWidgetTree.from_dict(tree,<br>root) static method, it builds a tree structure of TkWidgetTree objects from<br>nested dicts with the input to the TkWidgetTree constructor.<br><br>The parameters to the constructor are:<br><br>name\t\t- The Tk widget class to create or the name of the widget<br>parent*\t\t- The Tk widget that will be used as the parent<br>\t\t  (tk.Button(parent, ...)<br>id*\t\t- A tree-unique name for this widget, for when you want to<br>\t\t  find it for setting callbacks or fetching values (or whatever)<br>options*\t- A dict containing the options passed to the widget creation<br>\t\t  (tk.Button(parent, **options))<br>pack*\t\t- A dict containing the options to give to the pack method. This<br>\t\t  class only supports the pack arrangement method for the<br>\t\t  moment.<br>children*\t- A list of child TkWidgetTree:s. The widgets in this list will<br>\t\t  get this widget set as the parent when render()ing.<br><br>[*] Optional<br><br>You can then run the render() method on the root of your tree and they will<br>be recursively created. Once you've rendred all the widgets, you can set up<br>your callbacks by first finding your buttons/sliders whatnot by calling the<br>find method and using the TkWidgetTree.widget parameter to further set up<br>the widgets.<br><br>...<br>config={<br>\t'name': 'Frame',<br>\t'children': [<br>\t\t{<br>\t\t\t'id': 'mybutton',<br>\t\t\t'name': 'Button',<br>\t\t\t'options': { 'text': 'Hello World' },<br>\t\t\t'pack: { 'side': tk.LEFT }<br>\t\t}<br>\t]<br>}<br><br>tree = TkWidgetTree.from_dict(config)<br>tree.render()<br><br>button = tree.find('mybutton')<br><br>button.widget.config(callback=do_stuff)<br><br>tree.mainloop()<br>...<br><br>Loading from a file<br>-------------------<br><br>But keeping a chunky dict of your application in the source is still pretty<br>clunky, so why not put the structure in a file instead? That's where the<br>FileParser class comes in. It essentially reads a JSON-serialized version of<br>the above structure, with one small twist; any Tk constants you might want to<br>use are set as strings, with the key prefixed by an @-sign.<br><br>... \"pack\": { \"@side\": \"LEFT\" } ...\n          </div>"}, "last_serial": 2667919, "releases": {"1.0.0b1": [{"comment_text": "", "digests": {"md5": "97be2bf2bd3962c759ef8307cc6df326", "sha256": "9cf50d59bc7ee710aac79a05fea96914b9518fb70513dfc5eff1a7175d72490f"}, "downloads": -1, "filename": "tkwidgettree-1.0.0b1.tar.gz", "has_sig": false, "md5_digest": "97be2bf2bd3962c759ef8307cc6df326", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3515, "upload_time": "2017-02-21T19:14:23", "upload_time_iso_8601": "2017-02-21T19:14:23.540046Z", "url": "https://files.pythonhosted.org/packages/2c/c1/30c55c11e107cffc0299a82237ade9a5b74d7c0fa5e6a4ef67026eb9e313/tkwidgettree-1.0.0b1.tar.gz", "yanked": false}], "1.0.0b2": [{"comment_text": "", "digests": {"md5": "1a23069b2c9ae39239906bf90c29830e", "sha256": "a96d37492f3ce7b40986fd3573055867604196ca06e508d580c2713d12034317"}, "downloads": -1, "filename": "tkwidgettree-1.0.0b2.tar.gz", "has_sig": false, "md5_digest": "1a23069b2c9ae39239906bf90c29830e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3643, "upload_time": "2017-02-21T19:29:37", "upload_time_iso_8601": "2017-02-21T19:29:37.298431Z", "url": "https://files.pythonhosted.org/packages/bf/0f/badf789a3976fbcf01de456b53af452d43c4d4d9282a939b15e401cecb31/tkwidgettree-1.0.0b2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1a23069b2c9ae39239906bf90c29830e", "sha256": "a96d37492f3ce7b40986fd3573055867604196ca06e508d580c2713d12034317"}, "downloads": -1, "filename": "tkwidgettree-1.0.0b2.tar.gz", "has_sig": false, "md5_digest": "1a23069b2c9ae39239906bf90c29830e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3643, "upload_time": "2017-02-21T19:29:37", "upload_time_iso_8601": "2017-02-21T19:29:37.298431Z", "url": "https://files.pythonhosted.org/packages/bf/0f/badf789a3976fbcf01de456b53af452d43c4d4d9282a939b15e401cecb31/tkwidgettree-1.0.0b2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:52:31 2020"}