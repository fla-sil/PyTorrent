{"info": {"author": "Brandon Craig Rhodes", "author_email": "brandon@rhodesmill.org", "bugtrack_url": null, "classifiers": [], "description": "A few minutes ago,\nmy fingers were poised for a moment above the keyboard\nas I prepared to backport the essential ``match_hostname()`` function\n(without which the Secure Sockets Layer is not actually *secure!*)\nfrom the Python\u00a03.2 version of the ``ssl`` Standard Library\nto earlier versions of Python.\nSuddenly, I paused: what would I call the new distribution\nthat I created in the Package Index to hold this small function?\n\nIt seemed a shame to consume an entire top-level name\nin the Package Index for what is, after all, a stopgap measure\nuntil older versions of Python are one day retired.\n\nAnd so I conceived this ``backports`` namespace package.\nIt reserves a namespace beneath which we can happily place\nall of the various features that we want to cut-and-paste\nfrom later Python versions.\nI hope that this will provide two benefits:\n\n1. It should provide greater sanity, and a bit more organization,\n   in the Package Index.\n\n2. When you are ready to port a Python application\n   to a new version of Python,\n   you can search the code for any ``import`` statements\n   that name a ``backports`` package,\n   and remove the backports for features that have now \u201carrived\u201d\n   in the version of Python to which you are upgrading.\n\nI have considered calling for all ``backports`` packages\nto issue a warning upon import if they detect that they are\nrunning under a version of Python that has now gained the feature\nthey offer, but I think that will be unkind to actual users,\nsince the most widespread versions of Python today still\ndisplay warnings by default.\n\nBuilding your own backports module\n----------------------------------\n\nPlacing a module of your own inside of the ``backports`` namespace\nrequires only a few simple steps. First, set your project up like::\n\n    project/\n    project/setup.py\n    project/backports/\n    project/backports/__init__.py   <--- SPECIAL - see below!\n    project/backports/yourpkg/\n    project/backports/yourpkg/__init__.py\n    project/backports/yourpkg/foo.py\n    project/backports/yourpkg/bar.py\n\nThis places your own package inside of the ``backports`` namespace,\nso your package and its modules can be imported like this::\n\n    import backports.yourpkg\n    import backports.yourpkg.foo\n\nThe one **absolutely essential rule** is that the ``__init__.py`` inside\nof the ``backports`` directory itself **must** have the following code\nas its content::\n\n    # A Python \"namespace package\" http://www.python.org/dev/peps/pep-0382/\n    # This always goes inside of a namespace package's __init__.py\n\n    from pkgutil import extend_path\n    __path__ = extend_path(__path__, __name__)\n\nIf you fail to include this code, then the namespace package might fail\nto see all of the packages beneath it, and ``import`` statements might\nreturn errors.\n\nA live example of a package that implements all of this can be\ndownloaded from the Python Package Index:\n\nhttp://pypi.python.org/pypi/backports.ssl_match_hostname/3.2a3\n\nWhat if the feature is present?\n-------------------------------\n\nAn issue on which I am undecided is whether a ``backports`` package,\nif it finds itself on a modern enough version of Python,\nshould simply import the \u201creal\u201d version of its feature\nfrom the Standard Library instead of offering the replacement.\nMy guess is that this is *not* a good idea,\nbecause if\u00a0\u2014 for some reason\u00a0\u2014 an incompatibility crops up\nbewteen the tweaked code in a backport\nand the official code in the modern Standard Library,\nthen it would be nice for developers using the backport\nto be faced with that breakage when they themselves\ntry removing the backport,\ninstead of being faced with it simply because a user\ntries running their program on more modern version of Python.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://bitbucket.org/brandon/backports", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "backports", "package_url": "https://pypi.org/project/backports/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/backports/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://bitbucket.org/brandon/backports"}, "release_url": "https://pypi.org/project/backports/1.0/", "requires_dist": null, "requires_python": null, "summary": "Namespace for backported Python features", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>A few minutes ago,\nmy fingers were poised for a moment above the keyboard\nas I prepared to backport the essential <tt>match_hostname()</tt> function\n(without which the Secure Sockets Layer is not actually <em>secure!</em>)\nfrom the Python\u00a03.2 version of the <tt>ssl</tt> Standard Library\nto earlier versions of Python.\nSuddenly, I paused: what would I call the new distribution\nthat I created in the Package Index to hold this small function?</p>\n<p>It seemed a shame to consume an entire top-level name\nin the Package Index for what is, after all, a stopgap measure\nuntil older versions of Python are one day retired.</p>\n<p>And so I conceived this <tt>backports</tt> namespace package.\nIt reserves a namespace beneath which we can happily place\nall of the various features that we want to cut-and-paste\nfrom later Python versions.\nI hope that this will provide two benefits:</p>\n<ol>\n<li>It should provide greater sanity, and a bit more organization,\nin the Package Index.</li>\n<li>When you are ready to port a Python application\nto a new version of Python,\nyou can search the code for any <tt>import</tt> statements\nthat name a <tt>backports</tt> package,\nand remove the backports for features that have now \u201carrived\u201d\nin the version of Python to which you are upgrading.</li>\n</ol>\n<p>I have considered calling for all <tt>backports</tt> packages\nto issue a warning upon import if they detect that they are\nrunning under a version of Python that has now gained the feature\nthey offer, but I think that will be unkind to actual users,\nsince the most widespread versions of Python today still\ndisplay warnings by default.</p>\n<div id=\"building-your-own-backports-module\">\n<h2>Building your own backports module</h2>\n<p>Placing a module of your own inside of the <tt>backports</tt> namespace\nrequires only a few simple steps. First, set your project up like:</p>\n<pre>project/\nproject/setup.py\nproject/backports/\nproject/backports/__init__.py   &lt;--- SPECIAL - see below!\nproject/backports/yourpkg/\nproject/backports/yourpkg/__init__.py\nproject/backports/yourpkg/foo.py\nproject/backports/yourpkg/bar.py\n</pre>\n<p>This places your own package inside of the <tt>backports</tt> namespace,\nso your package and its modules can be imported like this:</p>\n<pre>import backports.yourpkg\nimport backports.yourpkg.foo\n</pre>\n<p>The one <strong>absolutely essential rule</strong> is that the <tt>__init__.py</tt> inside\nof the <tt>backports</tt> directory itself <strong>must</strong> have the following code\nas its content:</p>\n<pre># A Python \"namespace package\" http://www.python.org/dev/peps/pep-0382/\n# This always goes inside of a namespace package's __init__.py\n\nfrom pkgutil import extend_path\n__path__ = extend_path(__path__, __name__)\n</pre>\n<p>If you fail to include this code, then the namespace package might fail\nto see all of the packages beneath it, and <tt>import</tt> statements might\nreturn errors.</p>\n<p>A live example of a package that implements all of this can be\ndownloaded from the Python Package Index:</p>\n<p><a href=\"http://pypi.python.org/pypi/backports.ssl_match_hostname/3.2a3\" rel=\"nofollow\">http://pypi.python.org/pypi/backports.ssl_match_hostname/3.2a3</a></p>\n</div>\n<div id=\"what-if-the-feature-is-present\">\n<h2>What if the feature is present?</h2>\n<p>An issue on which I am undecided is whether a <tt>backports</tt> package,\nif it finds itself on a modern enough version of Python,\nshould simply import the \u201creal\u201d version of its feature\nfrom the Standard Library instead of offering the replacement.\nMy guess is that this is <em>not</em> a good idea,\nbecause if\u00a0\u2014 for some reason\u00a0\u2014 an incompatibility crops up\nbewteen the tweaked code in a backport\nand the official code in the modern Standard Library,\nthen it would be nice for developers using the backport\nto be faced with that breakage when they themselves\ntry removing the backport,\ninstead of being faced with it simply because a user\ntries running their program on more modern version of Python.</p>\n</div>\n\n          </div>"}, "last_serial": 2209497, "releases": {"1.0": []}, "urls": [], "timestamp": "Thu May  7 18:15:08 2020"}