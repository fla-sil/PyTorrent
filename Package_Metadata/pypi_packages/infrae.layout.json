{"info": {"author": "Sylvain Viollon", "author_email": "info@infrae.com", "bugtrack_url": null, "classifiers": ["Environment :: Web Environment", "Framework :: Zope2", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Programming Language :: Python", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "=============\ninfrae.layout\n=============\n\n``infrae.layout`` defines a way to write view that can reuse an\nexisting defined layout in Zope 2. It is similar to `megrok.layout`_,\nand work the same way, with some additions.\n\nAPI\n===\n\nYou can define a *Layout* that will be used by a *Page*. A *Page* is\na view and behave the same way. A page will look for Layout and will\nrender inside it.\n\nBoth *Page* and *Layout* can be rendered by either a ``render``\nmethod, or by an associated template, exactly like a Grok view.\n\nA *Layout* is found by adapting the request and the content:\nyou can register layouts for your skin, then for a specific content.\n\nIf this is not sufficient, a page can use the Grok directive\n``layout`` to directly specify its type of Layout to use. While\ndefining your layout, you can use the same directive to declare which\nlayout a type belongs to. For instance if you have a skin\n``ICorpSkin``::\n\n\n  from infae.layout import layout, Layout, ILayout, Page\n  from five import grok\n\n  from corp.skin import ICorpSkin\n\n  grok.skin(ICorpSkin)\n\n\n  class ViewLayout(Layout):\n\n     def render(self):\n         return u'View %s' % self.view.content()\n\n  class Index(Page):\n\n     def render(self):\n         return self.context.title()\n\n\nNow if on the same content you want an edition layout for instance::\n\n   class IEditionLayout(ILayout)\n       \"\"\"Layout to edit content\n       \"\"\"\n\n   class EditionLayout(Layout):\n       layout(IEditionLayout)\n\n       def render(self):\n           return u'Edit %s' % self.view.content()\n\n   class Edit(Page):\n      layout(IEditionLayout)\n\n      def render(self):\n           return self.context.title()\n\n\nIf the above mecanism is not flexible enough for your application, you can\nwrite an adapter on the request and your content that provides\n``ILayoutFactory``.\nThe adapter will allow you to code the logic to select any layout you want.\n\n\n.. _megrok.layout: http://pypi.python.org/pypi/megrok.layout\n\nCHANGES\n=======\n\n1.0 (2010/07/16)\n----------------\n\n* Initial release.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://svn.infrae.com/infrae.layout/trunk", "keywords": "zope2 layout silva infrae", "license": "ZPL", "maintainer": null, "maintainer_email": null, "name": "infrae.layout", "package_url": "https://pypi.org/project/infrae.layout/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/infrae.layout/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://svn.infrae.com/infrae.layout/trunk"}, "release_url": "https://pypi.org/project/infrae.layout/1.0/", "requires_dist": null, "requires_python": null, "summary": "Layout system for Zope 2", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><tt>infrae.layout</tt> defines a way to write view that can reuse an\nexisting defined layout in Zope 2. It is similar to <a href=\"http://pypi.python.org/pypi/megrok.layout\" rel=\"nofollow\">megrok.layout</a>,\nand work the same way, with some additions.</p>\n<div id=\"api\">\n<h2>API</h2>\n<p>You can define a <em>Layout</em> that will be used by a <em>Page</em>. A <em>Page</em> is\na view and behave the same way. A page will look for Layout and will\nrender inside it.</p>\n<p>Both <em>Page</em> and <em>Layout</em> can be rendered by either a <tt>render</tt>\nmethod, or by an associated template, exactly like a Grok view.</p>\n<p>A <em>Layout</em> is found by adapting the request and the content:\nyou can register layouts for your skin, then for a specific content.</p>\n<p>If this is not sufficient, a page can use the Grok directive\n<tt>layout</tt> to directly specify its type of Layout to use. While\ndefining your layout, you can use the same directive to declare which\nlayout a type belongs to. For instance if you have a skin\n<tt>ICorpSkin</tt>:</p>\n<pre>from infae.layout import layout, Layout, ILayout, Page\nfrom five import grok\n\nfrom corp.skin import ICorpSkin\n\ngrok.skin(ICorpSkin)\n\n\nclass ViewLayout(Layout):\n\n   def render(self):\n       return u'View %s' % self.view.content()\n\nclass Index(Page):\n\n   def render(self):\n       return self.context.title()\n</pre>\n<p>Now if on the same content you want an edition layout for instance:</p>\n<pre>class IEditionLayout(ILayout)\n    \"\"\"Layout to edit content\n    \"\"\"\n\nclass EditionLayout(Layout):\n    layout(IEditionLayout)\n\n    def render(self):\n        return u'Edit %s' % self.view.content()\n\nclass Edit(Page):\n   layout(IEditionLayout)\n\n   def render(self):\n        return self.context.title()\n</pre>\n<p>If the above mecanism is not flexible enough for your application, you can\nwrite an adapter on the request and your content that provides\n<tt>ILayoutFactory</tt>.\nThe adapter will allow you to code the logic to select any layout you want.</p>\n</div>\n<div id=\"changes\">\n<h2>CHANGES</h2>\n<h2 id=\"id1\"><span class=\"section-subtitle\">1.0 (2010/07/16)</span></h2>\n<ul>\n<li>Initial release.</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 945359, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "2d9ca0061206917af38098474a310322", "sha256": "1b93705a82d0ac2f3a38b3a35244cac12ff21efe332dd2f16bb647d1b03b9aaa"}, "downloads": -1, "filename": "infrae.layout-1.0.tar.gz", "has_sig": false, "md5_digest": "2d9ca0061206917af38098474a310322", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4657, "upload_time": "2010-07-16T10:13:39", "upload_time_iso_8601": "2010-07-16T10:13:39.267131Z", "url": "https://files.pythonhosted.org/packages/36/31/f81e73df81aa4e81c4af66b8467d64127743fbd38accd600c66866995899/infrae.layout-1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2d9ca0061206917af38098474a310322", "sha256": "1b93705a82d0ac2f3a38b3a35244cac12ff21efe332dd2f16bb647d1b03b9aaa"}, "downloads": -1, "filename": "infrae.layout-1.0.tar.gz", "has_sig": false, "md5_digest": "2d9ca0061206917af38098474a310322", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4657, "upload_time": "2010-07-16T10:13:39", "upload_time_iso_8601": "2010-07-16T10:13:39.267131Z", "url": "https://files.pythonhosted.org/packages/36/31/f81e73df81aa4e81c4af66b8467d64127743fbd38accd600c66866995899/infrae.layout-1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:56:01 2020"}