{"info": {"author": "Niriel", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.8", "Topic :: Software Development", "Topic :: Utilities"], "description": "==========\nYummyCurry\n==========\n\nAutomatic currying, uncurrying and application of functions and methods\n=======================================================================\n\n\n\nFeatures\n--------\n\n* Decorators for functions, methods and class methods.\n* Supports positional, positional-only, positional-variable,\n  keyword, keyword-only, and keyword-variable arguments.\n* Accepts too few argument.\n* Accepts too many arguments, storing them for the next resulting function that\n  wants them.\n* Automatically applies the underlying callable when all the necessary arguments\n  have been passed.\n* Automatically re-curries/re-applies when the result of the callable is\n  itself callable.\n* Picklable (no lambdas).\n* Flat (``curry(curry(f))`` is simplified to ``curry(f)``).\n* Inspection-friendly: implements ``__signature__``, ``__name__``, ``__str__``,\n  etc.\n\n\n\nContext\n-------\n\nMathematically, Python can be approached as a Closed Monoidal Category.\n\n* Category: Python's functions and other callables can be composed.\n* Monoidal: We can put two python things together to form a new python thing\n  (lists, dictionaries, tuples, class attributes, etc.).\n* Closed: Pythons's functions (callables) are first-class, meaning they can\n  be treated like any other non-callable Python thing.\n\nAll closed monoidal categories are also Cartesian closed categories,\nand all Cartesian closed categories have currying.\n\nIn simple terms, currying takes a function that takes two arguments\nand turns it into a function of one argument that returns a function of one\nargument::\n\n    (a, b) -> c  ===curry==>  a -> (b -> c)\n\nThe opposite operation is called un-currying, and lets you call a function\nwith more arguments than it requires.\n\nPython is not limited to unary functions and pairs of arguments, Python's\ncallable objects accept posititional arguments, keyword arguments, and even\nvariable arguments.\nPython has functions, but also methods, some of which can be class methods that\nare in fact implemented as descriptors.\nFurthermore, Python can do introspection, so not only should curried callables\nwork, they should also maintain signatures, names, docstrings, etc.\nTo complicate things even more, we should be able to pickle curried callables\nand have weakrefs to them.\n\nThe ``yummycurry`` package aims at providing a simple and reliable way to\nautomatically curry, uncurry and apply (call) any Python callable.\n\n\nWalkthrough\n-----------\n\nDecorator or simple function\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe function ``yummycurry.curry`` can be used as a decorator or as a function::\n\n    from yummycurry import curry\n\n    def dbl(x):\n        return x * 2\n    dbl = curry(dbl)  # As a function.\n\n    @curry  # As a decorator.\n    def inc(x):\n        return x + 1\n\n\nToo few arguments\n^^^^^^^^^^^^^^^^^\n\nA trivial use of ``curry`` is to call a function with fewer arguments than it\nrequires.\n\nWe can see it the other way around and design with ``curry`` in mind, in order\nto define functions that take more parameters than they actually need.\nIt is common to see function composition implemented as such::\n\n    def compose(f, g):\n        return lambda x: f(g(x))\n\nOne severe problem is that lambdas cannot be pickled, which prevents them\nfrom being shared easily in a multiprocessing environment.\nAnother problem is the lack of useful ``__doc__`` and ``__name__`` which make\nintrospection, documentation and printing/logging difficult.\nFinally they are difficult to read.\nAs a rule of thumb, lambdas should not escape the scope in which they are\ndefined.\n\nWe can avoid returning lambdas by making ``compose`` take a third argument and\nrelying on ``curry`` to wait for it::\n\n    @curry\n    def compose(f, g, x):\n        \"\"\"Composition of unary functions.\"\"\"\n        # No need to return a lambda, ``curry`` takes care of it.\n        return f(g(x))\n\n    dbl_inc = compose(dbl, inc)\n    assert dbl_inc(10) == 22\n\n    # Function composition is associative: as long as the order or the leaves\n    # is preserved, the way that the tree forks does not matter.\n    pipeline_1 = compose(compose(dbl, compose(inc, dbl)), compose(inc, inc))\n    pipeline_2 = compose(compose(compose(compose(dbl, inc), dbl), inc), inc)\n    assert pipeline_1(10) == 2 * (1 + 2 * (1 + 1 + 10))\n    assert pipeline_2(10) == 2 * (1 + 2 * (1 + 1 + 10))\n\nThis version of ``compose``, which relies on ``curry``, has no lambdas and is\ntherefore picklable.\nWe will see later that ``curry`` preserves the name, documentation, and even\nthe signature of the underlying callable.\nThose are also features of ``functools.partial``, so ``yummycurry`` brings no\nsurprise there.\n\nAutomatic application, re-currying and uncurrying\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nWith ``functools.partial``, there are two explicit phases:\n\n1. The currying phase:\n   create a ``partial`` object by setting some of, or all, the arguments.\n2. The application phase:\n   apply the partial object by calling it with all the remaining arguments,\n   even if there are actually no remaining arguments.\n\nExample::\n\n    from functools import partial\n\n    def cool(x, y, z):\n        return x * 100 + y * 10 + z\n\n    p = partial(cool, 1, 2, 3)  # Phase 1: explicit currying.\n    result = p()  # Phase 2: explicit application, even if there are no arguments.\n    assert result == 123\n\nIf we want to curry again we have to be explicit::\n\n    p = partial(cool, 1)  # Explicit currying.\n    p = partial(p, 2)  # Explicit currying, again.\n    result = p(3)  # Explicit application.\n    assert result == 123\n\nAutomatic application\n,,,,,,,,,,,,,,,,,,,,,\n\nWith ``yummycurry``, function application is automated::\n\n    p = curry(cool, 1)\n    p = p(2)\n    result = p(3)\n    assert result == 123\n\nTo achieve this, ``yummycurry`` inspects its underlying callable (in our case\n``cool``) and compares its signature with the arguments that have been\nprovided so far.\nIf the arguments satisfy the signature of the underlying callable, then\nit is automatically applied, otherwise ``yummycurry`` returns a new callable\nthat waits for more arguments: it re-curries itself.\n\nAutomatic application stops when the result is not callable.\nThis means that ``curry`` accepts non-callable objects; it just returns\nthem untouched::\n\n    s = \"Don't call us, we'll call you\"\n    assert curry(s) == s\n\n    @curry\n    def actually_constant():\n        return 123\n\n    assert actually_constant == 123\n\n\nAutomatic re-currying\n,,,,,,,,,,,,,,,,,,,,,\n\nNot only does ``yummycurry`` re-curries its underlying callable when it needs\nmore arguments, but it also automatically curries any callable resulting from\nits application.\n\nIf a callable ``f0`` returns a callable ``f1`` that is not explicitly\ncurried, then ``curry(f0)`` will automatically curry ``f1``::\n\n    def f0(x:int):  # Uncurried\n        def f1(y:int, z:int) -> int:  # Uncurried\n            return x*100 + y*10 + z\n        return f1\n\n    # Without currying, this is the only thing that works:\n    assert f0(1)(2, 3) == 123\n\n    try:\n        assert f0(1)(2)(3) == 123\n    except TypeError:\n        pass  # The result of f0(1) is not curried so f0(1)(2) is incorrect.\n\n    # If we curry f0, then its result ``f0(1)`` is automatically curried:\n    f0 = curry(f0)\n    assert f0(1)(2)(3) == 123  # Now it works.\n\nThe process continues: if ``curry(f1)`` returns a callable ``f2`` then it gets\ncurried as well.\nThe process stops when the result of a function is not callable.\nIn this example, the number ``123`` is not callable so the automatic\ncurrying and application stops.\n\nWhen currying, we wish to always preserve ``f(x, y) == f(x)(y)``.\nThere are cases in which this symmetry cannot be preserved: when ``f`` accepts\na variable-argument parameter (like ``*args`` or ``**kwargs``), or when a\nparameter has a default value.\nThis will be addressed later in this document.\n\n\nAutomatic uncurrying\n,,,,,,,,,,,,,,,,,,,,\n\nUnlike ``functools.partial`` and many other Python packages that ship a currying\nfunction, ``yummycurry`` accepts arguments even when they do not match any\nparameter of the curried callable.\n\nIf a curried function ``f0`` is called with too many arguments,\nand if its result is a function ``f1``,\nthen ``f1`` is automatically called with the arguments that ``f0`` did not use.\n\nFrom a mathematical point of view, it is not currying but uncurrying::\n\n    a -> (b -> c)  ===uncurry==>  (a, b) -> c\n\nIndeed, by accepting more arguments than necessary, ``yummycurry`` effectively\nturns a function-returning-function (``a -> (b -> c)``)\ninto a function of several parameters (``(a, b) -> c``).\n\nThe process repeats itself automatically until it runs out of arguments or the\nresult is not callable::\n\n    def one_param_only(x):\n        def i_eat_leftovers(y):\n            return x + y\n        return i_eat_leftovers\n\n    try:\n        greeting = one_param_only('hello ', 'world')\n    except TypeError:\n        pass  # We knew it would not work.\n\nWith ``yummycurry`` you can call a one-parameter function with more than one\nargument.\nIn our example, ``one_param_only`` does not use ``'world'``,\nso ``curry`` passes it to the result of ``one_param_only``, which is\na ``i_eat_leftovers`` closure::\n\n    greet = curry(one_param_only)\n    greeting = greet('hello ', 'world')\n    assert greeting == 'hello world'\n\nUntil now, we have always called ``curry`` or ``@curry`` with a single argument:\nthe callable to curry.\nHowever, it is possible to give more arguments to ``curry``; they will simply\nbe passed to the underlying callable.\n\nThe three following snippets are equivalent::\n\n    greet = curry(one_param_only)\n    greeting = greet('hello ', 'world')\n    assert greeting == 'hello world'\n\n    greet = curry(one_param_only, 'hello ')\n    greeting = greet('world')\n    assert greeting == 'hello world'\n\n    greeting = curry(one_param_only, 'hello ', 'world')\n    assert greeting == 'hello world'\n\nIt is an error to have left-over arguments when the automatic application stops::\n\n    # Good:\n    assert curry(inc, 123) == 124\n\n    # Bad:\n    try:\n        curry(inc, 123, 456, x=789)\n    except TypeError:\n        pass\n\nIt raises\n``TypeError: left-over arguments at the end of evaluation: *(456,), **{'x':789}``.\n\nIn that example, ``inc(123)`` returns the integer ``124`` which is not callable\nand does not know what to do with the extra arguments.\nInstead of letting Python return its typical\n``TypeError: 'int' object is not callable``,\n``yummycurry`` gives an error message that lists the leftover parameters, which\nhelps with debugging.\n\n\nKeyword arguments\n^^^^^^^^^^^^^^^^^\n\nIn addition to positional parameters, Python also has keyword parameters.\n\nOne can use ``yummycurry`` and keyword arguments when the order of the\npositional parameters is inconvenient\n(except for positional-only parameters in Python >=3.8 which will never\naccept being fed by a keyword argument)::\n\n    @curry\n    def list_map(f, iterable):\n        return list(map(f, iterable))\n\n    primes = [2, 3, 5, 7]\n\n    over_primes = list_map(iterable=primes)\n\n    assert over_primes(inc) == [3, 4, 6, 8]\n\n\nConflicts between keyword and positional arguments\n,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\n\nKeyword arguments and positional arguments can fight over names.\nThe ``curry`` function is designed to break whenever Python would break (with\nerror messages close to the original ones).\n\n* For example, if a positional-only parameter (Python >=3.8) is fed by\n  a keyword argument, both ``curry`` and undecorated functions\n  raise ``TypeError``.\n* If a positional-or-keyword parameter is fed both by a positional and\n  a keyword argument, ``TypeError`` is raised.\n\n::\n\n    @curry\n    def give_name(who, name, verbose=False):\n        if verbose:\n            print('Hello', name)\n        new_who = {**who, 'name':name}\n        return new_who\n\n    @curry\n    def create_genius(iq: int, best_quality:str, *, verbose=False):\n        you = dict(iq = 50, awesome_at=best_quality)\n        if iq > you['iq']:\n            you['iq'] = iq\n            if verbose:\n                print('Boosting your iq to', iq)\n        else:\n            if verbose:\n                print('You are already smart enough')\n        return give_name(you)\n\nConsider the following call::\n\n    dear_reader = create_genius('spitting fire', name='Darling', iq=160, verbose=True)\n\nThat call raises ``TypeError: multiple values for argument 'iq'``, as it would\nif it were not decorated with ``@curry``.\nIt would have been possible to make ``curry`` detect\nthat ``iq`` is passed as a keyword,\nand conclude that ``'spitting fire'`` should go to ``best_quality``,\nbut this would make the decorated and undecorated versions behave differently.\nIndeed, Python complains in this situation for the undecorated function.\nIn order to be transparent and predictable, ``curry`` complains as well.\n\nOne could think that doing it in two steps would resolve the ambiguity::\n\n    smart = create_genius(name='Darling', iq=160, verbose=True)\n    dear_reader = smart('spitting fire')\n\nbut it does not, which is a good thing.\nIn this case, the signature of ``smart`` is ``(best_quality: str)``,\nand we properly call it with a string.\nNevertheless it still raises the same ``TypeError`` about ``iq`` having more\nthan one value.\nThis is by design.\nThe order of the keyword arguments, and the number of calls that sets them,\nshould not matter.  If it breaks in one case, it should breaks in all cases.\nOtherwise that is a debugging nightmare.\n\nTwo exceptions to this rule: variable-argument parameters\n(``*args`` and ``**kwargs``), and parameters with default values.\nAs shown later in this document, those break the symmetry.\n\nThere are many ways to fix this call.\nFor example, if we insist in passing ``name`` and ``iq`` as keywords, then\nit is necessary to pass ``best_quality`` as a keyword as well to remove all\nambiguity.\nThis can be done in any order, in as many calls as wanted::\n\n    dear_reader = create_genius(\n        best_quality='spitting fire',\n        name='Darling',\n        iq=160,\n        verbose=True\n    )\n\n    # ... equivalent to ...\n\n    smart = create_genius(name='Darling', iq=160, verbose=True)\n    dear_reader = smart(best_quality='spitting fire')\n\n\nKeyword arguments are used only once\n,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\n\nIf you run the code above, you will notice that setting ``verbose=True`` makes\n``create_genius`` print something.\nHowever, ``give_name`` does not print anything.\nThis happens because ``curry`` uses arguments only once.\nWhen ``create_genius`` returns the ``give_name`` function, the ``verbose``\nargument has already been consumed.\n\n\nVariable positional and keyword arguments\n,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\n\nIf a callable has a variable-argument parameter, whether positional or keyword,\nthen it will take all the available arguments and will not pass them down the\ncall chain::\n\n    @curry\n    def greedy(x, *args):\n        if args:\n            print('I am stealing your', args)\n        def starving(y):\n            return x + y\n        return starving\n\n    assert greedy(10)(1) == 11\n\nHere, ``greedy`` is satisfied with one argument (even if it could take more)\nso it executes and returns the ``starving`` closure which takes ``1``.\nBecause of this, we break the general rule-of-thumb that ``f(x)(y) == f(x, y)``.\nIndeed::\n\n    try:\n        assert greedy(10, 1) == 11\n    except AssertionError:\n        pass\n\nHere, ``greedy`` takes the ``1`` it its ``*args``, it even brags about it\nwith its print statement.  Then, satisfied, it executes.  The result\nis the ``starving`` closure.  That closure does not receive any argument\nto feed its parameter so it cannot execute, it remains callable, it is\nnot an integer and therefore is not equal to 11.\nThere is no workaround, one must give ``starving`` its own argument::\n\n    assert greedy(10, 1000, 2000, 3000, 4000)(1) == 11\n\n\nThe same rule applies for variable-keyword-argument parameters::\n\n    @curry\n    def black_hole(mass, **slurp):\n        def hawking_radiation(*, bleep):\n            return 'tiny {}'.format(bleep)\n\n        return hawking_radiation\n\n    assert black_hole(10, bleep='proton', curvature='thicc')(bleep='neutrino') == 'tiny neutrino'\n\nHere, the black hole swallowed our bleeping proton,\nso the Hawking radiation requires that we specify a new bleep.\n\nBe careful: currying a function that takes only variable arguments will execute\nit immediately since its signature is satisfied by getting nothing at all.\n\nAs mentioned earlier in this document, variable-argument parameters break the\ngeneral rule of thumb that ``f(x)(y) == f(x, y)``.\n\n\nInspection and debugging\n^^^^^^^^^^^^^^^^^^^^^^^^\n\n``str``\n,,,,,,,\nCurried functions are easy on the eyes when given to ``str``.\nThis is achieved by using the ``__name__`` attribute of underlying callables,\nif they have one::\n\n    @curry\n    def inc(x: int) -> int:\n        return x + 1\n\n    @curry\n    def dbl(x: int) -> int:\n        return x * 2\n\n    def _compose(f: Callable[[int], int], g: Callable[[int], int], x: int) -> int:\n        return f(g(x))\n\n    compose = curry(_compose)  # __name__ will retain the underscore.\n\n    assert str(compose(inc, dbl)) == '_compose(inc, dbl)'  # Note the underscore.\n    assert str(compose(inc, x=10)) == '_compose(inc, x=10)'\n\n``Curried`` class\n,,,,,,,,,,,,,,,,,\n\nUsing ``__repr__`` reveals that the composed function is in fact\nan object of type ``Curried``::\n\n    print(repr(compose(inc, x=10))\n    # Curried(<function _compose at 0x000001F8D864A550>,\n    # (Curried(<function inc at 0x000001F8D864A430>, (), {},\n    # <Signature (x: int) -> int>),), {'x': 10},\n    # <Signature (g: Callable[[int], int]) -> int>)\n\nThat ``Curried`` object can be deconstructed with the attributes ``func``,\n``args`` and ``keywords`` (same attribute names as ``functool.partial``\nobjects)::\n\n    i10 = compose(inc, x=10)\n    assert i10.func == _compose\n    assert i10.args == (inc,)\n    assert i10.keywords == dict(x=10)\n\nThe ``Curried`` object also updates its signature to reflect the parameters\nthat its callable still needs.\nIn our example, the callable ``i10`` (our ``Curried`` object), still expects a\nparameter ``g`` which is a function from ``int`` to ``int``.\nThe signature can be accessed via the ``__signature__`` attribute, which is\nof type ``inspect.Signature``::\n\n    import inspect\n\n    assert i10.__signature__ == inspect.signature(i10)\n    print(i10.__signature__)  # (g: Callable[[int], int]) -> int\n\nNote that static type checking tools like MyPy_ are unlikely to understand this,\nas they look at the code but do not execute it.\n\n.. _MyPy: http://mypy-lang.org/\n\n\nParameters with default values\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUnder the hood, ``curry`` compares the result of ``inspect.signature`` to the\npositional and keyword arguments collected so far.\nAs soon as the function can be called, it is called.\nThis means that ``curry`` does not wait when a parameter has a default value::\n\n    @curry\n    def increase(x:int, increment:int=1):\n        return x + increment\n\n    assert increase(10) == 11  # Does not wait for ``increment``.\n\n    assert increase(10, increment=100) == 110\n\n    inc_100 = increase(increment=100)\n    assert inc_100(10) == 110\n\nParameters with default values break the general rule-of-thumb that\n``f(x, y) == f(x)(y)``.\n\n\nCurrying classes, class methods and instance methods\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nInstance and class methods can also be curried::\n\n    class Rabbit:\n        def __init__(self, ears, tails):\n            self._ears = ears\n            self._tails = tails\n\n        @curry_method  # Works here like a read-only property\n        def ears(self):\n            return self._ears\n\n        @curry_method\n        def tails(self):\n            return self._tails\n\n        @curry_classmethod\n        @classmethod\n        def breed(cls, rabbit1, rabbit2):\n            # Accurate model of rabbit genetics.\n            return cls(\n                (rabbit1.ears + rabbit2.ears) / 2,  # Yes, floats.\n                rabbit1.tails * rabbit2.tails,\n            )\n\n        @curry_method\n        def jump(self, impulse, target):\n            # Does not mean anything, just a demonstration.\n            return [impulse, target, 'boing']\n\n    thumper = Rabbit(2, 1)\n    monster = Rabbit(3, 2)\n\n    thumperize = Rabbit.breed(thumper)\n    oh_god_no = thumperize(monster)  # Currying a class method.\n    assert oh_god_no.ears == 2.5\n    assert oh_god_no.tails == 2\n\n    thumper_jump = thumper.jump('slow')\n    assert thumper_jump('west') == ['slow', 'west', 'boing']\n\nAnd of course, you can curry the class itself::\n\n    rabbit = curry(Rabbit)\n    deaf = rabbit(ears=0)\n    beethoven = deaf(tails=10)  # 5 per hand.\n    assert beethoven.ears == 0\n    assert beethoven.tails == 10\n\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Niriel/yummycurry", "keywords": "curry currying uncurry uncurrying partial", "license": "", "maintainer": "", "maintainer_email": "", "name": "yummycurry", "package_url": "https://pypi.org/project/yummycurry/", "platform": "", "project_url": "https://pypi.org/project/yummycurry/", "project_urls": {"Homepage": "https://github.com/Niriel/yummycurry"}, "release_url": "https://pypi.org/project/yummycurry/0.1.0/", "requires_dist": ["pytest ; extra == 'test'"], "requires_python": ">=3.8", "summary": "Automatic currying, uncurrying and application of functions and methods", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"features\">\n<h2>Features</h2>\n<ul>\n<li>Decorators for functions, methods and class methods.</li>\n<li>Supports positional, positional-only, positional-variable,\nkeyword, keyword-only, and keyword-variable arguments.</li>\n<li>Accepts too few argument.</li>\n<li>Accepts too many arguments, storing them for the next resulting function that\nwants them.</li>\n<li>Automatically applies the underlying callable when all the necessary arguments\nhave been passed.</li>\n<li>Automatically re-curries/re-applies when the result of the callable is\nitself callable.</li>\n<li>Picklable (no lambdas).</li>\n<li>Flat (<tt>curry(curry(f))</tt> is simplified to <tt>curry(f)</tt>).</li>\n<li>Inspection-friendly: implements <tt>__signature__</tt>, <tt>__name__</tt>, <tt>__str__</tt>,\netc.</li>\n</ul>\n</div>\n<div id=\"context\">\n<h2>Context</h2>\n<p>Mathematically, Python can be approached as a Closed Monoidal Category.</p>\n<ul>\n<li>Category: Python\u2019s functions and other callables can be composed.</li>\n<li>Monoidal: We can put two python things together to form a new python thing\n(lists, dictionaries, tuples, class attributes, etc.).</li>\n<li>Closed: Pythons\u2019s functions (callables) are first-class, meaning they can\nbe treated like any other non-callable Python thing.</li>\n</ul>\n<p>All closed monoidal categories are also Cartesian closed categories,\nand all Cartesian closed categories have currying.</p>\n<p>In simple terms, currying takes a function that takes two arguments\nand turns it into a function of one argument that returns a function of one\nargument:</p>\n<pre>(a, b) -&gt; c  ===curry==&gt;  a -&gt; (b -&gt; c)\n</pre>\n<p>The opposite operation is called un-currying, and lets you call a function\nwith more arguments than it requires.</p>\n<p>Python is not limited to unary functions and pairs of arguments, Python\u2019s\ncallable objects accept posititional arguments, keyword arguments, and even\nvariable arguments.\nPython has functions, but also methods, some of which can be class methods that\nare in fact implemented as descriptors.\nFurthermore, Python can do introspection, so not only should curried callables\nwork, they should also maintain signatures, names, docstrings, etc.\nTo complicate things even more, we should be able to pickle curried callables\nand have weakrefs to them.</p>\n<p>The <tt>yummycurry</tt> package aims at providing a simple and reliable way to\nautomatically curry, uncurry and apply (call) any Python callable.</p>\n</div>\n<div id=\"walkthrough\">\n<h2>Walkthrough</h2>\n<div id=\"decorator-or-simple-function\">\n<h3>Decorator or simple function</h3>\n<p>The function <tt>yummycurry.curry</tt> can be used as a decorator or as a function:</p>\n<pre>from yummycurry import curry\n\ndef dbl(x):\n    return x * 2\ndbl = curry(dbl)  # As a function.\n\n@curry  # As a decorator.\ndef inc(x):\n    return x + 1\n</pre>\n</div>\n<div id=\"too-few-arguments\">\n<h3>Too few arguments</h3>\n<p>A trivial use of <tt>curry</tt> is to call a function with fewer arguments than it\nrequires.</p>\n<p>We can see it the other way around and design with <tt>curry</tt> in mind, in order\nto define functions that take more parameters than they actually need.\nIt is common to see function composition implemented as such:</p>\n<pre>def compose(f, g):\n    return lambda x: f(g(x))\n</pre>\n<p>One severe problem is that lambdas cannot be pickled, which prevents them\nfrom being shared easily in a multiprocessing environment.\nAnother problem is the lack of useful <tt>__doc__</tt> and <tt>__name__</tt> which make\nintrospection, documentation and printing/logging difficult.\nFinally they are difficult to read.\nAs a rule of thumb, lambdas should not escape the scope in which they are\ndefined.</p>\n<p>We can avoid returning lambdas by making <tt>compose</tt> take a third argument and\nrelying on <tt>curry</tt> to wait for it:</p>\n<pre>@curry\ndef compose(f, g, x):\n    \"\"\"Composition of unary functions.\"\"\"\n    # No need to return a lambda, ``curry`` takes care of it.\n    return f(g(x))\n\ndbl_inc = compose(dbl, inc)\nassert dbl_inc(10) == 22\n\n# Function composition is associative: as long as the order or the leaves\n# is preserved, the way that the tree forks does not matter.\npipeline_1 = compose(compose(dbl, compose(inc, dbl)), compose(inc, inc))\npipeline_2 = compose(compose(compose(compose(dbl, inc), dbl), inc), inc)\nassert pipeline_1(10) == 2 * (1 + 2 * (1 + 1 + 10))\nassert pipeline_2(10) == 2 * (1 + 2 * (1 + 1 + 10))\n</pre>\n<p>This version of <tt>compose</tt>, which relies on <tt>curry</tt>, has no lambdas and is\ntherefore picklable.\nWe will see later that <tt>curry</tt> preserves the name, documentation, and even\nthe signature of the underlying callable.\nThose are also features of <tt>functools.partial</tt>, so <tt>yummycurry</tt> brings no\nsurprise there.</p>\n</div>\n<div id=\"automatic-application-re-currying-and-uncurrying\">\n<h3>Automatic application, re-currying and uncurrying</h3>\n<p>With <tt>functools.partial</tt>, there are two explicit phases:</p>\n<ol>\n<li>The currying phase:\ncreate a <tt>partial</tt> object by setting some of, or all, the arguments.</li>\n<li>The application phase:\napply the partial object by calling it with all the remaining arguments,\neven if there are actually no remaining arguments.</li>\n</ol>\n<p>Example:</p>\n<pre>from functools import partial\n\ndef cool(x, y, z):\n    return x * 100 + y * 10 + z\n\np = partial(cool, 1, 2, 3)  # Phase 1: explicit currying.\nresult = p()  # Phase 2: explicit application, even if there are no arguments.\nassert result == 123\n</pre>\n<p>If we want to curry again we have to be explicit:</p>\n<pre>p = partial(cool, 1)  # Explicit currying.\np = partial(p, 2)  # Explicit currying, again.\nresult = p(3)  # Explicit application.\nassert result == 123\n</pre>\n<div id=\"automatic-application\">\n<h4>Automatic application</h4>\n<p>With <tt>yummycurry</tt>, function application is automated:</p>\n<pre>p = curry(cool, 1)\np = p(2)\nresult = p(3)\nassert result == 123\n</pre>\n<p>To achieve this, <tt>yummycurry</tt> inspects its underlying callable (in our case\n<tt>cool</tt>) and compares its signature with the arguments that have been\nprovided so far.\nIf the arguments satisfy the signature of the underlying callable, then\nit is automatically applied, otherwise <tt>yummycurry</tt> returns a new callable\nthat waits for more arguments: it re-curries itself.</p>\n<p>Automatic application stops when the result is not callable.\nThis means that <tt>curry</tt> accepts non-callable objects; it just returns\nthem untouched:</p>\n<pre>s = \"Don't call us, we'll call you\"\nassert curry(s) == s\n\n@curry\ndef actually_constant():\n    return 123\n\nassert actually_constant == 123\n</pre>\n</div>\n<div id=\"automatic-re-currying\">\n<h4>Automatic re-currying</h4>\n<p>Not only does <tt>yummycurry</tt> re-curries its underlying callable when it needs\nmore arguments, but it also automatically curries any callable resulting from\nits application.</p>\n<p>If a callable <tt>f0</tt> returns a callable <tt>f1</tt> that is not explicitly\ncurried, then <tt>curry(f0)</tt> will automatically curry <tt>f1</tt>:</p>\n<pre>def f0(x:int):  # Uncurried\n    def f1(y:int, z:int) -&gt; int:  # Uncurried\n        return x*100 + y*10 + z\n    return f1\n\n# Without currying, this is the only thing that works:\nassert f0(1)(2, 3) == 123\n\ntry:\n    assert f0(1)(2)(3) == 123\nexcept TypeError:\n    pass  # The result of f0(1) is not curried so f0(1)(2) is incorrect.\n\n# If we curry f0, then its result ``f0(1)`` is automatically curried:\nf0 = curry(f0)\nassert f0(1)(2)(3) == 123  # Now it works.\n</pre>\n<p>The process continues: if <tt>curry(f1)</tt> returns a callable <tt>f2</tt> then it gets\ncurried as well.\nThe process stops when the result of a function is not callable.\nIn this example, the number <tt>123</tt> is not callable so the automatic\ncurrying and application stops.</p>\n<p>When currying, we wish to always preserve <tt>f(x, y) == <span class=\"pre\">f(x)(y)</span></tt>.\nThere are cases in which this symmetry cannot be preserved: when <tt>f</tt> accepts\na variable-argument parameter (like <tt>*args</tt> or <tt>**kwargs</tt>), or when a\nparameter has a default value.\nThis will be addressed later in this document.</p>\n</div>\n<div id=\"automatic-uncurrying\">\n<h4>Automatic uncurrying</h4>\n<p>Unlike <tt>functools.partial</tt> and many other Python packages that ship a currying\nfunction, <tt>yummycurry</tt> accepts arguments even when they do not match any\nparameter of the curried callable.</p>\n<p>If a curried function <tt>f0</tt> is called with too many arguments,\nand if its result is a function <tt>f1</tt>,\nthen <tt>f1</tt> is automatically called with the arguments that <tt>f0</tt> did not use.</p>\n<p>From a mathematical point of view, it is not currying but uncurrying:</p>\n<pre>a -&gt; (b -&gt; c)  ===uncurry==&gt;  (a, b) -&gt; c\n</pre>\n<p>Indeed, by accepting more arguments than necessary, <tt>yummycurry</tt> effectively\nturns a function-returning-function (<tt>a <span class=\"pre\">-&gt;</span> (b <span class=\"pre\">-&gt;</span> c)</tt>)\ninto a function of several parameters (<tt>(a, b) <span class=\"pre\">-&gt;</span> c</tt>).</p>\n<p>The process repeats itself automatically until it runs out of arguments or the\nresult is not callable:</p>\n<pre>def one_param_only(x):\n    def i_eat_leftovers(y):\n        return x + y\n    return i_eat_leftovers\n\ntry:\n    greeting = one_param_only('hello ', 'world')\nexcept TypeError:\n    pass  # We knew it would not work.\n</pre>\n<p>With <tt>yummycurry</tt> you can call a one-parameter function with more than one\nargument.\nIn our example, <tt>one_param_only</tt> does not use <tt>'world'</tt>,\nso <tt>curry</tt> passes it to the result of <tt>one_param_only</tt>, which is\na <tt>i_eat_leftovers</tt> closure:</p>\n<pre>greet = curry(one_param_only)\ngreeting = greet('hello ', 'world')\nassert greeting == 'hello world'\n</pre>\n<p>Until now, we have always called <tt>curry</tt> or <tt>@curry</tt> with a single argument:\nthe callable to curry.\nHowever, it is possible to give more arguments to <tt>curry</tt>; they will simply\nbe passed to the underlying callable.</p>\n<p>The three following snippets are equivalent:</p>\n<pre>greet = curry(one_param_only)\ngreeting = greet('hello ', 'world')\nassert greeting == 'hello world'\n\ngreet = curry(one_param_only, 'hello ')\ngreeting = greet('world')\nassert greeting == 'hello world'\n\ngreeting = curry(one_param_only, 'hello ', 'world')\nassert greeting == 'hello world'\n</pre>\n<p>It is an error to have left-over arguments when the automatic application stops:</p>\n<pre># Good:\nassert curry(inc, 123) == 124\n\n# Bad:\ntry:\n    curry(inc, 123, 456, x=789)\nexcept TypeError:\n    pass\n</pre>\n<p>It raises\n<tt>TypeError: <span class=\"pre\">left-over</span> arguments at the end of evaluation: <span class=\"pre\">*(456,),</span> <span class=\"pre\">**{'x':789}</span></tt>.</p>\n<p>In that example, <tt>inc(123)</tt> returns the integer <tt>124</tt> which is not callable\nand does not know what to do with the extra arguments.\nInstead of letting Python return its typical\n<tt>TypeError: 'int' object is not callable</tt>,\n<tt>yummycurry</tt> gives an error message that lists the leftover parameters, which\nhelps with debugging.</p>\n</div>\n</div>\n<div id=\"keyword-arguments\">\n<h3>Keyword arguments</h3>\n<p>In addition to positional parameters, Python also has keyword parameters.</p>\n<p>One can use <tt>yummycurry</tt> and keyword arguments when the order of the\npositional parameters is inconvenient\n(except for positional-only parameters in Python &gt;=3.8 which will never\naccept being fed by a keyword argument):</p>\n<pre>@curry\ndef list_map(f, iterable):\n    return list(map(f, iterable))\n\nprimes = [2, 3, 5, 7]\n\nover_primes = list_map(iterable=primes)\n\nassert over_primes(inc) == [3, 4, 6, 8]\n</pre>\n<div id=\"conflicts-between-keyword-and-positional-arguments\">\n<h4>Conflicts between keyword and positional arguments</h4>\n<p>Keyword arguments and positional arguments can fight over names.\nThe <tt>curry</tt> function is designed to break whenever Python would break (with\nerror messages close to the original ones).</p>\n<ul>\n<li>For example, if a positional-only parameter (Python &gt;=3.8) is fed by\na keyword argument, both <tt>curry</tt> and undecorated functions\nraise <tt>TypeError</tt>.</li>\n<li>If a positional-or-keyword parameter is fed both by a positional and\na keyword argument, <tt>TypeError</tt> is raised.</li>\n</ul>\n<pre>@curry\ndef give_name(who, name, verbose=False):\n    if verbose:\n        print('Hello', name)\n    new_who = {**who, 'name':name}\n    return new_who\n\n@curry\ndef create_genius(iq: int, best_quality:str, *, verbose=False):\n    you = dict(iq = 50, awesome_at=best_quality)\n    if iq &gt; you['iq']:\n        you['iq'] = iq\n        if verbose:\n            print('Boosting your iq to', iq)\n    else:\n        if verbose:\n            print('You are already smart enough')\n    return give_name(you)\n</pre>\n<p>Consider the following call:</p>\n<pre>dear_reader = create_genius('spitting fire', name='Darling', iq=160, verbose=True)\n</pre>\n<p>That call raises <tt>TypeError: multiple values for argument 'iq'</tt>, as it would\nif it were not decorated with <tt>@curry</tt>.\nIt would have been possible to make <tt>curry</tt> detect\nthat <tt>iq</tt> is passed as a keyword,\nand conclude that <tt>'spitting fire'</tt> should go to <tt>best_quality</tt>,\nbut this would make the decorated and undecorated versions behave differently.\nIndeed, Python complains in this situation for the undecorated function.\nIn order to be transparent and predictable, <tt>curry</tt> complains as well.</p>\n<p>One could think that doing it in two steps would resolve the ambiguity:</p>\n<pre>smart = create_genius(name='Darling', iq=160, verbose=True)\ndear_reader = smart('spitting fire')\n</pre>\n<p>but it does not, which is a good thing.\nIn this case, the signature of <tt>smart</tt> is <tt>(best_quality: str)</tt>,\nand we properly call it with a string.\nNevertheless it still raises the same <tt>TypeError</tt> about <tt>iq</tt> having more\nthan one value.\nThis is by design.\nThe order of the keyword arguments, and the number of calls that sets them,\nshould not matter.  If it breaks in one case, it should breaks in all cases.\nOtherwise that is a debugging nightmare.</p>\n<p>Two exceptions to this rule: variable-argument parameters\n(<tt>*args</tt> and <tt>**kwargs</tt>), and parameters with default values.\nAs shown later in this document, those break the symmetry.</p>\n<p>There are many ways to fix this call.\nFor example, if we insist in passing <tt>name</tt> and <tt>iq</tt> as keywords, then\nit is necessary to pass <tt>best_quality</tt> as a keyword as well to remove all\nambiguity.\nThis can be done in any order, in as many calls as wanted:</p>\n<pre>dear_reader = create_genius(\n    best_quality='spitting fire',\n    name='Darling',\n    iq=160,\n    verbose=True\n)\n\n# ... equivalent to ...\n\nsmart = create_genius(name='Darling', iq=160, verbose=True)\ndear_reader = smart(best_quality='spitting fire')\n</pre>\n</div>\n<div id=\"keyword-arguments-are-used-only-once\">\n<h4>Keyword arguments are used only once</h4>\n<p>If you run the code above, you will notice that setting <tt>verbose=True</tt> makes\n<tt>create_genius</tt> print something.\nHowever, <tt>give_name</tt> does not print anything.\nThis happens because <tt>curry</tt> uses arguments only once.\nWhen <tt>create_genius</tt> returns the <tt>give_name</tt> function, the <tt>verbose</tt>\nargument has already been consumed.</p>\n</div>\n<div id=\"variable-positional-and-keyword-arguments\">\n<h4>Variable positional and keyword arguments</h4>\n<p>If a callable has a variable-argument parameter, whether positional or keyword,\nthen it will take all the available arguments and will not pass them down the\ncall chain:</p>\n<pre>@curry\ndef greedy(x, *args):\n    if args:\n        print('I am stealing your', args)\n    def starving(y):\n        return x + y\n    return starving\n\nassert greedy(10)(1) == 11\n</pre>\n<p>Here, <tt>greedy</tt> is satisfied with one argument (even if it could take more)\nso it executes and returns the <tt>starving</tt> closure which takes <tt>1</tt>.\nBecause of this, we break the general rule-of-thumb that <tt><span class=\"pre\">f(x)(y)</span> == f(x, y)</tt>.\nIndeed:</p>\n<pre>try:\n    assert greedy(10, 1) == 11\nexcept AssertionError:\n    pass\n</pre>\n<p>Here, <tt>greedy</tt> takes the <tt>1</tt> it its <tt>*args</tt>, it even brags about it\nwith its print statement.  Then, satisfied, it executes.  The result\nis the <tt>starving</tt> closure.  That closure does not receive any argument\nto feed its parameter so it cannot execute, it remains callable, it is\nnot an integer and therefore is not equal to 11.\nThere is no workaround, one must give <tt>starving</tt> its own argument:</p>\n<pre>assert greedy(10, 1000, 2000, 3000, 4000)(1) == 11\n</pre>\n<p>The same rule applies for variable-keyword-argument parameters:</p>\n<pre>@curry\ndef black_hole(mass, **slurp):\n    def hawking_radiation(*, bleep):\n        return 'tiny {}'.format(bleep)\n\n    return hawking_radiation\n\nassert black_hole(10, bleep='proton', curvature='thicc')(bleep='neutrino') == 'tiny neutrino'\n</pre>\n<p>Here, the black hole swallowed our bleeping proton,\nso the Hawking radiation requires that we specify a new bleep.</p>\n<p>Be careful: currying a function that takes only variable arguments will execute\nit immediately since its signature is satisfied by getting nothing at all.</p>\n<p>As mentioned earlier in this document, variable-argument parameters break the\ngeneral rule of thumb that <tt><span class=\"pre\">f(x)(y)</span> == f(x, y)</tt>.</p>\n</div>\n</div>\n<div id=\"inspection-and-debugging\">\n<h3>Inspection and debugging</h3>\n<div id=\"str\">\n<h4><tt>str</tt></h4>\n<p>Curried functions are easy on the eyes when given to <tt>str</tt>.\nThis is achieved by using the <tt>__name__</tt> attribute of underlying callables,\nif they have one:</p>\n<pre>@curry\ndef inc(x: int) -&gt; int:\n    return x + 1\n\n@curry\ndef dbl(x: int) -&gt; int:\n    return x * 2\n\ndef _compose(f: Callable[[int], int], g: Callable[[int], int], x: int) -&gt; int:\n    return f(g(x))\n\ncompose = curry(_compose)  # __name__ will retain the underscore.\n\nassert str(compose(inc, dbl)) == '_compose(inc, dbl)'  # Note the underscore.\nassert str(compose(inc, x=10)) == '_compose(inc, x=10)'\n</pre>\n</div>\n<div id=\"curried-class\">\n<h4><tt>Curried</tt> class</h4>\n<p>Using <tt>__repr__</tt> reveals that the composed function is in fact\nan object of type <tt>Curried</tt>:</p>\n<pre>print(repr(compose(inc, x=10))\n# Curried(&lt;function _compose at 0x000001F8D864A550&gt;,\n# (Curried(&lt;function inc at 0x000001F8D864A430&gt;, (), {},\n# &lt;Signature (x: int) -&gt; int&gt;),), {'x': 10},\n# &lt;Signature (g: Callable[[int], int]) -&gt; int&gt;)\n</pre>\n<p>That <tt>Curried</tt> object can be deconstructed with the attributes <tt>func</tt>,\n<tt>args</tt> and <tt>keywords</tt> (same attribute names as <tt>functool.partial</tt>\nobjects):</p>\n<pre>i10 = compose(inc, x=10)\nassert i10.func == _compose\nassert i10.args == (inc,)\nassert i10.keywords == dict(x=10)\n</pre>\n<p>The <tt>Curried</tt> object also updates its signature to reflect the parameters\nthat its callable still needs.\nIn our example, the callable <tt>i10</tt> (our <tt>Curried</tt> object), still expects a\nparameter <tt>g</tt> which is a function from <tt>int</tt> to <tt>int</tt>.\nThe signature can be accessed via the <tt>__signature__</tt> attribute, which is\nof type <tt>inspect.Signature</tt>:</p>\n<pre>import inspect\n\nassert i10.__signature__ == inspect.signature(i10)\nprint(i10.__signature__)  # (g: Callable[[int], int]) -&gt; int\n</pre>\n<p>Note that static type checking tools like <a href=\"http://mypy-lang.org/\" rel=\"nofollow\">MyPy</a> are unlikely to understand this,\nas they look at the code but do not execute it.</p>\n</div>\n</div>\n<div id=\"parameters-with-default-values\">\n<h3>Parameters with default values</h3>\n<p>Under the hood, <tt>curry</tt> compares the result of <tt>inspect.signature</tt> to the\npositional and keyword arguments collected so far.\nAs soon as the function can be called, it is called.\nThis means that <tt>curry</tt> does not wait when a parameter has a default value:</p>\n<pre>@curry\ndef increase(x:int, increment:int=1):\n    return x + increment\n\nassert increase(10) == 11  # Does not wait for ``increment``.\n\nassert increase(10, increment=100) == 110\n\ninc_100 = increase(increment=100)\nassert inc_100(10) == 110\n</pre>\n<p>Parameters with default values break the general rule-of-thumb that\n<tt>f(x, y) == <span class=\"pre\">f(x)(y)</span></tt>.</p>\n</div>\n<div id=\"currying-classes-class-methods-and-instance-methods\">\n<h3>Currying classes, class methods and instance methods</h3>\n<p>Instance and class methods can also be curried:</p>\n<pre>class Rabbit:\n    def __init__(self, ears, tails):\n        self._ears = ears\n        self._tails = tails\n\n    @curry_method  # Works here like a read-only property\n    def ears(self):\n        return self._ears\n\n    @curry_method\n    def tails(self):\n        return self._tails\n\n    @curry_classmethod\n    @classmethod\n    def breed(cls, rabbit1, rabbit2):\n        # Accurate model of rabbit genetics.\n        return cls(\n            (rabbit1.ears + rabbit2.ears) / 2,  # Yes, floats.\n            rabbit1.tails * rabbit2.tails,\n        )\n\n    @curry_method\n    def jump(self, impulse, target):\n        # Does not mean anything, just a demonstration.\n        return [impulse, target, 'boing']\n\nthumper = Rabbit(2, 1)\nmonster = Rabbit(3, 2)\n\nthumperize = Rabbit.breed(thumper)\noh_god_no = thumperize(monster)  # Currying a class method.\nassert oh_god_no.ears == 2.5\nassert oh_god_no.tails == 2\n\nthumper_jump = thumper.jump('slow')\nassert thumper_jump('west') == ['slow', 'west', 'boing']\n</pre>\n<p>And of course, you can curry the class itself:</p>\n<pre>rabbit = curry(Rabbit)\ndeaf = rabbit(ears=0)\nbeethoven = deaf(tails=10)  # 5 per hand.\nassert beethoven.ears == 0\nassert beethoven.tails == 10\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6512605, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "7686565b8d73a714f7dc161d415cd87c", "sha256": "0073bf39f20c0227b0715f380bb4961cb40d85e4ff175ba1da1b1ac18b842f11"}, "downloads": -1, "filename": "yummycurry-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "7686565b8d73a714f7dc161d415cd87c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.8", "size": 11751, "upload_time": "2020-01-24T09:33:59", "upload_time_iso_8601": "2020-01-24T09:33:59.513150Z", "url": "https://files.pythonhosted.org/packages/4f/94/cb726e531bef9d72fd4dd57fa339b837809727bcc42fabf03cbbf51a8e18/yummycurry-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a9841e2207833fa7f65d0a20381d6993", "sha256": "d62f6d8495d584fa948e8006ace4775b65da0c87a834980623d5b04b8e665ebc"}, "downloads": -1, "filename": "yummycurry-0.1.0.tar.gz", "has_sig": false, "md5_digest": "a9841e2207833fa7f65d0a20381d6993", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.8", "size": 19846, "upload_time": "2020-01-24T09:34:02", "upload_time_iso_8601": "2020-01-24T09:34:02.267434Z", "url": "https://files.pythonhosted.org/packages/d7/e5/98d3c61490be193537bbf16568d07c4bb2e576f072fa57ce7f1c4b028c44/yummycurry-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "7686565b8d73a714f7dc161d415cd87c", "sha256": "0073bf39f20c0227b0715f380bb4961cb40d85e4ff175ba1da1b1ac18b842f11"}, "downloads": -1, "filename": "yummycurry-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "7686565b8d73a714f7dc161d415cd87c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.8", "size": 11751, "upload_time": "2020-01-24T09:33:59", "upload_time_iso_8601": "2020-01-24T09:33:59.513150Z", "url": "https://files.pythonhosted.org/packages/4f/94/cb726e531bef9d72fd4dd57fa339b837809727bcc42fabf03cbbf51a8e18/yummycurry-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a9841e2207833fa7f65d0a20381d6993", "sha256": "d62f6d8495d584fa948e8006ace4775b65da0c87a834980623d5b04b8e665ebc"}, "downloads": -1, "filename": "yummycurry-0.1.0.tar.gz", "has_sig": false, "md5_digest": "a9841e2207833fa7f65d0a20381d6993", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.8", "size": 19846, "upload_time": "2020-01-24T09:34:02", "upload_time_iso_8601": "2020-01-24T09:34:02.267434Z", "url": "https://files.pythonhosted.org/packages/d7/e5/98d3c61490be193537bbf16568d07c4bb2e576f072fa57ce7f1c4b028c44/yummycurry-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:21:22 2020"}