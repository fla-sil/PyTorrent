{"info": {"author": "Lars Berscheid", "author_email": "lars.berscheid@kit.edu", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Science/Research", "License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)", "Programming Language :: C++", "Topic :: Software Development :: Build Tools"], "description": "<div align=\"center\">\n  <center><img width=\"220\" src=\"https://raw.githubusercontent.com/pantor/frankx/master/doc/logo.png\"></div></center>\n  <h3 align=\"center\"><center><i>frankx</i><br>High-Level Motion Library for the Franka Panda Robot</center></h3>\n</div>\n\n<p align=\"center\">\n  <a href=\"https://github.com/pantor/frankx/actions\">\n    <img src=\"https://github.com/pantor/frankx/workflows/CI/badge.svg\" alt=\"CI\">\n  </a>\n\n  <a href=\"https://github.com/pantor/frankx/actions\">\n    <img src=\"https://github.com/pantor/frankx/workflows/Publish/badge.svg\" alt=\"Publish\">\n  </a>\n\n  <a href=\"https://github.com/pantor/frankx/issues\">\n    <img src=\"https://img.shields.io/github/issues/pantor/frankx.svg\" alt=\"Issues\">\n  </a>\n\n  <a href=\"https://github.com/pantor/frankx/releases\">\n    <img src=\"https://img.shields.io/github/v/release/pantor/frankx.svg?include_prereleases&sort=semver\" alt=\"Releases\">\n  </a>\n\n  <a href=\"https://github.com/pantor/frankx/blob/master/LICENSE\">\n    <img src=\"https://img.shields.io/badge/license-LGPL-green.svg\" alt=\"LGPL\">\n  </a>\n</p>\n\n\nFrankx is a high-level motion library (both C++ and Python) for the Franka Emika Panda robot. It adds a Python wrapper around [libfranka](https://frankaemika.github.io/docs/libfranka.html), while replacing necessary real-time programming with higher-level motion commands. As frankx focuses on making real-time trajectory generation easy, it allows the robot to react to unforeseen events.\n\n\n<!-- <div align=\"center\">\n  <center><img width=\"220\" src=\"https://raw.githubusercontent.com/pantor/frankx/master/doc/example.png\"></div></center>\n</div> -->\n\n\n## Installation\n\nFrankx is based on [libfranka](https://github.com/frankaemika/libfranka), [Reflexxes](http://reflexxes.ws) as a trajectory-generator, [Eigen](https://eigen.tuxfamily.org) for transformation calculations and [pybind11](https://github.com/pybind/pybind11) for the Python bindings. Make sure to have these dependencies installed, then you can build and install frankx via\n\n```bash\nmkdir -p build\ncd build\ncmake -DReflexxes_ROOT_DIR=../RMLTypeII -DREFLEXXES_TYPE=ReflexxesTypeII -DBUILD_TYPE=Release ..\nmake -j4\nmake install\n```\n\nOf course, you need to adapt the Reflexxes directory and type (either `ReflexxesTypeII` or `ReflexxesTypeIV`). We strongly recommend Type IV, as the Panda robot is quite sensitive to acceleration discontinuities. To use frankx, you can also include it as a subproject in your parent CMake via `add_subdirectory(frankx)` and then `target_link_libraries(<target> libfrankx)`. Make sure that the built library can be found from Python by adapting your Python Path.\n\n\n## Tutorial\n\nFrankx comes with both a C++ and Python API that differ only regarding real-time capability. We will introduce both languages next to each other. In your C++ project, just include `include <frankx/frankx.hpp>` and link the library. For Python, just `import frankx`. As a first example, only four lines of code are needed for simple robotic motions.\n\n```c++\n#include <frankx/frankx.hpp>\nusing namespace frankx;\n\n// Connect to the robot with the FCI IP address\nRobot robot(\"172.16.0.2\");\n\n// Reduce velocity and acceleration of the robot\nrobot.setDynamicRel(0.05);\n\n// Move the end-effector 20cm in positive x-direction\nauto motion = LinearRelativeMotion(Affine(0.2, 0.0, 0.0));\n\n// Finally move the robot\nrobot.move(motion);\n```\n\nThe corresponding program in Python is\n```python\nfrom frankx import Affine, LinearRelativeMotion, Robot\n\nrobot = Robot(\"172.16.0.2\")\nrobot.set_dynamic_rel(0.05)\n\nmotion = LinearRelativeMotion(Affine(0.2, 0.0, 0.0))\nrobot.move(motion)\n```\n\nFurthermore, we will introduce methods for geometric calculations, for moving the robot according to different motion types, how to implement real-time reactions and changing waypoints in real time as well as controlling the gripper.\n\n\n### Geometry\n\n`frankx::Affine` is a thin wrapper around [Eigen::Affine3d](https://eigen.tuxfamily.org/dox/group__TutorialGeometry.html). It is used for Cartesian poses, frames and transformation. Frankx simplifies the usage of Euler angles (default ZYX-convention).\n```c++\n// Initiliaze a transformation with an (x, y, z, a=0.0, b=0.0, c=0.0) translation\nAffine z_translation = Affine(0.0, 0.0, 0.5);\n\n// Define a rotation transformation using the (x, y, z, a, b, c) parameter list\nAffine z_rotation = Affine(0.0, 0.0, 0.0, M_PI / 3, 0.0, 0.0);\n\n// Make use of the wonderful Eigen library\nauto combined_transformation = z_translation * z_rotation;\n\n// Get the Euler angles (a, b, c) in a vector representation\nEigen::Vector3d euler_angles = combined_transformation.angles();\n\n// Get the vector representation (x, y, z, a, b, c) of an affine transformation\nfrankx::Vector6d pose = combined_transformation.vector();\n```\n\nIn all cases, distances are in [m] and rotations in [rad]. Additionally, there are several helper functions for conversion between Eigen and libfranka's std::array objects. In python, this translates into\n```python\nz_translation = Affine(0.0, 0.0, 0.5)\nz_rotation = Affine(0.0, 0.0, 0.0, math.pi / 3, 0.0, 0.0)\ncombined_transformation = z_translation * z_rotation\n\n# These two are now numpy arrays\neuler_angles = combined_transformation.angles()\npose = combined_transformation.vector()\n```\n\n### Robot\n\nWe wrapped most of the libfanka API (including the RobotState or ErrorMessage) for Python. Moreover, we added methods to adapt the dynamics of the robot for all motions. The `rel` name denotes that this a factor of the maximum constraints of the Panda robot.\n```python\nrobot = Robot(\"172.16.0.2\")\n\n# Recover from errors\nrobot.recover_from_errors()\n\n# Set velocity, acceleration and jerk to 5% of the maximum\nrobot.set_dynamic_rel(0.05)\n\n# Alternatively, you can define each constraint individually\nrobot.velocity_rel = 0.2\nrobot.acceleration_rel = 0.1\nrobot.jerk_rel = 0.01\n```\n\n\n### Motion Types\n\nFrankx defines five different motion types. In python, you can use them as follows:\n```python\n# A point-to-point motion in the joint space\nm1 = JointMotion([-1.81194, 1.17910, 1.75710, -2.1416, -1.14336, 1.63304, -0.43217])\n\n# A linear motion in cartesian space\nm2 = LinearMotion(Affine(0.2, -0.4, 0.3, math.pi / 2, 0.0, 0.0))\nm3 = LinearMotion(Affine(0.2, -0.4, 0.3, math.pi / 2, 0.0, 0.0), elbow=1.7)  # With target elbow angle\n\n# A linear motion in cartesian space relative to the initial position\nm4 = LinearRelativeMotion(Affine(0.0, 0.1, 0.0))\n\n# A more complex motion by defining multiple waypoints\nm5 = WaypointMotion([\n  Waypoint(Affine(0.2, -0.4, 0.2, 0.3, 0.2, 0.1)),\n  # The following waypoint is relative to the prior one\n  Waypoint(Affine(0.0, 0.1, 0.0, Waypoint.ReferenceType.Relative))\n])\n\n# Hold the position for [s]\nm6 = PositionHold(5.0)\n```\n\nThe real robot can be moved by applying a motion to the robot using `move`:\n```python\nrobot.move(m1)\nrobot.move(m2)\n\n# To use a given frame relative to the end effector\ncamera_frame = Affine(0.1, 0.0, 0.1)\nrobot.move(camera_frame, m3)\n\n# To change the dynamics of the motion, use MotionData\ndata = MotionData(0.2)  # Using a dynamic_rel of 0.2 (eventually multiplied with robot.dynamic_rel)\nrobot.move(m4, data)\n```\n\nUsing MotionData, you can adapt the dynamics (velocity, acceleration and jerk) of a specific motion.\n```python\ndata.velocity_rel = 1.0\ndata.jerk_rel = 0.2\n```\n\n\n### Real-Time Reactions\n\nBy adding reactions to the motion data, the robot can react to unforeseen events. In the Python API, you can define conditions by using a comparison between a robot's value and a given threshold. If the threshold is exceeded, the reaction fires. Following comparisons are currently implemented\n```python\nreaction_motion = LinearRelativeMotion(Affine(0.0, 0.0, 0.01))  # Move up for 1cm\n\n# Stop motion if the overall force is greater than 30N\nd1 = MotionData().with_reaction(Reaction(Measure.ForceXYZNorm, Comparison.Greater, 30.0))\n\n# Apply reaction motion if the force in z-direction is greater than 10N\nd2 = MotionData().with_reaction(Reaction(Measure.ForceZ, Comparison.Greater, 10.0), reaction_motion)\n\n# Stop motion if its duration is above 30s\nd3 = MotionData().with_reaction(Reaction(Measure.Time, Comparison.Greater, 30.0))\n\nrobot.move(m2, d2)\n\n# Check if the reaction was triggered\nif d2.has_fired:\n  robot.recover_from_errors()\n  print('Force exceeded 10N!')\n```\n\nOnce a reaction has fired, it will be neglected furthermore. In C++ you can additionally use lambdas to define more complex behaviours:\n```c++\n// Stop motion if force is over 10N\nauto data = MotionData()\n  .withReaction({\n    Measure::ForceXYZNorm, Comparison::Greater, 10.0  // [N]\n  })\n  .withReaction({\n    [](const franka::RobotState& state, double time) {\n      return (state.current_errors.self_collision_avoidance_violation);\n    }\n  });\n\n// Hold position for 5s\nrobot.move(PositionHold(5.0), data); // [s]\n// e.g. combined with a PositionHold, the robot continues its program after pushing the end effector.\n```\n\n\n### Real-Time Waypoint Motion\n\nWhile the robot moves in a background thread, you can change the waypoints in real-time. This is currently only possible from the C++ API.\n```c++\nrobot.moveAsync(motion_hold);\n\n// Wait for key input from user\nstd::cin.get();\n\nmotion_hold.setNextWaypoint(Waypoint(Affine(0.0, 0.0, 0.1), Waypoint::ReferenceType::Relative);\n```\n\nIf you need this functionality using Python, feel free to make a pull request!\n\n\n### Gripper\n\nIn the `frankx::Gripper` class, the default gripper force and gripper speed can be set. Then, additionally to the libfranka commands, the following helper methods can be used:\n\n```c++\nauto gripper = Gripper(\"172.16.0.2\");\n\n// These are the default values\ngripper.gripper_speed = 0.02; // [m/s]\ngripper.gripper_force = 20.0; // [N]\n\n// Preshape gripper before grasp, use the given speed\ngripper.move(50.0); // [mm]\n\n// Grasp an object of unknown width\nis_grasping = gripper.clamp();\n\n// Do something\nis_grasping &= gripper.isGrasping();\n\n// Release an object and move to a given distance\nif (is_grasping) {\n  gripper.release(50.0);\n}\n```\n\nThe Python API should be very straight-forward for the Gripper class.\n\n\n## Documentation\n\nWe will add a more detailed documentation once frankx reaches v1.0. However, you can find multiple examples for both C++ and Python in the [examples](https://github.com/pantor/frankx/tree/master/examples) directory. We also try to add more examples over time.\n\n\n## Development\n\nFrankx is written in C++17 and Python3. It works well with ROS2. It is currently tested against following versions\n\n- Python v3.6\n- Eigen v3.3.7\n- Libfranka v0.6.0\n- Reflexxes v1.2.7\n- Pybind11 v2.2.4\n- Catch2 v2.9 (only for testing)\n\n\n## License\n\nFor non-commercial applications, this software is licensed under the LGPL v3.0. If you want to use frankx within commercial applications or under a different license, please contact us for individual agreements.\n\nRobot vector created by [freepik](https://www.freepik.com/free-photos-vectors/technology).\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pantor/frankx", "keywords": "robotics,trajectory-generation,motion-control", "license": "LGPL", "maintainer": "", "maintainer_email": "", "name": "frankx", "package_url": "https://pypi.org/project/frankx/", "platform": "", "project_url": "https://pypi.org/project/frankx/", "project_urls": {"Homepage": "https://github.com/pantor/frankx"}, "release_url": "https://pypi.org/project/frankx/0.0.1/", "requires_dist": null, "requires_python": ">=3.6", "summary": "High-Level Motion Library for the Franka Panda Robot", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div>\n  &lt;center&gt;<img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/57f33aec11a54680875ef6f94e22851348a05ade/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f70616e746f722f6672616e6b782f6d61737465722f646f632f6c6f676f2e706e67\" width=\"220\"></div>&lt;/center&gt;\n  <h3>&lt;center&gt;<i>frankx</i><br>High-Level Motion Library for the Franka Panda Robot&lt;/center&gt;</h3>\n\n<p align=\"center\">\n  <a href=\"https://github.com/pantor/frankx/actions\" rel=\"nofollow\">\n    <img alt=\"CI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b43f0cffa01877652c15a5231b333297918e4442/68747470733a2f2f6769746875622e636f6d2f70616e746f722f6672616e6b782f776f726b666c6f77732f43492f62616467652e737667\">\n  </a>\n  <a href=\"https://github.com/pantor/frankx/actions\" rel=\"nofollow\">\n    <img alt=\"Publish\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9600ad208e7b9ed7dd54fee3c6602c17a39f62f6/68747470733a2f2f6769746875622e636f6d2f70616e746f722f6672616e6b782f776f726b666c6f77732f5075626c6973682f62616467652e737667\">\n  </a>\n  <a href=\"https://github.com/pantor/frankx/issues\" rel=\"nofollow\">\n    <img alt=\"Issues\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2a3ab21993da86a77b5239ec8c543f3f14b2c72b/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6973737565732f70616e746f722f6672616e6b782e737667\">\n  </a>\n  <a href=\"https://github.com/pantor/frankx/releases\" rel=\"nofollow\">\n    <img alt=\"Releases\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/16960e45d4cd3c2a36511447a204e4b785e8dc7b/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f762f72656c656173652f70616e746f722f6672616e6b782e7376673f696e636c7564655f70726572656c656173657326736f72743d73656d766572\">\n  </a>\n  <a href=\"https://github.com/pantor/frankx/blob/master/LICENSE\" rel=\"nofollow\">\n    <img alt=\"LGPL\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/74470099a8fb5f655fc27ec2929cd7f60a94a811/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4c47504c2d677265656e2e737667\">\n  </a>\n</p>\n<p>Frankx is a high-level motion library (both C++ and Python) for the Franka Emika Panda robot. It adds a Python wrapper around <a href=\"https://frankaemika.github.io/docs/libfranka.html\" rel=\"nofollow\">libfranka</a>, while replacing necessary real-time programming with higher-level motion commands. As frankx focuses on making real-time trajectory generation easy, it allows the robot to react to unforeseen events.</p>\n\n<h2>Installation</h2>\n<p>Frankx is based on <a href=\"https://github.com/frankaemika/libfranka\" rel=\"nofollow\">libfranka</a>, <a href=\"http://reflexxes.ws\" rel=\"nofollow\">Reflexxes</a> as a trajectory-generator, <a href=\"https://eigen.tuxfamily.org\" rel=\"nofollow\">Eigen</a> for transformation calculations and <a href=\"https://github.com/pybind/pybind11\" rel=\"nofollow\">pybind11</a> for the Python bindings. Make sure to have these dependencies installed, then you can build and install frankx via</p>\n<pre>mkdir -p build\n<span class=\"nb\">cd</span> build\ncmake -DReflexxes_ROOT_DIR<span class=\"o\">=</span>../RMLTypeII -DREFLEXXES_TYPE<span class=\"o\">=</span>ReflexxesTypeII -DBUILD_TYPE<span class=\"o\">=</span>Release ..\nmake -j4\nmake install\n</pre>\n<p>Of course, you need to adapt the Reflexxes directory and type (either <code>ReflexxesTypeII</code> or <code>ReflexxesTypeIV</code>). We strongly recommend Type IV, as the Panda robot is quite sensitive to acceleration discontinuities. To use frankx, you can also include it as a subproject in your parent CMake via <code>add_subdirectory(frankx)</code> and then <code>target_link_libraries(&lt;target&gt; libfrankx)</code>. Make sure that the built library can be found from Python by adapting your Python Path.</p>\n<h2>Tutorial</h2>\n<p>Frankx comes with both a C++ and Python API that differ only regarding real-time capability. We will introduce both languages next to each other. In your C++ project, just include <code>include &lt;frankx/frankx.hpp&gt;</code> and link the library. For Python, just <code>import frankx</code>. As a first example, only four lines of code are needed for simple robotic motions.</p>\n<pre><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;frankx/frankx.hpp&gt;</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">frankx</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// Connect to the robot with the FCI IP address</span>\n<span class=\"n\">Robot</span> <span class=\"nf\">robot</span><span class=\"p\">(</span><span class=\"s\">\"172.16.0.2\"</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// Reduce velocity and acceleration of the robot</span>\n<span class=\"n\">robot</span><span class=\"p\">.</span><span class=\"n\">setDynamicRel</span><span class=\"p\">(</span><span class=\"mf\">0.05</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// Move the end-effector 20cm in positive x-direction</span>\n<span class=\"k\">auto</span> <span class=\"n\">motion</span> <span class=\"o\">=</span> <span class=\"n\">LinearRelativeMotion</span><span class=\"p\">(</span><span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">));</span>\n\n<span class=\"c1\">// Finally move the robot</span>\n<span class=\"n\">robot</span><span class=\"p\">.</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">motion</span><span class=\"p\">);</span>\n</pre>\n<p>The corresponding program in Python is</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">frankx</span> <span class=\"kn\">import</span> <span class=\"n\">Affine</span><span class=\"p\">,</span> <span class=\"n\">LinearRelativeMotion</span><span class=\"p\">,</span> <span class=\"n\">Robot</span>\n\n<span class=\"n\">robot</span> <span class=\"o\">=</span> <span class=\"n\">Robot</span><span class=\"p\">(</span><span class=\"s2\">\"172.16.0.2\"</span><span class=\"p\">)</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">set_dynamic_rel</span><span class=\"p\">(</span><span class=\"mf\">0.05</span><span class=\"p\">)</span>\n\n<span class=\"n\">motion</span> <span class=\"o\">=</span> <span class=\"n\">LinearRelativeMotion</span><span class=\"p\">(</span><span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">))</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">motion</span><span class=\"p\">)</span>\n</pre>\n<p>Furthermore, we will introduce methods for geometric calculations, for moving the robot according to different motion types, how to implement real-time reactions and changing waypoints in real time as well as controlling the gripper.</p>\n<h3>Geometry</h3>\n<p><code>frankx::Affine</code> is a thin wrapper around <a href=\"https://eigen.tuxfamily.org/dox/group__TutorialGeometry.html\" rel=\"nofollow\">Eigen::Affine3d</a>. It is used for Cartesian poses, frames and transformation. Frankx simplifies the usage of Euler angles (default ZYX-convention).</p>\n<pre><span class=\"c1\">// Initiliaze a transformation with an (x, y, z, a=0.0, b=0.0, c=0.0) translation</span>\n<span class=\"n\">Affine</span> <span class=\"n\">z_translation</span> <span class=\"o\">=</span> <span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// Define a rotation transformation using the (x, y, z, a, b, c) parameter list</span>\n<span class=\"n\">Affine</span> <span class=\"n\">z_rotation</span> <span class=\"o\">=</span> <span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"n\">M_PI</span> <span class=\"o\">/</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// Make use of the wonderful Eigen library</span>\n<span class=\"k\">auto</span> <span class=\"n\">combined_transformation</span> <span class=\"o\">=</span> <span class=\"n\">z_translation</span> <span class=\"o\">*</span> <span class=\"n\">z_rotation</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// Get the Euler angles (a, b, c) in a vector representation</span>\n<span class=\"n\">Eigen</span><span class=\"o\">::</span><span class=\"n\">Vector3d</span> <span class=\"n\">euler_angles</span> <span class=\"o\">=</span> <span class=\"n\">combined_transformation</span><span class=\"p\">.</span><span class=\"n\">angles</span><span class=\"p\">();</span>\n\n<span class=\"c1\">// Get the vector representation (x, y, z, a, b, c) of an affine transformation</span>\n<span class=\"n\">frankx</span><span class=\"o\">::</span><span class=\"n\">Vector6d</span> <span class=\"n\">pose</span> <span class=\"o\">=</span> <span class=\"n\">combined_transformation</span><span class=\"p\">.</span><span class=\"n\">vector</span><span class=\"p\">();</span>\n</pre>\n<p>In all cases, distances are in [m] and rotations in [rad]. Additionally, there are several helper functions for conversion between Eigen and libfranka's std::array objects. In python, this translates into</p>\n<pre><span class=\"n\">z_translation</span> <span class=\"o\">=</span> <span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">)</span>\n<span class=\"n\">z_rotation</span> <span class=\"o\">=</span> <span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"n\">math</span><span class=\"o\">.</span><span class=\"n\">pi</span> <span class=\"o\">/</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">)</span>\n<span class=\"n\">combined_transformation</span> <span class=\"o\">=</span> <span class=\"n\">z_translation</span> <span class=\"o\">*</span> <span class=\"n\">z_rotation</span>\n\n<span class=\"c1\"># These two are now numpy arrays</span>\n<span class=\"n\">euler_angles</span> <span class=\"o\">=</span> <span class=\"n\">combined_transformation</span><span class=\"o\">.</span><span class=\"n\">angles</span><span class=\"p\">()</span>\n<span class=\"n\">pose</span> <span class=\"o\">=</span> <span class=\"n\">combined_transformation</span><span class=\"o\">.</span><span class=\"n\">vector</span><span class=\"p\">()</span>\n</pre>\n<h3>Robot</h3>\n<p>We wrapped most of the libfanka API (including the RobotState or ErrorMessage) for Python. Moreover, we added methods to adapt the dynamics of the robot for all motions. The <code>rel</code> name denotes that this a factor of the maximum constraints of the Panda robot.</p>\n<pre><span class=\"n\">robot</span> <span class=\"o\">=</span> <span class=\"n\">Robot</span><span class=\"p\">(</span><span class=\"s2\">\"172.16.0.2\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Recover from errors</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">recover_from_errors</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Set velocity, acceleration and jerk to 5% of the maximum</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">set_dynamic_rel</span><span class=\"p\">(</span><span class=\"mf\">0.05</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Alternatively, you can define each constraint individually</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">velocity_rel</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">acceleration_rel</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">jerk_rel</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>\n</pre>\n<h3>Motion Types</h3>\n<p>Frankx defines five different motion types. In python, you can use them as follows:</p>\n<pre><span class=\"c1\"># A point-to-point motion in the joint space</span>\n<span class=\"n\">m1</span> <span class=\"o\">=</span> <span class=\"n\">JointMotion</span><span class=\"p\">([</span><span class=\"o\">-</span><span class=\"mf\">1.81194</span><span class=\"p\">,</span> <span class=\"mf\">1.17910</span><span class=\"p\">,</span> <span class=\"mf\">1.75710</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">2.1416</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.14336</span><span class=\"p\">,</span> <span class=\"mf\">1.63304</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.43217</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># A linear motion in cartesian space</span>\n<span class=\"n\">m2</span> <span class=\"o\">=</span> <span class=\"n\">LinearMotion</span><span class=\"p\">(</span><span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.4</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"n\">math</span><span class=\"o\">.</span><span class=\"n\">pi</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">))</span>\n<span class=\"n\">m3</span> <span class=\"o\">=</span> <span class=\"n\">LinearMotion</span><span class=\"p\">(</span><span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.4</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"n\">math</span><span class=\"o\">.</span><span class=\"n\">pi</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">),</span> <span class=\"n\">elbow</span><span class=\"o\">=</span><span class=\"mf\">1.7</span><span class=\"p\">)</span>  <span class=\"c1\"># With target elbow angle</span>\n\n<span class=\"c1\"># A linear motion in cartesian space relative to the initial position</span>\n<span class=\"n\">m4</span> <span class=\"o\">=</span> <span class=\"n\">LinearRelativeMotion</span><span class=\"p\">(</span><span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># A more complex motion by defining multiple waypoints</span>\n<span class=\"n\">m5</span> <span class=\"o\">=</span> <span class=\"n\">WaypointMotion</span><span class=\"p\">([</span>\n  <span class=\"n\">Waypoint</span><span class=\"p\">(</span><span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">0.4</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">)),</span>\n  <span class=\"c1\"># The following waypoint is relative to the prior one</span>\n  <span class=\"n\">Waypoint</span><span class=\"p\">(</span><span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"n\">Waypoint</span><span class=\"o\">.</span><span class=\"n\">ReferenceType</span><span class=\"o\">.</span><span class=\"n\">Relative</span><span class=\"p\">))</span>\n<span class=\"p\">])</span>\n\n<span class=\"c1\"># Hold the position for [s]</span>\n<span class=\"n\">m6</span> <span class=\"o\">=</span> <span class=\"n\">PositionHold</span><span class=\"p\">(</span><span class=\"mf\">5.0</span><span class=\"p\">)</span>\n</pre>\n<p>The real robot can be moved by applying a motion to the robot using <code>move</code>:</p>\n<pre><span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">m1</span><span class=\"p\">)</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">m2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># To use a given frame relative to the end effector</span>\n<span class=\"n\">camera_frame</span> <span class=\"o\">=</span> <span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">)</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">camera_frame</span><span class=\"p\">,</span> <span class=\"n\">m3</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># To change the dynamics of the motion, use MotionData</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">MotionData</span><span class=\"p\">(</span><span class=\"mf\">0.2</span><span class=\"p\">)</span>  <span class=\"c1\"># Using a dynamic_rel of 0.2 (eventually multiplied with robot.dynamic_rel)</span>\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">m4</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">)</span>\n</pre>\n<p>Using MotionData, you can adapt the dynamics (velocity, acceleration and jerk) of a specific motion.</p>\n<pre><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">velocity_rel</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>\n<span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">jerk_rel</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>\n</pre>\n<h3>Real-Time Reactions</h3>\n<p>By adding reactions to the motion data, the robot can react to unforeseen events. In the Python API, you can define conditions by using a comparison between a robot's value and a given threshold. If the threshold is exceeded, the reaction fires. Following comparisons are currently implemented</p>\n<pre><span class=\"n\">reaction_motion</span> <span class=\"o\">=</span> <span class=\"n\">LinearRelativeMotion</span><span class=\"p\">(</span><span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.01</span><span class=\"p\">))</span>  <span class=\"c1\"># Move up for 1cm</span>\n\n<span class=\"c1\"># Stop motion if the overall force is greater than 30N</span>\n<span class=\"n\">d1</span> <span class=\"o\">=</span> <span class=\"n\">MotionData</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">with_reaction</span><span class=\"p\">(</span><span class=\"n\">Reaction</span><span class=\"p\">(</span><span class=\"n\">Measure</span><span class=\"o\">.</span><span class=\"n\">ForceXYZNorm</span><span class=\"p\">,</span> <span class=\"n\">Comparison</span><span class=\"o\">.</span><span class=\"n\">Greater</span><span class=\"p\">,</span> <span class=\"mf\">30.0</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Apply reaction motion if the force in z-direction is greater than 10N</span>\n<span class=\"n\">d2</span> <span class=\"o\">=</span> <span class=\"n\">MotionData</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">with_reaction</span><span class=\"p\">(</span><span class=\"n\">Reaction</span><span class=\"p\">(</span><span class=\"n\">Measure</span><span class=\"o\">.</span><span class=\"n\">ForceZ</span><span class=\"p\">,</span> <span class=\"n\">Comparison</span><span class=\"o\">.</span><span class=\"n\">Greater</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span><span class=\"p\">),</span> <span class=\"n\">reaction_motion</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Stop motion if its duration is above 30s</span>\n<span class=\"n\">d3</span> <span class=\"o\">=</span> <span class=\"n\">MotionData</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">with_reaction</span><span class=\"p\">(</span><span class=\"n\">Reaction</span><span class=\"p\">(</span><span class=\"n\">Measure</span><span class=\"o\">.</span><span class=\"n\">Time</span><span class=\"p\">,</span> <span class=\"n\">Comparison</span><span class=\"o\">.</span><span class=\"n\">Greater</span><span class=\"p\">,</span> <span class=\"mf\">30.0</span><span class=\"p\">))</span>\n\n<span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">m2</span><span class=\"p\">,</span> <span class=\"n\">d2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Check if the reaction was triggered</span>\n<span class=\"k\">if</span> <span class=\"n\">d2</span><span class=\"o\">.</span><span class=\"n\">has_fired</span><span class=\"p\">:</span>\n  <span class=\"n\">robot</span><span class=\"o\">.</span><span class=\"n\">recover_from_errors</span><span class=\"p\">()</span>\n  <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Force exceeded 10N!'</span><span class=\"p\">)</span>\n</pre>\n<p>Once a reaction has fired, it will be neglected furthermore. In C++ you can additionally use lambdas to define more complex behaviours:</p>\n<pre><span class=\"c1\">// Stop motion if force is over 10N</span>\n<span class=\"k\">auto</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">MotionData</span><span class=\"p\">()</span>\n  <span class=\"p\">.</span><span class=\"n\">withReaction</span><span class=\"p\">({</span>\n    <span class=\"n\">Measure</span><span class=\"o\">::</span><span class=\"n\">ForceXYZNorm</span><span class=\"p\">,</span> <span class=\"n\">Comparison</span><span class=\"o\">::</span><span class=\"n\">Greater</span><span class=\"p\">,</span> <span class=\"mf\">10.0</span>  <span class=\"c1\">// [N]</span>\n  <span class=\"p\">})</span>\n  <span class=\"p\">.</span><span class=\"n\">withReaction</span><span class=\"p\">({</span>\n    <span class=\"p\">[](</span><span class=\"k\">const</span> <span class=\"n\">franka</span><span class=\"o\">::</span><span class=\"n\">RobotState</span><span class=\"o\">&amp;</span> <span class=\"n\">state</span><span class=\"p\">,</span> <span class=\"kt\">double</span> <span class=\"n\">time</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">state</span><span class=\"p\">.</span><span class=\"n\">current_errors</span><span class=\"p\">.</span><span class=\"n\">self_collision_avoidance_violation</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">});</span>\n\n<span class=\"c1\">// Hold position for 5s</span>\n<span class=\"n\">robot</span><span class=\"p\">.</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">PositionHold</span><span class=\"p\">(</span><span class=\"mf\">5.0</span><span class=\"p\">),</span> <span class=\"n\">data</span><span class=\"p\">);</span> <span class=\"c1\">// [s]</span>\n<span class=\"c1\">// e.g. combined with a PositionHold, the robot continues its program after pushing the end effector.</span>\n</pre>\n<h3>Real-Time Waypoint Motion</h3>\n<p>While the robot moves in a background thread, you can change the waypoints in real-time. This is currently only possible from the C++ API.</p>\n<pre><span class=\"n\">robot</span><span class=\"p\">.</span><span class=\"n\">moveAsync</span><span class=\"p\">(</span><span class=\"n\">motion_hold</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// Wait for key input from user</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cin</span><span class=\"p\">.</span><span class=\"n\">get</span><span class=\"p\">();</span>\n\n<span class=\"n\">motion_hold</span><span class=\"p\">.</span><span class=\"n\">setNextWaypoint</span><span class=\"p\">(</span><span class=\"n\">Waypoint</span><span class=\"p\">(</span><span class=\"n\">Affine</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">),</span> <span class=\"n\">Waypoint</span><span class=\"o\">::</span><span class=\"n\">ReferenceType</span><span class=\"o\">::</span><span class=\"n\">Relative</span><span class=\"p\">);</span>\n</pre>\n<p>If you need this functionality using Python, feel free to make a pull request!</p>\n<h3>Gripper</h3>\n<p>In the <code>frankx::Gripper</code> class, the default gripper force and gripper speed can be set. Then, additionally to the libfranka commands, the following helper methods can be used:</p>\n<pre><span class=\"k\">auto</span> <span class=\"n\">gripper</span> <span class=\"o\">=</span> <span class=\"n\">Gripper</span><span class=\"p\">(</span><span class=\"s\">\"172.16.0.2\"</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// These are the default values</span>\n<span class=\"n\">gripper</span><span class=\"p\">.</span><span class=\"n\">gripper_speed</span> <span class=\"o\">=</span> <span class=\"mf\">0.02</span><span class=\"p\">;</span> <span class=\"c1\">// [m/s]</span>\n<span class=\"n\">gripper</span><span class=\"p\">.</span><span class=\"n\">gripper_force</span> <span class=\"o\">=</span> <span class=\"mf\">20.0</span><span class=\"p\">;</span> <span class=\"c1\">// [N]</span>\n\n<span class=\"c1\">// Preshape gripper before grasp, use the given speed</span>\n<span class=\"n\">gripper</span><span class=\"p\">.</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"mf\">50.0</span><span class=\"p\">);</span> <span class=\"c1\">// [mm]</span>\n\n<span class=\"c1\">// Grasp an object of unknown width</span>\n<span class=\"n\">is_grasping</span> <span class=\"o\">=</span> <span class=\"n\">gripper</span><span class=\"p\">.</span><span class=\"n\">clamp</span><span class=\"p\">();</span>\n\n<span class=\"c1\">// Do something</span>\n<span class=\"n\">is_grasping</span> <span class=\"o\">&amp;=</span> <span class=\"n\">gripper</span><span class=\"p\">.</span><span class=\"n\">isGrasping</span><span class=\"p\">();</span>\n\n<span class=\"c1\">// Release an object and move to a given distance</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">is_grasping</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"n\">gripper</span><span class=\"p\">.</span><span class=\"n\">release</span><span class=\"p\">(</span><span class=\"mf\">50.0</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</pre>\n<p>The Python API should be very straight-forward for the Gripper class.</p>\n<h2>Documentation</h2>\n<p>We will add a more detailed documentation once frankx reaches v1.0. However, you can find multiple examples for both C++ and Python in the <a href=\"https://github.com/pantor/frankx/tree/master/examples\" rel=\"nofollow\">examples</a> directory. We also try to add more examples over time.</p>\n<h2>Development</h2>\n<p>Frankx is written in C++17 and Python3. It works well with ROS2. It is currently tested against following versions</p>\n<ul>\n<li>Python v3.6</li>\n<li>Eigen v3.3.7</li>\n<li>Libfranka v0.6.0</li>\n<li>Reflexxes v1.2.7</li>\n<li>Pybind11 v2.2.4</li>\n<li>Catch2 v2.9 (only for testing)</li>\n</ul>\n<h2>License</h2>\n<p>For non-commercial applications, this software is licensed under the LGPL v3.0. If you want to use frankx within commercial applications or under a different license, please contact us for individual agreements.</p>\n<p>Robot vector created by <a href=\"https://www.freepik.com/free-photos-vectors/technology\" rel=\"nofollow\">freepik</a>.</p>\n\n          </div>"}, "last_serial": 6008360, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "39245bdde4375b203d069f8456e0b158", "sha256": "ac57894c5e0912a9d71b467c3905d926d6af1277b69f4d07cc39ab6eac548990"}, "downloads": -1, "filename": "frankx-0.0.1-cp36-cp36m-manylinux2010_x86_64.whl", "has_sig": false, "md5_digest": "39245bdde4375b203d069f8456e0b158", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": ">=3.6", "size": 1741708, "upload_time": "2019-10-21T17:18:36", "upload_time_iso_8601": "2019-10-21T17:18:36.253776Z", "url": "https://files.pythonhosted.org/packages/45/fe/f06c2490e8550889b32120b723a236349e2a2b66ca4a022f2a8982b3e3c7/frankx-0.0.1-cp36-cp36m-manylinux2010_x86_64.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "39245bdde4375b203d069f8456e0b158", "sha256": "ac57894c5e0912a9d71b467c3905d926d6af1277b69f4d07cc39ab6eac548990"}, "downloads": -1, "filename": "frankx-0.0.1-cp36-cp36m-manylinux2010_x86_64.whl", "has_sig": false, "md5_digest": "39245bdde4375b203d069f8456e0b158", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": ">=3.6", "size": 1741708, "upload_time": "2019-10-21T17:18:36", "upload_time_iso_8601": "2019-10-21T17:18:36.253776Z", "url": "https://files.pythonhosted.org/packages/45/fe/f06c2490e8550889b32120b723a236349e2a2b66ca4a022f2a8982b3e3c7/frankx-0.0.1-cp36-cp36m-manylinux2010_x86_64.whl", "yanked": false}], "timestamp": "Fri May  8 01:00:33 2020"}