{"info": {"author": "deepomatic", "author_email": "support@deepomatic.com", "bugtrack_url": null, "classifiers": ["Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "# Table of contents\n\n- [Deepomatic Remote Procedure Call](#deepomatic-remote-procedure-call)\n- [Installation](#installation)\n- [Usage](#usage)\n  * [Getting started](#getting-started)\n    + [Instanciate client and queues](#instanciate-client-and-queues)\n    + [Send recognition request](#send-recognition-request)\n    + [Stream and cleanup](#stream-and-cleanup)\n  * [Advanced](#advanced)\n    + [Shortcuts](#shortcuts)\n    + [Image input examples](#image-input-examples)\n- [Bugs](#bugs)\n\n# Deepomatic Remote Procedure Call\n\n[Deepomatic](https://www.deepomatic.com) Remote Procedure Call.\n\nThis remote procedure call has been made to help you interacting with our on-premises inference service.\nYou might also want to use our command line interface [deepomatic-cli](https://pypi.org/project/deepomatic-cli/).\n\n# Installation\n\n# Online\n\n```bash\npip install deepomatic-rpc\n```\n\n# Offline\n\nOn a machine with internet access you will need to download the package and its dependencies with the command below:\n\n```bash\nmkdir deepomatic-rpc\n# --platform force to get the packages compatibles with all OS\npip download --platform any --only-binary=:all: -d ./deepomatic-rpc deepomatic-rpc\n```\n\nThen save the `deepomatic-rpc` directory on the storage device of your choice.\n\nNow retrieve this directory on the offline machine and install the package:\n\n```bash\npip install --no-index --find-links ./deepomatic-rpc ./deepomatic-rpc/deepomatic_rpc-*-py2.py3-none-any.whl\n```\n\n# Usage\n\n## Getting started\n\n### Instanciate client and queues\n\n```python\nfrom deepomatic.rpc.client import Client\n\n# Replace placeholder variables with yours\ncommand_queue_name = 'my_command_queue'\nrecognition_version_id = 123\namqp_url = 'amqp://myuser:mypassword@localhost:5672/myvhost'\n\n# Instanciate client\nclient = Client(amqp_url)\n\n# Do the following for each stream\n\n# Declare lasting command queue\ncommand_queue = client.new_queue(command_queue_name)\n\n# Declare response queue and consumer to get responses\n# consumer is linked to the response_queue\n# If queue_name parameter is provided, will declare a durable queue\n# Otherwise it is an uniq temporary queue.\nresponse_queue, consumer = client.new_consuming_queue()\n\n# Don't forget to cleanup when you are done sending requests !\n```\n\n### Send recognition request\n\n```python\nfrom deepomatic.rpc import v07_ImageInput\nfrom deepomatic.rpc.response import wait\nfrom deepomatic.rpc.helpers.v07_proto import create_images_input_mix, create_recognition_command_mix\n\n# Create a recognition command mix\ncommand_mix = create_recognition_command_mix(recognition_version_id, max_predictions=100, show_discarded=False)\n\n# Create one image input\nimage_input = v07_ImageInput(source='https://static.wamiz.fr/images/animaux/chats/large/bengal.jpg'.encode())\n\n# Wrap it inside a generic input mix\ninput_mix = create_images_input_mix([image_input])\n\n# Send the request\ncorrelation_id = client.command(command_queue_name, response_queue.name, command_mix, input_mix)\n\n# Wait for response, `timeout=float('inf')` or `timeout=-1` for infinite wait, `timeout=None` for non blocking\nresponse = consumer.get(correlation_id, timeout=5)\n\n# get_labelled_output() is a shortcut that give you the corresponding predictions depending on the command mix you used\n# and raise a ServerError in case of error on the worker side. It should cover most cases but if it doesn't fit your needs, see the Response class. You might want to handle result and errors by yourself using `response.to_result_buffer()`.\nlabels = response.get_labelled_output()\npredicted = labels.predicted[0]  # Predicted is ordered by score\nprint(\"Predicted label {} with score {}\".format(predicted.label_name, predicted.score))\n# if show_discarded was True, you might want to read `labels.discarded` to see which labels have a low confidence.\n```\n\n### Stream and cleanup\n\nWhen you are done with a stream you should cleanup your consuming queues.\n- If your program stops right after, the consumer get cancelled and the queue will automatically be removed after 2 hours of inactivity (only if the queue is a uniq temporary queue).\n- If your program is a long running job, after 2 hours of inactivity the queue might be removed and the consumer cancelled by the broker, but the client might consider redeclaring both in case of a broker error.\n\nThus calling `client.remove_consuming_queue()` remove the queue and makes sure the consumer is cancelled and not redeclared later:\n\n```python\nclient.remove_consuming_queue(response_queue, consumer)\n```\n\nYou might also want to remove a queue without consumer using:\n\n```python\nclient.remove_queue(queue)\n```\n\nAlso instead of using `new_consuming_queue()` with no queue_name parameter and `remove_consuming_queue()` you might want to use the contextmanager version:\n\n```python\nwith client.tmp_consuming_queue() as (response_queue, consumer):\n    # this creates a temporary queue alive for the rest of this scope\n    # do your inference requests\n```\n\nIf you don't want to care about the response queue and consumer, we provide a high level class `RPCStream`.\nBy default it saves all correlation_ids so that you can call `get_next_response()` to get responses in the same order that you pushed the requests:\n\n```python\nfrom deepomatic.rpc.helpers.proto import create_v07_images_command\n\nserialized_buffer = create_v07_images_command([image_input], command_mix)\n\nwith client.new_stream(command_queue_name) as stream:\n    # it internally saves the correlation_id so that it can retrieve responses in order\n    # You need to call as many time get_next_response() as send_binary(), or the internal correlation_ids list will keep growing up\n    stream.send_binary(serialized_buffer)\n    response = stream.get_next_response(timeout=1)\n```\n\nAlso you might want to handle response order by yourself, in this case you can create the stream in the following way:\n```python\n# with keep_response_order=False, the stream will not buffer correlation_ids\nwith client.new_stream(command_queue_name, keep_response_order=False):\n    correlation_id = stream.send_binary(serialized_buffer)\n    # directly access the stream's consumer to retrieve a specific response\n    response = stream.consumer.get(correlation_id, timeout=1)\n```\n\n**IMPORTANT**: If you don't use the with statement, you will have to call `stream.close()` at the end to clean consumer and response queue.\n\n## Advanced\n\n### Shortcuts\n\n* You can avoid calling `create_images_input_mix` and directly sending the image_input list via the method `client.v07_images_command` which will call internally `create_images_input_mix`:\n\n```python\ncorrelation_id = client.v07_images_command(command_queue_name, response_queue.name, [image_input], command_mix)\n```\n\n* Create a workflow command mix. The recognition_version_id is deduced but the command queue name must match the recognition in the workflows.json.\nNote that it doesn't allow to specify `show_discarded` or `max_predictions`:\n\n```python\nfrom deepomatic.rpc.helpers.v07_proto import create_workflow_command_mix\ncommand_mix = create_workflow_command_mix()\n```\n\n* Create an inference command mix; the response will be a raw tensor :\n\n```python\nfrom deepomatic.rpc.helpers.v07_proto import create_inference_command_mix\noutput_tensors = ['prod']\ncommand_mix = create_inference_command_mix(output_tensors)\n```\n\n* Wait multiples correlation ids at once:\n\n```python\nfrom deepomatic.rpc.response import wait_responses\n# Wait for responses, `timeout=float('inf')` or `timeout=-1` for infinite wait\nresponses, pending = wait_responses(consumer, correlation_ids, timeout=10)\n\nprint(responses)\n# will print [(0, response), (1, response), (2, response)]\n# 0, 1, 2 are the position in correlation_ids list in case you want to retrieve their original correlation_id\n# the list is sorted by positions to keep the same order as the correlation_ids list\n# if no timeout reached len(response) == len(correlation_ids)\n\nprint(pending)\n# should be empty if timeout has not been reached\n# otherwise should print a list of correlation_id position that didn't get a response (the list is sorted)\n# If print [3, 5], then correlations_ids[3] and correlation_id[5] didn't get a response on time\n```\n\n### Image input examples\n\n* Create an image input with a bounding box:\n\n```python\nfrom deepomatic.rpc import v07_ImageInput\nfrom deepomatic.rpc import BBox\n# Coordinates between 0 and 1\nbbox = BBox(xmin=0.3, xmax=0.8, ymin=0.1, ymax=0.9)\nimage_input = v07_ImageInput(source='https://static.wamiz.fr/images/animaux/chats/large/bengal.jpg'.encode(),\n                             bbox=bbox)\n```\n\n* Create an image input with a polygon selection:\n```python\nfrom deepomatic.rpc import v07_ImageInput\nfrom deepomatic.rpc import Point\n# Coordinates between 0 and 1, minimum 3 points needed\npolygon = [Point(x=0.1, y=0.1), Point(x=0.9, y=0.1), Point(x=0.5, y=0.9)]\nimage_input = v07_ImageInput(source='https://static.wamiz.fr/images/animaux/chats/large/bengal.jpg'.encode(),\n                             polygon=polygon)\n```\n\n* Create an image input from a file on the disk:\n```python\nfrom deepomatic.rpc import v07_ImageInput\nfrom deepomatic.rpc.helpers.proto import binary_source_from_img_file\nbinary_content = binary_source_from_img_file(filename)  # Also works if you give a fileobj\nimage_input = v07_ImageInput(source=binary_content)\n```\n\n# Bugs\n\nPlease send bug reports to support@deepomatic.com\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://www.deepomatic.com", "keywords": "", "license": "UNLICENSED", "maintainer": "", "maintainer_email": "", "name": "deepomatic-rpc", "package_url": "https://pypi.org/project/deepomatic-rpc/", "platform": "", "project_url": "https://pypi.org/project/deepomatic-rpc/", "project_urls": {"Homepage": "https://www.deepomatic.com", "Product": "https://www.deepomatic.com"}, "release_url": "https://pypi.org/project/deepomatic-rpc/0.8.3/", "requires_dist": ["kombu (==4.2.2.post1)", "amqp (==2.4.1)", "protobuf (==3.6.1)", "grpcio (==1.20.1)"], "requires_python": "", "summary": "Deepomatic RPC python client", "version": "0.8.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Table of contents</h1>\n<ul>\n<li><a href=\"#deepomatic-remote-procedure-call\" rel=\"nofollow\">Deepomatic Remote Procedure Call</a></li>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#usage\" rel=\"nofollow\">Usage</a>\n<ul>\n<li><a href=\"#getting-started\" rel=\"nofollow\">Getting started</a>\n<ul>\n<li><a href=\"#instanciate-client-and-queues\" rel=\"nofollow\">Instanciate client and queues</a></li>\n<li><a href=\"#send-recognition-request\" rel=\"nofollow\">Send recognition request</a></li>\n<li><a href=\"#stream-and-cleanup\" rel=\"nofollow\">Stream and cleanup</a></li>\n</ul>\n</li>\n<li><a href=\"#advanced\" rel=\"nofollow\">Advanced</a>\n<ul>\n<li><a href=\"#shortcuts\" rel=\"nofollow\">Shortcuts</a></li>\n<li><a href=\"#image-input-examples\" rel=\"nofollow\">Image input examples</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#bugs\" rel=\"nofollow\">Bugs</a></li>\n</ul>\n<h1>Deepomatic Remote Procedure Call</h1>\n<p><a href=\"https://www.deepomatic.com\" rel=\"nofollow\">Deepomatic</a> Remote Procedure Call.</p>\n<p>This remote procedure call has been made to help you interacting with our on-premises inference service.\nYou might also want to use our command line interface <a href=\"https://pypi.org/project/deepomatic-cli/\" rel=\"nofollow\">deepomatic-cli</a>.</p>\n<h1>Installation</h1>\n<h1>Online</h1>\n<pre>pip install deepomatic-rpc\n</pre>\n<h1>Offline</h1>\n<p>On a machine with internet access you will need to download the package and its dependencies with the command below:</p>\n<pre>mkdir deepomatic-rpc\n<span class=\"c1\"># --platform force to get the packages compatibles with all OS</span>\npip download --platform any --only-binary<span class=\"o\">=</span>:all: -d ./deepomatic-rpc deepomatic-rpc\n</pre>\n<p>Then save the <code>deepomatic-rpc</code> directory on the storage device of your choice.</p>\n<p>Now retrieve this directory on the offline machine and install the package:</p>\n<pre>pip install --no-index --find-links ./deepomatic-rpc ./deepomatic-rpc/deepomatic_rpc-*-py2.py3-none-any.whl\n</pre>\n<h1>Usage</h1>\n<h2>Getting started</h2>\n<h3>Instanciate client and queues</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc.client</span> <span class=\"kn\">import</span> <span class=\"n\">Client</span>\n\n<span class=\"c1\"># Replace placeholder variables with yours</span>\n<span class=\"n\">command_queue_name</span> <span class=\"o\">=</span> <span class=\"s1\">'my_command_queue'</span>\n<span class=\"n\">recognition_version_id</span> <span class=\"o\">=</span> <span class=\"mi\">123</span>\n<span class=\"n\">amqp_url</span> <span class=\"o\">=</span> <span class=\"s1\">'amqp://myuser:mypassword@localhost:5672/myvhost'</span>\n\n<span class=\"c1\"># Instanciate client</span>\n<span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"n\">Client</span><span class=\"p\">(</span><span class=\"n\">amqp_url</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Do the following for each stream</span>\n\n<span class=\"c1\"># Declare lasting command queue</span>\n<span class=\"n\">command_queue</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">new_queue</span><span class=\"p\">(</span><span class=\"n\">command_queue_name</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Declare response queue and consumer to get responses</span>\n<span class=\"c1\"># consumer is linked to the response_queue</span>\n<span class=\"c1\"># If queue_name parameter is provided, will declare a durable queue</span>\n<span class=\"c1\"># Otherwise it is an uniq temporary queue.</span>\n<span class=\"n\">response_queue</span><span class=\"p\">,</span> <span class=\"n\">consumer</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">new_consuming_queue</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Don't forget to cleanup when you are done sending requests !</span>\n</pre>\n<h3>Send recognition request</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc</span> <span class=\"kn\">import</span> <span class=\"n\">v07_ImageInput</span>\n<span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc.response</span> <span class=\"kn\">import</span> <span class=\"n\">wait</span>\n<span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc.helpers.v07_proto</span> <span class=\"kn\">import</span> <span class=\"n\">create_images_input_mix</span><span class=\"p\">,</span> <span class=\"n\">create_recognition_command_mix</span>\n\n<span class=\"c1\"># Create a recognition command mix</span>\n<span class=\"n\">command_mix</span> <span class=\"o\">=</span> <span class=\"n\">create_recognition_command_mix</span><span class=\"p\">(</span><span class=\"n\">recognition_version_id</span><span class=\"p\">,</span> <span class=\"n\">max_predictions</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">show_discarded</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Create one image input</span>\n<span class=\"n\">image_input</span> <span class=\"o\">=</span> <span class=\"n\">v07_ImageInput</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s1\">'https://static.wamiz.fr/images/animaux/chats/large/bengal.jpg'</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">())</span>\n\n<span class=\"c1\"># Wrap it inside a generic input mix</span>\n<span class=\"n\">input_mix</span> <span class=\"o\">=</span> <span class=\"n\">create_images_input_mix</span><span class=\"p\">([</span><span class=\"n\">image_input</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Send the request</span>\n<span class=\"n\">correlation_id</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">command</span><span class=\"p\">(</span><span class=\"n\">command_queue_name</span><span class=\"p\">,</span> <span class=\"n\">response_queue</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">command_mix</span><span class=\"p\">,</span> <span class=\"n\">input_mix</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Wait for response, `timeout=float('inf')` or `timeout=-1` for infinite wait, `timeout=None` for non blocking</span>\n<span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">consumer</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">correlation_id</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># get_labelled_output() is a shortcut that give you the corresponding predictions depending on the command mix you used</span>\n<span class=\"c1\"># and raise a ServerError in case of error on the worker side. It should cover most cases but if it doesn't fit your needs, see the Response class. You might want to handle result and errors by yourself using `response.to_result_buffer()`.</span>\n<span class=\"n\">labels</span> <span class=\"o\">=</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">get_labelled_output</span><span class=\"p\">()</span>\n<span class=\"n\">predicted</span> <span class=\"o\">=</span> <span class=\"n\">labels</span><span class=\"o\">.</span><span class=\"n\">predicted</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># Predicted is ordered by score</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Predicted label </span><span class=\"si\">{}</span><span class=\"s2\"> with score </span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">predicted</span><span class=\"o\">.</span><span class=\"n\">label_name</span><span class=\"p\">,</span> <span class=\"n\">predicted</span><span class=\"o\">.</span><span class=\"n\">score</span><span class=\"p\">))</span>\n<span class=\"c1\"># if show_discarded was True, you might want to read `labels.discarded` to see which labels have a low confidence.</span>\n</pre>\n<h3>Stream and cleanup</h3>\n<p>When you are done with a stream you should cleanup your consuming queues.</p>\n<ul>\n<li>If your program stops right after, the consumer get cancelled and the queue will automatically be removed after 2 hours of inactivity (only if the queue is a uniq temporary queue).</li>\n<li>If your program is a long running job, after 2 hours of inactivity the queue might be removed and the consumer cancelled by the broker, but the client might consider redeclaring both in case of a broker error.</li>\n</ul>\n<p>Thus calling <code>client.remove_consuming_queue()</code> remove the queue and makes sure the consumer is cancelled and not redeclared later:</p>\n<pre><span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">remove_consuming_queue</span><span class=\"p\">(</span><span class=\"n\">response_queue</span><span class=\"p\">,</span> <span class=\"n\">consumer</span><span class=\"p\">)</span>\n</pre>\n<p>You might also want to remove a queue without consumer using:</p>\n<pre><span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">remove_queue</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"p\">)</span>\n</pre>\n<p>Also instead of using <code>new_consuming_queue()</code> with no queue_name parameter and <code>remove_consuming_queue()</code> you might want to use the contextmanager version:</p>\n<pre><span class=\"k\">with</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">tmp_consuming_queue</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"p\">(</span><span class=\"n\">response_queue</span><span class=\"p\">,</span> <span class=\"n\">consumer</span><span class=\"p\">):</span>\n    <span class=\"c1\"># this creates a temporary queue alive for the rest of this scope</span>\n    <span class=\"c1\"># do your inference requests</span>\n</pre>\n<p>If you don't want to care about the response queue and consumer, we provide a high level class <code>RPCStream</code>.\nBy default it saves all correlation_ids so that you can call <code>get_next_response()</code> to get responses in the same order that you pushed the requests:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc.helpers.proto</span> <span class=\"kn\">import</span> <span class=\"n\">create_v07_images_command</span>\n\n<span class=\"n\">serialized_buffer</span> <span class=\"o\">=</span> <span class=\"n\">create_v07_images_command</span><span class=\"p\">([</span><span class=\"n\">image_input</span><span class=\"p\">],</span> <span class=\"n\">command_mix</span><span class=\"p\">)</span>\n\n<span class=\"k\">with</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">new_stream</span><span class=\"p\">(</span><span class=\"n\">command_queue_name</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">stream</span><span class=\"p\">:</span>\n    <span class=\"c1\"># it internally saves the correlation_id so that it can retrieve responses in order</span>\n    <span class=\"c1\"># You need to call as many time get_next_response() as send_binary(), or the internal correlation_ids list will keep growing up</span>\n    <span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">send_binary</span><span class=\"p\">(</span><span class=\"n\">serialized_buffer</span><span class=\"p\">)</span>\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">get_next_response</span><span class=\"p\">(</span><span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>Also you might want to handle response order by yourself, in this case you can create the stream in the following way:</p>\n<pre><span class=\"c1\"># with keep_response_order=False, the stream will not buffer correlation_ids</span>\n<span class=\"k\">with</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">new_stream</span><span class=\"p\">(</span><span class=\"n\">command_queue_name</span><span class=\"p\">,</span> <span class=\"n\">keep_response_order</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n    <span class=\"n\">correlation_id</span> <span class=\"o\">=</span> <span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">send_binary</span><span class=\"p\">(</span><span class=\"n\">serialized_buffer</span><span class=\"p\">)</span>\n    <span class=\"c1\"># directly access the stream's consumer to retrieve a specific response</span>\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">stream</span><span class=\"o\">.</span><span class=\"n\">consumer</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">correlation_id</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p><strong>IMPORTANT</strong>: If you don't use the with statement, you will have to call <code>stream.close()</code> at the end to clean consumer and response queue.</p>\n<h2>Advanced</h2>\n<h3>Shortcuts</h3>\n<ul>\n<li>You can avoid calling <code>create_images_input_mix</code> and directly sending the image_input list via the method <code>client.v07_images_command</code> which will call internally <code>create_images_input_mix</code>:</li>\n</ul>\n<pre><span class=\"n\">correlation_id</span> <span class=\"o\">=</span> <span class=\"n\">client</span><span class=\"o\">.</span><span class=\"n\">v07_images_command</span><span class=\"p\">(</span><span class=\"n\">command_queue_name</span><span class=\"p\">,</span> <span class=\"n\">response_queue</span><span class=\"o\">.</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"n\">image_input</span><span class=\"p\">],</span> <span class=\"n\">command_mix</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li>Create a workflow command mix. The recognition_version_id is deduced but the command queue name must match the recognition in the workflows.json.\nNote that it doesn't allow to specify <code>show_discarded</code> or <code>max_predictions</code>:</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc.helpers.v07_proto</span> <span class=\"kn\">import</span> <span class=\"n\">create_workflow_command_mix</span>\n<span class=\"n\">command_mix</span> <span class=\"o\">=</span> <span class=\"n\">create_workflow_command_mix</span><span class=\"p\">()</span>\n</pre>\n<ul>\n<li>Create an inference command mix; the response will be a raw tensor :</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc.helpers.v07_proto</span> <span class=\"kn\">import</span> <span class=\"n\">create_inference_command_mix</span>\n<span class=\"n\">output_tensors</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">'prod'</span><span class=\"p\">]</span>\n<span class=\"n\">command_mix</span> <span class=\"o\">=</span> <span class=\"n\">create_inference_command_mix</span><span class=\"p\">(</span><span class=\"n\">output_tensors</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li>Wait multiples correlation ids at once:</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc.response</span> <span class=\"kn\">import</span> <span class=\"n\">wait_responses</span>\n<span class=\"c1\"># Wait for responses, `timeout=float('inf')` or `timeout=-1` for infinite wait</span>\n<span class=\"n\">responses</span><span class=\"p\">,</span> <span class=\"n\">pending</span> <span class=\"o\">=</span> <span class=\"n\">wait_responses</span><span class=\"p\">(</span><span class=\"n\">consumer</span><span class=\"p\">,</span> <span class=\"n\">correlation_ids</span><span class=\"p\">,</span> <span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">responses</span><span class=\"p\">)</span>\n<span class=\"c1\"># will print [(0, response), (1, response), (2, response)]</span>\n<span class=\"c1\"># 0, 1, 2 are the position in correlation_ids list in case you want to retrieve their original correlation_id</span>\n<span class=\"c1\"># the list is sorted by positions to keep the same order as the correlation_ids list</span>\n<span class=\"c1\"># if no timeout reached len(response) == len(correlation_ids)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">pending</span><span class=\"p\">)</span>\n<span class=\"c1\"># should be empty if timeout has not been reached</span>\n<span class=\"c1\"># otherwise should print a list of correlation_id position that didn't get a response (the list is sorted)</span>\n<span class=\"c1\"># If print [3, 5], then correlations_ids[3] and correlation_id[5] didn't get a response on time</span>\n</pre>\n<h3>Image input examples</h3>\n<ul>\n<li>Create an image input with a bounding box:</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc</span> <span class=\"kn\">import</span> <span class=\"n\">v07_ImageInput</span>\n<span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc</span> <span class=\"kn\">import</span> <span class=\"n\">BBox</span>\n<span class=\"c1\"># Coordinates between 0 and 1</span>\n<span class=\"n\">bbox</span> <span class=\"o\">=</span> <span class=\"n\">BBox</span><span class=\"p\">(</span><span class=\"n\">xmin</span><span class=\"o\">=</span><span class=\"mf\">0.3</span><span class=\"p\">,</span> <span class=\"n\">xmax</span><span class=\"o\">=</span><span class=\"mf\">0.8</span><span class=\"p\">,</span> <span class=\"n\">ymin</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">ymax</span><span class=\"o\">=</span><span class=\"mf\">0.9</span><span class=\"p\">)</span>\n<span class=\"n\">image_input</span> <span class=\"o\">=</span> <span class=\"n\">v07_ImageInput</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s1\">'https://static.wamiz.fr/images/animaux/chats/large/bengal.jpg'</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(),</span>\n                             <span class=\"n\">bbox</span><span class=\"o\">=</span><span class=\"n\">bbox</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li>Create an image input with a polygon selection:</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc</span> <span class=\"kn\">import</span> <span class=\"n\">v07_ImageInput</span>\n<span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc</span> <span class=\"kn\">import</span> <span class=\"n\">Point</span>\n<span class=\"c1\"># Coordinates between 0 and 1, minimum 3 points needed</span>\n<span class=\"n\">polygon</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">Point</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">),</span> <span class=\"n\">Point</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">),</span> <span class=\"n\">Point</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"mf\">0.9</span><span class=\"p\">)]</span>\n<span class=\"n\">image_input</span> <span class=\"o\">=</span> <span class=\"n\">v07_ImageInput</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"o\">=</span><span class=\"s1\">'https://static.wamiz.fr/images/animaux/chats/large/bengal.jpg'</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">(),</span>\n                             <span class=\"n\">polygon</span><span class=\"o\">=</span><span class=\"n\">polygon</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li>Create an image input from a file on the disk:</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc</span> <span class=\"kn\">import</span> <span class=\"n\">v07_ImageInput</span>\n<span class=\"kn\">from</span> <span class=\"nn\">deepomatic.rpc.helpers.proto</span> <span class=\"kn\">import</span> <span class=\"n\">binary_source_from_img_file</span>\n<span class=\"n\">binary_content</span> <span class=\"o\">=</span> <span class=\"n\">binary_source_from_img_file</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"p\">)</span>  <span class=\"c1\"># Also works if you give a fileobj</span>\n<span class=\"n\">image_input</span> <span class=\"o\">=</span> <span class=\"n\">v07_ImageInput</span><span class=\"p\">(</span><span class=\"n\">source</span><span class=\"o\">=</span><span class=\"n\">binary_content</span><span class=\"p\">)</span>\n</pre>\n<h1>Bugs</h1>\n<p>Please send bug reports to <a href=\"mailto:support@deepomatic.com\">support@deepomatic.com</a></p>\n\n          </div>"}, "last_serial": 6655462, "releases": {"0.8.0": [{"comment_text": "", "digests": {"md5": "d27d1cc8b15bbcb7f8772302bf47a5d5", "sha256": "b703759b913ae160e05733590e006809c672f05020aadaa2c51aebe91917bf74"}, "downloads": -1, "filename": "deepomatic_rpc-0.8.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d27d1cc8b15bbcb7f8772302bf47a5d5", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 43570, "upload_time": "2019-03-29T18:13:41", "upload_time_iso_8601": "2019-03-29T18:13:41.733260Z", "url": "https://files.pythonhosted.org/packages/5d/7a/abebe44a680e19ae6607442c000de7982cda117efdb001b2e1b23700a1d6/deepomatic_rpc-0.8.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "67401cdbc8eb72ecbcd21c930155d452", "sha256": "196c959b6ee300e43fa568e6d0ffe532101eed160cfc0c70474af50cb7177f60"}, "downloads": -1, "filename": "deepomatic-rpc-0.8.0.tar.gz", "has_sig": false, "md5_digest": "67401cdbc8eb72ecbcd21c930155d452", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32096, "upload_time": "2019-03-29T18:13:44", "upload_time_iso_8601": "2019-03-29T18:13:44.146976Z", "url": "https://files.pythonhosted.org/packages/2c/8f/c58ad34d6fe45500e2bf2e49584dc2eb82e68f43b7815f5cf3a96ef453cc/deepomatic-rpc-0.8.0.tar.gz", "yanked": false}], "0.8.1": [{"comment_text": "", "digests": {"md5": "c7b6786ce9b28bc1add2aa830996494a", "sha256": "da998167237bfd9d111116c284b8b5b8d6dabb989b66ae33dea0b2b224a7d0e8"}, "downloads": -1, "filename": "deepomatic_rpc-0.8.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "c7b6786ce9b28bc1add2aa830996494a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 45480, "upload_time": "2019-08-12T16:54:41", "upload_time_iso_8601": "2019-08-12T16:54:41.379884Z", "url": "https://files.pythonhosted.org/packages/3f/f7/875980798352bd867a8f847c0ba702287d8f891d1bff1b906ab9d7c61605/deepomatic_rpc-0.8.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "30d5ff9ad8f2e5a0da2fece07438db94", "sha256": "8dd4e3743661be2fb0c159349eafc587167de4982954b8244b3e50295f575d16"}, "downloads": -1, "filename": "deepomatic-rpc-0.8.1.tar.gz", "has_sig": false, "md5_digest": "30d5ff9ad8f2e5a0da2fece07438db94", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29932, "upload_time": "2019-08-12T16:54:43", "upload_time_iso_8601": "2019-08-12T16:54:43.433679Z", "url": "https://files.pythonhosted.org/packages/00/8c/7435c79eac0d557a30f79f0f7d92a82603c6844065779b4b6f068f31dd55/deepomatic-rpc-0.8.1.tar.gz", "yanked": false}], "0.8.2": [{"comment_text": "", "digests": {"md5": "f6bbfe49903180c1b36348870f45fcb5", "sha256": "7a4b57530c6b9184772eb3748bf45490dce3952b3964bf3f9a969970b03703df"}, "downloads": -1, "filename": "deepomatic_rpc-0.8.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f6bbfe49903180c1b36348870f45fcb5", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 45675, "upload_time": "2019-09-27T13:49:41", "upload_time_iso_8601": "2019-09-27T13:49:41.525540Z", "url": "https://files.pythonhosted.org/packages/ba/46/3ec990dd5f9bfc81fd6b82207addf140e0680f3a02d09a618562b0d8af66/deepomatic_rpc-0.8.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b55694616f92dab250f56dd30d5e3e48", "sha256": "6d35181cce307b20c0ad80d5afe4a71bce33226f422a2f2c5f272594e9592238"}, "downloads": -1, "filename": "deepomatic-rpc-0.8.2.tar.gz", "has_sig": false, "md5_digest": "b55694616f92dab250f56dd30d5e3e48", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33258, "upload_time": "2019-09-27T13:49:43", "upload_time_iso_8601": "2019-09-27T13:49:43.602083Z", "url": "https://files.pythonhosted.org/packages/65/a2/65bdd15289ff1d96331ca90fbc76b3f5391a440afc24a9bc1225f0ed0a81/deepomatic-rpc-0.8.2.tar.gz", "yanked": false}], "0.8.3": [{"comment_text": "", "digests": {"md5": "90150454643ac8a1130bb7f1dec6f8b4", "sha256": "61356a51912bc1999a7671a39896fd8e77fa6f64c72727ef004b2ccd60877c8c"}, "downloads": -1, "filename": "deepomatic_rpc-0.8.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "90150454643ac8a1130bb7f1dec6f8b4", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 55421, "upload_time": "2020-02-18T19:30:24", "upload_time_iso_8601": "2020-02-18T19:30:24.391308Z", "url": "https://files.pythonhosted.org/packages/aa/ff/7355033d08d2143ffa5ce662e10a0afdd6216e66b0c3263d788868dac8e0/deepomatic_rpc-0.8.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "48862a9544d688c85099a76138c70283", "sha256": "bdc6c33bfa9d9539f5b6e4e496e5ab862785268422846cb2c4cf0eef1af99ee2"}, "downloads": -1, "filename": "deepomatic-rpc-0.8.3.tar.gz", "has_sig": false, "md5_digest": "48862a9544d688c85099a76138c70283", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36994, "upload_time": "2020-02-18T19:30:26", "upload_time_iso_8601": "2020-02-18T19:30:26.202221Z", "url": "https://files.pythonhosted.org/packages/d1/df/d1cb1aaaaf1e156e7db9669aafd1845ab0af582414b0191ce509669c23a5/deepomatic-rpc-0.8.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "90150454643ac8a1130bb7f1dec6f8b4", "sha256": "61356a51912bc1999a7671a39896fd8e77fa6f64c72727ef004b2ccd60877c8c"}, "downloads": -1, "filename": "deepomatic_rpc-0.8.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "90150454643ac8a1130bb7f1dec6f8b4", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 55421, "upload_time": "2020-02-18T19:30:24", "upload_time_iso_8601": "2020-02-18T19:30:24.391308Z", "url": "https://files.pythonhosted.org/packages/aa/ff/7355033d08d2143ffa5ce662e10a0afdd6216e66b0c3263d788868dac8e0/deepomatic_rpc-0.8.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "48862a9544d688c85099a76138c70283", "sha256": "bdc6c33bfa9d9539f5b6e4e496e5ab862785268422846cb2c4cf0eef1af99ee2"}, "downloads": -1, "filename": "deepomatic-rpc-0.8.3.tar.gz", "has_sig": false, "md5_digest": "48862a9544d688c85099a76138c70283", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36994, "upload_time": "2020-02-18T19:30:26", "upload_time_iso_8601": "2020-02-18T19:30:26.202221Z", "url": "https://files.pythonhosted.org/packages/d1/df/d1cb1aaaaf1e156e7db9669aafd1845ab0af582414b0191ce509669c23a5/deepomatic-rpc-0.8.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:39:22 2020"}