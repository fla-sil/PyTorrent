{"info": {"author": "Caleb Hattingh", "author_email": "caleb.hattingh@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Framework :: AsyncIO", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Communications", "Topic :: Software Development :: Build Tools"], "description": ".. image:: https://github.com/cjrh/aiomsg/workflows/Python%20application/badge.svg\n    :target: https://github.com/cjrh/aiomsg/actions\n\n.. image:: https://img.shields.io/badge/stdlib--only-yes-green.svg\n    :target: https://img.shields.io/badge/stdlib--only-yes-green.svg\n\n.. image:: https://coveralls.io/repos/github/cjrh/aiomsg/badge.svg?branch=master\n    :target: https://coveralls.io/github/cjrh/aiomsg?branch=master\n\n.. image:: https://img.shields.io/pypi/pyversions/aiomsg.svg\n    :target: https://pypi.python.org/pypi/aiomsg\n\n.. image:: https://img.shields.io/github/tag/cjrh/aiomsg.svg\n    :target: https://img.shields.io/github/tag/cjrh/aiomsg.svg\n\n.. image:: https://img.shields.io/badge/install-pip%20install%20aiomsg-ff69b4.svg\n    :target: https://img.shields.io/badge/install-pip%20install%20aiomsg-ff69b4.svg\n\n.. image:: https://img.shields.io/pypi/v/aiomsg.svg\n    :target: https://img.shields.io/pypi/v/aiomsg.svg\n\n.. image:: https://img.shields.io/badge/calver-YYYY.MM.MINOR-22bfda.svg\n    :target: http://calver.org/\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n    :target: https://github.com/ambv/black\n\naiomsg\n======\n\nPure-Python smart sockets (like ZMQ) for simpler networking\n\n.. figure:: https://upload.wikimedia.org/wikipedia/commons/5/5e/NetworkDecentral.svg\n    :target: https://commons.wikimedia.org/wiki/File:NetworkDecentral.svg\n    :alt: Diagram of computers linked up in a network\n\n    :sub:`Attribution: And1mu [CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0)]`\n\n\nTable of Contents\n-----------------\n\n.. contents::\n\n\nDemo\n====\n\nLet's make two microservices; one will send the current time to the other.\nHere's the end that binds to a port (a.k.a, the \"server\"):\n\n.. code-block:: python3\n\n    import asyncio, time\n    from aiomsg import S\u00f8cket\n\n    async def main():\n        async with S\u00f8cket() as sock:\n            await sock.bind('127.0.0.1', 25000)\n            while True:\n                await sock.send(time.ctime().encode())\n                await asyncio.sleep(1)\n\n    asyncio.run(main())\n\nRunning as a different process, here is the end that does the\nconnecting (a.k.a, the \"client\"):\n\n.. code-block:: python3\n\n    import asyncio\n    from aiomsg import S\u00f8cket\n\n    async def main():\n        async with S\u00f8cket() as sock:\n            await sock.connect('127.0.0.1', 25000)\n            async for msg in sock.messages():\n                print(msg.decode())\n\n    asyncio.run(main())\n\nNote that these are both complete, runnable programs, not fragments.\n\nLooks a lot like conventional socket programming, except that *these*\nsockets have a few extra tricks. These are described in more detail\nfurther down in rest of this document.\n\nInspiration\n===========\n\nLooks a lot like ZeroMQ yes? no? Well if you\ndon't know anything about\nZeroMQ, that's fine too. The rest of this document will assume that you\ndon't know anything about ZeroMQ. ``aiomsg`` is heavily influenced\nby ZeroMQ.\n\nThere are some differences; hopefully they make things simpler than zmq.\nFor one thing, *aiomsg* is pure-python so no compilation step is required,\nand relies only on the Python standard library (and that won't change).\n\nAlso, we don't have special kinds of socket pairs like ZeroMQ has. There is\nonly the one ``S\u00f8cket`` class. The only role distinction you need to make\nbetween different socket instances is this: some sockets will **bind**\nand others will **connect**.\n\nThis is the leaky part of the API that comes from the\nunderlying BSD socket API. A *bind* socket will bind to a local interface\nand port. A *connect* socket must connect to a *bind* socket, which can\nbe on the same machine or a remote machine. This is the only complicated\nbit. You must decide, in a distributed microservices architecture,\nwhich sockets must bind and which must connect. A useful heuristic is\nthat the service which is more likely to require horizontal scaling should\nhave the *connect* sockets. This is because the *hostnames* to which they\nwill connect (these will be the *bind* sockets) will be long-lived.\n\nIntroduction\n============\n\nWhat you see above in the demo is pretty much a typical usage of\nnetwork sockets. So what's special about ``aiomsg``? These are\nthe high-level features:\n\n#.  Messages, not streams:\n\n    Send and receive are *message-based*, not stream based. Much easier! This\n    does mean that if you want to transmit large amounts of data, you're going\n    to have have to break them up yourself, send the pieces, and put them\n    back together on the other side.\n\n#.  Automatic reconnection\n\n    These sockets automatically reconnect. You don't have to\n    write special code for it. If the bind end (a.k.a \"server\") is restarted,\n    the connecting end will automatically reconnect. This works in either\n    direction.  Try it! run the demo code and kill one of the processes.\n    And then start it up again. The connection will get re-established.\n\n#.  Many connections on a single \"socket\"\n\n    The bind end can receive multiple connections, but you do all your\n    ``.send()`` and ``.recv()`` calls on a single object. (No\n    callback handlers or protocol objects.)\n\n    More impressive is that the connecting end is exactly the same; it can make\n    outgoing ``connect()`` calls to multiple peers (bind sockets),\n    and you make all your ``send()`` and ``recv()`` calls on a single object.\n\n    This will be described in more detail further on in this document.\n\n#.  Message distribution patterns\n\n    Receiving messages is pretty simple: new messages just show up (remember\n    that messages from all connected peers come through the same call):\n\n    .. code-block:: python3\n\n        async with S\u00f8cket() as sock:\n            await sock.bind()\n            async for msg in sock.messages():\n                print(f\"Received: {msg}\")\n\n    However, when sending messages you have choices. The choices affect\n    **which peers** get the message. The options are:\n\n    - **Publish**: every connected peer is sent a copy of the message\n    - **Round-robin**: each connected peer is sent a *unique* message; the messages\n      are distributed to each connection in a circular pattern.\n    - **By peer identity**: you can also send to a specific peer by using\n      its identity directly.\n\n    The choice between *pub-sub* and *round-robin* must be made when\n    creating the ``S\u00f8cket()``:\n\n    .. code-block:: python3\n\n        from aiomsg import S\u00f8cket, SendMode\n\n        async with S\u00f8cket(send_mode=SendMode.PUBLISH) as sock:\n            await sock.bind()\n            async for msg in sock.messages():\n                await sock.send(msg)\n\n    This example receives a message from any connected peer, and sends\n    that same message to *every* connected peer (including the original\n    sender). By changing ``PUBLISH`` to ``ROUNDROBIN``, the message\n    distribution pattern changes so that each \"sent\" message goes to\n    only one connected peer. The next \"sent\" message will go to a\n    different connected, and so on.\n\n    For *identity-based* message sending, that's available any time,\n    regardless of what you choose for the ``send_mode`` parameter; for\n    example:\n\n    .. code-block:: python3\n\n        import asyncio\n        from aiomsg import S\u00f8cket, SendMode\n\n        async def main():\n            async with S\u00f8cket() as sock1, S\u00f8cket(send_mode=SendMode.PUBLISH) as sock2:\n                await sock1.bind(port=25000)\n                await sock2.bind(port=25001)\n                while True:\n                    peer_id, message = await sock1.recv_identity()\n                    msg_id, _, data = msg.partition(b\"\\x00\")\n                    await sock2.send(data)\n                    await sock1.send(msg_id + b\"\\x00ok\", identity=peer_id)\n\n        asyncio.run(main())\n\n    This example shows how you can receive messages on one socket (``sock1``,\n    which could have thousands of connected peers), and relay those messages to\n    thousands of other peers connected on a different socket (``sock2``).\n\n    For this example, the ``send_mode`` of ``sock1`` doesn't matter because\n    if ``identity`` is specified in the ``send()`` call, it'll ignore\n    ``send_mode`` completely.\n\n    Oh, and the example above is a complete, runnable program which is\n    pretty amazing!\n\n#.  Built-in heartbeating\n\n    Because ain't nobody got time to mess around with TCP keepalive\n    settings. The heartbeating is internal and opaque to your application\n    code. You won't even know it's happening, unless you enable debug\n    logs. Heartbeats are sent only during periods of inactivity, so\n    they won't interfere with your application messages.\n\n    In theory, you really shouldn't need heartbeating because TCP is a very robust\n    protocol; but in practice, various intermediate servers and routers\n    sometimes do silly things to your connection if they think a connection\n    has been idle for too long. So, automatic heartbeating is baked in to\n    let all intermediate hops know you want the connection to stay up, and\n    if the connection goes down, you will know much sooner than the\n    standard TCP keepalive timeout duration (which can be very long!).\n\n    If either a heartbeat or a message isn't received within a specific\n    timeframe, that connection is destroyed. Whichever peer is making the\n    ``connect()`` call will then automatically try to reconnect, as\n    discussed earlier.\n\n#.  Built-in reliability choices\n\n    Ah, so what do \"reliability choices\" mean exactly...?\n\n    It turns out that it's quite hard to send messages in a reliable way.\n    Or, stated another way, it's quite hard to avoid dropping messages:\n    one side sends and the other side never gets the message.\n\n    ``aiomsg`` already buffers messages when being sent. Consider the\n    following example:\n\n    .. code-block:: python3\n\n        from aiomsg import S\u00f8cket, SendMode\n\n        async with S\u00f8cket(send_mode=SendMode.PUBLISH) as sock:\n            await sock.bind()\n            while True:\n                await sock.send(b'123)\n                await asyncio.sleep(1.0)\n\n    This server above will send the bytes ``b\"123\"`` to all connected peers;\n    but what happens if there are *no* connected peers? In this case the\n    message will be buffered internally until there is at least one\n    connected peer, and when that happens, all buffered messages will\n    immediately be sent. To be clear, you don't have to do anything extra.\n    This is just the normal behaviour, and it works the same with the\n    ``ROUNDROBIN`` send mode.\n\n    Message buffering happens whenever there are no connected peers\n    available to receive a message.  Sounds great right?  Unfortunately,\n    this is not quite enough to prevent messages from getting lost. It is\n    still easy to have your process killed immediately after sending data into\n    a kernel socket buffer, but right before the bytes actually get\n    transmitted. In other words, your code thinks the message got sent, but\n    it didn't actually get sent.\n\n    The only real solution for adding robustness is to have peers *reply*\n    to you saying that they received the message. Then, if you never receive\n    this notification, you should assume that the message might not have\n    been received, and send it again. ``aiomsg`` will do this for you\n    (so again there is no work on your part), but you do have to turn it\n    on.\n\n    This option is called the ``DeliveryGuarantee``. The default option,\n    which is just basic message buffering in the absence of any connected\n    peers, is called ``DeliveryGuarantee.AT_MOST_ONCE``. It means, literally,\n    that any \"sent\" message will received by a connected peer no more than\n    once (of course, it may also be zero, as described above).\n\n    The alternative is to set ``DeliveryGuarantee.AT_LEAST_ONCE``, which\n    enables the internal \"retry\" feature. It will be possible, under\n    certain conditions, that any given message could be received *more than\n    once*, depending on timing and situation.  This is how the code looks\n    if you enable it:\n\n    .. code-block:: python3\n\n        from aiomsg import S\u00f8cket, SendMode, DeliveryGuarantee\n\n        async with S\u00f8cket(\n                send_mode=SendMode.ROUNDROBIN,\n                delivery_guarantee=DeliveryGuarantee.AT_LEAST_ONCE\n        ) as sock:\n            await sock.bind()\n            while True:\n                await sock.send(b'123)\n                await asyncio.sleep(1.0)\n\n    It's pretty much exactly the same as before, but we added the\n    ``AT_LEAST_ONCE`` option. Note that ``AT_LEAST_ONCE`` does not work\n    for the ``PUBLISH`` sending mode. (Would it make sense to enable?)\n\n    As a minor point, you should note that when ``AT_LEAST_ONCE`` is\n    enabled, it does not mean that every send waits for acknowledgement\n    before the next send. That would incur too much latency. Instead,\n    there is a \"reply checker\" that runs on a timer, and if a reply\n    hasn't been received for a particular message in a certain timeframe\n    (5.0 seconds by default), that message will be sent again.\n\n    The connection may have gone down and back up within those 5 seconds,\n    and there may be new messages buffered for sending before the retry\n    send happens. In this case, the retry message will arrive **after**\n    those buffered messages. This is a long way of saying that the way\n    that message reliability has been implemented can result in messages\n    being received in a different **order** to what they were sent. In\n    exchange for this, you get a lower overall latency because sending\n    new messages is not waiting on previous messages getting acknowledged.\n\n#.  Pure python, doesn't require a compiler\n\n#.  Depends only on the Python standard library\n\n\nCookbook\n========\n\nThe message distribution patterns are what make ``aiomsg`` powerful. It\nis the way you connect up a whole bunch of microservices that brings the\ngreatest leverage. We'll go through the different scenarios using a\ncookbook format.\n\nIn the code snippets that follow, you should assumed that each snippet\nis a complete working program, except that some boilerplate is omitted.\nThis is the basic template:\n\n.. code-block:: python3\n\n    import asyncio\n    from aiomsg import S\u00f8cket, SendMode, DeliveryGuarantee\n\n    <main() function>\n\n    asyncio.run(main())\n\nJust substitute in the ``main()`` function from the snippets below to\nmake the complete programs.\n\nPublish from either the *bind* or *connect* end\n-----------------------------------------------\n\nThe choice of \"which peer should bind\" is unaffected by the sending mode\nof the socket.\n\nCompare\n\n.. code-block:: python3\n\n    # Publisher that binds\n    async def main():\n        async with S\u00f8cket(send_mode=SendMode.PUBLISH) as sock:\n            await sock.bind()\n            while True:\n                await sock.send(b'News!')\n                await asyncio.sleep(1)\n\nversus\n\n.. code-block:: python3\n\n    # Publisher that connects\n    async def main():\n        async with S\u00f8cket(send_mode=SendMode.PUBLISH) as sock:\n            await sock.connect()\n            while True:\n                await sock.send(b'News!')\n                await asyncio.sleep(1)\n\nThe same is true for the round-robin sending mode. You will usually\nchoose the *bind* peer based one which service is least likely to\nrequire dynamic scaling.  This means that the mental conception of\nsocket peers as either a *server* or *client* is not that useful.\n\nDistribute messages to a dynamically-scaled service (multiple instances)\n------------------------------------------------------------------------\n\nIn this recipe, one service needs to send messages to another service\nthat is horizontally scaled.\n\nThe trick here is that we *don't* want to use bind sockets on\nhorizontally-scaled services, because other peers that need to make\na *connect* call will need to know what hostname to use.\nEach instance in a horizontally-scaled service has a different IP\naddress, and it becomes difficult to keep the \"connect\" side up-to-date\nabout which peers are available. This can also change as the\nhorizontally-scaled service increases or decreases the number of\ninstances. (In ZeroMQ documentation, this is described as the\n`Dynamic Discovery Problem <http://zguide.zeromq.org/page:all#The-Dynamic-Discovery-Problem>`_).\n\n``aiomsg`` handles this very easily: just make sure that the\ndynamically-scaled service is making the connect calls:\n\nThis is the manually-scaled service (has a specific domain name):\n\n.. code-block:: python3\n\n    # jobcreator.py -> DNS for \"jobcreator.com\" should point to this machine.\n    async def main():\n        async with S\u00f8cket(send_mode=SendMode.ROUNDROBIN) as sock:\n            await sock.bind(hostname=\"0.0.0.0\", port=25001)\n            while True:\n                await sock.send(b\"job\")\n                await asyncio.sleep(1)\n\nThese are the downstream workers (don't need a domain name):\n\n.. code-block:: python3\n\n    # worker.py - > can be on any number of machines\n    async def main():\n        async with S\u00f8cket() as sock\n            await sock.connect(hostname='jobcreator.com', port=25001)\n            while True:\n                work = await sock.recv()\n                <do work>\n\nWith this code, after you start up ``jobcreator.py`` on the machine\nto which DNS resolves the domain name \"jobcreator.com\", you can start\nup multiple instances of ``worker.py`` on other machines, and work\nwill get distributed among them. You can even change the number of\nworker instances dynamically, and everything will \"just work\", with\nthe main instance distributing work out to all the connected workers\nin a circular pattern.\n\nThis core recipe provides a foundation on which many of the other\nrecipes are built.\n\nDistribute messages from a 2-instance service to a dynamically-scaled one\n-------------------------------------------------------------------------\n\nIn this scenario, there are actually two instances of the job-creating\nservice, not one. This would typically be done for reliability, and\neach instance would be placed in a different `availability zones <https://searchaws.techtarget.com/definition/availability-zones>`_.\nEach instance will have a different domain name.\n\nIt turns out that the required setup follows directly from the previous\none: you just add another connect call in the workers.\n\nThe manually-scaled service is as before, but you start on instance of\n``jobcreator.py`` on machine \"a.jobcreator.com\", and start another\non machine \"b.jobcreator.com\". Obviously, it is DNS that is configured\nto point to the correct IP addresses of those machines (or you could\nuse IP addresses too, if these are internal services).\n\n.. code-block:: python3\n\n    # jobcreator.py -> Configure DNS to point to these instances\n    async def main():\n        async with S\u00f8cket(send_mode=SendMode.ROUNDROBIN) as sock:\n            await sock.bind(hostname=\"0.0.0.0\", port=25001)\n            while True:\n                await sock.send(b\"job\")\n                await asyncio.sleep(1)\n\nAs before, the downstream workers, but this time each worker makes\nmultiple ``connect()`` calls; one to each job creator's domain name:\n\n.. code-block:: python3\n\n    # worker.py - > can be on any number of machines\n    async def main():\n        async with S\u00f8cket() as sock:\n            await sock.connect(hostname='a.jobcreator.com', port=25001)\n            await sock.connect(hostname='b.jobcreator.com', port=25001)\n            while True:\n                work = await sock.recv()\n                <do work>\n\n``aiomsg`` will return ``work`` from the ``sock.recv()`` call above as\nit comes in from either job creation service. And as before, the number\nof worker instances can be dynamically scaled, up or down, and all the\nconnection and reconnection logic will be handled internally.\n\nDistribute messages from one dynamically-scaled service to another\n------------------------------------------------------------------\n\nIf both services need to be dynamically-scaled, and can have\nvarying numbers of instances at any time, we can no longer rely\non having one end do the *socket bind* to a dedicated domain name.\nWe really would like each to make ``connect()`` calls, as we've\nseen in previous examples.\n\nHow to solve it?\n\nThe answer is to create an intermediate proxy service that has\n**two** bind sockets, with long-lived domain names. This is what\nwill allow the other two dynamically-scaled services to have\na dynamic number of instances.\n\nHere is the new job creator, whose name we change to ``dynamiccreator.py``\nto reflect that it is now dynamically scalable:\n\n.. code-block:: python3\n\n    # dynamiccreator.py -> can be on any number of machines\n    async def main():\n        async with S\u00f8cket(send_mode=SendMode.ROUNDROBIN) as sock:\n            await sock.connect(hostname=\"proxy.jobcreator.com\", port=25001)\n            while True:\n                await sock.send(b\"job\")\n                await asyncio.sleep(1)\n\nNote that our job creator above is now making a ``connect()`` call to\n``proxy.jobcreator.com:25001`` rather than binding to a local port.\nLet's see what it's connecting to. Here is the intermediate proxy\nservice, which needs a dedicated domain name, and two ports allocated\nfor each of the bind sockets.\n\n.. code-block:: python3\n\n    # proxy.py -> Set up DNS to point \"proxy.jobcreator.com\" to this instance\n    async def main():\n        async with S\u00f8cket() as sock1, \\\n                S\u00f8cket(send_mode=SendMode.ROUNDROBIN) as sock2:\n            await sock1.bind(hostname=\"0.0.0.0\", port=25001)\n            await sock2.bind(hostname=\"0.0.0.0\", port=25002)\n            while True:\n                work = await sock1.recv()\n                await sock2.send(work)\n\nNote that ``sock1`` is bound to port 25001; this is what our job creator\nis connecting to. The other socket, ``sock2``, is bound to port 25002, and\nthis is the one that our workers will be making their ``connect()`` calls\nto. Hopefully it's clear in the code that work is being received from\n``sock1`` and being sent onto ``sock2``. This is pretty much a feature\ncomplete proxy service, and with only minor additions for error-handling\ncan be used for real work.\n\nFor completeness, here are the downstream workers:\n\n.. code-block:: python3\n\n    # worker.py - > can be on any number of machines\n    async def main():\n        async with S\u00f8cket() as sock:\n            await sock.connect(hostname='proxy.jobcreator.com', port=25002)\n            while True:\n                work = await sock.recv()\n                <do work>\n\nNote that the workers are connecting to port 25002, as expected.\n\nYou might be wondering: isn't this just moving our performance problem\nto a different place? If the proxy service is not scalable, then surely\nthat becomes the \"weakest link\" in our system architecture?\n\nThis is a pretty typical reaction, but there are a couple of reasons\nwhy it might not be as bad as you think:\n\n#. The proxy service is doing very, very little work. Thus, we expect\n   it to suffer from performance problems only at a much higher scale\n   compared to our other two services which are likely to be doing more\n   CPU-bound work (in real code, not my simple examples above).\n#. We could compile only the proxy service into faster low-level code using\n   any number of tools such as Cython, C, C++, Rust, D and so on, in order\n   to improve its performance, if necessary (this would require implementing\n   the ``aiomsg`` protocols in that other language though). This allows\n   us to retain the benefits of using a dynamic language like Python\n   in the dynamically scaled services where much greater business\n   logic is captured (these can be then be horizontally scaled quite\n   easily to handle performance issues if necessary).\n#. Performance is not the only reason services are dynamically scaled.\n   It is always a good idea, even in low-throughput services, to have\n   multiple instances of a service running in different availability zones.\n   Outages do happen, yes, even in your favourite cloud provider's\n   systems.\n#. A separate proxy service as shown above isolates a really complex\n   problem and removes it from your business logic code. It might not\n   be easy to appreciate how significant that is. As your dev team is\n   rapidly iterating on business features, and redeploying new versions\n   several times a day, the proxy service is unchanging, and doesn't\n   require redeployment. In this sense, it plays a similar role to\n   more traditional messaging systems like RabbitMQ and ActiveMQ.\n#. We can still run multiple instances of our proxy service using an\n   earlier technique, as we'll see in the next recipe.\n\nTwo dynamically-scaled services, with a scaled fan-in, fan-out proxy\n--------------------------------------------------------------------\n\nThis scenario is exactly like the previous one, except that we're\nnervous about having only a single proxy service, since it is a\nsingle point of failure.  Instead, we're going to have 3 instances of\nthe proxy service running in parallel.\n\nLet's jump straight into code. The proxy code itself is actually\nunchanged from before.  We just need to run more copies of it on\ndifferent machines. *Each machine will have a different domain name*.\n\n.. code-block:: python3\n\n    # proxy.py -> unchanged from the previous recipe\n    async def main():\n        async with S\u00f8cket() as sock1, \\\n                S\u00f8cket(send_mode=SendMode.ROUNDROBIN) as sock2:\n            await sock1.bind(hostname=\"0.0.0.0\", port=25001)\n            await sock2.bind(hostname=\"0.0.0.0\", port=25002)\n            while True:\n                work = await sock1.recv()\n                await sock2.send(work)\n\nFor the other two dynamically scaled services, we need to tell them\nall the domain names to connect to.  We could set that up in an\nenvironment variable:\n\n.. code-block:: shell\n\n    $ export PROXY_HOSTNAMES=\"px1.jobcreator.com;px2.jobcreator.com;px3.jobcreator.com\"\n\nThen, it's really easy to modify our services to make use of that. First,\nthe dynamically-scaled job creator:\n\n.. code-block:: python3\n\n    # dynamiccreator.py -> can be on any number of machines\n    async def main():\n        async with S\u00f8cket(send_mode=SendMode.ROUNDROBIN) as sock:\n            for proxy in os.environ['PROXY_HOSTNAMES'].split(\";\"):\n                await sock.connect(hostname=proxy, port=25001)\n            while True:\n                await sock.send(b\"job\")\n                await asyncio.sleep(1)\n\nAnd the change for the worker code is identical (making sure the correct\nport is being used, 25002):\n\n.. code-block:: python3\n\n    # worker.py - > can be on any number of machines\n    async def main():\n        async with S\u00f8cket() as sock:\n            for proxy in os.environ['PROXY_HOSTNAMES'].split(\";\"):\n                await sock.connect(hostname=proxy, port=25002)\n            while True:\n                work = await sock.recv()\n                <do work>\n\nThree proxies, each running in a different availability zone, should\nbe adequate for most common scenarios.\n\nTODO: more scenarios involving identity (like ROUTER-DEALER)\n\nSecure connections with mutual TLS\n----------------------------------\n\nSecure connectivity is extremely important, *even in an internal\nmicroservices infrastructure*. From a design perspective, the single\nbiggest positive impact that can be made on security is to make it **easy**\nfor users to do the \"right thing\".\n\nFor this reason, ``aiomsg`` does nothing new at all. It uses the existing\nsupport for secure connectivity in the Python standard library, and\nuses the same APIs exactly as-is.\n\nAll you have to do is create an `SSLContext <https://docs.python.org/3/library/ssl.html#ssl.SSLContext>`_\nobject, exactly as you normally would for conventional Python\nsockets, and pass that in.\n\n`Mutual TLS authentication (mTLS) <https://en.wikipedia.org/wiki/Mutual_authentication>`_\nis where the client verifies the server **and** the server verifies\nthe client. In ``aiomsg``, names like \"client\" and \"server\" are less\nuseful, so let's rather say that the *connect* socket verifies the\ntarget *bind* socket, and the *bind* socket also verifies the incoming\nconnecting socket.\n\nIt sounds complicated, but at a high level you just need to supply\nan ``SSLContext`` instance to the bind socket, and a different ``SSLContext``\ninstance to the connect socket (usually on a different computer). The details\nare all stored in the ``SSLContext`` objects.\n\nLet's first look at how that looks for a typical bind socket and connect\nsocket:\n\n.. code-block:: python3\n\n    # bind end\n    import ssl\n    import asyncio, time\n    from aiomsg import S\u00f8cket\n\n    async def main():\n        ctx = ssl.SSLContext(...)    # <--------- NEW!\n        async with S\u00f8cket() as sock:\n            await sock.bind('127.0.0.1', 25000, ssl_context=ctx)\n            while True:\n                await s.send(time.ctime().encode())\n\n    asyncio.run(main())\n\n.. code-block:: python3\n\n    # connect end\n    import ssl\n    import asyncio\n    from aiomsg import S\u00f8cket\n\n    async def main():\n        ctx = ssl.SSLContext(...)    # <--------- NEW!\n        async with S\u00f8cket() as sock:\n            await sock.connect('127.0.0.1', 25000, ssl_context=ctx)\n            async for msg in sock.messages():\n                print(msg.decode())\n\n    asyncio.run(main())\n\nIf you compare these two code snippets to what was shown in the *Demo*\nsection, you'll see it's almost exactly the same, except that we're\npassing a new `ctx` parameter into the respective `bind()` and `connect()`\ncalls, which is an instance of `SSLContext`.\n\nSo if you already know how to work with Python's built-in `SSLContext`\nobject, you can already create secure connections with `aiomsg` and\nthere's nothing more you need to learn.\n\nCrash course on setting up an ``SSLContext``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nYou might not know how to set up the ``SSLContext`` object.\nHere, I'll give a crash course, but please remember that I am\nnot a security expert so make sure to ask an actual security expert\nto review your work if you're working on a production system.\n\nThe best way to create an ``SSLContext`` object is **not** with its\nconstructor, but rather a helper function called ``create_default_context()``,\nwhich sets a lot of sensible defaults that you would otherwise have to\ndo manually. So that's how you get the context instance.\n\nYou do have to specify whether the purpose of the context object is to\nverify a client or a server. Let's have a look at that:\n\n.. code-block:: python3\n\n    # bind socket, or \"server\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n\nSo here, above, we're creating a context object for a bind socket. The\npurpose of the context is going to be to *verify incoming client connections*,\nthat's why the ``CLIENT_AUTH`` purpose was given.  As you might imagine,\non the other end, i.e., the connect socket (or \"client\"), the purpose\nis going to be to verify the server:\n\n.. code-block:: python3\n\n    # connect socket, or \"client\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n\nOnce you've created the context, the remaining parameters have the same\nmeaning for both client and server.\n\nThe way TLS works (the artist formerly known as SSL) is that each end\nof a connection has two pieces of information:\n\n1. A **certificate** (may be shared publicly)\n2. A **key** (MUST NOT BE SHARED! SECRET!)\n\nWhen the two sockets establish a connection, they trade certificates, but\ndo not trade keys. Anyway, let's look at what you need to actually set\nin the code. We'll start with the connect socket (client).\n\n.. code-block:: python3\n\n    # connect socket, or \"client\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n    ctx.verify_mode = ssl.CERT_REQUIRED\n    ctx.check_hostname = True\n    ctx.load_verify_locations(<something that can verify the server cert>)\n\nThe above will let the client verify that the server it is connecting\nto is the correct one. When the socket connects, the server socket\nwill send back a *certificate* and the client checks that against one of\nthose mysterious \"verify locations\".\n\nFor mutual TLS, the server also wants to check the client. What does it\ncheck? Well, the client must also provide a certificate back to the server.\nSo that requires an additional line in the code block above:\n\n.. code-block:: python3\n\n    # connect socket, or \"client\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n    ctx.verify_mode = ssl.CERT_REQUIRED\n    ctx.check_hostname = True\n    ctx.load_verify_locations(<something that can verify the server cert>)\n\n    # Client needs a pair of \"cert\" and \"key\"\n    ctx.load_cert_chain(certfile=\"client.cert\", keyfile=\"client.key\")\n\nSo that completes everything we need to do for the SSL context on the\nclient side.  On the server side, everything is almost exactly the same:\n\n.. code-block:: python3\n\n    # bind socket, or \"server\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    ctx.verify_mode = ssl.CERT_REQUIRED\n    ctx.load_verify_locations(<something that can verify the client cert>)\n\n    # Server needs a pair of \"cert\" and \"key\"\n    ctx.load_cert_chain(certfile=\"server.cert\", keyfile=\"server.key\")\n\nThat describes everything you need to do to set up *mutual TLS* using\n``SSLContext`` instances.\n\nThere are a few loose ends to tie up though. Where do you get the\n``certfile`` and ``keyfile`` from? And what is this mysterious\n\"verify location\"? The first question is easier. The cert and key can be\ngenerated using the OpenSSL command-line application:\n\n.. code-block:: bash\n\n    $ openssl req -newkey rsa:2048 -nodes -keyout server.key \\\n        -x509 -days 365 -out server.cert \\\n        -subj '/C=GB/ST=Blah/L=Blah/O=Blah/OU=Blah/CN=example.com'\n\nRunning the above command will create two new files, ``server.cert`` and\n``server.key``; these are ones you specify in earlier commands. Generating\nthese files for the client is exactly the same, but you use different\nnames.\n\nYou could also use `Let's Encrypt <https://letsencrypt.org/>`_\nto generate the cert and key, in which case you don't have to run the\nabove commands. *IF* you use Let's Encrypt, you've also solved the\nother problem of supplying a \"verify location\", and in fact you won't need\nto call ``load_verify_locations()`` in the client code at all. This is\nbecause there are a bunch of *root certificate authorities* that are\nprovided with most operating systems, and *Let's Encrypt* is one of those.\n\nHowever, for the sake of argument, let's say you want to make your\nown certificates and you don't want to rely on system-provided root\ncertificates at all; how to do the verification? Well it turns out that\na very simple solution is to just use the target certificate itself to be\nthe \"verify location\". For example, here is the client context again:\n\n.. code-block:: python3\n\n    # connect socket, or \"client\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n    ctx.verify_mode = ssl.CERT_REQUIRED\n    ctx.check_hostname = True\n    ctx.load_verify_locations(\"server.cert\")   # <--- Same one as the server\n\n    # Client needs a pair of \"cert\" and \"key\"\n    ctx.load_cert_chain(certfile=\"client.cert\", keyfile=\"client.key\")\n\nand then in the server's context, you could also use the client's cert\nas the \"verify location\":\n\n.. code-block:: python3\n\n    # bind socket, or \"server\"\n    ctx: SSLContext = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)\n    ctx.verify_mode = ssl.CERT_REQUIRED\n    ctx.load_verify_locations(\"client.cert)   # <--- Same as on client\n\n    # Server needs a pair of \"cert\" and \"key\"\n    ctx.load_cert_chain(certfile=\"server.cert\", keyfile=\"server.key\")\n\nObviously, the client code and the server code are running on different\ncomputers and you need to make sure that the right files are on the right\ncomputers in the right places.\n\nThere are a lot of ways to make this more sophisticated, but it's\nprobably a good idea to get the simple case working, as described above,\nbefore looking at the more complicated cases. A cool option is to make\nyour own *root certificate authority*, which can be a standard\n\"verify location\" in all your microservices, and then when you make certs\nand keys for each microservice, you just have to \"sign\" them with the\nroot key. This process is described in\n`Be your own certificate authority <https://opensource.com/article/19/4/certificate-authority>`_\nby Moshe Zadka\n\nHope that helps!\n\nFAQ\n===\n\nWhy do you spell ``S\u00f8cket`` like that?\n--------------------------------------\n\nThe slashed O is used in homage to `\u00d8MQ <http://zeromq.org/>`_, a truly\nwonderful library that changed my thinking around what socket programming\ncould be like.\n\nI want to talk to the aiomsg S\u00f8cket with a different programming language\n-------------------------------------------------------------------------\n\n**WARNING: This section is extremely provisional. I haven't fully\nnailed down the protocol yet.**\n\nTo make a clone of the ``S\u00f8cket`` in another language is probably a\nlot of work, but it's actually not necessary to implement everything.\n\nYou can talk to ``aiomsg`` sockets quite easily by implementing the\nsimple protocol described below. It would be just like regular\nsocket programming in your programming language. You just have to\nfollow a few simple rules for the communication protocol.\n\nThese are the rules:\n\n#. **Every payload** in either direction shall be length-prefixed:\n\n   .. code-block::\n\n        message = [4-bytes big endian int32][payload]\n\n#. **Immediately** after successfully opening a TCP connection, before doing\n   anything else with your socket, you shall:\n\n    - Send your identity, as a 16 byte unique identifier (a 16 byte UUID4\n      is perfect). Note that Rule 1 still applies, so this would look like\n\n      .. code-block::\n\n           identity_message = b'\\x00\\x00\\x00\\x10' + [16 bytes]\n\n      (because the payload length, 16, is ``0x10`` in hex)\n\n    - Receive the other peer's identity (16 bytes). Remember Rule 1 still\n      applies, so you'll actually receive 20 bytes, and the first four will\n      be the length of the payload, which will be 16 bytes for this message.\n\n#. You shall **periodically** send a heartbeat message ``b\"aiomsg-heartbeat\"``.\n   Every 5 seconds is good. If you receive such messages you can ignore them.\n   If you don't receive one (or an actual data message) within 15 seconds\n   of the previous receipt,\n   the connection is probably dead and you should kill it and/or reconnect.\n   Note that Rule 1 still applies, and because the length of this message\n   is also 16 bytes, the message is ironically similar to the identity\n   message:\n\n   .. code-block::\n\n        heartbeat_message = b'\\x00\\x00\\x00\\x10' + b'aiomsg-heartbeat'\n\nAfter you've satisfied these rules, from that point on every message\nsent or received is a Rule 1 message, i.e., length prefixed with 4 bytes\nfor the length of the payload that follows.\n\nIf you want to run a *bind* socket, and receive multiple connections from\ndifferent ``aiomsg`` sockets, then the above rules apply to *each* separate\nconnection.\n\nThat's it!\n\nTODO: Discuss the protocol for ``AT_LEAST_ONCE`` mode, which is a bit messy\nat the moment.\n\nDeveloper setup\n===============\n\n1. Setup::\n\n    $ git clone https://github.com/cjrh/aiomsg\n    $ python -m venv venv\n    $ source venv/bin/activate  (or venv/Scripts/activate.bat on Windows)\n    $ pip install -e .[all]\n\n2. Run the tests::\n\n    $ pytest\n\n3. Create a new release::\n\n    $ bumpymcbumpface --push-git --push-pypi\n\nThe easiest way to obtain the\n`bumpymcbumpface <https://pypi.org/project/bumpymcbumpface/>`_ tool is\nto install it with `pipx <https://github.com/pipxproject/pipx>`_. Once installed\nand on your ``$PATH``, the command above should work. **NOTE: twine must be\ncorrectly configured to upload to pypi.**  If you don't have rights to\npush to PyPI, but you do have rights to push to github, just omit\nthe ``--push-pypi`` option in the command above. The command will\nautomatically create the next git tag and push it.\n\n\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/cjrh/aiomsg", "keywords": "asyncio socket network", "license": "", "maintainer": "", "maintainer_email": "", "name": "aiomsg", "package_url": "https://pypi.org/project/aiomsg/", "platform": "", "project_url": "https://pypi.org/project/aiomsg/", "project_urls": {"Homepage": "https://github.com/cjrh/aiomsg"}, "release_url": "https://pypi.org/project/aiomsg/2019.12.3/", "requires_dist": ["colorama ; extra == 'all'", "wheel ; extra == 'all'", "pytest ; extra == 'all'", "pytest-cov ; extra == 'all'", "twine ; extra == 'all'", "pygments ; extra == 'all'", "check-manifest ; extra == 'all'", "aiorun ; extra == 'all'", "pytest-benchmark ; extra == 'all'", "sphinx ; extra == 'all'", "portpicker ; extra == 'all'", "check-manifest ; extra == 'dev'", "colorama ; extra == 'dev'", "pygments ; extra == 'dev'", "twine ; extra == 'dev'", "wheel ; extra == 'dev'", "aiorun ; extra == 'dev'", "sphinx ; extra == 'doc'", "pytest ; extra == 'test'", "pytest-cov ; extra == 'test'", "portpicker ; extra == 'test'", "pytest-benchmark ; extra == 'test'"], "requires_python": "", "summary": "Socket-based abstraction for messaging patterns", "version": "2019.12.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://github.com/cjrh/aiomsg/actions\" rel=\"nofollow\"><img alt=\"https://github.com/cjrh/aiomsg/workflows/Python%20application/badge.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bb6ec0b80b137d51420ad446f6f41eede1462e9d/68747470733a2f2f6769746875622e636f6d2f636a72682f61696f6d73672f776f726b666c6f77732f507974686f6e2532306170706c69636174696f6e2f62616467652e737667\"></a>\n<a href=\"https://img.shields.io/badge/stdlib--only-yes-green.svg\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/stdlib--only-yes-green.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/de2a9d83373bb6492bfcffdc06c4147d95497b1a/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f7374646c69622d2d6f6e6c792d7965732d677265656e2e737667\"></a>\n<a href=\"https://coveralls.io/github/cjrh/aiomsg?branch=master\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/github/cjrh/aiomsg/badge.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b498f6d40a92589b947bde461cc39e8df8813a47/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f636a72682f61696f6d73672f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://pypi.python.org/pypi/aiomsg\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/pyversions/aiomsg.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/dee6845522868b91cb354526c436f48b4130c6ea/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f61696f6d73672e737667\"></a>\n<a href=\"https://img.shields.io/github/tag/cjrh/aiomsg.svg\" rel=\"nofollow\"><img alt=\"https://img.shields.io/github/tag/cjrh/aiomsg.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/dc3de1f886069af92fd15c583a4315fa6b1c106a/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f7461672f636a72682f61696f6d73672e737667\"></a>\n<a href=\"https://img.shields.io/badge/install-pip%20install%20aiomsg-ff69b4.svg\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/install-pip%20install%20aiomsg-ff69b4.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3d5db8bdc000da4455a518afacb166558a41aafb/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f696e7374616c6c2d706970253230696e7374616c6c25323061696f6d73672d6666363962342e737667\"></a>\n<a href=\"https://img.shields.io/pypi/v/aiomsg.svg\" rel=\"nofollow\"><img alt=\"https://img.shields.io/pypi/v/aiomsg.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6e909cbf8cdb28a1d8560877cec0766f8f8d3e38/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f61696f6d73672e737667\"></a>\n<a href=\"http://calver.org/\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/calver-YYYY.MM.MINOR-22bfda.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/957cdcd66ebe5225fea6bbf83a04bc66a232ab1c/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f63616c7665722d595959592e4d4d2e4d494e4f522d3232626664612e737667\"></a>\n<a href=\"https://github.com/ambv/black\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/code%20style-black-000000.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fbfdc7754183ecf079bc71ddeabaf88f6cbc5c00/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e737667\"></a>\n<div id=\"aiomsg\">\n<h2><a href=\"#id1\" rel=\"nofollow\">aiomsg</a></h2>\n<p>Pure-Python smart sockets (like ZMQ) for simpler networking</p>\n<div>\n<a href=\"https://commons.wikimedia.org/wiki/File:NetworkDecentral.svg\" rel=\"nofollow\"><img alt=\"Diagram of computers linked up in a network\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6bea90687ba6995466c697f5e3557c29a5d56ae0/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f352f35652f4e6574776f726b446563656e7472616c2e737667\"></a>\n<p><sub>Attribution: And1mu [CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0)]</sub></p>\n</div>\n<div id=\"table-of-contents\">\n<h3><a href=\"#id2\" rel=\"nofollow\">Table of Contents</a></h3>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#aiomsg\" id=\"id1\" rel=\"nofollow\">aiomsg</a><ul>\n<li><a href=\"#table-of-contents\" id=\"id2\" rel=\"nofollow\">Table of Contents</a></li>\n</ul>\n</li>\n<li><a href=\"#demo\" id=\"id3\" rel=\"nofollow\">Demo</a></li>\n<li><a href=\"#inspiration\" id=\"id4\" rel=\"nofollow\">Inspiration</a></li>\n<li><a href=\"#introduction\" id=\"id5\" rel=\"nofollow\">Introduction</a></li>\n<li><a href=\"#cookbook\" id=\"id6\" rel=\"nofollow\">Cookbook</a><ul>\n<li><a href=\"#publish-from-either-the-bind-or-connect-end\" id=\"id7\" rel=\"nofollow\">Publish from either the <em>bind</em> or <em>connect</em> end</a></li>\n<li><a href=\"#distribute-messages-to-a-dynamically-scaled-service-multiple-instances\" id=\"id8\" rel=\"nofollow\">Distribute messages to a dynamically-scaled service (multiple instances)</a></li>\n<li><a href=\"#distribute-messages-from-a-2-instance-service-to-a-dynamically-scaled-one\" id=\"id9\" rel=\"nofollow\">Distribute messages from a 2-instance service to a dynamically-scaled one</a></li>\n<li><a href=\"#distribute-messages-from-one-dynamically-scaled-service-to-another\" id=\"id10\" rel=\"nofollow\">Distribute messages from one dynamically-scaled service to another</a></li>\n<li><a href=\"#two-dynamically-scaled-services-with-a-scaled-fan-in-fan-out-proxy\" id=\"id11\" rel=\"nofollow\">Two dynamically-scaled services, with a scaled fan-in, fan-out proxy</a></li>\n<li><a href=\"#secure-connections-with-mutual-tls\" id=\"id12\" rel=\"nofollow\">Secure connections with mutual TLS</a><ul>\n<li><a href=\"#crash-course-on-setting-up-an-sslcontext\" id=\"id13\" rel=\"nofollow\">Crash course on setting up an <tt>SSLContext</tt></a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#faq\" id=\"id14\" rel=\"nofollow\">FAQ</a><ul>\n<li><a href=\"#why-do-you-spell-socket-like-that\" id=\"id15\" rel=\"nofollow\">Why do you spell <tt>S\u00f8cket</tt> like that?</a></li>\n<li><a href=\"#i-want-to-talk-to-the-aiomsg-socket-with-a-different-programming-language\" id=\"id16\" rel=\"nofollow\">I want to talk to the aiomsg S\u00f8cket with a different programming language</a></li>\n</ul>\n</li>\n<li><a href=\"#developer-setup\" id=\"id17\" rel=\"nofollow\">Developer setup</a></li>\n</ul>\n</div>\n</div>\n</div>\n<div id=\"demo\">\n<h2><a href=\"#id3\" rel=\"nofollow\">Demo</a></h2>\n<p>Let\u2019s make two microservices; one will send the current time to the other.\nHere\u2019s the end that binds to a port (a.k.a, the \u201cserver\u201d):</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span><span class=\"o\">,</span> <span class=\"nn\">time</span>\n<span class=\"kn\">from</span> <span class=\"nn\">aiomsg</span> <span class=\"kn\">import</span> <span class=\"n\">S\u00f8cket</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"s1\">'127.0.0.1'</span><span class=\"p\">,</span> <span class=\"mi\">25000</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">ctime</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">())</span>\n            <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n<p>Running as a different process, here is the end that does the\nconnecting (a.k.a, the \u201cclient\u201d):</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">from</span> <span class=\"nn\">aiomsg</span> <span class=\"kn\">import</span> <span class=\"n\">S\u00f8cket</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"s1\">'127.0.0.1'</span><span class=\"p\">,</span> <span class=\"mi\">25000</span><span class=\"p\">)</span>\n        <span class=\"k\">async</span> <span class=\"k\">for</span> <span class=\"n\">msg</span> <span class=\"ow\">in</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">messages</span><span class=\"p\">():</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">())</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n<p>Note that these are both complete, runnable programs, not fragments.</p>\n<p>Looks a lot like conventional socket programming, except that <em>these</em>\nsockets have a few extra tricks. These are described in more detail\nfurther down in rest of this document.</p>\n</div>\n<div id=\"inspiration\">\n<h2><a href=\"#id4\" rel=\"nofollow\">Inspiration</a></h2>\n<p>Looks a lot like ZeroMQ yes? no? Well if you\ndon\u2019t know anything about\nZeroMQ, that\u2019s fine too. The rest of this document will assume that you\ndon\u2019t know anything about ZeroMQ. <tt>aiomsg</tt> is heavily influenced\nby ZeroMQ.</p>\n<p>There are some differences; hopefully they make things simpler than zmq.\nFor one thing, <em>aiomsg</em> is pure-python so no compilation step is required,\nand relies only on the Python standard library (and that won\u2019t change).</p>\n<p>Also, we don\u2019t have special kinds of socket pairs like ZeroMQ has. There is\nonly the one <tt>S\u00f8cket</tt> class. The only role distinction you need to make\nbetween different socket instances is this: some sockets will <strong>bind</strong>\nand others will <strong>connect</strong>.</p>\n<p>This is the leaky part of the API that comes from the\nunderlying BSD socket API. A <em>bind</em> socket will bind to a local interface\nand port. A <em>connect</em> socket must connect to a <em>bind</em> socket, which can\nbe on the same machine or a remote machine. This is the only complicated\nbit. You must decide, in a distributed microservices architecture,\nwhich sockets must bind and which must connect. A useful heuristic is\nthat the service which is more likely to require horizontal scaling should\nhave the <em>connect</em> sockets. This is because the <em>hostnames</em> to which they\nwill connect (these will be the <em>bind</em> sockets) will be long-lived.</p>\n</div>\n<div id=\"introduction\">\n<h2><a href=\"#id5\" rel=\"nofollow\">Introduction</a></h2>\n<p>What you see above in the demo is pretty much a typical usage of\nnetwork sockets. So what\u2019s special about <tt>aiomsg</tt>? These are\nthe high-level features:</p>\n<ol>\n<li><p>Messages, not streams:</p>\n<p>Send and receive are <em>message-based</em>, not stream based. Much easier! This\ndoes mean that if you want to transmit large amounts of data, you\u2019re going\nto have have to break them up yourself, send the pieces, and put them\nback together on the other side.</p>\n</li>\n<li><p>Automatic reconnection</p>\n<p>These sockets automatically reconnect. You don\u2019t have to\nwrite special code for it. If the bind end (a.k.a \u201cserver\u201d) is restarted,\nthe connecting end will automatically reconnect. This works in either\ndirection.  Try it! run the demo code and kill one of the processes.\nAnd then start it up again. The connection will get re-established.</p>\n</li>\n<li><p>Many connections on a single \u201csocket\u201d</p>\n<p>The bind end can receive multiple connections, but you do all your\n<tt>.send()</tt> and <tt>.recv()</tt> calls on a single object. (No\ncallback handlers or protocol objects.)</p>\n<p>More impressive is that the connecting end is exactly the same; it can make\noutgoing <tt>connect()</tt> calls to multiple peers (bind sockets),\nand you make all your <tt>send()</tt> and <tt>recv()</tt> calls on a single object.</p>\n<p>This will be described in more detail further on in this document.</p>\n</li>\n<li><p>Message distribution patterns</p>\n<p>Receiving messages is pretty simple: new messages just show up (remember\nthat messages from all connected peers come through the same call):</p>\n<pre><span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n    <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">()</span>\n    <span class=\"k\">async</span> <span class=\"k\">for</span> <span class=\"n\">msg</span> <span class=\"ow\">in</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">messages</span><span class=\"p\">():</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">\"Received: </span><span class=\"si\">{</span><span class=\"n\">msg</span><span class=\"si\">}</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n</pre>\n<p>However, when sending messages you have choices. The choices affect\n<strong>which peers</strong> get the message. The options are:</p>\n<ul>\n<li><strong>Publish</strong>: every connected peer is sent a copy of the message</li>\n<li><strong>Round-robin</strong>: each connected peer is sent a <em>unique</em> message; the messages\nare distributed to each connection in a circular pattern.</li>\n<li><strong>By peer identity</strong>: you can also send to a specific peer by using\nits identity directly.</li>\n</ul>\n<p>The choice between <em>pub-sub</em> and <em>round-robin</em> must be made when\ncreating the <tt>S\u00f8cket()</tt>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">aiomsg</span> <span class=\"kn\">import</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">,</span> <span class=\"n\">SendMode</span>\n\n<span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">(</span><span class=\"n\">send_mode</span><span class=\"o\">=</span><span class=\"n\">SendMode</span><span class=\"o\">.</span><span class=\"n\">PUBLISH</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n    <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">()</span>\n    <span class=\"k\">async</span> <span class=\"k\">for</span> <span class=\"n\">msg</span> <span class=\"ow\">in</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">messages</span><span class=\"p\">():</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"p\">)</span>\n</pre>\n<p>This example receives a message from any connected peer, and sends\nthat same message to <em>every</em> connected peer (including the original\nsender). By changing <tt>PUBLISH</tt> to <tt>ROUNDROBIN</tt>, the message\ndistribution pattern changes so that each \u201csent\u201d message goes to\nonly one connected peer. The next \u201csent\u201d message will go to a\ndifferent connected, and so on.</p>\n<p>For <em>identity-based</em> message sending, that\u2019s available any time,\nregardless of what you choose for the <tt>send_mode</tt> parameter; for\nexample:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">from</span> <span class=\"nn\">aiomsg</span> <span class=\"kn\">import</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">,</span> <span class=\"n\">SendMode</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">sock1</span><span class=\"p\">,</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">(</span><span class=\"n\">send_mode</span><span class=\"o\">=</span><span class=\"n\">SendMode</span><span class=\"o\">.</span><span class=\"n\">PUBLISH</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sock2</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock1</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25000</span><span class=\"p\">)</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock2</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25001</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"n\">peer_id</span><span class=\"p\">,</span> <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">sock1</span><span class=\"o\">.</span><span class=\"n\">recv_identity</span><span class=\"p\">()</span>\n            <span class=\"n\">msg_id</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">,</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">msg</span><span class=\"o\">.</span><span class=\"n\">partition</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s2\">\"</span><span class=\"se\">\\x00</span><span class=\"s2\">\"</span><span class=\"p\">)</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock2</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock1</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">msg_id</span> <span class=\"o\">+</span> <span class=\"sa\">b</span><span class=\"s2\">\"</span><span class=\"se\">\\x00</span><span class=\"s2\">ok\"</span><span class=\"p\">,</span> <span class=\"n\">identity</span><span class=\"o\">=</span><span class=\"n\">peer_id</span><span class=\"p\">)</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n<p>This example shows how you can receive messages on one socket (<tt>sock1</tt>,\nwhich could have thousands of connected peers), and relay those messages to\nthousands of other peers connected on a different socket (<tt>sock2</tt>).</p>\n<p>For this example, the <tt>send_mode</tt> of <tt>sock1</tt> doesn\u2019t matter because\nif <tt>identity</tt> is specified in the <tt>send()</tt> call, it\u2019ll ignore\n<tt>send_mode</tt> completely.</p>\n<p>Oh, and the example above is a complete, runnable program which is\npretty amazing!</p>\n</li>\n<li><p>Built-in heartbeating</p>\n<p>Because ain\u2019t nobody got time to mess around with TCP keepalive\nsettings. The heartbeating is internal and opaque to your application\ncode. You won\u2019t even know it\u2019s happening, unless you enable debug\nlogs. Heartbeats are sent only during periods of inactivity, so\nthey won\u2019t interfere with your application messages.</p>\n<p>In theory, you really shouldn\u2019t need heartbeating because TCP is a very robust\nprotocol; but in practice, various intermediate servers and routers\nsometimes do silly things to your connection if they think a connection\nhas been idle for too long. So, automatic heartbeating is baked in to\nlet all intermediate hops know you want the connection to stay up, and\nif the connection goes down, you will know much sooner than the\nstandard TCP keepalive timeout duration (which can be very long!).</p>\n<p>If either a heartbeat or a message isn\u2019t received within a specific\ntimeframe, that connection is destroyed. Whichever peer is making the\n<tt>connect()</tt> call will then automatically try to reconnect, as\ndiscussed earlier.</p>\n</li>\n<li><p>Built-in reliability choices</p>\n<p>Ah, so what do \u201creliability choices\u201d mean exactly\u2026?</p>\n<p>It turns out that it\u2019s quite hard to send messages in a reliable way.\nOr, stated another way, it\u2019s quite hard to avoid dropping messages:\none side sends and the other side never gets the message.</p>\n<p><tt>aiomsg</tt> already buffers messages when being sent. Consider the\nfollowing example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">aiomsg</span> <span class=\"kn\">import</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">,</span> <span class=\"n\">SendMode</span>\n\n<span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">(</span><span class=\"n\">send_mode</span><span class=\"o\">=</span><span class=\"n\">SendMode</span><span class=\"o\">.</span><span class=\"n\">PUBLISH</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n    <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">()</span>\n    <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'123)</span>\n        <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n</pre>\n<p>This server above will send the bytes <tt>b\"123\"</tt> to all connected peers;\nbut what happens if there are <em>no</em> connected peers? In this case the\nmessage will be buffered internally until there is at least one\nconnected peer, and when that happens, all buffered messages will\nimmediately be sent. To be clear, you don\u2019t have to do anything extra.\nThis is just the normal behaviour, and it works the same with the\n<tt>ROUNDROBIN</tt> send mode.</p>\n<p>Message buffering happens whenever there are no connected peers\navailable to receive a message.  Sounds great right?  Unfortunately,\nthis is not quite enough to prevent messages from getting lost. It is\nstill easy to have your process killed immediately after sending data into\na kernel socket buffer, but right before the bytes actually get\ntransmitted. In other words, your code thinks the message got sent, but\nit didn\u2019t actually get sent.</p>\n<p>The only real solution for adding robustness is to have peers <em>reply</em>\nto you saying that they received the message. Then, if you never receive\nthis notification, you should assume that the message might not have\nbeen received, and send it again. <tt>aiomsg</tt> will do this for you\n(so again there is no work on your part), but you do have to turn it\non.</p>\n<p>This option is called the <tt>DeliveryGuarantee</tt>. The default option,\nwhich is just basic message buffering in the absence of any connected\npeers, is called <tt>DeliveryGuarantee.AT_MOST_ONCE</tt>. It means, literally,\nthat any \u201csent\u201d message will received by a connected peer no more than\nonce (of course, it may also be zero, as described above).</p>\n<p>The alternative is to set <tt>DeliveryGuarantee.AT_LEAST_ONCE</tt>, which\nenables the internal \u201cretry\u201d feature. It will be possible, under\ncertain conditions, that any given message could be received <em>more than\nonce</em>, depending on timing and situation.  This is how the code looks\nif you enable it:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">aiomsg</span> <span class=\"kn\">import</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">,</span> <span class=\"n\">SendMode</span><span class=\"p\">,</span> <span class=\"n\">DeliveryGuarantee</span>\n\n<span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">(</span>\n        <span class=\"n\">send_mode</span><span class=\"o\">=</span><span class=\"n\">SendMode</span><span class=\"o\">.</span><span class=\"n\">ROUNDROBIN</span><span class=\"p\">,</span>\n        <span class=\"n\">delivery_guarantee</span><span class=\"o\">=</span><span class=\"n\">DeliveryGuarantee</span><span class=\"o\">.</span><span class=\"n\">AT_LEAST_ONCE</span>\n<span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n    <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">()</span>\n    <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'123)</span>\n        <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n</pre>\n<p>It\u2019s pretty much exactly the same as before, but we added the\n<tt>AT_LEAST_ONCE</tt> option. Note that <tt>AT_LEAST_ONCE</tt> does not work\nfor the <tt>PUBLISH</tt> sending mode. (Would it make sense to enable?)</p>\n<p>As a minor point, you should note that when <tt>AT_LEAST_ONCE</tt> is\nenabled, it does not mean that every send waits for acknowledgement\nbefore the next send. That would incur too much latency. Instead,\nthere is a \u201creply checker\u201d that runs on a timer, and if a reply\nhasn\u2019t been received for a particular message in a certain timeframe\n(5.0 seconds by default), that message will be sent again.</p>\n<p>The connection may have gone down and back up within those 5 seconds,\nand there may be new messages buffered for sending before the retry\nsend happens. In this case, the retry message will arrive <strong>after</strong>\nthose buffered messages. This is a long way of saying that the way\nthat message reliability has been implemented can result in messages\nbeing received in a different <strong>order</strong> to what they were sent. In\nexchange for this, you get a lower overall latency because sending\nnew messages is not waiting on previous messages getting acknowledged.</p>\n</li>\n<li><p>Pure python, doesn\u2019t require a compiler</p>\n</li>\n<li><p>Depends only on the Python standard library</p>\n</li>\n</ol>\n</div>\n<div id=\"cookbook\">\n<h2><a href=\"#id6\" rel=\"nofollow\">Cookbook</a></h2>\n<p>The message distribution patterns are what make <tt>aiomsg</tt> powerful. It\nis the way you connect up a whole bunch of microservices that brings the\ngreatest leverage. We\u2019ll go through the different scenarios using a\ncookbook format.</p>\n<p>In the code snippets that follow, you should assumed that each snippet\nis a complete working program, except that some boilerplate is omitted.\nThis is the basic template:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">from</span> <span class=\"nn\">aiomsg</span> <span class=\"kn\">import</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">,</span> <span class=\"n\">SendMode</span><span class=\"p\">,</span> <span class=\"n\">DeliveryGuarantee</span>\n\n<span class=\"o\">&lt;</span><span class=\"n\">main</span><span class=\"p\">()</span> <span class=\"n\">function</span><span class=\"o\">&gt;</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n<p>Just substitute in the <tt>main()</tt> function from the snippets below to\nmake the complete programs.</p>\n<div id=\"publish-from-either-the-bind-or-connect-end\">\n<h3><a href=\"#id7\" rel=\"nofollow\">Publish from either the <em>bind</em> or <em>connect</em> end</a></h3>\n<p>The choice of \u201cwhich peer should bind\u201d is unaffected by the sending mode\nof the socket.</p>\n<p>Compare</p>\n<pre><span class=\"c1\"># Publisher that binds</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">(</span><span class=\"n\">send_mode</span><span class=\"o\">=</span><span class=\"n\">SendMode</span><span class=\"o\">.</span><span class=\"n\">PUBLISH</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">()</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'News!'</span><span class=\"p\">)</span>\n            <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>versus</p>\n<pre><span class=\"c1\"># Publisher that connects</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">(</span><span class=\"n\">send_mode</span><span class=\"o\">=</span><span class=\"n\">SendMode</span><span class=\"o\">.</span><span class=\"n\">PUBLISH</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">()</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s1\">'News!'</span><span class=\"p\">)</span>\n            <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>The same is true for the round-robin sending mode. You will usually\nchoose the <em>bind</em> peer based one which service is least likely to\nrequire dynamic scaling.  This means that the mental conception of\nsocket peers as either a <em>server</em> or <em>client</em> is not that useful.</p>\n</div>\n<div id=\"distribute-messages-to-a-dynamically-scaled-service-multiple-instances\">\n<h3><a href=\"#id8\" rel=\"nofollow\">Distribute messages to a dynamically-scaled service (multiple instances)</a></h3>\n<p>In this recipe, one service needs to send messages to another service\nthat is horizontally scaled.</p>\n<p>The trick here is that we <em>don\u2019t</em> want to use bind sockets on\nhorizontally-scaled services, because other peers that need to make\na <em>connect</em> call will need to know what hostname to use.\nEach instance in a horizontally-scaled service has a different IP\naddress, and it becomes difficult to keep the \u201cconnect\u201d side up-to-date\nabout which peers are available. This can also change as the\nhorizontally-scaled service increases or decreases the number of\ninstances. (In ZeroMQ documentation, this is described as the\n<a href=\"http://zguide.zeromq.org/page:all#The-Dynamic-Discovery-Problem\" rel=\"nofollow\">Dynamic Discovery Problem</a>).</p>\n<p><tt>aiomsg</tt> handles this very easily: just make sure that the\ndynamically-scaled service is making the connect calls:</p>\n<p>This is the manually-scaled service (has a specific domain name):</p>\n<pre><span class=\"c1\"># jobcreator.py -&gt; DNS for \"jobcreator.com\" should point to this machine.</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">(</span><span class=\"n\">send_mode</span><span class=\"o\">=</span><span class=\"n\">SendMode</span><span class=\"o\">.</span><span class=\"n\">ROUNDROBIN</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"s2\">\"0.0.0.0\"</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25001</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s2\">\"job\"</span><span class=\"p\">)</span>\n            <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>These are the downstream workers (don\u2019t need a domain name):</p>\n<pre><span class=\"c1\"># worker.py - &gt; can be on any number of machines</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">sock</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"s1\">'jobcreator.com'</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25001</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"n\">work</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">recv</span><span class=\"p\">()</span>\n            <span class=\"o\">&lt;</span><span class=\"n\">do</span> <span class=\"n\">work</span><span class=\"o\">&gt;</span>\n</pre>\n<p>With this code, after you start up <tt>jobcreator.py</tt> on the machine\nto which DNS resolves the domain name \u201cjobcreator.com\u201d, you can start\nup multiple instances of <tt>worker.py</tt> on other machines, and work\nwill get distributed among them. You can even change the number of\nworker instances dynamically, and everything will \u201cjust work\u201d, with\nthe main instance distributing work out to all the connected workers\nin a circular pattern.</p>\n<p>This core recipe provides a foundation on which many of the other\nrecipes are built.</p>\n</div>\n<div id=\"distribute-messages-from-a-2-instance-service-to-a-dynamically-scaled-one\">\n<h3><a href=\"#id9\" rel=\"nofollow\">Distribute messages from a 2-instance service to a dynamically-scaled one</a></h3>\n<p>In this scenario, there are actually two instances of the job-creating\nservice, not one. This would typically be done for reliability, and\neach instance would be placed in a different <a href=\"https://searchaws.techtarget.com/definition/availability-zones\" rel=\"nofollow\">availability zones</a>.\nEach instance will have a different domain name.</p>\n<p>It turns out that the required setup follows directly from the previous\none: you just add another connect call in the workers.</p>\n<p>The manually-scaled service is as before, but you start on instance of\n<tt>jobcreator.py</tt> on machine \u201ca.jobcreator.com\u201d, and start another\non machine \u201cb.jobcreator.com\u201d. Obviously, it is DNS that is configured\nto point to the correct IP addresses of those machines (or you could\nuse IP addresses too, if these are internal services).</p>\n<pre><span class=\"c1\"># jobcreator.py -&gt; Configure DNS to point to these instances</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">(</span><span class=\"n\">send_mode</span><span class=\"o\">=</span><span class=\"n\">SendMode</span><span class=\"o\">.</span><span class=\"n\">ROUNDROBIN</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"s2\">\"0.0.0.0\"</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25001</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s2\">\"job\"</span><span class=\"p\">)</span>\n            <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>As before, the downstream workers, but this time each worker makes\nmultiple <tt>connect()</tt> calls; one to each job creator\u2019s domain name:</p>\n<pre><span class=\"c1\"># worker.py - &gt; can be on any number of machines</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"s1\">'a.jobcreator.com'</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25001</span><span class=\"p\">)</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"s1\">'b.jobcreator.com'</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25001</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"n\">work</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">recv</span><span class=\"p\">()</span>\n            <span class=\"o\">&lt;</span><span class=\"n\">do</span> <span class=\"n\">work</span><span class=\"o\">&gt;</span>\n</pre>\n<p><tt>aiomsg</tt> will return <tt>work</tt> from the <tt>sock.recv()</tt> call above as\nit comes in from either job creation service. And as before, the number\nof worker instances can be dynamically scaled, up or down, and all the\nconnection and reconnection logic will be handled internally.</p>\n</div>\n<div id=\"distribute-messages-from-one-dynamically-scaled-service-to-another\">\n<h3><a href=\"#id10\" rel=\"nofollow\">Distribute messages from one dynamically-scaled service to another</a></h3>\n<p>If both services need to be dynamically-scaled, and can have\nvarying numbers of instances at any time, we can no longer rely\non having one end do the <em>socket bind</em> to a dedicated domain name.\nWe really would like each to make <tt>connect()</tt> calls, as we\u2019ve\nseen in previous examples.</p>\n<p>How to solve it?</p>\n<p>The answer is to create an intermediate proxy service that has\n<strong>two</strong> bind sockets, with long-lived domain names. This is what\nwill allow the other two dynamically-scaled services to have\na dynamic number of instances.</p>\n<p>Here is the new job creator, whose name we change to <tt>dynamiccreator.py</tt>\nto reflect that it is now dynamically scalable:</p>\n<pre><span class=\"c1\"># dynamiccreator.py -&gt; can be on any number of machines</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">(</span><span class=\"n\">send_mode</span><span class=\"o\">=</span><span class=\"n\">SendMode</span><span class=\"o\">.</span><span class=\"n\">ROUNDROBIN</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"s2\">\"proxy.jobcreator.com\"</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25001</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s2\">\"job\"</span><span class=\"p\">)</span>\n            <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>Note that our job creator above is now making a <tt>connect()</tt> call to\n<tt>proxy.jobcreator.com:25001</tt> rather than binding to a local port.\nLet\u2019s see what it\u2019s connecting to. Here is the intermediate proxy\nservice, which needs a dedicated domain name, and two ports allocated\nfor each of the bind sockets.</p>\n<pre><span class=\"c1\"># proxy.py -&gt; Set up DNS to point \"proxy.jobcreator.com\" to this instance</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">sock1</span><span class=\"p\">,</span> \\\n            <span class=\"n\">S\u00f8cket</span><span class=\"p\">(</span><span class=\"n\">send_mode</span><span class=\"o\">=</span><span class=\"n\">SendMode</span><span class=\"o\">.</span><span class=\"n\">ROUNDROBIN</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sock2</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock1</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"s2\">\"0.0.0.0\"</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25001</span><span class=\"p\">)</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock2</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"s2\">\"0.0.0.0\"</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25002</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"n\">work</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">sock1</span><span class=\"o\">.</span><span class=\"n\">recv</span><span class=\"p\">()</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock2</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">work</span><span class=\"p\">)</span>\n</pre>\n<p>Note that <tt>sock1</tt> is bound to port 25001; this is what our job creator\nis connecting to. The other socket, <tt>sock2</tt>, is bound to port 25002, and\nthis is the one that our workers will be making their <tt>connect()</tt> calls\nto. Hopefully it\u2019s clear in the code that work is being received from\n<tt>sock1</tt> and being sent onto <tt>sock2</tt>. This is pretty much a feature\ncomplete proxy service, and with only minor additions for error-handling\ncan be used for real work.</p>\n<p>For completeness, here are the downstream workers:</p>\n<pre><span class=\"c1\"># worker.py - &gt; can be on any number of machines</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"s1\">'proxy.jobcreator.com'</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25002</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"n\">work</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">recv</span><span class=\"p\">()</span>\n            <span class=\"o\">&lt;</span><span class=\"n\">do</span> <span class=\"n\">work</span><span class=\"o\">&gt;</span>\n</pre>\n<p>Note that the workers are connecting to port 25002, as expected.</p>\n<p>You might be wondering: isn\u2019t this just moving our performance problem\nto a different place? If the proxy service is not scalable, then surely\nthat becomes the \u201cweakest link\u201d in our system architecture?</p>\n<p>This is a pretty typical reaction, but there are a couple of reasons\nwhy it might not be as bad as you think:</p>\n<ol>\n<li>The proxy service is doing very, very little work. Thus, we expect\nit to suffer from performance problems only at a much higher scale\ncompared to our other two services which are likely to be doing more\nCPU-bound work (in real code, not my simple examples above).</li>\n<li>We could compile only the proxy service into faster low-level code using\nany number of tools such as Cython, C, C++, Rust, D and so on, in order\nto improve its performance, if necessary (this would require implementing\nthe <tt>aiomsg</tt> protocols in that other language though). This allows\nus to retain the benefits of using a dynamic language like Python\nin the dynamically scaled services where much greater business\nlogic is captured (these can be then be horizontally scaled quite\neasily to handle performance issues if necessary).</li>\n<li>Performance is not the only reason services are dynamically scaled.\nIt is always a good idea, even in low-throughput services, to have\nmultiple instances of a service running in different availability zones.\nOutages do happen, yes, even in your favourite cloud provider\u2019s\nsystems.</li>\n<li>A separate proxy service as shown above isolates a really complex\nproblem and removes it from your business logic code. It might not\nbe easy to appreciate how significant that is. As your dev team is\nrapidly iterating on business features, and redeploying new versions\nseveral times a day, the proxy service is unchanging, and doesn\u2019t\nrequire redeployment. In this sense, it plays a similar role to\nmore traditional messaging systems like RabbitMQ and ActiveMQ.</li>\n<li>We can still run multiple instances of our proxy service using an\nearlier technique, as we\u2019ll see in the next recipe.</li>\n</ol>\n</div>\n<div id=\"two-dynamically-scaled-services-with-a-scaled-fan-in-fan-out-proxy\">\n<h3><a href=\"#id11\" rel=\"nofollow\">Two dynamically-scaled services, with a scaled fan-in, fan-out proxy</a></h3>\n<p>This scenario is exactly like the previous one, except that we\u2019re\nnervous about having only a single proxy service, since it is a\nsingle point of failure.  Instead, we\u2019re going to have 3 instances of\nthe proxy service running in parallel.</p>\n<p>Let\u2019s jump straight into code. The proxy code itself is actually\nunchanged from before.  We just need to run more copies of it on\ndifferent machines. <em>Each machine will have a different domain name</em>.</p>\n<pre><span class=\"c1\"># proxy.py -&gt; unchanged from the previous recipe</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">sock1</span><span class=\"p\">,</span> \\\n            <span class=\"n\">S\u00f8cket</span><span class=\"p\">(</span><span class=\"n\">send_mode</span><span class=\"o\">=</span><span class=\"n\">SendMode</span><span class=\"o\">.</span><span class=\"n\">ROUNDROBIN</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sock2</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock1</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"s2\">\"0.0.0.0\"</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25001</span><span class=\"p\">)</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock2</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"s2\">\"0.0.0.0\"</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25002</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"n\">work</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">sock1</span><span class=\"o\">.</span><span class=\"n\">recv</span><span class=\"p\">()</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock2</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">work</span><span class=\"p\">)</span>\n</pre>\n<p>For the other two dynamically scaled services, we need to tell them\nall the domain names to connect to.  We could set that up in an\nenvironment variable:</p>\n<pre>$ <span class=\"nb\">export</span> <span class=\"nv\">PROXY_HOSTNAMES</span><span class=\"o\">=</span><span class=\"s2\">\"px1.jobcreator.com;px2.jobcreator.com;px3.jobcreator.com\"</span>\n</pre>\n<p>Then, it\u2019s really easy to modify our services to make use of that. First,\nthe dynamically-scaled job creator:</p>\n<pre><span class=\"c1\"># dynamiccreator.py -&gt; can be on any number of machines</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">(</span><span class=\"n\">send_mode</span><span class=\"o\">=</span><span class=\"n\">SendMode</span><span class=\"o\">.</span><span class=\"n\">ROUNDROBIN</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">for</span> <span class=\"n\">proxy</span> <span class=\"ow\">in</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">environ</span><span class=\"p\">[</span><span class=\"s1\">'PROXY_HOSTNAMES'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s2\">\";\"</span><span class=\"p\">):</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"n\">proxy</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25001</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"sa\">b</span><span class=\"s2\">\"job\"</span><span class=\"p\">)</span>\n            <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>And the change for the worker code is identical (making sure the correct\nport is being used, 25002):</p>\n<pre><span class=\"c1\"># worker.py - &gt; can be on any number of machines</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">for</span> <span class=\"n\">proxy</span> <span class=\"ow\">in</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">environ</span><span class=\"p\">[</span><span class=\"s1\">'PROXY_HOSTNAMES'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s2\">\";\"</span><span class=\"p\">):</span>\n            <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">hostname</span><span class=\"o\">=</span><span class=\"n\">proxy</span><span class=\"p\">,</span> <span class=\"n\">port</span><span class=\"o\">=</span><span class=\"mi\">25002</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"n\">work</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">recv</span><span class=\"p\">()</span>\n            <span class=\"o\">&lt;</span><span class=\"n\">do</span> <span class=\"n\">work</span><span class=\"o\">&gt;</span>\n</pre>\n<p>Three proxies, each running in a different availability zone, should\nbe adequate for most common scenarios.</p>\n<p>TODO: more scenarios involving identity (like ROUTER-DEALER)</p>\n</div>\n<div id=\"secure-connections-with-mutual-tls\">\n<h3><a href=\"#id12\" rel=\"nofollow\">Secure connections with mutual TLS</a></h3>\n<p>Secure connectivity is extremely important, <em>even in an internal\nmicroservices infrastructure</em>. From a design perspective, the single\nbiggest positive impact that can be made on security is to make it <strong>easy</strong>\nfor users to do the \u201cright thing\u201d.</p>\n<p>For this reason, <tt>aiomsg</tt> does nothing new at all. It uses the existing\nsupport for secure connectivity in the Python standard library, and\nuses the same APIs exactly as-is.</p>\n<p>All you have to do is create an <a href=\"https://docs.python.org/3/library/ssl.html#ssl.SSLContext\" rel=\"nofollow\">SSLContext</a>\nobject, exactly as you normally would for conventional Python\nsockets, and pass that in.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Mutual_authentication\" rel=\"nofollow\">Mutual TLS authentication (mTLS)</a>\nis where the client verifies the server <strong>and</strong> the server verifies\nthe client. In <tt>aiomsg</tt>, names like \u201cclient\u201d and \u201cserver\u201d are less\nuseful, so let\u2019s rather say that the <em>connect</em> socket verifies the\ntarget <em>bind</em> socket, and the <em>bind</em> socket also verifies the incoming\nconnecting socket.</p>\n<p>It sounds complicated, but at a high level you just need to supply\nan <tt>SSLContext</tt> instance to the bind socket, and a different <tt>SSLContext</tt>\ninstance to the connect socket (usually on a different computer). The details\nare all stored in the <tt>SSLContext</tt> objects.</p>\n<p>Let\u2019s first look at how that looks for a typical bind socket and connect\nsocket:</p>\n<pre><span class=\"c1\"># bind end</span>\n<span class=\"kn\">import</span> <span class=\"nn\">ssl</span>\n<span class=\"kn\">import</span> <span class=\"nn\">asyncio</span><span class=\"o\">,</span> <span class=\"nn\">time</span>\n<span class=\"kn\">from</span> <span class=\"nn\">aiomsg</span> <span class=\"kn\">import</span> <span class=\"n\">S\u00f8cket</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">ctx</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">SSLContext</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>    <span class=\"c1\"># &lt;--------- NEW!</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"s1\">'127.0.0.1'</span><span class=\"p\">,</span> <span class=\"mi\">25000</span><span class=\"p\">,</span> <span class=\"n\">ssl_context</span><span class=\"o\">=</span><span class=\"n\">ctx</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n            <span class=\"k\">await</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">ctime</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">())</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n<pre><span class=\"c1\"># connect end</span>\n<span class=\"kn\">import</span> <span class=\"nn\">ssl</span>\n<span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">from</span> <span class=\"nn\">aiomsg</span> <span class=\"kn\">import</span> <span class=\"n\">S\u00f8cket</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">ctx</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">SSLContext</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>    <span class=\"c1\"># &lt;--------- NEW!</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">S\u00f8cket</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">sock</span><span class=\"p\">:</span>\n        <span class=\"k\">await</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"s1\">'127.0.0.1'</span><span class=\"p\">,</span> <span class=\"mi\">25000</span><span class=\"p\">,</span> <span class=\"n\">ssl_context</span><span class=\"o\">=</span><span class=\"n\">ctx</span><span class=\"p\">)</span>\n        <span class=\"k\">async</span> <span class=\"k\">for</span> <span class=\"n\">msg</span> <span class=\"ow\">in</span> <span class=\"n\">sock</span><span class=\"o\">.</span><span class=\"n\">messages</span><span class=\"p\">():</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">())</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n<p>If you compare these two code snippets to what was shown in the <em>Demo</em>\nsection, you\u2019ll see it\u2019s almost exactly the same, except that we\u2019re\npassing a new <cite>ctx</cite> parameter into the respective <cite>bind()</cite> and <cite>connect()</cite>\ncalls, which is an instance of <cite>SSLContext</cite>.</p>\n<p>So if you already know how to work with Python\u2019s built-in <cite>SSLContext</cite>\nobject, you can already create secure connections with <cite>aiomsg</cite> and\nthere\u2019s nothing more you need to learn.</p>\n<div id=\"crash-course-on-setting-up-an-sslcontext\">\n<h4><a href=\"#id13\" rel=\"nofollow\">Crash course on setting up an <tt>SSLContext</tt></a></h4>\n<p>You might not know how to set up the <tt>SSLContext</tt> object.\nHere, I\u2019ll give a crash course, but please remember that I am\nnot a security expert so make sure to ask an actual security expert\nto review your work if you\u2019re working on a production system.</p>\n<p>The best way to create an <tt>SSLContext</tt> object is <strong>not</strong> with its\nconstructor, but rather a helper function called <tt>create_default_context()</tt>,\nwhich sets a lot of sensible defaults that you would otherwise have to\ndo manually. So that\u2019s how you get the context instance.</p>\n<p>You do have to specify whether the purpose of the context object is to\nverify a client or a server. Let\u2019s have a look at that:</p>\n<pre><span class=\"c1\"># bind socket, or \"server\"</span>\n<span class=\"n\">ctx</span><span class=\"p\">:</span> <span class=\"n\">SSLContext</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">create_default_context</span><span class=\"p\">(</span><span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">Purpose</span><span class=\"o\">.</span><span class=\"n\">CLIENT_AUTH</span><span class=\"p\">)</span>\n</pre>\n<p>So here, above, we\u2019re creating a context object for a bind socket. The\npurpose of the context is going to be to <em>verify incoming client connections</em>,\nthat\u2019s why the <tt>CLIENT_AUTH</tt> purpose was given.  As you might imagine,\non the other end, i.e., the connect socket (or \u201cclient\u201d), the purpose\nis going to be to verify the server:</p>\n<pre><span class=\"c1\"># connect socket, or \"client\"</span>\n<span class=\"n\">ctx</span><span class=\"p\">:</span> <span class=\"n\">SSLContext</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">create_default_context</span><span class=\"p\">(</span><span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">Purpose</span><span class=\"o\">.</span><span class=\"n\">SERVER_AUTH</span><span class=\"p\">)</span>\n</pre>\n<p>Once you\u2019ve created the context, the remaining parameters have the same\nmeaning for both client and server.</p>\n<p>The way TLS works (the artist formerly known as SSL) is that each end\nof a connection has two pieces of information:</p>\n<ol>\n<li>A <strong>certificate</strong> (may be shared publicly)</li>\n<li>A <strong>key</strong> (MUST NOT BE SHARED! SECRET!)</li>\n</ol>\n<p>When the two sockets establish a connection, they trade certificates, but\ndo not trade keys. Anyway, let\u2019s look at what you need to actually set\nin the code. We\u2019ll start with the connect socket (client).</p>\n<pre><span class=\"c1\"># connect socket, or \"client\"</span>\n<span class=\"n\">ctx</span><span class=\"p\">:</span> <span class=\"n\">SSLContext</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">create_default_context</span><span class=\"p\">(</span><span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">Purpose</span><span class=\"o\">.</span><span class=\"n\">SERVER_AUTH</span><span class=\"p\">)</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">verify_mode</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">CERT_REQUIRED</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">check_hostname</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">load_verify_locations</span><span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">something</span> <span class=\"n\">that</span> <span class=\"n\">can</span> <span class=\"n\">verify</span> <span class=\"n\">the</span> <span class=\"n\">server</span> <span class=\"n\">cert</span><span class=\"o\">&gt;</span><span class=\"p\">)</span>\n</pre>\n<p>The above will let the client verify that the server it is connecting\nto is the correct one. When the socket connects, the server socket\nwill send back a <em>certificate</em> and the client checks that against one of\nthose mysterious \u201cverify locations\u201d.</p>\n<p>For mutual TLS, the server also wants to check the client. What does it\ncheck? Well, the client must also provide a certificate back to the server.\nSo that requires an additional line in the code block above:</p>\n<pre><span class=\"c1\"># connect socket, or \"client\"</span>\n<span class=\"n\">ctx</span><span class=\"p\">:</span> <span class=\"n\">SSLContext</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">create_default_context</span><span class=\"p\">(</span><span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">Purpose</span><span class=\"o\">.</span><span class=\"n\">SERVER_AUTH</span><span class=\"p\">)</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">verify_mode</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">CERT_REQUIRED</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">check_hostname</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">load_verify_locations</span><span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">something</span> <span class=\"n\">that</span> <span class=\"n\">can</span> <span class=\"n\">verify</span> <span class=\"n\">the</span> <span class=\"n\">server</span> <span class=\"n\">cert</span><span class=\"o\">&gt;</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Client needs a pair of \"cert\" and \"key\"</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">load_cert_chain</span><span class=\"p\">(</span><span class=\"n\">certfile</span><span class=\"o\">=</span><span class=\"s2\">\"client.cert\"</span><span class=\"p\">,</span> <span class=\"n\">keyfile</span><span class=\"o\">=</span><span class=\"s2\">\"client.key\"</span><span class=\"p\">)</span>\n</pre>\n<p>So that completes everything we need to do for the SSL context on the\nclient side.  On the server side, everything is almost exactly the same:</p>\n<pre><span class=\"c1\"># bind socket, or \"server\"</span>\n<span class=\"n\">ctx</span><span class=\"p\">:</span> <span class=\"n\">SSLContext</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">create_default_context</span><span class=\"p\">(</span><span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">Purpose</span><span class=\"o\">.</span><span class=\"n\">CLIENT_AUTH</span><span class=\"p\">)</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">verify_mode</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">CERT_REQUIRED</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">load_verify_locations</span><span class=\"p\">(</span><span class=\"o\">&lt;</span><span class=\"n\">something</span> <span class=\"n\">that</span> <span class=\"n\">can</span> <span class=\"n\">verify</span> <span class=\"n\">the</span> <span class=\"n\">client</span> <span class=\"n\">cert</span><span class=\"o\">&gt;</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Server needs a pair of \"cert\" and \"key\"</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">load_cert_chain</span><span class=\"p\">(</span><span class=\"n\">certfile</span><span class=\"o\">=</span><span class=\"s2\">\"server.cert\"</span><span class=\"p\">,</span> <span class=\"n\">keyfile</span><span class=\"o\">=</span><span class=\"s2\">\"server.key\"</span><span class=\"p\">)</span>\n</pre>\n<p>That describes everything you need to do to set up <em>mutual TLS</em> using\n<tt>SSLContext</tt> instances.</p>\n<p>There are a few loose ends to tie up though. Where do you get the\n<tt>certfile</tt> and <tt>keyfile</tt> from? And what is this mysterious\n\u201cverify location\u201d? The first question is easier. The cert and key can be\ngenerated using the OpenSSL command-line application:</p>\n<pre>$ openssl req -newkey rsa:2048 -nodes -keyout server.key <span class=\"se\">\\\n</span>    -x509 -days <span class=\"m\">365</span> -out server.cert <span class=\"se\">\\\n</span>    -subj <span class=\"s1\">'/C=GB/ST=Blah/L=Blah/O=Blah/OU=Blah/CN=example.com'</span>\n</pre>\n<p>Running the above command will create two new files, <tt>server.cert</tt> and\n<tt>server.key</tt>; these are ones you specify in earlier commands. Generating\nthese files for the client is exactly the same, but you use different\nnames.</p>\n<p>You could also use <a href=\"https://letsencrypt.org/\" rel=\"nofollow\">Let\u2019s Encrypt</a>\nto generate the cert and key, in which case you don\u2019t have to run the\nabove commands. <em>IF</em> you use Let\u2019s Encrypt, you\u2019ve also solved the\nother problem of supplying a \u201cverify location\u201d, and in fact you won\u2019t need\nto call <tt>load_verify_locations()</tt> in the client code at all. This is\nbecause there are a bunch of <em>root certificate authorities</em> that are\nprovided with most operating systems, and <em>Let\u2019s Encrypt</em> is one of those.</p>\n<p>However, for the sake of argument, let\u2019s say you want to make your\nown certificates and you don\u2019t want to rely on system-provided root\ncertificates at all; how to do the verification? Well it turns out that\na very simple solution is to just use the target certificate itself to be\nthe \u201cverify location\u201d. For example, here is the client context again:</p>\n<pre><span class=\"c1\"># connect socket, or \"client\"</span>\n<span class=\"n\">ctx</span><span class=\"p\">:</span> <span class=\"n\">SSLContext</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">create_default_context</span><span class=\"p\">(</span><span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">Purpose</span><span class=\"o\">.</span><span class=\"n\">SERVER_AUTH</span><span class=\"p\">)</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">verify_mode</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">CERT_REQUIRED</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">check_hostname</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">load_verify_locations</span><span class=\"p\">(</span><span class=\"s2\">\"server.cert\"</span><span class=\"p\">)</span>   <span class=\"c1\"># &lt;--- Same one as the server</span>\n\n<span class=\"c1\"># Client needs a pair of \"cert\" and \"key\"</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">load_cert_chain</span><span class=\"p\">(</span><span class=\"n\">certfile</span><span class=\"o\">=</span><span class=\"s2\">\"client.cert\"</span><span class=\"p\">,</span> <span class=\"n\">keyfile</span><span class=\"o\">=</span><span class=\"s2\">\"client.key\"</span><span class=\"p\">)</span>\n</pre>\n<p>and then in the server\u2019s context, you could also use the client\u2019s cert\nas the \u201cverify location\u201d:</p>\n<pre><span class=\"c1\"># bind socket, or \"server\"</span>\n<span class=\"n\">ctx</span><span class=\"p\">:</span> <span class=\"n\">SSLContext</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">create_default_context</span><span class=\"p\">(</span><span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">Purpose</span><span class=\"o\">.</span><span class=\"n\">CLIENT_AUTH</span><span class=\"p\">)</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">verify_mode</span> <span class=\"o\">=</span> <span class=\"n\">ssl</span><span class=\"o\">.</span><span class=\"n\">CERT_REQUIRED</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">load_verify_locations</span><span class=\"p\">(</span><span class=\"s2\">\"client.cert)   # &lt;--- Same as on client</span>\n\n<span class=\"c1\"># Server needs a pair of \"cert\" and \"key\"</span>\n<span class=\"n\">ctx</span><span class=\"o\">.</span><span class=\"n\">load_cert_chain</span><span class=\"p\">(</span><span class=\"n\">certfile</span><span class=\"o\">=</span><span class=\"s2\">\"server.cert\"</span><span class=\"p\">,</span> <span class=\"n\">keyfile</span><span class=\"o\">=</span><span class=\"s2\">\"server.key\"</span><span class=\"p\">)</span>\n</pre>\n<p>Obviously, the client code and the server code are running on different\ncomputers and you need to make sure that the right files are on the right\ncomputers in the right places.</p>\n<p>There are a lot of ways to make this more sophisticated, but it\u2019s\nprobably a good idea to get the simple case working, as described above,\nbefore looking at the more complicated cases. A cool option is to make\nyour own <em>root certificate authority</em>, which can be a standard\n\u201cverify location\u201d in all your microservices, and then when you make certs\nand keys for each microservice, you just have to \u201csign\u201d them with the\nroot key. This process is described in\n<a href=\"https://opensource.com/article/19/4/certificate-authority\" rel=\"nofollow\">Be your own certificate authority</a>\nby Moshe Zadka</p>\n<p>Hope that helps!</p>\n</div>\n</div>\n</div>\n<div id=\"faq\">\n<h2><a href=\"#id14\" rel=\"nofollow\">FAQ</a></h2>\n<div id=\"why-do-you-spell-socket-like-that\">\n<h3><a href=\"#id15\" rel=\"nofollow\">Why do you spell <tt>S\u00f8cket</tt> like that?</a></h3>\n<p>The slashed O is used in homage to <a href=\"http://zeromq.org/\" rel=\"nofollow\">\u00d8MQ</a>, a truly\nwonderful library that changed my thinking around what socket programming\ncould be like.</p>\n</div>\n<div id=\"i-want-to-talk-to-the-aiomsg-socket-with-a-different-programming-language\">\n<h3><a href=\"#id16\" rel=\"nofollow\">I want to talk to the aiomsg S\u00f8cket with a different programming language</a></h3>\n<p><strong>WARNING: This section is extremely provisional. I haven\u2019t fully\nnailed down the protocol yet.</strong></p>\n<p>To make a clone of the <tt>S\u00f8cket</tt> in another language is probably a\nlot of work, but it\u2019s actually not necessary to implement everything.</p>\n<p>You can talk to <tt>aiomsg</tt> sockets quite easily by implementing the\nsimple protocol described below. It would be just like regular\nsocket programming in your programming language. You just have to\nfollow a few simple rules for the communication protocol.</p>\n<p>These are the rules:</p>\n<ol>\n<li><p><strong>Every payload</strong> in either direction shall be length-prefixed:</p>\n<pre>message = [4-bytes big endian int32][payload]\n</pre>\n</li>\n<li><p><strong>Immediately</strong> after successfully opening a TCP connection, before doing\nanything else with your socket, you shall:</p>\n<blockquote>\n<ul>\n<li><p>Send your identity, as a 16 byte unique identifier (a 16 byte UUID4\nis perfect). Note that Rule 1 still applies, so this would look like</p>\n<pre>identity_message = b'\\x00\\x00\\x00\\x10' + [16 bytes]\n</pre>\n<p>(because the payload length, 16, is <tt>0x10</tt> in hex)</p>\n</li>\n<li><p>Receive the other peer\u2019s identity (16 bytes). Remember Rule 1 still\napplies, so you\u2019ll actually receive 20 bytes, and the first four will\nbe the length of the payload, which will be 16 bytes for this message.</p>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>You shall <strong>periodically</strong> send a heartbeat message <tt><span class=\"pre\">b\"aiomsg-heartbeat\"</span></tt>.\nEvery 5 seconds is good. If you receive such messages you can ignore them.\nIf you don\u2019t receive one (or an actual data message) within 15 seconds\nof the previous receipt,\nthe connection is probably dead and you should kill it and/or reconnect.\nNote that Rule 1 still applies, and because the length of this message\nis also 16 bytes, the message is ironically similar to the identity\nmessage:</p>\n<pre>heartbeat_message = b'\\x00\\x00\\x00\\x10' + b'aiomsg-heartbeat'\n</pre>\n</li>\n</ol>\n<p>After you\u2019ve satisfied these rules, from that point on every message\nsent or received is a Rule 1 message, i.e., length prefixed with 4 bytes\nfor the length of the payload that follows.</p>\n<p>If you want to run a <em>bind</em> socket, and receive multiple connections from\ndifferent <tt>aiomsg</tt> sockets, then the above rules apply to <em>each</em> separate\nconnection.</p>\n<p>That\u2019s it!</p>\n<p>TODO: Discuss the protocol for <tt>AT_LEAST_ONCE</tt> mode, which is a bit messy\nat the moment.</p>\n</div>\n</div>\n<div id=\"developer-setup\">\n<h2><a href=\"#id17\" rel=\"nofollow\">Developer setup</a></h2>\n<ol>\n<li><p>Setup:</p>\n<pre>$ git clone https://github.com/cjrh/aiomsg\n$ python -m venv venv\n$ source venv/bin/activate  (or venv/Scripts/activate.bat on Windows)\n$ pip install -e .[all]\n</pre>\n</li>\n<li><p>Run the tests:</p>\n<pre>$ pytest\n</pre>\n</li>\n<li><p>Create a new release:</p>\n<pre>$ bumpymcbumpface --push-git --push-pypi\n</pre>\n</li>\n</ol>\n<p>The easiest way to obtain the\n<a href=\"https://pypi.org/project/bumpymcbumpface/\" rel=\"nofollow\">bumpymcbumpface</a> tool is\nto install it with <a href=\"https://github.com/pipxproject/pipx\" rel=\"nofollow\">pipx</a>. Once installed\nand on your <tt>$PATH</tt>, the command above should work. <strong>NOTE: twine must be\ncorrectly configured to upload to pypi.</strong>  If you don\u2019t have rights to\npush to PyPI, but you do have rights to push to github, just omit\nthe <tt><span class=\"pre\">--push-pypi</span></tt> option in the command above. The command will\nautomatically create the next git tag and push it.</p>\n</div>\n\n          </div>"}, "last_serial": 6260589, "releases": {"2018.8.1": [{"comment_text": "", "digests": {"md5": "c4e542eca1e7553f455cb1b4db4e9484", "sha256": "c9f6f5264491dcaff760220687bc20166c679ff09f33b773997accc9461623cb"}, "downloads": -1, "filename": "aiomsg-2018.8.1-py3-none-any.whl", "has_sig": false, "md5_digest": "c4e542eca1e7553f455cb1b4db4e9484", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 13920, "upload_time": "2019-01-13T07:38:14", "upload_time_iso_8601": "2019-01-13T07:38:14.170146Z", "url": "https://files.pythonhosted.org/packages/f8/a4/6362f3d2cf369ddc7c8970b9978191291b358e3a14723ac9e61f1daffa50/aiomsg-2018.8.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "41284c924e044b463f592645a35eb071", "sha256": "ff37c7ff877ac8ea0e0dadb867b5d7c47e6f2dfd09cb86959bedc0da8e6702b3"}, "downloads": -1, "filename": "aiomsg-2018.8.1.tar.gz", "has_sig": false, "md5_digest": "41284c924e044b463f592645a35eb071", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13741, "upload_time": "2019-01-13T07:38:16", "upload_time_iso_8601": "2019-01-13T07:38:16.244846Z", "url": "https://files.pythonhosted.org/packages/0b/01/e959f021e0cc8bd09cd086a1db674af4f353cffb4b092c2a7fa0776276a1/aiomsg-2018.8.1.tar.gz", "yanked": false}], "2019.1.1": [{"comment_text": "", "digests": {"md5": "55575be415f89d2504d0b3bf934a986c", "sha256": "88e44571f570850e356fa350be2b510d429162164256bfe7a5669f2cd51e8e2d"}, "downloads": -1, "filename": "aiomsg-2019.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "55575be415f89d2504d0b3bf934a986c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 13880, "upload_time": "2019-01-13T07:50:10", "upload_time_iso_8601": "2019-01-13T07:50:10.119641Z", "url": "https://files.pythonhosted.org/packages/29/de/23a3ed250c64849ae139a13e077b28dc3ea008dced5e40730db4c8a7d24d/aiomsg-2019.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "018a3b5a66bb7d090fedc4ec79dc715a", "sha256": "8636f452e21961e00fe84dfd14314f9554eb98ebf4d129bfee9d4dee2b3b60f4"}, "downloads": -1, "filename": "aiomsg-2019.1.1.tar.gz", "has_sig": false, "md5_digest": "018a3b5a66bb7d090fedc4ec79dc715a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13653, "upload_time": "2019-01-13T07:50:12", "upload_time_iso_8601": "2019-01-13T07:50:12.832711Z", "url": "https://files.pythonhosted.org/packages/fa/5e/3f410e24b82d5aadc4a7a2e1b4f91d1b8352ecfb266330de922411bc198b/aiomsg-2019.1.1.tar.gz", "yanked": false}], "2019.12.1": [{"comment_text": "", "digests": {"md5": "76ad75333ebb7822692be94adb2b37e9", "sha256": "340b8f28363f7cdb98c91d10d72e0f2674c268062d94825a228cb0fbab25c358"}, "downloads": -1, "filename": "aiomsg-2019.12.1-py3-none-any.whl", "has_sig": false, "md5_digest": "76ad75333ebb7822692be94adb2b37e9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 27202, "upload_time": "2019-12-08T03:19:27", "upload_time_iso_8601": "2019-12-08T03:19:27.383270Z", "url": "https://files.pythonhosted.org/packages/eb/9e/95451bbc6bd598e00d96df78942a5a7c8e9712e7474cbca3249eaee69ba6/aiomsg-2019.12.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "912c122694ab9dc45f929f5de54c652d", "sha256": "79aed8eb45d3905fbdebc1962be8e6ef2a2935ada7a13ccf31a4a47e49795482"}, "downloads": -1, "filename": "aiomsg-2019.12.1.tar.gz", "has_sig": false, "md5_digest": "912c122694ab9dc45f929f5de54c652d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47080, "upload_time": "2019-12-08T03:19:30", "upload_time_iso_8601": "2019-12-08T03:19:30.289405Z", "url": "https://files.pythonhosted.org/packages/a3/17/c116ce6c656c9aaefd91ed84eaca0e9403e7e43eaf757c5791950330e660/aiomsg-2019.12.1.tar.gz", "yanked": false}], "2019.12.2": [{"comment_text": "", "digests": {"md5": "a1d9b670c253018d66743dc7c73893ba", "sha256": "d1a56b43dee6d44068949ebe6607a16cbf367fb44f99e4104d882cbe5a4e3bb0"}, "downloads": -1, "filename": "aiomsg-2019.12.2-py3-none-any.whl", "has_sig": false, "md5_digest": "a1d9b670c253018d66743dc7c73893ba", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 27344, "upload_time": "2019-12-08T04:02:33", "upload_time_iso_8601": "2019-12-08T04:02:33.551432Z", "url": "https://files.pythonhosted.org/packages/a1/2f/b25331f6fd2503a2352ae2163baa243fe809d834d5569c39e1e55aba6d23/aiomsg-2019.12.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6e07976268fc03a399c208573ece2154", "sha256": "99e074d55cf3ec0c8a84ad656c9f2c6ec3ad264bf403d337c7db401e92fef006"}, "downloads": -1, "filename": "aiomsg-2019.12.2.tar.gz", "has_sig": false, "md5_digest": "6e07976268fc03a399c208573ece2154", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47493, "upload_time": "2019-12-08T04:02:36", "upload_time_iso_8601": "2019-12-08T04:02:36.227244Z", "url": "https://files.pythonhosted.org/packages/84/f3/15d41218171cd54991a1d089e1f0b6d2ad3a7721371dd6a15f8a83710f13/aiomsg-2019.12.2.tar.gz", "yanked": false}], "2019.12.3": [{"comment_text": "", "digests": {"md5": "22c070d8845db96e9c86fcce4856fdc9", "sha256": "aa531c1bc267908242dd7c6896c784ff542712255e18c0d5048c273b45418d85"}, "downloads": -1, "filename": "aiomsg-2019.12.3-py3-none-any.whl", "has_sig": false, "md5_digest": "22c070d8845db96e9c86fcce4856fdc9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 28122, "upload_time": "2019-12-08T05:34:46", "upload_time_iso_8601": "2019-12-08T05:34:46.516994Z", "url": "https://files.pythonhosted.org/packages/a2/10/557fc090c3c5fbe7fab20c9e7719bfd992b69451f85cda65cf6b0977e428/aiomsg-2019.12.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8c9c31bea97bdb555cc65aca2f226e74", "sha256": "87af01daffa77f4461a9a88cf0df7047eb82e6a3edc2a0033c335a17903f8ce4"}, "downloads": -1, "filename": "aiomsg-2019.12.3.tar.gz", "has_sig": false, "md5_digest": "8c9c31bea97bdb555cc65aca2f226e74", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 48243, "upload_time": "2019-12-08T05:34:49", "upload_time_iso_8601": "2019-12-08T05:34:49.604355Z", "url": "https://files.pythonhosted.org/packages/09/e1/674c7e0f4715ca6ea87ca8fa46e59a328dd41dd120b68ee411531221f945/aiomsg-2019.12.3.tar.gz", "yanked": false}], "2019.4.1": [{"comment_text": "", "digests": {"md5": "ec1306afa9917f344e040ff3f742e646", "sha256": "53c4b47994b2a1d1fd641f9f0add58254d76221d92b08f9dc7f8a069f4cd60c9"}, "downloads": -1, "filename": "aiomsg-2019.4.1-py3-none-any.whl", "has_sig": false, "md5_digest": "ec1306afa9917f344e040ff3f742e646", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14052, "upload_time": "2019-04-14T12:44:55", "upload_time_iso_8601": "2019-04-14T12:44:55.210173Z", "url": "https://files.pythonhosted.org/packages/9a/71/eb7904620ee3d6a5040ddc9af72eece523f1646fbf071b24c8249bccc5a1/aiomsg-2019.4.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c72225d421e50f0b566c19e02c5781db", "sha256": "121ee578664b7d7e8a265fc7024616b1b7e5f1be4533a89cf0e82ada0929189c"}, "downloads": -1, "filename": "aiomsg-2019.4.1.tar.gz", "has_sig": false, "md5_digest": "c72225d421e50f0b566c19e02c5781db", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14221, "upload_time": "2019-04-14T12:44:57", "upload_time_iso_8601": "2019-04-14T12:44:57.096413Z", "url": "https://files.pythonhosted.org/packages/d2/d5/f265f753e888bad69bfd0a11a8317d98558ec121adaa169b13cae1731b30/aiomsg-2019.4.1.tar.gz", "yanked": false}], "2019.4.12": [{"comment_text": "", "digests": {"md5": "ca4842f8819a947d8195b75e17df0147", "sha256": "5e277294f16614f56521f0d10f99bbbda11ab53d1629a67d8fac19a3aa28a7cc"}, "downloads": -1, "filename": "aiomsg-2019.4.12-py3-none-any.whl", "has_sig": false, "md5_digest": "ca4842f8819a947d8195b75e17df0147", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 23337, "upload_time": "2019-04-29T13:09:44", "upload_time_iso_8601": "2019-04-29T13:09:44.202787Z", "url": "https://files.pythonhosted.org/packages/92/4a/c6e8ad37be9679d462e0f8ba0fef518df71ad4243902f9baf30ef0245ae8/aiomsg-2019.4.12-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c1d2db80dd9dad7e5a9ebc418a2231fe", "sha256": "824b5b502a8c7b4cd7ece6b66975796f1bc6bda54cd29834985f5753e5309809"}, "downloads": -1, "filename": "aiomsg-2019.4.12.tar.gz", "has_sig": false, "md5_digest": "c1d2db80dd9dad7e5a9ebc418a2231fe", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36396, "upload_time": "2019-04-29T13:09:53", "upload_time_iso_8601": "2019-04-29T13:09:53.294781Z", "url": "https://files.pythonhosted.org/packages/6d/e9/83a92a4367ff4cb126c89df31ace437060234879a97b227169ea36d03d2e/aiomsg-2019.4.12.tar.gz", "yanked": false}], "2019.4.13": [{"comment_text": "", "digests": {"md5": "5b507ed5c4577a63c4e098630ae329bd", "sha256": "b37863b9acada1096583f6c7ede1b0c943834a448dbc16c695baf52a524d86f3"}, "downloads": -1, "filename": "aiomsg-2019.4.13-py3-none-any.whl", "has_sig": false, "md5_digest": "5b507ed5c4577a63c4e098630ae329bd", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 24192, "upload_time": "2019-05-12T09:18:34", "upload_time_iso_8601": "2019-05-12T09:18:34.261670Z", "url": "https://files.pythonhosted.org/packages/af/20/3aa93b5abe19a19637397ffb09de8a0581ddd5d0c07ac86f09daf88a7274/aiomsg-2019.4.13-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8a48af63b0c0416aa78258121916b6ea", "sha256": "8495987bef2d88748845dc9ffedb67936a96e0f94898a46c8912849b9fd88421"}, "downloads": -1, "filename": "aiomsg-2019.4.13.tar.gz", "has_sig": false, "md5_digest": "8a48af63b0c0416aa78258121916b6ea", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 39458, "upload_time": "2019-05-12T09:18:38", "upload_time_iso_8601": "2019-05-12T09:18:38.072691Z", "url": "https://files.pythonhosted.org/packages/4c/55/5615546e97195f524f49f9e3104f6d15839b80cebb10d5424b27e071bcda/aiomsg-2019.4.13.tar.gz", "yanked": false}], "2019.4.2": [{"comment_text": "", "digests": {"md5": "5f061d01b386542f43218c82c5e7917d", "sha256": "ddbd35226a9975d52cf7a0e3dcccd00309c598cef9f59d8baf95a9cc444311e3"}, "downloads": -1, "filename": "aiomsg-2019.4.2-py3-none-any.whl", "has_sig": false, "md5_digest": "5f061d01b386542f43218c82c5e7917d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17969, "upload_time": "2019-04-27T00:21:54", "upload_time_iso_8601": "2019-04-27T00:21:54.921187Z", "url": "https://files.pythonhosted.org/packages/8a/4e/56c33932130ab9648c8954b35c59b2e17c3e5da7b38d2c6847e228e00c45/aiomsg-2019.4.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c5b157fb63d7cfda2e4816cccf888888", "sha256": "81c60f241ea7a028fa1503ac0c1d36c00f67a919af9106697add7760590ab3fa"}, "downloads": -1, "filename": "aiomsg-2019.4.2.tar.gz", "has_sig": false, "md5_digest": "c5b157fb63d7cfda2e4816cccf888888", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18861, "upload_time": "2019-04-27T00:21:56", "upload_time_iso_8601": "2019-04-27T00:21:56.962776Z", "url": "https://files.pythonhosted.org/packages/37/07/471a75239e0b70ed7bde2f5b3046e989f0fae8844b1c650cebca9220421e/aiomsg-2019.4.2.tar.gz", "yanked": false}], "2019.4.3": [{"comment_text": "", "digests": {"md5": "e23db30da55c708a3828c5a9109f2f80", "sha256": "54e736b8112acc750fece4653b59f5e982eb5ed93f95071624033bac3dc59838"}, "downloads": -1, "filename": "aiomsg-2019.4.3-py3-none-any.whl", "has_sig": false, "md5_digest": "e23db30da55c708a3828c5a9109f2f80", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 17968, "upload_time": "2019-04-27T00:26:46", "upload_time_iso_8601": "2019-04-27T00:26:46.107153Z", "url": "https://files.pythonhosted.org/packages/e0/99/5a18baeb8362256a405029b0f26c9f1378e170d455d1ed97e168de80db80/aiomsg-2019.4.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "64e2fb1a10b9c136e331573e7297afc3", "sha256": "47f6db38bf78ea46ee2fad3a5f7ff2e040750b3018862ddc571c7d2388ac6e09"}, "downloads": -1, "filename": "aiomsg-2019.4.3.tar.gz", "has_sig": false, "md5_digest": "64e2fb1a10b9c136e331573e7297afc3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18858, "upload_time": "2019-04-27T00:26:48", "upload_time_iso_8601": "2019-04-27T00:26:48.278779Z", "url": "https://files.pythonhosted.org/packages/fb/c2/907ff68dad09b417af6e131d372beaea8bbb5d0145f7f98268cadb09747f/aiomsg-2019.4.3.tar.gz", "yanked": false}], "2019.4.4": [{"comment_text": "", "digests": {"md5": "f154130df9f1ff49032dc47f354e8121", "sha256": "013236c34ea7ed72f057db00a288d57aba44fc3275f6bf9a115380a74d8c01ff"}, "downloads": -1, "filename": "aiomsg-2019.4.4-py3-none-any.whl", "has_sig": false, "md5_digest": "f154130df9f1ff49032dc47f354e8121", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 18348, "upload_time": "2019-04-28T04:11:19", "upload_time_iso_8601": "2019-04-28T04:11:19.687031Z", "url": "https://files.pythonhosted.org/packages/54/2f/edd99b9371ef1091d2bc1d79f25511204b005f75eb602b7e11c84df307c1/aiomsg-2019.4.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "64dc79a20fd0fcb438c6642ed6a2920d", "sha256": "0df8e7d7d1f0d62e5488500de1b11a6a3d89e9a5f39a52e57a0dc856074812a8"}, "downloads": -1, "filename": "aiomsg-2019.4.4.tar.gz", "has_sig": false, "md5_digest": "64dc79a20fd0fcb438c6642ed6a2920d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19530, "upload_time": "2019-04-28T04:11:22", "upload_time_iso_8601": "2019-04-28T04:11:22.170781Z", "url": "https://files.pythonhosted.org/packages/43/a6/13c1f630f2f2642cc2a22d9bb3dc17eef3e0d91f16e05f27114a8dbaa7a2/aiomsg-2019.4.4.tar.gz", "yanked": false}], "2019.4.5": [{"comment_text": "", "digests": {"md5": "f62f191bad4e4d20bd42a1cc07272eac", "sha256": "850ce8d07e8b9795d779ba949039aa568bd9d8b9555e1521a8999fe11f29d97f"}, "downloads": -1, "filename": "aiomsg-2019.4.5-py3-none-any.whl", "has_sig": false, "md5_digest": "f62f191bad4e4d20bd42a1cc07272eac", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 23310, "upload_time": "2019-04-28T13:01:38", "upload_time_iso_8601": "2019-04-28T13:01:38.487164Z", "url": "https://files.pythonhosted.org/packages/97/56/8921a8a6cafee5a89db4d661fa17414323508b281d972533685e9df6538d/aiomsg-2019.4.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8bdcccb4ab15bbb59e26f0c292cdfed7", "sha256": "ac332e9fe1400a2a311caf891fe29aa361ab3fbb06ffd1343eb7c1eb25238156"}, "downloads": -1, "filename": "aiomsg-2019.4.5.tar.gz", "has_sig": false, "md5_digest": "8bdcccb4ab15bbb59e26f0c292cdfed7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35628, "upload_time": "2019-04-28T13:01:41", "upload_time_iso_8601": "2019-04-28T13:01:41.438876Z", "url": "https://files.pythonhosted.org/packages/b2/6c/9bc9639cd2e786cfe36e20738ff2540ea46623210f3ffc52c1f089b82381/aiomsg-2019.4.5.tar.gz", "yanked": false}], "2019.5.0": [{"comment_text": "", "digests": {"md5": "ca88b5d87559b39e85b1cbe26d8c715f", "sha256": "41923dccf865787fc718c14788da6a90da09f51d7abeace1c7a1a03e71e9fa6e"}, "downloads": -1, "filename": "aiomsg-2019.5.0-py3-none-any.whl", "has_sig": false, "md5_digest": "ca88b5d87559b39e85b1cbe26d8c715f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 24145, "upload_time": "2019-05-27T12:11:43", "upload_time_iso_8601": "2019-05-27T12:11:43.235043Z", "url": "https://files.pythonhosted.org/packages/52/61/888d7b3b2c36de887432a5bd203a69be07ed848997d6ef9e8159a1d21771/aiomsg-2019.5.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1420df2fe92cef9d843f82e3d10cf940", "sha256": "2678eb3f04aaae3c42a8a374452119acac0ffdcbb9d6bc4309692911e607135d"}, "downloads": -1, "filename": "aiomsg-2019.5.0.tar.gz", "has_sig": false, "md5_digest": "1420df2fe92cef9d843f82e3d10cf940", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38440, "upload_time": "2019-05-27T12:11:45", "upload_time_iso_8601": "2019-05-27T12:11:45.635966Z", "url": "https://files.pythonhosted.org/packages/1b/3e/0394c08803595f1e6c6d9a27cacb28c101bdd0044bcef182f3e58678b0ff/aiomsg-2019.5.0.tar.gz", "yanked": false}], "2019.5.2": [{"comment_text": "", "digests": {"md5": "8993da8eb2be31e6e14e7cdff4f1d234", "sha256": "c3decc34cee14b34c713d8e015095adb407da71736eca7c540c67d6df287bec8"}, "downloads": -1, "filename": "aiomsg-2019.5.2-py3-none-any.whl", "has_sig": false, "md5_digest": "8993da8eb2be31e6e14e7cdff4f1d234", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 24258, "upload_time": "2019-06-05T23:58:57", "upload_time_iso_8601": "2019-06-05T23:58:57.011579Z", "url": "https://files.pythonhosted.org/packages/7f/d5/f289d949e022db0926ab4bfae8e2251ff741d26308baa8e80fef0dba699f/aiomsg-2019.5.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9642e73e2d78dbdf8d182949a76c165a", "sha256": "f9d84076e86921062bf7fe8a1e90e04fdb3acae6d365cc9107baec99354f6890"}, "downloads": -1, "filename": "aiomsg-2019.5.2.tar.gz", "has_sig": false, "md5_digest": "9642e73e2d78dbdf8d182949a76c165a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 38943, "upload_time": "2019-06-05T23:58:59", "upload_time_iso_8601": "2019-06-05T23:58:59.278783Z", "url": "https://files.pythonhosted.org/packages/7c/2d/5286b5844d5ec491bb04e3ed533664ec4a561906ed067cdf6c4adb794859/aiomsg-2019.5.2.tar.gz", "yanked": false}], "2019.5.3": [{"comment_text": "", "digests": {"md5": "b23fad69a8b2198d81cc8d1294acc565", "sha256": "099c8cde3c605ce764b135f0999ce8c5bf4eb1eed238ce9154a9e75ad878b694"}, "downloads": -1, "filename": "aiomsg-2019.5.3-py3-none-any.whl", "has_sig": false, "md5_digest": "b23fad69a8b2198d81cc8d1294acc565", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 26989, "upload_time": "2019-06-06T14:08:31", "upload_time_iso_8601": "2019-06-06T14:08:31.695970Z", "url": "https://files.pythonhosted.org/packages/28/9b/92836b57835adc09650fcfb8812acaed036db6bd16ce21db5e6a082c6b12/aiomsg-2019.5.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f315cd293b3838fca8bdae2393b6ec01", "sha256": "809731c911a397b2c89b1033812de40b5cfa35314703ed2bee7551d6ffdd07f7"}, "downloads": -1, "filename": "aiomsg-2019.5.3.tar.gz", "has_sig": false, "md5_digest": "f315cd293b3838fca8bdae2393b6ec01", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47556, "upload_time": "2019-06-06T14:08:34", "upload_time_iso_8601": "2019-06-06T14:08:34.237899Z", "url": "https://files.pythonhosted.org/packages/a1/7b/7319bb8ee4dbedb03980e49802428cdf297375457eb0a3e4a6b9b3b710d9/aiomsg-2019.5.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "22c070d8845db96e9c86fcce4856fdc9", "sha256": "aa531c1bc267908242dd7c6896c784ff542712255e18c0d5048c273b45418d85"}, "downloads": -1, "filename": "aiomsg-2019.12.3-py3-none-any.whl", "has_sig": false, "md5_digest": "22c070d8845db96e9c86fcce4856fdc9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 28122, "upload_time": "2019-12-08T05:34:46", "upload_time_iso_8601": "2019-12-08T05:34:46.516994Z", "url": "https://files.pythonhosted.org/packages/a2/10/557fc090c3c5fbe7fab20c9e7719bfd992b69451f85cda65cf6b0977e428/aiomsg-2019.12.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8c9c31bea97bdb555cc65aca2f226e74", "sha256": "87af01daffa77f4461a9a88cf0df7047eb82e6a3edc2a0033c335a17903f8ce4"}, "downloads": -1, "filename": "aiomsg-2019.12.3.tar.gz", "has_sig": false, "md5_digest": "8c9c31bea97bdb555cc65aca2f226e74", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 48243, "upload_time": "2019-12-08T05:34:49", "upload_time_iso_8601": "2019-12-08T05:34:49.604355Z", "url": "https://files.pythonhosted.org/packages/09/e1/674c7e0f4715ca6ea87ca8fa46e59a328dd41dd120b68ee411531221f945/aiomsg-2019.12.3.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:21:02 2020"}