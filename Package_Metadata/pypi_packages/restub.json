{"info": {"author": "Igor Tolkachnikov", "author_email": "i.tolkachnikov@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6"], "description": "RESTUB is a library for creating HTTP stubs\n\n\nPreamble\n\nOften while developing there is a need to create some HTTP stub. Frequent solutions of this problem among developers are:\n- Using shareware and non-free software, like SoapUI\n- Creating service from scratch, for example, using a Flask\n- For unit-tests, using such packages as requests-mock\n\nEach of these solutions has the right for life. I needed free, completely transparent and simple package creating a really existing server in system. A server that could be invoked both from code and applications, like browser or curl. I found a lot of similar libraries, but for various reasons they did not fit me. So the restub appeared.\n\nMain functionality:\n- Automatic addition of necessary headers  according to a contents type\n- Tracing of an output of requests and responses\n- Support of regular expressions in URL\n- Emulation of a slow connection\n- Support of HTTPS\n\n\nRoutes and routing\n\nA route represents the ordered sequence of values (method, path, data, headers, status) describing data which we can receive at the specified address and a method of access. Therefore the method of access and the address is a required and other values can be omitted.\n\nmethod \u2014 an access method, can be \"GET\", \"POST\", \"PUT\" or \"DELETE\"\npath \u2014 describing the response address, can be regex\n*data \u2014 response data, can be str or dict\n*headers \u2014 HTTP response headers\n*status \u2014 code of the response status\n\nWhen data passed the headers Content-type and Content-length will be automatically added in response. Of course, you can always override these headers. Having sent the dict as data the header 'Content-type' with the value 'application/json' will be added. When str passed, the following scenarios are possible:\n- If the str is a path to the file existing in system, contents of this file will be load in a body of response. At the same time, if the extension of the file has a matching with one of  CTYPES values (the dictionary containing often used formats of data, such as \u201ccss\u201d, \u201cjs\u201d, \u201cttf\u201d, etc), the Content-type will be taken there\n- If the str represents json, xml or html document, then the Content-type will have the corresponding values: 'application/json', 'application/xml' or 'text/html'\n- In all other cases, data will be transferred as 'text/plain'\n\n\nRunning\n\nThe stub can be run as a context manager, a decorator of function or as a class instance. Before the run of a stub at least one route has to be defined. The address where the stub is started can be received through the property - host. By default the stub is available at the address http://localhost:8081 or https://localhost:8081 if the secure mode was enabled. \n\nRun as the a context manager with a change of port:\n```\nfrom restub import Service\n\nwith Service(routes=['GET', r'/$'], port=7777) as srv:\n    # your requests here\n```\n\nRun as the decorator of function:\n```\nfrom restub import Service\n\n@Service(routes=['GET', r'/$'])\ndef stubbed_func():\n    # your requests here\n```\n\nRun as the class instance:\n```\nfrom restub import Service\n\nsrv = Service(routes=['GET', r'/$'])\nsrv.start()\n# your requests here\nsrv.stop()\n```\n\nRun as the class instance and definition of routes through the functions of the same name:\n```\nfrom restub import Service\n\nsrv = Service()\nsrv.get(r'/$') # post(..), put(..), delete(..)\nsrv.start()\n# your requests here\nsrv.stop()\n```\n\nFor work with HTTPS it is necessary to set **secure** flag in True and pass absolute paths to a private key and a certificate:\n```\nfrom restub import Service\n\nwith Service(routes=['GET', r'/$'], secure=True, crt='<abs path to key>', key='<abs path to cert>'):\n    # your secured requests here\n```\n\nThe private key and the certificate in linux can be generated by the command:\n```\nopenssl req -new -x509 -days 365 -nodes -out restub.crt -keyout restub.key\n```\n\nThe slow connection can be emulated through delay property. It specifies the delay per response in seconds:\n```\nfrom restub import Service\n\nwith Service(routes=['GET', r'/$'], delay=0.5) as srv:\n    # your delayed requests here\n```\n\nTracing of an output of requests and responses turns on by the setting of trace flag in True:\n```\nfrom restub import Service\n\nwith Service(routes=['GET', r'/$'], trace=True) as srv:\n    # your requests with trace here\n```", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/everhide/restub", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "restub", "package_url": "https://pypi.org/project/restub/", "platform": "", "project_url": "https://pypi.org/project/restub/", "project_urls": {"Homepage": "https://github.com/everhide/restub"}, "release_url": "https://pypi.org/project/restub/1.12/", "requires_dist": null, "requires_python": "", "summary": "RESTub - REST Service Mocking", "version": "1.12", "yanked": false, "html_description": "<div class=\"project-description\">\n            RESTUB is a library for creating HTTP stubs<br><br><br>Preamble<br><br>Often while developing there is a need to create some HTTP stub. Frequent solutions of this problem among developers are:<br>- Using shareware and non-free software, like SoapUI<br>- Creating service from scratch, for example, using a Flask<br>- For unit-tests, using such packages as requests-mock<br><br>Each of these solutions has the right for life. I needed free, completely transparent and simple package creating a really existing server in system. A server that could be invoked both from code and applications, like browser or curl. I found a lot of similar libraries, but for various reasons they did not fit me. So the restub appeared.<br><br>Main functionality:<br>- Automatic addition of necessary headers  according to a contents type<br>- Tracing of an output of requests and responses<br>- Support of regular expressions in URL<br>- Emulation of a slow connection<br>- Support of HTTPS<br><br><br>Routes and routing<br><br>A route represents the ordered sequence of values (method, path, data, headers, status) describing data which we can receive at the specified address and a method of access. Therefore the method of access and the address is a required and other values can be omitted.<br><br>method \u2014 an access method, can be \"GET\", \"POST\", \"PUT\" or \"DELETE\"<br>path \u2014 describing the response address, can be regex<br>*data \u2014 response data, can be str or dict<br>*headers \u2014 HTTP response headers<br>*status \u2014 code of the response status<br><br>When data passed the headers Content-type and Content-length will be automatically added in response. Of course, you can always override these headers. Having sent the dict as data the header 'Content-type' with the value 'application/json' will be added. When str passed, the following scenarios are possible:<br>- If the str is a path to the file existing in system, contents of this file will be load in a body of response. At the same time, if the extension of the file has a matching with one of  CTYPES values (the dictionary containing often used formats of data, such as \u201ccss\u201d, \u201cjs\u201d, \u201cttf\u201d, etc), the Content-type will be taken there<br>- If the str represents json, xml or html document, then the Content-type will have the corresponding values: 'application/json', 'application/xml' or 'text/html'<br>- In all other cases, data will be transferred as 'text/plain'<br><br><br>Running<br><br>The stub can be run as a context manager, a decorator of function or as a class instance. Before the run of a stub at least one route has to be defined. The address where the stub is started can be received through the property - host. By default the stub is available at the address http://localhost:8081 or https://localhost:8081 if the secure mode was enabled. <br><br>Run as the a context manager with a change of port:<br>```<br>from restub import Service<br><br>with Service(routes=['GET', r'/$'], port=7777) as srv:<br>    # your requests here<br>```<br><br>Run as the decorator of function:<br>```<br>from restub import Service<br><br>@Service(routes=['GET', r'/$'])<br>def stubbed_func():<br>    # your requests here<br>```<br><br>Run as the class instance:<br>```<br>from restub import Service<br><br>srv = Service(routes=['GET', r'/$'])<br>srv.start()<br># your requests here<br>srv.stop()<br>```<br><br>Run as the class instance and definition of routes through the functions of the same name:<br>```<br>from restub import Service<br><br>srv = Service()<br>srv.get(r'/$') # post(..), put(..), delete(..)<br>srv.start()<br># your requests here<br>srv.stop()<br>```<br><br>For work with HTTPS it is necessary to set **secure** flag in True and pass absolute paths to a private key and a certificate:<br>```<br>from restub import Service<br><br>with Service(routes=['GET', r'/$'], secure=True, crt='&lt;abs path to key&gt;', key='&lt;abs path to cert&gt;'):<br>    # your secured requests here<br>```<br><br>The private key and the certificate in linux can be generated by the command:<br>```<br>openssl req -new -x509 -days 365 -nodes -out restub.crt -keyout restub.key<br>```<br><br>The slow connection can be emulated through delay property. It specifies the delay per response in seconds:<br>```<br>from restub import Service<br><br>with Service(routes=['GET', r'/$'], delay=0.5) as srv:<br>    # your delayed requests here<br>```<br><br>Tracing of an output of requests and responses turns on by the setting of trace flag in True:<br>```<br>from restub import Service<br><br>with Service(routes=['GET', r'/$'], trace=True) as srv:<br>    # your requests with trace here<br>```\n          </div>"}, "last_serial": 4243157, "releases": {"1.12": [{"comment_text": "", "digests": {"md5": "86be50f4231e8cef20cae958a73af91a", "sha256": "b8be80cf6313bec865fc6dc1b1884667dfe85ce1506f8edac106674a89e3842f"}, "downloads": -1, "filename": "restub-1.12.tar.gz", "has_sig": false, "md5_digest": "86be50f4231e8cef20cae958a73af91a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7854, "upload_time": "2018-09-06T02:46:12", "upload_time_iso_8601": "2018-09-06T02:46:12.031835Z", "url": "https://files.pythonhosted.org/packages/e7/fe/7fb1135632acdc6de8f0c290da27b5a5fd0d722f3ab4a6f43bd5ba7bd502/restub-1.12.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "86be50f4231e8cef20cae958a73af91a", "sha256": "b8be80cf6313bec865fc6dc1b1884667dfe85ce1506f8edac106674a89e3842f"}, "downloads": -1, "filename": "restub-1.12.tar.gz", "has_sig": false, "md5_digest": "86be50f4231e8cef20cae958a73af91a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7854, "upload_time": "2018-09-06T02:46:12", "upload_time_iso_8601": "2018-09-06T02:46:12.031835Z", "url": "https://files.pythonhosted.org/packages/e7/fe/7fb1135632acdc6de8f0c290da27b5a5fd0d722f3ab4a6f43bd5ba7bd502/restub-1.12.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:03:30 2020"}