{"info": {"author": "Dmitry Marakasov", "author_email": "amdmi3@amdmi3.ru", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: C++", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: 3 :: Only"], "description": "# jsonslicer - stream JSON parser\n\n<a href=\"https://repology.org/metapackage/python:jsonslicer/versions\">\n\t<img src=\"https://repology.org/badge/vertical-allrepos/python:jsonslicer.svg\" alt=\"jsonslicer packaging status\" align=\"right\">\n</a>\n\n[![Build Status](https://travis-ci.org/AMDmi3/jsonslicer.svg?branch=master)](https://travis-ci.org/AMDmi3/jsonslicer)\n[![Coverage Status](https://coveralls.io/repos/github/AMDmi3/jsonslicer/badge.svg?branch=master)](https://coveralls.io/github/AMDmi3/jsonslicer?branch=master)\n[![PyPI downloads](https://img.shields.io/pypi/dm/jsonslicer.svg)](https://pypi.org/project/jsonslicer/)\n[![PyPI version](https://img.shields.io/pypi/v/jsonslicer.svg)](https://pypi.org/project/jsonslicer/)\n[![PyPI pythons](https://img.shields.io/pypi/pyversions/jsonslicer.svg)](https://pypi.org/project/jsonslicer/)\n[![Github commits (since latest release)](https://img.shields.io/github/commits-since/AMDmi3/jsonslicer/latest.svg)](https://github.com/AMDmi3/jsonslicer)\n\n## Overview\n\nJsonSlicer performs a **stream** or **iterative**, **pull** JSON\nparsing, which means it **does not load** whole JSON into memory\nand is able to parse **very large** JSON files or streams.  The\nmodule is written in C and uses [YAJL](https://lloyd.github.io/yajl/)\nJSON parsing library, so it's also quite **fast**.\n\nJsonSlicer takes a **path** of JSON map keys or array indexes, and\nprovides **iterator interface** which yields JSON data matching\ngiven path as complete Python objects.\n\n## Example\n\n```json\n{\n    \"friends\": [\n        {\"name\": \"John\", \"age\": 31},\n        {\"name\": \"Ivan\", \"age\": 26}\n    ],\n    \"colleagues\": {\n        \"manager\": {\"name\": \"Jack\", \"age\": 33},\n        \"subordinate\": {\"name\": \"Lucy\", \"age\": 21}\n    }\n}\n```\n\n```python\nfrom jsonslicer import JsonSlicer\n\n# Extract specific elements:\nwith open('people.json') as data:\n    ivans_age = next(JsonSlicer(data, ('friends', 1, 'age')))\n    # 26\n\nwith open('people.json') as data:\n    managers_name = next(JsonSlicer(data, ('colleagues', 'manager', 'name')))\n    # 'Jack'\n\n# Iterate over collection(s) by using wildcards in the path:\nwith open('people.json') as data:\n    for person in JsonSlicer(data, ('friends', None)):\n        print(person)\n        # {'name': 'John', 'age': 31}\n        # {'name': 'Ivan', 'age': 26}\n\n# Iteration over both arrays and dicts is possible, even at the same time\nwith open('people.json') as data:\n    for person in JsonSlicer(data, (None, None)):\n        print(person)\n        # {'name': 'John', 'age': 31}\n        # {'name': 'Ivan', 'age': 26}\n        # {'name': 'Jack', 'age': 33}\n        # {'name': 'Lucy', 'age': 21}\n\n# Map key of returned objects is available on demand...\nwith open('people.json') as data:\n    for position, person in JsonSlicer(data, ('colleagues', None), path_mode='map_keys'):\n        print(position, person)\n        # 'manager' {'name': 'Jack', 'age': 33}\n        # 'subordinate' {'name': 'Lucy', 'age': 21}\n\n# ...as well as complete path information\nwith open('people.json') as data:\n    for *path, person in JsonSlicer(data, (None, None), path_mode='full'):\n        print(path, person)\n        # ('friends', 0) {'name': 'John', 'age': 31})\n        # ('friends', 1) {'name': 'Ivan', 'age': 26})\n        # ('colleagues', 'manager') {'name': 'Jack', 'age': 33})\n        # ('colleagues', 'subordinate') {'name': 'Lucy', 'age': 21})\n\n# Extract all instances of deep nested field\nwith open('people.json') as data:\n    age_sum = sum(JsonSlicer(data, (None, None, 'age')))\n    # 111\n```\n\n## API\n\n```\njsonslicer.JsonSlicer(\n    file,\n    path_prefix,\n    read_size=1024,\n    path_mode=None,\n    yajl_allow_comments=False,\n    yajl_dont_validate_strings=False,\n    yajl_allow_trailing_garbage=False,\n    yajl_allow_multiple_values=False,\n    yajl_allow_partial_values=False,\n    encoding=None,\n    errors=None,\n    binary=False,\n)\n```\n\nConstructs iterative JSON parser. which reads JSON data from _file_ (a `.read()`-supporting [file-like object](https://docs.python.org/3/glossary.html#term-file-like-object) containing a JSON document).\n\n_file_ is a `.read()`-supporting [file-like\nobject](https://docs.python.org/3/glossary.html#term-file-like-object)\ncontaining a JSON document. Both binary and text files are supported,\nbut binary ones are preferred, because the parser has to operate on\nbinary data internally anyway, and using text input would require an\nunnecessary encoding/decoding which yields ~3% performance overhead.\nNote that JsonSlicer supports both unicode and binary output regardless\nof input format.\n\n_path_prefix_ is an iterable (usually a list or a tuple) specifying\na path or a path pattern of objects which the parser should extract\nfrom JSON.\n\nFor instance, in the example above a path `('friends', 0, 'name')`\nwill yield string `'John'`, by descending from the root element\ninto the dictionary element by key `'friends'`, then into the array\nelement by index `0`, then into the dictionary element by key\n`'name'`. Note that integers only match array indexes and strings\nonly match dictionary keys.\n\nThe path can be turned into a pattern by specifying `None` as a\nplaceholder in some path positions. For instance,  `(None, None,\n'name')` will yield all four names from the example above, because\nit matches an item under 'name' key on the second nesting level of\nany arrays or map structure.\n\nBoth strings and byte objects are allowed in path, regardless of\ninput and output encodings.  are automatically converted\nto the format used internally.\n\n_read_size_ is a size of block read by the parser at a time.\n\n_path_mode_ is a string which specifies how a parser should\nreturn path information along with objects. The following modes are\nsupported:\n\n* _'ignore'_ (the default) - do not output any path information, just\nobjects as is (`'friends'`).\n\n  ```python\n  {'name': 'John', 'age': 31}\n  {'name': 'Ivan', 'age': 26}\n  {'name': 'Jack', 'age': 33}\n  {'name': 'Lucy', 'age': 21}\n  ```\n\n  Common usage pattern for this mode is\n\n  ```python\n  for object in JsonSlicer(...)\n  ```\n\n* _'map_keys'_ - output objects as is when traversing arrays and tuples\nconsisting of map key and object when traversing maps.\n\n  ```python\n  {'name': 'John', 'age': 31}\n  {'name': 'Ivan', 'age': 26}\n  ('manager', {'name': 'Jack', 'age': 33})\n  ('subordinate', {'name': 'Lucy', 'age': 21})\n  ```\n\n  This format may seem inconsistent (and therefore it's not the default),\n  however in practice only collection of a single type is iterated at\n  a time and this type is known, so this format is likely the most useful\n  as in most cases you do need dictionary keys.\n\n  Common usage pattern for this mode is\n\n  ```python\n  for object in JsonSlicer(...)  # when iterating arrays\n  for key object in JsonSlicer(...)  # when iterating maps\n  ```\n\n* _'full_paths'_ - output tuples consisting of all path components\n(both map keys and array indexes) and an object as the last element.\n\n  ```python\n  ('friends', 0, {'name': 'John', 'age': 31})\n  ('friends', 1, {'name': 'Ivan', 'age': 26})\n  ('colleagues', 'manager', {'name': 'Jack', 'age': 33})\n  ('colleagues', 'subordinate', {'name': 'Lucy', 'age': 21})\n  ```\n\n  Common usage pattern for this mode is\n\n  ```python\n  for *path, object in JsonSlicer(...)\n  ```\n\n_yajl_allow_comments_ enables corresponding YAJL flag, which is\ndocumented as follows:\n\n> Ignore javascript style comments present in JSON input.  Non-standard,\n> but rather fun\n\n_yajl_dont_validate_strings_ enables corresponding YAJL flag, which\nis documented as follows:\n\n> When set the parser will verify that all strings in JSON input\n> are valid UTF8 and will emit a parse error if this is not so.  When\n> set, this option makes parsing slightly more expensive (~7% depending\n> on processor and compiler in use)\n\n_yajl_allow_trailing_garbage_ enables corresponding YAJL flag, which\nis documented as follows:\n\n> By default, yajl will ensure the entire input text was consumed\n> and will raise an error otherwise.  Enabling this flag will cause\n> yajl to disable this check.  This can be useful when parsing json\n> out of a that contains more than a single JSON document.\n\n_yajl_allow_multiple_values_ enables corresponding YAJL flag, which\nis documented as follows:\n\n> Allow multiple values to be parsed by a single handle.  The entire\n> text must be valid JSON, and values can be seperated by any kind\n> of whitespace.  This flag will change the behavior of the parser,\n> and cause it continue parsing after a value is parsed, rather than\n> transitioning into a complete state.  This option can be useful\n> when parsing multiple values from an input stream.\n\n_yajl_allow_partial_values_ enables corresponding YAJL flag, which\nis documented as follows:\n\n> When yajl_complete_parse() is called the parser will check that the\n> top level value was completely consumed.  I.E., if called whilst\n> in the middle of parsing a value yajl will enter an error state\n> (premature EOF).  Setting this flag suppresses that check and the\n> corresponding error.\n\n_encoding_ may be used to override output encoding, which is derived\nfrom the input file handle if possible, or otherwise set to the\ndefault one as Python builtin `open()` would use (usually `'UTF-8'`).\n\n_errors_ is an optional string that specifies how encoding and\ndecoding errors are to be handled. Defaults to `'strict'`\n\n_binary_ forces the output to be in form of `bytes` objects instead\nof `str` unicode strings.\n\nThe constructed object is as iterator. You may call `next()` to extract\nsingle element from it, iterate it via `for` loop, or use it in generator\ncomprehensions or in any place where iterator is accepted.\n\n## Performance/competitors\n\nThe closest competitor is [ijson](https://github.com/isagalaev/ijson),\nand JsonSlicer was written to be better. Namely,\n\n* It's about 15x faster, similar in performance to Python's native `json` module\n* It allows iterating over dictionaries and allows more flexibility when\n  specifying paths/patterns of objects to iterate over\n\nThe results of bundled benchmark on Python 3.7.2 / clang 6.0.1 / `-O2 -DNDEBUG` / FreeBSD 12.0 amd64 / Core i7-6600U CPU @ 2.60GHz.\n\n|                                                 Facility |   Type |   Objects/sec |\n|:---------------------------------------------------------|:------:|--------------:|\n|                                             json.loads() |    str |       1155.9K |\n|                                    json.load(StringIO()) |    str |       1104.1K |\n|   **JsonSlicer (no paths, binary input, binary output)** |  bytes |       1149.5K |\n|  **JsonSlicer (no paths, unicode input, binary output)** |  bytes |       1121.3K |\n|  **JsonSlicer (no paths, binary input, unicode output)** |    str |       1033.3K |\n| **JsonSlicer (no paths, unicode input, unicode output)** |    str |       1006.2K |\n|               **JsonSlicer (full paths, binary output)** |  bytes |        787.6K |\n|              **JsonSlicer (full paths, unicode output)** |    str |        586.5K |\n|                                         ijson.yajl2_cffi |  bytes |         75.7K |\n|                                              ijson.yajl2 |  bytes |         52.0K |\n|                                             ijson.python |    str |         32.2K |\n\n## Status/TODO\n\nJsonSlicer is currently in beta stage, used in production in\n[Repology](https://repology.org) project. Testing foci are:\n\n- Edge cases with uncommon encoding (input/output) configurations\n- Absence of memory leaks\n\n## Requirements\n\n- Python 3.4+ (Python 2 not supported)\n- pkg-config\n- [yajl](https://lloyd.github.io/yajl/) 2.0.3+ (older versions lack pkgconfig file)\n\n## License\n\nMIT license, copyright (c) 2019 Dmitry Marakasov amdmi3@amdmi3.ru.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/AMDmi3/jsonslicer", "keywords": "json,parser,pull,stream", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "jsonslicer", "package_url": "https://pypi.org/project/jsonslicer/", "platform": "", "project_url": "https://pypi.org/project/jsonslicer/", "project_urls": {"Homepage": "https://github.com/AMDmi3/jsonslicer"}, "release_url": "https://pypi.org/project/jsonslicer/0.1.5/", "requires_dist": null, "requires_python": "", "summary": "Stream JSON parser with iterator interface", "version": "0.1.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>jsonslicer - stream JSON parser</h1>\n<a href=\"https://repology.org/metapackage/python:jsonslicer/versions\" rel=\"nofollow\">\n\t<img align=\"right\" alt=\"jsonslicer packaging status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a9cf4e9a6b53c9174fae26900cd66a825c1540e3/68747470733a2f2f7265706f6c6f67792e6f72672f62616467652f766572746963616c2d616c6c7265706f732f707974686f6e3a6a736f6e736c696365722e737667\">\n</a>\n<p><a href=\"https://travis-ci.org/AMDmi3/jsonslicer\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1e1020fd71367b12d41614265b124bb776311195/68747470733a2f2f7472617669732d63692e6f72672f414d446d69332f6a736f6e736c696365722e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/AMDmi3/jsonslicer?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/56096b2f9919763686f07fe14e0c746d1d081826/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f414d446d69332f6a736f6e736c696365722f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://pypi.org/project/jsonslicer/\" rel=\"nofollow\"><img alt=\"PyPI downloads\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a79a6bb527600f5443a4d8fc1d59c8234f429cf8/68747470733a2f2f696d672e736869656c64732e696f2f707970692f646d2f6a736f6e736c696365722e737667\"></a>\n<a href=\"https://pypi.org/project/jsonslicer/\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bbb8f0d86c67991bf2891bf24c06974a587f51c3/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6a736f6e736c696365722e737667\"></a>\n<a href=\"https://pypi.org/project/jsonslicer/\" rel=\"nofollow\"><img alt=\"PyPI pythons\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d9a8024e1415a3f235fd1fadef51145688bb5f8f/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f6a736f6e736c696365722e737667\"></a>\n<a href=\"https://github.com/AMDmi3/jsonslicer\" rel=\"nofollow\"><img alt=\"Github commits (since latest release)\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/81850fad84ba693511abf9d17e3e63b007ec8ff3/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f636f6d6d6974732d73696e63652f414d446d69332f6a736f6e736c696365722f6c61746573742e737667\"></a></p>\n<h2>Overview</h2>\n<p>JsonSlicer performs a <strong>stream</strong> or <strong>iterative</strong>, <strong>pull</strong> JSON\nparsing, which means it <strong>does not load</strong> whole JSON into memory\nand is able to parse <strong>very large</strong> JSON files or streams.  The\nmodule is written in C and uses <a href=\"https://lloyd.github.io/yajl/\" rel=\"nofollow\">YAJL</a>\nJSON parsing library, so it's also quite <strong>fast</strong>.</p>\n<p>JsonSlicer takes a <strong>path</strong> of JSON map keys or array indexes, and\nprovides <strong>iterator interface</strong> which yields JSON data matching\ngiven path as complete Python objects.</p>\n<h2>Example</h2>\n<pre><span class=\"p\">{</span>\n    <span class=\"nt\">\"friends\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n        <span class=\"p\">{</span><span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"John\"</span><span class=\"p\">,</span> <span class=\"nt\">\"age\"</span><span class=\"p\">:</span> <span class=\"mi\">31</span><span class=\"p\">},</span>\n        <span class=\"p\">{</span><span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Ivan\"</span><span class=\"p\">,</span> <span class=\"nt\">\"age\"</span><span class=\"p\">:</span> <span class=\"mi\">26</span><span class=\"p\">}</span>\n    <span class=\"p\">],</span>\n    <span class=\"nt\">\"colleagues\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"nt\">\"manager\"</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Jack\"</span><span class=\"p\">,</span> <span class=\"nt\">\"age\"</span><span class=\"p\">:</span> <span class=\"mi\">33</span><span class=\"p\">},</span>\n        <span class=\"nt\">\"subordinate\"</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Lucy\"</span><span class=\"p\">,</span> <span class=\"nt\">\"age\"</span><span class=\"p\">:</span> <span class=\"mi\">21</span><span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">jsonslicer</span> <span class=\"kn\">import</span> <span class=\"n\">JsonSlicer</span>\n\n<span class=\"c1\"># Extract specific elements:</span>\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'people.json'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">data</span><span class=\"p\">:</span>\n    <span class=\"n\">ivans_age</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">JsonSlicer</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'friends'</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">)))</span>\n    <span class=\"c1\"># 26</span>\n\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'people.json'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">data</span><span class=\"p\">:</span>\n    <span class=\"n\">managers_name</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">JsonSlicer</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'colleagues'</span><span class=\"p\">,</span> <span class=\"s1\">'manager'</span><span class=\"p\">,</span> <span class=\"s1\">'name'</span><span class=\"p\">)))</span>\n    <span class=\"c1\"># 'Jack'</span>\n\n<span class=\"c1\"># Iterate over collection(s) by using wildcards in the path:</span>\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'people.json'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">data</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">person</span> <span class=\"ow\">in</span> <span class=\"n\">JsonSlicer</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'friends'</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">person</span><span class=\"p\">)</span>\n        <span class=\"c1\"># {'name': 'John', 'age': 31}</span>\n        <span class=\"c1\"># {'name': 'Ivan', 'age': 26}</span>\n\n<span class=\"c1\"># Iteration over both arrays and dicts is possible, even at the same time</span>\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'people.json'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">data</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">person</span> <span class=\"ow\">in</span> <span class=\"n\">JsonSlicer</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">)):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">person</span><span class=\"p\">)</span>\n        <span class=\"c1\"># {'name': 'John', 'age': 31}</span>\n        <span class=\"c1\"># {'name': 'Ivan', 'age': 26}</span>\n        <span class=\"c1\"># {'name': 'Jack', 'age': 33}</span>\n        <span class=\"c1\"># {'name': 'Lucy', 'age': 21}</span>\n\n<span class=\"c1\"># Map key of returned objects is available on demand...</span>\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'people.json'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">data</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">position</span><span class=\"p\">,</span> <span class=\"n\">person</span> <span class=\"ow\">in</span> <span class=\"n\">JsonSlicer</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"s1\">'colleagues'</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">),</span> <span class=\"n\">path_mode</span><span class=\"o\">=</span><span class=\"s1\">'map_keys'</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">position</span><span class=\"p\">,</span> <span class=\"n\">person</span><span class=\"p\">)</span>\n        <span class=\"c1\"># 'manager' {'name': 'Jack', 'age': 33}</span>\n        <span class=\"c1\"># 'subordinate' {'name': 'Lucy', 'age': 21}</span>\n\n<span class=\"c1\"># ...as well as complete path information</span>\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'people.json'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">data</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"o\">*</span><span class=\"n\">path</span><span class=\"p\">,</span> <span class=\"n\">person</span> <span class=\"ow\">in</span> <span class=\"n\">JsonSlicer</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">),</span> <span class=\"n\">path_mode</span><span class=\"o\">=</span><span class=\"s1\">'full'</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">,</span> <span class=\"n\">person</span><span class=\"p\">)</span>\n        <span class=\"c1\"># ('friends', 0) {'name': 'John', 'age': 31})</span>\n        <span class=\"c1\"># ('friends', 1) {'name': 'Ivan', 'age': 26})</span>\n        <span class=\"c1\"># ('colleagues', 'manager') {'name': 'Jack', 'age': 33})</span>\n        <span class=\"c1\"># ('colleagues', 'subordinate') {'name': 'Lucy', 'age': 21})</span>\n\n<span class=\"c1\"># Extract all instances of deep nested field</span>\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'people.json'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">data</span><span class=\"p\">:</span>\n    <span class=\"n\">age_sum</span> <span class=\"o\">=</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">JsonSlicer</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">)))</span>\n    <span class=\"c1\"># 111</span>\n</pre>\n<h2>API</h2>\n<pre><code>jsonslicer.JsonSlicer(\n    file,\n    path_prefix,\n    read_size=1024,\n    path_mode=None,\n    yajl_allow_comments=False,\n    yajl_dont_validate_strings=False,\n    yajl_allow_trailing_garbage=False,\n    yajl_allow_multiple_values=False,\n    yajl_allow_partial_values=False,\n    encoding=None,\n    errors=None,\n    binary=False,\n)\n</code></pre>\n<p>Constructs iterative JSON parser. which reads JSON data from <em>file</em> (a <code>.read()</code>-supporting <a href=\"https://docs.python.org/3/glossary.html#term-file-like-object\" rel=\"nofollow\">file-like object</a> containing a JSON document).</p>\n<p><em>file</em> is a <code>.read()</code>-supporting <a href=\"https://docs.python.org/3/glossary.html#term-file-like-object\" rel=\"nofollow\">file-like\nobject</a>\ncontaining a JSON document. Both binary and text files are supported,\nbut binary ones are preferred, because the parser has to operate on\nbinary data internally anyway, and using text input would require an\nunnecessary encoding/decoding which yields ~3% performance overhead.\nNote that JsonSlicer supports both unicode and binary output regardless\nof input format.</p>\n<p><em>path_prefix</em> is an iterable (usually a list or a tuple) specifying\na path or a path pattern of objects which the parser should extract\nfrom JSON.</p>\n<p>For instance, in the example above a path <code>('friends', 0, 'name')</code>\nwill yield string <code>'John'</code>, by descending from the root element\ninto the dictionary element by key <code>'friends'</code>, then into the array\nelement by index <code>0</code>, then into the dictionary element by key\n<code>'name'</code>. Note that integers only match array indexes and strings\nonly match dictionary keys.</p>\n<p>The path can be turned into a pattern by specifying <code>None</code> as a\nplaceholder in some path positions. For instance,  <code>(None, None, 'name')</code> will yield all four names from the example above, because\nit matches an item under 'name' key on the second nesting level of\nany arrays or map structure.</p>\n<p>Both strings and byte objects are allowed in path, regardless of\ninput and output encodings.  are automatically converted\nto the format used internally.</p>\n<p><em>read_size</em> is a size of block read by the parser at a time.</p>\n<p><em>path_mode</em> is a string which specifies how a parser should\nreturn path information along with objects. The following modes are\nsupported:</p>\n<ul>\n<li>\n<p><em>'ignore'</em> (the default) - do not output any path information, just\nobjects as is (<code>'friends'</code>).</p>\n<pre><span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'John'</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">31</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'Ivan'</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">26</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'Jack'</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">33</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'Lucy'</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">21</span><span class=\"p\">}</span>\n</pre>\n<p>Common usage pattern for this mode is</p>\n<pre><span class=\"k\">for</span> <span class=\"nb\">object</span> <span class=\"ow\">in</span> <span class=\"n\">JsonSlicer</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n</li>\n<li>\n<p><em>'map_keys'</em> - output objects as is when traversing arrays and tuples\nconsisting of map key and object when traversing maps.</p>\n<pre><span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'John'</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">31</span><span class=\"p\">}</span>\n<span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'Ivan'</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">26</span><span class=\"p\">}</span>\n<span class=\"p\">(</span><span class=\"s1\">'manager'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'Jack'</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">33</span><span class=\"p\">})</span>\n<span class=\"p\">(</span><span class=\"s1\">'subordinate'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'Lucy'</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">21</span><span class=\"p\">})</span>\n</pre>\n<p>This format may seem inconsistent (and therefore it's not the default),\nhowever in practice only collection of a single type is iterated at\na time and this type is known, so this format is likely the most useful\nas in most cases you do need dictionary keys.</p>\n<p>Common usage pattern for this mode is</p>\n<pre><span class=\"k\">for</span> <span class=\"nb\">object</span> <span class=\"ow\">in</span> <span class=\"n\">JsonSlicer</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>  <span class=\"c1\"># when iterating arrays</span>\n<span class=\"k\">for</span> <span class=\"n\">key</span> <span class=\"nb\">object</span> <span class=\"ow\">in</span> <span class=\"n\">JsonSlicer</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>  <span class=\"c1\"># when iterating maps</span>\n</pre>\n</li>\n<li>\n<p><em>'full_paths'</em> - output tuples consisting of all path components\n(both map keys and array indexes) and an object as the last element.</p>\n<pre><span class=\"p\">(</span><span class=\"s1\">'friends'</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'John'</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">31</span><span class=\"p\">})</span>\n<span class=\"p\">(</span><span class=\"s1\">'friends'</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'Ivan'</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">26</span><span class=\"p\">})</span>\n<span class=\"p\">(</span><span class=\"s1\">'colleagues'</span><span class=\"p\">,</span> <span class=\"s1\">'manager'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'Jack'</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">33</span><span class=\"p\">})</span>\n<span class=\"p\">(</span><span class=\"s1\">'colleagues'</span><span class=\"p\">,</span> <span class=\"s1\">'subordinate'</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"s1\">'Lucy'</span><span class=\"p\">,</span> <span class=\"s1\">'age'</span><span class=\"p\">:</span> <span class=\"mi\">21</span><span class=\"p\">})</span>\n</pre>\n<p>Common usage pattern for this mode is</p>\n<pre><span class=\"k\">for</span> <span class=\"o\">*</span><span class=\"n\">path</span><span class=\"p\">,</span> <span class=\"nb\">object</span> <span class=\"ow\">in</span> <span class=\"n\">JsonSlicer</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n</li>\n</ul>\n<p><em>yajl_allow_comments</em> enables corresponding YAJL flag, which is\ndocumented as follows:</p>\n<blockquote>\n<p>Ignore javascript style comments present in JSON input.  Non-standard,\nbut rather fun</p>\n</blockquote>\n<p><em>yajl_dont_validate_strings</em> enables corresponding YAJL flag, which\nis documented as follows:</p>\n<blockquote>\n<p>When set the parser will verify that all strings in JSON input\nare valid UTF8 and will emit a parse error if this is not so.  When\nset, this option makes parsing slightly more expensive (~7% depending\non processor and compiler in use)</p>\n</blockquote>\n<p><em>yajl_allow_trailing_garbage</em> enables corresponding YAJL flag, which\nis documented as follows:</p>\n<blockquote>\n<p>By default, yajl will ensure the entire input text was consumed\nand will raise an error otherwise.  Enabling this flag will cause\nyajl to disable this check.  This can be useful when parsing json\nout of a that contains more than a single JSON document.</p>\n</blockquote>\n<p><em>yajl_allow_multiple_values</em> enables corresponding YAJL flag, which\nis documented as follows:</p>\n<blockquote>\n<p>Allow multiple values to be parsed by a single handle.  The entire\ntext must be valid JSON, and values can be seperated by any kind\nof whitespace.  This flag will change the behavior of the parser,\nand cause it continue parsing after a value is parsed, rather than\ntransitioning into a complete state.  This option can be useful\nwhen parsing multiple values from an input stream.</p>\n</blockquote>\n<p><em>yajl_allow_partial_values</em> enables corresponding YAJL flag, which\nis documented as follows:</p>\n<blockquote>\n<p>When yajl_complete_parse() is called the parser will check that the\ntop level value was completely consumed.  I.E., if called whilst\nin the middle of parsing a value yajl will enter an error state\n(premature EOF).  Setting this flag suppresses that check and the\ncorresponding error.</p>\n</blockquote>\n<p><em>encoding</em> may be used to override output encoding, which is derived\nfrom the input file handle if possible, or otherwise set to the\ndefault one as Python builtin <code>open()</code> would use (usually <code>'UTF-8'</code>).</p>\n<p><em>errors</em> is an optional string that specifies how encoding and\ndecoding errors are to be handled. Defaults to <code>'strict'</code></p>\n<p><em>binary</em> forces the output to be in form of <code>bytes</code> objects instead\nof <code>str</code> unicode strings.</p>\n<p>The constructed object is as iterator. You may call <code>next()</code> to extract\nsingle element from it, iterate it via <code>for</code> loop, or use it in generator\ncomprehensions or in any place where iterator is accepted.</p>\n<h2>Performance/competitors</h2>\n<p>The closest competitor is <a href=\"https://github.com/isagalaev/ijson\" rel=\"nofollow\">ijson</a>,\nand JsonSlicer was written to be better. Namely,</p>\n<ul>\n<li>It's about 15x faster, similar in performance to Python's native <code>json</code> module</li>\n<li>It allows iterating over dictionaries and allows more flexibility when\nspecifying paths/patterns of objects to iterate over</li>\n</ul>\n<p>The results of bundled benchmark on Python 3.7.2 / clang 6.0.1 / <code>-O2 -DNDEBUG</code> / FreeBSD 12.0 amd64 / Core i7-6600U CPU @ 2.60GHz.</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Facility</th>\n<th align=\"center\">Type</th>\n<th align=\"right\">Objects/sec</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">json.loads()</td>\n<td align=\"center\">str</td>\n<td align=\"right\">1155.9K</td>\n</tr>\n<tr>\n<td align=\"left\">json.load(StringIO())</td>\n<td align=\"center\">str</td>\n<td align=\"right\">1104.1K</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>JsonSlicer (no paths, binary input, binary output)</strong></td>\n<td align=\"center\">bytes</td>\n<td align=\"right\">1149.5K</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>JsonSlicer (no paths, unicode input, binary output)</strong></td>\n<td align=\"center\">bytes</td>\n<td align=\"right\">1121.3K</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>JsonSlicer (no paths, binary input, unicode output)</strong></td>\n<td align=\"center\">str</td>\n<td align=\"right\">1033.3K</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>JsonSlicer (no paths, unicode input, unicode output)</strong></td>\n<td align=\"center\">str</td>\n<td align=\"right\">1006.2K</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>JsonSlicer (full paths, binary output)</strong></td>\n<td align=\"center\">bytes</td>\n<td align=\"right\">787.6K</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>JsonSlicer (full paths, unicode output)</strong></td>\n<td align=\"center\">str</td>\n<td align=\"right\">586.5K</td>\n</tr>\n<tr>\n<td align=\"left\">ijson.yajl2_cffi</td>\n<td align=\"center\">bytes</td>\n<td align=\"right\">75.7K</td>\n</tr>\n<tr>\n<td align=\"left\">ijson.yajl2</td>\n<td align=\"center\">bytes</td>\n<td align=\"right\">52.0K</td>\n</tr>\n<tr>\n<td align=\"left\">ijson.python</td>\n<td align=\"center\">str</td>\n<td align=\"right\">32.2K</td>\n</tr></tbody></table>\n<h2>Status/TODO</h2>\n<p>JsonSlicer is currently in beta stage, used in production in\n<a href=\"https://repology.org\" rel=\"nofollow\">Repology</a> project. Testing foci are:</p>\n<ul>\n<li>Edge cases with uncommon encoding (input/output) configurations</li>\n<li>Absence of memory leaks</li>\n</ul>\n<h2>Requirements</h2>\n<ul>\n<li>Python 3.4+ (Python 2 not supported)</li>\n<li>pkg-config</li>\n<li><a href=\"https://lloyd.github.io/yajl/\" rel=\"nofollow\">yajl</a> 2.0.3+ (older versions lack pkgconfig file)</li>\n</ul>\n<h2>License</h2>\n<p>MIT license, copyright (c) 2019 Dmitry Marakasov <a href=\"mailto:amdmi3@amdmi3.ru\">amdmi3@amdmi3.ru</a>.</p>\n\n          </div>"}, "last_serial": 5951564, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "d75e053a631feb9529227ae43373972d", "sha256": "9e2e4b9e0cb03b7b5519c5289f5b1b9b43ec69f0d0c617a264f650fc3d9c99bd"}, "downloads": -1, "filename": "jsonslicer-0.1.0.tar.gz", "has_sig": false, "md5_digest": "d75e053a631feb9529227ae43373972d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21458, "upload_time": "2019-01-22T13:47:40", "upload_time_iso_8601": "2019-01-22T13:47:40.190256Z", "url": "https://files.pythonhosted.org/packages/0a/6f/803ddf86b706db159957e4c67dc1731c59e53c6ba6c5a1fe8853995bcf2b/jsonslicer-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "a497cb9f5a4778ab0e6d4985e3171758", "sha256": "82bcb3d3f995b8248f1713cef978ca3244509c70a2f6ddc9c3cb15b141f5cfff"}, "downloads": -1, "filename": "jsonslicer-0.1.1.tar.gz", "has_sig": false, "md5_digest": "a497cb9f5a4778ab0e6d4985e3171758", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21782, "upload_time": "2019-01-22T16:06:05", "upload_time_iso_8601": "2019-01-22T16:06:05.991452Z", "url": "https://files.pythonhosted.org/packages/13/87/df2b130e0c532e26af5c8e05fea6a405892f5759f9bf2520cc005e75f16f/jsonslicer-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "f6176437352ba43e56725dbe33a87059", "sha256": "cacca46c021bf3a2783968fd6c435d6d5baf60769dd18fe5157aec7324931287"}, "downloads": -1, "filename": "jsonslicer-0.1.2.tar.gz", "has_sig": false, "md5_digest": "f6176437352ba43e56725dbe33a87059", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22873, "upload_time": "2019-03-04T18:50:37", "upload_time_iso_8601": "2019-03-04T18:50:37.574201Z", "url": "https://files.pythonhosted.org/packages/6d/3c/4c2c5eb3fc85de32fd769686903e12d0197d54abe2618b0b825382392843/jsonslicer-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "56bd1da70e244ff39e93c08f8f904314", "sha256": "1cc9a731bdce316afcf04e938e959b7d0b7620bf580dcb1d98872603bbb365b8"}, "downloads": -1, "filename": "jsonslicer-0.1.3.tar.gz", "has_sig": false, "md5_digest": "56bd1da70e244ff39e93c08f8f904314", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29100, "upload_time": "2019-03-07T17:39:20", "upload_time_iso_8601": "2019-03-07T17:39:20.884410Z", "url": "https://files.pythonhosted.org/packages/0a/35/34db36b02375baaeb6809027173ca15b461bbc61f0b25cac336d72c7bec6/jsonslicer-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "89641b363828a1f51a08d0af5f16d461", "sha256": "b2db201723f954887ae45c87ec27a97f219c6dd2db1796543e27d44044f8a240"}, "downloads": -1, "filename": "jsonslicer-0.1.4.tar.gz", "has_sig": false, "md5_digest": "89641b363828a1f51a08d0af5f16d461", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22911, "upload_time": "2019-03-12T13:30:45", "upload_time_iso_8601": "2019-03-12T13:30:45.831652Z", "url": "https://files.pythonhosted.org/packages/bf/a0/54fe9b1c190ef9c2b0e6013b4c88f759a873b89144681ce52f87fb8a2dc1/jsonslicer-0.1.4.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "a39696ccd983106e56975604434d7b97", "sha256": "78aff4171369faafdeee0dd0363457b81104ca1768a4b82144073e748de6fd66"}, "downloads": -1, "filename": "jsonslicer-0.1.5.tar.gz", "has_sig": false, "md5_digest": "a39696ccd983106e56975604434d7b97", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23022, "upload_time": "2019-10-09T19:21:14", "upload_time_iso_8601": "2019-10-09T19:21:14.434888Z", "url": "https://files.pythonhosted.org/packages/61/ec/75c764f881625c97d2d9e9e06fe1b9aa6d145dee8b327d73cd76b36aeec2/jsonslicer-0.1.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a39696ccd983106e56975604434d7b97", "sha256": "78aff4171369faafdeee0dd0363457b81104ca1768a4b82144073e748de6fd66"}, "downloads": -1, "filename": "jsonslicer-0.1.5.tar.gz", "has_sig": false, "md5_digest": "a39696ccd983106e56975604434d7b97", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23022, "upload_time": "2019-10-09T19:21:14", "upload_time_iso_8601": "2019-10-09T19:21:14.434888Z", "url": "https://files.pythonhosted.org/packages/61/ec/75c764f881625c97d2d9e9e06fe1b9aa6d145dee8b327d73cd76b36aeec2/jsonslicer-0.1.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:37 2020"}