{"info": {"author": "Ilya Kreymer", "author_email": "ikreymer@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: System :: Archiving", "Topic :: System :: Archiving :: Backup", "Topic :: Utilities"], "description": "Warc-Signer 0.3.1\n=================\n\n.. image:: https://travis-ci.org/ikreymer/warcsigner.svg?branch=master\n  :target: https://travis-ci.org/ikreymer/warcsigner\n\n.. image:: https://coveralls.io/repos/ikreymer/warcsigner/badge.svg\n  :target: https://coveralls.io/r/ikreymer/warcsigner\n\n\nTools to add and a verify a cryptographic signature to WARC (or any gzip-chunked) files\n\nThis package provides complemetary ``warc-sign`` tool which signs WARC(s) with an RSA signature and \n``warc-verify`` which verifies that the WARC(s) have been signed.\n\nUsage\n------\n\nInstall with: ``python setup.py install``\n\nTests can be run with: ``python setup.py test``\n\nTo sign a warc:\n\n``warc-sign privatekey.pem my-warc-file.warc.gz``\n\nTo verify that a warc has been signed:\n\n``warc-verify publickey.pem my-warc-file.warc.gz``\n\n\nAPI Usage\n~~~~~~~~~\n\nwarcsigner can be used from other scripts.\nTo sign a warc:\n\n::\n\n  from warcsigner.warcsigner import RSASigner\n  \n  signer = RSASigner(private_key_file='privatekey.pem')\n  \n  if signer.sign('my-warc-file.warc.gz'):\n      # warc signed successfully\n  \n\nor to verify:\n\n::\n\n  from warcsigner.warcsigner import RSASigner\n  \n  signer = RSASigner(public_key_file='publickey.pem')\n  \n  if signer.verify('my-warc-file.warc.gz'):\n      # signature verified\n  else:\n      # signature not found/invalid\n\n\nthe ``sign`` and ``verify`` methods can take either a filename string or a file-like \nstream object (an object with a ``read`` method)\n\nAdditionally, upon verification, the signature can be removed:\n\n::\n\n  if signer.verify('my-warc-file.warc.gz', remove=True):\n      # signature verified and removed\n\n  assert signer.verify('my-warc-file.warc.gz') == False\n\nIf the first verify succeeds, the signature will be removed and file truncated\nto its previous pre-signature size. (The file is unaltered if the verification fails).\nThis may be useful if planning to append to the WARC and then resigning it.\n\nStreaming and ``seek()``\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nIt is possible to use a file-like object which supports a ``read()`` instead of a filename.\n\nWhen a WARC is signed, the signature is appended to the end of the file.\n\nWhen verifying a file, the ``seek()`` may be used to determine the file size and the position of the signature.\nHowever, if a ``size=`` param is added to ``verify`` or ``verify_stream`` calls, no seek() calls are made during\nthe verification and the file-like object is consumed linearly. This is specially useful\nwhen streaming a file from a remote location and ``seek()`` is not available. \nThe total file size must be provided, though.\n\n\nPublic/Private keys are expected to be in .PEM format\nSee the `python-rsa formats doc <http://stuvel.eu/files/python-rsa-doc/compatibility.html>`_ for more information\non supported key formats.\n\nOriginal Stream\n~~~~~~~~~~~~~~~\n\nIn certain situations, it may be useful to return the original, unsigned stream from a signed stream.\n``signer.get_unsigned_stream(stream, size)`` will return a wrapper for `stream` which will not include the signature (if present). This is useful if concatenating WARCs without including a signature (and empty record) for each one.\n\n\nHow it works\n------------\n\nThe `python-rsa <http://stuvel.eu/rsa>`_ library is used to sign and verify the signature.\n\nThe signature is stored in an extra gzip chunk containing no data but using `custom extra field <http://www.gzip.org/zlib/rfc-gzip.html#extra>`_ \nto store the signature. This allows the verify tool to quickly access the signature by checking a fixed offset from the end of the WARC.\n\nWhen decompressing gzip chunks, there should be no detectable difference as most gzip tools ignore the extra gzip header.\n\nWhile this is designed for compressed WARCs, this can be used for any format consisting of concatenated gzip chunks, ARC files, etc...\n\nNote: since the signature is a gzip block, it makes less sense for uncompressed / plain text files.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ikreymer/warcsigner", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "warcsigner", "package_url": "https://pypi.org/project/warcsigner/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/warcsigner/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/ikreymer/warcsigner"}, "release_url": "https://pypi.org/project/warcsigner/0.3.1/", "requires_dist": null, "requires_python": null, "summary": "Tools for signing and verifying WARC files", "version": "0.3.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/ikreymer/warcsigner\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/ikreymer/warcsigner.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/27d453036f90eeee2f6ff65e9679cf9f75d40d6e/68747470733a2f2f7472617669732d63692e6f72672f696b7265796d65722f776172637369676e65722e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/r/ikreymer/warcsigner\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/ikreymer/warcsigner/badge.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/47db1785356e79ed6a8b6b4ac111390abdab45aa/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f696b7265796d65722f776172637369676e65722f62616467652e737667\"></a>\n<p>Tools to add and a verify a cryptographic signature to WARC (or any gzip-chunked) files</p>\n<p>This package provides complemetary <tt><span class=\"pre\">warc-sign</span></tt> tool which signs WARC(s) with an RSA signature and\n<tt><span class=\"pre\">warc-verify</span></tt> which verifies that the WARC(s) have been signed.</p>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Install with: <tt>python setup.py install</tt></p>\n<p>Tests can be run with: <tt>python setup.py test</tt></p>\n<p>To sign a warc:</p>\n<p><tt><span class=\"pre\">warc-sign</span> privatekey.pem <span class=\"pre\">my-warc-file.warc.gz</span></tt></p>\n<p>To verify that a warc has been signed:</p>\n<p><tt><span class=\"pre\">warc-verify</span> publickey.pem <span class=\"pre\">my-warc-file.warc.gz</span></tt></p>\n<div id=\"api-usage\">\n<h3>API Usage</h3>\n<p>warcsigner can be used from other scripts.\nTo sign a warc:</p>\n<pre>from warcsigner.warcsigner import RSASigner\n\nsigner = RSASigner(private_key_file='privatekey.pem')\n\nif signer.sign('my-warc-file.warc.gz'):\n    # warc signed successfully\n</pre>\n<p>or to verify:</p>\n<pre>from warcsigner.warcsigner import RSASigner\n\nsigner = RSASigner(public_key_file='publickey.pem')\n\nif signer.verify('my-warc-file.warc.gz'):\n    # signature verified\nelse:\n    # signature not found/invalid\n</pre>\n<p>the <tt>sign</tt> and <tt>verify</tt> methods can take either a filename string or a file-like\nstream object (an object with a <tt>read</tt> method)</p>\n<p>Additionally, upon verification, the signature can be removed:</p>\n<pre>if signer.verify('my-warc-file.warc.gz', remove=True):\n    # signature verified and removed\n\nassert signer.verify('my-warc-file.warc.gz') == False\n</pre>\n<p>If the first verify succeeds, the signature will be removed and file truncated\nto its previous pre-signature size. (The file is unaltered if the verification fails).\nThis may be useful if planning to append to the WARC and then resigning it.</p>\n</div>\n<div id=\"streaming-and-seek\">\n<h3>Streaming and <tt>seek()</tt></h3>\n<p>It is possible to use a file-like object which supports a <tt>read()</tt> instead of a filename.</p>\n<p>When a WARC is signed, the signature is appended to the end of the file.</p>\n<p>When verifying a file, the <tt>seek()</tt> may be used to determine the file size and the position of the signature.\nHowever, if a <tt>size=</tt> param is added to <tt>verify</tt> or <tt>verify_stream</tt> calls, no seek() calls are made during\nthe verification and the file-like object is consumed linearly. This is specially useful\nwhen streaming a file from a remote location and <tt>seek()</tt> is not available.\nThe total file size must be provided, though.</p>\n<p>Public/Private keys are expected to be in .PEM format\nSee the <a href=\"http://stuvel.eu/files/python-rsa-doc/compatibility.html\" rel=\"nofollow\">python-rsa formats doc</a> for more information\non supported key formats.</p>\n</div>\n<div id=\"original-stream\">\n<h3>Original Stream</h3>\n<p>In certain situations, it may be useful to return the original, unsigned stream from a signed stream.\n<tt>signer.get_unsigned_stream(stream, size)</tt> will return a wrapper for <cite>stream</cite> which will not include the signature (if present). This is useful if concatenating WARCs without including a signature (and empty record) for each one.</p>\n</div>\n</div>\n<div id=\"how-it-works\">\n<h2>How it works</h2>\n<p>The <a href=\"http://stuvel.eu/rsa\" rel=\"nofollow\">python-rsa</a> library is used to sign and verify the signature.</p>\n<p>The signature is stored in an extra gzip chunk containing no data but using <a href=\"http://www.gzip.org/zlib/rfc-gzip.html#extra\" rel=\"nofollow\">custom extra field</a>\nto store the signature. This allows the verify tool to quickly access the signature by checking a fixed offset from the end of the WARC.</p>\n<p>When decompressing gzip chunks, there should be no detectable difference as most gzip tools ignore the extra gzip header.</p>\n<p>While this is designed for compressed WARCs, this can be used for any format consisting of concatenated gzip chunks, ARC files, etc\u2026</p>\n<p>Note: since the signature is a gzip block, it makes less sense for uncompressed / plain text files.</p>\n</div>\n\n          </div>"}, "last_serial": 1780626, "releases": {"0.3.0": [{"comment_text": "", "digests": {"md5": "0a6609aa73d5d22f94fbae820034f1f0", "sha256": "a7c617e9dd02e580341cf2cabc2344fa46b2c19bc46a9bc6e0a120fec2e66505"}, "downloads": -1, "filename": "warcsigner-0.3.0.tar.gz", "has_sig": false, "md5_digest": "0a6609aa73d5d22f94fbae820034f1f0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7012, "upload_time": "2015-10-21T21:10:03", "upload_time_iso_8601": "2015-10-21T21:10:03.311602Z", "url": "https://files.pythonhosted.org/packages/75/0f/328203850a2b0ee4e805facb2b70379bba43118af5a0185d38a73a799aa6/warcsigner-0.3.0.tar.gz", "yanked": false}], "0.3.1": [{"comment_text": "", "digests": {"md5": "deebbf1c07ebc44961768a1a9474cf76", "sha256": "46b2364228da83afe996de821ddd814e7e305a4b8f5a6219e8597de3df29a3f5"}, "downloads": -1, "filename": "warcsigner-0.3.1.tar.gz", "has_sig": false, "md5_digest": "deebbf1c07ebc44961768a1a9474cf76", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7210, "upload_time": "2015-10-21T21:42:35", "upload_time_iso_8601": "2015-10-21T21:42:35.881199Z", "url": "https://files.pythonhosted.org/packages/2a/3f/e8313689966aab7f389167efc75fd933ff7a50f37ae13a1ac7209344bea5/warcsigner-0.3.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "deebbf1c07ebc44961768a1a9474cf76", "sha256": "46b2364228da83afe996de821ddd814e7e305a4b8f5a6219e8597de3df29a3f5"}, "downloads": -1, "filename": "warcsigner-0.3.1.tar.gz", "has_sig": false, "md5_digest": "deebbf1c07ebc44961768a1a9474cf76", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7210, "upload_time": "2015-10-21T21:42:35", "upload_time_iso_8601": "2015-10-21T21:42:35.881199Z", "url": "https://files.pythonhosted.org/packages/2a/3f/e8313689966aab7f389167efc75fd933ff7a50f37ae13a1ac7209344bea5/warcsigner-0.3.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:32:25 2020"}