{"info": {"author": "21 strun", "author_email": "adm@21s.pl", "bugtrack_url": null, "classifiers": ["Framework :: Django", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Topic :: Database"], "description": "Migraine\n========\n\nMigraine helps with painful data migrations.\n\nIt provides a framework for running cross-model and SQL-to-model data\nmigrations for Django. Migraine's Migrator classes provide a declarative\napproach to importing data from external databases and Django models\ninto other Django models, with a syntax somewhat similar to Django's\nModelForms. Migraine will also run you your migrations in order derived\nfrom inter-migration dependencies.\n\nBuilding a migration project\n============================\n\nTo use Migraine, you will need to create a project containing two basic\nelements: a migrators package containg one module per Django app and a\nbootstrap script you will use to set up django settings and start a\nmigration.\n\nMigraine projects are recommended to be placed outside of your main\napplication's source code, so make sure the target app is available on\nthe PYTHONPATH. You can append its path in an environment variable or in\nthe ``migrate.py`` script.\n\nAssuming we want to migrate to a single app called ``polls``, here is\nhow our project structure will look like:\n\n::\n\n    polls_migration/\n        __init__.py\n        migrate.py\n        migrators/\n            __init__.py\n            polls.py\n\nWe created a ``migrate.py`` module that will contain our configuration\ncode, and a ``polls.py`` module where we will define our migrator\nclasses.\n\nWriting a bootstrap script\n==========================\n\nYour ``migrate.py`` script needs to do two things:\n\n1. Import your migrators package.\n2. Call ``run_from_command_line``.\n\nYou can also use it for additional configuration, like loading Django\nsettings.\n\nHere is a basic example:\n\n::\n\n    #!/usr/bin/env python\n    import sys\n    from migraine import run_from_command_line\n    import migrators\n\n    if __name__ == \"__main__\":\n        run_from_command_line(migrators, sys.argv)\n\nDefining Migrators\n==================\n\nA Migrator class defines how we want to process the data we're going to\nmigrate. It can be any class providing a ``run_migration`` method.\nInside each of the ``migrators`` package submodules define a list called\n``migrators``, containing names of classes from that submodule that you\nwish to be detected by migraine's migration-running mechanism.\n\nModel to Model migrations\n-------------------------\n\nMigraine provides a base ``ModelToModelMigrator`` that will create a\nsingle record in the target model per each record from the source model.\nWe will use it to migrate data from an old model called OldPoll to a\nfresh model called NewPoll.\n\n::\n\n    # our app's models:\n\n    from django.db import models\n\n    class OldPoll(models.Model):\n        old_poll_name = models.CharField(max_length=30)\n\n    class NewPoll(models.Model):\n        new_poll_name = models.CharField(max_length=36)\n\n\n    # migrators/polls.py:\n\n    from migraine.migrators import ModelToModelMigrator\n    from polls.models import OldPoll, NewPoll\n\n    migrators = ['PollsMigrator']\n\n    class PollsMigrator(ModelToModelMigrator):\n        source_model = OldPoll\n        target_model = NewPoll\n        fields = [\n            ('old_poll_name', 'new_poll_name')\n        ]\n\nWe've just created a Migrator that will copy over OldPolls to NewPolls.\n\nYou can also define more complex rules for processing fields. Let's\nassume we want the old polls' names to end with \"(old)\". For each such\nfield we can define a method that will return a processed value.\nMigraine uses a convention of prepending such methods' names with\n``import_``:\n\n::\n\n    class AppendingPollsMigrator(ModelToModelMigrator):\n        source_model = OldPoll\n        target_model = NewPoll\n\n        def import_new_poll_name(self, source):\n            return source.old_poll_name + ' (old)'\n\nEffect of running such a migration will be identical to running\n\n::\n\n    new_poll.new_poll_name = source.old_poll_name + ' (old)'\n\nfor each newly created NewPoll object.\n\nInstead of a ``source_model``, you can also define a ``query_set`` field\nif you need more control over source data.\n\nSQL table to model migrations\n-----------------------------\n\nMigraine can handle importing data from a raw SQL database. For this,\nthere is an ``SQLToModelMigrator``.\n\n::\n\n    from blog.models import Author, BlogPost\n    migrators = ['BlogPostMigrator']\n\n    class BlogPostMigrator(SQLToModelMigrator):\n        source_db = 'oldblog'\n        source_table = 'blog_posts'\n        target_model = BlogPost\n        skip_on_match = ['name']\n        fields = [\n            ('title', 'title'),\n            ('content', 'content'),\n        ]\n\n        def import_author(self, source):\n            return Author.objects.get_or_create(name=source['author_name'])\n\nThis simple example will populate the BlogPost model with data from\n``blog_post`` table's rows. The ``import_`` methods' ``source`` argument\ncontains a dict mapping column names to values for each of source\ntable's rows.\n\nThe ``source_db`` field declares the database to be used. The database\nneeds to be decared in the DATABASES dict in django settings. It is\noptional and defaults to ``default``.\n\nIntead of ``source_table``, you can define an ``sql`` field. This will\ncause the Migrator to use query's result rows as the source feed.\n\nRunning migrations\n==================\n\nTo launch all migrations, run your bootstrap script:\n\n::\n\n    python migrate.py\n\nYou can also specify individual migrations to run. To see a list of\navailable migrations run ``migrate.py --list``.\n\nMigrator dependencies\n=====================\n\nMigraine can sort your migrations using topological sorting based on\ninter-migration dependencies. To use this feature, declare a\n``depends_on`` field on your Migrators that will contain a list of\nmigrator names:\n\n::\n\n    # migrators/foo.py\n    migrators = ['MigratorA', MigratorB']\n\n    class MigratorA:\n        depends_on = ['foo.MigratorB']\n        # ...\n\n    class MigratorB:\n        # ...\n\nIn this example, MigratorB will always be run before MigratorA.\n\nRunning tests\n=============\n\n::\n\n    cd testapp\n    pip install -r requirements.txt  # you probably want to make a virtualenv\n                                     # for this\n    DJANGO_SETTINGS_MODULE=settings PYTHONPATH=`pwd` py.test", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/21strun/migraine", "keywords": "django,migration,database", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "migraine", "package_url": "https://pypi.org/project/migraine/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/migraine/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/21strun/migraine"}, "release_url": "https://pypi.org/project/migraine/0.0.1/", "requires_dist": null, "requires_python": null, "summary": "Migraine helps with painful data migrations.", "version": "0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"migraine\">\n<h2>Migraine</h2>\n<p>Migraine helps with painful data migrations.</p>\n<p>It provides a framework for running cross-model and SQL-to-model data\nmigrations for Django. Migraine\u2019s Migrator classes provide a declarative\napproach to importing data from external databases and Django models\ninto other Django models, with a syntax somewhat similar to Django\u2019s\nModelForms. Migraine will also run you your migrations in order derived\nfrom inter-migration dependencies.</p>\n</div>\n<div id=\"building-a-migration-project\">\n<h2>Building a migration project</h2>\n<p>To use Migraine, you will need to create a project containing two basic\nelements: a migrators package containg one module per Django app and a\nbootstrap script you will use to set up django settings and start a\nmigration.</p>\n<p>Migraine projects are recommended to be placed outside of your main\napplication\u2019s source code, so make sure the target app is available on\nthe PYTHONPATH. You can append its path in an environment variable or in\nthe <tt>migrate.py</tt> script.</p>\n<p>Assuming we want to migrate to a single app called <tt>polls</tt>, here is\nhow our project structure will look like:</p>\n<pre>polls_migration/\n    __init__.py\n    migrate.py\n    migrators/\n        __init__.py\n        polls.py\n</pre>\n<p>We created a <tt>migrate.py</tt> module that will contain our configuration\ncode, and a <tt>polls.py</tt> module where we will define our migrator\nclasses.</p>\n</div>\n<div id=\"writing-a-bootstrap-script\">\n<h2>Writing a bootstrap script</h2>\n<p>Your <tt>migrate.py</tt> script needs to do two things:</p>\n<ol>\n<li>Import your migrators package.</li>\n<li>Call <tt>run_from_command_line</tt>.</li>\n</ol>\n<p>You can also use it for additional configuration, like loading Django\nsettings.</p>\n<p>Here is a basic example:</p>\n<pre>#!/usr/bin/env python\nimport sys\nfrom migraine import run_from_command_line\nimport migrators\n\nif __name__ == \"__main__\":\n    run_from_command_line(migrators, sys.argv)\n</pre>\n</div>\n<div id=\"defining-migrators\">\n<h2>Defining Migrators</h2>\n<p>A Migrator class defines how we want to process the data we\u2019re going to\nmigrate. It can be any class providing a <tt>run_migration</tt> method.\nInside each of the <tt>migrators</tt> package submodules define a list called\n<tt>migrators</tt>, containing names of classes from that submodule that you\nwish to be detected by migraine\u2019s migration-running mechanism.</p>\n<div id=\"model-to-model-migrations\">\n<h3>Model to Model migrations</h3>\n<p>Migraine provides a base <tt>ModelToModelMigrator</tt> that will create a\nsingle record in the target model per each record from the source model.\nWe will use it to migrate data from an old model called OldPoll to a\nfresh model called NewPoll.</p>\n<pre># our app's models:\n\nfrom django.db import models\n\nclass OldPoll(models.Model):\n    old_poll_name = models.CharField(max_length=30)\n\nclass NewPoll(models.Model):\n    new_poll_name = models.CharField(max_length=36)\n\n\n# migrators/polls.py:\n\nfrom migraine.migrators import ModelToModelMigrator\nfrom polls.models import OldPoll, NewPoll\n\nmigrators = ['PollsMigrator']\n\nclass PollsMigrator(ModelToModelMigrator):\n    source_model = OldPoll\n    target_model = NewPoll\n    fields = [\n        ('old_poll_name', 'new_poll_name')\n    ]\n</pre>\n<p>We\u2019ve just created a Migrator that will copy over OldPolls to NewPolls.</p>\n<p>You can also define more complex rules for processing fields. Let\u2019s\nassume we want the old polls\u2019 names to end with \u201c(old)\u201d. For each such\nfield we can define a method that will return a processed value.\nMigraine uses a convention of prepending such methods\u2019 names with\n<tt>import_</tt>:</p>\n<pre>class AppendingPollsMigrator(ModelToModelMigrator):\n    source_model = OldPoll\n    target_model = NewPoll\n\n    def import_new_poll_name(self, source):\n        return source.old_poll_name + ' (old)'\n</pre>\n<p>Effect of running such a migration will be identical to running</p>\n<pre>new_poll.new_poll_name = source.old_poll_name + ' (old)'\n</pre>\n<p>for each newly created NewPoll object.</p>\n<p>Instead of a <tt>source_model</tt>, you can also define a <tt>query_set</tt> field\nif you need more control over source data.</p>\n</div>\n<div id=\"sql-table-to-model-migrations\">\n<h3>SQL table to model migrations</h3>\n<p>Migraine can handle importing data from a raw SQL database. For this,\nthere is an <tt>SQLToModelMigrator</tt>.</p>\n<pre>from blog.models import Author, BlogPost\nmigrators = ['BlogPostMigrator']\n\nclass BlogPostMigrator(SQLToModelMigrator):\n    source_db = 'oldblog'\n    source_table = 'blog_posts'\n    target_model = BlogPost\n    skip_on_match = ['name']\n    fields = [\n        ('title', 'title'),\n        ('content', 'content'),\n    ]\n\n    def import_author(self, source):\n        return Author.objects.get_or_create(name=source['author_name'])\n</pre>\n<p>This simple example will populate the BlogPost model with data from\n<tt>blog_post</tt> table\u2019s rows. The <tt>import_</tt> methods\u2019 <tt>source</tt> argument\ncontains a dict mapping column names to values for each of source\ntable\u2019s rows.</p>\n<p>The <tt>source_db</tt> field declares the database to be used. The database\nneeds to be decared in the DATABASES dict in django settings. It is\noptional and defaults to <tt>default</tt>.</p>\n<p>Intead of <tt>source_table</tt>, you can define an <tt>sql</tt> field. This will\ncause the Migrator to use query\u2019s result rows as the source feed.</p>\n</div>\n</div>\n<div id=\"running-migrations\">\n<h2>Running migrations</h2>\n<p>To launch all migrations, run your bootstrap script:</p>\n<pre>python migrate.py\n</pre>\n<p>You can also specify individual migrations to run. To see a list of\navailable migrations run <tt>migrate.py <span class=\"pre\">--list</span></tt>.</p>\n</div>\n<div id=\"migrator-dependencies\">\n<h2>Migrator dependencies</h2>\n<p>Migraine can sort your migrations using topological sorting based on\ninter-migration dependencies. To use this feature, declare a\n<tt>depends_on</tt> field on your Migrators that will contain a list of\nmigrator names:</p>\n<pre># migrators/foo.py\nmigrators = ['MigratorA', MigratorB']\n\nclass MigratorA:\n    depends_on = ['foo.MigratorB']\n    # ...\n\nclass MigratorB:\n    # ...\n</pre>\n<p>In this example, MigratorB will always be run before MigratorA.</p>\n</div>\n<div id=\"running-tests\">\n<h2>Running tests</h2>\n<pre>cd testapp\npip install -r requirements.txt  # you probably want to make a virtualenv\n                                 # for this\nDJANGO_SETTINGS_MODULE=settings PYTHONPATH=`pwd` py.test\n</pre>\n</div>\n\n          </div>"}, "last_serial": 1098379, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "877df819c43abb0ba043525465ba8853", "sha256": "6d5bbb4afaa71571b3a2379aef16ff3bc90b8e211f8378da9ec612d6d37597eb"}, "downloads": -1, "filename": "migraine-0.0.1.tar.gz", "has_sig": false, "md5_digest": "877df819c43abb0ba043525465ba8853", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6402, "upload_time": "2014-05-20T12:49:59", "upload_time_iso_8601": "2014-05-20T12:49:59.649748Z", "url": "https://files.pythonhosted.org/packages/0f/b3/7de1e0db169174fa418bee2dec076ffb4b181c7648c6e66645a359b35fc8/migraine-0.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "877df819c43abb0ba043525465ba8853", "sha256": "6d5bbb4afaa71571b3a2379aef16ff3bc90b8e211f8378da9ec612d6d37597eb"}, "downloads": -1, "filename": "migraine-0.0.1.tar.gz", "has_sig": false, "md5_digest": "877df819c43abb0ba043525465ba8853", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6402, "upload_time": "2014-05-20T12:49:59", "upload_time_iso_8601": "2014-05-20T12:49:59.649748Z", "url": "https://files.pythonhosted.org/packages/0f/b3/7de1e0db169174fa418bee2dec076ffb4b181c7648c6e66645a359b35fc8/migraine-0.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:45 2020"}