{"info": {"author": "Berkay \u00d6zt\u00fcrk", "author_email": "info@berkayozturk.net", "bugtrack_url": null, "classifiers": ["Development Status :: 1 - Planning", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Utilities"], "description": "![FlexDict Logo](docs/source/_static/logo.png)\n# FlexDict\n![Travis (.org)](https://img.shields.io/travis/ozturkberkay/FlexDict?style=flat-square) ![Codacy coverage](https://img.shields.io/codacy/coverage/66f007ce4acf4076802667c726e89753?style=flat-square) ![Codacy grade](https://img.shields.io/codacy/grade/66f007ce4acf4076802667c726e89753?style=flat-square) ![GitHub repo size](https://img.shields.io/github/repo-size/ozturkberkay/FlexDict?style=flat-square) ![PyPI](https://img.shields.io/pypi/v/flexdict?style=flat-square) ![PyPI - Python Version](https://img.shields.io/pypi/pyversions/flexdict?style=flat-square) [![security: bandit](https://img.shields.io/badge/security-bandit-yellow.svg?style=flat-square)](https://github.com/PyCQA/bandit)\n\n\n> Elegantly nested Python dictionaries.\n\nEasily work with deeply nested dictionaries **and** write clean code using FlexDict; a *small* subclass of ``dict``. FlexDict provides automatic and arbitrary levels of nesting along with additional utility functions.\n\n## Getting Started\n\n1) Install\n    ```console\n    pip install flexdict\n    ```\n\n2) Import\n    ```python\n    from flexdict import FlexDict\n    ```\n\n3) Create\n    ```python\n    f = FlexDict()\n    ```\n\n## User's Guide\n\nThe main purpose of `FlexDict` is to allow you to work with deeply nested dictionaries with minimal amount of code. It achieves this purpose by providing an automatic nesting algorithm. It can be a dangerous feature if not used with caution. That's why, `FlexDict` provides some helper methods to prevent any unintentional side-effects.\n\n### Setting Items\n\nWhen it comes to setting dictionary items, `FlexDict` provides many options. Let's start with the most *slick* way:\n\n```python\nf = FlexDict()\n\nf['easily', 'create', 'deeply', 'nested', 'structures'] = 1\n```\n\nThe resulting dictionary would be:\n\n```terminal\n{'easily':{'create':{'deeply':{'nested':{'structures': 1}}}}\n```\n\nYou can directly pass instances of `list`, `tuple` or `set` instead:\n\n```python\nf[['easily', 'create', 'deeply', 'nested', 'structures']]\nf[('easily', 'create', 'deeply', 'nested', 'structures')]\nf[{'easily', 'create', 'deeply', 'nested', 'structures'}]\n```\n\nYou also have other options:\n\n```python\nf['easily']['create']['deeply']['nested']['structures'] = 1\n\nf.set(['easily', 'create', 'deeply', 'nested', 'structures'], 1)\nf.set(('easily', 'create', 'deeply', 'nested', 'structures'), 1)\nf.set({'easily', 'create', 'deeply', 'nested', 'structures'}, 1)\n```\n\nThe resulting dictionary would be the same for all these examples. However, the `set` method provides many other features. For example, you may only want to set the dictionary items if they do not already exist:\n\n```python\nf = FlexDict({'a': {'b':1}})\n\nf.set(['a', 'b'], 2, overwrite=False)\nf.set(['a', 'c'], 2, overwrite=False)\n```\n\nThis prevents you to overwrite existing values:\n\n```terminal\n{'a': {'b': 1, 'c': 2}}\n```\n\nOr, if you need a counter, you can use the `increment` argument to do exactly that:\n\n```python\nf = FlexDict()\n\nfor i in range(20):\n    if i % 2 == 0:\n        f.set('Even', 1, increment=True)\n    else:\n        f.set('Odd', 1, increment=True)\n\nf\n```\n\nOutput:\n```terminal\n{'Even': 10, 'Odd': 10}\n```\n\n(Note that `overwrite` argument has no effect when `increment` is enabled.)\n\n## Getting Items\n\nAgain, `FlexDict` provides many alternative ways to access your dictionary items:\n\n```python\nf = FlexDict({'key1': {'key2': {'key3': 1}}})\n\n# 1\nf['key1', 'key2', 'key3']\n\n# 2\nf['key1']['key2']['key3']\n\n# 3\nf.get(['key1', 'key2', 'key3'])\nf.get(('key1', 'key2', 'key3'))\nf.get({'key1', 'key2', 'key3'})\n```\n\nThey will all return the same result:\n\n```terminal\n1\n```\n\nThere is a crucial distinction between these alternatives. Whenever you use squared brackets to access an item, `FlexDict` **will automatically create the keys and fill the value with an empty** `FlexDict` **if there is no such item**:\n\n```python\nf = FlexDict()\n\nf['a', 'b']\n\nf\n```\n\nOutput:\n```terminal\n{'a': {'b': {}}}\n```\n\nTo prevent this side-effect, `FlexDict` provides two options. First one, is the `get` method:\n\n```python\nf = FlexDict()\n\nf.get(['a', 'b']), f.get(['a', 'b'], default=0), f\n```\n\nThe `get` method returns the value provided with the `default` argument if the target item does not exist:\n\n```terminal\n(None, 0, {})\n```\n\nThe other option to avoid the aformentioned side-effect is to use the recursive locking mechnasim via the `lock` method. We will cover it later in this guide. However, just to give you a taste of it, the following example is added:\n\n```python\nf = FlexDict()\n\nf.lock()\n\nf['a', 'b']\n```\n\nOutput:\n```terminal\nKeyError: 'a'\n```\n\nGetting the top level keys and values works just like a regular `dict`:\n\n```python\nf = FlexDict({'a': 1, 'b': 2})\n\nf.keys(), f.values()\n```\n\nThe only difference you would notice is `f.values()` returns a `list` instead of `dict_values`. This is an intentional behavior since we are working with nested dictionaries:\n\n```terminal\n(dict_keys(['a', 'b']), [1, 2])\n```\n\nYou may also want to get every key and/or value inside your `FlexDict` instance, even the nested ones. `FlexDict` can do this with recursion:\n\n```python\nf = FlexDict({\n    'a': {\n        'b': 1,\n        'c': {\n            'd': 1,\n            'e': {\n                'a': 3\n            }\n        }\n    },\n    'g': 4\n})\n\nf.keys(nested=True), f.values(nested=True)\n```\n\nThis allows you to check exactly what is inside your `FlexDict` instance:\n\n```terminal\n(['a', 'b', 'c', 'd', 'e', 'a', 'g'], [1, 1, 3, 4])\n```\n\nYou can even get rid of the duplicates:\n\n```python\nf.keys(nested=True, unique=True), f.values(nested=True, unique=True)\n```\n\nNote that unique items gets returned inside of a `set`:\n\n```terminal\n({'a', 'b', 'c', 'd', 'e', 'g'}, {1, 3, 4})\n```\n\nIf you wish, you can flatten the entire `FlexDict` instance. The `flatten` method returns a `list` of values and their respective key-paths:\n\n```python\nf.flatten()\n```\n\nOutput:\n```\n[(['a', 'b'], 1), (['a', 'c', 'd'], 1), (['a', 'c', 'e', 'a'], 3), (['g'], 4)]\n```\n\nLast but not least, if you wish to get the last item and remove it from the `FlexDict` instance, you can use the `pop` method:\n\n```python\nf = FlexDict({'a': 1, 'b': 2})\n\nf.pop(), f\n```\n\nOutput:\n```python\n({'b': 2}, {'a': 1})\n```\n\n### Locking & Unlocking Automatic Nesting\n\nLike we discussed above, automatic nesting can be very dangerous in some cases. Thats why, aside from the previously mentioned workarounds, `FlexDict` provides a recursive algorithm to lock and unlock this feature:\n\n```python\nf = FlexDict()\n\nf.lock()\n\nf['a'] = 1  # Normal `dict` behavior works as expected\n\ntry:\n    f['b', 'c'] = 1 # Will throw a KeyError\nexcept KeyError:\n    f.unlock()\n    f['b', 'c'] = 1\n\nf\n```\n\nOutput:\n```terminal\n{'a': 1, 'b': {'c': 1}}\n```\n\nEach `FlexDict` instance has an attribute called `locked` which tells if it is locked. **Each nested dictionary inside a** `FlexDict` **instance is also a seperate** `FlexDict` **instance!** This means, each of them has seperate `locked` attributes. The `lock` method sets the `locked` attribute of the specified `FlexDict` instance and of all the other nested dictionaries inside of it to `True`. `unlock` method on the other hand, does the exact opposite. This means that you can create any hybrid lock structure you want (Do that with caution!):\n\n```python\nf = FlexDict({'secure': {}, 'not_secure': {}})\n\nf['secure'].lock()\n\nf.locked, f['secure'].locked, f['not_secure'].locked\n```\n\nOutput:\n```terminal\n(False, True, False)\n```\n\nBoth `lock` and `unlock` methods provide an argument called `inplace` which allows you to create locked/unlocked copies of your `FlexDict` instances:\n\n```python\nf = FlexDict()\n\nf_locked = f.lock(inplace=False)\n\nf.locked, f_locked.locked\n```\n\nOutput:\n```terminal\n(False, True)\n```\n\n### Other Utility Methods\n\nYou can check if your `FlexDict` instance contains (is a superset of) or inside of (is a subset of) another `dict` instance.\n\n```python\nf = FlexDict({'a': {'b': 1}})\n\nf.contains({'b': 1}), f.inside({'c': {'a': {'b': 1}}})\n```\n\nOutput:\n```terminal\n(True, True)\n```\n\n`FlexDict` also allows you to easily get the length (number of keys) and size (number of keys and values) inside your dictionaries via `length` and `size` methods. They both utilize the previously mentioned `keys` and `values` methods. Hence, they can work recursively and get rid of duplicates if you wish:\n\n```python\nf = FlexDict({\n    'a': {\n        'b': 1,\n        'c': {\n            'd': 1,\n            'e': {\n                'a': 3\n            }\n        }\n    },\n    'g': 4\n})\n\n# Can be used as a replacement for len()\nprint(f'Number of keys:', f.length())\nprint(f'Number of keys (Recursive):', f.length(nested=True))\nprint(f'Number of keys (Recursive, Unique):', f.length(nested=True, unique=True))\n\n# Saves some of your time\nprint(f'\\nNumber of items (Recursive):', f.size())\nprint(f'Number of items (Recursive, Unique):', f.size(unique=True))\n```\n\nOutput:\n```terminal\nNumber of keys: 2\nNumber of keys (Recursive): 7\nNumber of keys (Recursive, Unique): 6\n\nNumber of items (Recursive): 11\nNumber of items (Recursive, Unique): 9\n```\n\n## Contributing\nSee [contributing](https://github.com/ozturkberkay/FlexDict/CONTRIBUTING.md) for the details.\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ozturkberkay/flexdict", "keywords": "automatic arbitrary dict nesting", "license": "", "maintainer": "", "maintainer_email": "", "name": "flexdict", "package_url": "https://pypi.org/project/flexdict/", "platform": "", "project_url": "https://pypi.org/project/flexdict/", "project_urls": {"Bug Reports": "https://github.com/ozturkberkay/FlexDict/issues", "Homepage": "https://github.com/ozturkberkay/flexdict", "Source": "https://github.com/ozturkberkay/FlexDict"}, "release_url": "https://pypi.org/project/flexdict/0.0.1a1/", "requires_dist": null, "requires_python": ">=2.7", "summary": "Python dict with automatic and arbitrary levels of nesting along with additional utility methods.", "version": "0.0.1a1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><img alt=\"FlexDict Logo\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a44f77b5d440a2b80f04c1b9fb983c27b5fc2f96/646f63732f736f757263652f5f7374617469632f6c6f676f2e706e67\"></p>\n<h1>FlexDict</h1>\n<p><img alt=\"Travis (.org)\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/738ffd166c74596e9fc5cf760c384fb63b9125e4/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f6f7a7475726b6265726b61792f466c6578446963743f7374796c653d666c61742d737175617265\"> <img alt=\"Codacy coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/df95ca996f21e881f583c85854f45f810df1dca2/68747470733a2f2f696d672e736869656c64732e696f2f636f646163792f636f7665726167652f36366630303763653461636634303736383032363637633732366538393735333f7374796c653d666c61742d737175617265\"> <img alt=\"Codacy grade\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6b3b387c06d33b359666b0f6cfca61c3df3a350e/68747470733a2f2f696d672e736869656c64732e696f2f636f646163792f67726164652f36366630303763653461636634303736383032363637633732366538393735333f7374796c653d666c61742d737175617265\"> <img alt=\"GitHub repo size\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1cde0ad8d8c1b2f7e0d7d3572ac32811f1231cc0/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f7265706f2d73697a652f6f7a7475726b6265726b61792f466c6578446963743f7374796c653d666c61742d737175617265\"> <img alt=\"PyPI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b0bf18abefe5f7e410482d8b76f5d327adf7a850/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f666c6578646963743f7374796c653d666c61742d737175617265\"> <img alt=\"PyPI - Python Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/12c8fbfdb87748c542740b818c2cd0904ca1fcfd/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f666c6578646963743f7374796c653d666c61742d737175617265\"> <a href=\"https://github.com/PyCQA/bandit\" rel=\"nofollow\"><img alt=\"security: bandit\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b642c52a9166c8de31b460ddd3de71d841de6828/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f73656375726974792d62616e6469742d79656c6c6f772e7376673f7374796c653d666c61742d737175617265\"></a></p>\n<blockquote>\n<p>Elegantly nested Python dictionaries.</p>\n</blockquote>\n<p>Easily work with deeply nested dictionaries <strong>and</strong> write clean code using FlexDict; a <em>small</em> subclass of <code>dict</code>. FlexDict provides automatic and arbitrary levels of nesting along with additional utility functions.</p>\n<h2>Getting Started</h2>\n<ol>\n<li>\n<p>Install</p>\n<pre><span class=\"go\">pip install flexdict</span>\n</pre>\n</li>\n<li>\n<p>Import</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">flexdict</span> <span class=\"kn\">import</span> <span class=\"n\">FlexDict</span>\n</pre>\n</li>\n<li>\n<p>Create</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">()</span>\n</pre>\n</li>\n</ol>\n<h2>User's Guide</h2>\n<p>The main purpose of <code>FlexDict</code> is to allow you to work with deeply nested dictionaries with minimal amount of code. It achieves this purpose by providing an automatic nesting algorithm. It can be a dangerous feature if not used with caution. That's why, <code>FlexDict</code> provides some helper methods to prevent any unintentional side-effects.</p>\n<h3>Setting Items</h3>\n<p>When it comes to setting dictionary items, <code>FlexDict</code> provides many options. Let's start with the most <em>slick</em> way:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">()</span>\n\n<span class=\"n\">f</span><span class=\"p\">[</span><span class=\"s1\">'easily'</span><span class=\"p\">,</span> <span class=\"s1\">'create'</span><span class=\"p\">,</span> <span class=\"s1\">'deeply'</span><span class=\"p\">,</span> <span class=\"s1\">'nested'</span><span class=\"p\">,</span> <span class=\"s1\">'structures'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n</pre>\n<p>The resulting dictionary would be:</p>\n<pre>{'easily':{'create':{'deeply':{'nested':{'structures': 1}}}}\n</pre>\n<p>You can directly pass instances of <code>list</code>, <code>tuple</code> or <code>set</code> instead:</p>\n<pre><span class=\"n\">f</span><span class=\"p\">[[</span><span class=\"s1\">'easily'</span><span class=\"p\">,</span> <span class=\"s1\">'create'</span><span class=\"p\">,</span> <span class=\"s1\">'deeply'</span><span class=\"p\">,</span> <span class=\"s1\">'nested'</span><span class=\"p\">,</span> <span class=\"s1\">'structures'</span><span class=\"p\">]]</span>\n<span class=\"n\">f</span><span class=\"p\">[(</span><span class=\"s1\">'easily'</span><span class=\"p\">,</span> <span class=\"s1\">'create'</span><span class=\"p\">,</span> <span class=\"s1\">'deeply'</span><span class=\"p\">,</span> <span class=\"s1\">'nested'</span><span class=\"p\">,</span> <span class=\"s1\">'structures'</span><span class=\"p\">)]</span>\n<span class=\"n\">f</span><span class=\"p\">[{</span><span class=\"s1\">'easily'</span><span class=\"p\">,</span> <span class=\"s1\">'create'</span><span class=\"p\">,</span> <span class=\"s1\">'deeply'</span><span class=\"p\">,</span> <span class=\"s1\">'nested'</span><span class=\"p\">,</span> <span class=\"s1\">'structures'</span><span class=\"p\">}]</span>\n</pre>\n<p>You also have other options:</p>\n<pre><span class=\"n\">f</span><span class=\"p\">[</span><span class=\"s1\">'easily'</span><span class=\"p\">][</span><span class=\"s1\">'create'</span><span class=\"p\">][</span><span class=\"s1\">'deeply'</span><span class=\"p\">][</span><span class=\"s1\">'nested'</span><span class=\"p\">][</span><span class=\"s1\">'structures'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">set</span><span class=\"p\">([</span><span class=\"s1\">'easily'</span><span class=\"p\">,</span> <span class=\"s1\">'create'</span><span class=\"p\">,</span> <span class=\"s1\">'deeply'</span><span class=\"p\">,</span> <span class=\"s1\">'nested'</span><span class=\"p\">,</span> <span class=\"s1\">'structures'</span><span class=\"p\">],</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">set</span><span class=\"p\">((</span><span class=\"s1\">'easily'</span><span class=\"p\">,</span> <span class=\"s1\">'create'</span><span class=\"p\">,</span> <span class=\"s1\">'deeply'</span><span class=\"p\">,</span> <span class=\"s1\">'nested'</span><span class=\"p\">,</span> <span class=\"s1\">'structures'</span><span class=\"p\">),</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">set</span><span class=\"p\">({</span><span class=\"s1\">'easily'</span><span class=\"p\">,</span> <span class=\"s1\">'create'</span><span class=\"p\">,</span> <span class=\"s1\">'deeply'</span><span class=\"p\">,</span> <span class=\"s1\">'nested'</span><span class=\"p\">,</span> <span class=\"s1\">'structures'</span><span class=\"p\">},</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>The resulting dictionary would be the same for all these examples. However, the <code>set</code> method provides many other features. For example, you may only want to set the dictionary items if they do not already exist:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">({</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'b'</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">}})</span>\n\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">set</span><span class=\"p\">([</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">],</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">set</span><span class=\"p\">([</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'c'</span><span class=\"p\">],</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>This prevents you to overwrite existing values:</p>\n<pre>{'a': {'b': 1, 'c': 2}}\n</pre>\n<p>Or, if you need a counter, you can use the <code>increment</code> argument to do exactly that:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">()</span>\n\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"s1\">'Even'</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">increment</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">set</span><span class=\"p\">(</span><span class=\"s1\">'Odd'</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">increment</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"n\">f</span>\n</pre>\n<p>Output:</p>\n<pre>{'Even': 10, 'Odd': 10}\n</pre>\n<p>(Note that <code>overwrite</code> argument has no effect when <code>increment</code> is enabled.)</p>\n<h2>Getting Items</h2>\n<p>Again, <code>FlexDict</code> provides many alternative ways to access your dictionary items:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">({</span><span class=\"s1\">'key1'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'key2'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'key3'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}}})</span>\n\n<span class=\"c1\"># 1</span>\n<span class=\"n\">f</span><span class=\"p\">[</span><span class=\"s1\">'key1'</span><span class=\"p\">,</span> <span class=\"s1\">'key2'</span><span class=\"p\">,</span> <span class=\"s1\">'key3'</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># 2</span>\n<span class=\"n\">f</span><span class=\"p\">[</span><span class=\"s1\">'key1'</span><span class=\"p\">][</span><span class=\"s1\">'key2'</span><span class=\"p\">][</span><span class=\"s1\">'key3'</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># 3</span>\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">([</span><span class=\"s1\">'key1'</span><span class=\"p\">,</span> <span class=\"s1\">'key2'</span><span class=\"p\">,</span> <span class=\"s1\">'key3'</span><span class=\"p\">])</span>\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">((</span><span class=\"s1\">'key1'</span><span class=\"p\">,</span> <span class=\"s1\">'key2'</span><span class=\"p\">,</span> <span class=\"s1\">'key3'</span><span class=\"p\">))</span>\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">({</span><span class=\"s1\">'key1'</span><span class=\"p\">,</span> <span class=\"s1\">'key2'</span><span class=\"p\">,</span> <span class=\"s1\">'key3'</span><span class=\"p\">})</span>\n</pre>\n<p>They will all return the same result:</p>\n<pre>1\n</pre>\n<p>There is a crucial distinction between these alternatives. Whenever you use squared brackets to access an item, <code>FlexDict</code> <strong>will automatically create the keys and fill the value with an empty</strong> <code>FlexDict</code> <strong>if there is no such item</strong>:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">()</span>\n\n<span class=\"n\">f</span><span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">]</span>\n\n<span class=\"n\">f</span>\n</pre>\n<p>Output:</p>\n<pre>{'a': {'b': {}}}\n</pre>\n<p>To prevent this side-effect, <code>FlexDict</code> provides two options. First one, is the <code>get</code> method:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">()</span>\n\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">([</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">]),</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">([</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">],</span> <span class=\"n\">default</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">f</span>\n</pre>\n<p>The <code>get</code> method returns the value provided with the <code>default</code> argument if the target item does not exist:</p>\n<pre>(None, 0, {})\n</pre>\n<p>The other option to avoid the aformentioned side-effect is to use the recursive locking mechnasim via the <code>lock</code> method. We will cover it later in this guide. However, just to give you a taste of it, the following example is added:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">()</span>\n\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">lock</span><span class=\"p\">()</span>\n\n<span class=\"n\">f</span><span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">]</span>\n</pre>\n<p>Output:</p>\n<pre>KeyError: 'a'\n</pre>\n<p>Getting the top level keys and values works just like a regular <code>dict</code>:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">({</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">})</span>\n\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">(),</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">()</span>\n</pre>\n<p>The only difference you would notice is <code>f.values()</code> returns a <code>list</code> instead of <code>dict_values</code>. This is an intentional behavior since we are working with nested dictionaries:</p>\n<pre>(dict_keys(['a', 'b']), [1, 2])\n</pre>\n<p>You may also want to get every key and/or value inside your <code>FlexDict</code> instance, even the nested ones. <code>FlexDict</code> can do this with recursion:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">({</span>\n    <span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n        <span class=\"s1\">'c'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'d'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n            <span class=\"s1\">'e'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                <span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"mi\">3</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"s1\">'g'</span><span class=\"p\">:</span> <span class=\"mi\">4</span>\n<span class=\"p\">})</span>\n\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">(</span><span class=\"n\">nested</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">),</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">(</span><span class=\"n\">nested</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>This allows you to check exactly what is inside your <code>FlexDict</code> instance:</p>\n<pre>(['a', 'b', 'c', 'd', 'e', 'a', 'g'], [1, 1, 3, 4])\n</pre>\n<p>You can even get rid of the duplicates:</p>\n<pre><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">keys</span><span class=\"p\">(</span><span class=\"n\">nested</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">unique</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">),</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"p\">(</span><span class=\"n\">nested</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">unique</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>Note that unique items gets returned inside of a <code>set</code>:</p>\n<pre>({'a', 'b', 'c', 'd', 'e', 'g'}, {1, 3, 4})\n</pre>\n<p>If you wish, you can flatten the entire <code>FlexDict</code> instance. The <code>flatten</code> method returns a <code>list</code> of values and their respective key-paths:</p>\n<pre><span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">()</span>\n</pre>\n<p>Output:</p>\n<pre><code>[(['a', 'b'], 1), (['a', 'c', 'd'], 1), (['a', 'c', 'e', 'a'], 3), (['g'], 4)]\n</code></pre>\n<p>Last but not least, if you wish to get the last item and remove it from the <code>FlexDict</code> instance, you can use the <code>pop</code> method:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">({</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">})</span>\n\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">(),</span> <span class=\"n\">f</span>\n</pre>\n<p>Output:</p>\n<pre><span class=\"p\">({</span><span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">})</span>\n</pre>\n<h3>Locking &amp; Unlocking Automatic Nesting</h3>\n<p>Like we discussed above, automatic nesting can be very dangerous in some cases. Thats why, aside from the previously mentioned workarounds, <code>FlexDict</code> provides a recursive algorithm to lock and unlock this feature:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">()</span>\n\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">lock</span><span class=\"p\">()</span>\n\n<span class=\"n\">f</span><span class=\"p\">[</span><span class=\"s1\">'a'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>  <span class=\"c1\"># Normal `dict` behavior works as expected</span>\n\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"n\">f</span><span class=\"p\">[</span><span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"s1\">'c'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"c1\"># Will throw a KeyError</span>\n<span class=\"k\">except</span> <span class=\"ne\">KeyError</span><span class=\"p\">:</span>\n    <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">unlock</span><span class=\"p\">()</span>\n    <span class=\"n\">f</span><span class=\"p\">[</span><span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"s1\">'c'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n\n<span class=\"n\">f</span>\n</pre>\n<p>Output:</p>\n<pre>{'a': 1, 'b': {'c': 1}}\n</pre>\n<p>Each <code>FlexDict</code> instance has an attribute called <code>locked</code> which tells if it is locked. <strong>Each nested dictionary inside a</strong> <code>FlexDict</code> <strong>instance is also a seperate</strong> <code>FlexDict</code> <strong>instance!</strong> This means, each of them has seperate <code>locked</code> attributes. The <code>lock</code> method sets the <code>locked</code> attribute of the specified <code>FlexDict</code> instance and of all the other nested dictionaries inside of it to <code>True</code>. <code>unlock</code> method on the other hand, does the exact opposite. This means that you can create any hybrid lock structure you want (Do that with caution!):</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">({</span><span class=\"s1\">'secure'</span><span class=\"p\">:</span> <span class=\"p\">{},</span> <span class=\"s1\">'not_secure'</span><span class=\"p\">:</span> <span class=\"p\">{}})</span>\n\n<span class=\"n\">f</span><span class=\"p\">[</span><span class=\"s1\">'secure'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">lock</span><span class=\"p\">()</span>\n\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">locked</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">[</span><span class=\"s1\">'secure'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">locked</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">[</span><span class=\"s1\">'not_secure'</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">locked</span>\n</pre>\n<p>Output:</p>\n<pre>(False, True, False)\n</pre>\n<p>Both <code>lock</code> and <code>unlock</code> methods provide an argument called <code>inplace</code> which allows you to create locked/unlocked copies of your <code>FlexDict</code> instances:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">()</span>\n\n<span class=\"n\">f_locked</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">inplace</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">locked</span><span class=\"p\">,</span> <span class=\"n\">f_locked</span><span class=\"o\">.</span><span class=\"n\">locked</span>\n</pre>\n<p>Output:</p>\n<pre>(False, True)\n</pre>\n<h3>Other Utility Methods</h3>\n<p>You can check if your <code>FlexDict</code> instance contains (is a superset of) or inside of (is a subset of) another <code>dict</code> instance.</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">({</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}})</span>\n\n<span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">contains</span><span class=\"p\">({</span><span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}),</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">inside</span><span class=\"p\">({</span><span class=\"s1\">'c'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}}})</span>\n</pre>\n<p>Output:</p>\n<pre>(True, True)\n</pre>\n<p><code>FlexDict</code> also allows you to easily get the length (number of keys) and size (number of keys and values) inside your dictionaries via <code>length</code> and <code>size</code> methods. They both utilize the previously mentioned <code>keys</code> and <code>values</code> methods. Hence, they can work recursively and get rid of duplicates if you wish:</p>\n<pre><span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">FlexDict</span><span class=\"p\">({</span>\n    <span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'b'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n        <span class=\"s1\">'c'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s1\">'d'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n            <span class=\"s1\">'e'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                <span class=\"s1\">'a'</span><span class=\"p\">:</span> <span class=\"mi\">3</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"s1\">'g'</span><span class=\"p\">:</span> <span class=\"mi\">4</span>\n<span class=\"p\">})</span>\n\n<span class=\"c1\"># Can be used as a replacement for len()</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'Number of keys:'</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">length</span><span class=\"p\">())</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'Number of keys (Recursive):'</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">nested</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'Number of keys (Recursive, Unique):'</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">length</span><span class=\"p\">(</span><span class=\"n\">nested</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">unique</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Saves some of your time</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'</span><span class=\"se\">\\n</span><span class=\"s1\">Number of items (Recursive):'</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">())</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'Number of items (Recursive, Unique):'</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">(</span><span class=\"n\">unique</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">))</span>\n</pre>\n<p>Output:</p>\n<pre>Number of keys: 2\nNumber of keys (Recursive): 7\nNumber of keys (Recursive, Unique): 6\n\nNumber of items (Recursive): 11\nNumber of items (Recursive, Unique): 9\n</pre>\n<h2>Contributing</h2>\n<p>See <a href=\"https://github.com/ozturkberkay/FlexDict/CONTRIBUTING.md\" rel=\"nofollow\">contributing</a> for the details.</p>\n\n          </div>"}, "last_serial": 6068440, "releases": {"0.0.1a1": [{"comment_text": "", "digests": {"md5": "598bbb78b3f4a61091719aa1fa3ea318", "sha256": "9d61ec919d69089ec0b6d4626fa364b85d3349d54397516140e95322faddb609"}, "downloads": -1, "filename": "flexdict-0.0.1a1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "598bbb78b3f4a61091719aa1fa3ea318", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7", "size": 7843, "upload_time": "2019-11-02T16:13:49", "upload_time_iso_8601": "2019-11-02T16:13:49.663988Z", "url": "https://files.pythonhosted.org/packages/ef/57/fa2542fa85ae52cc2c88dd4e93139960dc9dfac4112b6105272175da5048/flexdict-0.0.1a1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "111a506990f6d88430a154804723b5b4", "sha256": "4c531df45f3e04171ac13d63eef5666144c1803fdc8cf4c834f88445f87054eb"}, "downloads": -1, "filename": "flexdict-0.0.1a1.tar.gz", "has_sig": false, "md5_digest": "111a506990f6d88430a154804723b5b4", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7", "size": 8539, "upload_time": "2019-11-02T16:13:52", "upload_time_iso_8601": "2019-11-02T16:13:52.198508Z", "url": "https://files.pythonhosted.org/packages/c7/14/3700649a7e404d84c29b46c48cc16a504af9d6a9da9a8e7aea5dd2506741/flexdict-0.0.1a1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "598bbb78b3f4a61091719aa1fa3ea318", "sha256": "9d61ec919d69089ec0b6d4626fa364b85d3349d54397516140e95322faddb609"}, "downloads": -1, "filename": "flexdict-0.0.1a1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "598bbb78b3f4a61091719aa1fa3ea318", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=2.7", "size": 7843, "upload_time": "2019-11-02T16:13:49", "upload_time_iso_8601": "2019-11-02T16:13:49.663988Z", "url": "https://files.pythonhosted.org/packages/ef/57/fa2542fa85ae52cc2c88dd4e93139960dc9dfac4112b6105272175da5048/flexdict-0.0.1a1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "111a506990f6d88430a154804723b5b4", "sha256": "4c531df45f3e04171ac13d63eef5666144c1803fdc8cf4c834f88445f87054eb"}, "downloads": -1, "filename": "flexdict-0.0.1a1.tar.gz", "has_sig": false, "md5_digest": "111a506990f6d88430a154804723b5b4", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7", "size": 8539, "upload_time": "2019-11-02T16:13:52", "upload_time_iso_8601": "2019-11-02T16:13:52.198508Z", "url": "https://files.pythonhosted.org/packages/c7/14/3700649a7e404d84c29b46c48cc16a504af9d6a9da9a8e7aea5dd2506741/flexdict-0.0.1a1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 01:02:00 2020"}