{"info": {"author": "", "author_email": "", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "Natural Language :: English", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5"], "description": "This is the Python core library of the Ethereum project.\n\nFor the python based command line client see:\nhttps://github.com/ethereum/pyethapp\n\nInstallation:\n-------------\n\n``sudo apt-get install libssl-dev build-essential automake pkg-config libtool libffi-dev libgmp-dev``\n\n``git clone https://github.com/ethereum/pyethereum/``\n\n``cd pyethereum``\n\n``python setup.py install``\n\nComponents\n----------\n\nethereum.pow.chain\n~~~~~~~~~~~~~~~~~~\n\nContains the Chain class, which can be used to manage a blockchain. Main\nmethods are:\n\n-  ``__init__(genesis=None, env=None, new_head_cb=None, reset_genesis=False, localtime=None)``\n   - initializes with the given genesis. ``env`` specifies the\n   *environment* (including chain config and database), ``new_head_cb``\n   is a callback called when a new head is added, and ``localtime`` is\n   what the chain assumes is the current timestamp. The genesis can be:\n\n   -  None - in which case it assumes ``env`` is given, and creates a\n      Chain object with the data saved in ``env.db``. If\n      ``reset_genesis`` is set, it re-initializes the chain.\n   -  A ``State`` object\n   -  A genesis declaration\n   -  A state snapshot (``State.snapshot()``)\n   -  An allocation (ie. dict\n      ``{address: {balance: 1, nonce: 2, code: b'\\x03\\x04\\x05', storage: {\"0x06\": \"0x07\"}}}``)\n\n-  ``add_block(block)`` - adds a block to the chain\n-  ``process_time_queue(timestamp)`` - tells the chain that the current\n   time has increased to the new timestamp. The chain will then process\n   any blocks that were unprocessed because they appeared too \"early\"\n-  ``get_blockhash_by_number(num)`` - get the block hash of a block at\n   the given block number\n-  ``get_block(hash)`` - gets the block with the given blockhash\n-  ``get_block_by_number(num)`` - equivalent to\n   ``get_block(get_blockhash_by_number(num))``\n-  ``get_parent(block)`` - gets the parent of a block\n-  ``get_children(block)`` - gets the children of a block\n-  ``head`` (property) - gets the block at the head of the chain\n-  ``state`` (property) - gets the state at the head of the chain\n-  ``mk_poststate_of_blockhash(hash)`` - creates a state object after a\n   given block\n-  ``has_block(block)`` - is that block in the chain? Returns True/False\n-  ``get_chain(from, to)`` - roughly equivalent to\n   ``[get_block_by_number(i) for i in range(from, to)]``, though\n   automatically stops if it reaches the head. ``from`` can be elided to\n   start from genesis, ``to`` can be elided to go up to the head.\n-  ``get_tx_position(tx)`` - if the transaction is in the chain, returns\n   ``(blknum, index)`` where ``blknum`` is the block number of the block\n   that contains the transaction and ``index`` is its position in the\n   block\n\nethereum.state\n~~~~~~~~~~~~~~\n\nContains the State class, which is used to manage a state. Main methods\nare:\n\n-  ``__init__(root_hash, env, **kwargs)`` - initializes a state with the\n   given root hash, the given env (which includes a config and database)\n   and the given auxiliary arguments. These include:\n\n   -  ``txindex`` - the transaction index\n   -  ``gas_used`` - amount of gas used\n   -  ``gas_limit`` - block gas limit\n   -  ``block_number`` - block number\n   -  ``block_coinbase`` - block coinbase address\n   -  ``block_difficulty`` - block difficulty\n   -  ``timestamp`` - timestamp\n   -  ``logs`` - logs created so far\n   -  ``receipts`` - receipts created so far (from previous transactions\n      in the current block)\n   -  ``bloom`` - the bloom filter\n   -  ``suicides`` - suicides (or selfdestructs, the newer more\n      politically correct synonym)\n   -  ``recent_uncles`` - recent uncle blocks in the chain\n   -  ``prev_headers`` - previous block headers\n   -  ``refunds`` - suicide/selfdestruct refund counter\n\nPyethereum follows a **maximally state-centric model**; the ONLY\ninformation needed to process a transaction or a block is located within\nthe state itself, allowing the actual state transition logic to be a\nvery clean ``apply_transaction(state, tx)`` and\n``apply_block(state, block)``.\n\n-  ``get_balance``- gets the balance of an account\n-  ``get_code`` - gets the code of an account\n-  ``get_storage_data(addr, k)`` - gets the storage at the given key of\n   the given address. Expects a key in **numerical** form (eg. b\"cow\" or\n   \"0x636f77\" is represented as 6516599).\n-  ``to_snapshot(root_only=False, no_prevblocks=False)`` - creates a\n   snapshot for the current state. If ``root_only`` is set, only adds\n   the state root, not the entire state. If ``no_prevblocks`` is set,\n   does not add previous headers and uncles. Setting either of those\n   flags means that the same database would be required to recover from\n   the snapshot.\n-  ``from_snapshot(snapshot, env)`` (classmethod) - creates a state from\n   the given snapshot with the given ``env``.\n-  ``ephemeral_clone()`` - creates a clone of the state that you can\n   work with without affecting the original\n\nThere are also many methods that modify the state, eg. ``set_code``,\n``set_storage_data``, but it is generally recommended to avoid using\nthese, and instead modify the state ONLY through ``apply_transaction``\nand ``apply_block``.\n\nethereum.meta\n~~~~~~~~~~~~~\n\nThis file contains two functions:\n\n-  ``apply_block(state, block)`` - takes a state and processes a block\n   onto that state\n-  ``make_head_candidate(chain, txqueue=None, parent=None, timestamp, coinbase, extra_data, min_gasprice=0)``\n   - creates a candidate block for the chain on top of the given parent\n   block (default: head of the chain). Gets transactions from the given\n   ``txqueue`` object with the given ``mingasprice`` (otherwise does not\n   add transactions). ``timestamp``, ``coinbase`` and ``extra_data`` can\n   be used to specify those parameters in the block; otherwise defaults\n   are used\n\nethereum.messages\n~~~~~~~~~~~~~~~~~\n\nThe main function that should be called from here is\n``apply_transaction(state, tx)``.\n\nethereum.utils\n~~~~~~~~~~~~~~\n\nContains a bunch of utility functions, including:\n\nNumerical and hex conversions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n-  ``encode_int(i)`` - converts an integer into big-endian binary\n   representation\n-  ``zpad(data, length)`` - pads the data up to the desired length by\n   adding zero bytes on the left\n-  ``encode_int32(i)`` - equivalent to ``zpad(encode_int(i), 32)`` but\n   faster\n-  ``big_endian_to_int(d)`` - converts binary data into an integer\n-  ``encode_hex(b)`` - converts bytes to hex\n-  ``decode_hex(h)`` - converts hex to bytes\n-  ``int_to_addr(i)`` - converts integer to address\n-  ``is_numeric(i)`` - returns True if the value is int or long,\n   otherwise False\n\nCryptography\n^^^^^^^^^^^^\n\n-  ``sha3(data)`` - computes the SHA3 (or more precisely, keccak256)\n   hash\n-  ``ecrecover_to_pub(hash, v, r, s)`` - recovers the public key that\n   made the signature as a 64-byte binary blob of\n   ``encode_int32(x) + encode_int32(y)``. Hashing this and taking the\n   last 20 bytes gives the *address* that signed a message.\n-  ``ecsign(hash, key)`` - returns the v, r, s values of a signature\n-  ``normalize_key(key)`` - converts a key from many formats into\n   32-byte binary\n-  ``privtoaddr(key)`` - converts a key to an address\n\nAddresses\n^^^^^^^^^\n\n-  ``normalize_address(addr)`` - converts an address into 20-byte binary\n   form\n-  ``check_checksum(addr)`` - returns True if the address checksum\n   passes, otherwise False\n-  ``checksum_encode(addr)`` - converts an address into hex form with a\n   checksum\n-  ``mk_contract_address(addr, nonce)`` - creates the address of a\n   contract created by the given address with the given nonce\n\nMiscellaneous\n^^^^^^^^^^^^^\n\n-  ``denoms`` - contains the denominations of ether, eg.\n   ``denoms.finney = 10**15``, ``denoms.shannon = 10**9``,\n   ``denoms.gwei = 10**9``\n\nethereum.block\n~~~~~~~~~~~~~~\n\nContains the ``Block`` and ``BlockHeader`` classes. Generally\nrecommended to avoid creating blocks and block headers directly, instead\nusing ``mk_head_candidate``. The member variables are straightforward:\n\n-  ``block.transactions`` - transactions in a block\n-  ``block.uncles`` - uncles in a block\n-  ``block.header`` - header of a block\n\nAnd in the header:\n\n-  ``header.hash`` - the hash (also the block hash)\n-  ``header.mining_hash`` - the hash used for proof of work mining\n-  ``header.to_dict()`` - serializes into a human-readable dict\n-  ``header.prevhash`` - previous block hash\n-  ``header.uncles_hash`` - hash of the uncle list\n-  ``header.coinbase`` - coinbase (miner) address\n-  ``header.state_root`` - root hash of the post-state\n-  ``header.tx_list_root`` - hash of the transactions in the block\n-  ``header.receipts_root`` - hash of the receipt trie\n-  ``header.bloom`` - bloom filter\n-  ``header.difficulty`` - block difficulty\n-  ``header.number`` - block number\n-  ``header.gas_limit`` - gas limit\n-  ``header.gas_used`` - gas used\n-  ``header.timestamp`` - timestamp\n-  ``header.extra_data`` - block extra data\n-  ``header.mixhash`` and ``header.nonce`` - Ethash proof of work values\n\nethereum.transactions\n~~~~~~~~~~~~~~~~~~~~~\n\nContains the Transaction class, with the following methods and values:\n\n-  ``__init__(nonce, gasprice, startgas, to, value, data, (v, r, s optional))``\n   - constructor\n-  ``sign(key, network_id=None)`` - signs the transaction with the given\n   key, and with the given EIP155 chain ID (leaving as None will create\n   a pre-EIP155 tx, be warned of replay attacks if you do this!)\n-  ``sender`` - the sender address of the transaction\n-  ``network_id`` - the EIP155 chain ID of the transaction\n-  ``hash`` - the hash of the transaction\n-  ``to_dict()`` - serializes into a human-readable dict\n-  ``intrinsic_gas_used`` - the amount of gas consumed by the\n   transaction, including the cost of the tx data\n-  ``creates`` - if the transaction creates a contract, returns the\n   contract address\n-  ``nonce``, ``gasprice``, ``startgas``, ``to``, ``value``, ``data``,\n   ``v``, ``r``, ``s`` - parameters in the transaction\n\nethereum.tools.keys\n~~~~~~~~~~~~~~~~~~~\n\nCreates encrypted private key storaes\n\n-  ``decode_keystore_json(jsondata, password)`` - returns the private\n   key from an encrypted keystore object. NOTE: if you are loading from\n   a file, the most convenient way to do this is\n   ``import json; key = decode_keystore_json(json.load(open('filename.json')), 'password')``\n-  ``make_keystore_json(key, pw, kdf='pbkdf2', cipher='aes-128-ctr')`` -\n   creates an encrypted keystore object for the key. Keeping ``kdf`` and\n   ``cipher`` at their default values is recommended.\n\nethereum.abi\n~~~~~~~~~~~~\n\nMost compilers for HLLs (solidity, serpent, viper, etc) on top of\nEthereum have the option to output an ABI declaration for a program.\nThis is a json object that looks something like this:\n\n::\n\n    [{\"name\": \"ecrecover(uint256,uint256,uint256,uint256)\", \"type\": \"function\", \"constant\": false,\n     \"inputs\": [{\"name\": \"h\", \"type\": \"uint256\"}, {\"name\": \"v\", \"type\": \"uint256\"}, {\"name\": \"r\", \"type\": \"uint256\"}, {\"name\": \"s\", \"type\": \"uint256\"}],\n     \"outputs\": [{\"name\": \"out\", \"type\": \"int256[]\"}]},\n     {\"name\": \"PubkeyTripleLogEvent(uint256,uint256,uint256)\", \"type\": \"event\",\n     \"inputs\": [{\"name\": \"x\", \"type\": \"uint256\", \"indexed\": false}, {\"name\": \"y\", \"type\": \"uint256\", \"indexed\": false}, {\"name\": \"z\", \"type\": \"uint256\", \"indexed\": false}]}]\n\nYou can initialize an ``abi.ContractTranslator`` object to encode and\ndecode data for contracts as follows:\n\n::\n\n    true, false = True, False  \n    ct = abi.ContractTranslator(<json here>)  \n    txdata = ct.encode('function_name', [arg1, arg2, arg3])  \n\nYou can also call ``ct.decode_event([topic1, topic2...], logdata)`` to\ndecode a log.\n\nRLP encoding and decoding\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor any transaction or block, you can simply do:\n\n::\n\n    import rlp  \n    bindata = rlp.encode(<tx or block>)  \n\nTo decode:\n\n::\n\n    import rlp  \n    from ethereum.transactions import Transaction  \n    rlp.decode(blob, Transaction)  \n\nOr:\n\n::\n\n    import rlp  \n    from ethereum.blocks import Block  \n    rlp.decode(blob, Block)  \n\nConsensus abstraction\n~~~~~~~~~~~~~~~~~~~~~\n\nThe pyethereum codebase is designed to be maximally friendly for use\nacross many different consensus algorithms. If you want to add a new\nconsensus algo, you'll need to take the following steps:\n\n-  Add a directory alongside ``pow``, and in it create a ``chain.py``\n   class that implements a ``Chain`` module. This may have a totally\n   different fork choice rule for proof of work (GHOST, signature\n   counting, Casper, etc).\n-  Add an entry to ``consensus_strategy.py``. You will need to\n   implement:\n\n   -  ``check_seal`` - check that a block is correctly \"sealed\" (mined,\n      signed, etc)\n   -  ``validate_uncles(state, block)`` - check that uncles are valid\n   -  ``initialize(state, block)`` - called in ``apply_block`` before\n      transactions are processed\n   -  ``finalize(state, block)`` - called in ``apply_block`` after\n      transactions are processed\n   -  ``get_uncle_candidates(chain, state)`` - called in\n      ``mk_head_candidate`` to include uncles in a block\n\n-  Create a chain config with the ``CONSENSUS_STRATEGY`` set to whatever\n   you named your new consensus strategy\n\nTester module\n-------------\n\nSee https://github.com/ethereum/pyethereum/wiki/Using-pyethereum.tester\n\nTests\n-----\n\nRun ``python3.6 -m pytest ethereum/tests/<filename>`` for any .py file\nin that directory. Currently all tests are passing except for a few\nMetropolis-specific state tests and block tests.\n\nTo make your own state tests, use the tester module as follows:\n\n::\n\n    from ethereum.tools import tester as t  \n    import json  \n    c = t.Chain()  \n    x = c.contract(<code>, language=<language>)  \n    pre = t.mk_state_test_prefill(c)  \n    x.foo(<args>)  \n    post = t.mk_state_test_postfill(c, pre)  \n    open('output.json', 'w').write(json.dumps(post, indent=4))  \n\nTo make a test filler file instead, do\n``post = t.mk_state_test_postfill(c, pre, True)``.\n\nLicense\n-------\n\nSee `LICENSE <LICENSE>`_\n\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/AugurProject/pyethereum", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "ethereum-augur-temp2", "package_url": "https://pypi.org/project/ethereum-augur-temp2/", "platform": "", "project_url": "https://pypi.org/project/ethereum-augur-temp2/", "project_urls": {"Homepage": "https://github.com/AugurProject/pyethereum"}, "release_url": "https://pypi.org/project/ethereum-augur-temp2/2.0.6/", "requires_dist": ["PyYAML", "pbkdf2", "py-ecc", "pyethash", "pysha3 (>=1.0.1)", "repoze.lru", "rlp (>=0.4.7)", "scrypt"], "requires_python": "", "summary": "Next generation cryptocurrency network", "version": "2.0.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This is the Python core library of the Ethereum project.</p>\n<p>For the python based command line client see:\n<a href=\"https://github.com/ethereum/pyethapp\" rel=\"nofollow\">https://github.com/ethereum/pyethapp</a></p>\n<div id=\"installation\">\n<h2>Installation:</h2>\n<p><tt>sudo <span class=\"pre\">apt-get</span> install <span class=\"pre\">libssl-dev</span> <span class=\"pre\">build-essential</span> automake <span class=\"pre\">pkg-config</span> libtool <span class=\"pre\">libffi-dev</span> <span class=\"pre\">libgmp-dev</span></tt></p>\n<p><tt>git clone <span class=\"pre\">https://github.com/ethereum/pyethereum/</span></tt></p>\n<p><tt>cd pyethereum</tt></p>\n<p><tt>python setup.py install</tt></p>\n</div>\n<div id=\"components\">\n<h2>Components</h2>\n<div id=\"ethereum-pow-chain\">\n<h3>ethereum.pow.chain</h3>\n<p>Contains the Chain class, which can be used to manage a blockchain. Main\nmethods are:</p>\n<ul>\n<li><tt>__init__(genesis=None, env=None, new_head_cb=None, reset_genesis=False, localtime=None)</tt>\n- initializes with the given genesis. <tt>env</tt> specifies the\n<em>environment</em> (including chain config and database), <tt>new_head_cb</tt>\nis a callback called when a new head is added, and <tt>localtime</tt> is\nwhat the chain assumes is the current timestamp. The genesis can be:<ul>\n<li>None - in which case it assumes <tt>env</tt> is given, and creates a\nChain object with the data saved in <tt>env.db</tt>. If\n<tt>reset_genesis</tt> is set, it re-initializes the chain.</li>\n<li>A <tt>State</tt> object</li>\n<li>A genesis declaration</li>\n<li>A state snapshot (<tt>State.snapshot()</tt>)</li>\n<li>An allocation (ie. dict\n<tt>{address: {balance: 1, nonce: 2, code: <span class=\"pre\">b'\\x03\\x04\\x05',</span> storage: {\"0x06\": <span class=\"pre\">\"0x07\"}}}</span></tt>)</li>\n</ul>\n</li>\n<li><tt>add_block(block)</tt> - adds a block to the chain</li>\n<li><tt>process_time_queue(timestamp)</tt> - tells the chain that the current\ntime has increased to the new timestamp. The chain will then process\nany blocks that were unprocessed because they appeared too \u201cearly\u201d</li>\n<li><tt>get_blockhash_by_number(num)</tt> - get the block hash of a block at\nthe given block number</li>\n<li><tt>get_block(hash)</tt> - gets the block with the given blockhash</li>\n<li><tt>get_block_by_number(num)</tt> - equivalent to\n<tt>get_block(get_blockhash_by_number(num))</tt></li>\n<li><tt>get_parent(block)</tt> - gets the parent of a block</li>\n<li><tt>get_children(block)</tt> - gets the children of a block</li>\n<li><tt>head</tt> (property) - gets the block at the head of the chain</li>\n<li><tt>state</tt> (property) - gets the state at the head of the chain</li>\n<li><tt>mk_poststate_of_blockhash(hash)</tt> - creates a state object after a\ngiven block</li>\n<li><tt>has_block(block)</tt> - is that block in the chain? Returns True/False</li>\n<li><tt>get_chain(from, to)</tt> - roughly equivalent to\n<tt>[get_block_by_number(i) for i in range(from, to)]</tt>, though\nautomatically stops if it reaches the head. <tt>from</tt> can be elided to\nstart from genesis, <tt>to</tt> can be elided to go up to the head.</li>\n<li><tt>get_tx_position(tx)</tt> - if the transaction is in the chain, returns\n<tt>(blknum, index)</tt> where <tt>blknum</tt> is the block number of the block\nthat contains the transaction and <tt>index</tt> is its position in the\nblock</li>\n</ul>\n</div>\n<div id=\"ethereum-state\">\n<h3>ethereum.state</h3>\n<p>Contains the State class, which is used to manage a state. Main methods\nare:</p>\n<ul>\n<li><tt>__init__(root_hash, env, **kwargs)</tt> - initializes a state with the\ngiven root hash, the given env (which includes a config and database)\nand the given auxiliary arguments. These include:<ul>\n<li><tt>txindex</tt> - the transaction index</li>\n<li><tt>gas_used</tt> - amount of gas used</li>\n<li><tt>gas_limit</tt> - block gas limit</li>\n<li><tt>block_number</tt> - block number</li>\n<li><tt>block_coinbase</tt> - block coinbase address</li>\n<li><tt>block_difficulty</tt> - block difficulty</li>\n<li><tt>timestamp</tt> - timestamp</li>\n<li><tt>logs</tt> - logs created so far</li>\n<li><tt>receipts</tt> - receipts created so far (from previous transactions\nin the current block)</li>\n<li><tt>bloom</tt> - the bloom filter</li>\n<li><tt>suicides</tt> - suicides (or selfdestructs, the newer more\npolitically correct synonym)</li>\n<li><tt>recent_uncles</tt> - recent uncle blocks in the chain</li>\n<li><tt>prev_headers</tt> - previous block headers</li>\n<li><tt>refunds</tt> - suicide/selfdestruct refund counter</li>\n</ul>\n</li>\n</ul>\n<p>Pyethereum follows a <strong>maximally state-centric model</strong>; the ONLY\ninformation needed to process a transaction or a block is located within\nthe state itself, allowing the actual state transition logic to be a\nvery clean <tt>apply_transaction(state, tx)</tt> and\n<tt>apply_block(state, block)</tt>.</p>\n<ul>\n<li><tt>get_balance</tt>- gets the balance of an account</li>\n<li><tt>get_code</tt> - gets the code of an account</li>\n<li><tt>get_storage_data(addr, k)</tt> - gets the storage at the given key of\nthe given address. Expects a key in <strong>numerical</strong> form (eg. b\u201dcow\u201d or\n\u201c0x636f77\u201d is represented as 6516599).</li>\n<li><tt>to_snapshot(root_only=False, no_prevblocks=False)</tt> - creates a\nsnapshot for the current state. If <tt>root_only</tt> is set, only adds\nthe state root, not the entire state. If <tt>no_prevblocks</tt> is set,\ndoes not add previous headers and uncles. Setting either of those\nflags means that the same database would be required to recover from\nthe snapshot.</li>\n<li><tt>from_snapshot(snapshot, env)</tt> (classmethod) - creates a state from\nthe given snapshot with the given <tt>env</tt>.</li>\n<li><tt>ephemeral_clone()</tt> - creates a clone of the state that you can\nwork with without affecting the original</li>\n</ul>\n<p>There are also many methods that modify the state, eg. <tt>set_code</tt>,\n<tt>set_storage_data</tt>, but it is generally recommended to avoid using\nthese, and instead modify the state ONLY through <tt>apply_transaction</tt>\nand <tt>apply_block</tt>.</p>\n</div>\n<div id=\"ethereum-meta\">\n<h3>ethereum.meta</h3>\n<p>This file contains two functions:</p>\n<ul>\n<li><tt>apply_block(state, block)</tt> - takes a state and processes a block\nonto that state</li>\n<li><tt>make_head_candidate(chain, txqueue=None, parent=None, timestamp, coinbase, extra_data, min_gasprice=0)</tt>\n- creates a candidate block for the chain on top of the given parent\nblock (default: head of the chain). Gets transactions from the given\n<tt>txqueue</tt> object with the given <tt>mingasprice</tt> (otherwise does not\nadd transactions). <tt>timestamp</tt>, <tt>coinbase</tt> and <tt>extra_data</tt> can\nbe used to specify those parameters in the block; otherwise defaults\nare used</li>\n</ul>\n</div>\n<div id=\"ethereum-messages\">\n<h3>ethereum.messages</h3>\n<p>The main function that should be called from here is\n<tt>apply_transaction(state, tx)</tt>.</p>\n</div>\n<div id=\"ethereum-utils\">\n<h3>ethereum.utils</h3>\n<p>Contains a bunch of utility functions, including:</p>\n<div id=\"numerical-and-hex-conversions\">\n<h4>Numerical and hex conversions</h4>\n<ul>\n<li><tt>encode_int(i)</tt> - converts an integer into big-endian binary\nrepresentation</li>\n<li><tt>zpad(data, length)</tt> - pads the data up to the desired length by\nadding zero bytes on the left</li>\n<li><tt>encode_int32(i)</tt> - equivalent to <tt>zpad(encode_int(i), 32)</tt> but\nfaster</li>\n<li><tt>big_endian_to_int(d)</tt> - converts binary data into an integer</li>\n<li><tt>encode_hex(b)</tt> - converts bytes to hex</li>\n<li><tt>decode_hex(h)</tt> - converts hex to bytes</li>\n<li><tt>int_to_addr(i)</tt> - converts integer to address</li>\n<li><tt>is_numeric(i)</tt> - returns True if the value is int or long,\notherwise False</li>\n</ul>\n</div>\n<div id=\"cryptography\">\n<h4>Cryptography</h4>\n<ul>\n<li><tt>sha3(data)</tt> - computes the SHA3 (or more precisely, keccak256)\nhash</li>\n<li><tt>ecrecover_to_pub(hash, v, r, s)</tt> - recovers the public key that\nmade the signature as a 64-byte binary blob of\n<tt>encode_int32(x) + encode_int32(y)</tt>. Hashing this and taking the\nlast 20 bytes gives the <em>address</em> that signed a message.</li>\n<li><tt>ecsign(hash, key)</tt> - returns the v, r, s values of a signature</li>\n<li><tt>normalize_key(key)</tt> - converts a key from many formats into\n32-byte binary</li>\n<li><tt>privtoaddr(key)</tt> - converts a key to an address</li>\n</ul>\n</div>\n<div id=\"addresses\">\n<h4>Addresses</h4>\n<ul>\n<li><tt>normalize_address(addr)</tt> - converts an address into 20-byte binary\nform</li>\n<li><tt>check_checksum(addr)</tt> - returns True if the address checksum\npasses, otherwise False</li>\n<li><tt>checksum_encode(addr)</tt> - converts an address into hex form with a\nchecksum</li>\n<li><tt>mk_contract_address(addr, nonce)</tt> - creates the address of a\ncontract created by the given address with the given nonce</li>\n</ul>\n</div>\n<div id=\"miscellaneous\">\n<h4>Miscellaneous</h4>\n<ul>\n<li><tt>denoms</tt> - contains the denominations of ether, eg.\n<tt>denoms.finney = <span class=\"pre\">10**15</span></tt>, <tt>denoms.shannon = <span class=\"pre\">10**9</span></tt>,\n<tt>denoms.gwei = <span class=\"pre\">10**9</span></tt></li>\n</ul>\n</div>\n</div>\n<div id=\"ethereum-block\">\n<h3>ethereum.block</h3>\n<p>Contains the <tt>Block</tt> and <tt>BlockHeader</tt> classes. Generally\nrecommended to avoid creating blocks and block headers directly, instead\nusing <tt>mk_head_candidate</tt>. The member variables are straightforward:</p>\n<ul>\n<li><tt>block.transactions</tt> - transactions in a block</li>\n<li><tt>block.uncles</tt> - uncles in a block</li>\n<li><tt>block.header</tt> - header of a block</li>\n</ul>\n<p>And in the header:</p>\n<ul>\n<li><tt>header.hash</tt> - the hash (also the block hash)</li>\n<li><tt>header.mining_hash</tt> - the hash used for proof of work mining</li>\n<li><tt>header.to_dict()</tt> - serializes into a human-readable dict</li>\n<li><tt>header.prevhash</tt> - previous block hash</li>\n<li><tt>header.uncles_hash</tt> - hash of the uncle list</li>\n<li><tt>header.coinbase</tt> - coinbase (miner) address</li>\n<li><tt>header.state_root</tt> - root hash of the post-state</li>\n<li><tt>header.tx_list_root</tt> - hash of the transactions in the block</li>\n<li><tt>header.receipts_root</tt> - hash of the receipt trie</li>\n<li><tt>header.bloom</tt> - bloom filter</li>\n<li><tt>header.difficulty</tt> - block difficulty</li>\n<li><tt>header.number</tt> - block number</li>\n<li><tt>header.gas_limit</tt> - gas limit</li>\n<li><tt>header.gas_used</tt> - gas used</li>\n<li><tt>header.timestamp</tt> - timestamp</li>\n<li><tt>header.extra_data</tt> - block extra data</li>\n<li><tt>header.mixhash</tt> and <tt>header.nonce</tt> - Ethash proof of work values</li>\n</ul>\n</div>\n<div id=\"ethereum-transactions\">\n<h3>ethereum.transactions</h3>\n<p>Contains the Transaction class, with the following methods and values:</p>\n<ul>\n<li><tt>__init__(nonce, gasprice, startgas, to, value, data, (v, r, s optional))</tt>\n- constructor</li>\n<li><tt>sign(key, network_id=None)</tt> - signs the transaction with the given\nkey, and with the given EIP155 chain ID (leaving as None will create\na pre-EIP155 tx, be warned of replay attacks if you do this!)</li>\n<li><tt>sender</tt> - the sender address of the transaction</li>\n<li><tt>network_id</tt> - the EIP155 chain ID of the transaction</li>\n<li><tt>hash</tt> - the hash of the transaction</li>\n<li><tt>to_dict()</tt> - serializes into a human-readable dict</li>\n<li><tt>intrinsic_gas_used</tt> - the amount of gas consumed by the\ntransaction, including the cost of the tx data</li>\n<li><tt>creates</tt> - if the transaction creates a contract, returns the\ncontract address</li>\n<li><tt>nonce</tt>, <tt>gasprice</tt>, <tt>startgas</tt>, <tt>to</tt>, <tt>value</tt>, <tt>data</tt>,\n<tt>v</tt>, <tt>r</tt>, <tt>s</tt> - parameters in the transaction</li>\n</ul>\n</div>\n<div id=\"ethereum-tools-keys\">\n<h3>ethereum.tools.keys</h3>\n<p>Creates encrypted private key storaes</p>\n<ul>\n<li><tt>decode_keystore_json(jsondata, password)</tt> - returns the private\nkey from an encrypted keystore object. NOTE: if you are loading from\na file, the most convenient way to do this is\n<tt>import json; key = <span class=\"pre\">decode_keystore_json(json.load(open('filename.json')),</span> 'password')</tt></li>\n<li><tt>make_keystore_json(key, pw, <span class=\"pre\">kdf='pbkdf2',</span> <span class=\"pre\">cipher='aes-128-ctr')</span></tt> -\ncreates an encrypted keystore object for the key. Keeping <tt>kdf</tt> and\n<tt>cipher</tt> at their default values is recommended.</li>\n</ul>\n</div>\n<div id=\"ethereum-abi\">\n<h3>ethereum.abi</h3>\n<p>Most compilers for HLLs (solidity, serpent, viper, etc) on top of\nEthereum have the option to output an ABI declaration for a program.\nThis is a json object that looks something like this:</p>\n<pre>[{\"name\": \"ecrecover(uint256,uint256,uint256,uint256)\", \"type\": \"function\", \"constant\": false,\n \"inputs\": [{\"name\": \"h\", \"type\": \"uint256\"}, {\"name\": \"v\", \"type\": \"uint256\"}, {\"name\": \"r\", \"type\": \"uint256\"}, {\"name\": \"s\", \"type\": \"uint256\"}],\n \"outputs\": [{\"name\": \"out\", \"type\": \"int256[]\"}]},\n {\"name\": \"PubkeyTripleLogEvent(uint256,uint256,uint256)\", \"type\": \"event\",\n \"inputs\": [{\"name\": \"x\", \"type\": \"uint256\", \"indexed\": false}, {\"name\": \"y\", \"type\": \"uint256\", \"indexed\": false}, {\"name\": \"z\", \"type\": \"uint256\", \"indexed\": false}]}]\n</pre>\n<p>You can initialize an <tt>abi.ContractTranslator</tt> object to encode and\ndecode data for contracts as follows:</p>\n<pre>true, false = True, False\nct = abi.ContractTranslator(&lt;json here&gt;)\ntxdata = ct.encode('function_name', [arg1, arg2, arg3])\n</pre>\n<p>You can also call <tt><span class=\"pre\">ct.decode_event([topic1,</span> <span class=\"pre\">topic2...],</span> logdata)</tt> to\ndecode a log.</p>\n</div>\n<div id=\"rlp-encoding-and-decoding\">\n<h3>RLP encoding and decoding</h3>\n<p>For any transaction or block, you can simply do:</p>\n<pre>import rlp\nbindata = rlp.encode(&lt;tx or block&gt;)\n</pre>\n<p>To decode:</p>\n<pre>import rlp\nfrom ethereum.transactions import Transaction\nrlp.decode(blob, Transaction)\n</pre>\n<p>Or:</p>\n<pre>import rlp\nfrom ethereum.blocks import Block\nrlp.decode(blob, Block)\n</pre>\n</div>\n<div id=\"consensus-abstraction\">\n<h3>Consensus abstraction</h3>\n<p>The pyethereum codebase is designed to be maximally friendly for use\nacross many different consensus algorithms. If you want to add a new\nconsensus algo, you\u2019ll need to take the following steps:</p>\n<ul>\n<li>Add a directory alongside <tt>pow</tt>, and in it create a <tt>chain.py</tt>\nclass that implements a <tt>Chain</tt> module. This may have a totally\ndifferent fork choice rule for proof of work (GHOST, signature\ncounting, Casper, etc).</li>\n<li>Add an entry to <tt>consensus_strategy.py</tt>. You will need to\nimplement:<ul>\n<li><tt>check_seal</tt> - check that a block is correctly \u201csealed\u201d (mined,\nsigned, etc)</li>\n<li><tt>validate_uncles(state, block)</tt> - check that uncles are valid</li>\n<li><tt>initialize(state, block)</tt> - called in <tt>apply_block</tt> before\ntransactions are processed</li>\n<li><tt>finalize(state, block)</tt> - called in <tt>apply_block</tt> after\ntransactions are processed</li>\n<li><tt>get_uncle_candidates(chain, state)</tt> - called in\n<tt>mk_head_candidate</tt> to include uncles in a block</li>\n</ul>\n</li>\n<li>Create a chain config with the <tt>CONSENSUS_STRATEGY</tt> set to whatever\nyou named your new consensus strategy</li>\n</ul>\n</div>\n</div>\n<div id=\"tester-module\">\n<h2>Tester module</h2>\n<p>See <a href=\"https://github.com/ethereum/pyethereum/wiki/Using-pyethereum.tester\" rel=\"nofollow\">https://github.com/ethereum/pyethereum/wiki/Using-pyethereum.tester</a></p>\n</div>\n<div id=\"tests\">\n<h2>Tests</h2>\n<p>Run <tt>python3.6 <span class=\"pre\">-m</span> pytest <span class=\"pre\">ethereum/tests/&lt;filename&gt;</span></tt> for any .py file\nin that directory. Currently all tests are passing except for a few\nMetropolis-specific state tests and block tests.</p>\n<p>To make your own state tests, use the tester module as follows:</p>\n<pre>from ethereum.tools import tester as t\nimport json\nc = t.Chain()\nx = c.contract(&lt;code&gt;, language=&lt;language&gt;)\npre = t.mk_state_test_prefill(c)\nx.foo(&lt;args&gt;)\npost = t.mk_state_test_postfill(c, pre)\nopen('output.json', 'w').write(json.dumps(post, indent=4))\n</pre>\n<p>To make a test filler file instead, do\n<tt>post = t.mk_state_test_postfill(c, pre, True)</tt>.</p>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>See <a href=\"LICENSE\" rel=\"nofollow\">LICENSE</a></p>\n</div>\n\n          </div>"}, "last_serial": 3215970, "releases": {"2.0.4": [], "2.0.5": [{"comment_text": "", "digests": {"md5": "0d0d3db39493d2cea610834a8a578223", "sha256": "c2c5bd00cf9a5f34d31c44c3adf9aea15cf452e45fb4928c22795125bd55c7b6"}, "downloads": -1, "filename": "ethereum_augur_temp2-2.0.5-py2-none-any.whl", "has_sig": false, "md5_digest": "0d0d3db39493d2cea610834a8a578223", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 166207, "upload_time": "2017-10-01T03:48:59", "upload_time_iso_8601": "2017-10-01T03:48:59.530108Z", "url": "https://files.pythonhosted.org/packages/52/1f/81279e9a83504fe31f5f4db4768b9d939a449bbf06ba631dbda39d2868a9/ethereum_augur_temp2-2.0.5-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c2a7bec3f0499e1ed66932a285eb3edf", "sha256": "02778f630338973a6a69781dd575c4601b8d9b1d6f48716852baea778237c23b"}, "downloads": -1, "filename": "ethereum-augur-temp2-2.0.5.tar.gz", "has_sig": false, "md5_digest": "c2a7bec3f0499e1ed66932a285eb3edf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 138800, "upload_time": "2017-10-01T03:49:04", "upload_time_iso_8601": "2017-10-01T03:49:04.081892Z", "url": "https://files.pythonhosted.org/packages/4c/64/1319b82f1c416fc966938db4c6324b9c166d4f3a2dec72ccf010738690a0/ethereum-augur-temp2-2.0.5.tar.gz", "yanked": false}], "2.0.6": [{"comment_text": "", "digests": {"md5": "0f9c43b33ca978812209d4814e6ba069", "sha256": "9727d35f73f5a1fc937502d5865aa005527019cc3cd5db298c138b749fae9d24"}, "downloads": -1, "filename": "ethereum_augur_temp2-2.0.6-py2-none-any.whl", "has_sig": false, "md5_digest": "0f9c43b33ca978812209d4814e6ba069", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 166208, "upload_time": "2017-10-01T03:51:10", "upload_time_iso_8601": "2017-10-01T03:51:10.322755Z", "url": "https://files.pythonhosted.org/packages/a4/05/f3acc4e2fb12277f638fbc7dcff34ecefe9fd063725915b791f4f595dfeb/ethereum_augur_temp2-2.0.6-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "806415822d2baa7894665f13fc6fc2b3", "sha256": "20cda765d2ee0223c11c9a398fe4018b5cd53f7ea29d907256a5516a13a28794"}, "downloads": -1, "filename": "ethereum-augur-temp2-2.0.6.tar.gz", "has_sig": false, "md5_digest": "806415822d2baa7894665f13fc6fc2b3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 138806, "upload_time": "2017-10-01T03:51:13", "upload_time_iso_8601": "2017-10-01T03:51:13.613646Z", "url": "https://files.pythonhosted.org/packages/50/5e/b32bf03235ce27b48b356ed5791a359161e4eb8ebc271ce4a3625d53dd99/ethereum-augur-temp2-2.0.6.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0f9c43b33ca978812209d4814e6ba069", "sha256": "9727d35f73f5a1fc937502d5865aa005527019cc3cd5db298c138b749fae9d24"}, "downloads": -1, "filename": "ethereum_augur_temp2-2.0.6-py2-none-any.whl", "has_sig": false, "md5_digest": "0f9c43b33ca978812209d4814e6ba069", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 166208, "upload_time": "2017-10-01T03:51:10", "upload_time_iso_8601": "2017-10-01T03:51:10.322755Z", "url": "https://files.pythonhosted.org/packages/a4/05/f3acc4e2fb12277f638fbc7dcff34ecefe9fd063725915b791f4f595dfeb/ethereum_augur_temp2-2.0.6-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "806415822d2baa7894665f13fc6fc2b3", "sha256": "20cda765d2ee0223c11c9a398fe4018b5cd53f7ea29d907256a5516a13a28794"}, "downloads": -1, "filename": "ethereum-augur-temp2-2.0.6.tar.gz", "has_sig": false, "md5_digest": "806415822d2baa7894665f13fc6fc2b3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 138806, "upload_time": "2017-10-01T03:51:13", "upload_time_iso_8601": "2017-10-01T03:51:13.613646Z", "url": "https://files.pythonhosted.org/packages/50/5e/b32bf03235ce27b48b356ed5791a359161e4eb8ebc271ce4a3625d53dd99/ethereum-augur-temp2-2.0.6.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:45:29 2020"}