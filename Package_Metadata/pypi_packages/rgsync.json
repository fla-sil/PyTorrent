{"info": {"author": "RedisLabs", "author_email": "oss@redislabs.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3.7", "Topic :: Database"], "description": "[![license](https://img.shields.io/github/license/RedisGears/rgsync.svg)](https://github.com/RedisGears/rgsync)\n[![CircleCI](https://circleci.com/gh/RedisGears/rgsync/tree/master.svg?style=svg)](https://circleci.com/gh/RedisGears/rgsync/tree/master)\n[![PyPI version](https://badge.fury.io/py/rgsync.svg)](https://badge.fury.io/py/rgsync)\n[![Known Vulnerabilities](https://snyk.io/test/github/RedisGears/rgsync/badge.svg?targetFile=requirements.txt)](https://snyk.io/test/github/RedisGears/rgsync?targetFile=requirements.txt)\n\n# RGSync\n[![Forum](https://img.shields.io/badge/Forum-RedisGears-blue)](https://forum.redislabs.com/c/modules/redisgears)\n[![Gitter](https://badges.gitter.im/RedisLabs/RedisGears.svg)](https://gitter.im/RedisLabs/RedisGears?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\n\nA _Write Behind_ and _Write Through_ Recipe for [RedisGears](https://github.com/RedisGears/RedisGears)\n\n## Demo\n![WriteBehind demo](demo/WriteBehindDemo.gif)\n\n## Example\nThe following is a RedisGears recipe that shows how to use the _Write Behind_ pattern to map data from Redis Hashes to MySQL tables. The recipe maps all Redis Hashes with the prefix `person:<id>` to the MySQL table `persons`, with `<id>` being the primary key and mapped to the `person_id` column. Similarly, it maps all Hashes with the prefix `car:<id>` to the `cars` table.\n\n```python\nfrom rgsync import RGWriteBehind\nfrom rgsync.Connectors import MySqlConnector, MySqlConnection\n\n'''\nCreate MySQL connection object\n'''\nconnection = MySqlConnection('demouser', 'Password123!', 'localhost:3306/test')\n\n'''\nCreate MySQL persons connector\npersons - MySQL table to put the data\nperson_id - primary key\n'''\npersonConnector = MySqlConnector(mySqlConnection, 'persons', 'person_id')\n\npersonsMappings = {\n\t'first_name':'first',\n\t'last_name':'last',\n\t'age':'age'\n}\n\nRGWriteBehind(GB, keysPrefix='person', mappings=personsMappings, connector=personsConnector, name='PersonsWriteBehind', version='99.99.99')\n\n'''\nCreate MySQL car connector\ncars - MySQL table to put the data\ncar_id - primary key\n'''\ncarConnector = MySqlConnector(connection, 'cars', 'car_id')\n\ncarsMappings = {\n\t'id':'id',\n\t'color':'color'\n}\n\nRGWriteBehind(GB, keysPrefix='cars', mappings=carsMappings, connector=carsConnector, name='CarsWriteBehind', version='99.99.99')\n```\n\n## Running the recipe\nYou can use [this utility](https://github.com/RedisGears/gears-cli) to send a RedisGears recipe for execution. For example, run this repository's [example.py recipe](example.py) and install its dependencies with the following command:\n\n```bash\ngears-cli --host <host> --port <post> --password <password> example.py REQUIREMENTS git+https://github.com/RedisGears/rgsync.git PyMySQL\n```\n\n## Overview of the recipe's operation\nThe [`RGWriteBehind()` class](rgsync/redis_gears_write_behind.py) implements the _Write Behind_ recipe, that mainly consists of two RedisGears functions and operates as follows:\n1. A write operation to a Redis Hash key triggers the execution of a RedisGears function.\n1. That RedisGears function reads the data from the Hash and writes into a Redis Stream.\n1. Another RedisGears function is executed asynchronously in the background and writes the changes to the target database.\n\n### The motivation for using a Redis Stream\nThe use of a Redis Stream in the _Write Behind_ recipe implementation is to ensure the persistence of captured changes while mitigating the performance penalty associated with shipping them to the target database.\n\nThe recipe's first RedisGears function is registered to run synchronously, which means that the function runs in the same main Redis thread in which the command was executed. This mode of execution is needed so changes events are recorded in order and to eliminate the possibility of losing events in case of failure.\n\nApplying the changes to the target database is usually much slower, effectively excluding the possibility of doing that in the main thread. The second RedisGears function is executed asynchronously on batches and in intervals to do that.\n\nThe Redis Stream is the channel through which both of the recipe's parts communicate, where the changes are persisted in order synchronously and are later processed in the background asynchronously.\n\n## Controlling what gets replicated\nSometimes you want to modify the data in Redis without replicating it to the target. For that purpose, the recipe can be customized by adding the special field `#` to your Hash's fields and setting it to one of these values:\n* `+` - Adds the data but does not replicate it to the target\n* `=` - Adds the data with and replicates it (the default behavior)\n* `-` - Deletes the data but does not replicate\n* `~` - Deletes the data from Redis and the target (the default behavior when using `del` command)\n\nWhen the Hash's value contains the `#` field, the recipe will act according to its value and will delete the `#` field from the Hash afterward. For example, the following shows how to delete a Hash without replicating the delete operation:\n\n```\nredis> HSET person:1 # -\n```\n\nAlternatively, to add a Hash without having it replicated:\n```\nredis> HSET person:007 first_name James last_name Bond age 42 # +\n```\n\n## At Least Once and Exactly Once semantics\nBy default the _Write Behind_ recipe provides the _At Least Once_ property for writes, meaning that data will be written once to the target, but possibly more than that in cases of failure.\n\nIt is possible to have the recipe provide _Exactly Once_ delivery semantics by using the Stream's message ID as an increasing ID of the operations. The writer RedisGears function can use that ID and record it in another table in the target to ensure that any given ID is only be written once.\n\nAll of the recipe's SQL connectors support this capability. To use it, you need to provide the connector with the name of the \"exactly once\" table. This table should contain 2 columns, the `id` which represents some unique ID of the writer (used to distinguish between shards for example) and `val` which is the last Stream ID written to the target. The \"exactly once\" table's name can be specified to the connector in the constructor via the optional `exactlyOnceTableName` variable.\n\n## Getting write acknowledgment\nIt is possible to use the recipe and get an acknowledgment of successful writes to the target. Follow these steps to do so:\n1. For each data-changing operation generate a `uuid`.\n2. Add the operation's `uuid` immediately after the value in the special `#` field, that is after the `+`/`=`/`-`/`~` character. Enabling write acknowledgment requires the use of the special `#`.\n3. After performing the operation, perform an `XREAD BLOCK <timeout> STREAMS {<hash key>}<uuid> 0-0`. Once the recipe has written to the target, it will create a message in that (`{<hash key>}<uuid>`) Stream that has a single field named 'status' with the value 'done'.\n4. For housekeeping purposes, it is recommended to delete that Stream after getting the acknowledgment. This is not a must, however, as these Streams are created with TTL of one hour.\n\n### Acknowledgment example\n```\n127.0.0.1:6379> hset person:007 first_name James last_name Bond age 42 # =6ce0c902-30c2-4ac9-8342-2f04fb359a94\n(integer) 1\n127.0.0.1:6379> XREAD BLOCK 2000 STREAMS {person:1}6ce0c902-30c2-4ac9-8342-2f04fb359a94 0-0\n1) 1) \"{person:1}6ce0c902-30c2-4ac9-8342-2f04fb359a94\"\n   2) 1) 1) \"1581927201056-0\"\n         2) 1) \"status\"\n            2) \"done\"\n```\n\n## Write Through\n_Write Through_ is done by using a temporary key. The recipe registers to changes of that key and writes them to the target. Writing to the target is executed in the Server's main thread, in synchronous mode, which means that the server will be blocked at that time and the client will not get the reply until it is finished.\n\nWriting the changes to the target may succeed or fail. If successful, the recipe renames the temporary key to its intended final name. A failure will prevent the rename. In either case, the temporary key is deleted.\n\nThe semantics of the acknowledgment Stream remains nearly the same as _Write Behind_. The only change is in the message's structure. Failed writes create a message in that (`{<hash key>}<uuid>`) Stream that has:\n\n  * A 'status' field with the value 'failed'\n  * An 'error' field containing the error's description\n\nNote that when using _Write Through_ it is mandatory to supply a `uuid` and read the acknowledgment Stream. That is the only way to tell whether the write had succeeded.\n\n_Write Through_ is registered using the `RGWriteThrough` class:\n```python\nRGWriteThrough(GB, keysPrefix, mappings, connector, name, version)\n```\n\nThe `keysPrefix` argument is the prefix of the key on which the writes will be triggered. The temporary key's name will be in the following format:\n```\n<keysPrefix>{<realKeyName>}\n```\nUpon success, the key is renamed to `<realKeyName>`.\n\nAny failure in writing to the target will cause the recipe to abort. In such cases, the temporary key is not renamed and is deleted.\n\nNote that in some cases, such as connection failures, it is impossible to tell whether the operation had succeeded or failed on the target. The recipe considers these as failures, although in reality, the write may have succeeded.\n\n### Example\nThese examples assume that the `keysPrefix` is set to \"__\". The first shows a successful write:\n\n```\n127.0.0.1:6379> HSET __{person:1} first_name foo last_name bar age 20 # =6ce0c902-30c2-4ac9-8342-2f04fb359a94\n(integer) 4\n127.0.0.1:6379> XREAD BLOCK 2000 STREAMS {person:1}6ce0c902-30c2-4ac9-8342-2f04fb359a94 0-0\n1) 1) \"{person:1}6ce0c902-30c2-4ac9-8342-2f04fb359a94\"\n   2) 1) 1) \"1583321726502-0\"\n         2) 1) \"status\"\n            2) \"done\"\n127.0.0.1:6379> HGETALL person:1\n1) \"age\"\n2) \"20\"\n3) \"last_name\"\n4) \"bar\"\n5) \"first_name\"\n6) \"foo\"\n```\n\nAn a example of a failed _Write Through_:\n\n```\n127.0.0.1:6379> HSET __{person:1} first_name foo last_name bar age 20 # =6ce0c902-30c2-4ac9-8342-2f04fb359a94\n(integer) 4\n127.0.0.1:6379> XREAD BLOCK 2000 STREAMS {person:1}6ce0c902-30c2-4ac9-8342-2f04fb359a94 0-0\n1) 1) \"{person:1}6ce0c902-30c2-4ac9-8342-2f04fb359a94\"\n   2) 1) 1) \"1583322141455-0\"\n         2) 1) \"status\"\n            2) \"failed\"\n            3) \"error\"\n            4) \"Failed connecting to SQL database, error=\\\"(pymysql.err.OperationalError) (2003, \\\"Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)\\\")\\n(Background on this error at: http://sqlalche.me/e/e3q8)\\\"\"\n\n```\n\n## Data persistence and availability\nTo avoid data loss in Redis and the resulting inconsistencies with the target databases, it is recommended to employ and use this recipe only with a highly-available Redis environment. In such environments, the failure of a master node will cause the replica that replaced it to continue the recipe's execution from the point it was stopped.\n\nFurthermore, Redis' AOF should be used alongside replication to protect against data loss during system-wide failures.\n\n## Monitoring the RedisGears function registrations\nUse [this](https://github.com/RedisGears/RedisGearsMonitor) to monitor RedisGear's function registrations.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/RedisGears/rgsync/", "keywords": "R,e,d,i,s,G,e,a,r,s, ,W,r,i,t,e,B,e,h,i,n,d", "license": "", "maintainer": "", "maintainer_email": "", "name": "rgsync", "package_url": "https://pypi.org/project/rgsync/", "platform": "", "project_url": "https://pypi.org/project/rgsync/", "project_urls": {"Homepage": "https://github.com/RedisGears/rgsync/"}, "release_url": "https://pypi.org/project/rgsync/0.2.0/", "requires_dist": null, "requires_python": "", "summary": "RedisGears synchronization recipe", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://github.com/RedisGears/rgsync\" rel=\"nofollow\"><img alt=\"license\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c8ed5130f5a2cfaa9c9047a584bf72da56b40b86/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f526564697347656172732f726773796e632e737667\"></a>\n<a href=\"https://circleci.com/gh/RedisGears/rgsync/tree/master\" rel=\"nofollow\"><img alt=\"CircleCI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d7c91e113cfbacc69e84d7c01132ca1916244e72/68747470733a2f2f636972636c6563692e636f6d2f67682f526564697347656172732f726773796e632f747265652f6d61737465722e7376673f7374796c653d737667\"></a>\n<a href=\"https://badge.fury.io/py/rgsync\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8ee13d6a9ffa428835c456b94c2b67ecdf4f1efd/68747470733a2f2f62616467652e667572792e696f2f70792f726773796e632e737667\"></a>\n<a href=\"https://snyk.io/test/github/RedisGears/rgsync?targetFile=requirements.txt\" rel=\"nofollow\"><img alt=\"Known Vulnerabilities\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a4966a8d2ac14048d6b70070c71d81e70a56586e/68747470733a2f2f736e796b2e696f2f746573742f6769746875622f526564697347656172732f726773796e632f62616467652e7376673f74617267657446696c653d726571756972656d656e74732e747874\"></a></p>\n<h1>RGSync</h1>\n<p><a href=\"https://forum.redislabs.com/c/modules/redisgears\" rel=\"nofollow\"><img alt=\"Forum\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2656d73003a3d6b07936cd54e3e440ba22631543/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f466f72756d2d526564697347656172732d626c7565\"></a>\n<a href=\"https://gitter.im/RedisLabs/RedisGears?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge\" rel=\"nofollow\"><img alt=\"Gitter\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e52be934d8468526d4b1e78991ab034c69004542/68747470733a2f2f6261646765732e6769747465722e696d2f52656469734c6162732f526564697347656172732e737667\"></a></p>\n<p>A <em>Write Behind</em> and <em>Write Through</em> Recipe for <a href=\"https://github.com/RedisGears/RedisGears\" rel=\"nofollow\">RedisGears</a></p>\n<h2>Demo</h2>\n<p><img alt=\"WriteBehind demo\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7eb5a9638a19447ef06f1f0283b81cf1ad2b1600/64656d6f2f5772697465426568696e6444656d6f2e676966\"></p>\n<h2>Example</h2>\n<p>The following is a RedisGears recipe that shows how to use the <em>Write Behind</em> pattern to map data from Redis Hashes to MySQL tables. The recipe maps all Redis Hashes with the prefix <code>person:&lt;id&gt;</code> to the MySQL table <code>persons</code>, with <code>&lt;id&gt;</code> being the primary key and mapped to the <code>person_id</code> column. Similarly, it maps all Hashes with the prefix <code>car:&lt;id&gt;</code> to the <code>cars</code> table.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">rgsync</span> <span class=\"kn\">import</span> <span class=\"n\">RGWriteBehind</span>\n<span class=\"kn\">from</span> <span class=\"nn\">rgsync.Connectors</span> <span class=\"kn\">import</span> <span class=\"n\">MySqlConnector</span><span class=\"p\">,</span> <span class=\"n\">MySqlConnection</span>\n\n<span class=\"sd\">'''</span>\n<span class=\"sd\">Create MySQL connection object</span>\n<span class=\"sd\">'''</span>\n<span class=\"n\">connection</span> <span class=\"o\">=</span> <span class=\"n\">MySqlConnection</span><span class=\"p\">(</span><span class=\"s1\">'demouser'</span><span class=\"p\">,</span> <span class=\"s1\">'Password123!'</span><span class=\"p\">,</span> <span class=\"s1\">'localhost:3306/test'</span><span class=\"p\">)</span>\n\n<span class=\"sd\">'''</span>\n<span class=\"sd\">Create MySQL persons connector</span>\n<span class=\"sd\">persons - MySQL table to put the data</span>\n<span class=\"sd\">person_id - primary key</span>\n<span class=\"sd\">'''</span>\n<span class=\"n\">personConnector</span> <span class=\"o\">=</span> <span class=\"n\">MySqlConnector</span><span class=\"p\">(</span><span class=\"n\">mySqlConnection</span><span class=\"p\">,</span> <span class=\"s1\">'persons'</span><span class=\"p\">,</span> <span class=\"s1\">'person_id'</span><span class=\"p\">)</span>\n\n<span class=\"n\">personsMappings</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n\t<span class=\"s1\">'first_name'</span><span class=\"p\">:</span><span class=\"s1\">'first'</span><span class=\"p\">,</span>\n\t<span class=\"s1\">'last_name'</span><span class=\"p\">:</span><span class=\"s1\">'last'</span><span class=\"p\">,</span>\n\t<span class=\"s1\">'age'</span><span class=\"p\">:</span><span class=\"s1\">'age'</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">RGWriteBehind</span><span class=\"p\">(</span><span class=\"n\">GB</span><span class=\"p\">,</span> <span class=\"n\">keysPrefix</span><span class=\"o\">=</span><span class=\"s1\">'person'</span><span class=\"p\">,</span> <span class=\"n\">mappings</span><span class=\"o\">=</span><span class=\"n\">personsMappings</span><span class=\"p\">,</span> <span class=\"n\">connector</span><span class=\"o\">=</span><span class=\"n\">personsConnector</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'PersonsWriteBehind'</span><span class=\"p\">,</span> <span class=\"n\">version</span><span class=\"o\">=</span><span class=\"s1\">'99.99.99'</span><span class=\"p\">)</span>\n\n<span class=\"sd\">'''</span>\n<span class=\"sd\">Create MySQL car connector</span>\n<span class=\"sd\">cars - MySQL table to put the data</span>\n<span class=\"sd\">car_id - primary key</span>\n<span class=\"sd\">'''</span>\n<span class=\"n\">carConnector</span> <span class=\"o\">=</span> <span class=\"n\">MySqlConnector</span><span class=\"p\">(</span><span class=\"n\">connection</span><span class=\"p\">,</span> <span class=\"s1\">'cars'</span><span class=\"p\">,</span> <span class=\"s1\">'car_id'</span><span class=\"p\">)</span>\n\n<span class=\"n\">carsMappings</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n\t<span class=\"s1\">'id'</span><span class=\"p\">:</span><span class=\"s1\">'id'</span><span class=\"p\">,</span>\n\t<span class=\"s1\">'color'</span><span class=\"p\">:</span><span class=\"s1\">'color'</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">RGWriteBehind</span><span class=\"p\">(</span><span class=\"n\">GB</span><span class=\"p\">,</span> <span class=\"n\">keysPrefix</span><span class=\"o\">=</span><span class=\"s1\">'cars'</span><span class=\"p\">,</span> <span class=\"n\">mappings</span><span class=\"o\">=</span><span class=\"n\">carsMappings</span><span class=\"p\">,</span> <span class=\"n\">connector</span><span class=\"o\">=</span><span class=\"n\">carsConnector</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'CarsWriteBehind'</span><span class=\"p\">,</span> <span class=\"n\">version</span><span class=\"o\">=</span><span class=\"s1\">'99.99.99'</span><span class=\"p\">)</span>\n</pre>\n<h2>Running the recipe</h2>\n<p>You can use <a href=\"https://github.com/RedisGears/gears-cli\" rel=\"nofollow\">this utility</a> to send a RedisGears recipe for execution. For example, run this repository's <a href=\"example.py\" rel=\"nofollow\">example.py recipe</a> and install its dependencies with the following command:</p>\n<pre>gears-cli --host &lt;host&gt; --port &lt;post&gt; --password &lt;password&gt; example.py REQUIREMENTS git+https://github.com/RedisGears/rgsync.git PyMySQL\n</pre>\n<h2>Overview of the recipe's operation</h2>\n<p>The <a href=\"rgsync/redis_gears_write_behind.py\" rel=\"nofollow\"><code>RGWriteBehind()</code> class</a> implements the <em>Write Behind</em> recipe, that mainly consists of two RedisGears functions and operates as follows:</p>\n<ol>\n<li>A write operation to a Redis Hash key triggers the execution of a RedisGears function.</li>\n<li>That RedisGears function reads the data from the Hash and writes into a Redis Stream.</li>\n<li>Another RedisGears function is executed asynchronously in the background and writes the changes to the target database.</li>\n</ol>\n<h3>The motivation for using a Redis Stream</h3>\n<p>The use of a Redis Stream in the <em>Write Behind</em> recipe implementation is to ensure the persistence of captured changes while mitigating the performance penalty associated with shipping them to the target database.</p>\n<p>The recipe's first RedisGears function is registered to run synchronously, which means that the function runs in the same main Redis thread in which the command was executed. This mode of execution is needed so changes events are recorded in order and to eliminate the possibility of losing events in case of failure.</p>\n<p>Applying the changes to the target database is usually much slower, effectively excluding the possibility of doing that in the main thread. The second RedisGears function is executed asynchronously on batches and in intervals to do that.</p>\n<p>The Redis Stream is the channel through which both of the recipe's parts communicate, where the changes are persisted in order synchronously and are later processed in the background asynchronously.</p>\n<h2>Controlling what gets replicated</h2>\n<p>Sometimes you want to modify the data in Redis without replicating it to the target. For that purpose, the recipe can be customized by adding the special field <code>#</code> to your Hash's fields and setting it to one of these values:</p>\n<ul>\n<li><code>+</code> - Adds the data but does not replicate it to the target</li>\n<li><code>=</code> - Adds the data with and replicates it (the default behavior)</li>\n<li><code>-</code> - Deletes the data but does not replicate</li>\n<li><code>~</code> - Deletes the data from Redis and the target (the default behavior when using <code>del</code> command)</li>\n</ul>\n<p>When the Hash's value contains the <code>#</code> field, the recipe will act according to its value and will delete the <code>#</code> field from the Hash afterward. For example, the following shows how to delete a Hash without replicating the delete operation:</p>\n<pre><code>redis&gt; HSET person:1 # -\n</code></pre>\n<p>Alternatively, to add a Hash without having it replicated:</p>\n<pre><code>redis&gt; HSET person:007 first_name James last_name Bond age 42 # +\n</code></pre>\n<h2>At Least Once and Exactly Once semantics</h2>\n<p>By default the <em>Write Behind</em> recipe provides the <em>At Least Once</em> property for writes, meaning that data will be written once to the target, but possibly more than that in cases of failure.</p>\n<p>It is possible to have the recipe provide <em>Exactly Once</em> delivery semantics by using the Stream's message ID as an increasing ID of the operations. The writer RedisGears function can use that ID and record it in another table in the target to ensure that any given ID is only be written once.</p>\n<p>All of the recipe's SQL connectors support this capability. To use it, you need to provide the connector with the name of the \"exactly once\" table. This table should contain 2 columns, the <code>id</code> which represents some unique ID of the writer (used to distinguish between shards for example) and <code>val</code> which is the last Stream ID written to the target. The \"exactly once\" table's name can be specified to the connector in the constructor via the optional <code>exactlyOnceTableName</code> variable.</p>\n<h2>Getting write acknowledgment</h2>\n<p>It is possible to use the recipe and get an acknowledgment of successful writes to the target. Follow these steps to do so:</p>\n<ol>\n<li>For each data-changing operation generate a <code>uuid</code>.</li>\n<li>Add the operation's <code>uuid</code> immediately after the value in the special <code>#</code> field, that is after the <code>+</code>/<code>=</code>/<code>-</code>/<code>~</code> character. Enabling write acknowledgment requires the use of the special <code>#</code>.</li>\n<li>After performing the operation, perform an <code>XREAD BLOCK &lt;timeout&gt; STREAMS {&lt;hash key&gt;}&lt;uuid&gt; 0-0</code>. Once the recipe has written to the target, it will create a message in that (<code>{&lt;hash key&gt;}&lt;uuid&gt;</code>) Stream that has a single field named 'status' with the value 'done'.</li>\n<li>For housekeeping purposes, it is recommended to delete that Stream after getting the acknowledgment. This is not a must, however, as these Streams are created with TTL of one hour.</li>\n</ol>\n<h3>Acknowledgment example</h3>\n<pre><code>127.0.0.1:6379&gt; hset person:007 first_name James last_name Bond age 42 # =6ce0c902-30c2-4ac9-8342-2f04fb359a94\n(integer) 1\n127.0.0.1:6379&gt; XREAD BLOCK 2000 STREAMS {person:1}6ce0c902-30c2-4ac9-8342-2f04fb359a94 0-0\n1) 1) \"{person:1}6ce0c902-30c2-4ac9-8342-2f04fb359a94\"\n   2) 1) 1) \"1581927201056-0\"\n         2) 1) \"status\"\n            2) \"done\"\n</code></pre>\n<h2>Write Through</h2>\n<p><em>Write Through</em> is done by using a temporary key. The recipe registers to changes of that key and writes them to the target. Writing to the target is executed in the Server's main thread, in synchronous mode, which means that the server will be blocked at that time and the client will not get the reply until it is finished.</p>\n<p>Writing the changes to the target may succeed or fail. If successful, the recipe renames the temporary key to its intended final name. A failure will prevent the rename. In either case, the temporary key is deleted.</p>\n<p>The semantics of the acknowledgment Stream remains nearly the same as <em>Write Behind</em>. The only change is in the message's structure. Failed writes create a message in that (<code>{&lt;hash key&gt;}&lt;uuid&gt;</code>) Stream that has:</p>\n<ul>\n<li>A 'status' field with the value 'failed'</li>\n<li>An 'error' field containing the error's description</li>\n</ul>\n<p>Note that when using <em>Write Through</em> it is mandatory to supply a <code>uuid</code> and read the acknowledgment Stream. That is the only way to tell whether the write had succeeded.</p>\n<p><em>Write Through</em> is registered using the <code>RGWriteThrough</code> class:</p>\n<pre><span class=\"n\">RGWriteThrough</span><span class=\"p\">(</span><span class=\"n\">GB</span><span class=\"p\">,</span> <span class=\"n\">keysPrefix</span><span class=\"p\">,</span> <span class=\"n\">mappings</span><span class=\"p\">,</span> <span class=\"n\">connector</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">version</span><span class=\"p\">)</span>\n</pre>\n<p>The <code>keysPrefix</code> argument is the prefix of the key on which the writes will be triggered. The temporary key's name will be in the following format:</p>\n<pre><code>&lt;keysPrefix&gt;{&lt;realKeyName&gt;}\n</code></pre>\n<p>Upon success, the key is renamed to <code>&lt;realKeyName&gt;</code>.</p>\n<p>Any failure in writing to the target will cause the recipe to abort. In such cases, the temporary key is not renamed and is deleted.</p>\n<p>Note that in some cases, such as connection failures, it is impossible to tell whether the operation had succeeded or failed on the target. The recipe considers these as failures, although in reality, the write may have succeeded.</p>\n<h3>Example</h3>\n<p>These examples assume that the <code>keysPrefix</code> is set to \"__\". The first shows a successful write:</p>\n<pre><code>127.0.0.1:6379&gt; HSET __{person:1} first_name foo last_name bar age 20 # =6ce0c902-30c2-4ac9-8342-2f04fb359a94\n(integer) 4\n127.0.0.1:6379&gt; XREAD BLOCK 2000 STREAMS {person:1}6ce0c902-30c2-4ac9-8342-2f04fb359a94 0-0\n1) 1) \"{person:1}6ce0c902-30c2-4ac9-8342-2f04fb359a94\"\n   2) 1) 1) \"1583321726502-0\"\n         2) 1) \"status\"\n            2) \"done\"\n127.0.0.1:6379&gt; HGETALL person:1\n1) \"age\"\n2) \"20\"\n3) \"last_name\"\n4) \"bar\"\n5) \"first_name\"\n6) \"foo\"\n</code></pre>\n<p>An a example of a failed <em>Write Through</em>:</p>\n<pre><code>127.0.0.1:6379&gt; HSET __{person:1} first_name foo last_name bar age 20 # =6ce0c902-30c2-4ac9-8342-2f04fb359a94\n(integer) 4\n127.0.0.1:6379&gt; XREAD BLOCK 2000 STREAMS {person:1}6ce0c902-30c2-4ac9-8342-2f04fb359a94 0-0\n1) 1) \"{person:1}6ce0c902-30c2-4ac9-8342-2f04fb359a94\"\n   2) 1) 1) \"1583322141455-0\"\n         2) 1) \"status\"\n            2) \"failed\"\n            3) \"error\"\n            4) \"Failed connecting to SQL database, error=\\\"(pymysql.err.OperationalError) (2003, \\\"Can't connect to MySQL server on 'localhost' ([Errno 111] Connection refused)\\\")\\n(Background on this error at: http://sqlalche.me/e/e3q8)\\\"\"\n\n</code></pre>\n<h2>Data persistence and availability</h2>\n<p>To avoid data loss in Redis and the resulting inconsistencies with the target databases, it is recommended to employ and use this recipe only with a highly-available Redis environment. In such environments, the failure of a master node will cause the replica that replaced it to continue the recipe's execution from the point it was stopped.</p>\n<p>Furthermore, Redis' AOF should be used alongside replication to protect against data loss during system-wide failures.</p>\n<h2>Monitoring the RedisGears function registrations</h2>\n<p>Use <a href=\"https://github.com/RedisGears/RedisGearsMonitor\" rel=\"nofollow\">this</a> to monitor RedisGear's function registrations.</p>\n\n          </div>"}, "last_serial": 7112166, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "5102c094e1a1755ecd8379c34f5777cc", "sha256": "3e5ff81714c379cef7f0391b6928634ceb3c1617dedf7da7d693b39ccc49c9a4"}, "downloads": -1, "filename": "rgsync-0.1.tar.gz", "has_sig": false, "md5_digest": "5102c094e1a1755ecd8379c34f5777cc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 337529, "upload_time": "2020-03-25T16:25:53", "upload_time_iso_8601": "2020-03-25T16:25:53.544540Z", "url": "https://files.pythonhosted.org/packages/52/1b/e3f8e077d5724cd0d031bff47b8550a5642636d4717dfb5a2bf4820917b0/rgsync-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "b85a5fc5b04388b045b2e1dc51cc03de", "sha256": "8f9f3c07d3b9977049d8464579ee6b3e299a40b721201e49d9198164bf08f7b3"}, "downloads": -1, "filename": "rgsync-0.1.1.tar.gz", "has_sig": false, "md5_digest": "b85a5fc5b04388b045b2e1dc51cc03de", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 338031, "upload_time": "2020-04-23T07:06:02", "upload_time_iso_8601": "2020-04-23T07:06:02.432574Z", "url": "https://files.pythonhosted.org/packages/79/82/ad1e214077d989058f79e61af77827a8f8a75af63e64cae877ef735f7a65/rgsync-0.1.1.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "e1839a9307a1e02aa6c1baff13e7715f", "sha256": "a857fd9255b662c436d0e43513b4afa567bbbd9c8be4b61289c9aee7f8f8d17d"}, "downloads": -1, "filename": "rgsync-0.2.0.tar.gz", "has_sig": false, "md5_digest": "e1839a9307a1e02aa6c1baff13e7715f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 339117, "upload_time": "2020-04-27T14:32:27", "upload_time_iso_8601": "2020-04-27T14:32:27.299257Z", "url": "https://files.pythonhosted.org/packages/25/ee/2428f0d11edc628ca6f5657e35f298f18b202965b93bd9c56659cff62e06/rgsync-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e1839a9307a1e02aa6c1baff13e7715f", "sha256": "a857fd9255b662c436d0e43513b4afa567bbbd9c8be4b61289c9aee7f8f8d17d"}, "downloads": -1, "filename": "rgsync-0.2.0.tar.gz", "has_sig": false, "md5_digest": "e1839a9307a1e02aa6c1baff13e7715f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 339117, "upload_time": "2020-04-27T14:32:27", "upload_time_iso_8601": "2020-04-27T14:32:27.299257Z", "url": "https://files.pythonhosted.org/packages/25/ee/2428f0d11edc628ca6f5657e35f298f18b202965b93bd9c56659cff62e06/rgsync-0.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:03:01 2020"}