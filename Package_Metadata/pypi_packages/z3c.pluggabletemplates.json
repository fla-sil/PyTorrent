{"info": {"author": "Kevin Smith", "author_email": "kevin@mcweekly.com", "bugtrack_url": null, "classifiers": ["Framework :: Zope3"], "description": "===================\nPluggable Templates\n===================\n\n\nThis package does two things. First, it does everything z3c.viewtemplate does\n-- seperate the view code layer from the template skin layer. Second, it\nallows an unlimited number of templates to be plugged into any view class.\n\nWhat's this for?\n~~~~~~~~~~~~~~~~\n\nMaking masterpages simple is hard work. Using macros is fairly complicated for\ndesigners to deal with. In fact they don't. Using z3c.viewtemplate with viewlets\nis fairly complicated for programmers to deal with. In fact I don't. So this\nis another evolutionary step to allow designers and programmersto work together\nwithout necessarily knowing or even liking each other.\n\nThis work relies heavily on the working code done by Jurgen for z3c.viewtemplate.\n\nA simple masterpage implementation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis is a simple masterpage implementation without using pluggabletemplates.\n\nbrowser.py::\n\n\tclass MyView(object):\n\n\t\tmasterpage = ViewTemplateFile('templates/masterpage.pt')\n\t\tsubpage = ViewTemplateFile('templates/content.pt')\n\n\t\tauthors = ['Roger Zelazny', 'Isaac Asimov', 'Robert Heinlien', 'J.R.R Tolkein']\n\n\t\tdef __call__(self):\n\t\t\treturn masterpage()\n\n templates/masterpage.pt::\n\n \t<html>...\n \t<body>\n \t<h2>My Master Page</h2>\n \t<span tal:replace=\"view/subpage\" />\n \t</body>\n \t</html>\n\n templates/index.pt::\n\n\t<ul>\n\t\t<li tal:repeat=\"author view/authors\" tal:content=\"author\" />\n\t</ul>\n\nThis is a very easy to follow pattern which can be extended  fairly easily. This\npattern runs into immediate problems when you want to change skins. Changing skins\nshould be as easy as ++skin++design1 ... +++skin++design2, but to do so, all of the\nview code needs to be duplicated. Which can be done, but as soon as one piece of view\ncode is changed, all the other view code has to be patched and easily falls out of\nsync.\n\nEnter viewplugs\n~~~~~~~~~~~~~~~\n\ndesign1/configure.zcml::\n\n\t<browser:pluggableTemplates\n\t\tfor=\"myapp.browser.MyView\"\n\t\tlayer=\".skins.Design1\"\n\t\t>\n\t\t<template\n\t\t\tname=\"master\"\n\t\t\tfile=\"templates/masterpage.pt\"\n\t\t\t/>\n\t\t<template\n\t\t\tname=\"subtemplate\"\n\t\t\tfile=\"templates/subtemplate.pt\n\t\t\t/>\n\t</browser:pluggableTemplates>\n\nSo does this mean we'll need to duplicate all of this configuration for\n++skin++design2?? Not necessarily::\n\n\tclass Design2(Design1):\n\t\t\"\"\" Skin marker \"\"\"\n\nNow you can use ++skin++design1 one as your base and simply override\nthe views or templates you need to change et. al. stylesheets and\nimages.\n\n\nBy plugging templates into view code, each template can display each of the\nother templates::\n\n\t<span tal:replace=\"view/template1\" />\n\t<span tal:replace=\"view/template2\" />\n\nAnd of course all view attributes are available::\n\n\t<span tal:replace=\"view/myattr1\" />\n\nYou can add as many views as you like, though, too many, and it could get recomplicated.\n\nDoctests\n~~~~~~~~\n\nBefore we can setup a view component using this new method, we have to first\ncreate a master template and subtemplate ...\n\n  >>> import os, tempfile\n  >>> temp_dir = tempfile.mkdtemp()\n  >>> master = os.path.join(temp_dir, 'master.pt')\n  >>> open(master, 'w').write('''<h2>Masterpage</h2><span tal:replace=\"view/subtemplate\"/>''')\n  >>> subtemplate = os.path.join(temp_dir, 'subtemplate.pt')\n  >>> open(subtemplate, 'w').write('''This is the subtemplate: <span tal:replace=\"view/taste\" />''')\n  >>> from zope.publisher.browser import TestRequest\n  >>> request = TestRequest()\n\n  >>> from zope import interface\n  >>> from z3c.pluggabletemplates.baseview import MasterView\n  >>> from z3c.pluggabletemplates.pagetemplate import RegisteredPageTemplate\n  >>> class IMyView(interface.Interface):\n  ...     pass\n  >>> class MyView(MasterView):\n  ...     interface.implements(IMyView)\n  ...     master = RegisteredPageTemplate( 'master' )\n  ...\t  taste = 'success'\n  ...     subtemplate = RegisteredPageTemplate( 'subtemplate' )\n\n\n  >>> view = MyView(root, request)\n\nSince the template is not yet registered, rendering the view will fail::\n\n  >>> print view()\n  Traceback (most recent call last):\n  ...\n  ComponentLookupError: ......\n\nLet's now register the template (commonly done using ZCML)::\n\n  >>> from zope import component\n  >>> from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n  >>> from z3c.pluggabletemplates.zcml import TemplateFactory\n  >>> from zope.pagetemplate.interfaces import IPageTemplate\n\nThe template factory allows us to create a ViewPageTemplateFile instance::\n\n  >>> factory = TemplateFactory(master, 'text/html')\n\nWe register the factory on a view interface and a layer::\n\n  >>> component.provideAdapter(factory,\n  ...            (interface.Interface, IDefaultBrowserLayer),\n  ...            IPageTemplate, name=\"master\")\n  >>> mastertemplate = component.getMultiAdapter(\n  ...               (view, request), IPageTemplate, name=\"master\"  )\n  >>> mastertemplate\n  <zope.app.pagetemplate.viewpagetemplatefile.ViewPageTemplateFile ...>\n\n  >>> factory = TemplateFactory(subtemplate, 'text/html')\n\nWe register the factory on a view interface and a layer::\n\n  >>> component.provideAdapter(factory,\n  ...            (interface.Interface, IDefaultBrowserLayer),\n  ...            IPageTemplate, name=\"subtemplate\")\n  >>> subtemplate = component.getMultiAdapter(\n  ...               (view, request), IPageTemplate, name=\"subtemplate\"  )\n  >>> subtemplate\n  <zope.app.pagetemplate.viewpagetemplatefile.ViewPageTemplateFile ...>\n\nNow that we have a registered template for the default layer we can call our\nview again::\n\n  >>> print view()\n  <h2>Masterpage</h2>This is the subtemplate: success\n  <BLANKLINE>\n\n\nCleanup\n\n  >>> import shutil\n  >>> shutil.rmtree(temp_dir)\n\nRevision Log\r\n============\r\n\r\n* 11/03/06 initial checkin", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://code.google.com/p/pluggabletemplates/", "keywords": "zope zope3 template", "license": "ZPL 2.1", "maintainer": null, "maintainer_email": null, "name": "z3c.pluggabletemplates", "package_url": "https://pypi.org/project/z3c.pluggabletemplates/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/z3c.pluggabletemplates/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://code.google.com/p/pluggabletemplates/"}, "release_url": "https://pypi.org/project/z3c.pluggabletemplates/0.2/", "requires_dist": null, "requires_python": null, "summary": "Allows seperation of view code from skin templates like z3c.viewtemplate, but also allows multiple templates to be plugged into your view code.", "version": "0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This package does two things. First, it does everything z3c.viewtemplate does\n\u2013 seperate the view code layer from the template skin layer. Second, it\nallows an unlimited number of templates to be plugged into any view class.</p>\n<div id=\"what-s-this-for\">\n<h2>What\u2019s this for?</h2>\n<p>Making masterpages simple is hard work. Using macros is fairly complicated for\ndesigners to deal with. In fact they don\u2019t. Using z3c.viewtemplate with viewlets\nis fairly complicated for programmers to deal with. In fact I don\u2019t. So this\nis another evolutionary step to allow designers and programmersto work together\nwithout necessarily knowing or even liking each other.</p>\n<p>This work relies heavily on the working code done by Jurgen for z3c.viewtemplate.</p>\n</div>\n<div id=\"a-simple-masterpage-implementation\">\n<h2>A simple masterpage implementation</h2>\n<p>This is a simple masterpage implementation without using pluggabletemplates.</p>\n<p>browser.py:</p>\n<pre>       class MyView(object):\n\n               masterpage = ViewTemplateFile('templates/masterpage.pt')\n               subpage = ViewTemplateFile('templates/content.pt')\n\n               authors = ['Roger Zelazny', 'Isaac Asimov', 'Robert Heinlien', 'J.R.R Tolkein']\n\n               def __call__(self):\n                       return masterpage()\n\ntemplates/masterpage.pt::\n\n       &lt;html&gt;...\n       &lt;body&gt;\n       &lt;h2&gt;My Master Page&lt;/h2&gt;\n       &lt;span tal:replace=\"view/subpage\" /&gt;\n       &lt;/body&gt;\n       &lt;/html&gt;\n\ntemplates/index.pt::\n\n       &lt;ul&gt;\n               &lt;li tal:repeat=\"author view/authors\" tal:content=\"author\" /&gt;\n       &lt;/ul&gt;\n</pre>\n<p>This is a very easy to follow pattern which can be extended  fairly easily. This\npattern runs into immediate problems when you want to change skins. Changing skins\nshould be as easy as ++skin++design1 \u2026 +++skin++design2, but to do so, all of the\nview code needs to be duplicated. Which can be done, but as soon as one piece of view\ncode is changed, all the other view code has to be patched and easily falls out of\nsync.</p>\n</div>\n<div id=\"enter-viewplugs\">\n<h2>Enter viewplugs</h2>\n<p>design1/configure.zcml:</p>\n<pre>&lt;browser:pluggableTemplates\n        for=\"myapp.browser.MyView\"\n        layer=\".skins.Design1\"\n        &gt;\n        &lt;template\n                name=\"master\"\n                file=\"templates/masterpage.pt\"\n                /&gt;\n        &lt;template\n                name=\"subtemplate\"\n                file=\"templates/subtemplate.pt\n                /&gt;\n&lt;/browser:pluggableTemplates&gt;\n</pre>\n<p>So does this mean we\u2019ll need to duplicate all of this configuration for\n++skin++design2?? Not necessarily:</p>\n<pre>class Design2(Design1):\n        \"\"\" Skin marker \"\"\"\n</pre>\n<p>Now you can use ++skin++design1 one as your base and simply override\nthe views or templates you need to change et. al. stylesheets and\nimages.</p>\n<p>By plugging templates into view code, each template can display each of the\nother templates:</p>\n<pre>&lt;span tal:replace=\"view/template1\" /&gt;\n&lt;span tal:replace=\"view/template2\" /&gt;\n</pre>\n<p>And of course all view attributes are available:</p>\n<pre>&lt;span tal:replace=\"view/myattr1\" /&gt;\n</pre>\n<p>You can add as many views as you like, though, too many, and it could get recomplicated.</p>\n</div>\n<div id=\"doctests\">\n<h2>Doctests</h2>\n<p>Before we can setup a view component using this new method, we have to first\ncreate a master template and subtemplate \u2026</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import os, tempfile\n&gt;&gt;&gt; temp_dir = tempfile.mkdtemp()\n&gt;&gt;&gt; master = os.path.join(temp_dir, 'master.pt')\n&gt;&gt;&gt; open(master, 'w').write('''&lt;h2&gt;Masterpage&lt;/h2&gt;&lt;span tal:replace=\"view/subtemplate\"/&gt;''')\n&gt;&gt;&gt; subtemplate = os.path.join(temp_dir, 'subtemplate.pt')\n&gt;&gt;&gt; open(subtemplate, 'w').write('''This is the subtemplate: &lt;span tal:replace=\"view/taste\" /&gt;''')\n&gt;&gt;&gt; from zope.publisher.browser import TestRequest\n&gt;&gt;&gt; request = TestRequest()\n</pre>\n<pre>&gt;&gt;&gt; from zope import interface\n&gt;&gt;&gt; from z3c.pluggabletemplates.baseview import MasterView\n&gt;&gt;&gt; from z3c.pluggabletemplates.pagetemplate import RegisteredPageTemplate\n&gt;&gt;&gt; class IMyView(interface.Interface):\n...     pass\n&gt;&gt;&gt; class MyView(MasterView):\n...     interface.implements(IMyView)\n...     master = RegisteredPageTemplate( 'master' )\n...     taste = 'success'\n...     subtemplate = RegisteredPageTemplate( 'subtemplate' )\n</pre>\n<pre>&gt;&gt;&gt; view = MyView(root, request)\n</pre>\n</blockquote>\n<p>Since the template is not yet registered, rendering the view will fail:</p>\n<pre>&gt;&gt;&gt; print view()\nTraceback (most recent call last):\n...\nComponentLookupError: ......\n</pre>\n<p>Let\u2019s now register the template (commonly done using ZCML):</p>\n<pre>&gt;&gt;&gt; from zope import component\n&gt;&gt;&gt; from zope.publisher.interfaces.browser import IDefaultBrowserLayer\n&gt;&gt;&gt; from z3c.pluggabletemplates.zcml import TemplateFactory\n&gt;&gt;&gt; from zope.pagetemplate.interfaces import IPageTemplate\n</pre>\n<p>The template factory allows us to create a ViewPageTemplateFile instance:</p>\n<pre>&gt;&gt;&gt; factory = TemplateFactory(master, 'text/html')\n</pre>\n<p>We register the factory on a view interface and a layer:</p>\n<pre>&gt;&gt;&gt; component.provideAdapter(factory,\n...            (interface.Interface, IDefaultBrowserLayer),\n...            IPageTemplate, name=\"master\")\n&gt;&gt;&gt; mastertemplate = component.getMultiAdapter(\n...               (view, request), IPageTemplate, name=\"master\"  )\n&gt;&gt;&gt; mastertemplate\n&lt;zope.app.pagetemplate.viewpagetemplatefile.ViewPageTemplateFile ...&gt;\n\n&gt;&gt;&gt; factory = TemplateFactory(subtemplate, 'text/html')\n</pre>\n<p>We register the factory on a view interface and a layer:</p>\n<pre>&gt;&gt;&gt; component.provideAdapter(factory,\n...            (interface.Interface, IDefaultBrowserLayer),\n...            IPageTemplate, name=\"subtemplate\")\n&gt;&gt;&gt; subtemplate = component.getMultiAdapter(\n...               (view, request), IPageTemplate, name=\"subtemplate\"  )\n&gt;&gt;&gt; subtemplate\n&lt;zope.app.pagetemplate.viewpagetemplatefile.ViewPageTemplateFile ...&gt;\n</pre>\n<p>Now that we have a registered template for the default layer we can call our\nview again:</p>\n<pre>&gt;&gt;&gt; print view()\n&lt;h2&gt;Masterpage&lt;/h2&gt;This is the subtemplate: success\n&lt;BLANKLINE&gt;\n</pre>\n<p>Cleanup</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import shutil\n&gt;&gt;&gt; shutil.rmtree(temp_dir)\n</pre>\n</blockquote>\n<div id=\"revision-log\">\n<h3>Revision Log</h3>\n<ul>\n<li>11/03/06 initial checkin</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 802064, "releases": {"0.2": [{"comment_text": "", "digests": {"md5": "a9adbbb6194dc585c9b02721edb488fc", "sha256": "0c3529ce8736ade71c608d3bf1114fd1d37dbcbf46e0db0de09f8a6b4496f1a1"}, "downloads": -1, "filename": "z3c.pluggabletemplates-0.2-py2.4.egg", "has_sig": false, "md5_digest": "a9adbbb6194dc585c9b02721edb488fc", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 19784, "upload_time": "2006-11-04T01:57:11", "upload_time_iso_8601": "2006-11-04T01:57:11Z", "url": "https://files.pythonhosted.org/packages/3f/14/d0c91a8cff2935f6f3f8a973b629170e47dbb1e4b0aa3912300e144b50cf/z3c.pluggabletemplates-0.2-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "b04cda507f2488fa7aa0a2a1a54ef583", "sha256": "54d503956a0b6491e8e8b40834da53de5c2e30107af23c4c1c0f91ce72fea8a9"}, "downloads": -1, "filename": "z3c.pluggabletemplates-0.2.tar.gz", "has_sig": false, "md5_digest": "b04cda507f2488fa7aa0a2a1a54ef583", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8025, "upload_time": "2006-11-04T01:55:29", "upload_time_iso_8601": "2006-11-04T01:55:29Z", "url": "https://files.pythonhosted.org/packages/16/01/7409af0d49554bfb39b92ad08a340114d9491b42a0a4cc73ecdf7956caba/z3c.pluggabletemplates-0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a9adbbb6194dc585c9b02721edb488fc", "sha256": "0c3529ce8736ade71c608d3bf1114fd1d37dbcbf46e0db0de09f8a6b4496f1a1"}, "downloads": -1, "filename": "z3c.pluggabletemplates-0.2-py2.4.egg", "has_sig": false, "md5_digest": "a9adbbb6194dc585c9b02721edb488fc", "packagetype": "bdist_egg", "python_version": "2.4", "requires_python": null, "size": 19784, "upload_time": "2006-11-04T01:57:11", "upload_time_iso_8601": "2006-11-04T01:57:11Z", "url": "https://files.pythonhosted.org/packages/3f/14/d0c91a8cff2935f6f3f8a973b629170e47dbb1e4b0aa3912300e144b50cf/z3c.pluggabletemplates-0.2-py2.4.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "b04cda507f2488fa7aa0a2a1a54ef583", "sha256": "54d503956a0b6491e8e8b40834da53de5c2e30107af23c4c1c0f91ce72fea8a9"}, "downloads": -1, "filename": "z3c.pluggabletemplates-0.2.tar.gz", "has_sig": false, "md5_digest": "b04cda507f2488fa7aa0a2a1a54ef583", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8025, "upload_time": "2006-11-04T01:55:29", "upload_time_iso_8601": "2006-11-04T01:55:29Z", "url": "https://files.pythonhosted.org/packages/16/01/7409af0d49554bfb39b92ad08a340114d9491b42a0a4cc73ecdf7956caba/z3c.pluggabletemplates-0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:20:51 2020"}