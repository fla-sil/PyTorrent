{"info": {"author": "Stephen Moore", "author_email": "delfick755@gmail.com", "bugtrack_url": null, "classifiers": ["Framework :: Pytest", "Topic :: Software Development :: Testing"], "description": "Alternative Pytest Asyncio\n==========================\n\nThis plugin allows you to have async pytest fixtures and tests.\n\nThis plugin only supports python 3.6 and above.\n\nThe code here is influenced by pytest-asyncio but with some differences:\n\n* Error tracebacks from are from your tests, rather than asyncio internals\n* There is only one loop for all of the tests\n* You can manage the lifecycle of the loop yourself outside of pytest by using\n  this plugin with your own loop\n* No need to explicitly mark your tests as async. (pytest-asyncio requires you\n  mark your async tests because it also supports other event loops like curio\n  and trio)\n\nLike pytest-asyncio it supports async tests, coroutine fixtures and async\ngenerator fixtures.\n\nChangelog\n---------\n\n0.5.2 - 6 February 2020\n    * Added ability to make a different event loop for some tests\n\n0.5.1 - 15 December 2019\n    * Added an ini option ``default_alt_async_timeout`` for the default async\n      timeout for fixtures and tests. The default is now 5 seconds. So say\n      you wanted the default to be 3.5 seconds, you would set\n      ``default_alt_async_timeout`` to be 3.5\n\n0.5 - 16 August 2019\n    * I made this functionality in a work project where I needed to run\n      pytest.main from an existing event loop. I decided to make this it's\n      own module so I can have tests for this code.\n\nRunning from your own event loop\n--------------------------------\n\nIf you want to run pytest.main from with an existing event loop then you can\ndo something like:\n\n.. code-block:: python\n\n   from alt_pytest_asyncio.plugin import AltPytestAsyncioPlugin, run_coro_as_main\n   import nest_asyncio\n   import asyncio\n   import pytest\n\n   async def my_tests():\n      await do_some_setup_before_pytest()\n\n      plugins = [AltPytestAsyncioPlugin(loop)]\n\n      try:\n          code = pytest.main([], plugins=plugins)\n      finally:\n          # Note that alt_pytest_asyncio will make sure all your async tests\n          # have been finalized by this point, even if you KeyboardInterrupt\n          # the pytest.main\n          await do_any_teardown_after_pytest()\n\n      if code != 0:\n         raise Exception(repr(code))\n\n   if __name__ == '__main__':\n      # Nest asyncio is required so that we can do run_until_complete in an\n      # existing event loop - https://github.com/erdewit/nest_asyncio\n      loop = asyncio.get_event_loop()\n      nest_asyncio.apply(loop)\n\n      run_coro_as_main(loop, my_tests())\n\nNote that if you don't need to run pytest from an existing event loop, you don't\nneed to do anything other than have alt_pytest_asyncio installed in your\nenvironment and you'll be able to just use async keywords on your fixtures and\ntests.\n\nTimeouts\n--------\n\nalt_pytest_asyncio registers a ``pytest.mark.async_timeout(seconds)`` mark which\nyou can use to set a timeout for your test.\n\nFor example:\n\n.. code-block:: python\n\n   import pytest\n\n   @pytest.mark.async_timeout(10)\n   async def test_something():\n      await something_that_may_take_a_while()\n\nThis test will be cancelled after 10 seconds and raise an assertion error saying\nthe test took too long and the file and line number where the test is.\n\nYou can also use the async_timeout mark on coroutine fixtures:\n\n.. code-block:: python\n\n   import pytest\n\n   @pytest.fixture()\n   @pytest.mark.async_timeout(0.5)\n   async def my_amazing_fixture():\n      await asyncio.sleep(1)\n      return 1\n\nAnd you can have a timeout on generator fixtures:\n\n.. code-block:: python\n\n   import pytest\n\n   @pytest.fixture()\n   @pytest.mark.async_timeout(0.5)\n   async def my_amazing_fixture():\n      try:\n         await asyncio.sleep(1)\n         yield 1\n      finally:\n         await asyncio.sleep(1)\n\nNote that for generator fixtures, the timeout is applied in whole to both the\nsetup and finalization of the fixture. As in the real timeout for the entire\nfixture is essentially double the single timeout specified.\n\nThe default timeout is 5 seconds. You can change this default by setting the\n``default_alt_async_timeout`` option to the number of seconds you want.\n\nOverriding the loop\n-------------------\n\nSometimes it may be necessary to close the current loop in a test. For this to\nnot then break the rest of your tests, you will need to set a new event loop for\nyour test and then restore the old loop afterwards.\n\nFor this, we have a context manager that will install a new asyncio loop and\nthen restore the original loop on exit.\n\nUsage looks like::\n\n    from alt_pytest_asyncio.plugin import OverrideLoop\n\n    class TestThing:\n        @pytest.fixture(autouse=True)\n        def custom_loop(self):\n            with OverrideLoop() as custom_loop:\n                yield custom_loop\n\n        def test_thing(self, custom_loop):\n            custom_loop.run_until_complete(my_thing())\n\nBy putting the loop into an autouse fixture, all fixtures used by the test\nwill have the custom loop. If you want to include module level fixtures too\nthen use the OverrideLoop in a module level fixture too.\n\nOverrideLoop takes in a ``new_loop`` boolean that will make it so no new\nloop is set and asyncio is left with no default loop.\n\nThe new loop itself (or None if new_loop is False) can be found in the\n``loop`` attribute of the object yielded by the context manager.\n\nThe ``run_until_complete`` on the ``custom_loop`` in the above example will\ndo a ``run_until_complete`` on the new loop, but in a way that means you\nwon't get ``unhandled exception during shutdown`` errors when the context\nmanager closes the new loop.\n\nWhen the context manager exits and closes the new loop, it will first cancel\nall tasks to ensure finally blocks are run.", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/delfick/alt-pytest-asyncio", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "alt-pytest-asyncio", "package_url": "https://pypi.org/project/alt-pytest-asyncio/", "platform": "", "project_url": "https://pypi.org/project/alt-pytest-asyncio/", "project_urls": {"Homepage": "https://github.com/delfick/alt-pytest-asyncio"}, "release_url": "https://pypi.org/project/alt-pytest-asyncio/0.5.2/", "requires_dist": null, "requires_python": ">= 3.5", "summary": "Alternative pytest plugin to pytest-asyncio", "version": "0.5.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This plugin allows you to have async pytest fixtures and tests.</p>\n<p>This plugin only supports python 3.6 and above.</p>\n<p>The code here is influenced by pytest-asyncio but with some differences:</p>\n<ul>\n<li>Error tracebacks from are from your tests, rather than asyncio internals</li>\n<li>There is only one loop for all of the tests</li>\n<li>You can manage the lifecycle of the loop yourself outside of pytest by using\nthis plugin with your own loop</li>\n<li>No need to explicitly mark your tests as async. (pytest-asyncio requires you\nmark your async tests because it also supports other event loops like curio\nand trio)</li>\n</ul>\n<p>Like pytest-asyncio it supports async tests, coroutine fixtures and async\ngenerator fixtures.</p>\n<div id=\"changelog\">\n<h2>Changelog</h2>\n<dl>\n<dt>0.5.2 - 6 February 2020</dt>\n<dd><ul>\n<li>Added ability to make a different event loop for some tests</li>\n</ul>\n</dd>\n<dt>0.5.1 - 15 December 2019</dt>\n<dd><ul>\n<li>Added an ini option <tt>default_alt_async_timeout</tt> for the default async\ntimeout for fixtures and tests. The default is now 5 seconds. So say\nyou wanted the default to be 3.5 seconds, you would set\n<tt>default_alt_async_timeout</tt> to be 3.5</li>\n</ul>\n</dd>\n<dt>0.5 - 16 August 2019</dt>\n<dd><ul>\n<li>I made this functionality in a work project where I needed to run\npytest.main from an existing event loop. I decided to make this it\u2019s\nown module so I can have tests for this code.</li>\n</ul>\n</dd>\n</dl>\n</div>\n<div id=\"running-from-your-own-event-loop\">\n<h2>Running from your own event loop</h2>\n<p>If you want to run pytest.main from with an existing event loop then you can\ndo something like:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">alt_pytest_asyncio.plugin</span> <span class=\"kn\">import</span> <span class=\"n\">AltPytestAsyncioPlugin</span><span class=\"p\">,</span> <span class=\"n\">run_coro_as_main</span>\n<span class=\"kn\">import</span> <span class=\"nn\">nest_asyncio</span>\n<span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pytest</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">my_tests</span><span class=\"p\">():</span>\n   <span class=\"k\">await</span> <span class=\"n\">do_some_setup_before_pytest</span><span class=\"p\">()</span>\n\n   <span class=\"n\">plugins</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">AltPytestAsyncioPlugin</span><span class=\"p\">(</span><span class=\"n\">loop</span><span class=\"p\">)]</span>\n\n   <span class=\"k\">try</span><span class=\"p\">:</span>\n       <span class=\"n\">code</span> <span class=\"o\">=</span> <span class=\"n\">pytest</span><span class=\"o\">.</span><span class=\"n\">main</span><span class=\"p\">([],</span> <span class=\"n\">plugins</span><span class=\"o\">=</span><span class=\"n\">plugins</span><span class=\"p\">)</span>\n   <span class=\"k\">finally</span><span class=\"p\">:</span>\n       <span class=\"c1\"># Note that alt_pytest_asyncio will make sure all your async tests</span>\n       <span class=\"c1\"># have been finalized by this point, even if you KeyboardInterrupt</span>\n       <span class=\"c1\"># the pytest.main</span>\n       <span class=\"k\">await</span> <span class=\"n\">do_any_teardown_after_pytest</span><span class=\"p\">()</span>\n\n   <span class=\"k\">if</span> <span class=\"n\">code</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n      <span class=\"k\">raise</span> <span class=\"ne\">Exception</span><span class=\"p\">(</span><span class=\"nb\">repr</span><span class=\"p\">(</span><span class=\"n\">code</span><span class=\"p\">))</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n   <span class=\"c1\"># Nest asyncio is required so that we can do run_until_complete in an</span>\n   <span class=\"c1\"># existing event loop - https://github.com/erdewit/nest_asyncio</span>\n   <span class=\"n\">loop</span> <span class=\"o\">=</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">get_event_loop</span><span class=\"p\">()</span>\n   <span class=\"n\">nest_asyncio</span><span class=\"o\">.</span><span class=\"n\">apply</span><span class=\"p\">(</span><span class=\"n\">loop</span><span class=\"p\">)</span>\n\n   <span class=\"n\">run_coro_as_main</span><span class=\"p\">(</span><span class=\"n\">loop</span><span class=\"p\">,</span> <span class=\"n\">my_tests</span><span class=\"p\">())</span>\n</pre>\n<p>Note that if you don\u2019t need to run pytest from an existing event loop, you don\u2019t\nneed to do anything other than have alt_pytest_asyncio installed in your\nenvironment and you\u2019ll be able to just use async keywords on your fixtures and\ntests.</p>\n</div>\n<div id=\"timeouts\">\n<h2>Timeouts</h2>\n<p>alt_pytest_asyncio registers a <tt>pytest.mark.async_timeout(seconds)</tt> mark which\nyou can use to set a timeout for your test.</p>\n<p>For example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pytest</span>\n\n<span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">mark</span><span class=\"o\">.</span><span class=\"n\">async_timeout</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">test_something</span><span class=\"p\">():</span>\n   <span class=\"k\">await</span> <span class=\"n\">something_that_may_take_a_while</span><span class=\"p\">()</span>\n</pre>\n<p>This test will be cancelled after 10 seconds and raise an assertion error saying\nthe test took too long and the file and line number where the test is.</p>\n<p>You can also use the async_timeout mark on coroutine fixtures:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pytest</span>\n\n<span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">fixture</span><span class=\"p\">()</span>\n<span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">mark</span><span class=\"o\">.</span><span class=\"n\">async_timeout</span><span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">my_amazing_fixture</span><span class=\"p\">():</span>\n   <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n   <span class=\"k\">return</span> <span class=\"mi\">1</span>\n</pre>\n<p>And you can have a timeout on generator fixtures:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pytest</span>\n\n<span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">fixture</span><span class=\"p\">()</span>\n<span class=\"nd\">@pytest</span><span class=\"o\">.</span><span class=\"n\">mark</span><span class=\"o\">.</span><span class=\"n\">async_timeout</span><span class=\"p\">(</span><span class=\"mf\">0.5</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">my_amazing_fixture</span><span class=\"p\">():</span>\n   <span class=\"k\">try</span><span class=\"p\">:</span>\n      <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n      <span class=\"k\">yield</span> <span class=\"mi\">1</span>\n   <span class=\"k\">finally</span><span class=\"p\">:</span>\n      <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>Note that for generator fixtures, the timeout is applied in whole to both the\nsetup and finalization of the fixture. As in the real timeout for the entire\nfixture is essentially double the single timeout specified.</p>\n<p>The default timeout is 5 seconds. You can change this default by setting the\n<tt>default_alt_async_timeout</tt> option to the number of seconds you want.</p>\n</div>\n<div id=\"overriding-the-loop\">\n<h2>Overriding the loop</h2>\n<p>Sometimes it may be necessary to close the current loop in a test. For this to\nnot then break the rest of your tests, you will need to set a new event loop for\nyour test and then restore the old loop afterwards.</p>\n<p>For this, we have a context manager that will install a new asyncio loop and\nthen restore the original loop on exit.</p>\n<p>Usage looks like:</p>\n<pre>from alt_pytest_asyncio.plugin import OverrideLoop\n\nclass TestThing:\n    @pytest.fixture(autouse=True)\n    def custom_loop(self):\n        with OverrideLoop() as custom_loop:\n            yield custom_loop\n\n    def test_thing(self, custom_loop):\n        custom_loop.run_until_complete(my_thing())\n</pre>\n<p>By putting the loop into an autouse fixture, all fixtures used by the test\nwill have the custom loop. If you want to include module level fixtures too\nthen use the OverrideLoop in a module level fixture too.</p>\n<p>OverrideLoop takes in a <tt>new_loop</tt> boolean that will make it so no new\nloop is set and asyncio is left with no default loop.</p>\n<p>The new loop itself (or None if new_loop is False) can be found in the\n<tt>loop</tt> attribute of the object yielded by the context manager.</p>\n<p>The <tt>run_until_complete</tt> on the <tt>custom_loop</tt> in the above example will\ndo a <tt>run_until_complete</tt> on the new loop, but in a way that means you\nwon\u2019t get <tt>unhandled exception during shutdown</tt> errors when the context\nmanager closes the new loop.</p>\n<p>When the context manager exits and closes the new loop, it will first cancel\nall tasks to ensure finally blocks are run.</p>\n</div>\n\n          </div>"}, "last_serial": 6579523, "releases": {"0.5": [{"comment_text": "", "digests": {"md5": "0df6cde61926a43411de09f9354a21c2", "sha256": "d0aae89ffeb7470e8e92fc6d25d54da591cd4a806683cd08722157e635323586"}, "downloads": -1, "filename": "alt_pytest_asyncio-0.5.tar.gz", "has_sig": false, "md5_digest": "0df6cde61926a43411de09f9354a21c2", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 6022, "upload_time": "2019-08-16T03:47:36", "upload_time_iso_8601": "2019-08-16T03:47:36.974765Z", "url": "https://files.pythonhosted.org/packages/05/d1/dc418f604938d29f0c0a9fe142f6cb10d31066e94eb1103144ffd83e3534/alt_pytest_asyncio-0.5.tar.gz", "yanked": false}], "0.5.1": [{"comment_text": "", "digests": {"md5": "604a12bc34f4a66c148442778c1bc75b", "sha256": "45b8abf4059ed91f3f8035240df23f9994d78f9bf255d89cc9fb89cafff2038b"}, "downloads": -1, "filename": "alt_pytest_asyncio-0.5.1.tar.gz", "has_sig": false, "md5_digest": "604a12bc34f4a66c148442778c1bc75b", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 6238, "upload_time": "2019-12-15T04:50:13", "upload_time_iso_8601": "2019-12-15T04:50:13.845006Z", "url": "https://files.pythonhosted.org/packages/d1/0b/a8807f1640b2da3673d71ec457c89e7fb7634f09914f1e3464ecbad0f512/alt_pytest_asyncio-0.5.1.tar.gz", "yanked": false}], "0.5.2": [{"comment_text": "", "digests": {"md5": "f54d0361dda8d17ad3351e08594d8f50", "sha256": "2dc67b40ed65ab5262409c32944ec46ac329ac0fdddc782d4dd5afbf53ec258d"}, "downloads": -1, "filename": "alt_pytest_asyncio-0.5.2.tar.gz", "has_sig": false, "md5_digest": "f54d0361dda8d17ad3351e08594d8f50", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 7534, "upload_time": "2020-02-06T00:06:15", "upload_time_iso_8601": "2020-02-06T00:06:15.781788Z", "url": "https://files.pythonhosted.org/packages/3c/78/eb79d5d7a83628ac4a8afb4ea5a857708039fa2ac3992d15feefb626539d/alt_pytest_asyncio-0.5.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f54d0361dda8d17ad3351e08594d8f50", "sha256": "2dc67b40ed65ab5262409c32944ec46ac329ac0fdddc782d4dd5afbf53ec258d"}, "downloads": -1, "filename": "alt_pytest_asyncio-0.5.2.tar.gz", "has_sig": false, "md5_digest": "f54d0361dda8d17ad3351e08594d8f50", "packagetype": "sdist", "python_version": "source", "requires_python": ">= 3.5", "size": 7534, "upload_time": "2020-02-06T00:06:15", "upload_time_iso_8601": "2020-02-06T00:06:15.781788Z", "url": "https://files.pythonhosted.org/packages/3c/78/eb79d5d7a83628ac4a8afb4ea5a857708039fa2ac3992d15feefb626539d/alt_pytest_asyncio-0.5.2.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:18:26 2020"}