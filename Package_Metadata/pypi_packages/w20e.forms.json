{"info": {"author": "D.A.Dokter", "author_email": "dokter@w20e.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Framework :: Plone", "Framework :: Pylons", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License (GPL)", "Operating System :: OS Independent", "Programming Language :: Python"], "description": ".. contents:: Table of Contents\n\nThe w20e.forms package provides a powerful API for creating and\nhandling electronic forms. The package is loosely based on XForms\nconcepts (and Socrates QE, a Java implementation). The package intends\nto provide a drop-in alternative for standard plone, pyramid and\ndjango solutions, but is useable in any framework (or without a\nframework...).\n\n\nCore concepts\n=============\n\nThe core concepts are as follows (so you can quickly decide whether\nyou like this approach or not):\n\nA form is a container for/composition of four things:\n\n1. data\n2. model\n3. view\n4. submission\n\nThis clearly separates the data, the data's properties (datatype,\nwhether something is required or not, etc.) and the renderable part of\nthe form. This is also the main difference between this API and other\nsolutions (afaik...). Where the usual approach is to define a form\nbased on a *Schema* or other data-centered notion, like so::\n\n  foo = String(\"id\", \"label\", validator=somefunction)\n\nthe approach of w20e.forms is to define::\n\n  foo = Field(\"fid\")\n  props = FieldProperties(\"pid\", [\"fid\"], required=True, datatype=int)\n  ctrl = Input(\"cid\", \"label\", bind=\"fid\")\n\nwhere the properties and control are *bound* to the variable. This\nenables controls in your form that are not bound to any data you wish\nto collect, sharing of properties, etc.\n\nAnother important difference is that the API provides a structured way\nof defining properties for data, instead of having to define your own\nvalidation. See section 1.2 for details.\n\n\nData\n----\n\nThe data holds the variables you wish to collect with this form. A\nvariable simply has an id, and if you like a default value.\n\n\nModel\n-----\n\nThe model holds all properties for a given form, like readonly-ness,\nrequiredness, datatyping for variables, relevance, etc. All these\nproperties are calculated from expressions, in this case Python\nexpressions, so requiredness is not just true or false, it can be\ncalculated based on an expression that can include other variables in\nyour data. All variables from the form data are available in\nexpressions via the 'data' dict, so if variable 'foo' would be\nrequired if variable 'bar' was set to 666, this can be expressed like\nso in the properties bound to foo:\n\n ... required=\"data['bar'] == 666\" ...\n\nIn general, all expressions are eval-ed to something true or\nfalse. The model offers the following properties:\n\n* required: is a variable required or not?\n* relevant: is the variable relevant? Like maiden name would be irrelevant\n  when gender is male. In general, the related control/widget for irrelevant \n  variables would not be shown.\n* readonly: can a person change the value of a variable?\n* calculate: in stead of letting a person set the value of a variable, the\n  variable is calculated.\n* constraint: check whether the expression evaluates to True.\n* datatype: datatype for the variable, like int, string, or more complex\n  variables.\n\nProperties are bound to variables by a bind attribute. A set of\nproperties can be bound to a series of variables.\n\n\nView\n----\n\nThe view (or FormView) is the actual visible part (or audible for that\nmatter) of the form. The view can be rendered and holds a collection\nof widgets or controls, that are bound to variables. More than one\ncontrol can bind to the same variable. Controls can be grouped in\ngroups for layout purposes, like flow layout or card layout (tabs).\n\nIn label and hint texts of controls you can use lexical values of\nvariables by using the expression ${<var name>}. This way you can refer to\nvalues given in other variables from your labels and hints.\n\n\nBasic use\n=========\n\nOk, enough theory, let's do something for real.\n\nA form is produced by hand, or by using a factory: this should take\ncare of producing a form holding the necessary stuff.\n\nLet's get the imports over with...\n\n      >>> import sys\n      >>> from interfaces import *\n      >>> from zope.interface import implements\n      >>> from formdata import FormData\n      >>> from formview import FormView\n      >>> from formmodel import FormModel\n      >>> from data.field import Field\n      >>> from model.fieldproperties import FieldProperties\n      >>> from rendering.control import Input, Select, Option\n      >>> from rendering.group import FlowGroup\n      >>> from form import Form, FormValidationError\n      >>> from rendering.html.renderer import HTMLRenderer\n      >>> from submission.attrstorage import AttrStorage\n\nCreating a form\n---------------\n\nNow let us create a factory class\n\n      >>> class FormFactory():\n      ...   implements(IFormFactory)\n      ...   def createForm(self):\n      ...     data = FormData()\n      ...     data.addField(Field(\"field0\"))\n      ...     data.addField(Field(\"field1\", \"foo\"))\n      ...     data.addField(Field(\"field2\", \"bar\"))\n      ...     data.addField(Field(\"field3\"))\n      ...     view = FormView()\n      ...     grp = FlowGroup(\"grp0\", label=\"Group 0\")\n      ...     grp.addRenderable(Input(\"input2\", \"Input 2\", bind=\"field0\"))\n      ...     view.addRenderable(Input(\"input0\", \"First name\", bind=\"field0\"))\n      ...     view.addRenderable(Input(\"input1\", \"Last name\", bind=\"field1\"))\n      ...     view.addRenderable(Select(\"select0\", \"Select me!\", options=[], bind=\"field2\", with_empty=True))\n      ...     view.addRenderable(grp)\n      ...     model = FormModel()\n      ...     model.addFieldProperties(FieldProperties(\"prop0\", [\"field0\"], required=\"True\"))\n      ...     model.addFieldProperties(FieldProperties(\"prop1\", [\"field1\", \"field2\"], relevant=\"data['field0']\"))\n      ...     submission = AttrStorage(attr_name=\"_data\")\n      ...     return Form(\"test\", data, model, view, submission)\n\n      >>> ff = FormFactory()\n      >>> form = ff.createForm()\n\nBy now, we should have a form where field0 is required, and field1 and\nfield2 are only relevant if field0 is filled in.\n\n      >>> print len(form.data.getFields())\n      4\n\n      >>> props = form.model.getFieldProperties(\"field0\")\n      >>> props[0].id\n      'prop0'\n\n      >>> len(props)\n      1\n\n      >>> field0 = form.data.getField(\"field0\")\n      >>> field0.id\n      'field0'\n\n      >>> field0.value\n\nIn the meanwhile, field1 and field2 should be irrelevant, given that field0\nhas no value\n\n      >>> form.model.isRelevant(\"field1\", form.data)\n      False\n      >>> form.model.isRelevant(\"field2\", form.data)\n      False\n\nValidation should fail, given that field0 is required.\n\n      >>> try:\n      ...   form.validate()\n      ... except FormValidationError:\n      ...   print sys.exc_info()[1].errors['field0']\n      ['required']\n\n      >>> form.data.getField(\"field0\").value = \"pipo\"\n      >>> form.validate()\n      True\n\n      >>> field0.value\n      'pipo'\n\nBy now, field1 and field2 should also be relevant\n\n      >>> form.model.isRelevant(\"field1\", form.data)\n      True\n      >>> form.model.isRelevant(\"field2\", form.data)\n      True\n\nDisplay\n-------\n\nThe following section will assume rendering to HTML. This will most\nlikely cover nigh 100% of the use cases...\nNow for some display parts. An irrelevant control should\nnot have a class 'relevant', otherwise it should have it... This\nenables specific styling, like 'display: none'.\n\n      >>> form.data.getField('field0').value = None\n      >>> field = form.view.getRenderable('input1')\n      >>> renderer = HTMLRenderer()\n      >>> renderer.render(form, field, sys.stdout)\n      <div id=\"input1\" class=\"control input \">\n      <label for=\"input-input1\">Last name</label>\n      <div class=\"alert\"></div>\n      <div class=\"hint\"></div>\n      <input id=\"input-input1\" type=\"text\" name=\"input1\" value=\"foo\" size=\"20\"/>\n      </div>\n\n      >>> form.data.getField('field0').value = 'pipo'\n      >>> field = form.view.getRenderable('input1')\n      >>> renderer = HTMLRenderer()\n      >>> renderer.render(form, field, sys.stdout)\n      <div id=\"input1\" class=\"control input relevant\">\n      <label for=\"input-input1\">Last name</label>\n      <div class=\"alert\"></div>\n      <div class=\"hint\"></div>\n      <input id=\"input-input1\" type=\"text\" name=\"input1\" value=\"foo\" size=\"20\"/>\n      </div>\n\n      >>> field = form.view.getRenderable('input0')\n      >>> renderer.render(form, field, sys.stdout)\n      <div id=\"input0\" class=\"control input relevant required\">\n      <label for=\"input-input0\">First name</label>\n      <div class=\"alert\"></div>\n      <div class=\"hint\"></div>\n      <input id=\"input-input0\" type=\"text\" name=\"input0\" value=\"pipo\" size=\"20\"/>\n      </div>\n      \nHow 'bout those extra classes...\n\n      >>> renderer.render(form, field, sys.stdout, extra_classes=\"card\")\n      <div id=\"input0\" class=\"control input card relevant required\">\n      <label for=\"input-input0\">First name</label>\n      <div class=\"alert\"></div>\n      <div class=\"hint\"></div>\n      <input id=\"input-input0\" type=\"text\" name=\"input0\" value=\"pipo\" size=\"20\"/>\n      </div>\n\n      >>> select = form.view.getRenderable('select0')\n      >>> renderer.render(form, select, sys.stdout)\n      <div id=\"select0\" class=\"control select relevant\">\n      <label for=\"input-select0\">Select me!</label>\n      <div class=\"alert\"></div>\n      <div class=\"hint\"></div>\n      <select id=\"input-select0\" name=\"select0\"  size=\"1\">\n      <option value=\"\" >Maak een keuze</option>\n      </select>\n      </div>\n\nDo we actually get grouped controls?\n\n      >>> nested_input = form.view.getRenderable('input2')\n      >>> nested_input.id\n      'input2'\n\nSubmission\n----------\n\nFinally when the form is rendered, filled in by someone, and\nvalidated, the data should normally go somewhere. This is by way of\nsubmission. We defined submission to be AttrStorage, something that\nstores the data in an attribute on some context. This is a case that\ncould be used in many frameworks, at least plone and pyramid.\n\nLet's see what it does:\n\n      >>> class Context:\n      ...   \"\"\" some context \"\"\"\n      >>> ctx = Context()\n      >>> form.submission.submit(form, ctx)\n\nThe context now should hold the data in an attribute. We specified the\nname of the attribute to be '_data', so let's check:\n\n     >>> ctx._data.getField('field0').value\n     'pipo'\n\n\nBeyond the basics\n=================\n\nWell, this is all very simple, and it is quite likely that you would\nwish for something a bit more usefull. All parts of the form are there\nto be extended. Take for instance the FormView. A developer (or end\nuser) should be able to:\n\n * create a full HTML form;\n * use a generated HTML form (this is wat the base implementation does);\n * create a PDF form.\n\nThe factory is also an important part of the form process. A factory\ncan be imagined to be one of the following:\n\n * produced from a Schema (content type);\n * produced from an XML definition, for example an XForms instance from\n   OpenOffice.\n\nForms in general should be:\n\n * submitable to a range of handlers, like email, database storage,\n   content type storage;\n * easy to validate 'live;\n * enable multi-page.\n\nMore detailed tests:\n\nWe'd like to check whether lookup of a control by bind works, so as to\nbe able to process values into lexical values. This is especially\ninteresting when using selects: we'd expect to see the label not the\nvalue in lexical space.\n\n      >>> data = FormData()\n      >>> data.addField(Field(\"f0\", \"opt0\"))\n      >>> view = FormView()\n      >>> opts = [Option(\"opt0\", \"Option 0\"), Option(\"opt1\", \"Option 1\")]\n      >>> view.addRenderable(Select(\"sel0\", \"Select 0\", bind=\"f0\", options=opts))\n      >>> ctl = view.getRenderableByBind(\"f0\")\n      >>> ctl.lexVal(\"opt0\")\n      'Option 0'\n\n\nCan we use variable substitution in labels and hints? Yes, we can!\n\n      >>> data = FormData()\n      >>> data.addField(Field(\"f0\", \"Pipo\"))\n      >>> data.addField(Field(\"f1\"))\n      >>> view = FormView()\n      >>> view.addRenderable(Input(\"in0\", \"First name\", bind=\"f0\"))\n      >>> view.addRenderable(Input(\"in1\", \"Last name for ${f0}\", bind=\"f1\"))\n      >>> model = FormModel()\n      >>> form = Form(\"test\", data, model, view, None)\n      >>> renderer = HTMLRenderer()\n      >>> field = form.view.getRenderable('in1')\n      >>> renderer.render(form, field, sys.stdout)\n      <div id=\"in1\" class=\"control input relevant\">\n      <label for=\"input-in1\">Last name for Pipo</label>\n      <div class=\"alert\"></div>\n      <div class=\"hint\"></div>\n      <input id=\"input-in1\" type=\"text\" name=\"in1\" value=\"\" size=\"20\"/>\n      </div>\n\nLet's delve into input processing a bit...\nA simple input should just return it's own value\n\n  >>> data = {'pipo': 'lala'}\n  >>> ctl = Input(\"pipo\", \"f0\", \"Some input\")\n  >>> ctl.processInput(data)\n  'lala'\n\n\nRegistering your own stuff\n==========================\n\nw20e.forms is not a complete library for forms, and it will never be\nthis, since most people have very specific needs, like a specific\nwidget, a custom version of an input field, etc. The API facilitates\nin this by using a global registry to register extensions.\n\nThe global registry is available like so:\n\n  >>> from w20e.forms.registry import Registry\n\nand offers a number of class methods to register stuff. \n\nLet's for exampe register a new renderer for an input:\n\n\nVocabularies\n------------\n\nw20e.forms enables use of vocabularies to limit possible answers to a\ngiven list. This is a feature that is generally used with select\nwidgets. A vocabulary is a 'named' factory that creates a list of\noptions. \n\nRegister like so:\n\n>>> def make_vocab():\n...   return [Option('0', 'Opt 0'), Option('1', 'Opt 1')]\n... Registry.register_vocab('foovocab', make_vocab)\n... sel = Select(\"select0\", \"Select me!\", vocab=make_vocab,\n...   bind=\"field2\", with_empty=True))\n\n\nRequired, Relevant, Readonly\n----------------------------\n\nIn a form you'll usually want to say things like: this control need\nonly be shown whan the answer to that question is 'x', or that\nquestion is required whenever the answer to somethind else is 'y'.\n\nw20e.forms enables this using expressions. The epxressions are set as\nproperties in variables, by their 'bind' attribute. So in the form\nmodel you may have a property set named 'req', that makes\nvariable 'foo' required like so:\n\n  model.addFieldProperties(FieldProperties(\"req\", [\"foo\"], required=\"True\"))\n\nObviously in general you want something a bit more flexible than that,\nlike checking for other data that has been entered. All form data is\nmade available to the expression within the 'data' variable, that is a\ndict. So checking upon some other variable, goes like this:\n\n  model.addFieldProperties(FieldProperties(\"req\", [\"foo\"],\n    required=\"data['bar'] == 42\"))\n\nSo only if the answer to 'bar' is 42, 'foo' is required. Relevance,\nrequiredness and readonly-ness all work like this.\n\nYou may even add your own expression context to the engine, to call\nmethods on objects, etc.\n\nGo like this, assuming your object is obj:\n\n>>> registry.register_expr_context('mycontext', obj)\n... model.addFieldProperties(FieldProperties(\"req\", [\"foo\"],\n...   relevant=\"mycontext.some_method())\n\n\nXML\n===\n\nThe xml namespace of the w20e.forms package provides an XML based\nimplementation of the w20e.forms API. This enables definition from\nand serialization to XML files. Provided is the DTD used for defining\nthe w20e.forms as XML. This is quite similar to xForms.\n\nUsing XML as definition of forms provides a more declarative way of\ncreating forms, not unlike the way you create a form in HTML. Also, XML is a format that is easily stored and transported.\n\n\nStart using the XML factory\n\n      >>> from factory import XMLFormFactory\n\nNow let us create a factory class\n\n      >>> xml = \"\"\"\n      ... <form id=\"test\">\n      ...\n      ...   <!-- The data part, a.k.a. the variables you wish to collect -->\n      ...   <data>\n      ...     <foo/>\n      ...     <bar value=\"666\"/>\n      ...   </data>\n      ...\n      ...   <model>\n      ...     <properties id=\"required\">\n      ...       <bind>foo</bind>\n      ...\t<bind>bar</bind>\n      ...\t<required>True</required>\n      ...     </properties>\n      ...     <properties id=\"int\">\n      ...       <bind>bar</bind>\n      ...\t<datatype>int</datatype>\n      ...     </properties>\n      ...   </model>\n      ...\n      ...   <view>\n      ...     <input id=\"fooctl\" bind=\"foo\">\n      ...       <label>Foo?</label>\n      ...       <hint>Well, foo or no?</hint>\n      ...     </input>\n      ...     <select id=\"barctl\" bind=\"bar\">\n      ...       <property name=\"multiple\">False</property>\n      ...       <label>Bar</label>\n      ...       <option value=\"1\">One</option>\n      ...       <option value=\"2\">Two</option>\n      ...     </select>\n      ...     <select bind=\"bar\" id=\"barctl2\">\n      ...       <label>Bar2</label>\n      ...       <option value=\"3\">Three</option>\n      ...       <option value=\"4\">Four</option>\n      ...     </select>\n      ...     <select bind=\"bar\" id=\"barctl3\">\n      ...       <property name=\"vocab\">some_vocab</property>\n      ...       <label>Bar3</label>\n      ...     </select>\n      ...     <group layout=\"flow\" id=\"groupie\">\n      ...       <label>GruppoSportivo</label>\n      ...       <text id=\"txt\">Moi</text>\n      ...     </group>\n      ...   </view>\n      ...\n      ...   <submission type=\"none\">\n      ...     <property name=\"action\">@@save</property>\n      ...   </submission>\n      ...\n      ... </form>\"\"\"\n\n      We are using a vocab in the xml, so register it...\n      >>> from w20e.forms.registry import Registry\n      ... def some_vocab():\n      ...   return [Option(0, 0), Option(1, 1)]\n      ... Registry.register_vocab('some_vocab', some_vocab)\n\n      >>> xmlff = XMLFormFactory(xml)\n      >>> form = xmlff.create_form()\n      >>> print len(form.data.getFields())\n      2\n\n      >>> print form.data.getField(\"foo\").id\n      foo\n\n      >>> print form.data.getField(\"bar\").value\n      666\n\n      Set the value \n\n      >>> form.data.getField(\"bar\").value = 777\n      >>> print form.data.getField(\"bar\").value\n      777\n\n      Okido, so far so good. Now let's see what properties we have.\n      \n      >>> props = form.model.getFieldProperties(\"bar\")\n      >>> len(props)\n      2\n\n      >>> intprop = [prop for prop in props if prop.id == \"int\"][0]\n      >>> reqprop = [prop for prop in props if prop.id == \"required\"][0]\n      >>> reqprop.getRequired()\n      'True'\n      \n      >>> intprop.getDatatype()\n      'int'\n\n      Finally, check the viewable part, or the controls\n      >>> ctrl = form.view.getRenderable(\"fooctl\")\n      >>> ctrl.label\n      'Foo?'\n\n      >>> ctrl.__class__.__name__\n      'Input'\n\n      >>> ctrl.hint\n      'Well, foo or no?'\n\n      >>> ctrl.id\n      'fooctl'\n\n      >>> ctrl.bind\n      'foo'\n\n      >>> ctrl = form.view.getRenderable(\"barctl\")\n      >>> ctrl.multiple\n      'False'\n\n      >>> len(ctrl.options)\n      2\n\nDo we get the nested stuff?\n      >>> ctrl = form.view.getRenderable(\"txt\")\n      >>> ctrl.id\n      'txt'\n\n\nSerialization\n-------------\n\nYou can easily serilialize the form back into XML. Let's try...\n\n      >>> from serializer import XMLSerializer\n      >>> serializer = XMLSerializer()\n      >>> print serializer.serialize(form)\n      <form id=\"test\">\n        <data>\n          <foo/>\n          <bar value=\"777\"/>\n        </data>\n        <model>\n          <properties id=\"int\">\n            <bind>bar</bind>\n      \t    <datatype>int</datatype>\n          </properties>\n          <properties id=\"required\">\n            <bind>foo</bind>\n     \t    <bind>bar</bind>\n      \t    <required>True</required>\n          </properties>\n        </model>\n\t<view>\n      \t  <input bind=\"foo\" id=\"fooctl\">\n            <label>Foo?</label>\n            <hint>Well, foo or no?</hint>\n          </input>\n          <select bind=\"bar\" id=\"barctl\">\n            <label>Bar</label>\n            <property name=\"multiple\">False</property>\n\t    <option value=\"1\">One</option>\n\t    <option value=\"2\">Two</option>\n          </select>\n          <select bind=\"bar\" id=\"barctl2\">\n            <label>Bar2</label>\n\t    <option value=\"3\">Three</option>\n\t    <option value=\"4\">Four</option>\n          </select>\n          <flowgroup id=\"groupie\">\n            <label>GruppoSportivo</label>\n            <text id=\"txt\"/>\n          </flowgroup>\n        </view>\n        <submission type=\"none\">\n\t  <property name=\"action\">@@save</property>\n\t</submission>\n      </form>\n      <BLANKLINE>\n\nNote that variable foo now holds the value 777. Sadly, it is hard to\nguarantee that all XML will be exactely the same as the input XML.\n\n\nPyramid\n=======\n\nThe pyramid package provides a simple means of using w20e.forms for pyramid\napps. The package provides a specific 'file' field for pyramid, to enable\nextracting filename and contents from a file in a POST/GET request, and a base\nview.\n\nWould you wish to use w20e.forms, then:\n\n * add w20e.forms to the eggs dependencies of your app (duh...)\n\n * for the view that you wish to show the actual form, override\n   w20e.forms.pyramid.pyramidformview. Let's do some imports\n   first. Please note that it is more convenient to use the XML\n   implementation, as shown later on. Also, if you insist on using the\n   Pythonic implementation, it is better to make a factory create the\n   form, so you can just call the factory from your view. Anyway,\n   let's go for the not-so-smart way:\n\n      >>> from w20e.forms.form import Form\n      >>> from w20e.forms.formdata import FormData\n      >>> from w20e.forms.formmodel import FormModel\n      >>> from w20e.forms.formview import FormView\n      >>> from w20e.forms.submission.attrstorage import AttrStorage\n      >>> from w20e.forms.data.field import Field\n      >>> from w20e.forms.rendering.control import Input\n      >>> from w20e.forms.pyramid.formview import formview as pyramidformview\n      \n   Phew, that was a load of imports. Now do the actual view\n   class. It's a pretty simple form, but you should get the picture.\n\n      >>> class yourformview(pyramidformview):\n      ...   def __init__(self, context, request):\n      ...     data = FormData()\n      ...     data.addField(Field(\"foo\", \"some default value\"))\n      ...     data.addField(Field(\"bar\"))\n      ...     model = FormModel() \n      ...     view = FormView()\n      ...     # We'll leave the poperties out for now, check the main\n      ...     # README for details\n      ...     view.addRenderable(Input(\"input0\", \"Input foo\", bind=\"foo\"))\n      ...     view.addRenderable(Input(\"input1\", \"Input bar here\", bind=\"bar\"))\n      ...     submission = AttrStorage(attr_name=\"_data\")\n      ...     form = Form(\"test\", data, model, view, submission)\n      ...     pyramidformview.__init__(self, context, request, form)\n\n   Now, a view for pyramid just takes a context, and a request, so let's \n   create the view instance:\n\n      >>> class Context:\n      ...  \"\"\" nothing needed here, but we'll store the data in here \"\"\"\n      >>> class Request:\n      ...   def __init__(self, params=None):\n      ...     self.params = params\n      >>> ctx = Context()\n      >>> req = Request()\n      >>> view = yourformview(ctx, req)\n\n   Ok, we're ready for some action now. Let's try to render the form.\n\n      >>> print view.renderform()\n      <form class=\"w20e-form\" method=\"post\" action=\"\" enctype=\"multipart/form-data\">\n      <input type=\"hidden\" name=\"formprocess\" value=\"1\"/>\n      <div class=\"alert\"></div>\n      <div id=\"input0\" class=\"control input relevant\">\n      <label for=\"input-input0\">Input foo</label>\n      <div class=\"alert\"></div>\n      <div class=\"hint\"></div>\n      <input id=\"input-input0\" type=\"text\" name=\"input0\" value=\"some default value\" size=\"20\"/>\n      </div>\n      <div id=\"input1\" class=\"control input relevant\">\n      <label for=\"input-input1\">Input bar here</label>\n      <div class=\"alert\"></div>\n      <div class=\"hint\"></div>\n      <input id=\"input-input1\" type=\"text\" name=\"input1\" value=\"\" size=\"20\"/>\n      </div>\n      </form>\n      <BLANKLINE>\n\n   Nice. Now let's give the request some content, and let the view handle the\n   submission. This should result in the context having the form data stored\n   in the _data attribute. formprocess is the marker used by w20e.forms\n   to assume that the form is posted.\n\n      >>> req = Request({'formprocess': 1, 'input0': 6, 'input1': 'whatever'})\n      >>> view = yourformview(ctx, req)\n      >>> view()\n      {'status': 'stored', 'errors': {}}\n      >>> ctx._data.getField('foo').value\n      6\n      >>> ctx._data.getField('bar').value\n      'whatever'\n\n\nXML implementation\n------------------\n\n   Using the XML implementation makes life even easier::\n\n     from w20e.forms.pyramid.formview import xmlformview as pyramidformview\n     from w20e.forms.xml.formfile import FormFile\n\n     class yourformview(pyramidformview):\n     \n       def __init__(self, context, request):\n           pyramidformview.__init__(self, context, request, FormFile(\"forms/yourform.xml\"))\n\n   where you have a directory 'forms' containing the XML definition\n   called yourform.xml. Check the w20e.forms.xml module for details\n   on XML definitions.\n\n\n * Create a template (form.pt for example) that calls the render\n   method of the view::\n\n     <p tal:content=\"structure python:view.renderform()\"></p>\n\n\n * Wire the stuff into zcml (assuming you use that), like so::\n   \n     <view\n       context=\".models.YourModel\"\n       view=\".views.yourformview\"\n       renderer=\"templates/form.pt\"\n       name=\"yourform\"\n       />", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "UNKNOWN", "keywords": "forms", "license": "GPL", "maintainer": null, "maintainer_email": null, "name": "w20e.forms", "package_url": "https://pypi.org/project/w20e.forms/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/w20e.forms/", "project_urls": {"Download": "UNKNOWN", "Homepage": "UNKNOWN"}, "release_url": "https://pypi.org/project/w20e.forms/1.0.2b/", "requires_dist": null, "requires_python": null, "summary": "Python API for creating and handling forms", "version": "1.0.2b", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"table-of-contents\">\n<p>Table of Contents</p>\n<ul>\n<li><a href=\"#core-concepts\" id=\"id1\" rel=\"nofollow\">Core concepts</a><ul>\n<li><a href=\"#data\" id=\"id2\" rel=\"nofollow\">Data</a></li>\n<li><a href=\"#model\" id=\"id3\" rel=\"nofollow\">Model</a></li>\n<li><a href=\"#view\" id=\"id4\" rel=\"nofollow\">View</a></li>\n</ul>\n</li>\n<li><a href=\"#basic-use\" id=\"id5\" rel=\"nofollow\">Basic use</a><ul>\n<li><a href=\"#creating-a-form\" id=\"id6\" rel=\"nofollow\">Creating a form</a></li>\n<li><a href=\"#display\" id=\"id7\" rel=\"nofollow\">Display</a></li>\n<li><a href=\"#submission\" id=\"id8\" rel=\"nofollow\">Submission</a></li>\n</ul>\n</li>\n<li><a href=\"#beyond-the-basics\" id=\"id9\" rel=\"nofollow\">Beyond the basics</a></li>\n<li><a href=\"#registering-your-own-stuff\" id=\"id10\" rel=\"nofollow\">Registering your own stuff</a><ul>\n<li><a href=\"#vocabularies\" id=\"id11\" rel=\"nofollow\">Vocabularies</a></li>\n<li><a href=\"#required-relevant-readonly\" id=\"id12\" rel=\"nofollow\">Required, Relevant, Readonly</a></li>\n</ul>\n</li>\n<li><a href=\"#xml\" id=\"id13\" rel=\"nofollow\">XML</a><ul>\n<li><a href=\"#serialization\" id=\"id14\" rel=\"nofollow\">Serialization</a></li>\n</ul>\n</li>\n<li><a href=\"#pyramid\" id=\"id15\" rel=\"nofollow\">Pyramid</a><ul>\n<li><a href=\"#xml-implementation\" id=\"id16\" rel=\"nofollow\">XML implementation</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<p>The w20e.forms package provides a powerful API for creating and\nhandling electronic forms. The package is loosely based on XForms\nconcepts (and Socrates QE, a Java implementation). The package intends\nto provide a drop-in alternative for standard plone, pyramid and\ndjango solutions, but is useable in any framework (or without a\nframework\u2026).</p>\n<div id=\"core-concepts\">\n<h2><a href=\"#id1\" rel=\"nofollow\">Core concepts</a></h2>\n<p>The core concepts are as follows (so you can quickly decide whether\nyou like this approach or not):</p>\n<p>A form is a container for/composition of four things:</p>\n<ol>\n<li>data</li>\n<li>model</li>\n<li>view</li>\n<li>submission</li>\n</ol>\n<p>This clearly separates the data, the data\u2019s properties (datatype,\nwhether something is required or not, etc.) and the renderable part of\nthe form. This is also the main difference between this API and other\nsolutions (afaik\u2026). Where the usual approach is to define a form\nbased on a <em>Schema</em> or other data-centered notion, like so:</p>\n<pre>foo = String(\"id\", \"label\", validator=somefunction)\n</pre>\n<p>the approach of w20e.forms is to define:</p>\n<pre>foo = Field(\"fid\")\nprops = FieldProperties(\"pid\", [\"fid\"], required=True, datatype=int)\nctrl = Input(\"cid\", \"label\", bind=\"fid\")\n</pre>\n<p>where the properties and control are <em>bound</em> to the variable. This\nenables controls in your form that are not bound to any data you wish\nto collect, sharing of properties, etc.</p>\n<p>Another important difference is that the API provides a structured way\nof defining properties for data, instead of having to define your own\nvalidation. See section 1.2 for details.</p>\n<div id=\"data\">\n<h3><a href=\"#id2\" rel=\"nofollow\">Data</a></h3>\n<p>The data holds the variables you wish to collect with this form. A\nvariable simply has an id, and if you like a default value.</p>\n</div>\n<div id=\"model\">\n<h3><a href=\"#id3\" rel=\"nofollow\">Model</a></h3>\n<p>The model holds all properties for a given form, like readonly-ness,\nrequiredness, datatyping for variables, relevance, etc. All these\nproperties are calculated from expressions, in this case Python\nexpressions, so requiredness is not just true or false, it can be\ncalculated based on an expression that can include other variables in\nyour data. All variables from the form data are available in\nexpressions via the \u2018data\u2019 dict, so if variable \u2018foo\u2019 would be\nrequired if variable \u2018bar\u2019 was set to 666, this can be expressed like\nso in the properties bound to foo:</p>\n<blockquote>\n\u2026 required=\u201ddata[\u2018bar\u2019] == 666\u201d \u2026</blockquote>\n<p>In general, all expressions are eval-ed to something true or\nfalse. The model offers the following properties:</p>\n<ul>\n<li>required: is a variable required or not?</li>\n<li>relevant: is the variable relevant? Like maiden name would be irrelevant\nwhen gender is male. In general, the related control/widget for irrelevant\nvariables would not be shown.</li>\n<li>readonly: can a person change the value of a variable?</li>\n<li>calculate: in stead of letting a person set the value of a variable, the\nvariable is calculated.</li>\n<li>constraint: check whether the expression evaluates to True.</li>\n<li>datatype: datatype for the variable, like int, string, or more complex\nvariables.</li>\n</ul>\n<p>Properties are bound to variables by a bind attribute. A set of\nproperties can be bound to a series of variables.</p>\n</div>\n<div id=\"view\">\n<h3><a href=\"#id4\" rel=\"nofollow\">View</a></h3>\n<p>The view (or FormView) is the actual visible part (or audible for that\nmatter) of the form. The view can be rendered and holds a collection\nof widgets or controls, that are bound to variables. More than one\ncontrol can bind to the same variable. Controls can be grouped in\ngroups for layout purposes, like flow layout or card layout (tabs).</p>\n<p>In label and hint texts of controls you can use lexical values of\nvariables by using the expression ${&lt;var name&gt;}. This way you can refer to\nvalues given in other variables from your labels and hints.</p>\n</div>\n</div>\n<div id=\"basic-use\">\n<h2><a href=\"#id5\" rel=\"nofollow\">Basic use</a></h2>\n<p>Ok, enough theory, let\u2019s do something for real.</p>\n<p>A form is produced by hand, or by using a factory: this should take\ncare of producing a form holding the necessary stuff.</p>\n<p>Let\u2019s get the imports over with\u2026</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; from interfaces import *\n&gt;&gt;&gt; from zope.interface import implements\n&gt;&gt;&gt; from formdata import FormData\n&gt;&gt;&gt; from formview import FormView\n&gt;&gt;&gt; from formmodel import FormModel\n&gt;&gt;&gt; from data.field import Field\n&gt;&gt;&gt; from model.fieldproperties import FieldProperties\n&gt;&gt;&gt; from rendering.control import Input, Select, Option\n&gt;&gt;&gt; from rendering.group import FlowGroup\n&gt;&gt;&gt; from form import Form, FormValidationError\n&gt;&gt;&gt; from rendering.html.renderer import HTMLRenderer\n&gt;&gt;&gt; from submission.attrstorage import AttrStorage\n</pre>\n</blockquote>\n<div id=\"creating-a-form\">\n<h3><a href=\"#id6\" rel=\"nofollow\">Creating a form</a></h3>\n<p>Now let us create a factory class</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class FormFactory():\n...   implements(IFormFactory)\n...   def createForm(self):\n...     data = FormData()\n...     data.addField(Field(\"field0\"))\n...     data.addField(Field(\"field1\", \"foo\"))\n...     data.addField(Field(\"field2\", \"bar\"))\n...     data.addField(Field(\"field3\"))\n...     view = FormView()\n...     grp = FlowGroup(\"grp0\", label=\"Group 0\")\n...     grp.addRenderable(Input(\"input2\", \"Input 2\", bind=\"field0\"))\n...     view.addRenderable(Input(\"input0\", \"First name\", bind=\"field0\"))\n...     view.addRenderable(Input(\"input1\", \"Last name\", bind=\"field1\"))\n...     view.addRenderable(Select(\"select0\", \"Select me!\", options=[], bind=\"field2\", with_empty=True))\n...     view.addRenderable(grp)\n...     model = FormModel()\n...     model.addFieldProperties(FieldProperties(\"prop0\", [\"field0\"], required=\"True\"))\n...     model.addFieldProperties(FieldProperties(\"prop1\", [\"field1\", \"field2\"], relevant=\"data['field0']\"))\n...     submission = AttrStorage(attr_name=\"_data\")\n...     return Form(\"test\", data, model, view, submission)\n</pre>\n<pre>&gt;&gt;&gt; ff = FormFactory()\n&gt;&gt;&gt; form = ff.createForm()\n</pre>\n</blockquote>\n<p>By now, we should have a form where field0 is required, and field1 and\nfield2 are only relevant if field0 is filled in.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print len(form.data.getFields())\n4\n</pre>\n<pre>&gt;&gt;&gt; props = form.model.getFieldProperties(\"field0\")\n&gt;&gt;&gt; props[0].id\n'prop0'\n</pre>\n<pre>&gt;&gt;&gt; len(props)\n1\n</pre>\n<pre>&gt;&gt;&gt; field0 = form.data.getField(\"field0\")\n&gt;&gt;&gt; field0.id\n'field0'\n</pre>\n<pre>&gt;&gt;&gt; field0.value\n</pre>\n</blockquote>\n<p>In the meanwhile, field1 and field2 should be irrelevant, given that field0\nhas no value</p>\n<blockquote>\n<pre>&gt;&gt;&gt; form.model.isRelevant(\"field1\", form.data)\nFalse\n&gt;&gt;&gt; form.model.isRelevant(\"field2\", form.data)\nFalse\n</pre>\n</blockquote>\n<p>Validation should fail, given that field0 is required.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; try:\n...   form.validate()\n... except FormValidationError:\n...   print sys.exc_info()[1].errors['field0']\n['required']\n</pre>\n<pre>&gt;&gt;&gt; form.data.getField(\"field0\").value = \"pipo\"\n&gt;&gt;&gt; form.validate()\nTrue\n</pre>\n<pre>&gt;&gt;&gt; field0.value\n'pipo'\n</pre>\n</blockquote>\n<p>By now, field1 and field2 should also be relevant</p>\n<blockquote>\n<pre>&gt;&gt;&gt; form.model.isRelevant(\"field1\", form.data)\nTrue\n&gt;&gt;&gt; form.model.isRelevant(\"field2\", form.data)\nTrue\n</pre>\n</blockquote>\n</div>\n<div id=\"display\">\n<h3><a href=\"#id7\" rel=\"nofollow\">Display</a></h3>\n<p>The following section will assume rendering to HTML. This will most\nlikely cover nigh 100% of the use cases\u2026\nNow for some display parts. An irrelevant control should\nnot have a class \u2018relevant\u2019, otherwise it should have it\u2026 This\nenables specific styling, like \u2018display: none\u2019.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; form.data.getField('field0').value = None\n&gt;&gt;&gt; field = form.view.getRenderable('input1')\n&gt;&gt;&gt; renderer = HTMLRenderer()\n&gt;&gt;&gt; renderer.render(form, field, sys.stdout)\n&lt;div id=\"input1\" class=\"control input \"&gt;\n&lt;label for=\"input-input1\"&gt;Last name&lt;/label&gt;\n&lt;div class=\"alert\"&gt;&lt;/div&gt;\n&lt;div class=\"hint\"&gt;&lt;/div&gt;\n&lt;input id=\"input-input1\" type=\"text\" name=\"input1\" value=\"foo\" size=\"20\"/&gt;\n&lt;/div&gt;\n</pre>\n<pre>&gt;&gt;&gt; form.data.getField('field0').value = 'pipo'\n&gt;&gt;&gt; field = form.view.getRenderable('input1')\n&gt;&gt;&gt; renderer = HTMLRenderer()\n&gt;&gt;&gt; renderer.render(form, field, sys.stdout)\n&lt;div id=\"input1\" class=\"control input relevant\"&gt;\n&lt;label for=\"input-input1\"&gt;Last name&lt;/label&gt;\n&lt;div class=\"alert\"&gt;&lt;/div&gt;\n&lt;div class=\"hint\"&gt;&lt;/div&gt;\n&lt;input id=\"input-input1\" type=\"text\" name=\"input1\" value=\"foo\" size=\"20\"/&gt;\n&lt;/div&gt;\n</pre>\n<pre>&gt;&gt;&gt; field = form.view.getRenderable('input0')\n&gt;&gt;&gt; renderer.render(form, field, sys.stdout)\n&lt;div id=\"input0\" class=\"control input relevant required\"&gt;\n&lt;label for=\"input-input0\"&gt;First name&lt;/label&gt;\n&lt;div class=\"alert\"&gt;&lt;/div&gt;\n&lt;div class=\"hint\"&gt;&lt;/div&gt;\n&lt;input id=\"input-input0\" type=\"text\" name=\"input0\" value=\"pipo\" size=\"20\"/&gt;\n&lt;/div&gt;\n</pre>\n</blockquote>\n<p>How \u2018bout those extra classes\u2026</p>\n<blockquote>\n<pre>&gt;&gt;&gt; renderer.render(form, field, sys.stdout, extra_classes=\"card\")\n&lt;div id=\"input0\" class=\"control input card relevant required\"&gt;\n&lt;label for=\"input-input0\"&gt;First name&lt;/label&gt;\n&lt;div class=\"alert\"&gt;&lt;/div&gt;\n&lt;div class=\"hint\"&gt;&lt;/div&gt;\n&lt;input id=\"input-input0\" type=\"text\" name=\"input0\" value=\"pipo\" size=\"20\"/&gt;\n&lt;/div&gt;\n</pre>\n<pre>&gt;&gt;&gt; select = form.view.getRenderable('select0')\n&gt;&gt;&gt; renderer.render(form, select, sys.stdout)\n&lt;div id=\"select0\" class=\"control select relevant\"&gt;\n&lt;label for=\"input-select0\"&gt;Select me!&lt;/label&gt;\n&lt;div class=\"alert\"&gt;&lt;/div&gt;\n&lt;div class=\"hint\"&gt;&lt;/div&gt;\n&lt;select id=\"input-select0\" name=\"select0\"  size=\"1\"&gt;\n&lt;option value=\"\" &gt;Maak een keuze&lt;/option&gt;\n&lt;/select&gt;\n&lt;/div&gt;\n</pre>\n</blockquote>\n<p>Do we actually get grouped controls?</p>\n<blockquote>\n<pre>&gt;&gt;&gt; nested_input = form.view.getRenderable('input2')\n&gt;&gt;&gt; nested_input.id\n'input2'\n</pre>\n</blockquote>\n</div>\n<div id=\"submission\">\n<h3><a href=\"#id8\" rel=\"nofollow\">Submission</a></h3>\n<p>Finally when the form is rendered, filled in by someone, and\nvalidated, the data should normally go somewhere. This is by way of\nsubmission. We defined submission to be AttrStorage, something that\nstores the data in an attribute on some context. This is a case that\ncould be used in many frameworks, at least plone and pyramid.</p>\n<p>Let\u2019s see what it does:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Context:\n...   \"\"\" some context \"\"\"\n&gt;&gt;&gt; ctx = Context()\n&gt;&gt;&gt; form.submission.submit(form, ctx)\n</pre>\n</blockquote>\n<p>The context now should hold the data in an attribute. We specified the\nname of the attribute to be \u2018_data\u2019, so let\u2019s check:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; ctx._data.getField('field0').value\n'pipo'\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"beyond-the-basics\">\n<h2><a href=\"#id9\" rel=\"nofollow\">Beyond the basics</a></h2>\n<p>Well, this is all very simple, and it is quite likely that you would\nwish for something a bit more usefull. All parts of the form are there\nto be extended. Take for instance the FormView. A developer (or end\nuser) should be able to:</p>\n<blockquote>\n<ul>\n<li>create a full HTML form;</li>\n<li>use a generated HTML form (this is wat the base implementation does);</li>\n<li>create a PDF form.</li>\n</ul>\n</blockquote>\n<p>The factory is also an important part of the form process. A factory\ncan be imagined to be one of the following:</p>\n<blockquote>\n<ul>\n<li>produced from a Schema (content type);</li>\n<li>produced from an XML definition, for example an XForms instance from\nOpenOffice.</li>\n</ul>\n</blockquote>\n<p>Forms in general should be:</p>\n<blockquote>\n<ul>\n<li>submitable to a range of handlers, like email, database storage,\ncontent type storage;</li>\n<li>easy to validate \u2018live;</li>\n<li>enable multi-page.</li>\n</ul>\n</blockquote>\n<p>More detailed tests:</p>\n<p>We\u2019d like to check whether lookup of a control by bind works, so as to\nbe able to process values into lexical values. This is especially\ninteresting when using selects: we\u2019d expect to see the label not the\nvalue in lexical space.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = FormData()\n&gt;&gt;&gt; data.addField(Field(\"f0\", \"opt0\"))\n&gt;&gt;&gt; view = FormView()\n&gt;&gt;&gt; opts = [Option(\"opt0\", \"Option 0\"), Option(\"opt1\", \"Option 1\")]\n&gt;&gt;&gt; view.addRenderable(Select(\"sel0\", \"Select 0\", bind=\"f0\", options=opts))\n&gt;&gt;&gt; ctl = view.getRenderableByBind(\"f0\")\n&gt;&gt;&gt; ctl.lexVal(\"opt0\")\n'Option 0'\n</pre>\n</blockquote>\n<p>Can we use variable substitution in labels and hints? Yes, we can!</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = FormData()\n&gt;&gt;&gt; data.addField(Field(\"f0\", \"Pipo\"))\n&gt;&gt;&gt; data.addField(Field(\"f1\"))\n&gt;&gt;&gt; view = FormView()\n&gt;&gt;&gt; view.addRenderable(Input(\"in0\", \"First name\", bind=\"f0\"))\n&gt;&gt;&gt; view.addRenderable(Input(\"in1\", \"Last name for ${f0}\", bind=\"f1\"))\n&gt;&gt;&gt; model = FormModel()\n&gt;&gt;&gt; form = Form(\"test\", data, model, view, None)\n&gt;&gt;&gt; renderer = HTMLRenderer()\n&gt;&gt;&gt; field = form.view.getRenderable('in1')\n&gt;&gt;&gt; renderer.render(form, field, sys.stdout)\n&lt;div id=\"in1\" class=\"control input relevant\"&gt;\n&lt;label for=\"input-in1\"&gt;Last name for Pipo&lt;/label&gt;\n&lt;div class=\"alert\"&gt;&lt;/div&gt;\n&lt;div class=\"hint\"&gt;&lt;/div&gt;\n&lt;input id=\"input-in1\" type=\"text\" name=\"in1\" value=\"\" size=\"20\"/&gt;\n&lt;/div&gt;\n</pre>\n</blockquote>\n<p>Let\u2019s delve into input processing a bit\u2026\nA simple input should just return it\u2019s own value</p>\n<blockquote>\n<pre>&gt;&gt;&gt; data = {'pipo': 'lala'}\n&gt;&gt;&gt; ctl = Input(\"pipo\", \"f0\", \"Some input\")\n&gt;&gt;&gt; ctl.processInput(data)\n'lala'\n</pre>\n</blockquote>\n</div>\n<div id=\"registering-your-own-stuff\">\n<h2><a href=\"#id10\" rel=\"nofollow\">Registering your own stuff</a></h2>\n<p>w20e.forms is not a complete library for forms, and it will never be\nthis, since most people have very specific needs, like a specific\nwidget, a custom version of an input field, etc. The API facilitates\nin this by using a global registry to register extensions.</p>\n<p>The global registry is available like so:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from w20e.forms.registry import Registry\n</pre>\n</blockquote>\n<p>and offers a number of class methods to register stuff.</p>\n<p>Let\u2019s for exampe register a new renderer for an input:</p>\n<div id=\"vocabularies\">\n<h3><a href=\"#id11\" rel=\"nofollow\">Vocabularies</a></h3>\n<p>w20e.forms enables use of vocabularies to limit possible answers to a\ngiven list. This is a feature that is generally used with select\nwidgets. A vocabulary is a \u2018named\u2019 factory that creates a list of\noptions.</p>\n<p>Register like so:</p>\n<pre>&gt;&gt;&gt; def make_vocab():\n...   return [Option('0', 'Opt 0'), Option('1', 'Opt 1')]\n... Registry.register_vocab('foovocab', make_vocab)\n... sel = Select(\"select0\", \"Select me!\", vocab=make_vocab,\n...   bind=\"field2\", with_empty=True))\n</pre>\n</div>\n<div id=\"required-relevant-readonly\">\n<h3><a href=\"#id12\" rel=\"nofollow\">Required, Relevant, Readonly</a></h3>\n<p>In a form you\u2019ll usually want to say things like: this control need\nonly be shown whan the answer to that question is \u2018x\u2019, or that\nquestion is required whenever the answer to somethind else is \u2018y\u2019.</p>\n<p>w20e.forms enables this using expressions. The epxressions are set as\nproperties in variables, by their \u2018bind\u2019 attribute. So in the form\nmodel you may have a property set named \u2018req\u2019, that makes\nvariable \u2018foo\u2019 required like so:</p>\n<blockquote>\nmodel.addFieldProperties(FieldProperties(\u201creq\u201d, [\u201cfoo\u201d], required=\u201dTrue\u201d))</blockquote>\n<p>Obviously in general you want something a bit more flexible than that,\nlike checking for other data that has been entered. All form data is\nmade available to the expression within the \u2018data\u2019 variable, that is a\ndict. So checking upon some other variable, goes like this:</p>\n<blockquote>\n<dl>\n<dt>model.addFieldProperties(FieldProperties(\u201creq\u201d, [\u201cfoo\u201d],</dt>\n<dd>required=\u201ddata[\u2018bar\u2019] == 42\u201d))</dd>\n</dl>\n</blockquote>\n<p>So only if the answer to \u2018bar\u2019 is 42, \u2018foo\u2019 is required. Relevance,\nrequiredness and readonly-ness all work like this.</p>\n<p>You may even add your own expression context to the engine, to call\nmethods on objects, etc.</p>\n<p>Go like this, assuming your object is obj:</p>\n<pre>&gt;&gt;&gt; registry.register_expr_context('mycontext', obj)\n... model.addFieldProperties(FieldProperties(\"req\", [\"foo\"],\n...   relevant=\"mycontext.some_method())\n</pre>\n</div>\n</div>\n<div id=\"xml\">\n<h2><a href=\"#id13\" rel=\"nofollow\">XML</a></h2>\n<p>The xml namespace of the w20e.forms package provides an XML based\nimplementation of the w20e.forms API. This enables definition from\nand serialization to XML files. Provided is the DTD used for defining\nthe w20e.forms as XML. This is quite similar to xForms.</p>\n<p>Using XML as definition of forms provides a more declarative way of\ncreating forms, not unlike the way you create a form in HTML. Also, XML is a format that is easily stored and transported.</p>\n<p>Start using the XML factory</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from factory import XMLFormFactory\n</pre>\n</blockquote>\n<p>Now let us create a factory class</p>\n<blockquote>\n<pre>&gt;&gt;&gt; xml = \"\"\"\n... &lt;form id=\"test\"&gt;\n...\n...   &lt;!-- The data part, a.k.a. the variables you wish to collect --&gt;\n...   &lt;data&gt;\n...     &lt;foo/&gt;\n...     &lt;bar value=\"666\"/&gt;\n...   &lt;/data&gt;\n...\n...   &lt;model&gt;\n...     &lt;properties id=\"required\"&gt;\n...       &lt;bind&gt;foo&lt;/bind&gt;\n...       &lt;bind&gt;bar&lt;/bind&gt;\n...       &lt;required&gt;True&lt;/required&gt;\n...     &lt;/properties&gt;\n...     &lt;properties id=\"int\"&gt;\n...       &lt;bind&gt;bar&lt;/bind&gt;\n...       &lt;datatype&gt;int&lt;/datatype&gt;\n...     &lt;/properties&gt;\n...   &lt;/model&gt;\n...\n...   &lt;view&gt;\n...     &lt;input id=\"fooctl\" bind=\"foo\"&gt;\n...       &lt;label&gt;Foo?&lt;/label&gt;\n...       &lt;hint&gt;Well, foo or no?&lt;/hint&gt;\n...     &lt;/input&gt;\n...     &lt;select id=\"barctl\" bind=\"bar\"&gt;\n...       &lt;property name=\"multiple\"&gt;False&lt;/property&gt;\n...       &lt;label&gt;Bar&lt;/label&gt;\n...       &lt;option value=\"1\"&gt;One&lt;/option&gt;\n...       &lt;option value=\"2\"&gt;Two&lt;/option&gt;\n...     &lt;/select&gt;\n...     &lt;select bind=\"bar\" id=\"barctl2\"&gt;\n...       &lt;label&gt;Bar2&lt;/label&gt;\n...       &lt;option value=\"3\"&gt;Three&lt;/option&gt;\n...       &lt;option value=\"4\"&gt;Four&lt;/option&gt;\n...     &lt;/select&gt;\n...     &lt;select bind=\"bar\" id=\"barctl3\"&gt;\n...       &lt;property name=\"vocab\"&gt;some_vocab&lt;/property&gt;\n...       &lt;label&gt;Bar3&lt;/label&gt;\n...     &lt;/select&gt;\n...     &lt;group layout=\"flow\" id=\"groupie\"&gt;\n...       &lt;label&gt;GruppoSportivo&lt;/label&gt;\n...       &lt;text id=\"txt\"&gt;Moi&lt;/text&gt;\n...     &lt;/group&gt;\n...   &lt;/view&gt;\n...\n...   &lt;submission type=\"none\"&gt;\n...     &lt;property name=\"action\"&gt;@@save&lt;/property&gt;\n...   &lt;/submission&gt;\n...\n... &lt;/form&gt;\"\"\"\n</pre>\n<p>We are using a vocab in the xml, so register it\u2026\n&gt;&gt;&gt; from w20e.forms.registry import Registry\n\u2026 def some_vocab():\n\u2026   return [Option(0, 0), Option(1, 1)]\n\u2026 Registry.register_vocab(\u2018some_vocab\u2019, some_vocab)</p>\n<pre>&gt;&gt;&gt; xmlff = XMLFormFactory(xml)\n&gt;&gt;&gt; form = xmlff.create_form()\n&gt;&gt;&gt; print len(form.data.getFields())\n2\n</pre>\n<pre>&gt;&gt;&gt; print form.data.getField(\"foo\").id\nfoo\n</pre>\n<pre>&gt;&gt;&gt; print form.data.getField(\"bar\").value\n666\n</pre>\n<p>Set the value</p>\n<pre>&gt;&gt;&gt; form.data.getField(\"bar\").value = 777\n&gt;&gt;&gt; print form.data.getField(\"bar\").value\n777\n</pre>\n<p>Okido, so far so good. Now let\u2019s see what properties we have.</p>\n<pre>&gt;&gt;&gt; props = form.model.getFieldProperties(\"bar\")\n&gt;&gt;&gt; len(props)\n2\n</pre>\n<pre>&gt;&gt;&gt; intprop = [prop for prop in props if prop.id == \"int\"][0]\n&gt;&gt;&gt; reqprop = [prop for prop in props if prop.id == \"required\"][0]\n&gt;&gt;&gt; reqprop.getRequired()\n'True'\n</pre>\n<pre>&gt;&gt;&gt; intprop.getDatatype()\n'int'\n</pre>\n<p>Finally, check the viewable part, or the controls\n&gt;&gt;&gt; ctrl = form.view.getRenderable(\u201cfooctl\u201d)\n&gt;&gt;&gt; ctrl.label\n\u2018Foo?\u2019</p>\n<pre>&gt;&gt;&gt; ctrl.__class__.__name__\n'Input'\n</pre>\n<pre>&gt;&gt;&gt; ctrl.hint\n'Well, foo or no?'\n</pre>\n<pre>&gt;&gt;&gt; ctrl.id\n'fooctl'\n</pre>\n<pre>&gt;&gt;&gt; ctrl.bind\n'foo'\n</pre>\n<pre>&gt;&gt;&gt; ctrl = form.view.getRenderable(\"barctl\")\n&gt;&gt;&gt; ctrl.multiple\n'False'\n</pre>\n<pre>&gt;&gt;&gt; len(ctrl.options)\n2\n</pre>\n</blockquote>\n<dl>\n<dt>Do we get the nested stuff?</dt>\n<dd><pre>&gt;&gt;&gt; ctrl = form.view.getRenderable(\"txt\")\n&gt;&gt;&gt; ctrl.id\n'txt'\n</pre>\n</dd>\n</dl>\n<div id=\"serialization\">\n<h3><a href=\"#id14\" rel=\"nofollow\">Serialization</a></h3>\n<p>You can easily serilialize the form back into XML. Let\u2019s try\u2026</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from serializer import XMLSerializer\n&gt;&gt;&gt; serializer = XMLSerializer()\n&gt;&gt;&gt; print serializer.serialize(form)\n&lt;form id=\"test\"&gt;\n  &lt;data&gt;\n    &lt;foo/&gt;\n    &lt;bar value=\"777\"/&gt;\n  &lt;/data&gt;\n  &lt;model&gt;\n    &lt;properties id=\"int\"&gt;\n      &lt;bind&gt;bar&lt;/bind&gt;\n      &lt;datatype&gt;int&lt;/datatype&gt;\n    &lt;/properties&gt;\n    &lt;properties id=\"required\"&gt;\n      &lt;bind&gt;foo&lt;/bind&gt;\n      &lt;bind&gt;bar&lt;/bind&gt;\n      &lt;required&gt;True&lt;/required&gt;\n    &lt;/properties&gt;\n  &lt;/model&gt;\n  &lt;view&gt;\n    &lt;input bind=\"foo\" id=\"fooctl\"&gt;\n      &lt;label&gt;Foo?&lt;/label&gt;\n      &lt;hint&gt;Well, foo or no?&lt;/hint&gt;\n    &lt;/input&gt;\n    &lt;select bind=\"bar\" id=\"barctl\"&gt;\n      &lt;label&gt;Bar&lt;/label&gt;\n      &lt;property name=\"multiple\"&gt;False&lt;/property&gt;\n      &lt;option value=\"1\"&gt;One&lt;/option&gt;\n      &lt;option value=\"2\"&gt;Two&lt;/option&gt;\n    &lt;/select&gt;\n    &lt;select bind=\"bar\" id=\"barctl2\"&gt;\n      &lt;label&gt;Bar2&lt;/label&gt;\n      &lt;option value=\"3\"&gt;Three&lt;/option&gt;\n      &lt;option value=\"4\"&gt;Four&lt;/option&gt;\n    &lt;/select&gt;\n    &lt;flowgroup id=\"groupie\"&gt;\n      &lt;label&gt;GruppoSportivo&lt;/label&gt;\n      &lt;text id=\"txt\"/&gt;\n    &lt;/flowgroup&gt;\n  &lt;/view&gt;\n  &lt;submission type=\"none\"&gt;\n    &lt;property name=\"action\"&gt;@@save&lt;/property&gt;\n  &lt;/submission&gt;\n&lt;/form&gt;\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n<p>Note that variable foo now holds the value 777. Sadly, it is hard to\nguarantee that all XML will be exactely the same as the input XML.</p>\n</div>\n</div>\n<div id=\"pyramid\">\n<h2><a href=\"#id15\" rel=\"nofollow\">Pyramid</a></h2>\n<p>The pyramid package provides a simple means of using w20e.forms for pyramid\napps. The package provides a specific \u2018file\u2019 field for pyramid, to enable\nextracting filename and contents from a file in a POST/GET request, and a base\nview.</p>\n<p>Would you wish to use w20e.forms, then:</p>\n<blockquote>\n<ul>\n<li><p>add w20e.forms to the eggs dependencies of your app (duh\u2026)</p>\n</li>\n<li><p>for the view that you wish to show the actual form, override\nw20e.forms.pyramid.pyramidformview. Let\u2019s do some imports\nfirst. Please note that it is more convenient to use the XML\nimplementation, as shown later on. Also, if you insist on using the\nPythonic implementation, it is better to make a factory create the\nform, so you can just call the factory from your view. Anyway,\nlet\u2019s go for the not-so-smart way:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from w20e.forms.form import Form\n&gt;&gt;&gt; from w20e.forms.formdata import FormData\n&gt;&gt;&gt; from w20e.forms.formmodel import FormModel\n&gt;&gt;&gt; from w20e.forms.formview import FormView\n&gt;&gt;&gt; from w20e.forms.submission.attrstorage import AttrStorage\n&gt;&gt;&gt; from w20e.forms.data.field import Field\n&gt;&gt;&gt; from w20e.forms.rendering.control import Input\n&gt;&gt;&gt; from w20e.forms.pyramid.formview import formview as pyramidformview\n</pre>\n</blockquote>\n<p>Phew, that was a load of imports. Now do the actual view\nclass. It\u2019s a pretty simple form, but you should get the picture.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class yourformview(pyramidformview):\n...   def __init__(self, context, request):\n...     data = FormData()\n...     data.addField(Field(\"foo\", \"some default value\"))\n...     data.addField(Field(\"bar\"))\n...     model = FormModel()\n...     view = FormView()\n...     # We'll leave the poperties out for now, check the main\n...     # README for details\n...     view.addRenderable(Input(\"input0\", \"Input foo\", bind=\"foo\"))\n...     view.addRenderable(Input(\"input1\", \"Input bar here\", bind=\"bar\"))\n...     submission = AttrStorage(attr_name=\"_data\")\n...     form = Form(\"test\", data, model, view, submission)\n...     pyramidformview.__init__(self, context, request, form)\n</pre>\n</blockquote>\n<p>Now, a view for pyramid just takes a context, and a request, so let\u2019s\ncreate the view instance:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class Context:\n...  \"\"\" nothing needed here, but we'll store the data in here \"\"\"\n&gt;&gt;&gt; class Request:\n...   def __init__(self, params=None):\n...     self.params = params\n&gt;&gt;&gt; ctx = Context()\n&gt;&gt;&gt; req = Request()\n&gt;&gt;&gt; view = yourformview(ctx, req)\n</pre>\n</blockquote>\n<p>Ok, we\u2019re ready for some action now. Let\u2019s try to render the form.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; print view.renderform()\n&lt;form class=\"w20e-form\" method=\"post\" action=\"\" enctype=\"multipart/form-data\"&gt;\n&lt;input type=\"hidden\" name=\"formprocess\" value=\"1\"/&gt;\n&lt;div class=\"alert\"&gt;&lt;/div&gt;\n&lt;div id=\"input0\" class=\"control input relevant\"&gt;\n&lt;label for=\"input-input0\"&gt;Input foo&lt;/label&gt;\n&lt;div class=\"alert\"&gt;&lt;/div&gt;\n&lt;div class=\"hint\"&gt;&lt;/div&gt;\n&lt;input id=\"input-input0\" type=\"text\" name=\"input0\" value=\"some default value\" size=\"20\"/&gt;\n&lt;/div&gt;\n&lt;div id=\"input1\" class=\"control input relevant\"&gt;\n&lt;label for=\"input-input1\"&gt;Input bar here&lt;/label&gt;\n&lt;div class=\"alert\"&gt;&lt;/div&gt;\n&lt;div class=\"hint\"&gt;&lt;/div&gt;\n&lt;input id=\"input-input1\" type=\"text\" name=\"input1\" value=\"\" size=\"20\"/&gt;\n&lt;/div&gt;\n&lt;/form&gt;\n&lt;BLANKLINE&gt;\n</pre>\n</blockquote>\n<p>Nice. Now let\u2019s give the request some content, and let the view handle the\nsubmission. This should result in the context having the form data stored\nin the _data attribute. formprocess is the marker used by w20e.forms\nto assume that the form is posted.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; req = Request({'formprocess': 1, 'input0': 6, 'input1': 'whatever'})\n&gt;&gt;&gt; view = yourformview(ctx, req)\n&gt;&gt;&gt; view()\n{'status': 'stored', 'errors': {}}\n&gt;&gt;&gt; ctx._data.getField('foo').value\n6\n&gt;&gt;&gt; ctx._data.getField('bar').value\n'whatever'\n</pre>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<div id=\"xml-implementation\">\n<h3><a href=\"#id16\" rel=\"nofollow\">XML implementation</a></h3>\n<blockquote>\n<blockquote>\n<p>Using the XML implementation makes life even easier:</p>\n<pre>from w20e.forms.pyramid.formview import xmlformview as pyramidformview\nfrom w20e.forms.xml.formfile import FormFile\n\nclass yourformview(pyramidformview):\n\n  def __init__(self, context, request):\n      pyramidformview.__init__(self, context, request, FormFile(\"forms/yourform.xml\"))\n</pre>\n<p>where you have a directory \u2018forms\u2019 containing the XML definition\ncalled yourform.xml. Check the w20e.forms.xml module for details\non XML definitions.</p>\n</blockquote>\n<ul>\n<li><p>Create a template (form.pt for example) that calls the render\nmethod of the view:</p>\n<pre>&lt;p tal:content=\"structure python:view.renderform()\"&gt;&lt;/p&gt;\n</pre>\n</li>\n<li><p>Wire the stuff into zcml (assuming you use that), like so:</p>\n<pre>&lt;view\n  context=\".models.YourModel\"\n  view=\".views.yourformview\"\n  renderer=\"templates/form.pt\"\n  name=\"yourform\"\n  /&gt;\n</pre>\n</li>\n</ul>\n</blockquote>\n</div>\n</div>\n\n          </div>"}, "last_serial": 801482, "releases": {"1.0.0a": [{"comment_text": "", "digests": {"md5": "0ad5d724fe3f7d3b40cd92ad009c8a50", "sha256": "c3fecdd332fe1802f9c63695f718b881fbd699b5cc63109c5d908922303c05ba"}, "downloads": -1, "filename": "w20e.forms-1.0.0a.tar.gz", "has_sig": false, "md5_digest": "0ad5d724fe3f7d3b40cd92ad009c8a50", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 46262, "upload_time": "2012-07-10T12:22:59", "upload_time_iso_8601": "2012-07-10T12:22:59.901481Z", "url": "https://files.pythonhosted.org/packages/56/fe/852916d6311081a9ba17b46231930dc4f4a989e9b94f5e3c1523e4dc9ca3/w20e.forms-1.0.0a.tar.gz", "yanked": false}], "1.0.2b": [{"comment_text": "", "digests": {"md5": "fe34744c9fc3e7e00898b49ef886b7c8", "sha256": "2c06945271aa0dca4f540bc0a093a01e06db718e54192ef0f353b1f6ceb7b06a"}, "downloads": -1, "filename": "w20e.forms-1.0.2b.tar.gz", "has_sig": false, "md5_digest": "fe34744c9fc3e7e00898b49ef886b7c8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49583, "upload_time": "2013-02-05T12:07:18", "upload_time_iso_8601": "2013-02-05T12:07:18.619872Z", "url": "https://files.pythonhosted.org/packages/4b/51/52e615cc75761725acae43cc602ddc53723dad78d35812e8ad3b111b7e05/w20e.forms-1.0.2b.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fe34744c9fc3e7e00898b49ef886b7c8", "sha256": "2c06945271aa0dca4f540bc0a093a01e06db718e54192ef0f353b1f6ceb7b06a"}, "downloads": -1, "filename": "w20e.forms-1.0.2b.tar.gz", "has_sig": false, "md5_digest": "fe34744c9fc3e7e00898b49ef886b7c8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 49583, "upload_time": "2013-02-05T12:07:18", "upload_time_iso_8601": "2013-02-05T12:07:18.619872Z", "url": "https://files.pythonhosted.org/packages/4b/51/52e615cc75761725acae43cc602ddc53723dad78d35812e8ad3b111b7e05/w20e.forms-1.0.2b.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:33:24 2020"}