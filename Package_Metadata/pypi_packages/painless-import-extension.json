{"info": {"author": "thautwarm", "author_email": "twshere@outlook.com", "bugtrack_url": null, "classifiers": ["Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: Implementation :: CPython"], "description": "## PIE\n\n[![PyPI version](https://img.shields.io/pypi/v/painless-import-extension.svg)](https://pypi.org/project/painless-import-extension)\n[![Build Status](https://travis-ci.com/thautwarm/PIE.svg?branch=master)](https://travis-ci.com/thautwarm/PIE)\n[![codecov](https://codecov.io/gh/thautwarm/PIE/branch/master/graph/badge.svg)](https://codecov.io/gh/thautwarm/PIE)\n[![MIT License](https://img.shields.io/badge/license-MIT-Green.svg?style=flat)](https://github.com/thautwarm/EBNFParser/blob/boating-new/LICENSE)\n\n\n## Installation & Documentation\n\n`pip install painless-import-extension`.\n\nBasically there's only one thing exported from package `pie`:\n\n```python\nfrom pie import LoaderForBetterLife\n```\n\nIt's an abstract generic type. When you want to load a file to type `A`,\nwrite such a loader:\n\n```python\nclass ALoader(LoaderForBetterLife[A]):\n    pass\n```\n\n**IDEs and static type checkers will help you to finish the following steps of implementing your expecting loader, and this is what I'd call a documentation here.**\n\n\n### Motivation\n\nFuck it, I must say something at first.\n\nOnce you use the Python import hooks to support files with extensions other than '.py',\nyou will feel extremely disgusting, and if you're expert enough to use Python internal stuffs\nto track the implementation of `PathFinder.find_spec`(usually `sys.meta_path[2].find_spec` or  `sys.meta_path[1].find_spec`),\nthe awfulness of the module finding mechanism will lead you to a strong suspicion of the reliability of Python `import` statements,\nand finally, likely to bring about the crash of one's faith in writing reliable codes.\n\nI for one encountered this, and fortunately I didn't jump down from my dormitory after working with that for months(and knew it for years).\n\nHence, I realized that it should be my duty to keep people away from being killed when working with Python's module finding mechanism,\nwhich might save several people's lives.\n\n\n### What is PIE?\n\nPIE, aka **painless-import-extension**, is not aimed at providing a higher level interface of Python's\nimport system, but is actually useful for solving most of the related problems.\n\nTechnically, PIE \"did nothing\", all the codes involved in this project are so far pretty easy,\nthat even a newbie to Python could understand it thoroughly with any question. However,\nPIE is useful, because it shows a **healthy mental model** for using Python import system,\nin a simplest way, and also a most practical way if you want to use the same module file search strategy of Python's.\n\nFor instance, if you want to import `data.json` via PIE, other than the JSON file,\nyou should also prepare a file with just suffix changed to `.py`(hence you got `data.py`), and\nfill the following contents:\n\n```python\nfrom pie.json_loader import JsonLoader\n\ndata = JsonLoader(__file__, __name__).load()\n```\n\nwhere, `JsonLoader(__file__, __name__).load()` will load the JSON data.\n\nLooks trivial? Yes, that's expected, and I'm telling you that this way is powerful,\nand subtly, much more powerful than `json.load(pathlib.Path(__file__).with_suffix('.json').open())`.\n\n### A PIE loader, and what happened when invoking `LoaderForBetterLife.load()`?\n\nGiven such a file directory:\n\n```\n- proj\n    - data.json\n    - data.py\n```\n\nAnd we fill `data.py` with \n\n```python\nfrom pie.json_loader import JsonLoader\n\ndata = JsonLoader(__file__, __name__).load()\n```\n\nNext, when you're import `proj.data`,\n\n- for the first time,\n  things similar to `json.load` happened, JSON is loaded from `data.json`.\n  However, a default caching system is introduced, and when you exit\n  current Python interpreter, and reopen the interpreter to import\n  `proj.data`\n\n- for the second time, `json.load` might not be invoked.\n    There're some cases:\n    - when `proj/data.json` doesn't exist, we'll get the JSON\n      from a binary file cached on disk.\n    - when `proj/data.json` exists, we'll check if the content\n      of `proj/data.json` has changed. If true, we import `proj/data.json`\n      just as what we did at the first time; otherwise, we use the cached\n      binary contents.\n\nThings become quite useful when you're loading DSLs(domain specific languages),\nor other programming languages that compile to the Python.\n\nFor example, we give an implementation of loading the script of [muridesu](https://github.com/LanguageAsGarbage/muridesu-lang) language(Python 3.7 only).\n\nCheck `test/zenzen_muridesu.py`, note that if you're using an IDE,\nyou will have a good experience of auto completion and static checking\ndue to our thorough support of Python type hints.\n\n```python\nfrom pathlib import Path\nfrom typing import Union, Tuple\nfrom muridesu.parse_stmts import parse_stmts as parse\nfrom pie import LoaderForBetterLife\nfrom types import CodeType\nimport marshal\n\n\nclass MuridesuLoader(LoaderForBetterLife[CodeType]):\n    def source_to_prog(self, src: bytes, path: Path):\n        mod = parse(src.decode('utf8'), str(path.absolute()))\n        code = compile(mod, self.file.with_suffix(self.suffix()), 'exec')\n        return code\n\n    def load_program(self, b: bytes):\n        return marshal.loads(b)\n\n    def dump_program(self, prog: CodeType):\n        return marshal.dumps(prog)\n\n    def suffix(self) -> Union[str, Tuple[str, ...]]:\n        return '.muridesu'\n\n\nexec(MuridesuLoader(__file__, __name__).load(), globals())\n```\n\nIn `test/zenzen_muridesu.muridesu`, write down\n```\nclass Animal {\n    func bark(self){\n        print(\"hoho\")\n    }\n}\n\nclass Dog <: Animal {\n    bark = fn (self) -> {\n        print(\"dogy\")\n    }\n}\n\nlist(\n    map(\n        fn (it) -> {\n            print(it.__class__)\n            it.bark()\n        },\n        [Dog(), Animal()]\n    )\n)\n```\n\nImporting `test/zenzen_muridesu.py` will give following STD output:\n\n```\n<class '__main__.Dog'>\ndogy\n<class '__main__.Animal'>\nhoho\n```\n\n### Conclusion\n\nMake sure if you really want to introduce the complexity of `importlib`?\n\nWhen you just need searching extension files just as searching normal python files,\nuse PIE.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/thautwarm/painless-import-extension", "keywords": "", "license": "mit", "maintainer": "", "maintainer_email": "", "name": "painless-import-extension", "package_url": "https://pypi.org/project/painless-import-extension/", "platform": "any", "project_url": "https://pypi.org/project/painless-import-extension/", "project_urls": {"Homepage": "https://github.com/thautwarm/painless-import-extension"}, "release_url": "https://pypi.org/project/painless-import-extension/0.2.2/", "requires_dist": null, "requires_python": ">=3", "summary": "", "version": "0.2.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h2>PIE</h2>\n<p><a href=\"https://pypi.org/project/painless-import-extension\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/eb5d3e256747da316e03849f3df0dfd03de4f9a5/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f7061696e6c6573732d696d706f72742d657874656e73696f6e2e737667\"></a>\n<a href=\"https://travis-ci.com/thautwarm/PIE\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cf06b1792bff78bb8519cb6b37b9aa3ec6b65acb/68747470733a2f2f7472617669732d63692e636f6d2f74686175747761726d2f5049452e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/thautwarm/PIE\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2a22564c65ac1cb916479cc593e9e3e786ad69ec/68747470733a2f2f636f6465636f762e696f2f67682f74686175747761726d2f5049452f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://github.com/thautwarm/EBNFParser/blob/boating-new/LICENSE\" rel=\"nofollow\"><img alt=\"MIT License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/dbc16c61456731c293f15f21214a1f7bad2b4d36/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4d49542d477265656e2e7376673f7374796c653d666c6174\"></a></p>\n<h2>Installation &amp; Documentation</h2>\n<p><code>pip install painless-import-extension</code>.</p>\n<p>Basically there's only one thing exported from package <code>pie</code>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pie</span> <span class=\"kn\">import</span> <span class=\"n\">LoaderForBetterLife</span>\n</pre>\n<p>It's an abstract generic type. When you want to load a file to type <code>A</code>,\nwrite such a loader:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">ALoader</span><span class=\"p\">(</span><span class=\"n\">LoaderForBetterLife</span><span class=\"p\">[</span><span class=\"n\">A</span><span class=\"p\">]):</span>\n    <span class=\"k\">pass</span>\n</pre>\n<p><strong>IDEs and static type checkers will help you to finish the following steps of implementing your expecting loader, and this is what I'd call a documentation here.</strong></p>\n<h3>Motivation</h3>\n<p>Fuck it, I must say something at first.</p>\n<p>Once you use the Python import hooks to support files with extensions other than '.py',\nyou will feel extremely disgusting, and if you're expert enough to use Python internal stuffs\nto track the implementation of <code>PathFinder.find_spec</code>(usually <code>sys.meta_path[2].find_spec</code> or  <code>sys.meta_path[1].find_spec</code>),\nthe awfulness of the module finding mechanism will lead you to a strong suspicion of the reliability of Python <code>import</code> statements,\nand finally, likely to bring about the crash of one's faith in writing reliable codes.</p>\n<p>I for one encountered this, and fortunately I didn't jump down from my dormitory after working with that for months(and knew it for years).</p>\n<p>Hence, I realized that it should be my duty to keep people away from being killed when working with Python's module finding mechanism,\nwhich might save several people's lives.</p>\n<h3>What is PIE?</h3>\n<p>PIE, aka <strong>painless-import-extension</strong>, is not aimed at providing a higher level interface of Python's\nimport system, but is actually useful for solving most of the related problems.</p>\n<p>Technically, PIE \"did nothing\", all the codes involved in this project are so far pretty easy,\nthat even a newbie to Python could understand it thoroughly with any question. However,\nPIE is useful, because it shows a <strong>healthy mental model</strong> for using Python import system,\nin a simplest way, and also a most practical way if you want to use the same module file search strategy of Python's.</p>\n<p>For instance, if you want to import <code>data.json</code> via PIE, other than the JSON file,\nyou should also prepare a file with just suffix changed to <code>.py</code>(hence you got <code>data.py</code>), and\nfill the following contents:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pie.json_loader</span> <span class=\"kn\">import</span> <span class=\"n\">JsonLoader</span>\n\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">JsonLoader</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">,</span> <span class=\"vm\">__name__</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">()</span>\n</pre>\n<p>where, <code>JsonLoader(__file__, __name__).load()</code> will load the JSON data.</p>\n<p>Looks trivial? Yes, that's expected, and I'm telling you that this way is powerful,\nand subtly, much more powerful than <code>json.load(pathlib.Path(__file__).with_suffix('.json').open())</code>.</p>\n<h3>A PIE loader, and what happened when invoking <code>LoaderForBetterLife.load()</code>?</h3>\n<p>Given such a file directory:</p>\n<pre><code>- proj\n    - data.json\n    - data.py\n</code></pre>\n<p>And we fill <code>data.py</code> with</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pie.json_loader</span> <span class=\"kn\">import</span> <span class=\"n\">JsonLoader</span>\n\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">JsonLoader</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">,</span> <span class=\"vm\">__name__</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">()</span>\n</pre>\n<p>Next, when you're import <code>proj.data</code>,</p>\n<ul>\n<li>\n<p>for the first time,\nthings similar to <code>json.load</code> happened, JSON is loaded from <code>data.json</code>.\nHowever, a default caching system is introduced, and when you exit\ncurrent Python interpreter, and reopen the interpreter to import\n<code>proj.data</code></p>\n</li>\n<li>\n<p>for the second time, <code>json.load</code> might not be invoked.\nThere're some cases:</p>\n<ul>\n<li>when <code>proj/data.json</code> doesn't exist, we'll get the JSON\nfrom a binary file cached on disk.</li>\n<li>when <code>proj/data.json</code> exists, we'll check if the content\nof <code>proj/data.json</code> has changed. If true, we import <code>proj/data.json</code>\njust as what we did at the first time; otherwise, we use the cached\nbinary contents.</li>\n</ul>\n</li>\n</ul>\n<p>Things become quite useful when you're loading DSLs(domain specific languages),\nor other programming languages that compile to the Python.</p>\n<p>For example, we give an implementation of loading the script of <a href=\"https://github.com/LanguageAsGarbage/muridesu-lang\" rel=\"nofollow\">muridesu</a> language(Python 3.7 only).</p>\n<p>Check <code>test/zenzen_muridesu.py</code>, note that if you're using an IDE,\nyou will have a good experience of auto completion and static checking\ndue to our thorough support of Python type hints.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pathlib</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span>\n<span class=\"kn\">from</span> <span class=\"nn\">typing</span> <span class=\"kn\">import</span> <span class=\"n\">Union</span><span class=\"p\">,</span> <span class=\"n\">Tuple</span>\n<span class=\"kn\">from</span> <span class=\"nn\">muridesu.parse_stmts</span> <span class=\"kn\">import</span> <span class=\"n\">parse_stmts</span> <span class=\"k\">as</span> <span class=\"n\">parse</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pie</span> <span class=\"kn\">import</span> <span class=\"n\">LoaderForBetterLife</span>\n<span class=\"kn\">from</span> <span class=\"nn\">types</span> <span class=\"kn\">import</span> <span class=\"n\">CodeType</span>\n<span class=\"kn\">import</span> <span class=\"nn\">marshal</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MuridesuLoader</span><span class=\"p\">(</span><span class=\"n\">LoaderForBetterLife</span><span class=\"p\">[</span><span class=\"n\">CodeType</span><span class=\"p\">]):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">source_to_prog</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">src</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span><span class=\"p\">,</span> <span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"n\">Path</span><span class=\"p\">):</span>\n        <span class=\"n\">mod</span> <span class=\"o\">=</span> <span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">src</span><span class=\"o\">.</span><span class=\"n\">decode</span><span class=\"p\">(</span><span class=\"s1\">'utf8'</span><span class=\"p\">),</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">absolute</span><span class=\"p\">()))</span>\n        <span class=\"n\">code</span> <span class=\"o\">=</span> <span class=\"nb\">compile</span><span class=\"p\">(</span><span class=\"n\">mod</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">file</span><span class=\"o\">.</span><span class=\"n\">with_suffix</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">suffix</span><span class=\"p\">()),</span> <span class=\"s1\">'exec'</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">code</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">load_program</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">:</span> <span class=\"nb\">bytes</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">marshal</span><span class=\"o\">.</span><span class=\"n\">loads</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">dump_program</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">prog</span><span class=\"p\">:</span> <span class=\"n\">CodeType</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">marshal</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"n\">prog</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">suffix</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]]:</span>\n        <span class=\"k\">return</span> <span class=\"s1\">'.muridesu'</span>\n\n\n<span class=\"n\">exec</span><span class=\"p\">(</span><span class=\"n\">MuridesuLoader</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">,</span> <span class=\"vm\">__name__</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(),</span> <span class=\"nb\">globals</span><span class=\"p\">())</span>\n</pre>\n<p>In <code>test/zenzen_muridesu.muridesu</code>, write down</p>\n<pre><code>class Animal {\n    func bark(self){\n        print(\"hoho\")\n    }\n}\n\nclass Dog &lt;: Animal {\n    bark = fn (self) -&gt; {\n        print(\"dogy\")\n    }\n}\n\nlist(\n    map(\n        fn (it) -&gt; {\n            print(it.__class__)\n            it.bark()\n        },\n        [Dog(), Animal()]\n    )\n)\n</code></pre>\n<p>Importing <code>test/zenzen_muridesu.py</code> will give following STD output:</p>\n<pre><code>&lt;class '__main__.Dog'&gt;\ndogy\n&lt;class '__main__.Animal'&gt;\nhoho\n</code></pre>\n<h3>Conclusion</h3>\n<p>Make sure if you really want to introduce the complexity of <code>importlib</code>?</p>\n<p>When you just need searching extension files just as searching normal python files,\nuse PIE.</p>\n\n          </div>"}, "last_serial": 6638800, "releases": {"0.2.1": [{"comment_text": "", "digests": {"md5": "9b2f94ea902c44f1a5ec3465c0c21e96", "sha256": "d15d34341fa974519273b0f8468a6ab3866ba381e63a47fa16de24c7f917cd95"}, "downloads": -1, "filename": "painless_import_extension-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "9b2f94ea902c44f1a5ec3465c0c21e96", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 7435, "upload_time": "2020-02-11T12:10:36", "upload_time_iso_8601": "2020-02-11T12:10:36.820439Z", "url": "https://files.pythonhosted.org/packages/ed/28/8f860191629c6f56615909a6d16003c50fb685eecc85250bf3158e556fc5/painless_import_extension-0.2.1-py3-none-any.whl", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "0ba2e29541b05f901c079abb9655cb35", "sha256": "ec39cee8bd202ea005f0f0fc398f447ccab30b1a9268e400bc65f37005dc66db"}, "downloads": -1, "filename": "painless_import_extension-0.2.2-py3-none-any.whl", "has_sig": false, "md5_digest": "0ba2e29541b05f901c079abb9655cb35", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 7634, "upload_time": "2020-02-16T04:54:51", "upload_time_iso_8601": "2020-02-16T04:54:51.449946Z", "url": "https://files.pythonhosted.org/packages/f6/8f/b3e6e8a161988b68a7f20b20f9e2dbc51ab87ebb794b5eda40c240b9c293/painless_import_extension-0.2.2-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0ba2e29541b05f901c079abb9655cb35", "sha256": "ec39cee8bd202ea005f0f0fc398f447ccab30b1a9268e400bc65f37005dc66db"}, "downloads": -1, "filename": "painless_import_extension-0.2.2-py3-none-any.whl", "has_sig": false, "md5_digest": "0ba2e29541b05f901c079abb9655cb35", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 7634, "upload_time": "2020-02-16T04:54:51", "upload_time_iso_8601": "2020-02-16T04:54:51.449946Z", "url": "https://files.pythonhosted.org/packages/f6/8f/b3e6e8a161988b68a7f20b20f9e2dbc51ab87ebb794b5eda40c240b9c293/painless_import_extension-0.2.2-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 02:59:49 2020"}