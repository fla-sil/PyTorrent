{"info": {"author": "Christopher Rabotin", "author_email": "christopher.rabotin@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Framework :: Django", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 2"], "description": "Bungiesearch\n============\n\n|Build Status| |Coverage Status|\n\n.. contents:: Table of contents\n   :depth: 2\n\nPurpose\n=======\n\nBungiesearch is a Django wrapper for\n`elasticsearch-dsl-py <https://github.com/elasticsearch/elasticsearch-dsl-py>`__.\nIt inherits from elasticsearch-dsl-py's ``Search`` class, so all the\nfabulous features developed by the elasticsearch-dsl-py team are also\navailable in Bungiesearch. In addition, just like ``Search``,\nBungiesearch is a lazy searching class (and iterable), meaning you can\ncall functions in a row, or do something like the following.\n\n.. code:: python\n\n    lazy = Article.objects.search.query('match', _all='Description')\n    print len(lazy) # Prints the number of hits by only fetching the number of items.\n    for item in lazy[5:10]:\n        print item\n\nFeatures\n========\n\n-  Core Python friendly\n\n   -  Iteration (``[x for x in lazy_search]``)\n   -  Get items (``lazy_search[10]``)\n   -  Number of hits via ``len`` (``len(lazy_search)``)\n\n-  Index management\n\n   -  Creating and deleting an index.\n   -  Creating, updating and deleting doctypes and their mappings.\n   -  Update index doctypes.\n\n-  Django Model Mapping\n\n   -  Very easy mapping (no lies).\n   -  Automatic model mapping (and supports undefined models by\n      returning a ``Result`` instance of ``elasticsearch-dsl-py``).\n   -  Efficient database fetching:\n\n      -  One fetch for all items of a given model.\n      -  Fetches only desired fields.\n\n-  Django Manager\n\n   -  Easy model integration:\n      ``MyModel.search.query(\"match\", _all=\"something to search\")``.\n   -  Search aliases (search shortcuts with as many parameters as\n      wanted): ``Tweet.object.bungie_title_search(\"bungie\")`` or\n      ``Article.object.bungie_title_search(\"bungie\")``, where\n      ``bungie_title_search`` is uniquely defined.\n\n-  Django signals\n\n   -  Connect to post save and pre delete signals for the elasticsearch\n      index to correctly reflect the database (almost) at all times.\n\n-  Requirements\n\n   -  Django >= 1.7\n   -  Python 2.7 (**no Python 3 support yet**)\n\nFeature examples\n----------------\n\nSee section \"Full example\" at the bottom of page to see the code needed\nto perform these following examples. ### Query a word (or list thereof)\non a managed model.\n\n``Article.objects.search.query('match', _all='Description')``\n\nUse a search alias on a model's manager.\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n``Article.objects.bsearch_title_search('title')``\n\nUse a search alias on a bungiesearch instance.\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n``Article.objects.search.bsearch_title_search('title').bsearch_titlefilter('filter this title')``\n\nIterate over search results\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    # Will print the Django model instance.\n    for result in Article.objects.search.query('match', _all='Description'):\n        print result\n\nFetch a single item\n~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    Article.objects.search.query('match', _all='Description')[0]\n\nGet the number of returned items\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    print len(Article.objects.search.query('match', _all='Description'))\n\nDeferred model instantiation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    # Will print the Django model instance's primary key. Will only fetch the `pk` field from the database.\n    for result in Article.objects.search.query('match', _all='Description').only('pk'):\n        print result.pk\n\nElasticsearch limited field fetching\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    # Will print the Django model instance. However, elasticsearch's response only has the `_id` field.\n    for result in Article.objects.search.query('match', _all='Description').fields('_id'):\n        print result\n\nGet a specific number of items with an offset.\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis is actually elasticseach-dsl-py functionality, but it's\ndemonstrated here because we can iterate over the results via\nBungiesearch.\n\n.. code:: python\n\n    for item in Article.objects.bsearch_title_search('title').only('pk').fields('_id')[5:7]:\n        print item\n\nLazy objects\n~~~~~~~~~~~~\n\n.. code:: python\n\n    lazy = Article.objects.bsearch_title_search('title')\n    print len(lazy)\n    for item in lazy.filter('range', effective_date={'lte': '2014-09-22'}):\n        print item\n\nInstallation\n============\n\nUnless noted otherwise, each step is required.\n\nInstall the package\n-------------------\n\nThe easiest way is to install the package from PyPi:\n\n``pip install bungiesearch``\n\n**Note:** Check your version of Django after installing bungiesearch. It\nwas reported to me directly that installing bungiesearch may upgrade\nyour version of Django, although I haven't been able to confirm that\nmyself. Bungiesearch depends on Django 1.7 and above.\n\nIn Django\n---------\n\nUpdating your Django models\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Note:** this part is only needed if you want to be able to use search\naliases, which allow you to define shortcuts to complex queries,\navailable directly from your Django models. I think it's extremely\npractical.\n\n1. Open your ``models.py`` file.\n2. Add the bungiesearch manager import:\n   ``from bungiesearch.managers import BungiesearchManager``\n3. Find the model, or models, you wish to index on Elasticsearch and set\n   them to be managed by Bungiesearch by adding the objects field to\n   them, as such: ``objects = BungiesearchManager()``. You should now\n   have a Django model `similar to\n   this <https://github.com/Sparrho/bungiesearch#django-model>`__.\n\nCreating bungiesearch search indexes\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe search indexes define how bungiesearch should serialize each of the\nmodel's objects. It effectively defines how your object is serialized\nand how the ES index should be structured. These are referred to as\n`ModelIndex <https://github.com/Sparrho/bungiesearch#modelindex-1>`__\\ es.\n\nA good practice here is to have all the bungiesearch stuff in its own\npackage. For example, for the section of the Sparrho platform that uses\nDjango, we have a package called ``search`` where we define the search\nindexes, and a subpackage called ``aliases`` which has the many aliases\nwe use (more on that latter).\n\n1. Create a subclass of ``ModelIndex``, which you can import from from\n   ``bungiesearch.indices import ModelIndex``, in a new module\n   preferably.\n2. In this class, define a class called ``Meta``: it will hold meta\n   information of this search index for bungiesearch's internal working.\n3. Import the Django model you want to index (from your models file)\n   and, in the Meta class, define a field called ``model``, which must\n   be set to the model you want indexed.\n4. By default, bungiesearch will index every field of your model. This\n   may not always be desired, so you can define which fields must be\n   excluded in this ``Meta`` class, via the exclude field.\n5. There are plenty of options, so definitely have a read through the\n   documentation for\n   `ModelIndex <https://github.com/Sparrho/bungiesearch#modelindex-1>`__.\n\nHere's `an\nexample <https://github.com/Sparrho/bungiesearch#modelindex>`__ of a\nsearch index. There can be many such definitions in a file.\n\nDjango settings\n~~~~~~~~~~~~~~~\n\nThis is the final required step. Here's the `full\ndocumentation <https://github.com/Sparrho/bungiesearch#settings>`__ of\nthis step.\n\n1. Open your settings file and add a ``BUNGIESEARCH`` variable, which\n   must be a dictionary.\n2. Define ``URLS`` as a list of URLs (which can contain only one) of\n   your ES servers.\n3. Define the ``INDICES`` key as a dictionary where the key is the name\n   of the index on ES that you want, and the value is the full Python\n   path to the module which has all the ModelIndex classes for to be\n   indexed on that index name.\n4. Set ``ALIASES`` to an empty dictionary (until you define any search\n   aliases).\n5. You can keep other values as their defaults.\n\nIn your shell\n-------------\n\nCreate the ES indexes\n~~~~~~~~~~~~~~~~~~~~~\n\nFrom your shell, in the Django environment, run the following:\n\n``python manage.py search_index --create``\n\nStart populating the index\n--------------------------\n\nRun the following which will take each of the objects in your model,\nserialize them, and add them to the elasticsearch index.\n\n``python manage.py search_index --update``\n\n**Note:** With additional parameters, you can limit the number of\ndocuments to be indexed, as well as set conditions on whether they\nshould be indexed based on updated time for example.\n\nIn Elasticsearch\n----------------\n\nYou can now open your elasticsearch dashboard, such as Elastic HQ, and\nsee that your index is created with the appropriate mapping and has\nitems that are indexed.\n\nQuick start example\n===================\n\nThis example is from the ``test`` folder. It may be partially out-dated,\nso please refer to the ``test`` folder for the latest version.\n\nProcedure\n---------\n\n1. In your models.py file (or your managers.py), import bungiesearch and\n   use it as a model manager.\n2. Define one or more ModelIndex subclasses which define the mapping\n   between your Django model and elasticsearch.\n3. (Optional) Define SearchAlias subclasses which make it trivial to\n   call complex elasticsearch-dsl-py functions.\n4. Add a BUNGIESEARCH variable in your Django settings, which must\n   contain the elasticsearch URL(s), the modules for the indices, the\n   modules for the search aliases and the signal definitions.\n\nExample\n-------\n\nHere's the code which is applicable to the previous examples. ### Django\nModel\n\n.. code:: python\n\n    from django.db import models\n    from bungiesearch.managers import BungiesearchManager\n\n    class Article(models.Model):\n        title = models.TextField(db_index=True)\n        authors = models.TextField(blank=True)\n        description = models.TextField(blank=True)\n        link = models.URLField(max_length=510, unique=True, db_index=True)\n        published = models.DateTimeField(null=True)\n        created = models.DateTimeField(auto_now_add=True)\n        updated = models.DateTimeField(null=True)\n        tweet_count = models.IntegerField()\n        raw = models.BinaryField(null=True)\n        source_hash = models.BigIntegerField(null=True)\n        missing_data = models.CharField(blank=True, max_length=255)\n        positive_feedback = models.PositiveIntegerField(null=True, blank=True, default=0)\n        negative_feedback = models.PositiveIntegerField(null=True, blank=True, default=0)\n        popularity_index = models.IntegerField(default=0)\n\n        objects = BungiesearchManager()\n\n        class Meta:\n            app_label = 'core'\n\nModelIndex\n~~~~~~~~~~\n\nThe following ModelIndex will generate a mapping containing all fields\nfrom ``Article``, minus those defined in ``ArticleIndex.Meta.exclude``.\nWhen the mapping is generated, each field will the most appropriate\n`elasticsearch core\ntype <http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/mapping-core-types.html>`__,\nwith default attributes (as defined in bungiesearch.fields).\n\nThese default attributes can be overwritten with\n``ArticleIndex.Meta.hotfixes``: each dictionary key must be field\ndefined either in the model or in the ModelIndex subclass\n(``ArticleIndex`` in this case).\n\n.. code:: python\n\n    from core.models import Article\n    from bungiesearch.fields import DateField, StringField\n    from bungiesearch.indices import ModelIndex\n\n\n    class ArticleIndex(ModelIndex):\n        effectived_date = DateField(eval_as='obj.created if obj.created and obj.published > obj.created else obj.published')\n        meta_data = StringField(eval_as='\" \".join([fld for fld in [obj.link, str(obj.tweet_count), obj.raw] if fld])')\n\n        class Meta:\n            model = Article\n            exclude = ('raw', 'missing_data', 'negative_feedback', 'positive_feedback', 'popularity_index', 'source_hash')\n            hotfixes = {'updated': {'null_value': '2013-07-01'},\n                        'title': {'boost': 1.75},\n                        'description': {'boost': 1.35},\n                        'full_text': {'boost': 1.125}}\n\nSearchAlias\n~~~~~~~~~~~\n\nDefines a search alias for one or more models (in this case only for\n``core.models.Article``).\n\n.. code:: python\n\n    from core.models import Article\n    from bungiesearch.aliases import SearchAlias\n\n\n    class SearchTitle(SearchAlias):\n        def alias_for(self, title):\n            return self.search_instance.query('match', title=title)\n\n        class Meta:\n            models = (Article,)\n            alias_name = 'title_search' # This is optional. If none is provided, the name will be the class name in lower case.\n\n    class InvalidAlias(SearchAlias):\n        def alias_for_does_not_exist(self, title):\n            return title\n\n        class Meta:\n            models = (Article,)\n\nDjango settings\n~~~~~~~~~~~~~~~\n\n.. code:: python\n\n    BUNGIESEARCH = {\n                    'URLS': [os.getenv('ELASTIC_SEARCH_URL')],\n                    'INDICES': {'bungiesearch_demo': 'core.search_indices'},\n                    'ALIASES': {'bsearch': 'myproject.search_aliases'},\n                    'SIGNALS': {'BUFFER_SIZE': 1}  # uses BungieSignalProcessor\n                    }\n\nDocumentation\n=============\n\nModelIndex\n----------\n\nA ``ModelIndex`` defines mapping and object extraction for indexing of a\ngiven Django model.\n\nAny Django model to be managed by bungiesearch must have a defined\nModelIndex subclass. This subclass must contain a subclass called\n``Meta`` which must have a ``model`` attribute (sets the model which it\nrepresents).\n\nClass attributes\n~~~~~~~~~~~~~~~~\n\nAs detailed below, the doc type mapping will contain fields from the\nmodel it related to. However, one may often need to index fields which\ncorrespond to either a concatenation of fields of the model or some\nlogical operation.\n\nBungiesearch makes this very easy: simply define a class attribute as\nwhichever core type, and set to the ``eval_as`` constructor parameter to\na one line Python statement. The object is referenced as ``obj`` (not\n``self`` nor ``object``, just ``obj``).\n\nExample\n^^^^^^^\n\nThis is a partial example as the Meta subclass is not defined, yet\nmandatory (cf. below).\n\n.. code:: python\n\n    from bungiesearch.fields import DateField, StringField\n    from bungiesearch.indices import ModelIndex\n\n    class ArticleIndex(ModelIndex):\n        effective_date = DateField(eval_as='obj.created if obj.created and obj.published > obj.created else obj.published')\n        meta_data = StringField(eval_as='\" \".join([fld for fld in [obj.link, str(obj.tweet_count), obj.raw] if fld])')\n\nHere, both ``effective_date`` and ``meta_data`` will be part of the doc\ntype mapping, but won't be reversed mapped since those fields do not\nexist in the model.\n\nThis can also be used to index foreign keys:\n\n.. code:: python\n\n    some_field_name = StringField(eval_as='\",\".join([item for item in obj.some_foreign_relation.values_list(\"some_field\", flat=True)]) if obj.some_foreign_relation else \"\"')\n\nClass methods\n~~~~~~~~~~~~~\n\nmatches\\_indexing\\_condition\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nOverride this function to specify whether an item should be indexed or\nnot. This is useful when defining multiple indices (and ModelIndex\nclasses) for a given model. This method's signature and super class code\nis as follows, and allows indexing of all items.\n\n.. code:: python\n\n    def matches_indexing_condition(self, item):\n        return True\n\nFor example, if a given elasticsearch index should contain only item\nwhose title starts with ``\"Awesome\"``, then this method can be\noverridden as follows.\n\n.. code:: python\n\n    def matches_indexing_condition(self, item):\n        return item.title.startswith(\"Awesome\")\n\nMeta subclass attributes\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n**Note**: in the following, any variable defined a being a ``list``\ncould also be a ``tuple``. ##### model *Required:* defines the Django\nmodel for which this ModelIndex is applicable.\n\nfields\n^^^^^^\n\n*Optional:* list of fields (or columns) which must be fetched when\nserializing the object for elasticsearch, or when reverse mapping the\nobject from elasticsearch back to a Django Model instance. By default,\nall fields will be fetched. Setting this *will* restrict which fields\ncan be fetched and may lead to errors when serializing the object. It is\nrecommended to use the ``exclude`` attribute instead (cf. below).\n\nexclude\n^^^^^^^\n\n*Optional:* list of fields (or columns) which must not be fetched when\nserializing or deserializing the object.\n\nhotfixes\n^^^^^^^^\n\n*Optional:* a dictionary whose keys are index fields and whose values\nare dictionaries which define `core type\nattributes <http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/mapping-core-types.html>`__.\nBy default, there aren't any special settings, apart for String fields,\nwhere the\n`analyzer <http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/analysis-analyzers.html>`__\nis set to\n```snowball`` <http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/analysis-snowball-analyzer.html>`__\n(``{'analyzer': 'snowball'}``).\n\nadditional\\_fields\n^^^^^^^^^^^^^^^^^^\n\n*Optional:* additional fields to fetch for mapping, may it be for\n``eval_as`` fields or when returning the object from the database.\n\nid\\_field\n^^^^^^^^^\n\n*Optional:* the model field to use as a unique ID for elasticsearch's\nmetadata ``_id``. Defaults to ``id`` (also called\n```pk`` <https://docs.djangoproject.com/en/dev/topics/db/models/#automatic-primary-key-fields>`__).\n\nupdated\\_field\n^^^^^^^^^^^^^^\n\n*Optional:* set the model's field which can be filtered on dates in\norder to find when objects have been updated. Note, this is *mandatory*\nto use ``--start`` and/or ``--end`` when updating index (with\n``search_index --update``).\n\noptimize\\_queries\n^^^^^^^^^^^^^^^^^\n\n*Optional:* set to True to make efficient queries when automatically\nmapping to database objects. This will *always* restrict fetching to the\nfields set in ``fields`` and in ``additional_fields``. *Note:* You can\nalso perform an optimal database query with ``.only('__model')``, which\nwill use the same fields as ``optimize_queries``, or\n``.only('__fields')``, which will use the fields provided in the\n``.fields()`` call.\n\nindexing\\_query\n^^^^^^^^^^^^^^^\n\n*Optional:* set to a QuerySet instance to specify the query used when\nthe search\\_index command is ran to index. This **does not** affect how\neach piece of content is indexed.\n\ndefault\n^^^^^^^\n\nEnables support for a given model to be indexed on several elasticsearch\nindices. Set to ``False`` on all but the default index. **Note**: if all\nmanaged models are set with ``default=False`` then Bungiesearch will\nfail to find and index that model.\n\nExample\n~~~~~~~\n\nIndexes all objects of ``Article``, as long as their ``updated``\ndatetime is less than `21 October 2015\n04:29 <https://en.wikipedia.org/wiki/Back_to_the_Future_Part_II>`__.\n\n.. code:: python\n\n    from core.models import Article\n    from bungiesearch.indices import ModelIndex\n    from datetime import datetime\n\n    class ArticleIndex(ModelIndex):\n\n        def matches_indexing_condition(self, item):\n            return item.updated < datetime.datetime(2015, 10, 21, 4, 29)\n\n        class Meta:\n            model = Article\n            id_field = 'id' # That's actually the default value, so it's not really needed.\n            exclude = ('raw', 'missing_data', 'negative_feedback', 'positive_feedback', 'popularity_index', 'source_hash')\n            hotfixes = {'updated': {'null_value': '2013-07-01'},\n                        'title': {'boost': 1.75},\n                        'description': {'boost': 1.35},\n                        'full_text': {'boost': 1.125}}\n            optimized_queries = True\n            indexing_query = Article.objects.defer(*exclude).select_related().all().prefetch_related('tags')\n\nSearchAlias\n-----------\n\nA ``SearchAlias`` define search shortcuts (somewhat similar to `Django\nmanagers <https://docs.djangoproject.com/en/dev/topics/db/managers/>`__).\nOften times, a given search will be used in multiple parts of the code.\nSearchAliases allow you define those queries, filters, or any\nbungiesearch/elasticsearch-dsl-py calls as an alias.\n\nA search alias is either applicable to a ``list`` (or ``tuple``) of\nmanaged models, or to any bungiesearch instance. It's very simple, so\nhere's an example which is detailed right below.\n\nExample\n~~~~~~~\n\nThe most simple implementation of a SearchAlias is as follows. This\nsearch alias can be called via ``Article.objects.bungie_title`` (or\n``Article.objects.search.bungie_title``), supposing that the namespace\nis set to ``None`` in the settings (cf. below).\n\nDefinition\n^^^^^^^^^^\n\n.. code:: python\n\n    from bungiesearch.aliases import SearchAlias\n\n    class Title(SearchAlias):\n        def alias_for(self, title):\n            return self.search_instance.query('match', title=title)\n\nUsage\n^^^^^\n\n.. code:: python\n\n    Article.objects.bungie_title('title')\n\nMethod overwrite\n~~~~~~~~~~~~~~~~\n\nAny implementation needs to inherit from\n``bungiesearch.aliases.SearchAlias`` and overwrite ``alias_for``. You\ncan set as many or as little parameters as you want for that function\n(since bungiesearch only return the pointer to that function without\nactually calling it).\n\nSince each managed model has its own doc type, ``self.search_instance``\nis a bungiesearch instance set to search the specific doctype.\n\nMeta subclass attributes\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nAlthough not mandatory, the ``Meta`` subclass enabled custom naming and\nmodel restrictions for a search alias.\n\nmodels\n^^^^^^\n\n*Optional:* ``list`` (or ``tuple``) of Django models which are allowed\nto use this search alias. If a model which is not allowed to use this\nSearchAlias tries it, a ``ValueError`` will be raised.\n\nalias\\_name\n^^^^^^^^^^^\n\n*Optional:* A string corresponding the suffix name of this search alias.\nDefaults to the lower case class name.\n\n**WARNING**: As explained in the \"Settings\" section below, all search\naliases in a given module share the prefix (or namespace). This is to\nprevent aliases from accidently overwriting Django manager function\n(e.g. ``update`` or ``get``). In other words, if you define the\n``alias_name`` to ``test``, then it must be called as\n``model_obj.objects.$prefix$_test`` where ``$prefix$`` is the prefix\ndefined in the settings. This prefix is also applicable to search\naliases which are available via bungiesearch instances directly. Hence,\none can define in one module search utilities (e.g. ``regex`` and\n``range``) and define model specific aliases (e.g. ``title``) in another\nmodule, and use both in conjunction as such:\n``Article.objects.search.bungie_title('search title').utils_range(field='created', gte='2014-05-20', as_query=True)``.\nThese aliases can be concatenated ad vitam aeternam.\n\nSophisticated example\n~~~~~~~~~~~~~~~~~~~~~\n\nThis example shows that we can have some fun with search aliases. In\nthis case, we define a Range alias which is applicable to any field on\nany model.\n\n.. code:: python\n\n    class Range(SearchAlias):\n        def alias_for(self, field, gte=None, lte=None, boost=None, as_query=False):\n            body = {field: {}}\n            if gte:\n                body[field]['gte'] = gte\n            if lte:\n                body[field]['lte'] = lte\n            if boost:\n                if not as_query:\n                    logging.warning('Boost is not applicable to search alias Range when not used as a query.')\n                else:\n                    body[field]['boost'] = boost\n            if as_query:\n                return self.search_instance.query({'range': body})\n            return self.search_instance.filter({'range': body})\n\nWe can use it as such\n``Article.objects.bungie_range(field='created', gte='2014-05-20', as_query=True)``.\n\nSettings\n--------\nAdd 'bungiesearch' to INSTALLED_APPS.\n\nYou must define ``BUNGIESEARCH`` in your Django settings in order for\nbungiesearch to know elasticsearch URL(s) and which index name contains\nmappings for each ModelIndex.\n\n.. code:: python\n\n    BUNGIESEARCH = {\n                    'URLS': ['localhost'], # No leading http:// or the elasticsearch client will complain.\n                    'INDICES': {'main_index': 'myproject.myapp.myindices'} # Must be a module path.\n                    'ALIASES': {'bsearch': 'myproject.search_aliases'},\n                    'SIGNALS': {'BUFFER_SIZE': 1},\n                    'TIMEOUT': 5\n                    }\n\nURLS\n~~~~\n\n*Required:* must be a list of URLs which host elasticsearch instance(s).\nThis is directly sent to elasticsearch-dsl-py, so any issue with\nmultiple URLs should be refered to them.\n\nINDICES\n~~~~~~~\n\n*Required:* must be a dictionary where each key is the name of an\nelasticsearch index and each value is a path to a Python module\ncontaining classes which inherit from\n``bungiesearch.indices.ModelIndex`` (cf. below).\n\nALIASES\n~~~~~~~\n\n*Optional:* a dictionary whose key is the alias namespace and whose\nvalue is the Python module containing classes which inherit from\n``bungiesearch.aliases.SearchAlias``. If the namespace is ``None``, then\nthe alias will be named ``bungie``. If the namespace is an empty string,\nthere will be no alias namespace. The provided namespace will be\nappended by an underscore. In the example above, each search alias\ndefined in ``myproject.search_aliases`` will be referenced as\n``$ModelObj$.objects.bsearch_$alias$``, where ``$ModelObj$`` is a Django\nmodel and ``$alias$`` is the name of the search alias.\n\nThe purpose is to not accidently overwrite Django's default manager\nfunctions with search aliases.\n\nSIGNALS\n~~~~~~~\n\n*Optional:* if it exists, it must be a dictionary (even empty), and will\nconnect to the ``post save`` and ``pre delete`` model functions of *all*\nmodels using ``bungiesearch.managers.BungiesearchManager`` as a manager.\nOne may also define a signal processor class for more custom\nfunctionality by placing the string value of the module path under a key\ncalled ``SIGNAL_CLASS`` in the dictionary value of ``SIGNALS`` and\ndefining ``setup`` and ``teardown`` methods, which take ``model`` as the\nonly parameter. These methods connect and disconnect the signal\nprocessing class to django signals (signals are connected to each model\nwhich uses a BungiesearchManager).\n\nIf ``SIGNALS`` is not defined in the settings, *none* of the models\nmanaged by BungiesearchManager will automatically update the index when\na new item is created or deleted.\n\nBUFFER\\_SIZE\n^^^^^^^^^^^^\n\n*Optional:* an integer representing the number of items to buffer before\nmaking a bulk index update, defaults to ``100``.\n\n**WARNING**: if your application is shut down before the buffer is\nemptied, then any buffered instance *will not* be indexed on\nelasticsearch. Hence, a possibly better implementation is wrapping\n``post_save_connector`` and ``pre_delete_connector`` from\n``bungiesearch.signals`` in a celery task. It is not implemented as such\nhere in order to not require ``celery``.\n\nTIMEOUT\n~~~~~~~\n\n*Optional:* Elasticsearch connection timeout in seconds. Defaults to\n``5``.\n\nTesting\n=======\n\nThe easiest way to run the tests is to install all dev dependencies using\n``./setup.sh`` then run ``./test.sh``\n\nAll Bungiesearch tests are in ``tests/core/test_bungiesearch.py``. You\ncan run the tests by creating a Python virtual environment, installing\nthe requirements from ``requirements.txt``, installing the package\n(``pip install .``) and running ``python tests/manage.py test``. Make\nsure to update ``tests/settings.py`` to use your own elasticsearch URLs,\nor update the ELASTIC\\_SEARCH\\_URL environment variable.\n\n.. |Build Status| image:: https://travis-ci.org/Sparrho/bungiesearch.svg?branch=master\n   :target: https://travis-ci.org/Sparrho/bungiesearch\n.. |Coverage Status| image:: https://coveralls.io/repos/Sparrho/bungiesearch/badge.svg?branch=master&service=github\n   :target: https://coveralls.io/github/Sparrho/bungiesearch?branch=master", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ChristopherRabotin/bungiesearch", "keywords": "elasticsearch haystack django bungiesearch", "license": "BSD-3", "maintainer": null, "maintainer_email": null, "name": "bungiesearch", "package_url": "https://pypi.org/project/bungiesearch/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/bungiesearch/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/ChristopherRabotin/bungiesearch"}, "release_url": "https://pypi.org/project/bungiesearch/1.3.0/", "requires_dist": null, "requires_python": null, "summary": "A Django elasticsearch wrapper and helper using elasticsearch-dsl-py high level library.", "version": "1.3.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"bungiesearch\">\n<h2><a href=\"#id8\" rel=\"nofollow\">Bungiesearch</a></h2>\n<p><a href=\"https://travis-ci.org/Sparrho/bungiesearch\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0d35c701078d4d7c327b2e97600a2989d9c3c2a9/68747470733a2f2f7472617669732d63692e6f72672f5370617272686f2f62756e6769657365617263682e7376673f6272616e63683d6d6173746572\"></a> <a href=\"https://coveralls.io/github/Sparrho/bungiesearch?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ae90f75fa260b872b48e990a41e5eae923455cfc/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f5370617272686f2f62756e6769657365617263682f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562\"></a></p>\n<div id=\"table-of-contents\">\n<p>Table of contents</p>\n<ul>\n<li><a href=\"#bungiesearch\" id=\"id8\" rel=\"nofollow\">Bungiesearch</a></li>\n<li><a href=\"#purpose\" id=\"id9\" rel=\"nofollow\">Purpose</a></li>\n<li><a href=\"#features\" id=\"id10\" rel=\"nofollow\">Features</a><ul>\n<li><a href=\"#feature-examples\" id=\"id11\" rel=\"nofollow\">Feature examples</a></li>\n</ul>\n</li>\n<li><a href=\"#installation\" id=\"id12\" rel=\"nofollow\">Installation</a><ul>\n<li><a href=\"#install-the-package\" id=\"id13\" rel=\"nofollow\">Install the package</a></li>\n<li><a href=\"#in-django\" id=\"id14\" rel=\"nofollow\">In Django</a></li>\n<li><a href=\"#in-your-shell\" id=\"id15\" rel=\"nofollow\">In your shell</a></li>\n<li><a href=\"#start-populating-the-index\" id=\"id16\" rel=\"nofollow\">Start populating the index</a></li>\n<li><a href=\"#in-elasticsearch\" id=\"id17\" rel=\"nofollow\">In Elasticsearch</a></li>\n</ul>\n</li>\n<li><a href=\"#quick-start-example\" id=\"id18\" rel=\"nofollow\">Quick start example</a><ul>\n<li><a href=\"#procedure\" id=\"id19\" rel=\"nofollow\">Procedure</a></li>\n<li><a href=\"#example\" id=\"id20\" rel=\"nofollow\">Example</a></li>\n</ul>\n</li>\n<li><a href=\"#documentation\" id=\"id21\" rel=\"nofollow\">Documentation</a><ul>\n<li><a href=\"#id2\" id=\"id22\" rel=\"nofollow\">ModelIndex</a></li>\n<li><a href=\"#id5\" id=\"id23\" rel=\"nofollow\">SearchAlias</a></li>\n<li><a href=\"#settings\" id=\"id24\" rel=\"nofollow\">Settings</a></li>\n</ul>\n</li>\n<li><a href=\"#testing\" id=\"id25\" rel=\"nofollow\">Testing</a></li>\n</ul>\n</div>\n</div>\n<div id=\"purpose\">\n<h2><a href=\"#id9\" rel=\"nofollow\">Purpose</a></h2>\n<p>Bungiesearch is a Django wrapper for\n<a href=\"https://github.com/elasticsearch/elasticsearch-dsl-py\" rel=\"nofollow\">elasticsearch-dsl-py</a>.\nIt inherits from elasticsearch-dsl-py\u2019s <tt>Search</tt> class, so all the\nfabulous features developed by the elasticsearch-dsl-py team are also\navailable in Bungiesearch. In addition, just like <tt>Search</tt>,\nBungiesearch is a lazy searching class (and iterable), meaning you can\ncall functions in a row, or do something like the following.</p>\n<pre><span class=\"n\">lazy</span> <span class=\"o\">=</span> <span class=\"n\">Article</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"s1\">'match'</span><span class=\"p\">,</span> <span class=\"n\">_all</span><span class=\"o\">=</span><span class=\"s1\">'Description'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">lazy</span><span class=\"p\">)</span> <span class=\"c1\"># Prints the number of hits by only fetching the number of items.</span>\n<span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">:</span><span class=\"mi\">10</span><span class=\"p\">]:</span>\n    <span class=\"nb\">print</span> <span class=\"n\">item</span>\n</pre>\n</div>\n<div id=\"features\">\n<h2><a href=\"#id10\" rel=\"nofollow\">Features</a></h2>\n<ul>\n<li>Core Python friendly<ul>\n<li>Iteration (<tt>[x for x in lazy_search]</tt>)</li>\n<li>Get items (<tt>lazy_search[10]</tt>)</li>\n<li>Number of hits via <tt>len</tt> (<tt>len(lazy_search)</tt>)</li>\n</ul>\n</li>\n<li>Index management<ul>\n<li>Creating and deleting an index.</li>\n<li>Creating, updating and deleting doctypes and their mappings.</li>\n<li>Update index doctypes.</li>\n</ul>\n</li>\n<li>Django Model Mapping<ul>\n<li>Very easy mapping (no lies).</li>\n<li>Automatic model mapping (and supports undefined models by\nreturning a <tt>Result</tt> instance of <tt><span class=\"pre\">elasticsearch-dsl-py</span></tt>).</li>\n<li>Efficient database fetching:<ul>\n<li>One fetch for all items of a given model.</li>\n<li>Fetches only desired fields.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Django Manager<ul>\n<li>Easy model integration:\n<tt><span class=\"pre\">MyModel.search.query(\"match\",</span> <span class=\"pre\">_all=\"something</span> to search\")</tt>.</li>\n<li>Search aliases (search shortcuts with as many parameters as\nwanted): <tt><span class=\"pre\">Tweet.object.bungie_title_search(\"bungie\")</span></tt> or\n<tt><span class=\"pre\">Article.object.bungie_title_search(\"bungie\")</span></tt>, where\n<tt>bungie_title_search</tt> is uniquely defined.</li>\n</ul>\n</li>\n<li>Django signals<ul>\n<li>Connect to post save and pre delete signals for the elasticsearch\nindex to correctly reflect the database (almost) at all times.</li>\n</ul>\n</li>\n<li>Requirements<ul>\n<li>Django &gt;= 1.7</li>\n<li>Python 2.7 (<strong>no Python 3 support yet</strong>)</li>\n</ul>\n</li>\n</ul>\n<div id=\"feature-examples\">\n<h3><a href=\"#id11\" rel=\"nofollow\">Feature examples</a></h3>\n<p>See section \u201cFull example\u201d at the bottom of page to see the code needed\nto perform these following examples. ### Query a word (or list thereof)\non a managed model.</p>\n<p><tt><span class=\"pre\">Article.objects.search.query('match',</span> <span class=\"pre\">_all='Description')</span></tt></p>\n<div id=\"use-a-search-alias-on-a-model-s-manager\">\n<h4>Use a search alias on a model\u2019s manager.</h4>\n<p><tt><span class=\"pre\">Article.objects.bsearch_title_search('title')</span></tt></p>\n</div>\n<div id=\"use-a-search-alias-on-a-bungiesearch-instance\">\n<h4>Use a search alias on a bungiesearch instance.</h4>\n<p><tt><span class=\"pre\">Article.objects.search.bsearch_title_search('title').bsearch_titlefilter('filter</span> this title')</tt></p>\n</div>\n<div id=\"iterate-over-search-results\">\n<h4>Iterate over search results</h4>\n<pre><span class=\"c1\"># Will print the Django model instance.</span>\n<span class=\"k\">for</span> <span class=\"n\">result</span> <span class=\"ow\">in</span> <span class=\"n\">Article</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"s1\">'match'</span><span class=\"p\">,</span> <span class=\"n\">_all</span><span class=\"o\">=</span><span class=\"s1\">'Description'</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span> <span class=\"n\">result</span>\n</pre>\n</div>\n<div id=\"fetch-a-single-item\">\n<h4>Fetch a single item</h4>\n<pre><span class=\"n\">Article</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"s1\">'match'</span><span class=\"p\">,</span> <span class=\"n\">_all</span><span class=\"o\">=</span><span class=\"s1\">'Description'</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n</pre>\n</div>\n<div id=\"get-the-number-of-returned-items\">\n<h4>Get the number of returned items</h4>\n<pre><span class=\"nb\">print</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">Article</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"s1\">'match'</span><span class=\"p\">,</span> <span class=\"n\">_all</span><span class=\"o\">=</span><span class=\"s1\">'Description'</span><span class=\"p\">))</span>\n</pre>\n</div>\n<div id=\"deferred-model-instantiation\">\n<h4>Deferred model instantiation</h4>\n<pre><span class=\"c1\"># Will print the Django model instance's primary key. Will only fetch the `pk` field from the database.</span>\n<span class=\"k\">for</span> <span class=\"n\">result</span> <span class=\"ow\">in</span> <span class=\"n\">Article</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"s1\">'match'</span><span class=\"p\">,</span> <span class=\"n\">_all</span><span class=\"o\">=</span><span class=\"s1\">'Description'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">only</span><span class=\"p\">(</span><span class=\"s1\">'pk'</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">pk</span>\n</pre>\n</div>\n<div id=\"elasticsearch-limited-field-fetching\">\n<h4>Elasticsearch limited field fetching</h4>\n<pre><span class=\"c1\"># Will print the Django model instance. However, elasticsearch's response only has the `_id` field.</span>\n<span class=\"k\">for</span> <span class=\"n\">result</span> <span class=\"ow\">in</span> <span class=\"n\">Article</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">search</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"s1\">'match'</span><span class=\"p\">,</span> <span class=\"n\">_all</span><span class=\"o\">=</span><span class=\"s1\">'Description'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fields</span><span class=\"p\">(</span><span class=\"s1\">'_id'</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span> <span class=\"n\">result</span>\n</pre>\n</div>\n<div id=\"get-a-specific-number-of-items-with-an-offset\">\n<h4>Get a specific number of items with an offset.</h4>\n<p>This is actually elasticseach-dsl-py functionality, but it\u2019s\ndemonstrated here because we can iterate over the results via\nBungiesearch.</p>\n<pre><span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">Article</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">bsearch_title_search</span><span class=\"p\">(</span><span class=\"s1\">'title'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">only</span><span class=\"p\">(</span><span class=\"s1\">'pk'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">fields</span><span class=\"p\">(</span><span class=\"s1\">'_id'</span><span class=\"p\">)[</span><span class=\"mi\">5</span><span class=\"p\">:</span><span class=\"mi\">7</span><span class=\"p\">]:</span>\n    <span class=\"nb\">print</span> <span class=\"n\">item</span>\n</pre>\n</div>\n<div id=\"lazy-objects\">\n<h4>Lazy objects</h4>\n<pre><span class=\"n\">lazy</span> <span class=\"o\">=</span> <span class=\"n\">Article</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">bsearch_title_search</span><span class=\"p\">(</span><span class=\"s1\">'title'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">lazy</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">lazy</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"s1\">'range'</span><span class=\"p\">,</span> <span class=\"n\">effective_date</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'lte'</span><span class=\"p\">:</span> <span class=\"s1\">'2014-09-22'</span><span class=\"p\">}):</span>\n    <span class=\"nb\">print</span> <span class=\"n\">item</span>\n</pre>\n</div>\n</div>\n</div>\n<div id=\"installation\">\n<h2><a href=\"#id12\" rel=\"nofollow\">Installation</a></h2>\n<p>Unless noted otherwise, each step is required.</p>\n<div id=\"install-the-package\">\n<h3><a href=\"#id13\" rel=\"nofollow\">Install the package</a></h3>\n<p>The easiest way is to install the package from PyPi:</p>\n<p><tt>pip install bungiesearch</tt></p>\n<p><strong>Note:</strong> Check your version of Django after installing bungiesearch. It\nwas reported to me directly that installing bungiesearch may upgrade\nyour version of Django, although I haven\u2019t been able to confirm that\nmyself. Bungiesearch depends on Django 1.7 and above.</p>\n</div>\n<div id=\"in-django\">\n<h3><a href=\"#id14\" rel=\"nofollow\">In Django</a></h3>\n<div id=\"updating-your-django-models\">\n<h4>Updating your Django models</h4>\n<p><strong>Note:</strong> this part is only needed if you want to be able to use search\naliases, which allow you to define shortcuts to complex queries,\navailable directly from your Django models. I think it\u2019s extremely\npractical.</p>\n<ol>\n<li>Open your <tt>models.py</tt> file.</li>\n<li>Add the bungiesearch manager import:\n<tt>from bungiesearch.managers import BungiesearchManager</tt></li>\n<li>Find the model, or models, you wish to index on Elasticsearch and set\nthem to be managed by Bungiesearch by adding the objects field to\nthem, as such: <tt>objects = BungiesearchManager()</tt>. You should now\nhave a Django model <a href=\"https://github.com/Sparrho/bungiesearch#django-model\" rel=\"nofollow\">similar to\nthis</a>.</li>\n</ol>\n</div>\n<div id=\"creating-bungiesearch-search-indexes\">\n<h4>Creating bungiesearch search indexes</h4>\n<p>The search indexes define how bungiesearch should serialize each of the\nmodel\u2019s objects. It effectively defines how your object is serialized\nand how the ES index should be structured. These are referred to as\n<a href=\"https://github.com/Sparrho/bungiesearch#modelindex-1\" rel=\"nofollow\">ModelIndex</a>es.</p>\n<p>A good practice here is to have all the bungiesearch stuff in its own\npackage. For example, for the section of the Sparrho platform that uses\nDjango, we have a package called <tt>search</tt> where we define the search\nindexes, and a subpackage called <tt>aliases</tt> which has the many aliases\nwe use (more on that latter).</p>\n<ol>\n<li>Create a subclass of <tt>ModelIndex</tt>, which you can import from from\n<tt>bungiesearch.indices import ModelIndex</tt>, in a new module\npreferably.</li>\n<li>In this class, define a class called <tt>Meta</tt>: it will hold meta\ninformation of this search index for bungiesearch\u2019s internal working.</li>\n<li>Import the Django model you want to index (from your models file)\nand, in the Meta class, define a field called <tt>model</tt>, which must\nbe set to the model you want indexed.</li>\n<li>By default, bungiesearch will index every field of your model. This\nmay not always be desired, so you can define which fields must be\nexcluded in this <tt>Meta</tt> class, via the exclude field.</li>\n<li>There are plenty of options, so definitely have a read through the\ndocumentation for\n<a href=\"https://github.com/Sparrho/bungiesearch#modelindex-1\" rel=\"nofollow\">ModelIndex</a>.</li>\n</ol>\n<p>Here\u2019s <a href=\"https://github.com/Sparrho/bungiesearch#modelindex\" rel=\"nofollow\">an\nexample</a> of a\nsearch index. There can be many such definitions in a file.</p>\n</div>\n<div id=\"django-settings\">\n<h4>Django settings</h4>\n<p>This is the final required step. Here\u2019s the <a href=\"https://github.com/Sparrho/bungiesearch#settings\" rel=\"nofollow\">full\ndocumentation</a> of\nthis step.</p>\n<ol>\n<li>Open your settings file and add a <tt>BUNGIESEARCH</tt> variable, which\nmust be a dictionary.</li>\n<li>Define <tt>URLS</tt> as a list of URLs (which can contain only one) of\nyour ES servers.</li>\n<li>Define the <tt>INDICES</tt> key as a dictionary where the key is the name\nof the index on ES that you want, and the value is the full Python\npath to the module which has all the ModelIndex classes for to be\nindexed on that index name.</li>\n<li>Set <tt>ALIASES</tt> to an empty dictionary (until you define any search\naliases).</li>\n<li>You can keep other values as their defaults.</li>\n</ol>\n</div>\n</div>\n<div id=\"in-your-shell\">\n<h3><a href=\"#id15\" rel=\"nofollow\">In your shell</a></h3>\n<h3 id=\"create-the-es-indexes\"><span class=\"section-subtitle\">Create the ES indexes</span></h3>\n<p>From your shell, in the Django environment, run the following:</p>\n<p><tt>python manage.py search_index <span class=\"pre\">--create</span></tt></p>\n</div>\n<div id=\"start-populating-the-index\">\n<h3><a href=\"#id16\" rel=\"nofollow\">Start populating the index</a></h3>\n<p>Run the following which will take each of the objects in your model,\nserialize them, and add them to the elasticsearch index.</p>\n<p><tt>python manage.py search_index <span class=\"pre\">--update</span></tt></p>\n<p><strong>Note:</strong> With additional parameters, you can limit the number of\ndocuments to be indexed, as well as set conditions on whether they\nshould be indexed based on updated time for example.</p>\n</div>\n<div id=\"in-elasticsearch\">\n<h3><a href=\"#id17\" rel=\"nofollow\">In Elasticsearch</a></h3>\n<p>You can now open your elasticsearch dashboard, such as Elastic HQ, and\nsee that your index is created with the appropriate mapping and has\nitems that are indexed.</p>\n</div>\n</div>\n<div id=\"quick-start-example\">\n<h2><a href=\"#id18\" rel=\"nofollow\">Quick start example</a></h2>\n<p>This example is from the <tt>test</tt> folder. It may be partially out-dated,\nso please refer to the <tt>test</tt> folder for the latest version.</p>\n<div id=\"procedure\">\n<h3><a href=\"#id19\" rel=\"nofollow\">Procedure</a></h3>\n<ol>\n<li>In your models.py file (or your managers.py), import bungiesearch and\nuse it as a model manager.</li>\n<li>Define one or more ModelIndex subclasses which define the mapping\nbetween your Django model and elasticsearch.</li>\n<li>(Optional) Define SearchAlias subclasses which make it trivial to\ncall complex elasticsearch-dsl-py functions.</li>\n<li>Add a BUNGIESEARCH variable in your Django settings, which must\ncontain the elasticsearch URL(s), the modules for the indices, the\nmodules for the search aliases and the signal definitions.</li>\n</ol>\n</div>\n<div id=\"example\">\n<h3><a href=\"#id20\" rel=\"nofollow\">Example</a></h3>\n<p>Here\u2019s the code which is applicable to the previous examples. ### Django\nModel</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">django.db</span> <span class=\"kn\">import</span> <span class=\"n\">models</span>\n<span class=\"kn\">from</span> <span class=\"nn\">bungiesearch.managers</span> <span class=\"kn\">import</span> <span class=\"n\">BungiesearchManager</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Article</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">TextField</span><span class=\"p\">(</span><span class=\"n\">db_index</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">authors</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">TextField</span><span class=\"p\">(</span><span class=\"n\">blank</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">description</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">TextField</span><span class=\"p\">(</span><span class=\"n\">blank</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">link</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">URLField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">510</span><span class=\"p\">,</span> <span class=\"n\">unique</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">db_index</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">published</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">DateTimeField</span><span class=\"p\">(</span><span class=\"n\">null</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">created</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">DateTimeField</span><span class=\"p\">(</span><span class=\"n\">auto_now_add</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">updated</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">DateTimeField</span><span class=\"p\">(</span><span class=\"n\">null</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">tweet_count</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">IntegerField</span><span class=\"p\">()</span>\n    <span class=\"n\">raw</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">BinaryField</span><span class=\"p\">(</span><span class=\"n\">null</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">source_hash</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">BigIntegerField</span><span class=\"p\">(</span><span class=\"n\">null</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">missing_data</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">blank</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">255</span><span class=\"p\">)</span>\n    <span class=\"n\">positive_feedback</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">PositiveIntegerField</span><span class=\"p\">(</span><span class=\"n\">null</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">blank</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">default</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">negative_feedback</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">PositiveIntegerField</span><span class=\"p\">(</span><span class=\"n\">null</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">blank</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">default</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"n\">popularity_index</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">IntegerField</span><span class=\"p\">(</span><span class=\"n\">default</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n    <span class=\"n\">objects</span> <span class=\"o\">=</span> <span class=\"n\">BungiesearchManager</span><span class=\"p\">()</span>\n\n    <span class=\"k\">class</span> <span class=\"nc\">Meta</span><span class=\"p\">:</span>\n        <span class=\"n\">app_label</span> <span class=\"o\">=</span> <span class=\"s1\">'core'</span>\n</pre>\n<div id=\"modelindex\">\n<h4>ModelIndex</h4>\n<p>The following ModelIndex will generate a mapping containing all fields\nfrom <tt>Article</tt>, minus those defined in <tt>ArticleIndex.Meta.exclude</tt>.\nWhen the mapping is generated, each field will the most appropriate\n<a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/mapping-core-types.html\" rel=\"nofollow\">elasticsearch core\ntype</a>,\nwith default attributes (as defined in bungiesearch.fields).</p>\n<p>These default attributes can be overwritten with\n<tt>ArticleIndex.Meta.hotfixes</tt>: each dictionary key must be field\ndefined either in the model or in the ModelIndex subclass\n(<tt>ArticleIndex</tt> in this case).</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">core.models</span> <span class=\"kn\">import</span> <span class=\"n\">Article</span>\n<span class=\"kn\">from</span> <span class=\"nn\">bungiesearch.fields</span> <span class=\"kn\">import</span> <span class=\"n\">DateField</span><span class=\"p\">,</span> <span class=\"n\">StringField</span>\n<span class=\"kn\">from</span> <span class=\"nn\">bungiesearch.indices</span> <span class=\"kn\">import</span> <span class=\"n\">ModelIndex</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">ArticleIndex</span><span class=\"p\">(</span><span class=\"n\">ModelIndex</span><span class=\"p\">):</span>\n    <span class=\"n\">effectived_date</span> <span class=\"o\">=</span> <span class=\"n\">DateField</span><span class=\"p\">(</span><span class=\"n\">eval_as</span><span class=\"o\">=</span><span class=\"s1\">'obj.created if obj.created and obj.published &gt; obj.created else obj.published'</span><span class=\"p\">)</span>\n    <span class=\"n\">meta_data</span> <span class=\"o\">=</span> <span class=\"n\">StringField</span><span class=\"p\">(</span><span class=\"n\">eval_as</span><span class=\"o\">=</span><span class=\"s1\">'\" \".join([fld for fld in [obj.link, str(obj.tweet_count), obj.raw] if fld])'</span><span class=\"p\">)</span>\n\n    <span class=\"k\">class</span> <span class=\"nc\">Meta</span><span class=\"p\">:</span>\n        <span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">Article</span>\n        <span class=\"n\">exclude</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'raw'</span><span class=\"p\">,</span> <span class=\"s1\">'missing_data'</span><span class=\"p\">,</span> <span class=\"s1\">'negative_feedback'</span><span class=\"p\">,</span> <span class=\"s1\">'positive_feedback'</span><span class=\"p\">,</span> <span class=\"s1\">'popularity_index'</span><span class=\"p\">,</span> <span class=\"s1\">'source_hash'</span><span class=\"p\">)</span>\n        <span class=\"n\">hotfixes</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'updated'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'null_value'</span><span class=\"p\">:</span> <span class=\"s1\">'2013-07-01'</span><span class=\"p\">},</span>\n                    <span class=\"s1\">'title'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'boost'</span><span class=\"p\">:</span> <span class=\"mf\">1.75</span><span class=\"p\">},</span>\n                    <span class=\"s1\">'description'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'boost'</span><span class=\"p\">:</span> <span class=\"mf\">1.35</span><span class=\"p\">},</span>\n                    <span class=\"s1\">'full_text'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'boost'</span><span class=\"p\">:</span> <span class=\"mf\">1.125</span><span class=\"p\">}}</span>\n</pre>\n</div>\n<div id=\"searchalias\">\n<h4>SearchAlias</h4>\n<p>Defines a search alias for one or more models (in this case only for\n<tt>core.models.Article</tt>).</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">core.models</span> <span class=\"kn\">import</span> <span class=\"n\">Article</span>\n<span class=\"kn\">from</span> <span class=\"nn\">bungiesearch.aliases</span> <span class=\"kn\">import</span> <span class=\"n\">SearchAlias</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">SearchTitle</span><span class=\"p\">(</span><span class=\"n\">SearchAlias</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">alias_for</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">search_instance</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"s1\">'match'</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"n\">title</span><span class=\"p\">)</span>\n\n    <span class=\"k\">class</span> <span class=\"nc\">Meta</span><span class=\"p\">:</span>\n        <span class=\"n\">models</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">Article</span><span class=\"p\">,)</span>\n        <span class=\"n\">alias_name</span> <span class=\"o\">=</span> <span class=\"s1\">'title_search'</span> <span class=\"c1\"># This is optional. If none is provided, the name will be the class name in lower case.</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">InvalidAlias</span><span class=\"p\">(</span><span class=\"n\">SearchAlias</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">alias_for_does_not_exist</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">title</span>\n\n    <span class=\"k\">class</span> <span class=\"nc\">Meta</span><span class=\"p\">:</span>\n        <span class=\"n\">models</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">Article</span><span class=\"p\">,)</span>\n</pre>\n</div>\n<div id=\"id1\">\n<h4>Django settings</h4>\n<pre><span class=\"n\">BUNGIESEARCH</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n                <span class=\"s1\">'URLS'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">getenv</span><span class=\"p\">(</span><span class=\"s1\">'ELASTIC_SEARCH_URL'</span><span class=\"p\">)],</span>\n                <span class=\"s1\">'INDICES'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'bungiesearch_demo'</span><span class=\"p\">:</span> <span class=\"s1\">'core.search_indices'</span><span class=\"p\">},</span>\n                <span class=\"s1\">'ALIASES'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'bsearch'</span><span class=\"p\">:</span> <span class=\"s1\">'myproject.search_aliases'</span><span class=\"p\">},</span>\n                <span class=\"s1\">'SIGNALS'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'BUFFER_SIZE'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}</span>  <span class=\"c1\"># uses BungieSignalProcessor</span>\n                <span class=\"p\">}</span>\n</pre>\n</div>\n</div>\n</div>\n<div id=\"documentation\">\n<h2><a href=\"#id21\" rel=\"nofollow\">Documentation</a></h2>\n<div id=\"id2\">\n<h3><a href=\"#id22\" rel=\"nofollow\">ModelIndex</a></h3>\n<p>A <tt>ModelIndex</tt> defines mapping and object extraction for indexing of a\ngiven Django model.</p>\n<p>Any Django model to be managed by bungiesearch must have a defined\nModelIndex subclass. This subclass must contain a subclass called\n<tt>Meta</tt> which must have a <tt>model</tt> attribute (sets the model which it\nrepresents).</p>\n<div id=\"class-attributes\">\n<h4>Class attributes</h4>\n<p>As detailed below, the doc type mapping will contain fields from the\nmodel it related to. However, one may often need to index fields which\ncorrespond to either a concatenation of fields of the model or some\nlogical operation.</p>\n<p>Bungiesearch makes this very easy: simply define a class attribute as\nwhichever core type, and set to the <tt>eval_as</tt> constructor parameter to\na one line Python statement. The object is referenced as <tt>obj</tt> (not\n<tt>self</tt> nor <tt>object</tt>, just <tt>obj</tt>).</p>\n<div id=\"id3\">\n<h5>Example</h5>\n<p>This is a partial example as the Meta subclass is not defined, yet\nmandatory (cf. below).</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">bungiesearch.fields</span> <span class=\"kn\">import</span> <span class=\"n\">DateField</span><span class=\"p\">,</span> <span class=\"n\">StringField</span>\n<span class=\"kn\">from</span> <span class=\"nn\">bungiesearch.indices</span> <span class=\"kn\">import</span> <span class=\"n\">ModelIndex</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ArticleIndex</span><span class=\"p\">(</span><span class=\"n\">ModelIndex</span><span class=\"p\">):</span>\n    <span class=\"n\">effective_date</span> <span class=\"o\">=</span> <span class=\"n\">DateField</span><span class=\"p\">(</span><span class=\"n\">eval_as</span><span class=\"o\">=</span><span class=\"s1\">'obj.created if obj.created and obj.published &gt; obj.created else obj.published'</span><span class=\"p\">)</span>\n    <span class=\"n\">meta_data</span> <span class=\"o\">=</span> <span class=\"n\">StringField</span><span class=\"p\">(</span><span class=\"n\">eval_as</span><span class=\"o\">=</span><span class=\"s1\">'\" \".join([fld for fld in [obj.link, str(obj.tweet_count), obj.raw] if fld])'</span><span class=\"p\">)</span>\n</pre>\n<p>Here, both <tt>effective_date</tt> and <tt>meta_data</tt> will be part of the doc\ntype mapping, but won\u2019t be reversed mapped since those fields do not\nexist in the model.</p>\n<p>This can also be used to index foreign keys:</p>\n<pre><span class=\"n\">some_field_name</span> <span class=\"o\">=</span> <span class=\"n\">StringField</span><span class=\"p\">(</span><span class=\"n\">eval_as</span><span class=\"o\">=</span><span class=\"s1\">'\",\".join([item for item in obj.some_foreign_relation.values_list(\"some_field\", flat=True)]) if obj.some_foreign_relation else \"\"'</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"class-methods\">\n<h4>Class methods</h4>\n<h4 id=\"matches-indexing-condition\"><span class=\"section-subtitle\">matches_indexing_condition</span></h4>\n<p>Override this function to specify whether an item should be indexed or\nnot. This is useful when defining multiple indices (and ModelIndex\nclasses) for a given model. This method\u2019s signature and super class code\nis as follows, and allows indexing of all items.</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">matches_indexing_condition</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">item</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"kc\">True</span>\n</pre>\n<p>For example, if a given elasticsearch index should contain only item\nwhose title starts with <tt>\"Awesome\"</tt>, then this method can be\noverridden as follows.</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">matches_indexing_condition</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">item</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">item</span><span class=\"o\">.</span><span class=\"n\">title</span><span class=\"o\">.</span><span class=\"n\">startswith</span><span class=\"p\">(</span><span class=\"s2\">\"Awesome\"</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"meta-subclass-attributes\">\n<h4>Meta subclass attributes</h4>\n<p><strong>Note</strong>: in the following, any variable defined a being a <tt>list</tt>\ncould also be a <tt>tuple</tt>. ##### model <em>Required:</em> defines the Django\nmodel for which this ModelIndex is applicable.</p>\n<div id=\"fields\">\n<h5>fields</h5>\n<p><em>Optional:</em> list of fields (or columns) which must be fetched when\nserializing the object for elasticsearch, or when reverse mapping the\nobject from elasticsearch back to a Django Model instance. By default,\nall fields will be fetched. Setting this <em>will</em> restrict which fields\ncan be fetched and may lead to errors when serializing the object. It is\nrecommended to use the <tt>exclude</tt> attribute instead (cf. below).</p>\n</div>\n<div id=\"exclude\">\n<h5>exclude</h5>\n<p><em>Optional:</em> list of fields (or columns) which must not be fetched when\nserializing or deserializing the object.</p>\n</div>\n<div id=\"hotfixes\">\n<h5>hotfixes</h5>\n<p><em>Optional:</em> a dictionary whose keys are index fields and whose values\nare dictionaries which define <a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/mapping-core-types.html\" rel=\"nofollow\">core type\nattributes</a>.\nBy default, there aren\u2019t any special settings, apart for String fields,\nwhere the\n<a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/analysis-analyzers.html\" rel=\"nofollow\">analyzer</a>\nis set to\n<tt>`snowball</tt> &lt;<a href=\"http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/analysis-snowball-analyzer.html\" rel=\"nofollow\">http://www.elasticsearch.org/guide/en/elasticsearch/reference/current/analysis-snowball-analyzer.html</a>&gt;`__\n(<tt>{'analyzer': 'snowball'}</tt>).</p>\n</div>\n<div id=\"additional-fields\">\n<h5>additional_fields</h5>\n<p><em>Optional:</em> additional fields to fetch for mapping, may it be for\n<tt>eval_as</tt> fields or when returning the object from the database.</p>\n</div>\n<div id=\"id-field\">\n<h5>id_field</h5>\n<p><em>Optional:</em> the model field to use as a unique ID for elasticsearch\u2019s\nmetadata <tt>_id</tt>. Defaults to <tt>id</tt> (also called\n<tt>`pk</tt> &lt;<a href=\"https://docs.djangoproject.com/en/dev/topics/db/models/#automatic-primary-key-fields\" rel=\"nofollow\">https://docs.djangoproject.com/en/dev/topics/db/models/#automatic-primary-key-fields</a>&gt;`__).</p>\n</div>\n<div id=\"updated-field\">\n<h5>updated_field</h5>\n<p><em>Optional:</em> set the model\u2019s field which can be filtered on dates in\norder to find when objects have been updated. Note, this is <em>mandatory</em>\nto use <tt><span class=\"pre\">--start</span></tt> and/or <tt><span class=\"pre\">--end</span></tt> when updating index (with\n<tt>search_index <span class=\"pre\">--update</span></tt>).</p>\n</div>\n<div id=\"optimize-queries\">\n<h5>optimize_queries</h5>\n<p><em>Optional:</em> set to True to make efficient queries when automatically\nmapping to database objects. This will <em>always</em> restrict fetching to the\nfields set in <tt>fields</tt> and in <tt>additional_fields</tt>. <em>Note:</em> You can\nalso perform an optimal database query with <tt><span class=\"pre\">.only('__model')</span></tt>, which\nwill use the same fields as <tt>optimize_queries</tt>, or\n<tt><span class=\"pre\">.only('__fields')</span></tt>, which will use the fields provided in the\n<tt>.fields()</tt> call.</p>\n</div>\n<div id=\"indexing-query\">\n<h5>indexing_query</h5>\n<p><em>Optional:</em> set to a QuerySet instance to specify the query used when\nthe search_index command is ran to index. This <strong>does not</strong> affect how\neach piece of content is indexed.</p>\n</div>\n<div id=\"default\">\n<h5>default</h5>\n<p>Enables support for a given model to be indexed on several elasticsearch\nindices. Set to <tt>False</tt> on all but the default index. <strong>Note</strong>: if all\nmanaged models are set with <tt>default=False</tt> then Bungiesearch will\nfail to find and index that model.</p>\n</div>\n</div>\n<div id=\"id4\">\n<h4>Example</h4>\n<p>Indexes all objects of <tt>Article</tt>, as long as their <tt>updated</tt>\ndatetime is less than <a href=\"https://en.wikipedia.org/wiki/Back_to_the_Future_Part_II\" rel=\"nofollow\">21 October 2015\n04:29</a>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">core.models</span> <span class=\"kn\">import</span> <span class=\"n\">Article</span>\n<span class=\"kn\">from</span> <span class=\"nn\">bungiesearch.indices</span> <span class=\"kn\">import</span> <span class=\"n\">ModelIndex</span>\n<span class=\"kn\">from</span> <span class=\"nn\">datetime</span> <span class=\"kn\">import</span> <span class=\"n\">datetime</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ArticleIndex</span><span class=\"p\">(</span><span class=\"n\">ModelIndex</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">matches_indexing_condition</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">item</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">item</span><span class=\"o\">.</span><span class=\"n\">updated</span> <span class=\"o\">&lt;</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"p\">(</span><span class=\"mi\">2015</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">21</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">29</span><span class=\"p\">)</span>\n\n    <span class=\"k\">class</span> <span class=\"nc\">Meta</span><span class=\"p\">:</span>\n        <span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">Article</span>\n        <span class=\"n\">id_field</span> <span class=\"o\">=</span> <span class=\"s1\">'id'</span> <span class=\"c1\"># That's actually the default value, so it's not really needed.</span>\n        <span class=\"n\">exclude</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'raw'</span><span class=\"p\">,</span> <span class=\"s1\">'missing_data'</span><span class=\"p\">,</span> <span class=\"s1\">'negative_feedback'</span><span class=\"p\">,</span> <span class=\"s1\">'positive_feedback'</span><span class=\"p\">,</span> <span class=\"s1\">'popularity_index'</span><span class=\"p\">,</span> <span class=\"s1\">'source_hash'</span><span class=\"p\">)</span>\n        <span class=\"n\">hotfixes</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">'updated'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'null_value'</span><span class=\"p\">:</span> <span class=\"s1\">'2013-07-01'</span><span class=\"p\">},</span>\n                    <span class=\"s1\">'title'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'boost'</span><span class=\"p\">:</span> <span class=\"mf\">1.75</span><span class=\"p\">},</span>\n                    <span class=\"s1\">'description'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'boost'</span><span class=\"p\">:</span> <span class=\"mf\">1.35</span><span class=\"p\">},</span>\n                    <span class=\"s1\">'full_text'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'boost'</span><span class=\"p\">:</span> <span class=\"mf\">1.125</span><span class=\"p\">}}</span>\n        <span class=\"n\">optimized_queries</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n        <span class=\"n\">indexing_query</span> <span class=\"o\">=</span> <span class=\"n\">Article</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">defer</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">exclude</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">select_related</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">all</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">prefetch_related</span><span class=\"p\">(</span><span class=\"s1\">'tags'</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"id5\">\n<h3><a href=\"#id23\" rel=\"nofollow\">SearchAlias</a></h3>\n<p>A <tt>SearchAlias</tt> define search shortcuts (somewhat similar to <a href=\"https://docs.djangoproject.com/en/dev/topics/db/managers/\" rel=\"nofollow\">Django\nmanagers</a>).\nOften times, a given search will be used in multiple parts of the code.\nSearchAliases allow you define those queries, filters, or any\nbungiesearch/elasticsearch-dsl-py calls as an alias.</p>\n<p>A search alias is either applicable to a <tt>list</tt> (or <tt>tuple</tt>) of\nmanaged models, or to any bungiesearch instance. It\u2019s very simple, so\nhere\u2019s an example which is detailed right below.</p>\n<div id=\"id6\">\n<h4>Example</h4>\n<p>The most simple implementation of a SearchAlias is as follows. This\nsearch alias can be called via <tt>Article.objects.bungie_title</tt> (or\n<tt>Article.objects.search.bungie_title</tt>), supposing that the namespace\nis set to <tt>None</tt> in the settings (cf. below).</p>\n<div id=\"definition\">\n<h5>Definition</h5>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">bungiesearch.aliases</span> <span class=\"kn\">import</span> <span class=\"n\">SearchAlias</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Title</span><span class=\"p\">(</span><span class=\"n\">SearchAlias</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">alias_for</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">search_instance</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"s1\">'match'</span><span class=\"p\">,</span> <span class=\"n\">title</span><span class=\"o\">=</span><span class=\"n\">title</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"usage\">\n<h5>Usage</h5>\n<pre><span class=\"n\">Article</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">bungie_title</span><span class=\"p\">(</span><span class=\"s1\">'title'</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"method-overwrite\">\n<h4>Method overwrite</h4>\n<p>Any implementation needs to inherit from\n<tt>bungiesearch.aliases.SearchAlias</tt> and overwrite <tt>alias_for</tt>. You\ncan set as many or as little parameters as you want for that function\n(since bungiesearch only return the pointer to that function without\nactually calling it).</p>\n<p>Since each managed model has its own doc type, <tt>self.search_instance</tt>\nis a bungiesearch instance set to search the specific doctype.</p>\n</div>\n<div id=\"id7\">\n<h4>Meta subclass attributes</h4>\n<p>Although not mandatory, the <tt>Meta</tt> subclass enabled custom naming and\nmodel restrictions for a search alias.</p>\n<div id=\"models\">\n<h5>models</h5>\n<p><em>Optional:</em> <tt>list</tt> (or <tt>tuple</tt>) of Django models which are allowed\nto use this search alias. If a model which is not allowed to use this\nSearchAlias tries it, a <tt>ValueError</tt> will be raised.</p>\n</div>\n<div id=\"alias-name\">\n<h5>alias_name</h5>\n<p><em>Optional:</em> A string corresponding the suffix name of this search alias.\nDefaults to the lower case class name.</p>\n<p><strong>WARNING</strong>: As explained in the \u201cSettings\u201d section below, all search\naliases in a given module share the prefix (or namespace). This is to\nprevent aliases from accidently overwriting Django manager function\n(e.g. <tt>update</tt> or <tt>get</tt>). In other words, if you define the\n<tt>alias_name</tt> to <tt>test</tt>, then it must be called as\n<tt><span class=\"pre\">model_obj.objects.$prefix$_test</span></tt> where <tt>$prefix$</tt> is the prefix\ndefined in the settings. This prefix is also applicable to search\naliases which are available via bungiesearch instances directly. Hence,\none can define in one module search utilities (e.g. <tt>regex</tt> and\n<tt>range</tt>) and define model specific aliases (e.g. <tt>title</tt>) in another\nmodule, and use both in conjunction as such:\n<tt><span class=\"pre\">Article.objects.search.bungie_title('search</span> <span class=\"pre\">title').utils_range(field='created',</span> <span class=\"pre\">gte='2014-05-20',</span> as_query=True)</tt>.\nThese aliases can be concatenated ad vitam aeternam.</p>\n</div>\n</div>\n<div id=\"sophisticated-example\">\n<h4>Sophisticated example</h4>\n<p>This example shows that we can have some fun with search aliases. In\nthis case, we define a Range alias which is applicable to any field on\nany model.</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Range</span><span class=\"p\">(</span><span class=\"n\">SearchAlias</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">alias_for</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">field</span><span class=\"p\">,</span> <span class=\"n\">gte</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">lte</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">boost</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">as_query</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">):</span>\n        <span class=\"n\">body</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">field</span><span class=\"p\">:</span> <span class=\"p\">{}}</span>\n        <span class=\"k\">if</span> <span class=\"n\">gte</span><span class=\"p\">:</span>\n            <span class=\"n\">body</span><span class=\"p\">[</span><span class=\"n\">field</span><span class=\"p\">][</span><span class=\"s1\">'gte'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">gte</span>\n        <span class=\"k\">if</span> <span class=\"n\">lte</span><span class=\"p\">:</span>\n            <span class=\"n\">body</span><span class=\"p\">[</span><span class=\"n\">field</span><span class=\"p\">][</span><span class=\"s1\">'lte'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">lte</span>\n        <span class=\"k\">if</span> <span class=\"n\">boost</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">as_query</span><span class=\"p\">:</span>\n                <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">warning</span><span class=\"p\">(</span><span class=\"s1\">'Boost is not applicable to search alias Range when not used as a query.'</span><span class=\"p\">)</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">body</span><span class=\"p\">[</span><span class=\"n\">field</span><span class=\"p\">][</span><span class=\"s1\">'boost'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">boost</span>\n        <span class=\"k\">if</span> <span class=\"n\">as_query</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">search_instance</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">({</span><span class=\"s1\">'range'</span><span class=\"p\">:</span> <span class=\"n\">body</span><span class=\"p\">})</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">search_instance</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">({</span><span class=\"s1\">'range'</span><span class=\"p\">:</span> <span class=\"n\">body</span><span class=\"p\">})</span>\n</pre>\n<p>We can use it as such\n<tt><span class=\"pre\">Article.objects.bungie_range(field='created',</span> <span class=\"pre\">gte='2014-05-20',</span> as_query=True)</tt>.</p>\n</div>\n</div>\n<div id=\"settings\">\n<h3><a href=\"#id24\" rel=\"nofollow\">Settings</a></h3>\n<p>Add \u2018bungiesearch\u2019 to INSTALLED_APPS.</p>\n<p>You must define <tt>BUNGIESEARCH</tt> in your Django settings in order for\nbungiesearch to know elasticsearch URL(s) and which index name contains\nmappings for each ModelIndex.</p>\n<pre><span class=\"n\">BUNGIESEARCH</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n                <span class=\"s1\">'URLS'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'localhost'</span><span class=\"p\">],</span> <span class=\"c1\"># No leading http:// or the elasticsearch client will complain.</span>\n                <span class=\"s1\">'INDICES'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'main_index'</span><span class=\"p\">:</span> <span class=\"s1\">'myproject.myapp.myindices'</span><span class=\"p\">}</span> <span class=\"c1\"># Must be a module path.</span>\n                <span class=\"s1\">'ALIASES'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'bsearch'</span><span class=\"p\">:</span> <span class=\"s1\">'myproject.search_aliases'</span><span class=\"p\">},</span>\n                <span class=\"s1\">'SIGNALS'</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"s1\">'BUFFER_SIZE'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">},</span>\n                <span class=\"s1\">'TIMEOUT'</span><span class=\"p\">:</span> <span class=\"mi\">5</span>\n                <span class=\"p\">}</span>\n</pre>\n<div id=\"urls\">\n<h4>URLS</h4>\n<p><em>Required:</em> must be a list of URLs which host elasticsearch instance(s).\nThis is directly sent to elasticsearch-dsl-py, so any issue with\nmultiple URLs should be refered to them.</p>\n</div>\n<div id=\"indices\">\n<h4>INDICES</h4>\n<p><em>Required:</em> must be a dictionary where each key is the name of an\nelasticsearch index and each value is a path to a Python module\ncontaining classes which inherit from\n<tt>bungiesearch.indices.ModelIndex</tt> (cf. below).</p>\n</div>\n<div id=\"aliases\">\n<h4>ALIASES</h4>\n<p><em>Optional:</em> a dictionary whose key is the alias namespace and whose\nvalue is the Python module containing classes which inherit from\n<tt>bungiesearch.aliases.SearchAlias</tt>. If the namespace is <tt>None</tt>, then\nthe alias will be named <tt>bungie</tt>. If the namespace is an empty string,\nthere will be no alias namespace. The provided namespace will be\nappended by an underscore. In the example above, each search alias\ndefined in <tt>myproject.search_aliases</tt> will be referenced as\n<tt><span class=\"pre\">$ModelObj$.objects.bsearch_$alias$</span></tt>, where <tt>$ModelObj$</tt> is a Django\nmodel and <tt>$alias$</tt> is the name of the search alias.</p>\n<p>The purpose is to not accidently overwrite Django\u2019s default manager\nfunctions with search aliases.</p>\n</div>\n<div id=\"signals\">\n<h4>SIGNALS</h4>\n<p><em>Optional:</em> if it exists, it must be a dictionary (even empty), and will\nconnect to the <tt>post save</tt> and <tt>pre delete</tt> model functions of <em>all</em>\nmodels using <tt>bungiesearch.managers.BungiesearchManager</tt> as a manager.\nOne may also define a signal processor class for more custom\nfunctionality by placing the string value of the module path under a key\ncalled <tt>SIGNAL_CLASS</tt> in the dictionary value of <tt>SIGNALS</tt> and\ndefining <tt>setup</tt> and <tt>teardown</tt> methods, which take <tt>model</tt> as the\nonly parameter. These methods connect and disconnect the signal\nprocessing class to django signals (signals are connected to each model\nwhich uses a BungiesearchManager).</p>\n<p>If <tt>SIGNALS</tt> is not defined in the settings, <em>none</em> of the models\nmanaged by BungiesearchManager will automatically update the index when\na new item is created or deleted.</p>\n<div id=\"buffer-size\">\n<h5>BUFFER_SIZE</h5>\n<p><em>Optional:</em> an integer representing the number of items to buffer before\nmaking a bulk index update, defaults to <tt>100</tt>.</p>\n<p><strong>WARNING</strong>: if your application is shut down before the buffer is\nemptied, then any buffered instance <em>will not</em> be indexed on\nelasticsearch. Hence, a possibly better implementation is wrapping\n<tt>post_save_connector</tt> and <tt>pre_delete_connector</tt> from\n<tt>bungiesearch.signals</tt> in a celery task. It is not implemented as such\nhere in order to not require <tt>celery</tt>.</p>\n</div>\n</div>\n<div id=\"timeout\">\n<h4>TIMEOUT</h4>\n<p><em>Optional:</em> Elasticsearch connection timeout in seconds. Defaults to\n<tt>5</tt>.</p>\n</div>\n</div>\n</div>\n<div id=\"testing\">\n<h2><a href=\"#id25\" rel=\"nofollow\">Testing</a></h2>\n<p>The easiest way to run the tests is to install all dev dependencies using\n<tt>./setup.sh</tt> then run <tt>./test.sh</tt></p>\n<p>All Bungiesearch tests are in <tt>tests/core/test_bungiesearch.py</tt>. You\ncan run the tests by creating a Python virtual environment, installing\nthe requirements from <tt>requirements.txt</tt>, installing the package\n(<tt>pip install .</tt>) and running <tt>python tests/manage.py test</tt>. Make\nsure to update <tt>tests/settings.py</tt> to use your own elasticsearch URLs,\nor update the ELASTIC_SEARCH_URL environment variable.</p>\n</div>\n\n          </div>"}, "last_serial": 1846445, "releases": {"1.0.2": [{"comment_text": "", "digests": {"md5": "3d5dfd50f284764515b19ab65add51c5", "sha256": "798acb79f857bae524ad32995834158380f3ebeb0ae1ab248f5b55ebd7774263"}, "downloads": -1, "filename": "bungiesearch-1.0.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "3d5dfd50f284764515b19ab65add51c5", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 38586, "upload_time": "2015-06-05T16:46:50", "upload_time_iso_8601": "2015-06-05T16:46:50.464986Z", "url": "https://files.pythonhosted.org/packages/b4/07/139ad3d51174510790696ea6392a164131642ac17ba95b2656175a11aa1d/bungiesearch-1.0.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f3340b5d2f47f06b2ffdf3cecc38f6cd", "sha256": "681f5904b9d78ebb169d0d3d5a1b344602d0a17aecf47a11d10ef9b96b0f7086"}, "downloads": -1, "filename": "bungiesearch-1.0.2.tar.gz", "has_sig": false, "md5_digest": "f3340b5d2f47f06b2ffdf3cecc38f6cd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30146, "upload_time": "2015-06-05T16:46:54", "upload_time_iso_8601": "2015-06-05T16:46:54.822136Z", "url": "https://files.pythonhosted.org/packages/f2/3b/6f8c5b822aaba9c0f9e57f57822fcffc527cab8c7458435a91d147c0f026/bungiesearch-1.0.2.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "fd62df76b0988a672db3b35358c79a77", "sha256": "64a413b087d4db8c94626c69628770f5a1c3dcb39303c1aebfce2b2f9696d207"}, "downloads": -1, "filename": "bungiesearch-1.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "fd62df76b0988a672db3b35358c79a77", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 40866, "upload_time": "2015-06-26T11:39:58", "upload_time_iso_8601": "2015-06-26T11:39:58.878842Z", "url": "https://files.pythonhosted.org/packages/9d/0b/4152e541ceded5d982e86c530f4af81855c63f03063eb9be06e9b98afae0/bungiesearch-1.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9e957a11fb73b0c3f7ef2ec46e3ccf9b", "sha256": "4367dc614c41112e65bf7a1b3f823b5fa78ec6c79dfbb2b3c3377d83c443a62d"}, "downloads": -1, "filename": "bungiesearch-1.1.0.tar.gz", "has_sig": false, "md5_digest": "9e957a11fb73b0c3f7ef2ec46e3ccf9b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32379, "upload_time": "2015-06-26T11:40:02", "upload_time_iso_8601": "2015-06-26T11:40:02.917611Z", "url": "https://files.pythonhosted.org/packages/02/23/03d09ae14cbbab61c6a8fab07a7669098522c31691f3e09599ca1368e8fa/bungiesearch-1.1.0.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "d4211f5ac1c7cbe848433a435a8e3b8d", "sha256": "809ed85c84025d0cd1b2825ce394e7572b7dbb8f12b7a331ca78c728ddbcaa1b"}, "downloads": -1, "filename": "bungiesearch-1.2.0.tar.gz", "has_sig": false, "md5_digest": "d4211f5ac1c7cbe848433a435a8e3b8d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 37805, "upload_time": "2015-08-07T15:37:49", "upload_time_iso_8601": "2015-08-07T15:37:49.367955Z", "url": "https://files.pythonhosted.org/packages/84/bf/93552fab7bdd66772731331b8ce83dff3454323cab06caa9816e45949374/bungiesearch-1.2.0.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "9e06cf398f84c3d87472f16d3cca1902", "sha256": "ec9979d3f1cdb15d0065f9a27c4ac90389f8c58bde0e85388b3cf410e3135395"}, "downloads": -1, "filename": "bungiesearch-1.2.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9e06cf398f84c3d87472f16d3cca1902", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 48066, "upload_time": "2015-08-10T10:45:29", "upload_time_iso_8601": "2015-08-10T10:45:29.923460Z", "url": "https://files.pythonhosted.org/packages/2a/a4/596c5c581e83c08f0bf79fe519d568456a960c80b0778c12a85a84f5f57b/bungiesearch-1.2.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1ee84abde71f724269cc050b94b1309e", "sha256": "662f7a702e441f7662cc2233493935830f638f32b5b80a5460a4810a562339fb"}, "downloads": -1, "filename": "bungiesearch-1.2.1.tar.gz", "has_sig": false, "md5_digest": "1ee84abde71f724269cc050b94b1309e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47213, "upload_time": "2015-08-10T10:45:25", "upload_time_iso_8601": "2015-08-10T10:45:25.025498Z", "url": "https://files.pythonhosted.org/packages/c7/d4/7ac190569459bbfa472404c1d60671c715a41cf5e9513800324ffd06c823/bungiesearch-1.2.1.tar.gz", "yanked": false}], "1.2.2": [{"comment_text": "", "digests": {"md5": "972eac11859a4d76d8a725d0b239ff6f", "sha256": "f2a190660d6d88fe79a57f5eeb33d596c8c7b633b74d6a73e39064249c46ca2a"}, "downloads": -1, "filename": "bungiesearch-1.2.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "972eac11859a4d76d8a725d0b239ff6f", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 48363, "upload_time": "2015-11-05T12:19:40", "upload_time_iso_8601": "2015-11-05T12:19:40.142838Z", "url": "https://files.pythonhosted.org/packages/76/fd/f4a842d9a52f30b44b2be84861c0902bc186d5d29e5dc90853a2356a476d/bungiesearch-1.2.2-py2.py3-none-any.whl", "yanked": false}], "1.3.0": [{"comment_text": "", "digests": {"md5": "fccd780fa6c4f5dc672a91d09b4c3968", "sha256": "eafb5fa8236f087edc2bf94a1416b173823a3dfcecb4f94d2e303136b717bb00"}, "downloads": -1, "filename": "bungiesearch-1.3.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "fccd780fa6c4f5dc672a91d09b4c3968", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 48566, "upload_time": "2015-12-04T13:02:00", "upload_time_iso_8601": "2015-12-04T13:02:00.958097Z", "url": "https://files.pythonhosted.org/packages/2b/a0/d95640a1ea3af48de5338caa887b11e814ba791e244d3f8e4e5b8d89da37/bungiesearch-1.3.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "732e4de9dbb9264af7abd816d2fd5dd1", "sha256": "973aa0d5e85e97fecf66932173e1ed5923745c23977e4068706e332d22147ad3"}, "downloads": -1, "filename": "bungiesearch-1.3.0.tar.gz", "has_sig": false, "md5_digest": "732e4de9dbb9264af7abd816d2fd5dd1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47907, "upload_time": "2015-12-04T13:01:55", "upload_time_iso_8601": "2015-12-04T13:01:55.483582Z", "url": "https://files.pythonhosted.org/packages/21/27/642df321ba9adea9de114e5659c01aef5af2e01a90ee6f0f9326538626a9/bungiesearch-1.3.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fccd780fa6c4f5dc672a91d09b4c3968", "sha256": "eafb5fa8236f087edc2bf94a1416b173823a3dfcecb4f94d2e303136b717bb00"}, "downloads": -1, "filename": "bungiesearch-1.3.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "fccd780fa6c4f5dc672a91d09b4c3968", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 48566, "upload_time": "2015-12-04T13:02:00", "upload_time_iso_8601": "2015-12-04T13:02:00.958097Z", "url": "https://files.pythonhosted.org/packages/2b/a0/d95640a1ea3af48de5338caa887b11e814ba791e244d3f8e4e5b8d89da37/bungiesearch-1.3.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "732e4de9dbb9264af7abd816d2fd5dd1", "sha256": "973aa0d5e85e97fecf66932173e1ed5923745c23977e4068706e332d22147ad3"}, "downloads": -1, "filename": "bungiesearch-1.3.0.tar.gz", "has_sig": false, "md5_digest": "732e4de9dbb9264af7abd816d2fd5dd1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 47907, "upload_time": "2015-12-04T13:01:55", "upload_time_iso_8601": "2015-12-04T13:01:55.483582Z", "url": "https://files.pythonhosted.org/packages/21/27/642df321ba9adea9de114e5659c01aef5af2e01a90ee6f0f9326538626a9/bungiesearch-1.3.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:35:58 2020"}