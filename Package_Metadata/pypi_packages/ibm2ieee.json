{"info": {"author": "Enthought", "author_email": "info@enthought.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "The **ibm2ieee** package provides NumPy universal functions (\"ufuncs\") for\nconverting IBM single-precision and double-precision hexadecimal floats\nto the IEEE 754-format floats used by Python and NumPy on almost all\ncurrent platforms.\n\n\nFeatures\n--------\n\n- Fast: 200-400 million values converted per second on a typical modern\n  machine, assuming normal inputs.\n- Correct: converted results are correctly rounded, according to the default\n  IEEE 754 round-ties-to-even rounding mode. Corner cases (overflow, underflow,\n  subnormal results, signed zeros, non-normalised input) are all handled\n  correctly. Where the rounded converted value is out of range for the target\n  type, an appropriately-signed infinity is returned.\n- Handles both single-precision and double-precision input and output formats.\n\nPortability note: the conversion functions provided in this module assume that\n``numpy.float32`` and ``numpy.float64`` are based on the standard IEEE 754\nbinary32 and binary64 floating-point formats. This is true on the overwhelming\nmajority of current platforms, but is not guaranteed by the relevant language\nstandards.\n\n\nUsage\n-----\n\nThe package provides two functions:\n\n- ``ibm2float32`` converts IBM single- or double-precision data to\n  IEEE 754 single-precision values, in ``numpy.float32`` format.\n\n- ``ibm2float64`` converts IBM single- or double-precision data to\n  IEEE 754 double-precision values, in ``numpy.float64`` format.\n\nFor both functions, IBM single-precision input data must be represented\nusing the ``numpy.uint32`` dtype, while IBM double-precision inputs must\nbe represented using ``numpy.uint64``.\n\nBoth functions assume that the IBM data have been converted to NumPy integer\nformat in such a way that the most significant bits of the floating-point\nnumber become the most significant bits of the integer values. So when decoding\nbyte data representing IBM hexadecimal floating-point numbers, it's important\nto take the endianness of the byte data into account. See the Examples section\nbelow for an example of converting big-endian byte data.\n\n\nExamples\n--------\n\n>>> import numpy\n>>> from ibm2ieee import ibm2float32, ibm2float64\n>>> ibm2float32(numpy.uint32(0xc1180000))\n-1.5\n>>> type(ibm2float32(numpy.uint32(0xc1180000)))\n<class 'numpy.float32'>\n>>> ibm2float32(numpy.uint64(0x413243f6a8885a31))\n3.1415927\n>>> ibm2float32(numpy.uint32(0x61100000))\ninf\n>>> ibm2float64(numpy.uint32(0xc1180000))\n-1.5\n>>> ibm2float64(numpy.uint64(0x413243f6a8885a31))\n3.141592653589793\n>>> ibm2float64(numpy.uint32(0x61100000))\n3.402823669209385e+38\n>>> input_array = numpy.arange(\n        0x40fffffe, 0x41000002, dtype=numpy.uint32).reshape(2, 2)\n>>> input_array\narray([[1090519038, 1090519039],\n       [1090519040, 1090519041]], dtype=uint32)\n>>> ibm2float64(input_array)\narray([[9.99999881e-01, 9.99999940e-01],\n       [0.00000000e+00, 9.53674316e-07]])\n\nWhen converting byte data read from a file, it's important to know the\nendianness of that data (which is frequently big-endian in historical data\nfiles using IBM hex floating-point). Here's an example of converting IBM\nsingle-precision data stored in big-endian form to ``numpy.float32``. Note the\nuse of the ``'>u4'`` dtype when converting the bytestring to a NumPy ``uint32``\narray. For little-endian input data, you would use ``'<u4'`` instead.\n\n>>> input_data = b'\\xc12C\\xf7\\xc1\\x19!\\xfb\\x00\\x00\\x00\\x00A\\x19!\\xfbA2C\\xf7'\n>>> input_as_uint32 = numpy.frombuffer(input_data, dtype='>u4')\n>>> input_as_uint32\narray([3241296887, 3239649787,          0, 1092166139, 1093813239],\n      dtype=uint32)\n>>> ibm2float32(input_as_uint32)\narray([-3.141593, -1.570796,  0.      ,  1.570796,  3.141593],\n      dtype=float32)\n\n\nNotes on the formats\n--------------------\n\nThe IBM single-precision format has a precision of 6 hexadecimal digits, which\nin practice translates to a precision of 21-24 bits, depending on the binade\nthat the relevant value belongs to. IEEE 754 single-precision has a precision\nof 24 bits. So all not-too-small, not-too-large IBM single-precision values can\nbe translated to IEEE 754 single-precision values with no loss of precision.\nHowever, the IBM single precision range is larger than the corresponding IEEE\n754 range, so extreme IBM single-precision values may overflow to infinity,\nunderflow to zero, or be rounded to a subnormal value when converted to IEEE\n754 single-precision.\n\nFor double-precision conversions, the tradeoff works the other way: the IBM\ndouble-precision format has an effective precision of 53-56 bits, while IEEE\n754 double-precision has 53-bit precision. So most IBM values will be rounded\nwhen converted to IEEE 754. However, the IEEE 754 double-precision range is\nlarger than that of IBM double-precision, so there's no danger of overflow,\nunderflow, or reduced-precision subnormal results when converting IBM\ndouble-precision to IEEE 754 double-precision.\n\nEvery IBM single-precision value can be exactly represented in IEEE 754\ndouble-precision, so if you want a lossless representation of IBM\nsingle-precision data, use ``ibm2float64``.\n\nNote that the IBM formats do not allow representations of special values like\ninfinities and NaNs. However, signed zeros are representable, and the sign of a\nzero is preserved under all conversions.\n\n\nInstallation\n------------\n\nThe latest release of ibm2ieee is available from the Python Package Index, at\nhttps://pypi.org/project/ibm2ieee. It can be installed with ``pip`` in the\nusual way::\n\n    pip install ibm2ieee\n\nNote that it includes a C extension, so you'll need a compiler on your system\nto be able to install.\n\n\nLicense\n-------\n\nThe ibm2ieee package is copyright (c) 2018, Enthought, Inc.\n\nThe ibm2ieee package is licensed under a standard BSD 3-clause License. See the\nLICENSE file for details.", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/enthought/ibm2ieee", "keywords": "ibm hfp ieee754 hexadecimal floating-point ufunc", "license": "", "maintainer": "", "maintainer_email": "", "name": "ibm2ieee", "package_url": "https://pypi.org/project/ibm2ieee/", "platform": "", "project_url": "https://pypi.org/project/ibm2ieee/", "project_urls": {"Homepage": "https://github.com/enthought/ibm2ieee"}, "release_url": "https://pypi.org/project/ibm2ieee/1.0.2/", "requires_dist": null, "requires_python": "", "summary": "Convert IBM hexadecimal floating-point data to IEEE 754 floating-point data.", "version": "1.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>The <strong>ibm2ieee</strong> package provides NumPy universal functions (\u201cufuncs\u201d) for\nconverting IBM single-precision and double-precision hexadecimal floats\nto the IEEE 754-format floats used by Python and NumPy on almost all\ncurrent platforms.</p>\n<div id=\"features\">\n<h2>Features</h2>\n<ul>\n<li>Fast: 200-400 million values converted per second on a typical modern\nmachine, assuming normal inputs.</li>\n<li>Correct: converted results are correctly rounded, according to the default\nIEEE 754 round-ties-to-even rounding mode. Corner cases (overflow, underflow,\nsubnormal results, signed zeros, non-normalised input) are all handled\ncorrectly. Where the rounded converted value is out of range for the target\ntype, an appropriately-signed infinity is returned.</li>\n<li>Handles both single-precision and double-precision input and output formats.</li>\n</ul>\n<p>Portability note: the conversion functions provided in this module assume that\n<tt>numpy.float32</tt> and <tt>numpy.float64</tt> are based on the standard IEEE 754\nbinary32 and binary64 floating-point formats. This is true on the overwhelming\nmajority of current platforms, but is not guaranteed by the relevant language\nstandards.</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>The package provides two functions:</p>\n<ul>\n<li><tt>ibm2float32</tt> converts IBM single- or double-precision data to\nIEEE 754 single-precision values, in <tt>numpy.float32</tt> format.</li>\n<li><tt>ibm2float64</tt> converts IBM single- or double-precision data to\nIEEE 754 double-precision values, in <tt>numpy.float64</tt> format.</li>\n</ul>\n<p>For both functions, IBM single-precision input data must be represented\nusing the <tt>numpy.uint32</tt> dtype, while IBM double-precision inputs must\nbe represented using <tt>numpy.uint64</tt>.</p>\n<p>Both functions assume that the IBM data have been converted to NumPy integer\nformat in such a way that the most significant bits of the floating-point\nnumber become the most significant bits of the integer values. So when decoding\nbyte data representing IBM hexadecimal floating-point numbers, it\u2019s important\nto take the endianness of the byte data into account. See the Examples section\nbelow for an example of converting big-endian byte data.</p>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<pre>&gt;&gt;&gt; import numpy\n&gt;&gt;&gt; from ibm2ieee import ibm2float32, ibm2float64\n&gt;&gt;&gt; ibm2float32(numpy.uint32(0xc1180000))\n-1.5\n&gt;&gt;&gt; type(ibm2float32(numpy.uint32(0xc1180000)))\n&lt;class 'numpy.float32'&gt;\n&gt;&gt;&gt; ibm2float32(numpy.uint64(0x413243f6a8885a31))\n3.1415927\n&gt;&gt;&gt; ibm2float32(numpy.uint32(0x61100000))\ninf\n&gt;&gt;&gt; ibm2float64(numpy.uint32(0xc1180000))\n-1.5\n&gt;&gt;&gt; ibm2float64(numpy.uint64(0x413243f6a8885a31))\n3.141592653589793\n&gt;&gt;&gt; ibm2float64(numpy.uint32(0x61100000))\n3.402823669209385e+38\n&gt;&gt;&gt; input_array = numpy.arange(\n        0x40fffffe, 0x41000002, dtype=numpy.uint32).reshape(2, 2)\n&gt;&gt;&gt; input_array\narray([[1090519038, 1090519039],\n       [1090519040, 1090519041]], dtype=uint32)\n&gt;&gt;&gt; ibm2float64(input_array)\narray([[9.99999881e-01, 9.99999940e-01],\n       [0.00000000e+00, 9.53674316e-07]])\n</pre>\n<p>When converting byte data read from a file, it\u2019s important to know the\nendianness of that data (which is frequently big-endian in historical data\nfiles using IBM hex floating-point). Here\u2019s an example of converting IBM\nsingle-precision data stored in big-endian form to <tt>numpy.float32</tt>. Note the\nuse of the <tt>'&gt;u4'</tt> dtype when converting the bytestring to a NumPy <tt>uint32</tt>\narray. For little-endian input data, you would use <tt>'&lt;u4'</tt> instead.</p>\n<pre>&gt;&gt;&gt; input_data = b'\\xc12C\\xf7\\xc1\\x19!\\xfb\\x00\\x00\\x00\\x00A\\x19!\\xfbA2C\\xf7'\n&gt;&gt;&gt; input_as_uint32 = numpy.frombuffer(input_data, dtype='&gt;u4')\n&gt;&gt;&gt; input_as_uint32\narray([3241296887, 3239649787,          0, 1092166139, 1093813239],\n      dtype=uint32)\n&gt;&gt;&gt; ibm2float32(input_as_uint32)\narray([-3.141593, -1.570796,  0.      ,  1.570796,  3.141593],\n      dtype=float32)\n</pre>\n</div>\n<div id=\"notes-on-the-formats\">\n<h2>Notes on the formats</h2>\n<p>The IBM single-precision format has a precision of 6 hexadecimal digits, which\nin practice translates to a precision of 21-24 bits, depending on the binade\nthat the relevant value belongs to. IEEE 754 single-precision has a precision\nof 24 bits. So all not-too-small, not-too-large IBM single-precision values can\nbe translated to IEEE 754 single-precision values with no loss of precision.\nHowever, the IBM single precision range is larger than the corresponding IEEE\n754 range, so extreme IBM single-precision values may overflow to infinity,\nunderflow to zero, or be rounded to a subnormal value when converted to IEEE\n754 single-precision.</p>\n<p>For double-precision conversions, the tradeoff works the other way: the IBM\ndouble-precision format has an effective precision of 53-56 bits, while IEEE\n754 double-precision has 53-bit precision. So most IBM values will be rounded\nwhen converted to IEEE 754. However, the IEEE 754 double-precision range is\nlarger than that of IBM double-precision, so there\u2019s no danger of overflow,\nunderflow, or reduced-precision subnormal results when converting IBM\ndouble-precision to IEEE 754 double-precision.</p>\n<p>Every IBM single-precision value can be exactly represented in IEEE 754\ndouble-precision, so if you want a lossless representation of IBM\nsingle-precision data, use <tt>ibm2float64</tt>.</p>\n<p>Note that the IBM formats do not allow representations of special values like\ninfinities and NaNs. However, signed zeros are representable, and the sign of a\nzero is preserved under all conversions.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>The latest release of ibm2ieee is available from the Python Package Index, at\n<a href=\"https://pypi.org/project/ibm2ieee\" rel=\"nofollow\">https://pypi.org/project/ibm2ieee</a>. It can be installed with <tt>pip</tt> in the\nusual way:</p>\n<pre>pip install ibm2ieee\n</pre>\n<p>Note that it includes a C extension, so you\u2019ll need a compiler on your system\nto be able to install.</p>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>The ibm2ieee package is copyright (c) 2018, Enthought, Inc.</p>\n<p>The ibm2ieee package is licensed under a standard BSD 3-clause License. See the\nLICENSE file for details.</p>\n</div>\n\n          </div>"}, "last_serial": 6597965, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "bc92ba532ecc591430fb23eb9972ef57", "sha256": "74049b5f0c87291b73500a88b5196d2fe8e95687547eb09b4ad5fe53edd3379c"}, "downloads": -1, "filename": "ibm2ieee-0.1.0.tar.gz", "has_sig": false, "md5_digest": "bc92ba532ecc591430fb23eb9972ef57", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14547, "upload_time": "2018-12-04T11:43:46", "upload_time_iso_8601": "2018-12-04T11:43:46.680228Z", "url": "https://files.pythonhosted.org/packages/15/aa/078a5e510a137b2b0f6ba4126594bafc330bd83e9d8c8439128357a9c15d/ibm2ieee-0.1.0.tar.gz", "yanked": false}], "1.0.0": [{"comment_text": "", "digests": {"md5": "6d1312fb80d215b383227790f046fc02", "sha256": "4aedbe4f2045ff6b3295d2e0bef29004a61accfbac549a5e881126caedc8565c"}, "downloads": -1, "filename": "ibm2ieee-1.0.0.tar.gz", "has_sig": false, "md5_digest": "6d1312fb80d215b383227790f046fc02", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14901, "upload_time": "2018-12-04T14:57:53", "upload_time_iso_8601": "2018-12-04T14:57:53.115811Z", "url": "https://files.pythonhosted.org/packages/7e/31/47b6a79d64279919045a608bbceb8c3f9cf88584d31db823d6e0ab5f477d/ibm2ieee-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "8ea071a1b97b8f5c15e930e674ed3f6e", "sha256": "684e7755e246be6e2815b9d7545c57ec3ef16a90b4a4e4174fe436a89332e4b6"}, "downloads": -1, "filename": "ibm2ieee-1.0.1.tar.gz", "has_sig": false, "md5_digest": "8ea071a1b97b8f5c15e930e674ed3f6e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 12828, "upload_time": "2018-12-04T17:04:08", "upload_time_iso_8601": "2018-12-04T17:04:08.318555Z", "url": "https://files.pythonhosted.org/packages/74/4b/8c6f1fd77e298cccb2f035409d5861f548766195baa7eaf8d83614067dbe/ibm2ieee-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "0f986a537dba18a9392865c0dc7e5b51", "sha256": "af7c7b839d3cb88b79d859b57c23697cacb52896b44ba84dcbb970f5d027e9d4"}, "downloads": -1, "filename": "ibm2ieee-1.0.2.tar.gz", "has_sig": false, "md5_digest": "0f986a537dba18a9392865c0dc7e5b51", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16699, "upload_time": "2020-02-09T15:09:04", "upload_time_iso_8601": "2020-02-09T15:09:04.061436Z", "url": "https://files.pythonhosted.org/packages/e2/15/0546ac5c1c7b71d778ac27e70d84eec2289a06959a39b21334a821235f91/ibm2ieee-1.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0f986a537dba18a9392865c0dc7e5b51", "sha256": "af7c7b839d3cb88b79d859b57c23697cacb52896b44ba84dcbb970f5d027e9d4"}, "downloads": -1, "filename": "ibm2ieee-1.0.2.tar.gz", "has_sig": false, "md5_digest": "0f986a537dba18a9392865c0dc7e5b51", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16699, "upload_time": "2020-02-09T15:09:04", "upload_time_iso_8601": "2020-02-09T15:09:04.061436Z", "url": "https://files.pythonhosted.org/packages/e2/15/0546ac5c1c7b71d778ac27e70d84eec2289a06959a39b21334a821235f91/ibm2ieee-1.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:49:14 2020"}