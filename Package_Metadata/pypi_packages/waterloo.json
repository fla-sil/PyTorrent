{"info": {"author": "Anentropic", "author_email": "ego@anentropic.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Topic :: Text Processing"], "description": "# Waterloo\n\n![Waterloo](https://user-images.githubusercontent.com/147840/74556780-b1621b80-4f56-11ea-9b4a-6d34da996cd8.jpg)\n\n[![Build Status](https://travis-ci.org/anentropic/python-waterloo.svg?branch=master)](https://travis-ci.org/anentropic/python-waterloo)\n[![Latest PyPI version](https://badge.fury.io/py/waterloo.svg)](https://pypi.python.org/pypi/waterloo/)\n\n![Python 3.7](https://img.shields.io/badge/Python%203.7--brightgreen.svg)\n![Python 3.8](https://img.shields.io/badge/Python%203.8--brightgreen.svg)  \n_(...but primarily for running on Python 2.7 code)_\n\nA cli tool to convert type annotations found in 'Google-style' docstrings (as understood and documented by the [Sphinx Napoleon](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/) plugin) into PEP-484 type comments which can be checked statically using `mypy --py2`.\n\nFor an example of the format see https://github.com/anentropic/python-waterloo/blob/master/tests/fixtures/napoleon.py\n\n### Installation\n\nWaterloo itself requires Python 3.7 or later, but is primarily designed for projects having Python 2.7 source files.  \n_(It can be run on Python 3 source files too, but since we add type-comments you will want to run the [comm2ann](https://github.com/ilevkivskyi/com2ann) tool afterwards to migrate those to Py3 annotations)._\n\nFor this reason it is best installed using [pipx](https://github.com/pipxproject/pipx):\n\n```\n$ pipx install waterloo\n  installed package waterloo 0.5.0, Python 3.7.6\n  These apps are now globally available\n    - waterloo\ndone! \u2728 \ud83c\udf1f \u2728\n```\n\n(NOTE: we currently have to install from GitHub due to using a forked version Bowler, PyPI installation will be available once our changes are upstreamed)\n\n### Basic Usage\n\nAfter we parse the docstrings and prepare the type comments (and imports of mentioned types), the resulting modifications to the files are performed by [Bowler](https://pybowler.io/). This tool provides a few nice features such as an optional interactive \"diff\" interface (or just preview diffs without writing changes yet as a \"dry run\").\n\nIn short you can...\n```\nwaterloo annotate my-project-dir/ --write\n```\n...and it will derive type comments from all of your typed docstrings and add them to the files.\n\nTo preview the changes without committing them:\n```\nwaterloo annotate my-project-dir/ --show-diff\n```\n\n### CLI options\n\n```\nusage: waterloo annotate [-h] [-p PYTHON_VERSION] [-aa] [-rr]\n                         [-ic {IMPORT,NO_IMPORT,FAIL}] [-up {IGNORE,WARN,FAIL}]\n                         [-w] [-s] [-i]\n                         F [F ...]\n\npositional arguments:\n  F                     List of file or directory paths to process.\n```\n\n**Annotation options:**\n\n| arg  | description |\n| ---- | ----------- |\n| `-p --python-version` | We can refactor either Python 2 or Python 3 source files but the underlying bowler+fissix libraries need to know which grammar to use (to know if `print` is a statement or a function). In Py2 mode, `print` will be auto-detected based on whether a `from __future__ import print_function` is found. For Py3 files `print` can only be a function. We also use `parso` library which can benefit from knowing `<major>.<minor>` version of your sources. (default: `2.7`) |\n| `-aa, --allow-untyped-args` | If any args or return types are found in docstring we can attempt to output a type annotation. If arg types are missing or incomplete, default behaviour is to raise an error. If this flag is set we will instead output an annotation like `(...) -> returnT` which mypy will treat as if all args are `Any`. (default: `False`) |\n| `-rr, --require-return-type` | If any args or return types are found in docstring we can attempt to output a type annotation. If the return type is missing our default behaviour is to assume function should be annotated as returning `-> None`. If this flag is set we will instead raise an error. (default: `False`) |\n| `-ic --import-collision-policy {IMPORT,NO_IMPORT,FAIL}` | There are some cases where it is ambiguous whether we need to add an import for your documented type. This can occur if you gave a dotted package path but there is already a matching `from package import *`, or a relative import of same type name. In both cases it is safest for us to add a new specific import for your type, but it may be redundant. The default option `IMPORT` will add imports. The `NO_IMPORT` option will annotate without adding imports, and will also show a warning message. FAIL will print an error and won't add any annotation. (default: `IMPORT`) |\n| `-up --unpathed-type-policy {IGNORE,WARN,FAIL}` | There are some cases where we cannot determine an appropriate import to add - when your types do not have a dotted path and we can't find a matching type in builtins, typing package or locals. When policy is `IGNORE` we will annotate as documented, you will need to resolve any errors raised by mypy manually. `WARN`option will annotate as documented but also display a warning. `FAIL` will print an error and won't add any annotation. (default: `FAIL`) |\n\n**Apply options:**\n\n| arg  | description |\n| ---- | ----------- |\n| `-w, --write` | Whether to apply the changes to target files. Without this flag set waterloo will just perform a 'dry run'. (default: `False`) |\n| `-s, --show-diff` | Whether to print the hunk diffs to be applied. (default: `False`) |\n| `-i, --interactive` | Whether to prompt about applying each diff hunk. (default: `False`) |\n\n**waterloo.toml**\n\nYou can also define a `waterloo.toml` file in the root of your project to provide your own defaults to some of these options:\n\n```toml\npython_version = 3\n\nallow_untyped_args = false\nrequire_return_type = true\nunpathed_type_policy = \"IGNORE\"\nimport_collision_policy = \"FAIL\"\n```\n\n**Environment vars**\n\nYou can also provide config defaults via environment variables, e.g.:\n```bash\nWATERLOO_PYTHON_VERSION=3\n\nWATERLOO_ALLOW_UNTYPED_ARGS=false\nWATERLOO_REQUIRE_RETURN_TYPE=true\nUNPATHED_TYPE_POLICY='IGNORE'\nIMPORT_COLLISION_POLICY='FAIL'\n```\n\n### Notes on 'Napoleon' docstring format\n\nThe format is defined here https://sphinxcontrib-napoleon.readthedocs.io/en/latest/\n\nFor now we only support the \"Google-style\" option. Open an issue if you need the alternative \"Numpy-style\" format.\n\nIn addition to the [official list](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/#docstring-sections) of Section headings we also allow `Kwargs:` (since I'd used that one myself in many places).\n\nIf you run waterloo with `--show-diff` option you will notice that we automatically add imports for the annotated types:\n\n```diff\n--- tests/fixtures/napoleon.py\n+++ tests/fixtures/napoleon.py\n@@ -2,6 +2,8 @@\n Boring docstring for the module itself\n \"\"\"\n import logging\n+from engine.models import Product\n+from typing import Any, Callable, Dict, Iterable, List, Optional, Union\n\n logger = logging.getLogger(__name__)\n```\n\nBuilt-in types and those from `typing` module are recognised. For other types we can still generate the import as long as you use dotted-path syntax in the docstring, for example:\n\n```python\n\"\"\"\n    Args:\n        products (Union[Iterable[Dict], Iterable[engine.models.Product]])\n        getter (Callable[[str], Callable])\n\"\"\"\n```\n\nIn this docstring, waterloo is able to add the `from engine.models import Product` import.\n\nIf your docstrings don't have dotted paths you will see warnings like:\n```\n\u26a0\ufe0f  Could not determine imports for these types: MysteryType\n   (will assume types already imported or defined in file)\n```\n\nWaterloo will still add the annotation to the function, but when you try to run mypy on this file it will complain that `MysteryType` is not imported (if `MysteryType` is not already imported or defined in the file). You will then have to resolve that manually.\n\nYou may want to run a formatter such as [isort](https://github.com/timothycrosley/isort) on your code after applying annotations with waterloo, since it will just append the imports to the bottom of your existing import block.\n\n### Upgrading your project to Python 3\n\nAdding type comments with `waterloo` can be an intermediate step. You can start type checking with `mypy` while you're still on Python 2.7.\n\nLater when you're ready to upgrade you can then run this other tool https://github.com/ilevkivskyi/com2ann\nand it will convert the py2 type-comments into proper py3 type annotations.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/anentropic/python-waterloo", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "waterloo", "package_url": "https://pypi.org/project/waterloo/", "platform": "", "project_url": "https://pypi.org/project/waterloo/", "project_urls": {"Homepage": "https://github.com/anentropic/python-waterloo"}, "release_url": "https://pypi.org/project/waterloo/0.5.0/", "requires_dist": null, "requires_python": "~=3.7", "summary": "Tool to convert 'typed docstrings' (i.e. 'Google-style', Sphinx 'Napoleon' format) to PEP-484 Py2 type comments.", "version": "0.5.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Waterloo</h1>\n<p><img alt=\"Waterloo\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/481783522da39636c24a4b39eb4ad7ddb412a4a8/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f3134373834302f37343535363738302d62313632316238302d346635362d313165612d396234612d3664333464613939366364382e6a7067\"></p>\n<p><a href=\"https://travis-ci.org/anentropic/python-waterloo\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5e9218288369aaa7bbc2fa1c9760afb3f4d08366/68747470733a2f2f7472617669732d63692e6f72672f616e656e74726f7069632f707974686f6e2d77617465726c6f6f2e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://pypi.python.org/pypi/waterloo/\" rel=\"nofollow\"><img alt=\"Latest PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d888b13c5bbd35f214c2064c5ae2ea7a000105ea/68747470733a2f2f62616467652e667572792e696f2f70792f77617465726c6f6f2e737667\"></a></p>\n<p><img alt=\"Python 3.7\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2f588af29177efc1e9cbf24a8fb8d954cb2b53e9/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f507974686f6e253230332e372d2d627269676874677265656e2e737667\">\n<img alt=\"Python 3.8\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/adbddcb1472156fafc06c8935e82d2d0ad8dc27d/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f507974686f6e253230332e382d2d627269676874677265656e2e737667\"><br>\n<em>(...but primarily for running on Python 2.7 code)</em></p>\n<p>A cli tool to convert type annotations found in 'Google-style' docstrings (as understood and documented by the <a href=\"https://sphinxcontrib-napoleon.readthedocs.io/en/latest/\" rel=\"nofollow\">Sphinx Napoleon</a> plugin) into PEP-484 type comments which can be checked statically using <code>mypy --py2</code>.</p>\n<p>For an example of the format see <a href=\"https://github.com/anentropic/python-waterloo/blob/master/tests/fixtures/napoleon.py\" rel=\"nofollow\">https://github.com/anentropic/python-waterloo/blob/master/tests/fixtures/napoleon.py</a></p>\n<h3>Installation</h3>\n<p>Waterloo itself requires Python 3.7 or later, but is primarily designed for projects having Python 2.7 source files.<br>\n<em>(It can be run on Python 3 source files too, but since we add type-comments you will want to run the <a href=\"https://github.com/ilevkivskyi/com2ann\" rel=\"nofollow\">comm2ann</a> tool afterwards to migrate those to Py3 annotations).</em></p>\n<p>For this reason it is best installed using <a href=\"https://github.com/pipxproject/pipx\" rel=\"nofollow\">pipx</a>:</p>\n<pre><code>$ pipx install waterloo\n  installed package waterloo 0.5.0, Python 3.7.6\n  These apps are now globally available\n    - waterloo\ndone! \u2728 \ud83c\udf1f \u2728\n</code></pre>\n<p>(NOTE: we currently have to install from GitHub due to using a forked version Bowler, PyPI installation will be available once our changes are upstreamed)</p>\n<h3>Basic Usage</h3>\n<p>After we parse the docstrings and prepare the type comments (and imports of mentioned types), the resulting modifications to the files are performed by <a href=\"https://pybowler.io/\" rel=\"nofollow\">Bowler</a>. This tool provides a few nice features such as an optional interactive \"diff\" interface (or just preview diffs without writing changes yet as a \"dry run\").</p>\n<p>In short you can...</p>\n<pre><code>waterloo annotate my-project-dir/ --write\n</code></pre>\n<p>...and it will derive type comments from all of your typed docstrings and add them to the files.</p>\n<p>To preview the changes without committing them:</p>\n<pre><code>waterloo annotate my-project-dir/ --show-diff\n</code></pre>\n<h3>CLI options</h3>\n<pre><code>usage: waterloo annotate [-h] [-p PYTHON_VERSION] [-aa] [-rr]\n                         [-ic {IMPORT,NO_IMPORT,FAIL}] [-up {IGNORE,WARN,FAIL}]\n                         [-w] [-s] [-i]\n                         F [F ...]\n\npositional arguments:\n  F                     List of file or directory paths to process.\n</code></pre>\n<p><strong>Annotation options:</strong></p>\n<table>\n<thead>\n<tr>\n<th>arg</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-p --python-version</code></td>\n<td>We can refactor either Python 2 or Python 3 source files but the underlying bowler+fissix libraries need to know which grammar to use (to know if <code>print</code> is a statement or a function). In Py2 mode, <code>print</code> will be auto-detected based on whether a <code>from __future__ import print_function</code> is found. For Py3 files <code>print</code> can only be a function. We also use <code>parso</code> library which can benefit from knowing <code>&lt;major&gt;.&lt;minor&gt;</code> version of your sources. (default: <code>2.7</code>)</td>\n</tr>\n<tr>\n<td><code>-aa, --allow-untyped-args</code></td>\n<td>If any args or return types are found in docstring we can attempt to output a type annotation. If arg types are missing or incomplete, default behaviour is to raise an error. If this flag is set we will instead output an annotation like <code>(...) -&gt; returnT</code> which mypy will treat as if all args are <code>Any</code>. (default: <code>False</code>)</td>\n</tr>\n<tr>\n<td><code>-rr, --require-return-type</code></td>\n<td>If any args or return types are found in docstring we can attempt to output a type annotation. If the return type is missing our default behaviour is to assume function should be annotated as returning <code>-&gt; None</code>. If this flag is set we will instead raise an error. (default: <code>False</code>)</td>\n</tr>\n<tr>\n<td><code>-ic --import-collision-policy {IMPORT,NO_IMPORT,FAIL}</code></td>\n<td>There are some cases where it is ambiguous whether we need to add an import for your documented type. This can occur if you gave a dotted package path but there is already a matching <code>from package import *</code>, or a relative import of same type name. In both cases it is safest for us to add a new specific import for your type, but it may be redundant. The default option <code>IMPORT</code> will add imports. The <code>NO_IMPORT</code> option will annotate without adding imports, and will also show a warning message. FAIL will print an error and won't add any annotation. (default: <code>IMPORT</code>)</td>\n</tr>\n<tr>\n<td><code>-up --unpathed-type-policy {IGNORE,WARN,FAIL}</code></td>\n<td>There are some cases where we cannot determine an appropriate import to add - when your types do not have a dotted path and we can't find a matching type in builtins, typing package or locals. When policy is <code>IGNORE</code> we will annotate as documented, you will need to resolve any errors raised by mypy manually. <code>WARN</code>option will annotate as documented but also display a warning. <code>FAIL</code> will print an error and won't add any annotation. (default: <code>FAIL</code>)</td>\n</tr></tbody></table>\n<p><strong>Apply options:</strong></p>\n<table>\n<thead>\n<tr>\n<th>arg</th>\n<th>description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>-w, --write</code></td>\n<td>Whether to apply the changes to target files. Without this flag set waterloo will just perform a 'dry run'. (default: <code>False</code>)</td>\n</tr>\n<tr>\n<td><code>-s, --show-diff</code></td>\n<td>Whether to print the hunk diffs to be applied. (default: <code>False</code>)</td>\n</tr>\n<tr>\n<td><code>-i, --interactive</code></td>\n<td>Whether to prompt about applying each diff hunk. (default: <code>False</code>)</td>\n</tr></tbody></table>\n<p><strong>waterloo.toml</strong></p>\n<p>You can also define a <code>waterloo.toml</code> file in the root of your project to provide your own defaults to some of these options:</p>\n<pre><span class=\"n\">python_version</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n\n<span class=\"n\">allow_untyped_args</span> <span class=\"o\">=</span> <span class=\"kc\">false</span>\n<span class=\"n\">require_return_type</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>\n<span class=\"n\">unpathed_type_policy</span> <span class=\"o\">=</span> <span class=\"s\">\"IGNORE\"</span>\n<span class=\"n\">import_collision_policy</span> <span class=\"o\">=</span> <span class=\"s\">\"FAIL\"</span>\n</pre>\n<p><strong>Environment vars</strong></p>\n<p>You can also provide config defaults via environment variables, e.g.:</p>\n<pre><span class=\"nv\">WATERLOO_PYTHON_VERSION</span><span class=\"o\">=</span><span class=\"m\">3</span>\n\n<span class=\"nv\">WATERLOO_ALLOW_UNTYPED_ARGS</span><span class=\"o\">=</span><span class=\"nb\">false</span>\n<span class=\"nv\">WATERLOO_REQUIRE_RETURN_TYPE</span><span class=\"o\">=</span><span class=\"nb\">true</span>\n<span class=\"nv\">UNPATHED_TYPE_POLICY</span><span class=\"o\">=</span><span class=\"s1\">'IGNORE'</span>\n<span class=\"nv\">IMPORT_COLLISION_POLICY</span><span class=\"o\">=</span><span class=\"s1\">'FAIL'</span>\n</pre>\n<h3>Notes on 'Napoleon' docstring format</h3>\n<p>The format is defined here <a href=\"https://sphinxcontrib-napoleon.readthedocs.io/en/latest/\" rel=\"nofollow\">https://sphinxcontrib-napoleon.readthedocs.io/en/latest/</a></p>\n<p>For now we only support the \"Google-style\" option. Open an issue if you need the alternative \"Numpy-style\" format.</p>\n<p>In addition to the <a href=\"https://sphinxcontrib-napoleon.readthedocs.io/en/latest/#docstring-sections\" rel=\"nofollow\">official list</a> of Section headings we also allow <code>Kwargs:</code> (since I'd used that one myself in many places).</p>\n<p>If you run waterloo with <code>--show-diff</code> option you will notice that we automatically add imports for the annotated types:</p>\n<pre><span class=\"gd\">--- tests/fixtures/napoleon.py</span>\n<span class=\"gi\">+++ tests/fixtures/napoleon.py</span>\n<span class=\"gu\">@@ -2,6 +2,8 @@</span>\n Boring docstring for the module itself\n \"\"\"\n import logging\n<span class=\"gi\">+from engine.models import Product</span>\n<span class=\"gi\">+from typing import Any, Callable, Dict, Iterable, List, Optional, Union</span>\n\n logger = logging.getLogger(__name__)\n</pre>\n<p>Built-in types and those from <code>typing</code> module are recognised. For other types we can still generate the import as long as you use dotted-path syntax in the docstring, for example:</p>\n<pre><span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        products (Union[Iterable[Dict], Iterable[engine.models.Product]])</span>\n<span class=\"sd\">        getter (Callable[[str], Callable])</span>\n<span class=\"sd\">\"\"\"</span>\n</pre>\n<p>In this docstring, waterloo is able to add the <code>from engine.models import Product</code> import.</p>\n<p>If your docstrings don't have dotted paths you will see warnings like:</p>\n<pre><code>\u26a0\ufe0f  Could not determine imports for these types: MysteryType\n   (will assume types already imported or defined in file)\n</code></pre>\n<p>Waterloo will still add the annotation to the function, but when you try to run mypy on this file it will complain that <code>MysteryType</code> is not imported (if <code>MysteryType</code> is not already imported or defined in the file). You will then have to resolve that manually.</p>\n<p>You may want to run a formatter such as <a href=\"https://github.com/timothycrosley/isort\" rel=\"nofollow\">isort</a> on your code after applying annotations with waterloo, since it will just append the imports to the bottom of your existing import block.</p>\n<h3>Upgrading your project to Python 3</h3>\n<p>Adding type comments with <code>waterloo</code> can be an intermediate step. You can start type checking with <code>mypy</code> while you're still on Python 2.7.</p>\n<p>Later when you're ready to upgrade you can then run this other tool <a href=\"https://github.com/ilevkivskyi/com2ann\" rel=\"nofollow\">https://github.com/ilevkivskyi/com2ann</a>\nand it will convert the py2 type-comments into proper py3 type annotations.</p>\n\n          </div>"}, "last_serial": 6903225, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "1bd5a8a3107c2bb25406d7ff7991f484", "sha256": "0585cc2f73fa9dd2b26ab74ae91e5e6d86d1b35d8f3f39de437b24320554e63b"}, "downloads": -1, "filename": "waterloo-0.1.0.tar.gz", "has_sig": false, "md5_digest": "1bd5a8a3107c2bb25406d7ff7991f484", "packagetype": "sdist", "python_version": "source", "requires_python": "~=3.7", "size": 16361, "upload_time": "2020-02-24T20:36:40", "upload_time_iso_8601": "2020-02-24T20:36:40.271544Z", "url": "https://files.pythonhosted.org/packages/96/0b/7ee6e0593be37597265a8b2beaf932b4bcdeb49744f28b3bf47c69f3f0b7/waterloo-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "205f0f8251407d3ac62c62f083a0dc4f", "sha256": "b9267336f9f56315985b6edda06ecbf90bddb5545a5b10078baa0417990fff4b"}, "downloads": -1, "filename": "waterloo-0.1.1.tar.gz", "has_sig": false, "md5_digest": "205f0f8251407d3ac62c62f083a0dc4f", "packagetype": "sdist", "python_version": "source", "requires_python": "~=3.7", "size": 18079, "upload_time": "2020-02-25T08:09:14", "upload_time_iso_8601": "2020-02-25T08:09:14.224589Z", "url": "https://files.pythonhosted.org/packages/2a/f1/3b315a7ad2fce5dd943acbcb48e4627e0c361ebf23c5a07ee49c2d3963b4/waterloo-0.1.1.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "45bf05c6c0c24875d5f9cf6463353b81", "sha256": "1ecdf50f7bc5e2cc14172dd6310fd4c768120394aa4932375b06517d0841d1a6"}, "downloads": -1, "filename": "waterloo-0.2.0.tar.gz", "has_sig": false, "md5_digest": "45bf05c6c0c24875d5f9cf6463353b81", "packagetype": "sdist", "python_version": "source", "requires_python": "~=3.7", "size": 25480, "upload_time": "2020-03-18T10:44:08", "upload_time_iso_8601": "2020-03-18T10:44:08.580421Z", "url": "https://files.pythonhosted.org/packages/c2/90/378b05b60098a38ed0aed8de30ba5832084c6cfd26700bed80ee421c0283/waterloo-0.2.0.tar.gz", "yanked": false}], "0.3.0": [{"comment_text": "", "digests": {"md5": "2337100adb3a7a4c3da93f8e31ec3e4f", "sha256": "6b39ff697786397086860d827ebc59b322e7f0e26a2736b3944225c6ae1036bd"}, "downloads": -1, "filename": "waterloo-0.3.0.tar.gz", "has_sig": false, "md5_digest": "2337100adb3a7a4c3da93f8e31ec3e4f", "packagetype": "sdist", "python_version": "source", "requires_python": "~=3.7", "size": 25482, "upload_time": "2020-03-18T11:42:17", "upload_time_iso_8601": "2020-03-18T11:42:17.984362Z", "url": "https://files.pythonhosted.org/packages/90/12/27fa9a0a1af9f20c8d5450268ea62df904b7a72f850c5dbedceef103cc16/waterloo-0.3.0.tar.gz", "yanked": false}], "0.4.0": [{"comment_text": "", "digests": {"md5": "fc1e56419317559b2a0fe4e6aec53579", "sha256": "f8d417c1a738b338d42964377ce578d4668d23f899cb72b75c049dc6d99dd05f"}, "downloads": -1, "filename": "waterloo-0.4.0.tar.gz", "has_sig": false, "md5_digest": "fc1e56419317559b2a0fe4e6aec53579", "packagetype": "sdist", "python_version": "source", "requires_python": "~=3.7", "size": 25682, "upload_time": "2020-03-18T12:29:26", "upload_time_iso_8601": "2020-03-18T12:29:26.457262Z", "url": "https://files.pythonhosted.org/packages/64/16/ae5533da6966545e55e9939f8c312eead2e59cdd3c5d9b3c8ea3f51432d3/waterloo-0.4.0.tar.gz", "yanked": false}], "0.5.0": [{"comment_text": "", "digests": {"md5": "990c43fa672413367a26ff9bfda5af96", "sha256": "37cb8338659138390bfe84f6806a0922717e2d5deda94c81407fffcff05e5d5b"}, "downloads": -1, "filename": "waterloo-0.5.0.tar.gz", "has_sig": false, "md5_digest": "990c43fa672413367a26ff9bfda5af96", "packagetype": "sdist", "python_version": "source", "requires_python": "~=3.7", "size": 43488, "upload_time": "2020-03-28T19:36:24", "upload_time_iso_8601": "2020-03-28T19:36:24.502880Z", "url": "https://files.pythonhosted.org/packages/35/37/1b1ce5660cce95f004e02fcbc0c1ea05c9e2b4f24552a7aab49ba7f0c090/waterloo-0.5.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "990c43fa672413367a26ff9bfda5af96", "sha256": "37cb8338659138390bfe84f6806a0922717e2d5deda94c81407fffcff05e5d5b"}, "downloads": -1, "filename": "waterloo-0.5.0.tar.gz", "has_sig": false, "md5_digest": "990c43fa672413367a26ff9bfda5af96", "packagetype": "sdist", "python_version": "source", "requires_python": "~=3.7", "size": 43488, "upload_time": "2020-03-28T19:36:24", "upload_time_iso_8601": "2020-03-28T19:36:24.502880Z", "url": "https://files.pythonhosted.org/packages/35/37/1b1ce5660cce95f004e02fcbc0c1ea05c9e2b4f24552a7aab49ba7f0c090/waterloo-0.5.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:32:07 2020"}