{"info": {"author": "Marian Kleineberg", "author_email": "mail@marian42.de", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# Calculate signed distance fields for arbitrary meshes\n\nThis project calculates approximate SDFs for triangle meshes.\nIt works for **non-watertight** meshes (meshes with holes), **self-intersecting** meshes, meshes with **non-manifold geometry** and meshes with **inconsistently oriented faces**.\n\n## Install\n\n```\npip3 install mesh-to-sdf\n```\n\n## Examples\n\n### Voxelize a mesh\n\nThe `mesh_to_voxels` function creates an N \u2715 N \u2715 N array of SDF values.\nIn this example, a mesh reconstructed using Marching Cubes and then rendered.\n\n```python\nfrom mesh_to_sdf import mesh_to_voxels\n\nimport trimesh\nimport skimage\n\nmesh = trimesh.load('chair.obj')\n\nvoxels = mesh_to_voxels(mesh, 64, pad=True)\n\nvertices, faces, normals, _ = skimage.measure.marching_cubes_lewiner(voxels, level=0)\nmesh = trimesh.Trimesh(vertices=vertices, faces=faces, vertex_normals=normals)\nmesh.show()\n```\n![Example of a mesh and a reconstructed SDF voxel volume](https://raw.githubusercontent.com/marian42/mesh_to_sdf/master/example/voxel.png)\n\n### Sample SDF points non-uniformly near the surface\n\nThis example creates 250,000 points, where most of the points are close to the surface and some are sampled uniformly.\nThis is the method that is proposed and used in the [DeepSDF paper](https://arxiv.org/abs/1901.05103).\nIn this example, the resulting points are rendered in red where the SDF is positive and in blue where it is negative.\n\n```python\nfrom mesh_to_sdf import sample_sdf_near_surface\n\nimport trimesh\nimport pyrender\nimport numpy as np\n\nmesh = trimesh.load('chair.obj')\n\npoints, sdf = sample_sdf_near_surface(mesh, number_of_points=250000)\n\ncolors = np.zeros(points.shape)\ncolors[sdf < 0, 2] = 1\ncolors[sdf > 0, 0] = 1\ncloud = pyrender.Mesh.from_points(points, colors=colors)\nscene = pyrender.Scene()\nscene.add(cloud)\nviewer = pyrender.Viewer(scene, use_raymond_lighting=True, point_size=2)\n```\n\n![Example of a mesh and a point cloud of non-uniformly sampled SDF points](https://raw.githubusercontent.com/marian42/mesh_to_sdf/master/example/non-uniform.png)\n\n## How it works\n\nThe general pipeline for calculating SDF in this project is as follows:\n\n1. Create 100 virtual laser scans of the shape from multiple angles.\nThese each consist of a normal buffer and a depth buffer.\n2. Use the inverse MVP matrix and depth buffer of each scan to calculate a world-space surface point cloud\n3. Determine the value of the SDF for each query point by finding the closest surface point using a kd-tree\n4. Determine the sign of the SDF using either the normal of the closest surface point or by checking it against the depth buffers of the scans.\nWhen using normals, the sign is determined with a dot product.\nWhen using the depth buffer method, the point is projected in the frame of each render.\nBy comparing the depth element of the depth buffer and depth of the query point, we determine if the query point is seen by the camera.\nThe sign of the point is positive if it is seen by any of the cameras.\n\nThis repository contains an implementation of the procedure proposed in the [DeepSDF paper](), as well as some alternatives.\n\n# Documentation\n\n## mesh_to_sdf\n\nCalculate signed distance values for an array of given query points\n\n```python\nmesh_to_sdf.mesh_to_sdf(mesh, query_points, surface_point_method='scan', sign_method='normal', bounding_radius=None, scan_count=100, scan_resolution=400, sample_point_count=10000000, normal_sample_count=11)\n```\n\nParameters\n- `mesh`: a [trimesh](https://trimsh.org/trimesh.html) mesh\n- `query_points`: an N \u2715 3 numpy array, containing the points for which the signed distance function should be calculated.\n- See *common parameters* for the remaining parameters\n\nReturns\n- a numpy array with N elemenents, containing the SDF for each query point\n\n## mesh_to_voxels\n\nCalculate an N \u2715 N \u2715 N voxel volume of signed distance values for a given mesh.\nThe mesh is first transformed to fit inside a cube ranging from -1 to 1.\n\n```python\nmesh_to_sdf.mesh_to_voxels(mesh, voxel_resolution=64, surface_point_method='scan', sign_method='normal', scan_count=100, scan_resolution=400, sample_point_count=10000000, normal_sample_count=11, pad=False, check_result=False)\n```\n\nParameters\n- `mesh`: a [trimesh](https://trimsh.org/trimesh.html) mesh\n- `voxel_resolution`: the resolution N of the resulting voxel volume\n- `pad`: if `True`, the resulting array is padded with ones, ensuring a mesh without holes when reconstructing with Marching Cubes\n- `check_result`: if `True`, the result is checked for continuity.\nIf the voxel volume is not a plausible signed distance field, an exception is thrown.\n- See *common parameters* for the remaining parameters\n\nReturns\n- a numpy array of shape N \u2715 N \u2715 N (or N + 2 \u2715 N + 2 \u2715 N + 2 when using padding)\n\n## sample_sdf_near_surface\n\nSample some points uniformly and some points near the shape surface and calculate SDFs for these points.\nThis follows the procedure proposed in the [DeepSDF paper](https://arxiv.org/abs/1901.05103).\nThe mesh is first transformed to fit inside the unit sphere.\n\n```python\nmesh_to_sdf.sample_sdf_near_surface(mesh, number_of_points = 500000, surface_point_method='scan', sign_method='normal', scan_count=100, scan_resolution=400, sample_point_count=10000000, normal_sample_count=11, min_size=0)\n```\n\nParameters\n- `mesh`: a [trimesh](https://trimsh.org/trimesh.html) mesh\n- `number_of_points`: the number N of points to be sampled, including surface points and uniform points\n- `min_size`: The fraction of uniformly sampled that should be inside the shape.\nIf this is 0.015 and less than 1.5% of uniformly sampled points have negative SDFs, an exception is thrown.\nThis can be used to detect bad meshes.\n- See *common parameters* for the remaining parameters\n\nReturns\n- `points`: an N \u2715 3 numpy array containing the sample points\n- `sdf`: a numpy array of size N with the corresponding SDF values\n\n## get_surface_point_cloud\n\nReturns an intermediate data structure containing a surface point cloud, scans and a kd-tree of the point cloud.\nThis can be used if SDFs will be calculated multiple times for the same mesh or for debugging.\n\n```python\nmesh_to_sdf.get_surface_point_cloud(mesh, surface_point_method='scan', bounding_radius=1, scan_count=100, scan_resolution=400, sample_point_count=10000000, calculate_normals=True)\n```\n\nParameters\n- `mesh`: a [trimesh](https://trimsh.org/trimesh.html) mesh\n- See *common parameters* for the remaining parameters\n\nReturns\n- an instance of `SurfacePointCloud`\n\n## Common parameters\n- `surface_point_method`:\nThe method to generate a surface point cloud.\nEither `'scan'` or `'sample'`.\nThe scanning method creates virtual scans while the sampling method uses the triangles to sample surface points.\nThe sampling method only works with watertight meshes with correct face normals, but avoids some of the artifacts that the scanning method creates.\n\n- `sign_method`:\nThe method to determine the signs of the SDF values.\nEither `'normal'` or `'depth'`.\nThe normal method uses normals of the point cloud.\nIt works better for meshes with holes, but sometimes results in \"bubble\" artifacts.\nThe depth method avoids the bubble artifacts but is less accurate.\n\n- `bounding_radius`:\nThe radius of a sphere that contains all mesh vertices.\nIf `None`, this value is calculated using the mesh.\n\n- `scan_count`:\nNumber of scans when using the scanning method\n\n- `scan_resolution`:\nResolution for the scans in pixels.\n\n- `sample_point_count`:\nNumber of points to sample when using `surface_point_method='sample'`\n\n- `normal_sample_count`:\nNumber of nearby surface points to check when using `sign_method='normal'`.\nThe sign of the resulting SDF is determined by majority vote.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/marian42/mesh_to_sdf", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "mesh-to-sdf", "package_url": "https://pypi.org/project/mesh-to-sdf/", "platform": "", "project_url": "https://pypi.org/project/mesh-to-sdf/", "project_urls": {"Homepage": "https://github.com/marian42/mesh_to_sdf"}, "release_url": "https://pypi.org/project/mesh-to-sdf/0.0.10/", "requires_dist": null, "requires_python": ">=3.5", "summary": "Calculate signed distance fields for arbitrary meshes", "version": "0.0.10", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Calculate signed distance fields for arbitrary meshes</h1>\n<p>This project calculates approximate SDFs for triangle meshes.\nIt works for <strong>non-watertight</strong> meshes (meshes with holes), <strong>self-intersecting</strong> meshes, meshes with <strong>non-manifold geometry</strong> and meshes with <strong>inconsistently oriented faces</strong>.</p>\n<h2>Install</h2>\n<pre><code>pip3 install mesh-to-sdf\n</code></pre>\n<h2>Examples</h2>\n<h3>Voxelize a mesh</h3>\n<p>The <code>mesh_to_voxels</code> function creates an N \u2715 N \u2715 N array of SDF values.\nIn this example, a mesh reconstructed using Marching Cubes and then rendered.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">mesh_to_sdf</span> <span class=\"kn\">import</span> <span class=\"n\">mesh_to_voxels</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">trimesh</span>\n<span class=\"kn\">import</span> <span class=\"nn\">skimage</span>\n\n<span class=\"n\">mesh</span> <span class=\"o\">=</span> <span class=\"n\">trimesh</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'chair.obj'</span><span class=\"p\">)</span>\n\n<span class=\"n\">voxels</span> <span class=\"o\">=</span> <span class=\"n\">mesh_to_voxels</span><span class=\"p\">(</span><span class=\"n\">mesh</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">pad</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"n\">vertices</span><span class=\"p\">,</span> <span class=\"n\">faces</span><span class=\"p\">,</span> <span class=\"n\">normals</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">skimage</span><span class=\"o\">.</span><span class=\"n\">measure</span><span class=\"o\">.</span><span class=\"n\">marching_cubes_lewiner</span><span class=\"p\">(</span><span class=\"n\">voxels</span><span class=\"p\">,</span> <span class=\"n\">level</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">mesh</span> <span class=\"o\">=</span> <span class=\"n\">trimesh</span><span class=\"o\">.</span><span class=\"n\">Trimesh</span><span class=\"p\">(</span><span class=\"n\">vertices</span><span class=\"o\">=</span><span class=\"n\">vertices</span><span class=\"p\">,</span> <span class=\"n\">faces</span><span class=\"o\">=</span><span class=\"n\">faces</span><span class=\"p\">,</span> <span class=\"n\">vertex_normals</span><span class=\"o\">=</span><span class=\"n\">normals</span><span class=\"p\">)</span>\n<span class=\"n\">mesh</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p><img alt=\"Example of a mesh and a reconstructed SDF voxel volume\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c4312cd76c924ccd5e81732f600d76ccbe79f472/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6d617269616e34322f6d6573685f746f5f7364662f6d61737465722f6578616d706c652f766f78656c2e706e67\"></p>\n<h3>Sample SDF points non-uniformly near the surface</h3>\n<p>This example creates 250,000 points, where most of the points are close to the surface and some are sampled uniformly.\nThis is the method that is proposed and used in the <a href=\"https://arxiv.org/abs/1901.05103\" rel=\"nofollow\">DeepSDF paper</a>.\nIn this example, the resulting points are rendered in red where the SDF is positive and in blue where it is negative.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">mesh_to_sdf</span> <span class=\"kn\">import</span> <span class=\"n\">sample_sdf_near_surface</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">trimesh</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pyrender</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"n\">mesh</span> <span class=\"o\">=</span> <span class=\"n\">trimesh</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"s1\">'chair.obj'</span><span class=\"p\">)</span>\n\n<span class=\"n\">points</span><span class=\"p\">,</span> <span class=\"n\">sdf</span> <span class=\"o\">=</span> <span class=\"n\">sample_sdf_near_surface</span><span class=\"p\">(</span><span class=\"n\">mesh</span><span class=\"p\">,</span> <span class=\"n\">number_of_points</span><span class=\"o\">=</span><span class=\"mi\">250000</span><span class=\"p\">)</span>\n\n<span class=\"n\">colors</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">(</span><span class=\"n\">points</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">)</span>\n<span class=\"n\">colors</span><span class=\"p\">[</span><span class=\"n\">sdf</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">colors</span><span class=\"p\">[</span><span class=\"n\">sdf</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">cloud</span> <span class=\"o\">=</span> <span class=\"n\">pyrender</span><span class=\"o\">.</span><span class=\"n\">Mesh</span><span class=\"o\">.</span><span class=\"n\">from_points</span><span class=\"p\">(</span><span class=\"n\">points</span><span class=\"p\">,</span> <span class=\"n\">colors</span><span class=\"o\">=</span><span class=\"n\">colors</span><span class=\"p\">)</span>\n<span class=\"n\">scene</span> <span class=\"o\">=</span> <span class=\"n\">pyrender</span><span class=\"o\">.</span><span class=\"n\">Scene</span><span class=\"p\">()</span>\n<span class=\"n\">scene</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">cloud</span><span class=\"p\">)</span>\n<span class=\"n\">viewer</span> <span class=\"o\">=</span> <span class=\"n\">pyrender</span><span class=\"o\">.</span><span class=\"n\">Viewer</span><span class=\"p\">(</span><span class=\"n\">scene</span><span class=\"p\">,</span> <span class=\"n\">use_raymond_lighting</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">point_size</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"Example of a mesh and a point cloud of non-uniformly sampled SDF points\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/affb66b2e566e2456a2c98b3c192b96e220bf3e9/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f6d617269616e34322f6d6573685f746f5f7364662f6d61737465722f6578616d706c652f6e6f6e2d756e69666f726d2e706e67\"></p>\n<h2>How it works</h2>\n<p>The general pipeline for calculating SDF in this project is as follows:</p>\n<ol>\n<li>Create 100 virtual laser scans of the shape from multiple angles.\nThese each consist of a normal buffer and a depth buffer.</li>\n<li>Use the inverse MVP matrix and depth buffer of each scan to calculate a world-space surface point cloud</li>\n<li>Determine the value of the SDF for each query point by finding the closest surface point using a kd-tree</li>\n<li>Determine the sign of the SDF using either the normal of the closest surface point or by checking it against the depth buffers of the scans.\nWhen using normals, the sign is determined with a dot product.\nWhen using the depth buffer method, the point is projected in the frame of each render.\nBy comparing the depth element of the depth buffer and depth of the query point, we determine if the query point is seen by the camera.\nThe sign of the point is positive if it is seen by any of the cameras.</li>\n</ol>\n<p>This repository contains an implementation of the procedure proposed in the <a href=\"\" rel=\"nofollow\">DeepSDF paper</a>, as well as some alternatives.</p>\n<h1>Documentation</h1>\n<h2>mesh_to_sdf</h2>\n<p>Calculate signed distance values for an array of given query points</p>\n<pre><span class=\"n\">mesh_to_sdf</span><span class=\"o\">.</span><span class=\"n\">mesh_to_sdf</span><span class=\"p\">(</span><span class=\"n\">mesh</span><span class=\"p\">,</span> <span class=\"n\">query_points</span><span class=\"p\">,</span> <span class=\"n\">surface_point_method</span><span class=\"o\">=</span><span class=\"s1\">'scan'</span><span class=\"p\">,</span> <span class=\"n\">sign_method</span><span class=\"o\">=</span><span class=\"s1\">'normal'</span><span class=\"p\">,</span> <span class=\"n\">bounding_radius</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">scan_count</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">scan_resolution</span><span class=\"o\">=</span><span class=\"mi\">400</span><span class=\"p\">,</span> <span class=\"n\">sample_point_count</span><span class=\"o\">=</span><span class=\"mi\">10000000</span><span class=\"p\">,</span> <span class=\"n\">normal_sample_count</span><span class=\"o\">=</span><span class=\"mi\">11</span><span class=\"p\">)</span>\n</pre>\n<p>Parameters</p>\n<ul>\n<li><code>mesh</code>: a <a href=\"https://trimsh.org/trimesh.html\" rel=\"nofollow\">trimesh</a> mesh</li>\n<li><code>query_points</code>: an N \u2715 3 numpy array, containing the points for which the signed distance function should be calculated.</li>\n<li>See <em>common parameters</em> for the remaining parameters</li>\n</ul>\n<p>Returns</p>\n<ul>\n<li>a numpy array with N elemenents, containing the SDF for each query point</li>\n</ul>\n<h2>mesh_to_voxels</h2>\n<p>Calculate an N \u2715 N \u2715 N voxel volume of signed distance values for a given mesh.\nThe mesh is first transformed to fit inside a cube ranging from -1 to 1.</p>\n<pre><span class=\"n\">mesh_to_sdf</span><span class=\"o\">.</span><span class=\"n\">mesh_to_voxels</span><span class=\"p\">(</span><span class=\"n\">mesh</span><span class=\"p\">,</span> <span class=\"n\">voxel_resolution</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">surface_point_method</span><span class=\"o\">=</span><span class=\"s1\">'scan'</span><span class=\"p\">,</span> <span class=\"n\">sign_method</span><span class=\"o\">=</span><span class=\"s1\">'normal'</span><span class=\"p\">,</span> <span class=\"n\">scan_count</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">scan_resolution</span><span class=\"o\">=</span><span class=\"mi\">400</span><span class=\"p\">,</span> <span class=\"n\">sample_point_count</span><span class=\"o\">=</span><span class=\"mi\">10000000</span><span class=\"p\">,</span> <span class=\"n\">normal_sample_count</span><span class=\"o\">=</span><span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"n\">pad</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">check_result</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>Parameters</p>\n<ul>\n<li><code>mesh</code>: a <a href=\"https://trimsh.org/trimesh.html\" rel=\"nofollow\">trimesh</a> mesh</li>\n<li><code>voxel_resolution</code>: the resolution N of the resulting voxel volume</li>\n<li><code>pad</code>: if <code>True</code>, the resulting array is padded with ones, ensuring a mesh without holes when reconstructing with Marching Cubes</li>\n<li><code>check_result</code>: if <code>True</code>, the result is checked for continuity.\nIf the voxel volume is not a plausible signed distance field, an exception is thrown.</li>\n<li>See <em>common parameters</em> for the remaining parameters</li>\n</ul>\n<p>Returns</p>\n<ul>\n<li>a numpy array of shape N \u2715 N \u2715 N (or N + 2 \u2715 N + 2 \u2715 N + 2 when using padding)</li>\n</ul>\n<h2>sample_sdf_near_surface</h2>\n<p>Sample some points uniformly and some points near the shape surface and calculate SDFs for these points.\nThis follows the procedure proposed in the <a href=\"https://arxiv.org/abs/1901.05103\" rel=\"nofollow\">DeepSDF paper</a>.\nThe mesh is first transformed to fit inside the unit sphere.</p>\n<pre><span class=\"n\">mesh_to_sdf</span><span class=\"o\">.</span><span class=\"n\">sample_sdf_near_surface</span><span class=\"p\">(</span><span class=\"n\">mesh</span><span class=\"p\">,</span> <span class=\"n\">number_of_points</span> <span class=\"o\">=</span> <span class=\"mi\">500000</span><span class=\"p\">,</span> <span class=\"n\">surface_point_method</span><span class=\"o\">=</span><span class=\"s1\">'scan'</span><span class=\"p\">,</span> <span class=\"n\">sign_method</span><span class=\"o\">=</span><span class=\"s1\">'normal'</span><span class=\"p\">,</span> <span class=\"n\">scan_count</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">scan_resolution</span><span class=\"o\">=</span><span class=\"mi\">400</span><span class=\"p\">,</span> <span class=\"n\">sample_point_count</span><span class=\"o\">=</span><span class=\"mi\">10000000</span><span class=\"p\">,</span> <span class=\"n\">normal_sample_count</span><span class=\"o\">=</span><span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"n\">min_size</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n</pre>\n<p>Parameters</p>\n<ul>\n<li><code>mesh</code>: a <a href=\"https://trimsh.org/trimesh.html\" rel=\"nofollow\">trimesh</a> mesh</li>\n<li><code>number_of_points</code>: the number N of points to be sampled, including surface points and uniform points</li>\n<li><code>min_size</code>: The fraction of uniformly sampled that should be inside the shape.\nIf this is 0.015 and less than 1.5% of uniformly sampled points have negative SDFs, an exception is thrown.\nThis can be used to detect bad meshes.</li>\n<li>See <em>common parameters</em> for the remaining parameters</li>\n</ul>\n<p>Returns</p>\n<ul>\n<li><code>points</code>: an N \u2715 3 numpy array containing the sample points</li>\n<li><code>sdf</code>: a numpy array of size N with the corresponding SDF values</li>\n</ul>\n<h2>get_surface_point_cloud</h2>\n<p>Returns an intermediate data structure containing a surface point cloud, scans and a kd-tree of the point cloud.\nThis can be used if SDFs will be calculated multiple times for the same mesh or for debugging.</p>\n<pre><span class=\"n\">mesh_to_sdf</span><span class=\"o\">.</span><span class=\"n\">get_surface_point_cloud</span><span class=\"p\">(</span><span class=\"n\">mesh</span><span class=\"p\">,</span> <span class=\"n\">surface_point_method</span><span class=\"o\">=</span><span class=\"s1\">'scan'</span><span class=\"p\">,</span> <span class=\"n\">bounding_radius</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">scan_count</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">scan_resolution</span><span class=\"o\">=</span><span class=\"mi\">400</span><span class=\"p\">,</span> <span class=\"n\">sample_point_count</span><span class=\"o\">=</span><span class=\"mi\">10000000</span><span class=\"p\">,</span> <span class=\"n\">calculate_normals</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>Parameters</p>\n<ul>\n<li><code>mesh</code>: a <a href=\"https://trimsh.org/trimesh.html\" rel=\"nofollow\">trimesh</a> mesh</li>\n<li>See <em>common parameters</em> for the remaining parameters</li>\n</ul>\n<p>Returns</p>\n<ul>\n<li>an instance of <code>SurfacePointCloud</code></li>\n</ul>\n<h2>Common parameters</h2>\n<ul>\n<li>\n<p><code>surface_point_method</code>:\nThe method to generate a surface point cloud.\nEither <code>'scan'</code> or <code>'sample'</code>.\nThe scanning method creates virtual scans while the sampling method uses the triangles to sample surface points.\nThe sampling method only works with watertight meshes with correct face normals, but avoids some of the artifacts that the scanning method creates.</p>\n</li>\n<li>\n<p><code>sign_method</code>:\nThe method to determine the signs of the SDF values.\nEither <code>'normal'</code> or <code>'depth'</code>.\nThe normal method uses normals of the point cloud.\nIt works better for meshes with holes, but sometimes results in \"bubble\" artifacts.\nThe depth method avoids the bubble artifacts but is less accurate.</p>\n</li>\n<li>\n<p><code>bounding_radius</code>:\nThe radius of a sphere that contains all mesh vertices.\nIf <code>None</code>, this value is calculated using the mesh.</p>\n</li>\n<li>\n<p><code>scan_count</code>:\nNumber of scans when using the scanning method</p>\n</li>\n<li>\n<p><code>scan_resolution</code>:\nResolution for the scans in pixels.</p>\n</li>\n<li>\n<p><code>sample_point_count</code>:\nNumber of points to sample when using <code>surface_point_method='sample'</code></p>\n</li>\n<li>\n<p><code>normal_sample_count</code>:\nNumber of nearby surface points to check when using <code>sign_method='normal'</code>.\nThe sign of the resulting SDF is determined by majority vote.</p>\n</li>\n</ul>\n\n          </div>"}, "last_serial": 7158985, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "e9041e1edaf799aa681c60b452aa460a", "sha256": "788f8afa84ebc937c527baac7c87f251029286c0186df4cd7968acfe21a0878f"}, "downloads": -1, "filename": "mesh_to_sdf-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "e9041e1edaf799aa681c60b452aa460a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 10607, "upload_time": "2020-01-18T21:35:44", "upload_time_iso_8601": "2020-01-18T21:35:44.984377Z", "url": "https://files.pythonhosted.org/packages/a3/cb/c6a08295862c92cb19a231b6cf22a9ff28f571d51744b93823bb903942c0/mesh_to_sdf-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "c7da2ff6b82d5ed9f37f93233a563416", "sha256": "d07eb4dfe90512dfb7c08f8a7d70f99eb0232c85e6c68590c7c767ba9071dc75"}, "downloads": -1, "filename": "mesh-to-sdf-0.0.1.tar.gz", "has_sig": false, "md5_digest": "c7da2ff6b82d5ed9f37f93233a563416", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 10217, "upload_time": "2020-01-18T21:35:47", "upload_time_iso_8601": "2020-01-18T21:35:47.015097Z", "url": "https://files.pythonhosted.org/packages/77/49/9f21714e5f7ef3ca26490b235043b10df3bf4674c3d4074ac5f6e4cda35a/mesh-to-sdf-0.0.1.tar.gz", "yanked": false}], "0.0.10": [{"comment_text": "", "digests": {"md5": "e6b7e8dc03220800defc9d6b6aec9ee1", "sha256": "94d24b0c54c1c3ad47d7ce44dae6ae5b29d9aa58933b1450ccb9fd37553b79ab"}, "downloads": -1, "filename": "mesh_to_sdf-0.0.10-py3-none-any.whl", "has_sig": false, "md5_digest": "e6b7e8dc03220800defc9d6b6aec9ee1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 12441, "upload_time": "2020-05-03T18:52:52", "upload_time_iso_8601": "2020-05-03T18:52:52.812749Z", "url": "https://files.pythonhosted.org/packages/52/70/7c651bceba068af2be3048fbd0da6fe17841694dd33bdc04874703eab7ac/mesh_to_sdf-0.0.10-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "77d07fcd6268f473012be3cae0be008f", "sha256": "c9eed6284c523904bae89bd29c16d620e08ba6a055eb9dec0f78cbc08f3d88c8"}, "downloads": -1, "filename": "mesh-to-sdf-0.0.10.tar.gz", "has_sig": false, "md5_digest": "77d07fcd6268f473012be3cae0be008f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 11239, "upload_time": "2020-05-03T18:52:53", "upload_time_iso_8601": "2020-05-03T18:52:53.829098Z", "url": "https://files.pythonhosted.org/packages/8c/37/8c888b5f5192c97e7590f7550c8bb4ccfda21ddd60dd136f392e87da4372/mesh-to-sdf-0.0.10.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "6a245a502ef9f578cba0ff730f16859e", "sha256": "126d5e9c409b399aedd0df2b90c1f17b8ab7387264ed066c036ab69f2153aae1"}, "downloads": -1, "filename": "mesh_to_sdf-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "6a245a502ef9f578cba0ff730f16859e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 10650, "upload_time": "2020-01-18T22:09:49", "upload_time_iso_8601": "2020-01-18T22:09:49.052760Z", "url": "https://files.pythonhosted.org/packages/0b/21/67973bb5795f5aa9882842b5b6aa209f9bfd10ca4cee6afa9d4cd91786ce/mesh_to_sdf-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9deb9e559ed58009fdd404fb2bc631f1", "sha256": "251f72eb78769be3ec56e4ef29d36d1df22f3878c8243069a1efe4ed1da03aa6"}, "downloads": -1, "filename": "mesh-to-sdf-0.0.2.tar.gz", "has_sig": false, "md5_digest": "9deb9e559ed58009fdd404fb2bc631f1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 10282, "upload_time": "2020-01-18T22:09:50", "upload_time_iso_8601": "2020-01-18T22:09:50.292749Z", "url": "https://files.pythonhosted.org/packages/3a/5f/cd8114740f6f56916f28d54aa7cdf9cb34d99c70cdabff6e148c5faff026/mesh-to-sdf-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "8647c45be8b91ff4b26d036fd7a85874", "sha256": "45bb88ad5c571e7025c62d053c13a30b12d46c033b4329ef554b1a2b063c5904"}, "downloads": -1, "filename": "mesh_to_sdf-0.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "8647c45be8b91ff4b26d036fd7a85874", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 10736, "upload_time": "2020-01-19T18:02:34", "upload_time_iso_8601": "2020-01-19T18:02:34.776165Z", "url": "https://files.pythonhosted.org/packages/a4/c9/e36a40f6ca1279885d54d817b0f6ecbee44a548a122b36ae6b91481883f6/mesh_to_sdf-0.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "57e9b61bb68663602366d6bf68e9db35", "sha256": "54c769ba40c12d25bdc5a8a7266f7c3413715b9fc9112298986356ba5d792d1f"}, "downloads": -1, "filename": "mesh-to-sdf-0.0.3.tar.gz", "has_sig": false, "md5_digest": "57e9b61bb68663602366d6bf68e9db35", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 10458, "upload_time": "2020-01-19T18:02:36", "upload_time_iso_8601": "2020-01-19T18:02:36.394840Z", "url": "https://files.pythonhosted.org/packages/23/87/d18494932484e3aeeebe1bf7be23cee564ad8317aa61481122c69d9b3182/mesh-to-sdf-0.0.3.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "df074cbf8de0684128dd44701663245a", "sha256": "f2f31738e225cbadcf3ad765fbe81e54d0a6a444ad836a01276d591ee85ff8c2"}, "downloads": -1, "filename": "mesh_to_sdf-0.0.4-py3-none-any.whl", "has_sig": false, "md5_digest": "df074cbf8de0684128dd44701663245a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 12270, "upload_time": "2020-01-20T16:30:40", "upload_time_iso_8601": "2020-01-20T16:30:40.567553Z", "url": "https://files.pythonhosted.org/packages/5b/17/03c05879c766b6ecad58230865c1b73d44f585b0e6b85d99c4db8e90b285/mesh_to_sdf-0.0.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "af74c12118f4fba6b1916a4f0b0892fa", "sha256": "176007efd473882362680ec793013268a8df12f8f92b840990bb6802f39e60eb"}, "downloads": -1, "filename": "mesh-to-sdf-0.0.4.tar.gz", "has_sig": false, "md5_digest": "af74c12118f4fba6b1916a4f0b0892fa", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 11138, "upload_time": "2020-01-20T16:30:41", "upload_time_iso_8601": "2020-01-20T16:30:41.994837Z", "url": "https://files.pythonhosted.org/packages/76/02/7230274f2de49d0c6b6bc5a0f348378bad176d0c74113a861230907d31bf/mesh-to-sdf-0.0.4.tar.gz", "yanked": false}], "0.0.5": [{"comment_text": "", "digests": {"md5": "3e1199c9ba7a8b0954bb62e42c682f6e", "sha256": "b916883fbb61ddda0865833442f19b56ca9c9b3d4b7c891a36343806759a26be"}, "downloads": -1, "filename": "mesh_to_sdf-0.0.5-py3-none-any.whl", "has_sig": false, "md5_digest": "3e1199c9ba7a8b0954bb62e42c682f6e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 12386, "upload_time": "2020-01-20T21:02:07", "upload_time_iso_8601": "2020-01-20T21:02:07.406146Z", "url": "https://files.pythonhosted.org/packages/d5/da/492145fd8f26635fd79eaf0a0486dd15ff4f89dbf85e22702ecac20cd69e/mesh_to_sdf-0.0.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "47c8971c70937e9aff81bd432aea7e17", "sha256": "5345080ceddab71f09807ebdddab35f5de73091c6594e04c1205f6748cf2a925"}, "downloads": -1, "filename": "mesh-to-sdf-0.0.5.tar.gz", "has_sig": false, "md5_digest": "47c8971c70937e9aff81bd432aea7e17", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 11200, "upload_time": "2020-01-20T21:02:08", "upload_time_iso_8601": "2020-01-20T21:02:08.946366Z", "url": "https://files.pythonhosted.org/packages/56/f5/4cc2bc6dd61d336133137c01d4920a0962708a4e86a57f248aa3253c008f/mesh-to-sdf-0.0.5.tar.gz", "yanked": false}], "0.0.6": [{"comment_text": "", "digests": {"md5": "5f6635f264692cadacf6bf69b820b9be", "sha256": "3eea1e55b30452e41c5d7c8f0789d76ed81ef3fa5f17adf97e3512346cf90bd5"}, "downloads": -1, "filename": "mesh_to_sdf-0.0.6-py3-none-any.whl", "has_sig": false, "md5_digest": "5f6635f264692cadacf6bf69b820b9be", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 12408, "upload_time": "2020-01-20T21:42:36", "upload_time_iso_8601": "2020-01-20T21:42:36.442094Z", "url": "https://files.pythonhosted.org/packages/54/26/6da07575b6697f3ecb9fe53b37ffdc13a0726ca21156c58f44ef770c5a42/mesh_to_sdf-0.0.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1d237aa2d6a52706e32b774292997ef9", "sha256": "e77d320cd85c2e9e95a62689ae7a75f389ce2aa9a80a0801459c8da5675cd3af"}, "downloads": -1, "filename": "mesh-to-sdf-0.0.6.tar.gz", "has_sig": false, "md5_digest": "1d237aa2d6a52706e32b774292997ef9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 11217, "upload_time": "2020-01-20T21:42:37", "upload_time_iso_8601": "2020-01-20T21:42:37.784705Z", "url": "https://files.pythonhosted.org/packages/54/25/afadf06a4638457caa76bf001f355b846e8bf1cad87a456996fb15cd7985/mesh-to-sdf-0.0.6.tar.gz", "yanked": false}], "0.0.7": [{"comment_text": "", "digests": {"md5": "69fa394f9e28a74fb91bd5e63a7cfacd", "sha256": "9b3f3a2a582d383cc0ab0f80c8490793575d39b5bd90f3e46b579a63184089ed"}, "downloads": -1, "filename": "mesh_to_sdf-0.0.7-py3-none-any.whl", "has_sig": false, "md5_digest": "69fa394f9e28a74fb91bd5e63a7cfacd", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 12407, "upload_time": "2020-01-20T22:02:10", "upload_time_iso_8601": "2020-01-20T22:02:10.512463Z", "url": "https://files.pythonhosted.org/packages/46/30/1973353f917b6cb507d0bf5272c7d925e635b3c5d09cd1b4b15cd4b3d11b/mesh_to_sdf-0.0.7-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "022e1f15ef03dd95f0a8d66d724137e6", "sha256": "d504693bd1c5e48d7ae80f46a89aff6e6f5fdd47fdff954d6a88bcf6f60f168f"}, "downloads": -1, "filename": "mesh-to-sdf-0.0.7.tar.gz", "has_sig": false, "md5_digest": "022e1f15ef03dd95f0a8d66d724137e6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 11216, "upload_time": "2020-01-20T22:02:12", "upload_time_iso_8601": "2020-01-20T22:02:12.062957Z", "url": "https://files.pythonhosted.org/packages/cf/bf/a220689668422380bc22e48b8b13ee5819eaaade0743fda6017c4246daa7/mesh-to-sdf-0.0.7.tar.gz", "yanked": false}], "0.0.8": [{"comment_text": "", "digests": {"md5": "e15f7b43438a9fb6be4ddd2f98c63ac0", "sha256": "784a1c8b363e341d6a6f0f78fb75bc94eca44af643a3f6113dd62b33a2219c59"}, "downloads": -1, "filename": "mesh_to_sdf-0.0.8-py3-none-any.whl", "has_sig": false, "md5_digest": "e15f7b43438a9fb6be4ddd2f98c63ac0", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 12407, "upload_time": "2020-01-23T17:57:27", "upload_time_iso_8601": "2020-01-23T17:57:27.166117Z", "url": "https://files.pythonhosted.org/packages/4d/e9/b81957f1d0b11f175e55d7c8aeceb9de8f63fa71afdbfd30cbf486a554b6/mesh_to_sdf-0.0.8-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "42b0b8db80774107f3095acefaf1af48", "sha256": "6ed5d6f44ed9b0e178589599c43d6decca3f3875651b0699547c449840446918"}, "downloads": -1, "filename": "mesh-to-sdf-0.0.8.tar.gz", "has_sig": false, "md5_digest": "42b0b8db80774107f3095acefaf1af48", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 11213, "upload_time": "2020-01-23T17:57:28", "upload_time_iso_8601": "2020-01-23T17:57:28.666358Z", "url": "https://files.pythonhosted.org/packages/5d/ac/0a1fc78a8992627144aef4ec66f484b1575f84ab2c6f63deaa14deb3b7f0/mesh-to-sdf-0.0.8.tar.gz", "yanked": false}], "0.0.9": [{"comment_text": "", "digests": {"md5": "8202daf96db31ec128d149b4c8e33011", "sha256": "f4e38e5f66a05e0bbd6b1ed41b526235e15177e021dc1a42b65d0cfa2c1b83bc"}, "downloads": -1, "filename": "mesh_to_sdf-0.0.9-py3-none-any.whl", "has_sig": false, "md5_digest": "8202daf96db31ec128d149b4c8e33011", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 12398, "upload_time": "2020-01-23T22:15:55", "upload_time_iso_8601": "2020-01-23T22:15:55.605039Z", "url": "https://files.pythonhosted.org/packages/55/3c/fc32b2e57cbdacbfd1d01cd837080ed46d2de0f0900c2c37102230ee0ac1/mesh_to_sdf-0.0.9-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "04a14039a0629b6a23d25140d9c51e68", "sha256": "e75892b05962d827fdc535edc8a21777465bbf7af7d2a4e32717e1e40e51b83a"}, "downloads": -1, "filename": "mesh-to-sdf-0.0.9.tar.gz", "has_sig": false, "md5_digest": "04a14039a0629b6a23d25140d9c51e68", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 11210, "upload_time": "2020-01-23T22:15:57", "upload_time_iso_8601": "2020-01-23T22:15:57.757412Z", "url": "https://files.pythonhosted.org/packages/7f/e0/1584b73ff97b526d28724b3c6510e8030ad19e8acc7f15a10dcc7a443ef0/mesh-to-sdf-0.0.9.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e6b7e8dc03220800defc9d6b6aec9ee1", "sha256": "94d24b0c54c1c3ad47d7ce44dae6ae5b29d9aa58933b1450ccb9fd37553b79ab"}, "downloads": -1, "filename": "mesh_to_sdf-0.0.10-py3-none-any.whl", "has_sig": false, "md5_digest": "e6b7e8dc03220800defc9d6b6aec9ee1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 12441, "upload_time": "2020-05-03T18:52:52", "upload_time_iso_8601": "2020-05-03T18:52:52.812749Z", "url": "https://files.pythonhosted.org/packages/52/70/7c651bceba068af2be3048fbd0da6fe17841694dd33bdc04874703eab7ac/mesh_to_sdf-0.0.10-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "77d07fcd6268f473012be3cae0be008f", "sha256": "c9eed6284c523904bae89bd29c16d620e08ba6a055eb9dec0f78cbc08f3d88c8"}, "downloads": -1, "filename": "mesh-to-sdf-0.0.10.tar.gz", "has_sig": false, "md5_digest": "77d07fcd6268f473012be3cae0be008f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.5", "size": 11239, "upload_time": "2020-05-03T18:52:53", "upload_time_iso_8601": "2020-05-03T18:52:53.829098Z", "url": "https://files.pythonhosted.org/packages/8c/37/8c888b5f5192c97e7590f7550c8bb4ccfda21ddd60dd136f392e87da4372/mesh-to-sdf-0.0.10.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:56:04 2020"}