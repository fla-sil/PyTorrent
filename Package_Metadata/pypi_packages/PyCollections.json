{"info": {"author": "IsGiambyy aka Nocturn9x", "author_email": "hackhab@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: GNU Lesser General Public License v3 or later (LGPLv3+)", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# PyCollections\nPyCollections is a Python 3 library that implements some useful containers (tuples, dictionaries, lists)\n\n\n### Note\n\nVersion 0.2.1 contains a major fix with NamedTuple, that now allows to use Python standard collections--those are lists, dicts, sets and tuples--as named arguments.\n\n### Note 2\n\nThe **Methods** section of every container that is documented below, contains only methods that are not present in the respective parent class. For instance, the `LockedList()` **Methods** section does not contain `append(self)` because it's inherited and reimplemented from its parent class.\n\n## A bit of information\n\nPyCollections implements some cool containers based on Python's builtins such as lists, tuples, dicts and sets.\n\nThese containers, or collections, behave slightly different from their parent class as explained below.\n\nAt the time of writing, PyCollections is in Development Status 3 (Alpha) and has reached version 0.2.0, that implements:\n\n  - ConstantDict() -> A dictionary whose key-value couples cannot be overwritten nor deleted once set\n  - NamedTuple() -> Behaves exactly like a tuple, but has named arguments and can be accessed with literal indexes like dicts\n  - LockedList() -> A list that can be locked or unlocked, allowing or disallowing access to the list itself\n  - RLockedList() -> Inspired by threading's RLock() class, this special list cannot be accessed by other threads once acquired (It needs to be released to access it)\n\n### ConstantDict() - Docs\n\n#### Introduction\n\nThis class implements a 'constant' (or immutable) mapping, we'll face those apexes in a second.\n\nConstantDict inherits most of its functions from Python's built-in mapping objects: dicts.\nThis mapping mostly behaves like an usual python dict, except for  4 things:\n\n  - Once a key-value pair is inserted, it cannot be removed anymore\n  - Existing key-value pairs cannot be overwritten\n  - Attempting to access the `__dict__` attribute will fail\n  - Attempting to access `dir(object)` will fail\n\nThese characteristics have been specifically implemented to avoid item's accidental overwrite/deletion.\n\nLet's face the apexes at the beginning: In pure Python, it's impossible to implement an immutable container as it is duck typed: tuples and frozen sets, for example, are implemented in C AND Python, this allowing them to be truly immutable.\n\nYou might be wondering, \"Soo, how does this class even exists? Didn't you just say it's impossible?!\"\n\nYeah, it is, and actually this mapping is not truly immutable: it just overwrites any known standard method to access mappings values and edit them, but it is still possible to edit those values by accessing the class attribute `{object}_ConstantDict__container`.\n\nThis mapping is indeed intended to reduce the probability of **ACCIDENTALLY** overwriting those\nvalues, if you are looking for immutable objects natively, just\nswitch to Java :)\n\n#### Methods\n\n  - `act_as_dict(self)` -> Bound method to activate/deactivate Python dict emulation. Returns the value of the act_as_dict instance attribute as a boolean value once called\n\n  - `typeof(self)` -> The ConstantDict class is built so that it can emulate Python dicts.\n    To pass `isinstance()` check, use `ConstantDict.typeof()` as first argument, after having called `act_as_dict()` on the container\n\n### NamedTuple() - Docs\n\nThis class implement a named tuple, that is, a container that behaves like a common tuple, but has named arguments.\n\nThe tuple works as described below:\n\n  - Create tuple :\n\n    `>>> test = NamedTuple(key1='var1', key2='var2', ...)`\n\n  - Find element in tuple :\n\n    `>>> test.find(key1)`\n\n        'var1'\n\n  - Get tuple keys :\n\n    `>>> test.keys()`\n\n        ['key1', 'key2', ...]\n\n  - Get tuple elements :\n\n    `>>> test.items()`\n\n        ['var1', 'var2', ...]\n\n  - Get a single element :\n\n    `>>> test[0]`\n\n    `>>> test[\"key1\"]`\n\n        'var1'\n\n#### Methods\n\n  - `create_tuple(self)` -> This method, meant for internal use, is called after `__init__` and has the job of\n   initializizing the `NamedTuple` arguments and to set the needed parameters for the container to work properly\n\n  - `isfloat(value)` -> This method, meant for internal use, is called by the `NamedTuple` class to determine wheter a given value is a float or not\n\n  - `find(self, item)` -> Finds an element in tuple with the given key\n\n  - `items(self)` -> Returns all the values inside the tuple as a list object\n\n  - `keys(self)` -> Returns all the keys inside the tuple as a list object\n\n  - `typeof(self)` -> Returns the type of the tuple depending on the `_act_as_tuple` object attribute\n\n  - `act_as_tuple(self)` -> Bound method to activate/deactivate Python tuple emulation. Returns the value of the `_act_as_tuple` instance attribute as a boolean value once called\n\n\n### LockedList() - Docs\n\nThe LockedList() container behaves mostly like a common Python list object, except for the fact that it has a special attribute --namely, `_status`-- that can assume a boolean value, that is either `True` or `False`. When `_status` is set to `False`, the container's behaviour is the same as Python lists, but when its value equals `True`, every attempt to read/write the list will raise an exception and leave the container unmodified. This can be useful for situations where very important variables need to be preserved from being accidentally modified. \n\n**NOTE**: The concept explained for the `ConstantDict()`'s \"fake\" immutability is valid also for `LockedList()`, the below `RLockedList()` and in general for every container in this library whose behaviour prevents data modification. This means that the \"you can't touch this!\" rule isn't valid like, e.g., for Java where the `private` or `public` reserved keywords do prevent/allow variable modification. If you need a truly immutable container, use the `collections` module, that is implemented in C, a language that supports this kind of variable behaviour. In substance, there are no immutable containers in pure Python and this is not a flaw, just an implementation choice (like the GIL or the absence of constants, but you can argue about that with Guido van Rossum).\n\n\n#### Methods\n\n  - `lock(self)` -> Sets the `_status` parameter to `True`, disallowing access to the list's items\n\n  - `unlock(self)` -> Sets the `_status` parameter to `False`, allowing access to the list's items\n\n  - `status(self)` -> Returns the value of the `_status` parameter\n\n  - `act_as_list(self)` -> Bound method to activate/deactivate Python list emulation. Returns the value of the `_act_as_list` instance attribute as a boolean value once called\n\n  - `typeof(self)` -> Returns the type of the tuple depending on the `_act_as_list` object attribute\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/nocturn9x/pycollections", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "PyCollections", "package_url": "https://pypi.org/project/PyCollections/", "platform": "", "project_url": "https://pypi.org/project/PyCollections/", "project_urls": {"Homepage": "https://github.com/nocturn9x/pycollections"}, "release_url": "https://pypi.org/project/PyCollections/0.2.1/", "requires_dist": null, "requires_python": ">=3.6", "summary": "A bunch of useful containers and custom variables", "version": "0.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>PyCollections</h1>\n<p>PyCollections is a Python 3 library that implements some useful containers (tuples, dictionaries, lists)</p>\n<h3>Note</h3>\n<p>Version 0.2.1 contains a major fix with NamedTuple, that now allows to use Python standard collections--those are lists, dicts, sets and tuples--as named arguments.</p>\n<h3>Note 2</h3>\n<p>The <strong>Methods</strong> section of every container that is documented below, contains only methods that are not present in the respective parent class. For instance, the <code>LockedList()</code> <strong>Methods</strong> section does not contain <code>append(self)</code> because it's inherited and reimplemented from its parent class.</p>\n<h2>A bit of information</h2>\n<p>PyCollections implements some cool containers based on Python's builtins such as lists, tuples, dicts and sets.</p>\n<p>These containers, or collections, behave slightly different from their parent class as explained below.</p>\n<p>At the time of writing, PyCollections is in Development Status 3 (Alpha) and has reached version 0.2.0, that implements:</p>\n<ul>\n<li>ConstantDict() -&gt; A dictionary whose key-value couples cannot be overwritten nor deleted once set</li>\n<li>NamedTuple() -&gt; Behaves exactly like a tuple, but has named arguments and can be accessed with literal indexes like dicts</li>\n<li>LockedList() -&gt; A list that can be locked or unlocked, allowing or disallowing access to the list itself</li>\n<li>RLockedList() -&gt; Inspired by threading's RLock() class, this special list cannot be accessed by other threads once acquired (It needs to be released to access it)</li>\n</ul>\n<h3>ConstantDict() - Docs</h3>\n<h4>Introduction</h4>\n<p>This class implements a 'constant' (or immutable) mapping, we'll face those apexes in a second.</p>\n<p>ConstantDict inherits most of its functions from Python's built-in mapping objects: dicts.\nThis mapping mostly behaves like an usual python dict, except for  4 things:</p>\n<ul>\n<li>Once a key-value pair is inserted, it cannot be removed anymore</li>\n<li>Existing key-value pairs cannot be overwritten</li>\n<li>Attempting to access the <code>__dict__</code> attribute will fail</li>\n<li>Attempting to access <code>dir(object)</code> will fail</li>\n</ul>\n<p>These characteristics have been specifically implemented to avoid item's accidental overwrite/deletion.</p>\n<p>Let's face the apexes at the beginning: In pure Python, it's impossible to implement an immutable container as it is duck typed: tuples and frozen sets, for example, are implemented in C AND Python, this allowing them to be truly immutable.</p>\n<p>You might be wondering, \"Soo, how does this class even exists? Didn't you just say it's impossible?!\"</p>\n<p>Yeah, it is, and actually this mapping is not truly immutable: it just overwrites any known standard method to access mappings values and edit them, but it is still possible to edit those values by accessing the class attribute <code>{object}_ConstantDict__container</code>.</p>\n<p>This mapping is indeed intended to reduce the probability of <strong>ACCIDENTALLY</strong> overwriting those\nvalues, if you are looking for immutable objects natively, just\nswitch to Java :)</p>\n<h4>Methods</h4>\n<ul>\n<li>\n<p><code>act_as_dict(self)</code> -&gt; Bound method to activate/deactivate Python dict emulation. Returns the value of the act_as_dict instance attribute as a boolean value once called</p>\n</li>\n<li>\n<p><code>typeof(self)</code> -&gt; The ConstantDict class is built so that it can emulate Python dicts.\nTo pass <code>isinstance()</code> check, use <code>ConstantDict.typeof()</code> as first argument, after having called <code>act_as_dict()</code> on the container</p>\n</li>\n</ul>\n<h3>NamedTuple() - Docs</h3>\n<p>This class implement a named tuple, that is, a container that behaves like a common tuple, but has named arguments.</p>\n<p>The tuple works as described below:</p>\n<ul>\n<li>\n<p>Create tuple :</p>\n<p><code>&gt;&gt;&gt; test = NamedTuple(key1='var1', key2='var2', ...)</code></p>\n</li>\n<li>\n<p>Find element in tuple :</p>\n<p><code>&gt;&gt;&gt; test.find(key1)</code></p>\n<pre><code>'var1'\n</code></pre>\n</li>\n<li>\n<p>Get tuple keys :</p>\n<p><code>&gt;&gt;&gt; test.keys()</code></p>\n<pre><code>['key1', 'key2', ...]\n</code></pre>\n</li>\n<li>\n<p>Get tuple elements :</p>\n<p><code>&gt;&gt;&gt; test.items()</code></p>\n<pre><code>['var1', 'var2', ...]\n</code></pre>\n</li>\n<li>\n<p>Get a single element :</p>\n<p><code>&gt;&gt;&gt; test[0]</code></p>\n<p><code>&gt;&gt;&gt; test[\"key1\"]</code></p>\n<pre><code>'var1'\n</code></pre>\n</li>\n</ul>\n<h4>Methods</h4>\n<ul>\n<li>\n<p><code>create_tuple(self)</code> -&gt; This method, meant for internal use, is called after <code>__init__</code> and has the job of\ninitializizing the <code>NamedTuple</code> arguments and to set the needed parameters for the container to work properly</p>\n</li>\n<li>\n<p><code>isfloat(value)</code> -&gt; This method, meant for internal use, is called by the <code>NamedTuple</code> class to determine wheter a given value is a float or not</p>\n</li>\n<li>\n<p><code>find(self, item)</code> -&gt; Finds an element in tuple with the given key</p>\n</li>\n<li>\n<p><code>items(self)</code> -&gt; Returns all the values inside the tuple as a list object</p>\n</li>\n<li>\n<p><code>keys(self)</code> -&gt; Returns all the keys inside the tuple as a list object</p>\n</li>\n<li>\n<p><code>typeof(self)</code> -&gt; Returns the type of the tuple depending on the <code>_act_as_tuple</code> object attribute</p>\n</li>\n<li>\n<p><code>act_as_tuple(self)</code> -&gt; Bound method to activate/deactivate Python tuple emulation. Returns the value of the <code>_act_as_tuple</code> instance attribute as a boolean value once called</p>\n</li>\n</ul>\n<h3>LockedList() - Docs</h3>\n<p>The LockedList() container behaves mostly like a common Python list object, except for the fact that it has a special attribute --namely, <code>_status</code>-- that can assume a boolean value, that is either <code>True</code> or <code>False</code>. When <code>_status</code> is set to <code>False</code>, the container's behaviour is the same as Python lists, but when its value equals <code>True</code>, every attempt to read/write the list will raise an exception and leave the container unmodified. This can be useful for situations where very important variables need to be preserved from being accidentally modified.</p>\n<p><strong>NOTE</strong>: The concept explained for the <code>ConstantDict()</code>'s \"fake\" immutability is valid also for <code>LockedList()</code>, the below <code>RLockedList()</code> and in general for every container in this library whose behaviour prevents data modification. This means that the \"you can't touch this!\" rule isn't valid like, e.g., for Java where the <code>private</code> or <code>public</code> reserved keywords do prevent/allow variable modification. If you need a truly immutable container, use the <code>collections</code> module, that is implemented in C, a language that supports this kind of variable behaviour. In substance, there are no immutable containers in pure Python and this is not a flaw, just an implementation choice (like the GIL or the absence of constants, but you can argue about that with Guido van Rossum).</p>\n<h4>Methods</h4>\n<ul>\n<li>\n<p><code>lock(self)</code> -&gt; Sets the <code>_status</code> parameter to <code>True</code>, disallowing access to the list's items</p>\n</li>\n<li>\n<p><code>unlock(self)</code> -&gt; Sets the <code>_status</code> parameter to <code>False</code>, allowing access to the list's items</p>\n</li>\n<li>\n<p><code>status(self)</code> -&gt; Returns the value of the <code>_status</code> parameter</p>\n</li>\n<li>\n<p><code>act_as_list(self)</code> -&gt; Bound method to activate/deactivate Python list emulation. Returns the value of the <code>_act_as_list</code> instance attribute as a boolean value once called</p>\n</li>\n<li>\n<p><code>typeof(self)</code> -&gt; Returns the type of the tuple depending on the <code>_act_as_list</code> object attribute</p>\n</li>\n</ul>\n\n          </div>"}, "last_serial": 6030733, "releases": {"0.1.8": [{"comment_text": "", "digests": {"md5": "217ab6ef029748431e5e8b224e7165ba", "sha256": "1226e05cf9fb1757b1906716fe217109fb4bd0082bbd7abb1c6cb409419e4d33"}, "downloads": -1, "filename": "PyCollections-0.1.8-py3-none-any.whl", "has_sig": false, "md5_digest": "217ab6ef029748431e5e8b224e7165ba", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 8136, "upload_time": "2019-10-18T17:30:42", "upload_time_iso_8601": "2019-10-18T17:30:42.900158Z", "url": "https://files.pythonhosted.org/packages/09/5e/d21f6a9b5124a327432bfa0d3f58f4bfdcf4a23e09926a0ab07c9030e37f/PyCollections-0.1.8-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dfb97accf1abbcd111831f16eaed3280", "sha256": "a2d3e2bb1c996a3132d1b96f59cf92451de9bfeff65e1361ac5b84cd66caa889"}, "downloads": -1, "filename": "PyCollections-0.1.8.tar.gz", "has_sig": false, "md5_digest": "dfb97accf1abbcd111831f16eaed3280", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 4146, "upload_time": "2019-10-18T17:30:45", "upload_time_iso_8601": "2019-10-18T17:30:45.634250Z", "url": "https://files.pythonhosted.org/packages/46/3b/c2f51f1c35e2403ab1c1a7bb4f36a01d8110e34a7b08bbfa56d83b983eed/PyCollections-0.1.8.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "385ff9425a990d9efb306e7f4fb71003", "sha256": "2f069f8b908c0a6c0be865950b0c6be74b02f3c29c0da591ec9a5c229ab0d013"}, "downloads": -1, "filename": "PyCollections-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "385ff9425a990d9efb306e7f4fb71003", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 11730, "upload_time": "2019-10-20T12:06:13", "upload_time_iso_8601": "2019-10-20T12:06:13.858787Z", "url": "https://files.pythonhosted.org/packages/fc/f1/953e260a31956a0247988d76784ed0716399b82bbe6687d235a611fd16a8/PyCollections-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "86f4dce3e677d516dd87b31e4281ac81", "sha256": "b06e2001b7cddf3c559a6f53856c96920e1a6bd5b8dbbff671f86b5110ecf539"}, "downloads": -1, "filename": "PyCollections-0.2.0.tar.gz", "has_sig": false, "md5_digest": "86f4dce3e677d516dd87b31e4281ac81", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6072, "upload_time": "2019-10-20T12:06:15", "upload_time_iso_8601": "2019-10-20T12:06:15.843325Z", "url": "https://files.pythonhosted.org/packages/e3/2c/5ceecdf7027596749b4ec960fd8293ea714a92d880acad47b68bd6e5b090/PyCollections-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "3532baa365a75c3adde3bf3473e55434", "sha256": "8de09d1d55af7420b6e626d10de23c1ab56551c2d5324bcd3981cc31c71adac9"}, "downloads": -1, "filename": "PyCollections-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "3532baa365a75c3adde3bf3473e55434", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 11918, "upload_time": "2019-10-25T17:15:43", "upload_time_iso_8601": "2019-10-25T17:15:43.244768Z", "url": "https://files.pythonhosted.org/packages/d7/b6/7f889df6d0db546209a0e4d5a6df94d999a0ea0e179159865ae8c3650e20/PyCollections-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "57acdc993a946f35c11a2eb16d4b66bc", "sha256": "ca2dd2a3831f5a0eb9063a07f36f1e83cbb46a12d7caf3c8f49ac4bc33daa630"}, "downloads": -1, "filename": "PyCollections-0.2.1.tar.gz", "has_sig": false, "md5_digest": "57acdc993a946f35c11a2eb16d4b66bc", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 7584, "upload_time": "2019-10-25T17:15:45", "upload_time_iso_8601": "2019-10-25T17:15:45.175963Z", "url": "https://files.pythonhosted.org/packages/c1/25/e283becbbdd9cc06f4fdcc9da1023086f33dc7a0ed1647bb72152e744ea1/PyCollections-0.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3532baa365a75c3adde3bf3473e55434", "sha256": "8de09d1d55af7420b6e626d10de23c1ab56551c2d5324bcd3981cc31c71adac9"}, "downloads": -1, "filename": "PyCollections-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "3532baa365a75c3adde3bf3473e55434", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 11918, "upload_time": "2019-10-25T17:15:43", "upload_time_iso_8601": "2019-10-25T17:15:43.244768Z", "url": "https://files.pythonhosted.org/packages/d7/b6/7f889df6d0db546209a0e4d5a6df94d999a0ea0e179159865ae8c3650e20/PyCollections-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "57acdc993a946f35c11a2eb16d4b66bc", "sha256": "ca2dd2a3831f5a0eb9063a07f36f1e83cbb46a12d7caf3c8f49ac4bc33daa630"}, "downloads": -1, "filename": "PyCollections-0.2.1.tar.gz", "has_sig": false, "md5_digest": "57acdc993a946f35c11a2eb16d4b66bc", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 7584, "upload_time": "2019-10-25T17:15:45", "upload_time_iso_8601": "2019-10-25T17:15:45.175963Z", "url": "https://files.pythonhosted.org/packages/c1/25/e283becbbdd9cc06f4fdcc9da1023086f33dc7a0ed1647bb72152e744ea1/PyCollections-0.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:08:14 2020"}