{"info": {"author": "Howard A. Landman", "author_email": "howard@riverrock.org", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Natural Language :: English", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering", "Topic :: Scientific/Engineering :: Physics", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: System :: Hardware :: Hardware Drivers"], "description": "# TDC7201 driver for Raspberry Pi\n\nThis project contains a python3 module for interfacing with the Texas Instruments TDC7201 Time-to-Digital-Converter chip through SPI.\nAs much as possible, it hides the internal implementation details (like SPI transactions, and chip registers and their field encodings) from the user.\n\nAll code is GPLv3+ licensed unless explicitly stated otherwise.\n\nFor more information on the chip, see https://www.ti.com/product/TDC7201\n\n## Usage\n\n```python\nimport tdc7201\ntdc = tdc7201.TDC7201() # Create TDC object with SPI interface.\ntdc.initGPIO() # Set pin directions and default values for non-SPI signals.\ntdc.set_SPI_clock_speed(12500000)\ntdc.on(meas_mode=2,num_stop=3,clock_cntr_stop=1,timeout=0.0005)\nstatus = tdc.measure(simulate=True)\ntdc.off()\n```\n\n## Settings\n\nHardware pin assignments are done in `initGPIO()`, which should only be called once.\nMost other important parameters are set in the `on()` method,\nsince the chip can only be reconfigured after it has come out of reset.\nIf you want to change parameters, it is cleanest to turn the chip `off()`, and then `on()` again with the new parameters.\n\n## Methods\n\n    initGPIO(enable=12,osc_enable=16,trig1=7,int1=37,trig2=11,int2=32,start=18,stop=22,verbose=False)\n\nAssigns and initializes all the non-SPI pins.\nYour actual hardware (wiring between RPi and chip) needs to match this setup.\nNo arguments are required, but the defaults match my prototype and are somewhat arbitrary.\nYou can see all assignments by calling with `verbose=True`.\nPin numbers follow `GPIO.BOARD` conventions,\ni.e. they are the pin numbers on the 2x20 pin heeader.\nOnly 3 pins (`enable`,`trig1`,`int1`) are absolutely required;\nthe others can be skipped by assigning `None` to them.\nIf `osc_enable` is `None`, then there will be no signal to turn an external clock on or off; this is OK if you supply the chip clock yourself.\nIf `trig2` and/or `int2` is `None`, then side 2 of the chip will not work correctly, but side 1 still will.\nThe `start` and `stop` pins are only required if you want the Raspberry Pi to generate START and STOP signals for testing, i.e. if you plan to run `tdc.measure(simulate=True)`.\nIf you are hooked up to real signals to measure, then you can and should set `start=None,stop=None`.\n\n    on(force_cal=True,meas_mode=2,falling=False,calibration2_periods=10,avg_cycles=1,num_stop=1,clock_cntr_stop=0,clock_cntr_ovf=0xFFFF,timeout=None)\n\nTakes the chip out of reset and set up various control parameters.\n\n* `force_cal` -\nIf `True`, will recalibrate the chip after every attempted measurement.\nThis is recommended (and, in this version, required and default).\nIf `False`, will only recalibrate after a \"successful\" measurement,\nwith timeouts and some other results considered unsuccessful.\n(This currently does not work.)\n* `meas_mode` -\nSets the measurement mode.\nMode 1 is recommended for times less than 2000 nS; mode 2 for greater.\n(In this release only mode 2 is fully supported, and is therefore the default.)\n* `falling` -\nIf `True`, sets the chip to trigger on falling edges of START and STOP.\nThe default is `False`, which has it trigger on rising edges.\n* `calibration2_periods` - The number of clock cycles to recalibrate for. The allowed values are 2, 10 (hardware default), 20, and 40.\n* `avg_cycles` - The number of measurements to average over. The allowed values are 1, 2, 4, 8, 16, 32, 64, and 128. The default is 1, which means no averaging. If you use anything larger, the chip will run that many measurements and then report only the average values. This can be useful in a noisy environment.\n* `num_stop` -\nThe chip starts timing on a pulse on the START pin, and then can record timings for up to 5 pulses on the STOP pin.\nAllowed values are 1, 2, 3, 4, 5.\nThe default is 1, which means the measurement will terminate as soon as a single STOP pulse is received.\n* `clock_cntr_stop = N` - If N is non-zero, the chip will ignore STOP pulses for N clock cycles after START.\n* `clock_cntr_ovf = N` - The chip will end measurement (\"time out\" or \"clock counter overflow\") after N clock cycles even if `num_stop` STOP pulses have not been received.\nDefault (and maximum) is 65535 = 0xFFFF.\n* `timeout = T` - You can also specify the overflow period as a time in seconds. For example, if T is 0.0005, the timeout period will be 500 microseconds. If both `timeout` and `clock_cntr_ovf` are specified, `timeout` wins.\n\nNote that `clock_cntr_ovf` must be greater than `clock_cntr_stop`,\nor the measurement will time out before it begins accepting stop pulses.\n\n    measure(simulate=False)\n\nRuns a single measurement, polling the chip INT1 pin until it indicates completion.\n(This should really be an interrupt.)\nWill time out after 0.1 seconds if measurement doesn't complete.\nIf it does complete, calls `read_regs1()` and `compute_tofs()` so that both raw and processed data are available.\nIf `simulate=True`, then generates START and STOP signals to send to the chip (for testing when your actual signal source is not yet available);\nthis requires that the appropriate RPi pins be connected to START and STOP.\n\n    off()\n\nAsserts reset. This will terminate any measurement in progress, and make the chip unresponsive to SPI.\n\n    clear_status(verbose=False,force=False)\n\nClears any set interrupt status register bits to prepare for next measurement.\nThis isn't supposed to be necessary, but I was having problems without doing it.\nIf `verbose==True`, prints detailed step-by-step results for debugging.\nIf `force==True`, does a write even if none of the bits appears to be set.\n\n    set_SPI_clock(speed)\n\nAttempts to set the SPI interface clock speed to `speed` (in Hz).\nMinimum legal value is 50000 (50 kHz), and maximum is 25000000 (25 MHz).\nThe SPI clock is a hardware division of the CPU clock, so there are two important things to note.\n(1) The exact clock speed set may be restricted (by hardware) to only certain values in that range, so you may not get exactly what you ask for.\n(2) The SPI clock will slow down or speed up if the CPU clock does (for example, for thermal management, turbo mode, or due to user over- or under-clocking of the Raspberry Pi).\n The CPU (and the SPI driver, and this module) can not tell what the CPU clock speed is, so there is no way to compensate for this in software.\nTherefore, it's probably a bad idea to set the maximum SPI speed if you know that your CPU will be overclocked, since that might result in a speed that exceeds the chip specs.\nBut all this should mostly be invisible to the user, as it only affects SPI communication speed, and does not affect performance of the TDC7201 measurements (unless the TDC7201 is also being clocked by some submultiple of the Pi clock, which is a really really bad idea).\n\nThe casual user should be able to get by with only the above methods; the following low-level methods give more detailed access to the hardware, but you'll need to know what you're doing.\n\n    write8(reg,val)\n\nLow-level routine to write a single 8-bit value to an 8-bit chip register.\n\n    read8(reg)\n\nLow-level routine to read a single 8-bit value from an 8-bit chip register.\n\n    write24(reg,val)\n\nLow-level routine to write a 24-bit value to a 24-bit chip register.\n\n    read24(reg)\n\nLow-level routine to read a 24-bit value from a 24-bit chip register.\n\n    read_regs1()\n\nRead all of the side 1 chip registers (including measurement results) into the tdc.reg1 list. (There should be a similar method to read the side 2 registers, but there isn't yet.)\n\n    print_regs1()\n\nPrint the internal copy of the side 1 chip registers. Note that, if this is not immediately preceded by `read_regs1()`, the internal copy and the actual chip registers may be out of sync.\n\n    tof_mm2(time1,time2,count)\n\nCompute time-of-flight given Measurement Mode 2 data for two adjacent stops.\n\n    compute_tofs()\n\nCheck how many pulses we got, and compute the inter-pulse time for each adjacent pair.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/HowardALandman/QTD/src/tdc7201", "keywords": "", "license": "GPLv3+", "maintainer": "", "maintainer_email": "", "name": "tdc7201", "package_url": "https://pypi.org/project/tdc7201/", "platform": "", "project_url": "https://pypi.org/project/tdc7201/", "project_urls": {"Homepage": "https://github.com/HowardALandman/QTD/src/tdc7201"}, "release_url": "https://pypi.org/project/tdc7201/0.3b2/", "requires_dist": ["RPi.GPIO (>=0.5)", "spidev (>=3.4)"], "requires_python": "", "summary": "Raspberry Pi driver for Texas Instruments TDC7201 Time-to-Digital-Converter chip", "version": "0.3b2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>TDC7201 driver for Raspberry Pi</h1>\n<p>This project contains a python3 module for interfacing with the Texas Instruments TDC7201 Time-to-Digital-Converter chip through SPI.\nAs much as possible, it hides the internal implementation details (like SPI transactions, and chip registers and their field encodings) from the user.</p>\n<p>All code is GPLv3+ licensed unless explicitly stated otherwise.</p>\n<p>For more information on the chip, see <a href=\"https://www.ti.com/product/TDC7201\" rel=\"nofollow\">https://www.ti.com/product/TDC7201</a></p>\n<h2>Usage</h2>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">tdc7201</span>\n<span class=\"n\">tdc</span> <span class=\"o\">=</span> <span class=\"n\">tdc7201</span><span class=\"o\">.</span><span class=\"n\">TDC7201</span><span class=\"p\">()</span> <span class=\"c1\"># Create TDC object with SPI interface.</span>\n<span class=\"n\">tdc</span><span class=\"o\">.</span><span class=\"n\">initGPIO</span><span class=\"p\">()</span> <span class=\"c1\"># Set pin directions and default values for non-SPI signals.</span>\n<span class=\"n\">tdc</span><span class=\"o\">.</span><span class=\"n\">set_SPI_clock_speed</span><span class=\"p\">(</span><span class=\"mi\">12500000</span><span class=\"p\">)</span>\n<span class=\"n\">tdc</span><span class=\"o\">.</span><span class=\"n\">on</span><span class=\"p\">(</span><span class=\"n\">meas_mode</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"n\">num_stop</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"n\">clock_cntr_stop</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">timeout</span><span class=\"o\">=</span><span class=\"mf\">0.0005</span><span class=\"p\">)</span>\n<span class=\"n\">status</span> <span class=\"o\">=</span> <span class=\"n\">tdc</span><span class=\"o\">.</span><span class=\"n\">measure</span><span class=\"p\">(</span><span class=\"n\">simulate</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">tdc</span><span class=\"o\">.</span><span class=\"n\">off</span><span class=\"p\">()</span>\n</pre>\n<h2>Settings</h2>\n<p>Hardware pin assignments are done in <code>initGPIO()</code>, which should only be called once.\nMost other important parameters are set in the <code>on()</code> method,\nsince the chip can only be reconfigured after it has come out of reset.\nIf you want to change parameters, it is cleanest to turn the chip <code>off()</code>, and then <code>on()</code> again with the new parameters.</p>\n<h2>Methods</h2>\n<pre><code>initGPIO(enable=12,osc_enable=16,trig1=7,int1=37,trig2=11,int2=32,start=18,stop=22,verbose=False)\n</code></pre>\n<p>Assigns and initializes all the non-SPI pins.\nYour actual hardware (wiring between RPi and chip) needs to match this setup.\nNo arguments are required, but the defaults match my prototype and are somewhat arbitrary.\nYou can see all assignments by calling with <code>verbose=True</code>.\nPin numbers follow <code>GPIO.BOARD</code> conventions,\ni.e. they are the pin numbers on the 2x20 pin heeader.\nOnly 3 pins (<code>enable</code>,<code>trig1</code>,<code>int1</code>) are absolutely required;\nthe others can be skipped by assigning <code>None</code> to them.\nIf <code>osc_enable</code> is <code>None</code>, then there will be no signal to turn an external clock on or off; this is OK if you supply the chip clock yourself.\nIf <code>trig2</code> and/or <code>int2</code> is <code>None</code>, then side 2 of the chip will not work correctly, but side 1 still will.\nThe <code>start</code> and <code>stop</code> pins are only required if you want the Raspberry Pi to generate START and STOP signals for testing, i.e. if you plan to run <code>tdc.measure(simulate=True)</code>.\nIf you are hooked up to real signals to measure, then you can and should set <code>start=None,stop=None</code>.</p>\n<pre><code>on(force_cal=True,meas_mode=2,falling=False,calibration2_periods=10,avg_cycles=1,num_stop=1,clock_cntr_stop=0,clock_cntr_ovf=0xFFFF,timeout=None)\n</code></pre>\n<p>Takes the chip out of reset and set up various control parameters.</p>\n<ul>\n<li><code>force_cal</code> -\nIf <code>True</code>, will recalibrate the chip after every attempted measurement.\nThis is recommended (and, in this version, required and default).\nIf <code>False</code>, will only recalibrate after a \"successful\" measurement,\nwith timeouts and some other results considered unsuccessful.\n(This currently does not work.)</li>\n<li><code>meas_mode</code> -\nSets the measurement mode.\nMode 1 is recommended for times less than 2000 nS; mode 2 for greater.\n(In this release only mode 2 is fully supported, and is therefore the default.)</li>\n<li><code>falling</code> -\nIf <code>True</code>, sets the chip to trigger on falling edges of START and STOP.\nThe default is <code>False</code>, which has it trigger on rising edges.</li>\n<li><code>calibration2_periods</code> - The number of clock cycles to recalibrate for. The allowed values are 2, 10 (hardware default), 20, and 40.</li>\n<li><code>avg_cycles</code> - The number of measurements to average over. The allowed values are 1, 2, 4, 8, 16, 32, 64, and 128. The default is 1, which means no averaging. If you use anything larger, the chip will run that many measurements and then report only the average values. This can be useful in a noisy environment.</li>\n<li><code>num_stop</code> -\nThe chip starts timing on a pulse on the START pin, and then can record timings for up to 5 pulses on the STOP pin.\nAllowed values are 1, 2, 3, 4, 5.\nThe default is 1, which means the measurement will terminate as soon as a single STOP pulse is received.</li>\n<li><code>clock_cntr_stop = N</code> - If N is non-zero, the chip will ignore STOP pulses for N clock cycles after START.</li>\n<li><code>clock_cntr_ovf = N</code> - The chip will end measurement (\"time out\" or \"clock counter overflow\") after N clock cycles even if <code>num_stop</code> STOP pulses have not been received.\nDefault (and maximum) is 65535 = 0xFFFF.</li>\n<li><code>timeout = T</code> - You can also specify the overflow period as a time in seconds. For example, if T is 0.0005, the timeout period will be 500 microseconds. If both <code>timeout</code> and <code>clock_cntr_ovf</code> are specified, <code>timeout</code> wins.</li>\n</ul>\n<p>Note that <code>clock_cntr_ovf</code> must be greater than <code>clock_cntr_stop</code>,\nor the measurement will time out before it begins accepting stop pulses.</p>\n<pre><code>measure(simulate=False)\n</code></pre>\n<p>Runs a single measurement, polling the chip INT1 pin until it indicates completion.\n(This should really be an interrupt.)\nWill time out after 0.1 seconds if measurement doesn't complete.\nIf it does complete, calls <code>read_regs1()</code> and <code>compute_tofs()</code> so that both raw and processed data are available.\nIf <code>simulate=True</code>, then generates START and STOP signals to send to the chip (for testing when your actual signal source is not yet available);\nthis requires that the appropriate RPi pins be connected to START and STOP.</p>\n<pre><code>off()\n</code></pre>\n<p>Asserts reset. This will terminate any measurement in progress, and make the chip unresponsive to SPI.</p>\n<pre><code>clear_status(verbose=False,force=False)\n</code></pre>\n<p>Clears any set interrupt status register bits to prepare for next measurement.\nThis isn't supposed to be necessary, but I was having problems without doing it.\nIf <code>verbose==True</code>, prints detailed step-by-step results for debugging.\nIf <code>force==True</code>, does a write even if none of the bits appears to be set.</p>\n<pre><code>set_SPI_clock(speed)\n</code></pre>\n<p>Attempts to set the SPI interface clock speed to <code>speed</code> (in Hz).\nMinimum legal value is 50000 (50 kHz), and maximum is 25000000 (25 MHz).\nThe SPI clock is a hardware division of the CPU clock, so there are two important things to note.\n(1) The exact clock speed set may be restricted (by hardware) to only certain values in that range, so you may not get exactly what you ask for.\n(2) The SPI clock will slow down or speed up if the CPU clock does (for example, for thermal management, turbo mode, or due to user over- or under-clocking of the Raspberry Pi).\nThe CPU (and the SPI driver, and this module) can not tell what the CPU clock speed is, so there is no way to compensate for this in software.\nTherefore, it's probably a bad idea to set the maximum SPI speed if you know that your CPU will be overclocked, since that might result in a speed that exceeds the chip specs.\nBut all this should mostly be invisible to the user, as it only affects SPI communication speed, and does not affect performance of the TDC7201 measurements (unless the TDC7201 is also being clocked by some submultiple of the Pi clock, which is a really really bad idea).</p>\n<p>The casual user should be able to get by with only the above methods; the following low-level methods give more detailed access to the hardware, but you'll need to know what you're doing.</p>\n<pre><code>write8(reg,val)\n</code></pre>\n<p>Low-level routine to write a single 8-bit value to an 8-bit chip register.</p>\n<pre><code>read8(reg)\n</code></pre>\n<p>Low-level routine to read a single 8-bit value from an 8-bit chip register.</p>\n<pre><code>write24(reg,val)\n</code></pre>\n<p>Low-level routine to write a 24-bit value to a 24-bit chip register.</p>\n<pre><code>read24(reg)\n</code></pre>\n<p>Low-level routine to read a 24-bit value from a 24-bit chip register.</p>\n<pre><code>read_regs1()\n</code></pre>\n<p>Read all of the side 1 chip registers (including measurement results) into the tdc.reg1 list. (There should be a similar method to read the side 2 registers, but there isn't yet.)</p>\n<pre><code>print_regs1()\n</code></pre>\n<p>Print the internal copy of the side 1 chip registers. Note that, if this is not immediately preceded by <code>read_regs1()</code>, the internal copy and the actual chip registers may be out of sync.</p>\n<pre><code>tof_mm2(time1,time2,count)\n</code></pre>\n<p>Compute time-of-flight given Measurement Mode 2 data for two adjacent stops.</p>\n<pre><code>compute_tofs()\n</code></pre>\n<p>Check how many pulses we got, and compute the inter-pulse time for each adjacent pair.</p>\n\n          </div>"}, "last_serial": 7183764, "releases": {"0.1b1": [{"comment_text": "", "digests": {"md5": "04e7769772b1ea415d8655b2323512d4", "sha256": "945355d6fa461f30b090243f5e81dcee80cae904f5e4c2902a0dcdc97bf27dd2"}, "downloads": -1, "filename": "tdc7201-0.1b1-py3-none-any.whl", "has_sig": false, "md5_digest": "04e7769772b1ea415d8655b2323512d4", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 10013, "upload_time": "2020-05-02T21:18:45", "upload_time_iso_8601": "2020-05-02T21:18:45.009272Z", "url": "https://files.pythonhosted.org/packages/65/1d/a0cb69622311d385e3d665056f58fc53719d93d6624e855f97adcca394eb/tdc7201-0.1b1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "63714986746972c473264203d378dd5a", "sha256": "3493e2ce2a49e559695d2f532b35336b1fd00cdf4300d0ad9018094b7401fa19"}, "downloads": -1, "filename": "tdc7201-0.1b1.tar.gz", "has_sig": false, "md5_digest": "63714986746972c473264203d378dd5a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10160, "upload_time": "2020-05-02T21:18:47", "upload_time_iso_8601": "2020-05-02T21:18:47.212942Z", "url": "https://files.pythonhosted.org/packages/d8/ce/9fbf4c9ff0c33249e642430877886570203d14dc14f754f1e4079ca427a5/tdc7201-0.1b1.tar.gz", "yanked": false}], "0.2b9": [{"comment_text": "", "digests": {"md5": "be72336c9a89967113c2857765def405", "sha256": "a1c9f8ba54073f295c05e67894ba6295dae2a5843819bbe54c40dbc4acb91978"}, "downloads": -1, "filename": "tdc7201-0.2b9-py3-none-any.whl", "has_sig": false, "md5_digest": "be72336c9a89967113c2857765def405", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 13566, "upload_time": "2020-05-06T14:44:45", "upload_time_iso_8601": "2020-05-06T14:44:45.395530Z", "url": "https://files.pythonhosted.org/packages/2b/b8/3e0c3af2f92ed92630e5d65388b2bce154137da3ad57608781023b05d062/tdc7201-0.2b9-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "66439147bc4b2b2c4a03907d6806386b", "sha256": "d562ef49e08075e3972cf41690d2845fc9d2f6dc4c46b06ae3cb079fe8a05f90"}, "downloads": -1, "filename": "tdc7201-0.2b9.tar.gz", "has_sig": false, "md5_digest": "66439147bc4b2b2c4a03907d6806386b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16494, "upload_time": "2020-05-06T14:44:46", "upload_time_iso_8601": "2020-05-06T14:44:46.663612Z", "url": "https://files.pythonhosted.org/packages/90/62/f16e6a2da964036a629d937be599af1028652cfd2858e42d7533655bec3c/tdc7201-0.2b9.tar.gz", "yanked": false}], "0.3b2": [{"comment_text": "", "digests": {"md5": "f6ed4d03a54fe598dec8c091d8afd6fe", "sha256": "b8ab20eb94471fec3714098bd29a1fa44a1a6cca27c0f814af558977e8b0678c"}, "downloads": -1, "filename": "tdc7201-0.3b2-py3-none-any.whl", "has_sig": false, "md5_digest": "f6ed4d03a54fe598dec8c091d8afd6fe", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14621, "upload_time": "2020-05-06T21:55:13", "upload_time_iso_8601": "2020-05-06T21:55:13.611887Z", "url": "https://files.pythonhosted.org/packages/89/5f/9b5f04c3b88b9fb259c0d5cfa3ee68c09a6aa499ceea193f1f979dc0643d/tdc7201-0.3b2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9135acb1cf3d839a9c060e264880be23", "sha256": "6ec9e98ee181ec457cf3b7f033caf0d01e64b716961f7eccc7190f8c65a718f3"}, "downloads": -1, "filename": "tdc7201-0.3b2.tar.gz", "has_sig": false, "md5_digest": "9135acb1cf3d839a9c060e264880be23", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18090, "upload_time": "2020-05-06T21:55:15", "upload_time_iso_8601": "2020-05-06T21:55:15.184571Z", "url": "https://files.pythonhosted.org/packages/8d/14/75cccd52c7a262ab45009365fe3a5c8c0558589febe3a98ddbef348d5a96/tdc7201-0.3b2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f6ed4d03a54fe598dec8c091d8afd6fe", "sha256": "b8ab20eb94471fec3714098bd29a1fa44a1a6cca27c0f814af558977e8b0678c"}, "downloads": -1, "filename": "tdc7201-0.3b2-py3-none-any.whl", "has_sig": false, "md5_digest": "f6ed4d03a54fe598dec8c091d8afd6fe", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 14621, "upload_time": "2020-05-06T21:55:13", "upload_time_iso_8601": "2020-05-06T21:55:13.611887Z", "url": "https://files.pythonhosted.org/packages/89/5f/9b5f04c3b88b9fb259c0d5cfa3ee68c09a6aa499ceea193f1f979dc0643d/tdc7201-0.3b2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9135acb1cf3d839a9c060e264880be23", "sha256": "6ec9e98ee181ec457cf3b7f033caf0d01e64b716961f7eccc7190f8c65a718f3"}, "downloads": -1, "filename": "tdc7201-0.3b2.tar.gz", "has_sig": false, "md5_digest": "9135acb1cf3d839a9c060e264880be23", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18090, "upload_time": "2020-05-06T21:55:15", "upload_time_iso_8601": "2020-05-06T21:55:15.184571Z", "url": "https://files.pythonhosted.org/packages/8d/14/75cccd52c7a262ab45009365fe3a5c8c0558589febe3a98ddbef348d5a96/tdc7201-0.3b2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:57:15 2020"}