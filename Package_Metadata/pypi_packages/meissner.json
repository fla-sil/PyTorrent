{"info": {"author": "Aaron Esau", "author_email": "python@aaronesau.com", "bugtrack_url": null, "classifiers": [], "description": "# About\n\nMeissner Lop is a dictionary-based mutation-based exploit fuzzer for XSS.\n\n![xss](https://raw.githubusercontent.com/Arinerron/meissner/master/tests/run.gif)\n\n# Installation\n### Automatic\n\n```bash\npip3 install meissner\n```\n\n### Manual\n\n```\ngit clone https://github.com/arinerron/meissner.git\ncd meissner\nsudo ./setup.py install\n```\n\n# Usage\n\n```\nusage: meissner [-h] [--no-ansi] [--log-level LOG_LEVEL] [--url URL] [--dictionary DICTIONARY] [--threads THREADS] [--filter FILTER] [--engine ENGINE] [cmd [cmd ...]]\n\nMeissner Lop - XSS Filter Bypass Exploit Fuzzer\n\npositional arguments:\n  cmd                   the command to execute, where {xss} is the injection point\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --no-ansi, -c         disable ANSI coloring on all output\n  --log-level LOG_LEVEL, -v LOG_LEVEL\n                        set logging level\n  --url URL, --uri URL, -u URL\n                        use a URL harness, where {xss} is the injection point\n  --dictionary DICTIONARY, --dict DICTIONARY, -d DICTIONARY\n                        the Meissner mutation dictionary to use\n  --threads THREADS, --threads-count THREADS, -t THREADS\n                        the number of threads allocated to use for engines\n  --filter FILTER, -f FILTER\n                        pass the input through a filter before the program\n  --engine ENGINE, --browser ENGINE, -e ENGINE\n                        the browser rendering engine to use\n```\n\n## General\n\nWhen entering a URL, simply put the string `{xss}` where you would like to insert XSS payloads. For example:\n\n```bash\nmeissner --url 'https://example.com/vulnerable.php?query={xss}'\n```\n\nAdditionally, if you have a script that outputs the generated HTML, Meissner Lop can work with you. For example, if a mutation XSS CTF challenge provides source and you setup a local instance at `https://localhost:8080/xss.php`, you may use that as the URL. It is more efficient to run instances locally as HTTP requests will not have to travel across the internet.\n\nMeissner can also provide XSS payloads through `argv` if you have an executable that generates HTML output. This option is by far the most efficient as it removes need for HTTP servers/clients and networking.\n\nFor example, if your executable is called `./give-me-flag`, you may use the tool like:\n\n```bash\nmeissner -- ./give-me-flag '{xss}'\n```\n\nIf the `{xss}` argument is not found in the arguments, Meissner will assume that you would like payloads to be passed through stdin/stdout.\n\n# Limitations\n\n- The tool does not attempt to abide by any character or length restrictions. This does not mean that it will not work for your specific XSS vulnerability, however; just that it may take longer to find something as the tool is not specifically trying to abide by restrictions.\n- Meissner does not attempt to parse HTML and bypass filters in that way; rather, it is a \"dumb\" fuzzer and prioritizes based on cases it considers interesting. However, it can brute-force XSS challenges MUCH faster than you can. I'd recommend running this tool in the background while you manually solve challenges.\n- The fuzzer may take the fun of the challenge away from you. If you are playing a CTF for fun, then solve the challenge by hand! ... unless you get some sort of odd satisfaction from using tools to solve all your problems like I do--in which case, by all means, use this tool.\n\n# TODO\n- double URL encoding\n\n- New features\n    - more intelligent fuzzing\n        - detect \"interesting\" cases and prioritize them\n    - more mutations\n        - randomly pick bytes to encode with HTML entities\n    - make HTTP requests more flexible\n        - random user agent generation\n        - `POST`, `PUT`, etc requests\n        - cookies\n        - proxies\n        - requests from a file\n    - support custom filters through Python files (use stdin/stdout)\n    - if `{xss}`not found in stdin/stdout, write through stdin\n    - saving and restoring progress\n- Fix bugs / race conditions (search for `XXX: ` in the code!)\n    - expose some of the hardcoded timeouts to the CLI\n- Write documentation\n- Create more / better dictionaries\n- Optimizations!\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Arinerron/meissner", "keywords": "ctf xss hacking mutation fuzzer fuzzing fuzz dictionary attack attacking injection scripting", "license": "", "maintainer": "", "maintainer_email": "", "name": "meissner", "package_url": "https://pypi.org/project/meissner/", "platform": "", "project_url": "https://pypi.org/project/meissner/", "project_urls": {"Homepage": "https://github.com/Arinerron/meissner"}, "release_url": "https://pypi.org/project/meissner/1.0.2/", "requires_dist": ["smartbytes", "selenium", "requests"], "requires_python": ">=3.6", "summary": "a dictionary-based XSS mutation fuzzer", "version": "1.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>About</h1>\n<p>Meissner Lop is a dictionary-based mutation-based exploit fuzzer for XSS.</p>\n<p><img alt=\"xss\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/23d6f059d77cbed29c40331183270115adc8c56c/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f4172696e6572726f6e2f6d656973736e65722f6d61737465722f74657374732f72756e2e676966\"></p>\n<h1>Installation</h1>\n<h3>Automatic</h3>\n<pre>pip3 install meissner\n</pre>\n<h3>Manual</h3>\n<pre><code>git clone https://github.com/arinerron/meissner.git\ncd meissner\nsudo ./setup.py install\n</code></pre>\n<h1>Usage</h1>\n<pre><code>usage: meissner [-h] [--no-ansi] [--log-level LOG_LEVEL] [--url URL] [--dictionary DICTIONARY] [--threads THREADS] [--filter FILTER] [--engine ENGINE] [cmd [cmd ...]]\n\nMeissner Lop - XSS Filter Bypass Exploit Fuzzer\n\npositional arguments:\n  cmd                   the command to execute, where {xss} is the injection point\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --no-ansi, -c         disable ANSI coloring on all output\n  --log-level LOG_LEVEL, -v LOG_LEVEL\n                        set logging level\n  --url URL, --uri URL, -u URL\n                        use a URL harness, where {xss} is the injection point\n  --dictionary DICTIONARY, --dict DICTIONARY, -d DICTIONARY\n                        the Meissner mutation dictionary to use\n  --threads THREADS, --threads-count THREADS, -t THREADS\n                        the number of threads allocated to use for engines\n  --filter FILTER, -f FILTER\n                        pass the input through a filter before the program\n  --engine ENGINE, --browser ENGINE, -e ENGINE\n                        the browser rendering engine to use\n</code></pre>\n<h2>General</h2>\n<p>When entering a URL, simply put the string <code>{xss}</code> where you would like to insert XSS payloads. For example:</p>\n<pre>meissner --url <span class=\"s1\">'https://example.com/vulnerable.php?query={xss}'</span>\n</pre>\n<p>Additionally, if you have a script that outputs the generated HTML, Meissner Lop can work with you. For example, if a mutation XSS CTF challenge provides source and you setup a local instance at <code>https://localhost:8080/xss.php</code>, you may use that as the URL. It is more efficient to run instances locally as HTTP requests will not have to travel across the internet.</p>\n<p>Meissner can also provide XSS payloads through <code>argv</code> if you have an executable that generates HTML output. This option is by far the most efficient as it removes need for HTTP servers/clients and networking.</p>\n<p>For example, if your executable is called <code>./give-me-flag</code>, you may use the tool like:</p>\n<pre>meissner -- ./give-me-flag <span class=\"s1\">'{xss}'</span>\n</pre>\n<p>If the <code>{xss}</code> argument is not found in the arguments, Meissner will assume that you would like payloads to be passed through stdin/stdout.</p>\n<h1>Limitations</h1>\n<ul>\n<li>The tool does not attempt to abide by any character or length restrictions. This does not mean that it will not work for your specific XSS vulnerability, however; just that it may take longer to find something as the tool is not specifically trying to abide by restrictions.</li>\n<li>Meissner does not attempt to parse HTML and bypass filters in that way; rather, it is a \"dumb\" fuzzer and prioritizes based on cases it considers interesting. However, it can brute-force XSS challenges MUCH faster than you can. I'd recommend running this tool in the background while you manually solve challenges.</li>\n<li>The fuzzer may take the fun of the challenge away from you. If you are playing a CTF for fun, then solve the challenge by hand! ... unless you get some sort of odd satisfaction from using tools to solve all your problems like I do--in which case, by all means, use this tool.</li>\n</ul>\n<h1>TODO</h1>\n<ul>\n<li>\n<p>double URL encoding</p>\n</li>\n<li>\n<p>New features</p>\n<ul>\n<li>more intelligent fuzzing\n<ul>\n<li>detect \"interesting\" cases and prioritize them</li>\n</ul>\n</li>\n<li>more mutations\n<ul>\n<li>randomly pick bytes to encode with HTML entities</li>\n</ul>\n</li>\n<li>make HTTP requests more flexible\n<ul>\n<li>random user agent generation</li>\n<li><code>POST</code>, <code>PUT</code>, etc requests</li>\n<li>cookies</li>\n<li>proxies</li>\n<li>requests from a file</li>\n</ul>\n</li>\n<li>support custom filters through Python files (use stdin/stdout)</li>\n<li>if <code>{xss}</code>not found in stdin/stdout, write through stdin</li>\n<li>saving and restoring progress</li>\n</ul>\n</li>\n<li>\n<p>Fix bugs / race conditions (search for <code>XXX:</code> in the code!)</p>\n<ul>\n<li>expose some of the hardcoded timeouts to the CLI</li>\n</ul>\n</li>\n<li>\n<p>Write documentation</p>\n</li>\n<li>\n<p>Create more / better dictionaries</p>\n</li>\n<li>\n<p>Optimizations!</p>\n</li>\n</ul>\n\n          </div>"}, "last_serial": 6953883, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "0ab36fd2af803017728c2a8df2e9f90b", "sha256": "de70c2306a497ba460cfa194088a5001ffc93619b76c01002add933be62456bb"}, "downloads": -1, "filename": "meissner-1.0.0-py3-none-any.whl", "has_sig": true, "md5_digest": "0ab36fd2af803017728c2a8df2e9f90b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 7678, "upload_time": "2020-04-05T00:02:06", "upload_time_iso_8601": "2020-04-05T00:02:06.122727Z", "url": "https://files.pythonhosted.org/packages/97/23/c034729f377d26d8a67a692ed74c2803a78bcb89babdf9010d4f86e33d60/meissner-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b66abeacc57b1965205b3c4e0c1ba2af", "sha256": "5aa202fde537bc2f453e4ae0a6cf4871928f372df5898a28e34cbf47204965cb"}, "downloads": -1, "filename": "meissner-1.0.0.tar.gz", "has_sig": true, "md5_digest": "b66abeacc57b1965205b3c4e0c1ba2af", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 6054, "upload_time": "2020-04-05T00:02:08", "upload_time_iso_8601": "2020-04-05T00:02:08.438808Z", "url": "https://files.pythonhosted.org/packages/ec/13/659655c3a31677fb579938b0aba66d71fbc9ace39d6171b9062c6fcafd1e/meissner-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "4b77d9cce6618597e83b45c729451c7d", "sha256": "e35611015de668a959e6fc742809501ae86f2631a9d420b9b89c00bc68155a0f"}, "downloads": -1, "filename": "meissner-1.0.1-py3-none-any.whl", "has_sig": true, "md5_digest": "4b77d9cce6618597e83b45c729451c7d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 16260, "upload_time": "2020-04-05T03:41:17", "upload_time_iso_8601": "2020-04-05T03:41:17.344889Z", "url": "https://files.pythonhosted.org/packages/23/65/56981622b2770fa18ce8c8f02a1814e93ca573ccae382479a469a0c22ce3/meissner-1.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6997b8920c5b3ae15af808d7ee97c4c1", "sha256": "43dc8d71c76f8a1137c665618bd48dad883963f3360430984147b9f36167bb66"}, "downloads": -1, "filename": "meissner-1.0.1.tar.gz", "has_sig": true, "md5_digest": "6997b8920c5b3ae15af808d7ee97c4c1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 15169, "upload_time": "2020-04-05T03:41:18", "upload_time_iso_8601": "2020-04-05T03:41:18.519838Z", "url": "https://files.pythonhosted.org/packages/8f/5d/ce237eea4fa29d7f4dc13d3439c512d8198d5d95989a9b1337ebb8b470d3/meissner-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "6667d5c9e98a03bff980ee82e0f803af", "sha256": "e068de5754cb3384b7e44df05bf770e2a65e7d4368c245a041048bfa8453c025"}, "downloads": -1, "filename": "meissner-1.0.2-py3-none-any.whl", "has_sig": true, "md5_digest": "6667d5c9e98a03bff980ee82e0f803af", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 16627, "upload_time": "2020-04-05T03:56:26", "upload_time_iso_8601": "2020-04-05T03:56:26.942121Z", "url": "https://files.pythonhosted.org/packages/9f/4d/74d74c75c564df0dadd0e10b80fccc6931a18ab9e06f1e3f0713fa58afb5/meissner-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b8c04dea6c59af649e9d6a236caf47f9", "sha256": "1f614db7d5a6d4ef8fd73397bef703d17b79c53ab14b46aa31bbd4a931995944"}, "downloads": -1, "filename": "meissner-1.0.2.tar.gz", "has_sig": true, "md5_digest": "b8c04dea6c59af649e9d6a236caf47f9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 15324, "upload_time": "2020-04-05T03:56:28", "upload_time_iso_8601": "2020-04-05T03:56:28.369418Z", "url": "https://files.pythonhosted.org/packages/da/6e/1d5e6150f1b2ab41b6715b5b627afee65569848425bb8e0c219b970e3821/meissner-1.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6667d5c9e98a03bff980ee82e0f803af", "sha256": "e068de5754cb3384b7e44df05bf770e2a65e7d4368c245a041048bfa8453c025"}, "downloads": -1, "filename": "meissner-1.0.2-py3-none-any.whl", "has_sig": true, "md5_digest": "6667d5c9e98a03bff980ee82e0f803af", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 16627, "upload_time": "2020-04-05T03:56:26", "upload_time_iso_8601": "2020-04-05T03:56:26.942121Z", "url": "https://files.pythonhosted.org/packages/9f/4d/74d74c75c564df0dadd0e10b80fccc6931a18ab9e06f1e3f0713fa58afb5/meissner-1.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b8c04dea6c59af649e9d6a236caf47f9", "sha256": "1f614db7d5a6d4ef8fd73397bef703d17b79c53ab14b46aa31bbd4a931995944"}, "downloads": -1, "filename": "meissner-1.0.2.tar.gz", "has_sig": true, "md5_digest": "b8c04dea6c59af649e9d6a236caf47f9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 15324, "upload_time": "2020-04-05T03:56:28", "upload_time_iso_8601": "2020-04-05T03:56:28.369418Z", "url": "https://files.pythonhosted.org/packages/da/6e/1d5e6150f1b2ab41b6715b5b627afee65569848425bb8e0c219b970e3821/meissner-1.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:56:26 2020"}