{"info": {"author": "Oren Ben-Kiki", "author_email": "oren@ben-kiki.org", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Scientific/Engineering :: Bio-Informatics", "Topic :: Software Development :: Libraries"], "description": "Metacell - Single-cell RNA Sequencing Analysis\n==============================================\n\n.. image:: https://travis-ci.org/tanaylab/metacell.py.svg?branch=master\n    :target: https://travis-ci.org/tanaylab/metacell.py\n    :alt: Build Status\n\n.. image:: https://readthedocs.org/projects/metacellpy/badge/?version=latest\n    :target: https://metacellpy.readthedocs.io/en/latest/?badge=latest\n    :alt: Documentation Status\n\nThe metacell package implements the metacell algorithm for single-cell RNA sequencing (scRNA-seq)\ndata analysis.\n\nThe `original <https://www.biorxiv.org/content/10.1101/437665v1>`_ metacell algorithm was\nimplemented in R. In contrast, the Python package described here implements an `improved\n<https://todo/>` version, which uses improved internal algorithms and supports much larger data sets\n(millions of cells).\n\nMetacell Analysis\n-----------------\n\nNaively, scRNA_seq data is a set of cell profiles, where for each one, for each gene, we get a count\nof the mRNA molecules that existed in the cell for that gene. This serves as an indicator of how\n\"expressed\" or \"active\" the gene is.\n\nAs in any real world technology, the raw data may suffer from technical artifacts (counting the\nmolecules of two cells in one profile, counting the molecules from a ruptured cells, counting only\nthe molecules from the cell nucleus, etc.). This requires pruning the raw data to exclude such\nartifacts. TODO: Create view should consider these issues.\n\nThe current technology scRNA-seq data is also very sparse (typically <10%, sometimes even <5% of the\nRNA molecules are counted). This introduces large sampling variance on top of the original signal,\nwhich itself contains significant inherent biological noise.\n\nAnalyzing scRNA-seq data therefore requires processing the profiles in bulk. Classically, this has\nbeen done by directly clustering the cells using various methods.\n\nIn contrast, the metacell approach groups together profiles of the \"same\" biological state into\ngroups with the *minimal* number of profiles (~100) needed for computing robust statistics (in\nparticular, mean gene expression). Each such group is a single \"metacell\".\n\nBy summing profiles together, each metacell greatly reduces the sampling variance, and provides a\nmore robust estimation of some transcription state. In particular, a metacell is not a cell type\n(multiple metacells may belong to the same type), and is not a parametric model of the cell state.\n\nThe metacells should therefore be further analyzed using additional methods to classify cell types,\ndetect cell trajectories and/or lineage, build parametric models for cell behavior, etc. Using\nmetacells as input for such analysis techniques should benefit both from the more robust, less noisy\ninput; and from the (~100-fold) reduction in the number of profiles to analyze.\n\nAn obvious technique is to recursively group the metacells into larger groups, and investigate the\nresulting clustering hierarchy. Methods for further analysis of the data may choose to build upon\nthis readily available hierarchy (which is also provided by this package).\n\nUsage\n-----\n\nInstallation\n............\n\nGiven Python version 3.6 and above, run ``pip install --user metacell`` (or, ``sudo pip install\nmetacell`` if you have ``sudo`` privileges). This will install this package and two scripts:\n``metacell_flow`` and ``metacell_call``.\n\nThe metacell package is built using the `DynaMake <https://pypi.org/project/dynamake/>`_ package.\nThe ``metacell_flow`` script is simply the ``dynamake`` script, pre-loaded with the metacell build\nsteps, and ``metacell_call`` is simply the ``dynacall`` script, pre-loaded with the metacell\ncomputation functions.\n\nImporting\n.........\n\nTo use the package, create a directory somewhere with a large amount of available space (for ~2M\ncells, metacell required up to 200GB of disk space). If using a servers cluster, on some shared file\nsystem, and provide a DynaMake configuration file with an appropriate ``run_prefix`` for\ndistributing jobs across the cluster; see the DynaMake documentation for details.\n\nCreate a ``raw`` sub-directory and download the raw_data_ into it. Then, run ``metacell_import`` to\nimport the gene and cell data into the fast-access format used by the metacell package. This is\nunfortunately a slow process (in particular, the delaning step). Luckily, you only need to do this\nonce.\n\nThis will create the following directories:\n\n``genes``\n    Describes the genes used in the data.\n\n``cells``\n    A COLLECTION_ profiles directory containing all the imported cells.\n\nGrouping\n........\n\nTODO: Running ``metacell_group``.\n\nTODO: ``excluded_genes_names.txt``, ``forbidden_genes_names.txt``.\n\nZoning\n......\n\nTODO: Running ``metacell_zone``.\n\nAnalysis\n........\n\nTODO: Running ``metacell_dash``.\n\nTODO: ``colors`` directory.\n\nDirectory Structure\n-------------------\n\nThe provided automated workflow uses the following directory structure. The specifics of each\ndirectory type are provided further below.\n\n``ROOT``\n    A directory which is typically named after the data source (``PBMC``, ``MOCA``, ``HCA``, etc.).\n    Will contain:\n\n    ``raw``\n        A directory containing the raw data from the data source. Should contain one or more:\n\n        ``name``\n            A directory containing 10X_ or MOCA_ data.\n\n        ``name.h5``\n            An HDF file containing HCA_ data.\n\n    ``std``\n        The first processing step will convert the ``raw`` data to the standard input format. The\n        result will contain:\n\n        ``name``\n            A directory in the standard (STD_) format ready to be delaned.\n\n        Creating the standard format directory is pretty fast. It typically requires either a simple\n        copy or applying something like ``sed`` to fix minor formatting issues. For HCA files, it is\n        just a matter of dumping the data into a textual format.\n\n    ``delaned``\n        The next processing step will split the input into distinct lanes. The result will contain:\n\n        ``name``\n            A directory for each of the standard format directories. This would be either a standard\n            format directory, or will contain:\n\n            ``lane``\n                A directory in the standard format containing just the data for a single lane.\n\n        When data contains multiple lanes, delaning is a painfully slow process as it needs to split\n        the matrix market file, processing one line at a time (without any parallelization). It\n        would have been much easier if the raw data was already split into lanes.\n\n    ``genes``\n        A directory containing fast access per-gene data (GENES_) extracted from the ``delaned``\n        data.\n\n        The extraction process first verifies this data is identical for all the ``delaned``\n        directories. Then one of these directories is used to actually extract the data.\n        This is very fast, as there are only ~30,000 genes to deal with.\n\n    ``cells``\n        A directory containing fast access per-gene-per-profile (COLLECTION_) data. Will contain:\n\n        ``name``\n            A directory for each of the ``delaned`` directories. This would either be a\n            simple profiles batch (BATCH_), or a collection combining:\n\n            ``lane``\n                A profiles batch directory containing the data for a single lane.\n\n        Conversion of the (delaned) textual data to the fast-access format isn't very fast, but this\n        is offset by being able to run this conversion in parallel for each lane. It is therefore\n        much less painful than delaning. Once conversion is done, the import process is complete and\n        does not need to be repeated.\n\n    ``views``\n        This is where the metacells package performs its analysis, recursively grouping the cells\n        into metacells. Should contain:\n\n        ``name``\n            Some view profiles container (VIEW_) based on the full ``cells`` profiles collection, to\n            group. Typically such a view will exclude profiles with too-low total UMIs count, or\n            that suffer from other technical issues (e.g. doublets). Genes may also be excluded.\n\n            The main function of the metacell package is to recursively compute the groups for\n            such a view (that is, extend it to become a GROUPED_ directory).\n\n.. _raw_data:\n\nRaw Data\n........\n\nThe formats which can be used as the raw input for metacell processing:\n\n.. _10X:\n\n**10X**\n    A directory containing `10X Genomics <https://www.10xgenomics.com/>`_ data. Should contain the\n    files:\n\n    ``matrix.mtx``\n        Matrix market UMIs data.\n\n    ``barcodes.tsv``\n        The barcode of each profile (possibly with a ``-lane`` suffix).\n\n    ``genes.tsv``\n        The ensembl ID and name of each gene.\n\n.. _MOCA:\n\n**MOCA**\n    A directory containing `Mouse Organogenesis Cell Atlas\n    <http://atlas.gs.washington.edu/mouse-rna/>`_ data. Should contain the files:\n\n    ``gene_count.txt``\n        Matrix market UMIs data.\n\n    ``cell_annotate.csv``\n        Per-cell data (see list of expected fields in ``metacell/storage/moca_format.yaml``).\n\n    ``gene_annotate.csv``\n        Per-gene data (see list of expected fields in ``metacell/storage/moca_format.yaml``).\n\n.. _HCA:\n\n**HCA**\n    A file containing `Human Cell Atlas <https://www.humancellatlas.org/>`_ in HDF format with a\n    `.h5`` suffix. Must contain a single top-level key with the sub-keys ``barcodes``, ``indptr``,\n    ``genes``, ``indices`` and ``data``.\n\nThese formats are converted to a standard input format:\n\n.. _STD:\n\n**STD**\n    A directory containing data in a standard metacell input format. Should contain the files:\n\n    ``umis.mtx``\n        Matrix market UMIs data.\n\n    ``profiles.csv``\n        Per-profile data.\n\n    ``genes.csv``\n        Per-gene data.\n\n    ``format.yaml``\n        A description of the fields of the CSV files.\n\nFast Access Data\n................\n\nFormats of data allowing fast access during the metacell processing.\n\n.. _GENES:\n\n**GENES**\n    A directory containing per-gene data, accessed using the\n    ``metacell.storage.genes.Genes`` class. Should contain the files:\n\n    ``genes.yaml``\n        General meta-data describing this set of genes. Should contain the keys ``organism``,\n        ``genes_count`` and ``uuid``, which must be equal to the ``md5sum`` of the\n        ``genes.name.txt`` file. This UUID uniquely identifies this set of genes.\n\n    ``genes.*.txt``\n        Per-gene string data. These should include ``genes.name.txt`` containing the\n        (sorted, all-upper-case) gene names, and ``genes.ensembl.txt`` containing the\n        `ensembl <https://www.ensembl.org>`_ identifier of each gene.\n\n    ``genes.*.npy``\n        Per-gene numeric data, if any.\n\n.. _CONTAINER:\n\n**CONTAINER**\n    Either a **BATCH**, **COLLECTION**, or **VIEW** directory, providing access to\n    per-gene-per-profile data for some genes and profiles using the\n    ``metacell.storage.profiles.ProfilesContainer`` class.\n\n    Each container directory contains at least the file:\n\n    ``profiles.yaml``\n        General meta-data describing this container of profiles. Should contain at least the keys:\n\n        ``organism``\n            The organism whose cells were sequenced (e.g. ``human`` or ``mouse``).\n        ``genes_uuid``\n            The UUID of the genes per profile.\n        ``profiles_count``, ``genes_count``\n            The number of profiles, and number of genes per profiles.\n        ``profiles_kind``\n            The kind of profiles (``cells``, ``metacells``, ``clans``, ``tribes``,\n            ``nations``, ``hordes``).\n        ``uuid``\n            Should be equal to the ``md5sum`` of the ``matrix.umis.mmm`` or ``matrix.umis.npy``\n            file. This UUID uniquely identifies this profiles batch.\n\n    ``metadata.yaml``\n        Additional arbitrary meta-data collected for this container profile over time.\n\n    Additional keys may be specified depending on the container type.\n\n.. _BATCH:\n\n**BATCH**\n    A directory containing per-gene-per-profile data for some closely related profiles (a single\n    batch), accessed using the ``metacell.storage.profiles.ProfilesBatch`` class. Barcodes\n    can be safely assumed to be unique within each batch, but not between multiple batches. When\n    investigating batch effects, this is the smallest group of profiles for which these effects can\n    be assumed to be the same. Should contain the additional files:\n\n    ``gp.*.mmm``, ``gp.*.npy``\n        Per-gene-per-profile data. The ``mmm`` format is a metacell-specific compressed sparse data\n        format accessed using the ``metacell.matrices.MemoryMappedMatrix`` class. Each batch\n        should contain ``gp.umis.mmm`` or ``gp.umis.npy``.\n\n        Additional per-gene-per-profile data may exist, for example:\n\n        ``gp.log_fold.npy``\n            The log-fold-factor of the gene's UMIs fraction (out of the profile's total), compared\n            to the gene's median UMIs fraction (in all the profiles). This serves as an estimate of\n            how strong a marker the gene is for this specific profile. This should not be used\n            for single cells.\n\n    ``p.*.txt``\n        Per-profile string data. Common data includes:\n\n        ``p.barcode.txt``\n            The unique (in this batch) per-profile barcode (without any lane suffix).\n\n        ``p.name.txt``\n            The unique (in this batch) per-profile string name, if any.\n\n        ``p.batch.txt``, ``p.lane.txt``\n            The name of the batch and the name of the lane (if any) per profile. These are the same\n            for all profiles in the batch, but having these files is useful when collecting multiple\n            batches to a single data set (see below).\n\n    ``p.*.npy``\n        Per-profile numeric data. Common data includes:\n\n        ``p.total_umis.npy``\n            The sum of the genes UMIs for each profile.\n\n        ``p.max_log_fold.npy``\n            The maximal fold factor of a gene in this profile.\n\n    ``g.*.txt``, ``g.*.npy``\n        Per-gene string and numeric data, specific for this profiles batch, if any. Common data\n        includes:\n\n        ``g.median_fraction.npy``\n            The median fraction of the gene's UMIs out of the profile's UMIs. This is used as an\n            estimate of the global gene expression. This should not be used for single cells.\n\n        ``g.min_rank_log_fold.npy``\n            The minimal rank of the gene's fold factor in some profile. That is, the lower the\n            number, the stronger the marker the gene is for distinguishing between profiles. This is\n            used to filter genes in heatmap visualizations. This should not be used for single\n            cells.\n\n.. _VIEW:\n\n**VIEW**\n    A directory containing a possibly restricted view of another profiles container accessed using\n    the ``metacell.storage.profiles.ProfilesView`` class. The ``profiles.yaml`` file should\n    contain the additional keys:\n\n    ``base_uuid``\n        The UUID of the base profiles container this is a view of.\n\n    ``base_path``\n        The path of the base profiles container this is a view of. If this is a relative path,\n        it is relative to the view directory.\n\n    The directory may contain the additional file(s):\n\n    ``p.base_index.npy``\n        If exist, contain the sorted indices of the base container profiles which are included in\n        this view. Otherwise, the view contains all the base container profiles.\n\n    ``g.base_index.npy``\n        If exist, contain the sorted indices of the base container genes which are included in this\n        view. Otherwise, the view contains all the base container genes.\n\n    When accessing data of a view, if there exists a local file containing the data, it is used.\n    Otherwise, if possible, the data of the base container is fetched and sliced to include only\n    the relevant subset of profiles and/or genes. By default, data is assumed to be slicable.\n    Non-slicable data is specified in\n    ``metacell.storage.profiles.ProfilesView.GENES_DEPENDENT_DATA``\n    and ``metacell.storage.profiles.ProfilesView.PROFILES_DEPENDENT_DATA``.\n\n.. _COLLECTION:\n\n**COLLECTION**\n    A directory combining a collection of other profiles container directories into a single unified\n    profiles container, accessed using the ``metacell.storage.profiles.ProfilesCollection``\n    class. The ``profiles.yaml`` file should contain the additional key:\n\n    ``combined``\n        A list of mapping, one per combined profile container directories. Should contain the\n        keys:\n\n        ``name``\n            The name of a sub-directory of the collection directory, containing the profiles\n            container which is combined into the overall collection.\n\n        ``uuid``\n            The UUID identifying the combined profiles container.\n\n        ``profiles_count``\n            The number of profiles in the combined profiles container.\n\n    For each listed ``name``, a sub-directory with that name must exist, and contain a profiles\n    container. When accessing data of a collection, if there exists a local file containing the\n    data, it is used. Otherwise (except for per-gene data), the data is combined from the data\n    of all the collected sub-containers.\n\n.. _GROUPED:\n\nGrouped Data\n............\n\nThe primary function of the metacell package is to group profiles together, in particular, to group\ncell profiles into metacells, metacells into clans, etc.\n\nWhen groups are computed, the following files are created:\n\n``p.group_index.npy``\n    The group index for each of the container's profiles. A negative value indicates the profile\n    belongs to no group (is an \"outlier\").\n\n``grouped``\n    A profiles VIEW_ containing just the profiles with a non-negative group index, that is, only the\n    non-outlier profiles.\n\n``outliers``\n    A profiles VIEW_ containing just the outlier profiles (which are not included in any\n    of the groups). Typically this would only hold ``p.base_index.npy`` in addition\n    to the ``profiles.yaml``.\n\n``groups``\n    A GROUPS_ profiles container for the computed groups.\n\n``zones``\n    A hierarchy of ZONE_ (view) containers based on the computed groups.\n\n``tmp``\n    Temporary files used to compute the groupings, but need not be used once it has been\n    computed. The contents of this directory depends on whether we are grouping a few\n    profiles or many profiles.\n\n    If grouping a small number of profiles:\n\n    ``selected``\n        A view of the profiles container, including only the selected (\"feature\") genes.\n\n    If grouping a large number of profiles, we can't directly compute the groups, since the\n    basic algorithm has a complexity of O(N^2). Computation therefore must works through a\n    divide-and-conquer algorithm. This requires different temporary files:\n\n    ``phase-1``\n        A directory containing the second phase's files.\n\n        ``pile-index``\n            A profiles view of a random subset of a restricted number of to-be-grouped profiles.\n            To help in sorting file names, the indices are zero-padded so all have the same\n            width (e.g. ``00, .., 10, 11, ...``). Each such pile is independently (directly)\n            grouped.\n\n        ``outliers-pile``\n            This directory is a profiles view containing all profiles that were marked as an\n            outlier in some indexed pile. It is also independently grouped. Unlike the indexed\n            piles, this view may contain a large number of profiles so grouping it may require\n            an intermediate step of its own.\n\n            Rare \"types\" do not have enough profiles in each of the piles to form groups, so\n            will be marked as outliers. In this outliers-only view, there might be enough of\n            these rare profiles to form a proper group.\n\n            When grouping the profiles in the final first phase outliers pile (small enough to be\n            directly grouped), we disable outliers detection. That is, we insist that each of the\n            profiles be assigned to some group by the end of the first phase, as these groups are\n            used to compute the piles for the second phase and we'd like to give each profile a\n            chance to be grouped in this second phase.\n\n    ``grouped``\n        A view of the grouped profiles container, with ``p.group_index.npy`` containing the\n        combined group indices from all the phase-1 piles.\n\n    ``groups``\n        The intermediate grouping combines the groups from all the phase-1 piles, as well as the\n        groups from the phase-1 outliers. This is the less-accurate grouping we will improve upon.\n        To allow doing so, we compute the groups-of-groups (that is, we compute\n        ``p.group_index.npy`` here), and use these to construct the second phase piles.\n\n        Similarly to grouping the outliers pile, we disable outlier detection when grouping the\n        final pile, so that each group will be assigned to one of the second phase piles.\n\n    ``phase-2``\n        A directory containing the second phase's files. This is similar to the first phase's\n        structure, with the following differences:\n\n        - The profiles contained in each pile are not chosen randomly. Instead, they are the\n          profiles contained in one of the computed intermediate groups-of-groups.\n\n        - The outliers pile contains the phase-1 outliers in addition to the outliers of the\n          phase-2 indexed piles. This allows very rare profile \"types\" a second chance at being\n          grouped.\n\n        - There are no ``grouped`` or ``groups`` directories; the results are written directly\n          to the original (parent) grouped profiles container. These final groups are\n          recursively grouped as long as there is a large number of profiles, as described\n          above.\n\n\n.. _GROUPS:\n\n**GROUPS**\n    A profiles container describing groups of profiles. The ``gp.umis.npy`` per-profile-per-gene\n    UMIs count in this container will contain the sum of the per-profile-per-gene of each of the\n    grouped profiles contained in each (group) profile.\n\n    A groups profiles container has identical format to a normal profiles batch directory, except\n    that its ``profiles.yaml`` file contains a ``grouped_profiles`` key with the (relative) path to\n    the grouped profiles container (typically ``..``), and a ``grouped_uuid`` key with the UUID of\n    the grouped profiles container. For convenience, ``mean_grouped_count`` and ``mean_cells_count``\n    provide an estimate of the number of cells and profiles in each group.\n\n    The ``profiles_kind`` of the groups container should be based on the grouped container profiles\n    kind. In particular, groups of ``cells`` are called ``metacells``. Such groups are expected to\n    contain cells of the \"same\" state.\n\n    When grouping a large number of profiles, the ``groups`` directory might itself be grouped. This\n    recursion continues as long as the total number of profiles is \"large\". Groups of ``metacells``\n    are called ``clans``, groups of ``clans`` are called ``tribes``, groups of ``tribes`` are\n    called ``nations``, and groups of ``nations`` are called ``hordes``. All higher-level groups\n    contain profiles with a \"similar\", but not necessarily the \"same\" state.\n\n    Finally, a groups container will hold the files ``p.grouped_count.npy`` with the number of\n    profiles summed into each group, and ``p.cells_count.npy`` with the number of cells summed into\n    each group. These two numbers are the same for metacells, but differ for higher level groups.\n\n\n.. _ZONE:\n\n**ZONE**\n    A tree directory is used to provide convenient views for exploring the hierarchy created by the\n    computed groups. In each level of the tree, in addition to the ``groups`` and ``grouped``\n    containers, there is also a ``zones`` directory that contains views that group the overall\n    profiles into groups-of-groups.\n\n    The directory structure for a small amount of cells would contain:\n\n    ::\n\n        zones\n            groups  # All the clans (groups of metacells)\n                ...\n            grouped  # All the metacells (grouped into clans).\n                ...\n            clan-0  # The 1st clan\n                groups  # All the metacells in the 1st clan\n                    ...\n                grouped  # All the cells in the 1st clan\n                    ...\n            clan-1  # The 2nd clan\n                groups  # All the metacells in the 2nd clan\n                    ...\n                grouped  # All the cells in the 2nd clan\n                    ...\n                ...\n            ...\n\n    And a directory structure for a larger number (several hundred of thousands) of cells would\n    contain:\n\n    ::\n\n        zones\n            groups  # All the tribess (groups of clans)\n                ...\n            grouped  # All the clans (grouped into tribes).\n                ...\n            tribe-0  # The 1st tribe\n                groups  # All the clans in the 1st tribe\n                    ...\n                grouped  # All the metacells in the 1st tribe\n                    ...\n                clan-000  # The 1st clan in the 1st tribe\n                    groups  # All the metacells in the 1st clan\n                        ...\n                    grouped  # All the cells in the 1st clan\n                        ...\n                clan-001  # The 2nd clan in the 1st tribe\n                    ...\n                ...\n            tribe-1  # The 2nd tribe\n                groups  # All the clans in the 2nd tribe\n                    ...\n                grouped  # All the metacells in the 2nd tribe\n                    ...\n                clan  # The 1st clan in the 2nd tribe\n                    groups  # All the metacells in the 1st clan\n                        ...\n                    grouped  # All the cells in the 1st clan\n                        ...\n                clan-091  # The 2nd clan in the 2nd tribe\n                    ...\n                ...\n            ...\n\n    A much larger number (tens of millions) of cells would include an additional hierarchy level for\n    each ``nation``. Even larges number of cells would (up to a few billion) would require an\n    additional level for each ``horde``. Currently the largest data sets are at most of a few\n    million so this scheme should be sufficient for the foreseeable future.\n\n    In all cases, the ``grouped`` directory contains a ``p.group_index.npy`` which specifies the\n    index of the group in the adjacent ``groups`` directory.", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/orenbenkiki/metacell.py.git", "keywords": "logging configuration", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "metacell", "package_url": "https://pypi.org/project/metacell/", "platform": "", "project_url": "https://pypi.org/project/metacell/", "project_urls": {"Homepage": "https://github.com/orenbenkiki/metacell.py.git"}, "release_url": "https://pypi.org/project/metacell/0.5.50/", "requires_dist": null, "requires_python": "", "summary": "Single-cell RNA Sequencing Analysis", "version": "0.5.50", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/tanaylab/metacell.py\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9710172638653ce4573dbb9820dd3f516b2949fc/68747470733a2f2f7472617669732d63692e6f72672f74616e61796c61622f6d65746163656c6c2e70792e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://metacellpy.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/db66e8241c7526de9efd88378b26a93063796e44/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f6d65746163656c6c70792f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<p>The metacell package implements the metacell algorithm for single-cell RNA sequencing (scRNA-seq)\ndata analysis.</p>\n<p>The <a href=\"https://www.biorxiv.org/content/10.1101/437665v1\" rel=\"nofollow\">original</a> metacell algorithm was\nimplemented in R. In contrast, the Python package described here implements an <cite>improved\n&lt;https://todo/&gt;</cite> version, which uses improved internal algorithms and supports much larger data sets\n(millions of cells).</p>\n<div id=\"metacell-analysis\">\n<h2>Metacell Analysis</h2>\n<p>Naively, scRNA_seq data is a set of cell profiles, where for each one, for each gene, we get a count\nof the mRNA molecules that existed in the cell for that gene. This serves as an indicator of how\n\u201cexpressed\u201d or \u201cactive\u201d the gene is.</p>\n<p>As in any real world technology, the raw data may suffer from technical artifacts (counting the\nmolecules of two cells in one profile, counting the molecules from a ruptured cells, counting only\nthe molecules from the cell nucleus, etc.). This requires pruning the raw data to exclude such\nartifacts. TODO: Create view should consider these issues.</p>\n<p>The current technology scRNA-seq data is also very sparse (typically &lt;10%, sometimes even &lt;5% of the\nRNA molecules are counted). This introduces large sampling variance on top of the original signal,\nwhich itself contains significant inherent biological noise.</p>\n<p>Analyzing scRNA-seq data therefore requires processing the profiles in bulk. Classically, this has\nbeen done by directly clustering the cells using various methods.</p>\n<p>In contrast, the metacell approach groups together profiles of the \u201csame\u201d biological state into\ngroups with the <em>minimal</em> number of profiles (~100) needed for computing robust statistics (in\nparticular, mean gene expression). Each such group is a single \u201cmetacell\u201d.</p>\n<p>By summing profiles together, each metacell greatly reduces the sampling variance, and provides a\nmore robust estimation of some transcription state. In particular, a metacell is not a cell type\n(multiple metacells may belong to the same type), and is not a parametric model of the cell state.</p>\n<p>The metacells should therefore be further analyzed using additional methods to classify cell types,\ndetect cell trajectories and/or lineage, build parametric models for cell behavior, etc. Using\nmetacells as input for such analysis techniques should benefit both from the more robust, less noisy\ninput; and from the (~100-fold) reduction in the number of profiles to analyze.</p>\n<p>An obvious technique is to recursively group the metacells into larger groups, and investigate the\nresulting clustering hierarchy. Methods for further analysis of the data may choose to build upon\nthis readily available hierarchy (which is also provided by this package).</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<div id=\"installation\">\n<h3>Installation</h3>\n<p>Given Python version 3.6 and above, run <tt>pip install <span class=\"pre\">--user</span> metacell</tt> (or, <tt>sudo pip install\nmetacell</tt> if you have <tt>sudo</tt> privileges). This will install this package and two scripts:\n<tt>metacell_flow</tt> and <tt>metacell_call</tt>.</p>\n<p>The metacell package is built using the <a href=\"https://pypi.org/project/dynamake/\" rel=\"nofollow\">DynaMake</a> package.\nThe <tt>metacell_flow</tt> script is simply the <tt>dynamake</tt> script, pre-loaded with the metacell build\nsteps, and <tt>metacell_call</tt> is simply the <tt>dynacall</tt> script, pre-loaded with the metacell\ncomputation functions.</p>\n</div>\n<div id=\"importing\">\n<h3>Importing</h3>\n<p>To use the package, create a directory somewhere with a large amount of available space (for ~2M\ncells, metacell required up to 200GB of disk space). If using a servers cluster, on some shared file\nsystem, and provide a DynaMake configuration file with an appropriate <tt>run_prefix</tt> for\ndistributing jobs across the cluster; see the DynaMake documentation for details.</p>\n<p>Create a <tt>raw</tt> sub-directory and download the <a href=\"#raw-data\" rel=\"nofollow\">raw_data</a> into it. Then, run <tt>metacell_import</tt> to\nimport the gene and cell data into the fast-access format used by the metacell package. This is\nunfortunately a slow process (in particular, the delaning step). Luckily, you only need to do this\nonce.</p>\n<p>This will create the following directories:</p>\n<dl>\n<dt><tt>genes</tt></dt>\n<dd>Describes the genes used in the data.</dd>\n<dt><tt>cells</tt></dt>\n<dd>A <a href=\"#collection\" rel=\"nofollow\">COLLECTION</a> profiles directory containing all the imported cells.</dd>\n</dl>\n</div>\n<div id=\"grouping\">\n<h3>Grouping</h3>\n<p>TODO: Running <tt>metacell_group</tt>.</p>\n<p>TODO: <tt>excluded_genes_names.txt</tt>, <tt>forbidden_genes_names.txt</tt>.</p>\n</div>\n<div id=\"zoning\">\n<h3>Zoning</h3>\n<p>TODO: Running <tt>metacell_zone</tt>.</p>\n</div>\n<div id=\"analysis\">\n<h3>Analysis</h3>\n<p>TODO: Running <tt>metacell_dash</tt>.</p>\n<p>TODO: <tt>colors</tt> directory.</p>\n</div>\n</div>\n<div id=\"directory-structure\">\n<h2>Directory Structure</h2>\n<p>The provided automated workflow uses the following directory structure. The specifics of each\ndirectory type are provided further below.</p>\n<dl>\n<dt><tt>ROOT</tt></dt>\n<dd><p>A directory which is typically named after the data source (<tt>PBMC</tt>, <tt>MOCA</tt>, <tt>HCA</tt>, etc.).\nWill contain:</p>\n<dl>\n<dt><tt>raw</tt></dt>\n<dd><p>A directory containing the raw data from the data source. Should contain one or more:</p>\n<dl>\n<dt><tt>name</tt></dt>\n<dd>A directory containing <a href=\"#x\" rel=\"nofollow\">10X</a> or <a href=\"#moca\" rel=\"nofollow\">MOCA</a> data.</dd>\n<dt><tt>name.h5</tt></dt>\n<dd>An HDF file containing <a href=\"#hca\" rel=\"nofollow\">HCA</a> data.</dd>\n</dl>\n</dd>\n<dt><tt>std</tt></dt>\n<dd><p>The first processing step will convert the <tt>raw</tt> data to the standard input format. The\nresult will contain:</p>\n<dl>\n<dt><tt>name</tt></dt>\n<dd>A directory in the standard (<a href=\"#std\" rel=\"nofollow\">STD</a>) format ready to be delaned.</dd>\n</dl>\n<p>Creating the standard format directory is pretty fast. It typically requires either a simple\ncopy or applying something like <tt>sed</tt> to fix minor formatting issues. For HCA files, it is\njust a matter of dumping the data into a textual format.</p>\n</dd>\n<dt><tt>delaned</tt></dt>\n<dd><p>The next processing step will split the input into distinct lanes. The result will contain:</p>\n<dl>\n<dt><tt>name</tt></dt>\n<dd><p>A directory for each of the standard format directories. This would be either a standard\nformat directory, or will contain:</p>\n<dl>\n<dt><tt>lane</tt></dt>\n<dd>A directory in the standard format containing just the data for a single lane.</dd>\n</dl>\n</dd>\n</dl>\n<p>When data contains multiple lanes, delaning is a painfully slow process as it needs to split\nthe matrix market file, processing one line at a time (without any parallelization). It\nwould have been much easier if the raw data was already split into lanes.</p>\n</dd>\n<dt><tt>genes</tt></dt>\n<dd><p>A directory containing fast access per-gene data (<a href=\"#genes\" rel=\"nofollow\">GENES</a>) extracted from the <tt>delaned</tt>\ndata.</p>\n<p>The extraction process first verifies this data is identical for all the <tt>delaned</tt>\ndirectories. Then one of these directories is used to actually extract the data.\nThis is very fast, as there are only ~30,000 genes to deal with.</p>\n</dd>\n<dt><tt>cells</tt></dt>\n<dd><p>A directory containing fast access per-gene-per-profile (<a href=\"#collection\" rel=\"nofollow\">COLLECTION</a>) data. Will contain:</p>\n<dl>\n<dt><tt>name</tt></dt>\n<dd><p>A directory for each of the <tt>delaned</tt> directories. This would either be a\nsimple profiles batch (<a href=\"#batch\" rel=\"nofollow\">BATCH</a>), or a collection combining:</p>\n<dl>\n<dt><tt>lane</tt></dt>\n<dd>A profiles batch directory containing the data for a single lane.</dd>\n</dl>\n</dd>\n</dl>\n<p>Conversion of the (delaned) textual data to the fast-access format isn\u2019t very fast, but this\nis offset by being able to run this conversion in parallel for each lane. It is therefore\nmuch less painful than delaning. Once conversion is done, the import process is complete and\ndoes not need to be repeated.</p>\n</dd>\n<dt><tt>views</tt></dt>\n<dd><p>This is where the metacells package performs its analysis, recursively grouping the cells\ninto metacells. Should contain:</p>\n<dl>\n<dt><tt>name</tt></dt>\n<dd><p>Some view profiles container (<a href=\"#view\" rel=\"nofollow\">VIEW</a>) based on the full <tt>cells</tt> profiles collection, to\ngroup. Typically such a view will exclude profiles with too-low total UMIs count, or\nthat suffer from other technical issues (e.g. doublets). Genes may also be excluded.</p>\n<p>The main function of the metacell package is to recursively compute the groups for\nsuch a view (that is, extend it to become a <a href=\"#grouped\" rel=\"nofollow\">GROUPED</a> directory).</p>\n</dd>\n</dl>\n</dd>\n</dl>\n</dd>\n</dl>\n<div id=\"id1\">\n<span id=\"raw-data\"></span><h3>Raw Data</h3>\n<p>The formats which can be used as the raw input for metacell processing:</p>\n<dl id=\"x\">\n<dt><strong>10X</strong></dt>\n<dd><p>A directory containing <a href=\"https://www.10xgenomics.com/\" rel=\"nofollow\">10X Genomics</a> data. Should contain the\nfiles:</p>\n<dl>\n<dt><tt>matrix.mtx</tt></dt>\n<dd>Matrix market UMIs data.</dd>\n<dt><tt>barcodes.tsv</tt></dt>\n<dd>The barcode of each profile (possibly with a <tt><span class=\"pre\">-lane</span></tt> suffix).</dd>\n<dt><tt>genes.tsv</tt></dt>\n<dd>The ensembl ID and name of each gene.</dd>\n</dl>\n</dd>\n</dl>\n<dl id=\"moca\">\n<dt><strong>MOCA</strong></dt>\n<dd><p>A directory containing <a href=\"http://atlas.gs.washington.edu/mouse-rna/\" rel=\"nofollow\">Mouse Organogenesis Cell Atlas</a> data. Should contain the files:</p>\n<dl>\n<dt><tt>gene_count.txt</tt></dt>\n<dd>Matrix market UMIs data.</dd>\n<dt><tt>cell_annotate.csv</tt></dt>\n<dd>Per-cell data (see list of expected fields in <tt>metacell/storage/moca_format.yaml</tt>).</dd>\n<dt><tt>gene_annotate.csv</tt></dt>\n<dd>Per-gene data (see list of expected fields in <tt>metacell/storage/moca_format.yaml</tt>).</dd>\n</dl>\n</dd>\n</dl>\n<dl id=\"hca\">\n<dt><strong>HCA</strong></dt>\n<dd>A file containing <a href=\"https://www.humancellatlas.org/\" rel=\"nofollow\">Human Cell Atlas</a> in HDF format with a\n<cite>.h5`</cite> suffix. Must contain a single top-level key with the sub-keys <tt>barcodes</tt>, <tt>indptr</tt>,\n<tt>genes</tt>, <tt>indices</tt> and <tt>data</tt>.</dd>\n</dl>\n<p>These formats are converted to a standard input format:</p>\n<dl id=\"std\">\n<dt><strong>STD</strong></dt>\n<dd><p>A directory containing data in a standard metacell input format. Should contain the files:</p>\n<dl>\n<dt><tt>umis.mtx</tt></dt>\n<dd>Matrix market UMIs data.</dd>\n<dt><tt>profiles.csv</tt></dt>\n<dd>Per-profile data.</dd>\n<dt><tt>genes.csv</tt></dt>\n<dd>Per-gene data.</dd>\n<dt><tt>format.yaml</tt></dt>\n<dd>A description of the fields of the CSV files.</dd>\n</dl>\n</dd>\n</dl>\n</div>\n<div id=\"fast-access-data\">\n<h3>Fast Access Data</h3>\n<p>Formats of data allowing fast access during the metacell processing.</p>\n<dl id=\"genes\">\n<dt><strong>GENES</strong></dt>\n<dd><p>A directory containing per-gene data, accessed using the\n<tt>metacell.storage.genes.Genes</tt> class. Should contain the files:</p>\n<dl>\n<dt><tt>genes.yaml</tt></dt>\n<dd>General meta-data describing this set of genes. Should contain the keys <tt>organism</tt>,\n<tt>genes_count</tt> and <tt>uuid</tt>, which must be equal to the <tt>md5sum</tt> of the\n<tt>genes.name.txt</tt> file. This UUID uniquely identifies this set of genes.</dd>\n<dt><tt><span class=\"pre\">genes.*.txt</span></tt></dt>\n<dd>Per-gene string data. These should include <tt>genes.name.txt</tt> containing the\n(sorted, all-upper-case) gene names, and <tt>genes.ensembl.txt</tt> containing the\n<a href=\"https://www.ensembl.org\" rel=\"nofollow\">ensembl</a> identifier of each gene.</dd>\n<dt><tt><span class=\"pre\">genes.*.npy</span></tt></dt>\n<dd>Per-gene numeric data, if any.</dd>\n</dl>\n</dd>\n</dl>\n<dl id=\"container\">\n<dt><strong>CONTAINER</strong></dt>\n<dd><p>Either a <strong>BATCH</strong>, <strong>COLLECTION</strong>, or <strong>VIEW</strong> directory, providing access to\nper-gene-per-profile data for some genes and profiles using the\n<tt>metacell.storage.profiles.ProfilesContainer</tt> class.</p>\n<p>Each container directory contains at least the file:</p>\n<dl>\n<dt><tt>profiles.yaml</tt></dt>\n<dd><p>General meta-data describing this container of profiles. Should contain at least the keys:</p>\n<dl>\n<dt><tt>organism</tt></dt>\n<dd>The organism whose cells were sequenced (e.g. <tt>human</tt> or <tt>mouse</tt>).</dd>\n<dt><tt>genes_uuid</tt></dt>\n<dd>The UUID of the genes per profile.</dd>\n<dt><tt>profiles_count</tt>, <tt>genes_count</tt></dt>\n<dd>The number of profiles, and number of genes per profiles.</dd>\n<dt><tt>profiles_kind</tt></dt>\n<dd>The kind of profiles (<tt>cells</tt>, <tt>metacells</tt>, <tt>clans</tt>, <tt>tribes</tt>,\n<tt>nations</tt>, <tt>hordes</tt>).</dd>\n<dt><tt>uuid</tt></dt>\n<dd>Should be equal to the <tt>md5sum</tt> of the <tt>matrix.umis.mmm</tt> or <tt>matrix.umis.npy</tt>\nfile. This UUID uniquely identifies this profiles batch.</dd>\n</dl>\n</dd>\n<dt><tt>metadata.yaml</tt></dt>\n<dd>Additional arbitrary meta-data collected for this container profile over time.</dd>\n</dl>\n<p>Additional keys may be specified depending on the container type.</p>\n</dd>\n</dl>\n<dl id=\"batch\">\n<dt><strong>BATCH</strong></dt>\n<dd><p>A directory containing per-gene-per-profile data for some closely related profiles (a single\nbatch), accessed using the <tt>metacell.storage.profiles.ProfilesBatch</tt> class. Barcodes\ncan be safely assumed to be unique within each batch, but not between multiple batches. When\ninvestigating batch effects, this is the smallest group of profiles for which these effects can\nbe assumed to be the same. Should contain the additional files:</p>\n<dl>\n<dt><tt><span class=\"pre\">gp.*.mmm</span></tt>, <tt><span class=\"pre\">gp.*.npy</span></tt></dt>\n<dd><p>Per-gene-per-profile data. The <tt>mmm</tt> format is a metacell-specific compressed sparse data\nformat accessed using the <tt>metacell.matrices.MemoryMappedMatrix</tt> class. Each batch\nshould contain <tt>gp.umis.mmm</tt> or <tt>gp.umis.npy</tt>.</p>\n<p>Additional per-gene-per-profile data may exist, for example:</p>\n<dl>\n<dt><tt>gp.log_fold.npy</tt></dt>\n<dd>The log-fold-factor of the gene\u2019s UMIs fraction (out of the profile\u2019s total), compared\nto the gene\u2019s median UMIs fraction (in all the profiles). This serves as an estimate of\nhow strong a marker the gene is for this specific profile. This should not be used\nfor single cells.</dd>\n</dl>\n</dd>\n<dt><tt><span class=\"pre\">p.*.txt</span></tt></dt>\n<dd><p>Per-profile string data. Common data includes:</p>\n<dl>\n<dt><tt>p.barcode.txt</tt></dt>\n<dd>The unique (in this batch) per-profile barcode (without any lane suffix).</dd>\n<dt><tt>p.name.txt</tt></dt>\n<dd>The unique (in this batch) per-profile string name, if any.</dd>\n<dt><tt>p.batch.txt</tt>, <tt>p.lane.txt</tt></dt>\n<dd>The name of the batch and the name of the lane (if any) per profile. These are the same\nfor all profiles in the batch, but having these files is useful when collecting multiple\nbatches to a single data set (see below).</dd>\n</dl>\n</dd>\n<dt><tt><span class=\"pre\">p.*.npy</span></tt></dt>\n<dd><p>Per-profile numeric data. Common data includes:</p>\n<dl>\n<dt><tt>p.total_umis.npy</tt></dt>\n<dd>The sum of the genes UMIs for each profile.</dd>\n<dt><tt>p.max_log_fold.npy</tt></dt>\n<dd>The maximal fold factor of a gene in this profile.</dd>\n</dl>\n</dd>\n<dt><tt><span class=\"pre\">g.*.txt</span></tt>, <tt><span class=\"pre\">g.*.npy</span></tt></dt>\n<dd><p>Per-gene string and numeric data, specific for this profiles batch, if any. Common data\nincludes:</p>\n<dl>\n<dt><tt>g.median_fraction.npy</tt></dt>\n<dd>The median fraction of the gene\u2019s UMIs out of the profile\u2019s UMIs. This is used as an\nestimate of the global gene expression. This should not be used for single cells.</dd>\n<dt><tt>g.min_rank_log_fold.npy</tt></dt>\n<dd>The minimal rank of the gene\u2019s fold factor in some profile. That is, the lower the\nnumber, the stronger the marker the gene is for distinguishing between profiles. This is\nused to filter genes in heatmap visualizations. This should not be used for single\ncells.</dd>\n</dl>\n</dd>\n</dl>\n</dd>\n</dl>\n<dl id=\"view\">\n<dt><strong>VIEW</strong></dt>\n<dd><p>A directory containing a possibly restricted view of another profiles container accessed using\nthe <tt>metacell.storage.profiles.ProfilesView</tt> class. The <tt>profiles.yaml</tt> file should\ncontain the additional keys:</p>\n<dl>\n<dt><tt>base_uuid</tt></dt>\n<dd>The UUID of the base profiles container this is a view of.</dd>\n<dt><tt>base_path</tt></dt>\n<dd>The path of the base profiles container this is a view of. If this is a relative path,\nit is relative to the view directory.</dd>\n</dl>\n<p>The directory may contain the additional file(s):</p>\n<dl>\n<dt><tt>p.base_index.npy</tt></dt>\n<dd>If exist, contain the sorted indices of the base container profiles which are included in\nthis view. Otherwise, the view contains all the base container profiles.</dd>\n<dt><tt>g.base_index.npy</tt></dt>\n<dd>If exist, contain the sorted indices of the base container genes which are included in this\nview. Otherwise, the view contains all the base container genes.</dd>\n</dl>\n<p>When accessing data of a view, if there exists a local file containing the data, it is used.\nOtherwise, if possible, the data of the base container is fetched and sliced to include only\nthe relevant subset of profiles and/or genes. By default, data is assumed to be slicable.\nNon-slicable data is specified in\n<tt>metacell.storage.profiles.ProfilesView.GENES_DEPENDENT_DATA</tt>\nand <tt>metacell.storage.profiles.ProfilesView.PROFILES_DEPENDENT_DATA</tt>.</p>\n</dd>\n</dl>\n<dl id=\"collection\">\n<dt><strong>COLLECTION</strong></dt>\n<dd><p>A directory combining a collection of other profiles container directories into a single unified\nprofiles container, accessed using the <tt>metacell.storage.profiles.ProfilesCollection</tt>\nclass. The <tt>profiles.yaml</tt> file should contain the additional key:</p>\n<dl>\n<dt><tt>combined</tt></dt>\n<dd><p>A list of mapping, one per combined profile container directories. Should contain the\nkeys:</p>\n<dl>\n<dt><tt>name</tt></dt>\n<dd>The name of a sub-directory of the collection directory, containing the profiles\ncontainer which is combined into the overall collection.</dd>\n<dt><tt>uuid</tt></dt>\n<dd>The UUID identifying the combined profiles container.</dd>\n<dt><tt>profiles_count</tt></dt>\n<dd>The number of profiles in the combined profiles container.</dd>\n</dl>\n</dd>\n</dl>\n<p>For each listed <tt>name</tt>, a sub-directory with that name must exist, and contain a profiles\ncontainer. When accessing data of a collection, if there exists a local file containing the\ndata, it is used. Otherwise (except for per-gene data), the data is combined from the data\nof all the collected sub-containers.</p>\n</dd>\n</dl>\n</div>\n<div id=\"grouped-data\">\n<span id=\"grouped\"></span><h3>Grouped Data</h3>\n<p>The primary function of the metacell package is to group profiles together, in particular, to group\ncell profiles into metacells, metacells into clans, etc.</p>\n<p>When groups are computed, the following files are created:</p>\n<dl>\n<dt><tt>p.group_index.npy</tt></dt>\n<dd>The group index for each of the container\u2019s profiles. A negative value indicates the profile\nbelongs to no group (is an \u201coutlier\u201d).</dd>\n<dt><tt>grouped</tt></dt>\n<dd>A profiles <a href=\"#view\" rel=\"nofollow\">VIEW</a> containing just the profiles with a non-negative group index, that is, only the\nnon-outlier profiles.</dd>\n<dt><tt>outliers</tt></dt>\n<dd>A profiles <a href=\"#view\" rel=\"nofollow\">VIEW</a> containing just the outlier profiles (which are not included in any\nof the groups). Typically this would only hold <tt>p.base_index.npy</tt> in addition\nto the <tt>profiles.yaml</tt>.</dd>\n<dt><tt>groups</tt></dt>\n<dd>A <a href=\"#groups\" rel=\"nofollow\">GROUPS</a> profiles container for the computed groups.</dd>\n<dt><tt>zones</tt></dt>\n<dd>A hierarchy of <a href=\"#zone\" rel=\"nofollow\">ZONE</a> (view) containers based on the computed groups.</dd>\n<dt><tt>tmp</tt></dt>\n<dd><p>Temporary files used to compute the groupings, but need not be used once it has been\ncomputed. The contents of this directory depends on whether we are grouping a few\nprofiles or many profiles.</p>\n<p>If grouping a small number of profiles:</p>\n<dl>\n<dt><tt>selected</tt></dt>\n<dd>A view of the profiles container, including only the selected (\u201cfeature\u201d) genes.</dd>\n</dl>\n<p>If grouping a large number of profiles, we can\u2019t directly compute the groups, since the\nbasic algorithm has a complexity of O(N^2). Computation therefore must works through a\ndivide-and-conquer algorithm. This requires different temporary files:</p>\n<dl>\n<dt><tt><span class=\"pre\">phase-1</span></tt></dt>\n<dd><p>A directory containing the second phase\u2019s files.</p>\n<dl>\n<dt><tt><span class=\"pre\">pile-index</span></tt></dt>\n<dd>A profiles view of a random subset of a restricted number of to-be-grouped profiles.\nTo help in sorting file names, the indices are zero-padded so all have the same\nwidth (e.g. <tt>00, .., 10, 11, ...</tt>). Each such pile is independently (directly)\ngrouped.</dd>\n<dt><tt><span class=\"pre\">outliers-pile</span></tt></dt>\n<dd><p>This directory is a profiles view containing all profiles that were marked as an\noutlier in some indexed pile. It is also independently grouped. Unlike the indexed\npiles, this view may contain a large number of profiles so grouping it may require\nan intermediate step of its own.</p>\n<p>Rare \u201ctypes\u201d do not have enough profiles in each of the piles to form groups, so\nwill be marked as outliers. In this outliers-only view, there might be enough of\nthese rare profiles to form a proper group.</p>\n<p>When grouping the profiles in the final first phase outliers pile (small enough to be\ndirectly grouped), we disable outliers detection. That is, we insist that each of the\nprofiles be assigned to some group by the end of the first phase, as these groups are\nused to compute the piles for the second phase and we\u2019d like to give each profile a\nchance to be grouped in this second phase.</p>\n</dd>\n</dl>\n</dd>\n<dt><tt>grouped</tt></dt>\n<dd>A view of the grouped profiles container, with <tt>p.group_index.npy</tt> containing the\ncombined group indices from all the phase-1 piles.</dd>\n<dt><tt>groups</tt></dt>\n<dd><p>The intermediate grouping combines the groups from all the phase-1 piles, as well as the\ngroups from the phase-1 outliers. This is the less-accurate grouping we will improve upon.\nTo allow doing so, we compute the groups-of-groups (that is, we compute\n<tt>p.group_index.npy</tt> here), and use these to construct the second phase piles.</p>\n<p>Similarly to grouping the outliers pile, we disable outlier detection when grouping the\nfinal pile, so that each group will be assigned to one of the second phase piles.</p>\n</dd>\n<dt><tt><span class=\"pre\">phase-2</span></tt></dt>\n<dd><p>A directory containing the second phase\u2019s files. This is similar to the first phase\u2019s\nstructure, with the following differences:</p>\n<ul>\n<li>The profiles contained in each pile are not chosen randomly. Instead, they are the\nprofiles contained in one of the computed intermediate groups-of-groups.</li>\n<li>The outliers pile contains the phase-1 outliers in addition to the outliers of the\nphase-2 indexed piles. This allows very rare profile \u201ctypes\u201d a second chance at being\ngrouped.</li>\n<li>There are no <tt>grouped</tt> or <tt>groups</tt> directories; the results are written directly\nto the original (parent) grouped profiles container. These final groups are\nrecursively grouped as long as there is a large number of profiles, as described\nabove.</li>\n</ul>\n</dd>\n</dl>\n</dd>\n</dl>\n<dl id=\"groups\">\n<dt><strong>GROUPS</strong></dt>\n<dd><p>A profiles container describing groups of profiles. The <tt>gp.umis.npy</tt> per-profile-per-gene\nUMIs count in this container will contain the sum of the per-profile-per-gene of each of the\ngrouped profiles contained in each (group) profile.</p>\n<p>A groups profiles container has identical format to a normal profiles batch directory, except\nthat its <tt>profiles.yaml</tt> file contains a <tt>grouped_profiles</tt> key with the (relative) path to\nthe grouped profiles container (typically <tt>..</tt>), and a <tt>grouped_uuid</tt> key with the UUID of\nthe grouped profiles container. For convenience, <tt>mean_grouped_count</tt> and <tt>mean_cells_count</tt>\nprovide an estimate of the number of cells and profiles in each group.</p>\n<p>The <tt>profiles_kind</tt> of the groups container should be based on the grouped container profiles\nkind. In particular, groups of <tt>cells</tt> are called <tt>metacells</tt>. Such groups are expected to\ncontain cells of the \u201csame\u201d state.</p>\n<p>When grouping a large number of profiles, the <tt>groups</tt> directory might itself be grouped. This\nrecursion continues as long as the total number of profiles is \u201clarge\u201d. Groups of <tt>metacells</tt>\nare called <tt>clans</tt>, groups of <tt>clans</tt> are called <tt>tribes</tt>, groups of <tt>tribes</tt> are\ncalled <tt>nations</tt>, and groups of <tt>nations</tt> are called <tt>hordes</tt>. All higher-level groups\ncontain profiles with a \u201csimilar\u201d, but not necessarily the \u201csame\u201d state.</p>\n<p>Finally, a groups container will hold the files <tt>p.grouped_count.npy</tt> with the number of\nprofiles summed into each group, and <tt>p.cells_count.npy</tt> with the number of cells summed into\neach group. These two numbers are the same for metacells, but differ for higher level groups.</p>\n</dd>\n</dl>\n<dl id=\"zone\">\n<dt><strong>ZONE</strong></dt>\n<dd><p>A tree directory is used to provide convenient views for exploring the hierarchy created by the\ncomputed groups. In each level of the tree, in addition to the <tt>groups</tt> and <tt>grouped</tt>\ncontainers, there is also a <tt>zones</tt> directory that contains views that group the overall\nprofiles into groups-of-groups.</p>\n<p>The directory structure for a small amount of cells would contain:</p>\n<pre>zones\n    groups  # All the clans (groups of metacells)\n        ...\n    grouped  # All the metacells (grouped into clans).\n        ...\n    clan-0  # The 1st clan\n        groups  # All the metacells in the 1st clan\n            ...\n        grouped  # All the cells in the 1st clan\n            ...\n    clan-1  # The 2nd clan\n        groups  # All the metacells in the 2nd clan\n            ...\n        grouped  # All the cells in the 2nd clan\n            ...\n        ...\n    ...\n</pre>\n<p>And a directory structure for a larger number (several hundred of thousands) of cells would\ncontain:</p>\n<pre>zones\n    groups  # All the tribess (groups of clans)\n        ...\n    grouped  # All the clans (grouped into tribes).\n        ...\n    tribe-0  # The 1st tribe\n        groups  # All the clans in the 1st tribe\n            ...\n        grouped  # All the metacells in the 1st tribe\n            ...\n        clan-000  # The 1st clan in the 1st tribe\n            groups  # All the metacells in the 1st clan\n                ...\n            grouped  # All the cells in the 1st clan\n                ...\n        clan-001  # The 2nd clan in the 1st tribe\n            ...\n        ...\n    tribe-1  # The 2nd tribe\n        groups  # All the clans in the 2nd tribe\n            ...\n        grouped  # All the metacells in the 2nd tribe\n            ...\n        clan  # The 1st clan in the 2nd tribe\n            groups  # All the metacells in the 1st clan\n                ...\n            grouped  # All the cells in the 1st clan\n                ...\n        clan-091  # The 2nd clan in the 2nd tribe\n            ...\n        ...\n    ...\n</pre>\n<p>A much larger number (tens of millions) of cells would include an additional hierarchy level for\neach <tt>nation</tt>. Even larges number of cells would (up to a few billion) would require an\nadditional level for each <tt>horde</tt>. Currently the largest data sets are at most of a few\nmillion so this scheme should be sufficient for the foreseeable future.</p>\n<p>In all cases, the <tt>grouped</tt> directory contains a <tt>p.group_index.npy</tt> which specifies the\nindex of the group in the adjacent <tt>groups</tt> directory.</p>\n</dd>\n</dl>\n</div>\n</div>\n\n          </div>"}, "last_serial": 6562152, "releases": {"0.5.50": [{"comment_text": "", "digests": {"md5": "2828ff79fa381cc6fae797d2bf25fa19", "sha256": "4025711704eed55676667a5735d0c94127515f6a082081543c982a7556321e9b"}, "downloads": -1, "filename": "metacell-0.5.50.tar.gz", "has_sig": false, "md5_digest": "2828ff79fa381cc6fae797d2bf25fa19", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 254858, "upload_time": "2020-02-03T11:29:37", "upload_time_iso_8601": "2020-02-03T11:29:37.520514Z", "url": "https://files.pythonhosted.org/packages/43/cb/d7c6725a02bb63beec8f42e5193aa6c35f17d0b482545678e88795ef4dfe/metacell-0.5.50.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2828ff79fa381cc6fae797d2bf25fa19", "sha256": "4025711704eed55676667a5735d0c94127515f6a082081543c982a7556321e9b"}, "downloads": -1, "filename": "metacell-0.5.50.tar.gz", "has_sig": false, "md5_digest": "2828ff79fa381cc6fae797d2bf25fa19", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 254858, "upload_time": "2020-02-03T11:29:37", "upload_time_iso_8601": "2020-02-03T11:29:37.520514Z", "url": "https://files.pythonhosted.org/packages/43/cb/d7c6725a02bb63beec8f42e5193aa6c35f17d0b482545678e88795ef4dfe/metacell-0.5.50.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:55:58 2020"}