{"info": {"author": "Peter Bengtsson", "author_email": "mail@peterbe.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment :: Mozilla", "Framework :: Django", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Topic :: Internet :: WWW/HTTP"], "description": "====================\ndjango-cache-memoize\n====================\n\n.. image:: https://travis-ci.org/peterbe/django-cache-memoize.svg?branch=master\n   :alt: Build Status\n   :target: https://travis-ci.org/peterbe/django-cache-memoize\n\n.. image:: https://readthedocs.org/projects/django-cache-memoize/badge/?version=latest\n   :alt: Documentation Status\n   :target: https://django-cache-memoize.readthedocs.io/en/latest/?badge=latest\n\n.. image:: https://codecov.io/gh/peterbe/django-cache-memoize/branch/master/graph/badge.svg\n   :alt: Code Coverage\n   :target: https://codecov.io/gh/peterbe/django-cache-memoize\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n  :target: https://github.com/ambv/black\n\nDjango utility for a memoization decorator that uses the Django cache framework.\n\nKey Features\n------------\n\n* Memoized function calls can be invalidated.\n\n* Works with non-trivial arguments and keyword arguments\n\n* Insight into cache hits and cache missed with a callback.\n\n* Ability to use as a \"guard\" for repeated execution when storing the function\n  result isn't important or needed.\n\n\nInstallation\n============\n\n.. code-block:: python\n\n    pip install django-cache-memoize\n\nUsage\n=====\n\n.. code-block:: python\n\n    # Import the decorator\n    from cache_memoize import cache_memoize\n\n    # Attach decorator to cacheable function with a timeout of 100 seconds.\n    @cache_memoize(100)\n    def expensive_function(start, end):\n        return random.randint(start, end)\n\n    # Just a regular Django view\n    def myview(request):\n        # If you run this view repeatedly you'll get the same\n        # output every time for 100 seconds.\n        return http.HttpResponse(str(expensive_function(0, 100)))\n\n\nThe caching uses `Django's default cache framework`_. Ultimately, it calls\n``django.core.cache.cache.set(cache_key, function_out, expiration)``.\nSo if you have a function that returns something that can't be pickled and\ncached it won't work.\n\n    For cases like this, Django exposes a simple, low-level cache API. You can\n    use this API to store objects in the cache with any level of granularity\n    you like. You can cache any Python object that can be pickled safely:\n    strings, dictionaries, lists of model objects, and so forth. (Most\n    common Python objects can be pickled; refer to the Python documentation\n    for more information about pickling.)\n\nSee `documentation`_.\n\n\n.. _`Django's default cache framework`: https://docs.djangoproject.com/en/1.11/topics/cache/\n.. _`documentation`: https://docs.djangoproject.com/en/1.11/topics/cache/#the-low-level-cache-api\n\n\nExample Usage\n=============\n\nThis blog post: `How to use django-cache-memoize`_\n\nIt demonstrates similarly to the above Usage example but with a little more\ndetail. In particular it demonstrates the difference between *not* using\n``django-cache-memoize`` and then adding it to your code after.\n\n.. _`How to use django-cache-memoize`: https://www.peterbe.com/plog/how-to-use-django-cache-memoize\n\nAdvanced Usage\n==============\n\n``args_rewrite``\n~~~~~~~~~~~~~~~~\n\nInternally the decorator rewrites every argument and keyword argument to\nthe function it wraps into a concatenated string. The first thing you\nmight want to do is help the decorator rewrite the arguments to something\nmore suitable as a cache key string. For example, suppose you have instances\nof a class whose ``__str__`` method doesn't return a unique value. For example:\n\n.. code-block:: python\n\n    class Record(models.Model):\n        name = models.CharField(max_length=100)\n        lastname = models.CharField(max_length=100)\n        friends = models.ManyToManyField(SomeOtherModel)\n\n        def __str__(self):\n            return self.name\n\n    # Example use:\n    >>> record = Record.objects.create(name='Peter', lastname='Bengtsson')\n    >>> print(record)\n    Peter\n    >>> record2 = Record.objects.create(name='Peter', lastname='Different')\n    >>> print(record2)\n    Peter\n\nThis is a contrived example, but basically *you know* that the ``str()``\nconversion of certain arguments isn't safe. Then you can pass in a callable\ncalled ``args_rewrite``. It gets the same positional and keyword arguments\nas the function you're decorating. Here's an example implementation:\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    def count_friends_args_rewrite(record):\n        # The 'id' is always unique. Use that instead of the default __str__\n        return record.id\n\n    @cache_memoize(100, args_rewrite=count_friends_args_rewrite)\n    def count_friends(record):\n        # Assume this is an expensive function that can be memoize cached.\n        return record.friends.all().count()\n\n\n``prefix``\n~~~~~~~~~~\n\nBy default the prefix becomes the name of the function. Consider:\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    @cache_memoize(10, prefix='randomness')\n    def function1():\n        return random.random()\n\n    @cache_memoize(10, prefix='randomness')\n    def function2():  # different name, same arguments, same functionality\n        return random.random()\n\n    # Example use\n    >>> function1()\n    0.39403406043780986\n    >>> function1()\n    0.39403406043780986\n    >>> # ^ repeated of course\n    >>> function2()\n    0.39403406043780986\n    >>> # ^ because the prefix was forcibly the same, the cache key is the same\n\n\n``hit_callable``\n~~~~~~~~~~~~~~~~\n\nIf set, a function that gets called with the original argument and keyword\narguments **if** the cache was able to find and return a cache hit.\nFor example, suppose you want to tell your ``statsd`` server every time\nthere's a cache hit.\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    def _cache_hit(user, **kwargs):\n        statsdthing.incr(f'cachehit:{user.id}', 1)\n\n    @cache_memoize(10, hit_callable=_cache_hit)\n    def calculate_tax(user, tax=0.1):\n        return ...\n\n\n``miss_callable``\n~~~~~~~~~~~~~~~~~\n\nExact same functionality as ``hit_callable`` except the obvious difference\nthat it gets called if it was *not* a cache hit.\n\n``store_result``\n~~~~~~~~~~~~~~~~\n\nThis is useful if you have a function you want to make sure only gets called\nonce per timeout expiration but you don't actually care that much about\nwhat the function return value was. Perhaps because you know that the\nfunction returns something that would quickly fill up your ``memcached`` or\nperhaps you know it returns something that can't be pickled. Then you\ncan set ``store_result`` to ``False``. This is equivalent to your function\nreturning ``True``.\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    @cache_memoize(1000, store_result=False)\n    def send_tax_returns(user):\n        # something something time consuming\n        ...\n        return some_none_pickleable_thing\n\n    def myview(request):\n        # View this view as much as you like the 'send_tax_returns' function\n        # won't be called more than once every 1000 seconds.\n        send_tax_returns(request.user)\n\n``cache_alias``\n~~~~~~~~~~~~~~~\n\nThe ``cache_alias`` argument allows you to use a cache other than the default.\n\n.. code-block:: python\n\n    # Given settings like:\n    # CACHES = {\n    #     'default': {...},\n    #     'other': {...},\n    # }\n\n    @cache_memoize(1000, cache_alias='other')\n    def myfunc(start, end):\n        return random.random()\n\n\nCache invalidation\n~~~~~~~~~~~~~~~~~~\n\nWhen you want to \"undo\" some caching done, you simple call the function\nagain with the same arguments except you add ``.invalidate`` to the function.\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    @cache_memoize(10)\n    def expensive_function(start, end):\n        return random.randint(start, end)\n\n    >>> expensive_function(1, 100)\n    65\n    >>> expensive_function(1, 100)\n    65\n    >>> expensive_function(100, 200)\n    121\n    >>> exensive_function.invalidate(1, 200)\n    >>> expensive_function(1, 100)\n    89\n    >>> expensive_function(100, 200)\n    121\n\nAn \"alias\" of doing the same thing is to pass a keyword argument called\n``_refresh=True``. Like this:\n\n.. code-block:: python\n\n    # Continuing from the code block above\n    >>> expensive_function(100, 200)\n    121\n    >>> expensive_function(100, 200, _refresh=True)\n    177\n    >>> expensive_function(100, 200)\n    177\n\nThere is no way to clear more than one cache key. In the above example,\nyou had to know the \"original arguments\" when you wanted to invalidate\nthe cache. There is no method \"search\" for all cache keys that match a\ncertain pattern.\n\n\nCompatibility\n=============\n\n* Python 2.7, 3.4, 3.5, 3.6\n\n* Django 1.8, 1.9, 1.10, 1.11, 2.0, 2.1\n\nCheck out the `tox.ini`_ file for more up-to-date compatibility by\ntest coverage.\n\n.. _`tox.ini`: https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini\n\nPrior Art\n=========\n\nHistory\n~~~~~~~\n\n`Mozilla Symbol Server`_ is written in Django. It's a web service that\nsits between C++ debuggers and AWS S3. It shuffles symbol files in and out of\nAWS S3. Symbol files are for C++ (and other compiled languages) what\nsourcemaps are for JavaScript.\n\nThis service gets a LOT of traffic. The download traffic (proxying requests\nfor symbols in S3) gets about ~40 requests per second. Due to the nature\nof the application most of these GETs result in a 404 Not Found but instead\nof asking AWS S3 for every single file, these lookups are cached in a\nhighly configured `Redis`_ configuration. This Redis cache is also connected\nto the part of the code that uploads new files.\n\nNew uploads are arriving as zip file bundles of files, from Mozilla's build\nsystems, at a rate of about 600MB every minute, each containing on average\nabout 100 files each. When a new upload comes in we need to quickly be able\nfind out if it exists in S3 and this gets cached since often the same files\nare repeated in different uploads. But when a file does get uploaded into S3\nwe need to quickly and confidently invalidate any local caches. That way you\nget to keep a really aggressive cache without any stale periods.\n\nThis is the use case ``django-cache-memoize`` was built for and tested in.\nIt was originally written for Python 3.6 in Django 1.11 but when\nextracted, made compatible with Python 2.7 and as far back as Django 1.8.\n\n``django-cache-memoize`` is also used in `SongSear.ch`_ to cache short\nqueries in the autocomplete search input. All autocomplete is done by\nElasticsearch, which is amazingly fast, but not as fast as ``memcached``.\n\n\n.. _`Mozilla Symbol Server`: https://symbols.mozilla.org\n.. _`Redis`: https://redis.io/\n.. _`SongSear.ch`: https://songsear.ch\n\n\n\"Competition\"\n~~~~~~~~~~~~~\n\nThere is already `django-memoize`_ by `Thomas Vavrys`_.\nIt too is available as a memoization decorator you use in Django. And it\nuses the default cache framework as a storage. It used ``inspect`` on the\ndecorated function to build a cache key.\n\nIn benchmarks running both ``django-memoize`` and ``django-cache-memoize``\nI found ``django-cache-memoize`` to be **~4 times faster** on average.\n\nAnother key difference is that ``django-cache-memoize`` uses ``str()`` and\n``django-memoize`` uses ``repr()`` which in certain cases of mutable objects\n(e.g. class instances) as arguments the caching will not work. For example,\nthis does *not* work in ``django-memoize``:\n\n.. code-block:: python\n\n    from memoize import memoize\n\n    @memoize(60)\n    def count_user_groups(user):\n        return user.groups.all().count()\n\n    def myview(request):\n        # this will never be memoized\n        print(count_user_groups(request.user))\n\nHowever, this works...\n\n.. code-block:: python\n\n    from cache_memoize import cache_memoize\n\n    @cache_memoize(60)\n    def count_user_groups(user):\n        return user.groups.all().count()\n\n    def myview(request):\n        # this *will* work as expected\n        print(count_user_groups(request.user))\n\n\n.. _`django-memoize`: http://pythonhosted.org/django-memoize/\n.. _`Thomas Vavrys`: https://github.com/tvavrys\n\n\nDevelopment\n===========\n\nThe most basic thing is to clone the repo and run:\n\n.. code-block:: shell\n\n    pip install -e \".[dev]\"\n    tox\n\n\nCode style is all black\n~~~~~~~~~~~~~~~~~~~~~~~\n\nAll code has to be formatted with `Black <https://pypi.org/project/black/>`_\nand the best tool for checking this is\n`therapist <https://pypi.org/project/therapist/>`_ since it can help you run\nall, help you fix things, and help you make sure linting is passing before\nyou git commit. This project also uses ``flake8`` to check other things\nBlack can't check.\n\nTo check linting with ``tox`` use:\n\n.. code:: bash\n\n    tox -e lint-py36\n\nTo install the ``therapist`` pre-commit hook simply run:\n\n.. code:: bash\n\n    therapist install\n\nWhen you run ``therapist run`` it will only check the files you've touched.\nTo run it for all files use:\n\n.. code:: bash\n\n    therapist run --use-tracked-files\n\nAnd to fix all/any issues run:\n\n.. code:: bash\n\n    therapist run --use-tracked-files --fix", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/peterbe/django-cache-memoize", "keywords": "django,memoize,cache,decorator", "license": "MPL 2.0", "maintainer": "", "maintainer_email": "", "name": "django-cache-memoize", "package_url": "https://pypi.org/project/django-cache-memoize/", "platform": "", "project_url": "https://pypi.org/project/django-cache-memoize/", "project_urls": {"Homepage": "https://github.com/peterbe/django-cache-memoize"}, "release_url": "https://pypi.org/project/django-cache-memoize/0.1.6/", "requires_dist": null, "requires_python": "", "summary": "Django utility for a memoization decorator that uses the Django cache framework.", "version": "0.1.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/peterbe/django-cache-memoize\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ba043006b1d6c90f504a423970a0262b02c63271/68747470733a2f2f7472617669732d63692e6f72672f706574657262652f646a616e676f2d63616368652d6d656d6f697a652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://django-cache-memoize.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e2c3930ff1dac7ac104e6b715e27a7bd67a06ec7/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f646a616e676f2d63616368652d6d656d6f697a652f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<a href=\"https://codecov.io/gh/peterbe/django-cache-memoize\" rel=\"nofollow\"><img alt=\"Code Coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c6161220f8a55b5e8697634533369514f5a88ce1/68747470733a2f2f636f6465636f762e696f2f67682f706574657262652f646a616e676f2d63616368652d6d656d6f697a652f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<a href=\"https://github.com/ambv/black\" rel=\"nofollow\"><img alt=\"https://img.shields.io/badge/code%20style-black-000000.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fbfdc7754183ecf079bc71ddeabaf88f6cbc5c00/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e737667\"></a>\n<p>Django utility for a memoization decorator that uses the Django cache framework.</p>\n<div id=\"key-features\">\n<h2>Key Features</h2>\n<ul>\n<li>Memoized function calls can be invalidated.</li>\n<li>Works with non-trivial arguments and keyword arguments</li>\n<li>Insight into cache hits and cache missed with a callback.</li>\n<li>Ability to use as a \u201cguard\u201d for repeated execution when storing the function\nresult isn\u2019t important or needed.</li>\n</ul>\n<div id=\"installation\">\n<h3>Installation</h3>\n<pre><span class=\"n\">pip</span> <span class=\"n\">install</span> <span class=\"n\">django</span><span class=\"o\">-</span><span class=\"n\">cache</span><span class=\"o\">-</span><span class=\"n\">memoize</span>\n</pre>\n</div>\n<div id=\"usage\">\n<h3>Usage</h3>\n<pre><span class=\"c1\"># Import the decorator</span>\n<span class=\"kn\">from</span> <span class=\"nn\">cache_memoize</span> <span class=\"kn\">import</span> <span class=\"n\">cache_memoize</span>\n\n<span class=\"c1\"># Attach decorator to cacheable function with a timeout of 100 seconds.</span>\n<span class=\"nd\">@cache_memoize</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">expensive_function</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Just a regular Django view</span>\n<span class=\"k\">def</span> <span class=\"nf\">myview</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"c1\"># If you run this view repeatedly you'll get the same</span>\n    <span class=\"c1\"># output every time for 100 seconds.</span>\n    <span class=\"k\">return</span> <span class=\"n\">http</span><span class=\"o\">.</span><span class=\"n\">HttpResponse</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">expensive_function</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)))</span>\n</pre>\n<p>The caching uses <a href=\"https://docs.djangoproject.com/en/1.11/topics/cache/\" rel=\"nofollow\">Django\u2019s default cache framework</a>. Ultimately, it calls\n<tt>django.core.cache.cache.set(cache_key, function_out, expiration)</tt>.\nSo if you have a function that returns something that can\u2019t be pickled and\ncached it won\u2019t work.</p>\n<blockquote>\nFor cases like this, Django exposes a simple, low-level cache API. You can\nuse this API to store objects in the cache with any level of granularity\nyou like. You can cache any Python object that can be pickled safely:\nstrings, dictionaries, lists of model objects, and so forth. (Most\ncommon Python objects can be pickled; refer to the Python documentation\nfor more information about pickling.)</blockquote>\n<p>See <a href=\"https://docs.djangoproject.com/en/1.11/topics/cache/#the-low-level-cache-api\" rel=\"nofollow\">documentation</a>.</p>\n</div>\n<div id=\"example-usage\">\n<h3>Example Usage</h3>\n<p>This blog post: <a href=\"https://www.peterbe.com/plog/how-to-use-django-cache-memoize\" rel=\"nofollow\">How to use django-cache-memoize</a></p>\n<p>It demonstrates similarly to the above Usage example but with a little more\ndetail. In particular it demonstrates the difference between <em>not</em> using\n<tt><span class=\"pre\">django-cache-memoize</span></tt> and then adding it to your code after.</p>\n</div>\n<div id=\"advanced-usage\">\n<h3>Advanced Usage</h3>\n<div id=\"args-rewrite\">\n<h4><tt>args_rewrite</tt></h4>\n<p>Internally the decorator rewrites every argument and keyword argument to\nthe function it wraps into a concatenated string. The first thing you\nmight want to do is help the decorator rewrite the arguments to something\nmore suitable as a cache key string. For example, suppose you have instances\nof a class whose <tt>__str__</tt> method doesn\u2019t return a unique value. For example:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Record</span><span class=\"p\">(</span><span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">):</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n    <span class=\"n\">lastname</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">CharField</span><span class=\"p\">(</span><span class=\"n\">max_length</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n    <span class=\"n\">friends</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">ManyToManyField</span><span class=\"p\">(</span><span class=\"n\">SomeOtherModel</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__str__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">name</span>\n\n<span class=\"c1\"># Example use:</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">record</span> <span class=\"o\">=</span> <span class=\"n\">Record</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'Peter'</span><span class=\"p\">,</span> <span class=\"n\">lastname</span><span class=\"o\">=</span><span class=\"s1\">'Bengtsson'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">record</span><span class=\"p\">)</span>\n<span class=\"n\">Peter</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">record2</span> <span class=\"o\">=</span> <span class=\"n\">Record</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'Peter'</span><span class=\"p\">,</span> <span class=\"n\">lastname</span><span class=\"o\">=</span><span class=\"s1\">'Different'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">record2</span><span class=\"p\">)</span>\n<span class=\"n\">Peter</span>\n</pre>\n<p>This is a contrived example, but basically <em>you know</em> that the <tt>str()</tt>\nconversion of certain arguments isn\u2019t safe. Then you can pass in a callable\ncalled <tt>args_rewrite</tt>. It gets the same positional and keyword arguments\nas the function you\u2019re decorating. Here\u2019s an example implementation:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cache_memoize</span> <span class=\"kn\">import</span> <span class=\"n\">cache_memoize</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">count_friends_args_rewrite</span><span class=\"p\">(</span><span class=\"n\">record</span><span class=\"p\">):</span>\n    <span class=\"c1\"># The 'id' is always unique. Use that instead of the default __str__</span>\n    <span class=\"k\">return</span> <span class=\"n\">record</span><span class=\"o\">.</span><span class=\"n\">id</span>\n\n<span class=\"nd\">@cache_memoize</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">args_rewrite</span><span class=\"o\">=</span><span class=\"n\">count_friends_args_rewrite</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">count_friends</span><span class=\"p\">(</span><span class=\"n\">record</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Assume this is an expensive function that can be memoize cached.</span>\n    <span class=\"k\">return</span> <span class=\"n\">record</span><span class=\"o\">.</span><span class=\"n\">friends</span><span class=\"o\">.</span><span class=\"n\">all</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"prefix\">\n<h4><tt>prefix</tt></h4>\n<p>By default the prefix becomes the name of the function. Consider:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cache_memoize</span> <span class=\"kn\">import</span> <span class=\"n\">cache_memoize</span>\n\n<span class=\"nd\">@cache_memoize</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">'randomness'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">function1</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">()</span>\n\n<span class=\"nd\">@cache_memoize</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">'randomness'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">function2</span><span class=\"p\">():</span>  <span class=\"c1\"># different name, same arguments, same functionality</span>\n    <span class=\"k\">return</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Example use</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">function1</span><span class=\"p\">()</span>\n<span class=\"mf\">0.39403406043780986</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">function1</span><span class=\"p\">()</span>\n<span class=\"mf\">0.39403406043780986</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># ^ repeated of course</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">function2</span><span class=\"p\">()</span>\n<span class=\"mf\">0.39403406043780986</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># ^ because the prefix was forcibly the same, the cache key is the same</span>\n</pre>\n</div>\n<div id=\"hit-callable\">\n<h4><tt>hit_callable</tt></h4>\n<p>If set, a function that gets called with the original argument and keyword\narguments <strong>if</strong> the cache was able to find and return a cache hit.\nFor example, suppose you want to tell your <tt>statsd</tt> server every time\nthere\u2019s a cache hit.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cache_memoize</span> <span class=\"kn\">import</span> <span class=\"n\">cache_memoize</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">_cache_hit</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"n\">statsdthing</span><span class=\"o\">.</span><span class=\"n\">incr</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'cachehit:</span><span class=\"si\">{</span><span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@cache_memoize</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">hit_callable</span><span class=\"o\">=</span><span class=\"n\">_cache_hit</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">calculate_tax</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">,</span> <span class=\"n\">tax</span><span class=\"o\">=</span><span class=\"mf\">0.1</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"o\">...</span>\n</pre>\n</div>\n<div id=\"miss-callable\">\n<h4><tt>miss_callable</tt></h4>\n<p>Exact same functionality as <tt>hit_callable</tt> except the obvious difference\nthat it gets called if it was <em>not</em> a cache hit.</p>\n</div>\n<div id=\"store-result\">\n<h4><tt>store_result</tt></h4>\n<p>This is useful if you have a function you want to make sure only gets called\nonce per timeout expiration but you don\u2019t actually care that much about\nwhat the function return value was. Perhaps because you know that the\nfunction returns something that would quickly fill up your <tt>memcached</tt> or\nperhaps you know it returns something that can\u2019t be pickled. Then you\ncan set <tt>store_result</tt> to <tt>False</tt>. This is equivalent to your function\nreturning <tt>True</tt>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cache_memoize</span> <span class=\"kn\">import</span> <span class=\"n\">cache_memoize</span>\n\n<span class=\"nd\">@cache_memoize</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"n\">store_result</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">send_tax_returns</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">):</span>\n    <span class=\"c1\"># something something time consuming</span>\n    <span class=\"o\">...</span>\n    <span class=\"k\">return</span> <span class=\"n\">some_none_pickleable_thing</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">myview</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"c1\"># View this view as much as you like the 'send_tax_returns' function</span>\n    <span class=\"c1\"># won't be called more than once every 1000 seconds.</span>\n    <span class=\"n\">send_tax_returns</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">user</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"cache-alias\">\n<h4><tt>cache_alias</tt></h4>\n<p>The <tt>cache_alias</tt> argument allows you to use a cache other than the default.</p>\n<pre><span class=\"c1\"># Given settings like:</span>\n<span class=\"c1\"># CACHES = {</span>\n<span class=\"c1\">#     'default': {...},</span>\n<span class=\"c1\">#     'other': {...},</span>\n<span class=\"c1\"># }</span>\n\n<span class=\"nd\">@cache_memoize</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">,</span> <span class=\"n\">cache_alias</span><span class=\"o\">=</span><span class=\"s1\">'other'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">myfunc</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"cache-invalidation\">\n<h4>Cache invalidation</h4>\n<p>When you want to \u201cundo\u201d some caching done, you simple call the function\nagain with the same arguments except you add <tt>.invalidate</tt> to the function.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cache_memoize</span> <span class=\"kn\">import</span> <span class=\"n\">cache_memoize</span>\n\n<span class=\"nd\">@cache_memoize</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">expensive_function</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">end</span><span class=\"p\">)</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">expensive_function</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"mi\">65</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">expensive_function</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"mi\">65</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">expensive_function</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">)</span>\n<span class=\"mi\">121</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">exensive_function</span><span class=\"o\">.</span><span class=\"n\">invalidate</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">expensive_function</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"mi\">89</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">expensive_function</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">)</span>\n<span class=\"mi\">121</span>\n</pre>\n<p>An \u201calias\u201d of doing the same thing is to pass a keyword argument called\n<tt>_refresh=True</tt>. Like this:</p>\n<pre><span class=\"c1\"># Continuing from the code block above</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">expensive_function</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">)</span>\n<span class=\"mi\">121</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">expensive_function</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"n\">_refresh</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"mi\">177</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">expensive_function</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">)</span>\n<span class=\"mi\">177</span>\n</pre>\n<p>There is no way to clear more than one cache key. In the above example,\nyou had to know the \u201coriginal arguments\u201d when you wanted to invalidate\nthe cache. There is no method \u201csearch\u201d for all cache keys that match a\ncertain pattern.</p>\n</div>\n</div>\n<div id=\"compatibility\">\n<h3>Compatibility</h3>\n<ul>\n<li>Python 2.7, 3.4, 3.5, 3.6</li>\n<li>Django 1.8, 1.9, 1.10, 1.11, 2.0, 2.1</li>\n</ul>\n<p>Check out the <a href=\"https://github.com/peterbe/django-cache-memoize/blob/master/tox.ini\" rel=\"nofollow\">tox.ini</a> file for more up-to-date compatibility by\ntest coverage.</p>\n</div>\n<div id=\"prior-art\">\n<h3>Prior Art</h3>\n<div id=\"history\">\n<h4>History</h4>\n<p><a href=\"https://symbols.mozilla.org\" rel=\"nofollow\">Mozilla Symbol Server</a> is written in Django. It\u2019s a web service that\nsits between C++ debuggers and AWS S3. It shuffles symbol files in and out of\nAWS S3. Symbol files are for C++ (and other compiled languages) what\nsourcemaps are for JavaScript.</p>\n<p>This service gets a LOT of traffic. The download traffic (proxying requests\nfor symbols in S3) gets about ~40 requests per second. Due to the nature\nof the application most of these GETs result in a 404 Not Found but instead\nof asking AWS S3 for every single file, these lookups are cached in a\nhighly configured <a href=\"https://redis.io/\" rel=\"nofollow\">Redis</a> configuration. This Redis cache is also connected\nto the part of the code that uploads new files.</p>\n<p>New uploads are arriving as zip file bundles of files, from Mozilla\u2019s build\nsystems, at a rate of about 600MB every minute, each containing on average\nabout 100 files each. When a new upload comes in we need to quickly be able\nfind out if it exists in S3 and this gets cached since often the same files\nare repeated in different uploads. But when a file does get uploaded into S3\nwe need to quickly and confidently invalidate any local caches. That way you\nget to keep a really aggressive cache without any stale periods.</p>\n<p>This is the use case <tt><span class=\"pre\">django-cache-memoize</span></tt> was built for and tested in.\nIt was originally written for Python 3.6 in Django 1.11 but when\nextracted, made compatible with Python 2.7 and as far back as Django 1.8.</p>\n<p><tt><span class=\"pre\">django-cache-memoize</span></tt> is also used in <a href=\"https://songsear.ch\" rel=\"nofollow\">SongSear.ch</a> to cache short\nqueries in the autocomplete search input. All autocomplete is done by\nElasticsearch, which is amazingly fast, but not as fast as <tt>memcached</tt>.</p>\n</div>\n<div id=\"competition\">\n<h4>\u201cCompetition\u201d</h4>\n<p>There is already <a href=\"http://pythonhosted.org/django-memoize/\" rel=\"nofollow\">django-memoize</a> by <a href=\"https://github.com/tvavrys\" rel=\"nofollow\">Thomas Vavrys</a>.\nIt too is available as a memoization decorator you use in Django. And it\nuses the default cache framework as a storage. It used <tt>inspect</tt> on the\ndecorated function to build a cache key.</p>\n<p>In benchmarks running both <tt><span class=\"pre\">django-memoize</span></tt> and <tt><span class=\"pre\">django-cache-memoize</span></tt>\nI found <tt><span class=\"pre\">django-cache-memoize</span></tt> to be <strong>~4 times faster</strong> on average.</p>\n<p>Another key difference is that <tt><span class=\"pre\">django-cache-memoize</span></tt> uses <tt>str()</tt> and\n<tt><span class=\"pre\">django-memoize</span></tt> uses <tt>repr()</tt> which in certain cases of mutable objects\n(e.g. class instances) as arguments the caching will not work. For example,\nthis does <em>not</em> work in <tt><span class=\"pre\">django-memoize</span></tt>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">memoize</span> <span class=\"kn\">import</span> <span class=\"n\">memoize</span>\n\n<span class=\"nd\">@memoize</span><span class=\"p\">(</span><span class=\"mi\">60</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">count_user_groups</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">groups</span><span class=\"o\">.</span><span class=\"n\">all</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">()</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">myview</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"c1\"># this will never be memoized</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">count_user_groups</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">user</span><span class=\"p\">))</span>\n</pre>\n<p>However, this works\u2026</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cache_memoize</span> <span class=\"kn\">import</span> <span class=\"n\">cache_memoize</span>\n\n<span class=\"nd\">@cache_memoize</span><span class=\"p\">(</span><span class=\"mi\">60</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">count_user_groups</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">groups</span><span class=\"o\">.</span><span class=\"n\">all</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">()</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">myview</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"c1\"># this *will* work as expected</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">count_user_groups</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">user</span><span class=\"p\">))</span>\n</pre>\n</div>\n</div>\n<div id=\"development\">\n<h3>Development</h3>\n<p>The most basic thing is to clone the repo and run:</p>\n<pre>pip install -e <span class=\"s2\">\".[dev]\"</span>\ntox\n</pre>\n<div id=\"code-style-is-all-black\">\n<h4>Code style is all black</h4>\n<p>All code has to be formatted with <a href=\"https://pypi.org/project/black/\" rel=\"nofollow\">Black</a>\nand the best tool for checking this is\n<a href=\"https://pypi.org/project/therapist/\" rel=\"nofollow\">therapist</a> since it can help you run\nall, help you fix things, and help you make sure linting is passing before\nyou git commit. This project also uses <tt>flake8</tt> to check other things\nBlack can\u2019t check.</p>\n<p>To check linting with <tt>tox</tt> use:</p>\n<pre>tox -e lint-py36\n</pre>\n<p>To install the <tt>therapist</tt> pre-commit hook simply run:</p>\n<pre>therapist install\n</pre>\n<p>When you run <tt>therapist run</tt> it will only check the files you\u2019ve touched.\nTo run it for all files use:</p>\n<pre>therapist run --use-tracked-files\n</pre>\n<p>And to fix all/any issues run:</p>\n<pre>therapist run --use-tracked-files --fix\n</pre>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4638079, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "4760496227c7a6f09268b682622abb0b", "sha256": "782b1b0b61c4639d1c10cfcaf6aa2c8a5f56229a0f59d67cde82c3c684842c63"}, "downloads": -1, "filename": "django_cache_memoize-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "4760496227c7a6f09268b682622abb0b", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 10034, "upload_time": "2017-10-27T19:55:01", "upload_time_iso_8601": "2017-10-27T19:55:01.861393Z", "url": "https://files.pythonhosted.org/packages/86/d2/ddf6d04bf1c8c36c02c49d445fd254ec52badb6cff6e97165bb3a44ba008/django_cache_memoize-0.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ed7b1466c6b1c6b9e210bb2a4232819b", "sha256": "b4b3e6a319bd9357e6d4e44d528eac31c9d22b3ddb410d50c56ce71200def058"}, "downloads": -1, "filename": "django-cache-memoize-0.1.0.tar.gz", "has_sig": false, "md5_digest": "ed7b1466c6b1c6b9e210bb2a4232819b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7256, "upload_time": "2017-10-27T19:55:03", "upload_time_iso_8601": "2017-10-27T19:55:03.696056Z", "url": "https://files.pythonhosted.org/packages/7b/65/c2137f993b2a50366dcef1bdc420c51df1cddb049a7889944b356c77095f/django-cache-memoize-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "d32667691b122953f9114518ace0c017", "sha256": "12c3359b7f48bf34db739732eae66d9f4b6103093382fa5723774d10be4c352f"}, "downloads": -1, "filename": "django_cache_memoize-0.1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d32667691b122953f9114518ace0c017", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 11691, "upload_time": "2017-10-27T20:21:41", "upload_time_iso_8601": "2017-10-27T20:21:41.393054Z", "url": "https://files.pythonhosted.org/packages/58/76/9e05e2cb0d647a4c0f5ddee112645cc43390972d29c047721141c4d3b40f/django_cache_memoize-0.1.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "033ca668784754865e3caa8e20bc6445", "sha256": "e04b84b18430dd75a62da6a367b64042bbac8def8aa765d32d6eb74bc3423580"}, "downloads": -1, "filename": "django-cache-memoize-0.1.1.tar.gz", "has_sig": false, "md5_digest": "033ca668784754865e3caa8e20bc6445", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8543, "upload_time": "2017-10-27T20:21:43", "upload_time_iso_8601": "2017-10-27T20:21:43.400166Z", "url": "https://files.pythonhosted.org/packages/4d/59/9c3b44b909d8ad6a1374801b081f3478dcdf7968013c445f698793270278/django-cache-memoize-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "9a5fef6d2dcd99876b60140a455f8808", "sha256": "43065e2d3b07f3b4316dd1dd3fe036d519b71cf791a3a0a20a05fb42a9ab8da6"}, "downloads": -1, "filename": "django_cache_memoize-0.1.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9a5fef6d2dcd99876b60140a455f8808", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 7140, "upload_time": "2018-08-10T12:48:16", "upload_time_iso_8601": "2018-08-10T12:48:16.266256Z", "url": "https://files.pythonhosted.org/packages/d5/15/1bc8f16a524ef8e83f43cc3ec9cb8dea2e9dd3c98f1b5e832d19254a700a/django_cache_memoize-0.1.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "78dc4249418aca9b4bfe32d70fb113dd", "sha256": "42b4497060fd9a152984f61c3f9fa48432534a62e4cd69264199c19f805828d7"}, "downloads": -1, "filename": "django-cache-memoize-0.1.2.tar.gz", "has_sig": false, "md5_digest": "78dc4249418aca9b4bfe32d70fb113dd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9023, "upload_time": "2018-08-10T12:48:17", "upload_time_iso_8601": "2018-08-10T12:48:17.602247Z", "url": "https://files.pythonhosted.org/packages/e5/c7/f7fdd4276bce225751e2bb6696fd813d4e79fd23c1eeebe79e699cc950c6/django-cache-memoize-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "36bee4074d36e4480582aad7caf3a860", "sha256": "45c1261ed91cedf863a3f55d9cf1e30cd7bd3221f92235f0a79c4bef7a0889da"}, "downloads": -1, "filename": "django-cache-memoize-0.1.3.tar.gz", "has_sig": false, "md5_digest": "36bee4074d36e4480582aad7caf3a860", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9117, "upload_time": "2018-11-03T00:46:59", "upload_time_iso_8601": "2018-11-03T00:46:59.121406Z", "url": "https://files.pythonhosted.org/packages/5e/a8/3a8a66d5b5eb9d563662841844be9e8eee42f84b6c6dd9d6a384b9b10dc1/django-cache-memoize-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "66458546045b64d4d2f6a16429bdf185", "sha256": "1d8f7625762b92605287f9cff4b59b2dcee19d30904c86bbbe51db822a81fcec"}, "downloads": -1, "filename": "django-cache-memoize-0.1.4.tar.gz", "has_sig": false, "md5_digest": "66458546045b64d4d2f6a16429bdf185", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9397, "upload_time": "2018-12-03T12:25:20", "upload_time_iso_8601": "2018-12-03T12:25:20.548545Z", "url": "https://files.pythonhosted.org/packages/58/d8/f05e0ce93f1c96d21d0c636c776dffbe25152c1c1f3812db38f6a492c713/django-cache-memoize-0.1.4.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "17f13a05c1577fe16a3f2a77d7ed5215", "sha256": "fe72f087f8e3c1a77e1152c38f6fb6c36b99626d3683a4c844eea99e03a7d885"}, "downloads": -1, "filename": "django-cache-memoize-0.1.5.tar.gz", "has_sig": false, "md5_digest": "17f13a05c1577fe16a3f2a77d7ed5215", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10153, "upload_time": "2018-12-04T21:48:41", "upload_time_iso_8601": "2018-12-04T21:48:41.818150Z", "url": "https://files.pythonhosted.org/packages/26/f5/c9631bd172489c18596ad8d408f6abcf61299abb42f183ed53727f75f15c/django-cache-memoize-0.1.5.tar.gz", "yanked": false}], "0.1.6": [{"comment_text": "", "digests": {"md5": "6ee090b7b074b45cc02a6c29474fe09a", "sha256": "d239e8c37734b0a70b74f94fa33b180b3b0c82c3784beb21209bb4ab64a3e6fb"}, "downloads": -1, "filename": "django_cache_memoize-0.1.6-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "6ee090b7b074b45cc02a6c29474fe09a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8113, "upload_time": "2018-12-27T14:40:58", "upload_time_iso_8601": "2018-12-27T14:40:58.922962Z", "url": "https://files.pythonhosted.org/packages/8e/26/4de73cd5e6b762231dbaee246d7b44a9d5c4bf0b91ddcd1c9d56659db7be/django_cache_memoize-0.1.6-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "aaa29791c9231b86b96fa4c498906060", "sha256": "7f271be70b11155929ee8a4a2b5f53c9fb46b9befa1b546caffa3298e6ac8f7d"}, "downloads": -1, "filename": "django-cache-memoize-0.1.6.tar.gz", "has_sig": false, "md5_digest": "aaa29791c9231b86b96fa4c498906060", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10217, "upload_time": "2018-12-27T14:39:28", "upload_time_iso_8601": "2018-12-27T14:39:28.352990Z", "url": "https://files.pythonhosted.org/packages/3d/6b/ffaff539fe79f11fb70e8fc1168163aff791e2b50c7078d8d91b5a08e1e6/django-cache-memoize-0.1.6.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "6ee090b7b074b45cc02a6c29474fe09a", "sha256": "d239e8c37734b0a70b74f94fa33b180b3b0c82c3784beb21209bb4ab64a3e6fb"}, "downloads": -1, "filename": "django_cache_memoize-0.1.6-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "6ee090b7b074b45cc02a6c29474fe09a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8113, "upload_time": "2018-12-27T14:40:58", "upload_time_iso_8601": "2018-12-27T14:40:58.922962Z", "url": "https://files.pythonhosted.org/packages/8e/26/4de73cd5e6b762231dbaee246d7b44a9d5c4bf0b91ddcd1c9d56659db7be/django_cache_memoize-0.1.6-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "aaa29791c9231b86b96fa4c498906060", "sha256": "7f271be70b11155929ee8a4a2b5f53c9fb46b9befa1b546caffa3298e6ac8f7d"}, "downloads": -1, "filename": "django-cache-memoize-0.1.6.tar.gz", "has_sig": false, "md5_digest": "aaa29791c9231b86b96fa4c498906060", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10217, "upload_time": "2018-12-27T14:39:28", "upload_time_iso_8601": "2018-12-27T14:39:28.352990Z", "url": "https://files.pythonhosted.org/packages/3d/6b/ffaff539fe79f11fb70e8fc1168163aff791e2b50c7078d8d91b5a08e1e6/django-cache-memoize-0.1.6.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:37:17 2020"}