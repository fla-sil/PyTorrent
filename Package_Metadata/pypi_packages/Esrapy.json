{"info": {"author": "Simon Funk", "author_email": "simonfunk@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: GNU General Public License (GPL)", "Natural Language :: English", "Programming Language :: Python", "Topic :: Software Development :: Compilers", "Topic :: Software Development :: Interpreters", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Software Development :: Pre-processors", "Topic :: Text Processing :: Linguistic"], "description": "Esrapy can parse pretty much any context-free grammar, including left-recursive\r\nones; can compile patterns (grammars) from textual or procedural descriptions;\r\nunifies parsing and tokenizing so tokenization can be contextual; has support\r\nfor precedence (ambiguity resolution) and attributes (limited\r\ncontext-sensitivity); can return \"first match\" or a forrest of all possible\r\nparsings (for an ambiguous grammar); is very easy to use and results in very\r\nreadable applications; and is only about 600 lines of code (not counting\r\ncomments)--or only 450 if you don't need the textual compiler. Esrapy works as a\r\nsimple translator from a raw source text to a friendly(!) parse tree. Much of\r\nthe emphasis in esrapy is in making the returned parse tree very easy to traverse.\r\n\r\nEsrapy is not terribly fast, and may be a bit of a memory hog while it's running\r\n(this may be an understatement). It's probably most useful for language\r\nprototyping or small interactive applications where generality and ease of use\r\nare more important than speed. (I could be wrong about the speed--I haven't run\r\ncomparisons.) The parsing method it uses is somewhere between chart parsing and\r\na packrat recursive descent.\r\n\r\nThere is a very short but complete example given on the home page which\r\nimplements a five function (plus assignment) infix calculator with operator\r\nprecedence.  That should give you a quick idea for what it provides and how to\r\nuse it (as well as how easy it is to use).", "description_content_type": null, "docs_url": null, "download_url": "http://interstice.com/~simon/esrapy/esrapy.latest.tgz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://interstice.com/~simon/esrapy/", "keywords": "parse parser parsing context-free grammar", "license": "GPL", "maintainer": "", "maintainer_email": "", "name": "Esrapy", "package_url": "https://pypi.org/project/Esrapy/", "platform": "", "project_url": "https://pypi.org/project/Esrapy/", "project_urls": {"Download": "http://interstice.com/~simon/esrapy/esrapy.latest.tgz", "Homepage": "http://interstice.com/~simon/esrapy/"}, "release_url": "https://pypi.org/project/Esrapy/0.5/", "requires_dist": null, "requires_python": null, "summary": "Esrapy is an easy-to-use parsing library written entirely in python.", "version": "0.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Esrapy can parse pretty much any context-free grammar, including left-recursive\nones; can compile patterns (grammars) from textual or procedural descriptions;\nunifies parsing and tokenizing so tokenization can be contextual; has support\nfor precedence (ambiguity resolution) and attributes (limited\ncontext-sensitivity); can return \u201cfirst match\u201d or a forrest of all possible\nparsings (for an ambiguous grammar); is very easy to use and results in very\nreadable applications; and is only about 600 lines of code (not counting\ncomments)\u2013or only 450 if you don\u2019t need the textual compiler. Esrapy works as a\nsimple translator from a raw source text to a friendly(!) parse tree. Much of\nthe emphasis in esrapy is in making the returned parse tree very easy to traverse.</p>\n<p>Esrapy is not terribly fast, and may be a bit of a memory hog while it\u2019s running\n(this may be an understatement). It\u2019s probably most useful for language\nprototyping or small interactive applications where generality and ease of use\nare more important than speed. (I could be wrong about the speed\u2013I haven\u2019t run\ncomparisons.) The parsing method it uses is somewhere between chart parsing and\na packrat recursive descent.</p>\n<p>There is a very short but complete example given on the home page which\nimplements a five function (plus assignment) infix calculator with operator\nprecedence.  That should give you a quick idea for what it provides and how to\nuse it (as well as how easy it is to use).</p>\n\n          </div>"}, "last_serial": 10000, "releases": {"0.5": []}, "urls": [], "timestamp": "Fri May  8 00:45:36 2020"}