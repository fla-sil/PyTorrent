{"info": {"author": "Tim Golden", "author_email": "mail@timgolden.me.uk", "bugtrack_url": null, "classifiers": ["Environment :: Console", "Intended Audience :: Developers", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3"], "description": "Board Game for Python Dojos\n===========================\n\nIntroduction\n------------\n\nOften, when running a Python Dojo, we've ended up with a challenge\nbased around some kind of board or tile-based landscape. In these\nsituations it's not uncommon to spend a lot of the time building up\nyour basic board functionality in order to support the more interesting\ngameplay algorithm.\n\nThis module implements a general-purpose board structure which\nhas the functionality needed for a range of purposes, and lends itself\nto being subclassed for those particular needs.\n\nDependencies\n------------\n\nNone - stdlib only\n\nTests\n-----\n\nFairly decent coverage (not actually checked with coverage.py): test.py\n\nGetting Started\n---------------\n\nInstall with pip::\n\n    pip install board\n\nAbsolutely basic usage::\n\n    import board\n    #\n    # Produce a 3x3 board\n    #\n    b = board.Board((3, 3))\n\n    b[0, 0] = \"X\"\n    b[1, 0] = \"O\"\n\nUsage\n-----\n\nBoard is an n-dimensional board, any of which dimensions can be of\ninfinite size. (So if you have, say, 3 infinite dimensions, you have\nthe basis for a Minecraft layout). Dimensions are zero-based and\nnegative indexes operate as they usually do in Python: working from\nthe end of the dimension backwards.\n\nCells on the board are accessed by item access, eg board[1, 2] or\nlandscape[1, 1, 10].\n\nA board can be copied, optionally along with its data by means of the\n.copy method. Or a section of a board can be linked to the original\nboard by slicing the original board::\n\n    b1 = board.Board((9, 9))\n    b1[1, 1] = 1\n    b2 = b1.copy()\n    b3 = b1[:3, :3]\n\nNote that the slice must include all the dimensions of the original\nboard, but any of those subdimensions can be of length 1::\n\n    b1 = board.Board((9, 9, 9))\n    b2 = b1[:3, :3, :1]\n\nA sentinel value of Empty indicates a position which is not populated\nbecause it has never had a value, or because its value has been deleted::\n\n    b1 = board.Board((3, 3))\n    assert b1[1, 1] is board.Empty\n    b1.populate(\"abcdefghi\")\n    assert b1[1, 1] == \"e\"\n    del b1[1, 1]\n    assert b1[1, 1] is board.Empty\n\nIterating over the board yields its coordinates::\n\n    b1 = board.Board((2, 2))\n    for coord in b1:\n        print(coord)\n    #\n    # => (0, 0), (0, 1) etc.\n    #\n\nIteration over a board with one or more infinite dimensions will work\nby iterating in chunks::\n\n    b1 = board.Board((3, 3, board.Infinity))\n    for coord in b1:\n        print(b1)\n\nTo see coordinates with their data items, use iterdata::\n\n    b1 = board.Board((2, 2))\n    b1.populate(\"abcd\")\n    for coord, data in b1.iterdata():\n        print(coord, \"=>\", data)\n\nTo read, write and empty the data at a board position, use indexing::\n\n    b1 = board.Board((3, 3))\n    b1.populate(\"abcdef\")\n    print(b1[0, 0]) # \"a\"\n\n    b1[0, 0] = \"*\"\n    print(b1[0, 0]) # \"*\"\n\n    b1[-1, -1] = \"*\"\n    print(b1[2, 2]) # \"*\"\n\n    del b1[0, 0]\n    print(b1[0, 0]) # <Empty>\n\nTo test whether a coordinate is contained with the local coordinate space, use in::\n\n    b1 = board.Board((3, 3))\n    (1, 1) in b1 # True\n    (4, 4) in b1 # False\n    (1, 1, 1) in b1 # InvalidDimensionsError\n\nOne board is equal to another if it has the same dimensionality and\neach data item is equal::\n\n    b1 = board.Board((3, 3))\n    b1.populate(\"abcdef\")\n    b2 = b1.copy()\n    b1 == b2 # True\n    b2[0, 0] = \"*\"\n    b1 == b2 # False\n\n    b2 = board.Board((2, 2))\n    b2.populate(\"abcdef\")\n    b1 == b2 # False\n\nTo populate the board from an arbitrary iterator, use .populate::\n\n    def random_letters():\n        import random, string\n        while True:\n            yield random.choice(string.ascii_uppercase)\n\n    b1 = board.Board((4, 4))\n    b1.populate(random_letters())\n\nTo clear the board, use .clear::\n\n    b1 = board.Board((3, 3))\n    b1.populate(range(10))\n    b1.clear()\n    list(b1.iterdata()) # []\n\nA board is True if it has any data, False if it has none::\n\n    b1 = board.Board((2, 2))\n    b1.populate(\"abcd\")\n    bool(b1) # True\n    b1.clear()\n    bool(b1) # False\n\nThe length of the board is the product of its dimension lengths. If any\ndimension is infinite, the board length is infinite. NB to find the\namount of data on the board, use lendata::\n\n    b1 = board.Board((4, 4))\n    len(b1) # 16\n    b1.populate(\"abcd\")\n    len(b1) # 16\n    b1.lendata() # 4\n    b2 = board.Board((2, board.Infinity))\n    len(b2) # Infinity\n\nTo determine the bounding box of the board which contains data, use .occupied::\n\n    b1 = board.Board((3, 3))\n    b1.populate(\"abcd\")\n    list(c for (c, d) in b1.iterdata()) # [(0, 0), (0, 1), (0, 2), (1, 0)]\n    b1.occupied() # ((0, 0), (1, 2))\n\nFor the common case of slicing a board around its occupied space,\nuse .occupied_board::\n\n    b1 = board.Board((3, 3))\n    b1.populate(\"abcd\")\n    b1.draw()\n    b2 = b1.occupied_board()\n    b2.draw()\n\nTo test whether a position is on any edge of the board, use .is_edge::\n\n    b1 = board.Board((3, 3))\n    b1.is_edge((0, 0)) # True\n    b1.is_edge((1, 1)) # False\n    b1.is_edge((2, 0)) # True\n\nTo find the immediate on-board neighbours to a position along all dimensions::\n\n    b1 = board.Board((3, 3, 3))\n    list(b1.neighbours((0, 0, 0)))\n    # [(0, 1, 1), (1, 1, 0), ..., (1, 0, 1), (0, 1, 0)]\n\nTo iterate over all the coords in the rectangular space between\ntwo corners, use .itercoords::\n\n    b1 = board.Board((3, 3))\n    list(b1.itercoords((0, 0), (1, 1))) # [(0, 0), (0, 1), (1, 0), (1, 1)]\n\nTo iterate over all the on-board positions from one point in a\nparticular direction, use .iterline::\n\n    b1 = board.Board((4, 4))\n    start_from = 1, 1\n    direction = 1, 1\n    list(b1.iterline(start_from, direction)) # [(1, 1), (2, 2), (3, 3)]\n    direction = 0, 2\n    list(b1.iterline(start_from, direction)) # [(1, 1), (1, 3)]\n\nor .iterlinedata to generate the data at each point::\n\n    b1 = board.Board((3, 3))\n    b1.populate(\"ABCDEFGHJ\")\n    start_from = 1, 1\n    direction = 1, 0\n    list(b1.iterlinedata(start_from, direction)) # ['A', 'D', 'G']\n\nBoth iterline and iterdata can take a maximum number of steps, eg for\ngames like Connect 4 or Battleships::\n\n    b1 = board.Board((8, 8))\n    #\n    # Draw a Battleship\n    #\n    b1.populate(\"BBBB\", b1.iterline((2, 2), (1, 0)))\n\nAs a convenience for games which need to look for a run of so many\nthings, the .run_of_n method combines iterline with data to yield\nevery possible line on the board which is of a certain length along\nwith its data::\n\n    b1 = board.Board((3, 3))\n    b1[0, 0] = 'X'\n    b1[1, 1] = 'O'\n    b1[0, 1] = 'X'\n    for line, data in b1.runs_of_n(3):\n        if all(d == \"O\" for d in data):\n            print(\"O wins\")\n            break\n        elif all(d == \"X\" for d in data):\n            print(\"X wins\")\n            break\n\nTo iterate over the corners of the board, use .corners::\n\n    b1 = board.Board((3, 3))\n    corners() # [(0, 0), (0, 2), (2, 0), (2, 2)]\n\nProperties\n----------\n\nTo determine whether a board is offset from another (ie the result of a slice)::\n\n    b1 = board.Board((3, 3))\n    b1.is_offset # False\n    b2 = b1[:1, :1]\n    b2.is_offset # True\n\nTo determine whether a board has any infinite or finite dimensions::\n\n    b1 = board.Board((3, board.Infinity))\n    b1.has_finite_dimensions # True\n    b1.has_infinite_dimensions # True\n    b2 = board.Board((3, 3))\n    b1.has_infinite_dimensions # False\n    b3 = board.Board((board.Infinity, board.Infinity))\n    b3.has_finite_dimensions # False\n\nDisplay the Board\n-----------------\n\nTo get a crude view of the contents of the board, use .dump::\n\n    b1 = board.Board((3, 3))\n    b1.populate(\"abcdef\")\n    b1.dump()\n\nTo get a grid view of a 2-dimensional board, use .draw::\n\n    b1 = board.Board((3, 3))\n    b1.populate(\"OX  XXOO \")\n    b1.draw()\n\nIf you don't want the borders drawn, eg because you're using the board\nto render ASCII art, pass use_borders=False::\n\n    b1 = board.Board((8, 8))\n    for coord in b1.iterline((0, 0), (1, 1)):\n        b1[coord] = \"*\"\n    for coord in b1.iterline((7, 0), (-1, 1)):\n        b1[coord] = \"*\"\n    b1.draw(use_borders=False)\n\nTo render to an image using Pillow (which isn't a hard dependency) use paint.\nThe default renderer treats the data items as text and renders then, scaled\nto fit, into each cell. This works, obviously, for things like Noughts & Crosses\nassuming that you store something like \"O\" and \"X\". But it also works for\nword searches and even simple battleships where the data items are objects\nwhose __str__ returns blank (for undiscovered), \"+\" for a single hit, and \"*\"\nfor a destroyed vessel::\n\n    b1 = board.Board((3, 3))\n    b1[0, 0] = \"X\"\n    b1[1, 1] = \"O\"\n    b1[0, 2] = \"X\"\n    b1.paint(\"board.png\")\n    # ... and now look at board.png\n\nThe text painting is achieved internally by means of a callback called\ntext_sprite. An alternative ready-cooked callback for paint() is\nimagefile_sprite. This looks for a .png file in the current directory\n(or another; you can specify).\n\nLocal and Global coordinates\n----------------------------\n\nSince one board can represent a slice of another, there are two levels\nof coordinates: local and global. Coordinates passed to or returned from\nany of the public API methods are always local for that board. They\nrepresent the natural coordinate space for the board. Internally, the\nmodule will use global coordinates, translating as necessary.\n\nSay you're managing a viewport of a tile-based dungeon game where the\nmaster dungeon board is 100 x 100 but the visible board is 10 x 10.\nYour viewport board is currently representing the slice of the master\nboard from (5, 5) to (14, 14). Changing the item at position (2, 2) on\nthe viewport board will change the item at position (7, 7) on the master\nboard (and vice versa).\n\nAs a user of the API you don't need to know this, except to understand\nthat a board slice is essentially a view on its parent. If you wish\nto subclass or otherwise extend the board, you'll need to note where\ncoordinate translations are necessary.\n\n\n\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/tjguk/dojo-board", "keywords": "", "license": "unlicensed", "maintainer": "Tim Golden", "maintainer_email": "mail@timgolden.me.uk", "name": "board", "package_url": "https://pypi.org/project/board/", "platform": "", "project_url": "https://pypi.org/project/board/", "project_urls": {"Homepage": "https://github.com/tjguk/dojo-board"}, "release_url": "https://pypi.org/project/board/1.0/", "requires_dist": null, "requires_python": "", "summary": "Standard Board mechanism for Dojo tasks", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>Often, when running a Python Dojo, we\u2019ve ended up with a challenge\nbased around some kind of board or tile-based landscape. In these\nsituations it\u2019s not uncommon to spend a lot of the time building up\nyour basic board functionality in order to support the more interesting\ngameplay algorithm.</p>\n<p>This module implements a general-purpose board structure which\nhas the functionality needed for a range of purposes, and lends itself\nto being subclassed for those particular needs.</p>\n</div>\n<div id=\"dependencies\">\n<h2>Dependencies</h2>\n<p>None - stdlib only</p>\n</div>\n<div id=\"tests\">\n<h2>Tests</h2>\n<p>Fairly decent coverage (not actually checked with coverage.py): test.py</p>\n</div>\n<div id=\"getting-started\">\n<h2>Getting Started</h2>\n<p>Install with pip:</p>\n<pre>pip install board\n</pre>\n<p>Absolutely basic usage:</p>\n<pre>import board\n#\n# Produce a 3x3 board\n#\nb = board.Board((3, 3))\n\nb[0, 0] = \"X\"\nb[1, 0] = \"O\"\n</pre>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Board is an n-dimensional board, any of which dimensions can be of\ninfinite size. (So if you have, say, 3 infinite dimensions, you have\nthe basis for a Minecraft layout). Dimensions are zero-based and\nnegative indexes operate as they usually do in Python: working from\nthe end of the dimension backwards.</p>\n<p>Cells on the board are accessed by item access, eg board[1, 2] or\nlandscape[1, 1, 10].</p>\n<p>A board can be copied, optionally along with its data by means of the\n.copy method. Or a section of a board can be linked to the original\nboard by slicing the original board:</p>\n<pre>b1 = board.Board((9, 9))\nb1[1, 1] = 1\nb2 = b1.copy()\nb3 = b1[:3, :3]\n</pre>\n<p>Note that the slice must include all the dimensions of the original\nboard, but any of those subdimensions can be of length 1:</p>\n<pre>b1 = board.Board((9, 9, 9))\nb2 = b1[:3, :3, :1]\n</pre>\n<p>A sentinel value of Empty indicates a position which is not populated\nbecause it has never had a value, or because its value has been deleted:</p>\n<pre>b1 = board.Board((3, 3))\nassert b1[1, 1] is board.Empty\nb1.populate(\"abcdefghi\")\nassert b1[1, 1] == \"e\"\ndel b1[1, 1]\nassert b1[1, 1] is board.Empty\n</pre>\n<p>Iterating over the board yields its coordinates:</p>\n<pre>b1 = board.Board((2, 2))\nfor coord in b1:\n    print(coord)\n#\n# =&gt; (0, 0), (0, 1) etc.\n#\n</pre>\n<p>Iteration over a board with one or more infinite dimensions will work\nby iterating in chunks:</p>\n<pre>b1 = board.Board((3, 3, board.Infinity))\nfor coord in b1:\n    print(b1)\n</pre>\n<p>To see coordinates with their data items, use iterdata:</p>\n<pre>b1 = board.Board((2, 2))\nb1.populate(\"abcd\")\nfor coord, data in b1.iterdata():\n    print(coord, \"=&gt;\", data)\n</pre>\n<p>To read, write and empty the data at a board position, use indexing:</p>\n<pre>b1 = board.Board((3, 3))\nb1.populate(\"abcdef\")\nprint(b1[0, 0]) # \"a\"\n\nb1[0, 0] = \"*\"\nprint(b1[0, 0]) # \"*\"\n\nb1[-1, -1] = \"*\"\nprint(b1[2, 2]) # \"*\"\n\ndel b1[0, 0]\nprint(b1[0, 0]) # &lt;Empty&gt;\n</pre>\n<p>To test whether a coordinate is contained with the local coordinate space, use in:</p>\n<pre>b1 = board.Board((3, 3))\n(1, 1) in b1 # True\n(4, 4) in b1 # False\n(1, 1, 1) in b1 # InvalidDimensionsError\n</pre>\n<p>One board is equal to another if it has the same dimensionality and\neach data item is equal:</p>\n<pre>b1 = board.Board((3, 3))\nb1.populate(\"abcdef\")\nb2 = b1.copy()\nb1 == b2 # True\nb2[0, 0] = \"*\"\nb1 == b2 # False\n\nb2 = board.Board((2, 2))\nb2.populate(\"abcdef\")\nb1 == b2 # False\n</pre>\n<p>To populate the board from an arbitrary iterator, use .populate:</p>\n<pre>def random_letters():\n    import random, string\n    while True:\n        yield random.choice(string.ascii_uppercase)\n\nb1 = board.Board((4, 4))\nb1.populate(random_letters())\n</pre>\n<p>To clear the board, use .clear:</p>\n<pre>b1 = board.Board((3, 3))\nb1.populate(range(10))\nb1.clear()\nlist(b1.iterdata()) # []\n</pre>\n<p>A board is True if it has any data, False if it has none:</p>\n<pre>b1 = board.Board((2, 2))\nb1.populate(\"abcd\")\nbool(b1) # True\nb1.clear()\nbool(b1) # False\n</pre>\n<p>The length of the board is the product of its dimension lengths. If any\ndimension is infinite, the board length is infinite. NB to find the\namount of data on the board, use lendata:</p>\n<pre>b1 = board.Board((4, 4))\nlen(b1) # 16\nb1.populate(\"abcd\")\nlen(b1) # 16\nb1.lendata() # 4\nb2 = board.Board((2, board.Infinity))\nlen(b2) # Infinity\n</pre>\n<p>To determine the bounding box of the board which contains data, use .occupied:</p>\n<pre>b1 = board.Board((3, 3))\nb1.populate(\"abcd\")\nlist(c for (c, d) in b1.iterdata()) # [(0, 0), (0, 1), (0, 2), (1, 0)]\nb1.occupied() # ((0, 0), (1, 2))\n</pre>\n<p>For the common case of slicing a board around its occupied space,\nuse .occupied_board:</p>\n<pre>b1 = board.Board((3, 3))\nb1.populate(\"abcd\")\nb1.draw()\nb2 = b1.occupied_board()\nb2.draw()\n</pre>\n<p>To test whether a position is on any edge of the board, use .is_edge:</p>\n<pre>b1 = board.Board((3, 3))\nb1.is_edge((0, 0)) # True\nb1.is_edge((1, 1)) # False\nb1.is_edge((2, 0)) # True\n</pre>\n<p>To find the immediate on-board neighbours to a position along all dimensions:</p>\n<pre>b1 = board.Board((3, 3, 3))\nlist(b1.neighbours((0, 0, 0)))\n# [(0, 1, 1), (1, 1, 0), ..., (1, 0, 1), (0, 1, 0)]\n</pre>\n<p>To iterate over all the coords in the rectangular space between\ntwo corners, use .itercoords:</p>\n<pre>b1 = board.Board((3, 3))\nlist(b1.itercoords((0, 0), (1, 1))) # [(0, 0), (0, 1), (1, 0), (1, 1)]\n</pre>\n<p>To iterate over all the on-board positions from one point in a\nparticular direction, use .iterline:</p>\n<pre>b1 = board.Board((4, 4))\nstart_from = 1, 1\ndirection = 1, 1\nlist(b1.iterline(start_from, direction)) # [(1, 1), (2, 2), (3, 3)]\ndirection = 0, 2\nlist(b1.iterline(start_from, direction)) # [(1, 1), (1, 3)]\n</pre>\n<p>or .iterlinedata to generate the data at each point:</p>\n<pre>b1 = board.Board((3, 3))\nb1.populate(\"ABCDEFGHJ\")\nstart_from = 1, 1\ndirection = 1, 0\nlist(b1.iterlinedata(start_from, direction)) # ['A', 'D', 'G']\n</pre>\n<p>Both iterline and iterdata can take a maximum number of steps, eg for\ngames like Connect 4 or Battleships:</p>\n<pre>b1 = board.Board((8, 8))\n#\n# Draw a Battleship\n#\nb1.populate(\"BBBB\", b1.iterline((2, 2), (1, 0)))\n</pre>\n<p>As a convenience for games which need to look for a run of so many\nthings, the .run_of_n method combines iterline with data to yield\nevery possible line on the board which is of a certain length along\nwith its data:</p>\n<pre>b1 = board.Board((3, 3))\nb1[0, 0] = 'X'\nb1[1, 1] = 'O'\nb1[0, 1] = 'X'\nfor line, data in b1.runs_of_n(3):\n    if all(d == \"O\" for d in data):\n        print(\"O wins\")\n        break\n    elif all(d == \"X\" for d in data):\n        print(\"X wins\")\n        break\n</pre>\n<p>To iterate over the corners of the board, use .corners:</p>\n<pre>b1 = board.Board((3, 3))\ncorners() # [(0, 0), (0, 2), (2, 0), (2, 2)]\n</pre>\n</div>\n<div id=\"properties\">\n<h2>Properties</h2>\n<p>To determine whether a board is offset from another (ie the result of a slice):</p>\n<pre>b1 = board.Board((3, 3))\nb1.is_offset # False\nb2 = b1[:1, :1]\nb2.is_offset # True\n</pre>\n<p>To determine whether a board has any infinite or finite dimensions:</p>\n<pre>b1 = board.Board((3, board.Infinity))\nb1.has_finite_dimensions # True\nb1.has_infinite_dimensions # True\nb2 = board.Board((3, 3))\nb1.has_infinite_dimensions # False\nb3 = board.Board((board.Infinity, board.Infinity))\nb3.has_finite_dimensions # False\n</pre>\n</div>\n<div id=\"display-the-board\">\n<h2>Display the Board</h2>\n<p>To get a crude view of the contents of the board, use .dump:</p>\n<pre>b1 = board.Board((3, 3))\nb1.populate(\"abcdef\")\nb1.dump()\n</pre>\n<p>To get a grid view of a 2-dimensional board, use .draw:</p>\n<pre>b1 = board.Board((3, 3))\nb1.populate(\"OX  XXOO \")\nb1.draw()\n</pre>\n<p>If you don\u2019t want the borders drawn, eg because you\u2019re using the board\nto render ASCII art, pass use_borders=False:</p>\n<pre>b1 = board.Board((8, 8))\nfor coord in b1.iterline((0, 0), (1, 1)):\n    b1[coord] = \"*\"\nfor coord in b1.iterline((7, 0), (-1, 1)):\n    b1[coord] = \"*\"\nb1.draw(use_borders=False)\n</pre>\n<p>To render to an image using Pillow (which isn\u2019t a hard dependency) use paint.\nThe default renderer treats the data items as text and renders then, scaled\nto fit, into each cell. This works, obviously, for things like Noughts &amp; Crosses\nassuming that you store something like \u201cO\u201d and \u201cX\u201d. But it also works for\nword searches and even simple battleships where the data items are objects\nwhose __str__ returns blank (for undiscovered), \u201c+\u201d for a single hit, and \u201c*\u201d\nfor a destroyed vessel:</p>\n<pre>b1 = board.Board((3, 3))\nb1[0, 0] = \"X\"\nb1[1, 1] = \"O\"\nb1[0, 2] = \"X\"\nb1.paint(\"board.png\")\n# ... and now look at board.png\n</pre>\n<p>The text painting is achieved internally by means of a callback called\ntext_sprite. An alternative ready-cooked callback for paint() is\nimagefile_sprite. This looks for a .png file in the current directory\n(or another; you can specify).</p>\n</div>\n<div id=\"local-and-global-coordinates\">\n<h2>Local and Global coordinates</h2>\n<p>Since one board can represent a slice of another, there are two levels\nof coordinates: local and global. Coordinates passed to or returned from\nany of the public API methods are always local for that board. They\nrepresent the natural coordinate space for the board. Internally, the\nmodule will use global coordinates, translating as necessary.</p>\n<p>Say you\u2019re managing a viewport of a tile-based dungeon game where the\nmaster dungeon board is 100 x 100 but the visible board is 10 x 10.\nYour viewport board is currently representing the slice of the master\nboard from (5, 5) to (14, 14). Changing the item at position (2, 2) on\nthe viewport board will change the item at position (7, 7) on the master\nboard (and vice versa).</p>\n<p>As a user of the API you don\u2019t need to know this, except to understand\nthat a board slice is essentially a view on its parent. If you wish\nto subclass or otherwise extend the board, you\u2019ll need to note where\ncoordinate translations are necessary.</p>\n</div>\n\n          </div>"}, "last_serial": 6064118, "releases": {"0.0.0": [{"comment_text": "", "digests": {"md5": "b6082a424a8ebb59679d14b768bd8a88", "sha256": "592416972460ca424bb2a98ab85f1d2748b49cfb9d1d0336f93f5344dcb0a863"}, "downloads": -1, "filename": "board-0.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "b6082a424a8ebb59679d14b768bd8a88", "packagetype": "bdist_wheel", "python_version": "3.6", "requires_python": null, "size": 7100, "upload_time": "2018-02-01T19:56:49", "upload_time_iso_8601": "2018-02-01T19:56:49.978162Z", "url": "https://files.pythonhosted.org/packages/e2/e2/bbb57c79d75088c0448709b89e7097fb3265a0e1652ec240314294506633/board-0.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "488269a8ebfebb2442d2ebf145bd645c", "sha256": "08148e7ad2cfc90ce84e3e45db51032a1ae38802e698319ca82291e896037eb2"}, "downloads": -1, "filename": "board-0.0.0.tar.gz", "has_sig": false, "md5_digest": "488269a8ebfebb2442d2ebf145bd645c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4599, "upload_time": "2018-02-01T19:56:48", "upload_time_iso_8601": "2018-02-01T19:56:48.120260Z", "url": "https://files.pythonhosted.org/packages/71/19/78cdca3441e09d382ff3d8db0ba1211d714b7ab3261a11dcf12b142da6e2/board-0.0.0.tar.gz", "yanked": false}], "0.0.0.post0": [{"comment_text": "", "digests": {"md5": "cd37903ddef850cf69e5850ae5533e4c", "sha256": "831de92f159ae43d4b4458155a7156947fd48da7886d65598f0882453abe5b6d"}, "downloads": -1, "filename": "board-0.0.0.post0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "cd37903ddef850cf69e5850ae5533e4c", "packagetype": "bdist_wheel", "python_version": "3.6", "requires_python": null, "size": 12477, "upload_time": "2018-02-01T20:29:06", "upload_time_iso_8601": "2018-02-01T20:29:06.485224Z", "url": "https://files.pythonhosted.org/packages/a9/84/5a574f9f1af2ec3fa47856c9cc76cc5d7607d6fe26d8d032722b14734816/board-0.0.0.post0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "251b4a129d016913d1c949e3c90e5180", "sha256": "149e5dd87be1835ecfea76fc25bba29dc5ee9ed5088338e61557124601b9eaf4"}, "downloads": -1, "filename": "board-0.0.0.post0.tar.gz", "has_sig": false, "md5_digest": "251b4a129d016913d1c949e3c90e5180", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9485, "upload_time": "2018-02-01T20:29:05", "upload_time_iso_8601": "2018-02-01T20:29:05.186606Z", "url": "https://files.pythonhosted.org/packages/44/aa/de9c002e7726425ea628f8b576a33d172ba792f7e2dd07e1130ad651974f/board-0.0.0.post0.tar.gz", "yanked": false}], "1.0": [{"comment_text": "", "digests": {"md5": "47665ada00bffa59abda58a9e4f3d643", "sha256": "b97c986d0190a2a5181a7fe28959cd8515520b87f672796e21e1b0d32cc63e2f"}, "downloads": -1, "filename": "board-1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "47665ada00bffa59abda58a9e4f3d643", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12869, "upload_time": "2019-11-01T14:17:29", "upload_time_iso_8601": "2019-11-01T14:17:29.838844Z", "url": "https://files.pythonhosted.org/packages/bd/b8/461dae0fae64be12d818efab745d520bcf4a96195ccbd5028d58d042e68b/board-1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9896667b8549bb3e1cc13a7e68fd0d28", "sha256": "cd718c3322a126d86455e24ae0cebb59a567cbdbaf03696391dccf88c8f456d6"}, "downloads": -1, "filename": "board-1.0.tar.gz", "has_sig": false, "md5_digest": "9896667b8549bb3e1cc13a7e68fd0d28", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16717, "upload_time": "2019-11-01T14:17:31", "upload_time_iso_8601": "2019-11-01T14:17:31.456333Z", "url": "https://files.pythonhosted.org/packages/de/7d/4de4e7b0eb780854e2c1258225a831ef29c447f0e934347ce58128939b69/board-1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "47665ada00bffa59abda58a9e4f3d643", "sha256": "b97c986d0190a2a5181a7fe28959cd8515520b87f672796e21e1b0d32cc63e2f"}, "downloads": -1, "filename": "board-1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "47665ada00bffa59abda58a9e4f3d643", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 12869, "upload_time": "2019-11-01T14:17:29", "upload_time_iso_8601": "2019-11-01T14:17:29.838844Z", "url": "https://files.pythonhosted.org/packages/bd/b8/461dae0fae64be12d818efab745d520bcf4a96195ccbd5028d58d042e68b/board-1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9896667b8549bb3e1cc13a7e68fd0d28", "sha256": "cd718c3322a126d86455e24ae0cebb59a567cbdbaf03696391dccf88c8f456d6"}, "downloads": -1, "filename": "board-1.0.tar.gz", "has_sig": false, "md5_digest": "9896667b8549bb3e1cc13a7e68fd0d28", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16717, "upload_time": "2019-11-01T14:17:31", "upload_time_iso_8601": "2019-11-01T14:17:31.456333Z", "url": "https://files.pythonhosted.org/packages/de/7d/4de4e7b0eb780854e2c1258225a831ef29c447f0e934347ce58128939b69/board-1.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:36:54 2020"}