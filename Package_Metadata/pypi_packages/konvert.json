{"info": {"author": "Kim G L Pedersen", "author_email": "georglind@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: Apache Software License", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy"], "description": "# konvert\n\nKonvert implements universal conversion graphs for e.g. coordinate transformations.\n\nAt the core, konvert represents types connected by conversions on a graph. Such conversion graphs can be expandend incrementally, because it only requires two connections to connect a new type to the graph, This type can then be freely converted to any other type in the graph, by automatically chaining conversions between existing types.\n\nThe automatic chaining requires the conversions to be parameter-free. Conversions with additional parameters are called projections, which konvert also helps you manage.\n\n## Points\n\nThe moule konvert.points includes a conversion graph for coordinate transformations. As an example consider a set of points in two-dimensional Cartesian coordinates:\n\n```python\nfrom konvert.points import Cartesian2D\n\nline = Cartesian2D(x=[0, 1, 2], y=[0, 1, 2])\n```\n\nThis points can be converted to other implented 2D point sets, like ``Polar`` and ``Bipolar``, by using the ``to()`` method\n\n```python\nfrom konvert.points import Polar, Bipolar\n\nlp = line.to(Polar)\nlb = line.to(Bipolar)\n```\n\nIt can also be lifted up to its 3D description, ```l3 = line.to(Cartesian3D)```. The conversion graph can automatically chain conversions, so in fact, any point in the plane can be hoisted up to any point in three-dimensional space. That means, that points in e.g. polar coordinates, can be hoisted up to ```Cartesian3D```.\n\n```python\np0 = Polar(theta=30 * degrees, r=1.5).to(Cartesian3D)\n```\n\nPoints in 3D can be represented using the coordinate representations ``Cartesian3D``, ``Cylindrical``, and ``Spherical``. All Cartesian types have some helper methods for easily manipulating points. \n\n```python\np0 = Cartesian3D(1, 1, 1)\nq0 = Cartesian3D(1, 1, 0)\n\n# Create normalized version\np1 = p0.normalized()\n\n# Shift p0 by q0\np0.shift(q0)  \n\n# Rotate around an axis thorugh q0.\np0.rotate(theta=45 * degrees, point=q0)\n```\n\n### Helpers\n\nBecause the points module work extensively with angles, konvert defines a convenience ``degrees`` symbol, which converts values and arrays in degrees to radians,\n\n```python\nfrom konvert.points import degrees\n\ntheta = 90 * degrees\n# theta is now pi/2\n\ntheta = numpy.array([45, 60, 90, 180, 360]) * degrees\n# theta is now numpy.array([pi/4, pi/3, pi/2, pi, 2*pi])\n```\n\n### Map projections\n\nThe points module also contains a set of map projections: ``Azimuthal``, ``AzimuthalEquidistant``, ``Mercator``, ``Orthographic``, ``Stereographic`` and ``Equirectangular``. Points are represented on the ``Sphere``, in spherical coordinates, or in ``Equitorial`` coordinates (lattitude and longitude).\n\n```python\npoints = Equitorial([40.12, 50.53] * degrees, [33.16, 44.53] * degrees, r=1)\n\np0 = points.project(Mercator)\np1 = points.project(Stereographic)\n...\n```\n\nThe points can be easily plotted using matplotlib and the plot utility on Cartesian2D, ``p0.to(Cartesian2D).plot()``.\n\n### Extending the conversion graph\n\nIt is fairly simple to extend an existing conversion graph and an existing projection collection. Let us extend the points graph with a Skew2D coordinate system. Note the use of numpy to efficiently represent and transform coordinates.\n\n```python\nimport numpy\nfrom konvert.points import Points\n\nclass Skew2D(Points):\n    _sig = ('x', 'y', 'theta')\n\n    def __init__(self, x, y, theta):\n        \"\"\" \n        Skew 2D coordinates. Theta is a scalar denominating the skew angle.\n        \"\"\"\n        self.x = numpy.array(x)\n        self.y = numpy.array(y)\n        self.theta = theta\n```\n\nThe Skew2D class can be connected to the ``konvert.points`` conversion graph by using the following conversion.\n\n```python\nfrom konvert.points import converters, Conversion\n\n@converters.register()\nclass Skew2DToCartesian2D(Conversion):\n    src = Skew2D\n    dst = points.Cartesian2D\n\n    @staticmethod\n    def convert(skew):\n        return points.Cartesian2D(skew.x + numpy.cos(theta) * skew.y, numpy.sin(theta) * skew.y)\n```\n\nThe reverse conversion requires the additional theta parameter and must be implemented as a projection.\n\n```python\nfrom konvert.points import projectors, Projection\n\n@projectors.register()\nclass Cartesian2DToSkew2D(Projection):\n    src = points.Cartesian2D\n    dst = Skew2D\n\n    @staticmethod\n    def project(cart, theta=np.pi / 2):\n        y = cart.y / numpy.sin(theta)\n        x = cart.x - numpy.cos(theta) * y\n        return Skew2D(x, y, theta)\n```\n\nWith these two additions we can convet between Skew2D points and any points type in the graph,\n\n```python\np0 = Skew2D(1, 2, theta=45 * degrees)\np1 = p0.to(Cylindrical)\n```\n\nor the opposite way,\n\n```python\np1 = Cylindrical(theta=30 * degrees, phi=45 * degrees, r=10)\np0 = p1.project(OnPlane).project(Cartesian2DToSkew2D, theta=45 * degrees)\n```\n\n## Extensions \n\nThe conversion graph has been implemented in the ``conversions`` module. It is possible to create additional conversion graphs and register existing or new conversions in those graphs. As an example we may create a colors module, which converts between values in the RGB and HSL color space. For this is example we will not bother with vectorizing the entities, and instead just work with single color entries and use the  ``colorsys`` module in the python standard library.\n\n```python\nimport colorsys\nfrom konvert.conversions import Conversion, ConversionGraph\n\nconverters = ConversionGraph()\n\nclass Color(metaclass=ABCMeta):     \n     def to(self, type):\n        return convertes.convert(self, type)\n\n\nclass RGB(Color):\n    def __init__(self, r, g, b):\n        self.r = r\n        self.g = g\n        self.b = b\n\nclass HSL(Color):\n    def __init__(self, h, s, l):\n        self.h = h\n        self.s = s\n        self.l = l\n\nconverters.register()\nclass RGBToHSL(Conversion):\n    src = RGB\n    dst = HSL\n\n    @staticmethod\n    def convert(rgb):\n        hsl = colorsys.rgb_to_hsl(rgb.r, rgb.g, rgb.b)\n        return HSL(*hsl)\n\n\nconverters.register()\nclass HSLToRGB(Conversion):\n  src = RGB\n  dst = HSL\n\n  @staticmethod\n  def convert(hsl):\n      rgb = colorsys.hsl_to_rgb(hsl.h, hsl.s, hsl.l)\n      return RGB(*rgb)\n```\n\nWe can now write ``RGB(0.1, 0.3, 0.3).to(HSL)`` and get the correct result.\n\nIf we wanted, we could merge this graph into the points conversion graph, or include part of the points graph in the color conversion graph... \n\n\n\n\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/georglind/konvert", "keywords": "", "license": "ASL 2.0", "maintainer": "", "maintainer_email": "", "name": "konvert", "package_url": "https://pypi.org/project/konvert/", "platform": "", "project_url": "https://pypi.org/project/konvert/", "project_urls": {"Homepage": "https://github.com/georglind/konvert"}, "release_url": "https://pypi.org/project/konvert/0.1.0/", "requires_dist": ["numpy", "matplotlib ; extra == 'plotting'"], "requires_python": ">=3.6.0", "summary": "Build graphs of types connected by conversions and projections", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>konvert</h1>\n<p>Konvert implements universal conversion graphs for e.g. coordinate transformations.</p>\n<p>At the core, konvert represents types connected by conversions on a graph. Such conversion graphs can be expandend incrementally, because it only requires two connections to connect a new type to the graph, This type can then be freely converted to any other type in the graph, by automatically chaining conversions between existing types.</p>\n<p>The automatic chaining requires the conversions to be parameter-free. Conversions with additional parameters are called projections, which konvert also helps you manage.</p>\n<h2>Points</h2>\n<p>The moule konvert.points includes a conversion graph for coordinate transformations. As an example consider a set of points in two-dimensional Cartesian coordinates:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">konvert.points</span> <span class=\"kn\">import</span> <span class=\"n\">Cartesian2D</span>\n\n<span class=\"n\">line</span> <span class=\"o\">=</span> <span class=\"n\">Cartesian2D</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"n\">y</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">])</span>\n</pre>\n<p>This points can be converted to other implented 2D point sets, like <code>Polar</code> and <code>Bipolar</code>, by using the <code>to()</code> method</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">konvert.points</span> <span class=\"kn\">import</span> <span class=\"n\">Polar</span><span class=\"p\">,</span> <span class=\"n\">Bipolar</span>\n\n<span class=\"n\">lp</span> <span class=\"o\">=</span> <span class=\"n\">line</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"n\">Polar</span><span class=\"p\">)</span>\n<span class=\"n\">lb</span> <span class=\"o\">=</span> <span class=\"n\">line</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"n\">Bipolar</span><span class=\"p\">)</span>\n</pre>\n<p>It can also be lifted up to its 3D description, <code>l3 = line.to(Cartesian3D)</code>. The conversion graph can automatically chain conversions, so in fact, any point in the plane can be hoisted up to any point in three-dimensional space. That means, that points in e.g. polar coordinates, can be hoisted up to <code>Cartesian3D</code>.</p>\n<pre><span class=\"n\">p0</span> <span class=\"o\">=</span> <span class=\"n\">Polar</span><span class=\"p\">(</span><span class=\"n\">theta</span><span class=\"o\">=</span><span class=\"mi\">30</span> <span class=\"o\">*</span> <span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"o\">=</span><span class=\"mf\">1.5</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"n\">Cartesian3D</span><span class=\"p\">)</span>\n</pre>\n<p>Points in 3D can be represented using the coordinate representations <code>Cartesian3D</code>, <code>Cylindrical</code>, and <code>Spherical</code>. All Cartesian types have some helper methods for easily manipulating points.</p>\n<pre><span class=\"n\">p0</span> <span class=\"o\">=</span> <span class=\"n\">Cartesian3D</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">q0</span> <span class=\"o\">=</span> <span class=\"n\">Cartesian3D</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Create normalized version</span>\n<span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">p0</span><span class=\"o\">.</span><span class=\"n\">normalized</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Shift p0 by q0</span>\n<span class=\"n\">p0</span><span class=\"o\">.</span><span class=\"n\">shift</span><span class=\"p\">(</span><span class=\"n\">q0</span><span class=\"p\">)</span>  \n\n<span class=\"c1\"># Rotate around an axis thorugh q0.</span>\n<span class=\"n\">p0</span><span class=\"o\">.</span><span class=\"n\">rotate</span><span class=\"p\">(</span><span class=\"n\">theta</span><span class=\"o\">=</span><span class=\"mi\">45</span> <span class=\"o\">*</span> <span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">point</span><span class=\"o\">=</span><span class=\"n\">q0</span><span class=\"p\">)</span>\n</pre>\n<h3>Helpers</h3>\n<p>Because the points module work extensively with angles, konvert defines a convenience <code>degrees</code> symbol, which converts values and arrays in degrees to radians,</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">konvert.points</span> <span class=\"kn\">import</span> <span class=\"n\">degrees</span>\n\n<span class=\"n\">theta</span> <span class=\"o\">=</span> <span class=\"mi\">90</span> <span class=\"o\">*</span> <span class=\"n\">degrees</span>\n<span class=\"c1\"># theta is now pi/2</span>\n\n<span class=\"n\">theta</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">45</span><span class=\"p\">,</span> <span class=\"mi\">60</span><span class=\"p\">,</span> <span class=\"mi\">90</span><span class=\"p\">,</span> <span class=\"mi\">180</span><span class=\"p\">,</span> <span class=\"mi\">360</span><span class=\"p\">])</span> <span class=\"o\">*</span> <span class=\"n\">degrees</span>\n<span class=\"c1\"># theta is now numpy.array([pi/4, pi/3, pi/2, pi, 2*pi])</span>\n</pre>\n<h3>Map projections</h3>\n<p>The points module also contains a set of map projections: <code>Azimuthal</code>, <code>AzimuthalEquidistant</code>, <code>Mercator</code>, <code>Orthographic</code>, <code>Stereographic</code> and <code>Equirectangular</code>. Points are represented on the <code>Sphere</code>, in spherical coordinates, or in <code>Equitorial</code> coordinates (lattitude and longitude).</p>\n<pre><span class=\"n\">points</span> <span class=\"o\">=</span> <span class=\"n\">Equitorial</span><span class=\"p\">([</span><span class=\"mf\">40.12</span><span class=\"p\">,</span> <span class=\"mf\">50.53</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mf\">33.16</span><span class=\"p\">,</span> <span class=\"mf\">44.53</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"n\">p0</span> <span class=\"o\">=</span> <span class=\"n\">points</span><span class=\"o\">.</span><span class=\"n\">project</span><span class=\"p\">(</span><span class=\"n\">Mercator</span><span class=\"p\">)</span>\n<span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">points</span><span class=\"o\">.</span><span class=\"n\">project</span><span class=\"p\">(</span><span class=\"n\">Stereographic</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n</pre>\n<p>The points can be easily plotted using matplotlib and the plot utility on Cartesian2D, <code>p0.to(Cartesian2D).plot()</code>.</p>\n<h3>Extending the conversion graph</h3>\n<p>It is fairly simple to extend an existing conversion graph and an existing projection collection. Let us extend the points graph with a Skew2D coordinate system. Note the use of numpy to efficiently represent and transform coordinates.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span>\n<span class=\"kn\">from</span> <span class=\"nn\">konvert.points</span> <span class=\"kn\">import</span> <span class=\"n\">Points</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Skew2D</span><span class=\"p\">(</span><span class=\"n\">Points</span><span class=\"p\">):</span>\n    <span class=\"n\">_sig</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">'x'</span><span class=\"p\">,</span> <span class=\"s1\">'y'</span><span class=\"p\">,</span> <span class=\"s1\">'theta'</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">theta</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\" </span>\n<span class=\"sd\">        Skew 2D coordinates. Theta is a scalar denominating the skew angle.</span>\n<span class=\"sd\">        \"\"\"</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">theta</span> <span class=\"o\">=</span> <span class=\"n\">theta</span>\n</pre>\n<p>The Skew2D class can be connected to the <code>konvert.points</code> conversion graph by using the following conversion.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">konvert.points</span> <span class=\"kn\">import</span> <span class=\"n\">converters</span><span class=\"p\">,</span> <span class=\"n\">Conversion</span>\n\n<span class=\"nd\">@converters</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">()</span>\n<span class=\"k\">class</span> <span class=\"nc\">Skew2DToCartesian2D</span><span class=\"p\">(</span><span class=\"n\">Conversion</span><span class=\"p\">):</span>\n    <span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">Skew2D</span>\n    <span class=\"n\">dst</span> <span class=\"o\">=</span> <span class=\"n\">points</span><span class=\"o\">.</span><span class=\"n\">Cartesian2D</span>\n\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">convert</span><span class=\"p\">(</span><span class=\"n\">skew</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">points</span><span class=\"o\">.</span><span class=\"n\">Cartesian2D</span><span class=\"p\">(</span><span class=\"n\">skew</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">theta</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">skew</span><span class=\"o\">.</span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">theta</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">skew</span><span class=\"o\">.</span><span class=\"n\">y</span><span class=\"p\">)</span>\n</pre>\n<p>The reverse conversion requires the additional theta parameter and must be implemented as a projection.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">konvert.points</span> <span class=\"kn\">import</span> <span class=\"n\">projectors</span><span class=\"p\">,</span> <span class=\"n\">Projection</span>\n\n<span class=\"nd\">@projectors</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">()</span>\n<span class=\"k\">class</span> <span class=\"nc\">Cartesian2DToSkew2D</span><span class=\"p\">(</span><span class=\"n\">Projection</span><span class=\"p\">):</span>\n    <span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">points</span><span class=\"o\">.</span><span class=\"n\">Cartesian2D</span>\n    <span class=\"n\">dst</span> <span class=\"o\">=</span> <span class=\"n\">Skew2D</span>\n\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">project</span><span class=\"p\">(</span><span class=\"n\">cart</span><span class=\"p\">,</span> <span class=\"n\">theta</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">):</span>\n        <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">cart</span><span class=\"o\">.</span><span class=\"n\">y</span> <span class=\"o\">/</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">sin</span><span class=\"p\">(</span><span class=\"n\">theta</span><span class=\"p\">)</span>\n        <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">cart</span><span class=\"o\">.</span><span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">cos</span><span class=\"p\">(</span><span class=\"n\">theta</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">y</span>\n        <span class=\"k\">return</span> <span class=\"n\">Skew2D</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">theta</span><span class=\"p\">)</span>\n</pre>\n<p>With these two additions we can convet between Skew2D points and any points type in the graph,</p>\n<pre><span class=\"n\">p0</span> <span class=\"o\">=</span> <span class=\"n\">Skew2D</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">theta</span><span class=\"o\">=</span><span class=\"mi\">45</span> <span class=\"o\">*</span> <span class=\"n\">degrees</span><span class=\"p\">)</span>\n<span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">p0</span><span class=\"o\">.</span><span class=\"n\">to</span><span class=\"p\">(</span><span class=\"n\">Cylindrical</span><span class=\"p\">)</span>\n</pre>\n<p>or the opposite way,</p>\n<pre><span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">Cylindrical</span><span class=\"p\">(</span><span class=\"n\">theta</span><span class=\"o\">=</span><span class=\"mi\">30</span> <span class=\"o\">*</span> <span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">phi</span><span class=\"o\">=</span><span class=\"mi\">45</span> <span class=\"o\">*</span> <span class=\"n\">degrees</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">p0</span> <span class=\"o\">=</span> <span class=\"n\">p1</span><span class=\"o\">.</span><span class=\"n\">project</span><span class=\"p\">(</span><span class=\"n\">OnPlane</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">project</span><span class=\"p\">(</span><span class=\"n\">Cartesian2DToSkew2D</span><span class=\"p\">,</span> <span class=\"n\">theta</span><span class=\"o\">=</span><span class=\"mi\">45</span> <span class=\"o\">*</span> <span class=\"n\">degrees</span><span class=\"p\">)</span>\n</pre>\n<h2>Extensions</h2>\n<p>The conversion graph has been implemented in the <code>conversions</code> module. It is possible to create additional conversion graphs and register existing or new conversions in those graphs. As an example we may create a colors module, which converts between values in the RGB and HSL color space. For this is example we will not bother with vectorizing the entities, and instead just work with single color entries and use the  <code>colorsys</code> module in the python standard library.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">colorsys</span>\n<span class=\"kn\">from</span> <span class=\"nn\">konvert.conversions</span> <span class=\"kn\">import</span> <span class=\"n\">Conversion</span><span class=\"p\">,</span> <span class=\"n\">ConversionGraph</span>\n\n<span class=\"n\">converters</span> <span class=\"o\">=</span> <span class=\"n\">ConversionGraph</span><span class=\"p\">()</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Color</span><span class=\"p\">(</span><span class=\"n\">metaclass</span><span class=\"o\">=</span><span class=\"n\">ABCMeta</span><span class=\"p\">):</span>     \n     <span class=\"k\">def</span> <span class=\"nf\">to</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">convertes</span><span class=\"o\">.</span><span class=\"n\">convert</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">RGB</span><span class=\"p\">(</span><span class=\"n\">Color</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">r</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"n\">g</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">b</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">HSL</span><span class=\"p\">(</span><span class=\"n\">Color</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">h</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">h</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">s</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">l</span>\n\n<span class=\"n\">converters</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">()</span>\n<span class=\"k\">class</span> <span class=\"nc\">RGBToHSL</span><span class=\"p\">(</span><span class=\"n\">Conversion</span><span class=\"p\">):</span>\n    <span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">RGB</span>\n    <span class=\"n\">dst</span> <span class=\"o\">=</span> <span class=\"n\">HSL</span>\n\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"k\">def</span> <span class=\"nf\">convert</span><span class=\"p\">(</span><span class=\"n\">rgb</span><span class=\"p\">):</span>\n        <span class=\"n\">hsl</span> <span class=\"o\">=</span> <span class=\"n\">colorsys</span><span class=\"o\">.</span><span class=\"n\">rgb_to_hsl</span><span class=\"p\">(</span><span class=\"n\">rgb</span><span class=\"o\">.</span><span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">rgb</span><span class=\"o\">.</span><span class=\"n\">g</span><span class=\"p\">,</span> <span class=\"n\">rgb</span><span class=\"o\">.</span><span class=\"n\">b</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">HSL</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">hsl</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">converters</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">()</span>\n<span class=\"k\">class</span> <span class=\"nc\">HSLToRGB</span><span class=\"p\">(</span><span class=\"n\">Conversion</span><span class=\"p\">):</span>\n  <span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">RGB</span>\n  <span class=\"n\">dst</span> <span class=\"o\">=</span> <span class=\"n\">HSL</span>\n\n  <span class=\"nd\">@staticmethod</span>\n  <span class=\"k\">def</span> <span class=\"nf\">convert</span><span class=\"p\">(</span><span class=\"n\">hsl</span><span class=\"p\">):</span>\n      <span class=\"n\">rgb</span> <span class=\"o\">=</span> <span class=\"n\">colorsys</span><span class=\"o\">.</span><span class=\"n\">hsl_to_rgb</span><span class=\"p\">(</span><span class=\"n\">hsl</span><span class=\"o\">.</span><span class=\"n\">h</span><span class=\"p\">,</span> <span class=\"n\">hsl</span><span class=\"o\">.</span><span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">hsl</span><span class=\"o\">.</span><span class=\"n\">l</span><span class=\"p\">)</span>\n      <span class=\"k\">return</span> <span class=\"n\">RGB</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">rgb</span><span class=\"p\">)</span>\n</pre>\n<p>We can now write <code>RGB(0.1, 0.3, 0.3).to(HSL)</code> and get the correct result.</p>\n<p>If we wanted, we could merge this graph into the points conversion graph, or include part of the points graph in the color conversion graph...</p>\n\n          </div>"}, "last_serial": 5499777, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "25c392b8ecf5a45a5ac7cbab8c9ebd32", "sha256": "1c19f54c658f280a2c6135694cb48ad3ce4f8720a7e0f16b0e17ad86e209b532"}, "downloads": -1, "filename": "konvert-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "25c392b8ecf5a45a5ac7cbab8c9ebd32", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6.0", "size": 13826, "upload_time": "2019-07-08T09:29:38", "upload_time_iso_8601": "2019-07-08T09:29:38.846364Z", "url": "https://files.pythonhosted.org/packages/75/b4/e0b97ac2875170ed8548ce0d503f5c463bac23a8fdf82d1c393dfc671765/konvert-0.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "26a3209dabb248cf95a77d814b0888fb", "sha256": "5498ebb5e47b56ef0d473029a4012c8d49f4bb1fd6dccac12a6234b5eda149a7"}, "downloads": -1, "filename": "konvert-0.1.0.tar.gz", "has_sig": false, "md5_digest": "26a3209dabb248cf95a77d814b0888fb", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 12743, "upload_time": "2019-07-08T09:29:40", "upload_time_iso_8601": "2019-07-08T09:29:40.977053Z", "url": "https://files.pythonhosted.org/packages/fb/77/dfde7163ed524a42a79048ad1283df8780ceeddace1a63adf21e70ed695c/konvert-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "25c392b8ecf5a45a5ac7cbab8c9ebd32", "sha256": "1c19f54c658f280a2c6135694cb48ad3ce4f8720a7e0f16b0e17ad86e209b532"}, "downloads": -1, "filename": "konvert-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "25c392b8ecf5a45a5ac7cbab8c9ebd32", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.6.0", "size": 13826, "upload_time": "2019-07-08T09:29:38", "upload_time_iso_8601": "2019-07-08T09:29:38.846364Z", "url": "https://files.pythonhosted.org/packages/75/b4/e0b97ac2875170ed8548ce0d503f5c463bac23a8fdf82d1c393dfc671765/konvert-0.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "26a3209dabb248cf95a77d814b0888fb", "sha256": "5498ebb5e47b56ef0d473029a4012c8d49f4bb1fd6dccac12a6234b5eda149a7"}, "downloads": -1, "filename": "konvert-0.1.0.tar.gz", "has_sig": false, "md5_digest": "26a3209dabb248cf95a77d814b0888fb", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 12743, "upload_time": "2019-07-08T09:29:40", "upload_time_iso_8601": "2019-07-08T09:29:40.977053Z", "url": "https://files.pythonhosted.org/packages/fb/77/dfde7163ed524a42a79048ad1283df8780ceeddace1a63adf21e70ed695c/konvert-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:49:00 2020"}