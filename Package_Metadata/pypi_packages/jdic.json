{"info": {"author": "Fabien Kerbouci", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 3", "Programming Language :: Python :: Implementation :: CPython", "Topic :: Utilities"], "description": "Jdic Documentation\n==================\n\n1. Overview\n-----------\n\nIn most projects, manipulating JSON documents requires to reinvent the\nwheel on a lot of small features, or to use a varied set of external\npackages. Jdic's admitted goal is to write less code with the guarantee\nto get the job done fast, flawlessly and efficiently.\n\nJdic aims to avoid that: it is a ready-to-use type-class which eases the\nmanipulation of JSON-like documents, so that you can focus on logic\ninstead of losing time in formal document manipulations.\n\nThe Jdic class provides a lot of original features but also embeds\nmission-critical 3rd party libraries and unite them all within a\ncomprehensive easy-to-use API.\n\n2. Features\n-----------\n\nHere are the useful operations Jdic can do for you:\n\n-  Transparent JSON paths integration - for read and write operations,\n   through an agnostic driver model. Currently MongoDB and Jsonpath-NG\n   paths formats are natively supported.\n\n-  Fast browsing of JSON documents - browse the entire data structure\n   while getting useful values on each iteration: value, JSON path,\n   parent, parent JSON path, depth, etc.\n\n-  Find, Find-Keys and Find-Match features for quickly finding any key\n   or value, or subdocument matching MongoDB-like queries.\n\n-  Merge features for fusioning objects recursively, with up to 4 modes\n   for handling conflicting arrays (replace, merge, new, append).\n\n-  Diff & Patch features - so you can represent differences between two\n   documents in small data sets (diff), and apply those differences to\n   update documents (patch).\n\n-  JSON Schema validation - if you need it, with auto-validation on each\n   document change.\n\n-  Consistent document checksuming - natively SHA-256, it allows to get\n   a single checksum for the document, the checksum will always be the\n   same on all systems.\n\n-  Depth features - you can crawl your document at certain depths only.\n\n-  Strict features - input data will be serialized to a strict JSON\n   format.\n\n-  Agnostic dicts/lists replacement for Python's ``enumerate()``\n\n-  Custom input serializer support - convert specific objects to the\n   JSON data you want to.\n\n-  Cache features with change detection to accelerate some of the API\n   calls.\n\n3. Examples\n-----------\n\nInstantiation\n~~~~~~~~~~~~~\n\n::\n\n    from jdic import jdic   \n\n    o = {\"a\" : {\"b\" : {\"c\" : 1}}}\n    j = jdic(o) # Accepts dicts and lists (or any Mapping, Sequence)\n\nFind the paths for a value\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    paths = [m.path for m in j.find(1)] # Find path for a value as-is\n    >>> [\"a.b.c\"]\n\n    for match in j.find(1): # Classic loop format\n        print(match.path)\n    >>> a.b.c\n\nCrawl all the leaves\n~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    paths = [m.parent_path for m in j.leaves()]  # Results include parents paths and more\n    >>> [\"a.b\"]\n\nCrawl everything\n~~~~~~~~~~~~~~~~\n\n::\n\n    allitems = [m.value for m in j.browse()]  # The first item is always the root itself\n    >>> [\n            {\"a\": {\"b\": {\"c\": 1}}},\n            {\"b\": {\"c\": 1}},\n            {\"c\": 1},\n            1\n    ]\n\nGet the depth of values\n~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    paths = [m.depth for m in j.find({\"c\" : 1})] # find() target values can be objects\n    >>> [2]\n\nMatch an object against a MongoDB-like query (useful for rules/filtering engines)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    paths = [m.path for m in j.find_match({\"c\": {\"$gt\": 0}}) ] # Support of Mongo-like queries\n    >>> [\"a.b\"]\n\n    paths = [m.path for m in j.find_match({  # Complex Mongo-like queries are permitted\n        \"$and\" : [\n            {\"b.c\": {\"$exists\" : True}},\n            {\"b.d\": {\"$exists\" : False}}\n        ]\n    })]\n    >>> [\"a\"]\n\nChecksum objects and sub-objects consistently\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    j.checksum()\n    >>> ebd240a9ae435649514086d13c20d9963ec2844a1f866b313919c55a7c3f7ccb # Is consistent on all systems\n\n    j[\"a\"].checksum() # Sub-iterables have Jdic methods / all sub-iterables implement their own checksum()\n    >>> 05a2013fbe17af7d58779ed96e0d74bd6fa3ce2726c1ebbd9f7dc33671b1c28e \n\n    j[\"a\"] = None\n    j.checksum()\n    >>> 69d7d33051c5e05aa72f55a9a8e30a73da8d4afaa37127b9ea7ee29403aa9d3f # Change detection from child to parent\n\nMake diffs and patches between objects\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    j = jdic(o)\n    p = {\"a\" : {\"e\" : {\"f\" : -1 }}}\n    diff = j.diff(p)\n    >>> [[[\"a\"], {\"e\": {\"f\": -1}}]] # A diff stanza - on larger documents the diffs are smaller than documents\n\n    j = j.patch(diff) # Patch does not modify the original object but returns a patched version\n    j == p # Jdic objects can be transparently compared with dict or list objects (or equivalents)\n    >>> True\n\nMerge objects together\n~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    q = {\"a\" : {\"b\" : {\"d\" : 2}}}\n    j.merge(q)\n    >>> {\"a\": {\"b\": {\"c\": 1, \"d\": 2}}} # Handles recursive merge\n\nValidate against a schema in real-time with the built-in change detection\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    j = jdic(o, schema = {'type' : 'object' , 'properties' : {'a' : {'type' : 'object'}}}) # Correct Schema\n    j['a'] = 3 # instant detection of schema violation (exception)\n    >>> Traceback (most recent call last): ...\n\nTest the Jdic object type:\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    from jdic import Jdic # `Jdic` is the parent class, do not confuse with the function `jdic()`\n    >>> type(j)\n    <class 'jdic.JdicMapping'>\n    >>> isinstance(j, Jdic)\n    True\n\nChange the native enumerate()'s behavior for smoother iterations\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    # Agnostic enumerations with a revised enumerate() function\n    from jdic import enumerate \n    y, z = [1,2,3], {'a':1, 'b':2}\n    for k, v in enumerate(y): # Acts just as the original enumerate() for lists\n        y[k] = v\n    for k, v in enumerate(z): # But allows dict enumeration, raising a key instead of a counter\n        z[k] = v\n\nChange the JSON path driver\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    j = jdic({'a' : [{'b': 1}, {'b': 2}, {'b': 3}]}, driver = 'jsonpath_ng')\n    j['a[*].b'] = 0 # Reassign the value to all locations at once!\n    >>> {\"a\": [{\"b\": 0}, {\"b\": 0}, {\"b\": 0}]}\n\n    del('a[*].b') # Also works with del()\n    >>> {\"a\": [{}, {}, {}]}\n\n4. The MatchResult object\n-------------------------\n\nThe MatchResult object is returned for most search operations. It\ncontains:\n\n-  ``value``: the found object\n\n-  ``path``: the full JSON path of the found object\n\n-  ``parent``: the Jdic object containing the current found object\n\n-  ``parent_path``: the full JSON path of the parent of the found object\n\n-  ``key``: the current key (or index) at which the object was found\n   within its parent\n\n-  ``depth``: the depth of the object counting from the root of the Jdic\n\n5. Jdic object instantiation\n----------------------------\n\n``jdic(obj, schema=None, serializer=None, driver=None)``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nInstantiations of Jdic objects is made through the ``jdic()`` function\nwhich will decide for the type of Jdic object (``JdicMapping`` or\n``JdicSequence``) to instantiate and return. Both those types inherit\nfrom the Jdic class (do not use this one directly, mind the lowercase).\n\n-  ``obj``: any list or dictionary. Sequence and Mapping equivalents\n   will be casted to ``list`` and ``dict``.\n\n-  ``schema``: optional, must be a JSON Schema in the form of a\n   ``dict``. If provided, all changes affecting the Jdic will be\n   validated against the schema whenever they happen.\n\n-  ``serializer``: optional, your custom serialization function. Useless\n   when ``obj`` is the result of a ``json.loads()``. It will be called\n   to transform non-standard object types into standard JSON types. If\n   not provided, exotic types are transformed to ``str``. It is possible\n   to use ``settings.serialize_custom_function`` instead, to globally\n   specify a serializing function for all the Jdic instances. A\n   serializer specified as argument will always have priority over\n   settings. The custom serializer function, if used, must return a JSON\n   compliant data type: None, bool, str, int, float, list, dict.\n\n-  ``driver``: optional, a string representing the driver to use\n   (``mongo`` and ``jsonpath_ng`` are natively implemented). It is\n   possible to use ``settings.json_path_driver`` instead, to globally\n   specify a driver. Drivers specified as argument will have priority\n   over settings.\n\nNote about floating point values: objects serialized as Jdic objects\nwill have their floating values transformed to integers whenever the\nfloat value is equal to its integer form. This is to make the JSON dumps\nand checksums consistent and avoids '5' to be shown as '5.0'. This can\nbe changed by setting ``settings.serialize_float_to_int`` to ``False``.\n\n6. Jdic objects methods\n-----------------------\n\n``browse(sort=False, depth=None, maxdepth=None)``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nRecurse on all Jdic elements, yielding a ``MatchResult`` object on each\niteration.\n\n-  ``sort``: if True all the results will be yielded with JSON paths in\n   alphabetical order.\n-  ``depth``: an integer - only the results from objects at *depth* will\n   be yielded.\n-  ``maxdepth`` : an integer - will not recurse on documents whose depth\n   is above ``maxdepth``.\n\n``checksum(algo='sha256')``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nReturns an ASCII checksum representing the content and data types of the\nobject. Checksums are consistent from an execution to another and can be\nsafely used for content change detection or objects comparisons. The\nchecksum is cached and is only recalculated if changes occured.\n\n-  ``algo``: any algorithm supported by the ``hashlib`` Python library\n\n``deepness()``\n~~~~~~~~~~~~~~\n\nReturns an integer representing the deepness of the JSON structure from\nwhere ``deepness()`` is called. A document with no dict or list within\nit has a deepness of zero. The deepness is cached and is only\nrecalculated if changes occured.\n\n``depth()``\n~~~~~~~~~~~\n\nReturns an integer representing the depth of the current document from\nthe root of the Jdic object. The depth of the root document is 0.\n\n``diff(obj)``\n~~~~~~~~~~~~~\n\nReturns an object (a diff *stanza*) representing the differences between\nthe Jdic and ``obj``. ``diff()`` is implemented by the ``json_delta``\nPython library.\n\n-  ``obj``: any data\n\n``enumerate(sort=False)``\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAgnostic and non-recursive enumeration of each entry in the current\nobject. It yields a ``(k, v)`` tuple, where ``k`` is either an integer\nindex when object is a list, and a string key when object is a dict.\n``v`` is always the value. ``enumerate()`` is also available as a\nstandalone function within the Jdic package:\n``from jdic import enumerate``.\n\n-  ``sort`` : if True, sorts the dictionary keys alphabetically. Only\n   sort dictionary keys, not lists.\n\n``find(value, sort=False, limit=None, depth=None, maxdepth=None)``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSearches a value within the entire Jdic. Searches are strict (``==``).\n\n-  ``value``: the value to search for - can be a simple type (int, str,\n   etc.) or complex object (list, dict, Jdic, etc.)\n-  ``sort``: if True the search results will be sorted with JSON paths\n   in alphabetical order.\n-  ``limit``: an integer - terminates the search when the number of\n   results reaches ``limit``.\n-  ``depth``: an integer - only the results from objects at *depth* will\n   be yielded.\n-  ``maxdepth``: an integer - will not recurse on documents whose depth\n   is above ``maxdepth``.\n\n``find_keys(keys, mode=\"any\", sort=False, limit=None, depth=None, maxdepth=None)``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSearches any sub-object containing ``keys``. ``keys`` can be a single\nkey or a list of keys. This function aims to facilitate finding\nsub-objects whose keys are known.\n\n-  ``keys``: a string or list of strings. The search will be case\n   sensitive. Keys are for dicts and cannot be integer indexes of\n   arrays. Keys cannot be JSON paths.\n-  ``mode``: ``\"any\"`` or ``\"all\"`` - if ``\"any\"`` then any object\n   matching any of the provided keys will be yielded. If ``\"all\"`` then\n   any object containing all the keys will be matched.\n-  ``sort``: if True the search results will be sorted with JSON paths\n   in alphabetical order.\n-  ``limit``: an integer - terminates the search when the number of\n   results reaches ``limit``.\n-  ``depth``: an integer - only the results from objects at *depth* will\n   be yielded.\n-  ``maxdepth``: an integer - will not recurse on documents whose depth\n   is above ``maxdepth``.\n\n``find_match(query, sort=False, limit=None, depth=None, maxdepth=None)``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFinds all objects matching positive against ``query``. Queries for\n``find_match()`` are MongoDB-like queries, for both ``mongo`` and\n``jsonpath_ng`` drivers. The underlying implementation is provided by\nthe ``mongoquery`` Python library.\n\n-  ``query``: a MongoDB-like query. Please refer to the MongoDB\n   documentation or the examples for information on queries\n   structuration. Also review https://github.com/kapouille/mongoquery\n   for more details on ``mongoquery`` and its known limitations.\n-  ``sort``: if True the search results will be sorted with JSON paths\n   in alphabetical order.\n-  ``limit``: an integer - terminates the search when the number of\n   results reaches ``limit``.\n-  ``depth``: an integer - only the results from objects at *depth* will\n   be yielded.\n-  ``maxdepth``: an integer - will not recurse on documents whose depth\n   is above ``maxdepth``.\n\n``json(sort_keys=False, indent=0, ensure_ascii=False)``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nA helper to dump Jdic objects as serialized JSON strings.\n\n-  ``sort_keys``: all keys will be sorted alphabetically within their\n   own dicts.\n-  ``indent``: number of spaces to add on new blocks.\n-  ``ensure_ascii``: for a pure ASCII output (usually not recommended\n   for anything else than printing binary data).\n\n``leaves(sort=False, depth=None, maxdepth=None)``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWill yield a ``MatchResult`` on each leaf encountered in the document. A\nleaf is a terminal value within the JSON documents. Basically all values\nare leaves, except dicts and lists.\n\n-  ``sort``: if True the search results will be sorted with JSON paths\n   in alphabetical order.\n-  ``depth``: an integer - only the results from objects at *depth* will\n   be yielded.\n-  ``maxdepth``: an integer - will not recurse on documents whose depth\n   is above ``maxdepth``.\n\n``nb_leaves()``\n~~~~~~~~~~~~~~~\n\nReturns the number of leaves contained in the Jdic object. This\ninformation is cached and is only recalculated if changes occured.\n\n``match(query)``\n~~~~~~~~~~~~~~~~\n\nReturns ``True`` or ``False`` if the current Jdic object matches the\nMongo-like query. Unlike ``find_match()`` it will not recurse into\nsubdocuments. The current ``match()`` implementation is supported by the\n``mongoquery`` Python library.\n\n-  ``query``: a Mongo-like query object\n\n``merge(*objs, arr_mode=\"replace\")``\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWill merge the current Jdic with one or multiple other objects (dicts or\nlists). It is not possible to merge a Jdic of type Mapping (dict) with a\nSequence (list) or vice-versa. This limitation does not apply to\nsub-documents. Note that, unlike ``patch()``, the method will change the\nstate of the current object. If multiple args are provided then the next\nobj in ``objs`` is merged on the result of the previous merge operation,\nallowing to chain the merges.\n\n-  ``objs``: one or multiple objects of a similar type as the Jdic\n   object itself.\n-  ``arr_mode``: determines how are handled the merging of conflicting\n   arrays (arrays who are on the same JSON path). 4 modes are supported:\n\n   -  ``\"replace\"``: arrays in Jdic are simply replaced.\n   -  ``\"append\"``: arrays from ``args`` are appended to array in Jdic.\n   -  ``\"new\"``: elements of arrays from ``args`` are appended, but only\n      if they do not exist in the Jdic array.\n   -  ``\"merge\"``: a recursive merge is processed on the elements of the\n      same index. If there are more elements in ``args`` arrays then\n      those are appended in the Jdic arrays.\n\n``new()``\n~~~~~~~~~\n\nReturns an independant copy of the current Jdic, but inheriting its\ndriver, schema and serializer. If the Jdic is a subdocument of another\nJdic then it loses its parenthood information (detachment).\n\n``parent(generation=1)``\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nReturns the Jdic parent of the current object. The root document has no\nparent (``None``).\n\n-  ``generation``: changes the generation of the parent returned. Eg.\n   ``2`` will return the grand-parent. ``0`` always returns ``None``.\n   ``None`` is also returned when ``generation`` targets above the root\n   Jdic document.\n\n``patch(diff)``\n~~~~~~~~~~~~~~~\n\nApplies a *diff stanza* as returned by ``diff()`` and returns a patched\nversion of the Jdic object, without parenthood information. The original\nobject is not modified. The underlying implementation is provided by the\n``json_delta`` Python library.\n\n-  ``diff``: an object returned by ``diff()``.\n\n``path()``\n~~~~~~~~~~\n\nReturns the full JSON path of the current Jdic object. Note that the\nJSON path format will depend of the current underlying driver in use.\nEg: the root path for the ``mongo`` driver is an empty string (``\"\"``)\nand ``\"$\"`` with the ``jsonpath_ng`` driver.\n\n``raw()``\n~~~~~~~~~\n\nReturns a standalone non-Jdic object representing the JSON document. The\nresult is a ``list`` or ``dict``, depending of the type of the Jdic\ndocument (Sequence or Mapping). This function is useful for passing a\nJdic in the form of pure Python basic types for compatibility purposes.\nThe results are cached and rebuilt only if changes occured.\n\n``validate(schema=None)``\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nValidates the current Jdic with any JSON schema provided. If no argument\nis passed the Jdic is validated against its own schema, if it has any.\nNote that calling ``validate()`` without argument is useless if the Jdic\nis instantiated with a schema: in such case the Jdic object is\nconstantly validated after a change. The schema validation features are\nsupported by the ``jsonschema`` Python library.\n\n-  ``schema``: a JSON schema.\n\n7. Settings\n-----------\n\nAdvanced serialization settings\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBy default Jdic will try to transform input floats into integers, if the\ninteger value is equal the float value (eg: float ``5.0`` is changed to\nint ``5``).\n\nThe goal is trying to avoid unpredicted behaviors in serializations\noperations, so we reduce the risk of detecting differences between two\nobjects who are both semantically and mathematically identical.\n\nIf you want to globally prevent the float to int normalization it is\npossible to set ``serialize_float_to_int`` to False:\n\n::\n\n    from jdic import settings\n    settings.serialize_float_to_int = False\n\nThis will apply to all classes.\n\nJSON dump formatting of Jdic objects\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nWhen using ``str()`` on a Jdic object the default behavior is to return\na nicely formatted JSON dump, whose keys are sorted and indentation set\nto 4, to ease the debugging processes and ``print()`` operations.\n\nIf you wish to send or store this dump, casting it to string with\n``str()`` is not the proper way to do, prefer the ``json()`` method\ninstead.\n\nIf you want to change the behavior of the JSON dump through ``str()``,\nyou can change the settings with ``json_dump_sort_keys`` and\n``json_dump_indent``:\n\n::\n\n    from jdic import settings\n    settings.json_dump_sort_keys = False # Disables key sorting\n    settings.json_dump_indent = 0 # Disables indentation\n\nThis will apply to all classes.\n\nChanging the default driver\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBy default the JSON path driver is ``mongo``. Changing the\n``json_path_driver`` to another value in the settings (eg:\n``jsonpath_ng``) will change the default driver used for any future\nclass instantiation, unless otherwise specified in ``jdic()``\nparameters:\n\n::\n\n    from jdic import settings\n    settings.json_path_driver = \"jsonpath_ng\"\n\n8. Implementing your own JSON path driver\n-----------------------------------------\n\nCreate your driver as a module\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n-  Create a new folder within your project (eg: ``new_driver``)\n\n-  Create a ``__init__.py`` file within the folder\n\nImplementing drivers\n~~~~~~~~~~~~~~~~~~~~\n\nFirst, you should review an already implemented driver. The ``mongo``\ndriver is the best example you can use so far. It is available within\nthe jdic module in ``drivers/mongo/__init__.py``.\n\nThe ``__init__.py`` file must contain a ``Driver`` class whose template\nis:\n\n::\n\n    class Driver(object):\n        \"\"\"The driver class\"\"\"\n\n        @classmethod\n        def add_to_path(cls, path, key):\n            \"\"\"Adds a key at the end of a JSON path and returns the new path\"\"\"\n\n        @classmethod\n        def control_invalid_key(cls, key):\n            \"\"\" Raises an exception if a key format (not JSON path) is not valid \"\"\"\n\n        @staticmethod\n        def get_new_path():\n            \"\"\"Returns a static JSON path pointing to the root of document\"\"\"\n\n        @classmethod\n        def get_parent(cls, obj, path):\n            \"\"\"Returns the parent of the value pointed by JSON path\"\"\"\n\n        @classmethod\n        def get_value_at_path(cls, obj, path):\n            \"\"\"Returns the value pointed by JSON path\"\"\"\n\n        @staticmethod\n        def is_a_path(key):\n            \"\"\"True if is a JSON path, else False\"\"\"\n\n        @classmethod\n        def is_root_path(cls, path):\n            \"\"\"True if is a JSON path for root document, else False\"\"\"\n\n        @staticmethod\n        def keys_to_path(keys):\n            \"\"\"Transforms a list of keys into a proper JSON path\"\"\"\n\n        @staticmethod\n        def match(obj, query):\n            \"\"\"Returns True if object matches the query, else False\"\"\"\n\n        @staticmethod\n        def path_to_keys(path):\n            \"\"\"Transforms an expression-less JSON path into a series of keys\"\"\"\n\nNote that if you wish to benefit from already implemented functions, you\ncan inherit from any existing driver. For example, the current class\nimplementation of the ``jsonpath-ng`` driver inherits from the Mongo\ndriver allowing to reimplement only the relevant features, explaining\nwhy the ``match()`` function is still implemented to match against Mongo\nQuery Language queries supported by the ``mongo`` driver.\n\n::\n\n    class Driver(jdic.drivers.mongo.Driver):\n        ...\n\n9. Related projects/libraries:\n------------------------------\n\njson\\_delta: http://json-delta.readthedocs.io/en/latest/\n\njsonschema: https://github.com/Julian/jsonschema\n\nmongoquery: https://github.com/kapouille/mongoquery\n\njsonpath\\_ng: https://github.com/h2non/jsonpath-ng\n\n10. TODO:\n---------\n\n-  Pip package\n-  Readthedocs documentation\n-  More tests (current state: 108 assertions)\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/kerfab/jdic", "keywords": "jdic json checksum diff patch find match mongo mongodb path", "license": "", "maintainer": "", "maintainer_email": "", "name": "jdic", "package_url": "https://pypi.org/project/jdic/", "platform": "", "project_url": "https://pypi.org/project/jdic/", "project_urls": {"Homepage": "https://github.com/kerfab/jdic"}, "release_url": "https://pypi.org/project/jdic/1.0.3/", "requires_dist": ["json-delta", "json-schema", "jsonpath-ng", "mongoquery"], "requires_python": "", "summary": "A ready-to-use library which eases the manipulation of JSON-like documents, so that you can focus on logic instead of losing time in formal document manipulations.Jdic offers original features, but also embeds mission-critical 3rd party libraries and unite them all within a comprehensive easy-to-use API.", "version": "1.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"overview\">\n<h2>1. Overview</h2>\n<p>In most projects, manipulating JSON documents requires to reinvent the\nwheel on a lot of small features, or to use a varied set of external\npackages. Jdic\u2019s admitted goal is to write less code with the guarantee\nto get the job done fast, flawlessly and efficiently.</p>\n<p>Jdic aims to avoid that: it is a ready-to-use type-class which eases the\nmanipulation of JSON-like documents, so that you can focus on logic\ninstead of losing time in formal document manipulations.</p>\n<p>The Jdic class provides a lot of original features but also embeds\nmission-critical 3rd party libraries and unite them all within a\ncomprehensive easy-to-use API.</p>\n</div>\n<div id=\"features\">\n<h2>2. Features</h2>\n<p>Here are the useful operations Jdic can do for you:</p>\n<ul>\n<li>Transparent JSON paths integration - for read and write operations,\nthrough an agnostic driver model. Currently MongoDB and Jsonpath-NG\npaths formats are natively supported.</li>\n<li>Fast browsing of JSON documents - browse the entire data structure\nwhile getting useful values on each iteration: value, JSON path,\nparent, parent JSON path, depth, etc.</li>\n<li>Find, Find-Keys and Find-Match features for quickly finding any key\nor value, or subdocument matching MongoDB-like queries.</li>\n<li>Merge features for fusioning objects recursively, with up to 4 modes\nfor handling conflicting arrays (replace, merge, new, append).</li>\n<li>Diff &amp; Patch features - so you can represent differences between two\ndocuments in small data sets (diff), and apply those differences to\nupdate documents (patch).</li>\n<li>JSON Schema validation - if you need it, with auto-validation on each\ndocument change.</li>\n<li>Consistent document checksuming - natively SHA-256, it allows to get\na single checksum for the document, the checksum will always be the\nsame on all systems.</li>\n<li>Depth features - you can crawl your document at certain depths only.</li>\n<li>Strict features - input data will be serialized to a strict JSON\nformat.</li>\n<li>Agnostic dicts/lists replacement for Python\u2019s <tt>enumerate()</tt></li>\n<li>Custom input serializer support - convert specific objects to the\nJSON data you want to.</li>\n<li>Cache features with change detection to accelerate some of the API\ncalls.</li>\n</ul>\n</div>\n<div id=\"examples\">\n<h2>3. Examples</h2>\n<div id=\"instantiation\">\n<h3>Instantiation</h3>\n<pre>from jdic import jdic\n\no = {\"a\" : {\"b\" : {\"c\" : 1}}}\nj = jdic(o) # Accepts dicts and lists (or any Mapping, Sequence)\n</pre>\n</div>\n<div id=\"find-the-paths-for-a-value\">\n<h3>Find the paths for a value</h3>\n<pre>paths = [m.path for m in j.find(1)] # Find path for a value as-is\n&gt;&gt;&gt; [\"a.b.c\"]\n\nfor match in j.find(1): # Classic loop format\n    print(match.path)\n&gt;&gt;&gt; a.b.c\n</pre>\n</div>\n<div id=\"crawl-all-the-leaves\">\n<h3>Crawl all the leaves</h3>\n<pre>paths = [m.parent_path for m in j.leaves()]  # Results include parents paths and more\n&gt;&gt;&gt; [\"a.b\"]\n</pre>\n</div>\n<div id=\"crawl-everything\">\n<h3>Crawl everything</h3>\n<pre>allitems = [m.value for m in j.browse()]  # The first item is always the root itself\n&gt;&gt;&gt; [\n        {\"a\": {\"b\": {\"c\": 1}}},\n        {\"b\": {\"c\": 1}},\n        {\"c\": 1},\n        1\n]\n</pre>\n</div>\n<div id=\"get-the-depth-of-values\">\n<h3>Get the depth of values</h3>\n<pre>paths = [m.depth for m in j.find({\"c\" : 1})] # find() target values can be objects\n&gt;&gt;&gt; [2]\n</pre>\n</div>\n<div id=\"match-an-object-against-a-mongodb-like-query-useful-for-rules-filtering-engines\">\n<h3>Match an object against a MongoDB-like query (useful for rules/filtering engines)</h3>\n<pre>paths = [m.path for m in j.find_match({\"c\": {\"$gt\": 0}}) ] # Support of Mongo-like queries\n&gt;&gt;&gt; [\"a.b\"]\n\npaths = [m.path for m in j.find_match({  # Complex Mongo-like queries are permitted\n    \"$and\" : [\n        {\"b.c\": {\"$exists\" : True}},\n        {\"b.d\": {\"$exists\" : False}}\n    ]\n})]\n&gt;&gt;&gt; [\"a\"]\n</pre>\n</div>\n<div id=\"checksum-objects-and-sub-objects-consistently\">\n<h3>Checksum objects and sub-objects consistently</h3>\n<pre>j.checksum()\n&gt;&gt;&gt; ebd240a9ae435649514086d13c20d9963ec2844a1f866b313919c55a7c3f7ccb # Is consistent on all systems\n\nj[\"a\"].checksum() # Sub-iterables have Jdic methods / all sub-iterables implement their own checksum()\n&gt;&gt;&gt; 05a2013fbe17af7d58779ed96e0d74bd6fa3ce2726c1ebbd9f7dc33671b1c28e\n\nj[\"a\"] = None\nj.checksum()\n&gt;&gt;&gt; 69d7d33051c5e05aa72f55a9a8e30a73da8d4afaa37127b9ea7ee29403aa9d3f # Change detection from child to parent\n</pre>\n</div>\n<div id=\"make-diffs-and-patches-between-objects\">\n<h3>Make diffs and patches between objects</h3>\n<pre>j = jdic(o)\np = {\"a\" : {\"e\" : {\"f\" : -1 }}}\ndiff = j.diff(p)\n&gt;&gt;&gt; [[[\"a\"], {\"e\": {\"f\": -1}}]] # A diff stanza - on larger documents the diffs are smaller than documents\n\nj = j.patch(diff) # Patch does not modify the original object but returns a patched version\nj == p # Jdic objects can be transparently compared with dict or list objects (or equivalents)\n&gt;&gt;&gt; True\n</pre>\n</div>\n<div id=\"merge-objects-together\">\n<h3>Merge objects together</h3>\n<pre>q = {\"a\" : {\"b\" : {\"d\" : 2}}}\nj.merge(q)\n&gt;&gt;&gt; {\"a\": {\"b\": {\"c\": 1, \"d\": 2}}} # Handles recursive merge\n</pre>\n</div>\n<div id=\"validate-against-a-schema-in-real-time-with-the-built-in-change-detection\">\n<h3>Validate against a schema in real-time with the built-in change detection</h3>\n<pre>j = jdic(o, schema = {'type' : 'object' , 'properties' : {'a' : {'type' : 'object'}}}) # Correct Schema\nj['a'] = 3 # instant detection of schema violation (exception)\n&gt;&gt;&gt; Traceback (most recent call last): ...\n</pre>\n</div>\n<div id=\"test-the-jdic-object-type\">\n<h3>Test the Jdic object type:</h3>\n<pre>from jdic import Jdic # `Jdic` is the parent class, do not confuse with the function `jdic()`\n&gt;&gt;&gt; type(j)\n&lt;class 'jdic.JdicMapping'&gt;\n&gt;&gt;&gt; isinstance(j, Jdic)\nTrue\n</pre>\n</div>\n<div id=\"change-the-native-enumerate-s-behavior-for-smoother-iterations\">\n<h3>Change the native enumerate()\u2019s behavior for smoother iterations</h3>\n<pre># Agnostic enumerations with a revised enumerate() function\nfrom jdic import enumerate\ny, z = [1,2,3], {'a':1, 'b':2}\nfor k, v in enumerate(y): # Acts just as the original enumerate() for lists\n    y[k] = v\nfor k, v in enumerate(z): # But allows dict enumeration, raising a key instead of a counter\n    z[k] = v\n</pre>\n</div>\n<div id=\"change-the-json-path-driver\">\n<h3>Change the JSON path driver</h3>\n<pre>j = jdic({'a' : [{'b': 1}, {'b': 2}, {'b': 3}]}, driver = 'jsonpath_ng')\nj['a[*].b'] = 0 # Reassign the value to all locations at once!\n&gt;&gt;&gt; {\"a\": [{\"b\": 0}, {\"b\": 0}, {\"b\": 0}]}\n\ndel('a[*].b') # Also works with del()\n&gt;&gt;&gt; {\"a\": [{}, {}, {}]}\n</pre>\n</div>\n</div>\n<div id=\"the-matchresult-object\">\n<h2>4. The MatchResult object</h2>\n<p>The MatchResult object is returned for most search operations. It\ncontains:</p>\n<ul>\n<li><tt>value</tt>: the found object</li>\n<li><tt>path</tt>: the full JSON path of the found object</li>\n<li><tt>parent</tt>: the Jdic object containing the current found object</li>\n<li><tt>parent_path</tt>: the full JSON path of the parent of the found object</li>\n<li><tt>key</tt>: the current key (or index) at which the object was found\nwithin its parent</li>\n<li><tt>depth</tt>: the depth of the object counting from the root of the Jdic</li>\n</ul>\n</div>\n<div id=\"jdic-object-instantiation\">\n<h2>5. Jdic object instantiation</h2>\n<h2 id=\"jdic-obj-schema-none-serializer-none-driver-none\"><span class=\"section-subtitle\"><tt>jdic(obj, schema=None, serializer=None, driver=None)</tt></span></h2>\n<p>Instantiations of Jdic objects is made through the <tt>jdic()</tt> function\nwhich will decide for the type of Jdic object (<tt>JdicMapping</tt> or\n<tt>JdicSequence</tt>) to instantiate and return. Both those types inherit\nfrom the Jdic class (do not use this one directly, mind the lowercase).</p>\n<ul>\n<li><tt>obj</tt>: any list or dictionary. Sequence and Mapping equivalents\nwill be casted to <tt>list</tt> and <tt>dict</tt>.</li>\n<li><tt>schema</tt>: optional, must be a JSON Schema in the form of a\n<tt>dict</tt>. If provided, all changes affecting the Jdic will be\nvalidated against the schema whenever they happen.</li>\n<li><tt>serializer</tt>: optional, your custom serialization function. Useless\nwhen <tt>obj</tt> is the result of a <tt>json.loads()</tt>. It will be called\nto transform non-standard object types into standard JSON types. If\nnot provided, exotic types are transformed to <tt>str</tt>. It is possible\nto use <tt>settings.serialize_custom_function</tt> instead, to globally\nspecify a serializing function for all the Jdic instances. A\nserializer specified as argument will always have priority over\nsettings. The custom serializer function, if used, must return a JSON\ncompliant data type: None, bool, str, int, float, list, dict.</li>\n<li><tt>driver</tt>: optional, a string representing the driver to use\n(<tt>mongo</tt> and <tt>jsonpath_ng</tt> are natively implemented). It is\npossible to use <tt>settings.json_path_driver</tt> instead, to globally\nspecify a driver. Drivers specified as argument will have priority\nover settings.</li>\n</ul>\n<p>Note about floating point values: objects serialized as Jdic objects\nwill have their floating values transformed to integers whenever the\nfloat value is equal to its integer form. This is to make the JSON dumps\nand checksums consistent and avoids \u20185\u2019 to be shown as \u20185.0\u2019. This can\nbe changed by setting <tt>settings.serialize_float_to_int</tt> to <tt>False</tt>.</p>\n</div>\n<div id=\"jdic-objects-methods\">\n<h2>6. Jdic objects methods</h2>\n<div id=\"browse-sort-false-depth-none-maxdepth-none\">\n<h3><tt>browse(sort=False, depth=None, maxdepth=None)</tt></h3>\n<p>Recurse on all Jdic elements, yielding a <tt>MatchResult</tt> object on each\niteration.</p>\n<ul>\n<li><tt>sort</tt>: if True all the results will be yielded with JSON paths in\nalphabetical order.</li>\n<li><tt>depth</tt>: an integer - only the results from objects at <em>depth</em> will\nbe yielded.</li>\n<li><tt>maxdepth</tt> : an integer - will not recurse on documents whose depth\nis above <tt>maxdepth</tt>.</li>\n</ul>\n</div>\n<div id=\"checksum-algo-sha256\">\n<h3><tt><span class=\"pre\">checksum(algo='sha256')</span></tt></h3>\n<p>Returns an ASCII checksum representing the content and data types of the\nobject. Checksums are consistent from an execution to another and can be\nsafely used for content change detection or objects comparisons. The\nchecksum is cached and is only recalculated if changes occured.</p>\n<ul>\n<li><tt>algo</tt>: any algorithm supported by the <tt>hashlib</tt> Python library</li>\n</ul>\n</div>\n<div id=\"deepness\">\n<h3><tt>deepness()</tt></h3>\n<p>Returns an integer representing the deepness of the JSON structure from\nwhere <tt>deepness()</tt> is called. A document with no dict or list within\nit has a deepness of zero. The deepness is cached and is only\nrecalculated if changes occured.</p>\n</div>\n<div id=\"depth\">\n<h3><tt>depth()</tt></h3>\n<p>Returns an integer representing the depth of the current document from\nthe root of the Jdic object. The depth of the root document is 0.</p>\n</div>\n<div id=\"diff-obj\">\n<h3><tt>diff(obj)</tt></h3>\n<p>Returns an object (a diff <em>stanza</em>) representing the differences between\nthe Jdic and <tt>obj</tt>. <tt>diff()</tt> is implemented by the <tt>json_delta</tt>\nPython library.</p>\n<ul>\n<li><tt>obj</tt>: any data</li>\n</ul>\n</div>\n<div id=\"enumerate-sort-false\">\n<h3><tt>enumerate(sort=False)</tt></h3>\n<p>Agnostic and non-recursive enumeration of each entry in the current\nobject. It yields a <tt>(k, v)</tt> tuple, where <tt>k</tt> is either an integer\nindex when object is a list, and a string key when object is a dict.\n<tt>v</tt> is always the value. <tt>enumerate()</tt> is also available as a\nstandalone function within the Jdic package:\n<tt>from jdic import enumerate</tt>.</p>\n<ul>\n<li><tt>sort</tt> : if True, sorts the dictionary keys alphabetically. Only\nsort dictionary keys, not lists.</li>\n</ul>\n</div>\n<div id=\"find-value-sort-false-limit-none-depth-none-maxdepth-none\">\n<h3><tt>find(value, sort=False, limit=None, depth=None, maxdepth=None)</tt></h3>\n<p>Searches a value within the entire Jdic. Searches are strict (<tt>==</tt>).</p>\n<ul>\n<li><tt>value</tt>: the value to search for - can be a simple type (int, str,\netc.) or complex object (list, dict, Jdic, etc.)</li>\n<li><tt>sort</tt>: if True the search results will be sorted with JSON paths\nin alphabetical order.</li>\n<li><tt>limit</tt>: an integer - terminates the search when the number of\nresults reaches <tt>limit</tt>.</li>\n<li><tt>depth</tt>: an integer - only the results from objects at <em>depth</em> will\nbe yielded.</li>\n<li><tt>maxdepth</tt>: an integer - will not recurse on documents whose depth\nis above <tt>maxdepth</tt>.</li>\n</ul>\n</div>\n<div id=\"find-keys-keys-mode-any-sort-false-limit-none-depth-none-maxdepth-none\">\n<h3><tt>find_keys(keys, <span class=\"pre\">mode=\"any\",</span> sort=False, limit=None, depth=None, maxdepth=None)</tt></h3>\n<p>Searches any sub-object containing <tt>keys</tt>. <tt>keys</tt> can be a single\nkey or a list of keys. This function aims to facilitate finding\nsub-objects whose keys are known.</p>\n<ul>\n<li><tt>keys</tt>: a string or list of strings. The search will be case\nsensitive. Keys are for dicts and cannot be integer indexes of\narrays. Keys cannot be JSON paths.</li>\n<li><tt>mode</tt>: <tt>\"any\"</tt> or <tt>\"all\"</tt> - if <tt>\"any\"</tt> then any object\nmatching any of the provided keys will be yielded. If <tt>\"all\"</tt> then\nany object containing all the keys will be matched.</li>\n<li><tt>sort</tt>: if True the search results will be sorted with JSON paths\nin alphabetical order.</li>\n<li><tt>limit</tt>: an integer - terminates the search when the number of\nresults reaches <tt>limit</tt>.</li>\n<li><tt>depth</tt>: an integer - only the results from objects at <em>depth</em> will\nbe yielded.</li>\n<li><tt>maxdepth</tt>: an integer - will not recurse on documents whose depth\nis above <tt>maxdepth</tt>.</li>\n</ul>\n</div>\n<div id=\"find-match-query-sort-false-limit-none-depth-none-maxdepth-none\">\n<h3><tt>find_match(query, sort=False, limit=None, depth=None, maxdepth=None)</tt></h3>\n<p>Finds all objects matching positive against <tt>query</tt>. Queries for\n<tt>find_match()</tt> are MongoDB-like queries, for both <tt>mongo</tt> and\n<tt>jsonpath_ng</tt> drivers. The underlying implementation is provided by\nthe <tt>mongoquery</tt> Python library.</p>\n<ul>\n<li><tt>query</tt>: a MongoDB-like query. Please refer to the MongoDB\ndocumentation or the examples for information on queries\nstructuration. Also review <a href=\"https://github.com/kapouille/mongoquery\" rel=\"nofollow\">https://github.com/kapouille/mongoquery</a>\nfor more details on <tt>mongoquery</tt> and its known limitations.</li>\n<li><tt>sort</tt>: if True the search results will be sorted with JSON paths\nin alphabetical order.</li>\n<li><tt>limit</tt>: an integer - terminates the search when the number of\nresults reaches <tt>limit</tt>.</li>\n<li><tt>depth</tt>: an integer - only the results from objects at <em>depth</em> will\nbe yielded.</li>\n<li><tt>maxdepth</tt>: an integer - will not recurse on documents whose depth\nis above <tt>maxdepth</tt>.</li>\n</ul>\n</div>\n<div id=\"json-sort-keys-false-indent-0-ensure-ascii-false\">\n<h3><tt>json(sort_keys=False, indent=0, ensure_ascii=False)</tt></h3>\n<p>A helper to dump Jdic objects as serialized JSON strings.</p>\n<ul>\n<li><tt>sort_keys</tt>: all keys will be sorted alphabetically within their\nown dicts.</li>\n<li><tt>indent</tt>: number of spaces to add on new blocks.</li>\n<li><tt>ensure_ascii</tt>: for a pure ASCII output (usually not recommended\nfor anything else than printing binary data).</li>\n</ul>\n</div>\n<div id=\"leaves-sort-false-depth-none-maxdepth-none\">\n<h3><tt>leaves(sort=False, depth=None, maxdepth=None)</tt></h3>\n<p>Will yield a <tt>MatchResult</tt> on each leaf encountered in the document. A\nleaf is a terminal value within the JSON documents. Basically all values\nare leaves, except dicts and lists.</p>\n<ul>\n<li><tt>sort</tt>: if True the search results will be sorted with JSON paths\nin alphabetical order.</li>\n<li><tt>depth</tt>: an integer - only the results from objects at <em>depth</em> will\nbe yielded.</li>\n<li><tt>maxdepth</tt>: an integer - will not recurse on documents whose depth\nis above <tt>maxdepth</tt>.</li>\n</ul>\n</div>\n<div id=\"nb-leaves\">\n<h3><tt>nb_leaves()</tt></h3>\n<p>Returns the number of leaves contained in the Jdic object. This\ninformation is cached and is only recalculated if changes occured.</p>\n</div>\n<div id=\"match-query\">\n<h3><tt>match(query)</tt></h3>\n<p>Returns <tt>True</tt> or <tt>False</tt> if the current Jdic object matches the\nMongo-like query. Unlike <tt>find_match()</tt> it will not recurse into\nsubdocuments. The current <tt>match()</tt> implementation is supported by the\n<tt>mongoquery</tt> Python library.</p>\n<ul>\n<li><tt>query</tt>: a Mongo-like query object</li>\n</ul>\n</div>\n<div id=\"merge-objs-arr-mode-replace\">\n<h3><tt><span class=\"pre\">merge(*objs,</span> <span class=\"pre\">arr_mode=\"replace\")</span></tt></h3>\n<p>Will merge the current Jdic with one or multiple other objects (dicts or\nlists). It is not possible to merge a Jdic of type Mapping (dict) with a\nSequence (list) or vice-versa. This limitation does not apply to\nsub-documents. Note that, unlike <tt>patch()</tt>, the method will change the\nstate of the current object. If multiple args are provided then the next\nobj in <tt>objs</tt> is merged on the result of the previous merge operation,\nallowing to chain the merges.</p>\n<ul>\n<li><tt>objs</tt>: one or multiple objects of a similar type as the Jdic\nobject itself.</li>\n<li><tt>arr_mode</tt>: determines how are handled the merging of conflicting\narrays (arrays who are on the same JSON path). 4 modes are supported:<ul>\n<li><tt>\"replace\"</tt>: arrays in Jdic are simply replaced.</li>\n<li><tt>\"append\"</tt>: arrays from <tt>args</tt> are appended to array in Jdic.</li>\n<li><tt>\"new\"</tt>: elements of arrays from <tt>args</tt> are appended, but only\nif they do not exist in the Jdic array.</li>\n<li><tt>\"merge\"</tt>: a recursive merge is processed on the elements of the\nsame index. If there are more elements in <tt>args</tt> arrays then\nthose are appended in the Jdic arrays.</li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"new\">\n<h3><tt>new()</tt></h3>\n<p>Returns an independant copy of the current Jdic, but inheriting its\ndriver, schema and serializer. If the Jdic is a subdocument of another\nJdic then it loses its parenthood information (detachment).</p>\n</div>\n<div id=\"parent-generation-1\">\n<h3><tt>parent(generation=1)</tt></h3>\n<p>Returns the Jdic parent of the current object. The root document has no\nparent (<tt>None</tt>).</p>\n<ul>\n<li><tt>generation</tt>: changes the generation of the parent returned. Eg.\n<tt>2</tt> will return the grand-parent. <tt>0</tt> always returns <tt>None</tt>.\n<tt>None</tt> is also returned when <tt>generation</tt> targets above the root\nJdic document.</li>\n</ul>\n</div>\n<div id=\"patch-diff\">\n<h3><tt>patch(diff)</tt></h3>\n<p>Applies a <em>diff stanza</em> as returned by <tt>diff()</tt> and returns a patched\nversion of the Jdic object, without parenthood information. The original\nobject is not modified. The underlying implementation is provided by the\n<tt>json_delta</tt> Python library.</p>\n<ul>\n<li><tt>diff</tt>: an object returned by <tt>diff()</tt>.</li>\n</ul>\n</div>\n<div id=\"path\">\n<h3><tt>path()</tt></h3>\n<p>Returns the full JSON path of the current Jdic object. Note that the\nJSON path format will depend of the current underlying driver in use.\nEg: the root path for the <tt>mongo</tt> driver is an empty string (<tt>\"\"</tt>)\nand <tt>\"$\"</tt> with the <tt>jsonpath_ng</tt> driver.</p>\n</div>\n<div id=\"raw\">\n<h3><tt>raw()</tt></h3>\n<p>Returns a standalone non-Jdic object representing the JSON document. The\nresult is a <tt>list</tt> or <tt>dict</tt>, depending of the type of the Jdic\ndocument (Sequence or Mapping). This function is useful for passing a\nJdic in the form of pure Python basic types for compatibility purposes.\nThe results are cached and rebuilt only if changes occured.</p>\n</div>\n<div id=\"validate-schema-none\">\n<h3><tt>validate(schema=None)</tt></h3>\n<p>Validates the current Jdic with any JSON schema provided. If no argument\nis passed the Jdic is validated against its own schema, if it has any.\nNote that calling <tt>validate()</tt> without argument is useless if the Jdic\nis instantiated with a schema: in such case the Jdic object is\nconstantly validated after a change. The schema validation features are\nsupported by the <tt>jsonschema</tt> Python library.</p>\n<ul>\n<li><tt>schema</tt>: a JSON schema.</li>\n</ul>\n</div>\n</div>\n<div id=\"settings\">\n<h2>7. Settings</h2>\n<div id=\"advanced-serialization-settings\">\n<h3>Advanced serialization settings</h3>\n<p>By default Jdic will try to transform input floats into integers, if the\ninteger value is equal the float value (eg: float <tt>5.0</tt> is changed to\nint <tt>5</tt>).</p>\n<p>The goal is trying to avoid unpredicted behaviors in serializations\noperations, so we reduce the risk of detecting differences between two\nobjects who are both semantically and mathematically identical.</p>\n<p>If you want to globally prevent the float to int normalization it is\npossible to set <tt>serialize_float_to_int</tt> to False:</p>\n<pre>from jdic import settings\nsettings.serialize_float_to_int = False\n</pre>\n<p>This will apply to all classes.</p>\n</div>\n<div id=\"json-dump-formatting-of-jdic-objects\">\n<h3>JSON dump formatting of Jdic objects</h3>\n<p>When using <tt>str()</tt> on a Jdic object the default behavior is to return\na nicely formatted JSON dump, whose keys are sorted and indentation set\nto 4, to ease the debugging processes and <tt>print()</tt> operations.</p>\n<p>If you wish to send or store this dump, casting it to string with\n<tt>str()</tt> is not the proper way to do, prefer the <tt>json()</tt> method\ninstead.</p>\n<p>If you want to change the behavior of the JSON dump through <tt>str()</tt>,\nyou can change the settings with <tt>json_dump_sort_keys</tt> and\n<tt>json_dump_indent</tt>:</p>\n<pre>from jdic import settings\nsettings.json_dump_sort_keys = False # Disables key sorting\nsettings.json_dump_indent = 0 # Disables indentation\n</pre>\n<p>This will apply to all classes.</p>\n</div>\n<div id=\"changing-the-default-driver\">\n<h3>Changing the default driver</h3>\n<p>By default the JSON path driver is <tt>mongo</tt>. Changing the\n<tt>json_path_driver</tt> to another value in the settings (eg:\n<tt>jsonpath_ng</tt>) will change the default driver used for any future\nclass instantiation, unless otherwise specified in <tt>jdic()</tt>\nparameters:</p>\n<pre>from jdic import settings\nsettings.json_path_driver = \"jsonpath_ng\"\n</pre>\n</div>\n</div>\n<div id=\"implementing-your-own-json-path-driver\">\n<h2>8. Implementing your own JSON path driver</h2>\n<div id=\"create-your-driver-as-a-module\">\n<h3>Create your driver as a module</h3>\n<ul>\n<li>Create a new folder within your project (eg: <tt>new_driver</tt>)</li>\n<li>Create a <tt>__init__.py</tt> file within the folder</li>\n</ul>\n</div>\n<div id=\"implementing-drivers\">\n<h3>Implementing drivers</h3>\n<p>First, you should review an already implemented driver. The <tt>mongo</tt>\ndriver is the best example you can use so far. It is available within\nthe jdic module in <tt>drivers/mongo/__init__.py</tt>.</p>\n<p>The <tt>__init__.py</tt> file must contain a <tt>Driver</tt> class whose template\nis:</p>\n<pre>class Driver(object):\n    \"\"\"The driver class\"\"\"\n\n    @classmethod\n    def add_to_path(cls, path, key):\n        \"\"\"Adds a key at the end of a JSON path and returns the new path\"\"\"\n\n    @classmethod\n    def control_invalid_key(cls, key):\n        \"\"\" Raises an exception if a key format (not JSON path) is not valid \"\"\"\n\n    @staticmethod\n    def get_new_path():\n        \"\"\"Returns a static JSON path pointing to the root of document\"\"\"\n\n    @classmethod\n    def get_parent(cls, obj, path):\n        \"\"\"Returns the parent of the value pointed by JSON path\"\"\"\n\n    @classmethod\n    def get_value_at_path(cls, obj, path):\n        \"\"\"Returns the value pointed by JSON path\"\"\"\n\n    @staticmethod\n    def is_a_path(key):\n        \"\"\"True if is a JSON path, else False\"\"\"\n\n    @classmethod\n    def is_root_path(cls, path):\n        \"\"\"True if is a JSON path for root document, else False\"\"\"\n\n    @staticmethod\n    def keys_to_path(keys):\n        \"\"\"Transforms a list of keys into a proper JSON path\"\"\"\n\n    @staticmethod\n    def match(obj, query):\n        \"\"\"Returns True if object matches the query, else False\"\"\"\n\n    @staticmethod\n    def path_to_keys(path):\n        \"\"\"Transforms an expression-less JSON path into a series of keys\"\"\"\n</pre>\n<p>Note that if you wish to benefit from already implemented functions, you\ncan inherit from any existing driver. For example, the current class\nimplementation of the <tt><span class=\"pre\">jsonpath-ng</span></tt> driver inherits from the Mongo\ndriver allowing to reimplement only the relevant features, explaining\nwhy the <tt>match()</tt> function is still implemented to match against Mongo\nQuery Language queries supported by the <tt>mongo</tt> driver.</p>\n<pre>class Driver(jdic.drivers.mongo.Driver):\n    ...\n</pre>\n</div>\n</div>\n<div id=\"related-projects-libraries\">\n<h2>9. Related projects/libraries:</h2>\n<p>json_delta: <a href=\"http://json-delta.readthedocs.io/en/latest/\" rel=\"nofollow\">http://json-delta.readthedocs.io/en/latest/</a></p>\n<p>jsonschema: <a href=\"https://github.com/Julian/jsonschema\" rel=\"nofollow\">https://github.com/Julian/jsonschema</a></p>\n<p>mongoquery: <a href=\"https://github.com/kapouille/mongoquery\" rel=\"nofollow\">https://github.com/kapouille/mongoquery</a></p>\n<p>jsonpath_ng: <a href=\"https://github.com/h2non/jsonpath-ng\" rel=\"nofollow\">https://github.com/h2non/jsonpath-ng</a></p>\n</div>\n<div id=\"todo\">\n<h2>10. TODO:</h2>\n<ul>\n<li>Pip package</li>\n<li>Readthedocs documentation</li>\n<li>More tests (current state: 108 assertions)</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 3192847, "releases": {"1.0.3": [{"comment_text": "", "digests": {"md5": "8ef7d448348c43e2af049480446e51f7", "sha256": "e9ea6104cd35e2b15f6a2d2e18ff6298921f73e5b74ee01d35deadaf0d4e4fcb"}, "downloads": -1, "filename": "jdic-1.0.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "8ef7d448348c43e2af049480446e51f7", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 25798, "upload_time": "2017-09-21T20:41:43", "upload_time_iso_8601": "2017-09-21T20:41:43.577694Z", "url": "https://files.pythonhosted.org/packages/ab/55/0545e13e75d0784aed1bf059087c26b480c3388a56cf24ebe4fb1cb222fb/jdic-1.0.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4f97ef8aca7d0c79297e72a28968a37c", "sha256": "46a857dbfefd2e15627836cffe8fe2ef2cfc177900b017ff4bd548915035dc52"}, "downloads": -1, "filename": "jdic-1.0.3.tar.gz", "has_sig": false, "md5_digest": "4f97ef8aca7d0c79297e72a28968a37c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28805, "upload_time": "2017-09-21T20:41:44", "upload_time_iso_8601": "2017-09-21T20:41:44.883114Z", "url": "https://files.pythonhosted.org/packages/d2/b5/9f02e0cc396a7186fa6f48a1d27dbc048a9ea842cbea5b168813640441cc/jdic-1.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "8ef7d448348c43e2af049480446e51f7", "sha256": "e9ea6104cd35e2b15f6a2d2e18ff6298921f73e5b74ee01d35deadaf0d4e4fcb"}, "downloads": -1, "filename": "jdic-1.0.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "8ef7d448348c43e2af049480446e51f7", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 25798, "upload_time": "2017-09-21T20:41:43", "upload_time_iso_8601": "2017-09-21T20:41:43.577694Z", "url": "https://files.pythonhosted.org/packages/ab/55/0545e13e75d0784aed1bf059087c26b480c3388a56cf24ebe4fb1cb222fb/jdic-1.0.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4f97ef8aca7d0c79297e72a28968a37c", "sha256": "46a857dbfefd2e15627836cffe8fe2ef2cfc177900b017ff4bd548915035dc52"}, "downloads": -1, "filename": "jdic-1.0.3.tar.gz", "has_sig": false, "md5_digest": "4f97ef8aca7d0c79297e72a28968a37c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28805, "upload_time": "2017-09-21T20:41:44", "upload_time_iso_8601": "2017-09-21T20:41:44.883114Z", "url": "https://files.pythonhosted.org/packages/d2/b5/9f02e0cc396a7186fa6f48a1d27dbc048a9ea842cbea5b168813640441cc/jdic-1.0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:52:57 2020"}