{"info": {"author": "Andy Pearce", "author_email": "andy@andy-pearce.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Text Processing", "Topic :: Text Processing :: General"], "description": "Overview\n========\n\nThe ``cmdparser`` package contains two modules which are useful for writing\ntext command parsers, particularly using the builtin Python ``cmd`` module.\n\nThe package consists of two modules:\n\n* ``cmdparser.cmdparser``\n* ``cmdparser.datetimeparse``\n\nThese two modules are discussed below briefly. For more information see the\ndocstrings of the two modules, and also the ``ttrack`` command-line application\n(from which these libraries originated) makes a good example of their use.\n\n\n\nInstallation\n============\n\nInstall the ``cmdparser`` package from PyPI. For example, to install using\n``pip``::\n\n    pip install cmdparser\n\n\n.. _cmdparser_overview:\n\ncmdparser Overview\n==================\n\nThis module allows the creation of parse trees from textual command\nspecifications of the following form::\n\n    ham ( eggs | chips [spam] | beans [spam [...]] )\n\nThese parse trees can then be used to check for matches against particular\ncommand strings, and also allow valid completions of partial command strings to\nbe listed. To build a parse tree and use it in a few examples, see the\nfollowing example code:\n\n.. code-block:: python\n\n    from cmdparser import cmdparser\n\n    parse_tree = cmdparser.parse_spec(\"one (two|three) <four> [five]\")\n\n    # Returns None to indicate successful parse\n    parse_tree.check_match((\"one\", \"two\", \"anything\"))\n    # Returns an appropriate parsing error message\n    parse_tree.check_match((\"one\", \"three\", \"anything\", \"six\"))\n    # Returns the list [\"two\", \"three\"]\n    parse_tree.get_completions((\"one\",))\n\nAs well as dealing with fixed token strings, dynamic tokens can also be set up\nwhere the list of strings accepted can change over time, or where arbitrary\nstrings or lists of strings can be accepted. See the module's docstrings for\nspecifics of the classes available, but as an example:\n\n.. code-block:: python\n\n    from cmdparser import cmdparser\n\n    class ColourToken(cmdparser.Token):\n        def get_values(self, context):\n            # Static list here, but could easily be dynamic\n            return [\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"purple\"]\n\n    def my_ident_factory(token):\n        if token == \"number\":\n            return cmdparser.IntegerToken(token)\n        elif token == \"colour\":\n            return ColourToken(token)\n        return None\n\n    parse_tree = cmdparser.parse_tree(\"take <number> <colour> balls\",\n                                      ident_factory=my_ident_factory)\n\n    # Returns None to indicate successful parse, and the \"cmd_fields\" dict will\n    # be initialised as:\n    # { \"take\": [\"take\"], \"<number>\": [\"23\"],\n    #   \"<colour>\": [\"blue\"], \"balls\": [\"balls\"] }\n    cmd_fields = {}\n    parse_tree.check_match((\"take\", \"23\", \"blue\", \"balls\"), fields=cmd_fields)\n    # Returns an appropriate parsing error message\n    parse_tree.check_match((\"take\", \"all\", \"red\", \"balls\"))\n    # Returns the list [\"red\", \"orange\", \"yellow\", ..., \"purple\"]\n    parse_tree.get_completions((\"take\", \"5\"))\n\n\nThere are four classes which are suitable base classes for user-derived\ntokens:\n\n``Token``\n  This is useful for cases where one of a set of fixed values is suitable,\n  where the list may be fixed or dynamic. The ``get_values()`` method should be\n  overridden to return a list of valid tokens as strings. Optionally, there is\n  also a ``convert()`` method which can be used to convert\n\n``AnyToken``\n  Similar to ``Token``, but any string is to be expected. Validation can be\n  performed via the ``validate()`` method, but that doesn't allow\n  tab-completion as it's only called once the entire command is parsed.\n  There is also a ``convert()`` method should it be required.\n\n``AnyTokenString``\n  As ``AnyToken`` but all remaining items on the command line are consumed.\n  There are ``validate()`` and ``convert()`` methods.\n\n``Subtree``\n  Matches an entire command subtree and stores the result against the specified\n  token in the ``fields`` dictionary. The command specification string must\n  be passed to the constructor, and typically classes will override the\n  ``convert()`` method to interpret the command in some way (although this\n  is strictly optional).\n\nThere are also decorators for use with command handlers derived from ``cmd.Cmd``\nwhich allow command strings to be automatically extracted from docstring help\ntext, allowing command parsing and completion to be transparently added to the\ncommand-handling methods of the class.\n\nTo implement the ``cmd.Cmd`` class, various methods of the form ``do_XXX()`` are\nimplemented. To add the ``cmdparser`` integration, these methods must contain a\ndocstring the first line(s) of which form a command specification as outlined\nabove, followed by a blank line and then any descriptive text for the operation\nof the command. The prototype is also altered, taking three arguments - the\nusual ``self`` argument, a list of parsed command line items and a\n``fields`` dictionary as demonstrated in the example immediately above.\n\nOnce the methods have been suitably modified, the ``CmdMethodDecorator``\ndecorator should be applied to each of them, and the ``CmdClassDecorator``\ndecorator should be applied to the class definition as a whole:\n\n.. code-block:: python\n\n    from cmdparser import cmdparser\n\n    @cmdparser.CmdClassDecorator()\n    class CommandHandler(cmd.Cmd):\n\n        @cmdparser.CmdMethodDecorator():\n        def do_command(self, args, fields):\n            \"\"\"command ( add | delete ) <name>\n\n            This is an example command to demonstrate use of the cmd\n            decorators.\n            \"\"\"\n\n            # Method body goes here - it will only be called if a command\n            # parses successfully according to the specification above.\n\nNote that due to the design of the ``cmd.Cmd`` class, the first token in the\nspecification must be the same as the method name after the ``do_`` prefix. An\nexception will be raised if this is not the case.\n\nThe method decorator adds some wrapper code which parses the entered command\naccording to the specification, and displays an error message if parsing fails.\nShould parsing succeed, the implementation method itself is called with the\nparsed arguments and fields passed as from the ``check_match()`` method of the\nparse tree. Note that when using these decorators, the ``cmd.Cmd`` class\ninstance is passed as the ``context`` parameter to many of the token methods,\nwhich can be useful for recovering dynamic state.\n\nThe class decorator then adds tab-completion methods for every decorated\ncommand method, so applications need not concern themselves with this at all.\n\nIt is not necessary to decorate every command method - for very simple commands\nwhich take no arguments it may be simpler to leave them bare. In this case, of\ncourse, the method prototype must match what is expected by ``cmd.Cmd``\n(i.e. a single ``string`` parameter beyond the ``self`` parameter). However,\nif any method is decorated then the class decorator is required to add the\ncompletion methods.\n\nFinally, note that as a convenience the docstring help for commands has the\nleading whitespace of the second line stripped from all lines (on the\nassumption that the first line immediately follows a triple quote and hence has\nno indentation). Lines are also wrapped to 80 columns in the help text.\n\n\ndatetimeparse Overview\n======================\n\nBuilding on the parse trees within the ``cmdparser`` module, this module adds\nspecific token types to parse human-readable specifications of date and time.\nIt allows both absolute and relative dates to be specified, and these are\nconverted to datetime and other instances as appropriate.\n\nSome examples of the type of specifications supported:\n\n* ``2:35pm on Wednesday last week``\n* ``3 days, 2 hours and 5 minutes ago``\n* ``3rd March 2012``\n\nThe following classes are currently defined:\n\n``DateSubtree``\n  Parses a calendar date, including literal dates (``2012-06-15``), descriptive\n  versions (``15th June 2012``), days of the week relative to the current day\n  (``Thursday last week``) as well as ``yesterday``, ``today`` and\n  ``tomorrow``. The returned value is a ``datetime.date`` instance.\n\n``TimeSubtree``\n  Parses a time of day in 12 or 24 hour format. The returned value is as\n  returned by ``time.localtime()``.\n\n``RelativeTimeSubtree``\n  Parses phrases which indicate a time offset from the present time, such as\n  ``3 days and 2 hours ago``. The returned value is an instance of\n  ``cmdparser.DateDelta``, which is a wrapper class containing a\n  ``datetime.timedelta`` and an additional offset in calendar months. It has\n  sufficient methods defined to allow it to be added or subtracted from\n  a ``datetime.datetime`` in the same way as ``datetime.timedelta``.\n\n``DateTimeSubtree``\n  Parses specifications of a date and time, accepting either a combination of\n  ``DateSubtree`` and ``TimeSubtree`` phrases, or a ``RelativeTimeSubtree``\n  phrase; in the latter case the time is taken as relative to the current\n  time. The returned value is a ``datetime.datetime`` instance.\n\n``PastCalendarPeriodSubtree``\n  Parses specifications of calendar periods in the past. Examples of the\n  phrases this will accept include ``last week``, ``3 months ago``,\n  ``week containing 24th March 2012`` and ``between 2012-02-03 and today``.\n  The returned value is a 2-tuple of ``datetime.date`` instances representing\n  the range of dates specified, where the first date is inclusive and the\n  second exclusive.\n\nSee the docstrings of the classes for more details and the ``spec`` class\nattribute for the complete specification of phrases that each class accepts.\n\n\nFeedback\n========\n\nIf you have any questions, problems or requests, please get in touch with me\nat andy@andy-pearce.com. If you want to submit a bug, please do so via\n`GitHub's issue tracker`_ for the TTrack application, with which ``cmdparser``\nshares a repository.\n\nIf you want to make changes, the source code is available at GitHub_ - feel\nfree to send me pull requests if you make an improvement you feel others would\nfind useful.\n\n.. _GitHub: https://github.com/Cartroo/ttrack\n.. _`GitHub's issue tracker`: https://github.com/Cartroo/ttrack/issues", "description_content_type": null, "docs_url": "https://pythonhosted.org/cmdparser/", "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://cartroo.github.com/ttrack/cmdparser.html", "keywords": null, "license": "LICENSE.txt", "maintainer": null, "maintainer_email": null, "name": "cmdparser", "package_url": "https://pypi.org/project/cmdparser/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/cmdparser/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://cartroo.github.com/ttrack/cmdparser.html"}, "release_url": "https://pypi.org/project/cmdparser/1.0.1/", "requires_dist": null, "requires_python": null, "summary": "Command parsing extensions to the cmd module.", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"overview\">\n<h2>Overview</h2>\n<p>The <tt>cmdparser</tt> package contains two modules which are useful for writing\ntext command parsers, particularly using the builtin Python <tt>cmd</tt> module.</p>\n<p>The package consists of two modules:</p>\n<ul>\n<li><tt>cmdparser.cmdparser</tt></li>\n<li><tt>cmdparser.datetimeparse</tt></li>\n</ul>\n<p>These two modules are discussed below briefly. For more information see the\ndocstrings of the two modules, and also the <tt>ttrack</tt> command-line application\n(from which these libraries originated) makes a good example of their use.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>Install the <tt>cmdparser</tt> package from PyPI. For example, to install using\n<tt>pip</tt>:</p>\n<pre>pip install cmdparser\n</pre>\n</div>\n<div id=\"id1\">\n<span id=\"cmdparser-overview\"></span><h2>cmdparser Overview</h2>\n<p>This module allows the creation of parse trees from textual command\nspecifications of the following form:</p>\n<pre>ham ( eggs | chips [spam] | beans [spam [...]] )\n</pre>\n<p>These parse trees can then be used to check for matches against particular\ncommand strings, and also allow valid completions of partial command strings to\nbe listed. To build a parse tree and use it in a few examples, see the\nfollowing example code:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cmdparser</span> <span class=\"kn\">import</span> <span class=\"n\">cmdparser</span>\n\n<span class=\"n\">parse_tree</span> <span class=\"o\">=</span> <span class=\"n\">cmdparser</span><span class=\"o\">.</span><span class=\"n\">parse_spec</span><span class=\"p\">(</span><span class=\"s2\">\"one (two|three) &lt;four&gt; [five]\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Returns None to indicate successful parse</span>\n<span class=\"n\">parse_tree</span><span class=\"o\">.</span><span class=\"n\">check_match</span><span class=\"p\">((</span><span class=\"s2\">\"one\"</span><span class=\"p\">,</span> <span class=\"s2\">\"two\"</span><span class=\"p\">,</span> <span class=\"s2\">\"anything\"</span><span class=\"p\">))</span>\n<span class=\"c1\"># Returns an appropriate parsing error message</span>\n<span class=\"n\">parse_tree</span><span class=\"o\">.</span><span class=\"n\">check_match</span><span class=\"p\">((</span><span class=\"s2\">\"one\"</span><span class=\"p\">,</span> <span class=\"s2\">\"three\"</span><span class=\"p\">,</span> <span class=\"s2\">\"anything\"</span><span class=\"p\">,</span> <span class=\"s2\">\"six\"</span><span class=\"p\">))</span>\n<span class=\"c1\"># Returns the list [\"two\", \"three\"]</span>\n<span class=\"n\">parse_tree</span><span class=\"o\">.</span><span class=\"n\">get_completions</span><span class=\"p\">((</span><span class=\"s2\">\"one\"</span><span class=\"p\">,))</span>\n</pre>\n<p>As well as dealing with fixed token strings, dynamic tokens can also be set up\nwhere the list of strings accepted can change over time, or where arbitrary\nstrings or lists of strings can be accepted. See the module\u2019s docstrings for\nspecifics of the classes available, but as an example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cmdparser</span> <span class=\"kn\">import</span> <span class=\"n\">cmdparser</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ColourToken</span><span class=\"p\">(</span><span class=\"n\">cmdparser</span><span class=\"o\">.</span><span class=\"n\">Token</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get_values</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">context</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Static list here, but could easily be dynamic</span>\n        <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"s2\">\"red\"</span><span class=\"p\">,</span> <span class=\"s2\">\"orange\"</span><span class=\"p\">,</span> <span class=\"s2\">\"yellow\"</span><span class=\"p\">,</span> <span class=\"s2\">\"green\"</span><span class=\"p\">,</span> <span class=\"s2\">\"blue\"</span><span class=\"p\">,</span> <span class=\"s2\">\"purple\"</span><span class=\"p\">]</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">my_ident_factory</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">token</span> <span class=\"o\">==</span> <span class=\"s2\">\"number\"</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">cmdparser</span><span class=\"o\">.</span><span class=\"n\">IntegerToken</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">)</span>\n    <span class=\"k\">elif</span> <span class=\"n\">token</span> <span class=\"o\">==</span> <span class=\"s2\">\"colour\"</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">ColourToken</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"kc\">None</span>\n\n<span class=\"n\">parse_tree</span> <span class=\"o\">=</span> <span class=\"n\">cmdparser</span><span class=\"o\">.</span><span class=\"n\">parse_tree</span><span class=\"p\">(</span><span class=\"s2\">\"take &lt;number&gt; &lt;colour&gt; balls\"</span><span class=\"p\">,</span>\n                                  <span class=\"n\">ident_factory</span><span class=\"o\">=</span><span class=\"n\">my_ident_factory</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Returns None to indicate successful parse, and the \"cmd_fields\" dict will</span>\n<span class=\"c1\"># be initialised as:</span>\n<span class=\"c1\"># { \"take\": [\"take\"], \"&lt;number&gt;\": [\"23\"],</span>\n<span class=\"c1\">#   \"&lt;colour&gt;\": [\"blue\"], \"balls\": [\"balls\"] }</span>\n<span class=\"n\">cmd_fields</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n<span class=\"n\">parse_tree</span><span class=\"o\">.</span><span class=\"n\">check_match</span><span class=\"p\">((</span><span class=\"s2\">\"take\"</span><span class=\"p\">,</span> <span class=\"s2\">\"23\"</span><span class=\"p\">,</span> <span class=\"s2\">\"blue\"</span><span class=\"p\">,</span> <span class=\"s2\">\"balls\"</span><span class=\"p\">),</span> <span class=\"n\">fields</span><span class=\"o\">=</span><span class=\"n\">cmd_fields</span><span class=\"p\">)</span>\n<span class=\"c1\"># Returns an appropriate parsing error message</span>\n<span class=\"n\">parse_tree</span><span class=\"o\">.</span><span class=\"n\">check_match</span><span class=\"p\">((</span><span class=\"s2\">\"take\"</span><span class=\"p\">,</span> <span class=\"s2\">\"all\"</span><span class=\"p\">,</span> <span class=\"s2\">\"red\"</span><span class=\"p\">,</span> <span class=\"s2\">\"balls\"</span><span class=\"p\">))</span>\n<span class=\"c1\"># Returns the list [\"red\", \"orange\", \"yellow\", ..., \"purple\"]</span>\n<span class=\"n\">parse_tree</span><span class=\"o\">.</span><span class=\"n\">get_completions</span><span class=\"p\">((</span><span class=\"s2\">\"take\"</span><span class=\"p\">,</span> <span class=\"s2\">\"5\"</span><span class=\"p\">))</span>\n</pre>\n<p>There are four classes which are suitable base classes for user-derived\ntokens:</p>\n<dl>\n<dt><tt>Token</tt></dt>\n<dd>This is useful for cases where one of a set of fixed values is suitable,\nwhere the list may be fixed or dynamic. The <tt>get_values()</tt> method should be\noverridden to return a list of valid tokens as strings. Optionally, there is\nalso a <tt>convert()</tt> method which can be used to convert</dd>\n<dt><tt>AnyToken</tt></dt>\n<dd>Similar to <tt>Token</tt>, but any string is to be expected. Validation can be\nperformed via the <tt>validate()</tt> method, but that doesn\u2019t allow\ntab-completion as it\u2019s only called once the entire command is parsed.\nThere is also a <tt>convert()</tt> method should it be required.</dd>\n<dt><tt>AnyTokenString</tt></dt>\n<dd>As <tt>AnyToken</tt> but all remaining items on the command line are consumed.\nThere are <tt>validate()</tt> and <tt>convert()</tt> methods.</dd>\n<dt><tt>Subtree</tt></dt>\n<dd>Matches an entire command subtree and stores the result against the specified\ntoken in the <tt>fields</tt> dictionary. The command specification string must\nbe passed to the constructor, and typically classes will override the\n<tt>convert()</tt> method to interpret the command in some way (although this\nis strictly optional).</dd>\n</dl>\n<p>There are also decorators for use with command handlers derived from <tt>cmd.Cmd</tt>\nwhich allow command strings to be automatically extracted from docstring help\ntext, allowing command parsing and completion to be transparently added to the\ncommand-handling methods of the class.</p>\n<p>To implement the <tt>cmd.Cmd</tt> class, various methods of the form <tt>do_XXX()</tt> are\nimplemented. To add the <tt>cmdparser</tt> integration, these methods must contain a\ndocstring the first line(s) of which form a command specification as outlined\nabove, followed by a blank line and then any descriptive text for the operation\nof the command. The prototype is also altered, taking three arguments - the\nusual <tt>self</tt> argument, a list of parsed command line items and a\n<tt>fields</tt> dictionary as demonstrated in the example immediately above.</p>\n<p>Once the methods have been suitably modified, the <tt>CmdMethodDecorator</tt>\ndecorator should be applied to each of them, and the <tt>CmdClassDecorator</tt>\ndecorator should be applied to the class definition as a whole:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">cmdparser</span> <span class=\"kn\">import</span> <span class=\"n\">cmdparser</span>\n\n<span class=\"nd\">@cmdparser</span><span class=\"o\">.</span><span class=\"n\">CmdClassDecorator</span><span class=\"p\">()</span>\n<span class=\"k\">class</span> <span class=\"nc\">CommandHandler</span><span class=\"p\">(</span><span class=\"n\">cmd</span><span class=\"o\">.</span><span class=\"n\">Cmd</span><span class=\"p\">):</span>\n\n    <span class=\"nd\">@cmdparser</span><span class=\"o\">.</span><span class=\"n\">CmdMethodDecorator</span><span class=\"p\">():</span>\n    <span class=\"k\">def</span> <span class=\"nf\">do_command</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"n\">fields</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"command ( add | delete ) &lt;name&gt;\n\n        This is an example command to demonstrate use of the cmd\n        decorators.\n        \"\"\"</span>\n\n        <span class=\"c1\"># Method body goes here - it will only be called if a command</span>\n        <span class=\"c1\"># parses successfully according to the specification above.</span>\n</pre>\n<p>Note that due to the design of the <tt>cmd.Cmd</tt> class, the first token in the\nspecification must be the same as the method name after the <tt>do_</tt> prefix. An\nexception will be raised if this is not the case.</p>\n<p>The method decorator adds some wrapper code which parses the entered command\naccording to the specification, and displays an error message if parsing fails.\nShould parsing succeed, the implementation method itself is called with the\nparsed arguments and fields passed as from the <tt>check_match()</tt> method of the\nparse tree. Note that when using these decorators, the <tt>cmd.Cmd</tt> class\ninstance is passed as the <tt>context</tt> parameter to many of the token methods,\nwhich can be useful for recovering dynamic state.</p>\n<p>The class decorator then adds tab-completion methods for every decorated\ncommand method, so applications need not concern themselves with this at all.</p>\n<p>It is not necessary to decorate every command method - for very simple commands\nwhich take no arguments it may be simpler to leave them bare. In this case, of\ncourse, the method prototype must match what is expected by <tt>cmd.Cmd</tt>\n(i.e. a single <tt>string</tt> parameter beyond the <tt>self</tt> parameter). However,\nif any method is decorated then the class decorator is required to add the\ncompletion methods.</p>\n<p>Finally, note that as a convenience the docstring help for commands has the\nleading whitespace of the second line stripped from all lines (on the\nassumption that the first line immediately follows a triple quote and hence has\nno indentation). Lines are also wrapped to 80 columns in the help text.</p>\n</div>\n<div id=\"datetimeparse-overview\">\n<h2>datetimeparse Overview</h2>\n<p>Building on the parse trees within the <tt>cmdparser</tt> module, this module adds\nspecific token types to parse human-readable specifications of date and time.\nIt allows both absolute and relative dates to be specified, and these are\nconverted to datetime and other instances as appropriate.</p>\n<p>Some examples of the type of specifications supported:</p>\n<ul>\n<li><tt>2:35pm on Wednesday last week</tt></li>\n<li><tt>3 days, 2 hours and 5 minutes ago</tt></li>\n<li><tt>3rd March 2012</tt></li>\n</ul>\n<p>The following classes are currently defined:</p>\n<dl>\n<dt><tt>DateSubtree</tt></dt>\n<dd>Parses a calendar date, including literal dates (<tt><span class=\"pre\">2012-06-15</span></tt>), descriptive\nversions (<tt>15th June 2012</tt>), days of the week relative to the current day\n(<tt>Thursday last week</tt>) as well as <tt>yesterday</tt>, <tt>today</tt> and\n<tt>tomorrow</tt>. The returned value is a <tt>datetime.date</tt> instance.</dd>\n<dt><tt>TimeSubtree</tt></dt>\n<dd>Parses a time of day in 12 or 24 hour format. The returned value is as\nreturned by <tt>time.localtime()</tt>.</dd>\n<dt><tt>RelativeTimeSubtree</tt></dt>\n<dd>Parses phrases which indicate a time offset from the present time, such as\n<tt>3 days and 2 hours ago</tt>. The returned value is an instance of\n<tt>cmdparser.DateDelta</tt>, which is a wrapper class containing a\n<tt>datetime.timedelta</tt> and an additional offset in calendar months. It has\nsufficient methods defined to allow it to be added or subtracted from\na <tt>datetime.datetime</tt> in the same way as <tt>datetime.timedelta</tt>.</dd>\n<dt><tt>DateTimeSubtree</tt></dt>\n<dd>Parses specifications of a date and time, accepting either a combination of\n<tt>DateSubtree</tt> and <tt>TimeSubtree</tt> phrases, or a <tt>RelativeTimeSubtree</tt>\nphrase; in the latter case the time is taken as relative to the current\ntime. The returned value is a <tt>datetime.datetime</tt> instance.</dd>\n<dt><tt>PastCalendarPeriodSubtree</tt></dt>\n<dd>Parses specifications of calendar periods in the past. Examples of the\nphrases this will accept include <tt>last week</tt>, <tt>3 months ago</tt>,\n<tt>week containing 24th March 2012</tt> and <tt>between <span class=\"pre\">2012-02-03</span> and today</tt>.\nThe returned value is a 2-tuple of <tt>datetime.date</tt> instances representing\nthe range of dates specified, where the first date is inclusive and the\nsecond exclusive.</dd>\n</dl>\n<p>See the docstrings of the classes for more details and the <tt>spec</tt> class\nattribute for the complete specification of phrases that each class accepts.</p>\n</div>\n<div id=\"feedback\">\n<h2>Feedback</h2>\n<p>If you have any questions, problems or requests, please get in touch with me\nat <a href=\"mailto:andy%40andy-pearce.com\">andy<span>@</span>andy-pearce<span>.</span>com</a>. If you want to submit a bug, please do so via\n<a href=\"https://github.com/Cartroo/ttrack/issues\" rel=\"nofollow\">GitHub\u2019s issue tracker</a> for the TTrack application, with which <tt>cmdparser</tt>\nshares a repository.</p>\n<p>If you want to make changes, the source code is available at <a href=\"https://github.com/Cartroo/ttrack\" rel=\"nofollow\">GitHub</a> - feel\nfree to send me pull requests if you make an improvement you feel others would\nfind useful.</p>\n</div>\n\n          </div>"}, "last_serial": 787531, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "c0dcf404394cfda564f3494def2e9199", "sha256": "5d914823e368ac9c687b7f1d14e1e944c1fa26be1dc9af45066a84d3b4b576f5"}, "downloads": -1, "filename": "cmdparser-1.0.0.tar.gz", "has_sig": false, "md5_digest": "c0dcf404394cfda564f3494def2e9199", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23502, "upload_time": "2012-12-18T13:33:39", "upload_time_iso_8601": "2012-12-18T13:33:39.405350Z", "url": "https://files.pythonhosted.org/packages/c1/c4/86d363335c71a286fa432fdee4910d21b82093a74018c480ad941aec67d6/cmdparser-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "c8c65aec080367a0928cb23cf0d90b43", "sha256": "4d05afda12168c5125b164b3e1fc17b097db70558d5c02c1b32e59329bf7e5ed"}, "downloads": -1, "filename": "cmdparser-1.0.1.tar.gz", "has_sig": false, "md5_digest": "c8c65aec080367a0928cb23cf0d90b43", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28538, "upload_time": "2013-01-14T14:37:35", "upload_time_iso_8601": "2013-01-14T14:37:35.161807Z", "url": "https://files.pythonhosted.org/packages/d8/01/6f68ab7b90ac908e223dcb8ba4015d7836e52a617c4f79114e875d214161/cmdparser-1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c8c65aec080367a0928cb23cf0d90b43", "sha256": "4d05afda12168c5125b164b3e1fc17b097db70558d5c02c1b32e59329bf7e5ed"}, "downloads": -1, "filename": "cmdparser-1.0.1.tar.gz", "has_sig": false, "md5_digest": "c8c65aec080367a0928cb23cf0d90b43", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28538, "upload_time": "2013-01-14T14:37:35", "upload_time_iso_8601": "2013-01-14T14:37:35.161807Z", "url": "https://files.pythonhosted.org/packages/d8/01/6f68ab7b90ac908e223dcb8ba4015d7836e52a617c4f79114e875d214161/cmdparser-1.0.1.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:18:34 2020"}