{"info": {"author": "Michael Wayne Goodman", "author_email": "goodman.m.w@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Console", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Text Processing", "Topic :: Utilities"], "description": "# <img src=\"docs/logo.png\" width=\"60\" alt=\"pe logo\" /> Parsing Expressions\n\n[![PyPI Version](https://img.shields.io/pypi/v/pe)](https://pypi.org/project/pe)\n![Development Status](https://img.shields.io/pypi/status/pe)\n![Python Support](https://img.shields.io/pypi/pyversions/pe)\n[![Python Package](https://github.com/goodmami/pe/workflows/Python%20package/badge.svg)](https://github.com/goodmami/pe/actions?query=workflow%3A%22Python+package%22)\n\n**pe** is a library for parsing expressions, including [parsing\nexpression grammars] (PEGs). It aims to join the expressive power of\nparsing expressions with the familiarity of regular expressions.  For\nexample:\n\n``` python\n>>> import pe\n>>> m = pe.match(r'[\"] (![\"\\\\] . / \"\\\\\" .)* [\"]',\n...              '\"escaped \\\\\"string\\\\\"\" ...')\n>>> m.group()\n'\"escaped \\\\\"string\\\\\"\"'\n\n```\n\n[parsing expression grammars]: https://en.wikipedia.org/wiki/Parsing_expression_grammar\n\n**Quick Links**\n\n* [Guides](docs/guides/README.md)\n* [API Documentation](docs/api/README.md)\n* [Example Parsers](examples/)\n\n\n## Current Status\n\nPlease note that **pe** is very new and is currently *alpha*-level\nsoftware. The API or behavior may change significantly as things are\nfinalized.\n\n\n## Features and Goals\n\n* Grammar notation is backward-compatible with standard PEG with few extensions\n* A [specification](docs/specification.md) describes the semantic\n  effect of parsing (e.g., for mapping expressions to function calls)\n* Parsers are often faster than other parsing libraries, sometimes by\n  a lot; see the [benchmarks]\n* The API is intuitive and familiar; it's modeled on the standard\n  API's [re] module\n* Grammar definitions and parser implementations are separate\n  - Optimizations target the abstract grammar definitions\n  - Multiple parsers are available (currently [packrat](pe/packrat.py)\n    for recursive descent and [machine](pe/machine.py) for an\n    iterative \"parsing machine\" as from [Medeiros and Ierusalimschy,\n    2008] and implemented in [LPeg]).\n\n[benchmarks]: https://github.com/goodmami/python-parsing-benchmarks\n[re]: https://docs.python.org/3/library/re.html\n[Medeiros and Ierusalimschy, 2008]: http://www.inf.puc-rio.br/~roberto/docs/ry08-4.pdf\n\n\n## Syntax Overview\n\n**pe** is backward compatible with standard PEG syntax and it is\nconservative with extensions.\n\n```regex\n# terminals\n.            # any single character\n\"abc\"        # string literal\n'abc'        # string literal\n[abc]        # character class\n\n# repeating expressions\ne            # exactly one\ne?           # zero or one (optional)\ne*           # zero or more\ne+           # one or more\n\n# combining expressions\ne1 e2        # sequence of e1 and e2\ne1 / e2      # ordered choice of e1 and e2\n(e)          # subexpression\n\n# lookahead\n&e           # positive lookahead\n!e           # negative lookahead\n\n# (extension) capture substring\n~e           # result of e is matched substring\n\n# (extension) binding\nname:e       # bind result of e to 'name'\n\n# grammars\nName <- ...  # define a rule named 'Name'\n... <- Name  # refer to rule named 'Name'\n```\n\n## Matching Inputs with Parsing Expressions\n\nWhen a parsing expression matches an input, it returns a `Match`\nobject, which is similar to those of Python's\n[re](https://docs.python.org/3/library/re.html) module for regular\nexpressions. By default, nothing is captured, but the capture operator\n(`~`) emits the substring of the matching expression, similar to\nregular expression's capturing groups:\n\n```python\n>>> e = pe.compile(r'[0-9] [.] [0-9]')\n>>> m = e.match('1.4')\n>>> m.group()\n'1.4'\n>>> m.groups()\n()\n>>> e = pe.compile(r'~([0-9] [.] [0-9])')\n>>> m = e.match('1.4')\n>>> m.group()\n'1.4'\n>>> m.groups()\n('1.4',)\n\n```\n\n### Value Bindings\n\nA value binding extracts the emitted values of a match and associates\nit with a name that is made available in the `Match.groupdict()`\ndictionary. This is similar to named-capture groups in regular\nexpressions, except that it extracts the emitted values and not the\nsubstring of the bound expression.\n\n```python\n>>> e = pe.compile(r'~[0-9] x:(~[.]) ~[0-9]')\n>>> m = e.match('1.4')\n>>> m.groups()\n('1', '4')\n>>> m.groupdict()\n{'x': '.'}\n\n```\n\n### Actions\n\nActions (also called \"semantic actions\") are callables that transform\nparse results. When an arbitrary function is given, it is called as\nfollows:\n\n``` python\nfunc(*match.groups(), **match.groupdict())\n```\n\nThe result of this function call becomes the only emitted value going\nforward, and all bound values are cleared.\n\nFor more control, **pe** provides the [Action] class and a number of\nsubclasses for various use-cases. These actions have access to more\ninformation about a parse result and more control over the\nmatch. For example, the [Pack] class takes a function and calls it\nwith the emitted values packed into a list:\n\n``` python\nfunc(match.groups())\n```\n\nAnd the [Join] class joins all emitted strings with a separator:\n\n``` python\nfunc(sep.join(match.groups()), **match.groupdict())\n```\n\n[Action]: docs/api/pe.actions.md#Action\n[Pack]: docs/api/pe.actions.md#Pack\n[Join]: docs/api/pe.actions.md#Join\n\n\n### Example\n\nHere is one way to parse a list of comma-separated integers:\n\n```python\n>>> from pe.actions import Pack\n>>> p = pe.compile(\n...   r'''\n...     Start  <- \"[\" Values? \"]\"\n...     Values <- Int (\",\" Int)*\n...     Int    <- ~( \"-\"? (\"0\" / [1-9] [0-9]*) )\n...   ''',\n...   actions={'Values': Pack(list), 'Int': int})\n>>> m = p.match('[5,10,-15]')\n>>> m.value()\n[5, 10, -15]\n\n```\n\n## Similar Projects\n\n- [Lark](https://github.com/lark-parser/lark) (Python)\n- [nom](https://github.com/Geal/nom) (Rust)\n- [Parsimonious](https://github.com/erikrose/parsimonious) (Python)\n- [Rosie](https://rosie-lang.org/) (Multiple bindings)\n- [TatSu](https://tatsu.readthedocs.io/en/stable/) (Python)\n- [PEG.js](https://github.com/pegjs/pegjs) (Javascript)\n- [Pegged](https://github.com/PhilippeSigaud/Pegged) (D)\n- [pegen](https://github.com/gvanrossum/pegen) (Python / C)\n- [LPeg] (Lua)\n\n[LPeg]: http://www.inf.puc-rio.br/~roberto/lpeg/\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/goodmami/pe", "keywords": "peg parsing text", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pe", "package_url": "https://pypi.org/project/pe/", "platform": "", "project_url": "https://pypi.org/project/pe/", "project_urls": {"Homepage": "https://github.com/goodmami/pe"}, "release_url": "https://pypi.org/project/pe/0.2.0/", "requires_dist": null, "requires_python": ">=3.6", "summary": "Parsing Expressions", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1><img alt=\"pe logo\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/cbd2c1dff46dc9a0d418cc8410275d7ca6bb53e3/646f63732f6c6f676f2e706e67\" width=\"60\"> Parsing Expressions</h1>\n<p><a href=\"https://pypi.org/project/pe\" rel=\"nofollow\"><img alt=\"PyPI Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4b03eb1450712913f48a53a985481ff42ae23108/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f7065\"></a>\n<img alt=\"Development Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0c5d79d71309bd5f5904d732c7152c57133f78e0/68747470733a2f2f696d672e736869656c64732e696f2f707970692f7374617475732f7065\">\n<img alt=\"Python Support\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b3f592d1b9f9ef7c542d08160367e7ca92b3fc0c/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f7065\">\n<a href=\"https://github.com/goodmami/pe/actions?query=workflow%3A%22Python+package%22\" rel=\"nofollow\"><img alt=\"Python Package\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d9befde677c6d9d69c0f15acc7d9ffcf3d8edade/68747470733a2f2f6769746875622e636f6d2f676f6f646d616d692f70652f776f726b666c6f77732f507974686f6e2532307061636b6167652f62616467652e737667\"></a></p>\n<p><strong>pe</strong> is a library for parsing expressions, including <a href=\"https://en.wikipedia.org/wiki/Parsing_expression_grammar\" rel=\"nofollow\">parsing\nexpression grammars</a> (PEGs). It aims to join the expressive power of\nparsing expressions with the familiarity of regular expressions.  For\nexample:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">pe</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">pe</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[\"] (![\"</span><span class=\"se\">\\\\</span><span class=\"s1\">] . / \"</span><span class=\"se\">\\\\</span><span class=\"s1\">\" .)* [\"]'</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>              <span class=\"s1\">'\"escaped </span><span class=\"se\">\\\\</span><span class=\"s1\">\"string</span><span class=\"se\">\\\\</span><span class=\"s1\">\"\" ...'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span><span class=\"o\">.</span><span class=\"n\">group</span><span class=\"p\">()</span>\n<span class=\"s1\">'\"escaped </span><span class=\"se\">\\\\</span><span class=\"s1\">\"string</span><span class=\"se\">\\\\</span><span class=\"s1\">\"\"'</span>\n</pre>\n<p><strong>Quick Links</strong></p>\n<ul>\n<li><a href=\"docs/guides/README.md\" rel=\"nofollow\">Guides</a></li>\n<li><a href=\"docs/api/README.md\" rel=\"nofollow\">API Documentation</a></li>\n<li><a href=\"examples/\" rel=\"nofollow\">Example Parsers</a></li>\n</ul>\n<h2>Current Status</h2>\n<p>Please note that <strong>pe</strong> is very new and is currently <em>alpha</em>-level\nsoftware. The API or behavior may change significantly as things are\nfinalized.</p>\n<h2>Features and Goals</h2>\n<ul>\n<li>Grammar notation is backward-compatible with standard PEG with few extensions</li>\n<li>A <a href=\"docs/specification.md\" rel=\"nofollow\">specification</a> describes the semantic\neffect of parsing (e.g., for mapping expressions to function calls)</li>\n<li>Parsers are often faster than other parsing libraries, sometimes by\na lot; see the <a href=\"https://github.com/goodmami/python-parsing-benchmarks\" rel=\"nofollow\">benchmarks</a></li>\n<li>The API is intuitive and familiar; it's modeled on the standard\nAPI's <a href=\"https://docs.python.org/3/library/re.html\" rel=\"nofollow\">re</a> module</li>\n<li>Grammar definitions and parser implementations are separate\n<ul>\n<li>Optimizations target the abstract grammar definitions</li>\n<li>Multiple parsers are available (currently <a href=\"pe/packrat.py\" rel=\"nofollow\">packrat</a>\nfor recursive descent and <a href=\"pe/machine.py\" rel=\"nofollow\">machine</a> for an\niterative \"parsing machine\" as from <a href=\"http://www.inf.puc-rio.br/%7Eroberto/docs/ry08-4.pdf\" rel=\"nofollow\">Medeiros and Ierusalimschy,\n2008</a> and implemented in <a href=\"http://www.inf.puc-rio.br/%7Eroberto/lpeg/\" rel=\"nofollow\">LPeg</a>).</li>\n</ul>\n</li>\n</ul>\n<h2>Syntax Overview</h2>\n<p><strong>pe</strong> is backward compatible with standard PEG syntax and it is\nconservative with extensions.</p>\n<pre># terminals\n.            # any single character\n\"abc\"        # string literal\n'abc'        # string literal\n[abc]        # character class\n\n# repeating expressions\ne            # exactly one\ne?           # zero or one (optional)\ne*           # zero or more\ne+           # one or more\n\n# combining expressions\ne1 e2        # sequence of e1 and e2\ne1 / e2      # ordered choice of e1 and e2\n(e)          # subexpression\n\n# lookahead\n&amp;e           # positive lookahead\n!e           # negative lookahead\n\n# (extension) capture substring\n~e           # result of e is matched substring\n\n# (extension) binding\nname:e       # bind result of e to 'name'\n\n# grammars\nName &lt;- ...  # define a rule named 'Name'\n... &lt;- Name  # refer to rule named 'Name'\n</pre>\n<h2>Matching Inputs with Parsing Expressions</h2>\n<p>When a parsing expression matches an input, it returns a <code>Match</code>\nobject, which is similar to those of Python's\n<a href=\"https://docs.python.org/3/library/re.html\" rel=\"nofollow\">re</a> module for regular\nexpressions. By default, nothing is captured, but the capture operator\n(<code>~</code>) emits the substring of the matching expression, similar to\nregular expression's capturing groups:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">pe</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'[0-9] [.] [0-9]'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span><span class=\"s1\">'1.4'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span><span class=\"o\">.</span><span class=\"n\">group</span><span class=\"p\">()</span>\n<span class=\"s1\">'1.4'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span><span class=\"o\">.</span><span class=\"n\">groups</span><span class=\"p\">()</span>\n<span class=\"p\">()</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">pe</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'~([0-9] [.] [0-9])'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span><span class=\"s1\">'1.4'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span><span class=\"o\">.</span><span class=\"n\">group</span><span class=\"p\">()</span>\n<span class=\"s1\">'1.4'</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span><span class=\"o\">.</span><span class=\"n\">groups</span><span class=\"p\">()</span>\n<span class=\"p\">(</span><span class=\"s1\">'1.4'</span><span class=\"p\">,)</span>\n</pre>\n<h3>Value Bindings</h3>\n<p>A value binding extracts the emitted values of a match and associates\nit with a name that is made available in the <code>Match.groupdict()</code>\ndictionary. This is similar to named-capture groups in regular\nexpressions, except that it extracts the emitted values and not the\nsubstring of the bound expression.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">pe</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'~[0-9] x:(~[.]) ~[0-9]'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span><span class=\"s1\">'1.4'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span><span class=\"o\">.</span><span class=\"n\">groups</span><span class=\"p\">()</span>\n<span class=\"p\">(</span><span class=\"s1\">'1'</span><span class=\"p\">,</span> <span class=\"s1\">'4'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span><span class=\"o\">.</span><span class=\"n\">groupdict</span><span class=\"p\">()</span>\n<span class=\"p\">{</span><span class=\"s1\">'x'</span><span class=\"p\">:</span> <span class=\"s1\">'.'</span><span class=\"p\">}</span>\n</pre>\n<h3>Actions</h3>\n<p>Actions (also called \"semantic actions\") are callables that transform\nparse results. When an arbitrary function is given, it is called as\nfollows:</p>\n<pre><span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">match</span><span class=\"o\">.</span><span class=\"n\">groups</span><span class=\"p\">(),</span> <span class=\"o\">**</span><span class=\"n\">match</span><span class=\"o\">.</span><span class=\"n\">groupdict</span><span class=\"p\">())</span>\n</pre>\n<p>The result of this function call becomes the only emitted value going\nforward, and all bound values are cleared.</p>\n<p>For more control, <strong>pe</strong> provides the <a href=\"docs/api/pe.actions.md#Action\" rel=\"nofollow\">Action</a> class and a number of\nsubclasses for various use-cases. These actions have access to more\ninformation about a parse result and more control over the\nmatch. For example, the <a href=\"docs/api/pe.actions.md#Pack\" rel=\"nofollow\">Pack</a> class takes a function and calls it\nwith the emitted values packed into a list:</p>\n<pre><span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">match</span><span class=\"o\">.</span><span class=\"n\">groups</span><span class=\"p\">())</span>\n</pre>\n<p>And the <a href=\"docs/api/pe.actions.md#Join\" rel=\"nofollow\">Join</a> class joins all emitted strings with a separator:</p>\n<pre><span class=\"n\">func</span><span class=\"p\">(</span><span class=\"n\">sep</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">match</span><span class=\"o\">.</span><span class=\"n\">groups</span><span class=\"p\">()),</span> <span class=\"o\">**</span><span class=\"n\">match</span><span class=\"o\">.</span><span class=\"n\">groupdict</span><span class=\"p\">())</span>\n</pre>\n<h3>Example</h3>\n<p>Here is one way to parse a list of comma-separated integers:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pe.actions</span> <span class=\"kn\">import</span> <span class=\"n\">Pack</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">pe</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span>\n<span class=\"o\">...</span>   <span class=\"sa\">r</span><span class=\"s1\">'''</span>\n<span class=\"s1\">...     Start  &lt;- \"[\" Values? \"]\"</span>\n<span class=\"s1\">...     Values &lt;- Int (\",\" Int)*</span>\n<span class=\"s1\">...     Int    &lt;- ~( \"-\"? (\"0\" / [1-9] [0-9]*) )</span>\n<span class=\"s1\">...   '''</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>   <span class=\"n\">actions</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'Values'</span><span class=\"p\">:</span> <span class=\"n\">Pack</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">),</span> <span class=\"s1\">'Int'</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">})</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">match</span><span class=\"p\">(</span><span class=\"s1\">'[5,10,-15]'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">m</span><span class=\"o\">.</span><span class=\"n\">value</span><span class=\"p\">()</span>\n<span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">15</span><span class=\"p\">]</span>\n</pre>\n<h2>Similar Projects</h2>\n<ul>\n<li><a href=\"https://github.com/lark-parser/lark\" rel=\"nofollow\">Lark</a> (Python)</li>\n<li><a href=\"https://github.com/Geal/nom\" rel=\"nofollow\">nom</a> (Rust)</li>\n<li><a href=\"https://github.com/erikrose/parsimonious\" rel=\"nofollow\">Parsimonious</a> (Python)</li>\n<li><a href=\"https://rosie-lang.org/\" rel=\"nofollow\">Rosie</a> (Multiple bindings)</li>\n<li><a href=\"https://tatsu.readthedocs.io/en/stable/\" rel=\"nofollow\">TatSu</a> (Python)</li>\n<li><a href=\"https://github.com/pegjs/pegjs\" rel=\"nofollow\">PEG.js</a> (Javascript)</li>\n<li><a href=\"https://github.com/PhilippeSigaud/Pegged\" rel=\"nofollow\">Pegged</a> (D)</li>\n<li><a href=\"https://github.com/gvanrossum/pegen\" rel=\"nofollow\">pegen</a> (Python / C)</li>\n<li><a href=\"http://www.inf.puc-rio.br/%7Eroberto/lpeg/\" rel=\"nofollow\">LPeg</a> (Lua)</li>\n</ul>\n\n          </div>"}, "last_serial": 7117749, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "f169035d7a877aa86d812fea3cc04ae2", "sha256": "a669870941279e84692e786f2e2689d79e1e178b7a292e01fe4e8ad41033e643"}, "downloads": -1, "filename": "pe-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "f169035d7a877aa86d812fea3cc04ae2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 23728, "upload_time": "2020-04-14T14:43:06", "upload_time_iso_8601": "2020-04-14T14:43:06.371546Z", "url": "https://files.pythonhosted.org/packages/f2/e2/780be06029eb4453efbcef7a558a3e0c6c38c2b02bde50377f54d100982f/pe-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5b3f7de0b0f0441766a556c404fa83ee", "sha256": "52687ea1663ec6d2c32caf96a841f86944feee232437b38969dc60a8a623b60a"}, "downloads": -1, "filename": "pe-0.1.0.tar.gz", "has_sig": false, "md5_digest": "5b3f7de0b0f0441766a556c404fa83ee", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 25382, "upload_time": "2020-04-14T14:43:07", "upload_time_iso_8601": "2020-04-14T14:43:07.161896Z", "url": "https://files.pythonhosted.org/packages/13/9c/6afdfc9f06e1c0bef68b1d34c12cb586fe87a4dbf204e6f1d4c2109987a3/pe-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "c8f45c42d4b77af626eca177f6b74750", "sha256": "f34a1cde8f00b361b1da8817ed34193f07eb7a010931b7db97f0788134a927b3"}, "downloads": -1, "filename": "pe-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "c8f45c42d4b77af626eca177f6b74750", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 25400, "upload_time": "2020-04-28T07:00:38", "upload_time_iso_8601": "2020-04-28T07:00:38.514313Z", "url": "https://files.pythonhosted.org/packages/a2/c6/74b78dd09c161b774ab76c075cd2d767b713d4180163d7215f346ee4c03b/pe-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9731996612a701e471e8a4342b82f741", "sha256": "37f61e604f2e4ab2b33063c38db86b094b17bb6d9869edae4a6c14b4bb532529"}, "downloads": -1, "filename": "pe-0.2.0.tar.gz", "has_sig": false, "md5_digest": "9731996612a701e471e8a4342b82f741", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 27023, "upload_time": "2020-04-28T07:00:39", "upload_time_iso_8601": "2020-04-28T07:00:39.411300Z", "url": "https://files.pythonhosted.org/packages/52/34/5e3350c8af561084c5403fbb57a162f2941e7267349c20714e76b73517c5/pe-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c8f45c42d4b77af626eca177f6b74750", "sha256": "f34a1cde8f00b361b1da8817ed34193f07eb7a010931b7db97f0788134a927b3"}, "downloads": -1, "filename": "pe-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "c8f45c42d4b77af626eca177f6b74750", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 25400, "upload_time": "2020-04-28T07:00:38", "upload_time_iso_8601": "2020-04-28T07:00:38.514313Z", "url": "https://files.pythonhosted.org/packages/a2/c6/74b78dd09c161b774ab76c075cd2d767b713d4180163d7215f346ee4c03b/pe-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9731996612a701e471e8a4342b82f741", "sha256": "37f61e604f2e4ab2b33063c38db86b094b17bb6d9869edae4a6c14b4bb532529"}, "downloads": -1, "filename": "pe-0.2.0.tar.gz", "has_sig": false, "md5_digest": "9731996612a701e471e8a4342b82f741", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 27023, "upload_time": "2020-04-28T07:00:39", "upload_time_iso_8601": "2020-04-28T07:00:39.411300Z", "url": "https://files.pythonhosted.org/packages/52/34/5e3350c8af561084c5403fbb57a162f2941e7267349c20714e76b73517c5/pe-0.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:57:01 2020"}