{"info": {"author": "Biplab Ch Das", "author_email": "biplab12@cse.iitb.ac.in", "bugtrack_url": null, "classifiers": [], "description": "Important\n\t============= \n \n\tpractNLPTools\n\t=============\n\t\n\tPractical Natural Language Processing Tools for Humans.\n\tpractNLPTools is a pythonic library over SENNA and Stanford Dependency Extractor.\n\n\tFunctionality\n\t=============\n\t1. Semantic Role Labeling\n\t2. Syntactic Parsing\n\t3. Part of Speech Tagging (POS Tagging)\n\t4. Named Entity Recognisation (NER)\n\t5. Dependency Parsing\n\t6. Shallow Chunking\n\n\tFeatures\n\t=============\n\t1. Fast: SENNA is written is C. So it is Fast.\n\t2. We use only dependency Extractor Component of Stanford Parser, which takes in Syntactic Parse from SENNA and applies dependency Extraction. So there is no need to load parsing models for Stanford Parser, which takes time.\n\t3. Easy to use.\n\n\tInstallation\n\t=============\n\n\tRequires:\n\tA computer with 500mb memory, Java Runtime Environment (1.7 preferably, works with 1.6 too, but didnt test.) installed and python.\n\n\tIf you are in linux:\n\trun:\n\n\t    sudo python setup.py install \n\n\tIf you are in windows:\n\trun this commands as administrator:\n\n\t    sudo python setup.py install\n\t  \n\n\tExamples\n\t=============\n\n\tChunk and NER use BIOS Tagging Scheme. Which expands to:\n\n\t1. S = Tag covers Single Word.\n\t2. B = Tag Begins with the Word.\n\t3. I = Word is internal to tag which has begun.\n\t4. E = Tag Ends with the Word.\n\t5. 0 = Other tags.\n\n\tExample:\n\t  ('Biplab', 'S-NP'), ('is', 'S-VP'), ('a', 'B-NP'), ('good', 'I-NP'), ('boy', 'E-NP'), ('.', 'O')\n\t  \n\t  means:\n\t  \n\t  [Biplab]NP [is]VP [a good boy]NP [.]O\n\t  \n\n\tAnnotator is the only class you need. Create an annotator object.\n\n\t    >>>from practnlptools.tools import Annotator\n\t    >>>annotator=Annotator()\n\n\n\tUsing Function getAnnoations(sentence) returns a dictionary of annotations.\n\n\t    >>>annotator.getAnnotations(\"There are people dying make this world a better place for you and for me.\")\n\t    {'dep_parse': '', 'chunk': [('There', 'S-NP'), ('are', 'S-VP'), ('people', 'S-NP'), ('dying', 'B-VP'), ('make', 'E-VP'), ('this', 'B-NP'), ('world', 'E-NP'), ('a', 'B-NP'), ('better', 'I-NP'), ('place', 'E-NP'), ('for', 'S-PP'), ('you', 'S-NP'), ('and', 'O'), ('for', 'S-PP'), ('me.', 'S-NP')], 'pos': [('There', 'EX'), ('are', 'VBP'), ('people', 'NNS'), ('dying', 'VBG'), ('make', 'VB'), ('this', 'DT'), ('world', 'NN'), ('a', 'DT'), ('better', 'JJR'), ('place', 'NN'), ('for', 'IN'), ('you', 'PRP'), ('and', 'CC'), ('for', 'IN'), ('me.', '.')], 'srl': [{'A1': 'people', 'V': 'dying'}, {'A1': 'people  this world', 'A2': 'a better place for you and for me.', 'V': 'make'}], 'syntax_tree': '(S1(S(NP(EX There))(VP(VBP are)(NP(NP(NNS people))(SBAR(S(VBG dying)(VP(VB make)(S(NP(DT this)(NN world))(NP(DT a)(JJR better)(NN place)))(PP(PP(IN for)(NP(PRP you)))(CC and)(PP(IN for)(NP(. me.)))))))))))', 'verbs': ['dying', 'make'], 'words': ['There', 'are', 'people', 'dying', 'make', 'this', 'world', 'a', 'better', 'place', 'for', 'you', 'and', 'for', 'me.'], 'ner': [('There', 'O'), ('are', 'O'), ('people', 'O'), ('dying', 'O'), ('make', 'O'), ('this', 'O'), ('world', 'O'), ('a', 'O'), ('better', 'O'), ('place', 'O'), ('for', 'O'), ('you', 'O'), ('and', 'O'), ('for', 'O'), ('me.', 'O')]}\n\n\n\tUsing Function getAnnoations(sentence,dep_parse=True) returns a dictionary of annotations with dependency parse, by default it is switched off.\n\n\t    >>>annotator.getAnnotations(\"There are people dying make this world a better place for you and for me.\",dep_parse=True)\n\t    {'dep_parse': 'expl(are-2, There-1)\nroot(ROOT-0, are-2)\nnsubj(are-2, people-3)\ndep(make-5, dying-4)\nrcmod(people-3, make-5)\ndet(world-7, this-6)\nnsubj(place-10, world-7)\ndet(place-10, a-8)\namod(place-10, better-9)\nxcomp(make-5, place-10)\nprep_for(make-5, you-12)\nconj_and(you-12, me.-15)', 'chunk': [('There', 'S-NP'), ('are', 'S-VP'), ('people', 'S-NP'), ('dying', 'B-VP'), ('make', 'E-VP'), ('this', 'B-NP'), ('world', 'E-NP'), ('a', 'B-NP'), ('better', 'I-NP'), ('place', 'E-NP'), ('for', 'S-PP'), ('you', 'S-NP'), ('and', 'O'), ('for', 'S-PP'), ('me.', 'S-NP')], 'pos': [('There', 'EX'), ('are', 'VBP'), ('people', 'NNS'), ('dying', 'VBG'), ('make', 'VB'), ('this', 'DT'), ('world', 'NN'), ('a', 'DT'), ('better', 'JJR'), ('place', 'NN'), ('for', 'IN'), ('you', 'PRP'), ('and', 'CC'), ('for', 'IN'), ('me.', '.')], 'srl': [{'A1': 'people', 'V': 'dying'}, {'A1': 'people  this world', 'A2': 'a better place for you and for me.', 'V': 'make'}], 'syntax_tree': '(S1(S(NP(EX There))(VP(VBP are)(NP(NP(NNS people))(SBAR(S(VBG dying)(VP(VB make)(S(NP(DT this)(NN world))(NP(DT a)(JJR better)(NN place)))(PP(PP(IN for)(NP(PRP you)))(CC and)(PP(IN for)(NP(. me.)))))))))))', 'verbs': ['dying', 'make'], 'words': ['There', 'are', 'people', 'dying', 'make', 'this', 'world', 'a', 'better', 'place', 'for', 'you', 'and', 'for', 'me.'], 'ner': [('There', 'O'), ('are', 'O'), ('people', 'O'), ('dying', 'O'), ('make', 'O'), ('this', 'O'), ('world', 'O'), ('a', 'O'), ('better', 'O'), ('place', 'O'), ('for', 'O'), ('you', 'O'), ('and', 'O'), ('for', 'O'), ('me.', 'O')]}\n\n\tYou can access individual componets as:\n\n\t    >>>annotator.getAnnotations(\"Biplab is a good boy.\")['pos']\n\t    [('Biplab', 'NNP'), ('is', 'VBZ'), ('a', 'DT'), ('good', 'JJ'), ('boy', 'NN'), ('.', '.')]\n\t    >>>annotator.getAnnotations(\"Biplab is a good boy.\")['ner']\n\t    [('Biplab', 'S-PER'), ('is', 'O'), ('a', 'O'), ('good', 'O'), ('boy', 'O'), ('.', 'O')]\n\t    >>>annotator.getAnnotations(\"Biplab is a good boy.\")['chunk']\n\t    [('Biplab', 'S-NP'), ('is', 'S-VP'), ('a', 'B-NP'), ('good', 'I-NP'), ('boy', 'E-NP'), ('.', 'O')]\n\n\n\tTo list the verbs for which semantic roles are found.\n\n\t    >>>annotator.getAnnotations(\"He created the robot and broke it after making it.\")['verbs']\n\t    ['created', 'broke', 'making']\n\n\t'srl' Returns a list of dictionaries, identifyinging sematic roles for various verbs in sentence.\n\n\t    >>>annotator.getAnnotations(\"He created the robot and broke it after making it.\")['srl']\n\t    [{'A1': 'the robot', 'A0': 'He', 'V': 'created'}, {'A1': 'it', 'A0': 'He', 'AM-TMP': 'after making it.', 'V': 'broke'}, {'A1': 'it.', 'A0': 'He', 'V': 'making'}]\n\n\t'syntax_tree' Returns syntax tree in penn Tree Bank Format.\n\n\t    >>>annotator.getAnnotations(\"He created the robot and broke it after making it.\")['syntax_tree']\n\t    '(S1(S(NP(PRP He))(VP(VP(VBD created)(NP(DT the)(NN robot)))(CC and)(VP(VBD broke)(NP(PRP it))(PP(IN after)(S(VP(VBG making)(NP(PRP it.)))))))))'\n\n\t'dep_parse' Returns dependency Relations as a string. Each relation is in new line. You may require some post processing on this.\n\n\t    >>>print annotator.getAnnotations(\"He created the robot and broke it after making it.\",dep_parse=True)['dep_parse']\n\t    nsubj(created-2, He-1)\n\t    root(ROOT-0, created-2)\n\t    det(robot-4, the-3)\n\t    dobj(created-2, robot-4)\n\t    conj_and(created-2, broke-6)\n\t    dobj(broke-6, it-7)\n\t    prepc_after(broke-6, making-9)\n\t    dobj(making-9, it.-10)\n\n\n\tIf there are many sentences to annotate, Use batch Mode, annotator.getBatchAnnotations(sentences,dep_parse=True/False). Returns a list of annotation dictionaries.\n\n\t    >>>annotator.getBatchAnnotations([\"He created the robot and broke it after making it.\",\"Biplab is a good boy.\"],dep_parse=True)\n\t    [{'dep_parse': 'nsubj(created-2, He-1)\nroot(ROOT-0, created-2)\ndet(robot-4, the-3)\ndobj(created-2, robot-4)\nconj_and(created-2, broke-6)\ndobj(broke-6, it-7)\nprepc_after(broke-6, making-9)\ndobj(making-9, it.-10)', 'chunk': [('He', 'S-NP'), ('created', 'S-VP'), ('the', 'B-NP'), ('robot', 'E-NP'), ('and', 'O'), ('broke', 'S-VP'), ('it', 'S-NP'), ('after', 'S-PP'), ('making', 'S-VP'), ('it.', 'S-NP')], 'pos': [('He', 'PRP'), ('created', 'VBD'), ('the', 'DT'), ('robot', 'NN'), ('and', 'CC'), ('broke', 'VBD'), ('it', 'PRP'), ('after', 'IN'), ('making', 'VBG'), ('it.', 'PRP')], 'srl': [{'A1': 'the robot', 'A0': 'He', 'V': 'created'}, {'A1': 'it', 'A0': 'He', 'AM-TMP': 'after making it.', 'V': 'broke'}, {'A1': 'it.', 'A0': 'He', 'V': 'making'}], 'syntax_tree': '(S1(S(NP(PRP He))(VP(VP(VBD created)(NP(DT the)(NN robot)))(CC and)(VP(VBD broke)(NP(PRP it))(PP(IN after)(S(VP(VBG making)(NP(PRP it.)))))))))', 'verbs': ['created', 'broke', 'making'], 'words': ['He', 'created', 'the', 'robot', 'and', 'broke', 'it', 'after', 'making', 'it.'], 'ner': [('He', 'O'), ('created', 'O'), ('the', 'O'), ('robot', 'O'), ('and', 'O'), ('broke', 'O'), ('it', 'O'), ('after', 'O'), ('making', 'O'), ('it.', 'O')]}, {'dep_parse': 'nsubj(boy-5, Biplab-1)\ncop(boy-5, is-2)\ndet(boy-5, a-3)\namod(boy-5, good-4)\nroot(ROOT-0, boy-5)', 'chunk': [('Biplab', 'S-NP'), ('is', 'S-VP'), ('a', 'B-NP'), ('good', 'I-NP'), ('boy', 'E-NP'), ('.', 'O')], 'pos': [('Biplab', 'NNP'), ('is', 'VBZ'), ('a', 'DT'), ('good', 'JJ'), ('boy', 'NN'), ('.', '.')], 'srl': [], 'syntax_tree': '(S1(S(NP(NNP Biplab))(VP(VBZ is)(NP(DT a)(JJ good)(NN boy)))(. .)))', 'verbs': [], 'words': ['Biplab', 'is', 'a', 'good', 'boy', '.'], 'ner': [('Biplab', 'S-PER'), ('is', 'O'), ('a', 'O'), ('good', 'O'), ('boy', 'O'), ('.', 'O')]}]\n\n\n\tNote: For illustration purposes we have used:\n\n\t    >>>annotator.getAnnotations(\"He created the robot and broke it after making it.\",dep_parse=True)['dep_parse']\n\n\tBetter method is:\n\n\t    >>>annotation=annotator.getAnnotations(\"He created the robot and broke it after making it.\",dep_parse=True)\n\t    >>>ner=annotation['ner']\n\t    >>>srl=annotation['srl']\n\n\tIssues\n\t=============\n\n\t1. You cannot give sentence with (  or ), that is left bracket aor right bracket. It will end up in returning no result. So please clean Sentences before sending to annotator.\n\t2. Other issue might be senna executable built for various platforms. I have not experienced it, but its highly probable. If you get this issuse:\n\n\tGo to folder practnlptools\n\n\t    cd practnlptools\n\t    gcc -O3 -o senna-linux64 *.c  (For linux 64 bit)\n\t    gcc -O3 -o senna-linux32 *.c  (For linux 32 bit)\n\t    gcc -O3 -o senna-senna-osx *.c (For Mac)\n\t    *windows: I never compiled C files in Windows.*\n\t    python setup.py install\n\n\t3. Any other, you can la la laa la laaaa to  biplab12  (A T) cse d0t iitb d0t ac d0t in \n\n\tTO DO\n\t=============\n\t1. Make Dependency Parse more Accessible.\n\t2. Include instruction to build senna for windows", "description_content_type": null, "docs_url": null, "download_url": "http://www.cfilt.iitb.ac.in/biplab/practNLPTools-1.0.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/biplab-iitb/practNLPTools", "keywords": "Dependency Parsing,Syntactic Constituent Parsing,Semantic Role Labeling,Named Entity Recognisation,Shallow chunking,Part of Speech Tagging,Python Interface,Stanford Parser,SENNA Machine Learning,SENNA.", "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "practnlptools", "package_url": "https://pypi.org/project/practnlptools/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/practnlptools/", "project_urls": {"Download": "http://www.cfilt.iitb.ac.in/biplab/practNLPTools-1.0.tar.gz", "Homepage": "https://github.com/biplab-iitb/practNLPTools"}, "release_url": "https://pypi.org/project/practnlptools/1.0/", "requires_dist": null, "requires_python": null, "summary": "Practical Natural Language Processing Tools for Humans. Dependency Parsing, Syntactic Constituent Parsing, Semantic Role Labeling, Named Entity Recognisation, Shallow chunking, Part of Speech Tagging, all in Python.", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            Important<br>\t============= <br> <br>\tpractNLPTools<br>\t=============<br>\t<br>\tPractical Natural Language Processing Tools for Humans.<br>\tpractNLPTools is a pythonic library over SENNA and Stanford Dependency Extractor.<br><br>\tFunctionality<br>\t=============<br>\t1. Semantic Role Labeling<br>\t2. Syntactic Parsing<br>\t3. Part of Speech Tagging (POS Tagging)<br>\t4. Named Entity Recognisation (NER)<br>\t5. Dependency Parsing<br>\t6. Shallow Chunking<br><br>\tFeatures<br>\t=============<br>\t1. Fast: SENNA is written is C. So it is Fast.<br>\t2. We use only dependency Extractor Component of Stanford Parser, which takes in Syntactic Parse from SENNA and applies dependency Extraction. So there is no need to load parsing models for Stanford Parser, which takes time.<br>\t3. Easy to use.<br><br>\tInstallation<br>\t=============<br><br>\tRequires:<br>\tA computer with 500mb memory, Java Runtime Environment (1.7 preferably, works with 1.6 too, but didnt test.) installed and python.<br><br>\tIf you are in linux:<br>\trun:<br><br>\t    sudo python setup.py install <br><br>\tIf you are in windows:<br>\trun this commands as administrator:<br><br>\t    sudo python setup.py install<br>\t  <br><br>\tExamples<br>\t=============<br><br>\tChunk and NER use BIOS Tagging Scheme. Which expands to:<br><br>\t1. S = Tag covers Single Word.<br>\t2. B = Tag Begins with the Word.<br>\t3. I = Word is internal to tag which has begun.<br>\t4. E = Tag Ends with the Word.<br>\t5. 0 = Other tags.<br><br>\tExample:<br>\t  ('Biplab', 'S-NP'), ('is', 'S-VP'), ('a', 'B-NP'), ('good', 'I-NP'), ('boy', 'E-NP'), ('.', 'O')<br>\t  <br>\t  means:<br>\t  <br>\t  [Biplab]NP [is]VP [a good boy]NP [.]O<br>\t  <br><br>\tAnnotator is the only class you need. Create an annotator object.<br><br>\t    &gt;&gt;&gt;from practnlptools.tools import Annotator<br>\t    &gt;&gt;&gt;annotator=Annotator()<br><br><br>\tUsing Function getAnnoations(sentence) returns a dictionary of annotations.<br><br>\t    &gt;&gt;&gt;annotator.getAnnotations(\"There are people dying make this world a better place for you and for me.\")<br>\t    {'dep_parse': '', 'chunk': [('There', 'S-NP'), ('are', 'S-VP'), ('people', 'S-NP'), ('dying', 'B-VP'), ('make', 'E-VP'), ('this', 'B-NP'), ('world', 'E-NP'), ('a', 'B-NP'), ('better', 'I-NP'), ('place', 'E-NP'), ('for', 'S-PP'), ('you', 'S-NP'), ('and', 'O'), ('for', 'S-PP'), ('me.', 'S-NP')], 'pos': [('There', 'EX'), ('are', 'VBP'), ('people', 'NNS'), ('dying', 'VBG'), ('make', 'VB'), ('this', 'DT'), ('world', 'NN'), ('a', 'DT'), ('better', 'JJR'), ('place', 'NN'), ('for', 'IN'), ('you', 'PRP'), ('and', 'CC'), ('for', 'IN'), ('me.', '.')], 'srl': [{'A1': 'people', 'V': 'dying'}, {'A1': 'people  this world', 'A2': 'a better place for you and for me.', 'V': 'make'}], 'syntax_tree': '(S1(S(NP(EX There))(VP(VBP are)(NP(NP(NNS people))(SBAR(S(VBG dying)(VP(VB make)(S(NP(DT this)(NN world))(NP(DT a)(JJR better)(NN place)))(PP(PP(IN for)(NP(PRP you)))(CC and)(PP(IN for)(NP(. me.)))))))))))', 'verbs': ['dying', 'make'], 'words': ['There', 'are', 'people', 'dying', 'make', 'this', 'world', 'a', 'better', 'place', 'for', 'you', 'and', 'for', 'me.'], 'ner': [('There', 'O'), ('are', 'O'), ('people', 'O'), ('dying', 'O'), ('make', 'O'), ('this', 'O'), ('world', 'O'), ('a', 'O'), ('better', 'O'), ('place', 'O'), ('for', 'O'), ('you', 'O'), ('and', 'O'), ('for', 'O'), ('me.', 'O')]}<br><br><br>\tUsing Function getAnnoations(sentence,dep_parse=True) returns a dictionary of annotations with dependency parse, by default it is switched off.<br><br>\t    &gt;&gt;&gt;annotator.getAnnotations(\"There are people dying make this world a better place for you and for me.\",dep_parse=True)<br>\t    {'dep_parse': 'expl(are-2, There-1)<br>root(ROOT-0, are-2)<br>nsubj(are-2, people-3)<br>dep(make-5, dying-4)<br>rcmod(people-3, make-5)<br>det(world-7, this-6)<br>nsubj(place-10, world-7)<br>det(place-10, a-8)<br>amod(place-10, better-9)<br>xcomp(make-5, place-10)<br>prep_for(make-5, you-12)<br>conj_and(you-12, me.-15)', 'chunk': [('There', 'S-NP'), ('are', 'S-VP'), ('people', 'S-NP'), ('dying', 'B-VP'), ('make', 'E-VP'), ('this', 'B-NP'), ('world', 'E-NP'), ('a', 'B-NP'), ('better', 'I-NP'), ('place', 'E-NP'), ('for', 'S-PP'), ('you', 'S-NP'), ('and', 'O'), ('for', 'S-PP'), ('me.', 'S-NP')], 'pos': [('There', 'EX'), ('are', 'VBP'), ('people', 'NNS'), ('dying', 'VBG'), ('make', 'VB'), ('this', 'DT'), ('world', 'NN'), ('a', 'DT'), ('better', 'JJR'), ('place', 'NN'), ('for', 'IN'), ('you', 'PRP'), ('and', 'CC'), ('for', 'IN'), ('me.', '.')], 'srl': [{'A1': 'people', 'V': 'dying'}, {'A1': 'people  this world', 'A2': 'a better place for you and for me.', 'V': 'make'}], 'syntax_tree': '(S1(S(NP(EX There))(VP(VBP are)(NP(NP(NNS people))(SBAR(S(VBG dying)(VP(VB make)(S(NP(DT this)(NN world))(NP(DT a)(JJR better)(NN place)))(PP(PP(IN for)(NP(PRP you)))(CC and)(PP(IN for)(NP(. me.)))))))))))', 'verbs': ['dying', 'make'], 'words': ['There', 'are', 'people', 'dying', 'make', 'this', 'world', 'a', 'better', 'place', 'for', 'you', 'and', 'for', 'me.'], 'ner': [('There', 'O'), ('are', 'O'), ('people', 'O'), ('dying', 'O'), ('make', 'O'), ('this', 'O'), ('world', 'O'), ('a', 'O'), ('better', 'O'), ('place', 'O'), ('for', 'O'), ('you', 'O'), ('and', 'O'), ('for', 'O'), ('me.', 'O')]}<br><br>\tYou can access individual componets as:<br><br>\t    &gt;&gt;&gt;annotator.getAnnotations(\"Biplab is a good boy.\")['pos']<br>\t    [('Biplab', 'NNP'), ('is', 'VBZ'), ('a', 'DT'), ('good', 'JJ'), ('boy', 'NN'), ('.', '.')]<br>\t    &gt;&gt;&gt;annotator.getAnnotations(\"Biplab is a good boy.\")['ner']<br>\t    [('Biplab', 'S-PER'), ('is', 'O'), ('a', 'O'), ('good', 'O'), ('boy', 'O'), ('.', 'O')]<br>\t    &gt;&gt;&gt;annotator.getAnnotations(\"Biplab is a good boy.\")['chunk']<br>\t    [('Biplab', 'S-NP'), ('is', 'S-VP'), ('a', 'B-NP'), ('good', 'I-NP'), ('boy', 'E-NP'), ('.', 'O')]<br><br><br>\tTo list the verbs for which semantic roles are found.<br><br>\t    &gt;&gt;&gt;annotator.getAnnotations(\"He created the robot and broke it after making it.\")['verbs']<br>\t    ['created', 'broke', 'making']<br><br>\t'srl' Returns a list of dictionaries, identifyinging sematic roles for various verbs in sentence.<br><br>\t    &gt;&gt;&gt;annotator.getAnnotations(\"He created the robot and broke it after making it.\")['srl']<br>\t    [{'A1': 'the robot', 'A0': 'He', 'V': 'created'}, {'A1': 'it', 'A0': 'He', 'AM-TMP': 'after making it.', 'V': 'broke'}, {'A1': 'it.', 'A0': 'He', 'V': 'making'}]<br><br>\t'syntax_tree' Returns syntax tree in penn Tree Bank Format.<br><br>\t    &gt;&gt;&gt;annotator.getAnnotations(\"He created the robot and broke it after making it.\")['syntax_tree']<br>\t    '(S1(S(NP(PRP He))(VP(VP(VBD created)(NP(DT the)(NN robot)))(CC and)(VP(VBD broke)(NP(PRP it))(PP(IN after)(S(VP(VBG making)(NP(PRP it.)))))))))'<br><br>\t'dep_parse' Returns dependency Relations as a string. Each relation is in new line. You may require some post processing on this.<br><br>\t    &gt;&gt;&gt;print annotator.getAnnotations(\"He created the robot and broke it after making it.\",dep_parse=True)['dep_parse']<br>\t    nsubj(created-2, He-1)<br>\t    root(ROOT-0, created-2)<br>\t    det(robot-4, the-3)<br>\t    dobj(created-2, robot-4)<br>\t    conj_and(created-2, broke-6)<br>\t    dobj(broke-6, it-7)<br>\t    prepc_after(broke-6, making-9)<br>\t    dobj(making-9, it.-10)<br><br><br>\tIf there are many sentences to annotate, Use batch Mode, annotator.getBatchAnnotations(sentences,dep_parse=True/False). Returns a list of annotation dictionaries.<br><br>\t    &gt;&gt;&gt;annotator.getBatchAnnotations([\"He created the robot and broke it after making it.\",\"Biplab is a good boy.\"],dep_parse=True)<br>\t    [{'dep_parse': 'nsubj(created-2, He-1)<br>root(ROOT-0, created-2)<br>det(robot-4, the-3)<br>dobj(created-2, robot-4)<br>conj_and(created-2, broke-6)<br>dobj(broke-6, it-7)<br>prepc_after(broke-6, making-9)<br>dobj(making-9, it.-10)', 'chunk': [('He', 'S-NP'), ('created', 'S-VP'), ('the', 'B-NP'), ('robot', 'E-NP'), ('and', 'O'), ('broke', 'S-VP'), ('it', 'S-NP'), ('after', 'S-PP'), ('making', 'S-VP'), ('it.', 'S-NP')], 'pos': [('He', 'PRP'), ('created', 'VBD'), ('the', 'DT'), ('robot', 'NN'), ('and', 'CC'), ('broke', 'VBD'), ('it', 'PRP'), ('after', 'IN'), ('making', 'VBG'), ('it.', 'PRP')], 'srl': [{'A1': 'the robot', 'A0': 'He', 'V': 'created'}, {'A1': 'it', 'A0': 'He', 'AM-TMP': 'after making it.', 'V': 'broke'}, {'A1': 'it.', 'A0': 'He', 'V': 'making'}], 'syntax_tree': '(S1(S(NP(PRP He))(VP(VP(VBD created)(NP(DT the)(NN robot)))(CC and)(VP(VBD broke)(NP(PRP it))(PP(IN after)(S(VP(VBG making)(NP(PRP it.)))))))))', 'verbs': ['created', 'broke', 'making'], 'words': ['He', 'created', 'the', 'robot', 'and', 'broke', 'it', 'after', 'making', 'it.'], 'ner': [('He', 'O'), ('created', 'O'), ('the', 'O'), ('robot', 'O'), ('and', 'O'), ('broke', 'O'), ('it', 'O'), ('after', 'O'), ('making', 'O'), ('it.', 'O')]}, {'dep_parse': 'nsubj(boy-5, Biplab-1)<br>cop(boy-5, is-2)<br>det(boy-5, a-3)<br>amod(boy-5, good-4)<br>root(ROOT-0, boy-5)', 'chunk': [('Biplab', 'S-NP'), ('is', 'S-VP'), ('a', 'B-NP'), ('good', 'I-NP'), ('boy', 'E-NP'), ('.', 'O')], 'pos': [('Biplab', 'NNP'), ('is', 'VBZ'), ('a', 'DT'), ('good', 'JJ'), ('boy', 'NN'), ('.', '.')], 'srl': [], 'syntax_tree': '(S1(S(NP(NNP Biplab))(VP(VBZ is)(NP(DT a)(JJ good)(NN boy)))(. .)))', 'verbs': [], 'words': ['Biplab', 'is', 'a', 'good', 'boy', '.'], 'ner': [('Biplab', 'S-PER'), ('is', 'O'), ('a', 'O'), ('good', 'O'), ('boy', 'O'), ('.', 'O')]}]<br><br><br>\tNote: For illustration purposes we have used:<br><br>\t    &gt;&gt;&gt;annotator.getAnnotations(\"He created the robot and broke it after making it.\",dep_parse=True)['dep_parse']<br><br>\tBetter method is:<br><br>\t    &gt;&gt;&gt;annotation=annotator.getAnnotations(\"He created the robot and broke it after making it.\",dep_parse=True)<br>\t    &gt;&gt;&gt;ner=annotation['ner']<br>\t    &gt;&gt;&gt;srl=annotation['srl']<br><br>\tIssues<br>\t=============<br><br>\t1. You cannot give sentence with (  or ), that is left bracket aor right bracket. It will end up in returning no result. So please clean Sentences before sending to annotator.<br>\t2. Other issue might be senna executable built for various platforms. I have not experienced it, but its highly probable. If you get this issuse:<br><br>\tGo to folder practnlptools<br><br>\t    cd practnlptools<br>\t    gcc -O3 -o senna-linux64 *.c  (For linux 64 bit)<br>\t    gcc -O3 -o senna-linux32 *.c  (For linux 32 bit)<br>\t    gcc -O3 -o senna-senna-osx *.c (For Mac)<br>\t    *windows: I never compiled C files in Windows.*<br>\t    python setup.py install<br><br>\t3. Any other, you can la la laa la laaaa to  biplab12  (A T) cse d0t iitb d0t ac d0t in <br><br>\tTO DO<br>\t=============<br>\t1. Make Dependency Parse more Accessible.<br>\t2. Include instruction to build senna for windows\n          </div>"}, "last_serial": 1141764, "releases": {"1.0": []}, "urls": [], "timestamp": "Fri May  8 03:20:14 2020"}