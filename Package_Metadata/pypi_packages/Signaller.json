{"info": {"author": "Michal Krenek (Mikos)", "author_email": "m.krenek@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "Signaller\n=========\n\nSignals and slots implementation with asyncio support\n\nSlots can be functions, methods or coroutines. Weak references are used by default.\nIf slot is coroutine, it will be scheduled to run asynchronously with ``asyncio.async()``\n(but you must run event loop by yourself).\n\nYou can also run blocking functions asynchronously by specifying ``force_async=True`` when\nconnecting signal to slot (it will only apply to that slot) or when creating signal (it will\napply to all connected slots). ThreadPoolExecutor with 5 worker threads is used by default,\nbut it can be changed when creating signal with ``executor`` argument.\n\nRequirements\n------------\n\n- Python >= 3.4\n\nUsage\n-----\n\nExample:\n\n.. code-block:: python\n\n    import logging\n    from signaller import Signal, autoconnect\n\n    # Enable verbose logging\n    logging.basicConfig(level=logging.DEBUG)\n\n    # Creating signals (you can set signal name, but it is not required,\n    # signals can be anonymous):\n    sig_test = Signal('sig_test')\n    \n    # Connecting signals to slots (uses weak references by default,\n    # but you can force strong references by specifying weak=False):\n    def slot(arg):\n        print('slot:', arg)\n\n    sig_test.connect(slot)\n    sig_test.connect(lambda arg: print('slot_lambda:', arg), weak=False)\n\n    # You can also use decorators for connecting signals to slots:\n    @sig_test.connect\n    def slot2(arg):\n        print('slot2:', arg)\n\n    # And keyword arguments can be specified when using decorators too:\n    @sig_test.connect(force_async=True)\n    def slot3(arg):\n        print('slot3:', arg)\n\n    # You can also use decorators on methods, then signals will be connected to instance\n    # methods automatically whenever new instance is created. But you must decorate class\n    # with @autoconnect decorator for autoconnection to work. Class methods and\n    # static methods are not supported.\n    @autoconnect\n    class Cls:\n        @sig_test.connect\n        def slot4(self, arg):\n            print('slot4:', arg)\n\n    obj = Cls()\n\n    # Slots are automatically disconnected from signals\n    # when using weak references:\n    del slot\n\n    # Or you can disconnect slots manually:\n    sig_test.disconnect(slot2)\n\n    # Emitting signals (you can send both positional and keyword\n    # arguments to connected slots):\n    sig_test.emit('Hello world!')\n\nOutput::\n\n    INFO:signaller:Connecting signal <Signal 'sig_test' at 0x7f3c468bfc50> to slot <function slot at 0x7f3c46cc6f28>\n    INFO:signaller:Connecting signal <Signal 'sig_test' at 0x7f3c468bfc50> to slot <function <lambda> at 0x7f3c468c97b8>\n    INFO:signaller:Connecting signal <Signal 'sig_test' at 0x7f3c468bfc50> to slot <function slot2 at 0x7f3c43c9e400>\n    INFO:signaller:Connecting signal <Signal 'sig_test' at 0x7f3c468bfc50> to slot <function slot3 at 0x7f3c43c9e598>\n    DEBUG:signaller:Marking instance method <function Cls.slot4 at 0x7f3c43c9e6a8> for autoconnect to signal <Signal 'sig_test' at 0x7f3c468bfc50>\n    INFO:signaller:Connecting signal <Signal 'sig_test' at 0x7f3c468bfc50> to slot <bound method Cls.slot4 of <__main__.Cls object at 0x7f3c43f11d30>>\n    DEBUG:signaller:Object <function slot at 0x7f3c46cc6f28> has been deleted\n    INFO:signaller:Disconnecting slot <Reference (weak) to <function slot at 0x7f3c46cc6f28> (dead)> from signal <Signal 'sig_test' at 0x7f3c468bfc50>\n    INFO:signaller:Disconnecting slot <function slot2 at 0x7f3c43c9e400> from signal <Signal 'sig_test' at 0x7f3c468bfc50>\n    INFO:signaller:Emitting signal <Signal 'sig_test' at 0x7f3c468bfc50>\n    DEBUG:signaller:Calling slot <Reference (weak) to <function slot3 at 0x7f3c43c9e598>> asynchronously (in executor <concurrent.futures.thread.ThreadPoolExecutor object at 0x7f3c468bff28>)\n    slot3: Hello world!\n    DEBUG:signaller:Calling slot <Reference (strong) to <function <lambda> at 0x7f3c468c97b8>>\n    slot_lambda: Hello world!\n    DEBUG:signaller:Calling slot <Reference (weak) to <bound method Cls.slot4 of <__main__.Cls object at 0x7f3c43f11d30>>>\n    slot4: Hello world!\n", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/xmikos/signaller", "keywords": "signal slot dispatch dispatcher observer event notify asyncio weakref", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "Signaller", "package_url": "https://pypi.org/project/Signaller/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/Signaller/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/xmikos/signaller"}, "release_url": "https://pypi.org/project/Signaller/1.1.0/", "requires_dist": null, "requires_python": null, "summary": "Signals and slots implementation with asyncio support", "version": "1.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Signals and slots implementation with asyncio support</p>\n<p>Slots can be functions, methods or coroutines. Weak references are used by default.\nIf slot is coroutine, it will be scheduled to run asynchronously with <tt>asyncio.async()</tt>\n(but you must run event loop by yourself).</p>\n<p>You can also run blocking functions asynchronously by specifying <tt>force_async=True</tt> when\nconnecting signal to slot (it will only apply to that slot) or when creating signal (it will\napply to all connected slots). ThreadPoolExecutor with 5 worker threads is used by default,\nbut it can be changed when creating signal with <tt>executor</tt> argument.</p>\n<div id=\"requirements\">\n<h2>Requirements</h2>\n<ul>\n<li>Python &gt;= 3.4</li>\n</ul>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>Example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">logging</span>\n<span class=\"kn\">from</span> <span class=\"nn\">signaller</span> <span class=\"kn\">import</span> <span class=\"n\">Signal</span><span class=\"p\">,</span> <span class=\"n\">autoconnect</span>\n\n<span class=\"c1\"># Enable verbose logging</span>\n<span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">basicConfig</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"o\">=</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">DEBUG</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Creating signals (you can set signal name, but it is not required,</span>\n<span class=\"c1\"># signals can be anonymous):</span>\n<span class=\"n\">sig_test</span> <span class=\"o\">=</span> <span class=\"n\">Signal</span><span class=\"p\">(</span><span class=\"s1\">'sig_test'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Connecting signals to slots (uses weak references by default,</span>\n<span class=\"c1\"># but you can force strong references by specifying weak=False):</span>\n<span class=\"k\">def</span> <span class=\"nf\">slot</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'slot:'</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">)</span>\n\n<span class=\"n\">sig_test</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">slot</span><span class=\"p\">)</span>\n<span class=\"n\">sig_test</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">arg</span><span class=\"p\">:</span> <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'slot_lambda:'</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">),</span> <span class=\"n\">weak</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># You can also use decorators for connecting signals to slots:</span>\n<span class=\"nd\">@sig_test</span><span class=\"o\">.</span><span class=\"n\">connect</span>\n<span class=\"k\">def</span> <span class=\"nf\">slot2</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'slot2:'</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># And keyword arguments can be specified when using decorators too:</span>\n<span class=\"nd\">@sig_test</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">force_async</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">slot3</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'slot3:'</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># You can also use decorators on methods, then signals will be connected to instance</span>\n<span class=\"c1\"># methods automatically whenever new instance is created. But you must decorate class</span>\n<span class=\"c1\"># with @autoconnect decorator for autoconnection to work. Class methods and</span>\n<span class=\"c1\"># static methods are not supported.</span>\n<span class=\"nd\">@autoconnect</span>\n<span class=\"k\">class</span> <span class=\"nc\">Cls</span><span class=\"p\">:</span>\n    <span class=\"nd\">@sig_test</span><span class=\"o\">.</span><span class=\"n\">connect</span>\n    <span class=\"k\">def</span> <span class=\"nf\">slot4</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">):</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'slot4:'</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">)</span>\n\n<span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"n\">Cls</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Slots are automatically disconnected from signals</span>\n<span class=\"c1\"># when using weak references:</span>\n<span class=\"k\">del</span> <span class=\"n\">slot</span>\n\n<span class=\"c1\"># Or you can disconnect slots manually:</span>\n<span class=\"n\">sig_test</span><span class=\"o\">.</span><span class=\"n\">disconnect</span><span class=\"p\">(</span><span class=\"n\">slot2</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Emitting signals (you can send both positional and keyword</span>\n<span class=\"c1\"># arguments to connected slots):</span>\n<span class=\"n\">sig_test</span><span class=\"o\">.</span><span class=\"n\">emit</span><span class=\"p\">(</span><span class=\"s1\">'Hello world!'</span><span class=\"p\">)</span>\n</pre>\n<p>Output:</p>\n<pre>INFO:signaller:Connecting signal &lt;Signal 'sig_test' at 0x7f3c468bfc50&gt; to slot &lt;function slot at 0x7f3c46cc6f28&gt;\nINFO:signaller:Connecting signal &lt;Signal 'sig_test' at 0x7f3c468bfc50&gt; to slot &lt;function &lt;lambda&gt; at 0x7f3c468c97b8&gt;\nINFO:signaller:Connecting signal &lt;Signal 'sig_test' at 0x7f3c468bfc50&gt; to slot &lt;function slot2 at 0x7f3c43c9e400&gt;\nINFO:signaller:Connecting signal &lt;Signal 'sig_test' at 0x7f3c468bfc50&gt; to slot &lt;function slot3 at 0x7f3c43c9e598&gt;\nDEBUG:signaller:Marking instance method &lt;function Cls.slot4 at 0x7f3c43c9e6a8&gt; for autoconnect to signal &lt;Signal 'sig_test' at 0x7f3c468bfc50&gt;\nINFO:signaller:Connecting signal &lt;Signal 'sig_test' at 0x7f3c468bfc50&gt; to slot &lt;bound method Cls.slot4 of &lt;__main__.Cls object at 0x7f3c43f11d30&gt;&gt;\nDEBUG:signaller:Object &lt;function slot at 0x7f3c46cc6f28&gt; has been deleted\nINFO:signaller:Disconnecting slot &lt;Reference (weak) to &lt;function slot at 0x7f3c46cc6f28&gt; (dead)&gt; from signal &lt;Signal 'sig_test' at 0x7f3c468bfc50&gt;\nINFO:signaller:Disconnecting slot &lt;function slot2 at 0x7f3c43c9e400&gt; from signal &lt;Signal 'sig_test' at 0x7f3c468bfc50&gt;\nINFO:signaller:Emitting signal &lt;Signal 'sig_test' at 0x7f3c468bfc50&gt;\nDEBUG:signaller:Calling slot &lt;Reference (weak) to &lt;function slot3 at 0x7f3c43c9e598&gt;&gt; asynchronously (in executor &lt;concurrent.futures.thread.ThreadPoolExecutor object at 0x7f3c468bff28&gt;)\nslot3: Hello world!\nDEBUG:signaller:Calling slot &lt;Reference (strong) to &lt;function &lt;lambda&gt; at 0x7f3c468c97b8&gt;&gt;\nslot_lambda: Hello world!\nDEBUG:signaller:Calling slot &lt;Reference (weak) to &lt;bound method Cls.slot4 of &lt;__main__.Cls object at 0x7f3c43f11d30&gt;&gt;&gt;\nslot4: Hello world!\n</pre>\n</div>\n\n          </div>"}, "last_serial": 1936644, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "373131178d8363432cc052371fe3e208", "sha256": "6893ef5073573f448c9444ae810b1e4feb0188293ba5d58bafe4b7722e751217"}, "downloads": -1, "filename": "Signaller-1.0.0.tar.gz", "has_sig": false, "md5_digest": "373131178d8363432cc052371fe3e208", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4028, "upload_time": "2016-01-31T02:03:20", "upload_time_iso_8601": "2016-01-31T02:03:20.738880Z", "url": "https://files.pythonhosted.org/packages/87/ef/f933bdedc2d60894ecb96d825d1d70fde290aa996c73f7090ba55870e0e2/Signaller-1.0.0.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "eb759cbdcbb0b972bf2f22d2fc280989", "sha256": "df43d1bb47bbd389a001be6a1aae708ae6a9e8f9fa7514efab35123b642df8b8"}, "downloads": -1, "filename": "Signaller-1.1.0.tar.gz", "has_sig": false, "md5_digest": "eb759cbdcbb0b972bf2f22d2fc280989", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4579, "upload_time": "2016-02-03T00:21:52", "upload_time_iso_8601": "2016-02-03T00:21:52.998928Z", "url": "https://files.pythonhosted.org/packages/9b/87/c350cc8d91cf33a26f0912a4a06b375017a51ddadf3723d1c1bb682e087b/Signaller-1.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "eb759cbdcbb0b972bf2f22d2fc280989", "sha256": "df43d1bb47bbd389a001be6a1aae708ae6a9e8f9fa7514efab35123b642df8b8"}, "downloads": -1, "filename": "Signaller-1.1.0.tar.gz", "has_sig": false, "md5_digest": "eb759cbdcbb0b972bf2f22d2fc280989", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4579, "upload_time": "2016-02-03T00:21:52", "upload_time_iso_8601": "2016-02-03T00:21:52.998928Z", "url": "https://files.pythonhosted.org/packages/9b/87/c350cc8d91cf33a26f0912a4a06b375017a51ddadf3723d1c1bb682e087b/Signaller-1.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:11:45 2020"}