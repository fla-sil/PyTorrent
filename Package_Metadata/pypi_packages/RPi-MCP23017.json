{"info": {"author": "Christian Fischer", "author_email": "pypi@computerlyrik.de", "bugtrack_url": null, "classifiers": [], "description": "MCP23017-RPi-python\n        ===================\n        \n        Library for Raspberry interfacing with MCP23017 (e.g. on a shield)\n        \n        Datasheet: http://ww1.microchip.com/downloads/en/devicedoc/21952b.pdf\n        \n        Created with use of http://www.abelectronics.co.uk/products/3/Raspberry-Pi/18/IO-Pi-32-Channel-Port-Expander-for-the-Raspberry-Pi-computer-boards\n        \n        MCP23017 can be used with bank=0 or bank=1 - what you prefer.\n        \n        16-bit mode (2-byte write/read) is NOT SUPPORTED at the moment.\n        The focus is on a more generic interface which supports interrupts and (perhaps) the 8-bit MCP chips also.\n        \n        Dependencies\n        ============\n        \n        Python3\n        \n        quick2wire.i2c (http://quick2wire.com/)\n        \n        RPi.GPIO (https://pypi.python.org/pypi/RPi.GPIO)\n        \n        Features\n        ========\n        \n        MCP23017 class\n        --------------\n        MCP23017 class supports all low level configuration like accessing IOCON register, reading and writing any registers\n        \n        - Initialize MCP23017 with address\n        - Optionally configure your Bank bit in constructor (default: BANK = 0)\n        - Read from specific Register\n        - Write to specific register\n        - Setting a specific Bit in IOCON\n        - Unsetting a specific Bit in IOCON\n        \n        - Generating of two 8-bit-Port-Objects for a chip\n        \n        Port Manager Class\n        ------------------\n        \n        Port manager supports more high level operations.\n        \n        PortManager supplies the following methods to configure and work with an 8-bit-port (like Arduino lib on http://playground.arduino.cc/Main/MCP23S17 with more features)\n        \n        *Set I/O mode*\n        `pin_mode`\n        \n        *Set Pullups*\n        `pullup_mode`\n        \n        *Set Input Invert*\n        `input_invert`\n        \n        *Interrupt enabling*\n        `interrupt_enable`\n        \n        *Set Inerrupt compare*\n        `interrupt_compare`\n        \n        *Define Interrupt compare*\n        `interrupt_compare_value`\n        \n        - Reading and writing\n        `digital_write`\n        `digital_read`\n        \n        - Additionally it can handle a interrupt callback by passing a method:\n        `set_callback`\n        \n        Usage\n        =====\n        \n        Executing the module\n        --------------------\n        Reading the chip on address 0x20\n        ```bash\n        sudo ./MCP23017.py 32\n        ```\n        \n        Simple polling example\n        ----------------------\n        \n        ```python\n        from MCP23017 import MCP23017, PortManager, IOCON\n        \n        #create chip with bank=1 mode on address 0x20\n        chip1 = MCP23017(0x20, 1)\n        #create chip with bank=0 mode on address 0x21\n        chip2 = MCP23017(0x21, 1)\n        \n        #set some config bits on chip1\n        chip1.set_config(IOCON['INTPOL'])\n        \n        #generate ports for chip1 - takes always a dict with keys 'A' and 'B' and the desired RPi GPIO interrupt pins\n        ports = chip1.generate_ports({'A':4, 'B':17})\n        \n        #set ports of chip1 as input pins\n        for name,port in ports.items():\n          print(\" Setting up port \"+name)\n          #Set port to input pin\n          port.pin_mode(0xff)\n        \n        while True:\n          for name,port in ports.items():\n            print(\" Reading port \"+name)\n            print(port.digital_read())\n        \n        ```\n        \n        for setting up callbacks see also https://github.com/computerlyrik/PowerCounter\n        \n        \n        \n        TODO\n        ====\n        - TODO: implement 16 bit mode, affects:\n         - read() method\n         - write() method\n         - interrupt mirrors setting(?)", "description_content_type": null, "docs_url": null, "download_url": null, "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/computerlyrik/MCP23017-RPi-python", "keywords": null, "license": "LICENSE", "maintainer": null, "maintainer_email": null, "name": "RPi-MCP23017", "package_url": "https://pypi.org/project/RPi-MCP23017/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/RPi-MCP23017/", "project_urls": {"Homepage": "https://github.com/computerlyrik/MCP23017-RPi-python"}, "release_url": "https://pypi.org/project/RPi-MCP23017/0.1.0/", "requires_dist": null, "requires_python": null, "summary": "Interfacing MCP23017 with Raspberry Pi", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            MCP23017-RPi-python<br>        ===================<br>        <br>        Library for Raspberry interfacing with MCP23017 (e.g. on a shield)<br>        <br>        Datasheet: http://ww1.microchip.com/downloads/en/devicedoc/21952b.pdf<br>        <br>        Created with use of http://www.abelectronics.co.uk/products/3/Raspberry-Pi/18/IO-Pi-32-Channel-Port-Expander-for-the-Raspberry-Pi-computer-boards<br>        <br>        MCP23017 can be used with bank=0 or bank=1 - what you prefer.<br>        <br>        16-bit mode (2-byte write/read) is NOT SUPPORTED at the moment.<br>        The focus is on a more generic interface which supports interrupts and (perhaps) the 8-bit MCP chips also.<br>        <br>        Dependencies<br>        ============<br>        <br>        Python3<br>        <br>        quick2wire.i2c (http://quick2wire.com/)<br>        <br>        RPi.GPIO (https://pypi.python.org/pypi/RPi.GPIO)<br>        <br>        Features<br>        ========<br>        <br>        MCP23017 class<br>        --------------<br>        MCP23017 class supports all low level configuration like accessing IOCON register, reading and writing any registers<br>        <br>        - Initialize MCP23017 with address<br>        - Optionally configure your Bank bit in constructor (default: BANK = 0)<br>        - Read from specific Register<br>        - Write to specific register<br>        - Setting a specific Bit in IOCON<br>        - Unsetting a specific Bit in IOCON<br>        <br>        - Generating of two 8-bit-Port-Objects for a chip<br>        <br>        Port Manager Class<br>        ------------------<br>        <br>        Port manager supports more high level operations.<br>        <br>        PortManager supplies the following methods to configure and work with an 8-bit-port (like Arduino lib on http://playground.arduino.cc/Main/MCP23S17 with more features)<br>        <br>        *Set I/O mode*<br>        `pin_mode`<br>        <br>        *Set Pullups*<br>        `pullup_mode`<br>        <br>        *Set Input Invert*<br>        `input_invert`<br>        <br>        *Interrupt enabling*<br>        `interrupt_enable`<br>        <br>        *Set Inerrupt compare*<br>        `interrupt_compare`<br>        <br>        *Define Interrupt compare*<br>        `interrupt_compare_value`<br>        <br>        - Reading and writing<br>        `digital_write`<br>        `digital_read`<br>        <br>        - Additionally it can handle a interrupt callback by passing a method:<br>        `set_callback`<br>        <br>        Usage<br>        =====<br>        <br>        Executing the module<br>        --------------------<br>        Reading the chip on address 0x20<br>        ```bash<br>        sudo ./MCP23017.py 32<br>        ```<br>        <br>        Simple polling example<br>        ----------------------<br>        <br>        ```python<br>        from MCP23017 import MCP23017, PortManager, IOCON<br>        <br>        #create chip with bank=1 mode on address 0x20<br>        chip1 = MCP23017(0x20, 1)<br>        #create chip with bank=0 mode on address 0x21<br>        chip2 = MCP23017(0x21, 1)<br>        <br>        #set some config bits on chip1<br>        chip1.set_config(IOCON['INTPOL'])<br>        <br>        #generate ports for chip1 - takes always a dict with keys 'A' and 'B' and the desired RPi GPIO interrupt pins<br>        ports = chip1.generate_ports({'A':4, 'B':17})<br>        <br>        #set ports of chip1 as input pins<br>        for name,port in ports.items():<br>          print(\" Setting up port \"+name)<br>          #Set port to input pin<br>          port.pin_mode(0xff)<br>        <br>        while True:<br>          for name,port in ports.items():<br>            print(\" Reading port \"+name)<br>            print(port.digital_read())<br>        <br>        ```<br>        <br>        for setting up callbacks see also https://github.com/computerlyrik/PowerCounter<br>        <br>        <br>        <br>        TODO<br>        ====<br>        - TODO: implement 16 bit mode, affects:<br>         - read() method<br>         - write() method<br>         - interrupt mirrors setting(?)\n          </div>"}, "last_serial": 869585, "releases": {"0.1.0": []}, "urls": [], "timestamp": "Fri May  8 03:00:55 2020"}