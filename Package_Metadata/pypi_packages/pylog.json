{"info": {"author": "Russ Abbott, Jay Patel", "author_email": "Russ.Abbott@gmail.com, imjaypatel12@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.7", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "## Abstract (outline from [The Programming Journal](https://programming-journal.org/cfp/))\n\n<dl><dt>Context: What is the broad context of the work? What is the importance of the general research area?</dt>\n<dd>Pylog inhabits three programming contexts.<br/><br/>\n\n**a)** Pylog explores the integration of two distinct programming language paradigms: (i) the modern general purpose programming paradigm, which often includes features of procedural programming, object-oriented programming, functional programming, and meta-programming, here represented by Python, and (ii) logic programming, whose primary features are logic variables (and unification) and built-in depth-first search, here represented by Prolog. These logic programming feature are generally missing from modern general purpose languages. Pylog illustrates how these two features can be implemented in and integated into Python. \n\n**b)** Pylog demonstrates the breadth and broad applicability of Python. Although Python is now the most widely used programming language for teaching introductory programming, it has also become very widely used for sophisticated programming tasks. One of the reasons for its popularity is the range of capabilities it offers\u2014most of which are not used in elementary programming classes or for the sort of scripting applications with which Python is often associated. Pylog makes effective use of many of those capabilities.  \n\n**c)** Pylog examplifies programming at its best. Pylog is first-of-all a programming exercise: How can the primary features of logic programming be integrated with Python? Secondly, Pylog uses features of Python in ways that aere both intended and innovative. The overall result is software worth studying. From the perspective of [The Programming Journal](https://programming-journal.org/cfp/), it would fit into its Art-of-Programming category.\n</dd>\n\n<dt>Inquiry: What problem or question does the paper address? How has this problem or question been addressed by others (if at all)?</dt>\n<dd>The primary issue addressed in the paper\u2014and in Pylog itself\u2014is how logic variables and backtracking can be integrated cleanly into a Python framework. A fair amount of work has been done in this area: see <i>Related Work</i>. Although well done, most of it has been incomplete in one way or another. Pylog is the first complete system (as far as we know) to achieve the goal of integration.</dd>\n\n<dt>Approach: What was done that unveiled new knowledge?</dt>\n<dd>Pylog, exhibits the integration mentined above. The paper discusses\u2014and Pylog demonstrates\u2014how logic variables and backtracking can be interwoven with standard Python data structures and control structures.</dd>\n\n<dt>Knowledge: What new facts were uncovered? If the research was not results oriented, what new capabilities are enabled by the work?</dt>\n<dd>Pylog  is available as a logic programming library for use in Python software.</dd>\n\n<dt>Grounding: What argument, feasibility proof, artifacts, or results and evaluation support this work?</dt>\n<dd>Pylog demonstrates by its existence and functionality that the goal of integrating logic variables and backtracking with Python can be achieved.</dd>\n\n<dt>Importance: Why does this work matter?</dt>\n<dd>Python is known to be compatible with functional programming. This work shows that it is also (and simultaneously) compatible with logic programming. This work also demonstrates the power and elegance of well-designed software. \n<dd>\n</dl>\n\n## Introduction\n\nProlog, a programming language derived from logic, was developed in the 1970s. It became very popular during the 1980s as an AI language, especially in Japan as part of their [5th generation project](https://www.nytimes.com/1992/06/05/business/fifth-generation-became-japan-s-lost-generation.html). \n\nProlog went out of favor because [it was difficult to trace the execution of Prolog programs](https://synthese.wordpress.com/2010/08/21/prologs-death/)\u2014which made debugging very challenging.\n\nStructurally, Prolog is both one of the simplest of all programming languages\u2014you can learn it very quickly\u2014and one of the most interesting. It is quite different from virtually all other programming languages. In Prolog you make assertions of facts and then pose questions about those facts. Answers are *unified* with (rather than assigned to) variables.  Prolog is seductively elegant and powerful. \n\nWe can look a few examples [here](https://swish.swi-prolog.org/p/kb_rja.pl).\n\n## SWI-Prolog\n\n[SWI-Prolog](http://www.swi-prolog.org/) has kept the Prolog flame burning and seems to have developed a successful community of Prolog users.\n\n<dl>\n<dt>From the <a href=\"http://www.swi-prolog.org/features.html\">SWI-Prolog website</a></dt>\n<dd> SWI-Prolog is a versatile implementation of the <a href=\"https://en.wikipedia.org/wiki/Prolog\">Prolog language</a>. Although SWI-Prolog gained its popularity primarily in education, its development is mostly driven by the needs for application development. This is facilitated by a rich interface to other IT components by supporting many document types and (network) protocols as well as a comprehensive low-level interface to C that is the basis for high-level interfaces to C++, Java (bundled), C#, Python, etc (externally available). Data type extensions such as dicts and strings as well as full support for Unicode and unbounded integers simplify smooth exchange of data with other components.<br /><br />\nSWI-Prolog aims at scalability. Its robust support for multi-threading exploits multi-core hardware efficiently and simplifies embedding in concurrent applications. Its Just In Time Indexing (JITI) provides transparent and efficient support for predicates with millions of clauses.</dd>\n</dl>\n\n## Prolog tutorials\n\n* Blackburn, Patrick, Johan Bos, and Kristina Striegnitz (2012) [*Learn Prolog Now!*](http://lpn.swi-prolog.org/lpnpage.php?pageid=online) (This version of the book is embedded in SWI Prolog\u2019s [SWI SH](http://swish.swi-prolog.org/) ([SWI-Prolog](http://www.swi-prolog.org/) for SHaring), an online Prolog interpreter similar to Jupyter.)\n\n* Wilson, Bill, [\"Introduction to Prolog Programming,\"](http://www.cse.unsw.edu.au/~billw/cs9414/notes/prolog/intro.html) for the course COMP9414/9814 \"Artificial Intelligence.\" Consists mostly of extracts from the first five chapters of \n\n  * Bratko, I. (2011) [*Programming in Prolog for Artificial Intelligence*](https://www.amazon.com/gp/product/0321417461/ref=dbs_a_def_rwt_hsch_vapi_taft_p1_i0), 4th Edition, Addison-Wesley.\n\n* Piumarta, Ian (2017) [\"Programming-language-paradigms\"](http://www.ritsumei.ac.jp/~piumarta/pl/) (a course).  \u201cLogic programming and Prolog\u201d is explored in week 5 ([slides-5](http://www.ritsumei.ac.jp/~piumarta/pl/slides/PL-05.pdf), [exercises-5](http://www.ritsumei.ac.jp/~piumarta/pl/ex/PL-05-ex.pdf)), week 6 ([slides-6](http://www.ritsumei.ac.jp/~piumarta/pl/slides/PL-06.pdf), [exercises-6](http://www.ritsumei.ac.jp/~piumarta/pl/ex/PL-06-ex.pdf)), and week 7 ([slides-7](http://www.ritsumei.ac.jp/~piumarta/pl/slides/PL-07.pdf), [exercises-7](http://www.ritsumei.ac.jp/~piumarta/pl/ex/PL-07-ex.pdf)). Week 7 is a Prolog tutorial. You should be able to understand it without first reading weeks 5 and 6. But those weeks are important. They show how to  implement many Prolog features in Python.\n\n## Pylog: prolog in Python\nThis repository is a Python implementation of many Prolog features. It is a fork of Piumarta\u2019s [`unify.py`](http://www.ritsumei.ac.jp/~piumarta/pl/src/unify.py).\n\nAs an introductory example, consider the following (Python) code\u2014adapted from [Piumarta's week 5 exercises](http://www.ritsumei.ac.jp/~piumarta/pl/ex/PL-05-ex.py). (You can run it [here](https://colab.research.google.com/drive/1BkWBGY0GpOYqHLpyylzbPU9OLdyqxSmk).) (The type annotations are not required, but they are useful to understand what's going on.) \n\n```python\nfrom typing import Generator\n\ndef isEven(i: int) -> Generator[None, None, None]:\n    if i % 2 == 0:\n        print(f'{i}-even', end = ', ')\n        yield \n    else:\n        print(f'{i}-odd', end = ', ')\n\nevens = [i for i in range(10) for _ in isEven(i)]\n\nprint(f'\\n{evens}')\n\n```\nCan you figure out how the preceding produces these results? \n```python\n0-even, 1-odd, 2-even, 3-odd, 4-even, 5-odd, 6-even, 7-odd, 8-even, 9-odd,\n[0, 2, 4, 6, 8] \n```\nIn particular, what does \n\n```python \nfor _ in isEven(i)\n``` \n\ndo in the list comprehension?\n\nIn Prolog, program components are understood as predicates. They may *succeed* or *fail*. To succeed/fail means that the system was/was not able to establish that the predicate holds given the information available. \n\nSuccess or failure is implemented in Python through generators. A generator that **yield**s a result (at the Python level) is said to succeed (at the Prolog level); one that does not **yield** a result, fails (at the Prolog level).\n\nIn this case, `isEven(i)` succeeds/fails when `i` is even/odd. (In either case it produces an output line.) When\n\n```python\nfor _ in isEven(i)\n```\n\nsucceeds/fails for a given `i`, the list comprehension completes/fails to complete the iteration for that `i` and includes/does not include `i` in the generated list.  \n\n## Implementing logic variables and unification in Python\n\n*To be written*\n\n## Implementing Prolog backtracking in Python \n\n*To be written*\n\n## File organization (not recently updated)\n\n```\npylog                            -- Root directory\n    examples                     -- A directory of example pylog programs\n        n_queens.py              -- The traditional n-queens problem. Uses minimal pylog features but illustrates the pylog style.\n        puzzles.py               -- A file containing information common to the scholarship_problem and the zebra_problem\n        scholarship_problem.py   -- A traditional Prolog logic puzzle\u2014less complex than the zebra problem\n        trains.py                -- A revised version of the train example from Piumarta\n        zebra_problem.py         -- The well-known logic puzzle often solved with Prolog\n    sequence_options             -- A directory of options for lists and sequences\n        linked_list.py           -- A traditional head/tail list structure. Allows a variable tail, which Python does not\n        sequences.py             -- Implementations of Python lists and tuples\n        super_sequence.py        -- A class that serves as a superclass for all the sequences\n    control_structures.py        -- Implementation of the Prolog control structures\n    logic_variables.py           -- Implementation of Prolog's logic variables\n```\n\n## File dependencies/`imports from` relations (not recently updated)\n\n```\nlogic_variables: none\ncontrol_structures: logic_variables\n\nsuper_sequence: control_structures, logic_variables\nlinked_list and sequences: logic_variables, super_sequence\n\nn_queens: logic_variables, sequences\ntrains: control_structures, logic_variables, sequences\npuzzle: super_sequence\nscholarship_problem and zebra_problem: control_structures, logic_variables, puzzles, super_sequence\n\n```\n## Naming conventions\n\nFor the most part, Python identifier names follow PEP 8 conventions: all lower case, with underscores between words; no camel case except for class names.\n\nHowever, since Prolog uses identifiers that begin with an upper case letter for Prolog variables, Python identifiers used as Prolog variables begin with upper case letters.\n\n## Previous work\n\n* Berger, Shai (2004) [Pythologic](http://code.activestate.com/recipes/303057-pythologic-prolog-syntax-in-python/)\n\n* Bolz, Carl Friedrich (2007) [A Prolog Interpreter in Python](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.121.8625&rep=rep1&type=pdf)\n\n* Delord, Christophe (2009) [PyLog](http://cdsoft.fr/pylog/index.html)\n\n* Frederiksen, Bruce Frederiksen (2011) [Pyke](http://pyke.sourceforge.net/)\n\n* Kopec, David (2019) [Constraint-Satisfaction Problems in Python](https://freecontent.manning.com/constraint-satisfaction-problems-in-python/) from _[Classic Computer Science Problems in Python](https://www.manning.com/books/classic-computer-science-problems-in-python)_, Manning ([GitHub code repository](https://github.com/davecom/ClassicComputerScienceProblemsInPython/tree/master/Chapter3))\n\n* Maxime, Istasse (2016) [Prology: Logic programming for Python3](https://github.com/mistasse/Prology)\n\n* Meyers, Chris (2015) [Prolog in Python](http://www.openbookproject.net/py4fun/countClick.php?dest=prolog/intro.html)\n\n* Niemeyer, Gustavo and S\u00e9bastien Celles (2019). [python-constraint](https://github.com/python-constraint/python-constraint). Pypi page: [python-constraint](https://pypi.org/project/python-constraint/) (Also discussed in Popovi\u0107, Olivera (2019) [Constraint Programming with python-constraint](https://stackabuse.com/constraint-programming-with-python-constraint/#listofbuiltinconstraints))\n\n* Orsini, Francesc, Paolo Frasconi, Luc De Raedt (2017) [kProbLog: an algebraic Prolog for machine learning](https://link.springer.com/article/10.1007/s10994-017-5668-y) (This seems more like a theoretical discussion of kProbLog, which was implementated in Python, rather than an integraton of Python and Prolog. It's a worthwhile distinction to make. One can implement Prolog in any general purpose language. Pylog is notable because it integrates Python and Prolog.)\n\n* Python Foundation [re: Regular expression operations](https://docs.python.org/3/library/re.html)\n\n* Rocklin, Matthew (2015) [Unification](https://github.com/mrocklin/unification)\n\n* Rocklin, Matthew (2019) [kanren: Logic Programming in Python](https://github.com/logpy/logpy/) (The author of [toolz](https://toolz.readthedocs.io/en/latest/index.html))\n\n* Santini, Claudio (2018) [Pampy: The Pattern Matching for Python you always dreamed of](https://github.com/santinic/pampy)  \n\n* Stack Overflow questions.\n  * [Implementing the Prolog Unification algorithm in Python? Backtracking](https://stackoverflow.com/questions/49101342/implementing-the-prolog-unification-algorithm-in-python-backtracking)\n  * [Relational/Logic Programming in Python?](https://stackoverflow.com/questions/1917607/relational-logic-programming-in-python)\n\n* Thompson, Jeff (2017) [Yield Prolog](http://yieldprolog.sourceforge.net/)\n\n* Triska, Markus [CLP(FD): Constraint Logic Programming over Finite Domains](http://www.swi-prolog.org/man/clpfd.html) (also [CLP(FD): Constraint Logic Programming over Finite Domains](http://www.swi-prolog.org/pldoc/man?section=clpfd) (Repo of [examples](https://github.com/triska/clpz))\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/RussAbbott/pylog", "keywords": "prolog python logic programming", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pylog", "package_url": "https://pypi.org/project/pylog/", "platform": "", "project_url": "https://pypi.org/project/pylog/", "project_urls": {"Homepage": "https://github.com/RussAbbott/pylog"}, "release_url": "https://pypi.org/project/pylog/1.1/", "requires_dist": null, "requires_python": ">=3.7", "summary": "Python implementation of Prolog features.", "version": "1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h2>Abstract (outline from <a href=\"https://programming-journal.org/cfp/\" rel=\"nofollow\">The Programming Journal</a>)</h2>\n<dl><dt>Context: What is the broad context of the work? What is the importance of the general research area?</dt>\n<dd>Pylog inhabits three programming contexts.<br><br>\n<p><strong>a)</strong> Pylog explores the integration of two distinct programming language paradigms: (i) the modern general purpose programming paradigm, which often includes features of procedural programming, object-oriented programming, functional programming, and meta-programming, here represented by Python, and (ii) logic programming, whose primary features are logic variables (and unification) and built-in depth-first search, here represented by Prolog. These logic programming feature are generally missing from modern general purpose languages. Pylog illustrates how these two features can be implemented in and integated into Python.</p>\n<p><strong>b)</strong> Pylog demonstrates the breadth and broad applicability of Python. Although Python is now the most widely used programming language for teaching introductory programming, it has also become very widely used for sophisticated programming tasks. One of the reasons for its popularity is the range of capabilities it offers\u2014most of which are not used in elementary programming classes or for the sort of scripting applications with which Python is often associated. Pylog makes effective use of many of those capabilities.</p>\n<p><strong>c)</strong> Pylog examplifies programming at its best. Pylog is first-of-all a programming exercise: How can the primary features of logic programming be integrated with Python? Secondly, Pylog uses features of Python in ways that aere both intended and innovative. The overall result is software worth studying. From the perspective of <a href=\"https://programming-journal.org/cfp/\" rel=\"nofollow\">The Programming Journal</a>, it would fit into its Art-of-Programming category.</p>\n</dd>\n<dt>Inquiry: What problem or question does the paper address? How has this problem or question been addressed by others (if at all)?</dt>\n<dd>The primary issue addressed in the paper\u2014and in Pylog itself\u2014is how logic variables and backtracking can be integrated cleanly into a Python framework. A fair amount of work has been done in this area: see <i>Related Work</i>. Although well done, most of it has been incomplete in one way or another. Pylog is the first complete system (as far as we know) to achieve the goal of integration.</dd>\n<dt>Approach: What was done that unveiled new knowledge?</dt>\n<dd>Pylog, exhibits the integration mentined above. The paper discusses\u2014and Pylog demonstrates\u2014how logic variables and backtracking can be interwoven with standard Python data structures and control structures.</dd>\n<dt>Knowledge: What new facts were uncovered? If the research was not results oriented, what new capabilities are enabled by the work?</dt>\n<dd>Pylog  is available as a logic programming library for use in Python software.</dd>\n<dt>Grounding: What argument, feasibility proof, artifacts, or results and evaluation support this work?</dt>\n<dd>Pylog demonstrates by its existence and functionality that the goal of integrating logic variables and backtracking with Python can be achieved.</dd>\n<dt>Importance: Why does this work matter?</dt>\n<dd>Python is known to be compatible with functional programming. This work shows that it is also (and simultaneously) compatible with logic programming. This work also demonstrates the power and elegance of well-designed software. \n<dd>\n</dd></dd></dl>\n<h2>Introduction</h2>\n<p>Prolog, a programming language derived from logic, was developed in the 1970s. It became very popular during the 1980s as an AI language, especially in Japan as part of their <a href=\"https://www.nytimes.com/1992/06/05/business/fifth-generation-became-japan-s-lost-generation.html\" rel=\"nofollow\">5th generation project</a>.</p>\n<p>Prolog went out of favor because <a href=\"https://synthese.wordpress.com/2010/08/21/prologs-death/\" rel=\"nofollow\">it was difficult to trace the execution of Prolog programs</a>\u2014which made debugging very challenging.</p>\n<p>Structurally, Prolog is both one of the simplest of all programming languages\u2014you can learn it very quickly\u2014and one of the most interesting. It is quite different from virtually all other programming languages. In Prolog you make assertions of facts and then pose questions about those facts. Answers are <em>unified</em> with (rather than assigned to) variables.  Prolog is seductively elegant and powerful.</p>\n<p>We can look a few examples <a href=\"https://swish.swi-prolog.org/p/kb_rja.pl\" rel=\"nofollow\">here</a>.</p>\n<h2>SWI-Prolog</h2>\n<p><a href=\"http://www.swi-prolog.org/\" rel=\"nofollow\">SWI-Prolog</a> has kept the Prolog flame burning and seems to have developed a successful community of Prolog users.</p>\n<dl>\n<dt>From the <a href=\"http://www.swi-prolog.org/features.html\" rel=\"nofollow\">SWI-Prolog website</a></dt>\n<dd> SWI-Prolog is a versatile implementation of the <a href=\"https://en.wikipedia.org/wiki/Prolog\" rel=\"nofollow\">Prolog language</a>. Although SWI-Prolog gained its popularity primarily in education, its development is mostly driven by the needs for application development. This is facilitated by a rich interface to other IT components by supporting many document types and (network) protocols as well as a comprehensive low-level interface to C that is the basis for high-level interfaces to C++, Java (bundled), C#, Python, etc (externally available). Data type extensions such as dicts and strings as well as full support for Unicode and unbounded integers simplify smooth exchange of data with other components.<br><br>\nSWI-Prolog aims at scalability. Its robust support for multi-threading exploits multi-core hardware efficiently and simplifies embedding in concurrent applications. Its Just In Time Indexing (JITI) provides transparent and efficient support for predicates with millions of clauses.</dd>\n</dl>\n<h2>Prolog tutorials</h2>\n<ul>\n<li>\n<p>Blackburn, Patrick, Johan Bos, and Kristina Striegnitz (2012) <a href=\"http://lpn.swi-prolog.org/lpnpage.php?pageid=online\" rel=\"nofollow\"><em>Learn Prolog Now!</em></a> (This version of the book is embedded in SWI Prolog\u2019s <a href=\"http://swish.swi-prolog.org/\" rel=\"nofollow\">SWI SH</a> (<a href=\"http://www.swi-prolog.org/\" rel=\"nofollow\">SWI-Prolog</a> for SHaring), an online Prolog interpreter similar to Jupyter.)</p>\n</li>\n<li>\n<p>Wilson, Bill, <a href=\"http://www.cse.unsw.edu.au/%7Ebillw/cs9414/notes/prolog/intro.html\" rel=\"nofollow\">\"Introduction to Prolog Programming,\"</a> for the course COMP9414/9814 \"Artificial Intelligence.\" Consists mostly of extracts from the first five chapters of</p>\n<ul>\n<li>Bratko, I. (2011) <a href=\"https://www.amazon.com/gp/product/0321417461/ref=dbs_a_def_rwt_hsch_vapi_taft_p1_i0\" rel=\"nofollow\"><em>Programming in Prolog for Artificial Intelligence</em></a>, 4th Edition, Addison-Wesley.</li>\n</ul>\n</li>\n<li>\n<p>Piumarta, Ian (2017) <a href=\"http://www.ritsumei.ac.jp/%7Epiumarta/pl/\" rel=\"nofollow\">\"Programming-language-paradigms\"</a> (a course).  \u201cLogic programming and Prolog\u201d is explored in week 5 (<a href=\"http://www.ritsumei.ac.jp/%7Epiumarta/pl/slides/PL-05.pdf\" rel=\"nofollow\">slides-5</a>, <a href=\"http://www.ritsumei.ac.jp/%7Epiumarta/pl/ex/PL-05-ex.pdf\" rel=\"nofollow\">exercises-5</a>), week 6 (<a href=\"http://www.ritsumei.ac.jp/%7Epiumarta/pl/slides/PL-06.pdf\" rel=\"nofollow\">slides-6</a>, <a href=\"http://www.ritsumei.ac.jp/%7Epiumarta/pl/ex/PL-06-ex.pdf\" rel=\"nofollow\">exercises-6</a>), and week 7 (<a href=\"http://www.ritsumei.ac.jp/%7Epiumarta/pl/slides/PL-07.pdf\" rel=\"nofollow\">slides-7</a>, <a href=\"http://www.ritsumei.ac.jp/%7Epiumarta/pl/ex/PL-07-ex.pdf\" rel=\"nofollow\">exercises-7</a>). Week 7 is a Prolog tutorial. You should be able to understand it without first reading weeks 5 and 6. But those weeks are important. They show how to  implement many Prolog features in Python.</p>\n</li>\n</ul>\n<h2>Pylog: prolog in Python</h2>\n<p>This repository is a Python implementation of many Prolog features. It is a fork of Piumarta\u2019s <a href=\"http://www.ritsumei.ac.jp/%7Epiumarta/pl/src/unify.py\" rel=\"nofollow\"><code>unify.py</code></a>.</p>\n<p>As an introductory example, consider the following (Python) code\u2014adapted from <a href=\"http://www.ritsumei.ac.jp/%7Epiumarta/pl/ex/PL-05-ex.py\" rel=\"nofollow\">Piumarta's week 5 exercises</a>. (You can run it <a href=\"https://colab.research.google.com/drive/1BkWBGY0GpOYqHLpyylzbPU9OLdyqxSmk\" rel=\"nofollow\">here</a>.) (The type annotations are not required, but they are useful to understand what's going on.)</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">typing</span> <span class=\"kn\">import</span> <span class=\"n\">Generator</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">isEven</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">Generator</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">]:</span>\n    <span class=\"k\">if</span> <span class=\"n\">i</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'</span><span class=\"si\">{</span><span class=\"n\">i</span><span class=\"si\">}</span><span class=\"s1\">-even'</span><span class=\"p\">,</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"s1\">', '</span><span class=\"p\">)</span>\n        <span class=\"k\">yield</span> \n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'</span><span class=\"si\">{</span><span class=\"n\">i</span><span class=\"si\">}</span><span class=\"s1\">-odd'</span><span class=\"p\">,</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"s1\">', '</span><span class=\"p\">)</span>\n\n<span class=\"n\">evens</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"n\">isEven</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)]</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'</span><span class=\"se\">\\n</span><span class=\"si\">{</span><span class=\"n\">evens</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n</pre>\n<p>Can you figure out how the preceding produces these results?</p>\n<pre><span class=\"mi\">0</span><span class=\"o\">-</span><span class=\"n\">even</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"n\">odd</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"o\">-</span><span class=\"n\">even</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"o\">-</span><span class=\"n\">odd</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"o\">-</span><span class=\"n\">even</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"o\">-</span><span class=\"n\">odd</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"o\">-</span><span class=\"n\">even</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"o\">-</span><span class=\"n\">odd</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"o\">-</span><span class=\"n\">even</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"o\">-</span><span class=\"n\">odd</span><span class=\"p\">,</span>\n<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">]</span> \n</pre>\n<p>In particular, what does</p>\n<pre><span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"n\">isEven</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span>\n</pre>\n<p>do in the list comprehension?</p>\n<p>In Prolog, program components are understood as predicates. They may <em>succeed</em> or <em>fail</em>. To succeed/fail means that the system was/was not able to establish that the predicate holds given the information available.</p>\n<p>Success or failure is implemented in Python through generators. A generator that <strong>yield</strong>s a result (at the Python level) is said to succeed (at the Prolog level); one that does not <strong>yield</strong> a result, fails (at the Prolog level).</p>\n<p>In this case, <code>isEven(i)</code> succeeds/fails when <code>i</code> is even/odd. (In either case it produces an output line.) When</p>\n<pre><span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"n\">isEven</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span>\n</pre>\n<p>succeeds/fails for a given <code>i</code>, the list comprehension completes/fails to complete the iteration for that <code>i</code> and includes/does not include <code>i</code> in the generated list.</p>\n<h2>Implementing logic variables and unification in Python</h2>\n<p><em>To be written</em></p>\n<h2>Implementing Prolog backtracking in Python</h2>\n<p><em>To be written</em></p>\n<h2>File organization (not recently updated)</h2>\n<pre><code>pylog                            -- Root directory\n    examples                     -- A directory of example pylog programs\n        n_queens.py              -- The traditional n-queens problem. Uses minimal pylog features but illustrates the pylog style.\n        puzzles.py               -- A file containing information common to the scholarship_problem and the zebra_problem\n        scholarship_problem.py   -- A traditional Prolog logic puzzle\u2014less complex than the zebra problem\n        trains.py                -- A revised version of the train example from Piumarta\n        zebra_problem.py         -- The well-known logic puzzle often solved with Prolog\n    sequence_options             -- A directory of options for lists and sequences\n        linked_list.py           -- A traditional head/tail list structure. Allows a variable tail, which Python does not\n        sequences.py             -- Implementations of Python lists and tuples\n        super_sequence.py        -- A class that serves as a superclass for all the sequences\n    control_structures.py        -- Implementation of the Prolog control structures\n    logic_variables.py           -- Implementation of Prolog's logic variables\n</code></pre>\n<h2>File dependencies/<code>imports from</code> relations (not recently updated)</h2>\n<pre><code>logic_variables: none\ncontrol_structures: logic_variables\n\nsuper_sequence: control_structures, logic_variables\nlinked_list and sequences: logic_variables, super_sequence\n\nn_queens: logic_variables, sequences\ntrains: control_structures, logic_variables, sequences\npuzzle: super_sequence\nscholarship_problem and zebra_problem: control_structures, logic_variables, puzzles, super_sequence\n\n</code></pre>\n<h2>Naming conventions</h2>\n<p>For the most part, Python identifier names follow PEP 8 conventions: all lower case, with underscores between words; no camel case except for class names.</p>\n<p>However, since Prolog uses identifiers that begin with an upper case letter for Prolog variables, Python identifiers used as Prolog variables begin with upper case letters.</p>\n<h2>Previous work</h2>\n<ul>\n<li>\n<p>Berger, Shai (2004) <a href=\"http://code.activestate.com/recipes/303057-pythologic-prolog-syntax-in-python/\" rel=\"nofollow\">Pythologic</a></p>\n</li>\n<li>\n<p>Bolz, Carl Friedrich (2007) <a href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.121.8625&amp;rep=rep1&amp;type=pdf\" rel=\"nofollow\">A Prolog Interpreter in Python</a></p>\n</li>\n<li>\n<p>Delord, Christophe (2009) <a href=\"http://cdsoft.fr/pylog/index.html\" rel=\"nofollow\">PyLog</a></p>\n</li>\n<li>\n<p>Frederiksen, Bruce Frederiksen (2011) <a href=\"http://pyke.sourceforge.net/\" rel=\"nofollow\">Pyke</a></p>\n</li>\n<li>\n<p>Kopec, David (2019) <a href=\"https://freecontent.manning.com/constraint-satisfaction-problems-in-python/\" rel=\"nofollow\">Constraint-Satisfaction Problems in Python</a> from <em><a href=\"https://www.manning.com/books/classic-computer-science-problems-in-python\" rel=\"nofollow\">Classic Computer Science Problems in Python</a></em>, Manning (<a href=\"https://github.com/davecom/ClassicComputerScienceProblemsInPython/tree/master/Chapter3\" rel=\"nofollow\">GitHub code repository</a>)</p>\n</li>\n<li>\n<p>Maxime, Istasse (2016) <a href=\"https://github.com/mistasse/Prology\" rel=\"nofollow\">Prology: Logic programming for Python3</a></p>\n</li>\n<li>\n<p>Meyers, Chris (2015) <a href=\"http://www.openbookproject.net/py4fun/countClick.php?dest=prolog/intro.html\" rel=\"nofollow\">Prolog in Python</a></p>\n</li>\n<li>\n<p>Niemeyer, Gustavo and S\u00e9bastien Celles (2019). <a href=\"https://github.com/python-constraint/python-constraint\" rel=\"nofollow\">python-constraint</a>. Pypi page: <a href=\"https://pypi.org/project/python-constraint/\" rel=\"nofollow\">python-constraint</a> (Also discussed in Popovi\u0107, Olivera (2019) <a href=\"https://stackabuse.com/constraint-programming-with-python-constraint/#listofbuiltinconstraints\" rel=\"nofollow\">Constraint Programming with python-constraint</a>)</p>\n</li>\n<li>\n<p>Orsini, Francesc, Paolo Frasconi, Luc De Raedt (2017) <a href=\"https://link.springer.com/article/10.1007/s10994-017-5668-y\" rel=\"nofollow\">kProbLog: an algebraic Prolog for machine learning</a> (This seems more like a theoretical discussion of kProbLog, which was implementated in Python, rather than an integraton of Python and Prolog. It's a worthwhile distinction to make. One can implement Prolog in any general purpose language. Pylog is notable because it integrates Python and Prolog.)</p>\n</li>\n<li>\n<p>Python Foundation <a href=\"https://docs.python.org/3/library/re.html\" rel=\"nofollow\">re: Regular expression operations</a></p>\n</li>\n<li>\n<p>Rocklin, Matthew (2015) <a href=\"https://github.com/mrocklin/unification\" rel=\"nofollow\">Unification</a></p>\n</li>\n<li>\n<p>Rocklin, Matthew (2019) <a href=\"https://github.com/logpy/logpy/\" rel=\"nofollow\">kanren: Logic Programming in Python</a> (The author of <a href=\"https://toolz.readthedocs.io/en/latest/index.html\" rel=\"nofollow\">toolz</a>)</p>\n</li>\n<li>\n<p>Santini, Claudio (2018) <a href=\"https://github.com/santinic/pampy\" rel=\"nofollow\">Pampy: The Pattern Matching for Python you always dreamed of</a></p>\n</li>\n<li>\n<p>Stack Overflow questions.</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/49101342/implementing-the-prolog-unification-algorithm-in-python-backtracking\" rel=\"nofollow\">Implementing the Prolog Unification algorithm in Python? Backtracking</a></li>\n<li><a href=\"https://stackoverflow.com/questions/1917607/relational-logic-programming-in-python\" rel=\"nofollow\">Relational/Logic Programming in Python?</a></li>\n</ul>\n</li>\n<li>\n<p>Thompson, Jeff (2017) <a href=\"http://yieldprolog.sourceforge.net/\" rel=\"nofollow\">Yield Prolog</a></p>\n</li>\n<li>\n<p>Triska, Markus <a href=\"http://www.swi-prolog.org/man/clpfd.html\" rel=\"nofollow\">CLP(FD): Constraint Logic Programming over Finite Domains</a> (also <a href=\"http://www.swi-prolog.org/pldoc/man?section=clpfd\" rel=\"nofollow\">CLP(FD): Constraint Logic Programming over Finite Domains</a> (Repo of <a href=\"https://github.com/triska/clpz\" rel=\"nofollow\">examples</a>)</p>\n</li>\n</ul>\n\n          </div>"}, "last_serial": 5795281, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "36fa8286065ff8552faf0c58890ddda2", "sha256": "86e7c38cf1006881d72be426febb2b45cc37e68423f206795ba0c089884f2909"}, "downloads": -1, "filename": "pylog-1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "36fa8286065ff8552faf0c58890ddda2", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 16571, "upload_time": "2019-07-22T01:08:19", "upload_time_iso_8601": "2019-07-22T01:08:19.455598Z", "url": "https://files.pythonhosted.org/packages/86/31/df94b317ae527670088272cd510f7c3607be978422b58fecbe999bef7a43/pylog-1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4b2dc5de78d57a52a7ebed47e007f91a", "sha256": "55a7ce9a42fb3e4ccc56ab3ea0ed113b780258638ccfa9e08b1ea5c735179d6a"}, "downloads": -1, "filename": "pylog-1.0.tar.gz", "has_sig": false, "md5_digest": "4b2dc5de78d57a52a7ebed47e007f91a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 22275, "upload_time": "2019-07-22T01:08:22", "upload_time_iso_8601": "2019-07-22T01:08:22.118443Z", "url": "https://files.pythonhosted.org/packages/15/43/902122525b15b975dd6d99d1e9de0bc99184961ece1de008f1d3716360b5/pylog-1.0.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "f8c0bbfde308a84a6594b1b523eea05b", "sha256": "e04ebdad682d48746f2c20a25896b8919feb6481c5507a1c0afb346565b5d7b3"}, "downloads": -1, "filename": "pylog-1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "f8c0bbfde308a84a6594b1b523eea05b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 24833, "upload_time": "2019-09-07T07:11:52", "upload_time_iso_8601": "2019-09-07T07:11:52.440227Z", "url": "https://files.pythonhosted.org/packages/14/3e/e20b3e8fb78eb7f1629efb4fc77290df02566e683bf41a7abe2e8dc5405c/pylog-1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4c8b350e4317a7be4a29bb7241346980", "sha256": "a053aa2e8d885691dd3585a3e3192b24a03af6298f557ba4907213f27a1ef415"}, "downloads": -1, "filename": "pylog-1.1.tar.gz", "has_sig": false, "md5_digest": "4c8b350e4317a7be4a29bb7241346980", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 28426, "upload_time": "2019-09-07T07:11:54", "upload_time_iso_8601": "2019-09-07T07:11:54.085522Z", "url": "https://files.pythonhosted.org/packages/fa/1a/67f294296c23d87e50e4699cbd157bb44214c6ec29804dc848d8509800ac/pylog-1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f8c0bbfde308a84a6594b1b523eea05b", "sha256": "e04ebdad682d48746f2c20a25896b8919feb6481c5507a1c0afb346565b5d7b3"}, "downloads": -1, "filename": "pylog-1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "f8c0bbfde308a84a6594b1b523eea05b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7", "size": 24833, "upload_time": "2019-09-07T07:11:52", "upload_time_iso_8601": "2019-09-07T07:11:52.440227Z", "url": "https://files.pythonhosted.org/packages/14/3e/e20b3e8fb78eb7f1629efb4fc77290df02566e683bf41a7abe2e8dc5405c/pylog-1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "4c8b350e4317a7be4a29bb7241346980", "sha256": "a053aa2e8d885691dd3585a3e3192b24a03af6298f557ba4907213f27a1ef415"}, "downloads": -1, "filename": "pylog-1.1.tar.gz", "has_sig": false, "md5_digest": "4c8b350e4317a7be4a29bb7241346980", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7", "size": 28426, "upload_time": "2019-09-07T07:11:54", "upload_time_iso_8601": "2019-09-07T07:11:54.085522Z", "url": "https://files.pythonhosted.org/packages/fa/1a/67f294296c23d87e50e4699cbd157bb44214c6ec29804dc848d8509800ac/pylog-1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:02:52 2020"}