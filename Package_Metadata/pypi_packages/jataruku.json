{"info": {"author": "Deniz Bozyigit", "author_email": "deniz195@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice, this\n  list of conditions and the following disclaimer in the documentation and/or\n  other materials provided with the distribution.\n\n* The code must not be modified to destroy the extant physical universe.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nDescription: jataruku\n        ========\n        \n        This project provides a PID controller written in Python3 in contrast to the orignal. The original is made by Jeremy Bornstein This is based on [the Arduino PID code written by Brett Beauregard](https://github.com/br3ttb/Arduino-PID-Library).\n        \n        Brett's code is the result of much research and thought on his part, which\n        he has [generously documented](http://brettbeauregard.com/blog/2011/04/improving-the-beginners-pid-introduction/).\n        Most of what I did is translate it into a form which I hope can be easily\n        used if you are implementing a system in Python that wants to use PID\n        control.\n        \n        How to Use\n        ----------\n        \n        The module exports only one object, a class called PID. The best way\n        to learn how to use it is to look at the test.py file (see below).\n        \n        The second-best way to learn how to use it is to keep reading this\n        section.\n        \n        The PID object must be constructed with the following parameters:\n        \n        * ``input``: a lambda which reports the input value, e.g. the temperature of the object the temperature of which is being controlled\n        \n        * ``output``: a function which controls the output setting, e.g. whether\n          or not the heater is turned on or not. it takes a single parameter,\n          which is the value that the output object should receive\n        \n        * ``setpoint``: the target value for input, e.g. the desired temperature\n          of the object in question\n        \n        * ``kp``, ``ki``, and ``kd``: the three PID parameters.  (If you don't know\n          what they are you should [go read about how PIDs work](http://en.wikipedia.org/wiki/PID_controller), though you may\n          be able to get away with using defaults based on the test code herein.)\n        \n        * ``direct``: True if an increase in the output value will produce an\n          increase in the input value, False otherwise\n        \n        ``pid = PID(input, output, setpoint, kp, ki, kd, direct)``\n        \n        After the object has been created, turn PID control on with ``pid.auto = True``,\n        and set the range of your output control with ``pid.set_output_limits(min_out, max_out)``.\n        At that point you can just call ``pid.compute()`` as\n        frequently as possible, preferably via an interrupt of some sort. The\n        frequency required for good results will depend on the characteristics\n        of your entire system, but the default update frequency of 100\n        milliseconds is probably a good place to start. If the system is\n        working, then the input value will approach the set point and stay there.\n        \n        You can change the system back and forth from automatic to manual mode at\n        any time by setting ``pid.auto`` to ``False`` (for manual control) or ``True``\n        (for automatic).\n        \n        If you want to change the sample rate, set ``pid.sample_time`` to a number\n        of milliseconds. The default value is ``100``. If you want to change the\n        set point, just set ``pid.setpoint``, and if you want to re-set any of the\n        PID parameters you can call ``pid.set_tunings(kp, ki, kd)``. The system should\n        be pretty reasonable under these changes.\n        \n        Testing\n        -------\n        \n        Since a PID is inherently real-time and dependent on external systems,\n        you can't really write code to test it quickly without decoupling it\n        from the wall clock or having an external system with which to integrate it.\n        In order to prove to myself that it basically works, I wrote a very simple\n        simulation of a heater attached to a tank of water, and some tests to\n        see what the PIDs behavior is when attached to the heater simulation.\n        The heater, when turned on, heats up at a certain rate, and if its\n        temperature is above the ambient temperature will\n        lose a certain amount of heat to the environment over time.\n        \n        The first test should demonstrate that the dummy heater is basically working.\n        \n            test.py 0\n        \n        The second test should demonstrate that the system can bring the water to\n        a given temperature and hold it there.\n        \n            test.py 1\n        \n        \n        Caveats\n        -------\n        \n        This is basically first draft code. Since the object is relatively straightforward there's\n        hardly any need. If this bothers you, go ahead and add them,\n        though it is not inconceivable that I would eventually get around to it\n        myself. Nevertheless, it should be usable as-is without too much\n        difficulty.\n        \n        This code depends on ``pid.compute()`` being called at a predictable interval. It won't\n        work as well under conditions which delay the call by too much, such as\n        use under a non-real-time operating system which is trying to do too\n        many things.\n        \n        There are other PID features which could be added to make this even\n        better. I'm not even sure I know what they are. If you do, feel free\n        to write them and submit a pull request.\n        \n        P.S. \"jataruku\" is a word in the Warlpiri language which according to\n        [the Australian Society for Indigenous Languages' Walpiri lexicon](http://ausil.org/Dictionary/Warlpiri/lexicon/index.htm) means\n        \"stubborn, bullheaded, hot-tempered.\"\n        \nPlatform: UNKNOWN\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/deniz195/jataruku", "keywords": "", "license": "Copyright &copy; 2013, Jeremy Bornstein", "maintainer": "", "maintainer_email": "", "name": "jataruku", "package_url": "https://pypi.org/project/jataruku/", "platform": "", "project_url": "https://pypi.org/project/jataruku/", "project_urls": {"Homepage": "https://github.com/deniz195/jataruku"}, "release_url": "https://pypi.org/project/jataruku/0.1.1/", "requires_dist": null, "requires_python": "", "summary": "A PID controller written in Python3", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            All rights reserved.<br><br>Redistribution and use in source and binary forms, with or without modification,<br>are permitted provided that the following conditions are met:<br><br>* Redistributions of source code must retain the above copyright notice, this<br>  list of conditions and the following disclaimer.<br><br>* Redistributions in binary form must reproduce the above copyright notice, this<br>  list of conditions and the following disclaimer in the documentation and/or<br>  other materials provided with the distribution.<br><br>* The code must not be modified to destroy the extant physical universe.<br><br>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND<br>ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED<br>WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE<br>DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR<br>ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES<br>(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;<br>LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON<br>ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT<br>(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS<br>SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.<br><br>Description: jataruku<br>        ========<br>        <br>        This project provides a PID controller written in Python3 in contrast to the orignal. The original is made by Jeremy Bornstein This is based on [the Arduino PID code written by Brett Beauregard](https://github.com/br3ttb/Arduino-PID-Library).<br>        <br>        Brett's code is the result of much research and thought on his part, which<br>        he has [generously documented](http://brettbeauregard.com/blog/2011/04/improving-the-beginners-pid-introduction/).<br>        Most of what I did is translate it into a form which I hope can be easily<br>        used if you are implementing a system in Python that wants to use PID<br>        control.<br>        <br>        How to Use<br>        ----------<br>        <br>        The module exports only one object, a class called PID. The best way<br>        to learn how to use it is to look at the test.py file (see below).<br>        <br>        The second-best way to learn how to use it is to keep reading this<br>        section.<br>        <br>        The PID object must be constructed with the following parameters:<br>        <br>        * ``input``: a lambda which reports the input value, e.g. the temperature of the object the temperature of which is being controlled<br>        <br>        * ``output``: a function which controls the output setting, e.g. whether<br>          or not the heater is turned on or not. it takes a single parameter,<br>          which is the value that the output object should receive<br>        <br>        * ``setpoint``: the target value for input, e.g. the desired temperature<br>          of the object in question<br>        <br>        * ``kp``, ``ki``, and ``kd``: the three PID parameters.  (If you don't know<br>          what they are you should [go read about how PIDs work](http://en.wikipedia.org/wiki/PID_controller), though you may<br>          be able to get away with using defaults based on the test code herein.)<br>        <br>        * ``direct``: True if an increase in the output value will produce an<br>          increase in the input value, False otherwise<br>        <br>        ``pid = PID(input, output, setpoint, kp, ki, kd, direct)``<br>        <br>        After the object has been created, turn PID control on with ``pid.auto = True``,<br>        and set the range of your output control with ``pid.set_output_limits(min_out, max_out)``.<br>        At that point you can just call ``pid.compute()`` as<br>        frequently as possible, preferably via an interrupt of some sort. The<br>        frequency required for good results will depend on the characteristics<br>        of your entire system, but the default update frequency of 100<br>        milliseconds is probably a good place to start. If the system is<br>        working, then the input value will approach the set point and stay there.<br>        <br>        You can change the system back and forth from automatic to manual mode at<br>        any time by setting ``pid.auto`` to ``False`` (for manual control) or ``True``<br>        (for automatic).<br>        <br>        If you want to change the sample rate, set ``pid.sample_time`` to a number<br>        of milliseconds. The default value is ``100``. If you want to change the<br>        set point, just set ``pid.setpoint``, and if you want to re-set any of the<br>        PID parameters you can call ``pid.set_tunings(kp, ki, kd)``. The system should<br>        be pretty reasonable under these changes.<br>        <br>        Testing<br>        -------<br>        <br>        Since a PID is inherently real-time and dependent on external systems,<br>        you can't really write code to test it quickly without decoupling it<br>        from the wall clock or having an external system with which to integrate it.<br>        In order to prove to myself that it basically works, I wrote a very simple<br>        simulation of a heater attached to a tank of water, and some tests to<br>        see what the PIDs behavior is when attached to the heater simulation.<br>        The heater, when turned on, heats up at a certain rate, and if its<br>        temperature is above the ambient temperature will<br>        lose a certain amount of heat to the environment over time.<br>        <br>        The first test should demonstrate that the dummy heater is basically working.<br>        <br>            test.py 0<br>        <br>        The second test should demonstrate that the system can bring the water to<br>        a given temperature and hold it there.<br>        <br>            test.py 1<br>        <br>        <br>        Caveats<br>        -------<br>        <br>        This is basically first draft code. Since the object is relatively straightforward there's<br>        hardly any need. If this bothers you, go ahead and add them,<br>        though it is not inconceivable that I would eventually get around to it<br>        myself. Nevertheless, it should be usable as-is without too much<br>        difficulty.<br>        <br>        This code depends on ``pid.compute()`` being called at a predictable interval. It won't<br>        work as well under conditions which delay the call by too much, such as<br>        use under a non-real-time operating system which is trying to do too<br>        many things.<br>        <br>        There are other PID features which could be added to make this even<br>        better. I'm not even sure I know what they are. If you do, feel free<br>        to write them and submit a pull request.<br>        <br>        P.S. \"jataruku\" is a word in the Warlpiri language which according to<br>        [the Australian Society for Indigenous Languages' Walpiri lexicon](http://ausil.org/Dictionary/Warlpiri/lexicon/index.htm) means<br>        \"stubborn, bullheaded, hot-tempered.\"<br>        <br>Platform: UNKNOWN<br>\n          </div>"}, "last_serial": 4330513, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "63594e595a2592cb6361a05b7706a697", "sha256": "8861bf2a638a8db3b8f20fe63cdfdde61a88e7753bc79d3ddafe8b6670848614"}, "downloads": -1, "filename": "jataruku-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "63594e595a2592cb6361a05b7706a697", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 4931, "upload_time": "2018-10-01T22:08:13", "upload_time_iso_8601": "2018-10-01T22:08:13.523082Z", "url": "https://files.pythonhosted.org/packages/c4/46/21e65706544ccc17d68ba1a2083f2ec3b7f211fb9b775b9a4a3227f035a0/jataruku-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1d8b42f6fb6b97cf9d5c0eed4eec727d", "sha256": "e2fa0ef64e01a1026b802021d70931a011bb6d8016b493a9584ce5b77d5354e8"}, "downloads": -1, "filename": "jataruku-0.1.0.tar.gz", "has_sig": false, "md5_digest": "1d8b42f6fb6b97cf9d5c0eed4eec727d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4303, "upload_time": "2018-10-01T22:08:14", "upload_time_iso_8601": "2018-10-01T22:08:14.755269Z", "url": "https://files.pythonhosted.org/packages/d9/d2/7347f3169e2acd6895893b0995dca60b70d0bb275cdae196d2a245e71c4d/jataruku-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "cd42465be750d4556e7d19226d87a5c9", "sha256": "2775cfa5aa8bf89a8571524ee8a877d8018f677940037c629adf63e954291117"}, "downloads": -1, "filename": "jataruku-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "cd42465be750d4556e7d19226d87a5c9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 6541, "upload_time": "2018-10-01T22:24:02", "upload_time_iso_8601": "2018-10-01T22:24:02.373127Z", "url": "https://files.pythonhosted.org/packages/5d/cc/38683e0e1752e82a31c74e3afb09fdf5574d6d9a2e1594f84effd2b18997/jataruku-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b306694960b512e9b87024946c84d959", "sha256": "829ac4fd0531e4ce87a9a7a119ea89831c7d27dd9a91ae9d34dc386033cf9f37"}, "downloads": -1, "filename": "jataruku-0.1.1.tar.gz", "has_sig": false, "md5_digest": "b306694960b512e9b87024946c84d959", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5651, "upload_time": "2018-10-01T22:24:03", "upload_time_iso_8601": "2018-10-01T22:24:03.604023Z", "url": "https://files.pythonhosted.org/packages/0c/36/b43ce366baabb275f61f6a31c1318ffd51e08dbf831782af1b749f9299e8/jataruku-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "cd42465be750d4556e7d19226d87a5c9", "sha256": "2775cfa5aa8bf89a8571524ee8a877d8018f677940037c629adf63e954291117"}, "downloads": -1, "filename": "jataruku-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "cd42465be750d4556e7d19226d87a5c9", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 6541, "upload_time": "2018-10-01T22:24:02", "upload_time_iso_8601": "2018-10-01T22:24:02.373127Z", "url": "https://files.pythonhosted.org/packages/5d/cc/38683e0e1752e82a31c74e3afb09fdf5574d6d9a2e1594f84effd2b18997/jataruku-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "b306694960b512e9b87024946c84d959", "sha256": "829ac4fd0531e4ce87a9a7a119ea89831c7d27dd9a91ae9d34dc386033cf9f37"}, "downloads": -1, "filename": "jataruku-0.1.1.tar.gz", "has_sig": false, "md5_digest": "b306694960b512e9b87024946c84d959", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5651, "upload_time": "2018-10-01T22:24:03", "upload_time_iso_8601": "2018-10-01T22:24:03.604023Z", "url": "https://files.pythonhosted.org/packages/0c/36/b43ce366baabb275f61f6a31c1318ffd51e08dbf831782af1b749f9299e8/jataruku-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:53:05 2020"}