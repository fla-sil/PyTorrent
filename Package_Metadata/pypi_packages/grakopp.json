{"info": {"author": "Marcus Brinkmann", "author_email": "m.brinkmann@semantics.de", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Console", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: BSD License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: C++", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.4", "Topic :: Software Development :: Code Generators", "Topic :: Software Development :: Compilers", "Topic :: Software Development :: Interpreters", "Topic :: Text Processing :: General"], "description": "**Work in progress!**\n\n|Build Status|\n\nGrako++\n=======\n\nGrako++ is a packrat parser runtime for Grako, written in C++. The aim\nis to provide a Grako-compatible parser generator, but with improved\nperformance over Python.\n\nDifferences to Grako\n--------------------\n\n* The output is always AST/JSON.\n* The semantics class can be implemented in C++ or Cython (pure Python\n  through Cython is planned).\n* The regular expression syntax is\n  `ECMAScript <http://www.cplusplus.com/reference/regex/ECMAScript/>`__,\n  not Python.\n* Some features of Grako are missing, see below in the TODO section.\n* State types must implement operator< for std::map (for future\n  flexibility, consider implementing the hash trait, too).\n\nBuild\n-----\n\nThe library is header-files only currently, so you can just copy the\nfiles in include/ to a convenient location, or build from there. More\nformally, you can use cmake.\n\nBuild with clang by invoking: cmake -DCMAKE\\_CXX\\_COMPILER=/path/to/clang++\n\nBuilding with g++ < 4.9 requires linking with the boost\\_regex library,\nbecause the std::regex implementation is broken. You can rely on the\nexported cmake library file to configure the right settings.\n\nOther useful option: -DCMAKE\\_INSTALL\\_PREFIX:PATH=/path/to/install\n\nUsage\n-----\n\nThe grakopp program is used like grako to compile PEG files to source\ncode. There are four different source code output formats that can be\nspecified with the -f/--format option:\n\n+------------+-------------+-------------------------+\n| --format   | --output    | Purpose                 |\n+============+=============+=========================+\n| hpp        | name.hpp    | C++ declaration         |\n+------------+-------------+-------------------------+\n| cpp        |  name.cpp   | C++ implementation      |\n+------------+-------------+-------------------------+\n| pxd        | name.pxd    | Cython declaration      |\n+------------+-------------+-------------------------+\n| pyx        | name.pyx    | Cython implementation   |\n+------------+-------------+-------------------------+\n\nFor pure C++ parsers, generating the hpp and cpp files is sufficient.\nFor Python integration, the pxd and pyx files are also needed. For\n\"name\" you should subsitute the actual name of the parser (either the\nbase name of the PEG file or the argument to the --name option). The\nfilenames are, for now, hard-coded into the source files (the underscore\nprotects the C++ implementation from Cython-generated source files).\n\nHere is an example how to build a parser:\n\n.. code:: sh\n\n    $ ./grakopp -f hpp -o _basic.hpp tests/basic/basic.peg\n    $ ./grakopp --whitespace=\"\" --no-nameguard -f cpp -o _basic.cpp tests/basic/basic.peg\n    $ g++ -DGRAKOPP_MAIN -std=c++11 -Iinclude -O4 -o basic _basic.cpp -lboost_regex\n\nYou can invoke the parser like a Python parser generated with grako\n(currently, no options are supported, though, except for an internal\noption --test that compares the AST with a text fixture file):\n\n.. code:: sh\n\n    $ echo -n e1e2 | ./basic /dev/stdin sequence\n    [\n        \"e1\",\n        \"e2\"\n    ]\n\nC++ Interface\n-------------\n\nThe following header files exist:\n\n+-----------------------+---------------------------+\n| Header                | Purpose                   |\n+=======================+===========================+\n| grakopp/exception.hpp | Parser exceptions         |\n+-----------------------+---------------------------+\n| grakopp/buffer.hpp    | Buffer for I/O            |\n+-----------------------+---------------------------+\n| grakopp/ast.hpp       | AST implementation        |\n+-----------------------+---------------------------+\n| grakopp/parser.hpp    | Parser base class         |\n+-----------------------+---------------------------+\n| grakopp/grakopp/hpp   | Include all above         |\n+-----------------------+---------------------------+\n| grakopp/ast-io.hpp    | Optional AST stream I/O   |\n+-----------------------+---------------------------+\n\nPython Integration\n------------------\n\nUntil the Python package is prepared properly, build the Cython\nextensions manually, for example like this:\n\n.. code:: sh\n\n    $ cd python/grakopp\n    $ cython --cplus buffer.pyx\n    $ cython --cplus ast.pyx\n    $ g++ -std=c++11 -I../../include -shared -pthread -fPIC -fwrapv -O2 -Wall -fno-strict-aliasing -I/usr/include/python2.7 -o buffer.so buffer.cpp \n    $ g++ -std=c++11 -I../../include -shared -pthread -fPIC -fwrapv -O2 -Wall -fno-strict-aliasing -I/usr/include/python2.7 -o ast.so ast.cpp \n    $ cd ../..\n\nTo continue the above example:\n\n.. code:: sh\n\n    $ ./grakopp -f pxd -o basic.pxd tests/basic/basic.peg\n    $ ./grakopp -f pyx -o basic.pyx tests/basic/basic.peg\n    $ cython -Ipython --cplus basic.pyx\n    $ g++ -std=c++11 -Iinclude -shared -pthread -fPIC -fwrapv -O2 -Wall -fno-strict-aliasing -I/usr/include/python2.7 -o basic.so basic.cpp _basic.cpp -l boost_regex\n\nYou can then use it from Python:\n\n::\n\n    $ PYTHONPATH=python python\n    >>> from grakopp import buffer\n    >>> b = buffer.PyBuffer()\n    >>> b.from_string(\"e1e2\")\n    >>> import basic\n    >>> p = basic.basicPyParser()\n    >>> p.set_buffer(b)\n    >>> a = p._sequence_()\n    >>> a.to_python()\n    ['e1', 'e2']\n    >>> b.pos\n    4\n    >>> a = p._sequence_()\n    >>> a.to_python()\n    FailedToken('e1')\n\nTODO\n----\n\n* dynamic Ast objects (so you can pass through Python or XML objects)\n* python/distutils integration\n* automatic compilation a la pyximport\n* add namespace\n* unicode support?\n* more support and tests for stateful parsing\n* regex syntax tests (make sure generated C strings are always proper)\n* profile and optimize\n\nGrako features missing:\n\n* ignorecase (buffer match, matchre)\n* comments skipping\n* buffer line parsing and trace output (also in exceptions)\n* ParseInfo\n* rules with arguments\n* left recursion\n* semantic action \"\\_default\"\n\nAuthors\n-------\n\n::\n\n    Copyright (C) 2014 semantics Kommunikationsmanagement GmbH\n    Written by Marcus Brinkmann <m.brinkmann@semantics.de>\n    See LICENSE.txt for details.\n\n.. |Build Status| image:: https://travis-ci.org/lambdafu/grakopp.png\n   :target: https://travis-ci.org/lambdafu/grakopp", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/lambdafu/grakopp", "keywords": "grako parser peg", "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "grakopp", "package_url": "https://pypi.org/project/grakopp/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/grakopp/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/lambdafu/grakopp"}, "release_url": "https://pypi.org/project/grakopp/0.1.0/", "requires_dist": null, "requires_python": null, "summary": "Grako++ is a packrat parser runtime for Grako, written in C++.", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><strong>Work in progress!</strong></p>\n<p><a href=\"https://travis-ci.org/lambdafu/grakopp\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f30323bec5332520ed68dad87aedd9142a901b1b/68747470733a2f2f7472617669732d63692e6f72672f6c616d62646166752f6772616b6f70702e706e67\"></a></p>\n<div id=\"grako\">\n<h2>Grako++</h2>\n<p>Grako++ is a packrat parser runtime for Grako, written in C++. The aim\nis to provide a Grako-compatible parser generator, but with improved\nperformance over Python.</p>\n<div id=\"differences-to-grako\">\n<h3>Differences to Grako</h3>\n<ul>\n<li>The output is always AST/JSON.</li>\n<li>The semantics class can be implemented in C++ or Cython (pure Python\nthrough Cython is planned).</li>\n<li>The regular expression syntax is\n<a href=\"http://www.cplusplus.com/reference/regex/ECMAScript/\" rel=\"nofollow\">ECMAScript</a>,\nnot Python.</li>\n<li>Some features of Grako are missing, see below in the TODO section.</li>\n<li>State types must implement operator&lt; for std::map (for future\nflexibility, consider implementing the hash trait, too).</li>\n</ul>\n</div>\n<div id=\"build\">\n<h3>Build</h3>\n<p>The library is header-files only currently, so you can just copy the\nfiles in include/ to a convenient location, or build from there. More\nformally, you can use cmake.</p>\n<p>Build with clang by invoking: cmake -DCMAKE_CXX_COMPILER=/path/to/clang++</p>\n<p>Building with g++ &lt; 4.9 requires linking with the boost_regex library,\nbecause the std::regex implementation is broken. You can rely on the\nexported cmake library file to configure the right settings.</p>\n<p>Other useful option: -DCMAKE_INSTALL_PREFIX:PATH=/path/to/install</p>\n</div>\n<div id=\"usage\">\n<h3>Usage</h3>\n<p>The grakopp program is used like grako to compile PEG files to source\ncode. There are four different source code output formats that can be\nspecified with the -f/\u2013format option:</p>\n<table>\n<colgroup>\n<col>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>\u2013format</th>\n<th>\u2013output</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>hpp</td>\n<td>name.hpp</td>\n<td>C++ declaration</td>\n</tr>\n<tr><td>cpp</td>\n<td>name.cpp</td>\n<td>C++ implementation</td>\n</tr>\n<tr><td>pxd</td>\n<td>name.pxd</td>\n<td>Cython declaration</td>\n</tr>\n<tr><td>pyx</td>\n<td>name.pyx</td>\n<td>Cython implementation</td>\n</tr>\n</tbody>\n</table>\n<p>For pure C++ parsers, generating the hpp and cpp files is sufficient.\nFor Python integration, the pxd and pyx files are also needed. For\n\u201cname\u201d you should subsitute the actual name of the parser (either the\nbase name of the PEG file or the argument to the \u2013name option). The\nfilenames are, for now, hard-coded into the source files (the underscore\nprotects the C++ implementation from Cython-generated source files).</p>\n<p>Here is an example how to build a parser:</p>\n<pre>$ ./grakopp -f hpp -o _basic.hpp tests/basic/basic.peg\n$ ./grakopp --whitespace<span class=\"o\">=</span><span class=\"s2\">\"\"</span> --no-nameguard -f cpp -o _basic.cpp tests/basic/basic.peg\n$ g++ -DGRAKOPP_MAIN -std<span class=\"o\">=</span>c++11 -Iinclude -O4 -o basic _basic.cpp -lboost_regex\n</pre>\n<p>You can invoke the parser like a Python parser generated with grako\n(currently, no options are supported, though, except for an internal\noption \u2013test that compares the AST with a text fixture file):</p>\n<pre>$ <span class=\"nb\">echo</span> -n e1e2 <span class=\"p\">|</span> ./basic /dev/stdin sequence\n<span class=\"o\">[</span>\n    <span class=\"s2\">\"e1\"</span>,\n    <span class=\"s2\">\"e2\"</span>\n<span class=\"o\">]</span>\n</pre>\n</div>\n<div id=\"c-interface\">\n<h3>C++ Interface</h3>\n<p>The following header files exist:</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Header</th>\n<th>Purpose</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>grakopp/exception.hpp</td>\n<td>Parser exceptions</td>\n</tr>\n<tr><td>grakopp/buffer.hpp</td>\n<td>Buffer for I/O</td>\n</tr>\n<tr><td>grakopp/ast.hpp</td>\n<td>AST implementation</td>\n</tr>\n<tr><td>grakopp/parser.hpp</td>\n<td>Parser base class</td>\n</tr>\n<tr><td>grakopp/grakopp/hpp</td>\n<td>Include all above</td>\n</tr>\n<tr><td>grakopp/ast-io.hpp</td>\n<td>Optional AST stream I/O</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"python-integration\">\n<h3>Python Integration</h3>\n<p>Until the Python package is prepared properly, build the Cython\nextensions manually, for example like this:</p>\n<pre>$ <span class=\"nb\">cd</span> python/grakopp\n$ cython --cplus buffer.pyx\n$ cython --cplus ast.pyx\n$ g++ -std<span class=\"o\">=</span>c++11 -I../../include -shared -pthread -fPIC -fwrapv -O2 -Wall -fno-strict-aliasing -I/usr/include/python2.7 -o buffer.so buffer.cpp\n$ g++ -std<span class=\"o\">=</span>c++11 -I../../include -shared -pthread -fPIC -fwrapv -O2 -Wall -fno-strict-aliasing -I/usr/include/python2.7 -o ast.so ast.cpp\n$ <span class=\"nb\">cd</span> ../..\n</pre>\n<p>To continue the above example:</p>\n<pre>$ ./grakopp -f pxd -o basic.pxd tests/basic/basic.peg\n$ ./grakopp -f pyx -o basic.pyx tests/basic/basic.peg\n$ cython -Ipython --cplus basic.pyx\n$ g++ -std<span class=\"o\">=</span>c++11 -Iinclude -shared -pthread -fPIC -fwrapv -O2 -Wall -fno-strict-aliasing -I/usr/include/python2.7 -o basic.so basic.cpp _basic.cpp -l boost_regex\n</pre>\n<p>You can then use it from Python:</p>\n<pre>$ PYTHONPATH=python python\n&gt;&gt;&gt; from grakopp import buffer\n&gt;&gt;&gt; b = buffer.PyBuffer()\n&gt;&gt;&gt; b.from_string(\"e1e2\")\n&gt;&gt;&gt; import basic\n&gt;&gt;&gt; p = basic.basicPyParser()\n&gt;&gt;&gt; p.set_buffer(b)\n&gt;&gt;&gt; a = p._sequence_()\n&gt;&gt;&gt; a.to_python()\n['e1', 'e2']\n&gt;&gt;&gt; b.pos\n4\n&gt;&gt;&gt; a = p._sequence_()\n&gt;&gt;&gt; a.to_python()\nFailedToken('e1')\n</pre>\n</div>\n<div id=\"todo\">\n<h3>TODO</h3>\n<ul>\n<li>dynamic Ast objects (so you can pass through Python or XML objects)</li>\n<li>python/distutils integration</li>\n<li>automatic compilation a la pyximport</li>\n<li>add namespace</li>\n<li>unicode support?</li>\n<li>more support and tests for stateful parsing</li>\n<li>regex syntax tests (make sure generated C strings are always proper)</li>\n<li>profile and optimize</li>\n</ul>\n<p>Grako features missing:</p>\n<ul>\n<li>ignorecase (buffer match, matchre)</li>\n<li>comments skipping</li>\n<li>buffer line parsing and trace output (also in exceptions)</li>\n<li>ParseInfo</li>\n<li>rules with arguments</li>\n<li>left recursion</li>\n<li>semantic action \u201c_default\u201d</li>\n</ul>\n</div>\n<div id=\"authors\">\n<h3>Authors</h3>\n<pre>Copyright (C) 2014 semantics Kommunikationsmanagement GmbH\nWritten by Marcus Brinkmann &lt;m.brinkmann@semantics.de&gt;\nSee LICENSE.txt for details.\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1177783, "releases": {"0.1.0": [{"comment_text": "built for Linux-3.15.6-200.fc20.x86_64-x86_64-with-glibc2.2.5", "digests": {"md5": "b647fff80f0f1ab584f6e832802f014b", "sha256": "8f1f8a7fe69f13f739cfa358cb7674f55df6db8ba5059525ba16486da488df2a"}, "downloads": -1, "filename": "grakopp-0.1.0.linux-x86_64.tar.gz", "has_sig": false, "md5_digest": "b647fff80f0f1ab584f6e832802f014b", "packagetype": "bdist_dumb", "python_version": "2.7", "requires_python": null, "size": 285343, "upload_time": "2014-08-02T20:19:53", "upload_time_iso_8601": "2014-08-02T20:19:53.751196Z", "url": "https://files.pythonhosted.org/packages/56/9e/902734185b8c8e8c4c6f34f0e1f2152f77498c9b396beccd62670366bc7b/grakopp-0.1.0.linux-x86_64.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "ee931d383d83a66bf88785360a519eee", "sha256": "4d3b2892e5e8494dc773cc7d26a3396b92bb4e8d7c42f99f981b6140e7fbc2f6"}, "downloads": -1, "filename": "grakopp-0.1.0.tar.gz", "has_sig": false, "md5_digest": "ee931d383d83a66bf88785360a519eee", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 62346, "upload_time": "2014-08-02T20:19:48", "upload_time_iso_8601": "2014-08-02T20:19:48.094988Z", "url": "https://files.pythonhosted.org/packages/2c/ed/a47e685b29ada7e1435b0d13eb4044f731bbdcba3f0fbe52ddba079dd1c7/grakopp-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "built for Linux-3.15.6-200.fc20.x86_64-x86_64-with-glibc2.2.5", "digests": {"md5": "b647fff80f0f1ab584f6e832802f014b", "sha256": "8f1f8a7fe69f13f739cfa358cb7674f55df6db8ba5059525ba16486da488df2a"}, "downloads": -1, "filename": "grakopp-0.1.0.linux-x86_64.tar.gz", "has_sig": false, "md5_digest": "b647fff80f0f1ab584f6e832802f014b", "packagetype": "bdist_dumb", "python_version": "2.7", "requires_python": null, "size": 285343, "upload_time": "2014-08-02T20:19:53", "upload_time_iso_8601": "2014-08-02T20:19:53.751196Z", "url": "https://files.pythonhosted.org/packages/56/9e/902734185b8c8e8c4c6f34f0e1f2152f77498c9b396beccd62670366bc7b/grakopp-0.1.0.linux-x86_64.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "ee931d383d83a66bf88785360a519eee", "sha256": "4d3b2892e5e8494dc773cc7d26a3396b92bb4e8d7c42f99f981b6140e7fbc2f6"}, "downloads": -1, "filename": "grakopp-0.1.0.tar.gz", "has_sig": false, "md5_digest": "ee931d383d83a66bf88785360a519eee", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 62346, "upload_time": "2014-08-02T20:19:48", "upload_time_iso_8601": "2014-08-02T20:19:48.094988Z", "url": "https://files.pythonhosted.org/packages/2c/ed/a47e685b29ada7e1435b0d13eb4044f731bbdcba3f0fbe52ddba079dd1c7/grakopp-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:52 2020"}