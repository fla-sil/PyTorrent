{"info": {"author": "Jeroen van der Heijden", "author_email": "jeroen@transceptor.technology", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.0", "Programming Language :: Python :: 3.1", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3 :: Only", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Text Processing :: Linguistic"], "description": "Python Left-Right Parser\n========================\nPyleri is an easy-to-use parser created for [SiriDB](http://siridb.net/). We first used [lrparsing](http://lrparsing.sourceforge.net/doc/html/) and wrote [jsleri](https://github.com/transceptor-technology/jsleri) for auto-completion and suggestions in our web console. Later we found small issues within the `lrparsing` module and also had difficulties keeping the language the same in all projects. That is when we decided to create Pyleri which can export a created grammar to JavaScript, C, Python, Go and Java.\n\n---------------------------------------\n  * [Related projects](#related-projects)\n  * [Installation](#installation)\n  * [Quick usage](#quick-usage)\n  * [Grammar](#grammar)\n    * [Grammar.parse()](#parse)\n    * [Grammar.export_js()](#export_js)\n    * [Grammar.export_c()](#export_c)\n    * [Grammar.export_go()](#export_go)\n    * [Grammar.export_java()](#export_java)\n    * [Grammar.export_py()](#export_py)\n  * [Result](#result)\n    * [is_valid](#is_valid)\n    * [Position](#position)\n    * [Tree](#tree)\n    * [Expecting](#expecting)\n  * [Elements](#elements)\n    * [Keyword](#keyword)\n    * [Regex](#regex)\n    * [Token](#token)\n    * [Tokens](#tokens)\n    * [Sequence](#sequence)\n    * [Choice](#choice)\n    * [Repeat](#repeat)\n    * [List](#list)\n    * [Optional](#optional)\n    * [Ref](#ref)\n    * [Prio](#prio)\n\n\n---------------------------------------\n## Related projects\n- [jsleri](https://github.com/transceptor-technology/jsleri): JavaScript parser\n- [libcleri](https://github.com/transceptor-technology/libcleri): C parser\n- [goleri](https://github.com/transceptor-technology/goleri): Go parser\n- [jleri](https://github.com/transceptor-technology/jleri): Java parser\n\n## Installation\nThe easiest way is to use PyPI:\n\n    sudo pip3 install pyleri\n\n## Quick usage\n```python\n# Imports, note that we skip the imports in other examples...\nfrom pyleri import (\n    Grammar,\n    Keyword,\n    Regex,\n    Sequence)\n\n# Create a Grammar Class to define your language\nclass MyGrammar(Grammar):\n    r_name = Regex('(?:\"(?:[^\"]*)\")+')\n    k_hi = Keyword('hi')\n    START = Sequence(k_hi, r_name)\n\n# Compile your grammar by creating an instance of the Grammar Class.\nmy_grammar = MyGrammar()\n\n# Use the compiled grammar to parse 'strings'\nprint(my_grammar.parse('hi \"Iris\"').is_valid) # => True\nprint(my_grammar.parse('bye \"Iris\"').is_valid) # => False\nprint(my_grammar.parse('bye \"Iris\"').as_str()) # => error at position 0, expecting: hi\n```\n\n## Grammar\nWhen writing a grammar you should subclass Grammar. A Grammar expects at least a `START` property so the parser knows where to start parsing. Grammar has some default properties which can be overwritten like `RE_KEYWORDS`, which will be explained later. Grammar also has a parse method: `parse()`, and a few export methods: [export_js()](#export_js), [export_c()](#export_c), [export_py()](#export_py), [export_go()](#export_go) and [export_java()](#export_java) which are explained below.\n\n\n### parse\nsyntax:\n```python\nGrammar().parse(string)\n```\nThe `parse()` method returns a result object which has the following properties that are further explained in [Result](#result):\n- `expecting`\n- `is_valid`\n- `pos`\n- `tree`\n\n\n### export_js\nsyntax:\n```python\nGrammar().export_js(\n    js_module_name='jsleri',\n    js_template=Grammar.JS_TEMPLATE,\n    js_indent=' ' * 4)\n```\nOptional keyword arguments:\n- `js_module_name`: Name of the JavaScript module. (default: 'jsleri')\n- `js_template`: Template String used for the export. You might want to look at the default string which can be found at Grammar.JS_TEMPLATE.\n- `js_indent`: indentation used in the JavaScript file. (default: 4 spaces)\n\nFor example when using our Quick usage grammar, this is the output when running `my_grammar.export_js()`:\n```javascript\n/* jshint newcap: false */\n\n/*\n * This grammar is generated using the Grammar.export_js() method and\n * should be used with the jsleri JavaScript module.\n *\n * Source class: MyGrammar\n * Created at: 2015-11-04 10:06:06\n */\n\n'use strict';\n\n(function (\n            Regex,\n            Sequence,\n            Keyword,\n            Grammar\n        ) {\n    var r_name = Regex('^(?:\"(?:[^\"]*)\")+');\n    var k_hi = Keyword('hi');\n    var START = Sequence(\n        k_hi,\n        r_name\n    );\n\n    window.MyGrammar = Grammar(START, '^\\w+');\n\n})(\n    window.jsleri.Regex,\n    window.jsleri.Sequence,\n    window.jsleri.Keyword,\n    window.jsleri.Grammar\n);\n```\n\n### export_c\nsyntax:\n```python\nGrammar().export_c(\n    target=Grammar.C_TARGET,\n    c_indent=' ' * 4)\n```\nOptional keyword arguments:\n- `target`: Name of the c module. (default: 'grammar')\n- `c_indent`: indentation used in the c files. (default: 4 spaces)\n\nThe return value is a tuple containing the source (c) file and header (h) file.\n\nFor example when using our Quick usage grammar, this is the output when running `my_grammar.export_c()`:\n```c\n/*\n * grammar.c\n *\n * This grammar is generated using the Grammar.export_c() method and\n * should be used with the libcleri module.\n *\n * Source class: MyGrammar\n * Created at: 2016-05-09 12:16:49\n */\n\n#include \"grammar.h\"\n#include <stdio.h>\n\n#define CLERI_CASE_SENSITIVE 0\n#define CLERI_CASE_INSENSITIVE 1\n\n#define CLERI_FIRST_MATCH 0\n#define CLERI_MOST_GREEDY 1\n\ncleri_grammar_t * compile_grammar(void)\n{\n    cleri_t * r_name = cleri_regex(CLERI_GID_R_NAME, \"^(?:\\\"(?:[^\\\"]*)\\\")+\");\n    cleri_t * k_hi = cleri_keyword(CLERI_GID_K_HI, \"hi\", CLERI_CASE_INSENSITIVE);\n    cleri_t * START = cleri_sequence(\n        CLERI_GID_START,\n        2,\n        k_hi,\n        r_name\n    );\n\n    cleri_grammar_t * grammar = cleri_grammar(START, \"^\\\\w+\");\n\n    return grammar;\n}\n```\nand the header file...\n```c\n/*\n * grammar.h\n *\n * This grammar is generated using the Grammar.export_c() method and\n * should be used with the libcleri module.\n *\n * Source class: MyGrammar\n * Created at: 2016-05-09 12:16:49\n */\n#ifndef CLERI_EXPORT_GRAMMAR_H_\n#define CLERI_EXPORT_GRAMMAR_H_\n\n#include <grammar.h>\n#include <cleri/cleri.h>\n\ncleri_grammar_t * compile_grammar(void);\n\nenum cleri_grammar_ids {\n    CLERI_NONE,   // used for objects with no name\n    CLERI_GID_K_HI,\n    CLERI_GID_R_NAME,\n    CLERI_GID_START,\n    CLERI_END // can be used to get the enum length\n};\n\n#endif /* CLERI_EXPORT_GRAMMAR_H_ */\n\n```\n### export_go\nsyntax:\n```python\nGrammar().export_go(\n    go_template=Grammar.GO_TEMPLATE,\n    go_indent='\\t',\n    go_package='grammar')\n```\nOptional keyword arguments:\n- `go_template`: Template String used for the export. You might want to look at the default string which can be found at Grammar.GO_TEMPLATE.\n- `go_indent`: indentation used in the Go file. (default: one tab)\n- `go_package`: Name of the go package. (default: 'grammar')\n\nFor example when using our Quick usage grammar, this is the output when running `my_grammar.export_go()`:\n```go\npackage grammar\n\n// This grammar is generated using the Grammar.export_go() method and\n// should be used with the goleri module.\n//\n// Source class: MyGrammar\n// Created at: 2017-03-14 19:07:09\n\nimport (\n        \"regexp\"\n\n        \"github.com/transceptor-technology/goleri\"\n)\n\n// Element indentifiers\nconst (\n        NoGid = iota\n        GidKHi = iota\n        GidRName = iota\n        GidSTART = iota\n)\n\n// MyGrammar returns a compiled goleri grammar.\nfunc MyGrammar() *goleri.Grammar {\n        rName := goleri.NewRegex(GidRName, regexp.MustCompile(`^(?:\"(?:[^\"]*)\")+`))\n        kHi := goleri.NewKeyword(GidKHi, \"hi\", false)\n        START := goleri.NewSequence(\n                GidSTART,\n                kHi,\n                rName,\n        )\n        return goleri.NewGrammar(START, regexp.MustCompile(`^\\w+`))\n}\n```\n### export_java\nsyntax:\n```python\nGrammar().export_java(\n    java_template=Grammar.JAVA_TEMPLATE,\n    java_indent=' ' * 4,\n    java_package=None,\n    is_public=True)\n```\nOptional keyword arguments:\n- `java_template`: Template String used for the export. You might want to look at the default string which can be found at Grammar.JAVA_TEMPLATE.\n- `java_indent`: indentation used in the Java file. (default: four spaces)\n- `java_package`: Name of the Java package or None when no package is specified. (default: None)\n- `is_public`: Class and constructor are defined as public when True, else they will be defined as package private.\n\nFor example when using our Quick usage grammar, this is the output when running `my_grammar.export_java()`:\n```java\n/**\n * This grammar is generated using the Grammar.export_java() method and\n * should be used with the jleri module.\n *\n * Source class: MyGrammar\n * Created at: 2018-07-04 12:12:34\n */\n\nimport jleri.Grammar;\nimport jleri.Element;\nimport jleri.Sequence;\nimport jleri.Regex;\nimport jleri.Keyword;\n\npublic class MyGrammar extends Grammar {\n    enum Ids {\n        K_HI,\n        R_NAME,\n        START\n    }\n\n    private static final Element R_NAME = new Regex(Ids.R_NAME, \"^(?:\\\"(?:[^\\\"]*)\\\")+\");\n    private static final Element K_HI = new Keyword(Ids.K_HI, \"hi\", false);\n    private static final Element START = new Sequence(\n        Ids.START,\n        K_HI,\n        R_NAME\n    );\n\n    public MyGrammar() {\n        super(START, \"^\\\\w+\");\n    }\n}\n```\n### export_py\nsyntax:\n```python\nGrammar().export_py(\n    py_module_name='pyleri',\n    py_template=Grammar.PY_TEMPLATE,\n    py_indent=' ' * 4)\n```\nOptional keyword arguments:\n- `py_module_name`: Name of the Pyleri Module. (default: 'pyleri')\n- `py_template`: Template String used for the export. You might want to look at the default string which can be found at Grammar.PY_TEMPLATE.\n- `py_indent`: indentation used in the Python file. (default: 4 spaces)\n\nFor example when using our Quick usage grammar, this is the output when running `my_grammar.export_py()`:\n```python\n\"\"\"\n This grammar is generated using the Grammar.export_py() method and\n should be used with the pyleri python module.\n\n Source class: MyGrammar\n Created at: 2017-03-14 19:14:51\n\"\"\"\nimport re\nfrom pyleri import Sequence\nfrom pyleri import Keyword\nfrom pyleri import Grammar\nfrom pyleri import Regex\n\nclass MyGrammar(Grammar):\n\n    RE_KEYWORDS = re.compile('^\\\\w+')\n    r_name = Regex('^(?:\"(?:[^\"]*)\")+')\n    k_hi = Keyword('hi')\n    START = Sequence(\n        k_hi,\n        r_name\n    )\n```\n\n## Result\nThe result of the `parse()` method contains 4 properties that will be explained next. A function `as_str(translate=None)` is also available which will\nshow the result as a string. The `translate` argument should be a function which accepts an element as argument. This function can be used to\nreturn custom strings for certain elements. If the return value of `translate` is `None` then the function will fall try to generate a string value. If\nthe return value is an empty string, the value will be ignored.\n\nExample of translate functions:\n```python\n# In case a translation function returns an empty string, no text is used\ndef translate(elem):\n    return ''  # as a result you get something like: 'error at position x'\n\n# Text may be returned based on gid\ndef translate(elem):\n    if elem is some_elem:\n        return 'A'   # something like: error at position x, expecting: A\n    elif elem is other_elem:\n        return ''    # other_elem will be ignored\n    else:\n        return None  # normal parsing\n\n# A translate function can be used as follow:\nprint(my_grammar.parse('some string').as_str(translate=translate))\n```\n\n### is_valid\n`is_valid` returns a boolean value, `True` when the given string is valid according to the given grammar, `False` when not valid.\n\nLet us take the example from Quick usage.\n```python\nres = my_grammar.parse('bye \"Iris\"')\nprint(res.is_valid) # => False\n```\n\n### Position\n`pos` returns the position where the parser had to stop. (when `is_valid` is `True` this value will be equal to the length of the given string with `str.rstrip()` applied)\n\nLet us take the example from Quick usage.\n```python\nresult = my_grammar.parse('hi Iris')\nprint(res.is_valid, result.pos) # => False, 3\n```\n\n### Tree\n`tree` contains the parse tree. Even when `is_valid` is `False` the parse tree is returned but will only contain results as far as parsing has succeeded. The tree is the root node which can include several `children` nodes. The structure will be further clarified in the following example which explains a way of visualizing the parse tree.\n\nExample:\n```python\nimport json\nfrom pyleri import Choice\nfrom pyleri import Grammar\nfrom pyleri import Keyword\nfrom pyleri import Regex\nfrom pyleri import Repeat\nfrom pyleri import Sequence\n\n\n# Create a Grammar Class to define your language\nclass MyGrammar(Grammar):\n    r_name = Regex('(?:\"(?:[^\"]*)\")+')\n    k_hi = Keyword('hi')\n    k_bye = Keyword('bye')\n    START = Repeat(Sequence(Choice(k_hi, k_bye), r_name))\n\n\n# Returns properties of a node object as a dictionary:\ndef node_props(node, children):\n    return {\n        'start': node.start,\n        'end': node.end,\n        'name': node.element.name if hasattr(node.element, 'name') else None,\n        'element': node.element.__class__.__name__,\n        'string': node.string,\n        'children': children}\n\n\n# Recursive method to get the children of a node object:\ndef get_children(children):\n    return [node_props(c, get_children(c.children)) for c in children]\n\n\n# View the parse tree:\ndef view_parse_tree(res):\n    start = res.tree.children[0] \\\n        if res.tree.children else res.tree\n    return node_props(start, get_children(start.children))\n\n\nif __name__ == '__main__':\n    # Compile your grammar by creating an instance of the Grammar Class:\n    my_grammar = MyGrammar()\n    res = my_grammar.parse('hi \"siri\" bye \"siri\"')\n    # The parse tree is visualized as a JSON object:\n    print(json.dumps(view_parse_tree(res), indent=2))\n```\n\nPart of the output is shown below.\n\n```json\n\n    {\n    \"start\": 0,\n    \"end\": 23,\n    \"name\": \"START\",\n    \"element\": \"Repeat\",\n    \"string\": \"hi \\\"pyleri\\\" hi \\\"pyleri\\\"\",\n    \"children\": [\n        {\n        \"start\": 0,\n        \"end\": 11,\n        \"name\": null,\n        \"element\": \"Sequence\",\n        \"string\": \"hi \\\"pyleri\\\"\",\n        \"children\": [\n            {\n            \"start\": 0,\n            \"end\": 2,\n            \"name\": null,\n            \"element\": \"Choice\",\n            \"string\": \"hi\",\n            \"children\": [\n                {\n                \"start\": 0,\n                \"end\": 2,\n                \"name\": \"k_hi\",\n                \"element\": \"Keyword\",\n                \"string\": \"hi\",\n                \"children\": []\n                }\n            ]\n            },\n            {\n            \"start\": 3,\n            \"end\": 11,\n            \"name\": \"r_name\",\n            \"element\": \"Regex\",\n            \"string\": \"\\\"pyleri\\\"\",\n            \"children\": []\n            }\n\n            \"...\"\n            \"...\"\n\n\n```\nA node contains 5 properties that will be explained next:\n\n- `start` property returns the start of the node object.\n- `end` property returns the end of the  node object.\n- `element` returns the type of [Element](#elements) (e.g. Repeat, Sequence, Keyword, etc.). An element can be assigned to a variable; for instance in the example above `Keyword('hi')` was assigned to `k_hi`. With `element.name` the assigned name `k_hi` will be returned. Note that it is not a given that an element is named; in our example `Sequence` was not assigned, thus in this case the element has no attribute `name`.\n- `string` returns the string that is parsed.\n- `children` can return a node object containing deeper layered nodes provided that there are any. In our example the root node has an element type `Repeat()`, starts at 0 and ends at 24, and it has two `children`. These children are node objects that have both an element type `Sequence`, start at 0 and 12 respectively, and so on.\n\n\n### Expecting\n`expecting` returns a Python set() containing elements which pyleri expects at `pos`. Even if `is_valid` is true there might be elements in this set, for example when an `Optional()` element could be added to the string. Expecting is useful if you want to implement things like auto-completion, syntax error handling, auto-syntax-correction etc. The following example will illustrate a way of implementation.\n\nExample:\n```python\nimport re\nimport random\nfrom pyleri import Choice\nfrom pyleri import Grammar\nfrom pyleri import Keyword\nfrom pyleri import Repeat\nfrom pyleri import Sequence\nfrom pyleri import end_of_statement\n\n\n# Create a Grammar Class to define your language.\nclass MyGrammar(Grammar):\n    RE_KEYWORDS = re.compile(r'\\S+')\n    r_name = Keyword('\"pyleri\"')\n    k_hi = Keyword('hi')\n    k_bye = Keyword('bye')\n    START = Repeat(Sequence(Choice(k_hi, k_bye), r_name), mi=2)\n\n\n# Print the expected elements as a indented and numbered list.\ndef print_expecting(node_expecting, string_expecting):\n    for loop, e in enumerate(node_expecting):\n        string_expecting = '{}\\n\\t({}) {}'.format(string_expecting, loop, e)\n    print(string_expecting)\n\n\n# Complete a string until it is valid according to the grammar.\ndef auto_correction(string, my_grammar):\n    node = my_grammar.parse(string)\n    print('\\nParsed string: {}'.format(node.tree.string))\n\n    if node.is_valid:\n        string_expecting = 'String is valid. \\nExpected: '\n        print_expecting(node.expecting, string_expecting)\n\n    else:\n        string_expecting = 'String is NOT valid.\\nExpected: ' \\\n            if not node.pos \\\n            else 'String is NOT valid. \\nAfter \"{}\" expected: '.format(\n                                                  node.tree.string[:node.pos])\n        print_expecting(node.expecting, string_expecting)\n\n        selected = random.choice(list(node.expecting))\n        string = '{} {}'.format(node.tree.string[:node.pos],\n                                selected\n                                if selected\n                                is not end_of_statement else '')\n\n        auto_correction(string, my_grammar)\n\n\nif __name__ == '__main__':\n    # Compile your grammar by creating an instance of the Grammar Class.\n    my_grammar = MyGrammar()\n    string = 'hello \"pyleri\"'\n    auto_correction(string, my_grammar)\n\n```\n\nOutput:\n```\nParsed string: hello \"pyleri\"\nString is NOT valid.\nExpected:\n        (1) hi\n        (2) bye\n\nParsed string:  bye\nString is NOT valid.\nAfter \" bye\" expected:\n        (1) \"pyleri\"\n\nParsed string:  bye \"pyleri\"\nString is NOT valid.\nAfter \" bye \"pyleri\"\" expected:\n        (1) hi\n        (2) bye\n\nParsed string:  bye \"pyleri\" hi\nString is NOT valid.\nAfter \" bye \"pyleri\" hi\" expected:\n        (1) \"pyleri\"\n\nParsed string:  bye \"pyleri\" hi \"pyleri\"\nString is valid.\nExpected:\n        (1) hi\n        (2) bye\n\n```\nIn the above example we parsed an invalid string according to the grammar class. The `auto-correction()` method that we built for this example combines all properties from the `parse()` to create a valid string. The output shows every recursion of the `auto-correction()` method and prints successively the set of expected elements. It takes one randomly and adds it to the string. When the string corresponds to the grammar, the property `is_valid` will return `True`. Notably the `expecting` property still contains elements even if the `is_valid` returned `True`. The reason in this example is because of the [Repeat](#repeat) element.\n\n## Elements\nPyleri has several elements which are all subclasses of [Element](#element) and can be used to create a grammar.\n\n### Keyword\nsyntax:\n```python\nKeyword(keyword, ign_case=False)\n```\nThe parser needs to match the keyword which is just a string. When matching keywords we need to tell the parser what characters are allowed in keywords. By default Pyleri uses `^\\w+` which is both in Python and JavaScript equal to `^[A-Za-z0-9_]+`. We can overwrite the default by setting `RE_KEYWORDS` in the grammar. Keyword() accepts one keyword argument `ign_case` to tell the parser if we should match case insensitive.\n\nExample:\n\n```python\nclass TicTacToe(Grammar):\n    # Let's allow keywords with alphabetic characters and dashes.\n    RE_KEYWORDS = re.compile('^[A-Za-z-]+')\n\n    START = Keyword('tic-tac-toe', ign_case=True)\n\nttt_grammar = TicTacToe()\nttt_grammar.parse('Tic-Tac-Toe').is_valid  # => True\n```\n\n### Regex\nsyntax:\n```python\nRegex(pattern, flags=0)\n```\nThe parser compiles a regular expression using the `re` module. The current version of pyleri has only support for the `re.IGNORECASE` flag.\nSee the [Quick usage](#quick-usage) example for how to use `Regex`.\n\n### Token\nsyntax:\n```python\nToken(token)\n```\nA token can be one or more characters and is usually used to match operators like `+`, `-`, `//` and so on. When we parse a string object where pyleri expects an element, it will automatically be converted to a `Token()` object.\n\nExample:\n```python\nclass Ni(Grammar):\n    t_dash = Token('-')\n    # We could just write delimiter='-' because\n    # any string will be converted to Token()\n    START = List(Keyword('ni'), delimiter=t_dash)\n\nni = Ni()\nni.parse('ni-ni-ni-ni-ni').is_valid  # => True\n```\n\n### Tokens\nsyntax:\n```python\nTokens(tokens)\n```\nCan be used to register multiple tokens at once. The `tokens` argument should be a string with tokens separated by spaces. If given tokens are different in size the parser will try to match the longest tokens first.\n\nExample:\n```python\nclass Ni(Grammar):\n    tks = Tokens('+ - !=')\n    START = List(Keyword('ni'), delimiter=tks)\n\nni = Ni()\nni.parse('ni + ni != ni - ni').is_valid  # => True\n```\n\n### Sequence\nsyntax:\n```python\nSequence(element, element, ...)\n```\nThe parser needs to match each element in a sequence.\n\nExample:\n```python\nclass TicTacToe(Grammar):\n    START = Sequence(Keyword('Tic'), Keyword('Tac'), Keyword('Toe'))\n\nttt_grammar = TicTacToe()\nttt_grammar.parse('Tic Tac Toe').is_valid  # => True\n```\n\n### Choice\nsyntax:\n```python\nChoice(element, element, ..., most_greedy=True)\n```\nThe parser needs to choose between one of the given elements. Choice accepts one keyword argument `most_greedy` which is `True` by default. When `most_greedy` is set to `False` the parser will stop at the first match. When `True` the parser will try each element and returns the longest match. Setting `most_greedy` to `False` can provide some extra performance. Note that the parser will try to match each element in the exact same order they are parsed to Choice.\n\nExample: let us use `Choice` to modify the Quick usage example to allow the string 'bye \"Iris\"'\n```python\nclass MyGrammar(Grammar):\n    r_name = Regex('(?:\"(?:[^\"]*)\")+')\n    k_hi = Keyword('hi')\n    k_bye = Keyword('bye')\n    START = Sequence(Choice(k_hi, k_bye), r_name)\n\nmy_grammar = MyGrammar()\nmy_grammar.parse('hi \"Iris\"').is_valid  # => True\nmy_grammar.parse('bye \"Iris\"').is_valid  # => True\n```\n\n### Repeat\nsyntax:\n```python\nRepeat(element, mi=0, ma=None)\n```\nThe parser needs at least `mi` elements and at most `ma` elements. When `ma` is set to `None` we allow unlimited number of elements. `mi` can be any integer value equal or higher than 0 but not larger then `ma`.\n\nExample:\n```python\nclass Ni(Grammar):\n    START = Repeat(Keyword('ni'))\n\nni = Ni()\nni.parse('ni ni ni ni ni').is_valid  # => True\n```\n\nIt is not allowed to bind a name to the same element twice and Repeat(element, 1, 1) is a common solution to bind the element a second (or more) time(s).\n\nFor example consider the following:\n```python\nclass MyGrammar(Grammar):\n    r_name = Regex('(?:\"(?:[^\"]*)\")+')\n\n    # Raises a SyntaxError because we try to bind a second time.\n    r_address = r_name # WRONG\n\n    # Instead use Repeat\n    r_address = Repeat(r_name, 1, 1) # RIGHT\n```\n\n### List\nsyntax:\n```python\nList(element, delimiter=',', mi=0, ma=None, opt=False)\n```\nList is like Repeat but with a delimiter. A comma is used as default delimiter but any element is allowed. When a string is used as delimiter it will be converted to a `Token` element. `mi` and `ma` work exactly like with Repeat. An optional keyword argument `opt` can be set to `True` to allow the list to end with a delimiter. By default this is set to `False` which means the list has to end with an element.\n\nExample:\n```python\nclass Ni(Grammar):\n    START = List(Keyword('ni'))\n\nni = Ni()\nni.parse('ni, ni, ni, ni, ni').is_valid  # => True\n```\n\n### Optional\nsyntax:\n```python\nOptional(element)\n```\nThe parser looks for an optional element. It is like using `Repeat(element, 0, 1)` but we encourage to use `Optional` since it is more readable. (and slightly faster)\n\nExample:\n```python\nclass MyGrammar(Grammar):\n    r_name = Regex('(?:\"(?:[^\"]*)\")+')\n    k_hi = Keyword('hi')\n    START = Sequence(k_hi, Optional(r_name))\n\nmy_grammar = MyGrammar()\nmy_grammar.parse('hi \"Iris\"').is_valid  # => True\nmy_grammar.parse('hi').is_valid  # => True\n```\n\n### Ref\nsyntax:\n```python\nRef()\n```\nThe grammar can make a forward reference to make recursion possible. In the example below we create a forward reference to START but note that\na reference to any element can be made.\n\n>Warning: A reference is not protected against testing the same position in\n>a string. This could potentially lead to an infinite loop.\n>For example:\n>```python\n>r = Ref()\n>r = Optional(r)  # DON'T DO THIS\n>```\n>Use [Prio](#prio) if such recursive construction is required.\n\nExample:\n```python\nclass NestedNi(Grammar):\n    START = Ref()\n    ni_item = Choice(Keyword('ni'), START)\n    START = Sequence('[', List(ni_item), ']')\n\nnested_ni = NestedNi()\nnested_ni.parse('[ni, ni, [ni, [], [ni, ni]]]').is_valid  # => True\n```\n\n### Prio\nsyntax:\n```python\nPrio(element, element, ...)\n```\nChoose the first match from the prio elements and allow `THIS` for recursive operations. With `THIS` we point to the `Prio` element. Probably the example below explains how `Prio` and `THIS` can be used.\n\n>Note: Use a [Ref](#ref) when possible.\n>A `Prio` element is required when the same position in a string is potentially\n>checked more than once.\n\nExample:\n```python\nclass Ni(Grammar):\n    k_ni = Keyword('ni')\n    START = Prio(\n        k_ni,\n        # '(' and ')' are automatically converted to Token('(') and Token(')')\n        Sequence('(', THIS, ')'),\n        Sequence(THIS, Keyword('or'), THIS),\n        Sequence(THIS, Keyword('and'), THIS))\n\nni = Ni()\nni.parse('(ni or ni) and (ni or ni)').is_valid  # => True\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/transceptor-technology/pyleri/tarball/1.3.2", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/transceptor-technology/pyleri", "keywords": "parser,grammar,autocompletion", "license": "", "maintainer": "", "maintainer_email": "", "name": "pyleri", "package_url": "https://pypi.org/project/pyleri/", "platform": "", "project_url": "https://pypi.org/project/pyleri/", "project_urls": {"Download": "https://github.com/transceptor-technology/pyleri/tarball/1.3.2", "Homepage": "https://github.com/transceptor-technology/pyleri"}, "release_url": "https://pypi.org/project/pyleri/1.3.2/", "requires_dist": null, "requires_python": "", "summary": "Python Left-Right Parser", "version": "1.3.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Python Left-Right Parser</h1>\n<p>Pyleri is an easy-to-use parser created for <a href=\"http://siridb.net/\" rel=\"nofollow\">SiriDB</a>. We first used <a href=\"http://lrparsing.sourceforge.net/doc/html/\" rel=\"nofollow\">lrparsing</a> and wrote <a href=\"https://github.com/transceptor-technology/jsleri\" rel=\"nofollow\">jsleri</a> for auto-completion and suggestions in our web console. Later we found small issues within the <code>lrparsing</code> module and also had difficulties keeping the language the same in all projects. That is when we decided to create Pyleri which can export a created grammar to JavaScript, C, Python, Go and Java.</p>\n<hr>\n<ul>\n<li><a href=\"#related-projects\" rel=\"nofollow\">Related projects</a></li>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#quick-usage\" rel=\"nofollow\">Quick usage</a></li>\n<li><a href=\"#grammar\" rel=\"nofollow\">Grammar</a>\n<ul>\n<li><a href=\"#parse\" rel=\"nofollow\">Grammar.parse()</a></li>\n<li><a href=\"#export_js\" rel=\"nofollow\">Grammar.export_js()</a></li>\n<li><a href=\"#export_c\" rel=\"nofollow\">Grammar.export_c()</a></li>\n<li><a href=\"#export_go\" rel=\"nofollow\">Grammar.export_go()</a></li>\n<li><a href=\"#export_java\" rel=\"nofollow\">Grammar.export_java()</a></li>\n<li><a href=\"#export_py\" rel=\"nofollow\">Grammar.export_py()</a></li>\n</ul>\n</li>\n<li><a href=\"#result\" rel=\"nofollow\">Result</a>\n<ul>\n<li><a href=\"#is_valid\" rel=\"nofollow\">is_valid</a></li>\n<li><a href=\"#position\" rel=\"nofollow\">Position</a></li>\n<li><a href=\"#tree\" rel=\"nofollow\">Tree</a></li>\n<li><a href=\"#expecting\" rel=\"nofollow\">Expecting</a></li>\n</ul>\n</li>\n<li><a href=\"#elements\" rel=\"nofollow\">Elements</a>\n<ul>\n<li><a href=\"#keyword\" rel=\"nofollow\">Keyword</a></li>\n<li><a href=\"#regex\" rel=\"nofollow\">Regex</a></li>\n<li><a href=\"#token\" rel=\"nofollow\">Token</a></li>\n<li><a href=\"#tokens\" rel=\"nofollow\">Tokens</a></li>\n<li><a href=\"#sequence\" rel=\"nofollow\">Sequence</a></li>\n<li><a href=\"#choice\" rel=\"nofollow\">Choice</a></li>\n<li><a href=\"#repeat\" rel=\"nofollow\">Repeat</a></li>\n<li><a href=\"#list\" rel=\"nofollow\">List</a></li>\n<li><a href=\"#optional\" rel=\"nofollow\">Optional</a></li>\n<li><a href=\"#ref\" rel=\"nofollow\">Ref</a></li>\n<li><a href=\"#prio\" rel=\"nofollow\">Prio</a></li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2>Related projects</h2>\n<ul>\n<li><a href=\"https://github.com/transceptor-technology/jsleri\" rel=\"nofollow\">jsleri</a>: JavaScript parser</li>\n<li><a href=\"https://github.com/transceptor-technology/libcleri\" rel=\"nofollow\">libcleri</a>: C parser</li>\n<li><a href=\"https://github.com/transceptor-technology/goleri\" rel=\"nofollow\">goleri</a>: Go parser</li>\n<li><a href=\"https://github.com/transceptor-technology/jleri\" rel=\"nofollow\">jleri</a>: Java parser</li>\n</ul>\n<h2>Installation</h2>\n<p>The easiest way is to use PyPI:</p>\n<pre><code>sudo pip3 install pyleri\n</code></pre>\n<h2>Quick usage</h2>\n<pre><span class=\"c1\"># Imports, note that we skip the imports in other examples...</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"p\">(</span>\n    <span class=\"n\">Grammar</span><span class=\"p\">,</span>\n    <span class=\"n\">Keyword</span><span class=\"p\">,</span>\n    <span class=\"n\">Regex</span><span class=\"p\">,</span>\n    <span class=\"n\">Sequence</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Create a Grammar Class to define your language</span>\n<span class=\"k\">class</span> <span class=\"nc\">MyGrammar</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">r_name</span> <span class=\"o\">=</span> <span class=\"n\">Regex</span><span class=\"p\">(</span><span class=\"s1\">'(?:\"(?:[^\"]*)\")+'</span><span class=\"p\">)</span>\n    <span class=\"n\">k_hi</span> <span class=\"o\">=</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'hi'</span><span class=\"p\">)</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"n\">k_hi</span><span class=\"p\">,</span> <span class=\"n\">r_name</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Compile your grammar by creating an instance of the Grammar Class.</span>\n<span class=\"n\">my_grammar</span> <span class=\"o\">=</span> <span class=\"n\">MyGrammar</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Use the compiled grammar to parse 'strings'</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">my_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'hi \"Iris\"'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span><span class=\"p\">)</span> <span class=\"c1\"># =&gt; True</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">my_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'bye \"Iris\"'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span><span class=\"p\">)</span> <span class=\"c1\"># =&gt; False</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">my_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'bye \"Iris\"'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_str</span><span class=\"p\">())</span> <span class=\"c1\"># =&gt; error at position 0, expecting: hi</span>\n</pre>\n<h2>Grammar</h2>\n<p>When writing a grammar you should subclass Grammar. A Grammar expects at least a <code>START</code> property so the parser knows where to start parsing. Grammar has some default properties which can be overwritten like <code>RE_KEYWORDS</code>, which will be explained later. Grammar also has a parse method: <code>parse()</code>, and a few export methods: <a href=\"#export_js\" rel=\"nofollow\">export_js()</a>, <a href=\"#export_c\" rel=\"nofollow\">export_c()</a>, <a href=\"#export_py\" rel=\"nofollow\">export_py()</a>, <a href=\"#export_go\" rel=\"nofollow\">export_go()</a> and <a href=\"#export_java\" rel=\"nofollow\">export_java()</a> which are explained below.</p>\n<h3>parse</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Grammar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">)</span>\n</pre>\n<p>The <code>parse()</code> method returns a result object which has the following properties that are further explained in <a href=\"#result\" rel=\"nofollow\">Result</a>:</p>\n<ul>\n<li><code>expecting</code></li>\n<li><code>is_valid</code></li>\n<li><code>pos</code></li>\n<li><code>tree</code></li>\n</ul>\n<h3>export_js</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Grammar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">export_js</span><span class=\"p\">(</span>\n    <span class=\"n\">js_module_name</span><span class=\"o\">=</span><span class=\"s1\">'jsleri'</span><span class=\"p\">,</span>\n    <span class=\"n\">js_template</span><span class=\"o\">=</span><span class=\"n\">Grammar</span><span class=\"o\">.</span><span class=\"n\">JS_TEMPLATE</span><span class=\"p\">,</span>\n    <span class=\"n\">js_indent</span><span class=\"o\">=</span><span class=\"s1\">' '</span> <span class=\"o\">*</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n</pre>\n<p>Optional keyword arguments:</p>\n<ul>\n<li><code>js_module_name</code>: Name of the JavaScript module. (default: 'jsleri')</li>\n<li><code>js_template</code>: Template String used for the export. You might want to look at the default string which can be found at Grammar.JS_TEMPLATE.</li>\n<li><code>js_indent</code>: indentation used in the JavaScript file. (default: 4 spaces)</li>\n</ul>\n<p>For example when using our Quick usage grammar, this is the output when running <code>my_grammar.export_js()</code>:</p>\n<pre><span class=\"cm\">/* jshint newcap: false */</span>\n\n<span class=\"cm\">/*</span>\n<span class=\"cm\"> * This grammar is generated using the Grammar.export_js() method and</span>\n<span class=\"cm\"> * should be used with the jsleri JavaScript module.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * Source class: MyGrammar</span>\n<span class=\"cm\"> * Created at: 2015-11-04 10:06:06</span>\n<span class=\"cm\"> */</span>\n\n<span class=\"s1\">'use strict'</span><span class=\"p\">;</span>\n\n<span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span>\n            <span class=\"nx\">Regex</span><span class=\"p\">,</span>\n            <span class=\"nx\">Sequence</span><span class=\"p\">,</span>\n            <span class=\"nx\">Keyword</span><span class=\"p\">,</span>\n            <span class=\"nx\">Grammar</span>\n        <span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">r_name</span> <span class=\"o\">=</span> <span class=\"nx\">Regex</span><span class=\"p\">(</span><span class=\"s1\">'^(?:\"(?:[^\"]*)\")+'</span><span class=\"p\">);</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">k_hi</span> <span class=\"o\">=</span> <span class=\"nx\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'hi'</span><span class=\"p\">);</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">START</span> <span class=\"o\">=</span> <span class=\"nx\">Sequence</span><span class=\"p\">(</span>\n        <span class=\"nx\">k_hi</span><span class=\"p\">,</span>\n        <span class=\"nx\">r_name</span>\n    <span class=\"p\">);</span>\n\n    <span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">MyGrammar</span> <span class=\"o\">=</span> <span class=\"nx\">Grammar</span><span class=\"p\">(</span><span class=\"nx\">START</span><span class=\"p\">,</span> <span class=\"s1\">'^\\w+'</span><span class=\"p\">);</span>\n\n<span class=\"p\">})(</span>\n    <span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">jsleri</span><span class=\"p\">.</span><span class=\"nx\">Regex</span><span class=\"p\">,</span>\n    <span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">jsleri</span><span class=\"p\">.</span><span class=\"nx\">Sequence</span><span class=\"p\">,</span>\n    <span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">jsleri</span><span class=\"p\">.</span><span class=\"nx\">Keyword</span><span class=\"p\">,</span>\n    <span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">jsleri</span><span class=\"p\">.</span><span class=\"nx\">Grammar</span>\n<span class=\"p\">);</span>\n</pre>\n<h3>export_c</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Grammar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">export_c</span><span class=\"p\">(</span>\n    <span class=\"n\">target</span><span class=\"o\">=</span><span class=\"n\">Grammar</span><span class=\"o\">.</span><span class=\"n\">C_TARGET</span><span class=\"p\">,</span>\n    <span class=\"n\">c_indent</span><span class=\"o\">=</span><span class=\"s1\">' '</span> <span class=\"o\">*</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n</pre>\n<p>Optional keyword arguments:</p>\n<ul>\n<li><code>target</code>: Name of the c module. (default: 'grammar')</li>\n<li><code>c_indent</code>: indentation used in the c files. (default: 4 spaces)</li>\n</ul>\n<p>The return value is a tuple containing the source (c) file and header (h) file.</p>\n<p>For example when using our Quick usage grammar, this is the output when running <code>my_grammar.export_c()</code>:</p>\n<pre><span class=\"cm\">/*</span>\n<span class=\"cm\"> * grammar.c</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * This grammar is generated using the Grammar.export_c() method and</span>\n<span class=\"cm\"> * should be used with the libcleri module.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * Source class: MyGrammar</span>\n<span class=\"cm\"> * Created at: 2016-05-09 12:16:49</span>\n<span class=\"cm\"> */</span>\n\n<span class=\"cp\">#include</span> <span class=\"cpf\">\"grammar.h\"</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\"></span>\n\n<span class=\"cp\">#define CLERI_CASE_SENSITIVE 0</span>\n<span class=\"cp\">#define CLERI_CASE_INSENSITIVE 1</span>\n\n<span class=\"cp\">#define CLERI_FIRST_MATCH 0</span>\n<span class=\"cp\">#define CLERI_MOST_GREEDY 1</span>\n\n<span class=\"n\">cleri_grammar_t</span> <span class=\"o\">*</span> <span class=\"nf\">compile_grammar</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">cleri_t</span> <span class=\"o\">*</span> <span class=\"n\">r_name</span> <span class=\"o\">=</span> <span class=\"n\">cleri_regex</span><span class=\"p\">(</span><span class=\"n\">CLERI_GID_R_NAME</span><span class=\"p\">,</span> <span class=\"s\">\"^(?:</span><span class=\"se\">\\\"</span><span class=\"s\">(?:[^</span><span class=\"se\">\\\"</span><span class=\"s\">]*)</span><span class=\"se\">\\\"</span><span class=\"s\">)+\"</span><span class=\"p\">);</span>\n    <span class=\"n\">cleri_t</span> <span class=\"o\">*</span> <span class=\"n\">k_hi</span> <span class=\"o\">=</span> <span class=\"n\">cleri_keyword</span><span class=\"p\">(</span><span class=\"n\">CLERI_GID_K_HI</span><span class=\"p\">,</span> <span class=\"s\">\"hi\"</span><span class=\"p\">,</span> <span class=\"n\">CLERI_CASE_INSENSITIVE</span><span class=\"p\">);</span>\n    <span class=\"n\">cleri_t</span> <span class=\"o\">*</span> <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">cleri_sequence</span><span class=\"p\">(</span>\n        <span class=\"n\">CLERI_GID_START</span><span class=\"p\">,</span>\n        <span class=\"mi\">2</span><span class=\"p\">,</span>\n        <span class=\"n\">k_hi</span><span class=\"p\">,</span>\n        <span class=\"n\">r_name</span>\n    <span class=\"p\">);</span>\n\n    <span class=\"n\">cleri_grammar_t</span> <span class=\"o\">*</span> <span class=\"n\">grammar</span> <span class=\"o\">=</span> <span class=\"n\">cleri_grammar</span><span class=\"p\">(</span><span class=\"n\">START</span><span class=\"p\">,</span> <span class=\"s\">\"^</span><span class=\"se\">\\\\</span><span class=\"s\">w+\"</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">grammar</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</pre>\n<p>and the header file...</p>\n<pre><span class=\"cm\">/*</span>\n<span class=\"cm\"> * grammar.h</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * This grammar is generated using the Grammar.export_c() method and</span>\n<span class=\"cm\"> * should be used with the libcleri module.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * Source class: MyGrammar</span>\n<span class=\"cm\"> * Created at: 2016-05-09 12:16:49</span>\n<span class=\"cm\"> */</span>\n<span class=\"cp\">#ifndef CLERI_EXPORT_GRAMMAR_H_</span>\n<span class=\"cp\">#define CLERI_EXPORT_GRAMMAR_H_</span>\n\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;grammar.h&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cleri/cleri.h&gt;</span><span class=\"cp\"></span>\n\n<span class=\"n\">cleri_grammar_t</span> <span class=\"o\">*</span> <span class=\"nf\">compile_grammar</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">);</span>\n\n<span class=\"k\">enum</span> <span class=\"n\">cleri_grammar_ids</span> <span class=\"p\">{</span>\n    <span class=\"n\">CLERI_NONE</span><span class=\"p\">,</span>   <span class=\"c1\">// used for objects with no name</span>\n    <span class=\"n\">CLERI_GID_K_HI</span><span class=\"p\">,</span>\n    <span class=\"n\">CLERI_GID_R_NAME</span><span class=\"p\">,</span>\n    <span class=\"n\">CLERI_GID_START</span><span class=\"p\">,</span>\n    <span class=\"n\">CLERI_END</span> <span class=\"c1\">// can be used to get the enum length</span>\n<span class=\"p\">};</span>\n\n<span class=\"cp\">#endif </span><span class=\"cm\">/* CLERI_EXPORT_GRAMMAR_H_ */</span><span class=\"cp\"></span>\n</pre>\n<h3>export_go</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Grammar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">export_go</span><span class=\"p\">(</span>\n    <span class=\"n\">go_template</span><span class=\"o\">=</span><span class=\"n\">Grammar</span><span class=\"o\">.</span><span class=\"n\">GO_TEMPLATE</span><span class=\"p\">,</span>\n    <span class=\"n\">go_indent</span><span class=\"o\">=</span><span class=\"s1\">'</span><span class=\"se\">\\t</span><span class=\"s1\">'</span><span class=\"p\">,</span>\n    <span class=\"n\">go_package</span><span class=\"o\">=</span><span class=\"s1\">'grammar'</span><span class=\"p\">)</span>\n</pre>\n<p>Optional keyword arguments:</p>\n<ul>\n<li><code>go_template</code>: Template String used for the export. You might want to look at the default string which can be found at Grammar.GO_TEMPLATE.</li>\n<li><code>go_indent</code>: indentation used in the Go file. (default: one tab)</li>\n<li><code>go_package</code>: Name of the go package. (default: 'grammar')</li>\n</ul>\n<p>For example when using our Quick usage grammar, this is the output when running <code>my_grammar.export_go()</code>:</p>\n<pre><span class=\"kn\">package</span> <span class=\"nx\">grammar</span>\n\n<span class=\"c1\">// This grammar is generated using the Grammar.export_go() method and</span>\n<span class=\"c1\">// should be used with the goleri module.</span>\n<span class=\"c1\">//</span>\n<span class=\"c1\">// Source class: MyGrammar</span>\n<span class=\"c1\">// Created at: 2017-03-14 19:07:09</span>\n\n<span class=\"kn\">import</span> <span class=\"p\">(</span>\n        <span class=\"s\">\"regexp\"</span>\n\n        <span class=\"s\">\"github.com/transceptor-technology/goleri\"</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\">// Element indentifiers</span>\n<span class=\"kd\">const</span> <span class=\"p\">(</span>\n        <span class=\"nx\">NoGid</span> <span class=\"p\">=</span> <span class=\"kc\">iota</span>\n        <span class=\"nx\">GidKHi</span> <span class=\"p\">=</span> <span class=\"kc\">iota</span>\n        <span class=\"nx\">GidRName</span> <span class=\"p\">=</span> <span class=\"kc\">iota</span>\n        <span class=\"nx\">GidSTART</span> <span class=\"p\">=</span> <span class=\"kc\">iota</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\">// MyGrammar returns a compiled goleri grammar.</span>\n<span class=\"kd\">func</span> <span class=\"nx\">MyGrammar</span><span class=\"p\">()</span> <span class=\"o\">*</span><span class=\"nx\">goleri</span><span class=\"p\">.</span><span class=\"nx\">Grammar</span> <span class=\"p\">{</span>\n        <span class=\"nx\">rName</span> <span class=\"o\">:=</span> <span class=\"nx\">goleri</span><span class=\"p\">.</span><span class=\"nx\">NewRegex</span><span class=\"p\">(</span><span class=\"nx\">GidRName</span><span class=\"p\">,</span> <span class=\"nx\">regexp</span><span class=\"p\">.</span><span class=\"nx\">MustCompile</span><span class=\"p\">(</span><span class=\"s\">`^(?:\"(?:[^\"]*)\")+`</span><span class=\"p\">))</span>\n        <span class=\"nx\">kHi</span> <span class=\"o\">:=</span> <span class=\"nx\">goleri</span><span class=\"p\">.</span><span class=\"nx\">NewKeyword</span><span class=\"p\">(</span><span class=\"nx\">GidKHi</span><span class=\"p\">,</span> <span class=\"s\">\"hi\"</span><span class=\"p\">,</span> <span class=\"kc\">false</span><span class=\"p\">)</span>\n        <span class=\"nx\">START</span> <span class=\"o\">:=</span> <span class=\"nx\">goleri</span><span class=\"p\">.</span><span class=\"nx\">NewSequence</span><span class=\"p\">(</span>\n                <span class=\"nx\">GidSTART</span><span class=\"p\">,</span>\n                <span class=\"nx\">kHi</span><span class=\"p\">,</span>\n                <span class=\"nx\">rName</span><span class=\"p\">,</span>\n        <span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"nx\">goleri</span><span class=\"p\">.</span><span class=\"nx\">NewGrammar</span><span class=\"p\">(</span><span class=\"nx\">START</span><span class=\"p\">,</span> <span class=\"nx\">regexp</span><span class=\"p\">.</span><span class=\"nx\">MustCompile</span><span class=\"p\">(</span><span class=\"s\">`^\\w+`</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</pre>\n<h3>export_java</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Grammar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">export_java</span><span class=\"p\">(</span>\n    <span class=\"n\">java_template</span><span class=\"o\">=</span><span class=\"n\">Grammar</span><span class=\"o\">.</span><span class=\"n\">JAVA_TEMPLATE</span><span class=\"p\">,</span>\n    <span class=\"n\">java_indent</span><span class=\"o\">=</span><span class=\"s1\">' '</span> <span class=\"o\">*</span> <span class=\"mi\">4</span><span class=\"p\">,</span>\n    <span class=\"n\">java_package</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n    <span class=\"n\">is_public</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>Optional keyword arguments:</p>\n<ul>\n<li><code>java_template</code>: Template String used for the export. You might want to look at the default string which can be found at Grammar.JAVA_TEMPLATE.</li>\n<li><code>java_indent</code>: indentation used in the Java file. (default: four spaces)</li>\n<li><code>java_package</code>: Name of the Java package or None when no package is specified. (default: None)</li>\n<li><code>is_public</code>: Class and constructor are defined as public when True, else they will be defined as package private.</li>\n</ul>\n<p>For example when using our Quick usage grammar, this is the output when running <code>my_grammar.export_java()</code>:</p>\n<pre><span class=\"cm\">/**</span>\n<span class=\"cm\"> * This grammar is generated using the Grammar.export_java() method and</span>\n<span class=\"cm\"> * should be used with the jleri module.</span>\n<span class=\"cm\"> *</span>\n<span class=\"cm\"> * Source class: MyGrammar</span>\n<span class=\"cm\"> * Created at: 2018-07-04 12:12:34</span>\n<span class=\"cm\"> */</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">jleri.Grammar</span><span class=\"p\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">jleri.Element</span><span class=\"p\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">jleri.Sequence</span><span class=\"p\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">jleri.Regex</span><span class=\"p\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">jleri.Keyword</span><span class=\"p\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyGrammar</span> <span class=\"kd\">extends</span> <span class=\"n\">Grammar</span> <span class=\"p\">{</span>\n    <span class=\"kd\">enum</span> <span class=\"n\">Ids</span> <span class=\"p\">{</span>\n        <span class=\"n\">K_HI</span><span class=\"p\">,</span>\n        <span class=\"n\">R_NAME</span><span class=\"p\">,</span>\n        <span class=\"n\">START</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">Element</span> <span class=\"n\">R_NAME</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Regex</span><span class=\"p\">(</span><span class=\"n\">Ids</span><span class=\"p\">.</span><span class=\"na\">R_NAME</span><span class=\"p\">,</span> <span class=\"s\">\"^(?:\\\"(?:[^\\\"]*)\\\")+\"</span><span class=\"p\">);</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">Element</span> <span class=\"n\">K_HI</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"n\">Ids</span><span class=\"p\">.</span><span class=\"na\">K_HI</span><span class=\"p\">,</span> <span class=\"s\">\"hi\"</span><span class=\"p\">,</span> <span class=\"kc\">false</span><span class=\"p\">);</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">Element</span> <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Sequence</span><span class=\"p\">(</span>\n        <span class=\"n\">Ids</span><span class=\"p\">.</span><span class=\"na\">START</span><span class=\"p\">,</span>\n        <span class=\"n\">K_HI</span><span class=\"p\">,</span>\n        <span class=\"n\">R_NAME</span>\n    <span class=\"p\">);</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">MyGrammar</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n        <span class=\"kd\">super</span><span class=\"p\">(</span><span class=\"n\">START</span><span class=\"p\">,</span> <span class=\"s\">\"^\\\\w+\"</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n<h3>export_py</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Grammar</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">export_py</span><span class=\"p\">(</span>\n    <span class=\"n\">py_module_name</span><span class=\"o\">=</span><span class=\"s1\">'pyleri'</span><span class=\"p\">,</span>\n    <span class=\"n\">py_template</span><span class=\"o\">=</span><span class=\"n\">Grammar</span><span class=\"o\">.</span><span class=\"n\">PY_TEMPLATE</span><span class=\"p\">,</span>\n    <span class=\"n\">py_indent</span><span class=\"o\">=</span><span class=\"s1\">' '</span> <span class=\"o\">*</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n</pre>\n<p>Optional keyword arguments:</p>\n<ul>\n<li><code>py_module_name</code>: Name of the Pyleri Module. (default: 'pyleri')</li>\n<li><code>py_template</code>: Template String used for the export. You might want to look at the default string which can be found at Grammar.PY_TEMPLATE.</li>\n<li><code>py_indent</code>: indentation used in the Python file. (default: 4 spaces)</li>\n</ul>\n<p>For example when using our Quick usage grammar, this is the output when running <code>my_grammar.export_py()</code>:</p>\n<pre><span class=\"sd\">\"\"\"</span>\n<span class=\"sd\"> This grammar is generated using the Grammar.export_py() method and</span>\n<span class=\"sd\"> should be used with the pyleri python module.</span>\n\n<span class=\"sd\"> Source class: MyGrammar</span>\n<span class=\"sd\"> Created at: 2017-03-14 19:14:51</span>\n<span class=\"sd\">\"\"\"</span>\n<span class=\"kn\">import</span> <span class=\"nn\">re</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Sequence</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Keyword</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Grammar</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Regex</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyGrammar</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n\n    <span class=\"n\">RE_KEYWORDS</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"s1\">'^</span><span class=\"se\">\\\\</span><span class=\"s1\">w+'</span><span class=\"p\">)</span>\n    <span class=\"n\">r_name</span> <span class=\"o\">=</span> <span class=\"n\">Regex</span><span class=\"p\">(</span><span class=\"s1\">'^(?:\"(?:[^\"]*)\")+'</span><span class=\"p\">)</span>\n    <span class=\"n\">k_hi</span> <span class=\"o\">=</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'hi'</span><span class=\"p\">)</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">(</span>\n        <span class=\"n\">k_hi</span><span class=\"p\">,</span>\n        <span class=\"n\">r_name</span>\n    <span class=\"p\">)</span>\n</pre>\n<h2>Result</h2>\n<p>The result of the <code>parse()</code> method contains 4 properties that will be explained next. A function <code>as_str(translate=None)</code> is also available which will\nshow the result as a string. The <code>translate</code> argument should be a function which accepts an element as argument. This function can be used to\nreturn custom strings for certain elements. If the return value of <code>translate</code> is <code>None</code> then the function will fall try to generate a string value. If\nthe return value is an empty string, the value will be ignored.</p>\n<p>Example of translate functions:</p>\n<pre><span class=\"c1\"># In case a translation function returns an empty string, no text is used</span>\n<span class=\"k\">def</span> <span class=\"nf\">translate</span><span class=\"p\">(</span><span class=\"n\">elem</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"s1\">''</span>  <span class=\"c1\"># as a result you get something like: 'error at position x'</span>\n\n<span class=\"c1\"># Text may be returned based on gid</span>\n<span class=\"k\">def</span> <span class=\"nf\">translate</span><span class=\"p\">(</span><span class=\"n\">elem</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">elem</span> <span class=\"ow\">is</span> <span class=\"n\">some_elem</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"s1\">'A'</span>   <span class=\"c1\"># something like: error at position x, expecting: A</span>\n    <span class=\"k\">elif</span> <span class=\"n\">elem</span> <span class=\"ow\">is</span> <span class=\"n\">other_elem</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"s1\">''</span>    <span class=\"c1\"># other_elem will be ignored</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"kc\">None</span>  <span class=\"c1\"># normal parsing</span>\n\n<span class=\"c1\"># A translate function can be used as follow:</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">my_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'some string'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">as_str</span><span class=\"p\">(</span><span class=\"n\">translate</span><span class=\"o\">=</span><span class=\"n\">translate</span><span class=\"p\">))</span>\n</pre>\n<h3>is_valid</h3>\n<p><code>is_valid</code> returns a boolean value, <code>True</code> when the given string is valid according to the given grammar, <code>False</code> when not valid.</p>\n<p>Let us take the example from Quick usage.</p>\n<pre><span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">my_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'bye \"Iris\"'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">is_valid</span><span class=\"p\">)</span> <span class=\"c1\"># =&gt; False</span>\n</pre>\n<h3>Position</h3>\n<p><code>pos</code> returns the position where the parser had to stop. (when <code>is_valid</code> is <code>True</code> this value will be equal to the length of the given string with <code>str.rstrip()</code> applied)</p>\n<p>Let us take the example from Quick usage.</p>\n<pre><span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">my_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'hi Iris'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">is_valid</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"n\">pos</span><span class=\"p\">)</span> <span class=\"c1\"># =&gt; False, 3</span>\n</pre>\n<h3>Tree</h3>\n<p><code>tree</code> contains the parse tree. Even when <code>is_valid</code> is <code>False</code> the parse tree is returned but will only contain results as far as parsing has succeeded. The tree is the root node which can include several <code>children</code> nodes. The structure will be further clarified in the following example which explains a way of visualizing the parse tree.</p>\n<p>Example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">json</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Choice</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Grammar</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Keyword</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Regex</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Repeat</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Sequence</span>\n\n\n<span class=\"c1\"># Create a Grammar Class to define your language</span>\n<span class=\"k\">class</span> <span class=\"nc\">MyGrammar</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">r_name</span> <span class=\"o\">=</span> <span class=\"n\">Regex</span><span class=\"p\">(</span><span class=\"s1\">'(?:\"(?:[^\"]*)\")+'</span><span class=\"p\">)</span>\n    <span class=\"n\">k_hi</span> <span class=\"o\">=</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'hi'</span><span class=\"p\">)</span>\n    <span class=\"n\">k_bye</span> <span class=\"o\">=</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'bye'</span><span class=\"p\">)</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">Repeat</span><span class=\"p\">(</span><span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"n\">Choice</span><span class=\"p\">(</span><span class=\"n\">k_hi</span><span class=\"p\">,</span> <span class=\"n\">k_bye</span><span class=\"p\">),</span> <span class=\"n\">r_name</span><span class=\"p\">))</span>\n\n\n<span class=\"c1\"># Returns properties of a node object as a dictionary:</span>\n<span class=\"k\">def</span> <span class=\"nf\">node_props</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">,</span> <span class=\"n\">children</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'start'</span><span class=\"p\">:</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">,</span>\n        <span class=\"s1\">'end'</span><span class=\"p\">:</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">end</span><span class=\"p\">,</span>\n        <span class=\"s1\">'name'</span><span class=\"p\">:</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"n\">name</span> <span class=\"k\">if</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"s1\">'name'</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"kc\">None</span><span class=\"p\">,</span>\n        <span class=\"s1\">'element'</span><span class=\"p\">:</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">element</span><span class=\"o\">.</span><span class=\"vm\">__class__</span><span class=\"o\">.</span><span class=\"vm\">__name__</span><span class=\"p\">,</span>\n        <span class=\"s1\">'string'</span><span class=\"p\">:</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">string</span><span class=\"p\">,</span>\n        <span class=\"s1\">'children'</span><span class=\"p\">:</span> <span class=\"n\">children</span><span class=\"p\">}</span>\n\n\n<span class=\"c1\"># Recursive method to get the children of a node object:</span>\n<span class=\"k\">def</span> <span class=\"nf\">get_children</span><span class=\"p\">(</span><span class=\"n\">children</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"p\">[</span><span class=\"n\">node_props</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">get_children</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">children</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">c</span> <span class=\"ow\">in</span> <span class=\"n\">children</span><span class=\"p\">]</span>\n\n\n<span class=\"c1\"># View the parse tree:</span>\n<span class=\"k\">def</span> <span class=\"nf\">view_parse_tree</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">):</span>\n    <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">children</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> \\\n        <span class=\"k\">if</span> <span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">children</span> <span class=\"k\">else</span> <span class=\"n\">res</span><span class=\"o\">.</span><span class=\"n\">tree</span>\n    <span class=\"k\">return</span> <span class=\"n\">node_props</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">get_children</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"o\">.</span><span class=\"n\">children</span><span class=\"p\">))</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Compile your grammar by creating an instance of the Grammar Class:</span>\n    <span class=\"n\">my_grammar</span> <span class=\"o\">=</span> <span class=\"n\">MyGrammar</span><span class=\"p\">()</span>\n    <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">my_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'hi \"siri\" bye \"siri\"'</span><span class=\"p\">)</span>\n    <span class=\"c1\"># The parse tree is visualized as a JSON object:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"n\">view_parse_tree</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">),</span> <span class=\"n\">indent</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">))</span>\n</pre>\n<p>Part of the output is shown below.</p>\n<pre>    <span class=\"p\">{</span>\n    <span class=\"nt\">\"start\"</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"end\"</span><span class=\"p\">:</span> <span class=\"mi\">23</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"START\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"element\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Repeat\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"string\"</span><span class=\"p\">:</span> <span class=\"s2\">\"hi \\\"pyleri\\\" hi \\\"pyleri\\\"\"</span><span class=\"p\">,</span>\n    <span class=\"nt\">\"children\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n        <span class=\"p\">{</span>\n        <span class=\"nt\">\"start\"</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n        <span class=\"nt\">\"end\"</span><span class=\"p\">:</span> <span class=\"mi\">11</span><span class=\"p\">,</span>\n        <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"kc\">null</span><span class=\"p\">,</span>\n        <span class=\"nt\">\"element\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Sequence\"</span><span class=\"p\">,</span>\n        <span class=\"nt\">\"string\"</span><span class=\"p\">:</span> <span class=\"s2\">\"hi \\\"pyleri\\\"\"</span><span class=\"p\">,</span>\n        <span class=\"nt\">\"children\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n            <span class=\"p\">{</span>\n            <span class=\"nt\">\"start\"</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"end\"</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"kc\">null</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"element\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Choice\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"string\"</span><span class=\"p\">:</span> <span class=\"s2\">\"hi\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"children\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n                <span class=\"p\">{</span>\n                <span class=\"nt\">\"start\"</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n                <span class=\"nt\">\"end\"</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span>\n                <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"k_hi\"</span><span class=\"p\">,</span>\n                <span class=\"nt\">\"element\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Keyword\"</span><span class=\"p\">,</span>\n                <span class=\"nt\">\"string\"</span><span class=\"p\">:</span> <span class=\"s2\">\"hi\"</span><span class=\"p\">,</span>\n                <span class=\"nt\">\"children\"</span><span class=\"p\">:</span> <span class=\"p\">[]</span>\n                <span class=\"p\">}</span>\n            <span class=\"p\">]</span>\n            <span class=\"p\">},</span>\n            <span class=\"p\">{</span>\n            <span class=\"nt\">\"start\"</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"end\"</span><span class=\"p\">:</span> <span class=\"mi\">11</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"r_name\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"element\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Regex\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"string\"</span><span class=\"p\">:</span> <span class=\"s2\">\"\\\"pyleri\\\"\"</span><span class=\"p\">,</span>\n            <span class=\"nt\">\"children\"</span><span class=\"p\">:</span> <span class=\"p\">[]</span>\n            <span class=\"p\">}</span>\n\n            <span class=\"s2\">\"...\"</span>\n            <span class=\"s2\">\"...\"</span>\n</pre>\n<p>A node contains 5 properties that will be explained next:</p>\n<ul>\n<li><code>start</code> property returns the start of the node object.</li>\n<li><code>end</code> property returns the end of the  node object.</li>\n<li><code>element</code> returns the type of <a href=\"#elements\" rel=\"nofollow\">Element</a> (e.g. Repeat, Sequence, Keyword, etc.). An element can be assigned to a variable; for instance in the example above <code>Keyword('hi')</code> was assigned to <code>k_hi</code>. With <code>element.name</code> the assigned name <code>k_hi</code> will be returned. Note that it is not a given that an element is named; in our example <code>Sequence</code> was not assigned, thus in this case the element has no attribute <code>name</code>.</li>\n<li><code>string</code> returns the string that is parsed.</li>\n<li><code>children</code> can return a node object containing deeper layered nodes provided that there are any. In our example the root node has an element type <code>Repeat()</code>, starts at 0 and ends at 24, and it has two <code>children</code>. These children are node objects that have both an element type <code>Sequence</code>, start at 0 and 12 respectively, and so on.</li>\n</ul>\n<h3>Expecting</h3>\n<p><code>expecting</code> returns a Python set() containing elements which pyleri expects at <code>pos</code>. Even if <code>is_valid</code> is true there might be elements in this set, for example when an <code>Optional()</code> element could be added to the string. Expecting is useful if you want to implement things like auto-completion, syntax error handling, auto-syntax-correction etc. The following example will illustrate a way of implementation.</p>\n<p>Example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">re</span>\n<span class=\"kn\">import</span> <span class=\"nn\">random</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Choice</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Grammar</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Keyword</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Repeat</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">Sequence</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pyleri</span> <span class=\"kn\">import</span> <span class=\"n\">end_of_statement</span>\n\n\n<span class=\"c1\"># Create a Grammar Class to define your language.</span>\n<span class=\"k\">class</span> <span class=\"nc\">MyGrammar</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">RE_KEYWORDS</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'\\S+'</span><span class=\"p\">)</span>\n    <span class=\"n\">r_name</span> <span class=\"o\">=</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'\"pyleri\"'</span><span class=\"p\">)</span>\n    <span class=\"n\">k_hi</span> <span class=\"o\">=</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'hi'</span><span class=\"p\">)</span>\n    <span class=\"n\">k_bye</span> <span class=\"o\">=</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'bye'</span><span class=\"p\">)</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">Repeat</span><span class=\"p\">(</span><span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"n\">Choice</span><span class=\"p\">(</span><span class=\"n\">k_hi</span><span class=\"p\">,</span> <span class=\"n\">k_bye</span><span class=\"p\">),</span> <span class=\"n\">r_name</span><span class=\"p\">),</span> <span class=\"n\">mi</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># Print the expected elements as a indented and numbered list.</span>\n<span class=\"k\">def</span> <span class=\"nf\">print_expecting</span><span class=\"p\">(</span><span class=\"n\">node_expecting</span><span class=\"p\">,</span> <span class=\"n\">string_expecting</span><span class=\"p\">):</span>\n    <span class=\"k\">for</span> <span class=\"n\">loop</span><span class=\"p\">,</span> <span class=\"n\">e</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"n\">node_expecting</span><span class=\"p\">):</span>\n        <span class=\"n\">string_expecting</span> <span class=\"o\">=</span> <span class=\"s1\">'</span><span class=\"si\">{}</span><span class=\"se\">\\n\\t</span><span class=\"s1\">(</span><span class=\"si\">{}</span><span class=\"s1\">) </span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">string_expecting</span><span class=\"p\">,</span> <span class=\"n\">loop</span><span class=\"p\">,</span> <span class=\"n\">e</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">string_expecting</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># Complete a string until it is valid according to the grammar.</span>\n<span class=\"k\">def</span> <span class=\"nf\">auto_correction</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">,</span> <span class=\"n\">my_grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">my_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'</span><span class=\"se\">\\n</span><span class=\"s1\">Parsed string: </span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">string</span><span class=\"p\">))</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">is_valid</span><span class=\"p\">:</span>\n        <span class=\"n\">string_expecting</span> <span class=\"o\">=</span> <span class=\"s1\">'String is valid. </span><span class=\"se\">\\n</span><span class=\"s1\">Expected: '</span>\n        <span class=\"n\">print_expecting</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">expecting</span><span class=\"p\">,</span> <span class=\"n\">string_expecting</span><span class=\"p\">)</span>\n\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">string_expecting</span> <span class=\"o\">=</span> <span class=\"s1\">'String is NOT valid.</span><span class=\"se\">\\n</span><span class=\"s1\">Expected: '</span> \\\n            <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">pos</span> \\\n            <span class=\"k\">else</span> <span class=\"s1\">'String is NOT valid. </span><span class=\"se\">\\n</span><span class=\"s1\">After \"</span><span class=\"si\">{}</span><span class=\"s1\">\" expected: '</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span>\n                                                  <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">string</span><span class=\"p\">[:</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">pos</span><span class=\"p\">])</span>\n        <span class=\"n\">print_expecting</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">expecting</span><span class=\"p\">,</span> <span class=\"n\">string_expecting</span><span class=\"p\">)</span>\n\n        <span class=\"n\">selected</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">choice</span><span class=\"p\">(</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">expecting</span><span class=\"p\">))</span>\n        <span class=\"n\">string</span> <span class=\"o\">=</span> <span class=\"s1\">'</span><span class=\"si\">{}</span><span class=\"s1\"> </span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">tree</span><span class=\"o\">.</span><span class=\"n\">string</span><span class=\"p\">[:</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">pos</span><span class=\"p\">],</span>\n                                <span class=\"n\">selected</span>\n                                <span class=\"k\">if</span> <span class=\"n\">selected</span>\n                                <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"n\">end_of_statement</span> <span class=\"k\">else</span> <span class=\"s1\">''</span><span class=\"p\">)</span>\n\n        <span class=\"n\">auto_correction</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">,</span> <span class=\"n\">my_grammar</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Compile your grammar by creating an instance of the Grammar Class.</span>\n    <span class=\"n\">my_grammar</span> <span class=\"o\">=</span> <span class=\"n\">MyGrammar</span><span class=\"p\">()</span>\n    <span class=\"n\">string</span> <span class=\"o\">=</span> <span class=\"s1\">'hello \"pyleri\"'</span>\n    <span class=\"n\">auto_correction</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">,</span> <span class=\"n\">my_grammar</span><span class=\"p\">)</span>\n</pre>\n<p>Output:</p>\n<pre><code>Parsed string: hello \"pyleri\"\nString is NOT valid.\nExpected:\n        (1) hi\n        (2) bye\n\nParsed string:  bye\nString is NOT valid.\nAfter \" bye\" expected:\n        (1) \"pyleri\"\n\nParsed string:  bye \"pyleri\"\nString is NOT valid.\nAfter \" bye \"pyleri\"\" expected:\n        (1) hi\n        (2) bye\n\nParsed string:  bye \"pyleri\" hi\nString is NOT valid.\nAfter \" bye \"pyleri\" hi\" expected:\n        (1) \"pyleri\"\n\nParsed string:  bye \"pyleri\" hi \"pyleri\"\nString is valid.\nExpected:\n        (1) hi\n        (2) bye\n\n</code></pre>\n<p>In the above example we parsed an invalid string according to the grammar class. The <code>auto-correction()</code> method that we built for this example combines all properties from the <code>parse()</code> to create a valid string. The output shows every recursion of the <code>auto-correction()</code> method and prints successively the set of expected elements. It takes one randomly and adds it to the string. When the string corresponds to the grammar, the property <code>is_valid</code> will return <code>True</code>. Notably the <code>expecting</code> property still contains elements even if the <code>is_valid</code> returned <code>True</code>. The reason in this example is because of the <a href=\"#repeat\" rel=\"nofollow\">Repeat</a> element.</p>\n<h2>Elements</h2>\n<p>Pyleri has several elements which are all subclasses of <a href=\"#element\" rel=\"nofollow\">Element</a> and can be used to create a grammar.</p>\n<h3>Keyword</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"n\">keyword</span><span class=\"p\">,</span> <span class=\"n\">ign_case</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>The parser needs to match the keyword which is just a string. When matching keywords we need to tell the parser what characters are allowed in keywords. By default Pyleri uses <code>^\\w+</code> which is both in Python and JavaScript equal to <code>^[A-Za-z0-9_]+</code>. We can overwrite the default by setting <code>RE_KEYWORDS</code> in the grammar. Keyword() accepts one keyword argument <code>ign_case</code> to tell the parser if we should match case insensitive.</p>\n<p>Example:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">TicTacToe</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Let's allow keywords with alphabetic characters and dashes.</span>\n    <span class=\"n\">RE_KEYWORDS</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"o\">.</span><span class=\"n\">compile</span><span class=\"p\">(</span><span class=\"s1\">'^[A-Za-z-]+'</span><span class=\"p\">)</span>\n\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'tic-tac-toe'</span><span class=\"p\">,</span> <span class=\"n\">ign_case</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"n\">ttt_grammar</span> <span class=\"o\">=</span> <span class=\"n\">TicTacToe</span><span class=\"p\">()</span>\n<span class=\"n\">ttt_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'Tic-Tac-Toe'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span>  <span class=\"c1\"># =&gt; True</span>\n</pre>\n<h3>Regex</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Regex</span><span class=\"p\">(</span><span class=\"n\">pattern</span><span class=\"p\">,</span> <span class=\"n\">flags</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n</pre>\n<p>The parser compiles a regular expression using the <code>re</code> module. The current version of pyleri has only support for the <code>re.IGNORECASE</code> flag.\nSee the <a href=\"#quick-usage\" rel=\"nofollow\">Quick usage</a> example for how to use <code>Regex</code>.</p>\n<h3>Token</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Token</span><span class=\"p\">(</span><span class=\"n\">token</span><span class=\"p\">)</span>\n</pre>\n<p>A token can be one or more characters and is usually used to match operators like <code>+</code>, <code>-</code>, <code>//</code> and so on. When we parse a string object where pyleri expects an element, it will automatically be converted to a <code>Token()</code> object.</p>\n<p>Example:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Ni</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">t_dash</span> <span class=\"o\">=</span> <span class=\"n\">Token</span><span class=\"p\">(</span><span class=\"s1\">'-'</span><span class=\"p\">)</span>\n    <span class=\"c1\"># We could just write delimiter='-' because</span>\n    <span class=\"c1\"># any string will be converted to Token()</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'ni'</span><span class=\"p\">),</span> <span class=\"n\">delimiter</span><span class=\"o\">=</span><span class=\"n\">t_dash</span><span class=\"p\">)</span>\n\n<span class=\"n\">ni</span> <span class=\"o\">=</span> <span class=\"n\">Ni</span><span class=\"p\">()</span>\n<span class=\"n\">ni</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'ni-ni-ni-ni-ni'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span>  <span class=\"c1\"># =&gt; True</span>\n</pre>\n<h3>Tokens</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Tokens</span><span class=\"p\">(</span><span class=\"n\">tokens</span><span class=\"p\">)</span>\n</pre>\n<p>Can be used to register multiple tokens at once. The <code>tokens</code> argument should be a string with tokens separated by spaces. If given tokens are different in size the parser will try to match the longest tokens first.</p>\n<p>Example:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Ni</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">tks</span> <span class=\"o\">=</span> <span class=\"n\">Tokens</span><span class=\"p\">(</span><span class=\"s1\">'+ - !='</span><span class=\"p\">)</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'ni'</span><span class=\"p\">),</span> <span class=\"n\">delimiter</span><span class=\"o\">=</span><span class=\"n\">tks</span><span class=\"p\">)</span>\n\n<span class=\"n\">ni</span> <span class=\"o\">=</span> <span class=\"n\">Ni</span><span class=\"p\">()</span>\n<span class=\"n\">ni</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'ni + ni != ni - ni'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span>  <span class=\"c1\"># =&gt; True</span>\n</pre>\n<h3>Sequence</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n<p>The parser needs to match each element in a sequence.</p>\n<p>Example:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">TicTacToe</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'Tic'</span><span class=\"p\">),</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'Tac'</span><span class=\"p\">),</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'Toe'</span><span class=\"p\">))</span>\n\n<span class=\"n\">ttt_grammar</span> <span class=\"o\">=</span> <span class=\"n\">TicTacToe</span><span class=\"p\">()</span>\n<span class=\"n\">ttt_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'Tic Tac Toe'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span>  <span class=\"c1\"># =&gt; True</span>\n</pre>\n<h3>Choice</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Choice</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span> <span class=\"n\">most_greedy</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</pre>\n<p>The parser needs to choose between one of the given elements. Choice accepts one keyword argument <code>most_greedy</code> which is <code>True</code> by default. When <code>most_greedy</code> is set to <code>False</code> the parser will stop at the first match. When <code>True</code> the parser will try each element and returns the longest match. Setting <code>most_greedy</code> to <code>False</code> can provide some extra performance. Note that the parser will try to match each element in the exact same order they are parsed to Choice.</p>\n<p>Example: let us use <code>Choice</code> to modify the Quick usage example to allow the string 'bye \"Iris\"'</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyGrammar</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">r_name</span> <span class=\"o\">=</span> <span class=\"n\">Regex</span><span class=\"p\">(</span><span class=\"s1\">'(?:\"(?:[^\"]*)\")+'</span><span class=\"p\">)</span>\n    <span class=\"n\">k_hi</span> <span class=\"o\">=</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'hi'</span><span class=\"p\">)</span>\n    <span class=\"n\">k_bye</span> <span class=\"o\">=</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'bye'</span><span class=\"p\">)</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"n\">Choice</span><span class=\"p\">(</span><span class=\"n\">k_hi</span><span class=\"p\">,</span> <span class=\"n\">k_bye</span><span class=\"p\">),</span> <span class=\"n\">r_name</span><span class=\"p\">)</span>\n\n<span class=\"n\">my_grammar</span> <span class=\"o\">=</span> <span class=\"n\">MyGrammar</span><span class=\"p\">()</span>\n<span class=\"n\">my_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'hi \"Iris\"'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span>  <span class=\"c1\"># =&gt; True</span>\n<span class=\"n\">my_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'bye \"Iris\"'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span>  <span class=\"c1\"># =&gt; True</span>\n</pre>\n<h3>Repeat</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Repeat</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"n\">mi</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">ma</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n</pre>\n<p>The parser needs at least <code>mi</code> elements and at most <code>ma</code> elements. When <code>ma</code> is set to <code>None</code> we allow unlimited number of elements. <code>mi</code> can be any integer value equal or higher than 0 but not larger then <code>ma</code>.</p>\n<p>Example:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Ni</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">Repeat</span><span class=\"p\">(</span><span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'ni'</span><span class=\"p\">))</span>\n\n<span class=\"n\">ni</span> <span class=\"o\">=</span> <span class=\"n\">Ni</span><span class=\"p\">()</span>\n<span class=\"n\">ni</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'ni ni ni ni ni'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span>  <span class=\"c1\"># =&gt; True</span>\n</pre>\n<p>It is not allowed to bind a name to the same element twice and Repeat(element, 1, 1) is a common solution to bind the element a second (or more) time(s).</p>\n<p>For example consider the following:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyGrammar</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">r_name</span> <span class=\"o\">=</span> <span class=\"n\">Regex</span><span class=\"p\">(</span><span class=\"s1\">'(?:\"(?:[^\"]*)\")+'</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Raises a SyntaxError because we try to bind a second time.</span>\n    <span class=\"n\">r_address</span> <span class=\"o\">=</span> <span class=\"n\">r_name</span> <span class=\"c1\"># WRONG</span>\n\n    <span class=\"c1\"># Instead use Repeat</span>\n    <span class=\"n\">r_address</span> <span class=\"o\">=</span> <span class=\"n\">Repeat</span><span class=\"p\">(</span><span class=\"n\">r_name</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\"># RIGHT</span>\n</pre>\n<h3>List</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"n\">delimiter</span><span class=\"o\">=</span><span class=\"s1\">','</span><span class=\"p\">,</span> <span class=\"n\">mi</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">ma</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">opt</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>List is like Repeat but with a delimiter. A comma is used as default delimiter but any element is allowed. When a string is used as delimiter it will be converted to a <code>Token</code> element. <code>mi</code> and <code>ma</code> work exactly like with Repeat. An optional keyword argument <code>opt</code> can be set to <code>True</code> to allow the list to end with a delimiter. By default this is set to <code>False</code> which means the list has to end with an element.</p>\n<p>Example:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Ni</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'ni'</span><span class=\"p\">))</span>\n\n<span class=\"n\">ni</span> <span class=\"o\">=</span> <span class=\"n\">Ni</span><span class=\"p\">()</span>\n<span class=\"n\">ni</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'ni, ni, ni, ni, ni'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span>  <span class=\"c1\"># =&gt; True</span>\n</pre>\n<h3>Optional</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Optional</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span>\n</pre>\n<p>The parser looks for an optional element. It is like using <code>Repeat(element, 0, 1)</code> but we encourage to use <code>Optional</code> since it is more readable. (and slightly faster)</p>\n<p>Example:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">MyGrammar</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">r_name</span> <span class=\"o\">=</span> <span class=\"n\">Regex</span><span class=\"p\">(</span><span class=\"s1\">'(?:\"(?:[^\"]*)\")+'</span><span class=\"p\">)</span>\n    <span class=\"n\">k_hi</span> <span class=\"o\">=</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'hi'</span><span class=\"p\">)</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"n\">k_hi</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">(</span><span class=\"n\">r_name</span><span class=\"p\">))</span>\n\n<span class=\"n\">my_grammar</span> <span class=\"o\">=</span> <span class=\"n\">MyGrammar</span><span class=\"p\">()</span>\n<span class=\"n\">my_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'hi \"Iris\"'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span>  <span class=\"c1\"># =&gt; True</span>\n<span class=\"n\">my_grammar</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'hi'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span>  <span class=\"c1\"># =&gt; True</span>\n</pre>\n<h3>Ref</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Ref</span><span class=\"p\">()</span>\n</pre>\n<p>The grammar can make a forward reference to make recursion possible. In the example below we create a forward reference to START but note that\na reference to any element can be made.</p>\n<blockquote>\n<p>Warning: A reference is not protected against testing the same position in\na string. This could potentially lead to an infinite loop.\nFor example:</p>\n<pre><span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">Ref</span><span class=\"p\">()</span>\n<span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">Optional</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">)</span>  <span class=\"c1\"># DON'T DO THIS</span>\n</pre>\n<p>Use <a href=\"#prio\" rel=\"nofollow\">Prio</a> if such recursive construction is required.</p>\n</blockquote>\n<p>Example:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">NestedNi</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">Ref</span><span class=\"p\">()</span>\n    <span class=\"n\">ni_item</span> <span class=\"o\">=</span> <span class=\"n\">Choice</span><span class=\"p\">(</span><span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'ni'</span><span class=\"p\">),</span> <span class=\"n\">START</span><span class=\"p\">)</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"s1\">'['</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">(</span><span class=\"n\">ni_item</span><span class=\"p\">),</span> <span class=\"s1\">']'</span><span class=\"p\">)</span>\n\n<span class=\"n\">nested_ni</span> <span class=\"o\">=</span> <span class=\"n\">NestedNi</span><span class=\"p\">()</span>\n<span class=\"n\">nested_ni</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'[ni, ni, [ni, [], [ni, ni]]]'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span>  <span class=\"c1\"># =&gt; True</span>\n</pre>\n<h3>Prio</h3>\n<p>syntax:</p>\n<pre><span class=\"n\">Prio</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n<p>Choose the first match from the prio elements and allow <code>THIS</code> for recursive operations. With <code>THIS</code> we point to the <code>Prio</code> element. Probably the example below explains how <code>Prio</code> and <code>THIS</code> can be used.</p>\n<blockquote>\n<p>Note: Use a <a href=\"#ref\" rel=\"nofollow\">Ref</a> when possible.\nA <code>Prio</code> element is required when the same position in a string is potentially\nchecked more than once.</p>\n</blockquote>\n<p>Example:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">Ni</span><span class=\"p\">(</span><span class=\"n\">Grammar</span><span class=\"p\">):</span>\n    <span class=\"n\">k_ni</span> <span class=\"o\">=</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'ni'</span><span class=\"p\">)</span>\n    <span class=\"n\">START</span> <span class=\"o\">=</span> <span class=\"n\">Prio</span><span class=\"p\">(</span>\n        <span class=\"n\">k_ni</span><span class=\"p\">,</span>\n        <span class=\"c1\"># '(' and ')' are automatically converted to Token('(') and Token(')')</span>\n        <span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"s1\">'('</span><span class=\"p\">,</span> <span class=\"n\">THIS</span><span class=\"p\">,</span> <span class=\"s1\">')'</span><span class=\"p\">),</span>\n        <span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"n\">THIS</span><span class=\"p\">,</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'or'</span><span class=\"p\">),</span> <span class=\"n\">THIS</span><span class=\"p\">),</span>\n        <span class=\"n\">Sequence</span><span class=\"p\">(</span><span class=\"n\">THIS</span><span class=\"p\">,</span> <span class=\"n\">Keyword</span><span class=\"p\">(</span><span class=\"s1\">'and'</span><span class=\"p\">),</span> <span class=\"n\">THIS</span><span class=\"p\">))</span>\n\n<span class=\"n\">ni</span> <span class=\"o\">=</span> <span class=\"n\">Ni</span><span class=\"p\">()</span>\n<span class=\"n\">ni</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s1\">'(ni or ni) and (ni or ni)'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">is_valid</span>  <span class=\"c1\"># =&gt; True</span>\n</pre>\n\n          </div>"}, "last_serial": 4426888, "releases": {"1.0.6": [{"comment_text": "", "digests": {"md5": "9b12f740b61a966cbdcc1b4438a0e0fc", "sha256": "4cf183780b28adeabea8d50ecd9100a7db153e977ac60b21757ef14f2f3ddfb6"}, "downloads": -1, "filename": "pyleri-1.0.6.tar.gz", "has_sig": false, "md5_digest": "9b12f740b61a966cbdcc1b4438a0e0fc", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8148, "upload_time": "2016-02-18T20:47:02", "upload_time_iso_8601": "2016-02-18T20:47:02.274514Z", "url": "https://files.pythonhosted.org/packages/81/d9/c7aa2fb425fa90b4b2ec38c472af578604adb4b78753f787add37a7c9627/pyleri-1.0.6.tar.gz", "yanked": false}], "1.0.8": [{"comment_text": "", "digests": {"md5": "f70d4d9e480d31df8c0eb7bb1bf26753", "sha256": "217e1e35679b2d068d4122a765473bc4f69e0c568c4c1a7e6a0d7424ce948029"}, "downloads": -1, "filename": "pyleri-1.0.8.tar.gz", "has_sig": false, "md5_digest": "f70d4d9e480d31df8c0eb7bb1bf26753", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8754, "upload_time": "2016-02-19T09:29:31", "upload_time_iso_8601": "2016-02-19T09:29:31.866327Z", "url": "https://files.pythonhosted.org/packages/51/85/475036997113e871e727c00081e2b6f1284d9f6da6bda6f937b2d045b77c/pyleri-1.0.8.tar.gz", "yanked": false}], "1.0.9": [{"comment_text": "", "digests": {"md5": "4a26b02ea49bd48e3ca219c2424807fd", "sha256": "74ada29882d30656b9c51b88507be6f3da89656345773a47e1236e369630c2bd"}, "downloads": -1, "filename": "pyleri-1.0.9.tar.gz", "has_sig": false, "md5_digest": "4a26b02ea49bd48e3ca219c2424807fd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9947, "upload_time": "2016-05-09T10:24:02", "upload_time_iso_8601": "2016-05-09T10:24:02.576833Z", "url": "https://files.pythonhosted.org/packages/ce/b0/8f492e0c87a8bc0019f7d057eb59a5fe029531385e035f8ff4c271e628d7/pyleri-1.0.9.tar.gz", "yanked": false}], "1.1.0": [{"comment_text": "", "digests": {"md5": "5ff43e1478651b7f4b339eb41a81bafb", "sha256": "c5814a50a25c3203875d7efd8327de5ec3f41921db959d5a2c3247528de73e1b"}, "downloads": -1, "filename": "pyleri-1.1.0.tar.gz", "has_sig": false, "md5_digest": "5ff43e1478651b7f4b339eb41a81bafb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10909, "upload_time": "2016-05-20T08:40:47", "upload_time_iso_8601": "2016-05-20T08:40:47.096650Z", "url": "https://files.pythonhosted.org/packages/b7/38/aa0a1882c9f2e15eab930ebc9e23141f9633db274d1e71ba477f15373cef/pyleri-1.1.0.tar.gz", "yanked": false}], "1.1.2": [{"comment_text": "", "digests": {"md5": "060afe89c89c84d74200442f77681a67", "sha256": "998054506b96c3886f29e5f7484c3964c0ce1a69e3dc1f8b6fc10f83f43814a0"}, "downloads": -1, "filename": "pyleri-1.1.2.tar.gz", "has_sig": false, "md5_digest": "060afe89c89c84d74200442f77681a67", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11176, "upload_time": "2016-05-23T08:12:37", "upload_time_iso_8601": "2016-05-23T08:12:37.090108Z", "url": "https://files.pythonhosted.org/packages/eb/db/d659cbb8872bf189ebf8623ff028902c163b9875f6c864778b507c7a6ea0/pyleri-1.1.2.tar.gz", "yanked": false}], "1.1.3": [{"comment_text": "", "digests": {"md5": "637c3f9dc5b340d9a8ddc7871649bb40", "sha256": "1bcc2f10b23459510566a9eb8df64cce898eb14ef50d0db2faf7e04fa2ab76ca"}, "downloads": -1, "filename": "pyleri-1.1.3.tar.gz", "has_sig": false, "md5_digest": "637c3f9dc5b340d9a8ddc7871649bb40", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11145, "upload_time": "2016-10-24T12:10:47", "upload_time_iso_8601": "2016-10-24T12:10:47.909922Z", "url": "https://files.pythonhosted.org/packages/7c/f4/a0d5f682f6b306f418a1a70bb7d7ee311108473f3e29c3853f055b0a6112/pyleri-1.1.3.tar.gz", "yanked": false}], "1.1.4": [{"comment_text": "", "digests": {"md5": "f5188a942c86388a93d187020804b920", "sha256": "43b336be6346d8909a01199aaae483e4b6ee19f8a27f9799cd5503ff92738d96"}, "downloads": -1, "filename": "pyleri-1.1.4.tar.gz", "has_sig": false, "md5_digest": "f5188a942c86388a93d187020804b920", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11144, "upload_time": "2016-10-25T07:36:10", "upload_time_iso_8601": "2016-10-25T07:36:10.061130Z", "url": "https://files.pythonhosted.org/packages/b7/69/ec97d1bcf48aea5a036646371cee9cccb33cf236feee041cbec400f4a5f9/pyleri-1.1.4.tar.gz", "yanked": false}], "1.1.5": [{"comment_text": "", "digests": {"md5": "8cda55009717586ded39e3ff0971e5f0", "sha256": "853b9d15154a057af01588102ea62d3fb4e002188834f80ccc5b2fe50b23460f"}, "downloads": -1, "filename": "pyleri-1.1.5.tar.gz", "has_sig": false, "md5_digest": "8cda55009717586ded39e3ff0971e5f0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11819, "upload_time": "2017-03-13T20:42:03", "upload_time_iso_8601": "2017-03-13T20:42:03.824389Z", "url": "https://files.pythonhosted.org/packages/e0/31/b8b2751f43fb5f6a4e8c7018588d084bb868f416d3a5c92fa2b9f87d86fb/pyleri-1.1.5.tar.gz", "yanked": false}], "1.1.6": [{"comment_text": "", "digests": {"md5": "d7ef15d0102859ee3d19871c42120d8c", "sha256": "90a7f7f000376f0f6f8d99f49b33ec9c7ed6e2100809440e22db96c6dd6b0c14"}, "downloads": -1, "filename": "pyleri-1.1.6.tar.gz", "has_sig": false, "md5_digest": "d7ef15d0102859ee3d19871c42120d8c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11767, "upload_time": "2017-06-20T20:15:35", "upload_time_iso_8601": "2017-06-20T20:15:35.276198Z", "url": "https://files.pythonhosted.org/packages/4d/6a/a2ddf35f8df3d8d69ff8b119c05de43786330ae654aca8b489d7ff77ded1/pyleri-1.1.6.tar.gz", "yanked": false}], "1.1.7": [{"comment_text": "", "digests": {"md5": "ae0fcfc1963dff73987f84f9fef2402b", "sha256": "59ceecc7b672421e97910792023bb834840dc8d6877f8866fe0d96672f076e3b"}, "downloads": -1, "filename": "pyleri-1.1.7.tar.gz", "has_sig": false, "md5_digest": "ae0fcfc1963dff73987f84f9fef2402b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11895, "upload_time": "2017-06-22T13:16:42", "upload_time_iso_8601": "2017-06-22T13:16:42.405147Z", "url": "https://files.pythonhosted.org/packages/84/fe/90535de1cbf433330c849c31fa87d986c96d801fff0babd80b0c58ecb240/pyleri-1.1.7.tar.gz", "yanked": false}], "1.1.8": [{"comment_text": "", "digests": {"md5": "a095f1303a8680a5c674e7ae2154bd6d", "sha256": "f6713c0dd5298185f51340747643c0e781577169483af6714729254c4bba7018"}, "downloads": -1, "filename": "pyleri-1.1.8.tar.gz", "has_sig": false, "md5_digest": "a095f1303a8680a5c674e7ae2154bd6d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11856, "upload_time": "2017-06-23T08:26:59", "upload_time_iso_8601": "2017-06-23T08:26:59.888304Z", "url": "https://files.pythonhosted.org/packages/f6/56/f7791f63375fe8fcf121179d4c07adf0dd492921086026560110b24e8668/pyleri-1.1.8.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "ee06d764c244a305bcea48246515cd2d", "sha256": "b29c8f40c12d96a7925a0b2ced625bfbd630eb1bb8dcc3a6a28792531e076bf1"}, "downloads": -1, "filename": "pyleri-1.2.0.tar.gz", "has_sig": false, "md5_digest": "ee06d764c244a305bcea48246515cd2d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18725, "upload_time": "2018-07-05T14:28:10", "upload_time_iso_8601": "2018-07-05T14:28:10.645704Z", "url": "https://files.pythonhosted.org/packages/85/9c/9e911e405104276cff3fca9b64cd6180f745d2373b8f359b0cef468f4e00/pyleri-1.2.0.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "fb434d31ca25623c8cf0c389767826d1", "sha256": "3a2ef69b7a4b37c113b90efaad466b74112e2f9631f724bb6bb2cf539d8e634d"}, "downloads": -1, "filename": "pyleri-1.2.1.tar.gz", "has_sig": false, "md5_digest": "fb434d31ca25623c8cf0c389767826d1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22314, "upload_time": "2018-07-05T15:58:34", "upload_time_iso_8601": "2018-07-05T15:58:34.720525Z", "url": "https://files.pythonhosted.org/packages/08/e6/18eacf653edcfc9e8fe570053526b0202ca0cae3325c7e9c1838f7553c34/pyleri-1.2.1.tar.gz", "yanked": false}], "1.2.2": [{"comment_text": "", "digests": {"md5": "584e5b9f25d2a0b632a158f71ac769f3", "sha256": "5b539f342892bb55d2c6ebc9c9d4507570af33743d43a237c9315243d3b1963b"}, "downloads": -1, "filename": "pyleri-1.2.2.tar.gz", "has_sig": false, "md5_digest": "584e5b9f25d2a0b632a158f71ac769f3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22913, "upload_time": "2018-07-09T11:19:14", "upload_time_iso_8601": "2018-07-09T11:19:14.307266Z", "url": "https://files.pythonhosted.org/packages/a4/ca/49265a8ed8d72807ee9af12e4ea87ae1013c3bafb17bf3dbe616cb159785/pyleri-1.2.2.tar.gz", "yanked": false}], "1.3.0": [{"comment_text": "", "digests": {"md5": "caadd8dbb0ba9638262ae4ba8def5b83", "sha256": "c5a3d225adfde5df78a045c0bce9fee8d89c1bd7a7702788e60ca7a2c774ca12"}, "downloads": -1, "filename": "pyleri-1.3.0.tar.gz", "has_sig": false, "md5_digest": "caadd8dbb0ba9638262ae4ba8def5b83", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34444, "upload_time": "2018-10-15T14:26:59", "upload_time_iso_8601": "2018-10-15T14:26:59.882418Z", "url": "https://files.pythonhosted.org/packages/8a/f4/659a10e896befffc2221b4aa4ed2c98d00111d9a53484c70839235945e9c/pyleri-1.3.0.tar.gz", "yanked": false}], "1.3.1": [{"comment_text": "", "digests": {"md5": "dc980b84fe4e8ce28d6b9c952e38ff5a", "sha256": "ca15682a429d295d75930c43243dc7a1262a6c9aa52c02be1d9be2e20440ed7a"}, "downloads": -1, "filename": "pyleri-1.3.1.tar.gz", "has_sig": false, "md5_digest": "dc980b84fe4e8ce28d6b9c952e38ff5a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34498, "upload_time": "2018-10-25T20:02:26", "upload_time_iso_8601": "2018-10-25T20:02:26.183292Z", "url": "https://files.pythonhosted.org/packages/23/d0/a6b4ec63d472b871675ffe295d024fd49a361d86387a4142a6560be462ed/pyleri-1.3.1.tar.gz", "yanked": false}], "1.3.2": [{"comment_text": "", "digests": {"md5": "819f65aed0a331f8f3b8ad7a67c7a156", "sha256": "f893dd2989feaa27ead244c0887e45aa831df408eeb7d19ecfe30358fbfabe69"}, "downloads": -1, "filename": "pyleri-1.3.2.tar.gz", "has_sig": false, "md5_digest": "819f65aed0a331f8f3b8ad7a67c7a156", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34527, "upload_time": "2018-10-29T10:01:20", "upload_time_iso_8601": "2018-10-29T10:01:20.979761Z", "url": "https://files.pythonhosted.org/packages/49/17/3395056129b8090564f00f914640c665eb1206136708b09d5ed3ceb5d898/pyleri-1.3.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "819f65aed0a331f8f3b8ad7a67c7a156", "sha256": "f893dd2989feaa27ead244c0887e45aa831df408eeb7d19ecfe30358fbfabe69"}, "downloads": -1, "filename": "pyleri-1.3.2.tar.gz", "has_sig": false, "md5_digest": "819f65aed0a331f8f3b8ad7a67c7a156", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34527, "upload_time": "2018-10-29T10:01:20", "upload_time_iso_8601": "2018-10-29T10:01:20.979761Z", "url": "https://files.pythonhosted.org/packages/49/17/3395056129b8090564f00f914640c665eb1206136708b09d5ed3ceb5d898/pyleri-1.3.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:03:13 2020"}