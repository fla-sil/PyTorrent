{"info": {"author": "", "author_email": "", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "=========\nTaskTiger\n=========\n.. image:: https://circleci.com/gh/closeio/tasktiger/tree/master.svg?style=svg&circle-token=a86617952aa9b4cfee784b6ac43358cd042a6672\n    :target: https://circleci.com/gh/closeio/tasktiger/tree/master\n\n*TaskTiger* is a Python task queue using Redis.\n\n\n(Interested in working on projects like this? `Close`_ is looking for `great engineers`_ to join our team)\n\n.. _Close: http://close.com\n.. _great engineers: http://jobs.close.com\n\n\n.. contents:: Contents\n\nFeatures\n--------\n\n- Per-task fork\n\n  TaskTiger forks a subprocess for each task, This comes with several benefits:\n  Memory leaks caused by tasks are avoided since the subprocess is terminated\n  when the task is finished. A hard time limit can be set for each task, after\n  which the task is killed if it hasn't completed. To ensure performance, any\n  necessary Python modules can be preloaded in the parent process.\n\n- Unique queues\n\n  TaskTiger has the option to avoid duplicate tasks in the task queue. In some\n  cases it is desirable to combine multiple similar tasks. For example, imagine\n  a task that indexes objects (e.g. to make them searchable). If an object is\n  already present in the task queue and hasn't been processed yet, a unique\n  queue will ensure that the indexing task doesn't have to do duplicate work.\n  However, if the task is already running while it's queued, the task will be\n  executed another time to ensure that the indexing task always picks up the\n  latest state.\n\n- Task locks\n\n  TaskTiger can ensure to never execute more than one instance of tasks with\n  similar arguments by acquiring a lock. If a task hits a lock, it is requeued\n  and scheduled for later executions after a configurable interval.\n\n- Task retrying\n\n  TaskTiger lets you retry exceptions (all exceptions or a list of specific\n  ones) and comes with configurable retry intervals (fixed, linear,\n  exponential, custom).\n\n- Flexible queues\n\n  Tasks can be easily queued in separate queues. Workers pick tasks from a\n  randomly chosen queue and can be configured to only process specific queues,\n  ensuring that all queues are processed equally. TaskTiger also supports\n  subqueues which are separated by a period. For example, you can have\n  per-customer queues in the form ``process_emails.CUSTOMER_ID`` and start a\n  worker to process ``process_emails`` and any of its subqueues. Since tasks\n  are picked from a random queue, all customers get equal treatment: If one\n  customer is queueing many tasks it can't block other customers' tasks from\n  being processed. A maximum queue size can also be enforced.\n\n- Batch queues\n\n  Batch queues can be used to combine multiple queued tasks into one. That way,\n  your task function can process multiple sets of arguments at the same time,\n  which can improve performance. The batch size is configurable.\n\n- Scheduled and periodic tasks\n\n  Tasks can be scheduled for execution at a specific time. Tasks can also be\n  executed periodically (e.g. every five seconds).\n\n- Structured logging\n\n  TaskTiger supports JSON-style logging via structlog, allowing more\n  flexibility for tools to analyze the log. For example, you can use TaskTiger\n  together with Logstash, Elasticsearch, and Kibana.\n\n  The structlog processor ``tasktiger.logging.tasktiger_processor`` can\n  be used to inject the current task id into all log messages.\n\n- Reliability\n\n  TaskTiger atomically moves tasks between queue states, and will re-execute\n  tasks after a timeout if a worker crashes.\n\n- Error handling\n\n  If an exception occurs during task execution and the task is not set up to be\n  retried, TaskTiger stores the execution tracebacks in an error queue. The\n  task can then be retried or deleted manually. TaskTiger can be easily\n  integrated with error reporting services like Rollbar.\n\n- Admin interface\n\n  A simple admin interface using flask-admin exists as a separate project\n  (tasktiger-admin_).\n\n.. _tasktiger-admin: https://github.com/closeio/tasktiger-admin\n\n\nQuick start\n-----------\n\nIt is easy to get started with TaskTiger.\n\nCreate a file that contains the task(s).\n\n.. code:: python\n\n  # tasks.py\n  def my_task():\n      print('Hello')\n\nQueue the task using the ``delay`` method.\n\n.. code:: python\n\n  In [1]: import tasktiger, tasks\n  In [2]: tiger = tasktiger.TaskTiger()\n  In [3]: tiger.delay(tasks.my_task)\n\nRun a worker (make sure the task code can be found, e.g. using ``PYTHONPATH``).\n\n.. code:: bash\n\n  % PYTHONPATH=. tasktiger\n  {\"timestamp\": \"2015-08-27T21:00:09.135344Z\", \"queues\": null, \"pid\": 69840, \"event\": \"ready\", \"level\": \"info\"}\n  {\"task_id\": \"6fa07a91642363593cddef7a9e0c70ae3480921231710aa7648b467e637baa79\", \"level\": \"debug\", \"timestamp\": \"2015-08-27T21:03:56.727051Z\", \"pid\": 69840, \"queue\": \"default\", \"child_pid\": 70171, \"event\": \"processing\"}\n  Hello\n  {\"task_id\": \"6fa07a91642363593cddef7a9e0c70ae3480921231710aa7648b467e637baa79\", \"level\": \"debug\", \"timestamp\": \"2015-08-27T21:03:56.732457Z\", \"pid\": 69840, \"queue\": \"default\", \"event\": \"done\"}\n\n\nConfiguration\n-------------\n\nA ``TaskTiger`` object keeps track of TaskTiger's settings and is used to\ndecorate and queue tasks. The constructor takes the following arguments:\n\n- ``connection``\n\n  Redis connection object. The connection should be initialized with\n  ``decode_responses=True`` to avoid encoding problems on Python 3.\n\n- ``config``\n\n  Dict with config options. Most configuration options don't need to be\n  changed, and a full list can be seen within ``TaskTiger``'s ``__init__``\n  method.\n\n  Here are a few commonly used options:\n\n  - ``ALWAYS_EAGER``\n\n    If set to ``True``, all tasks except future tasks (``when`` is a future\n    time) will be executed locally by blocking until the task returns. This is\n    useful for testing purposes.\n\n  - ``BATCH_QUEUES``\n\n    Set up queues that will be processed in batch, i.e. multiple jobs are taken\n    out of the queue at the same time and passed as a list to the worker\n    method. Takes a dict where the key represents the queue name and the value\n    represents the batch size. Note that the task needs to be declared as\n    ``batch=True``. Also note that any subqueues will be automatically treated\n    as batch queues, and the batch value of the most specific subqueue name\n    takes precedence.\n\n  - ``ONLY_QUEUES``\n\n    If set to a non-empty list of queue names, a worker only processes the\n    given queues (and their subqueues), unless explicit queues are passed to\n    the command line.\n\n- ``setup_structlog``\n\n  If set to True, sets up structured logging using ``structlog`` when\n  initializing TaskTiger. This makes writing custom worker scripts easier\n  since it doesn't require the user to set up ``structlog`` in advance.\n\nExample:\n\n.. code:: python\n\n  import tasktiger\n  from redis import Redis\n  conn = Redis(db=1, decode_responses=True)\n  tiger = tasktiger.TaskTiger(connection=conn, config={\n      'BATCH_QUEUES': {\n          # Batch up to 50 tasks that are queued in the my_batch_queue or any\n          # of its subqueues, except for the send_email subqueue which only\n          # processes up to 10 tasks at a time.\n          'my_batch_queue': 50,\n          'my_batch_queue.send_email': 10,\n      },\n  })\n\n\nTask decorator\n--------------\n\nTaskTiger provides a task decorator to specify task options. Note that simple\ntasks don't need to be decorated. However, decorating the task allows you to\nuse an alternative syntax to queue the task, which is compatible with Celery:\n\n.. code:: python\n\n  # tasks.py\n\n  import tasktiger\n  tiger = tasktiger.TaskTiger()\n\n  @tiger.task()\n  def my_task(name, n=None):\n      print('Hello', name)\n\n.. code:: python\n\n  In [1]: import tasks\n  # The following are equivalent. However, the second syntax can only be used\n  # if the task is decorated.\n  In [2]: tasks.tiger.delay(my_task, args=('John',), kwargs={'n': 1})\n  In [3]: tasks.my_task.delay('John', n=1)\n\n\nTask options\n------------\n\nTasks support a variety of options that can be specified either in the task\ndecorator, or when queueing a task. For the latter, the ``delay`` method must\nbe called on the ``TaskTiger`` object, and any options in the task decorator\nare overridden.\n\n.. code:: python\n\n  @tiger.task(queue='myqueue', unique=True)\n  def my_task():\n      print('Hello')\n\n.. code:: python\n\n  # The task will be queued in \"otherqueue\", even though the task decorator\n  # says \"myqueue\".\n  tiger.delay(my_task, queue='otherqueue')\n\nWhen queueing a task, the task needs to be defined in a module other than the\nPython file which is being executed. In other words, the task can't be in the\n``__main__`` module. TaskTiger will give you back an error otherwise.\n\nThe following options are supported by both ``delay`` and the task decorator:\n\n- ``queue``\n\n  Name of the queue where the task will be queued.\n\n- ``hard_timeout``\n\n  If the task runs longer than the given number of seconds, it will be\n  killed and marked as failed.\n\n- ``unique``\n\n  Boolean to indicate whether the task will only be queued if there is no\n  similar task with the same function, arguments, and keyword arguments in the\n  queue. Note that multiple similar tasks may still be executed at the same\n  time since the task will still be inserted into the queue if another one\n  is being processed. Requeueing an already scheduled unique task will not\n  change the time it was originally scheduled to execute at.\n\n- ``lock``\n\n  Boolean to indicate whether to hold a lock while the task is being executed\n  (for the given args and kwargs). If a task with similar args/kwargs is queued\n  and tries to acquire the lock, it will be retried later.\n\n- ``lock_key``\n\n  If set, this implies ``lock=True`` and specifies the list of kwargs to\n  use to construct the lock key. By default, all args and kwargs are\n  serialized and hashed.\n\n- ``max_queue_size``\n\n  A maximum queue size can be enforced by setting this to an integer value.\n  The ``QueueFullException`` exception will be raised when queuing a task if\n  this limit is reached. Tasks in the ``active``, ``scheduled``, and ``queued``\n  states are counted against this limit.\n\n- ``when``\n\n  Takes either a datetime (for an absolute date) or a timedelta\n  (relative to now). If given, the task will be scheduled for the given\n  time.\n\n- ``retry``\n\n  Boolean to indicate whether to retry the task when it fails (either because\n  of an exception or because of a timeout). To restrict the list of failures,\n  use ``retry_on``. Unless ``retry_method`` is given, the configured\n  ``DEFAULT_RETRY_METHOD`` is used.\n\n- ``retry_on``\n\n  If a list is given, it implies ``retry=True``. The task will be only retried\n  on the given exceptions (or its subclasses). To retry the task when a hard\n  timeout occurs, use ``JobTimeoutException``.\n\n- ``retry_method``\n\n  If given, implies ``retry=True``. Pass either:\n\n  - a function that takes the retry number as an argument, or,\n  - a tuple ``(f, args)``, where ``f`` takes the retry number as the first\n    argument, followed by the additional args.\n\n  The function needs to return the desired retry interval in seconds, or raise\n  ``StopRetry`` to stop retrying. The following built-in functions can be\n  passed for common scenarios and return the appropriate tuple:\n\n  - ``fixed(delay, max_retries)``\n\n    Returns a method that returns the given ``delay`` (in seconds) or raises\n    ``StopRetry`` if the number of retries exceeds ``max_retries``.\n\n  - ``linear(delay, increment, max_retries)``\n\n    Like ``fixed``, but starts off with the given ``delay`` and increments it\n    by the given ``increment`` after every retry.\n\n  - ``exponential(delay, factor, max_retries)``\n\n    Like ``fixed``, but starts off with the given ``delay`` and multiplies it\n    by the given ``factor`` after every retry.\n\n  For example, to retry a task 3 times (for a total of 4 executions), and wait\n  60 seconds between executions, pass ``retry_method=fixed(60, 3)``.\n\nThe following options can be only specified in the task decorator:\n\n- ``batch``\n\n  If set to ``True``, the task will receive a list of dicts with args and\n  kwargs and can process multiple tasks of the same type at once.\n  Example: ``[{\"args\": [1], \"kwargs\": {}}, {\"args\": [2], \"kwargs\": {}}]``\n  Note that the list will only contain multiple items if the worker\n  has set up ``BATCH_QUEUES`` for the specific queue (see the *Configuration*\n  section).\n\n- ``schedule``\n\n  If given, makes a task execute periodically. Pass either:\n\n  - a function that takes the current datetime as an argument.\n  - a tuple ``(f, args)``, where ``f`` takes the current datetime as the first\n    argument, followed by the additional args.\n\n  The schedule function must return the next task execution datetime, or\n  ``None`` to prevent periodic execution. The function is executed to determine\n  the initial task execution date when a worker is initialized, and to determine\n  the next execution date when the task is about to get executed.\n\n  For most common scenarios, the ``periodic`` built-in function can be passed:\n\n  - ``periodic(seconds=0, minutes=0, hours=0, days=0, weeks=0, start_date=None,\n    end_date=None)``\n\n    Use equal, periodic intervals, starting from ``start_date`` (defaults to\n    ``2000-01-01T00:00Z``, a Saturday, if not given), ending at ``end_date`` (or\n    never, if not given). For example, to run a task every five minutes\n    indefinitely, use ``schedule=periodic(minutes=5)``. To run a task every\n    every Sunday at 4am UTC, you could use\n    ``schedule=periodic(weeks=1, start_date=datetime.datetime(2000, 1, 2, 4))``.\n\nCustom retrying\n---------------\n\nIn some cases the task retry options may not be flexible enough. For example,\nyou might want to use a different retry method depending on the exception type,\nor you might want to like to suppress logging an error if a task fails after\nretries. In these cases, ``RetryException`` can be raised within the task\nfunction. The following options are supported:\n\n- ``method``\n\n  Specify a custom retry method for this retry. If not given, the task's\n  default retry method is used, or, if unspecified, the configured\n  ``DEFAULT_RETRY_METHOD``. Note that the number of retries passed to the\n  retry method is always the total number of times this method has been\n  executed, regardless of which retry method was used.\n\n- ``original_traceback``\n\n  If ``RetryException`` is raised from within an except block and\n  ``original_traceback`` is True, the original traceback will be logged (i.e.\n  the stacktrace at the place where the caught exception was raised). False by\n  default.\n\n- ``log_error``\n\n  If set to False and the task fails permanently, a warning will be logged\n  instead of an error, and the task will be removed from Redis when it\n  completes. True by default.\n\nExample usage:\n\n.. code:: python\n\n  from tasktiger.exceptions import RetryException\n\n  def my_task():\n      if not ready():\n          # Retry every minute up to 3 times if we're not ready. An error will\n          # be logged if we're out of retries.\n          raise RetryException(method=fixed(60, 3))\n\n      try:\n          some_code()\n      except NetworkException:\n          # Back off exponentially up to 5 times in case of a network failure.\n          # Log the original traceback (as a warning) and don't log an error if\n          # we still fail after 5 times.\n          raise RetryException(method=exponential(60, 2, 5),\n                               original_traceback=True,\n                               log_error=False)\n\n\nWorkers\n-------\n\nThe ``tasktiger`` command is used on the command line to invoke a worker. To\ninvoke multiple workers, multiple instances need to be started. This can be\neasily done e.g. via Supervisor. The following Supervisor configuration file\ncan be placed in ``/etc/supervisor/tasktiger.ini`` and runs 4 TaskTiger workers\nas the ``ubuntu`` user. For more information, read Supervisor's documentation.\n\n.. code:: bash\n\n  [program:tasktiger]\n  command=/usr/local/bin/tasktiger\n  process_name=%(program_name)s_%(process_num)02d\n  numprocs=4\n  numprocs_start=0\n  priority=999\n  autostart=true\n  autorestart=true\n  startsecs=10\n  startretries=3\n  exitcodes=0,2\n  stopsignal=TERM\n  stopwaitsecs=600\n  killasgroup=false\n  user=ubuntu\n  redirect_stderr=false\n  stdout_logfile=/var/log/tasktiger.out.log\n  stdout_logfile_maxbytes=250MB\n  stdout_logfile_backups=10\n  stderr_logfile=/var/log/tasktiger.err.log\n  stderr_logfile_maxbytes=250MB\n  stderr_logfile_backups=10\n\nWorkers support the following options:\n\n- ``-q``, ``--queues``\n\n  If specified, only the given queue(s) are processed. Multiple queues can be\n  separated by comma. Any subqueues of the given queues will be also processed.\n  For example, ``-q first,second`` will process items from ``first``,\n  ``second``, and subqueues such as ``first.CUSTOMER1``, ``first.CUSTOMER2``.\n\n- ``-e``, ``--exclude-queues``\n\n  If specified, exclude the given queue(s) from processing. Multiple queues can\n  be separated by comma. Any subqueues of the given queues will also be\n  excluded unless a more specific queue is specified with the ``-q`` option.\n  For example, ``-q email,email.incoming.CUSTOMER1 -e email.incoming`` will\n  process items from the ``email`` queue and subqueues like\n  ``email.outgoing.CUSTOMER1`` or ``email.incoming.CUSTOMER1``, but not\n  ``email.incoming`` or ``email.incoming.CUSTOMER2``.\n\n- ``-m``, ``--module``\n\n  Module(s) to import when launching the worker. This improves task performance\n  since the module doesn't have to be reimported every time a task is forked.\n  Multiple modules can be separated by comma.\n\n  Another way to preload modules is to set up a custom TaskTiger launch script,\n  which is described below.\n\n- ``-h``, ``--host``\n\n  Redis server hostname (if different from ``localhost``).\n\n- ``-p``, ``--port``\n\n  Redis server port (if different from ``6379``).\n\n- ``-a``, ``--password``\n\n  Redis server password (if required).\n\n- ``-n``, ``--db``\n\n  Redis server database number (if different from ``0``).\n\n- ``-M``, ``--max-workers-per-queue``\n\n  Maximum number of workers that are allowed to process a queue.\n\n- ``--store-tracebacks/--no-store-tracebacks``\n\n  Store tracebacks with execution history (config defaults to ``True``).\n\nIn some cases it is convenient to have a custom TaskTiger launch script. For\nexample, your application may have a ``manage.py`` command that sets up the\nenvironment and you may want to launch TaskTiger workers using that script. To\ndo that, you can use the ``run_worker_with_args`` method, which launches a\nTaskTiger worker and parses any command line arguments. Here is an example:\n\n.. code:: python\n\n  import sys\n  from tasktiger import TaskTiger\n\n  try:\n      command = sys.argv[1]\n  except IndexError:\n      command = None\n\n  if command == 'tasktiger':\n      tiger = TaskTiger(setup_structlog=True)\n      # Strip the \"tasktiger\" arg when running via manage, so we can run e.g.\n      # ./manage.py tasktiger --help\n      tiger.run_worker_with_args(sys.argv[2:])\n      sys.exit(0)\n\nIf you're using ``flask-script``, you can use the ``TaskTigerCommand`` provided\nin the ``tasktiger.flask_script`` module. It takes the ``TaskTiger`` instance\nas an argument. Tasks will have access to Flask's application context. Example:\n\n.. code:: python\n\n  from flask import Flask\n  from flask.ext.script import Manager\n  from tasktiger.flask_script import TaskTigerCommand\n\n  app = Flask()\n  manager = Manager(app)\n  tiger = TaskTiger(setup_structlog=True)\n\n  manager.add_command('tasktiger', TaskTigerCommand(tiger))\n\n  if __name__ == \"__main__\":\n      manager.run()\n\nYou can subclass the ``TaskTigerCommand`` and override the ``setup`` method to\nimplement any custom setup that needs to be done before running the worker.\n\n\nInspect, requeue and delete tasks\n---------------------------------\n\nTaskTiger provides access to the ``Task`` class which lets you inspect queues\nand perform various actions on tasks.\n\nEach queue can have tasks in the following states:\n\n- ``queued``: Tasks that are queued and waiting to be picked up by the workers.\n- ``active``: Tasks that are currently being processed by the workers.\n- ``scheduled``: Tasks that are scheduled for later execution.\n- ``error``: Tasks that failed with an error.\n\nTo get a list of all tasks for a given queue and state, use\n``Task.tasks_from_queue``. The method gives you back a tuple containing the\ntotal number of tasks in the queue (useful if the tasks are truncated) and a\nlist of tasks in the queue, latest first. Using the ``skip`` and ``limit``\nkeyword arguments, you can fetch arbitrary slices of the queue. If you know the\ntask ID, you can fetch a given task using ``Task.from_id``. Both methods let\nyou load tracebacks from failed task executions using the ``load_executions``\nkeyword argument, which accepts an integer indicating how many executions\nshould be loaded.\n\nTasks can also be constructed and queued using the regular constructor, which\ntakes the TaskTiger instance, the function name and the options described in\nthe *Task options* section. The task can then be queued using its ``delay``\nmethod. Note that the ``when`` argument needs to be passed to the ``delay``\nmethod, if applicable. Unique tasks can be reconstructed using the same\narguments.\n\nThe ``Task`` object has the following properties:\n\n- ``id``: The task ID.\n\n- ``data``: The raw data as a dict from Redis.\n\n- ``executions``: A list of failed task executions (as dicts). An execution\n  dict contains the processing time in ``time_started`` and ``time_failed``,\n  the worker host in ``host``, the exception name in ``exception_name`` and\n  the full traceback in ``traceback``.\n\n- ``serialized_func``, ``args``, ``kwargs``: The serialized function name with\n  all of its arguments.\n\n- ``func``: The imported (executable) function\n\nThe ``Task`` object has the following methods:\n\n- ``cancel``: Cancel a scheduled task.\n\n- ``delay``: Queue the task for execution.\n\n- ``delete``: Remove the task from the error queue.\n\n- ``execute``: Run the task without queueing it.\n\n- ``n_executions``: Queries and returns the number of past task executions.\n\n- ``retry``: Requeue the task from the error queue for execution.\n\n- ``update_scheduled_time``: Updates a scheduled task's date to the given date.\n\nThe current task can be accessed within the task function while it's being\nexecuted: In case of a non-batch task, the ``current_task`` property of the\n``TaskTiger`` instance returns the current ``Task`` instance. In case of a\nbatch task the ``current_tasks`` property must be used which returns a list of\ntasks that are currently being processed (in the same order as they were passed\nto the task).\n\nExample 1: Queueing a unique task and canceling it without a reference to the\noriginal task.\n\n.. code:: python\n\n  from tasktiger import TaskTiger, Task\n\n  tiger = TaskTiger()\n\n  # Send an email in five minutes.\n  task = Task(tiger, send_mail, args=['email_id'], unique=True)\n  task.delay(when=datetime.timedelta(minutes=5))\n\n  # Unique tasks get back a task instance referring to the same task by simply\n  # creating the same task again.\n  task = Task(tiger, send_mail, args=['email_id'], unique=True)\n  task.cancel()\n\nExample 2: Inspecting queues and retrying a task by ID.\n\n.. code:: python\n\n  from tasktiger import TaskTiger, Task\n\n  QUEUE_NAME = 'default'\n  TASK_STATE = 'error'\n  TASK_ID = '6fa07a91642363593cddef7a9e0c70ae3480921231710aa7648b467e637baa79'\n\n  tiger = TaskTiger()\n\n  n_total, tasks = Task.tasks_from_queue(tiger, QUEUE_NAME, TASK_STATE)\n\n  for task in tasks:\n      print(task.id, task.func)\n\n  task = Task.from_id(tiger, QUEUE_NAME, TASK_STATE, TASK_ID)\n  task.retry()\n\nExample 3: Accessing the task instances within a batch task function to\ndetermine how many times the currently processing tasks were previously\nexecuted.\n\n.. code:: python\n\n  from tasktiger import TaskTiger\n\n  tiger = TaskTiger()\n\n  @tiger.task(batch=True)\n  def my_task(args):\n      for task in tiger.current_tasks:\n          print(task.n_executions())\n\n\nPause queue processing\n----------------------\n\nThe ``--max-workers-per-queue`` option uses queue locks to control the\nnumber of workers that can simultaneously process the same queue. When using\nthis option a system lock can be placed on a queue which will keep workers\nfrom processing tasks from that queue until it expires. Use the\n``set_queue_system_lock()`` method of the TaskTiger object to set this lock.\n\n\nRollbar error handling\n----------------------\n\nTaskTiger comes with Rollbar integration for error handling. When a task errors\nout, it can be logged to Rollbar, grouped by queue, task function name and\nexception type. To enable logging, initialize rollbar with the\n``StructlogRollbarHandler`` provided in the ``tasktiger.rollbar`` module. The\nhandler takes a string as an argument which is used to prefix all the messages\nreported to Rollbar. Here is a custom worker launch script:\n\n.. code:: python\n\n  import logging\n  import rollbar\n  import sys\n  from tasktiger import TaskTiger\n  from tasktiger.rollbar import StructlogRollbarHandler\n\n  tiger = TaskTiger(setup_structlog=True)\n\n  rollbar.init(ROLLBAR_API_KEY, APPLICATION_ENVIRONMENT,\n               allow_logging_basic_config=False)\n  rollbar_handler = StructlogRollbarHandler('TaskTiger')\n  rollbar_handler.setLevel(logging.ERROR)\n  tiger.log.addHandler(rollbar_handler)\n\n  tiger.run_worker_with_args(sys.argv[1:])\n\n\nCleaning Up Error'd Tasks\n-------------------------\n\nError'd tasks occasionally need to be purged from Redis, so ``TaskTiger``\nexposes a ``purge_errored_tasks`` method to help. It might be useful to set\nthis up as a periodic task as follows:\n\n.. code:: python\n\n  from tasktiger import TaskTiger, periodic\n\n  tiger = TaskTiger()\n\n  @tiger.task(schedule=periodic(hours=1))\n  def purge_errored_tasks():\n      tiger.purge_errored_tasks(\n          limit=1000,\n          last_execution_before=(\n              datetime.datetime.utcnow() - datetime.timedelta(weeks=12)\n          )\n      )\n\n\nRunning The Test Suite\n----------------------\n\nTests can be run locally using the provided docker compose file. After installing docker, tests should be runnable with:\n\n.. code :: bash\n\n  docker-compose run --rm tasktiger pytest\n\nTests can be more granularly run using normal pytest flags. For example:\n\n.. code :: bash\n\n  docker-compose run --rm tasktiger pytest tests/test_base.py::TestCase\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/closeio/tasktiger", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "tasktiger", "package_url": "https://pypi.org/project/tasktiger/", "platform": "any", "project_url": "https://pypi.org/project/tasktiger/", "project_urls": {"Homepage": "http://github.com/closeio/tasktiger"}, "release_url": "https://pypi.org/project/tasktiger/0.10.1/", "requires_dist": ["click", "redis (<3,>=2)", "six", "structlog"], "requires_python": "", "summary": "Python task queue", "version": "0.10.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://circleci.com/gh/closeio/tasktiger/tree/master\" rel=\"nofollow\"><img alt=\"https://circleci.com/gh/closeio/tasktiger/tree/master.svg?style=svg&amp;circle-token=a86617952aa9b4cfee784b6ac43358cd042a6672\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/82981b5d310355e3527e2b7f75ab2d8ee81d8f05/68747470733a2f2f636972636c6563692e636f6d2f67682f636c6f7365696f2f7461736b74696765722f747265652f6d61737465722e7376673f7374796c653d73766726636972636c652d746f6b656e3d61383636313739353261613962346366656537383462366163343333353863643034326136363732\"></a>\n<p><em>TaskTiger</em> is a Python task queue using Redis.</p>\n<p>(Interested in working on projects like this? <a href=\"http://close.com\" rel=\"nofollow\">Close</a> is looking for <a href=\"http://jobs.close.com\" rel=\"nofollow\">great engineers</a> to join our team)</p>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#features\" id=\"id1\" rel=\"nofollow\">Features</a></li>\n<li><a href=\"#quick-start\" id=\"id2\" rel=\"nofollow\">Quick start</a></li>\n<li><a href=\"#configuration\" id=\"id3\" rel=\"nofollow\">Configuration</a></li>\n<li><a href=\"#task-decorator\" id=\"id4\" rel=\"nofollow\">Task decorator</a></li>\n<li><a href=\"#task-options\" id=\"id5\" rel=\"nofollow\">Task options</a></li>\n<li><a href=\"#custom-retrying\" id=\"id6\" rel=\"nofollow\">Custom retrying</a></li>\n<li><a href=\"#workers\" id=\"id7\" rel=\"nofollow\">Workers</a></li>\n<li><a href=\"#inspect-requeue-and-delete-tasks\" id=\"id8\" rel=\"nofollow\">Inspect, requeue and delete tasks</a></li>\n<li><a href=\"#pause-queue-processing\" id=\"id9\" rel=\"nofollow\">Pause queue processing</a></li>\n<li><a href=\"#rollbar-error-handling\" id=\"id10\" rel=\"nofollow\">Rollbar error handling</a></li>\n<li><a href=\"#cleaning-up-error-d-tasks\" id=\"id11\" rel=\"nofollow\">Cleaning Up Error\u2019d Tasks</a></li>\n<li><a href=\"#running-the-test-suite\" id=\"id12\" rel=\"nofollow\">Running The Test Suite</a></li>\n</ul>\n</div>\n<div id=\"features\">\n<h2><a href=\"#id1\" rel=\"nofollow\">Features</a></h2>\n<ul>\n<li><p>Per-task fork</p>\n<p>TaskTiger forks a subprocess for each task, This comes with several benefits:\nMemory leaks caused by tasks are avoided since the subprocess is terminated\nwhen the task is finished. A hard time limit can be set for each task, after\nwhich the task is killed if it hasn\u2019t completed. To ensure performance, any\nnecessary Python modules can be preloaded in the parent process.</p>\n</li>\n<li><p>Unique queues</p>\n<p>TaskTiger has the option to avoid duplicate tasks in the task queue. In some\ncases it is desirable to combine multiple similar tasks. For example, imagine\na task that indexes objects (e.g. to make them searchable). If an object is\nalready present in the task queue and hasn\u2019t been processed yet, a unique\nqueue will ensure that the indexing task doesn\u2019t have to do duplicate work.\nHowever, if the task is already running while it\u2019s queued, the task will be\nexecuted another time to ensure that the indexing task always picks up the\nlatest state.</p>\n</li>\n<li><p>Task locks</p>\n<p>TaskTiger can ensure to never execute more than one instance of tasks with\nsimilar arguments by acquiring a lock. If a task hits a lock, it is requeued\nand scheduled for later executions after a configurable interval.</p>\n</li>\n<li><p>Task retrying</p>\n<p>TaskTiger lets you retry exceptions (all exceptions or a list of specific\nones) and comes with configurable retry intervals (fixed, linear,\nexponential, custom).</p>\n</li>\n<li><p>Flexible queues</p>\n<p>Tasks can be easily queued in separate queues. Workers pick tasks from a\nrandomly chosen queue and can be configured to only process specific queues,\nensuring that all queues are processed equally. TaskTiger also supports\nsubqueues which are separated by a period. For example, you can have\nper-customer queues in the form <tt>process_emails.CUSTOMER_ID</tt> and start a\nworker to process <tt>process_emails</tt> and any of its subqueues. Since tasks\nare picked from a random queue, all customers get equal treatment: If one\ncustomer is queueing many tasks it can\u2019t block other customers\u2019 tasks from\nbeing processed. A maximum queue size can also be enforced.</p>\n</li>\n<li><p>Batch queues</p>\n<p>Batch queues can be used to combine multiple queued tasks into one. That way,\nyour task function can process multiple sets of arguments at the same time,\nwhich can improve performance. The batch size is configurable.</p>\n</li>\n<li><p>Scheduled and periodic tasks</p>\n<p>Tasks can be scheduled for execution at a specific time. Tasks can also be\nexecuted periodically (e.g. every five seconds).</p>\n</li>\n<li><p>Structured logging</p>\n<p>TaskTiger supports JSON-style logging via structlog, allowing more\nflexibility for tools to analyze the log. For example, you can use TaskTiger\ntogether with Logstash, Elasticsearch, and Kibana.</p>\n<p>The structlog processor <tt>tasktiger.logging.tasktiger_processor</tt> can\nbe used to inject the current task id into all log messages.</p>\n</li>\n<li><p>Reliability</p>\n<p>TaskTiger atomically moves tasks between queue states, and will re-execute\ntasks after a timeout if a worker crashes.</p>\n</li>\n<li><p>Error handling</p>\n<p>If an exception occurs during task execution and the task is not set up to be\nretried, TaskTiger stores the execution tracebacks in an error queue. The\ntask can then be retried or deleted manually. TaskTiger can be easily\nintegrated with error reporting services like Rollbar.</p>\n</li>\n<li><p>Admin interface</p>\n<p>A simple admin interface using flask-admin exists as a separate project\n(<a href=\"https://github.com/closeio/tasktiger-admin\" rel=\"nofollow\">tasktiger-admin</a>).</p>\n</li>\n</ul>\n</div>\n<div id=\"quick-start\">\n<h2><a href=\"#id2\" rel=\"nofollow\">Quick start</a></h2>\n<p>It is easy to get started with TaskTiger.</p>\n<p>Create a file that contains the task(s).</p>\n<pre><span class=\"c1\"># tasks.py</span>\n<span class=\"k\">def</span> <span class=\"nf\">my_task</span><span class=\"p\">():</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Hello'</span><span class=\"p\">)</span>\n</pre>\n<p>Queue the task using the <tt>delay</tt> method.</p>\n<pre><span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]:</span> <span class=\"kn\">import</span> <span class=\"nn\">tasktiger</span><span class=\"o\">,</span> <span class=\"nn\">tasks</span>\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]:</span> <span class=\"n\">tiger</span> <span class=\"o\">=</span> <span class=\"n\">tasktiger</span><span class=\"o\">.</span><span class=\"n\">TaskTiger</span><span class=\"p\">()</span>\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]:</span> <span class=\"n\">tiger</span><span class=\"o\">.</span><span class=\"n\">delay</span><span class=\"p\">(</span><span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">my_task</span><span class=\"p\">)</span>\n</pre>\n<p>Run a worker (make sure the task code can be found, e.g. using <tt>PYTHONPATH</tt>).</p>\n<pre>% <span class=\"nv\">PYTHONPATH</span><span class=\"o\">=</span>. tasktiger\n<span class=\"o\">{</span><span class=\"s2\">\"timestamp\"</span>: <span class=\"s2\">\"2015-08-27T21:00:09.135344Z\"</span>, <span class=\"s2\">\"queues\"</span>: null, <span class=\"s2\">\"pid\"</span>: <span class=\"m\">69840</span>, <span class=\"s2\">\"event\"</span>: <span class=\"s2\">\"ready\"</span>, <span class=\"s2\">\"level\"</span>: <span class=\"s2\">\"info\"</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"s2\">\"task_id\"</span>: <span class=\"s2\">\"6fa07a91642363593cddef7a9e0c70ae3480921231710aa7648b467e637baa79\"</span>, <span class=\"s2\">\"level\"</span>: <span class=\"s2\">\"debug\"</span>, <span class=\"s2\">\"timestamp\"</span>: <span class=\"s2\">\"2015-08-27T21:03:56.727051Z\"</span>, <span class=\"s2\">\"pid\"</span>: <span class=\"m\">69840</span>, <span class=\"s2\">\"queue\"</span>: <span class=\"s2\">\"default\"</span>, <span class=\"s2\">\"child_pid\"</span>: <span class=\"m\">70171</span>, <span class=\"s2\">\"event\"</span>: <span class=\"s2\">\"processing\"</span><span class=\"o\">}</span>\nHello\n<span class=\"o\">{</span><span class=\"s2\">\"task_id\"</span>: <span class=\"s2\">\"6fa07a91642363593cddef7a9e0c70ae3480921231710aa7648b467e637baa79\"</span>, <span class=\"s2\">\"level\"</span>: <span class=\"s2\">\"debug\"</span>, <span class=\"s2\">\"timestamp\"</span>: <span class=\"s2\">\"2015-08-27T21:03:56.732457Z\"</span>, <span class=\"s2\">\"pid\"</span>: <span class=\"m\">69840</span>, <span class=\"s2\">\"queue\"</span>: <span class=\"s2\">\"default\"</span>, <span class=\"s2\">\"event\"</span>: <span class=\"s2\">\"done\"</span><span class=\"o\">}</span>\n</pre>\n</div>\n<div id=\"configuration\">\n<h2><a href=\"#id3\" rel=\"nofollow\">Configuration</a></h2>\n<p>A <tt>TaskTiger</tt> object keeps track of TaskTiger\u2019s settings and is used to\ndecorate and queue tasks. The constructor takes the following arguments:</p>\n<ul>\n<li><p><tt>connection</tt></p>\n<p>Redis connection object. The connection should be initialized with\n<tt>decode_responses=True</tt> to avoid encoding problems on Python 3.</p>\n</li>\n<li><p><tt>config</tt></p>\n<p>Dict with config options. Most configuration options don\u2019t need to be\nchanged, and a full list can be seen within <tt>TaskTiger</tt>\u2019s <tt>__init__</tt>\nmethod.</p>\n<p>Here are a few commonly used options:</p>\n<ul>\n<li><p><tt>ALWAYS_EAGER</tt></p>\n<p>If set to <tt>True</tt>, all tasks except future tasks (<tt>when</tt> is a future\ntime) will be executed locally by blocking until the task returns. This is\nuseful for testing purposes.</p>\n</li>\n<li><p><tt>BATCH_QUEUES</tt></p>\n<p>Set up queues that will be processed in batch, i.e. multiple jobs are taken\nout of the queue at the same time and passed as a list to the worker\nmethod. Takes a dict where the key represents the queue name and the value\nrepresents the batch size. Note that the task needs to be declared as\n<tt>batch=True</tt>. Also note that any subqueues will be automatically treated\nas batch queues, and the batch value of the most specific subqueue name\ntakes precedence.</p>\n</li>\n<li><p><tt>ONLY_QUEUES</tt></p>\n<p>If set to a non-empty list of queue names, a worker only processes the\ngiven queues (and their subqueues), unless explicit queues are passed to\nthe command line.</p>\n</li>\n</ul>\n</li>\n<li><p><tt>setup_structlog</tt></p>\n<p>If set to True, sets up structured logging using <tt>structlog</tt> when\ninitializing TaskTiger. This makes writing custom worker scripts easier\nsince it doesn\u2019t require the user to set up <tt>structlog</tt> in advance.</p>\n</li>\n</ul>\n<p>Example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">tasktiger</span>\n<span class=\"kn\">from</span> <span class=\"nn\">redis</span> <span class=\"kn\">import</span> <span class=\"n\">Redis</span>\n<span class=\"n\">conn</span> <span class=\"o\">=</span> <span class=\"n\">Redis</span><span class=\"p\">(</span><span class=\"n\">db</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">decode_responses</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">tiger</span> <span class=\"o\">=</span> <span class=\"n\">tasktiger</span><span class=\"o\">.</span><span class=\"n\">TaskTiger</span><span class=\"p\">(</span><span class=\"n\">connection</span><span class=\"o\">=</span><span class=\"n\">conn</span><span class=\"p\">,</span> <span class=\"n\">config</span><span class=\"o\">=</span><span class=\"p\">{</span>\n    <span class=\"s1\">'BATCH_QUEUES'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"c1\"># Batch up to 50 tasks that are queued in the my_batch_queue or any</span>\n        <span class=\"c1\"># of its subqueues, except for the send_email subqueue which only</span>\n        <span class=\"c1\"># processes up to 10 tasks at a time.</span>\n        <span class=\"s1\">'my_batch_queue'</span><span class=\"p\">:</span> <span class=\"mi\">50</span><span class=\"p\">,</span>\n        <span class=\"s1\">'my_batch_queue.send_email'</span><span class=\"p\">:</span> <span class=\"mi\">10</span><span class=\"p\">,</span>\n    <span class=\"p\">},</span>\n<span class=\"p\">})</span>\n</pre>\n</div>\n<div id=\"task-decorator\">\n<h2><a href=\"#id4\" rel=\"nofollow\">Task decorator</a></h2>\n<p>TaskTiger provides a task decorator to specify task options. Note that simple\ntasks don\u2019t need to be decorated. However, decorating the task allows you to\nuse an alternative syntax to queue the task, which is compatible with Celery:</p>\n<pre><span class=\"c1\"># tasks.py</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">tasktiger</span>\n<span class=\"n\">tiger</span> <span class=\"o\">=</span> <span class=\"n\">tasktiger</span><span class=\"o\">.</span><span class=\"n\">TaskTiger</span><span class=\"p\">()</span>\n\n<span class=\"nd\">@tiger</span><span class=\"o\">.</span><span class=\"n\">task</span><span class=\"p\">()</span>\n<span class=\"k\">def</span> <span class=\"nf\">my_task</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Hello'</span><span class=\"p\">,</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]:</span> <span class=\"kn\">import</span> <span class=\"nn\">tasks</span>\n<span class=\"c1\"># The following are equivalent. However, the second syntax can only be used</span>\n<span class=\"c1\"># if the task is decorated.</span>\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]:</span> <span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">tiger</span><span class=\"o\">.</span><span class=\"n\">delay</span><span class=\"p\">(</span><span class=\"n\">my_task</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"s1\">'John'</span><span class=\"p\">,),</span> <span class=\"n\">kwargs</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'n'</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">})</span>\n<span class=\"n\">In</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]:</span> <span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">my_task</span><span class=\"o\">.</span><span class=\"n\">delay</span><span class=\"p\">(</span><span class=\"s1\">'John'</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"task-options\">\n<h2><a href=\"#id5\" rel=\"nofollow\">Task options</a></h2>\n<p>Tasks support a variety of options that can be specified either in the task\ndecorator, or when queueing a task. For the latter, the <tt>delay</tt> method must\nbe called on the <tt>TaskTiger</tt> object, and any options in the task decorator\nare overridden.</p>\n<pre><span class=\"nd\">@tiger</span><span class=\"o\">.</span><span class=\"n\">task</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"o\">=</span><span class=\"s1\">'myqueue'</span><span class=\"p\">,</span> <span class=\"n\">unique</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">my_task</span><span class=\"p\">():</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">'Hello'</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"c1\"># The task will be queued in \"otherqueue\", even though the task decorator</span>\n<span class=\"c1\"># says \"myqueue\".</span>\n<span class=\"n\">tiger</span><span class=\"o\">.</span><span class=\"n\">delay</span><span class=\"p\">(</span><span class=\"n\">my_task</span><span class=\"p\">,</span> <span class=\"n\">queue</span><span class=\"o\">=</span><span class=\"s1\">'otherqueue'</span><span class=\"p\">)</span>\n</pre>\n<p>When queueing a task, the task needs to be defined in a module other than the\nPython file which is being executed. In other words, the task can\u2019t be in the\n<tt>__main__</tt> module. TaskTiger will give you back an error otherwise.</p>\n<p>The following options are supported by both <tt>delay</tt> and the task decorator:</p>\n<ul>\n<li><p><tt>queue</tt></p>\n<p>Name of the queue where the task will be queued.</p>\n</li>\n<li><p><tt>hard_timeout</tt></p>\n<p>If the task runs longer than the given number of seconds, it will be\nkilled and marked as failed.</p>\n</li>\n<li><p><tt>unique</tt></p>\n<p>Boolean to indicate whether the task will only be queued if there is no\nsimilar task with the same function, arguments, and keyword arguments in the\nqueue. Note that multiple similar tasks may still be executed at the same\ntime since the task will still be inserted into the queue if another one\nis being processed. Requeueing an already scheduled unique task will not\nchange the time it was originally scheduled to execute at.</p>\n</li>\n<li><p><tt>lock</tt></p>\n<p>Boolean to indicate whether to hold a lock while the task is being executed\n(for the given args and kwargs). If a task with similar args/kwargs is queued\nand tries to acquire the lock, it will be retried later.</p>\n</li>\n<li><p><tt>lock_key</tt></p>\n<p>If set, this implies <tt>lock=True</tt> and specifies the list of kwargs to\nuse to construct the lock key. By default, all args and kwargs are\nserialized and hashed.</p>\n</li>\n<li><p><tt>max_queue_size</tt></p>\n<p>A maximum queue size can be enforced by setting this to an integer value.\nThe <tt>QueueFullException</tt> exception will be raised when queuing a task if\nthis limit is reached. Tasks in the <tt>active</tt>, <tt>scheduled</tt>, and <tt>queued</tt>\nstates are counted against this limit.</p>\n</li>\n<li><p><tt>when</tt></p>\n<p>Takes either a datetime (for an absolute date) or a timedelta\n(relative to now). If given, the task will be scheduled for the given\ntime.</p>\n</li>\n<li><p><tt>retry</tt></p>\n<p>Boolean to indicate whether to retry the task when it fails (either because\nof an exception or because of a timeout). To restrict the list of failures,\nuse <tt>retry_on</tt>. Unless <tt>retry_method</tt> is given, the configured\n<tt>DEFAULT_RETRY_METHOD</tt> is used.</p>\n</li>\n<li><p><tt>retry_on</tt></p>\n<p>If a list is given, it implies <tt>retry=True</tt>. The task will be only retried\non the given exceptions (or its subclasses). To retry the task when a hard\ntimeout occurs, use <tt>JobTimeoutException</tt>.</p>\n</li>\n<li><p><tt>retry_method</tt></p>\n<p>If given, implies <tt>retry=True</tt>. Pass either:</p>\n<ul>\n<li>a function that takes the retry number as an argument, or,</li>\n<li>a tuple <tt>(f, args)</tt>, where <tt>f</tt> takes the retry number as the first\nargument, followed by the additional args.</li>\n</ul>\n<p>The function needs to return the desired retry interval in seconds, or raise\n<tt>StopRetry</tt> to stop retrying. The following built-in functions can be\npassed for common scenarios and return the appropriate tuple:</p>\n<ul>\n<li><p><tt>fixed(delay, max_retries)</tt></p>\n<p>Returns a method that returns the given <tt>delay</tt> (in seconds) or raises\n<tt>StopRetry</tt> if the number of retries exceeds <tt>max_retries</tt>.</p>\n</li>\n<li><p><tt>linear(delay, increment, max_retries)</tt></p>\n<p>Like <tt>fixed</tt>, but starts off with the given <tt>delay</tt> and increments it\nby the given <tt>increment</tt> after every retry.</p>\n</li>\n<li><p><tt>exponential(delay, factor, max_retries)</tt></p>\n<p>Like <tt>fixed</tt>, but starts off with the given <tt>delay</tt> and multiplies it\nby the given <tt>factor</tt> after every retry.</p>\n</li>\n</ul>\n<p>For example, to retry a task 3 times (for a total of 4 executions), and wait\n60 seconds between executions, pass <tt>retry_method=fixed(60, 3)</tt>.</p>\n</li>\n</ul>\n<p>The following options can be only specified in the task decorator:</p>\n<ul>\n<li><p><tt>batch</tt></p>\n<p>If set to <tt>True</tt>, the task will receive a list of dicts with args and\nkwargs and can process multiple tasks of the same type at once.\nExample: <tt><span class=\"pre\">[{\"args\":</span> [1], \"kwargs\": <span class=\"pre\">{}},</span> {\"args\": [2], \"kwargs\": <span class=\"pre\">{}}]</span></tt>\nNote that the list will only contain multiple items if the worker\nhas set up <tt>BATCH_QUEUES</tt> for the specific queue (see the <em>Configuration</em>\nsection).</p>\n</li>\n<li><p><tt>schedule</tt></p>\n<p>If given, makes a task execute periodically. Pass either:</p>\n<ul>\n<li>a function that takes the current datetime as an argument.</li>\n<li>a tuple <tt>(f, args)</tt>, where <tt>f</tt> takes the current datetime as the first\nargument, followed by the additional args.</li>\n</ul>\n<p>The schedule function must return the next task execution datetime, or\n<tt>None</tt> to prevent periodic execution. The function is executed to determine\nthe initial task execution date when a worker is initialized, and to determine\nthe next execution date when the task is about to get executed.</p>\n<p>For most common scenarios, the <tt>periodic</tt> built-in function can be passed:</p>\n<ul>\n<li><p><tt>periodic(seconds=0, minutes=0, hours=0, days=0, weeks=0, start_date=None,\nend_date=None)</tt></p>\n<p>Use equal, periodic intervals, starting from <tt>start_date</tt> (defaults to\n<tt><span class=\"pre\">2000-01-01T00:00Z</span></tt>, a Saturday, if not given), ending at <tt>end_date</tt> (or\nnever, if not given). For example, to run a task every five minutes\nindefinitely, use <tt>schedule=periodic(minutes=5)</tt>. To run a task every\nevery Sunday at 4am UTC, you could use\n<tt>schedule=periodic(weeks=1, start_date=datetime.datetime(2000, 1, 2, 4))</tt>.</p>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"custom-retrying\">\n<h2><a href=\"#id6\" rel=\"nofollow\">Custom retrying</a></h2>\n<p>In some cases the task retry options may not be flexible enough. For example,\nyou might want to use a different retry method depending on the exception type,\nor you might want to like to suppress logging an error if a task fails after\nretries. In these cases, <tt>RetryException</tt> can be raised within the task\nfunction. The following options are supported:</p>\n<ul>\n<li><p><tt>method</tt></p>\n<p>Specify a custom retry method for this retry. If not given, the task\u2019s\ndefault retry method is used, or, if unspecified, the configured\n<tt>DEFAULT_RETRY_METHOD</tt>. Note that the number of retries passed to the\nretry method is always the total number of times this method has been\nexecuted, regardless of which retry method was used.</p>\n</li>\n<li><p><tt>original_traceback</tt></p>\n<p>If <tt>RetryException</tt> is raised from within an except block and\n<tt>original_traceback</tt> is True, the original traceback will be logged (i.e.\nthe stacktrace at the place where the caught exception was raised). False by\ndefault.</p>\n</li>\n<li><p><tt>log_error</tt></p>\n<p>If set to False and the task fails permanently, a warning will be logged\ninstead of an error, and the task will be removed from Redis when it\ncompletes. True by default.</p>\n</li>\n</ul>\n<p>Example usage:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">tasktiger.exceptions</span> <span class=\"kn\">import</span> <span class=\"n\">RetryException</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">my_task</span><span class=\"p\">():</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">ready</span><span class=\"p\">():</span>\n        <span class=\"c1\"># Retry every minute up to 3 times if we're not ready. An error will</span>\n        <span class=\"c1\"># be logged if we're out of retries.</span>\n        <span class=\"k\">raise</span> <span class=\"n\">RetryException</span><span class=\"p\">(</span><span class=\"n\">method</span><span class=\"o\">=</span><span class=\"n\">fixed</span><span class=\"p\">(</span><span class=\"mi\">60</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">some_code</span><span class=\"p\">()</span>\n    <span class=\"k\">except</span> <span class=\"n\">NetworkException</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Back off exponentially up to 5 times in case of a network failure.</span>\n        <span class=\"c1\"># Log the original traceback (as a warning) and don't log an error if</span>\n        <span class=\"c1\"># we still fail after 5 times.</span>\n        <span class=\"k\">raise</span> <span class=\"n\">RetryException</span><span class=\"p\">(</span><span class=\"n\">method</span><span class=\"o\">=</span><span class=\"n\">exponential</span><span class=\"p\">(</span><span class=\"mi\">60</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">),</span>\n                             <span class=\"n\">original_traceback</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n                             <span class=\"n\">log_error</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"workers\">\n<h2><a href=\"#id7\" rel=\"nofollow\">Workers</a></h2>\n<p>The <tt>tasktiger</tt> command is used on the command line to invoke a worker. To\ninvoke multiple workers, multiple instances need to be started. This can be\neasily done e.g. via Supervisor. The following Supervisor configuration file\ncan be placed in <tt>/etc/supervisor/tasktiger.ini</tt> and runs 4 TaskTiger workers\nas the <tt>ubuntu</tt> user. For more information, read Supervisor\u2019s documentation.</p>\n<pre><span class=\"o\">[</span>program:tasktiger<span class=\"o\">]</span>\n<span class=\"nv\">command</span><span class=\"o\">=</span>/usr/local/bin/tasktiger\n<span class=\"nv\">process_name</span><span class=\"o\">=</span>%<span class=\"o\">(</span>program_name<span class=\"o\">)</span>s_%<span class=\"o\">(</span>process_num<span class=\"o\">)</span>02d\n<span class=\"nv\">numprocs</span><span class=\"o\">=</span><span class=\"m\">4</span>\n<span class=\"nv\">numprocs_start</span><span class=\"o\">=</span><span class=\"m\">0</span>\n<span class=\"nv\">priority</span><span class=\"o\">=</span><span class=\"m\">999</span>\n<span class=\"nv\">autostart</span><span class=\"o\">=</span><span class=\"nb\">true</span>\n<span class=\"nv\">autorestart</span><span class=\"o\">=</span><span class=\"nb\">true</span>\n<span class=\"nv\">startsecs</span><span class=\"o\">=</span><span class=\"m\">10</span>\n<span class=\"nv\">startretries</span><span class=\"o\">=</span><span class=\"m\">3</span>\n<span class=\"nv\">exitcodes</span><span class=\"o\">=</span><span class=\"m\">0</span>,2\n<span class=\"nv\">stopsignal</span><span class=\"o\">=</span>TERM\n<span class=\"nv\">stopwaitsecs</span><span class=\"o\">=</span><span class=\"m\">600</span>\n<span class=\"nv\">killasgroup</span><span class=\"o\">=</span><span class=\"nb\">false</span>\n<span class=\"nv\">user</span><span class=\"o\">=</span>ubuntu\n<span class=\"nv\">redirect_stderr</span><span class=\"o\">=</span><span class=\"nb\">false</span>\n<span class=\"nv\">stdout_logfile</span><span class=\"o\">=</span>/var/log/tasktiger.out.log\n<span class=\"nv\">stdout_logfile_maxbytes</span><span class=\"o\">=</span>250MB\n<span class=\"nv\">stdout_logfile_backups</span><span class=\"o\">=</span><span class=\"m\">10</span>\n<span class=\"nv\">stderr_logfile</span><span class=\"o\">=</span>/var/log/tasktiger.err.log\n<span class=\"nv\">stderr_logfile_maxbytes</span><span class=\"o\">=</span>250MB\n<span class=\"nv\">stderr_logfile_backups</span><span class=\"o\">=</span><span class=\"m\">10</span>\n</pre>\n<p>Workers support the following options:</p>\n<ul>\n<li><p><tt><span class=\"pre\">-q</span></tt>, <tt><span class=\"pre\">--queues</span></tt></p>\n<p>If specified, only the given queue(s) are processed. Multiple queues can be\nseparated by comma. Any subqueues of the given queues will be also processed.\nFor example, <tt><span class=\"pre\">-q</span> first,second</tt> will process items from <tt>first</tt>,\n<tt>second</tt>, and subqueues such as <tt>first.CUSTOMER1</tt>, <tt>first.CUSTOMER2</tt>.</p>\n</li>\n<li><p><tt><span class=\"pre\">-e</span></tt>, <tt><span class=\"pre\">--exclude-queues</span></tt></p>\n<p>If specified, exclude the given queue(s) from processing. Multiple queues can\nbe separated by comma. Any subqueues of the given queues will also be\nexcluded unless a more specific queue is specified with the <tt><span class=\"pre\">-q</span></tt> option.\nFor example, <tt><span class=\"pre\">-q</span> email,email.incoming.CUSTOMER1 <span class=\"pre\">-e</span> email.incoming</tt> will\nprocess items from the <tt>email</tt> queue and subqueues like\n<tt>email.outgoing.CUSTOMER1</tt> or <tt>email.incoming.CUSTOMER1</tt>, but not\n<tt>email.incoming</tt> or <tt>email.incoming.CUSTOMER2</tt>.</p>\n</li>\n<li><p><tt><span class=\"pre\">-m</span></tt>, <tt><span class=\"pre\">--module</span></tt></p>\n<p>Module(s) to import when launching the worker. This improves task performance\nsince the module doesn\u2019t have to be reimported every time a task is forked.\nMultiple modules can be separated by comma.</p>\n<p>Another way to preload modules is to set up a custom TaskTiger launch script,\nwhich is described below.</p>\n</li>\n<li><p><tt><span class=\"pre\">-h</span></tt>, <tt><span class=\"pre\">--host</span></tt></p>\n<p>Redis server hostname (if different from <tt>localhost</tt>).</p>\n</li>\n<li><p><tt><span class=\"pre\">-p</span></tt>, <tt><span class=\"pre\">--port</span></tt></p>\n<p>Redis server port (if different from <tt>6379</tt>).</p>\n</li>\n<li><p><tt><span class=\"pre\">-a</span></tt>, <tt><span class=\"pre\">--password</span></tt></p>\n<p>Redis server password (if required).</p>\n</li>\n<li><p><tt><span class=\"pre\">-n</span></tt>, <tt><span class=\"pre\">--db</span></tt></p>\n<p>Redis server database number (if different from <tt>0</tt>).</p>\n</li>\n<li><p><tt><span class=\"pre\">-M</span></tt>, <tt><span class=\"pre\">--max-workers-per-queue</span></tt></p>\n<p>Maximum number of workers that are allowed to process a queue.</p>\n</li>\n<li><p><tt><span class=\"pre\">--store-tracebacks/--no-store-tracebacks</span></tt></p>\n<p>Store tracebacks with execution history (config defaults to <tt>True</tt>).</p>\n</li>\n</ul>\n<p>In some cases it is convenient to have a custom TaskTiger launch script. For\nexample, your application may have a <tt>manage.py</tt> command that sets up the\nenvironment and you may want to launch TaskTiger workers using that script. To\ndo that, you can use the <tt>run_worker_with_args</tt> method, which launches a\nTaskTiger worker and parses any command line arguments. Here is an example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">from</span> <span class=\"nn\">tasktiger</span> <span class=\"kn\">import</span> <span class=\"n\">TaskTiger</span>\n\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"n\">command</span> <span class=\"o\">=</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"k\">except</span> <span class=\"ne\">IndexError</span><span class=\"p\">:</span>\n    <span class=\"n\">command</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n\n<span class=\"k\">if</span> <span class=\"n\">command</span> <span class=\"o\">==</span> <span class=\"s1\">'tasktiger'</span><span class=\"p\">:</span>\n    <span class=\"n\">tiger</span> <span class=\"o\">=</span> <span class=\"n\">TaskTiger</span><span class=\"p\">(</span><span class=\"n\">setup_structlog</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Strip the \"tasktiger\" arg when running via manage, so we can run e.g.</span>\n    <span class=\"c1\"># ./manage.py tasktiger --help</span>\n    <span class=\"n\">tiger</span><span class=\"o\">.</span><span class=\"n\">run_worker_with_args</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">:])</span>\n    <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">exit</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n</pre>\n<p>If you\u2019re using <tt><span class=\"pre\">flask-script</span></tt>, you can use the <tt>TaskTigerCommand</tt> provided\nin the <tt>tasktiger.flask_script</tt> module. It takes the <tt>TaskTiger</tt> instance\nas an argument. Tasks will have access to Flask\u2019s application context. Example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">flask</span> <span class=\"kn\">import</span> <span class=\"n\">Flask</span>\n<span class=\"kn\">from</span> <span class=\"nn\">flask.ext.script</span> <span class=\"kn\">import</span> <span class=\"n\">Manager</span>\n<span class=\"kn\">from</span> <span class=\"nn\">tasktiger.flask_script</span> <span class=\"kn\">import</span> <span class=\"n\">TaskTigerCommand</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">Flask</span><span class=\"p\">()</span>\n<span class=\"n\">manager</span> <span class=\"o\">=</span> <span class=\"n\">Manager</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"p\">)</span>\n<span class=\"n\">tiger</span> <span class=\"o\">=</span> <span class=\"n\">TaskTiger</span><span class=\"p\">(</span><span class=\"n\">setup_structlog</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"n\">manager</span><span class=\"o\">.</span><span class=\"n\">add_command</span><span class=\"p\">(</span><span class=\"s1\">'tasktiger'</span><span class=\"p\">,</span> <span class=\"n\">TaskTigerCommand</span><span class=\"p\">(</span><span class=\"n\">tiger</span><span class=\"p\">))</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">manager</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">()</span>\n</pre>\n<p>You can subclass the <tt>TaskTigerCommand</tt> and override the <tt>setup</tt> method to\nimplement any custom setup that needs to be done before running the worker.</p>\n</div>\n<div id=\"inspect-requeue-and-delete-tasks\">\n<h2><a href=\"#id8\" rel=\"nofollow\">Inspect, requeue and delete tasks</a></h2>\n<p>TaskTiger provides access to the <tt>Task</tt> class which lets you inspect queues\nand perform various actions on tasks.</p>\n<p>Each queue can have tasks in the following states:</p>\n<ul>\n<li><tt>queued</tt>: Tasks that are queued and waiting to be picked up by the workers.</li>\n<li><tt>active</tt>: Tasks that are currently being processed by the workers.</li>\n<li><tt>scheduled</tt>: Tasks that are scheduled for later execution.</li>\n<li><tt>error</tt>: Tasks that failed with an error.</li>\n</ul>\n<p>To get a list of all tasks for a given queue and state, use\n<tt>Task.tasks_from_queue</tt>. The method gives you back a tuple containing the\ntotal number of tasks in the queue (useful if the tasks are truncated) and a\nlist of tasks in the queue, latest first. Using the <tt>skip</tt> and <tt>limit</tt>\nkeyword arguments, you can fetch arbitrary slices of the queue. If you know the\ntask ID, you can fetch a given task using <tt>Task.from_id</tt>. Both methods let\nyou load tracebacks from failed task executions using the <tt>load_executions</tt>\nkeyword argument, which accepts an integer indicating how many executions\nshould be loaded.</p>\n<p>Tasks can also be constructed and queued using the regular constructor, which\ntakes the TaskTiger instance, the function name and the options described in\nthe <em>Task options</em> section. The task can then be queued using its <tt>delay</tt>\nmethod. Note that the <tt>when</tt> argument needs to be passed to the <tt>delay</tt>\nmethod, if applicable. Unique tasks can be reconstructed using the same\narguments.</p>\n<p>The <tt>Task</tt> object has the following properties:</p>\n<ul>\n<li><tt>id</tt>: The task ID.</li>\n<li><tt>data</tt>: The raw data as a dict from Redis.</li>\n<li><tt>executions</tt>: A list of failed task executions (as dicts). An execution\ndict contains the processing time in <tt>time_started</tt> and <tt>time_failed</tt>,\nthe worker host in <tt>host</tt>, the exception name in <tt>exception_name</tt> and\nthe full traceback in <tt>traceback</tt>.</li>\n<li><tt>serialized_func</tt>, <tt>args</tt>, <tt>kwargs</tt>: The serialized function name with\nall of its arguments.</li>\n<li><tt>func</tt>: The imported (executable) function</li>\n</ul>\n<p>The <tt>Task</tt> object has the following methods:</p>\n<ul>\n<li><tt>cancel</tt>: Cancel a scheduled task.</li>\n<li><tt>delay</tt>: Queue the task for execution.</li>\n<li><tt>delete</tt>: Remove the task from the error queue.</li>\n<li><tt>execute</tt>: Run the task without queueing it.</li>\n<li><tt>n_executions</tt>: Queries and returns the number of past task executions.</li>\n<li><tt>retry</tt>: Requeue the task from the error queue for execution.</li>\n<li><tt>update_scheduled_time</tt>: Updates a scheduled task\u2019s date to the given date.</li>\n</ul>\n<p>The current task can be accessed within the task function while it\u2019s being\nexecuted: In case of a non-batch task, the <tt>current_task</tt> property of the\n<tt>TaskTiger</tt> instance returns the current <tt>Task</tt> instance. In case of a\nbatch task the <tt>current_tasks</tt> property must be used which returns a list of\ntasks that are currently being processed (in the same order as they were passed\nto the task).</p>\n<p>Example 1: Queueing a unique task and canceling it without a reference to the\noriginal task.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">tasktiger</span> <span class=\"kn\">import</span> <span class=\"n\">TaskTiger</span><span class=\"p\">,</span> <span class=\"n\">Task</span>\n\n<span class=\"n\">tiger</span> <span class=\"o\">=</span> <span class=\"n\">TaskTiger</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># Send an email in five minutes.</span>\n<span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">Task</span><span class=\"p\">(</span><span class=\"n\">tiger</span><span class=\"p\">,</span> <span class=\"n\">send_mail</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'email_id'</span><span class=\"p\">],</span> <span class=\"n\">unique</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">delay</span><span class=\"p\">(</span><span class=\"n\">when</span><span class=\"o\">=</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">minutes</span><span class=\"o\">=</span><span class=\"mi\">5</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Unique tasks get back a task instance referring to the same task by simply</span>\n<span class=\"c1\"># creating the same task again.</span>\n<span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">Task</span><span class=\"p\">(</span><span class=\"n\">tiger</span><span class=\"p\">,</span> <span class=\"n\">send_mail</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'email_id'</span><span class=\"p\">],</span> <span class=\"n\">unique</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">cancel</span><span class=\"p\">()</span>\n</pre>\n<p>Example 2: Inspecting queues and retrying a task by ID.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">tasktiger</span> <span class=\"kn\">import</span> <span class=\"n\">TaskTiger</span><span class=\"p\">,</span> <span class=\"n\">Task</span>\n\n<span class=\"n\">QUEUE_NAME</span> <span class=\"o\">=</span> <span class=\"s1\">'default'</span>\n<span class=\"n\">TASK_STATE</span> <span class=\"o\">=</span> <span class=\"s1\">'error'</span>\n<span class=\"n\">TASK_ID</span> <span class=\"o\">=</span> <span class=\"s1\">'6fa07a91642363593cddef7a9e0c70ae3480921231710aa7648b467e637baa79'</span>\n\n<span class=\"n\">tiger</span> <span class=\"o\">=</span> <span class=\"n\">TaskTiger</span><span class=\"p\">()</span>\n\n<span class=\"n\">n_total</span><span class=\"p\">,</span> <span class=\"n\">tasks</span> <span class=\"o\">=</span> <span class=\"n\">Task</span><span class=\"o\">.</span><span class=\"n\">tasks_from_queue</span><span class=\"p\">(</span><span class=\"n\">tiger</span><span class=\"p\">,</span> <span class=\"n\">QUEUE_NAME</span><span class=\"p\">,</span> <span class=\"n\">TASK_STATE</span><span class=\"p\">)</span>\n\n<span class=\"k\">for</span> <span class=\"n\">task</span> <span class=\"ow\">in</span> <span class=\"n\">tasks</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">func</span><span class=\"p\">)</span>\n\n<span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">Task</span><span class=\"o\">.</span><span class=\"n\">from_id</span><span class=\"p\">(</span><span class=\"n\">tiger</span><span class=\"p\">,</span> <span class=\"n\">QUEUE_NAME</span><span class=\"p\">,</span> <span class=\"n\">TASK_STATE</span><span class=\"p\">,</span> <span class=\"n\">TASK_ID</span><span class=\"p\">)</span>\n<span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">retry</span><span class=\"p\">()</span>\n</pre>\n<p>Example 3: Accessing the task instances within a batch task function to\ndetermine how many times the currently processing tasks were previously\nexecuted.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">tasktiger</span> <span class=\"kn\">import</span> <span class=\"n\">TaskTiger</span>\n\n<span class=\"n\">tiger</span> <span class=\"o\">=</span> <span class=\"n\">TaskTiger</span><span class=\"p\">()</span>\n\n<span class=\"nd\">@tiger</span><span class=\"o\">.</span><span class=\"n\">task</span><span class=\"p\">(</span><span class=\"n\">batch</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">my_task</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">):</span>\n    <span class=\"k\">for</span> <span class=\"n\">task</span> <span class=\"ow\">in</span> <span class=\"n\">tiger</span><span class=\"o\">.</span><span class=\"n\">current_tasks</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">n_executions</span><span class=\"p\">())</span>\n</pre>\n</div>\n<div id=\"pause-queue-processing\">\n<h2><a href=\"#id9\" rel=\"nofollow\">Pause queue processing</a></h2>\n<p>The <tt><span class=\"pre\">--max-workers-per-queue</span></tt> option uses queue locks to control the\nnumber of workers that can simultaneously process the same queue. When using\nthis option a system lock can be placed on a queue which will keep workers\nfrom processing tasks from that queue until it expires. Use the\n<tt>set_queue_system_lock()</tt> method of the TaskTiger object to set this lock.</p>\n</div>\n<div id=\"rollbar-error-handling\">\n<h2><a href=\"#id10\" rel=\"nofollow\">Rollbar error handling</a></h2>\n<p>TaskTiger comes with Rollbar integration for error handling. When a task errors\nout, it can be logged to Rollbar, grouped by queue, task function name and\nexception type. To enable logging, initialize rollbar with the\n<tt>StructlogRollbarHandler</tt> provided in the <tt>tasktiger.rollbar</tt> module. The\nhandler takes a string as an argument which is used to prefix all the messages\nreported to Rollbar. Here is a custom worker launch script:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">logging</span>\n<span class=\"kn\">import</span> <span class=\"nn\">rollbar</span>\n<span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">from</span> <span class=\"nn\">tasktiger</span> <span class=\"kn\">import</span> <span class=\"n\">TaskTiger</span>\n<span class=\"kn\">from</span> <span class=\"nn\">tasktiger.rollbar</span> <span class=\"kn\">import</span> <span class=\"n\">StructlogRollbarHandler</span>\n\n<span class=\"n\">tiger</span> <span class=\"o\">=</span> <span class=\"n\">TaskTiger</span><span class=\"p\">(</span><span class=\"n\">setup_structlog</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"n\">rollbar</span><span class=\"o\">.</span><span class=\"n\">init</span><span class=\"p\">(</span><span class=\"n\">ROLLBAR_API_KEY</span><span class=\"p\">,</span> <span class=\"n\">APPLICATION_ENVIRONMENT</span><span class=\"p\">,</span>\n             <span class=\"n\">allow_logging_basic_config</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n<span class=\"n\">rollbar_handler</span> <span class=\"o\">=</span> <span class=\"n\">StructlogRollbarHandler</span><span class=\"p\">(</span><span class=\"s1\">'TaskTiger'</span><span class=\"p\">)</span>\n<span class=\"n\">rollbar_handler</span><span class=\"o\">.</span><span class=\"n\">setLevel</span><span class=\"p\">(</span><span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">ERROR</span><span class=\"p\">)</span>\n<span class=\"n\">tiger</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"o\">.</span><span class=\"n\">addHandler</span><span class=\"p\">(</span><span class=\"n\">rollbar_handler</span><span class=\"p\">)</span>\n\n<span class=\"n\">tiger</span><span class=\"o\">.</span><span class=\"n\">run_worker_with_args</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:])</span>\n</pre>\n</div>\n<div id=\"cleaning-up-error-d-tasks\">\n<h2><a href=\"#id11\" rel=\"nofollow\">Cleaning Up Error\u2019d Tasks</a></h2>\n<p>Error\u2019d tasks occasionally need to be purged from Redis, so <tt>TaskTiger</tt>\nexposes a <tt>purge_errored_tasks</tt> method to help. It might be useful to set\nthis up as a periodic task as follows:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">tasktiger</span> <span class=\"kn\">import</span> <span class=\"n\">TaskTiger</span><span class=\"p\">,</span> <span class=\"n\">periodic</span>\n\n<span class=\"n\">tiger</span> <span class=\"o\">=</span> <span class=\"n\">TaskTiger</span><span class=\"p\">()</span>\n\n<span class=\"nd\">@tiger</span><span class=\"o\">.</span><span class=\"n\">task</span><span class=\"p\">(</span><span class=\"n\">schedule</span><span class=\"o\">=</span><span class=\"n\">periodic</span><span class=\"p\">(</span><span class=\"n\">hours</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"k\">def</span> <span class=\"nf\">purge_errored_tasks</span><span class=\"p\">():</span>\n    <span class=\"n\">tiger</span><span class=\"o\">.</span><span class=\"n\">purge_errored_tasks</span><span class=\"p\">(</span>\n        <span class=\"n\">limit</span><span class=\"o\">=</span><span class=\"mi\">1000</span><span class=\"p\">,</span>\n        <span class=\"n\">last_execution_before</span><span class=\"o\">=</span><span class=\"p\">(</span>\n            <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">utcnow</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">timedelta</span><span class=\"p\">(</span><span class=\"n\">weeks</span><span class=\"o\">=</span><span class=\"mi\">12</span><span class=\"p\">)</span>\n        <span class=\"p\">)</span>\n    <span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"running-the-test-suite\">\n<h2><a href=\"#id12\" rel=\"nofollow\">Running The Test Suite</a></h2>\n<p>Tests can be run locally using the provided docker compose file. After installing docker, tests should be runnable with:</p>\n<pre>docker-compose run --rm tasktiger pytest\n</pre>\n<p>Tests can be more granularly run using normal pytest flags. For example:</p>\n<pre>docker-compose run --rm tasktiger pytest tests/test_base.py::TestCase\n</pre>\n</div>\n\n          </div>"}, "last_serial": 6048906, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "d6ce23949f2785f41a4fca4dc7b13588", "sha256": "19c547ddf13ac99b8980ba664bf4fac6cc31a80c73105beb4169a17549d73516"}, "downloads": -1, "filename": "tasktiger-0.1.tar.gz", "has_sig": false, "md5_digest": "d6ce23949f2785f41a4fca4dc7b13588", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21573, "upload_time": "2015-10-02T11:05:48", "upload_time_iso_8601": "2015-10-02T11:05:48.502930Z", "url": "https://files.pythonhosted.org/packages/50/05/873fbf6e67b386e65e7319d76704138b28883332b9dccef07c7dfd618ae8/tasktiger-0.1.tar.gz", "yanked": false}], "0.10.1": [{"comment_text": "", "digests": {"md5": "94258897cb279f91fb6cf864b5be6059", "sha256": "ed58b0e7981bffbce6fd3a198842dd5a338031721dee24884ee246876da8394b"}, "downloads": -1, "filename": "tasktiger-0.10.1-py3-none-any.whl", "has_sig": false, "md5_digest": "94258897cb279f91fb6cf864b5be6059", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 51715, "upload_time": "2019-10-29T19:32:58", "upload_time_iso_8601": "2019-10-29T19:32:58.510808Z", "url": "https://files.pythonhosted.org/packages/2a/38/3a68437207a23d0ac3e2afe6383d20850ea7f1f8161a20ac7fa671347b55/tasktiger-0.10.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bf6e6a5ec53669d5774312aaae129e47", "sha256": "7a66f4ce55d49a391bece4fe5ba3a368ee4f0a9019148389c391732139e1ac48"}, "downloads": -1, "filename": "tasktiger-0.10.1.tar.gz", "has_sig": false, "md5_digest": "bf6e6a5ec53669d5774312aaae129e47", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 72038, "upload_time": "2019-10-29T19:33:00", "upload_time_iso_8601": "2019-10-29T19:33:00.932496Z", "url": "https://files.pythonhosted.org/packages/2d/d0/fbbcd8af7986262f7c7e9bcb6a560ae8893eeb90beaddc398b86c64f3de4/tasktiger-0.10.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "6398dbbed507a9b7a746f727dcc89264", "sha256": "fd93fb8631ca2e9637e98442b57afb0b730ce42757fc1bf748031cdfe17d868f"}, "downloads": -1, "filename": "tasktiger-0.2.tar.gz", "has_sig": false, "md5_digest": "6398dbbed507a9b7a746f727dcc89264", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23785, "upload_time": "2015-11-17T01:02:04", "upload_time_iso_8601": "2015-11-17T01:02:04.189326Z", "url": "https://files.pythonhosted.org/packages/c3/5c/2f9a48c86a0197f1f5cf869e5a27120c028bded26687a344a67395fa8514/tasktiger-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "707e3439f47a5440625795517f6922be", "sha256": "22bd8300415ed342a3befecf861f3377145f1f6e740452f3ecfe9c3b5bb434c8"}, "downloads": -1, "filename": "tasktiger-0.3.tar.gz", "has_sig": false, "md5_digest": "707e3439f47a5440625795517f6922be", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26155, "upload_time": "2016-02-03T19:45:16", "upload_time_iso_8601": "2016-02-03T19:45:16.237874Z", "url": "https://files.pythonhosted.org/packages/13/bc/8c7cbb17fcad49dfa204af118b11cae3ee2be70aa59ffa980c4200a8087a/tasktiger-0.3.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "ac0278f35c3c2fed142c71e76ba9e382", "sha256": "66940aa0c58d6e9e4388976ff6d802225d4fc5b9a229b31426c34f8151ff97b8"}, "downloads": -1, "filename": "tasktiger-0.4.tar.gz", "has_sig": false, "md5_digest": "ac0278f35c3c2fed142c71e76ba9e382", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27486, "upload_time": "2016-03-08T00:42:26", "upload_time_iso_8601": "2016-03-08T00:42:26.176053Z", "url": "https://files.pythonhosted.org/packages/3d/a8/ccb5723547717d15833929894bec6bd6f2cb8e47bbbc308c024cc82bfd34/tasktiger-0.4.tar.gz", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "88e95f340a26895eb054c3ad27f41267", "sha256": "c9cb9f95d8de7d196512b8e1e5b2b27a94021668ef9a3571659b230fb3c2fab9"}, "downloads": -1, "filename": "tasktiger-0.5.tar.gz", "has_sig": false, "md5_digest": "88e95f340a26895eb054c3ad27f41267", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27961, "upload_time": "2016-03-14T19:35:43", "upload_time_iso_8601": "2016-03-14T19:35:43.512340Z", "url": "https://files.pythonhosted.org/packages/95/fa/e9060dcc05c23c99f1cbb142f0d2262c3a995accb376dde869762647937c/tasktiger-0.5.tar.gz", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "0ae1e9fbcfcf427b550c55432b08923b", "sha256": "2e30ae42e6e85daa7999195fdb12648e3224d7b26a7876a261f88fe201e1c530"}, "downloads": -1, "filename": "tasktiger-0.6.tar.gz", "has_sig": false, "md5_digest": "0ae1e9fbcfcf427b550c55432b08923b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28103, "upload_time": "2016-04-14T09:49:32", "upload_time_iso_8601": "2016-04-14T09:49:32.169748Z", "url": "https://files.pythonhosted.org/packages/22/85/14c9f77715e6e6c797c859cc4e656980a3c66bc6e475a95ea101a4d359b1/tasktiger-0.6.tar.gz", "yanked": false}], "0.7": [{"comment_text": "", "digests": {"md5": "af29fd8ef407ff64dc667b43ead78d26", "sha256": "9723f16202ce13de709b6b705107bfdf9e7b04b802d29148c0e08ce450f7a657"}, "downloads": -1, "filename": "tasktiger-0.7.tar.gz", "has_sig": false, "md5_digest": "af29fd8ef407ff64dc667b43ead78d26", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28244, "upload_time": "2016-05-25T00:31:03", "upload_time_iso_8601": "2016-05-25T00:31:03.009124Z", "url": "https://files.pythonhosted.org/packages/f1/8c/4f5765bd69d5093f2d37e5cd4d1cb50f81b80fc9fdfc33313e291bb850d3/tasktiger-0.7.tar.gz", "yanked": false}], "0.8": [{"comment_text": "", "digests": {"md5": "d60ba0b1fbc5837f272f53d98f02fa5a", "sha256": "9a53d236a47a5476f194e0614e4be17de8c6ac54e3a94f8cb4d265e8c7b53235"}, "downloads": -1, "filename": "tasktiger-0.8.tar.gz", "has_sig": false, "md5_digest": "d60ba0b1fbc5837f272f53d98f02fa5a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29461, "upload_time": "2016-07-08T19:42:38", "upload_time_iso_8601": "2016-07-08T19:42:38.479797Z", "url": "https://files.pythonhosted.org/packages/61/65/e0746a52fb32130917e3a4e9ce35a9cc44a4b5f24210ceeb10b5c30663ac/tasktiger-0.8.tar.gz", "yanked": false}], "0.8.1": [{"comment_text": "", "digests": {"md5": "853f4e4d948dee5c648ec9ddaaac99b9", "sha256": "2ddb93260945015470e18ca9065789b6108191c25a051c00f2dccdbed0b0c762"}, "downloads": -1, "filename": "tasktiger-0.8.1.tar.gz", "has_sig": false, "md5_digest": "853f4e4d948dee5c648ec9ddaaac99b9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29456, "upload_time": "2016-08-11T04:54:31", "upload_time_iso_8601": "2016-08-11T04:54:31.430357Z", "url": "https://files.pythonhosted.org/packages/10/a8/bdc0c3e927f3f077f4dc8098689a26bb7e3daefb2f06fe4126ec06c12f09/tasktiger-0.8.1.tar.gz", "yanked": false}], "0.8.2": [{"comment_text": "", "digests": {"md5": "3ef80c41ff2fe99f432115ea56b7ce28", "sha256": "43dee8dd1e6097019cf436fe609ac1484a7990e7386613f76ce1008718c67950"}, "downloads": -1, "filename": "tasktiger-0.8.2.tar.gz", "has_sig": false, "md5_digest": "3ef80c41ff2fe99f432115ea56b7ce28", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29593, "upload_time": "2016-11-16T18:03:32", "upload_time_iso_8601": "2016-11-16T18:03:32.533010Z", "url": "https://files.pythonhosted.org/packages/9a/4b/1264c53579e35364a7d92ea4da40a8e93c3d51f67dd1ff5663dee224015c/tasktiger-0.8.2.tar.gz", "yanked": false}], "0.8.3": [{"comment_text": "", "digests": {"md5": "7cc293dbb3b8f032afc7fa2693277973", "sha256": "fe08b4dfb596e836914d09f532d21d51219a16b072aaa2a2573fdf81851eee10"}, "downloads": -1, "filename": "tasktiger-0.8.3.tar.gz", "has_sig": false, "md5_digest": "7cc293dbb3b8f032afc7fa2693277973", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30284, "upload_time": "2016-12-09T00:04:58", "upload_time_iso_8601": "2016-12-09T00:04:58.800236Z", "url": "https://files.pythonhosted.org/packages/fa/e1/0f0227040ab6c8fa1fb870682c3eccb217ab7f0e897130bb702f7318163b/tasktiger-0.8.3.tar.gz", "yanked": false}], "0.8.4": [{"comment_text": "", "digests": {"md5": "61232cec6f79635e98039e7bd8631023", "sha256": "8d07a9669ea20ab11fe90e0cb8b5e5814600f8e072400c0b65c5b80b1664dd90"}, "downloads": -1, "filename": "tasktiger-0.8.4.tar.gz", "has_sig": false, "md5_digest": "61232cec6f79635e98039e7bd8631023", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32113, "upload_time": "2017-01-10T23:23:21", "upload_time_iso_8601": "2017-01-10T23:23:21.137536Z", "url": "https://files.pythonhosted.org/packages/8c/27/8ad49d33a6a62be9fb9e51533a84f03dedfe3b573431031cfcbadefa5009/tasktiger-0.8.4.tar.gz", "yanked": false}], "0.8.5": [{"comment_text": "", "digests": {"md5": "3edfe03a4385a483bf29cbf2108a6f32", "sha256": "99c5e7b263e95cd860ff82e09923b3dba9962b32db6afd49b4775446d47ed571"}, "downloads": -1, "filename": "tasktiger-0.8.5.tar.gz", "has_sig": false, "md5_digest": "3edfe03a4385a483bf29cbf2108a6f32", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 33169, "upload_time": "2017-04-11T01:25:26", "upload_time_iso_8601": "2017-04-11T01:25:26.368714Z", "url": "https://files.pythonhosted.org/packages/8b/7d/dc2ec1904ddd025f58978a4829bbe79cebd4ffa6a9705cdb6fbb45e3bd4c/tasktiger-0.8.5.tar.gz", "yanked": false}], "0.9": [], "0.9.1": [{"comment_text": "", "digests": {"md5": "e3cdc886c9d527e526800242f883a79f", "sha256": "2da37de77144a2acc8ccb036f5ed575ec5f825770ca296844256db6309eeed3a"}, "downloads": -1, "filename": "tasktiger-0.9.1.tar.gz", "has_sig": false, "md5_digest": "e3cdc886c9d527e526800242f883a79f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 35664, "upload_time": "2017-05-24T22:33:07", "upload_time_iso_8601": "2017-05-24T22:33:07.077270Z", "url": "https://files.pythonhosted.org/packages/df/cb/1cbe369c619de6cff6bc290c90305e997302953b2207162d0e01e3879a71/tasktiger-0.9.1.tar.gz", "yanked": false}], "0.9.2": [{"comment_text": "", "digests": {"md5": "4db69f67272be27cf2f43dbdb54bcf99", "sha256": "e56708b779c8d65eae56618fd2f445bc487c8a8ac8e1a5070a5b257aaa98370c"}, "downloads": -1, "filename": "tasktiger-0.9.2.tar.gz", "has_sig": false, "md5_digest": "4db69f67272be27cf2f43dbdb54bcf99", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 59080, "upload_time": "2017-09-29T20:20:32", "upload_time_iso_8601": "2017-09-29T20:20:32.579336Z", "url": "https://files.pythonhosted.org/packages/8a/36/19c671eabf2c8fea8a862cea559ec9ef0f140ead39437470d6287d8ff368/tasktiger-0.9.2.tar.gz", "yanked": false}], "0.9.3": [{"comment_text": "", "digests": {"md5": "4ee7a4525fc6728da9c688573f54ac86", "sha256": "8ad532ef217cdc2e67035806a05f160ab2e3d59a758ebce34e93817207ba5760"}, "downloads": -1, "filename": "tasktiger-0.9.3.tar.gz", "has_sig": false, "md5_digest": "4ee7a4525fc6728da9c688573f54ac86", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 59734, "upload_time": "2018-01-09T20:09:10", "upload_time_iso_8601": "2018-01-09T20:09:10.949784Z", "url": "https://files.pythonhosted.org/packages/4e/40/01a6bf90d5f105c574178ca0af5376aa611f64a0b1122a67dd4cda9aa32b/tasktiger-0.9.3.tar.gz", "yanked": false}], "0.9.4": [{"comment_text": "", "digests": {"md5": "1c128f24543ff27162ca966409bb46f5", "sha256": "44e18244d5d1607cdd410fd9079e1093e77f9099302f759425154b01d8c5b248"}, "downloads": -1, "filename": "tasktiger-0.9.4.tar.gz", "has_sig": false, "md5_digest": "1c128f24543ff27162ca966409bb46f5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 59967, "upload_time": "2018-07-24T20:16:00", "upload_time_iso_8601": "2018-07-24T20:16:00.100251Z", "url": "https://files.pythonhosted.org/packages/64/ec/c7042e3891cf871445d11955bd3059c7772708d921a5601665b6851053d5/tasktiger-0.9.4.tar.gz", "yanked": false}], "0.9.5": [{"comment_text": "", "digests": {"md5": "e4c1ed88093e6b6f742033b4872f4adf", "sha256": "d0983cf3cf78f4759a245b54ceae97f5de014a9d13b6340bee7e924d1c31d14e"}, "downloads": -1, "filename": "tasktiger-0.9.5-py3-none-any.whl", "has_sig": false, "md5_digest": "e4c1ed88093e6b6f742033b4872f4adf", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 48893, "upload_time": "2019-07-30T11:25:36", "upload_time_iso_8601": "2019-07-30T11:25:36.617743Z", "url": "https://files.pythonhosted.org/packages/3a/37/0d6ea218682a28ce104a9bd8d505a31f092836fb8311db7eab9cbc78047f/tasktiger-0.9.5-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "633394e2fc2c1f032870dc1e6e2cba46", "sha256": "62d06fb79fc9350f28e82b376c07a28dfbbf5c3c941cd9408058117a055cc93c"}, "downloads": -1, "filename": "tasktiger-0.9.5.tar.gz", "has_sig": false, "md5_digest": "633394e2fc2c1f032870dc1e6e2cba46", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 66018, "upload_time": "2019-07-30T11:25:38", "upload_time_iso_8601": "2019-07-30T11:25:38.449518Z", "url": "https://files.pythonhosted.org/packages/ed/fe/e705e018c566994b44ef14a1466e41b66732ae3ba82aa3771b27a0a0103c/tasktiger-0.9.5.tar.gz", "yanked": false}], "0.9.6": [{"comment_text": "", "digests": {"md5": "6bad475194bd1f44a1e6571a49ec92e8", "sha256": "7d6082f0459f2bea5881f31886ecb872e574459494c54cec0a71dfde5ffa0fc9"}, "downloads": -1, "filename": "tasktiger-0.9.6.tar.gz", "has_sig": false, "md5_digest": "6bad475194bd1f44a1e6571a49ec92e8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 66461, "upload_time": "2019-09-12T19:17:19", "upload_time_iso_8601": "2019-09-12T19:17:19.292626Z", "url": "https://files.pythonhosted.org/packages/2c/4d/b280e11ac9cfdfb92acf2348b02eff85498fe444293a7443496f96e1e779/tasktiger-0.9.6.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "94258897cb279f91fb6cf864b5be6059", "sha256": "ed58b0e7981bffbce6fd3a198842dd5a338031721dee24884ee246876da8394b"}, "downloads": -1, "filename": "tasktiger-0.10.1-py3-none-any.whl", "has_sig": false, "md5_digest": "94258897cb279f91fb6cf864b5be6059", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 51715, "upload_time": "2019-10-29T19:32:58", "upload_time_iso_8601": "2019-10-29T19:32:58.510808Z", "url": "https://files.pythonhosted.org/packages/2a/38/3a68437207a23d0ac3e2afe6383d20850ea7f1f8161a20ac7fa671347b55/tasktiger-0.10.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "bf6e6a5ec53669d5774312aaae129e47", "sha256": "7a66f4ce55d49a391bece4fe5ba3a368ee4f0a9019148389c391732139e1ac48"}, "downloads": -1, "filename": "tasktiger-0.10.1.tar.gz", "has_sig": false, "md5_digest": "bf6e6a5ec53669d5774312aaae129e47", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 72038, "upload_time": "2019-10-29T19:33:00", "upload_time_iso_8601": "2019-10-29T19:33:00.932496Z", "url": "https://files.pythonhosted.org/packages/2d/d0/fbbcd8af7986262f7c7e9bcb6a560ae8893eeb90beaddc398b86c64f3de4/tasktiger-0.10.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:57:43 2020"}