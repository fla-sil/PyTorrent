{"info": {"author": "Erik Allik", "author_email": "eallik@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "Usage\n=====\n\nCall the `patternmatching.match()` function with two arguments:\n\n* Argument 1: the pattern to match against\n* Argument 2: the data structure to match\n\n* Optional argument ``flatten: True`` to have the matched values\n  flattened, i.e. returned as a flat tuple regardless of their position\n  in the structure of the matched data.\n\nReturn value:\n\n::\n\n    if flatten is true:\n        match_ok, [matched_value, matched_value, matched_value, ...]\n    if flatten is not true:\n        match_ok, matched_data_structure\n\nCaveat:\nif all matched values in the pattern are ignored, `match()` does not return a `tuple` but a boolean.\n\nYES:\n\n::\n\n    match_ok = match(PATTERN, DATA)\n\nNO:\n\n::\n\n    match_ok, = match(PATTERN, DATA)\n\n\nBuilt-in match objects\n======================\n\n* `ANY`\n* `IS_INSTANCE`\n\nAny match object can be wrapped with ``IGNORE()`` to ignore the value\nmatched by the match object in the returned values.\n\n``IGNORE`` itself can be used as a shortcut for ``IGNORE(ANY)``.\n\n::\n\n    assert True == match(IGNORE, 123)\n\n\nUsage in (unit) tests (but also anywhere else)\n==============================================\n\nComparing the return values of functions is tedious if you can't\nsimply use the `==` operator. For example when a function returns a\ntuple and you only care about some parts of the tuple and not the\nentire tuple:\n\n::\n\n    retval = some_function_under_test()\n    assert retval and isinstance(retval, tuple) \\\n        and len(retval) == 3 and retval[0] == 'foo' \\\n        and isinstance(retval[1], tuple) and len(retval[1]) == 2 \\\n        and isinstance(retval[1][1], SomeException)\n\nWith pattern matching:\n\n::\n\n    retval = some_function_under_test()\n    assert retval == ('foo', (ANY, IS_INSTANCE(SomeException)), ANY)\n\n\nExamples\n========\n\n``MATCH OK``\n------------\n\n::\n\n    match_ok, value = match(ANY, 'foobar')\n    assert match_ok and value == 'foobar'\n\n    match_ok = match(IGNORE(ANY), 'foobar')\n    assert match_ok\n\n    match_ok, value1, value2 match((ANY, ANY), ('foo', 'bar'))\n    assert match_ok and value1 == 'foo' and value2 == 'bar'\n\n    match_ok, (value1, value2) = match((ANY, ANY), ('foo', 'bar'), flatten=False)\n    assert match_ok and value1 == 'foo' and value2 == 'bar'\n\n    match_ok, (value1, ) = match((ANY, IGNORE(ANY)), ('foo', 'whatev'))\n    assert match_ok and value1 == 'foo'\n\n    match_ok, value1, value2 = match(('foo', ANY, ANY), ('foo', 1, 2))\n    assert match_ok and value1 == 1 and value2 == 2\n\n    match_ok, value1, value2, value3 = match(('foo', ANY, (ANY, ANY)), ('foo', 1, (2, 3)))\n    assert match_ok and value1 == 1 and value2 == 2 and value3 = 3\n\n    match_ok, (value1, (value2, value3)) = match(('foo', ANY, (ANY, ANY)), ('foo', 1, (2, 3)), flatten=False)\n    assert match_ok and value1 == 1 and value2 == 2 and value3 = 3\n\n``NO MATCH``\n------------\n\n::\n\n    match_ok = match(3, 4)\n    assert not match_ok\n\n    # notice how you can still successfully do unpacking of return values and just ignore `value` if the match failed\n    match_ok, value = match(IS_INSTANCE(unicode), '123132')\n    assert not match_ok\n\n    # notice how you can still successfully do unpacking of return values and just ignore `value` if the match failed\n    match_ok, (value1, (value2, value3)) = match(('foo', (ANY, (ANY, ANY))), ('not-foo', (1, (2, 3))))\n    assert not match_ok\n\n    # ...even when the structure of the data completely mismatches\n    match_ok, (value1, (value2, value3)) = match(('foo', (ANY, (ANY, ANY))), ('foo', 'blabla'))\n    assert not match_ok\n\n    # ...don't rely on `value1`, `value2` and `value3` being `None` though--the matcher can still return whatever it wants there; you have to check `match_ok` yourself.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/eallik/py-pattern-matching", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "py-pattern-matching", "package_url": "https://pypi.org/project/py-pattern-matching/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/py-pattern-matching/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/eallik/py-pattern-matching"}, "release_url": "https://pypi.org/project/py-pattern-matching/0.1.1/", "requires_dist": null, "requires_python": null, "summary": "Data-structure pattern matching and unpacking for Python", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"usage\">\n<h2>Usage</h2>\n<p>Call the <cite>patternmatching.match()</cite> function with two arguments:</p>\n<ul>\n<li>Argument 1: the pattern to match against</li>\n<li>Argument 2: the data structure to match</li>\n<li>Optional argument <tt>flatten: True</tt> to have the matched values\nflattened, i.e. returned as a flat tuple regardless of their position\nin the structure of the matched data.</li>\n</ul>\n<p>Return value:</p>\n<pre>if flatten is true:\n    match_ok, [matched_value, matched_value, matched_value, ...]\nif flatten is not true:\n    match_ok, matched_data_structure\n</pre>\n<p>Caveat:\nif all matched values in the pattern are ignored, <cite>match()</cite> does not return a <cite>tuple</cite> but a boolean.</p>\n<p>YES:</p>\n<pre>match_ok = match(PATTERN, DATA)\n</pre>\n<p>NO:</p>\n<pre>match_ok, = match(PATTERN, DATA)\n</pre>\n</div>\n<div id=\"built-in-match-objects\">\n<h2>Built-in match objects</h2>\n<ul>\n<li><cite>ANY</cite></li>\n<li><cite>IS_INSTANCE</cite></li>\n</ul>\n<p>Any match object can be wrapped with <tt>IGNORE()</tt> to ignore the value\nmatched by the match object in the returned values.</p>\n<p><tt>IGNORE</tt> itself can be used as a shortcut for <tt>IGNORE(ANY)</tt>.</p>\n<pre>assert True == match(IGNORE, 123)\n</pre>\n</div>\n<div id=\"usage-in-unit-tests-but-also-anywhere-else\">\n<h2>Usage in (unit) tests (but also anywhere else)</h2>\n<p>Comparing the return values of functions is tedious if you can\u2019t\nsimply use the <cite>==</cite> operator. For example when a function returns a\ntuple and you only care about some parts of the tuple and not the\nentire tuple:</p>\n<pre>retval = some_function_under_test()\nassert retval and isinstance(retval, tuple) \\\n    and len(retval) == 3 and retval[0] == 'foo' \\\n    and isinstance(retval[1], tuple) and len(retval[1]) == 2 \\\n    and isinstance(retval[1][1], SomeException)\n</pre>\n<p>With pattern matching:</p>\n<pre>retval = some_function_under_test()\nassert retval == ('foo', (ANY, IS_INSTANCE(SomeException)), ANY)\n</pre>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<div id=\"match-ok\">\n<h3><tt>MATCH OK</tt></h3>\n<pre>match_ok, value = match(ANY, 'foobar')\nassert match_ok and value == 'foobar'\n\nmatch_ok = match(IGNORE(ANY), 'foobar')\nassert match_ok\n\nmatch_ok, value1, value2 match((ANY, ANY), ('foo', 'bar'))\nassert match_ok and value1 == 'foo' and value2 == 'bar'\n\nmatch_ok, (value1, value2) = match((ANY, ANY), ('foo', 'bar'), flatten=False)\nassert match_ok and value1 == 'foo' and value2 == 'bar'\n\nmatch_ok, (value1, ) = match((ANY, IGNORE(ANY)), ('foo', 'whatev'))\nassert match_ok and value1 == 'foo'\n\nmatch_ok, value1, value2 = match(('foo', ANY, ANY), ('foo', 1, 2))\nassert match_ok and value1 == 1 and value2 == 2\n\nmatch_ok, value1, value2, value3 = match(('foo', ANY, (ANY, ANY)), ('foo', 1, (2, 3)))\nassert match_ok and value1 == 1 and value2 == 2 and value3 = 3\n\nmatch_ok, (value1, (value2, value3)) = match(('foo', ANY, (ANY, ANY)), ('foo', 1, (2, 3)), flatten=False)\nassert match_ok and value1 == 1 and value2 == 2 and value3 = 3\n</pre>\n</div>\n<div id=\"no-match\">\n<h3><tt>NO MATCH</tt></h3>\n<pre>match_ok = match(3, 4)\nassert not match_ok\n\n# notice how you can still successfully do unpacking of return values and just ignore `value` if the match failed\nmatch_ok, value = match(IS_INSTANCE(unicode), '123132')\nassert not match_ok\n\n# notice how you can still successfully do unpacking of return values and just ignore `value` if the match failed\nmatch_ok, (value1, (value2, value3)) = match(('foo', (ANY, (ANY, ANY))), ('not-foo', (1, (2, 3))))\nassert not match_ok\n\n# ...even when the structure of the data completely mismatches\nmatch_ok, (value1, (value2, value3)) = match(('foo', (ANY, (ANY, ANY))), ('foo', 'blabla'))\nassert not match_ok\n\n# ...don't rely on `value1`, `value2` and `value3` being `None` though--the matcher can still return whatever it wants there; you have to check `match_ok` yourself.\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 796849, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "d87c82689029bccdcdc3f5196fa533b6", "sha256": "2577d5c0834700b2a2c15e94d3fdb24100b07d7b1a1f3ea6cda9578c185cd012"}, "downloads": -1, "filename": "py-pattern-matching-0.1.tar.gz", "has_sig": false, "md5_digest": "d87c82689029bccdcdc3f5196fa533b6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3867, "upload_time": "2012-07-19T16:47:42", "upload_time_iso_8601": "2012-07-19T16:47:42.659875Z", "url": "https://files.pythonhosted.org/packages/26/9c/534ac2094dd353b96e1dc397feb9ede716495592a86a89f385b76e426e67/py-pattern-matching-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "1b3d46b29af8c7eb39eb0f37870bebea", "sha256": "54602b19e551b7506bb07f4acc384a4e8a1ee3b0f0b3873b15501d7f09733063"}, "downloads": -1, "filename": "py-pattern-matching-0.1.1.tar.gz", "has_sig": false, "md5_digest": "1b3d46b29af8c7eb39eb0f37870bebea", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3900, "upload_time": "2012-07-20T02:15:45", "upload_time_iso_8601": "2012-07-20T02:15:45.977954Z", "url": "https://files.pythonhosted.org/packages/3c/05/f37371d25230d55b93c785c4c4eba4f5d857292cd88277b9444b801e4f9d/py-pattern-matching-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "1b3d46b29af8c7eb39eb0f37870bebea", "sha256": "54602b19e551b7506bb07f4acc384a4e8a1ee3b0f0b3873b15501d7f09733063"}, "downloads": -1, "filename": "py-pattern-matching-0.1.1.tar.gz", "has_sig": false, "md5_digest": "1b3d46b29af8c7eb39eb0f37870bebea", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3900, "upload_time": "2012-07-20T02:15:45", "upload_time_iso_8601": "2012-07-20T02:15:45.977954Z", "url": "https://files.pythonhosted.org/packages/3c/05/f37371d25230d55b93c785c4c4eba4f5d857292cd88277b9444b801e4f9d/py-pattern-matching-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:59:51 2020"}