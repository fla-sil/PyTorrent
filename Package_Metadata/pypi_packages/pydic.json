{"info": {"author": "Felix Carmona", "author_email": "mail@felixcarmona.com", "bugtrack_url": null, "classifiers": [], "description": "Python Dependency Injection Container\n=====================================\n\n.. image:: https://travis-ci.org/felixcarmona/pydic.png?branch=master\n    :target: https://travis-ci.org/felixcarmona/pydic\n\n.. image:: https://coveralls.io/repos/felixcarmona/pydic/badge.png?branch=master\n    :target: https://coveralls.io/r/felixcarmona/pydic?branch=master\n\n.. image:: https://pypip.in/d/pydic/badge.png\n    :target: https://pypi.python.org/pypi/pydic/\n    :alt: Downloads\n\n.. image:: https://pypip.in/v/pydic/badge.png\n    :target: https://pypi.python.org/pypi/pydic/\n    :alt: Latest Version\n\nParameters\n----------\nThe ``pydic.Parameters`` class is a simple container for key/value pairs.\n\nThe available methods are:\n\n- ``set(key, value)``: Sets a parameter.\n- ``get(key, default=None)``: Returns a parameter by name. If the key don't exists, the default parameter will be returned.\n- ``has(key)``: Returns *True* if the parameter exists, *False* otherwise.\n- ``remove(key)``: Removes a parameter.\n- ``add(parameters)``: Adds a dict of parameters\n- ``all()``: Returns all set parameters.\n- ``count()``: Returns the number of all set parameters.\n- ``keys()``: Returns the all set parameter keys.\n- ``parse_text(text)``: Resolves a string which can contain parameters (example: 'Hello {{ name }} {{ surname }}!')\n\n\n.. note::\n\n    You can reference others parameters wrapping it between ``{{`` ``}}`` characters.\n\n    For example: ``'foo': '{{ bar }}', 'bar': 'aaa'``, if you get the ``foo`` parameter, the return value should be ``aaa`` because ``foo -> {{ bar }} -> bar -> aaa``\n\n    You can escape brackets processing with \"``\\``\".\n\n    For example, if you set a parameter with the following value ``Hello \\{\\{ name \\}\\}``, if you get it, the return will be ``Hello {{ name }}!``\n\n\nServices\n--------\n\nWhat is a Service Container\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\nA Service Container (or *dependency injection container*) is simply a python object that manages the instantiation of services (objects).\nFor example, suppose you have a simple python class that delivers email messages. Without a service container, you must manually create the object whenever you need it:\n\n.. code-block:: python\n\n    from myapplication.mailer import Mailer\n\n    mailer = Mailer('sendmail')\n    mailer.send('felix@example.com', ...)\n\nThis is easy enough. The imaginary *Mailer* class allows you to configure the method used to deliver the\nemail messages (e.g. *sendmail*, *smtp*, etc).\n\nBut what if you wanted to use the mailer service somewhere else? You certainly don't want to repeat the mailer\nconfiguration every time you need to use the Mailer object. What if you needed to change the *transport* from *sendmail*\nto *smtp* everywhere in the application? You'd need to hunt down every place you create a *Mailer* service and change it.\n\nThe Services container allows you to standardize and centralize the way objects are constructed in your application.\n\nCreating/Configuring Services in the Container\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nA better answer is to let the service container create the *Mailer* object for you.\nIn order for this to work, you must teach the container how to create the *Mailer* service.\nThis is done via configuration definitions:\n\n.. code-block:: python\n\n    ...\n    from pydic import Services\n\n    definitions = {\n        'my_mailer': {\n            'class':        'myapplication.mailer.Mailer',\n            'arguments':    ['sendmail']\n        }\n    }\n\n    services = Services(definitions)\n    ...\n\n\nWhen you ask for the *my_mailer* service from the container ``services.get('my_mailer')``, the container constructs the object and returns it.\n\nThis is another major advantage of using the service container. Namely, a service is never constructed until it's needed.\nIf you define a service and never use it, the service is never created. This saves memory and increases\nthe speed of your application. This also means that there's very little or no performance hit for defining lots\nof services. **Services that are never used are never constructed.**\n\nAs an added bonus, the *Mailer* service is only created once and the same instance is returned each time you ask for\nthe service. This is almost always the behavior you'll need (it's more flexible and powerful).\n\nYou can pass the arguments as list or dict.\n\nAlso you can call functions after object instantiation with:\n\n.. code-block:: python\n\n    ...\n    definitions = {\n        'my_mailer': {\n            'class':        'myapplication.mailer.Mailer',\n            'arguments':    ['sendmail'],\n            'calls': [\n                [ 'set_name', 'Felix Carmona'],\n                [ 'inject_something',  [1, 2, 3]],\n                [ 'inject_something',  [2, 3]],\n                [ 'set_location',  {'city': 'Barcelona', 'country': 'Spain'}]\n            ]\n        }\n    }\n    ...\n\n\nOnce the container has been constructed with the definitions, the available methods for the service container object are:\n\n- ``set(key, value)``: Sets a service object by name.\n- ``get(key)``: Returns a service object by name.\n- ``has(key)``: Returns *True* if the service definition exists or if the service object is instantiated, *False* otherwise.\n- ``remove(key)``: Removes a service object and service definition by name.\n- ``add(parameters)``: Adds a dict of services objects.\n- ``keys()``: Returns the services keys.\n\n\nUsing the Parameters to build Services\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nThe creation of new services (objects) via the container is pretty straightforward. Parameters make defining services\nmore organized and flexible:\n\n.. code-block:: python\n\n    ...\n    parameters = Parameters(\n        {\n            'my_mailer_class':     'myapplication.mailer.Mailer',\n            'my_mailer_transport': 'sendmail'\n        }\n    )\n\n    definitions = {\n        'my_mailer': {\n            'class':        '{{ my_mailer_class }}',\n            'arguments':    ['{{ my_mailer_transport }}']\n        }\n    }\n\n    services = Services(definitions, parameters)\n    ...\n\n\nThe end result is exactly the same as before - the difference is only in how you defined the service.\nBy surrounding the *my_mailer.class* and *my_mailer.transport* strings in double bracket keys (``{{`` ``}}``) signs, the services container knows to look\nfor parameters with those names. Parameters can deep reference other parameters that references other parameters, and will\nbe resolved anyway.\n\nThe purpose of parameters is to feed information into services. Of course there was nothing wrong with defining the\nservice without using any parameters. Parameters, however, have several advantages:\n\n    - separation and organization of all service \"options\" under a single parameters key\n    - parameter values can be used in multiple service definitions\n\nThe choice of using or not using parameters is up to you.\n\n\nReferencing (Injecting) Services\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nYou can of course also reference services\n\nStart the string with @ to reference a service, example:\n\n.. code-block:: python\n\n    ...\n    parameters = Parameters(\n        {\n            'my_mailer_class':     'myapplication.mailer.Mailer',\n            'my_mailer_transport': 'sendmail'\n        }\n    )\n\n    definitions = {\n        'my_mailer': {\n            'class':        '{{ my_mailer_class }}',\n            'arguments':    ['{{ my_mailer_transport }}']\n        },\n        'my_mailer_manager': {}\n            'class': 'myapplication.mailer.MailerManager',\n            'arguments': ['@my_mailer']\n        }\n    }\n\n    services = Services(definitions, parameters)\n    ...\n\n\nthe *my_mailer* service will be injected in the *my_mailer_manager*\n\n.. note::\n\n    Use ``@@`` to escape the ``@`` symbol. ``@@my_mailer`` will be converted into the string \"``@my_mailer``\" instead of referencing the\n    *my_mailer* service.\n\n------------------\n\n*pydic is open-sourced software licensed under the MIT license*", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/felixcarmona/pydic", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "pydic", "package_url": "https://pypi.org/project/pydic/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/pydic/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/felixcarmona/pydic"}, "release_url": "https://pypi.org/project/pydic/1.0.0/", "requires_dist": null, "requires_python": null, "summary": "Manage your services via a robust and flexible Dependency Injection Container", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/felixcarmona/pydic\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/felixcarmona/pydic.png?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/b51b7c0373a789b190d67047082d7453a4c7d99d/68747470733a2f2f7472617669732d63692e6f72672f66656c69786361726d6f6e612f70796469632e706e673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/r/felixcarmona/pydic?branch=master\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/felixcarmona/pydic/badge.png?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2f27cd97b7aea163188ce031aa883cf95d760488/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f66656c69786361726d6f6e612f70796469632f62616467652e706e673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://pypi.python.org/pypi/pydic/\" rel=\"nofollow\"><img alt=\"Downloads\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f2f35c20e686452eda1e53c6601f4e70e83f7217/68747470733a2f2f70797069702e696e2f642f70796469632f62616467652e706e67\"></a>\n<a href=\"https://pypi.python.org/pypi/pydic/\" rel=\"nofollow\"><img alt=\"Latest Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4b3ebd0c204031cd890b026fab6946ac74d01d8e/68747470733a2f2f70797069702e696e2f762f70796469632f62616467652e706e67\"></a>\n<div id=\"parameters\">\n<h2>Parameters</h2>\n<p>The <tt>pydic.Parameters</tt> class is a simple container for key/value pairs.</p>\n<p>The available methods are:</p>\n<ul>\n<li><tt>set(key, value)</tt>: Sets a parameter.</li>\n<li><tt>get(key, default=None)</tt>: Returns a parameter by name. If the key don\u2019t exists, the default parameter will be returned.</li>\n<li><tt>has(key)</tt>: Returns <em>True</em> if the parameter exists, <em>False</em> otherwise.</li>\n<li><tt>remove(key)</tt>: Removes a parameter.</li>\n<li><tt>add(parameters)</tt>: Adds a dict of parameters</li>\n<li><tt>all()</tt>: Returns all set parameters.</li>\n<li><tt>count()</tt>: Returns the number of all set parameters.</li>\n<li><tt>keys()</tt>: Returns the all set parameter keys.</li>\n<li><tt>parse_text(text)</tt>: Resolves a string which can contain parameters (example: \u2018Hello {{ name }} {{ surname }}!\u2019)</li>\n</ul>\n<div>\n<p>Note</p>\n<p>You can reference others parameters wrapping it between <tt>{{</tt> <tt>}}</tt> characters.</p>\n<p>For example: <tt>'foo': '{{ bar <span class=\"pre\">}}',</span> 'bar': 'aaa'</tt>, if you get the <tt>foo</tt> parameter, the return value should be <tt>aaa</tt> because <tt>foo <span class=\"pre\">-&gt;</span> {{ bar }} <span class=\"pre\">-&gt;</span> bar <span class=\"pre\">-&gt;</span> aaa</tt></p>\n<p>You can escape brackets processing with \u201c<tt>\\</tt>\u201d.</p>\n<p>For example, if you set a parameter with the following value <tt>Hello <span class=\"pre\">\\{\\{</span> name <span class=\"pre\">\\}\\}</span></tt>, if you get it, the return will be <tt>Hello {{ name }}!</tt></p>\n</div>\n</div>\n<div id=\"services\">\n<h2>Services</h2>\n<div id=\"what-is-a-service-container\">\n<h3>What is a Service Container</h3>\n<p>A Service Container (or <em>dependency injection container</em>) is simply a python object that manages the instantiation of services (objects).\nFor example, suppose you have a simple python class that delivers email messages. Without a service container, you must manually create the object whenever you need it:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">myapplication.mailer</span> <span class=\"kn\">import</span> <span class=\"n\">Mailer</span>\n\n<span class=\"n\">mailer</span> <span class=\"o\">=</span> <span class=\"n\">Mailer</span><span class=\"p\">(</span><span class=\"s1\">'sendmail'</span><span class=\"p\">)</span>\n<span class=\"n\">mailer</span><span class=\"o\">.</span><span class=\"n\">send</span><span class=\"p\">(</span><span class=\"s1\">'felix@example.com'</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n<p>This is easy enough. The imaginary <em>Mailer</em> class allows you to configure the method used to deliver the\nemail messages (e.g. <em>sendmail</em>, <em>smtp</em>, etc).</p>\n<p>But what if you wanted to use the mailer service somewhere else? You certainly don\u2019t want to repeat the mailer\nconfiguration every time you need to use the Mailer object. What if you needed to change the <em>transport</em> from <em>sendmail</em>\nto <em>smtp</em> everywhere in the application? You\u2019d need to hunt down every place you create a <em>Mailer</em> service and change it.</p>\n<p>The Services container allows you to standardize and centralize the way objects are constructed in your application.</p>\n</div>\n<div id=\"creating-configuring-services-in-the-container\">\n<h3>Creating/Configuring Services in the Container</h3>\n<p>A better answer is to let the service container create the <em>Mailer</em> object for you.\nIn order for this to work, you must teach the container how to create the <em>Mailer</em> service.\nThis is done via configuration definitions:</p>\n<pre><span class=\"o\">...</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pydic</span> <span class=\"kn\">import</span> <span class=\"n\">Services</span>\n\n<span class=\"n\">definitions</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'my_mailer'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'class'</span><span class=\"p\">:</span>        <span class=\"s1\">'myapplication.mailer.Mailer'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'arguments'</span><span class=\"p\">:</span>    <span class=\"p\">[</span><span class=\"s1\">'sendmail'</span><span class=\"p\">]</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">services</span> <span class=\"o\">=</span> <span class=\"n\">Services</span><span class=\"p\">(</span><span class=\"n\">definitions</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n</pre>\n<p>When you ask for the <em>my_mailer</em> service from the container <tt><span class=\"pre\">services.get('my_mailer')</span></tt>, the container constructs the object and returns it.</p>\n<p>This is another major advantage of using the service container. Namely, a service is never constructed until it\u2019s needed.\nIf you define a service and never use it, the service is never created. This saves memory and increases\nthe speed of your application. This also means that there\u2019s very little or no performance hit for defining lots\nof services. <strong>Services that are never used are never constructed.</strong></p>\n<p>As an added bonus, the <em>Mailer</em> service is only created once and the same instance is returned each time you ask for\nthe service. This is almost always the behavior you\u2019ll need (it\u2019s more flexible and powerful).</p>\n<p>You can pass the arguments as list or dict.</p>\n<p>Also you can call functions after object instantiation with:</p>\n<pre><span class=\"o\">...</span>\n<span class=\"n\">definitions</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'my_mailer'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'class'</span><span class=\"p\">:</span>        <span class=\"s1\">'myapplication.mailer.Mailer'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'arguments'</span><span class=\"p\">:</span>    <span class=\"p\">[</span><span class=\"s1\">'sendmail'</span><span class=\"p\">],</span>\n        <span class=\"s1\">'calls'</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n            <span class=\"p\">[</span> <span class=\"s1\">'set_name'</span><span class=\"p\">,</span> <span class=\"s1\">'Felix Carmona'</span><span class=\"p\">],</span>\n            <span class=\"p\">[</span> <span class=\"s1\">'inject_something'</span><span class=\"p\">,</span>  <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">]],</span>\n            <span class=\"p\">[</span> <span class=\"s1\">'inject_something'</span><span class=\"p\">,</span>  <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">]],</span>\n            <span class=\"p\">[</span> <span class=\"s1\">'set_location'</span><span class=\"p\">,</span>  <span class=\"p\">{</span><span class=\"s1\">'city'</span><span class=\"p\">:</span> <span class=\"s1\">'Barcelona'</span><span class=\"p\">,</span> <span class=\"s1\">'country'</span><span class=\"p\">:</span> <span class=\"s1\">'Spain'</span><span class=\"p\">}]</span>\n        <span class=\"p\">]</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"o\">...</span>\n</pre>\n<p>Once the container has been constructed with the definitions, the available methods for the service container object are:</p>\n<ul>\n<li><tt>set(key, value)</tt>: Sets a service object by name.</li>\n<li><tt>get(key)</tt>: Returns a service object by name.</li>\n<li><tt>has(key)</tt>: Returns <em>True</em> if the service definition exists or if the service object is instantiated, <em>False</em> otherwise.</li>\n<li><tt>remove(key)</tt>: Removes a service object and service definition by name.</li>\n<li><tt>add(parameters)</tt>: Adds a dict of services objects.</li>\n<li><tt>keys()</tt>: Returns the services keys.</li>\n</ul>\n</div>\n<div id=\"using-the-parameters-to-build-services\">\n<h3>Using the Parameters to build Services</h3>\n<p>The creation of new services (objects) via the container is pretty straightforward. Parameters make defining services\nmore organized and flexible:</p>\n<pre><span class=\"o\">...</span>\n<span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"n\">Parameters</span><span class=\"p\">(</span>\n    <span class=\"p\">{</span>\n        <span class=\"s1\">'my_mailer_class'</span><span class=\"p\">:</span>     <span class=\"s1\">'myapplication.mailer.Mailer'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'my_mailer_transport'</span><span class=\"p\">:</span> <span class=\"s1\">'sendmail'</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">definitions</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'my_mailer'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'class'</span><span class=\"p\">:</span>        <span class=\"s1\">'{{ my_mailer_class }}'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'arguments'</span><span class=\"p\">:</span>    <span class=\"p\">[</span><span class=\"s1\">'{{ my_mailer_transport }}'</span><span class=\"p\">]</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">services</span> <span class=\"o\">=</span> <span class=\"n\">Services</span><span class=\"p\">(</span><span class=\"n\">definitions</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n</pre>\n<p>The end result is exactly the same as before - the difference is only in how you defined the service.\nBy surrounding the <em>my_mailer.class</em> and <em>my_mailer.transport</em> strings in double bracket keys (<tt>{{</tt> <tt>}}</tt>) signs, the services container knows to look\nfor parameters with those names. Parameters can deep reference other parameters that references other parameters, and will\nbe resolved anyway.</p>\n<p>The purpose of parameters is to feed information into services. Of course there was nothing wrong with defining the\nservice without using any parameters. Parameters, however, have several advantages:</p>\n<blockquote>\n<ul>\n<li>separation and organization of all service \u201coptions\u201d under a single parameters key</li>\n<li>parameter values can be used in multiple service definitions</li>\n</ul>\n</blockquote>\n<p>The choice of using or not using parameters is up to you.</p>\n</div>\n<div id=\"referencing-injecting-services\">\n<h3>Referencing (Injecting) Services</h3>\n<p>You can of course also reference services</p>\n<p>Start the string with @ to reference a service, example:</p>\n<pre><span class=\"o\">...</span>\n<span class=\"n\">parameters</span> <span class=\"o\">=</span> <span class=\"n\">Parameters</span><span class=\"p\">(</span>\n    <span class=\"p\">{</span>\n        <span class=\"s1\">'my_mailer_class'</span><span class=\"p\">:</span>     <span class=\"s1\">'myapplication.mailer.Mailer'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'my_mailer_transport'</span><span class=\"p\">:</span> <span class=\"s1\">'sendmail'</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">definitions</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'my_mailer'</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n        <span class=\"s1\">'class'</span><span class=\"p\">:</span>        <span class=\"s1\">'{{ my_mailer_class }}'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'arguments'</span><span class=\"p\">:</span>    <span class=\"p\">[</span><span class=\"s1\">'{{ my_mailer_transport }}'</span><span class=\"p\">]</span>\n    <span class=\"p\">},</span>\n    <span class=\"s1\">'my_mailer_manager'</span><span class=\"p\">:</span> <span class=\"p\">{}</span>\n        <span class=\"s1\">'class'</span><span class=\"p\">:</span> <span class=\"s1\">'myapplication.mailer.MailerManager'</span><span class=\"p\">,</span>\n        <span class=\"s1\">'arguments'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'@my_mailer'</span><span class=\"p\">]</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">services</span> <span class=\"o\">=</span> <span class=\"n\">Services</span><span class=\"p\">(</span><span class=\"n\">definitions</span><span class=\"p\">,</span> <span class=\"n\">parameters</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n</pre>\n<p>the <em>my_mailer</em> service will be injected in the <em>my_mailer_manager</em></p>\n<div>\n<p>Note</p>\n<p>Use <tt>@@</tt> to escape the <tt>@</tt> symbol. <tt>@@my_mailer</tt> will be converted into the string \u201c<tt>@my_mailer</tt>\u201d instead of referencing the\n<em>my_mailer</em> service.</p>\n</div>\n<hr class=\"docutils\">\n<p><em>pydic is open-sourced software licensed under the MIT license</em></p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1275252, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "e790d10448ed6e6a8729a1ca79e650d2", "sha256": "2f9e8e2dd59cd9e80f0fd06df77c54f315209568b848f592d3ca6552e837ef55"}, "downloads": -1, "filename": "pydic-1.0.0.tar.gz", "has_sig": false, "md5_digest": "e790d10448ed6e6a8729a1ca79e650d2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5833, "upload_time": "2014-10-18T21:41:32", "upload_time_iso_8601": "2014-10-18T21:41:32.210380Z", "url": "https://files.pythonhosted.org/packages/4e/96/287792fc63d5cd631e85572aa5511a2fbde7319d1808f91790f36552270e/pydic-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e790d10448ed6e6a8729a1ca79e650d2", "sha256": "2f9e8e2dd59cd9e80f0fd06df77c54f315209568b848f592d3ca6552e837ef55"}, "downloads": -1, "filename": "pydic-1.0.0.tar.gz", "has_sig": false, "md5_digest": "e790d10448ed6e6a8729a1ca79e650d2", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 5833, "upload_time": "2014-10-18T21:41:32", "upload_time_iso_8601": "2014-10-18T21:41:32.210380Z", "url": "https://files.pythonhosted.org/packages/4e/96/287792fc63d5cd631e85572aa5511a2fbde7319d1808f91790f36552270e/pydic-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:07:02 2020"}