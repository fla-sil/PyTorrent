{"info": {"author": "LML", "author_email": "None", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Science/Research", "License :: OSI Approved :: GNU General Public License v2 or later (GPLv2+)", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 2.7", "Topic :: Software Development :: Build Tools"], "description": "=======================\nCommand and Real-time Acquisition in Parallelized PYthon (CRAPPY)\n=======================\n\n.. contents::\n\n\nWhat is CRAPPY?\n---------------\n\nCRAPPY is an open-source software developped to provide easy-to-use tools \nfor command and acquisition on complex experimental setups.\nAs every experimenter knows, designing complex setups and measuring physical\nphenomenons with precision can be tricky. As we increase the number of sensors\nto better understand what is really happening during a test, we need to have\nsimple tools to synchronise and quickly adapt a test sequence to new hardware.\n\n\nHow does it work?\n-----------------\n\nCRAPPY is a dataflow programming framework, allowing to write a new sequence \neasily by describing a sketch of your setup. Some classical part are already\nimplemented, as a signal generator, real-time graphs, and save functions.\nCRAPPY provide a framework to add custom methods and ensure its compatibilty \nwith the other parts.\n\n* CRAPPY keywords are :\n\n  - interchangeable : allowing the user to switch between several hardware \n    without re-writing all the sequence.\n\n  - independance : dissociate the different parts of the setup, especially the\n    acquisition and the control.\n\n  - synchronous : provide a common time-reference for all.\n\n  - simultaneous : each part of the software is parallelized.\n\n\nStructure\n---------\n\nCRAPPY is composed of 2 main parts : \n\n* A library part, containing:\n\n  - Sensors : each sensors methods are available here.\n\n  - Actuators : each actuators methods are available here.\n\n  - Technicals : some hardware are both a sensor AND an actuator. Methods \n    common to both are available here\n\n* A directly usable part, containing:\n\n  - Blocks : blocks are independant parts. Each one of them run in a different\n    process, and they use the methods available in the library part. They \n    communicate with each other through Links.\n\n  - Links : links are connections between Blocks, as you graphically could \n    represent them as a line between 2 blocks. They send data from one to \n    another, and can be customized with condition to modify the data or control \n    when to send it. You can for instance apply a filter to your data.\n    \nTo write a test sequence : \n\n- Declare the needed sensors, actuators and technicals with the arguments you\n  need.\n    \n- Declare the needed blocks, using as argument the previous sensors, \n  actuators and technicals.\n  \n- Declare the needed links with the associated conditions.\n  \n- Link blocks to other blocks, by attributing them inputs and outputs of \n  links.\n    \n- Start all the blocks (see the Examples for correct synthax).\n  \n\n\nExamples\n--------\n\nExamples of working sequences can be found in the Examples directory. Most of \nthem require specific hardware to work, so they may not all work.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/LaboratoireMecaniqueLille", "keywords": "control command acquisition multiprocessing", "license": "GPL V2", "maintainer": null, "maintainer_email": null, "name": "crappyLML", "package_url": "https://pypi.org/project/crappyLML/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/crappyLML/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/LaboratoireMecaniqueLille"}, "release_url": "https://pypi.org/project/crappyLML/1.2.1/", "requires_dist": null, "requires_python": null, "summary": "Command and Real-time Acquisition Parallelized in Python", "version": "1.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            =======================<br>Command and Real-time Acquisition in Parallelized PYthon (CRAPPY)<br>=======================<br><br>.. contents::<br><br><br>What is CRAPPY?<br>---------------<br><br>CRAPPY is an open-source software developped to provide easy-to-use tools <br>for command and acquisition on complex experimental setups.<br>As every experimenter knows, designing complex setups and measuring physical<br>phenomenons with precision can be tricky. As we increase the number of sensors<br>to better understand what is really happening during a test, we need to have<br>simple tools to synchronise and quickly adapt a test sequence to new hardware.<br><br><br>How does it work?<br>-----------------<br><br>CRAPPY is a dataflow programming framework, allowing to write a new sequence <br>easily by describing a sketch of your setup. Some classical part are already<br>implemented, as a signal generator, real-time graphs, and save functions.<br>CRAPPY provide a framework to add custom methods and ensure its compatibilty <br>with the other parts.<br><br>* CRAPPY keywords are :<br><br>  - interchangeable : allowing the user to switch between several hardware <br>    without re-writing all the sequence.<br><br>  - independance : dissociate the different parts of the setup, especially the<br>    acquisition and the control.<br><br>  - synchronous : provide a common time-reference for all.<br><br>  - simultaneous : each part of the software is parallelized.<br><br><br>Structure<br>---------<br><br>CRAPPY is composed of 2 main parts : <br><br>* A library part, containing:<br><br>  - Sensors : each sensors methods are available here.<br><br>  - Actuators : each actuators methods are available here.<br><br>  - Technicals : some hardware are both a sensor AND an actuator. Methods <br>    common to both are available here<br><br>* A directly usable part, containing:<br><br>  - Blocks : blocks are independant parts. Each one of them run in a different<br>    process, and they use the methods available in the library part. They <br>    communicate with each other through Links.<br><br>  - Links : links are connections between Blocks, as you graphically could <br>    represent them as a line between 2 blocks. They send data from one to <br>    another, and can be customized with condition to modify the data or control <br>    when to send it. You can for instance apply a filter to your data.<br>    <br>To write a test sequence : <br><br>- Declare the needed sensors, actuators and technicals with the arguments you<br>  need.<br>    <br>- Declare the needed blocks, using as argument the previous sensors, <br>  actuators and technicals.<br>  <br>- Declare the needed links with the associated conditions.<br>  <br>- Link blocks to other blocks, by attributing them inputs and outputs of <br>  links.<br>    <br>- Start all the blocks (see the Examples for correct synthax).<br>  <br><br><br>Examples<br>--------<br><br>Examples of working sequences can be found in the Examples directory. Most of <br>them require specific hardware to work, so they may not all work.\n          </div>"}, "last_serial": 2719657, "releases": {"1.2.1": []}, "urls": [], "timestamp": "Fri May  8 00:42:28 2020"}