{"info": {"author": "Nicolas Rahmouni", "author_email": "nicolas.rahmouni@polytechnique.edu", "bugtrack_url": null, "classifiers": [], "description": "Computer Graphics vs Real Photographic Images : A Deep-learning approach\n========================================================================\n\n.. image:: https://badge.fury.io/py/CGvsPhoto.svg\n    :target: https://badge.fury.io/py/CGvsPhoto\n    \n**CGvsPhoto** implements a method for computer graphics detection using\nConvolutional Neural Networks with TensorFlow back-end. The package\ncontains methods for extracting patches from computer graphics and real\nimages, training a CNN with a custom statistical layer, testing this\nmodel, comparing with a `state of the art method`_, visualizing\nprobability maps, etc.\n\n.. figure:: https://user-images.githubusercontent.com/17125992/26917538-9d918318-4c69-11e7-8c6f-f865b3c5f063.png\n   :alt: splicing\n\n\nGetting Started\n---------------\n\nThese instructions will get you a copy of the project up and running on\nyour local machine for testing purposes.\n\nPrerequisites\n~~~~~~~~~~~~~\n\n-  Python 3.6+\n-  Numpy 1.6.1+\n-  Scikit-learn 0.18.1+\n-  TensorFlow 1.0.1+ (https://github.com/tensorflow/tensorflow)\n-  Pillow 3.1.2+\n-  Matplotlib 1.3.1+\n\nInstalling\n~~~~~~~~~~\n\nSimply install this package with pip3 : \n::\n\n    $ pip3 install CGvsPhoto\n\nYou can also clone the repository into your favorite directory.\n\n::\n\n    $ git clone https://github.com/NicoRahm/CGvsPhoto\n\nThen, install the package using :\n\n::\n\n    $ cd CGvsPhoto/\n    $ pip3 install .\n\nTo run your first test, there is one more thing to set up:\n\n- Create a file named config.ini in your execution directory (the directory containing your scripts) to store the different configurations of your environment. The format is the following :\n\n::\n\n    [Name of the configuration]\n    dir_ckpt = /path/to/save/trained/weights/\n    dir_summaries = /path/to/save/summaries\n    dir_visualization = /path/to/save visualizations\n\nAn example file is given in the examples directory.\n\nDatabase format\n~~~~~~~~~~~~~~~\n\nYour database must follow this organization :\n\n::\n\n    Database/\n        test/\n            CGG/\n            Real/\n        train/\n            CGG/\n            Real/\n        validation/ \n            CGG/\n            Real/\n\nYou can create it manually or use the function construct\\_DB.\n\nSome simple examples\n~~~~~~~~~~~~~~~~~~~~\n\nTo get started, you can run simple scripts from the examples directory.\nDo not forget to **set up the config.ini file** correctly as described\nabove and to modify the paths to data.\n\n-  `create\\_DB.py`_ will create a formated database for future tests.\n-  `create\\_patches\\_splicing.py`_ will create a patches database for\n   training single-image classifier and a splicing database to test our\n   models.\n-  `test\\_pipeline.py`_ trains a neural network to classify image\n   patches and then evaluate it.\n-  `test\\_splicing.py`_ tests a model on spliced images.\n\nHow to use\n----------\n\nThis section explains basic uses of this code. We describe a step by\nstep procedure to evaluate our model on your database.\n\nFormatting the database\n~~~~~~~~~~~~~~~~~~~~~~~\n\nAs our code uses a special format for the database, the first thing you\nneed to do is to create a suited structure for the data. You can do this\nmanually but we give a piece of code to do it automatically which may\nprevent bad surprises\u2026 It creates validation, training and testing\ndirectories and put a certain number of images per class in it (same\nnumber of image for each class) To do so, you just need to have CG and\nPG images in two different directories and choose another directory to\nstore the formatted database. Then you can just use the *construct\\_DB*\nmethod :\n\n.. code:: python\n\n    from CGvsPhoto import construct_DB\n\n    path_CG = '/path/to/CG'\n    path_PG = '/path/to/PG'\n    path_export = 'path/to/export/database'\n\n    construct_DB(source_real = path_PG, source_CG = path_CG,\n                 target_dir = path_export, nb_per_class = 1000,\n                 validation_proportion = 0.1, test_proportion = 0.2)\n\nYou can choose the total number of images per class and the proportion\nof images to put in each directory.\n\nCreating the patches database\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOur implementation computes local patch classification before\naggregating the results for full-size images. So, to train the\nsingle-image classifier, a patch database must be created. To this end,\nuse the *Database\\_loader* class :\n\n.. code:: python\n\n    from CGvsPhoto import Database_loader\n\n    path_source = 'path/to/source/database'\n    path_export = 'path/to/export/patches'\n    size_patch = 100\n\n    data = Database_loader(path_source, image_size = size_patch, \n                         only_green=True)\n\n    # export a patch database    \n    data.export_database(path_export, \n                         nb_train = 40000, \n                         nb_test = 4000, \n                         nb_validation = 2000)\n\nYou can choose the patch size (100x100 pixels in our initial\nimplementation) and the number of patches to put in each directory (with\n50/50 distribution between each class).\n\nNote that supported image extensions are\n[\u201c.jpg\u201d,\u201c.gif\u201d,\u201c.png\u201d,\u201c.tga\u201d,\u201c.tif\u201d, \u201c.JPG\u201d, \u201c.jpeg\u201d]\n\nCreating a model\n~~~~~~~~~~~~~~~~\n\nNow comes the fun part! In order to create your own model, you just have\nto call the *Model* class. For example :\n\n.. code:: python\n\n    from CGvsPhoto import Model\n\n    model = Model(database_path 'Database/My_Patch_Data', image_size = 100,\n                  config = 'Config1', filters = [32, 64], \n                  feature_extractor = 'Stats', batch_size = 50)\n\nYou can specify the number of output filtered images for each layer with\nthe parameter ``filters`` and the feature extraction scheme (between\n\u2018Hist\u2019 and \u2018Stats\u2019). You also need to give the path to the patch\ndatabase.\n\nWarning : The database must contain images with the same image\\_size as\nspecified in parameter image\\_size.\n\nTraining a classifier\n~~~~~~~~~~~~~~~~~~~~~\n\nNow, to train this model, use the *train* function specifying the number\nof training/validation/testing batches:\n\n.. code:: python\n\n    model.train(nb_train_batch = 15000,\n                nb_test_batch = 80, \n                nb_validation_batch = 40)\n                \nThis will train a model and save the weights and a bunch of summaries in\ncorrespondant directories (you specify the name of the run at the\nbegining of the procedure). You can also load a pre-trained model and\ncontinue the training (be careful though to load a model which structure\ncorresponds to the one you are trying to train).\n\nAt the end of training, the model\u2019s accuracy is evaluated on the patches\ntesting set.\n\nTesting\n~~~~~~~\n\nNow that you have trained a model, you can load it and test it on\nfull-size images, using the *test\\_total\\_images* function :\n\n.. code:: python\n\n    test_data_path = '/Database/My_Data/test/'\n    clf.test_total_images(test_data_path = test_data_path,\n                          nb_images = 720, decision_rule = 'weighted_vote')\n\nYour test directory must contain two sub-directories : CGG and Real.\nBefore testing, the console will ask you the name of the weight file to\nload. It must be in the default checkpoint directory and you should\ninidcate the .ckpt file. You can specify the number of images you want\nto process and the aggregation scheme between \u2018weighted\\_vote\u2019 and\n\u2018majority\\_vote\u2019 (even if \u2018weighted\\_vote\u2019 is in general more\nefficient).\n\nAuthors\n-------\n\n**Nicolas Rahmouni** - `NicoRahm`_\n\n**Vincent Nozick**\n\n\n.. _NicoRahm: https://github.com/NicoRahm\n.. _state of the art method: http://ieeexplore.ieee.org/abstract/document/6115849/\n.. _create\\_DB.py: examples/create_DB.py\n.. _create\\_patches\\_splicing.py: examples/create_patches_splicing.py\n.. _test\\_pipeline.py: examples/test_pipeline.py\n.. _test\\_splicing.py: examples/test_splicing.py", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/NicoRahm/CGvsPhoto", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "CGvsPhoto", "package_url": "https://pypi.org/project/CGvsPhoto/", "platform": "", "project_url": "https://pypi.org/project/CGvsPhoto/", "project_urls": {"Homepage": "https://github.com/NicoRahm/CGvsPhoto"}, "release_url": "https://pypi.org/project/CGvsPhoto/0.0.3/", "requires_dist": null, "requires_python": "", "summary": "A deep-learning method for distinguishing computer graphics from real photogrphic images", "version": "0.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://badge.fury.io/py/CGvsPhoto\" rel=\"nofollow\"><img alt=\"https://badge.fury.io/py/CGvsPhoto.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c71bc8111eb6576cc1d65c26ad5784d36ebfdb0e/68747470733a2f2f62616467652e667572792e696f2f70792f4347767350686f746f2e737667\"></a>\n<p><strong>CGvsPhoto</strong> implements a method for computer graphics detection using\nConvolutional Neural Networks with TensorFlow back-end. The package\ncontains methods for extracting patches from computer graphics and real\nimages, training a CNN with a custom statistical layer, testing this\nmodel, comparing with a <a href=\"http://ieeexplore.ieee.org/abstract/document/6115849/\" rel=\"nofollow\">state of the art method</a>, visualizing\nprobability maps, etc.</p>\n<div>\n<img alt=\"splicing\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/940138930540fac0d0727491abcd54901e96ca21/68747470733a2f2f757365722d696d616765732e67697468756275736572636f6e74656e742e636f6d2f31373132353939322f32363931373533382d39643931383331382d346336392d313165372d386336662d6638363562336335663036332e706e67\">\n</div>\n<div id=\"getting-started\">\n<h2>Getting Started</h2>\n<p>These instructions will get you a copy of the project up and running on\nyour local machine for testing purposes.</p>\n<div id=\"prerequisites\">\n<h3>Prerequisites</h3>\n<ul>\n<li>Python 3.6+</li>\n<li>Numpy 1.6.1+</li>\n<li>Scikit-learn 0.18.1+</li>\n<li>TensorFlow 1.0.1+ (<a href=\"https://github.com/tensorflow/tensorflow\" rel=\"nofollow\">https://github.com/tensorflow/tensorflow</a>)</li>\n<li>Pillow 3.1.2+</li>\n<li>Matplotlib 1.3.1+</li>\n</ul>\n</div>\n<div id=\"installing\">\n<h3>Installing</h3>\n<p>Simply install this package with pip3 :</p>\n<pre>$ pip3 install CGvsPhoto\n</pre>\n<p>You can also clone the repository into your favorite directory.</p>\n<pre>$ git clone https://github.com/NicoRahm/CGvsPhoto\n</pre>\n<p>Then, install the package using :</p>\n<pre>$ cd CGvsPhoto/\n$ pip3 install .\n</pre>\n<p>To run your first test, there is one more thing to set up:</p>\n<ul>\n<li>Create a file named config.ini in your execution directory (the directory containing your scripts) to store the different configurations of your environment. The format is the following :</li>\n</ul>\n<pre>[Name of the configuration]\ndir_ckpt = /path/to/save/trained/weights/\ndir_summaries = /path/to/save/summaries\ndir_visualization = /path/to/save visualizations\n</pre>\n<p>An example file is given in the examples directory.</p>\n</div>\n<div id=\"database-format\">\n<h3>Database format</h3>\n<p>Your database must follow this organization :</p>\n<pre>Database/\n    test/\n        CGG/\n        Real/\n    train/\n        CGG/\n        Real/\n    validation/\n        CGG/\n        Real/\n</pre>\n<p>You can create it manually or use the function construct_DB.</p>\n</div>\n<div id=\"some-simple-examples\">\n<h3>Some simple examples</h3>\n<p>To get started, you can run simple scripts from the examples directory.\nDo not forget to <strong>set up the config.ini file</strong> correctly as described\nabove and to modify the paths to data.</p>\n<ul>\n<li><a href=\"examples/create_DB.py\" rel=\"nofollow\">create_DB.py</a> will create a formated database for future tests.</li>\n<li><a href=\"examples/create_patches_splicing.py\" rel=\"nofollow\">create_patches_splicing.py</a> will create a patches database for\ntraining single-image classifier and a splicing database to test our\nmodels.</li>\n<li><a href=\"examples/test_pipeline.py\" rel=\"nofollow\">test_pipeline.py</a> trains a neural network to classify image\npatches and then evaluate it.</li>\n<li><a href=\"examples/test_splicing.py\" rel=\"nofollow\">test_splicing.py</a> tests a model on spliced images.</li>\n</ul>\n</div>\n</div>\n<div id=\"how-to-use\">\n<h2>How to use</h2>\n<p>This section explains basic uses of this code. We describe a step by\nstep procedure to evaluate our model on your database.</p>\n<div id=\"formatting-the-database\">\n<h3>Formatting the database</h3>\n<p>As our code uses a special format for the database, the first thing you\nneed to do is to create a suited structure for the data. You can do this\nmanually but we give a piece of code to do it automatically which may\nprevent bad surprises\u2026 It creates validation, training and testing\ndirectories and put a certain number of images per class in it (same\nnumber of image for each class) To do so, you just need to have CG and\nPG images in two different directories and choose another directory to\nstore the formatted database. Then you can just use the <em>construct_DB</em>\nmethod :</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">CGvsPhoto</span> <span class=\"kn\">import</span> <span class=\"n\">construct_DB</span>\n\n<span class=\"n\">path_CG</span> <span class=\"o\">=</span> <span class=\"s1\">'/path/to/CG'</span>\n<span class=\"n\">path_PG</span> <span class=\"o\">=</span> <span class=\"s1\">'/path/to/PG'</span>\n<span class=\"n\">path_export</span> <span class=\"o\">=</span> <span class=\"s1\">'path/to/export/database'</span>\n\n<span class=\"n\">construct_DB</span><span class=\"p\">(</span><span class=\"n\">source_real</span> <span class=\"o\">=</span> <span class=\"n\">path_PG</span><span class=\"p\">,</span> <span class=\"n\">source_CG</span> <span class=\"o\">=</span> <span class=\"n\">path_CG</span><span class=\"p\">,</span>\n             <span class=\"n\">target_dir</span> <span class=\"o\">=</span> <span class=\"n\">path_export</span><span class=\"p\">,</span> <span class=\"n\">nb_per_class</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span><span class=\"p\">,</span>\n             <span class=\"n\">validation_proportion</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span><span class=\"p\">,</span> <span class=\"n\">test_proportion</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span><span class=\"p\">)</span>\n</pre>\n<p>You can choose the total number of images per class and the proportion\nof images to put in each directory.</p>\n</div>\n<div id=\"creating-the-patches-database\">\n<h3>Creating the patches database</h3>\n<p>Our implementation computes local patch classification before\naggregating the results for full-size images. So, to train the\nsingle-image classifier, a patch database must be created. To this end,\nuse the <em>Database_loader</em> class :</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">CGvsPhoto</span> <span class=\"kn\">import</span> <span class=\"n\">Database_loader</span>\n\n<span class=\"n\">path_source</span> <span class=\"o\">=</span> <span class=\"s1\">'path/to/source/database'</span>\n<span class=\"n\">path_export</span> <span class=\"o\">=</span> <span class=\"s1\">'path/to/export/patches'</span>\n<span class=\"n\">size_patch</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>\n\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">Database_loader</span><span class=\"p\">(</span><span class=\"n\">path_source</span><span class=\"p\">,</span> <span class=\"n\">image_size</span> <span class=\"o\">=</span> <span class=\"n\">size_patch</span><span class=\"p\">,</span>\n                     <span class=\"n\">only_green</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># export a patch database</span>\n<span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">export_database</span><span class=\"p\">(</span><span class=\"n\">path_export</span><span class=\"p\">,</span>\n                     <span class=\"n\">nb_train</span> <span class=\"o\">=</span> <span class=\"mi\">40000</span><span class=\"p\">,</span>\n                     <span class=\"n\">nb_test</span> <span class=\"o\">=</span> <span class=\"mi\">4000</span><span class=\"p\">,</span>\n                     <span class=\"n\">nb_validation</span> <span class=\"o\">=</span> <span class=\"mi\">2000</span><span class=\"p\">)</span>\n</pre>\n<p>You can choose the patch size (100x100 pixels in our initial\nimplementation) and the number of patches to put in each directory (with\n50/50 distribution between each class).</p>\n<p>Note that supported image extensions are\n[\u201c.jpg\u201d,\u201c.gif\u201d,\u201c.png\u201d,\u201c.tga\u201d,\u201c.tif\u201d, \u201c.JPG\u201d, \u201c.jpeg\u201d]</p>\n</div>\n<div id=\"creating-a-model\">\n<h3>Creating a model</h3>\n<p>Now comes the fun part! In order to create your own model, you just have\nto call the <em>Model</em> class. For example :</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">CGvsPhoto</span> <span class=\"kn\">import</span> <span class=\"n\">Model</span>\n\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">Model</span><span class=\"p\">(</span><span class=\"n\">database_path</span> <span class=\"s1\">'Database/My_Patch_Data'</span><span class=\"p\">,</span> <span class=\"n\">image_size</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"p\">,</span>\n              <span class=\"n\">config</span> <span class=\"o\">=</span> <span class=\"s1\">'Config1'</span><span class=\"p\">,</span> <span class=\"n\">filters</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">32</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"p\">],</span>\n              <span class=\"n\">feature_extractor</span> <span class=\"o\">=</span> <span class=\"s1\">'Stats'</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span> <span class=\"o\">=</span> <span class=\"mi\">50</span><span class=\"p\">)</span>\n</pre>\n<p>You can specify the number of output filtered images for each layer with\nthe parameter <tt>filters</tt> and the feature extraction scheme (between\n\u2018Hist\u2019 and \u2018Stats\u2019). You also need to give the path to the patch\ndatabase.</p>\n<p>Warning : The database must contain images with the same image_size as\nspecified in parameter image_size.</p>\n</div>\n<div id=\"training-a-classifier\">\n<h3>Training a classifier</h3>\n<p>Now, to train this model, use the <em>train</em> function specifying the number\nof training/validation/testing batches:</p>\n<pre><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">train</span><span class=\"p\">(</span><span class=\"n\">nb_train_batch</span> <span class=\"o\">=</span> <span class=\"mi\">15000</span><span class=\"p\">,</span>\n            <span class=\"n\">nb_test_batch</span> <span class=\"o\">=</span> <span class=\"mi\">80</span><span class=\"p\">,</span>\n            <span class=\"n\">nb_validation_batch</span> <span class=\"o\">=</span> <span class=\"mi\">40</span><span class=\"p\">)</span>\n</pre>\n<p>This will train a model and save the weights and a bunch of summaries in\ncorrespondant directories (you specify the name of the run at the\nbegining of the procedure). You can also load a pre-trained model and\ncontinue the training (be careful though to load a model which structure\ncorresponds to the one you are trying to train).</p>\n<p>At the end of training, the model\u2019s accuracy is evaluated on the patches\ntesting set.</p>\n</div>\n<div id=\"testing\">\n<h3>Testing</h3>\n<p>Now that you have trained a model, you can load it and test it on\nfull-size images, using the <em>test_total_images</em> function :</p>\n<pre><span class=\"n\">test_data_path</span> <span class=\"o\">=</span> <span class=\"s1\">'/Database/My_Data/test/'</span>\n<span class=\"n\">clf</span><span class=\"o\">.</span><span class=\"n\">test_total_images</span><span class=\"p\">(</span><span class=\"n\">test_data_path</span> <span class=\"o\">=</span> <span class=\"n\">test_data_path</span><span class=\"p\">,</span>\n                      <span class=\"n\">nb_images</span> <span class=\"o\">=</span> <span class=\"mi\">720</span><span class=\"p\">,</span> <span class=\"n\">decision_rule</span> <span class=\"o\">=</span> <span class=\"s1\">'weighted_vote'</span><span class=\"p\">)</span>\n</pre>\n<p>Your test directory must contain two sub-directories : CGG and Real.\nBefore testing, the console will ask you the name of the weight file to\nload. It must be in the default checkpoint directory and you should\ninidcate the .ckpt file. You can specify the number of images you want\nto process and the aggregation scheme between \u2018weighted_vote\u2019 and\n\u2018majority_vote\u2019 (even if \u2018weighted_vote\u2019 is in general more\nefficient).</p>\n</div>\n</div>\n<div id=\"authors\">\n<h2>Authors</h2>\n<p><strong>Nicolas Rahmouni</strong> - <a href=\"https://github.com/NicoRahm\" rel=\"nofollow\">NicoRahm</a></p>\n<p><strong>Vincent Nozick</strong></p>\n</div>\n\n          </div>"}, "last_serial": 3253770, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "7514d401eef4e263763610099ca561b9", "sha256": "fcfc04dece0aa0e6f358dda540d2dc1153946f10f4eeb647f50db1ec4b1b2b10"}, "downloads": -1, "filename": "CGvsPhoto-0.0.1.tar.gz", "has_sig": false, "md5_digest": "7514d401eef4e263763610099ca561b9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24981, "upload_time": "2017-06-09T08:07:31", "upload_time_iso_8601": "2017-06-09T08:07:31.449661Z", "url": "https://files.pythonhosted.org/packages/c2/ac/10586d615ac7048a572093d10487bab8ad9993b23ba30e1385d9e8d9fabc/CGvsPhoto-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "e8dc3d5fcae0e627f47d9f192fd9ee9b", "sha256": "6ccea5cc7c92341f00db8a2ee5180b229f0960a1df4164e4b9d61ea8b8b9b993"}, "downloads": -1, "filename": "CGvsPhoto-0.0.2.tar.gz", "has_sig": false, "md5_digest": "e8dc3d5fcae0e627f47d9f192fd9ee9b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 24976, "upload_time": "2017-06-09T08:34:10", "upload_time_iso_8601": "2017-06-09T08:34:10.958530Z", "url": "https://files.pythonhosted.org/packages/7c/28/0f797e91a7f87fd3256436284fbd144e9fc613955919a480c7135fb5c9d5/CGvsPhoto-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "f1ee7c11dce5b8033f0ec12c45f09162", "sha256": "9f018c9dcc08b524f4e6440f12577f142bb92b8cd5b3e5de757f47522a077c06"}, "downloads": -1, "filename": "CGvsPhoto-0.0.3.tar.gz", "has_sig": false, "md5_digest": "f1ee7c11dce5b8033f0ec12c45f09162", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26543, "upload_time": "2017-10-16T14:20:55", "upload_time_iso_8601": "2017-10-16T14:20:55.742324Z", "url": "https://files.pythonhosted.org/packages/19/df/a379c32e53911eba651f672de20b865854103a8b43391117841e659ed29a/CGvsPhoto-0.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "f1ee7c11dce5b8033f0ec12c45f09162", "sha256": "9f018c9dcc08b524f4e6440f12577f142bb92b8cd5b3e5de757f47522a077c06"}, "downloads": -1, "filename": "CGvsPhoto-0.0.3.tar.gz", "has_sig": false, "md5_digest": "f1ee7c11dce5b8033f0ec12c45f09162", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26543, "upload_time": "2017-10-16T14:20:55", "upload_time_iso_8601": "2017-10-16T14:20:55.742324Z", "url": "https://files.pythonhosted.org/packages/19/df/a379c32e53911eba651f672de20b865854103a8b43391117841e659ed29a/CGvsPhoto-0.0.3.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:34:34 2020"}