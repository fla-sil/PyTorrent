{"info": {"author": "Andrew Young", "author_email": "UNKNOWN", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Web Environment", "Framework :: Django", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5"], "description": "===================\nDjango Redis PubSub\n===================\n\n.. image:: https://travis-ci.org/andrewyoung1991/django-redis-pubsub.svg?branch=master\n    :target: https://travis-ci.org/andrewyoung1991/django-redis-pubsub\n\n.. image:: https://coveralls.io/repos/github/andrewyoung1991/django-redis-pubsub/badge.svg?branch=master\n    :target: https://coveralls.io/github/andrewyoung1991/django-redis-pubsub?branch=master\n\n.. image:: https://codeclimate.com/github/andrewyoung1991/django-redis-pubsub/badges/gpa.svg\n    :target: https://codeclimate.com/github/andrewyoung1991/django-redis-pubsub\n    :alt: Code Climate\n\n\nasyncronous subscription distrobution for django (with websocket support!!!!).\n\n\nPublishableModel\n================\n\nYou'll first need to create some publishable models.\n\n.. code:: python\n\n    # models.py\n\n    class Correspondence(PublishableModel):\n        PUBLISH_ON_CREATE = False\n        PUBLISH_ON_UPDATE = False\n\n        participants = models.ManyToManyField(settings.AUTH_USER_MODEL, related_name=\"correspondences\")\n\n        def save(self, *args, **kwargs):\n            super(Correspondence, self).save(*args, **kwargs)\n            # add subscribe all the users to the channel\n            channel = self.channel\n            for subscriber in self.participants:\n                channel.subscribe(subscriber)\n\n\n    class Message(PublishableModel):\n        PUBLISH_ON_CREATE = True\n        PUBLISH_ON_UPDATE = False\n\n        correspondence = models.ForeignKey(\"Correspondence\", related_name=\"messages\")\n        author = models.ForeignKey(settings.AUTH_USER_MODEL, related_name=\"sent_messages\")\n        body = models.TextField()\n\n        def save(self, *args, **kwargs):\n            if not hasattr(self, \"channel\"):\n                self.channel = self.correspondence.channel\n            super(Message, self).save(*args, **kwargs)\n\n    # views.py\n\n    def send_message(request, correspondence, *args, **kwargs):\n        message = Message.objects.create(\n            correspondence_id=correspondence,\n            author=request.user,\n            body=request.POST[\"body\"]\n        return render_to_response(request, \"messages.html\", {\"message\": message})\n\n    # websockets.py\n\n    @websocket_pubsub(authenticate=True)\n    def read_messages(ws, params, user, manager):\n        subscription = user.subscriptions.get(channel__name=\"something:unique\".format(user.username))\n        reader = subscription.get_reader(manager=manager)\n\n        @reader.callback\n        def send_message_alert(channel_name, model):\n            alert = json.dumps({\"message\": \"new message from {0}\".format(model.author.get_full_name()))\n            ws.send_str(alert)\n            return True\n\n        listener = yield from reader.listen()\n        yield from listener\n\n\nIn the above example, a client who has established a websocket connection to the handler in `websockets.py` will receive alerts as long as the websocket connection remains open. When another client sends a POST request to the send_message view in `views.py` the message will be published and received by the `read_messages.send_message_alert` callback where further processing/serialization can occur.\n\n\nWebsockets\n==========\n\nIf you choose to use `redis_pubsub.contrib.websockets` there are additional packages that you will need to install::\n\n  $ pip install aiohttp aiohttp_wsgi\n\nWebsocket handlers belong in module in your application by the name of `websockets.py`. This module should export a `handlerconf`, which is a list of the names of the handlers in the module\n\n.. code:: python\n\n  @websocket(\"/\")  # this handler will be at http://yourapp.com/\n  def myhandler(ws, params, **kwargs):\n      ...\n\n  handlerconf = [\"myhandler\", ]\n\nWebsocket requests are handled with the excellent `aiohttp` package which takes care of the encoding/decoding, handshake, and cleanup of a websocket session. Handlers for websocket requests are coroutines decorated with either the `redis_pubsub.contrib.websockets.websocket` or `redis_pubsub.contrib.websockets.websocket_pubsub` wrappers. These wrappers handle converting your handler to a coroutine and passing arguments to your handler. A simple handler that echo's a message back to the client would look like this\n\n.. code:: python\n\n  @websocket(\"/echo\")\n  def echo(ws, params, **kwargs):\n      message = yield from ws.receive()\n      ws.send_str(message.data)\n\nThe former example shows a websocket handler that waits for a message from a connected client, echo's the message back to the client and closes the connection.\n\n\nWebsocket Authentication\n========================\n\nIf you choose to use authenticated websockets you will need to either install `djangorestframework` and use the `rest_framework.authtoken.models.Token` object as your authentication method or simply use `rest_framework_jwt` to distribute and challenge JTW's provided by your client. to configure authentication with one of these methods (or your own token authentication method) add the module path to the REDIS_PUBSUB config::\n\n  REDIS_PUBSUB = {\n      \"tokenauth_method\": \"redis_pubsub.auth.authjwt_method\",  # defaults to \"redis_pubsub.auth.authtoken_method\"\n  }\n\nIf you do decide to roll your own `tokenauth_method`, this method must accept a single argument (the token string) and return either `None` if the token is not valid or an instance of `AUTH_USER_MODEL` if the token is valid.\n\n\nWebsocket Pubsub\n================\n\nYou can access the Pubsub methods provided by `redis_pubsub` in your websocket handlers by decorating your handler with the `redis.pubsub.contrib.websockets.websocket_pubsub` wrapper. This wrapper provides an additional argument `manager` to your handler. The manager can be used to keep track of subscription channels and stop them if necessary\n\n.. code:: python\n\n  # websockets.py\n\n  @websocket_pubsub(\"/messages\", authenticate=True)\n  def message_pusher(ws, params, manager, user, **kwargs):\n      subscription = user.subscriptions.get(channel__name=\"messages\")\n      reader = subscription.get_reader(manager=manager)\n\n      @reader.callback\n      def callback(channel_name, message):\n          to_client = {\n              channel_name: {\n                  \"author\": message.author.username,\n                  \"body\": message.body\n              }\n          }\n          ws.send_str(json.dumps())\n          return True\n\n      listener = yield from reader.listen()\n      yield from listener\n\nThis example shows the main purpose of the `redis_pubsub` package, which is to listen for updates on a redis channel and push the publication to a client. Lets break it down line by line\n\n1) retreive the users subscription\n2) create a managed ChannelReader object for this subscription\n3) register a callback to be executed whenever a new publication is received\n4) begin listening for changes\n5) listen until the channel is closed\n\nThe most fruitful method offerd by a SubscriptionManager is `listen_to_all_subscriptions` which takes two arguments, a subscriber and a callback, and publishes subscriptions as they arrive\n\n.. code:: python\n\n  # websockets.py\n\n  @websocket_pubsub(\"/subscriptions\", authenticate=True)\n  def subscriptions(ws, params, manager, user, **kwargs):\n\n      def callback(channel_name, message):\n          ws.send_str(message.serialize())\n          return True\n\n      manager.listen_to_all_subscriptions(user, callback)\n\n      while True:\n          message = yield from ws.receive()\n          if message.tp not in (MsgType.error, MsgType.close):\n              message = json.loads(message)\n              if message[\"action\"] == \"unsubscribe\":\n                  subscription = user.subscriptions.get(channel__name=message[\"channe\"])\n                  subscription.active = False\n                  subscription.save()\n                  reader = manager.readers[message[\"channel\"]]\n                  yield from manager.remove(reader)\n              elif message[\"action\"] == \"subscribe\":\n                  channel = Channel.objects.get(name=message[\"channel\"])\n                  reader = channel.subscribe(user).get_reader(manager=manager)\n                  reader.callback(callback)\n                  yield from reader.listen()\n          else:\n              break\n\nThe callback in this example will keep all subscription channels open and push messages to a client until the websocket has closed. This code provides a simple means of managing users with a multitude of subscriptions. The `while` loop here also handles unsubscribing and subscribing to new channels\n\n.. note::\n\n  A callback function should never receive from a websocket or else a RuntimeError will be raised.\n\n\nDeploying\n=========\n\nwhen deploying an application with websockets/aiohttp you will not be able to use the normal django deployment proceedures. Since your django application will be a component of an AioHttp application object, you will have to use Gunicorn as an application server. Using utilities from the `redis_pubsub.contrib.websockets` module you can create a deployment file simply\n\n.. code:: python\n\n  # deployment.py\n\n  import asyncio\n\n  from django.core.wsgi import get_wsgi_application\n  \n  from aiohttp_wsgi import WSGIHandler\n  \n  from redis_pubsub.contrib.websockets import setup\n\n\n  wsgi_app = get_wsgi_application()  # django.setup() is called here\n  wsgi_handler = WSGIHandler(wsgi_app)\n  \n  loop = asyncio.get_event_loop()\n  application = setup(loop=loop)\n  # any url patterns not matched by the Websocket app go to the django app for handling\n  application.router.add_route(\"*\", \"/{path_info:.*}\", wsgi_handler.handle_request)\n\nyou can then start gunicorn by running::\n\n  $ gunicorn deployment:application --bind localhost:8080 --worker-class aiohttp.worker.GunicornWebWorker", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/andrewyoung1991/django-redis-pubsub", "keywords": null, "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "django-redis-pubsub", "package_url": "https://pypi.org/project/django-redis-pubsub/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/django-redis-pubsub/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/andrewyoung1991/django-redis-pubsub"}, "release_url": "https://pypi.org/project/django-redis-pubsub/1.0/", "requires_dist": null, "requires_python": null, "summary": "asyncronous pubsub in django using redis", "version": "1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/andrewyoung1991/django-redis-pubsub\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/andrewyoung1991/django-redis-pubsub.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3d5e869d6aa22262ce51161686de6eafa4895ab5/68747470733a2f2f7472617669732d63692e6f72672f616e64726577796f756e67313939312f646a616e676f2d72656469732d7075627375622e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/andrewyoung1991/django-redis-pubsub?branch=master\" rel=\"nofollow\"><img alt=\"https://coveralls.io/repos/github/andrewyoung1991/django-redis-pubsub/badge.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/95f21ea2033a47133751de9e48a77412ee5510f1/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f616e64726577796f756e67313939312f646a616e676f2d72656469732d7075627375622f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codeclimate.com/github/andrewyoung1991/django-redis-pubsub\" rel=\"nofollow\"><img alt=\"Code Climate\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9d449b59445c102ad6aba1c35028e190d0e51bd5/68747470733a2f2f636f6465636c696d6174652e636f6d2f6769746875622f616e64726577796f756e67313939312f646a616e676f2d72656469732d7075627375622f6261646765732f6770612e737667\"></a>\n<p>asyncronous subscription distrobution for django (with websocket support!!!!).</p>\n<div id=\"publishablemodel\">\n<h2>PublishableModel</h2>\n<p>You\u2019ll first need to create some publishable models.</p>\n<pre><span class=\"c1\"># models.py</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Correspondence</span><span class=\"p\">(</span><span class=\"n\">PublishableModel</span><span class=\"p\">):</span>\n    <span class=\"n\">PUBLISH_ON_CREATE</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n    <span class=\"n\">PUBLISH_ON_UPDATE</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n    <span class=\"n\">participants</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">ManyToManyField</span><span class=\"p\">(</span><span class=\"n\">settings</span><span class=\"o\">.</span><span class=\"n\">AUTH_USER_MODEL</span><span class=\"p\">,</span> <span class=\"n\">related_name</span><span class=\"o\">=</span><span class=\"s2\">\"correspondences\"</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">save</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">Correspondence</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n        <span class=\"c1\"># add subscribe all the users to the channel</span>\n        <span class=\"n\">channel</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">channel</span>\n        <span class=\"k\">for</span> <span class=\"n\">subscriber</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">participants</span><span class=\"p\">:</span>\n            <span class=\"n\">channel</span><span class=\"o\">.</span><span class=\"n\">subscribe</span><span class=\"p\">(</span><span class=\"n\">subscriber</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Message</span><span class=\"p\">(</span><span class=\"n\">PublishableModel</span><span class=\"p\">):</span>\n    <span class=\"n\">PUBLISH_ON_CREATE</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n    <span class=\"n\">PUBLISH_ON_UPDATE</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n\n    <span class=\"n\">correspondence</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">ForeignKey</span><span class=\"p\">(</span><span class=\"s2\">\"Correspondence\"</span><span class=\"p\">,</span> <span class=\"n\">related_name</span><span class=\"o\">=</span><span class=\"s2\">\"messages\"</span><span class=\"p\">)</span>\n    <span class=\"n\">author</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">ForeignKey</span><span class=\"p\">(</span><span class=\"n\">settings</span><span class=\"o\">.</span><span class=\"n\">AUTH_USER_MODEL</span><span class=\"p\">,</span> <span class=\"n\">related_name</span><span class=\"o\">=</span><span class=\"s2\">\"sent_messages\"</span><span class=\"p\">)</span>\n    <span class=\"n\">body</span> <span class=\"o\">=</span> <span class=\"n\">models</span><span class=\"o\">.</span><span class=\"n\">TextField</span><span class=\"p\">()</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">save</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"s2\">\"channel\"</span><span class=\"p\">):</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">channel</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">correspondence</span><span class=\"o\">.</span><span class=\"n\">channel</span>\n        <span class=\"nb\">super</span><span class=\"p\">(</span><span class=\"n\">Message</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># views.py</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">send_message</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"n\">correspondence</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"n\">Message</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span>\n        <span class=\"n\">correspondence_id</span><span class=\"o\">=</span><span class=\"n\">correspondence</span><span class=\"p\">,</span>\n        <span class=\"n\">author</span><span class=\"o\">=</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">user</span><span class=\"p\">,</span>\n        <span class=\"n\">body</span><span class=\"o\">=</span><span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">POST</span><span class=\"p\">[</span><span class=\"s2\">\"body\"</span><span class=\"p\">]</span>\n    <span class=\"k\">return</span> <span class=\"n\">render_to_response</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"s2\">\"messages.html\"</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s2\">\"message\"</span><span class=\"p\">:</span> <span class=\"n\">message</span><span class=\"p\">})</span>\n\n<span class=\"c1\"># websockets.py</span>\n\n<span class=\"nd\">@websocket_pubsub</span><span class=\"p\">(</span><span class=\"n\">authenticate</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">read_messages</span><span class=\"p\">(</span><span class=\"n\">ws</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"n\">user</span><span class=\"p\">,</span> <span class=\"n\">manager</span><span class=\"p\">):</span>\n    <span class=\"n\">subscription</span> <span class=\"o\">=</span> <span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">subscriptions</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">channel__name</span><span class=\"o\">=</span><span class=\"s2\">\"something:unique\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">username</span><span class=\"p\">))</span>\n    <span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">subscription</span><span class=\"o\">.</span><span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"n\">manager</span><span class=\"o\">=</span><span class=\"n\">manager</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@reader</span><span class=\"o\">.</span><span class=\"n\">callback</span>\n    <span class=\"k\">def</span> <span class=\"nf\">send_message_alert</span><span class=\"p\">(</span><span class=\"n\">channel_name</span><span class=\"p\">,</span> <span class=\"n\">model</span><span class=\"p\">):</span>\n        <span class=\"n\">alert</span> <span class=\"o\">=</span> <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">({</span><span class=\"s2\">\"message\"</span><span class=\"p\">:</span> <span class=\"s2\">\"new message from </span><span class=\"si\">{0}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">author</span><span class=\"o\">.</span><span class=\"n\">get_full_name</span><span class=\"p\">()))</span>\n        <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">send_str</span><span class=\"p\">(</span><span class=\"n\">alert</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">True</span>\n\n    <span class=\"n\">listener</span> <span class=\"o\">=</span> <span class=\"k\">yield from</span> <span class=\"n\">reader</span><span class=\"o\">.</span><span class=\"n\">listen</span><span class=\"p\">()</span>\n    <span class=\"k\">yield from</span> <span class=\"n\">listener</span>\n</pre>\n<p>In the above example, a client who has established a websocket connection to the handler in <cite>websockets.py</cite> will receive alerts as long as the websocket connection remains open. When another client sends a POST request to the send_message view in <cite>views.py</cite> the message will be published and received by the <cite>read_messages.send_message_alert</cite> callback where further processing/serialization can occur.</p>\n</div>\n<div id=\"websockets\">\n<h2>Websockets</h2>\n<p>If you choose to use <cite>redis_pubsub.contrib.websockets</cite> there are additional packages that you will need to install:</p>\n<pre>$ pip install aiohttp aiohttp_wsgi\n</pre>\n<p>Websocket handlers belong in module in your application by the name of <cite>websockets.py</cite>. This module should export a <cite>handlerconf</cite>, which is a list of the names of the handlers in the module</p>\n<pre><span class=\"nd\">@websocket</span><span class=\"p\">(</span><span class=\"s2\">\"/\"</span><span class=\"p\">)</span>  <span class=\"c1\"># this handler will be at http://yourapp.com/</span>\n<span class=\"k\">def</span> <span class=\"nf\">myhandler</span><span class=\"p\">(</span><span class=\"n\">ws</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n\n<span class=\"n\">handlerconf</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">\"myhandler\"</span><span class=\"p\">,</span> <span class=\"p\">]</span>\n</pre>\n<p>Websocket requests are handled with the excellent <cite>aiohttp</cite> package which takes care of the encoding/decoding, handshake, and cleanup of a websocket session. Handlers for websocket requests are coroutines decorated with either the <cite>redis_pubsub.contrib.websockets.websocket</cite> or <cite>redis_pubsub.contrib.websockets.websocket_pubsub</cite> wrappers. These wrappers handle converting your handler to a coroutine and passing arguments to your handler. A simple handler that echo\u2019s a message back to the client would look like this</p>\n<pre><span class=\"nd\">@websocket</span><span class=\"p\">(</span><span class=\"s2\">\"/echo\"</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">echo</span><span class=\"p\">(</span><span class=\"n\">ws</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"k\">yield from</span> <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">receive</span><span class=\"p\">()</span>\n    <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">send_str</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">)</span>\n</pre>\n<p>The former example shows a websocket handler that waits for a message from a connected client, echo\u2019s the message back to the client and closes the connection.</p>\n</div>\n<div id=\"websocket-authentication\">\n<h2>Websocket Authentication</h2>\n<p>If you choose to use authenticated websockets you will need to either install <cite>djangorestframework</cite> and use the <cite>rest_framework.authtoken.models.Token</cite> object as your authentication method or simply use <cite>rest_framework_jwt</cite> to distribute and challenge JTW\u2019s provided by your client. to configure authentication with one of these methods (or your own token authentication method) add the module path to the REDIS_PUBSUB config:</p>\n<pre>REDIS_PUBSUB = {\n    \"tokenauth_method\": \"redis_pubsub.auth.authjwt_method\",  # defaults to \"redis_pubsub.auth.authtoken_method\"\n}\n</pre>\n<p>If you do decide to roll your own <cite>tokenauth_method</cite>, this method must accept a single argument (the token string) and return either <cite>None</cite> if the token is not valid or an instance of <cite>AUTH_USER_MODEL</cite> if the token is valid.</p>\n</div>\n<div id=\"websocket-pubsub\">\n<h2>Websocket Pubsub</h2>\n<p>You can access the Pubsub methods provided by <cite>redis_pubsub</cite> in your websocket handlers by decorating your handler with the <cite>redis.pubsub.contrib.websockets.websocket_pubsub</cite> wrapper. This wrapper provides an additional argument <cite>manager</cite> to your handler. The manager can be used to keep track of subscription channels and stop them if necessary</p>\n<pre><span class=\"c1\"># websockets.py</span>\n\n<span class=\"nd\">@websocket_pubsub</span><span class=\"p\">(</span><span class=\"s2\">\"/messages\"</span><span class=\"p\">,</span> <span class=\"n\">authenticate</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">message_pusher</span><span class=\"p\">(</span><span class=\"n\">ws</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"n\">manager</span><span class=\"p\">,</span> <span class=\"n\">user</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n    <span class=\"n\">subscription</span> <span class=\"o\">=</span> <span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">subscriptions</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">channel__name</span><span class=\"o\">=</span><span class=\"s2\">\"messages\"</span><span class=\"p\">)</span>\n    <span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">subscription</span><span class=\"o\">.</span><span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"n\">manager</span><span class=\"o\">=</span><span class=\"n\">manager</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@reader</span><span class=\"o\">.</span><span class=\"n\">callback</span>\n    <span class=\"k\">def</span> <span class=\"nf\">callback</span><span class=\"p\">(</span><span class=\"n\">channel_name</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">):</span>\n        <span class=\"n\">to_client</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n            <span class=\"n\">channel_name</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n                <span class=\"s2\">\"author\"</span><span class=\"p\">:</span> <span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">author</span><span class=\"o\">.</span><span class=\"n\">username</span><span class=\"p\">,</span>\n                <span class=\"s2\">\"body\"</span><span class=\"p\">:</span> <span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">body</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">send_str</span><span class=\"p\">(</span><span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">())</span>\n        <span class=\"k\">return</span> <span class=\"kc\">True</span>\n\n    <span class=\"n\">listener</span> <span class=\"o\">=</span> <span class=\"k\">yield from</span> <span class=\"n\">reader</span><span class=\"o\">.</span><span class=\"n\">listen</span><span class=\"p\">()</span>\n    <span class=\"k\">yield from</span> <span class=\"n\">listener</span>\n</pre>\n<p>This example shows the main purpose of the <cite>redis_pubsub</cite> package, which is to listen for updates on a redis channel and push the publication to a client. Lets break it down line by line</p>\n<ol>\n<li>retreive the users subscription</li>\n<li>create a managed ChannelReader object for this subscription</li>\n<li>register a callback to be executed whenever a new publication is received</li>\n<li>begin listening for changes</li>\n<li>listen until the channel is closed</li>\n</ol>\n<p>The most fruitful method offerd by a SubscriptionManager is <cite>listen_to_all_subscriptions</cite> which takes two arguments, a subscriber and a callback, and publishes subscriptions as they arrive</p>\n<pre><span class=\"c1\"># websockets.py</span>\n\n<span class=\"nd\">@websocket_pubsub</span><span class=\"p\">(</span><span class=\"s2\">\"/subscriptions\"</span><span class=\"p\">,</span> <span class=\"n\">authenticate</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">subscriptions</span><span class=\"p\">(</span><span class=\"n\">ws</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"n\">manager</span><span class=\"p\">,</span> <span class=\"n\">user</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">callback</span><span class=\"p\">(</span><span class=\"n\">channel_name</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">):</span>\n        <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">send_str</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">serialize</span><span class=\"p\">())</span>\n        <span class=\"k\">return</span> <span class=\"kc\">True</span>\n\n    <span class=\"n\">manager</span><span class=\"o\">.</span><span class=\"n\">listen_to_all_subscriptions</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"p\">)</span>\n\n    <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n        <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"k\">yield from</span> <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">receive</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">tp</span> <span class=\"ow\">not</span> <span class=\"ow\">in</span> <span class=\"p\">(</span><span class=\"n\">MsgType</span><span class=\"o\">.</span><span class=\"n\">error</span><span class=\"p\">,</span> <span class=\"n\">MsgType</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">):</span>\n            <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">loads</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"n\">message</span><span class=\"p\">[</span><span class=\"s2\">\"action\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s2\">\"unsubscribe\"</span><span class=\"p\">:</span>\n                <span class=\"n\">subscription</span> <span class=\"o\">=</span> <span class=\"n\">user</span><span class=\"o\">.</span><span class=\"n\">subscriptions</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">channel__name</span><span class=\"o\">=</span><span class=\"n\">message</span><span class=\"p\">[</span><span class=\"s2\">\"channe\"</span><span class=\"p\">])</span>\n                <span class=\"n\">subscription</span><span class=\"o\">.</span><span class=\"n\">active</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>\n                <span class=\"n\">subscription</span><span class=\"o\">.</span><span class=\"n\">save</span><span class=\"p\">()</span>\n                <span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">manager</span><span class=\"o\">.</span><span class=\"n\">readers</span><span class=\"p\">[</span><span class=\"n\">message</span><span class=\"p\">[</span><span class=\"s2\">\"channel\"</span><span class=\"p\">]]</span>\n                <span class=\"k\">yield from</span> <span class=\"n\">manager</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"n\">reader</span><span class=\"p\">)</span>\n            <span class=\"k\">elif</span> <span class=\"n\">message</span><span class=\"p\">[</span><span class=\"s2\">\"action\"</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"s2\">\"subscribe\"</span><span class=\"p\">:</span>\n                <span class=\"n\">channel</span> <span class=\"o\">=</span> <span class=\"n\">Channel</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"n\">message</span><span class=\"p\">[</span><span class=\"s2\">\"channel\"</span><span class=\"p\">])</span>\n                <span class=\"n\">reader</span> <span class=\"o\">=</span> <span class=\"n\">channel</span><span class=\"o\">.</span><span class=\"n\">subscribe</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get_reader</span><span class=\"p\">(</span><span class=\"n\">manager</span><span class=\"o\">=</span><span class=\"n\">manager</span><span class=\"p\">)</span>\n                <span class=\"n\">reader</span><span class=\"o\">.</span><span class=\"n\">callback</span><span class=\"p\">(</span><span class=\"n\">callback</span><span class=\"p\">)</span>\n                <span class=\"k\">yield from</span> <span class=\"n\">reader</span><span class=\"o\">.</span><span class=\"n\">listen</span><span class=\"p\">()</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">break</span>\n</pre>\n<p>The callback in this example will keep all subscription channels open and push messages to a client until the websocket has closed. This code provides a simple means of managing users with a multitude of subscriptions. The <cite>while</cite> loop here also handles unsubscribing and subscribing to new channels</p>\n<div>\n<p>Note</p>\n<p>A callback function should never receive from a websocket or else a RuntimeError will be raised.</p>\n</div>\n</div>\n<div id=\"deploying\">\n<h2>Deploying</h2>\n<p>when deploying an application with websockets/aiohttp you will not be able to use the normal django deployment proceedures. Since your django application will be a component of an AioHttp application object, you will have to use Gunicorn as an application server. Using utilities from the <cite>redis_pubsub.contrib.websockets</cite> module you can create a deployment file simply</p>\n<pre><span class=\"c1\"># deployment.py</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">django.core.wsgi</span> <span class=\"kn\">import</span> <span class=\"n\">get_wsgi_application</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">aiohttp_wsgi</span> <span class=\"kn\">import</span> <span class=\"n\">WSGIHandler</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">redis_pubsub.contrib.websockets</span> <span class=\"kn\">import</span> <span class=\"n\">setup</span>\n\n\n<span class=\"n\">wsgi_app</span> <span class=\"o\">=</span> <span class=\"n\">get_wsgi_application</span><span class=\"p\">()</span>  <span class=\"c1\"># django.setup() is called here</span>\n<span class=\"n\">wsgi_handler</span> <span class=\"o\">=</span> <span class=\"n\">WSGIHandler</span><span class=\"p\">(</span><span class=\"n\">wsgi_app</span><span class=\"p\">)</span>\n\n<span class=\"n\">loop</span> <span class=\"o\">=</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">get_event_loop</span><span class=\"p\">()</span>\n<span class=\"n\">application</span> <span class=\"o\">=</span> <span class=\"n\">setup</span><span class=\"p\">(</span><span class=\"n\">loop</span><span class=\"o\">=</span><span class=\"n\">loop</span><span class=\"p\">)</span>\n<span class=\"c1\"># any url patterns not matched by the Websocket app go to the django app for handling</span>\n<span class=\"n\">application</span><span class=\"o\">.</span><span class=\"n\">router</span><span class=\"o\">.</span><span class=\"n\">add_route</span><span class=\"p\">(</span><span class=\"s2\">\"*\"</span><span class=\"p\">,</span> <span class=\"s2\">\"/{path_info:.*}\"</span><span class=\"p\">,</span> <span class=\"n\">wsgi_handler</span><span class=\"o\">.</span><span class=\"n\">handle_request</span><span class=\"p\">)</span>\n</pre>\n<p>you can then start gunicorn by running:</p>\n<pre>$ gunicorn deployment:application --bind localhost:8080 --worker-class aiohttp.worker.GunicornWebWorker\n</pre>\n</div>\n\n          </div>"}, "last_serial": 1953808, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "3cb71c141fdc7d83df57ac5190911169", "sha256": "e85841d942f9daa6d63188ab719932cc1ab45886602a1a3cfe36c5e51deb927e"}, "downloads": -1, "filename": "django-redis-pubsub-1.0.tar.gz", "has_sig": false, "md5_digest": "3cb71c141fdc7d83df57ac5190911169", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13010, "upload_time": "2016-02-12T20:50:52", "upload_time_iso_8601": "2016-02-12T20:50:52.327544Z", "url": "https://files.pythonhosted.org/packages/db/91/f991d755dbe0d3d7bb2a193f0ebe0dfdf208b821a455ff9062aca5e6e941/django-redis-pubsub-1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3cb71c141fdc7d83df57ac5190911169", "sha256": "e85841d942f9daa6d63188ab719932cc1ab45886602a1a3cfe36c5e51deb927e"}, "downloads": -1, "filename": "django-redis-pubsub-1.0.tar.gz", "has_sig": false, "md5_digest": "3cb71c141fdc7d83df57ac5190911169", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13010, "upload_time": "2016-02-12T20:50:52", "upload_time_iso_8601": "2016-02-12T20:50:52.327544Z", "url": "https://files.pythonhosted.org/packages/db/91/f991d755dbe0d3d7bb2a193f0ebe0dfdf208b821a455ff9062aca5e6e941/django-redis-pubsub-1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:21 2020"}