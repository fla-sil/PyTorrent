{"info": {"author": "Joong-Hee Lee", "author_email": "leejoonghee@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2.7", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Utilities"], "description": "# configbuilder\nGeneral purpose configuration parser builder for python.\nYou can create your own configuration parser only with ```Configuration Template```\n\n```configbuilder``` offers you the easiest way to define a configuration file for your\napplication project written in python.\n \n## Synopsis\nData serialization language such as YAML or JSON is a good choice to write a\nconfiguration files for a application. \nThe code for parsing and validating the configuration file have to be re-written \neven for a simple change such as attribute name modification for new application. \n```configbuilder``` offers you an easy way to define a configuration file format with\nminimum code changing. It is even possible to define a configuration format without\nany developing codes. Instead of parsing code, you can define a configuration with\na template file written in data serialization language.  \n\n## Usage\n### Configuration Template\nYou can define the format of configuration format with writing a configuration template.\nLoading the configuration template in your application code, you can simply parse a\nuser configuration file also with the validation.\nThis is the example of a configuration template written in YAML.\n\n    ConfigKey1: String\n    ConfigKey2: Boolean\n    ConfigKey3: Integer\n    ConfigKey4: IP\n    ConfigKey5: FilePath\n    ConfigKey6:\n        ConfigKey6Name: # indicates the name of this subconfig\n            SubConfigKey1: List of DirectoryPath \n            SubConfigKey2: String\n            SubConfigKey3:\n                SubConfigKey3Name:\n                    SubSubConfigKey1: List of String\n                    SubSubConfigKey2: Integer\n                    SubSubConfigKey3: IP\n                SubConfigKey3Name:\n                    SubSubConfigKey4: Config In SubConfigKey3\n    ConfigKey7:\n        -   \n            SubConfigKey1: String\n            SubConfigKey2: Integer\n            SubConfigKey3: NotSupportingType\n\nAn Attribute in configuration template consists of Key:Type pair. A key without a type \nintends that there is a sub-config for the key.\nThere are built-in types to validate values. The types are case-insensitive.\n\n#### Built-in types\n* String: Any type of string is accepted, and automatically strip the string.\n* Boolean: True or False\n* Integer: Integers\n* IP: IP address\n* Path: Any path regardless of the existence\n* FilePath: Existing file path\n* DirectoryPath: Existing directory path\n* List: Any list regardless of the type of the item\n\n#### Compound type\n* List of ```Built-in type```: The value should be a list, and each item is \nvalidated with the specified built-in type.\n* Config In ```Other Configuration Key```: The value is the name of other configuration.\nThis type converts value into the configuration instead of the given name.\n\n### Build parser\nSimple function ```create_parser``` let you build your own parser. With your parser,\nyou are ready to parse your configuration file.\n\n    from configbuilder.parser import create_parser\n    parser = create_parser('path/your_template.yaml',\n                           casesensitivekey=False)\n    config = parser.parse_config('path/your_configuration.yaml')\n    value = config.get('attribute')\n    \nOr you can define your template in your code in dictionary type, and create the parser.\n\n    from configbuilder.parser import ConfigParser\n    YOUR_TEMPLATE = {\n        'KEY1': 'String',\n        'KEY2': 'Integer'\n    }\n    parser = ConfigParser(YOUR_TEMPLATE)\n\n### Define new types\nYou can define your own validator inheriting Validator class and set to parser.\nYou implement validate_yourtype() in your custom validator to define new type called\n```yourtype```. This type can be used in the template file.\nHere is the code defining a new type called ```protocol``` which is kind of string,\nbut only accpeting 'ssh' or 'ftp' as the value.\n\n    from configbuilder.validator import Validator\n    class MyValidator(Validator):\n        def validate_protocol(self, value):\n            supporting_protocol = ['ssh', 'ftp'] \n            return self._validate_choiceses(value, supporting_protocol)\n            \nThis validator can be set when building the parser.\n\n    parser = create_parser('path/your_template.yaml',\n                           validator=MyValidator())\n\n## Installation\n\n    pip install configbuilder\n\n## Authors\n* ** Joong-Hee Lee ** - *Initial work* - [joongh](https://github.com/joongh)\n    \n## License\nThis project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/joongh/configbuilder", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "configbuilder", "package_url": "https://pypi.org/project/configbuilder/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/configbuilder/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/joongh/configbuilder"}, "release_url": "https://pypi.org/project/configbuilder/0.2.2/", "requires_dist": null, "requires_python": null, "summary": "General purpose configuration parser builder", "version": "0.2.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            # configbuilder<br>General purpose configuration parser builder for python.<br>You can create your own configuration parser only with ```Configuration Template```<br><br>```configbuilder``` offers you the easiest way to define a configuration file for your<br>application project written in python.<br> <br>## Synopsis<br>Data serialization language such as YAML or JSON is a good choice to write a<br>configuration files for a application. <br>The code for parsing and validating the configuration file have to be re-written <br>even for a simple change such as attribute name modification for new application. <br>```configbuilder``` offers you an easy way to define a configuration file format with<br>minimum code changing. It is even possible to define a configuration format without<br>any developing codes. Instead of parsing code, you can define a configuration with<br>a template file written in data serialization language.  <br><br>## Usage<br>### Configuration Template<br>You can define the format of configuration format with writing a configuration template.<br>Loading the configuration template in your application code, you can simply parse a<br>user configuration file also with the validation.<br>This is the example of a configuration template written in YAML.<br><br>    ConfigKey1: String<br>    ConfigKey2: Boolean<br>    ConfigKey3: Integer<br>    ConfigKey4: IP<br>    ConfigKey5: FilePath<br>    ConfigKey6:<br>        ConfigKey6Name: # indicates the name of this subconfig<br>            SubConfigKey1: List of DirectoryPath <br>            SubConfigKey2: String<br>            SubConfigKey3:<br>                SubConfigKey3Name:<br>                    SubSubConfigKey1: List of String<br>                    SubSubConfigKey2: Integer<br>                    SubSubConfigKey3: IP<br>                SubConfigKey3Name:<br>                    SubSubConfigKey4: Config In SubConfigKey3<br>    ConfigKey7:<br>        -   <br>            SubConfigKey1: String<br>            SubConfigKey2: Integer<br>            SubConfigKey3: NotSupportingType<br><br>An Attribute in configuration template consists of Key:Type pair. A key without a type <br>intends that there is a sub-config for the key.<br>There are built-in types to validate values. The types are case-insensitive.<br><br>#### Built-in types<br>* String: Any type of string is accepted, and automatically strip the string.<br>* Boolean: True or False<br>* Integer: Integers<br>* IP: IP address<br>* Path: Any path regardless of the existence<br>* FilePath: Existing file path<br>* DirectoryPath: Existing directory path<br>* List: Any list regardless of the type of the item<br><br>#### Compound type<br>* List of ```Built-in type```: The value should be a list, and each item is <br>validated with the specified built-in type.<br>* Config In ```Other Configuration Key```: The value is the name of other configuration.<br>This type converts value into the configuration instead of the given name.<br><br>### Build parser<br>Simple function ```create_parser``` let you build your own parser. With your parser,<br>you are ready to parse your configuration file.<br><br>    from configbuilder.parser import create_parser<br>    parser = create_parser('path/your_template.yaml',<br>                           casesensitivekey=False)<br>    config = parser.parse_config('path/your_configuration.yaml')<br>    value = config.get('attribute')<br>    <br>Or you can define your template in your code in dictionary type, and create the parser.<br><br>    from configbuilder.parser import ConfigParser<br>    YOUR_TEMPLATE = {<br>        'KEY1': 'String',<br>        'KEY2': 'Integer'<br>    }<br>    parser = ConfigParser(YOUR_TEMPLATE)<br><br>### Define new types<br>You can define your own validator inheriting Validator class and set to parser.<br>You implement validate_yourtype() in your custom validator to define new type called<br>```yourtype```. This type can be used in the template file.<br>Here is the code defining a new type called ```protocol``` which is kind of string,<br>but only accpeting 'ssh' or 'ftp' as the value.<br><br>    from configbuilder.validator import Validator<br>    class MyValidator(Validator):<br>        def validate_protocol(self, value):<br>            supporting_protocol = ['ssh', 'ftp'] <br>            return self._validate_choiceses(value, supporting_protocol)<br>            <br>This validator can be set when building the parser.<br><br>    parser = create_parser('path/your_template.yaml',<br>                           validator=MyValidator())<br><br>## Installation<br><br>    pip install configbuilder<br><br>## Authors<br>* ** Joong-Hee Lee ** - *Initial work* - [joongh](https://github.com/joongh)<br>    <br>## License<br>This project is licensed under the MIT License - see the [LICENSE.md](LICENSE.md) file for details\n          </div>"}, "last_serial": 2075324, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "238b2fe7faf19ebb405d2ee105a6b1a7", "sha256": "1be7ca2fd2df787a09bda9c5ca58b8d82cb610fcfbacb4ae687b309d103d0b28"}, "downloads": -1, "filename": "configbuilder-0.1.tar.gz", "has_sig": false, "md5_digest": "238b2fe7faf19ebb405d2ee105a6b1a7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2494, "upload_time": "2016-04-18T17:07:59", "upload_time_iso_8601": "2016-04-18T17:07:59.617774Z", "url": "https://files.pythonhosted.org/packages/6c/2a/afe37449df40b174481ee4316c872edbe44f79246ad8862620d82de05cc9/configbuilder-0.1.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "5058bfcb78c6a85944ef4e82bc652140", "sha256": "6c68a9daa6c83b2b2356619b1fb02288c229c253cb58aff5f6a311cd1efe72c9"}, "downloads": -1, "filename": "configbuilder-0.2.1.tar.gz", "has_sig": false, "md5_digest": "5058bfcb78c6a85944ef4e82bc652140", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4897, "upload_time": "2016-04-20T17:33:02", "upload_time_iso_8601": "2016-04-20T17:33:02.036319Z", "url": "https://files.pythonhosted.org/packages/5f/34/05d6bbf1b5a458a19ef53255894f24fa8eeda77089ad99dcd5f63d42ac83/configbuilder-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "470451462ee03a72a16f4db740721163", "sha256": "3271f4d9c36aaf75c300bb6d4c0cabe46bbaf3f38420d785fcd447f56e3b8c68"}, "downloads": -1, "filename": "configbuilder-0.2.2.tar.gz", "has_sig": false, "md5_digest": "470451462ee03a72a16f4db740721163", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6038, "upload_time": "2016-04-21T02:22:14", "upload_time_iso_8601": "2016-04-21T02:22:14.703008Z", "url": "https://files.pythonhosted.org/packages/d0/58/b3ca8583fbd951b3e46def3fa369d98e683c5078436d9ff079d199a6a60a/configbuilder-0.2.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "470451462ee03a72a16f4db740721163", "sha256": "3271f4d9c36aaf75c300bb6d4c0cabe46bbaf3f38420d785fcd447f56e3b8c68"}, "downloads": -1, "filename": "configbuilder-0.2.2.tar.gz", "has_sig": false, "md5_digest": "470451462ee03a72a16f4db740721163", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6038, "upload_time": "2016-04-21T02:22:14", "upload_time_iso_8601": "2016-04-21T02:22:14.703008Z", "url": "https://files.pythonhosted.org/packages/d0/58/b3ca8583fbd951b3e46def3fa369d98e683c5078436d9ff079d199a6a60a/configbuilder-0.2.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:43:58 2020"}