{"info": {"author": "Martin Holst Swende", "author_email": "martin.swende@ethereum.org", "bugtrack_url": null, "classifiers": [], "description": "# EVM lab utilities\n\nThis package contains various tools to interact with the Ethereum virtual machine.\n\n## Project Structure\n\n| Folder       | Description   |\n| ------------ | ------------- |\n| docs         | Project documentation |\n| evmlab       | The evmlab package  |\n| utilities    | Example utilities and proof-of-concepts |\n| files        | Sample trace files and trace logs |\n| output       | output directory for artefacts |\n| templates    | Web application templates (currently used with reproducer) |\n| containers   | Docker container files |\n\n## Installation\n\n#### From source:\n\nConsider creating a virtualenv.\n\n    #> virtualenv -p python3 .env3\n    #> . .env3/bin/activate\n    #> python3 -m pip install -r requirements.txt\n    #> python3 setup.py install\n    #> python3 -m evmlab  # verify installation\n\n#### From PIP:\n\nTODO: publish to pip!\n\n    #> python3 -m pip install evmlab\n    #> python3 -m evmlab[consolegui,abidecoder,docker]  # verify installation\n\nEVMLab comes with a commandline utility that can be invoked by calling `python3 -m evmlab <subcommand> <args>`\n\n## Compiler\n\nThe 'compiler' is a tool to build evm binaries, using a pythonic way to construct the programs using assembly. \n\nHere's an example that tests `ecdsaRecover`:\n\n```python\n\n\tp = compiler.Program()\n\tp.mstore(0 ,0x38d18acb67d25c8bb9942764b62f18e17054f66a817bd4295423adf9ed98873e)\n\tv = 0x000000000000000000000000000000000000000000000000000000000000001b\n\tp.mstore(32   , v)\n\tp.mstore(64   ,0x723841761d213b60ac1cbf063207cbeba6c2725bcaf7c189e63f13d93fc1dc07)\n\tp.mstore(96   ,0x789d1dd423d25f0772d2748d60f7e4b81bb14d086eba8e8e8efb6dcff8a4ae02)\n\tp.call(0xfff,1,0,0,0x80,0x80,0x20)\n\tp.rreturn(140,20)\n\tcode = p.bytecode()\n```\n\nHere's an example of stuffing `JUMPDEST` into a program: \n\n```python\n\n\tp = compiler.Program()\n\tp.jump(0x3)\n\tp.jumpdest()\n\tp.rreturn()\n\tfor i in range(0,20000):\n\t\tp.op(JUMPDEST)\n\n\treturn p.bytecode()\n\n```\n\n## VM\n\nThe vm module contais some abstractions to run arbitrary virtual machines, primarily geth `evm` and parity's `parity-evm`. \n\n\n## Etherchain\n\nThe `etherchain` package contains an API for interacting with the Etherchain API.\n\n## Reproduce\n\nAn example app is `reproduce.py` which can reproduce an on-chain transaction as a totally local event, and run it in the `evm`. \n\nThe app takes a `txhash`, and \n\n1. Fetch the transaction data from an API. \n2. Mark (source, destination) as need-to-fetch\n3. Fetch balance and nonce at source, add to `genesis`\n4. Execute transaction on the `evm`\n5. If transaction has any externally reaching ops (BALANCE, EXTCODECOPY, CALL etc), \n  * Add those accounts as need-to-fetch\n6. Go back to 3 until the execution does not result in any more accounts to be fetched. \n7. Save the transaction trace and genesis\n\n## Opviewer\n\nThe 'opviewer.py' is a simple debugger-like trace-viewer. It can be used against an `evm`-trace and navigate the data in a bit more friendly manner than raw json. \nInvoke via e.g. `python opviewer.py -f example2.json`\n\n![screenshot](https://raw.githubusercontent.com/holiman/evmlab/master/docs/example2.png)\n\n# Running it\n\nThe easiest way to get it working is to use a docker image. \n\n```\ndocker build . -t evmlab && docker run -it evmlab\n```\n\nThe docker image should also be available at hub.docker.com, as an automated build:\n\n```\ndocker pull holiman/evmlab && docker run -it holiman/evmlab\n```\n\n\n# EVM \n\n## EVM format\n\nHere's what to think about if you want to add an `evm` to evmlab. \n\n\n### Input\n\nThe `evm` should take the following inputs: \n\n* `--code <code>` - code to be executed.\n* `--codeFile <file>` - file containing code to be executed. Sometimes really large chunks of input cannot be passed through bash. \n* `--gas <int>` \n* `--price <int>` \n* `--sender <address>` - address of `ORIGIN`\n* `--receiver <address` - address of `ADDRESS`\n* `--input <code>` : `CALLDATA` \n* `--value <int>`\n* `--json` - boolean flag, output json output for each opcode or not (it's useful to disable json when benchmarking)\n* `--nomemory` - disable showing the full memory output for each op\n* `--create` - if specified, it's executed as initcode\n* `--prestate` - a chain specification, the same one that the client normally would use. \n\nBasically, the `evm` should be able to run things very simply, like so: \n\n```bash\n$evm --code 6040 --json run\n{\"pc\":0,\"op\":96,\"gas\":\"0x2540be400\",\"gasCost\":\"0x3\",\"memory\":\"0x\",\"memSize\":0,\"stack\":[],\"depth\":1,\"error\":null,\"opName\":\"PUSH1\"}\n{\"pc\":2,\"op\":0,\"gas\":\"0x2540be3fd\",\"gasCost\":\"0x0\",\"memory\":\"0x\",\"memSize\":0,\"stack\":[\"0x40\"],\"depth\":1,\"error\":null,\"opName\":\"STOP\"}\n{\"output\":\"\",\"gasUsed\":\"0x3\",\"time\":141485}\n``` \n\nBut it should also be able to reconstruct an actual on-chain transaction, with complex options including prestate, where no `code` is passed, since it's already been showed into the `prestate`: \n\n```bash\n$evm --prestate /home/martin/workspace/evmlab/output//0xd6d519-genesis-geth_wq38zsy5.json --gas 150000 --sender 0x69ea6b31ef305d6b99bb2d4c9d99456fa108b02a --receiver 0xb97048628db6b661d4c2aa833e95dbe1a905b280 --input a9059cbb0000000000000000000000008eef795fd9150f118bddeca556a5a2a2438ab865000000000000000000000000000000000000000000000081ebd8ffd6b2a58000 --json run\n\n``` \n\n### Output\n\nThe `evm` should output a `json` object for each operation. Example: \n```\n{\"pc\":0,\"op\":96,\"gas\":\"0x2540be400\",\"gasCost\":\"0x3\",\"memory\":\"0x\",\"memSize\":0,\"stack\":[],\"depth\":1,\"error\":null,\"opName\":\"PUSH1\"}\n```\n\nRequired: `pc`, `op`, `gas`, `stack`, `depth`\nOptional: `opName`, `gasCost`, `error`\n\nThe `stack`, `memory` and `memSize` are the values _before_ execution of the op. \n\nAt the end of execution, some summarical info is good, e.g. \n```\n{\"output\":\"\",\"gasUsed\":\"0x3\",\"time\":141485}\n```\n\nWhen errors occur, geth and parity handles them differently. \n\nMinor changes to how things work is ok, we can handle discrepancies in format and minor quirks. \n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/ethereum/evmlab/tarball/v0.3.0.0.1", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/ethereum/evmlab/", "keywords": "ethereum,transaction,debugger", "license": "GPLv3", "maintainer": "", "maintainer_email": "", "name": "Evmlab", "package_url": "https://pypi.org/project/Evmlab/", "platform": "", "project_url": "https://pypi.org/project/Evmlab/", "project_urls": {"Download": "https://github.com/ethereum/evmlab/tarball/v0.3.0.0.1", "Homepage": "https://github.com/ethereum/evmlab/"}, "release_url": "https://pypi.org/project/Evmlab/0.3.0.0.1/", "requires_dist": ["requests", "web3", "eth-hash[pycryptodome]", "rlp (>=1.0)", "ethereum-input-decoder; extra == 'abidecoder'", "urwid; extra == 'consolegui'", "docker (==3.0.0); extra == 'docker'"], "requires_python": "", "summary": "Ethereum EVM utilities", "version": "0.3.0.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>EVM lab utilities</h1>\n<p>This package contains various tools to interact with the Ethereum virtual machine.</p>\n<h2>Project Structure</h2>\n<table>\n<thead>\n<tr>\n<th>Folder</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>docs</td>\n<td>Project documentation</td>\n</tr>\n<tr>\n<td>evmlab</td>\n<td>The evmlab package</td>\n</tr>\n<tr>\n<td>utilities</td>\n<td>Example utilities and proof-of-concepts</td>\n</tr>\n<tr>\n<td>files</td>\n<td>Sample trace files and trace logs</td>\n</tr>\n<tr>\n<td>output</td>\n<td>output directory for artefacts</td>\n</tr>\n<tr>\n<td>templates</td>\n<td>Web application templates (currently used with reproducer)</td>\n</tr>\n<tr>\n<td>containers</td>\n<td>Docker container files</td>\n</tr></tbody></table>\n<h2>Installation</h2>\n<h4>From source:</h4>\n<p>Consider creating a virtualenv.</p>\n<pre><code>#&gt; virtualenv -p python3 .env3\n#&gt; . .env3/bin/activate\n#&gt; python3 -m pip install -r requirements.txt\n#&gt; python3 setup.py install\n#&gt; python3 -m evmlab  # verify installation\n</code></pre>\n<h4>From PIP:</h4>\n<p>TODO: publish to pip!</p>\n<pre><code>#&gt; python3 -m pip install evmlab\n#&gt; python3 -m evmlab[consolegui,abidecoder,docker]  # verify installation\n</code></pre>\n<p>EVMLab comes with a commandline utility that can be invoked by calling <code>python3 -m evmlab &lt;subcommand&gt; &lt;args&gt;</code></p>\n<h2>Compiler</h2>\n<p>The 'compiler' is a tool to build evm binaries, using a pythonic way to construct the programs using assembly.</p>\n<p>Here's an example that tests <code>ecdsaRecover</code>:</p>\n<pre>\t<span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">compiler</span><span class=\"o\">.</span><span class=\"n\">Program</span><span class=\"p\">()</span>\n\t<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">mstore</span><span class=\"p\">(</span><span class=\"mi\">0</span> <span class=\"p\">,</span><span class=\"mh\">0x38d18acb67d25c8bb9942764b62f18e17054f66a817bd4295423adf9ed98873e</span><span class=\"p\">)</span>\n\t<span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"mh\">0x000000000000000000000000000000000000000000000000000000000000001b</span>\n\t<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">mstore</span><span class=\"p\">(</span><span class=\"mi\">32</span>   <span class=\"p\">,</span> <span class=\"n\">v</span><span class=\"p\">)</span>\n\t<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">mstore</span><span class=\"p\">(</span><span class=\"mi\">64</span>   <span class=\"p\">,</span><span class=\"mh\">0x723841761d213b60ac1cbf063207cbeba6c2725bcaf7c189e63f13d93fc1dc07</span><span class=\"p\">)</span>\n\t<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">mstore</span><span class=\"p\">(</span><span class=\"mi\">96</span>   <span class=\"p\">,</span><span class=\"mh\">0x789d1dd423d25f0772d2748d60f7e4b81bb14d086eba8e8e8efb6dcff8a4ae02</span><span class=\"p\">)</span>\n\t<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">call</span><span class=\"p\">(</span><span class=\"mh\">0xfff</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mh\">0x80</span><span class=\"p\">,</span><span class=\"mh\">0x80</span><span class=\"p\">,</span><span class=\"mh\">0x20</span><span class=\"p\">)</span>\n\t<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">rreturn</span><span class=\"p\">(</span><span class=\"mi\">140</span><span class=\"p\">,</span><span class=\"mi\">20</span><span class=\"p\">)</span>\n\t<span class=\"n\">code</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">bytecode</span><span class=\"p\">()</span>\n</pre>\n<p>Here's an example of stuffing <code>JUMPDEST</code> into a program:</p>\n<pre>\t<span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">compiler</span><span class=\"o\">.</span><span class=\"n\">Program</span><span class=\"p\">()</span>\n\t<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">jump</span><span class=\"p\">(</span><span class=\"mh\">0x3</span><span class=\"p\">)</span>\n\t<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">jumpdest</span><span class=\"p\">()</span>\n\t<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">rreturn</span><span class=\"p\">()</span>\n\t<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">20000</span><span class=\"p\">):</span>\n\t\t<span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">op</span><span class=\"p\">(</span><span class=\"n\">JUMPDEST</span><span class=\"p\">)</span>\n\n\t<span class=\"k\">return</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">bytecode</span><span class=\"p\">()</span>\n</pre>\n<h2>VM</h2>\n<p>The vm module contais some abstractions to run arbitrary virtual machines, primarily geth <code>evm</code> and parity's <code>parity-evm</code>.</p>\n<h2>Etherchain</h2>\n<p>The <code>etherchain</code> package contains an API for interacting with the Etherchain API.</p>\n<h2>Reproduce</h2>\n<p>An example app is <code>reproduce.py</code> which can reproduce an on-chain transaction as a totally local event, and run it in the <code>evm</code>.</p>\n<p>The app takes a <code>txhash</code>, and</p>\n<ol>\n<li>Fetch the transaction data from an API.</li>\n<li>Mark (source, destination) as need-to-fetch</li>\n<li>Fetch balance and nonce at source, add to <code>genesis</code></li>\n<li>Execute transaction on the <code>evm</code></li>\n<li>If transaction has any externally reaching ops (BALANCE, EXTCODECOPY, CALL etc),</li>\n</ol>\n<ul>\n<li>Add those accounts as need-to-fetch</li>\n</ul>\n<ol>\n<li>Go back to 3 until the execution does not result in any more accounts to be fetched.</li>\n<li>Save the transaction trace and genesis</li>\n</ol>\n<h2>Opviewer</h2>\n<p>The 'opviewer.py' is a simple debugger-like trace-viewer. It can be used against an <code>evm</code>-trace and navigate the data in a bit more friendly manner than raw json.\nInvoke via e.g. <code>python opviewer.py -f example2.json</code></p>\n<p><img alt=\"screenshot\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/06cea9b0e4ce089fdfebcb5422c02ccbb0c8e605/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f686f6c696d616e2f65766d6c61622f6d61737465722f646f63732f6578616d706c65322e706e67\"></p>\n<h1>Running it</h1>\n<p>The easiest way to get it working is to use a docker image.</p>\n<pre><code>docker build . -t evmlab &amp;&amp; docker run -it evmlab\n</code></pre>\n<p>The docker image should also be available at hub.docker.com, as an automated build:</p>\n<pre><code>docker pull holiman/evmlab &amp;&amp; docker run -it holiman/evmlab\n</code></pre>\n<h1>EVM</h1>\n<h2>EVM format</h2>\n<p>Here's what to think about if you want to add an <code>evm</code> to evmlab.</p>\n<h3>Input</h3>\n<p>The <code>evm</code> should take the following inputs:</p>\n<ul>\n<li><code>--code &lt;code&gt;</code> - code to be executed.</li>\n<li><code>--codeFile &lt;file&gt;</code> - file containing code to be executed. Sometimes really large chunks of input cannot be passed through bash.</li>\n<li><code>--gas &lt;int&gt;</code></li>\n<li><code>--price &lt;int&gt;</code></li>\n<li><code>--sender &lt;address&gt;</code> - address of <code>ORIGIN</code></li>\n<li><code>--receiver &lt;address</code> - address of <code>ADDRESS</code></li>\n<li><code>--input &lt;code&gt;</code> : <code>CALLDATA</code></li>\n<li><code>--value &lt;int&gt;</code></li>\n<li><code>--json</code> - boolean flag, output json output for each opcode or not (it's useful to disable json when benchmarking)</li>\n<li><code>--nomemory</code> - disable showing the full memory output for each op</li>\n<li><code>--create</code> - if specified, it's executed as initcode</li>\n<li><code>--prestate</code> - a chain specification, the same one that the client normally would use.</li>\n</ul>\n<p>Basically, the <code>evm</code> should be able to run things very simply, like so:</p>\n<pre><span class=\"nv\">$evm</span> --code <span class=\"m\">6040</span> --json run\n<span class=\"o\">{</span><span class=\"s2\">\"pc\"</span>:0,<span class=\"s2\">\"op\"</span>:96,<span class=\"s2\">\"gas\"</span>:<span class=\"s2\">\"0x2540be400\"</span>,<span class=\"s2\">\"gasCost\"</span>:<span class=\"s2\">\"0x3\"</span>,<span class=\"s2\">\"memory\"</span>:<span class=\"s2\">\"0x\"</span>,<span class=\"s2\">\"memSize\"</span>:0,<span class=\"s2\">\"stack\"</span>:<span class=\"o\">[]</span>,<span class=\"s2\">\"depth\"</span>:1,<span class=\"s2\">\"error\"</span>:null,<span class=\"s2\">\"opName\"</span>:<span class=\"s2\">\"PUSH1\"</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"s2\">\"pc\"</span>:2,<span class=\"s2\">\"op\"</span>:0,<span class=\"s2\">\"gas\"</span>:<span class=\"s2\">\"0x2540be3fd\"</span>,<span class=\"s2\">\"gasCost\"</span>:<span class=\"s2\">\"0x0\"</span>,<span class=\"s2\">\"memory\"</span>:<span class=\"s2\">\"0x\"</span>,<span class=\"s2\">\"memSize\"</span>:0,<span class=\"s2\">\"stack\"</span>:<span class=\"o\">[</span><span class=\"s2\">\"0x40\"</span><span class=\"o\">]</span>,<span class=\"s2\">\"depth\"</span>:1,<span class=\"s2\">\"error\"</span>:null,<span class=\"s2\">\"opName\"</span>:<span class=\"s2\">\"STOP\"</span><span class=\"o\">}</span>\n<span class=\"o\">{</span><span class=\"s2\">\"output\"</span>:<span class=\"s2\">\"\"</span>,<span class=\"s2\">\"gasUsed\"</span>:<span class=\"s2\">\"0x3\"</span>,<span class=\"s2\">\"time\"</span>:141485<span class=\"o\">}</span>\n</pre>\n<p>But it should also be able to reconstruct an actual on-chain transaction, with complex options including prestate, where no <code>code</code> is passed, since it's already been showed into the <code>prestate</code>:</p>\n<pre><span class=\"nv\">$evm</span> --prestate /home/martin/workspace/evmlab/output//0xd6d519-genesis-geth_wq38zsy5.json --gas <span class=\"m\">150000</span> --sender 0x69ea6b31ef305d6b99bb2d4c9d99456fa108b02a --receiver 0xb97048628db6b661d4c2aa833e95dbe1a905b280 --input a9059cbb0000000000000000000000008eef795fd9150f118bddeca556a5a2a2438ab865000000000000000000000000000000000000000000000081ebd8ffd6b2a58000 --json run\n</pre>\n<h3>Output</h3>\n<p>The <code>evm</code> should output a <code>json</code> object for each operation. Example:</p>\n<pre><code>{\"pc\":0,\"op\":96,\"gas\":\"0x2540be400\",\"gasCost\":\"0x3\",\"memory\":\"0x\",\"memSize\":0,\"stack\":[],\"depth\":1,\"error\":null,\"opName\":\"PUSH1\"}\n</code></pre>\n<p>Required: <code>pc</code>, <code>op</code>, <code>gas</code>, <code>stack</code>, <code>depth</code>\nOptional: <code>opName</code>, <code>gasCost</code>, <code>error</code></p>\n<p>The <code>stack</code>, <code>memory</code> and <code>memSize</code> are the values <em>before</em> execution of the op.</p>\n<p>At the end of execution, some summarical info is good, e.g.</p>\n<pre><code>{\"output\":\"\",\"gasUsed\":\"0x3\",\"time\":141485}\n</code></pre>\n<p>When errors occur, geth and parity handles them differently.</p>\n<p>Minor changes to how things work is ok, we can handle discrepancies in format and minor quirks.</p>\n\n          </div>"}, "last_serial": 4162259, "releases": {"0.3.0.0.1": [{"comment_text": "", "digests": {"md5": "754eb6ca11bda07f2097f390a6ad1dbd", "sha256": "1b7e91ea48e8372bbf4acdf2cdeb25c033de28a59167af49579346145b357553"}, "downloads": -1, "filename": "Evmlab-0.3.0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "754eb6ca11bda07f2097f390a6ad1dbd", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 48878, "upload_time": "2018-08-10T18:15:42", "upload_time_iso_8601": "2018-08-10T18:15:42.874234Z", "url": "https://files.pythonhosted.org/packages/fd/52/eb6cf263afe4dd6d1e039e03def838b2c4968d56003e16c59d88969f6956/Evmlab-0.3.0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "75befb7e053f651ffe9a5685cb789a14", "sha256": "c94f2dd67fd1a43e69af5eb36d74d7404bc0259910d049df768f8d4d3991b436"}, "downloads": -1, "filename": "Evmlab-0.3.0.0.1.tar.gz", "has_sig": false, "md5_digest": "75befb7e053f651ffe9a5685cb789a14", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42902, "upload_time": "2018-08-10T18:15:44", "upload_time_iso_8601": "2018-08-10T18:15:44.157305Z", "url": "https://files.pythonhosted.org/packages/f8/45/c77563be448382270b0b9b44de13bb3eb0ddd4a29f9f62bca0dfe408e085/Evmlab-0.3.0.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "754eb6ca11bda07f2097f390a6ad1dbd", "sha256": "1b7e91ea48e8372bbf4acdf2cdeb25c033de28a59167af49579346145b357553"}, "downloads": -1, "filename": "Evmlab-0.3.0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "754eb6ca11bda07f2097f390a6ad1dbd", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 48878, "upload_time": "2018-08-10T18:15:42", "upload_time_iso_8601": "2018-08-10T18:15:42.874234Z", "url": "https://files.pythonhosted.org/packages/fd/52/eb6cf263afe4dd6d1e039e03def838b2c4968d56003e16c59d88969f6956/Evmlab-0.3.0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "75befb7e053f651ffe9a5685cb789a14", "sha256": "c94f2dd67fd1a43e69af5eb36d74d7404bc0259910d049df768f8d4d3991b436"}, "downloads": -1, "filename": "Evmlab-0.3.0.0.1.tar.gz", "has_sig": false, "md5_digest": "75befb7e053f651ffe9a5685cb789a14", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42902, "upload_time": "2018-08-10T18:15:44", "upload_time_iso_8601": "2018-08-10T18:15:44.157305Z", "url": "https://files.pythonhosted.org/packages/f8/45/c77563be448382270b0b9b44de13bb3eb0ddd4a29f9f62bca0dfe408e085/Evmlab-0.3.0.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:45:07 2020"}