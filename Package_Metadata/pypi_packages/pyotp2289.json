{"info": {"author": "Simeon Simeonov", "author_email": "sgs@pichove.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Programming Language :: Python :: 3 :: Only", "Programming Language :: Python :: Implementation", "Topic :: Security :: Cryptography"], "description": "# pyotp2289\n\npyotp2289 is a pure Python 3 implementation of \"A One-Time Password System\" -\nRFC-2289.\n\nIt requires no additional libraries.\n\n\n## General\n\nThe main reason for writing this library was the need to login into my\nFreeBSD servers using the [opiepasswd](https://www.freebsd.org/cgi/man.cgi?query=opiepasswd&sektion=1&manpath=freebsd-release-ports)\nas described in [FreeBSD Handbook](https://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/one-time-passwords.html).\n\nI decided to license the library under the\n[Simplified BSD License / 2-clause BSD license](https://github.com/blackm0re/pyotp2289/blob/master/LICENSE) and not under the\n(L)GPL-3 as I usually do.\n\nI hope that somebody will find it useful.\n\n\n## Installation\n\n   ```bash\n   pip install pyotp2289\n   ```\n\n\n## Overview of RFC-2289\n\nRFC-2289 describes a one-time password authentication system (OTP):\n\n\"The system provides authentication for system access (login) and other\napplications requiring authentication that is secure against passive attacks\nbased on replaying captured reusable passwords. OTP evolved from the S/KEY\n(S/KEY is a trademark of Bellcore) One-Time Password System that was released\nby Bellcore.\"\n\n\"One form of attack on networked computing systems is eavesdropping on\nnetwork connections to obtain authentication information such as the\nlogin IDs and passwords of legitimate users. Once this information is\ncaptured, it can be used at a later time to gain access to the\nsystem. One-time password systems are designed to counter this type\nof attack, called a 'replay attack'.\"\n\nThe authentication system described in RFC-2289 \"uses a secret\npass-phrase to generate a sequence of one-time (single use)\npasswords.  With this system, the user's secret pass-phrase never\nneeds to cross the network at any time such as during authentication\nor during pass-phrase changes. Thus, it is not vulnerable to replay\nattacks.  Added security is provided by the property that no secret\ninformation need be stored on any system, including the server being\nprotected.\"\n\n\"There are two entities in the operation of the OTP one-time password\nsystem. The **generator** must produce the appropriate one-time password\nfrom the user's secret pass-phrase and from information provided in\nthe **challenge** from the **server**. The server must send a challenge that\nincludes the appropriate generation parameters to the generator, must\nverify the one-time password received, must store the last valid\none-time password it received, and must store the corresponding one-\ntime password sequence number. The server must also facilitate the\nchanging of the user's secret pass-phrase in a secure manner.\"\n\n\"The OTP system generator passes the user's secret pass-phrase, along\nwith a seed received from the server as part of the challenge,\nthrough multiple iterations of a secure hash function to produce a\none-time password. After each successful authentication, the number\nof secure hash function iterations is reduced by one.  Thus, a unique\nsequence of passwords is generated.  The server verifies the one-time\npassword received from the generator by computing the secure hash\nfunction once and comparing the result with the previously accepted\none-time password.\"\n\n\n## Examples\n\nWe define the two entities: *client* and *server*. The entire application of\nRFC-2289 consists of interactions between them.\n\n   ```python\n   import getpass  # client only\n\n   import otp2289  # client and server\n\n   # the server starts by picking:\n   # - algorithm (MD5 or SHA1) to use\n   # - seed - 1 to 16 alphanumeric characters. The seed must never be reused.\n   # - initial step - number (int) that will be decremented for each OTP.\n   # In FreeBSD, the following default values are used:\n   # - MD5\n   # - the first two letters of the hostname + 5 random digits for seed\n   # - initial step: 500\n\n   # the client receives those values, chooses a strong password and creates\n   # initialization digest (hash). The password 'This is a test.' will give you\n   # the same results as in the following example.\n   passwd_bytes = getpass.getpass().encode()  # Fetch the password as bytes\n   generator = otp2289.generator.OTPGenerator(passwd_bytes,\n                                              'TesT',\n                                              otp2289.OTP_ALGO_MD5)\n   digest = generator.generate_otp_hexdigest(500)\n   # digest is now: 0x2b8d82b6ac14346c\n   # the client sends it to the server\n\n   # the server creates the first state. Note that step is decremented by 1:\n   state = otp2289.server.OTPState(digest, 499, 'TesT', otp2289.OTP_ALGO_MD5)\n   # the state can be stored in a OTPStore container:\n   store = otp2289.server.OTPStore()\n   # key can be any str that can be used to reference the state (f.i username)\n   store.add_state('myusername', state)  # where key can be any str that can be\n   # OTPStore is provided only for convenience as it is not part of RFC-2289.\n   # The server can store states any way it wants. A normal dict is also fine.\n   # Once the initial state is set on the server, the client can authenticate.\n\n   # Upon authentication request (f.i. login), the server issues a challenge\n   # based on the state:\n   challenge = state.challenge_string  # challenge is now 'otp-md5 499 TesT '\n\n   # the client can now respond by using (or recreating) the same generator\n   # created earlier. RFC-2289 defines two types of responses:\n   # - hex (like '0x2b8d82b6ac14346c') - more suited for automation\n   # - tokens consisting of 6 short words - better when responding manually\n   hex_response = generator.generate_otp_hexdigest(499)  # '0x6323f96296a2526b'\n   token_response = generator.generate_otp_words(499)\n   # token_response is now: 'CANT JAW BITS NU LO PUP'\n   # a possible shortcut may be to use the challenge-string directly:\n   hex_response = generator.generate_otp_hexdigest_from_challenge(challenge)\n   token_response = generator.generate_otp_words_from_challenge(challenge)\n   # ... giving the same results.\n\n   # once the response is received, the server validates it by yet again using\n   # the current state:\n   result = state.response_validates(hex_response)\n   # or\n   result = state.response_validates(token_response)\n   # result should be True if the response matches the state, False if not\n   # in case of invalid response or response checksum doesn't match, a\n   # otp2289.server.OTPInvalidResponse exception is raised.\n\n   # once the state has successfully validated the corresponding response,\n   the state **must never be used again** and a state corresponding to the\n   \"next\" (498) step created.\n   state = state.get_next_state()\n\n   # the next authentication attempt...\n   challenge = state.challenge_string  # challenge is now 'otp-md5 498 TesT '\n   # ... and on the client side...\n   hex_response = generator.generate_otp_hexdigest_from_challenge(challenge)\n   # etc. etc...\n   ```\n\nPlease visit the\n[API documentation](http://gnulover.simeonov.no/docs/api/pyotp2289/latest/) for\na complete reference.\n\nIf you don't care about developing applications in Python and only care about\ngenerating one-time passwords (tokens / hex digests) and authenticating with\nexisting solutions (f.i. FreeBSD servers), pyotp2289 comes with a simple CLI:\n\n   ```bash\n   python -m otp2289 --generate-otp-response -f token -i 498 -s TesT\n   ```\n\n... will prompt for password and generate a 6 words (token) response.\n\n   ```bash\n   python -m otp2289 --generate-otp-range -f token -i 498 -s TesT\n   ```\n\n... will prompt for password and generate a range of 4 one-time passwords\nstarting from (and including) 498.\n\n\n## Support and contributing\n\npyotp2289 is hosted on GitHub: https://github.com/blackm0re/pyotp2289\n\n\n## Author\n\nSimeon Simeonov - sgs @ Freenode\n\n\n## [License](https://github.com/blackm0re/pyotp2289/blob/master/LICENSE)\n\nCopyright (c) 2020, Simeon Simeonov\nAll rights reserved.\n\n[Licensed](https://github.com/blackm0re/pyotp2289/blob/master/LICENSE) under the BSD 2-clause.\nSPDX-License-Identifier: BSD-2-Clause-FreeBSD\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/blackm0re/pyotp2289", "keywords": "2289 freebsd unix security cryptography otp password", "license": "BSD 2-Clause", "maintainer": "", "maintainer_email": "", "name": "pyotp2289", "package_url": "https://pypi.org/project/pyotp2289/", "platform": "", "project_url": "https://pypi.org/project/pyotp2289/", "project_urls": {"API Documentation": "http://gnulover.simeonov.no/docs/api/pyotp2289/latest/", "Bug Reports": "https://github.com/blackm0re/pyotp2289/issues", "Homepage": "https://github.com/blackm0re/pyotp2289", "Source": "https://github.com/blackm0re/pyotp2289"}, "release_url": "https://pypi.org/project/pyotp2289/1.0.0/", "requires_dist": null, "requires_python": ">=3.6", "summary": "A pure Python implementation of \"A One-Time Password System\"", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>pyotp2289</h1>\n<p>pyotp2289 is a pure Python 3 implementation of \"A One-Time Password System\" -\nRFC-2289.</p>\n<p>It requires no additional libraries.</p>\n<h2>General</h2>\n<p>The main reason for writing this library was the need to login into my\nFreeBSD servers using the <a href=\"https://www.freebsd.org/cgi/man.cgi?query=opiepasswd&amp;sektion=1&amp;manpath=freebsd-release-ports\" rel=\"nofollow\">opiepasswd</a>\nas described in <a href=\"https://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/one-time-passwords.html\" rel=\"nofollow\">FreeBSD Handbook</a>.</p>\n<p>I decided to license the library under the\n<a href=\"https://github.com/blackm0re/pyotp2289/blob/master/LICENSE\" rel=\"nofollow\">Simplified BSD License / 2-clause BSD license</a> and not under the\n(L)GPL-3 as I usually do.</p>\n<p>I hope that somebody will find it useful.</p>\n<h2>Installation</h2>\n<pre>pip install pyotp2289\n</pre>\n<h2>Overview of RFC-2289</h2>\n<p>RFC-2289 describes a one-time password authentication system (OTP):</p>\n<p>\"The system provides authentication for system access (login) and other\napplications requiring authentication that is secure against passive attacks\nbased on replaying captured reusable passwords. OTP evolved from the S/KEY\n(S/KEY is a trademark of Bellcore) One-Time Password System that was released\nby Bellcore.\"</p>\n<p>\"One form of attack on networked computing systems is eavesdropping on\nnetwork connections to obtain authentication information such as the\nlogin IDs and passwords of legitimate users. Once this information is\ncaptured, it can be used at a later time to gain access to the\nsystem. One-time password systems are designed to counter this type\nof attack, called a 'replay attack'.\"</p>\n<p>The authentication system described in RFC-2289 \"uses a secret\npass-phrase to generate a sequence of one-time (single use)\npasswords.  With this system, the user's secret pass-phrase never\nneeds to cross the network at any time such as during authentication\nor during pass-phrase changes. Thus, it is not vulnerable to replay\nattacks.  Added security is provided by the property that no secret\ninformation need be stored on any system, including the server being\nprotected.\"</p>\n<p>\"There are two entities in the operation of the OTP one-time password\nsystem. The <strong>generator</strong> must produce the appropriate one-time password\nfrom the user's secret pass-phrase and from information provided in\nthe <strong>challenge</strong> from the <strong>server</strong>. The server must send a challenge that\nincludes the appropriate generation parameters to the generator, must\nverify the one-time password received, must store the last valid\none-time password it received, and must store the corresponding one-\ntime password sequence number. The server must also facilitate the\nchanging of the user's secret pass-phrase in a secure manner.\"</p>\n<p>\"The OTP system generator passes the user's secret pass-phrase, along\nwith a seed received from the server as part of the challenge,\nthrough multiple iterations of a secure hash function to produce a\none-time password. After each successful authentication, the number\nof secure hash function iterations is reduced by one.  Thus, a unique\nsequence of passwords is generated.  The server verifies the one-time\npassword received from the generator by computing the secure hash\nfunction once and comparing the result with the previously accepted\none-time password.\"</p>\n<h2>Examples</h2>\n<p>We define the two entities: <em>client</em> and <em>server</em>. The entire application of\nRFC-2289 consists of interactions between them.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">getpass</span>  <span class=\"c1\"># client only</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">otp2289</span>  <span class=\"c1\"># client and server</span>\n\n<span class=\"c1\"># the server starts by picking:</span>\n<span class=\"c1\"># - algorithm (MD5 or SHA1) to use</span>\n<span class=\"c1\"># - seed - 1 to 16 alphanumeric characters. The seed must never be reused.</span>\n<span class=\"c1\"># - initial step - number (int) that will be decremented for each OTP.</span>\n<span class=\"c1\"># In FreeBSD, the following default values are used:</span>\n<span class=\"c1\"># - MD5</span>\n<span class=\"c1\"># - the first two letters of the hostname + 5 random digits for seed</span>\n<span class=\"c1\"># - initial step: 500</span>\n\n<span class=\"c1\"># the client receives those values, chooses a strong password and creates</span>\n<span class=\"c1\"># initialization digest (hash). The password 'This is a test.' will give you</span>\n<span class=\"c1\"># the same results as in the following example.</span>\n<span class=\"n\">passwd_bytes</span> <span class=\"o\">=</span> <span class=\"n\">getpass</span><span class=\"o\">.</span><span class=\"n\">getpass</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">()</span>  <span class=\"c1\"># Fetch the password as bytes</span>\n<span class=\"n\">generator</span> <span class=\"o\">=</span> <span class=\"n\">otp2289</span><span class=\"o\">.</span><span class=\"n\">generator</span><span class=\"o\">.</span><span class=\"n\">OTPGenerator</span><span class=\"p\">(</span><span class=\"n\">passwd_bytes</span><span class=\"p\">,</span>\n                                           <span class=\"s1\">'TesT'</span><span class=\"p\">,</span>\n                                           <span class=\"n\">otp2289</span><span class=\"o\">.</span><span class=\"n\">OTP_ALGO_MD5</span><span class=\"p\">)</span>\n<span class=\"n\">digest</span> <span class=\"o\">=</span> <span class=\"n\">generator</span><span class=\"o\">.</span><span class=\"n\">generate_otp_hexdigest</span><span class=\"p\">(</span><span class=\"mi\">500</span><span class=\"p\">)</span>\n<span class=\"c1\"># digest is now: 0x2b8d82b6ac14346c</span>\n<span class=\"c1\"># the client sends it to the server</span>\n\n<span class=\"c1\"># the server creates the first state. Note that step is decremented by 1:</span>\n<span class=\"n\">state</span> <span class=\"o\">=</span> <span class=\"n\">otp2289</span><span class=\"o\">.</span><span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">OTPState</span><span class=\"p\">(</span><span class=\"n\">digest</span><span class=\"p\">,</span> <span class=\"mi\">499</span><span class=\"p\">,</span> <span class=\"s1\">'TesT'</span><span class=\"p\">,</span> <span class=\"n\">otp2289</span><span class=\"o\">.</span><span class=\"n\">OTP_ALGO_MD5</span><span class=\"p\">)</span>\n<span class=\"c1\"># the state can be stored in a OTPStore container:</span>\n<span class=\"n\">store</span> <span class=\"o\">=</span> <span class=\"n\">otp2289</span><span class=\"o\">.</span><span class=\"n\">server</span><span class=\"o\">.</span><span class=\"n\">OTPStore</span><span class=\"p\">()</span>\n<span class=\"c1\"># key can be any str that can be used to reference the state (f.i username)</span>\n<span class=\"n\">store</span><span class=\"o\">.</span><span class=\"n\">add_state</span><span class=\"p\">(</span><span class=\"s1\">'myusername'</span><span class=\"p\">,</span> <span class=\"n\">state</span><span class=\"p\">)</span>  <span class=\"c1\"># where key can be any str that can be</span>\n<span class=\"c1\"># OTPStore is provided only for convenience as it is not part of RFC-2289.</span>\n<span class=\"c1\"># The server can store states any way it wants. A normal dict is also fine.</span>\n<span class=\"c1\"># Once the initial state is set on the server, the client can authenticate.</span>\n\n<span class=\"c1\"># Upon authentication request (f.i. login), the server issues a challenge</span>\n<span class=\"c1\"># based on the state:</span>\n<span class=\"n\">challenge</span> <span class=\"o\">=</span> <span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">challenge_string</span>  <span class=\"c1\"># challenge is now 'otp-md5 499 TesT '</span>\n\n<span class=\"c1\"># the client can now respond by using (or recreating) the same generator</span>\n<span class=\"c1\"># created earlier. RFC-2289 defines two types of responses:</span>\n<span class=\"c1\"># - hex (like '0x2b8d82b6ac14346c') - more suited for automation</span>\n<span class=\"c1\"># - tokens consisting of 6 short words - better when responding manually</span>\n<span class=\"n\">hex_response</span> <span class=\"o\">=</span> <span class=\"n\">generator</span><span class=\"o\">.</span><span class=\"n\">generate_otp_hexdigest</span><span class=\"p\">(</span><span class=\"mi\">499</span><span class=\"p\">)</span>  <span class=\"c1\"># '0x6323f96296a2526b'</span>\n<span class=\"n\">token_response</span> <span class=\"o\">=</span> <span class=\"n\">generator</span><span class=\"o\">.</span><span class=\"n\">generate_otp_words</span><span class=\"p\">(</span><span class=\"mi\">499</span><span class=\"p\">)</span>\n<span class=\"c1\"># token_response is now: 'CANT JAW BITS NU LO PUP'</span>\n<span class=\"c1\"># a possible shortcut may be to use the challenge-string directly:</span>\n<span class=\"n\">hex_response</span> <span class=\"o\">=</span> <span class=\"n\">generator</span><span class=\"o\">.</span><span class=\"n\">generate_otp_hexdigest_from_challenge</span><span class=\"p\">(</span><span class=\"n\">challenge</span><span class=\"p\">)</span>\n<span class=\"n\">token_response</span> <span class=\"o\">=</span> <span class=\"n\">generator</span><span class=\"o\">.</span><span class=\"n\">generate_otp_words_from_challenge</span><span class=\"p\">(</span><span class=\"n\">challenge</span><span class=\"p\">)</span>\n<span class=\"c1\"># ... giving the same results.</span>\n\n<span class=\"c1\"># once the response is received, the server validates it by yet again using</span>\n<span class=\"c1\"># the current state:</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">response_validates</span><span class=\"p\">(</span><span class=\"n\">hex_response</span><span class=\"p\">)</span>\n<span class=\"c1\"># or</span>\n<span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">response_validates</span><span class=\"p\">(</span><span class=\"n\">token_response</span><span class=\"p\">)</span>\n<span class=\"c1\"># result should be True if the response matches the state, False if not</span>\n<span class=\"c1\"># in case of invalid response or response checksum doesn't match, a</span>\n<span class=\"c1\"># otp2289.server.OTPInvalidResponse exception is raised.</span>\n\n<span class=\"c1\"># once the state has successfully validated the corresponding response,</span>\n<span class=\"n\">the</span> <span class=\"n\">state</span> <span class=\"o\">**</span><span class=\"n\">must</span> <span class=\"n\">never</span> <span class=\"n\">be</span> <span class=\"n\">used</span> <span class=\"n\">again</span><span class=\"o\">**</span> <span class=\"ow\">and</span> <span class=\"n\">a</span> <span class=\"n\">state</span> <span class=\"n\">corresponding</span> <span class=\"n\">to</span> <span class=\"n\">the</span>\n<span class=\"s2\">\"next\"</span> <span class=\"p\">(</span><span class=\"mi\">498</span><span class=\"p\">)</span> <span class=\"n\">step</span> <span class=\"n\">created</span><span class=\"o\">.</span>\n<span class=\"n\">state</span> <span class=\"o\">=</span> <span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">get_next_state</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># the next authentication attempt...</span>\n<span class=\"n\">challenge</span> <span class=\"o\">=</span> <span class=\"n\">state</span><span class=\"o\">.</span><span class=\"n\">challenge_string</span>  <span class=\"c1\"># challenge is now 'otp-md5 498 TesT '</span>\n<span class=\"c1\"># ... and on the client side...</span>\n<span class=\"n\">hex_response</span> <span class=\"o\">=</span> <span class=\"n\">generator</span><span class=\"o\">.</span><span class=\"n\">generate_otp_hexdigest_from_challenge</span><span class=\"p\">(</span><span class=\"n\">challenge</span><span class=\"p\">)</span>\n<span class=\"c1\"># etc. etc...</span>\n</pre>\n<p>Please visit the\n<a href=\"http://gnulover.simeonov.no/docs/api/pyotp2289/latest/\" rel=\"nofollow\">API documentation</a> for\na complete reference.</p>\n<p>If you don't care about developing applications in Python and only care about\ngenerating one-time passwords (tokens / hex digests) and authenticating with\nexisting solutions (f.i. FreeBSD servers), pyotp2289 comes with a simple CLI:</p>\n<pre>python -m otp2289 --generate-otp-response -f token -i <span class=\"m\">498</span> -s TesT\n</pre>\n<p>... will prompt for password and generate a 6 words (token) response.</p>\n<pre>python -m otp2289 --generate-otp-range -f token -i <span class=\"m\">498</span> -s TesT\n</pre>\n<p>... will prompt for password and generate a range of 4 one-time passwords\nstarting from (and including) 498.</p>\n<h2>Support and contributing</h2>\n<p>pyotp2289 is hosted on GitHub: <a href=\"https://github.com/blackm0re/pyotp2289\" rel=\"nofollow\">https://github.com/blackm0re/pyotp2289</a></p>\n<h2>Author</h2>\n<p>Simeon Simeonov - sgs @ Freenode</p>\n<h2><a href=\"https://github.com/blackm0re/pyotp2289/blob/master/LICENSE\" rel=\"nofollow\">License</a></h2>\n<p>Copyright (c) 2020, Simeon Simeonov\nAll rights reserved.</p>\n<p><a href=\"https://github.com/blackm0re/pyotp2289/blob/master/LICENSE\" rel=\"nofollow\">Licensed</a> under the BSD 2-clause.\nSPDX-License-Identifier: BSD-2-Clause-FreeBSD</p>\n\n          </div>"}, "last_serial": 6971563, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "84bdee88cb9efe396184d8a083fcb7d1", "sha256": "6e080ae9c21af61986316c64463944d91ec3e6fcf4eaac2aed2a0c08c52358e8"}, "downloads": -1, "filename": "pyotp2289-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "84bdee88cb9efe396184d8a083fcb7d1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 25529, "upload_time": "2020-04-07T17:18:41", "upload_time_iso_8601": "2020-04-07T17:18:41.126193Z", "url": "https://files.pythonhosted.org/packages/40/a2/923887691d2805f03f5de787845847a1c13bfc879339c2c4a3ed36ded8ca/pyotp2289-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5286977750e33ff6746367ba0c2ed024", "sha256": "c37b4a50726a1d57e1f3ef0f05169f4b0b6e7d9baed7335acfbcf4a2eb7432c4"}, "downloads": -1, "filename": "pyotp2289-1.0.0.tar.gz", "has_sig": false, "md5_digest": "5286977750e33ff6746367ba0c2ed024", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 30245, "upload_time": "2020-04-07T17:18:43", "upload_time_iso_8601": "2020-04-07T17:18:43.384665Z", "url": "https://files.pythonhosted.org/packages/db/8e/9125aad53441d1959180eec4db7f34dd2452c984d46c0176f500f8411616/pyotp2289-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "84bdee88cb9efe396184d8a083fcb7d1", "sha256": "6e080ae9c21af61986316c64463944d91ec3e6fcf4eaac2aed2a0c08c52358e8"}, "downloads": -1, "filename": "pyotp2289-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "84bdee88cb9efe396184d8a083fcb7d1", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 25529, "upload_time": "2020-04-07T17:18:41", "upload_time_iso_8601": "2020-04-07T17:18:41.126193Z", "url": "https://files.pythonhosted.org/packages/40/a2/923887691d2805f03f5de787845847a1c13bfc879339c2c4a3ed36ded8ca/pyotp2289-1.0.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5286977750e33ff6746367ba0c2ed024", "sha256": "c37b4a50726a1d57e1f3ef0f05169f4b0b6e7d9baed7335acfbcf4a2eb7432c4"}, "downloads": -1, "filename": "pyotp2289-1.0.0.tar.gz", "has_sig": false, "md5_digest": "5286977750e33ff6746367ba0c2ed024", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 30245, "upload_time": "2020-04-07T17:18:43", "upload_time_iso_8601": "2020-04-07T17:18:43.384665Z", "url": "https://files.pythonhosted.org/packages/db/8e/9125aad53441d1959180eec4db7f34dd2452c984d46c0176f500f8411616/pyotp2289-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:00:03 2020"}