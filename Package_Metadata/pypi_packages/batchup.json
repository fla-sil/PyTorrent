{"info": {"author": "Geoffrey French", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3.6", "Topic :: Scientific/Engineering :: Artificial Intelligence"], "description": "# BatchUp\nPython library for extracting mini-batches of data from a data source for the purpose of training neural networks.\n\nQuick example:\n\n```py3\nfrom batchup import data_source\n\n# Construct an array data source\nds = data_source.ArrayDataSource([train_X, train_y])\n\n# Iterate over samples, drawing batches of 64 elements in random order\nfor (batch_X, batch_y) in ds.batch_iterator(batch_size=64, shuffle=True):\n    # Processes batches here...\n```\n\nDocumentation available at https://batchup.readthedocs.io\n\n\n# Table of Contents\n\n#### Installation\n\n#### Batch iteration\nProcessing data in mini-batches:\n- quick batch iteration; a basic example\n- iterating over subsets identified by indices\n- data augmentation\n- including sample indices in the mini-batches\n- infinite batch iteration; an iterator that generates batches endlessly\n- sample weighting to alter likelihood of samples (e.g. to compensate for class imbalance)\n- iterating over two data sets simultaneously where their sizes differ (e.g. for semi-supervised learning)\n- iterating over data sets that are NOT stored as NumPy arrays (e.g. on disk or generated on the fly)\n- parallel processing to speed up iteration where loading/preparing samples could be slow\n\n#### Gathering results and loss values\n- removing the for-loop; predict values for samples in one line\n- computing mean loss/error values\n\n#### Standard datasets\nBatchUp supports some standard machine learning datasets. They will be automatically downloaded if necessary.\n- MNIST\n- SVHN\n- CIFAR-10\n- CIFAR-100\n- STL\n- USPS\n\n#### Configuring BatchUp\nData paths, etc.\n\nMore details further down, but briefly, use either the `~/.batchup.cfg` configuration file or the `BATCHUP_HOME` environment varible.\n\n\n## Installation\n\nYou can install BatchUp with:\n\n```> pip install batchup```\n\n## Batch iteration\n### Quick batch iteration\n\nAssume we have a training set loaded in the variables `train_X` and `train_y`:\n\n```py3\nfrom batchup import data_source\n\n# Construct an array data source\nds = data_source.ArrayDataSource([train_X, train_y])\n\n# Iterate over samples, drawing batches of 64 elements in random order\nfor (batch_X, batch_y) in ds.batch_iterator(batch_size=64, shuffle=np.random.RandomState(12345)):\n    # Processes batches here...\n```\n\nSome notes:\n- the last batch will be short (have less samples than the requested batch size) if there isn't enough data to fill it.\n- using `shuffle=True` will use NumPy's default random number generator\n- not specifying shuffle will process the samples in-order\n\n### Iterating over subsets identified by indices\n\nWe can specify the indices of a subset of the samples in a dataset and draw mini-batches from only those samples:\n\n```py3\nimport numpy as np\n\n# Randomly choose a subset of 20,000 samples, by indices\nsubset_a = np.random.permutation(train_X.shape[0])[:20000]\n\n# Construct an array data source that will only draw samples whose indices are in `subset_a`\nds = data_source.ArrayDataSource([train_X, train_y], indices=subset_a)\n\n# Drawing batches of 64 elements in random order\nfor (batch_X, batch_y) in ds.batch_iterator(batch_size=64, shuffle=np.random.RandomState(12345)):\n    # Processes batches here...\n```\n\n### Data augmentation\n\nWe can define a function that applies data augmentation on the fly. Let's assume that `train_X` contains image data,\nhas the shape `(sample, channel, height, width)` and that we wish to horizontally flip some of the images:\n\n```py3\nimport numpy as np\n\n# Define our batch augmentation function.\ndef augment_batch(batch_X, batch_y):\n    # Create an array that selects samples with 50% probability and convert to `bool` dtype\n    flip_flags = np.random.binomial(1, 0.5, size=(len(batch_X),)) != 0\n\n    # Flip the width dimension in selected samples\n    batch_X[flip_flags, ...] = flip_flags[flip_flags, :, :, ::-1]\n\n    # Return the batch as a tuple\n    return batch_X, batch_y\n\n# Construct an array data source that will only draw samples whose indices are in `subset_a`\nds = data_source.ArrayDataSource([train_X, train_y])\n\n# Apply augmentation\nds = ds.map(augment_batch)\n\n# Drawing batches of 64 elements in random order\nfor (batch_X, batch_y) in ds.batch_iterator(batch_size=64, shuffle=np.random.RandomState(12345)):\n    # Processes batches here...\n```\n\nMore complex augmentation may incurr significant runtime cost. This can be alleviated by preparing batches\nin background threads. See the *parallel processing* section below.\n\n### Including sample indices in the mini-batches\n\nWe can ask to be provided with the indices of the samples that were drawn to form the mini-batch:\n\n```py3\n# Construct an array data source that will provide sample indices\nds = data_source.ArrayDataSource([train_X, train_y], include_indices=True)\n\n# Drawing batches of 64 elements in random order\nfor (batch_ndx, batch_X, batch_y) in ds.batch_iterator(batch_size=64, shuffle=np.random.RandomState(12345)):\n    # Processes batches here...\n```\n\n### Infinite batch iteration\n\nLets say you need an iterator that extracts samples from your dataset and starts from the beginning when it reaches the end:\n\n```py3\nds = data_source.ArrayDataSource([train_X, train_y], repeats=-1)\n```\n\nNow use the `batch_iterator` method as before.\n\nThe `repeats` parameter accepts either `-1` for infininte, or any positive integer `>= 1` for a specified number of repetitions.\n\nThis will also work if the dataset has less samples than the batch size; not a common use case but can happen in certain situations involving semi-supervised learning for instance.\n\n### Sample weighting to alter likelihood of samples\n\nIf you want some samples to be drawn more frequently than others, construct a `sampling.WeightedSampler` and pass\nit as the `sampler` argument to the `ArrayDataSource` constructor. In the example the per-sample weights are stored\nin `train_w`.\n\n```py3\nfrom batchup import sampling\n\nsampler = sampling.WeightedSampler(weights=train_w)\n\nds = data_source.ArrayDataSource([train_X, train_y], sampler=sampler)\n\n# Drawing batches of 64 elements in random order\nfor (batch_X, batch_y) in ds.batch_iterator(batch_size=64, shuffle=np.random.RandomState(12345)):\n    # Processes batches here...\n```\n\n**Note** that in-order is NOT supported when using `sampling.WeightedSampler`, so `shuffle` *cannot* be `False` or\n`None`.\n\nTo draw from a subset of the dataset, use `sampling.WeightedSubsetSampler`:\n\n```py3\nfrom batchup import sampling\n\n# NOTE that that parameter is called `sub_weights` (rather than `weights`) and that it must have the\n# same length as `indices`.\nsampler = sampling.WeightedSubsetSampler(sub_weights=train_w[subset_a], indices=subset_a)\n\nds = data_source.ArrayDataSource([train_X, train_y], sampler=sampler)\n\n# Drawing batches of 64 elements in random order\nfor (batch_X, batch_y) in ds.batch_iterator(batch_size=64, shuffle=np.random.RandomState(12345)):\n    # Processes batches here...\n```\n\n\n#### Class balancing helper\n\nAn alternate constructor `sampling.WeightedSampler.class_balancing_sampler` is available to construct a weighted sampler to compensate for class imbalance:\n\n```py3\n# Construct the sampler; NOTE that the `n_classes` argument is *optional*\nsampler = sampling.WeightedSampler.class_balancing_sampler(y=train_y, n_classes=train_y.max() + 1)\n\nds = data_source.ArrayDataSource([train_X, train_y], sampler=sampler)\n\n# Drawing batches of 64 elements in random order\nfor (batch_X, batch_y) in ds.batch_iterator(batch_size=64, shuffle=np.random.RandomState(12345)):\n    # Processes batches here...\n```\n\nThe `sampling.WeightedSampler.class_balancing_sample_weights` helper method constructs an array of sample weights,\nin case you wish to modify the weights first:\n```py3\nweights = sampling.WeightedSampler.class_balancing_sample_weights(y=train_y, n_classes=train_y.max() + 1)\n\n# Assume `modify_weights` is defined above\nweights = modify_weights(weights)\n\n# Construct the sampler and the data source\nsampler = sampling.WeightedSampler(weights=weights)\nds = data_source.ArrayDataSource([train_X, train_y], sampler=sampler)\n\n# Drawing batches of 64 elements in random order\nfor (batch_X, batch_y) in ds.batch_iterator(batch_size=64, shuffle=np.random.RandomState(12345)):\n    # Processes batches here...\n```\n\n\n### Iterating over two data sources of wildly different sizes for semi-supervised learning\n\nIn semi-supervised learning we have a small dataset of labeled samples `lab_X` with ground truths `lab_y` and a larger set of unlabeled samples `unlab_X`. Lets say we want a single epoch to consist of the entire unlabeled dataset while looping over the labeled dataset repeatly. The `CompositeDataSource` class can help us here.\n\nWithout using `CompositeDataSource`:\n\n```py3\nrng = np.random.RandomState(12345)\n\n# Construct the data sources; the labeled data source will repeat infinitely\nds_lab = data_source.ArrayDataSource([lab_X, lab_y], repeats=-1)\nds_unlab = data_source.ArrayDataSource([unlab_X])\n\n# Construct an iterator to get samples from our labeled data source:\nlab_iter = ds_lab.batch_iterator(batch_size=64, shuffle=rng)\n\n# Iterate over the unlabled data set in the for-loop\nfor (batch_unlab_X,) in ds_unlab.batch_iterator(batch_size=64, shuffle=rng):\n    # Extract batches from the labeled iterator ourselves\n    batch_lab_X, batch_lab_y = next(lab_iter)\n\n    # Process batches here...\n```\n\nNow using `CompositeDataSource`:\n\n```py3\n# Construct the data sources; the labeled data source will repeat infinitely\nds_lab = data_source.ArrayDataSource([lab_X, lab_y], repeats=-1)\nds_unlab = data_source.ArrayDataSource([unlab_X])\nds = data_source.CompositeDataSource([ds_lab, ds_unlab])\n\n# Iterate over both the labeled and unlabeled samples:\nfor (batch_lab_X, batch_lab_y, batch_unlab_X) in ds.batch_iterator(batch_size=64, shuffle=rng):\n    # Process batches here...\n\n```\n\nThe two component data sources (`ds_lab` and `ds_unlab`) will be shuffled independently.\n\nYou can also have `CompositeDataSource` generate structured mini-batches that reflect the structure of the data source:\n\n```py3\n# Flatten this time round:\nds_struct = data_source.CompositeDataSource([ds_lab, ds_unlab], flatten=False)\n\n# Iterate over both the labeled and unlabeled samples:\nfor ((batch_lab_X, batch_lab_y), (batch_unlab_X,)) in ds_struct.batch_iterator(batch_size=64, shuffle=rng):\n    # Process batches here...\n```\n\n`CompositeDataSource` instances can be arbitrarily nested.\n\n### Using data that is NOT stored as NumPy arrays\n\nThe arrays passed to `ArrayDataSource` do not have to be NumPy arrays, they just have to be array-like. An array-like object should implement the `__len__` method that returns the number of samples and the `__getitem__` method that returns the samples themselves. Note that `__getitem__` should accept integer indices, slices, or NumPy integer arrays that give the indices of the samples to retrieve.\n\nLets day we want to implement a data source that loads images from disk on the fly. Lets also assume that the prefix of the filename, either `'cat'` or `'dog'` gives the ground truth:\n\n```py3\nimport glob\nimport os\nfrom scipy.misc import imread\nfrom batchup import data_source\n\nclass LoadImagesFromDisk (object):\n    def __init__(self, paths):\n        # Paths is a list of file paths\n        self.paths = paths\n\n    # We have to imlement the `__len__` method:\n    def __len__(self):\n        return len(self.paths)\n\n\n    # We have to implement the `__getitem__` method that `ArrayDataSource` will use to get samples\n    def __getitem__(self, index):\n        if isinstance(index, (int, long)):\n            # A single integer index; return that sample\n            return imread(self.paths[index])\n        elif isinstance(index, slice):\n            # A slice\n            images = [imread(p) for p in self.paths[index]]\n            return np.concatenate([img[None, ...] for img in images], axis=0)\n        elif isinstance(index, np.ndarray):\n            if index.ndim != 1:\n                raise ValueError('index array should only have 1 dimension, not {}'.format(index.ndim))\n            images = [imread(self.paths[i]) for i in index]\n            return np.concatenate([img[None, ...] for img in images], axis=0)\n        else:\n            raise TypeError('index should be an integer, a slice or a NumPy array, '\n                            'not a {}'.format(type(index))\n\n# Get our image paths\nimage_paths = glob.glob('/path/to/my/images/*.jpg')\n\n# Build our array-like data source\ntrain_X = LoadImagesFromDisk(image_paths)\n\n# Construct our ground truths as a NumPy array\ntrain_y = [(1 if os.path.basename(p).startswith('dog') else 0) for p in image_paths)]\ntrain_y = np.array(train_y, dtype=np.int32)\n\n# Mixing custom array types with NumPy arrays is fine\nds = data_source.ArrayDataSource([train_X, train_y])\n\nfor (batch_X, batch_y) in ds.batch_iterator(batch_size=64, shuffle=np.random.RandomState(12345)):\n    # Process batches here...\n```\n\n### Using parallel processing to speed things up\n\nThe above example has a potential performance problem as loading the images from disk would introduce latency. We can use the `work_pool` module to prepare the mini-batches in separate threads or processes to hide this latency.\n\n#### Using threads\n\nThe modifications to the previous example to use parallel processing are quite simple (lets assume that the `LoadImagesFromDisk` class is defined and that `train_X`, `train_y` and `ds` (an `ArrayDataSource` instance) have already been built:\n\n```py3\nfrom batchup import work_pool\n\n# Build a pool of 4 worker threads:\nth_pool = work_pool.WorkerThreadPool(processes=4)\n\n# Construct a data source that prepares mini-batches in the background\n# It wraps the existing data source `ds` and will try to keep a buffer of 32\n# mini-batches full to eliminate latency:\npar_ds = th_pool.parallel_data_source(ds, batch_buffer_size=32)\n\n# As soon as we create an iterator, it will start filling its buffer; lets create an\n# iterator right now to get it going in the background:\npar_iter = par_ds.batch_iterator(batch_size=64, shuffle=np.random.RandomState(12345))\n\n# Do some other initialisation stuff that may take a while...\n\n# By now, with any luck, some batches will be ready to retrieve\n\nfor (batch_X, batch_y) in par_iter:\n    # Process batches here...\n```\n\n#### Using processes\n\nIn some cases the data source that you wish to parallelize may include some cacheing logic that is not thread safe. In such cases you can use process based pools that use separate processes rather than threads.\nThere are one or two gotchas, namely that using process-based pools entails a higher overhead and that the data source class and its dependent types must be declared in the top level of a module so that `pickle` can find them.\n\n```py3\n# Build a pool of 4 worker processes:\nproc_pool = work_pool.WorkerProcessPool(processes=4)\n\n# Construct a data source that prepares mini-batches in the background\n# It wraps the existing non-thread-safe data source `ds` and\n# will try to keep a buffer of 32 mini-batches full to eliminate latency:\npar_ds = proc_pool.parallel_data_source(ds, batch_buffer_size=32)\n\n# ... use `par_ds` the same way as before ...\n```\n\n## Gathering results and loss values\n\nWe can further simplify training and evaluation procedures using the `batch_map_concat` and `batch_map_mean` methods.\n\n### Removing the for-loop; predict values for samples in one line\n\nLets assume we have a prediction function `f_pred` of the form `f_pred(batch_X) -> batch_pred_y`. \nIf we want to predict results for our test set in `test_X`, we can do this in one line, without the for loop:\n\n```py3\ntest_ds = data_source.ArrayDataSource([test_X])\n\n(pred_y,) = test_ds.batch_map_concat(f_pred, batch_size=256)\n```\n\nThe `batch_map_concat` method will process all the samples in `test_X` and gather the results in a tuple of arrays, hence\nthe `(pred_y,) = ...`. If you want `tqdm` ([PyPi](http://pypi.python.org/pypi/tqdm), [GitHub](http://github.com/noamraph/tqdm)) to give you a progress bar:\n\n```py3\n(pred_y,) = test_ds.batch_map_concat(f_pred, batch_size=256, progress_iter_func=tqdm.tqdm)\n```\n\n### Computing mean loss/error values\n\nLets assume we have a evaluation function `f_eval` of the form `f_eval(batch_X, batch_y) -> [log_loss_sum, err_count]`. \nAssuming that we are doing classification, `f_eval` returns the sum of the per-sample log-losses and the number of errors.\nThe `batch_map_mean` method will process all of the data in the data source, gather loss and error counts and return the mean:\n\n```py3\nval_ds = data_source.ArrayDataSource([val_X, val_y])\n\nmean_log_loss, mean_err_rate = val_ds.batch_map_mean(f_eval, batch_size=256)\n```\n\nNote that as above, the `progress_iter_func` parameter can be passed `tqdm.tqdm` to give you a progress bar.\n\n\n## Standard datasets\n\nBatchUp provides support for using some standard datasets.\n\n#### MNIST dataset\n\nLoad the MNIST dataset:\n```py3\nfrom batchup.datasets import mnist\n\n# Load MNIST dataset (downloading it if necessary) and retain the last 10000\n# training samples for validation\nds = mnist.MNIST(n_val=10000)\n```\n\n- `ds.train_X` is a `(n, 1, 28, 28)` `float32` array that contains the\n    training images.\n- `ds.train_y` is a `(n,)` `int32` array that contains the ground truths.\n- `ds.val_X` and `ds.val_y` contain the validation samples\n- `ds.test_X` and `ds.test_y` contain the test samples\n\n\n#### SVHN dataset\n\nLoad the SVHN dataset:\n```py3\nfrom batchup.datasets import svhn\n\n# Load SVHN dataset (downloading it if necessary) and retain the last 10000\n# training samples for validation\nds = svhn.SVHN(n_val=10000)\n```\n\n- `ds.train_X` is a `(n, 3, 32, 32)` `float32` array that contains the\n    training images.\n- `ds.train_y` is a `(n,)` `int32` array that contains the ground truths.\n- `ds.val_X` and `ds.val_y` contain the validation samples\n- `ds.test_X` and `ds.test_y` contain the test samples\n\n\n#### CIFAR-10 dataset\n\nLoad the CIFAR-10 dataset:\n```py3\nfrom batchup.datasets import cifar10\n\n# Load CIFAR-10 dataset (downloading it if necessary) and retain the last 5000\n# training samples for validation\nds = cifar10.CIFAR10(n_val=5000)\n```\n\n- `ds.train_X` is a `(n, 3, 32, 32)` `float32` array that contains the\n    training images.\n- `ds.train_y` is a `(n,)` `int32` array that contains the ground truths.\n- `ds.val_X` and `ds.val_y` contain the validation samples\n- `ds.test_X` and `ds.test_y` contain the test samples\n- `ds.class_names` lists the class names of the corresponding ground truth\n    indices\n\n\n#### CIFAR-100 dataset\n\nLoad the CIFAR-100 dataset:\n```py3\nfrom batchup.datasets import cifar100\n\n# Load CIFAR-100 dataset (downloading it if necessary) and retain the last 5000\n# training samples for validation\nds = cifar100.CIFAR100(n_val=5000)\n```\n\n- `ds.train_X` is a `(n, 3, 32, 32)` `float32` array that contains the\n    training images.\n- `ds.train_y` is a `(n,)` `int32` array that contains the fine ground\n    truth classes.\n- `ds.train_y_coarse` is a `(n,)` `int32` array that contains the coarse\n    ground truth classes.\n- `ds.val_X`, `ds.val_y` and `ds.val_y_coarse` contain the validation samples\n- `ds.test_X`, `ds.test_y` and `ds.test_y_coarse` contain the test samples\n- `ds.class_names` lists the class names of the corresponding fine ground\n    truth indices\n- `ds.class_names_coarse` lists the class names of the corresponding coarse\n    ground truth indices\n\n\n#### STL dataset\n\nLoad the STL dataset:\n```py3\nfrom batchup.datasets import stl\n\n# Load STL dataset (downloading it if necessary) and retain 1 fold of\n# training samples for validation\nds = stl.STL(n_val_folds=1)\n```\n\n- `ds.train_X_u8` is a `(n, 3, 96, 96)` `uint8` array that contains the\n    training images.\n- `ds.train_y` is a `(n,)` `int32` array that contains the ground truths.\n- `ds.val_X_u8` and `ds.val_y` contain the validation samples\n- `ds.test_X_u8` and `ds.test_y` contain the test samples\n- `ds.class_names` lists the class names of the corresponding ground truth\n    indices\n\nWe keep the image data in `uint8` form to save memory,\n\n\n#### USPS dataset\n\nLoad the USPS dataset (similar to MNIST hand-written digits but smaller):\n```py3\nfrom batchup.datasets import usps\n\n# Load USPS dataset (downloading it if necessary) and retain 729\n# training samples for validation\nds = usps.USPS(n_val=729)\n```\n\n- `ds.train_X` is a `(n, 1, 16, 16)` `float32` array that contains the\n    training images.\n- `ds.train_y` is a `(n,)` `int32` array that contains the ground truths.\n- `ds.val_X` and `ds.val_y` contain the validation samples\n- `ds.test_X` and `ds.test_y` contain the test samples\n\n\n## Configuring BatchUp (paths etc).\n\nThe configuration for BatchUp lives in `.batchup.cfg` in your home directory.\n\nBy default BatchUp will store its data (e.g. downloaded datasets) in a directory called `.batchup` that resides in your home directory. If you wish it to locate this data somewhere else (some of the datasets an take a few gigabytes), create the configuration file mentioned above:\n\n\n```cfg\n[paths]\ndata_dir=/some/path/batchup_data\n```\n\nAlternatively you can set the `BATCHUP_HOME` environment variable top the BatchUp data directory.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Britefury/batchup", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "batchup", "package_url": "https://pypi.org/project/batchup/", "platform": "", "project_url": "https://pypi.org/project/batchup/", "project_urls": {"Homepage": "https://github.com/Britefury/batchup"}, "release_url": "https://pypi.org/project/batchup/0.2.3/", "requires_dist": ["numpy", "scipy", "six", "tables", "joblib", "mock ; extra == 'testing'", "pytest ; extra == 'testing'", "pytest-cov ; extra == 'testing'", "pytest-pep8 ; extra == 'testing'"], "requires_python": "", "summary": "Python library for extracting mini-batches of data from a data source for the purpose of training neural networks", "version": "0.2.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>BatchUp</h1>\n<p>Python library for extracting mini-batches of data from a data source for the purpose of training neural networks.</p>\n<p>Quick example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">batchup</span> <span class=\"kn\">import</span> <span class=\"n\">data_source</span>\n\n<span class=\"c1\"># Construct an array data source</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Iterate over samples, drawing batches of 64 elements in random order</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Processes batches here...</span>\n</pre>\n<p>Documentation available at <a href=\"https://batchup.readthedocs.io\" rel=\"nofollow\">https://batchup.readthedocs.io</a></p>\n<h1>Table of Contents</h1>\n<h4>Installation</h4>\n<h4>Batch iteration</h4>\n<p>Processing data in mini-batches:</p>\n<ul>\n<li>quick batch iteration; a basic example</li>\n<li>iterating over subsets identified by indices</li>\n<li>data augmentation</li>\n<li>including sample indices in the mini-batches</li>\n<li>infinite batch iteration; an iterator that generates batches endlessly</li>\n<li>sample weighting to alter likelihood of samples (e.g. to compensate for class imbalance)</li>\n<li>iterating over two data sets simultaneously where their sizes differ (e.g. for semi-supervised learning)</li>\n<li>iterating over data sets that are NOT stored as NumPy arrays (e.g. on disk or generated on the fly)</li>\n<li>parallel processing to speed up iteration where loading/preparing samples could be slow</li>\n</ul>\n<h4>Gathering results and loss values</h4>\n<ul>\n<li>removing the for-loop; predict values for samples in one line</li>\n<li>computing mean loss/error values</li>\n</ul>\n<h4>Standard datasets</h4>\n<p>BatchUp supports some standard machine learning datasets. They will be automatically downloaded if necessary.</p>\n<ul>\n<li>MNIST</li>\n<li>SVHN</li>\n<li>CIFAR-10</li>\n<li>CIFAR-100</li>\n<li>STL</li>\n<li>USPS</li>\n</ul>\n<h4>Configuring BatchUp</h4>\n<p>Data paths, etc.</p>\n<p>More details further down, but briefly, use either the <code>~/.batchup.cfg</code> configuration file or the <code>BATCHUP_HOME</code> environment varible.</p>\n<h2>Installation</h2>\n<p>You can install BatchUp with:</p>\n<p><code>&gt; pip install batchup</code></p>\n<h2>Batch iteration</h2>\n<h3>Quick batch iteration</h3>\n<p>Assume we have a training set loaded in the variables <code>train_X</code> and <code>train_y</code>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">batchup</span> <span class=\"kn\">import</span> <span class=\"n\">data_source</span>\n\n<span class=\"c1\"># Construct an array data source</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Iterate over samples, drawing batches of 64 elements in random order</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">12345</span><span class=\"p\">)):</span>\n    <span class=\"c1\"># Processes batches here...</span>\n</pre>\n<p>Some notes:</p>\n<ul>\n<li>the last batch will be short (have less samples than the requested batch size) if there isn't enough data to fill it.</li>\n<li>using <code>shuffle=True</code> will use NumPy's default random number generator</li>\n<li>not specifying shuffle will process the samples in-order</li>\n</ul>\n<h3>Iterating over subsets identified by indices</h3>\n<p>We can specify the indices of a subset of the samples in a dataset and draw mini-batches from only those samples:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"c1\"># Randomly choose a subset of 20,000 samples, by indices</span>\n<span class=\"n\">subset_a</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">permutation</span><span class=\"p\">(</span><span class=\"n\">train_X</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])[:</span><span class=\"mi\">20000</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># Construct an array data source that will only draw samples whose indices are in `subset_a`</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">],</span> <span class=\"n\">indices</span><span class=\"o\">=</span><span class=\"n\">subset_a</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Drawing batches of 64 elements in random order</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">12345</span><span class=\"p\">)):</span>\n    <span class=\"c1\"># Processes batches here...</span>\n</pre>\n<h3>Data augmentation</h3>\n<p>We can define a function that applies data augmentation on the fly. Let's assume that <code>train_X</code> contains image data,\nhas the shape <code>(sample, channel, height, width)</code> and that we wish to horizontally flip some of the images:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"c1\"># Define our batch augmentation function.</span>\n<span class=\"k\">def</span> <span class=\"nf\">augment_batch</span><span class=\"p\">(</span><span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Create an array that selects samples with 50% probability and convert to `bool` dtype</span>\n    <span class=\"n\">flip_flags</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">binomial</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">batch_X</span><span class=\"p\">),))</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span>\n\n    <span class=\"c1\"># Flip the width dimension in selected samples</span>\n    <span class=\"n\">batch_X</span><span class=\"p\">[</span><span class=\"n\">flip_flags</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">flip_flags</span><span class=\"p\">[</span><span class=\"n\">flip_flags</span><span class=\"p\">,</span> <span class=\"p\">:,</span> <span class=\"p\">:,</span> <span class=\"p\">::</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n\n    <span class=\"c1\"># Return the batch as a tuple</span>\n    <span class=\"k\">return</span> <span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span>\n\n<span class=\"c1\"># Construct an array data source that will only draw samples whose indices are in `subset_a`</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Apply augmentation</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">augment_batch</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Drawing batches of 64 elements in random order</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">12345</span><span class=\"p\">)):</span>\n    <span class=\"c1\"># Processes batches here...</span>\n</pre>\n<p>More complex augmentation may incurr significant runtime cost. This can be alleviated by preparing batches\nin background threads. See the <em>parallel processing</em> section below.</p>\n<h3>Including sample indices in the mini-batches</h3>\n<p>We can ask to be provided with the indices of the samples that were drawn to form the mini-batch:</p>\n<pre><span class=\"c1\"># Construct an array data source that will provide sample indices</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">],</span> <span class=\"n\">include_indices</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Drawing batches of 64 elements in random order</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_ndx</span><span class=\"p\">,</span> <span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">12345</span><span class=\"p\">)):</span>\n    <span class=\"c1\"># Processes batches here...</span>\n</pre>\n<h3>Infinite batch iteration</h3>\n<p>Lets say you need an iterator that extracts samples from your dataset and starts from the beginning when it reaches the end:</p>\n<pre><span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">],</span> <span class=\"n\">repeats</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<p>Now use the <code>batch_iterator</code> method as before.</p>\n<p>The <code>repeats</code> parameter accepts either <code>-1</code> for infininte, or any positive integer <code>&gt;= 1</code> for a specified number of repetitions.</p>\n<p>This will also work if the dataset has less samples than the batch size; not a common use case but can happen in certain situations involving semi-supervised learning for instance.</p>\n<h3>Sample weighting to alter likelihood of samples</h3>\n<p>If you want some samples to be drawn more frequently than others, construct a <code>sampling.WeightedSampler</code> and pass\nit as the <code>sampler</code> argument to the <code>ArrayDataSource</code> constructor. In the example the per-sample weights are stored\nin <code>train_w</code>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">batchup</span> <span class=\"kn\">import</span> <span class=\"n\">sampling</span>\n\n<span class=\"n\">sampler</span> <span class=\"o\">=</span> <span class=\"n\">sampling</span><span class=\"o\">.</span><span class=\"n\">WeightedSampler</span><span class=\"p\">(</span><span class=\"n\">weights</span><span class=\"o\">=</span><span class=\"n\">train_w</span><span class=\"p\">)</span>\n\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">],</span> <span class=\"n\">sampler</span><span class=\"o\">=</span><span class=\"n\">sampler</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Drawing batches of 64 elements in random order</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">12345</span><span class=\"p\">)):</span>\n    <span class=\"c1\"># Processes batches here...</span>\n</pre>\n<p><strong>Note</strong> that in-order is NOT supported when using <code>sampling.WeightedSampler</code>, so <code>shuffle</code> <em>cannot</em> be <code>False</code> or\n<code>None</code>.</p>\n<p>To draw from a subset of the dataset, use <code>sampling.WeightedSubsetSampler</code>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">batchup</span> <span class=\"kn\">import</span> <span class=\"n\">sampling</span>\n\n<span class=\"c1\"># NOTE that that parameter is called `sub_weights` (rather than `weights`) and that it must have the</span>\n<span class=\"c1\"># same length as `indices`.</span>\n<span class=\"n\">sampler</span> <span class=\"o\">=</span> <span class=\"n\">sampling</span><span class=\"o\">.</span><span class=\"n\">WeightedSubsetSampler</span><span class=\"p\">(</span><span class=\"n\">sub_weights</span><span class=\"o\">=</span><span class=\"n\">train_w</span><span class=\"p\">[</span><span class=\"n\">subset_a</span><span class=\"p\">],</span> <span class=\"n\">indices</span><span class=\"o\">=</span><span class=\"n\">subset_a</span><span class=\"p\">)</span>\n\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">],</span> <span class=\"n\">sampler</span><span class=\"o\">=</span><span class=\"n\">sampler</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Drawing batches of 64 elements in random order</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">12345</span><span class=\"p\">)):</span>\n    <span class=\"c1\"># Processes batches here...</span>\n</pre>\n<h4>Class balancing helper</h4>\n<p>An alternate constructor <code>sampling.WeightedSampler.class_balancing_sampler</code> is available to construct a weighted sampler to compensate for class imbalance:</p>\n<pre><span class=\"c1\"># Construct the sampler; NOTE that the `n_classes` argument is *optional*</span>\n<span class=\"n\">sampler</span> <span class=\"o\">=</span> <span class=\"n\">sampling</span><span class=\"o\">.</span><span class=\"n\">WeightedSampler</span><span class=\"o\">.</span><span class=\"n\">class_balancing_sampler</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"n\">train_y</span><span class=\"p\">,</span> <span class=\"n\">n_classes</span><span class=\"o\">=</span><span class=\"n\">train_y</span><span class=\"o\">.</span><span class=\"n\">max</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">],</span> <span class=\"n\">sampler</span><span class=\"o\">=</span><span class=\"n\">sampler</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Drawing batches of 64 elements in random order</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">12345</span><span class=\"p\">)):</span>\n    <span class=\"c1\"># Processes batches here...</span>\n</pre>\n<p>The <code>sampling.WeightedSampler.class_balancing_sample_weights</code> helper method constructs an array of sample weights,\nin case you wish to modify the weights first:</p>\n<pre><span class=\"n\">weights</span> <span class=\"o\">=</span> <span class=\"n\">sampling</span><span class=\"o\">.</span><span class=\"n\">WeightedSampler</span><span class=\"o\">.</span><span class=\"n\">class_balancing_sample_weights</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"o\">=</span><span class=\"n\">train_y</span><span class=\"p\">,</span> <span class=\"n\">n_classes</span><span class=\"o\">=</span><span class=\"n\">train_y</span><span class=\"o\">.</span><span class=\"n\">max</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Assume `modify_weights` is defined above</span>\n<span class=\"n\">weights</span> <span class=\"o\">=</span> <span class=\"n\">modify_weights</span><span class=\"p\">(</span><span class=\"n\">weights</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Construct the sampler and the data source</span>\n<span class=\"n\">sampler</span> <span class=\"o\">=</span> <span class=\"n\">sampling</span><span class=\"o\">.</span><span class=\"n\">WeightedSampler</span><span class=\"p\">(</span><span class=\"n\">weights</span><span class=\"o\">=</span><span class=\"n\">weights</span><span class=\"p\">)</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">],</span> <span class=\"n\">sampler</span><span class=\"o\">=</span><span class=\"n\">sampler</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Drawing batches of 64 elements in random order</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">12345</span><span class=\"p\">)):</span>\n    <span class=\"c1\"># Processes batches here...</span>\n</pre>\n<h3>Iterating over two data sources of wildly different sizes for semi-supervised learning</h3>\n<p>In semi-supervised learning we have a small dataset of labeled samples <code>lab_X</code> with ground truths <code>lab_y</code> and a larger set of unlabeled samples <code>unlab_X</code>. Lets say we want a single epoch to consist of the entire unlabeled dataset while looping over the labeled dataset repeatly. The <code>CompositeDataSource</code> class can help us here.</p>\n<p>Without using <code>CompositeDataSource</code>:</p>\n<pre><span class=\"n\">rng</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">12345</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Construct the data sources; the labeled data source will repeat infinitely</span>\n<span class=\"n\">ds_lab</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">lab_X</span><span class=\"p\">,</span> <span class=\"n\">lab_y</span><span class=\"p\">],</span> <span class=\"n\">repeats</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">ds_unlab</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">unlab_X</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Construct an iterator to get samples from our labeled data source:</span>\n<span class=\"n\">lab_iter</span> <span class=\"o\">=</span> <span class=\"n\">ds_lab</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">rng</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Iterate over the unlabled data set in the for-loop</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_unlab_X</span><span class=\"p\">,)</span> <span class=\"ow\">in</span> <span class=\"n\">ds_unlab</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">rng</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Extract batches from the labeled iterator ourselves</span>\n    <span class=\"n\">batch_lab_X</span><span class=\"p\">,</span> <span class=\"n\">batch_lab_y</span> <span class=\"o\">=</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">lab_iter</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Process batches here...</span>\n</pre>\n<p>Now using <code>CompositeDataSource</code>:</p>\n<pre><span class=\"c1\"># Construct the data sources; the labeled data source will repeat infinitely</span>\n<span class=\"n\">ds_lab</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">lab_X</span><span class=\"p\">,</span> <span class=\"n\">lab_y</span><span class=\"p\">],</span> <span class=\"n\">repeats</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">ds_unlab</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">unlab_X</span><span class=\"p\">])</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">CompositeDataSource</span><span class=\"p\">([</span><span class=\"n\">ds_lab</span><span class=\"p\">,</span> <span class=\"n\">ds_unlab</span><span class=\"p\">])</span>\n\n<span class=\"c1\"># Iterate over both the labeled and unlabeled samples:</span>\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_lab_X</span><span class=\"p\">,</span> <span class=\"n\">batch_lab_y</span><span class=\"p\">,</span> <span class=\"n\">batch_unlab_X</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">rng</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Process batches here...</span>\n</pre>\n<p>The two component data sources (<code>ds_lab</code> and <code>ds_unlab</code>) will be shuffled independently.</p>\n<p>You can also have <code>CompositeDataSource</code> generate structured mini-batches that reflect the structure of the data source:</p>\n<pre><span class=\"c1\"># Flatten this time round:</span>\n<span class=\"n\">ds_struct</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">CompositeDataSource</span><span class=\"p\">([</span><span class=\"n\">ds_lab</span><span class=\"p\">,</span> <span class=\"n\">ds_unlab</span><span class=\"p\">],</span> <span class=\"n\">flatten</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Iterate over both the labeled and unlabeled samples:</span>\n<span class=\"k\">for</span> <span class=\"p\">((</span><span class=\"n\">batch_lab_X</span><span class=\"p\">,</span> <span class=\"n\">batch_lab_y</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">batch_unlab_X</span><span class=\"p\">,))</span> <span class=\"ow\">in</span> <span class=\"n\">ds_struct</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">rng</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Process batches here...</span>\n</pre>\n<p><code>CompositeDataSource</code> instances can be arbitrarily nested.</p>\n<h3>Using data that is NOT stored as NumPy arrays</h3>\n<p>The arrays passed to <code>ArrayDataSource</code> do not have to be NumPy arrays, they just have to be array-like. An array-like object should implement the <code>__len__</code> method that returns the number of samples and the <code>__getitem__</code> method that returns the samples themselves. Note that <code>__getitem__</code> should accept integer indices, slices, or NumPy integer arrays that give the indices of the samples to retrieve.</p>\n<p>Lets day we want to implement a data source that loads images from disk on the fly. Lets also assume that the prefix of the filename, either <code>'cat'</code> or <code>'dog'</code> gives the ground truth:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">glob</span>\n<span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"kn\">from</span> <span class=\"nn\">scipy.misc</span> <span class=\"kn\">import</span> <span class=\"n\">imread</span>\n<span class=\"kn\">from</span> <span class=\"nn\">batchup</span> <span class=\"kn\">import</span> <span class=\"n\">data_source</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">LoadImagesFromDisk</span> <span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">paths</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Paths is a list of file paths</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">paths</span> <span class=\"o\">=</span> <span class=\"n\">paths</span>\n\n    <span class=\"c1\"># We have to imlement the `__len__` method:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__len__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">paths</span><span class=\"p\">)</span>\n\n\n    <span class=\"c1\"># We have to implement the `__getitem__` method that `ArrayDataSource` will use to get samples</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__getitem__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">index</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">long</span><span class=\"p\">)):</span>\n            <span class=\"c1\"># A single integer index; return that sample</span>\n            <span class=\"k\">return</span> <span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">paths</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">])</span>\n        <span class=\"k\">elif</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"nb\">slice</span><span class=\"p\">):</span>\n            <span class=\"c1\"># A slice</span>\n            <span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">paths</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]]</span>\n            <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">([</span><span class=\"n\">img</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">img</span> <span class=\"ow\">in</span> <span class=\"n\">images</span><span class=\"p\">],</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"k\">elif</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">):</span>\n            <span class=\"k\">if</span> <span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">ndim</span> <span class=\"o\">!=</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n                <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">'index array should only have 1 dimension, not </span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"o\">.</span><span class=\"n\">ndim</span><span class=\"p\">))</span>\n            <span class=\"n\">images</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">paths</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">index</span><span class=\"p\">]</span>\n            <span class=\"k\">return</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">concatenate</span><span class=\"p\">([</span><span class=\"n\">img</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">img</span> <span class=\"ow\">in</span> <span class=\"n\">images</span><span class=\"p\">],</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">TypeError</span><span class=\"p\">(</span><span class=\"s1\">'index should be an integer, a slice or a NumPy array, '</span>\n                            <span class=\"s1\">'not a </span><span class=\"si\">{}</span><span class=\"s1\">'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Get our image paths</span>\n<span class=\"n\">image_paths</span> <span class=\"o\">=</span> <span class=\"n\">glob</span><span class=\"o\">.</span><span class=\"n\">glob</span><span class=\"p\">(</span><span class=\"s1\">'/path/to/my/images/*.jpg'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Build our array-like data source</span>\n<span class=\"n\">train_X</span> <span class=\"o\">=</span> <span class=\"n\">LoadImagesFromDisk</span><span class=\"p\">(</span><span class=\"n\">image_paths</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Construct our ground truths as a NumPy array</span>\n<span class=\"n\">train_y</span> <span class=\"o\">=</span> <span class=\"p\">[(</span><span class=\"mi\">1</span> <span class=\"k\">if</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">basename</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">startswith</span><span class=\"p\">(</span><span class=\"s1\">'dog'</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">p</span> <span class=\"ow\">in</span> <span class=\"n\">image_paths</span><span class=\"p\">)]</span>\n<span class=\"n\">train_y</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">train_y</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">int32</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Mixing custom array types with NumPy arrays is fine</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">train_X</span><span class=\"p\">,</span> <span class=\"n\">train_y</span><span class=\"p\">])</span>\n\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">ds</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">12345</span><span class=\"p\">)):</span>\n    <span class=\"c1\"># Process batches here...</span>\n</pre>\n<h3>Using parallel processing to speed things up</h3>\n<p>The above example has a potential performance problem as loading the images from disk would introduce latency. We can use the <code>work_pool</code> module to prepare the mini-batches in separate threads or processes to hide this latency.</p>\n<h4>Using threads</h4>\n<p>The modifications to the previous example to use parallel processing are quite simple (lets assume that the <code>LoadImagesFromDisk</code> class is defined and that <code>train_X</code>, <code>train_y</code> and <code>ds</code> (an <code>ArrayDataSource</code> instance) have already been built:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">batchup</span> <span class=\"kn\">import</span> <span class=\"n\">work_pool</span>\n\n<span class=\"c1\"># Build a pool of 4 worker threads:</span>\n<span class=\"n\">th_pool</span> <span class=\"o\">=</span> <span class=\"n\">work_pool</span><span class=\"o\">.</span><span class=\"n\">WorkerThreadPool</span><span class=\"p\">(</span><span class=\"n\">processes</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Construct a data source that prepares mini-batches in the background</span>\n<span class=\"c1\"># It wraps the existing data source `ds` and will try to keep a buffer of 32</span>\n<span class=\"c1\"># mini-batches full to eliminate latency:</span>\n<span class=\"n\">par_ds</span> <span class=\"o\">=</span> <span class=\"n\">th_pool</span><span class=\"o\">.</span><span class=\"n\">parallel_data_source</span><span class=\"p\">(</span><span class=\"n\">ds</span><span class=\"p\">,</span> <span class=\"n\">batch_buffer_size</span><span class=\"o\">=</span><span class=\"mi\">32</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># As soon as we create an iterator, it will start filling its buffer; lets create an</span>\n<span class=\"c1\"># iterator right now to get it going in the background:</span>\n<span class=\"n\">par_iter</span> <span class=\"o\">=</span> <span class=\"n\">par_ds</span><span class=\"o\">.</span><span class=\"n\">batch_iterator</span><span class=\"p\">(</span><span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">RandomState</span><span class=\"p\">(</span><span class=\"mi\">12345</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Do some other initialisation stuff that may take a while...</span>\n\n<span class=\"c1\"># By now, with any luck, some batches will be ready to retrieve</span>\n\n<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">batch_X</span><span class=\"p\">,</span> <span class=\"n\">batch_y</span><span class=\"p\">)</span> <span class=\"ow\">in</span> <span class=\"n\">par_iter</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Process batches here...</span>\n</pre>\n<h4>Using processes</h4>\n<p>In some cases the data source that you wish to parallelize may include some cacheing logic that is not thread safe. In such cases you can use process based pools that use separate processes rather than threads.\nThere are one or two gotchas, namely that using process-based pools entails a higher overhead and that the data source class and its dependent types must be declared in the top level of a module so that <code>pickle</code> can find them.</p>\n<pre><span class=\"c1\"># Build a pool of 4 worker processes:</span>\n<span class=\"n\">proc_pool</span> <span class=\"o\">=</span> <span class=\"n\">work_pool</span><span class=\"o\">.</span><span class=\"n\">WorkerProcessPool</span><span class=\"p\">(</span><span class=\"n\">processes</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Construct a data source that prepares mini-batches in the background</span>\n<span class=\"c1\"># It wraps the existing non-thread-safe data source `ds` and</span>\n<span class=\"c1\"># will try to keep a buffer of 32 mini-batches full to eliminate latency:</span>\n<span class=\"n\">par_ds</span> <span class=\"o\">=</span> <span class=\"n\">proc_pool</span><span class=\"o\">.</span><span class=\"n\">parallel_data_source</span><span class=\"p\">(</span><span class=\"n\">ds</span><span class=\"p\">,</span> <span class=\"n\">batch_buffer_size</span><span class=\"o\">=</span><span class=\"mi\">32</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># ... use `par_ds` the same way as before ...</span>\n</pre>\n<h2>Gathering results and loss values</h2>\n<p>We can further simplify training and evaluation procedures using the <code>batch_map_concat</code> and <code>batch_map_mean</code> methods.</p>\n<h3>Removing the for-loop; predict values for samples in one line</h3>\n<p>Lets assume we have a prediction function <code>f_pred</code> of the form <code>f_pred(batch_X) -&gt; batch_pred_y</code>.\nIf we want to predict results for our test set in <code>test_X</code>, we can do this in one line, without the for loop:</p>\n<pre><span class=\"n\">test_ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">test_X</span><span class=\"p\">])</span>\n\n<span class=\"p\">(</span><span class=\"n\">pred_y</span><span class=\"p\">,)</span> <span class=\"o\">=</span> <span class=\"n\">test_ds</span><span class=\"o\">.</span><span class=\"n\">batch_map_concat</span><span class=\"p\">(</span><span class=\"n\">f_pred</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">256</span><span class=\"p\">)</span>\n</pre>\n<p>The <code>batch_map_concat</code> method will process all the samples in <code>test_X</code> and gather the results in a tuple of arrays, hence\nthe <code>(pred_y,) = ...</code>. If you want <code>tqdm</code> (<a href=\"http://pypi.python.org/pypi/tqdm\" rel=\"nofollow\">PyPi</a>, <a href=\"http://github.com/noamraph/tqdm\" rel=\"nofollow\">GitHub</a>) to give you a progress bar:</p>\n<pre><span class=\"p\">(</span><span class=\"n\">pred_y</span><span class=\"p\">,)</span> <span class=\"o\">=</span> <span class=\"n\">test_ds</span><span class=\"o\">.</span><span class=\"n\">batch_map_concat</span><span class=\"p\">(</span><span class=\"n\">f_pred</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"n\">progress_iter_func</span><span class=\"o\">=</span><span class=\"n\">tqdm</span><span class=\"o\">.</span><span class=\"n\">tqdm</span><span class=\"p\">)</span>\n</pre>\n<h3>Computing mean loss/error values</h3>\n<p>Lets assume we have a evaluation function <code>f_eval</code> of the form <code>f_eval(batch_X, batch_y) -&gt; [log_loss_sum, err_count]</code>.\nAssuming that we are doing classification, <code>f_eval</code> returns the sum of the per-sample log-losses and the number of errors.\nThe <code>batch_map_mean</code> method will process all of the data in the data source, gather loss and error counts and return the mean:</p>\n<pre><span class=\"n\">val_ds</span> <span class=\"o\">=</span> <span class=\"n\">data_source</span><span class=\"o\">.</span><span class=\"n\">ArrayDataSource</span><span class=\"p\">([</span><span class=\"n\">val_X</span><span class=\"p\">,</span> <span class=\"n\">val_y</span><span class=\"p\">])</span>\n\n<span class=\"n\">mean_log_loss</span><span class=\"p\">,</span> <span class=\"n\">mean_err_rate</span> <span class=\"o\">=</span> <span class=\"n\">val_ds</span><span class=\"o\">.</span><span class=\"n\">batch_map_mean</span><span class=\"p\">(</span><span class=\"n\">f_eval</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">256</span><span class=\"p\">)</span>\n</pre>\n<p>Note that as above, the <code>progress_iter_func</code> parameter can be passed <code>tqdm.tqdm</code> to give you a progress bar.</p>\n<h2>Standard datasets</h2>\n<p>BatchUp provides support for using some standard datasets.</p>\n<h4>MNIST dataset</h4>\n<p>Load the MNIST dataset:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">batchup.datasets</span> <span class=\"kn\">import</span> <span class=\"n\">mnist</span>\n\n<span class=\"c1\"># Load MNIST dataset (downloading it if necessary) and retain the last 10000</span>\n<span class=\"c1\"># training samples for validation</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">mnist</span><span class=\"o\">.</span><span class=\"n\">MNIST</span><span class=\"p\">(</span><span class=\"n\">n_val</span><span class=\"o\">=</span><span class=\"mi\">10000</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li><code>ds.train_X</code> is a <code>(n, 1, 28, 28)</code> <code>float32</code> array that contains the\ntraining images.</li>\n<li><code>ds.train_y</code> is a <code>(n,)</code> <code>int32</code> array that contains the ground truths.</li>\n<li><code>ds.val_X</code> and <code>ds.val_y</code> contain the validation samples</li>\n<li><code>ds.test_X</code> and <code>ds.test_y</code> contain the test samples</li>\n</ul>\n<h4>SVHN dataset</h4>\n<p>Load the SVHN dataset:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">batchup.datasets</span> <span class=\"kn\">import</span> <span class=\"n\">svhn</span>\n\n<span class=\"c1\"># Load SVHN dataset (downloading it if necessary) and retain the last 10000</span>\n<span class=\"c1\"># training samples for validation</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">svhn</span><span class=\"o\">.</span><span class=\"n\">SVHN</span><span class=\"p\">(</span><span class=\"n\">n_val</span><span class=\"o\">=</span><span class=\"mi\">10000</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li><code>ds.train_X</code> is a <code>(n, 3, 32, 32)</code> <code>float32</code> array that contains the\ntraining images.</li>\n<li><code>ds.train_y</code> is a <code>(n,)</code> <code>int32</code> array that contains the ground truths.</li>\n<li><code>ds.val_X</code> and <code>ds.val_y</code> contain the validation samples</li>\n<li><code>ds.test_X</code> and <code>ds.test_y</code> contain the test samples</li>\n</ul>\n<h4>CIFAR-10 dataset</h4>\n<p>Load the CIFAR-10 dataset:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">batchup.datasets</span> <span class=\"kn\">import</span> <span class=\"n\">cifar10</span>\n\n<span class=\"c1\"># Load CIFAR-10 dataset (downloading it if necessary) and retain the last 5000</span>\n<span class=\"c1\"># training samples for validation</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">cifar10</span><span class=\"o\">.</span><span class=\"n\">CIFAR10</span><span class=\"p\">(</span><span class=\"n\">n_val</span><span class=\"o\">=</span><span class=\"mi\">5000</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li><code>ds.train_X</code> is a <code>(n, 3, 32, 32)</code> <code>float32</code> array that contains the\ntraining images.</li>\n<li><code>ds.train_y</code> is a <code>(n,)</code> <code>int32</code> array that contains the ground truths.</li>\n<li><code>ds.val_X</code> and <code>ds.val_y</code> contain the validation samples</li>\n<li><code>ds.test_X</code> and <code>ds.test_y</code> contain the test samples</li>\n<li><code>ds.class_names</code> lists the class names of the corresponding ground truth\nindices</li>\n</ul>\n<h4>CIFAR-100 dataset</h4>\n<p>Load the CIFAR-100 dataset:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">batchup.datasets</span> <span class=\"kn\">import</span> <span class=\"n\">cifar100</span>\n\n<span class=\"c1\"># Load CIFAR-100 dataset (downloading it if necessary) and retain the last 5000</span>\n<span class=\"c1\"># training samples for validation</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">cifar100</span><span class=\"o\">.</span><span class=\"n\">CIFAR100</span><span class=\"p\">(</span><span class=\"n\">n_val</span><span class=\"o\">=</span><span class=\"mi\">5000</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li><code>ds.train_X</code> is a <code>(n, 3, 32, 32)</code> <code>float32</code> array that contains the\ntraining images.</li>\n<li><code>ds.train_y</code> is a <code>(n,)</code> <code>int32</code> array that contains the fine ground\ntruth classes.</li>\n<li><code>ds.train_y_coarse</code> is a <code>(n,)</code> <code>int32</code> array that contains the coarse\nground truth classes.</li>\n<li><code>ds.val_X</code>, <code>ds.val_y</code> and <code>ds.val_y_coarse</code> contain the validation samples</li>\n<li><code>ds.test_X</code>, <code>ds.test_y</code> and <code>ds.test_y_coarse</code> contain the test samples</li>\n<li><code>ds.class_names</code> lists the class names of the corresponding fine ground\ntruth indices</li>\n<li><code>ds.class_names_coarse</code> lists the class names of the corresponding coarse\nground truth indices</li>\n</ul>\n<h4>STL dataset</h4>\n<p>Load the STL dataset:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">batchup.datasets</span> <span class=\"kn\">import</span> <span class=\"n\">stl</span>\n\n<span class=\"c1\"># Load STL dataset (downloading it if necessary) and retain 1 fold of</span>\n<span class=\"c1\"># training samples for validation</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">stl</span><span class=\"o\">.</span><span class=\"n\">STL</span><span class=\"p\">(</span><span class=\"n\">n_val_folds</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li><code>ds.train_X_u8</code> is a <code>(n, 3, 96, 96)</code> <code>uint8</code> array that contains the\ntraining images.</li>\n<li><code>ds.train_y</code> is a <code>(n,)</code> <code>int32</code> array that contains the ground truths.</li>\n<li><code>ds.val_X_u8</code> and <code>ds.val_y</code> contain the validation samples</li>\n<li><code>ds.test_X_u8</code> and <code>ds.test_y</code> contain the test samples</li>\n<li><code>ds.class_names</code> lists the class names of the corresponding ground truth\nindices</li>\n</ul>\n<p>We keep the image data in <code>uint8</code> form to save memory,</p>\n<h4>USPS dataset</h4>\n<p>Load the USPS dataset (similar to MNIST hand-written digits but smaller):</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">batchup.datasets</span> <span class=\"kn\">import</span> <span class=\"n\">usps</span>\n\n<span class=\"c1\"># Load USPS dataset (downloading it if necessary) and retain 729</span>\n<span class=\"c1\"># training samples for validation</span>\n<span class=\"n\">ds</span> <span class=\"o\">=</span> <span class=\"n\">usps</span><span class=\"o\">.</span><span class=\"n\">USPS</span><span class=\"p\">(</span><span class=\"n\">n_val</span><span class=\"o\">=</span><span class=\"mi\">729</span><span class=\"p\">)</span>\n</pre>\n<ul>\n<li><code>ds.train_X</code> is a <code>(n, 1, 16, 16)</code> <code>float32</code> array that contains the\ntraining images.</li>\n<li><code>ds.train_y</code> is a <code>(n,)</code> <code>int32</code> array that contains the ground truths.</li>\n<li><code>ds.val_X</code> and <code>ds.val_y</code> contain the validation samples</li>\n<li><code>ds.test_X</code> and <code>ds.test_y</code> contain the test samples</li>\n</ul>\n<h2>Configuring BatchUp (paths etc).</h2>\n<p>The configuration for BatchUp lives in <code>.batchup.cfg</code> in your home directory.</p>\n<p>By default BatchUp will store its data (e.g. downloaded datasets) in a directory called <code>.batchup</code> that resides in your home directory. If you wish it to locate this data somewhere else (some of the datasets an take a few gigabytes), create the configuration file mentioned above:</p>\n<pre><span class=\"k\">[paths]</span>\n<span class=\"na\">data_dir</span><span class=\"o\">=</span><span class=\"s\">/some/path/batchup_data</span>\n</pre>\n<p>Alternatively you can set the <code>BATCHUP_HOME</code> environment variable top the BatchUp data directory.</p>\n\n          </div>"}, "last_serial": 5491410, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "a22bc9e88e7be8ea69ea3af10268ce64", "sha256": "62afe535aa73414c58a94a73f979d69730f44f0e72bdb76f7749496f026bf164"}, "downloads": -1, "filename": "batchup-0.1.0.tar.gz", "has_sig": false, "md5_digest": "a22bc9e88e7be8ea69ea3af10268ce64", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 53031, "upload_time": "2018-01-20T18:48:56", "upload_time_iso_8601": "2018-01-20T18:48:56.025884Z", "url": "https://files.pythonhosted.org/packages/6d/55/3d9f7bb3296b56f758125384ae13aabc75f6d64e3ffcc5f95362c7802f5c/batchup-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "0f8d0f3e91d12032642da73aa8e5fea4", "sha256": "0a720613058d19efbcd06e90948f1374c303947ba63b81841b49a61ac5a54a2a"}, "downloads": -1, "filename": "batchup-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "0f8d0f3e91d12032642da73aa8e5fea4", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 67824, "upload_time": "2018-08-08T19:09:08", "upload_time_iso_8601": "2018-08-08T19:09:08.516729Z", "url": "https://files.pythonhosted.org/packages/fd/d0/dbeab0fcb91e4b6c0a46c0a7fb046815654df9510884faaacdbef9c32cad/batchup-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6a9e00146b158b8a1e80063b9ad66919", "sha256": "1373758efc695652d72f7dea65683f309046beccaabb9ed8911ea0da976f1c5f"}, "downloads": -1, "filename": "batchup-0.2.0.tar.gz", "has_sig": false, "md5_digest": "6a9e00146b158b8a1e80063b9ad66919", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 57719, "upload_time": "2018-08-08T19:09:10", "upload_time_iso_8601": "2018-08-08T19:09:10.978329Z", "url": "https://files.pythonhosted.org/packages/a9/1e/f6b10559899c34633c093ced1a3407ef6ce9b223150826d9d9987a9cad13/batchup-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "b325bcf372b642fb6f5fe60099a5c0d7", "sha256": "a14ddb760a92306958cbb57144741b142ebb5d02583be682c4ad63702ec39991"}, "downloads": -1, "filename": "batchup-0.2.1-py3-none-any.whl", "has_sig": false, "md5_digest": "b325bcf372b642fb6f5fe60099a5c0d7", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 73774, "upload_time": "2018-09-25T06:46:32", "upload_time_iso_8601": "2018-09-25T06:46:32.166720Z", "url": "https://files.pythonhosted.org/packages/76/33/1f64c1a66d4fcdaecfeef59888973de6071bd77159518973051eecf2ef87/batchup-0.2.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "991437324e390601251ee109cfa65c70", "sha256": "eb8a4735c5320b9389e6b8d086cdb133280d647a6b30379bf29cbf93266e3007"}, "downloads": -1, "filename": "batchup-0.2.1.tar.gz", "has_sig": false, "md5_digest": "991437324e390601251ee109cfa65c70", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 62960, "upload_time": "2018-09-25T06:46:33", "upload_time_iso_8601": "2018-09-25T06:46:33.678240Z", "url": "https://files.pythonhosted.org/packages/ce/f6/deeb7848393a699388cb1b92df96b2f35a723f7893242ed7375f45aa05d4/batchup-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "66aed0bc3f2b5ba85a6503664f110185", "sha256": "aecd529266c592725793514d657a3d578c0e6badbfabc52a5fcd222bc2ef44fb"}, "downloads": -1, "filename": "batchup-0.2.2.tar.gz", "has_sig": false, "md5_digest": "66aed0bc3f2b5ba85a6503664f110185", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 59559, "upload_time": "2019-04-13T13:05:41", "upload_time_iso_8601": "2019-04-13T13:05:41.915212Z", "url": "https://files.pythonhosted.org/packages/dd/48/6041a68b292345d4f043aa2c278a1926706a637baac405bc14eb6bf117be/batchup-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "034ea364223d8e170528c79e111e237d", "sha256": "0eec2e49bae52b9ffb2aa5a191605cbf6668d0daaece3d02569836abbfbce9c1"}, "downloads": -1, "filename": "batchup-0.2.3-py3-none-any.whl", "has_sig": false, "md5_digest": "034ea364223d8e170528c79e111e237d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 72485, "upload_time": "2019-07-05T13:24:15", "upload_time_iso_8601": "2019-07-05T13:24:15.182606Z", "url": "https://files.pythonhosted.org/packages/ec/c1/698b2eb8bbdb2137da0be85572db2a044c3e44d9f435e4565d04947cbd50/batchup-0.2.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ea4d0e4c50039b92ea964f776fa03f9e", "sha256": "8c952ad2b18261d2b224468a1b42648102fcd8696256ae5eb338cfd97a90f317"}, "downloads": -1, "filename": "batchup-0.2.3.tar.gz", "has_sig": false, "md5_digest": "ea4d0e4c50039b92ea964f776fa03f9e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 60095, "upload_time": "2019-07-05T13:24:17", "upload_time_iso_8601": "2019-07-05T13:24:17.308988Z", "url": "https://files.pythonhosted.org/packages/56/4a/a2f72c7fb945a94ca53dd3e73c2b0caf0cf464b42daa054e6e1d4ca60208/batchup-0.2.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "034ea364223d8e170528c79e111e237d", "sha256": "0eec2e49bae52b9ffb2aa5a191605cbf6668d0daaece3d02569836abbfbce9c1"}, "downloads": -1, "filename": "batchup-0.2.3-py3-none-any.whl", "has_sig": false, "md5_digest": "034ea364223d8e170528c79e111e237d", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 72485, "upload_time": "2019-07-05T13:24:15", "upload_time_iso_8601": "2019-07-05T13:24:15.182606Z", "url": "https://files.pythonhosted.org/packages/ec/c1/698b2eb8bbdb2137da0be85572db2a044c3e44d9f435e4565d04947cbd50/batchup-0.2.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ea4d0e4c50039b92ea964f776fa03f9e", "sha256": "8c952ad2b18261d2b224468a1b42648102fcd8696256ae5eb338cfd97a90f317"}, "downloads": -1, "filename": "batchup-0.2.3.tar.gz", "has_sig": false, "md5_digest": "ea4d0e4c50039b92ea964f776fa03f9e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 60095, "upload_time": "2019-07-05T13:24:17", "upload_time_iso_8601": "2019-07-05T13:24:17.308988Z", "url": "https://files.pythonhosted.org/packages/56/4a/a2f72c7fb945a94ca53dd3e73c2b0caf0cf464b42daa054e6e1d4ca60208/batchup-0.2.3.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:14:44 2020"}