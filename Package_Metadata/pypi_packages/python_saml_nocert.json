{"info": {"author": "OneLogin", "author_email": "support@onelogin.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "Intended Audience :: System Administrators", "Operating System :: OS Independent", "Programming Language :: Python :: 2.7"], "description": "# OneLogin's SAML Python Toolkit\n\n[![Build Status](https://api.travis-ci.org/onelogin/python-saml.png?branch=master)](http://travis-ci.org/onelogin/python-saml)\n[![Coverage Status](https://coveralls.io/repos/onelogin/python-saml/badge.png)](https://coveralls.io/r/onelogin/python-saml)\n[![PyPi Version](https://img.shields.io/pypi/v/python-saml.svg)](https://pypi.python.org/pypi/python-saml)\n![Python versions](https://img.shields.io/pypi/pyversions/python-saml.svg)\n\nAdd SAML support to your Python software using this library.\nForget those complicated libraries and use the open source library provided\nand supported by OneLogin Inc.\n\nThis version supports Python2. There is a separate version that supports\nPython3: [python3-saml](https://github.com/onelogin/python3-saml).\n\n#### Warning ####\n\nUpdate python-saml to 2.2.0, this version includes a security patch that contains extra validations that will prevent signature wrapping attacks. [CVE-2016-1000252](https://github.com/distributedweaknessfiling/DWF-Database-Artifacts/blob/master/DWF/2016/1000252/CVE-2016-1000252.json)\n\npython-saml < v2.2.0 is vulnerable and allows signature wrapping!\n\n#### Security Guidelines ####\n\nIf you believe you have discovered a security vulnerability in this toolkit, please report it at https://www.onelogin.com/security with a description. We follow responsible disclosure guidelines, and will work with you to quickly find a resolution.\n\nWhy add SAML support to my software?\n------------------------------------\n\nSAML is an XML-based standard for web browser single sign-on and is defined by\nthe OASIS Security Services Technical Committee. The standard has been around\nsince 2002, but lately it is becoming popular due its advantages:\n\n * **Usability** - One-click access from portals or intranets, deep linking,\n   password elimination and automatically renewing sessions make life\n   easier for the user.\n * **Security** - Based on strong digital signatures for authentication and\n   integrity, SAML is a secure single sign-on protocol that the largest\n   and most security conscious enterprises in the world rely on.\n * **Speed** - SAML is fast. One browser redirect is all it takes to securely\n   sign a user into an application.\n * **Phishing Prevention** - If you don\u2019t have a password for an app, you\n   can\u2019t be tricked into entering it on a fake login page.\n * **IT Friendly** - SAML simplifies life for IT because it centralizes\n   authentication, provides greater visibility and makes directory\n   integration easier.\n * **Opportunity** - B2B cloud vendor should support SAML to facilitate the\n   integration of their product.\n\nGeneral description\n-------------------\n\nOneLogin's SAML Python toolkit lets you turn your Python application into a SP\n(Service Provider) that can be connected to an IdP (Identity Provider).\n\nSupports:\n\n * SSO and SLO (SP-Initiated and IdP-Initiated).\n * Assertion and nameId encryption.\n * Assertion signatures.\n * Message signatures: AuthNRequest, LogoutRequest, LogoutResponses.\n * Enable an Assertion Consumer Service endpoint.\n * Enable a Single Logout Service endpoint.\n * Publish the SP metadata (which can be signed).\n\nKey features:\n\n * **saml2int** - Implements the SAML 2.0 Web Browser SSO Profile.\n * **Session-less** - Forget those common conflicts between the SP and\n   the final app, the toolkit delegate session in the final app.\n * **Easy to use** - Programmer will be allowed to code high-level and\n   low-level programming, 2 easy to use APIs are available.\n * **Tested** - Thoroughly tested.\n * **Popular** - OneLogin's customers use it. Add easy support to your django/flask/bottle web projects.\n\n\nInstallation\n------------\n\n### Dependencies ###\n\n * python 2.7\n * [dm.xmlsec.binding](https://pypi.python.org/pypi/dm.xmlsec.binding)  Cython/lxml based binding for the XML security library (depends on python-dev libxml2-dev libxmlsec1-dev)\n * [isodate](https://pypi.python.org/pypi/isodate)  An ISO 8601 date/time/duration parser and formater\n * [defusedxml](https://pypi.python.org/pypi/defusedxml)  XML bomb protection for Python stdlib modules\n\n\nReview the setup.py file to know the version of the library that python-saml is using\n\n### OSX Dependencies ###\n\n * python 2.7\n * libxmlsec1\n\n```sh\n# using brew\n$ brew install libxmlsec1\n```\n\n\n### Code ###\n\n#### Option 1. Download from github ####\n\nThe toolkit is hosted on github. You can download it from:\n\n * Lastest release: https://github.com/onelogin/python-saml/releases/latest\n * Master repo: https://github.com/onelogin/python-saml/tree/master\n\nCopy the core of the library (src/onelogin/saml2 folder) and merge the setup.py inside the python application. (each application has its structure so take your time to locate the Python SAML toolkit in the best place).\n\n#### Option 2. Download from pypi ####\n\nThe toolkit is hosted in pypi, you can find the python-saml package at https://pypi.python.org/pypi/python-saml\n\nYou can install it executing:\n```\n$ pip install python-saml\n```\n\nIf you want to know how a project can handle python packages review this [guide](https://packaging.python.org/en/latest/tutorial.html) and review this [sampleproject](https://github.com/pypa/sampleproject)\n\n\nSecurity warning\n----------------\n\nIn production, the **strict** parameter MUST be set as **\"true\"**. Otherwise\nyour environment is not secure and will be exposed to attacks.\n\n\nGetting started\n---------------\n\n### Knowing the toolkit ###\n\nThe new OneLogin SAML Toolkit contains different folders (certs, lib, demo-django, demo-flask, demo-bottle and tests) and some files.\n\nLet's start describing them:\n\n#### src ####\n\nThis folder contains the heart of the toolkit, **onelogin/saml2** folder contains the new version of\nthe classes and methods that are described in a later section.\n\n#### demo-django ####\n\nThis folder contains a Django project that will be used as demo to show how to add SAML support to the Django Framework. 'demo' is the main folder of the django project (with its settings.py, views.py, urls.py), 'templates' is the django templates of the project and 'saml' is a folder that contains the 'certs' folder that could be used to store the x509 public and private key, and the saml toolkit settings (settings.json and advanced_settings.json).\n\n***Notice about certs***\n\nSAML requires a x.509 cert to sign and encrypt elements like NameID, Message, Assertion, Metadata.\n\nIf our environment requires sign or encrypt support, the certs folder may contain the x509 cert and the private key that the SP will use:\n\n* sp.crt The public cert of the SP\n* sp.key The private key of the SP\n\nOr also we can provide those data in the setting file at the 'x509cert' and the privateKey' json parameters of the 'sp' element.\n\nSometimes we could need a signature on the metadata published by the SP, in this case we could use the x.509 cert previously mentioned or use a new x.509 cert: metadata.crt and metadata.key.\n\nIf you want to create self-signed certs, you can do it at the https://www.samltool.com/self_signed_certs.php service, or using the command:\n\n```bash\nopenssl req -new -x509 -days 3652 -nodes -out sp.crt -keyout saml.key\n```\n\n#### demo-bottle ####\n\nThis folder contains a Bottle project that will be used as demo to show how to add SAML support to the Bottle Framework. index.py contains all the logic of the demo project, 'templates' is the Bottle templates of the project and 'saml' is a folder that contains the 'certs' folder that could be used to store the x509 public and private key, and the saml toolkit settings (settings.json and advanced_settings.json).\n\n\n#### demo-flask ####\n\nThis folder contains a Flask project that will be used as demo to show how to add SAML support to the Flask Framework. 'index.py' is the main flask file that has all the code, this file uses the templates stored at the 'templates' folder. In the 'saml' folder we found the 'certs' folder to store the x509 public and private key, and the saml toolkit settings (settings.json and advanced_settings.json).\n\n#### setup.py ####\n\nSetup script is the centre of all activity in building, distributing, and installing modules.\nRead more at https://pythonhosted.org/an_example_pypi_project/setuptools.html\n\n#### tests ####\n\nContains the unit test of the toolkit.\n\nIn order to execute the test you need to load the virtualenv with the toolkit installed on it and execute:\n```\npip install -e \".[test]\"\n```\nthat will install dependences that the test requires.\n\nand later execute:\n```\npython setup.py test\n```\nThe previous line will run the tests for the whole toolkit. You can also run the tests for a specific module. To do so for the auth module you would have to execute this:\n```\npython setup.py test --test-suite tests.src.OneLogin.saml2_tests.auth_test.OneLogin_Saml2_Auth_Test\n```\n\nWith the --test-suite parameter you can specify the module to test. You'll find all the module available and their class names at tests/src/OneLogin/saml2_tests/\n\n### How it works ###\n\n#### Settings ####\n\nFirst of all we need to configure the toolkit. The SP's info, the IdP's info, and in some cases, configure advanced security issues like signatures and encryption.\n\nThere are two ways to provide the settings information:\n\n* Use a settings.json file that we should locate in any folder, but indicates its path with the 'custom_base_path' parameter.\n\n* Use a json object with the setting data and provide it directly to the constructor of the class (if your toolkit integation requires certs, remember to provide the 'custom_base_path' as part of the settings or as a parameter in the constructor.\n\nIn the demo-django, demo-flask and demo-bottle folders you will find a 'saml' folder, inside there is a 'certs' folder and a settings.json and a advanced_settings.json files. Those files contain the settings for the saml toolkit. Copy them in your project and set the correct values.\n\nThis is the settings.json file:\n\n```javascript\n{\n    // If strict is True, then the Python Toolkit will reject unsigned\n    // or unencrypted messages if it expects them to be signed or encrypted.\n    // Also it will reject the messages if the SAML standard is not strictly\n    // followed. Destination, NameId, Conditions ... are validated too.\n    \"strict\": true,\n\n    // Enable debug mode (outputs errors).\n    \"debug\": true,\n\n    // Service Provider Data that we are deploying.\n    \"sp\": {\n        // Identifier of the SP entity  (must be a URI)\n        \"entityId\": \"https://<sp_domain>/metadata/\",\n        // Specifies info about where and how the <AuthnResponse> message MUST be\n        // returned to the requester, in this case our SP.\n        \"assertionConsumerService\": {\n            // URL Location where the <Response> from the IdP will be returned\n            \"url\": \"https://<sp_domain>/?acs\",\n            // SAML protocol binding to be used when returning the <Response>\n            // message. OneLogin Toolkit supports this endpoint for the\n            // HTTP-POST binding only.\n            \"binding\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\"\n        },\n        // If you need to specify requested attributes, set a\n        // attributeConsumingService. nameFormat, attributeValue and\n        // friendlyName can be omitted\n        \"attributeConsumingService\": {\n                \"serviceName\": \"SP test\",\n                \"serviceDescription\": \"Test Service\",\n                \"requestedAttributes\": [\n                    {\n                        \"name\": \"\",\n                        \"isRequired\": false,\n                        \"nameFormat\": \"\",\n                        \"friendlyName\": \"\",\n                        \"attributeValue\": []\n                    }\n                ]\n        },\n        // Specifies info about where and how the <Logout Response> message MUST be\n        // returned to the requester, in this case our SP.\n        \"singleLogoutService\": {\n            // URL Location where the <Response> from the IdP will be returned\n            \"url\": \"https://<sp_domain>/?sls\",\n            // SAML protocol binding to be used when returning the <Response>\n            // message. OneLogin Toolkit supports the HTTP-Redirect binding\n            // only for this endpoint.\n            \"binding\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\"\n        },\n        // Specifies the constraints on the name identifier to be used to\n        // represent the requested subject.\n        // Take a look on src/onelogin/saml2/constants.py to see the NameIdFormat that are supported.\n        \"NameIDFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\",\n        // Usually x509cert and privateKey of the SP are provided by files placed at\n        // the certs folder. But we can also provide them with the following parameters\n        \"x509cert\": \"\",\n        \"privateKey\": \"\"\n    },\n\n    // Identity Provider Data that we want connected with our SP.\n    \"idp\": {\n        // Identifier of the IdP entity  (must be a URI)\n        \"entityId\": \"https://app.onelogin.com/saml/metadata/<onelogin_connector_id>\",\n        // SSO endpoint info of the IdP. (Authentication Request protocol)\n        \"singleSignOnService\": {\n            // URL Target of the IdP where the Authentication Request Message\n            // will be sent.\n            \"url\": \"https://app.onelogin.com/trust/saml2/http-post/sso/<onelogin_connector_id>\",\n            // SAML protocol binding to be used when returning the <Response>\n            // message. OneLogin Toolkit supports the HTTP-Redirect binding\n            // only for this endpoint.\n            \"binding\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\"\n        },\n        // SLO endpoint info of the IdP.\n        \"singleLogoutService\": {\n            // URL Location of the IdP where SLO Request will be sent.\n            \"url\": \"https://app.onelogin.com/trust/saml2/http-redirect/slo/<onelogin_connector_id>\",\n            // SAML protocol binding to be used when returning the <Response>\n            // message. OneLogin Toolkit supports the HTTP-Redirect binding\n            // only for this endpoint.\n            \"binding\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\"\n        },\n        // Public x509 certificate of the IdP\n        \"x509cert\": \"<onelogin_connector_cert>\"\n        /*\n         *  Instead of using the whole x509cert you can use a fingerprint in order to\n         *  validate a SAMLResponse, but you will need it to validate LogoutRequest and LogoutResponse using the HTTP-Redirect binding.\n         *\n         *  (openssl x509 -noout -fingerprint -in \"idp.crt\" to generate it,\n         *  or add for example the -sha256 , -sha384 or -sha512 parameter)\n         *\n         *  If a fingerprint is provided, then the certFingerprintAlgorithm is required in order to\n         *  let the toolkit know which algorithm was used. Possible values: sha1, sha256, sha384 or sha512\n         *  'sha1' is the default value.\n         *\n         *  Notice that if you want to validate any SAML Message sent by the HTTP-Redirect binding, you\n         *  will need to provide the whole x509cert.\n         */\n        // 'certFingerprint' => '',\n        // 'certFingerprintAlgorithm' => 'sha1',\n    }\n}\n```\n\nIn addition to the required settings data (idp, sp), extra settings can be defined in `advanced_settings.json`:\n\n```javascript\n{\n    // Security settings\n    \"security\": {\n\n        /** signatures and encryptions offered **/\n\n        // Indicates that the nameID of the <samlp:logoutRequest> sent by this SP\n        // will be encrypted.\n        \"nameIdEncrypted\": false,\n\n        // Indicates whether the <samlp:AuthnRequest> messages sent by this SP\n        // will be signed.  [Metadata of the SP will offer this info]\n        \"authnRequestsSigned\": false,\n\n        // Indicates whether the <samlp:logoutRequest> messages sent by this SP\n        // will be signed.\n        \"logoutRequestSigned\": false,\n\n        // Indicates whether the <samlp:logoutResponse> messages sent by this SP\n        // will be signed.\n        \"logoutResponseSigned\": false,\n\n        /* Sign the Metadata\n         false || true (use sp certs) || {\n                                            \"keyFileName\": \"metadata.key\",\n                                            \"certFileName\": \"metadata.crt\"\n                                         }\n        */\n        \"signMetadata\": false,\n\n        /** signatures and encryptions required **/\n\n        // Indicates a requirement for the <samlp:Response>, <samlp:LogoutRequest>\n        // and <samlp:LogoutResponse> elements received by this SP to be signed.\n        \"wantMessagesSigned\": false,\n\n        // Indicates a requirement for the <saml:Assertion> elements received by\n        // this SP to be signed. [Metadata of the SP will offer this info]\n        \"wantAssertionsSigned\": false,\n\n        // Indicates a requirement for the <saml:Assertion>\n        // elements received by this SP to be encrypted.\n        \"wantAssertionsEncrypted\": false,\n\n        // Indicates a requirement for the NameID element on the SAMLResponse\n        // received by this SP to be present.\n        \"wantNameId\": true,\n\n        // Indicates a requirement for the NameID received by\n        // this SP to be encrypted.\n        \"wantNameIdEncrypted\": false,\n\n        // Indicates a requirement for the AttributeStatement element\n        \"wantAttributeStatement\": true,\n\n        // Authentication context.\n        // Set to false and no AuthContext will be sent in the AuthNRequest,\n        // Set true or don't present this parameter and you will get an AuthContext 'exact' 'urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport'\n        // Set an array with the possible auth context values: array ('urn:oasis:names:tc:SAML:2.0:ac:classes:Password', 'urn:oasis:names:tc:SAML:2.0:ac:classes:X509'),\n        \"requestedAuthnContext\": true,\n        // Allows the authn comparison parameter to be set, defaults to 'exact' if the setting is not present.\n        \"requestedAuthnContextComparison\": \"exact\",\n\n        // In some environment you will need to set how long the published metadata of the Service Provider gonna be valid.\n        // is possible to not set the 2 following parameters (or set to null) and default values will be set (2 days, 1 week)\n        // Provide the desired Timestamp, for example 2015-06-26T20:00:00Z\n        \"metadataValidUntil\": null,\n        // Provide the desired duration, for example PT518400S (6 days)\n        \"metadataCacheDuration\": null,\n\n        // Algorithm that the toolkit will use on signing process. Options:\n        //    'http://www.w3.org/2000/09/xmldsig#rsa-sha1'\n        //    'http://www.w3.org/2000/09/xmldsig#dsa-sha1'\n        //    'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256'\n        //    'http://www.w3.org/2001/04/xmldsig-more#rsa-sha384'\n        //    'http://www.w3.org/2001/04/xmldsig-more#rsa-sha512'\n        \"signatureAlgorithm\": \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\",\n\n        // Algorithm that the toolkit will use on digest process. Options:\n        //    'http://www.w3.org/2000/09/xmldsig#sha1'\n        //    'http://www.w3.org/2001/04/xmlenc#sha256'\n        //    'http://www.w3.org/2001/04/xmldsig-more#sha384'\n        //    'http://www.w3.org/2001/04/xmlenc#sha512'\n        \"digestAlgorithm\": \"http://www.w3.org/2000/09/xmldsig#sha1\"\n    },\n\n    // Contact information template, it is recommended to supply\n    // technical and support contacts.\n    \"contactPerson\": {\n        \"technical\": {\n            \"givenName\": \"technical_name\",\n            \"emailAddress\": \"technical@example.com\"\n        },\n        \"support\": {\n            \"givenName\": \"support_name\",\n            \"emailAddress\": \"support@example.com\"\n        }\n    },\n\n    // Organization information template, the info in en_US lang is\n    // recommended, add more if required.\n    \"organization\": {\n        \"en-US\": {\n            \"name\": \"sp_test\",\n            \"displayname\": \"SP test\",\n            \"url\": \"http://sp.example.com\"\n        }\n    }\n}\n```\n\nIn the security section, you can set the way that the SP will handle the messages and assertions. Contact the admin of the IdP and ask them what the IdP expects, and decide what validations will handle the SP and what requirements the SP will have and communicate them to the IdP's admin too.\n\nOnce we know what kind of data could be configured, let's talk about the way settings are handled within the toolkit.\n\nThe settings files described (settings.json and advanced_settings.json) are loaded by the toolkit if not other dict with settings info is provided in the constructors of the toolkit. Let's see some examples.\n\n```python\n# Initializes toolkit with settings.json & advanced_settings.json files.\nauth = OneLogin_Saml2_Auth(req)\n# or\nsettings = OneLogin_Saml2_Settings()\n\n# Initializes toolkit with settings.json & advanced_settings.json files from a custom base path.\ncustom_folder = '/var/www/django-project'\nauth = OneLogin_Saml2_Auth(req, custom_base_path=custom_folder)\n# or\nsettings = OneLogin_Saml2_Settings(custom_base_path=custom_folder)\n\n# Initializes toolkit with the dict provided.\nauth = OneLogin_Saml2_Auth(req, settings_data)\n# or\nsettings = OneLogin_Saml2_Settings(settings_data)\n```\n\nYou can declare the settings_data in the file that constains the constructor execution or locate them in any file and load the file in order to get the dict available as we see in the following example:\n\n```python\nfilename = \"/var/www/django-project/custom_settings.json\" # The custom_settings.json contains a\njson_data_file = open(filename, 'r')                      # settings_data dict.\nsettings_data = json.load(json_data_file)\njson_data_file.close()\n\nauth = OneLogin_Saml2_Auth(req, settings_data)\n```\n\n#### How load the library ####\n\nIn order to use the toolkit library you need to import the file that contains the class that you will need\non the top of your python file.\n\n``` python\nfrom onelogin.saml2.auth import OneLogin_Saml2_Auth\nfrom onelogin.saml2.settings import OneLogin_Saml2_Settings\nfrom onelogin.saml2.utils import OneLogin_Saml2_Utils\n```\n\n#### The Request ####\n\nBuilding an OneLogin_Saml2_Auth object requires a 'request' parameter.\n\n```python\nauth = OneLogin_Saml2_Auth(req)\n```\n\nThis parameter has the following scheme:\n\n```javascript\nreq = {\n    \"http_host\": \"\",\n    \"script_name\": \"\",\n    \"server_port\": \"\",\n    \"get_data\": \"\",\n    \"post_data\": \"\"\n}\n```\n\nEach python framework built its own request object, you may map its data to match what the saml toolkit expects.\nLet`s see some examples:\n\n```python\ndef prepare_from_django_request(request):\n    return {\n        'http_host': request.META['HTTP_HOST'],\n        'script_name': request.META['PATH_INFO'],\n        'server_port': request.META['SERVER_PORT'],\n        'get_data': request.GET.copy(),\n        'post_data': request.POST.copy()\n    }\n\ndef prepare_from_flask_request(request):\n    url_data = urlparse(request.url)\n    return {\n        'http_host': request.host,\n        'server_port': url_data.port,\n        'script_name': request.path,\n        'get_data': request.args.copy(),\n        'post_data': request.form.copy()\n    }\n```\n\n\n#### Initiate SSO ####\n\nIn order to send an AuthNRequest to the IdP:\n\n```python\nfrom onelogin.saml2.auth import OneLogin_Saml2_Auth\n\nreq = prepare_request_for_toolkit(request)\nauth = OneLogin_Saml2_Auth(req)   # Constructor of the SP, loads settings.json\n                                  # and advanced_settings.json\n\nauth.login()      # Method that builds and sends the AuthNRequest\n```\n\nThe AuthNRequest will be sent signed or unsigned based on the security info of the advanced_settings.json ('authnRequestsSigned').\n\nThe IdP will then return the SAML Response to the user's client. The client is then forwarded to the Attribute Consumer Service of the SP with this information.\n\nWe can set a 'return_to' url parameter to the login function and that will be converted as a 'RelayState' parameter:\n\n```python\ntarget_url = 'https://example.com'\nauth.login(return_to=target_url)\n```\nThe login method can recieve 3 more optional parameters:\n\n* force_authn       When true the AuthNReuqest will set the ForceAuthn='true'\n* is_passive        When true the AuthNReuqest will set the Ispassive='true'\n* set_nameid_policy When true the AuthNReuqest will set a nameIdPolicy element.\n\nIf a match on the future SAMLResponse ID and the AuthNRequest ID to be sent is required, that AuthNRequest ID must to be extracted and stored for future validation, we can get that ID by\n\n```python\nauth.get_last_request_id()\n```\n\n#### The SP Endpoints ####\n\nRelated to the SP there are 3 important endpoints: The metadata view, the ACS view and the SLS view.\nThe toolkit provides examples of those views in the demos, but lets see an example.\n\n***SP Metadata***\n\nThis code will provide the XML metadata file of our SP, based on the info that we provided in the settings files.\n\n```python\nreq = prepare_request_for_toolkit(request)\nauth = OneLogin_Saml2_Auth(req)\nsaml_settings = auth.get_settings()\nmetadata = saml_settings.get_sp_metadata()\nerrors = saml_settings.validate_metadata(metadata)\nif len(errors) == 0:\n    print metadata\nelse:\n    print \"Error found on Metadata: %s\" % (', '.join(errors))\n```\n\nThe get_sp_metadata will return the metadata signed or not based on the security info of the advanced_settings.json ('signMetadata').\n\nBefore the XML metadata is exposed, a check takes place to ensure that the info to be provided is valid.\n\nInstead of using the Auth object, you can directly use\n```\nsaml_settings = OneLogin_Saml2_Settings(settings=None, custom_base_path=None, sp_validation_only=True)\n```\nto get the settings object and with the sp_validation_only=True parameter we will avoid the IdP Settings validation.\n\n***Attribute Consumer Service(ACS)***\n\nThis code handles the SAML response that the IdP forwards to the SP through the user's client.\n\n```python\nreq = prepare_request_for_toolkit(request)\nauth = OneLogin_Saml2_Auth(req)\nauth.process_response()\nerrors = auth.get_errors()\nif not errors:\n    if auth.is_authenticated():\n        request.session['samlUserdata'] = auth.get_attributes()\n        if 'RelayState' in req['post_data'] and\n          OneLogin_Saml2_Utils.get_self_url(req) != req['post_data']['RelayState']:\n            auth.redirect_to(req['post_data']['RelayState'])\n        else:\n            for attr_name in request.session['samlUserdata'].keys():\n                print '%s ==> %s' % (attr_name, '|| '.join(request.session['samlUserdata'][attr_name]))\n    else:\n      print 'Not authenticated'\nelse:\n    print \"Error when processing SAML Response: %s\" % (', '.join(errors))\n```\n\nThe SAML response is processed and then checked that there are no errors. It also verifies that the user is authenticated and stored the userdata in session.\n\nAt that point there are 2 possible alternatives:\n\n* If no RelayState is provided, we could show the user data in this view or however we wanted.\n* If RelayState is provided, a rediretion take place.\n\nNotice that we saved the user data in the session before the redirection to have the user data available at the RelayState view.\n\nIn order to retrieve attributes we use:\n\n```python\nattributes = auth.get_attributes();\n```\n\nWith this method we get a dict with all the user data provided by the IdP in the Assertion of the SAML Response.\n\nIf we execute print attributes we could get:\n\n```python\n{\n    \"cn\": [\"Jhon\"],\n    \"sn\": [\"Doe\"],\n    \"mail\": [\"Doe\"],\n    \"groups\": [\"users\", \"members\"]\n}\n```\n\nEach attribute name can be used as a key to obtain the value. Every attribute is a list of values. A single-valued attribute is a listy of a single element.\n\nThe following code is equivalent:\n\n```python\nattributes = auth.get_attributes();\nprint attributes['cn']\n\nprint auth.get_attribute('cn')\n```\n\nBefore trying to get an attribute, check that the user is authenticated. If the user isn't authenticated, an empty dict will be returned. For example, if we call to get_attributes before a auth.process_response, the get_attributes() will return an empty dict.\n\n\n***Single Logout Service (SLS)***\n\nThis code handles the Logout Request and the Logout Responses.\n\n```python\ndelete_session_callback = lambda: request.session.flush()\nurl = auth.process_slo(delete_session_cb=delete_session_callback)\nerrors = auth.get_errors()\nif len(errors) == 0:\n    if url is not None:\n        return redirect(url)\n    else:\n        print \"Sucessfully Logged out\"\nelse:\n    print \"Error when processing SLO: %s\" % (', '.join(errors))\n```\n\nIf the SLS endpoints receives a Logout Response, the response is validated and the session could be closed, using the callback.\n\n```python\n# Part of the process_slo method\nlogout_response = OneLogin_Saml2_Logout_Response(self.__settings, self.__request_data['get_data']['SAMLResponse'])\nif not logout_response.is_valid(self.__request_data, request_id):\n    self.__errors.append('invalid_logout_response')\nelif logout_response.get_status() != OneLogin_Saml2_Constants.STATUS_SUCCESS:\n    self.__errors.append('logout_not_success')\nelif not keep_local_session:\n    OneLogin_Saml2_Utils.delete_local_session(delete_session_cb)\n```\n\nIf the SLS endpoints receives an Logout Request, the request is validated, the session is closed and a Logout Response is sent to the SLS endpoint of the IdP.\n\n```python\n# Part of the process_slo method\nrequest = OneLogin_Saml2_Utils.decode_base64_and_inflate(self.__request_data['get_data']['SAMLRequest'])\nif not OneLogin_Saml2_Logout_Request.is_valid(self.__settings, request, self.__request_data):\n    self.__errors.append('invalid_logout_request')\nelse:\n    if not keep_local_session:\n        OneLogin_Saml2_Utils.delete_local_session(delete_session_cb)\n\n    in_response_to = request.id\n    response_builder = OneLogin_Saml2_Logout_Response(self.__settings)\n    response_builder.build(in_response_to)\n    logout_response = response_builder.get_response()\n\n    parameters = {'SAMLResponse': logout_response}\n    if 'RelayState' in self.__request_data['get_data']:\n        parameters['RelayState'] = self.__request_data['get_data']['RelayState']\n\n    security = self.__settings.get_security_data()\n    if 'logoutResponseSigned' in security and security['logoutResponseSigned']:\n        parameters['SigAlg'] = OneLogin_Saml2_Constants.RSA_SHA1\n        parameters['Signature'] = self.build_response_signature(logout_response, parameters.get('RelayState', None))\n\n    return self.redirect_to(self.get_slo_url(), parameters)\n```\n\nIf we don't want that process_slo to destroy the session, pass a true parameter to the process_slo method\n\n```python\nkeepLocalSession = true\nauth.process_slo(keep_local_session=keepLocalSession);\n```\n\n#### Initiate SLO ####\n\nIn order to send a Logout Request to the IdP:\n```python\nfrom onelogin.saml2.auth import OneLogin_Saml2_Auth\n\nreq = prepare_request_for_toolkit(request)\nauth = OneLogin_Saml2_Auth(req)   # Constructor of the SP, loads settings.json\n                                  # and advanced_settings.json\n\nauth.logout()      # Method that builds and sends the LogoutRequest\n```\n\nThe Logout Request will be sent signed or unsigned based on the security info of the advanced_settings.json ('logoutRequestSigned').\n\nThe IdP will return the Logout Response through the user's client to the Single Logout Service of the SP.\n\nWe can set a 'return_to' url parameter to the logout function and that will be converted as a 'RelayState' parameter:\n\n```python\ntarget_url = 'https://example.com'\nauth.logout(return_to=target_url)\n```\n\nAlso there are 2 optional parameters that can be set:\n\n* name_id. That will be used to build the LogoutRequest. If not name_id parameter is set and the auth object processed a\nSAML Response with a NameId, then this NameId will be used.\n* session_index. SessionIndex that identifies the session of the user.\n\nIf a match on the LogoutResponse ID and the LogoutRequest ID to be sent is required, that LogoutRequest ID must to be extracted and stored for future validation, we can get that ID by\n\n```python\nauth.get_last_request_id()\n```\n\n####Example of a view that initiates the SSO request and handles the response (is the acs target)####\n\nWe can code a unique file that initiates the SSO process, handle the response, get the attributes, initiate the slo and processes the logout response.\n\nNote: Review the demos, in a later section we explain the demo use case further in detail.\n\n```python\nreq = prepare_request_for_toolkit(request)  # Process the request and build the request dict that\n                                            # the toolkit expects\n\nauth = OneLogin_Saml2_Auth(req)             # Initialize the SP SAML instance\n\nif 'sso' in request.args:                   # SSO action (SP-SSO initited).  Will send an AuthNRequest to the IdP\n    return redirect(auth.login())\nelif 'sso2' in request.args:                       # Another SSO init action\n    return_to = '%sattrs/' % request.host_url      # but set a custom RelayState URL\n    return redirect(auth.login(return_to))\nelif 'slo' in request.args:                     # SLO action. Will sent a Logout Request to IdP\n    return redirect(auth.logout())\nelif 'acs' in request.args:                 # Assertion Consumer Service\n    auth.process_response()                     # Process the Response of the IdP\n    errors = auth.get_errors()              # This method receives an array with the errors\n    if len(errors) == 0:                    # that could took place during the process\n        if not auth.is_authenticated():         # This check if the response was ok and the user\n            msg = \"Not authenticated\"           # data retrieved or not (user authenticated)\n        else:\n            request.session['samlUserdata'] = auth.get_attributes()     # Retrieves user data\n            self_url = OneLogin_Saml2_Utils.get_self_url(req)\n            if 'RelayState' in request.form and self_url != request.form['RelayState']:\n                return redirect(auth.redirect_to(request.form['RelayState']))   # Redirect if there is a relayState\n            else:                           # If there is user data we save that to print it later.\n                msg = ''\n                for attr_name in request.session['samlUserdata'].keys():\n                    msg += '%s ==> %s' % (attr_name, '|| '.join(request.session['samlUserdata'][attr_name]))\nelif 'sls' in request.args:                                             # Single Logout Service\n    delete_session_callback = lambda: session.clear()           # Obtain session clear callback\n    url = auth.process_slo(delete_session_cb=delete_session_callback)   # Process the Logout Request & Logout Response\n    errors = auth.get_errors()              #  Retrieves possible validation errors\n    if len(errors) == 0:\n        if url is not None:\n            return redirect(url)\n        else:\n            msg = \"Sucessfully logged out\"\n\nif len(errors) == 0:\n  print msg\nelse:\n  print ', '.join(errors)\n```\n\n\n### Main classes and methods ###\n\nDescribed below are the main classes and methods that can be invoked from the SAML2 library.\n\n####OneLogin_Saml2_Auth - auth.py####\n\nMain class of OneLogin Python Toolkit\n\n* `__init__` Initializes the SP SAML instance.\n* ***login*** Initiates the SSO process.\n* ***logout*** Initiates the SLO process.\n* ***process_response*** Process the SAML Response sent by the IdP.\n* ***process_slo*** Process the SAML Logout Response / Logout Request sent by the IdP.\n* ***redirect_to*** Redirects the user to the url past by parameter or to the url that we defined in our SSO Request.\n* ***is_authenticated*** Checks if the user is authenticated or not.\n* ***get_attributes*** Returns the set of SAML attributes.\n* ***get_attribute*** Returns the requested SAML attribute.\n* ***get_nameid*** Returns the nameID.\n* ***get_session_index*** Gets the SessionIndex from the AuthnStatement.\n* ***get_session_expiration*** Gets the SessionNotOnOrAfter from the AuthnStatement.\n* ***get_errors*** Returns a list with code errors if something went wrong.\n* ***get_last_error_reason*** Returns the reason of the last error\n* ***get_sso_url*** Gets the SSO url.\n* ***get_slo_url*** Gets the SLO url.\n* ***get_last_request_id*** The ID of the last Request SAML message generated (AuthNRequest, LogoutRequest).\n* ***build_request_signature*** Builds the Signature of the SAML Request.\n* ***build_response_signature*** Builds the Signature of the SAML Response.\n* ***get_settings*** Returns the settings info.\n* ***set_strict*** Set the strict mode active/disable.\n* ***get_last_request_xml*** Returns the most recently-constructed/processed XML SAML request (AuthNRequest, LogoutRequest)\n* ***get_last_response_xml*** Returns the most recently-constructed/processed XML SAML response (SAMLResponse, LogoutResponse). If the SAMLResponse had an encrypted assertion, decrypts it.\n\n####OneLogin_Saml2_Auth - authn_request.py####\n\nSAML 2 Authentication Request class\n\n* `__init__` This class handles an AuthNRequest. It builds an AuthNRequest object.\n* ***get_request*** Returns unsigned AuthnRequest.\n* ***get_id*** Returns the AuthNRequest ID.\n* ***get_xml*** Returns the XML that will be sent as part of the request.\n\n####OneLogin_Saml2_Response - response.py####\n\nSAML 2 Authentication Response class\n\n* `__init__` Constructs the SAML Response object.\n* ***is_valid*** Determines if the SAML Response is valid. Includes checking of the signature by a certificate.\n* ***check_status*** Check if the status of the response is success or not\n* ***get_audiences*** Gets the audiences\n* ***get_issuers*** Gets the issuers (from message and from assertion)\n* ***get_nameid_data*** Gets the NameID Data provided by the SAML Response from the IdP (returns a dict)\n* ***get_nameid*** Gets the NameID provided by the SAML Response from the IdP (returns a string)\n* ***get_session_not_on_or_after*** Gets the SessionNotOnOrAfter from the AuthnStatement\n* ***get_session_index*** Gets the SessionIndex from the AuthnStatement\n* ***get_attributes*** Gets the Attributes from the AttributeStatement element.\n* ***validate_num_assertions*** Verifies that the document only contains a single Assertion (encrypted or not)\n* ***validate_timestamps*** Verifies that the document is valid according to Conditions Element\n* ***get_error*** After execute a validation process, if fails this method returns the cause\n* ***get_xml_document*** Returns the SAML Response document (If contains an encrypted assertion, decrypts it).\n\n####OneLogin_Saml2_LogoutRequest - logout_request.py####\n\nSAML 2 Logout Request class\n\n* `__init__` Constructs the Logout Request object.\n* ***get_request*** Returns the Logout Request defated, base64encoded.\n* ***get_id*** Returns the ID of the Logout Request. (If you have the object you can access to the id attribute)\n* ***get_nameid_data*** Gets the NameID Data of the the Logout Request (returns a dict).\n* ***get_nameid*** Gets the NameID of the Logout Request Message (returns a string).\n* ***get_issuer*** Gets the Issuer of the Logout Request Message.\n* ***get_session_indexes*** Gets the SessionIndexes from the Logout Request.\n* ***is_valid*** Checks if the Logout Request recieved is valid.\n* ***get_error*** After execute a validation process, if fails this method returns the cause.\n* ***get_xml*** Returns the XML that will be sent as part of the request or that was received at the SP\n\n####OneLogin_Saml2_LogoutResponse - logout_response.py####\n\nSAML 2 Logout Response class\n\n* `__init__` Constructs a Logout Response object.\n* ***get_issuer*** Gets the Issuer of the Logout Response Message\n* ***get_status*** Gets the Status of the Logout Response.\n* ***is_valid*** Determines if the SAML LogoutResponse is valid\n* ***build*** Creates a Logout Response object.\n* ***get_response*** Returns a Logout Response object.\n* ***get_error*** After execute a validation process, if fails this method returns the cause.\n* ***get_xml*** Returns the XML that will be sent as part of the response or that was received at the SP\n\n\n####OneLogin_Saml2_Settings - settings.py####\n\nConfiguration of the OneLogin Python Toolkit\n\n* `__init__`  Initializes the settings: Sets the paths of the different folders and Loads settings info from settings file or array/object provided.\n* ***check_settings*** Checks the settings info.\n* ***check_idp_settings*** Checks the IdP settings info.\n* ***check_sp_settings*** Checks the SP settings info.\n* ***get_errors*** Returns an array with the errors, the array is empty when the settings is ok.\n* ***get_sp_metadata*** Gets the SP metadata. The XML representation.\n* ***validate_metadata*** Validates an XML SP Metadata.\n* ***get_base_path*** Returns base path.\n* ***get_cert_path*** Returns cert path.\n* ***get_lib_path*** Returns lib path.\n* ***get_ext_lib_path*** Returns external lib path.\n* ***get_schemas_path*** Returns schema path.\n* ***check_sp_certs*** Checks if the x509 certs of the SP exists and are valid.\n* ***get_sp_key*** Returns the x509 private key of the SP.\n* ***get_sp_cert*** Returns the x509 public cert of the SP.\n* ***get_idp_cert*** Returns the x509 public cert of the IdP.\n* ***get_sp_data*** Gets the SP data.\n* ***get_idp_data*** Gets the IdP data.\n* ***get_security_data***  Gets security data.\n* ***get_contacts*** Gets contacts data.\n* ***get_organization*** Gets organization data.\n* ***format_idp_cert*** Formats the IdP cert.\n* ***format_sp_cert*** Formats the SP cert.\n* ***format_sp_key*** Formats the private key.\n* ***set_strict*** Activates or deactivates the strict mode.\n* ***is_strict*** Returns if the 'strict' mode is active.\n* ***is_debug_active*** Returns if the debug is active.\n\n####OneLogin_Saml2_Metadata - metadata.py####\n\nA class that contains functionality related to the metadata of the SP\n\n* ***builder*** Generates the metadata of the SP based on the settings.\n* ***sign_metadata*** Signs the metadata with the key/cert provided.\n* ***add_x509_key_descriptors*** Adds the x509 descriptors (sign/encriptation) to the metadata\n\n####OneLogin_Saml2_Utils - utils.py####\n\nAuxiliary class that contains several methods\n\n* ***decode_base64_and_inflate*** Base64 decodes and then inflates according to RFC1951.\n* ***deflate_and_base64_encode*** Deflates and the base64 encodes a string.\n* ***validate_xml*** Validates a xml against a schema.\n* ***format_cert*** Returns a x509 cert (adding header & footer if required).\n* ***format_private_key*** Returns a private key (adding header & footer if required).\n* ***redirect*** Executes a redirection to the provided url (or return the target url).\n* ***get_self_url_host*** Returns the protocol + the current host + the port (if different than common ports).\n* ***get_self_host*** Returns the current host.\n* ***is_https*** Checks if https or http.\n* ***get_self_url_no_query*** Returns the URL of the current host + current view.\n* ***get_self_routed_url_no_query*** Returns the routed URL of the current host + current view.\n* ***get_self_url*** Returns the URL of the current host + current view + query.\n* ***generate_unique_id*** Generates an unique string (used for example as ID for assertions).\n* ***parse_time_to_SAML*** Converts a UNIX timestamp to SAML2 timestamp on the form yyyy-mm-ddThh:mm:ss(\\.s+)?Z.\n* ***parse_SAML_to_time*** Converts a SAML2 timestamp on the form yyyy-mm-ddThh:mm:ss(\\.s+)?Z to a UNIX timestamp.\n* ***now*** Returns unix timestamp of actual time.\n* ***parse_duration*** Interprets a ISO8601 duration value relative to a given timestamp.\n* ***get_expire_time*** Compares 2 dates and returns the earliest.\n* ***query*** Extracts nodes that match the query from the Element.\n* ***delete_local_session*** Deletes the local session.\n* ***calculate_x509_fingerprint*** Calculates the fingerprint of a x509cert.\n* ***format_finger_print*** Formates a fingerprint.\n* ***generate_name_id*** Generates a nameID.\n* ***get_status*** Gets Status from a Response.\n* ***decrypt_element*** Decrypts an encrypted element.\n* ***write_temp_file*** Writes some content into a temporary file and returns it.\n* ***add_sign*** Adds signature key and senders certificate to an element (Message or Assertion).\n* ***validate_sign*** Validates a signature (Message or Assertion).\n* ***validate_binary_sign*** Validates signed bynary data (Used to validate GET Signature).\n* ***def get_encoded_parameter*** Return an url encoded get parameter value\n* ***extract_raw_query_parameter***\n\n####OneLogin_Saml2_IdPMetadataParser - idp_metadata_parser.py####\n\nA class that contains methods to obtain and parse metadata from IdP\n\n* ***get_metadata*** Get the metadata XML from the provided URL\n* ***parse_remote*** Get the metadata XML from the provided URL and parse it, returning a dict with extracted data\n* ***parse*** Parse the Identity Provider metadata and returns a dict with extracted data\n* ***merge_settings*** Will update the settings with the provided new settings data extracted from the IdP metadata\n\nFor more info, look at the source code; each method is documented and details about what does and how to use it are provided. Make sure to also check the doc folder where HTML documentation about the classes and methods is provided.\n\nDemos included in the toolkit\n-----------------------------\n\nThe toolkit includes 2 demos to teach how use the toolkit (A django and a flask project), take a look on it.\nDemos require that SP and IdP are well configured before test it, so edit the settings files.\n\nNotice that each python framework has it own way to handle routes/urls and process request, so focus on\nhow it deployed. New demos using other python frameworks are welcome as a contribution.\n\n### Getting Started ###\n\nWe said that this toolkit includes a django application demo and a flask applicacion demo,\nlets see how fast is deploy them.\n\n***Virtualenv***\n\nThe use of a [virtualenv](http://virtualenv.readthedocs.org/en/latest/) is\nhighly recommended.\n\nVirtualenv helps isolating the python enviroment used to run the toolkit. You\ncan find more details and an installation guide in the\n[official documentation](http://virtualenv.readthedocs.org/en/latest/).\n\nOnce you have your virtualenv ready and loaded, then you can install the\ntoolkit on it in development mode executing this:\n```\n python setup.py develop\n```\n\nUsing this method of deployment the toolkit files will be linked instead of\ncopied, so if you make changes on them you won't need to reinstall the toolkit.\n\nIf you want install it in a normal mode, execute:\n```\n python setup.py install\n```\n\n### Demo Flask ###\n\nYou'll need a virtualenv with the toolkit installed on it.\n\nTo run the demo you need to install the requirements first. Load your\nvirtualenv and execute:\n\n```\n pip install -r demo-flask/requirements.txt\n```\n\nThis will install flask and its dependences. Once it has finished, you have to complete the configuration\nof the toolkit. You'll find it at `demo-flask/settings.json`\n\nNow, with the virtualenv loaded, you can run the demo like this:\n```\n cd demo-flask\n python index.py\n```\n\nYou'll have the demo running at http://localhost:8000\n\n####Content####\n\nThe flask project contains:\n\n\n* ***index.py*** Is the main flask file, where or the SAML handle take place.\n\n* ***templates***. Is the folder where flask stores the templates of the project. It was implemented a base.html template that is extended by index.html and attrs.html, the templates of our simple demo that shows messages, user attributes when available and login and logout links.\n\n* ***saml*** Is a folder that contains the 'certs' folder that could be used to store the x509 public and private key, and the saml toolkit settings (settings.json and advanced_settings.json).\n\n\n####SP setup####\n\nThe Onelogin's Python Toolkit allows you to provide the settings info in 2 ways: settings files or define a setting dict. In the demo-flask it used the first method.\n\nIn the index.py file we define the app.config['SAML_PATH'], that will target to the 'saml' folder. We require it in order to load the settings files.\n\nFirst we need to edit the saml/settings.json, configure the SP part and  review the metadata of the IdP and complete the IdP info.  Later edit the saml/advanced_settings.json files and configure the how the toolkit will work. Check the settings section of this document if you have any doubt.\n\n####IdP setup####\n\nOnce the SP is configured, the metadata of the SP is published at the /metadata url. Based on that info, configure the IdP.\n\n####How it works####\n\n1. First time you access to the main view 'http://localhost:8000', you can select to login and return to the same view or login and be redirected to /?attrs (attrs view).\n\n 2. When you click:\n\n    2.1 in the first link, we access to /?sso (index view). An AuthNRequest is sent to the IdP, we authenticate at the IdP and then a Response is sent through the user's client to the SP, specifically the Assertion Consumer Service view: /?acs. Notice that a RelayState parameter is set to the url that initiated the process, the index view.\n\n    2.2 in the second link we access to /?attrs (attrs view), we will expetience have the same process described at 2.1 with the diference that as RelayState is set the attrs url.\n\n 3. The SAML Response is processed in the ACS /?acs, if the Response is not valid, the process stops here and a message is shown. Otherwise we are redirected to the RelayState view. a) / or b) /?attrs\n\n 4. We are logged in the app and the user attributes are showed. At this point, we can test the single log out functionality.\n\n The single log out funcionality could be tested by 2 ways.\n\n    5.1 SLO Initiated by SP. Click on the \"logout\" link at the SP, after that a Logout Request is sent to the IdP, the session at the IdP is closed and replies through the client to the SP with a Logout Response (sent to the Single Logout Service endpoint). The SLS endpoint /?sls of the SP process the Logout Response and if is valid, close the user session of the local app. Notice that the SLO Workflow starts and ends at the SP.\n\n    5.2 SLO Initiated by IdP. In this case, the action takes place on the IdP side, the logout process is initiated at the IdP, sends a Logout Request to the SP (SLS endpoint, /?sls). The SLS endpoint of the SP process the Logout Request and if is valid, close the session of the user at the local app and send a Logout Response to the IdP (to the SLS endpoint of the IdP). The IdP receives the Logout Response, process it and close the session at of the IdP. Notice that the SLO Workflow starts and ends at the IdP.\n\nNotice that all the SAML Requests and Responses are handled at a unique view (index) and how GET paramters are used to know the action that must be done.\n\n### Demo Django ###\n\nYou'll need a virtualenv with the toolkit installed on it.\n\nTo run the demo you need to install the requirements first. Load your\nvirtualenv  and execute:\n```\n pip install -r demo-django/requirements.txt\n```\nThis will install django and its dependences. Once it has finished, you have to complete the configuration of the toolkit.\n\nLater, with the virtualenv loaded, you can run the demo like this:\n```\n cd demo-django\n python manage.py runserver 0.0.0.0:8000\n```\n\nYou'll have the demo running at http://localhost:8000.\n\nNote that many of the configuration files expect HTTPS. This is not required by the demo, as replacing these SP URLs with HTTP will work just fine. HTTPS is however highly encouraged, and left as an exercise for the reader for their specific needs.\n\nIf you want to integrate a production django application, take a look on this SAMLServiceProviderBackend that uses our toolkit to add SAML support: https://github.com/KristianOellegaard/django-saml-service-provider\n\n####Content####\n\nThe django project contains:\n\n* ***manage.py***. A file that is automatically created in each Django project. Is a thin wrapper around django-admin.py that takes care of putting the project\u2019s package on sys.path and sets the DJANGO_SETTINGS_MODULE environment variable.\n\n* ***saml*** Is a folder that contains the 'certs' folder that could be used to store the x509 public and private key, and the saml toolkit settings (settings.json and advanced_settings.json).\n\n* ***demo*** Is the main folder of the django project, that contains the typical files:\n  * ***settings.py*** Contains the default parameters of a django project except the SAML_FOLDER parameter, that may contain the path where is located the 'saml' folder.\n  * ***urls.py*** A file that define url routes. In the demo we defined '/' that is related to the index view, '/attrs' that is related with the attrs view and '/metadata', related to th metadata view.\n  * ***views.py*** This file contains the views of the django project and some aux methods.\n  * ***wsgi.py*** A file that let as deploy django using WSGI, the Python standard for web servers and applications.\n\n* ***templates***. Is the folder where django stores the templates of the project. It was implemented a base.html template that is extended by index.html and attrs.html, the templates of our simple demo that shows messages, user attributes when available and login and logout links.\n\n####SP setup####\n\nThe Onelogin's Python Toolkit allows you to provide the settings info in 2 ways: settings files or define a setting dict. In the demo-django it used the first method.\n\nAfter set the SAML_FOLDER in the demo/settings.py, the settings of the python toolkit will be loaded on the django web.\n\nFirst we need to edit the saml/settings.json, configure the SP part and  review the metadata of the IdP and complete the IdP info.  Later edit the saml/advanced_settings.json files and configure the how the toolkit will work. Check the settings section of this document if you have any doubt.\n\n####IdP setup####\n\nOnce the SP is configured, the metadata of the SP is published at the /metadata url. Based on that info, configure the IdP.\n\n####How it works####\n\nThis demo works very similar to the flask-demo (We did it intentionally).\n", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/onelogin/python-saml", "keywords": "saml saml2 xmlsec django flask", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "python_saml_nocert", "package_url": "https://pypi.org/project/python_saml_nocert/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/python_saml_nocert/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/onelogin/python-saml"}, "release_url": "https://pypi.org/project/python_saml_nocert/2.2.1/", "requires_dist": null, "requires_python": null, "summary": "Onelogin Python Toolkit. Add SAML support to your Python software using this library", "version": "2.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            # OneLogin's SAML Python Toolkit<br><br>[![Build Status](https://api.travis-ci.org/onelogin/python-saml.png?branch=master)](http://travis-ci.org/onelogin/python-saml)<br>[![Coverage Status](https://coveralls.io/repos/onelogin/python-saml/badge.png)](https://coveralls.io/r/onelogin/python-saml)<br>[![PyPi Version](https://img.shields.io/pypi/v/python-saml.svg)](https://pypi.python.org/pypi/python-saml)<br>![Python versions](https://img.shields.io/pypi/pyversions/python-saml.svg)<br><br>Add SAML support to your Python software using this library.<br>Forget those complicated libraries and use the open source library provided<br>and supported by OneLogin Inc.<br><br>This version supports Python2. There is a separate version that supports<br>Python3: [python3-saml](https://github.com/onelogin/python3-saml).<br><br>#### Warning ####<br><br>Update python-saml to 2.2.0, this version includes a security patch that contains extra validations that will prevent signature wrapping attacks. [CVE-2016-1000252](https://github.com/distributedweaknessfiling/DWF-Database-Artifacts/blob/master/DWF/2016/1000252/CVE-2016-1000252.json)<br><br>python-saml &lt; v2.2.0 is vulnerable and allows signature wrapping!<br><br>#### Security Guidelines ####<br><br>If you believe you have discovered a security vulnerability in this toolkit, please report it at https://www.onelogin.com/security with a description. We follow responsible disclosure guidelines, and will work with you to quickly find a resolution.<br><br>Why add SAML support to my software?<br>------------------------------------<br><br>SAML is an XML-based standard for web browser single sign-on and is defined by<br>the OASIS Security Services Technical Committee. The standard has been around<br>since 2002, but lately it is becoming popular due its advantages:<br><br> * **Usability** - One-click access from portals or intranets, deep linking,<br>   password elimination and automatically renewing sessions make life<br>   easier for the user.<br> * **Security** - Based on strong digital signatures for authentication and<br>   integrity, SAML is a secure single sign-on protocol that the largest<br>   and most security conscious enterprises in the world rely on.<br> * **Speed** - SAML is fast. One browser redirect is all it takes to securely<br>   sign a user into an application.<br> * **Phishing Prevention** - If you don\u2019t have a password for an app, you<br>   can\u2019t be tricked into entering it on a fake login page.<br> * **IT Friendly** - SAML simplifies life for IT because it centralizes<br>   authentication, provides greater visibility and makes directory<br>   integration easier.<br> * **Opportunity** - B2B cloud vendor should support SAML to facilitate the<br>   integration of their product.<br><br>General description<br>-------------------<br><br>OneLogin's SAML Python toolkit lets you turn your Python application into a SP<br>(Service Provider) that can be connected to an IdP (Identity Provider).<br><br>Supports:<br><br> * SSO and SLO (SP-Initiated and IdP-Initiated).<br> * Assertion and nameId encryption.<br> * Assertion signatures.<br> * Message signatures: AuthNRequest, LogoutRequest, LogoutResponses.<br> * Enable an Assertion Consumer Service endpoint.<br> * Enable a Single Logout Service endpoint.<br> * Publish the SP metadata (which can be signed).<br><br>Key features:<br><br> * **saml2int** - Implements the SAML 2.0 Web Browser SSO Profile.<br> * **Session-less** - Forget those common conflicts between the SP and<br>   the final app, the toolkit delegate session in the final app.<br> * **Easy to use** - Programmer will be allowed to code high-level and<br>   low-level programming, 2 easy to use APIs are available.<br> * **Tested** - Thoroughly tested.<br> * **Popular** - OneLogin's customers use it. Add easy support to your django/flask/bottle web projects.<br><br><br>Installation<br>------------<br><br>### Dependencies ###<br><br> * python 2.7<br> * [dm.xmlsec.binding](https://pypi.python.org/pypi/dm.xmlsec.binding)  Cython/lxml based binding for the XML security library (depends on python-dev libxml2-dev libxmlsec1-dev)<br> * [isodate](https://pypi.python.org/pypi/isodate)  An ISO 8601 date/time/duration parser and formater<br> * [defusedxml](https://pypi.python.org/pypi/defusedxml)  XML bomb protection for Python stdlib modules<br><br><br>Review the setup.py file to know the version of the library that python-saml is using<br><br>### OSX Dependencies ###<br><br> * python 2.7<br> * libxmlsec1<br><br>```sh<br># using brew<br>$ brew install libxmlsec1<br>```<br><br><br>### Code ###<br><br>#### Option 1. Download from github ####<br><br>The toolkit is hosted on github. You can download it from:<br><br> * Lastest release: https://github.com/onelogin/python-saml/releases/latest<br> * Master repo: https://github.com/onelogin/python-saml/tree/master<br><br>Copy the core of the library (src/onelogin/saml2 folder) and merge the setup.py inside the python application. (each application has its structure so take your time to locate the Python SAML toolkit in the best place).<br><br>#### Option 2. Download from pypi ####<br><br>The toolkit is hosted in pypi, you can find the python-saml package at https://pypi.python.org/pypi/python-saml<br><br>You can install it executing:<br>```<br>$ pip install python-saml<br>```<br><br>If you want to know how a project can handle python packages review this [guide](https://packaging.python.org/en/latest/tutorial.html) and review this [sampleproject](https://github.com/pypa/sampleproject)<br><br><br>Security warning<br>----------------<br><br>In production, the **strict** parameter MUST be set as **\"true\"**. Otherwise<br>your environment is not secure and will be exposed to attacks.<br><br><br>Getting started<br>---------------<br><br>### Knowing the toolkit ###<br><br>The new OneLogin SAML Toolkit contains different folders (certs, lib, demo-django, demo-flask, demo-bottle and tests) and some files.<br><br>Let's start describing them:<br><br>#### src ####<br><br>This folder contains the heart of the toolkit, **onelogin/saml2** folder contains the new version of<br>the classes and methods that are described in a later section.<br><br>#### demo-django ####<br><br>This folder contains a Django project that will be used as demo to show how to add SAML support to the Django Framework. 'demo' is the main folder of the django project (with its settings.py, views.py, urls.py), 'templates' is the django templates of the project and 'saml' is a folder that contains the 'certs' folder that could be used to store the x509 public and private key, and the saml toolkit settings (settings.json and advanced_settings.json).<br><br>***Notice about certs***<br><br>SAML requires a x.509 cert to sign and encrypt elements like NameID, Message, Assertion, Metadata.<br><br>If our environment requires sign or encrypt support, the certs folder may contain the x509 cert and the private key that the SP will use:<br><br>* sp.crt The public cert of the SP<br>* sp.key The private key of the SP<br><br>Or also we can provide those data in the setting file at the 'x509cert' and the privateKey' json parameters of the 'sp' element.<br><br>Sometimes we could need a signature on the metadata published by the SP, in this case we could use the x.509 cert previously mentioned or use a new x.509 cert: metadata.crt and metadata.key.<br><br>If you want to create self-signed certs, you can do it at the https://www.samltool.com/self_signed_certs.php service, or using the command:<br><br>```bash<br>openssl req -new -x509 -days 3652 -nodes -out sp.crt -keyout saml.key<br>```<br><br>#### demo-bottle ####<br><br>This folder contains a Bottle project that will be used as demo to show how to add SAML support to the Bottle Framework. index.py contains all the logic of the demo project, 'templates' is the Bottle templates of the project and 'saml' is a folder that contains the 'certs' folder that could be used to store the x509 public and private key, and the saml toolkit settings (settings.json and advanced_settings.json).<br><br><br>#### demo-flask ####<br><br>This folder contains a Flask project that will be used as demo to show how to add SAML support to the Flask Framework. 'index.py' is the main flask file that has all the code, this file uses the templates stored at the 'templates' folder. In the 'saml' folder we found the 'certs' folder to store the x509 public and private key, and the saml toolkit settings (settings.json and advanced_settings.json).<br><br>#### setup.py ####<br><br>Setup script is the centre of all activity in building, distributing, and installing modules.<br>Read more at https://pythonhosted.org/an_example_pypi_project/setuptools.html<br><br>#### tests ####<br><br>Contains the unit test of the toolkit.<br><br>In order to execute the test you need to load the virtualenv with the toolkit installed on it and execute:<br>```<br>pip install -e \".[test]\"<br>```<br>that will install dependences that the test requires.<br><br>and later execute:<br>```<br>python setup.py test<br>```<br>The previous line will run the tests for the whole toolkit. You can also run the tests for a specific module. To do so for the auth module you would have to execute this:<br>```<br>python setup.py test --test-suite tests.src.OneLogin.saml2_tests.auth_test.OneLogin_Saml2_Auth_Test<br>```<br><br>With the --test-suite parameter you can specify the module to test. You'll find all the module available and their class names at tests/src/OneLogin/saml2_tests/<br><br>### How it works ###<br><br>#### Settings ####<br><br>First of all we need to configure the toolkit. The SP's info, the IdP's info, and in some cases, configure advanced security issues like signatures and encryption.<br><br>There are two ways to provide the settings information:<br><br>* Use a settings.json file that we should locate in any folder, but indicates its path with the 'custom_base_path' parameter.<br><br>* Use a json object with the setting data and provide it directly to the constructor of the class (if your toolkit integation requires certs, remember to provide the 'custom_base_path' as part of the settings or as a parameter in the constructor.<br><br>In the demo-django, demo-flask and demo-bottle folders you will find a 'saml' folder, inside there is a 'certs' folder and a settings.json and a advanced_settings.json files. Those files contain the settings for the saml toolkit. Copy them in your project and set the correct values.<br><br>This is the settings.json file:<br><br>```javascript<br>{<br>    // If strict is True, then the Python Toolkit will reject unsigned<br>    // or unencrypted messages if it expects them to be signed or encrypted.<br>    // Also it will reject the messages if the SAML standard is not strictly<br>    // followed. Destination, NameId, Conditions ... are validated too.<br>    \"strict\": true,<br><br>    // Enable debug mode (outputs errors).<br>    \"debug\": true,<br><br>    // Service Provider Data that we are deploying.<br>    \"sp\": {<br>        // Identifier of the SP entity  (must be a URI)<br>        \"entityId\": \"https://&lt;sp_domain&gt;/metadata/\",<br>        // Specifies info about where and how the &lt;AuthnResponse&gt; message MUST be<br>        // returned to the requester, in this case our SP.<br>        \"assertionConsumerService\": {<br>            // URL Location where the &lt;Response&gt; from the IdP will be returned<br>            \"url\": \"https://&lt;sp_domain&gt;/?acs\",<br>            // SAML protocol binding to be used when returning the &lt;Response&gt;<br>            // message. OneLogin Toolkit supports this endpoint for the<br>            // HTTP-POST binding only.<br>            \"binding\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST\"<br>        },<br>        // If you need to specify requested attributes, set a<br>        // attributeConsumingService. nameFormat, attributeValue and<br>        // friendlyName can be omitted<br>        \"attributeConsumingService\": {<br>                \"serviceName\": \"SP test\",<br>                \"serviceDescription\": \"Test Service\",<br>                \"requestedAttributes\": [<br>                    {<br>                        \"name\": \"\",<br>                        \"isRequired\": false,<br>                        \"nameFormat\": \"\",<br>                        \"friendlyName\": \"\",<br>                        \"attributeValue\": []<br>                    }<br>                ]<br>        },<br>        // Specifies info about where and how the &lt;Logout Response&gt; message MUST be<br>        // returned to the requester, in this case our SP.<br>        \"singleLogoutService\": {<br>            // URL Location where the &lt;Response&gt; from the IdP will be returned<br>            \"url\": \"https://&lt;sp_domain&gt;/?sls\",<br>            // SAML protocol binding to be used when returning the &lt;Response&gt;<br>            // message. OneLogin Toolkit supports the HTTP-Redirect binding<br>            // only for this endpoint.<br>            \"binding\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\"<br>        },<br>        // Specifies the constraints on the name identifier to be used to<br>        // represent the requested subject.<br>        // Take a look on src/onelogin/saml2/constants.py to see the NameIdFormat that are supported.<br>        \"NameIDFormat\": \"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\",<br>        // Usually x509cert and privateKey of the SP are provided by files placed at<br>        // the certs folder. But we can also provide them with the following parameters<br>        \"x509cert\": \"\",<br>        \"privateKey\": \"\"<br>    },<br><br>    // Identity Provider Data that we want connected with our SP.<br>    \"idp\": {<br>        // Identifier of the IdP entity  (must be a URI)<br>        \"entityId\": \"https://app.onelogin.com/saml/metadata/&lt;onelogin_connector_id&gt;\",<br>        // SSO endpoint info of the IdP. (Authentication Request protocol)<br>        \"singleSignOnService\": {<br>            // URL Target of the IdP where the Authentication Request Message<br>            // will be sent.<br>            \"url\": \"https://app.onelogin.com/trust/saml2/http-post/sso/&lt;onelogin_connector_id&gt;\",<br>            // SAML protocol binding to be used when returning the &lt;Response&gt;<br>            // message. OneLogin Toolkit supports the HTTP-Redirect binding<br>            // only for this endpoint.<br>            \"binding\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\"<br>        },<br>        // SLO endpoint info of the IdP.<br>        \"singleLogoutService\": {<br>            // URL Location of the IdP where SLO Request will be sent.<br>            \"url\": \"https://app.onelogin.com/trust/saml2/http-redirect/slo/&lt;onelogin_connector_id&gt;\",<br>            // SAML protocol binding to be used when returning the &lt;Response&gt;<br>            // message. OneLogin Toolkit supports the HTTP-Redirect binding<br>            // only for this endpoint.<br>            \"binding\": \"urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect\"<br>        },<br>        // Public x509 certificate of the IdP<br>        \"x509cert\": \"&lt;onelogin_connector_cert&gt;\"<br>        /*<br>         *  Instead of using the whole x509cert you can use a fingerprint in order to<br>         *  validate a SAMLResponse, but you will need it to validate LogoutRequest and LogoutResponse using the HTTP-Redirect binding.<br>         *<br>         *  (openssl x509 -noout -fingerprint -in \"idp.crt\" to generate it,<br>         *  or add for example the -sha256 , -sha384 or -sha512 parameter)<br>         *<br>         *  If a fingerprint is provided, then the certFingerprintAlgorithm is required in order to<br>         *  let the toolkit know which algorithm was used. Possible values: sha1, sha256, sha384 or sha512<br>         *  'sha1' is the default value.<br>         *<br>         *  Notice that if you want to validate any SAML Message sent by the HTTP-Redirect binding, you<br>         *  will need to provide the whole x509cert.<br>         */<br>        // 'certFingerprint' =&gt; '',<br>        // 'certFingerprintAlgorithm' =&gt; 'sha1',<br>    }<br>}<br>```<br><br>In addition to the required settings data (idp, sp), extra settings can be defined in `advanced_settings.json`:<br><br>```javascript<br>{<br>    // Security settings<br>    \"security\": {<br><br>        /** signatures and encryptions offered **/<br><br>        // Indicates that the nameID of the &lt;samlp:logoutRequest&gt; sent by this SP<br>        // will be encrypted.<br>        \"nameIdEncrypted\": false,<br><br>        // Indicates whether the &lt;samlp:AuthnRequest&gt; messages sent by this SP<br>        // will be signed.  [Metadata of the SP will offer this info]<br>        \"authnRequestsSigned\": false,<br><br>        // Indicates whether the &lt;samlp:logoutRequest&gt; messages sent by this SP<br>        // will be signed.<br>        \"logoutRequestSigned\": false,<br><br>        // Indicates whether the &lt;samlp:logoutResponse&gt; messages sent by this SP<br>        // will be signed.<br>        \"logoutResponseSigned\": false,<br><br>        /* Sign the Metadata<br>         false || true (use sp certs) || {<br>                                            \"keyFileName\": \"metadata.key\",<br>                                            \"certFileName\": \"metadata.crt\"<br>                                         }<br>        */<br>        \"signMetadata\": false,<br><br>        /** signatures and encryptions required **/<br><br>        // Indicates a requirement for the &lt;samlp:Response&gt;, &lt;samlp:LogoutRequest&gt;<br>        // and &lt;samlp:LogoutResponse&gt; elements received by this SP to be signed.<br>        \"wantMessagesSigned\": false,<br><br>        // Indicates a requirement for the &lt;saml:Assertion&gt; elements received by<br>        // this SP to be signed. [Metadata of the SP will offer this info]<br>        \"wantAssertionsSigned\": false,<br><br>        // Indicates a requirement for the &lt;saml:Assertion&gt;<br>        // elements received by this SP to be encrypted.<br>        \"wantAssertionsEncrypted\": false,<br><br>        // Indicates a requirement for the NameID element on the SAMLResponse<br>        // received by this SP to be present.<br>        \"wantNameId\": true,<br><br>        // Indicates a requirement for the NameID received by<br>        // this SP to be encrypted.<br>        \"wantNameIdEncrypted\": false,<br><br>        // Indicates a requirement for the AttributeStatement element<br>        \"wantAttributeStatement\": true,<br><br>        // Authentication context.<br>        // Set to false and no AuthContext will be sent in the AuthNRequest,<br>        // Set true or don't present this parameter and you will get an AuthContext 'exact' 'urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport'<br>        // Set an array with the possible auth context values: array ('urn:oasis:names:tc:SAML:2.0:ac:classes:Password', 'urn:oasis:names:tc:SAML:2.0:ac:classes:X509'),<br>        \"requestedAuthnContext\": true,<br>        // Allows the authn comparison parameter to be set, defaults to 'exact' if the setting is not present.<br>        \"requestedAuthnContextComparison\": \"exact\",<br><br>        // In some environment you will need to set how long the published metadata of the Service Provider gonna be valid.<br>        // is possible to not set the 2 following parameters (or set to null) and default values will be set (2 days, 1 week)<br>        // Provide the desired Timestamp, for example 2015-06-26T20:00:00Z<br>        \"metadataValidUntil\": null,<br>        // Provide the desired duration, for example PT518400S (6 days)<br>        \"metadataCacheDuration\": null,<br><br>        // Algorithm that the toolkit will use on signing process. Options:<br>        //    'http://www.w3.org/2000/09/xmldsig#rsa-sha1'<br>        //    'http://www.w3.org/2000/09/xmldsig#dsa-sha1'<br>        //    'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256'<br>        //    'http://www.w3.org/2001/04/xmldsig-more#rsa-sha384'<br>        //    'http://www.w3.org/2001/04/xmldsig-more#rsa-sha512'<br>        \"signatureAlgorithm\": \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\",<br><br>        // Algorithm that the toolkit will use on digest process. Options:<br>        //    'http://www.w3.org/2000/09/xmldsig#sha1'<br>        //    'http://www.w3.org/2001/04/xmlenc#sha256'<br>        //    'http://www.w3.org/2001/04/xmldsig-more#sha384'<br>        //    'http://www.w3.org/2001/04/xmlenc#sha512'<br>        \"digestAlgorithm\": \"http://www.w3.org/2000/09/xmldsig#sha1\"<br>    },<br><br>    // Contact information template, it is recommended to supply<br>    // technical and support contacts.<br>    \"contactPerson\": {<br>        \"technical\": {<br>            \"givenName\": \"technical_name\",<br>            \"emailAddress\": \"technical@example.com\"<br>        },<br>        \"support\": {<br>            \"givenName\": \"support_name\",<br>            \"emailAddress\": \"support@example.com\"<br>        }<br>    },<br><br>    // Organization information template, the info in en_US lang is<br>    // recommended, add more if required.<br>    \"organization\": {<br>        \"en-US\": {<br>            \"name\": \"sp_test\",<br>            \"displayname\": \"SP test\",<br>            \"url\": \"http://sp.example.com\"<br>        }<br>    }<br>}<br>```<br><br>In the security section, you can set the way that the SP will handle the messages and assertions. Contact the admin of the IdP and ask them what the IdP expects, and decide what validations will handle the SP and what requirements the SP will have and communicate them to the IdP's admin too.<br><br>Once we know what kind of data could be configured, let's talk about the way settings are handled within the toolkit.<br><br>The settings files described (settings.json and advanced_settings.json) are loaded by the toolkit if not other dict with settings info is provided in the constructors of the toolkit. Let's see some examples.<br><br>```python<br># Initializes toolkit with settings.json &amp; advanced_settings.json files.<br>auth = OneLogin_Saml2_Auth(req)<br># or<br>settings = OneLogin_Saml2_Settings()<br><br># Initializes toolkit with settings.json &amp; advanced_settings.json files from a custom base path.<br>custom_folder = '/var/www/django-project'<br>auth = OneLogin_Saml2_Auth(req, custom_base_path=custom_folder)<br># or<br>settings = OneLogin_Saml2_Settings(custom_base_path=custom_folder)<br><br># Initializes toolkit with the dict provided.<br>auth = OneLogin_Saml2_Auth(req, settings_data)<br># or<br>settings = OneLogin_Saml2_Settings(settings_data)<br>```<br><br>You can declare the settings_data in the file that constains the constructor execution or locate them in any file and load the file in order to get the dict available as we see in the following example:<br><br>```python<br>filename = \"/var/www/django-project/custom_settings.json\" # The custom_settings.json contains a<br>json_data_file = open(filename, 'r')                      # settings_data dict.<br>settings_data = json.load(json_data_file)<br>json_data_file.close()<br><br>auth = OneLogin_Saml2_Auth(req, settings_data)<br>```<br><br>#### How load the library ####<br><br>In order to use the toolkit library you need to import the file that contains the class that you will need<br>on the top of your python file.<br><br>``` python<br>from onelogin.saml2.auth import OneLogin_Saml2_Auth<br>from onelogin.saml2.settings import OneLogin_Saml2_Settings<br>from onelogin.saml2.utils import OneLogin_Saml2_Utils<br>```<br><br>#### The Request ####<br><br>Building an OneLogin_Saml2_Auth object requires a 'request' parameter.<br><br>```python<br>auth = OneLogin_Saml2_Auth(req)<br>```<br><br>This parameter has the following scheme:<br><br>```javascript<br>req = {<br>    \"http_host\": \"\",<br>    \"script_name\": \"\",<br>    \"server_port\": \"\",<br>    \"get_data\": \"\",<br>    \"post_data\": \"\"<br>}<br>```<br><br>Each python framework built its own request object, you may map its data to match what the saml toolkit expects.<br>Let`s see some examples:<br><br>```python<br>def prepare_from_django_request(request):<br>    return {<br>        'http_host': request.META['HTTP_HOST'],<br>        'script_name': request.META['PATH_INFO'],<br>        'server_port': request.META['SERVER_PORT'],<br>        'get_data': request.GET.copy(),<br>        'post_data': request.POST.copy()<br>    }<br><br>def prepare_from_flask_request(request):<br>    url_data = urlparse(request.url)<br>    return {<br>        'http_host': request.host,<br>        'server_port': url_data.port,<br>        'script_name': request.path,<br>        'get_data': request.args.copy(),<br>        'post_data': request.form.copy()<br>    }<br>```<br><br><br>#### Initiate SSO ####<br><br>In order to send an AuthNRequest to the IdP:<br><br>```python<br>from onelogin.saml2.auth import OneLogin_Saml2_Auth<br><br>req = prepare_request_for_toolkit(request)<br>auth = OneLogin_Saml2_Auth(req)   # Constructor of the SP, loads settings.json<br>                                  # and advanced_settings.json<br><br>auth.login()      # Method that builds and sends the AuthNRequest<br>```<br><br>The AuthNRequest will be sent signed or unsigned based on the security info of the advanced_settings.json ('authnRequestsSigned').<br><br>The IdP will then return the SAML Response to the user's client. The client is then forwarded to the Attribute Consumer Service of the SP with this information.<br><br>We can set a 'return_to' url parameter to the login function and that will be converted as a 'RelayState' parameter:<br><br>```python<br>target_url = 'https://example.com'<br>auth.login(return_to=target_url)<br>```<br>The login method can recieve 3 more optional parameters:<br><br>* force_authn       When true the AuthNReuqest will set the ForceAuthn='true'<br>* is_passive        When true the AuthNReuqest will set the Ispassive='true'<br>* set_nameid_policy When true the AuthNReuqest will set a nameIdPolicy element.<br><br>If a match on the future SAMLResponse ID and the AuthNRequest ID to be sent is required, that AuthNRequest ID must to be extracted and stored for future validation, we can get that ID by<br><br>```python<br>auth.get_last_request_id()<br>```<br><br>#### The SP Endpoints ####<br><br>Related to the SP there are 3 important endpoints: The metadata view, the ACS view and the SLS view.<br>The toolkit provides examples of those views in the demos, but lets see an example.<br><br>***SP Metadata***<br><br>This code will provide the XML metadata file of our SP, based on the info that we provided in the settings files.<br><br>```python<br>req = prepare_request_for_toolkit(request)<br>auth = OneLogin_Saml2_Auth(req)<br>saml_settings = auth.get_settings()<br>metadata = saml_settings.get_sp_metadata()<br>errors = saml_settings.validate_metadata(metadata)<br>if len(errors) == 0:<br>    print metadata<br>else:<br>    print \"Error found on Metadata: %s\" % (', '.join(errors))<br>```<br><br>The get_sp_metadata will return the metadata signed or not based on the security info of the advanced_settings.json ('signMetadata').<br><br>Before the XML metadata is exposed, a check takes place to ensure that the info to be provided is valid.<br><br>Instead of using the Auth object, you can directly use<br>```<br>saml_settings = OneLogin_Saml2_Settings(settings=None, custom_base_path=None, sp_validation_only=True)<br>```<br>to get the settings object and with the sp_validation_only=True parameter we will avoid the IdP Settings validation.<br><br>***Attribute Consumer Service(ACS)***<br><br>This code handles the SAML response that the IdP forwards to the SP through the user's client.<br><br>```python<br>req = prepare_request_for_toolkit(request)<br>auth = OneLogin_Saml2_Auth(req)<br>auth.process_response()<br>errors = auth.get_errors()<br>if not errors:<br>    if auth.is_authenticated():<br>        request.session['samlUserdata'] = auth.get_attributes()<br>        if 'RelayState' in req['post_data'] and<br>          OneLogin_Saml2_Utils.get_self_url(req) != req['post_data']['RelayState']:<br>            auth.redirect_to(req['post_data']['RelayState'])<br>        else:<br>            for attr_name in request.session['samlUserdata'].keys():<br>                print '%s ==&gt; %s' % (attr_name, '|| '.join(request.session['samlUserdata'][attr_name]))<br>    else:<br>      print 'Not authenticated'<br>else:<br>    print \"Error when processing SAML Response: %s\" % (', '.join(errors))<br>```<br><br>The SAML response is processed and then checked that there are no errors. It also verifies that the user is authenticated and stored the userdata in session.<br><br>At that point there are 2 possible alternatives:<br><br>* If no RelayState is provided, we could show the user data in this view or however we wanted.<br>* If RelayState is provided, a rediretion take place.<br><br>Notice that we saved the user data in the session before the redirection to have the user data available at the RelayState view.<br><br>In order to retrieve attributes we use:<br><br>```python<br>attributes = auth.get_attributes();<br>```<br><br>With this method we get a dict with all the user data provided by the IdP in the Assertion of the SAML Response.<br><br>If we execute print attributes we could get:<br><br>```python<br>{<br>    \"cn\": [\"Jhon\"],<br>    \"sn\": [\"Doe\"],<br>    \"mail\": [\"Doe\"],<br>    \"groups\": [\"users\", \"members\"]<br>}<br>```<br><br>Each attribute name can be used as a key to obtain the value. Every attribute is a list of values. A single-valued attribute is a listy of a single element.<br><br>The following code is equivalent:<br><br>```python<br>attributes = auth.get_attributes();<br>print attributes['cn']<br><br>print auth.get_attribute('cn')<br>```<br><br>Before trying to get an attribute, check that the user is authenticated. If the user isn't authenticated, an empty dict will be returned. For example, if we call to get_attributes before a auth.process_response, the get_attributes() will return an empty dict.<br><br><br>***Single Logout Service (SLS)***<br><br>This code handles the Logout Request and the Logout Responses.<br><br>```python<br>delete_session_callback = lambda: request.session.flush()<br>url = auth.process_slo(delete_session_cb=delete_session_callback)<br>errors = auth.get_errors()<br>if len(errors) == 0:<br>    if url is not None:<br>        return redirect(url)<br>    else:<br>        print \"Sucessfully Logged out\"<br>else:<br>    print \"Error when processing SLO: %s\" % (', '.join(errors))<br>```<br><br>If the SLS endpoints receives a Logout Response, the response is validated and the session could be closed, using the callback.<br><br>```python<br># Part of the process_slo method<br>logout_response = OneLogin_Saml2_Logout_Response(self.__settings, self.__request_data['get_data']['SAMLResponse'])<br>if not logout_response.is_valid(self.__request_data, request_id):<br>    self.__errors.append('invalid_logout_response')<br>elif logout_response.get_status() != OneLogin_Saml2_Constants.STATUS_SUCCESS:<br>    self.__errors.append('logout_not_success')<br>elif not keep_local_session:<br>    OneLogin_Saml2_Utils.delete_local_session(delete_session_cb)<br>```<br><br>If the SLS endpoints receives an Logout Request, the request is validated, the session is closed and a Logout Response is sent to the SLS endpoint of the IdP.<br><br>```python<br># Part of the process_slo method<br>request = OneLogin_Saml2_Utils.decode_base64_and_inflate(self.__request_data['get_data']['SAMLRequest'])<br>if not OneLogin_Saml2_Logout_Request.is_valid(self.__settings, request, self.__request_data):<br>    self.__errors.append('invalid_logout_request')<br>else:<br>    if not keep_local_session:<br>        OneLogin_Saml2_Utils.delete_local_session(delete_session_cb)<br><br>    in_response_to = request.id<br>    response_builder = OneLogin_Saml2_Logout_Response(self.__settings)<br>    response_builder.build(in_response_to)<br>    logout_response = response_builder.get_response()<br><br>    parameters = {'SAMLResponse': logout_response}<br>    if 'RelayState' in self.__request_data['get_data']:<br>        parameters['RelayState'] = self.__request_data['get_data']['RelayState']<br><br>    security = self.__settings.get_security_data()<br>    if 'logoutResponseSigned' in security and security['logoutResponseSigned']:<br>        parameters['SigAlg'] = OneLogin_Saml2_Constants.RSA_SHA1<br>        parameters['Signature'] = self.build_response_signature(logout_response, parameters.get('RelayState', None))<br><br>    return self.redirect_to(self.get_slo_url(), parameters)<br>```<br><br>If we don't want that process_slo to destroy the session, pass a true parameter to the process_slo method<br><br>```python<br>keepLocalSession = true<br>auth.process_slo(keep_local_session=keepLocalSession);<br>```<br><br>#### Initiate SLO ####<br><br>In order to send a Logout Request to the IdP:<br>```python<br>from onelogin.saml2.auth import OneLogin_Saml2_Auth<br><br>req = prepare_request_for_toolkit(request)<br>auth = OneLogin_Saml2_Auth(req)   # Constructor of the SP, loads settings.json<br>                                  # and advanced_settings.json<br><br>auth.logout()      # Method that builds and sends the LogoutRequest<br>```<br><br>The Logout Request will be sent signed or unsigned based on the security info of the advanced_settings.json ('logoutRequestSigned').<br><br>The IdP will return the Logout Response through the user's client to the Single Logout Service of the SP.<br><br>We can set a 'return_to' url parameter to the logout function and that will be converted as a 'RelayState' parameter:<br><br>```python<br>target_url = 'https://example.com'<br>auth.logout(return_to=target_url)<br>```<br><br>Also there are 2 optional parameters that can be set:<br><br>* name_id. That will be used to build the LogoutRequest. If not name_id parameter is set and the auth object processed a<br>SAML Response with a NameId, then this NameId will be used.<br>* session_index. SessionIndex that identifies the session of the user.<br><br>If a match on the LogoutResponse ID and the LogoutRequest ID to be sent is required, that LogoutRequest ID must to be extracted and stored for future validation, we can get that ID by<br><br>```python<br>auth.get_last_request_id()<br>```<br><br>####Example of a view that initiates the SSO request and handles the response (is the acs target)####<br><br>We can code a unique file that initiates the SSO process, handle the response, get the attributes, initiate the slo and processes the logout response.<br><br>Note: Review the demos, in a later section we explain the demo use case further in detail.<br><br>```python<br>req = prepare_request_for_toolkit(request)  # Process the request and build the request dict that<br>                                            # the toolkit expects<br><br>auth = OneLogin_Saml2_Auth(req)             # Initialize the SP SAML instance<br><br>if 'sso' in request.args:                   # SSO action (SP-SSO initited).  Will send an AuthNRequest to the IdP<br>    return redirect(auth.login())<br>elif 'sso2' in request.args:                       # Another SSO init action<br>    return_to = '%sattrs/' % request.host_url      # but set a custom RelayState URL<br>    return redirect(auth.login(return_to))<br>elif 'slo' in request.args:                     # SLO action. Will sent a Logout Request to IdP<br>    return redirect(auth.logout())<br>elif 'acs' in request.args:                 # Assertion Consumer Service<br>    auth.process_response()                     # Process the Response of the IdP<br>    errors = auth.get_errors()              # This method receives an array with the errors<br>    if len(errors) == 0:                    # that could took place during the process<br>        if not auth.is_authenticated():         # This check if the response was ok and the user<br>            msg = \"Not authenticated\"           # data retrieved or not (user authenticated)<br>        else:<br>            request.session['samlUserdata'] = auth.get_attributes()     # Retrieves user data<br>            self_url = OneLogin_Saml2_Utils.get_self_url(req)<br>            if 'RelayState' in request.form and self_url != request.form['RelayState']:<br>                return redirect(auth.redirect_to(request.form['RelayState']))   # Redirect if there is a relayState<br>            else:                           # If there is user data we save that to print it later.<br>                msg = ''<br>                for attr_name in request.session['samlUserdata'].keys():<br>                    msg += '%s ==&gt; %s' % (attr_name, '|| '.join(request.session['samlUserdata'][attr_name]))<br>elif 'sls' in request.args:                                             # Single Logout Service<br>    delete_session_callback = lambda: session.clear()           # Obtain session clear callback<br>    url = auth.process_slo(delete_session_cb=delete_session_callback)   # Process the Logout Request &amp; Logout Response<br>    errors = auth.get_errors()              #  Retrieves possible validation errors<br>    if len(errors) == 0:<br>        if url is not None:<br>            return redirect(url)<br>        else:<br>            msg = \"Sucessfully logged out\"<br><br>if len(errors) == 0:<br>  print msg<br>else:<br>  print ', '.join(errors)<br>```<br><br><br>### Main classes and methods ###<br><br>Described below are the main classes and methods that can be invoked from the SAML2 library.<br><br>####OneLogin_Saml2_Auth - auth.py####<br><br>Main class of OneLogin Python Toolkit<br><br>* `__init__` Initializes the SP SAML instance.<br>* ***login*** Initiates the SSO process.<br>* ***logout*** Initiates the SLO process.<br>* ***process_response*** Process the SAML Response sent by the IdP.<br>* ***process_slo*** Process the SAML Logout Response / Logout Request sent by the IdP.<br>* ***redirect_to*** Redirects the user to the url past by parameter or to the url that we defined in our SSO Request.<br>* ***is_authenticated*** Checks if the user is authenticated or not.<br>* ***get_attributes*** Returns the set of SAML attributes.<br>* ***get_attribute*** Returns the requested SAML attribute.<br>* ***get_nameid*** Returns the nameID.<br>* ***get_session_index*** Gets the SessionIndex from the AuthnStatement.<br>* ***get_session_expiration*** Gets the SessionNotOnOrAfter from the AuthnStatement.<br>* ***get_errors*** Returns a list with code errors if something went wrong.<br>* ***get_last_error_reason*** Returns the reason of the last error<br>* ***get_sso_url*** Gets the SSO url.<br>* ***get_slo_url*** Gets the SLO url.<br>* ***get_last_request_id*** The ID of the last Request SAML message generated (AuthNRequest, LogoutRequest).<br>* ***build_request_signature*** Builds the Signature of the SAML Request.<br>* ***build_response_signature*** Builds the Signature of the SAML Response.<br>* ***get_settings*** Returns the settings info.<br>* ***set_strict*** Set the strict mode active/disable.<br>* ***get_last_request_xml*** Returns the most recently-constructed/processed XML SAML request (AuthNRequest, LogoutRequest)<br>* ***get_last_response_xml*** Returns the most recently-constructed/processed XML SAML response (SAMLResponse, LogoutResponse). If the SAMLResponse had an encrypted assertion, decrypts it.<br><br>####OneLogin_Saml2_Auth - authn_request.py####<br><br>SAML 2 Authentication Request class<br><br>* `__init__` This class handles an AuthNRequest. It builds an AuthNRequest object.<br>* ***get_request*** Returns unsigned AuthnRequest.<br>* ***get_id*** Returns the AuthNRequest ID.<br>* ***get_xml*** Returns the XML that will be sent as part of the request.<br><br>####OneLogin_Saml2_Response - response.py####<br><br>SAML 2 Authentication Response class<br><br>* `__init__` Constructs the SAML Response object.<br>* ***is_valid*** Determines if the SAML Response is valid. Includes checking of the signature by a certificate.<br>* ***check_status*** Check if the status of the response is success or not<br>* ***get_audiences*** Gets the audiences<br>* ***get_issuers*** Gets the issuers (from message and from assertion)<br>* ***get_nameid_data*** Gets the NameID Data provided by the SAML Response from the IdP (returns a dict)<br>* ***get_nameid*** Gets the NameID provided by the SAML Response from the IdP (returns a string)<br>* ***get_session_not_on_or_after*** Gets the SessionNotOnOrAfter from the AuthnStatement<br>* ***get_session_index*** Gets the SessionIndex from the AuthnStatement<br>* ***get_attributes*** Gets the Attributes from the AttributeStatement element.<br>* ***validate_num_assertions*** Verifies that the document only contains a single Assertion (encrypted or not)<br>* ***validate_timestamps*** Verifies that the document is valid according to Conditions Element<br>* ***get_error*** After execute a validation process, if fails this method returns the cause<br>* ***get_xml_document*** Returns the SAML Response document (If contains an encrypted assertion, decrypts it).<br><br>####OneLogin_Saml2_LogoutRequest - logout_request.py####<br><br>SAML 2 Logout Request class<br><br>* `__init__` Constructs the Logout Request object.<br>* ***get_request*** Returns the Logout Request defated, base64encoded.<br>* ***get_id*** Returns the ID of the Logout Request. (If you have the object you can access to the id attribute)<br>* ***get_nameid_data*** Gets the NameID Data of the the Logout Request (returns a dict).<br>* ***get_nameid*** Gets the NameID of the Logout Request Message (returns a string).<br>* ***get_issuer*** Gets the Issuer of the Logout Request Message.<br>* ***get_session_indexes*** Gets the SessionIndexes from the Logout Request.<br>* ***is_valid*** Checks if the Logout Request recieved is valid.<br>* ***get_error*** After execute a validation process, if fails this method returns the cause.<br>* ***get_xml*** Returns the XML that will be sent as part of the request or that was received at the SP<br><br>####OneLogin_Saml2_LogoutResponse - logout_response.py####<br><br>SAML 2 Logout Response class<br><br>* `__init__` Constructs a Logout Response object.<br>* ***get_issuer*** Gets the Issuer of the Logout Response Message<br>* ***get_status*** Gets the Status of the Logout Response.<br>* ***is_valid*** Determines if the SAML LogoutResponse is valid<br>* ***build*** Creates a Logout Response object.<br>* ***get_response*** Returns a Logout Response object.<br>* ***get_error*** After execute a validation process, if fails this method returns the cause.<br>* ***get_xml*** Returns the XML that will be sent as part of the response or that was received at the SP<br><br><br>####OneLogin_Saml2_Settings - settings.py####<br><br>Configuration of the OneLogin Python Toolkit<br><br>* `__init__`  Initializes the settings: Sets the paths of the different folders and Loads settings info from settings file or array/object provided.<br>* ***check_settings*** Checks the settings info.<br>* ***check_idp_settings*** Checks the IdP settings info.<br>* ***check_sp_settings*** Checks the SP settings info.<br>* ***get_errors*** Returns an array with the errors, the array is empty when the settings is ok.<br>* ***get_sp_metadata*** Gets the SP metadata. The XML representation.<br>* ***validate_metadata*** Validates an XML SP Metadata.<br>* ***get_base_path*** Returns base path.<br>* ***get_cert_path*** Returns cert path.<br>* ***get_lib_path*** Returns lib path.<br>* ***get_ext_lib_path*** Returns external lib path.<br>* ***get_schemas_path*** Returns schema path.<br>* ***check_sp_certs*** Checks if the x509 certs of the SP exists and are valid.<br>* ***get_sp_key*** Returns the x509 private key of the SP.<br>* ***get_sp_cert*** Returns the x509 public cert of the SP.<br>* ***get_idp_cert*** Returns the x509 public cert of the IdP.<br>* ***get_sp_data*** Gets the SP data.<br>* ***get_idp_data*** Gets the IdP data.<br>* ***get_security_data***  Gets security data.<br>* ***get_contacts*** Gets contacts data.<br>* ***get_organization*** Gets organization data.<br>* ***format_idp_cert*** Formats the IdP cert.<br>* ***format_sp_cert*** Formats the SP cert.<br>* ***format_sp_key*** Formats the private key.<br>* ***set_strict*** Activates or deactivates the strict mode.<br>* ***is_strict*** Returns if the 'strict' mode is active.<br>* ***is_debug_active*** Returns if the debug is active.<br><br>####OneLogin_Saml2_Metadata - metadata.py####<br><br>A class that contains functionality related to the metadata of the SP<br><br>* ***builder*** Generates the metadata of the SP based on the settings.<br>* ***sign_metadata*** Signs the metadata with the key/cert provided.<br>* ***add_x509_key_descriptors*** Adds the x509 descriptors (sign/encriptation) to the metadata<br><br>####OneLogin_Saml2_Utils - utils.py####<br><br>Auxiliary class that contains several methods<br><br>* ***decode_base64_and_inflate*** Base64 decodes and then inflates according to RFC1951.<br>* ***deflate_and_base64_encode*** Deflates and the base64 encodes a string.<br>* ***validate_xml*** Validates a xml against a schema.<br>* ***format_cert*** Returns a x509 cert (adding header &amp; footer if required).<br>* ***format_private_key*** Returns a private key (adding header &amp; footer if required).<br>* ***redirect*** Executes a redirection to the provided url (or return the target url).<br>* ***get_self_url_host*** Returns the protocol + the current host + the port (if different than common ports).<br>* ***get_self_host*** Returns the current host.<br>* ***is_https*** Checks if https or http.<br>* ***get_self_url_no_query*** Returns the URL of the current host + current view.<br>* ***get_self_routed_url_no_query*** Returns the routed URL of the current host + current view.<br>* ***get_self_url*** Returns the URL of the current host + current view + query.<br>* ***generate_unique_id*** Generates an unique string (used for example as ID for assertions).<br>* ***parse_time_to_SAML*** Converts a UNIX timestamp to SAML2 timestamp on the form yyyy-mm-ddThh:mm:ss(\\.s+)?Z.<br>* ***parse_SAML_to_time*** Converts a SAML2 timestamp on the form yyyy-mm-ddThh:mm:ss(\\.s+)?Z to a UNIX timestamp.<br>* ***now*** Returns unix timestamp of actual time.<br>* ***parse_duration*** Interprets a ISO8601 duration value relative to a given timestamp.<br>* ***get_expire_time*** Compares 2 dates and returns the earliest.<br>* ***query*** Extracts nodes that match the query from the Element.<br>* ***delete_local_session*** Deletes the local session.<br>* ***calculate_x509_fingerprint*** Calculates the fingerprint of a x509cert.<br>* ***format_finger_print*** Formates a fingerprint.<br>* ***generate_name_id*** Generates a nameID.<br>* ***get_status*** Gets Status from a Response.<br>* ***decrypt_element*** Decrypts an encrypted element.<br>* ***write_temp_file*** Writes some content into a temporary file and returns it.<br>* ***add_sign*** Adds signature key and senders certificate to an element (Message or Assertion).<br>* ***validate_sign*** Validates a signature (Message or Assertion).<br>* ***validate_binary_sign*** Validates signed bynary data (Used to validate GET Signature).<br>* ***def get_encoded_parameter*** Return an url encoded get parameter value<br>* ***extract_raw_query_parameter***<br><br>####OneLogin_Saml2_IdPMetadataParser - idp_metadata_parser.py####<br><br>A class that contains methods to obtain and parse metadata from IdP<br><br>* ***get_metadata*** Get the metadata XML from the provided URL<br>* ***parse_remote*** Get the metadata XML from the provided URL and parse it, returning a dict with extracted data<br>* ***parse*** Parse the Identity Provider metadata and returns a dict with extracted data<br>* ***merge_settings*** Will update the settings with the provided new settings data extracted from the IdP metadata<br><br>For more info, look at the source code; each method is documented and details about what does and how to use it are provided. Make sure to also check the doc folder where HTML documentation about the classes and methods is provided.<br><br>Demos included in the toolkit<br>-----------------------------<br><br>The toolkit includes 2 demos to teach how use the toolkit (A django and a flask project), take a look on it.<br>Demos require that SP and IdP are well configured before test it, so edit the settings files.<br><br>Notice that each python framework has it own way to handle routes/urls and process request, so focus on<br>how it deployed. New demos using other python frameworks are welcome as a contribution.<br><br>### Getting Started ###<br><br>We said that this toolkit includes a django application demo and a flask applicacion demo,<br>lets see how fast is deploy them.<br><br>***Virtualenv***<br><br>The use of a [virtualenv](http://virtualenv.readthedocs.org/en/latest/) is<br>highly recommended.<br><br>Virtualenv helps isolating the python enviroment used to run the toolkit. You<br>can find more details and an installation guide in the<br>[official documentation](http://virtualenv.readthedocs.org/en/latest/).<br><br>Once you have your virtualenv ready and loaded, then you can install the<br>toolkit on it in development mode executing this:<br>```<br> python setup.py develop<br>```<br><br>Using this method of deployment the toolkit files will be linked instead of<br>copied, so if you make changes on them you won't need to reinstall the toolkit.<br><br>If you want install it in a normal mode, execute:<br>```<br> python setup.py install<br>```<br><br>### Demo Flask ###<br><br>You'll need a virtualenv with the toolkit installed on it.<br><br>To run the demo you need to install the requirements first. Load your<br>virtualenv and execute:<br><br>```<br> pip install -r demo-flask/requirements.txt<br>```<br><br>This will install flask and its dependences. Once it has finished, you have to complete the configuration<br>of the toolkit. You'll find it at `demo-flask/settings.json`<br><br>Now, with the virtualenv loaded, you can run the demo like this:<br>```<br> cd demo-flask<br> python index.py<br>```<br><br>You'll have the demo running at http://localhost:8000<br><br>####Content####<br><br>The flask project contains:<br><br><br>* ***index.py*** Is the main flask file, where or the SAML handle take place.<br><br>* ***templates***. Is the folder where flask stores the templates of the project. It was implemented a base.html template that is extended by index.html and attrs.html, the templates of our simple demo that shows messages, user attributes when available and login and logout links.<br><br>* ***saml*** Is a folder that contains the 'certs' folder that could be used to store the x509 public and private key, and the saml toolkit settings (settings.json and advanced_settings.json).<br><br><br>####SP setup####<br><br>The Onelogin's Python Toolkit allows you to provide the settings info in 2 ways: settings files or define a setting dict. In the demo-flask it used the first method.<br><br>In the index.py file we define the app.config['SAML_PATH'], that will target to the 'saml' folder. We require it in order to load the settings files.<br><br>First we need to edit the saml/settings.json, configure the SP part and  review the metadata of the IdP and complete the IdP info.  Later edit the saml/advanced_settings.json files and configure the how the toolkit will work. Check the settings section of this document if you have any doubt.<br><br>####IdP setup####<br><br>Once the SP is configured, the metadata of the SP is published at the /metadata url. Based on that info, configure the IdP.<br><br>####How it works####<br><br>1. First time you access to the main view 'http://localhost:8000', you can select to login and return to the same view or login and be redirected to /?attrs (attrs view).<br><br> 2. When you click:<br><br>    2.1 in the first link, we access to /?sso (index view). An AuthNRequest is sent to the IdP, we authenticate at the IdP and then a Response is sent through the user's client to the SP, specifically the Assertion Consumer Service view: /?acs. Notice that a RelayState parameter is set to the url that initiated the process, the index view.<br><br>    2.2 in the second link we access to /?attrs (attrs view), we will expetience have the same process described at 2.1 with the diference that as RelayState is set the attrs url.<br><br> 3. The SAML Response is processed in the ACS /?acs, if the Response is not valid, the process stops here and a message is shown. Otherwise we are redirected to the RelayState view. a) / or b) /?attrs<br><br> 4. We are logged in the app and the user attributes are showed. At this point, we can test the single log out functionality.<br><br> The single log out funcionality could be tested by 2 ways.<br><br>    5.1 SLO Initiated by SP. Click on the \"logout\" link at the SP, after that a Logout Request is sent to the IdP, the session at the IdP is closed and replies through the client to the SP with a Logout Response (sent to the Single Logout Service endpoint). The SLS endpoint /?sls of the SP process the Logout Response and if is valid, close the user session of the local app. Notice that the SLO Workflow starts and ends at the SP.<br><br>    5.2 SLO Initiated by IdP. In this case, the action takes place on the IdP side, the logout process is initiated at the IdP, sends a Logout Request to the SP (SLS endpoint, /?sls). The SLS endpoint of the SP process the Logout Request and if is valid, close the session of the user at the local app and send a Logout Response to the IdP (to the SLS endpoint of the IdP). The IdP receives the Logout Response, process it and close the session at of the IdP. Notice that the SLO Workflow starts and ends at the IdP.<br><br>Notice that all the SAML Requests and Responses are handled at a unique view (index) and how GET paramters are used to know the action that must be done.<br><br>### Demo Django ###<br><br>You'll need a virtualenv with the toolkit installed on it.<br><br>To run the demo you need to install the requirements first. Load your<br>virtualenv  and execute:<br>```<br> pip install -r demo-django/requirements.txt<br>```<br>This will install django and its dependences. Once it has finished, you have to complete the configuration of the toolkit.<br><br>Later, with the virtualenv loaded, you can run the demo like this:<br>```<br> cd demo-django<br> python manage.py runserver 0.0.0.0:8000<br>```<br><br>You'll have the demo running at http://localhost:8000.<br><br>Note that many of the configuration files expect HTTPS. This is not required by the demo, as replacing these SP URLs with HTTP will work just fine. HTTPS is however highly encouraged, and left as an exercise for the reader for their specific needs.<br><br>If you want to integrate a production django application, take a look on this SAMLServiceProviderBackend that uses our toolkit to add SAML support: https://github.com/KristianOellegaard/django-saml-service-provider<br><br>####Content####<br><br>The django project contains:<br><br>* ***manage.py***. A file that is automatically created in each Django project. Is a thin wrapper around django-admin.py that takes care of putting the project\u2019s package on sys.path and sets the DJANGO_SETTINGS_MODULE environment variable.<br><br>* ***saml*** Is a folder that contains the 'certs' folder that could be used to store the x509 public and private key, and the saml toolkit settings (settings.json and advanced_settings.json).<br><br>* ***demo*** Is the main folder of the django project, that contains the typical files:<br>  * ***settings.py*** Contains the default parameters of a django project except the SAML_FOLDER parameter, that may contain the path where is located the 'saml' folder.<br>  * ***urls.py*** A file that define url routes. In the demo we defined '/' that is related to the index view, '/attrs' that is related with the attrs view and '/metadata', related to th metadata view.<br>  * ***views.py*** This file contains the views of the django project and some aux methods.<br>  * ***wsgi.py*** A file that let as deploy django using WSGI, the Python standard for web servers and applications.<br><br>* ***templates***. Is the folder where django stores the templates of the project. It was implemented a base.html template that is extended by index.html and attrs.html, the templates of our simple demo that shows messages, user attributes when available and login and logout links.<br><br>####SP setup####<br><br>The Onelogin's Python Toolkit allows you to provide the settings info in 2 ways: settings files or define a setting dict. In the demo-django it used the first method.<br><br>After set the SAML_FOLDER in the demo/settings.py, the settings of the python toolkit will be loaded on the django web.<br><br>First we need to edit the saml/settings.json, configure the SP part and  review the metadata of the IdP and complete the IdP info.  Later edit the saml/advanced_settings.json files and configure the how the toolkit will work. Check the settings section of this document if you have any doubt.<br><br>####IdP setup####<br><br>Once the SP is configured, the metadata of the SP is published at the /metadata url. Based on that info, configure the IdP.<br><br>####How it works####<br><br>This demo works very similar to the flask-demo (We did it intentionally).<br>\n          </div>"}, "last_serial": 2772561, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "eabb56fd7a887ed23359e8317fb755c4", "sha256": "67127544c9f2ac0521258dafe6a2c6d79a2ad80f860d1f1f819f8c4719806b7b"}, "downloads": -1, "filename": "python_saml_nocert-0.1.tar.gz", "has_sig": false, "md5_digest": "eabb56fd7a887ed23359e8317fb755c4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1196, "upload_time": "2017-04-11T06:43:03", "upload_time_iso_8601": "2017-04-11T06:43:03.492435Z", "url": "https://files.pythonhosted.org/packages/1a/8b/3ea104581166a7f7c10abd1fdfd54c7f770ab9c64dd948e2f9c7474fe362/python_saml_nocert-0.1.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "1665d1608659b1bb6863003690b18d26", "sha256": "df180428ddc10fdaf344b1750965e1d65d0d37868cbad862217c23941ff761dc"}, "downloads": -1, "filename": "python_saml_nocert-0.2.tar.gz", "has_sig": false, "md5_digest": "1665d1608659b1bb6863003690b18d26", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1196, "upload_time": "2017-04-11T06:51:53", "upload_time_iso_8601": "2017-04-11T06:51:53.253278Z", "url": "https://files.pythonhosted.org/packages/fa/73/0cc55871685da46680c4758d8763e3c3378a32106c45cd8d283049fe6b4c/python_saml_nocert-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "7f2b3817200d20bd11cf264ba8f2c654", "sha256": "9a28a98ca8e109b4d66336bf7c4dcbda1e799f4ab8de59d08e04fed61979afb2"}, "downloads": -1, "filename": "python_saml_nocert-0.3.tar.gz", "has_sig": false, "md5_digest": "7f2b3817200d20bd11cf264ba8f2c654", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 1192, "upload_time": "2017-04-11T06:57:52", "upload_time_iso_8601": "2017-04-11T06:57:52.088211Z", "url": "https://files.pythonhosted.org/packages/e8/89/a5b59da2061c4e8d0d75a7c0f2e41667139bbb0936b653320a2bbd184b7b/python_saml_nocert-0.3.tar.gz", "yanked": false}], "0.4": [{"comment_text": "", "digests": {"md5": "2c62cccd3a0f640d07a408391ce49e76", "sha256": "cf3d1052c7d0854020a9661e4680ea5c042dc11285aff756937a971a0c58cb33"}, "downloads": -1, "filename": "python_saml_nocert-0.4.tar.gz", "has_sig": false, "md5_digest": "2c62cccd3a0f640d07a408391ce49e76", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34773, "upload_time": "2017-04-11T07:14:01", "upload_time_iso_8601": "2017-04-11T07:14:01.023935Z", "url": "https://files.pythonhosted.org/packages/0e/5c/7dc2e72f7fb4cfdbb16e67579bcb4e3540170d4be6d4141a71bcef925747/python_saml_nocert-0.4.tar.gz", "yanked": false}], "0.5": [{"comment_text": "", "digests": {"md5": "022fd142807a9eeb78f18941aee32a95", "sha256": "dc1598fd4ba4f182528c1acdaaee72200f6087cc72177a2cca13d236b5a85720"}, "downloads": -1, "filename": "python_saml_nocert-0.5.tar.gz", "has_sig": false, "md5_digest": "022fd142807a9eeb78f18941aee32a95", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34789, "upload_time": "2017-04-11T07:16:49", "upload_time_iso_8601": "2017-04-11T07:16:49.362917Z", "url": "https://files.pythonhosted.org/packages/ad/52/612d83b5710b5f932c9751093d8f73568cb446ccb9675332afbc5db23bc9/python_saml_nocert-0.5.tar.gz", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "ddfc13fba0bc97eee88cddaf932eb92e", "sha256": "d0872854057ba7f78f03889543b58d97fa75e4e5bcc2942a933c72c209326f54"}, "downloads": -1, "filename": "python_saml_nocert-0.6.tar.gz", "has_sig": false, "md5_digest": "ddfc13fba0bc97eee88cddaf932eb92e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 34789, "upload_time": "2017-04-11T07:28:29", "upload_time_iso_8601": "2017-04-11T07:28:29.745824Z", "url": "https://files.pythonhosted.org/packages/55/e4/84cd2fe27841b7ad0f20302af57ce8ddc54a1e1a70ecb856a9d725061567/python_saml_nocert-0.6.tar.gz", "yanked": false}], "2.2.1": [{"comment_text": "", "digests": {"md5": "88ffef4f5b6b8e157a306cd99ec7d987", "sha256": "c8e1fb83652e9a93daed3bc21b8aa44a59001874d3800e16127c67af584c2e29"}, "downloads": -1, "filename": "python-saml-nocert-2.2.1.tar.gz", "has_sig": false, "md5_digest": "88ffef4f5b6b8e157a306cd99ec7d987", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 67025, "upload_time": "2017-04-11T07:49:37", "upload_time_iso_8601": "2017-04-11T07:49:37.897907Z", "url": "https://files.pythonhosted.org/packages/09/d2/bbabb30c62c233e2723133a2afd93d8a446467ed5e920ab4dd5a5215d3ad/python-saml-nocert-2.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "88ffef4f5b6b8e157a306cd99ec7d987", "sha256": "c8e1fb83652e9a93daed3bc21b8aa44a59001874d3800e16127c67af584c2e29"}, "downloads": -1, "filename": "python-saml-nocert-2.2.1.tar.gz", "has_sig": false, "md5_digest": "88ffef4f5b6b8e157a306cd99ec7d987", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 67025, "upload_time": "2017-04-11T07:49:37", "upload_time_iso_8601": "2017-04-11T07:49:37.897907Z", "url": "https://files.pythonhosted.org/packages/09/d2/bbabb30c62c233e2723133a2afd93d8a446467ed5e920ab4dd5a5215d3ad/python-saml-nocert-2.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:15:31 2020"}