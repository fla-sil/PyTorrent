{"info": {"author": "Sergey Krilov", "author_email": "", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: MIT License", "Programming Language :: Python", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy"], "description": "\n# rtreelib\n\nPluggable R-tree implementation in pure Python.\n\n## Overview\n\nSince the original R-tree data structure has been initially proposed in 1984, there have been\nmany variations introduced over the years optimized for various use cases [1]. However, when\nworking in Python (one of the most popular languages for spatial data processing), there is\nno easy way to quickly compare how these various implementations behave on real data.\n\nThe aim of this library is to provide a \"pluggable\" R-tree implementation that allows swapping\nout the various strategies for insertion, node deletion, and other behaviors so that their\nimpact can be easily compared (without having to install separate libraries and having to\nmake code changes to accommodate for API differences). Several of the more common R-tree\nvariations will soon be provided as ready-built implementations (see the **Status** section\nbelow).\n\nIn addition, this library also provides utilities for inspecting the R-tree structure. It\nallows creating diagrams (using matplotlib and graphviz) that show the R-tree nodes and\nentries (including all the intermediate, non-leaf nodes), along with plots of their\ncorresponding bounding boxes. It also allows exporting the R-tree to PostGIS so it could\nbe examined using a GIS viewer like QGIS.\n\n## Status\n\nThis library is currently in early development. The table below shows which R-tree variants\nhave been implemented, along with which operations they currently support:\n\n| R-Tree Variant        | Insert                | Update                | Delete                |\n|-----------------------|-----------------------|-----------------------|-----------------------|\n| **Guttman** [2]       | :heavy_check_mark:    | :black_square_button: | :black_square_button: |\n| **R\\*-Tree** [3]      | :heavy_check_mark:    | :black_square_button: | :black_square_button: |\n\nThe library has a framework in place for swapping out the various strategies, making it\npossible to add a new R-tree variant. However, given that this library is still early in\ndevelopment, it is anticipated that this framework may need to be extended, resulting in\nbreaking changes.\n\nContributions for implementing additional strategies and operations are welcome. See\nthe section on **Extending** below.\n\n## Setup\n\nThis package is available on PyPI and can be installed using pip:\n\n```\npip install rtreelib\n```\n\nThis package requires Python 3.6+.\n\nThere are additional optional dependencies you can install if you want to be able to\ncreate diagrams or export the R-tree data to PostGIS. See the corresponding sections\nbelow for additional setup information.\n\n## Usage\n\nTo instantiate the default implementation and insert some entries:\n\n```python\nfrom rtreelib import RTree, Rect\n\nt = RTree()\nt.insert('a', Rect(0, 0, 3, 3))\nt.insert('b', Rect(2, 2, 4, 4))\nt.insert('c', Rect(1, 1, 2, 4))\nt.insert('d', Rect(8, 8, 10, 10))\nt.insert('e', Rect(7, 7, 9, 9))\n```\n\nThe first parameter to the `insert` method represents the data, and can be of any data type\n(though you will want to stick to strings, numbers, and other basic data types that can be\neasily and succintly represented as a string if you want to create diagrams). The second\nparameter represents the minimum bounding rectangle (MBR) of the associated data element.\n\nThe default implementation uses Guttman's original strategies for insertion, node splitting,\nand deletion, as outlined in his paper from 1984 [2].\n\nTo use the R* implementation instead:\n\n```python\nfrom rtreelib import RStarTree, Rect\n\nt = RStarTree()\nt.insert('a', Rect(0, 0, 3, 3))\nt.insert('b', Rect(2, 2, 4, 4))\nt.insert('c', Rect(1, 1, 2, 4))\nt.insert('d', Rect(8, 8, 10, 10))\nt.insert('e', Rect(7, 7, 9, 9))\n```\n\nYou can also create a custom implementation by inheriting from `RTreeBase` and providing\nyour own implementations for the various behaviors (insert, overflow, etc.). See the\nfollowing section for more information.\n\n## Querying\n\nUse the `query` method to find entries at a given location. The library supports querying\nby either a point or a rectangle, and returns an iterable of matching entries that\nintersect the given location.\n\nTo query using `Point`:\n\n```python\nentries = t.query(Point(2, 4))\n```\n\nAlternatively, you can also pass a tuple or list of 2 coordinates (`x` and `y`):\n\n```python\nentries = t.query((2, 4))\n```\n\nWhen querying by point, note that points that lie on the border (rather than the\ninterior) of a bounding rectangle are considered to intersect the rectangle.\n\nTo query using `Rect`:\n\n```python\nentries = t.query(Rect(2, 1, 4, 5))\n```\n\nAlternatively, you can also pass a tuple or list of 4 coordinates (the order is the\nsame as when using `Rect`, namely `min_x`, `min_y`, `max_x`, and `max_y`):\n\n```python\nentries = t.query((2, 1, 4, 5))\n```\n\nWhen querying by rectangle, note that the rectangles must have a non-zero intersection\narea. Rectangles that intersect at the border but whose interiors do not overlap will\n*not* match the query.\n\nNote the above methods return entries rather than nodes. To get an iterable of leaf\nnodes instead, use `query_nodes`:\n\n```python\nnodes = t.query_nodes(Rect(2, 1, 4, 5))\n```\n\nBy default, this method will only return leaf-level nodes. To include all\nintermediate-level nodes (including the root), set the optional `leaves` parameter\nto `False` (it defaults to `True` if not passed in):\n\n```python\nall_nodes = t.query_nodes(Rect(2, 1, 4, 5), leaves=False)\n```\n\n## Extending\n\nAs noted above, the purpose of this library is to provide a pluggable R-tree implementation\nwhere the various behaviors can be swapped out and customized to allow comparison. To that\nend, this library provides a framework for achieving this.\n\nAs an example, the [`RTreeGuttman`](https://github.com/sergkr/rtreelib/blob/master/rtreelib/strategies/guttman.py)\nclass (aliased as `RTree`) simply inherits from `RTreeBase`, providing an implementation\nfor the `insert`, `choose_leaf`, `adjust_tree`, and `overflow_strategy` behaviors as follows:\n\n```python\nclass RTreeGuttman(RTreeBase[T]):\n    \"\"\"R-Tree implementation that uses Guttman's strategies for insertion, splitting, and deletion.\"\"\"\n\n    def __init__(self, max_entries: int = DEFAULT_MAX_ENTRIES, min_entries: int = None):\n        \"\"\"\n        Initializes the R-Tree using Guttman's strategies for insertion, splitting, and deletion.\n        :param max_entries: Maximum number of entries per node.\n        :param min_entries: Minimum number of entries per node. Defaults to ceil(max_entries/2).\n        \"\"\"\n        super().__init__(\n            max_entries=max_entries,\n            min_entries=min_entries,\n            insert=insert,\n            choose_leaf=guttman_choose_leaf,\n            adjust_tree=adjust_tree_strategy,\n            overflow_strategy=quadratic_split\n        )\n```\n\nEach behavior should be a function that implements a specific signature and performs a given\ntask. Here are the behaviors that are currently required to be specified:\n\n* **`insert`**: Strategy used for inserting a single new entry into the tree.\n  * Signature: `(tree: RTreeBase[T], data: T, rect: Rect) \u2192 RTreeEntry[T]`\n  * Arguments:\n    * `tree: RTreeBase[T]`: R-tree instance.\n    * `data: T`: Data stored in this entry.\n    * `rect: Rect`: Bounding rectangle.\n  * Returns: `RTreeEntry[T]`\n    * This function should return the newly inserted entry.\n* **`choose_leaf`**: Strategy used for choosing a leaf node when inserting a new entry.\n  * Signature: `(tree: RTreeBase[T], entry: RTreeEntry[T]) \u2192 RTreeNode[T]`\n  * Arguments:\n    * `tree: RTreeBase[T]`: R-tree instance.\n    * `entry: RTreeEntry[T]`: Entry being inserted.\n  * Returns: `RTreeNode[T]`\n    * This function should return the leaf node where the new entry should be inserted. This\n    node may or may not have the capacity for the new entry. If the insertion of the new node\n    results in the node overflowing, then `overflow_strategy` will be invoked on the node.\n* **`adjust_tree`**: Strategy used for balancing the tree, including propagating node splits,\nupdating bounding boxes on all nodes and entries as necessary, and growing the tree by\ncreating a new root if necessary. This strategy is executed after inserting or deleting an\nentry.\n  * Signature: `(tree: RTreeBase[T], node: RTreeNode[T], split_node: RTreeNode[T]) \u2192 None`\n  * Arguments:\n    * `tree: RTreeBase[T]`: R-tree instance.\n    * `node: RTreeNode[T]`: Node where a newly-inserted entry has just been added.\n    * `split_node: RTreeNode[T]`: If the insertion of a new entry has caused the node to\n    split, this is the newly-created split node. Otherwise, this will be `None`.\n  * Returns: `None`\n* **`overflow_strategy`**: Strategy used for handling an overflowing node (a node that\ncontains more than `max_entries`). Depending on the implementation, this may involve\nsplitting the node and potentially growing the tree (Guttman), performing a forced\nreinsert of entries (R*), or some other strategy.\n  * Signature: `(tree: RTreeBase[T], node: RTreeNode[T]) \u2192 RTreeNode[T]`\n  * Arguments:\n    * `tree: RTreeBase[T]`: R-tree instance.\n    * `node: RTreeNode[T]`: Overflowing node.\n  * Returns: `RTreeNode[T]`\n    * Depending on the implementation, this function may return a newly-created split\n    node whose entries are a subset of the original node's entries (Guttman), or simply\n    return `None`.\n\n## Creating R-tree Diagrams\n\nThis library provides a set of utility functions that can be used to create diagrams of the\nentire R-tree structure, including the root and all intermediate and leaf level nodes and\nentries.\n\nThese features are optional, and the required dependencies are *not* automatically installed\nwhen installing this library. Therefore, you must install them manually. This includes the\nfollowing Python dependencies which can be installed using pip:\n\n```\npip install matplotlib pydot tqdm\n```\n\nThis also includes the following system-level dependencies:\n\n* TkInter\n* Graphviz\n\nOn Ubuntu, these can be installed using:\n\n```\nsudo apt install python3-tk graphviz\n```\n\nOnce the above dependencies are installed, you can create an R-tree diagram as follows:\n\n```python\nfrom rtreelib import RTree, Rect\nfrom rtreelib.diagram import create_rtree_diagram\n\n\n# Create an RTree instance with some sample data\nt = RTree(max_entries=4)\nt.insert('a', Rect(0, 0, 3, 3))\nt.insert('b', Rect(2, 2, 4, 4))\nt.insert('c', Rect(1, 1, 2, 4))\nt.insert('d', Rect(8, 8, 10, 10))\nt.insert('e', Rect(7, 7, 9, 9))\n\n# Create a diagram of the R-tree structure\ncreate_rtree_diagram(t)\n```\n\nThis creates a diagram like the following:\n\n![R-tree Diagram](https://github.com/sergkr/rtreelib/blob/master/doc/rtree_diagram.png \"R-tree Diagram\")\n\nThe diagram is created in a temp directory as a PNG file, and the default viewer\nis automatically launched for convenience. Each box in the main diagram represents a node\n(except at the leaf level, where it represents the leaf entry), and contains a plot that\ndepicts all of the data spatially. The bounding boxes of each node are represented using\ntan rectangles with a dashed outline. The bounding box corresponding to the current node\nis highlighted in pink.\n\nThe bounding boxes for the original data entries themselves are depicted in blue, and are\nlabeled using the value that was passed in to `insert`. At the leaf level, the corresponding\ndata element is highlighted in pink.\n\nThe entries contained in each node are depicted along the bottom of the node's box, and\npoint to either a child node (for non-leaf nodes), or to the data entries (for leaf nodes).\n\nAs can be seen in the above screenshot, the diagram depicts the entire tree structure, which\ncan be quite large depending on the number of nodes and entries. It may also take a while to\ngenerate, since it launches matplotlib to plot the data spatially for each node and entry, and\nthen graphviz to generate the overall diagram. Given the size and execution time required to\ngenerate these diagrams, it's only practical for R-trees containing a relatively small\namount of data (e.g., no more than about a dozen total entries). To analyze the resulting\nR-tree structure when working with a large amount of data, it is recommended to export the\ndata to PostGIS and use a viewer like QGIS (as explained in the following section).\n\n## Exporting to PostGIS\n\nIn addition to creating diagrams, this library also allows exporting R-trees to a\nPostGIS database.\n\nTo do so, you will first need to install the [psycopg2](http://initd.org/psycopg/) driver.\nThis is an optional dependency, so it is not automatically installed when you install\nthis package. Refer to the\n[installation instructions for psycopg2](http://initd.org/psycopg/docs/install.html) to\nensure that you have all the necessary system-wide prerequisites installed (C compiler,\nPython header files, etc.). Then, install `psycopg2` using the following command (passing\nthe `--no-binary` flag to ensure that it is built from source, and also to avoid a console\nwarning when using `psycopg2`):\n\n```\npip install psycopg2 --no-binary psycopg2\n```\n\nOnce `psycopg2` is installed, you should be able to import the functions you need from the\n`rtreelib.pg` module:\n\n```python\nfrom rtreelib.pg import init_db_pool, create_rtree_tables, export_to_postgis\n```\n\nThe subsections below guide you throw how to use this library to export R-trees to the\ndatabase. You will first need to decide on your preferred method for connecting to the\ndatabase, as well as create the necessary tables to store the R-tree data. Once these\nprerequisites are met, exporting the R-tree can be done using a simple function call.\nFinally, this guide shows how you can visualize the exported data using QGIS, a popular\nand freely-available GIS viewer.\n\n### Initializing a Connection Pool\n\nWhen working with the `rtreelib.pg` module, there are three ways of passing database\nconnection information:\n\n1. Initialize a connection pool by calling `init_db_pool`. This allows using the other\nfunctions in this module without having to pass around connection info.\n2. Manually open the connection yourself, and pass in the connection object to the\nfunction.\n3. Pass in keyword arguments that can be used to establish the database connection.\n\nThe first method is generally the easiest - you just have to call it once, and not\nhave to worry about passing in connection information to the other functions. This\nsection explains this method, and the following sections assume that you are using\nit. However, the other methods are also explained later on in this guide.\n\n`init_db_pool` accepts the same parameters as the\n[psycopg2.connect](http://initd.org/psycopg/docs/module.html#psycopg2.connect) function.\nFor example, you can pass in a connection string:\n\n```python\ninit_db_pool(\"dbname=mydb user=postgres password=temp123!\")\n```\n\nAlternatively, using the URL syntax:\n\n```python\ninit_db_pool(\"postgresql://localhost/mydb?user=postgres&password=temp123!\")\n```\n\nOr keyword arguments:\n\n```python\ninit_db_pool(user=\"postgres\", password=\"temp123!\", host=\"localhost\", database=\"mydb\")\n```\n\nNext, before you can export an R-tree, you first need to create a few database\ntables to store the data. The following section explains how to achieve this.\n\n### Creating Tables to Store R-tree Data\n\nWhen exporting an R-tree using this library, the data is populated inside three\ntables:\n\n* `rtree`: This tables simply contains the ID of each R-tree that was exported.\nThis library allows you to export multiple R-trees at once, and they are\ndifferentiated by ID (you can also clear the contents of all tables using\n`clear_rtree_tables`).\n* `rtree_node`: Contains information about each node in the R-tree, including\nits bounding box (as a PostGIS geometry column), a pointer to the parent entry\ncontaining this node, and the level of this node (starting at 0 for the root).\nThe node also contains a reference to the `rtree` that it is a part of.\n* `rtree_entry`: Contains information about each entry in the R-tree, including\nits bounding box (as a PostGIS geometry column) and a pointer to the node\ncontaining this entry. For leaf entries, this also contains the value of the\ndata element.\n\nThese tables can be created using the `create_rtree_tables` function. This is\nsomething you only need to do once.\n\nThis function can be called without any arguments if you have established the\nconnection pool, and your data does not use a spatial reference system (`srid`).\nHowever, generally when working with spatial data, you will have a particular\nSRID that your data is in, in which case you should pass it in to ensure that\nall geometry columns use the correct SRID:\n\n```python\ncreate_rtree_tables(srid=4326)\n```\n\nYou can also choose to create the tables in a different schema (other than `public`):\n\n```python\ncreate_rtree_tables(srid=4326, schema=\"temp\")\n```\n\nHowever, in this case, be sure to pass in the same schema to the other functions in\nthis module.\n\nYou can also pass in a `datatype`, which indicates the type of data stored in the leaf\nentries (i.e., the type of the data you pass in to the `insert` method of `RTree`).\nThis can either be a string containing a PostgreSQL column type:\n\n```python\ncreate_rtree_tables(srid=4326, datatype='VARCHAR(255)')\n```\n\nOr a Python type, in which case an appropriate PostgreSQL data type will be inferred:\n\n```python\ncreate_rtree_tables(srid=4326, datatype=int)\n```\n\nIf you don't pass anything in, or an appropriate PostgreSQL data type cannot be\ndetermined from the Python type, the column type will default to `TEXT`, which allows\nstoring arbitrary-length strings.\n\nWhen passing a string containing a PostgreSQL column type, you also have the option\nof adding a modifier such as `NOT NULL`, or even a foreign key constraint:\n\n```python\ncreate_rtree_tables(srid=4326, datatype='INT REFERENCES my_other_table (my_id_column)')\n```\n\n### Exporting the R-tree\n\nTo export the R-tree once the tables have been created, simply call the\n`export_to_postgis` function, passing in the R-tree instance (and optionally an SRID):\n\n```python\nrtree_id = export_to_postgis(tree, srid=4326)\n```\n\nThis function populates the `rtree`, `rtree_node`, and `rtree_entry` tables with\nthe data from the R-tree, and returns the ID of the newly-inserted R-tree in the\n`rtree` table.\n\nNote that if you used a schema other than `public` when calling\n`create_rtree_tables`, you will need to pass in the same schema when calling\n`export_to_postgis`:\n\n```python\nrtree_id = export_to_postgis(tree, srid=4326, schema='temp')\n```\n\n### Viewing the Data Using QGIS\n\n[QGIS](https://qgis.org/en/site/) is a popular and freely-available GIS viewer which\ncan be used to visualize the exported R-tree data. To do so, launch QGIS and create\na new project. Then, follow these steps to add the exported R-tree data as a layer:\n\n* Go to Layer \u2192 Add Layer \u2192 Add PostGIS Layers\n* Connect to the database where you exported the data\n* Select either the `rtree_node` or `rtree_entry` table, depending on which part of\nthe structure you wish to visualize. For this example, we will be looking at the\nnodes, so select `rtree_node`.\n* Optionally, you can set a layer filter to only include the nodes belonging to a\nparticular tree (if you exported multiple R-trees). To do so, click the\n**Set Filter** button, and enter a filter expression (such as `rtree_id=1`).\n* Click **Add**\n\nAt this point, the layer will be displaying all nodes at every level of the tree,\nwhich may be a bit hard to decipher if you have a lot of data. After adjusting the\nlayer style to make it partially transparent, here is an example of what an R-tree\nwith a couple hundred leaf entries might look like (41 nodes across 3 levels):\n\n![QGIS - All Nodes](https://github.com/sergkr/rtreelib/blob/master/doc/qgis_all_nodes.png)\n\nTo make it easier to understand the structure, it might help to be able to view each\nlevel of the tree independently. To do this, double click the layer in the Layers\npanel, switch to the Style tab, and change the style type at the top from\n\"Single symbol\" (the default) to \"Categorized\". Then in the Column dropdown, select\nthe \"level\" column. You can optionally assign a color ramp or use random colors so\nthat each level gets a different color. Then click **Classify** to automatically\ncreate a separate style for each layer:\n\n![QGIS - Layer Style](https://github.com/sergkr/rtreelib/blob/master/doc/qgis_layer_style.png)\n\nNow in the layers panel, each level will be shown as a separate entry and can be\ntoggled on and off, making it possible to explore the R-tree structure one level\nat a time:\n\n![QGIS - Layers Panel](https://github.com/sergkr/rtreelib/blob/master/doc/qgis_layers_panel.png)\n\nThe advantage with exporting the data to QGIS is you can also bring in your\noriginal dataset as a layer to see how it was partitioned spatially. Further,\nyou can import multiple R-trees as separate layers and be able to compare them\nside by side.\n\nBelow, I am using a subset of the FAA airspace data for a portion of the\nNortheastern US, and then toggling each level of the `rtree_node` layer individually\nso we can examine the resulting R-tree structure one level at a time. After\ncompositing these together, you can see how the Guttman R-Tree performs against\nR*.\n\n**Guttman**:\n\n![Guttman R-Tree](https://github.com/sergkr/rtreelib/blob/master/doc/qgis_guttman.gif)\n\n**R\\*-Tree**:\n\n![R*-Tree](https://github.com/sergkr/rtreelib/blob/master/doc/qgis_rstar.gif)\n\nIt is evident that R* has resulted in more square-like bounding rectangles with\nless overlap at the intermediate levels, compared to Guttman. The areas of overlap\nare made especially evident when using a partially transparent fill. Ideally, the\nspatial partitioning scheme should aim to minimize this overlap, since a query to\nfind the leaf entry for a given point would require visiting multiple subtrees if\nthat point happens to land in one of these darker shaded areas of overlap.\n\nYou can also write a query to analyze the amount of overlap that resulted in each\nlevel of the tree. For example, the query below returns the total amount of overlap\narea of all nodes at level 2 of an exported R-tree having ID 1:\n\n```postgresql\nSELECT ST_Area(ST_Union(ST_Intersection(n1.bbox, n2.bbox))) AS OverlapArea\nFROM temp.rtree t\n  INNER JOIN temp.rtree_node n1 ON n1.rtree_id = t.id\n  INNER JOIN temp.rtree_node n2 ON n2.rtree_id = t.id AND n1.level = n2.level\nWHERE\n  t.id = 1\n  AND n1.level = 2\n  AND ST_Overlaps(n1.bbox, n2.bbox)\n  AND n1.id <> n2.id;\n```\n\nExtending this even further, you can compare the total overlap area of multiple exported\nR-trees by level:\n\n```postgresql\nSELECT\n  CASE t.id\n    WHEN 1 THEN 'Guttman'\n    WHEN 2 THEN 'R*'\n  END AS tree,\n  n.level,\n  ST_Area(ST_Union(ST_Intersection(n.bbox, n2.bbox))) AS OverlapArea\nFROM temp.rtree t\n  INNER JOIN temp.rtree_node n ON n.rtree_id = t.id\n  INNER JOIN temp.rtree_node n2 ON n2.rtree_id = t.id AND n.level = n2.level\nWHERE\n  ST_Overlaps(n.bbox, n2.bbox)\n  AND n.id <> n2.id\nGROUP BY\n  t.id,\n  n.level\nORDER BY\n  t.id,\n  n.level;\n```\n\nThe above query may return a result like the following:\n\ntree    | level | OverlapArea |\n--------|-------|-------------|\nGuttman | 1     | 7.89e+11    |\nGuttman | 2     | 9.12e+11    |\nGuttman | 3     | 4.75e+11    |\nR*      | 1     | 3.97e+11    |\nR*      | 2     | 4.35e+11    |\nR*      | 3     | 1.80e+11    |\n\nIn the above example, the R*-Tree (`id`=2) achieved a smaller overlap area at\nevery level of the tree compared to Guttman (`id`=1).\n\n### Cleaning Up\n\nAs mentioned above, when you call `export_to_postgis`, the existing data in the\ntables is *not* cleared. This allows you to export multiple R-trees at once and\ncompare them side-by-side.\n\nHowever, for simplicity, you may wish to clear out the existing data prior to\nexporting new data. To do so, call `clear_rtree_tables`:\n\n```python\nclear_rtree_tables()\n```\n\nThis will perform a SQL `TRUNCATE` on all R-tree tables.\n\nNote that if you created the tables in a different schema (other than `public`),\nyou will need to pass in that same schema to this function:\n\n```python\nclear_rtree_tables(schema='temp')\n```\n\nYou may also wish to completely drop all the tables that were created by\n`create_rtree_tables`. To do so, call `drop_rtree_tables`:\n\n```python\ndrop_rtree_tables()\n```\n\nAgain, you may need to pass in a schema if it is something other than `public`:\n\n```python\ndrop_rtree_tables(schema='temp')\n```\n\n### Alternate Database Connection Handling Methods\n\nAs mentioned earlier in this guide, instead of initializing a connection pool,\nyou have other options for how to handle establishing database connections when\nusing this library. You can choose to handle opening and closing the connection\nyourself and pass in the connection object; alternatively, you can pass in the\nconnection information as keyword arguments.\n\nTo establish the database connection yourself, the typical usage scenario might\nlook like this:\n\n```python\nimport psycopg2\nfrom rtreelib import RTree, Rect\nfrom rtreelib.pg import init_db_pool, create_rtree_tables, clear_rtree_tables, export_to_postgis, drop_rtree_tables\n\n\n# Create an RTree instance with some sample data\nt = RTree(max_entries=4)\nt.insert('a', Rect(0, 0, 3, 3))\nt.insert('b', Rect(2, 2, 4, 4))\nt.insert('c', Rect(1, 1, 2, 4))\nt.insert('d', Rect(8, 8, 10, 10))\nt.insert('e', Rect(7, 7, 9, 9))\n\n# Export R-tree to PostGIS (using explicit connection)\nconn = None\ntry:\n    conn = psycopg2.connect(user=\"postgres\", password=\"temp123!\", host=\"localhost\", database=\"mydb\")\n    create_rtree_tables(conn, schema='temp')\n    rtree_id = export_to_postgis(t, conn=conn, schema='temp')\n    print(rtree_id)\nfinally:\n    if conn:\n        conn.close()\n```\n\nYou can also pass in the database connection information separately to each method as\nkeyword arguments. These keyword arguments should be the same ones as required by the\n[psycopg2.connect](http://initd.org/psycopg/docs/module.html#psycopg2.connect) function:\n\n```python\nrtree_id = export_to_postgis(tree, schema='temp', user=\"postgres\", password=\"temp123!\", host=\"localhost\", database=\"mydb\")\n```\n\n## References\n\n[1]: Nanopoulos, Alexandros & Papadopoulos, Apostolos (2003):\n[\"R-Trees Have Grown Everywhere\"](https://pdfs.semanticscholar.org/4e07/e800fe71505fbad686b08334abb49d41fcda.pdf)\n\n[2]:  Guttman, A. (1984):\n[\"R-trees: a Dynamic Index Structure for Spatial Searching\"](http://www-db.deis.unibo.it/courses/SI-LS/papers/Gut84.pdf)\n(PDF), *Proceedings of the 1984 ACM SIGMOD international conference on Management of data \u2013 SIGMOD\n'84.* p. 47.\n\n[3]: Beckmann, Norbert, et al.\n[\"The R*-tree: an efficient and robust access method for points and rectangles.\"](https://infolab.usc.edu/csci599/Fall2001/paper/rstar-tree.pdf)\n*Proceedings of the 1990 ACM SIGMOD international conference on Management of data.* 1990.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/sergkr/rtreelib", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "rtreelib", "package_url": "https://pypi.org/project/rtreelib/", "platform": "", "project_url": "https://pypi.org/project/rtreelib/", "project_urls": {"Homepage": "http://github.com/sergkr/rtreelib"}, "release_url": "https://pypi.org/project/rtreelib/0.2.0/", "requires_dist": ["matplotlib (>=3.0.0) ; extra == 'diagram'", "pydot (>=1.3.0) ; extra == 'diagram'", "tqdm (>=v4.31.0) ; extra == 'diagram'"], "requires_python": ">=3.6.0", "summary": "Pluggable R-tree implementation in pure Python.", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>rtreelib</h1>\n<p>Pluggable R-tree implementation in pure Python.</p>\n<h2>Overview</h2>\n<p>Since the original R-tree data structure has been initially proposed in 1984, there have been\nmany variations introduced over the years optimized for various use cases [1]. However, when\nworking in Python (one of the most popular languages for spatial data processing), there is\nno easy way to quickly compare how these various implementations behave on real data.</p>\n<p>The aim of this library is to provide a \"pluggable\" R-tree implementation that allows swapping\nout the various strategies for insertion, node deletion, and other behaviors so that their\nimpact can be easily compared (without having to install separate libraries and having to\nmake code changes to accommodate for API differences). Several of the more common R-tree\nvariations will soon be provided as ready-built implementations (see the <strong>Status</strong> section\nbelow).</p>\n<p>In addition, this library also provides utilities for inspecting the R-tree structure. It\nallows creating diagrams (using matplotlib and graphviz) that show the R-tree nodes and\nentries (including all the intermediate, non-leaf nodes), along with plots of their\ncorresponding bounding boxes. It also allows exporting the R-tree to PostGIS so it could\nbe examined using a GIS viewer like QGIS.</p>\n<h2>Status</h2>\n<p>This library is currently in early development. The table below shows which R-tree variants\nhave been implemented, along with which operations they currently support:</p>\n<table>\n<thead>\n<tr>\n<th>R-Tree Variant</th>\n<th>Insert</th>\n<th>Update</th>\n<th>Delete</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Guttman</strong> [2]</td>\n<td>:heavy_check_mark:</td>\n<td>:black_square_button:</td>\n<td>:black_square_button:</td>\n</tr>\n<tr>\n<td><strong>R*-Tree</strong> [3]</td>\n<td>:heavy_check_mark:</td>\n<td>:black_square_button:</td>\n<td>:black_square_button:</td>\n</tr></tbody></table>\n<p>The library has a framework in place for swapping out the various strategies, making it\npossible to add a new R-tree variant. However, given that this library is still early in\ndevelopment, it is anticipated that this framework may need to be extended, resulting in\nbreaking changes.</p>\n<p>Contributions for implementing additional strategies and operations are welcome. See\nthe section on <strong>Extending</strong> below.</p>\n<h2>Setup</h2>\n<p>This package is available on PyPI and can be installed using pip:</p>\n<pre><code>pip install rtreelib\n</code></pre>\n<p>This package requires Python 3.6+.</p>\n<p>There are additional optional dependencies you can install if you want to be able to\ncreate diagrams or export the R-tree data to PostGIS. See the corresponding sections\nbelow for additional setup information.</p>\n<h2>Usage</h2>\n<p>To instantiate the default implementation and insert some entries:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">rtreelib</span> <span class=\"kn\">import</span> <span class=\"n\">RTree</span><span class=\"p\">,</span> <span class=\"n\">Rect</span>\n\n<span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">RTree</span><span class=\"p\">()</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'c'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'d'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'e'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">))</span>\n</pre>\n<p>The first parameter to the <code>insert</code> method represents the data, and can be of any data type\n(though you will want to stick to strings, numbers, and other basic data types that can be\neasily and succintly represented as a string if you want to create diagrams). The second\nparameter represents the minimum bounding rectangle (MBR) of the associated data element.</p>\n<p>The default implementation uses Guttman's original strategies for insertion, node splitting,\nand deletion, as outlined in his paper from 1984 [2].</p>\n<p>To use the R* implementation instead:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">rtreelib</span> <span class=\"kn\">import</span> <span class=\"n\">RStarTree</span><span class=\"p\">,</span> <span class=\"n\">Rect</span>\n\n<span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">RStarTree</span><span class=\"p\">()</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'c'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'d'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'e'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">))</span>\n</pre>\n<p>You can also create a custom implementation by inheriting from <code>RTreeBase</code> and providing\nyour own implementations for the various behaviors (insert, overflow, etc.). See the\nfollowing section for more information.</p>\n<h2>Querying</h2>\n<p>Use the <code>query</code> method to find entries at a given location. The library supports querying\nby either a point or a rectangle, and returns an iterable of matching entries that\nintersect the given location.</p>\n<p>To query using <code>Point</code>:</p>\n<pre><span class=\"n\">entries</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">Point</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n</pre>\n<p>Alternatively, you can also pass a tuple or list of 2 coordinates (<code>x</code> and <code>y</code>):</p>\n<pre><span class=\"n\">entries</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">((</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n</pre>\n<p>When querying by point, note that points that lie on the border (rather than the\ninterior) of a bounding rectangle are considered to intersect the rectangle.</p>\n<p>To query using <code>Rect</code>:</p>\n<pre><span class=\"n\">entries</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">(</span><span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n</pre>\n<p>Alternatively, you can also pass a tuple or list of 4 coordinates (the order is the\nsame as when using <code>Rect</code>, namely <code>min_x</code>, <code>min_y</code>, <code>max_x</code>, and <code>max_y</code>):</p>\n<pre><span class=\"n\">entries</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">query</span><span class=\"p\">((</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n</pre>\n<p>When querying by rectangle, note that the rectangles must have a non-zero intersection\narea. Rectangles that intersect at the border but whose interiors do not overlap will\n<em>not</em> match the query.</p>\n<p>Note the above methods return entries rather than nodes. To get an iterable of leaf\nnodes instead, use <code>query_nodes</code>:</p>\n<pre><span class=\"n\">nodes</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">query_nodes</span><span class=\"p\">(</span><span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">))</span>\n</pre>\n<p>By default, this method will only return leaf-level nodes. To include all\nintermediate-level nodes (including the root), set the optional <code>leaves</code> parameter\nto <code>False</code> (it defaults to <code>True</code> if not passed in):</p>\n<pre><span class=\"n\">all_nodes</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">query_nodes</span><span class=\"p\">(</span><span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">),</span> <span class=\"n\">leaves</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<h2>Extending</h2>\n<p>As noted above, the purpose of this library is to provide a pluggable R-tree implementation\nwhere the various behaviors can be swapped out and customized to allow comparison. To that\nend, this library provides a framework for achieving this.</p>\n<p>As an example, the <a href=\"https://github.com/sergkr/rtreelib/blob/master/rtreelib/strategies/guttman.py\" rel=\"nofollow\"><code>RTreeGuttman</code></a>\nclass (aliased as <code>RTree</code>) simply inherits from <code>RTreeBase</code>, providing an implementation\nfor the <code>insert</code>, <code>choose_leaf</code>, <code>adjust_tree</code>, and <code>overflow_strategy</code> behaviors as follows:</p>\n<pre><span class=\"k\">class</span> <span class=\"nc\">RTreeGuttman</span><span class=\"p\">(</span><span class=\"n\">RTreeBase</span><span class=\"p\">[</span><span class=\"n\">T</span><span class=\"p\">]):</span>\n    <span class=\"sd\">\"\"\"R-Tree implementation that uses Guttman's strategies for insertion, splitting, and deletion.\"\"\"</span>\n\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">max_entries</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"n\">DEFAULT_MAX_ENTRIES</span><span class=\"p\">,</span> <span class=\"n\">min_entries</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"kc\">None</span><span class=\"p\">):</span>\n        <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">        Initializes the R-Tree using Guttman's strategies for insertion, splitting, and deletion.</span>\n<span class=\"sd\">        :param max_entries: Maximum number of entries per node.</span>\n<span class=\"sd\">        :param min_entries: Minimum number of entries per node. Defaults to ceil(max_entries/2).</span>\n<span class=\"sd\">        \"\"\"</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span>\n            <span class=\"n\">max_entries</span><span class=\"o\">=</span><span class=\"n\">max_entries</span><span class=\"p\">,</span>\n            <span class=\"n\">min_entries</span><span class=\"o\">=</span><span class=\"n\">min_entries</span><span class=\"p\">,</span>\n            <span class=\"n\">insert</span><span class=\"o\">=</span><span class=\"n\">insert</span><span class=\"p\">,</span>\n            <span class=\"n\">choose_leaf</span><span class=\"o\">=</span><span class=\"n\">guttman_choose_leaf</span><span class=\"p\">,</span>\n            <span class=\"n\">adjust_tree</span><span class=\"o\">=</span><span class=\"n\">adjust_tree_strategy</span><span class=\"p\">,</span>\n            <span class=\"n\">overflow_strategy</span><span class=\"o\">=</span><span class=\"n\">quadratic_split</span>\n        <span class=\"p\">)</span>\n</pre>\n<p>Each behavior should be a function that implements a specific signature and performs a given\ntask. Here are the behaviors that are currently required to be specified:</p>\n<ul>\n<li><strong><code>insert</code></strong>: Strategy used for inserting a single new entry into the tree.\n<ul>\n<li>Signature: <code>(tree: RTreeBase[T], data: T, rect: Rect) \u2192 RTreeEntry[T]</code></li>\n<li>Arguments:\n<ul>\n<li><code>tree: RTreeBase[T]</code>: R-tree instance.</li>\n<li><code>data: T</code>: Data stored in this entry.</li>\n<li><code>rect: Rect</code>: Bounding rectangle.</li>\n</ul>\n</li>\n<li>Returns: <code>RTreeEntry[T]</code>\n<ul>\n<li>This function should return the newly inserted entry.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>choose_leaf</code></strong>: Strategy used for choosing a leaf node when inserting a new entry.\n<ul>\n<li>Signature: <code>(tree: RTreeBase[T], entry: RTreeEntry[T]) \u2192 RTreeNode[T]</code></li>\n<li>Arguments:\n<ul>\n<li><code>tree: RTreeBase[T]</code>: R-tree instance.</li>\n<li><code>entry: RTreeEntry[T]</code>: Entry being inserted.</li>\n</ul>\n</li>\n<li>Returns: <code>RTreeNode[T]</code>\n<ul>\n<li>This function should return the leaf node where the new entry should be inserted. This\nnode may or may not have the capacity for the new entry. If the insertion of the new node\nresults in the node overflowing, then <code>overflow_strategy</code> will be invoked on the node.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong><code>adjust_tree</code></strong>: Strategy used for balancing the tree, including propagating node splits,\nupdating bounding boxes on all nodes and entries as necessary, and growing the tree by\ncreating a new root if necessary. This strategy is executed after inserting or deleting an\nentry.\n<ul>\n<li>Signature: <code>(tree: RTreeBase[T], node: RTreeNode[T], split_node: RTreeNode[T]) \u2192 None</code></li>\n<li>Arguments:\n<ul>\n<li><code>tree: RTreeBase[T]</code>: R-tree instance.</li>\n<li><code>node: RTreeNode[T]</code>: Node where a newly-inserted entry has just been added.</li>\n<li><code>split_node: RTreeNode[T]</code>: If the insertion of a new entry has caused the node to\nsplit, this is the newly-created split node. Otherwise, this will be <code>None</code>.</li>\n</ul>\n</li>\n<li>Returns: <code>None</code></li>\n</ul>\n</li>\n<li><strong><code>overflow_strategy</code></strong>: Strategy used for handling an overflowing node (a node that\ncontains more than <code>max_entries</code>). Depending on the implementation, this may involve\nsplitting the node and potentially growing the tree (Guttman), performing a forced\nreinsert of entries (R*), or some other strategy.\n<ul>\n<li>Signature: <code>(tree: RTreeBase[T], node: RTreeNode[T]) \u2192 RTreeNode[T]</code></li>\n<li>Arguments:\n<ul>\n<li><code>tree: RTreeBase[T]</code>: R-tree instance.</li>\n<li><code>node: RTreeNode[T]</code>: Overflowing node.</li>\n</ul>\n</li>\n<li>Returns: <code>RTreeNode[T]</code>\n<ul>\n<li>Depending on the implementation, this function may return a newly-created split\nnode whose entries are a subset of the original node's entries (Guttman), or simply\nreturn <code>None</code>.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2>Creating R-tree Diagrams</h2>\n<p>This library provides a set of utility functions that can be used to create diagrams of the\nentire R-tree structure, including the root and all intermediate and leaf level nodes and\nentries.</p>\n<p>These features are optional, and the required dependencies are <em>not</em> automatically installed\nwhen installing this library. Therefore, you must install them manually. This includes the\nfollowing Python dependencies which can be installed using pip:</p>\n<pre><code>pip install matplotlib pydot tqdm\n</code></pre>\n<p>This also includes the following system-level dependencies:</p>\n<ul>\n<li>TkInter</li>\n<li>Graphviz</li>\n</ul>\n<p>On Ubuntu, these can be installed using:</p>\n<pre><code>sudo apt install python3-tk graphviz\n</code></pre>\n<p>Once the above dependencies are installed, you can create an R-tree diagram as follows:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">rtreelib</span> <span class=\"kn\">import</span> <span class=\"n\">RTree</span><span class=\"p\">,</span> <span class=\"n\">Rect</span>\n<span class=\"kn\">from</span> <span class=\"nn\">rtreelib.diagram</span> <span class=\"kn\">import</span> <span class=\"n\">create_rtree_diagram</span>\n\n\n<span class=\"c1\"># Create an RTree instance with some sample data</span>\n<span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">RTree</span><span class=\"p\">(</span><span class=\"n\">max_entries</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'c'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'d'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'e'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Create a diagram of the R-tree structure</span>\n<span class=\"n\">create_rtree_diagram</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span>\n</pre>\n<p>This creates a diagram like the following:</p>\n<p><img alt=\"R-tree Diagram\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/18cf12456396b3674105446d62f2cdade2446869/68747470733a2f2f6769746875622e636f6d2f736572676b722f72747265656c69622f626c6f622f6d61737465722f646f632f72747265655f6469616772616d2e706e67\"></p>\n<p>The diagram is created in a temp directory as a PNG file, and the default viewer\nis automatically launched for convenience. Each box in the main diagram represents a node\n(except at the leaf level, where it represents the leaf entry), and contains a plot that\ndepicts all of the data spatially. The bounding boxes of each node are represented using\ntan rectangles with a dashed outline. The bounding box corresponding to the current node\nis highlighted in pink.</p>\n<p>The bounding boxes for the original data entries themselves are depicted in blue, and are\nlabeled using the value that was passed in to <code>insert</code>. At the leaf level, the corresponding\ndata element is highlighted in pink.</p>\n<p>The entries contained in each node are depicted along the bottom of the node's box, and\npoint to either a child node (for non-leaf nodes), or to the data entries (for leaf nodes).</p>\n<p>As can be seen in the above screenshot, the diagram depicts the entire tree structure, which\ncan be quite large depending on the number of nodes and entries. It may also take a while to\ngenerate, since it launches matplotlib to plot the data spatially for each node and entry, and\nthen graphviz to generate the overall diagram. Given the size and execution time required to\ngenerate these diagrams, it's only practical for R-trees containing a relatively small\namount of data (e.g., no more than about a dozen total entries). To analyze the resulting\nR-tree structure when working with a large amount of data, it is recommended to export the\ndata to PostGIS and use a viewer like QGIS (as explained in the following section).</p>\n<h2>Exporting to PostGIS</h2>\n<p>In addition to creating diagrams, this library also allows exporting R-trees to a\nPostGIS database.</p>\n<p>To do so, you will first need to install the <a href=\"http://initd.org/psycopg/\" rel=\"nofollow\">psycopg2</a> driver.\nThis is an optional dependency, so it is not automatically installed when you install\nthis package. Refer to the\n<a href=\"http://initd.org/psycopg/docs/install.html\" rel=\"nofollow\">installation instructions for psycopg2</a> to\nensure that you have all the necessary system-wide prerequisites installed (C compiler,\nPython header files, etc.). Then, install <code>psycopg2</code> using the following command (passing\nthe <code>--no-binary</code> flag to ensure that it is built from source, and also to avoid a console\nwarning when using <code>psycopg2</code>):</p>\n<pre><code>pip install psycopg2 --no-binary psycopg2\n</code></pre>\n<p>Once <code>psycopg2</code> is installed, you should be able to import the functions you need from the\n<code>rtreelib.pg</code> module:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">rtreelib.pg</span> <span class=\"kn\">import</span> <span class=\"n\">init_db_pool</span><span class=\"p\">,</span> <span class=\"n\">create_rtree_tables</span><span class=\"p\">,</span> <span class=\"n\">export_to_postgis</span>\n</pre>\n<p>The subsections below guide you throw how to use this library to export R-trees to the\ndatabase. You will first need to decide on your preferred method for connecting to the\ndatabase, as well as create the necessary tables to store the R-tree data. Once these\nprerequisites are met, exporting the R-tree can be done using a simple function call.\nFinally, this guide shows how you can visualize the exported data using QGIS, a popular\nand freely-available GIS viewer.</p>\n<h3>Initializing a Connection Pool</h3>\n<p>When working with the <code>rtreelib.pg</code> module, there are three ways of passing database\nconnection information:</p>\n<ol>\n<li>Initialize a connection pool by calling <code>init_db_pool</code>. This allows using the other\nfunctions in this module without having to pass around connection info.</li>\n<li>Manually open the connection yourself, and pass in the connection object to the\nfunction.</li>\n<li>Pass in keyword arguments that can be used to establish the database connection.</li>\n</ol>\n<p>The first method is generally the easiest - you just have to call it once, and not\nhave to worry about passing in connection information to the other functions. This\nsection explains this method, and the following sections assume that you are using\nit. However, the other methods are also explained later on in this guide.</p>\n<p><code>init_db_pool</code> accepts the same parameters as the\n<a href=\"http://initd.org/psycopg/docs/module.html#psycopg2.connect\" rel=\"nofollow\">psycopg2.connect</a> function.\nFor example, you can pass in a connection string:</p>\n<pre><span class=\"n\">init_db_pool</span><span class=\"p\">(</span><span class=\"s2\">\"dbname=mydb user=postgres password=temp123!\"</span><span class=\"p\">)</span>\n</pre>\n<p>Alternatively, using the URL syntax:</p>\n<pre><span class=\"n\">init_db_pool</span><span class=\"p\">(</span><span class=\"s2\">\"postgresql://localhost/mydb?user=postgres&amp;password=temp123!\"</span><span class=\"p\">)</span>\n</pre>\n<p>Or keyword arguments:</p>\n<pre><span class=\"n\">init_db_pool</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"o\">=</span><span class=\"s2\">\"postgres\"</span><span class=\"p\">,</span> <span class=\"n\">password</span><span class=\"o\">=</span><span class=\"s2\">\"temp123!\"</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"o\">=</span><span class=\"s2\">\"localhost\"</span><span class=\"p\">,</span> <span class=\"n\">database</span><span class=\"o\">=</span><span class=\"s2\">\"mydb\"</span><span class=\"p\">)</span>\n</pre>\n<p>Next, before you can export an R-tree, you first need to create a few database\ntables to store the data. The following section explains how to achieve this.</p>\n<h3>Creating Tables to Store R-tree Data</h3>\n<p>When exporting an R-tree using this library, the data is populated inside three\ntables:</p>\n<ul>\n<li><code>rtree</code>: This tables simply contains the ID of each R-tree that was exported.\nThis library allows you to export multiple R-trees at once, and they are\ndifferentiated by ID (you can also clear the contents of all tables using\n<code>clear_rtree_tables</code>).</li>\n<li><code>rtree_node</code>: Contains information about each node in the R-tree, including\nits bounding box (as a PostGIS geometry column), a pointer to the parent entry\ncontaining this node, and the level of this node (starting at 0 for the root).\nThe node also contains a reference to the <code>rtree</code> that it is a part of.</li>\n<li><code>rtree_entry</code>: Contains information about each entry in the R-tree, including\nits bounding box (as a PostGIS geometry column) and a pointer to the node\ncontaining this entry. For leaf entries, this also contains the value of the\ndata element.</li>\n</ul>\n<p>These tables can be created using the <code>create_rtree_tables</code> function. This is\nsomething you only need to do once.</p>\n<p>This function can be called without any arguments if you have established the\nconnection pool, and your data does not use a spatial reference system (<code>srid</code>).\nHowever, generally when working with spatial data, you will have a particular\nSRID that your data is in, in which case you should pass it in to ensure that\nall geometry columns use the correct SRID:</p>\n<pre><span class=\"n\">create_rtree_tables</span><span class=\"p\">(</span><span class=\"n\">srid</span><span class=\"o\">=</span><span class=\"mi\">4326</span><span class=\"p\">)</span>\n</pre>\n<p>You can also choose to create the tables in a different schema (other than <code>public</code>):</p>\n<pre><span class=\"n\">create_rtree_tables</span><span class=\"p\">(</span><span class=\"n\">srid</span><span class=\"o\">=</span><span class=\"mi\">4326</span><span class=\"p\">,</span> <span class=\"n\">schema</span><span class=\"o\">=</span><span class=\"s2\">\"temp\"</span><span class=\"p\">)</span>\n</pre>\n<p>However, in this case, be sure to pass in the same schema to the other functions in\nthis module.</p>\n<p>You can also pass in a <code>datatype</code>, which indicates the type of data stored in the leaf\nentries (i.e., the type of the data you pass in to the <code>insert</code> method of <code>RTree</code>).\nThis can either be a string containing a PostgreSQL column type:</p>\n<pre><span class=\"n\">create_rtree_tables</span><span class=\"p\">(</span><span class=\"n\">srid</span><span class=\"o\">=</span><span class=\"mi\">4326</span><span class=\"p\">,</span> <span class=\"n\">datatype</span><span class=\"o\">=</span><span class=\"s1\">'VARCHAR(255)'</span><span class=\"p\">)</span>\n</pre>\n<p>Or a Python type, in which case an appropriate PostgreSQL data type will be inferred:</p>\n<pre><span class=\"n\">create_rtree_tables</span><span class=\"p\">(</span><span class=\"n\">srid</span><span class=\"o\">=</span><span class=\"mi\">4326</span><span class=\"p\">,</span> <span class=\"n\">datatype</span><span class=\"o\">=</span><span class=\"nb\">int</span><span class=\"p\">)</span>\n</pre>\n<p>If you don't pass anything in, or an appropriate PostgreSQL data type cannot be\ndetermined from the Python type, the column type will default to <code>TEXT</code>, which allows\nstoring arbitrary-length strings.</p>\n<p>When passing a string containing a PostgreSQL column type, you also have the option\nof adding a modifier such as <code>NOT NULL</code>, or even a foreign key constraint:</p>\n<pre><span class=\"n\">create_rtree_tables</span><span class=\"p\">(</span><span class=\"n\">srid</span><span class=\"o\">=</span><span class=\"mi\">4326</span><span class=\"p\">,</span> <span class=\"n\">datatype</span><span class=\"o\">=</span><span class=\"s1\">'INT REFERENCES my_other_table (my_id_column)'</span><span class=\"p\">)</span>\n</pre>\n<h3>Exporting the R-tree</h3>\n<p>To export the R-tree once the tables have been created, simply call the\n<code>export_to_postgis</code> function, passing in the R-tree instance (and optionally an SRID):</p>\n<pre><span class=\"n\">rtree_id</span> <span class=\"o\">=</span> <span class=\"n\">export_to_postgis</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"n\">srid</span><span class=\"o\">=</span><span class=\"mi\">4326</span><span class=\"p\">)</span>\n</pre>\n<p>This function populates the <code>rtree</code>, <code>rtree_node</code>, and <code>rtree_entry</code> tables with\nthe data from the R-tree, and returns the ID of the newly-inserted R-tree in the\n<code>rtree</code> table.</p>\n<p>Note that if you used a schema other than <code>public</code> when calling\n<code>create_rtree_tables</code>, you will need to pass in the same schema when calling\n<code>export_to_postgis</code>:</p>\n<pre><span class=\"n\">rtree_id</span> <span class=\"o\">=</span> <span class=\"n\">export_to_postgis</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"n\">srid</span><span class=\"o\">=</span><span class=\"mi\">4326</span><span class=\"p\">,</span> <span class=\"n\">schema</span><span class=\"o\">=</span><span class=\"s1\">'temp'</span><span class=\"p\">)</span>\n</pre>\n<h3>Viewing the Data Using QGIS</h3>\n<p><a href=\"https://qgis.org/en/site/\" rel=\"nofollow\">QGIS</a> is a popular and freely-available GIS viewer which\ncan be used to visualize the exported R-tree data. To do so, launch QGIS and create\na new project. Then, follow these steps to add the exported R-tree data as a layer:</p>\n<ul>\n<li>Go to Layer \u2192 Add Layer \u2192 Add PostGIS Layers</li>\n<li>Connect to the database where you exported the data</li>\n<li>Select either the <code>rtree_node</code> or <code>rtree_entry</code> table, depending on which part of\nthe structure you wish to visualize. For this example, we will be looking at the\nnodes, so select <code>rtree_node</code>.</li>\n<li>Optionally, you can set a layer filter to only include the nodes belonging to a\nparticular tree (if you exported multiple R-trees). To do so, click the\n<strong>Set Filter</strong> button, and enter a filter expression (such as <code>rtree_id=1</code>).</li>\n<li>Click <strong>Add</strong></li>\n</ul>\n<p>At this point, the layer will be displaying all nodes at every level of the tree,\nwhich may be a bit hard to decipher if you have a lot of data. After adjusting the\nlayer style to make it partially transparent, here is an example of what an R-tree\nwith a couple hundred leaf entries might look like (41 nodes across 3 levels):</p>\n<p><img alt=\"QGIS - All Nodes\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c625c519e1bee7cd6c0f86ef564e894ea349de5c/68747470733a2f2f6769746875622e636f6d2f736572676b722f72747265656c69622f626c6f622f6d61737465722f646f632f716769735f616c6c5f6e6f6465732e706e67\"></p>\n<p>To make it easier to understand the structure, it might help to be able to view each\nlevel of the tree independently. To do this, double click the layer in the Layers\npanel, switch to the Style tab, and change the style type at the top from\n\"Single symbol\" (the default) to \"Categorized\". Then in the Column dropdown, select\nthe \"level\" column. You can optionally assign a color ramp or use random colors so\nthat each level gets a different color. Then click <strong>Classify</strong> to automatically\ncreate a separate style for each layer:</p>\n<p><img alt=\"QGIS - Layer Style\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/70fbb14aa3fb782362a2e3b94c7cf869449e1417/68747470733a2f2f6769746875622e636f6d2f736572676b722f72747265656c69622f626c6f622f6d61737465722f646f632f716769735f6c617965725f7374796c652e706e67\"></p>\n<p>Now in the layers panel, each level will be shown as a separate entry and can be\ntoggled on and off, making it possible to explore the R-tree structure one level\nat a time:</p>\n<p><img alt=\"QGIS - Layers Panel\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1262552a33033fd191eb5104fc106f2dfb365cd8/68747470733a2f2f6769746875622e636f6d2f736572676b722f72747265656c69622f626c6f622f6d61737465722f646f632f716769735f6c61796572735f70616e656c2e706e67\"></p>\n<p>The advantage with exporting the data to QGIS is you can also bring in your\noriginal dataset as a layer to see how it was partitioned spatially. Further,\nyou can import multiple R-trees as separate layers and be able to compare them\nside by side.</p>\n<p>Below, I am using a subset of the FAA airspace data for a portion of the\nNortheastern US, and then toggling each level of the <code>rtree_node</code> layer individually\nso we can examine the resulting R-tree structure one level at a time. After\ncompositing these together, you can see how the Guttman R-Tree performs against\nR*.</p>\n<p><strong>Guttman</strong>:</p>\n<p><img alt=\"Guttman R-Tree\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3be4ad679f69c30de749592598bc65868826122a/68747470733a2f2f6769746875622e636f6d2f736572676b722f72747265656c69622f626c6f622f6d61737465722f646f632f716769735f677574746d616e2e676966\"></p>\n<p><strong>R*-Tree</strong>:</p>\n<p><img alt=\"R*-Tree\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/504e9357315639c1d1fbc45289d820b1befa5546/68747470733a2f2f6769746875622e636f6d2f736572676b722f72747265656c69622f626c6f622f6d61737465722f646f632f716769735f72737461722e676966\"></p>\n<p>It is evident that R* has resulted in more square-like bounding rectangles with\nless overlap at the intermediate levels, compared to Guttman. The areas of overlap\nare made especially evident when using a partially transparent fill. Ideally, the\nspatial partitioning scheme should aim to minimize this overlap, since a query to\nfind the leaf entry for a given point would require visiting multiple subtrees if\nthat point happens to land in one of these darker shaded areas of overlap.</p>\n<p>You can also write a query to analyze the amount of overlap that resulted in each\nlevel of the tree. For example, the query below returns the total amount of overlap\narea of all nodes at level 2 of an exported R-tree having ID 1:</p>\n<pre><span class=\"k\">SELECT</span> <span class=\"n\">ST_Area</span><span class=\"p\">(</span><span class=\"n\">ST_Union</span><span class=\"p\">(</span><span class=\"n\">ST_Intersection</span><span class=\"p\">(</span><span class=\"n\">n1</span><span class=\"mf\">.</span><span class=\"n\">bbox</span><span class=\"p\">,</span> <span class=\"n\">n2</span><span class=\"mf\">.</span><span class=\"n\">bbox</span><span class=\"p\">)))</span> <span class=\"k\">AS</span> <span class=\"n\">OverlapArea</span>\n<span class=\"k\">FROM</span> <span class=\"k\">temp</span><span class=\"mf\">.</span><span class=\"n\">rtree</span> <span class=\"n\">t</span>\n  <span class=\"k\">INNER</span> <span class=\"k\">JOIN</span> <span class=\"k\">temp</span><span class=\"mf\">.</span><span class=\"n\">rtree_node</span> <span class=\"n\">n1</span> <span class=\"k\">ON</span> <span class=\"n\">n1</span><span class=\"mf\">.</span><span class=\"n\">rtree_id</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"mf\">.</span><span class=\"n\">id</span>\n  <span class=\"k\">INNER</span> <span class=\"k\">JOIN</span> <span class=\"k\">temp</span><span class=\"mf\">.</span><span class=\"n\">rtree_node</span> <span class=\"n\">n2</span> <span class=\"k\">ON</span> <span class=\"n\">n2</span><span class=\"mf\">.</span><span class=\"n\">rtree_id</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"mf\">.</span><span class=\"n\">id</span> <span class=\"k\">AND</span> <span class=\"n\">n1</span><span class=\"mf\">.</span><span class=\"k\">level</span> <span class=\"o\">=</span> <span class=\"n\">n2</span><span class=\"mf\">.</span><span class=\"k\">level</span>\n<span class=\"k\">WHERE</span>\n  <span class=\"n\">t</span><span class=\"mf\">.</span><span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"mf\">1</span>\n  <span class=\"k\">AND</span> <span class=\"n\">n1</span><span class=\"mf\">.</span><span class=\"k\">level</span> <span class=\"o\">=</span> <span class=\"mf\">2</span>\n  <span class=\"k\">AND</span> <span class=\"n\">ST_Overlaps</span><span class=\"p\">(</span><span class=\"n\">n1</span><span class=\"mf\">.</span><span class=\"n\">bbox</span><span class=\"p\">,</span> <span class=\"n\">n2</span><span class=\"mf\">.</span><span class=\"n\">bbox</span><span class=\"p\">)</span>\n  <span class=\"k\">AND</span> <span class=\"n\">n1</span><span class=\"mf\">.</span><span class=\"n\">id</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">n2</span><span class=\"mf\">.</span><span class=\"n\">id</span><span class=\"p\">;</span>\n</pre>\n<p>Extending this even further, you can compare the total overlap area of multiple exported\nR-trees by level:</p>\n<pre><span class=\"k\">SELECT</span>\n  <span class=\"k\">CASE</span> <span class=\"n\">t</span><span class=\"mf\">.</span><span class=\"n\">id</span>\n    <span class=\"k\">WHEN</span> <span class=\"mf\">1</span> <span class=\"k\">THEN</span> <span class=\"s1\">'Guttman'</span>\n    <span class=\"k\">WHEN</span> <span class=\"mf\">2</span> <span class=\"k\">THEN</span> <span class=\"s1\">'R*'</span>\n  <span class=\"k\">END</span> <span class=\"k\">AS</span> <span class=\"n\">tree</span><span class=\"p\">,</span>\n  <span class=\"n\">n</span><span class=\"mf\">.</span><span class=\"k\">level</span><span class=\"p\">,</span>\n  <span class=\"n\">ST_Area</span><span class=\"p\">(</span><span class=\"n\">ST_Union</span><span class=\"p\">(</span><span class=\"n\">ST_Intersection</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"mf\">.</span><span class=\"n\">bbox</span><span class=\"p\">,</span> <span class=\"n\">n2</span><span class=\"mf\">.</span><span class=\"n\">bbox</span><span class=\"p\">)))</span> <span class=\"k\">AS</span> <span class=\"n\">OverlapArea</span>\n<span class=\"k\">FROM</span> <span class=\"k\">temp</span><span class=\"mf\">.</span><span class=\"n\">rtree</span> <span class=\"n\">t</span>\n  <span class=\"k\">INNER</span> <span class=\"k\">JOIN</span> <span class=\"k\">temp</span><span class=\"mf\">.</span><span class=\"n\">rtree_node</span> <span class=\"n\">n</span> <span class=\"k\">ON</span> <span class=\"n\">n</span><span class=\"mf\">.</span><span class=\"n\">rtree_id</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"mf\">.</span><span class=\"n\">id</span>\n  <span class=\"k\">INNER</span> <span class=\"k\">JOIN</span> <span class=\"k\">temp</span><span class=\"mf\">.</span><span class=\"n\">rtree_node</span> <span class=\"n\">n2</span> <span class=\"k\">ON</span> <span class=\"n\">n2</span><span class=\"mf\">.</span><span class=\"n\">rtree_id</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"mf\">.</span><span class=\"n\">id</span> <span class=\"k\">AND</span> <span class=\"n\">n</span><span class=\"mf\">.</span><span class=\"k\">level</span> <span class=\"o\">=</span> <span class=\"n\">n2</span><span class=\"mf\">.</span><span class=\"k\">level</span>\n<span class=\"k\">WHERE</span>\n  <span class=\"n\">ST_Overlaps</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"mf\">.</span><span class=\"n\">bbox</span><span class=\"p\">,</span> <span class=\"n\">n2</span><span class=\"mf\">.</span><span class=\"n\">bbox</span><span class=\"p\">)</span>\n  <span class=\"k\">AND</span> <span class=\"n\">n</span><span class=\"mf\">.</span><span class=\"n\">id</span> <span class=\"o\">&lt;&gt;</span> <span class=\"n\">n2</span><span class=\"mf\">.</span><span class=\"n\">id</span>\n<span class=\"k\">GROUP</span> <span class=\"k\">BY</span>\n  <span class=\"n\">t</span><span class=\"mf\">.</span><span class=\"n\">id</span><span class=\"p\">,</span>\n  <span class=\"n\">n</span><span class=\"mf\">.</span><span class=\"k\">level</span>\n<span class=\"k\">ORDER</span> <span class=\"k\">BY</span>\n  <span class=\"n\">t</span><span class=\"mf\">.</span><span class=\"n\">id</span><span class=\"p\">,</span>\n  <span class=\"n\">n</span><span class=\"mf\">.</span><span class=\"k\">level</span><span class=\"p\">;</span>\n</pre>\n<p>The above query may return a result like the following:</p>\n<table>\n<thead>\n<tr>\n<th>tree</th>\n<th>level</th>\n<th>OverlapArea</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Guttman</td>\n<td>1</td>\n<td>7.89e+11</td>\n</tr>\n<tr>\n<td>Guttman</td>\n<td>2</td>\n<td>9.12e+11</td>\n</tr>\n<tr>\n<td>Guttman</td>\n<td>3</td>\n<td>4.75e+11</td>\n</tr>\n<tr>\n<td>R*</td>\n<td>1</td>\n<td>3.97e+11</td>\n</tr>\n<tr>\n<td>R*</td>\n<td>2</td>\n<td>4.35e+11</td>\n</tr>\n<tr>\n<td>R*</td>\n<td>3</td>\n<td>1.80e+11</td>\n</tr></tbody></table>\n<p>In the above example, the R*-Tree (<code>id</code>=2) achieved a smaller overlap area at\nevery level of the tree compared to Guttman (<code>id</code>=1).</p>\n<h3>Cleaning Up</h3>\n<p>As mentioned above, when you call <code>export_to_postgis</code>, the existing data in the\ntables is <em>not</em> cleared. This allows you to export multiple R-trees at once and\ncompare them side-by-side.</p>\n<p>However, for simplicity, you may wish to clear out the existing data prior to\nexporting new data. To do so, call <code>clear_rtree_tables</code>:</p>\n<pre><span class=\"n\">clear_rtree_tables</span><span class=\"p\">()</span>\n</pre>\n<p>This will perform a SQL <code>TRUNCATE</code> on all R-tree tables.</p>\n<p>Note that if you created the tables in a different schema (other than <code>public</code>),\nyou will need to pass in that same schema to this function:</p>\n<pre><span class=\"n\">clear_rtree_tables</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"o\">=</span><span class=\"s1\">'temp'</span><span class=\"p\">)</span>\n</pre>\n<p>You may also wish to completely drop all the tables that were created by\n<code>create_rtree_tables</code>. To do so, call <code>drop_rtree_tables</code>:</p>\n<pre><span class=\"n\">drop_rtree_tables</span><span class=\"p\">()</span>\n</pre>\n<p>Again, you may need to pass in a schema if it is something other than <code>public</code>:</p>\n<pre><span class=\"n\">drop_rtree_tables</span><span class=\"p\">(</span><span class=\"n\">schema</span><span class=\"o\">=</span><span class=\"s1\">'temp'</span><span class=\"p\">)</span>\n</pre>\n<h3>Alternate Database Connection Handling Methods</h3>\n<p>As mentioned earlier in this guide, instead of initializing a connection pool,\nyou have other options for how to handle establishing database connections when\nusing this library. You can choose to handle opening and closing the connection\nyourself and pass in the connection object; alternatively, you can pass in the\nconnection information as keyword arguments.</p>\n<p>To establish the database connection yourself, the typical usage scenario might\nlook like this:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">psycopg2</span>\n<span class=\"kn\">from</span> <span class=\"nn\">rtreelib</span> <span class=\"kn\">import</span> <span class=\"n\">RTree</span><span class=\"p\">,</span> <span class=\"n\">Rect</span>\n<span class=\"kn\">from</span> <span class=\"nn\">rtreelib.pg</span> <span class=\"kn\">import</span> <span class=\"n\">init_db_pool</span><span class=\"p\">,</span> <span class=\"n\">create_rtree_tables</span><span class=\"p\">,</span> <span class=\"n\">clear_rtree_tables</span><span class=\"p\">,</span> <span class=\"n\">export_to_postgis</span><span class=\"p\">,</span> <span class=\"n\">drop_rtree_tables</span>\n\n\n<span class=\"c1\"># Create an RTree instance with some sample data</span>\n<span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">RTree</span><span class=\"p\">(</span><span class=\"n\">max_entries</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'a'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'b'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'c'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'d'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">))</span>\n<span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"s1\">'e'</span><span class=\"p\">,</span> <span class=\"n\">Rect</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Export R-tree to PostGIS (using explicit connection)</span>\n<span class=\"n\">conn</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"n\">conn</span> <span class=\"o\">=</span> <span class=\"n\">psycopg2</span><span class=\"o\">.</span><span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"o\">=</span><span class=\"s2\">\"postgres\"</span><span class=\"p\">,</span> <span class=\"n\">password</span><span class=\"o\">=</span><span class=\"s2\">\"temp123!\"</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"o\">=</span><span class=\"s2\">\"localhost\"</span><span class=\"p\">,</span> <span class=\"n\">database</span><span class=\"o\">=</span><span class=\"s2\">\"mydb\"</span><span class=\"p\">)</span>\n    <span class=\"n\">create_rtree_tables</span><span class=\"p\">(</span><span class=\"n\">conn</span><span class=\"p\">,</span> <span class=\"n\">schema</span><span class=\"o\">=</span><span class=\"s1\">'temp'</span><span class=\"p\">)</span>\n    <span class=\"n\">rtree_id</span> <span class=\"o\">=</span> <span class=\"n\">export_to_postgis</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">conn</span><span class=\"o\">=</span><span class=\"n\">conn</span><span class=\"p\">,</span> <span class=\"n\">schema</span><span class=\"o\">=</span><span class=\"s1\">'temp'</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">rtree_id</span><span class=\"p\">)</span>\n<span class=\"k\">finally</span><span class=\"p\">:</span>\n    <span class=\"k\">if</span> <span class=\"n\">conn</span><span class=\"p\">:</span>\n        <span class=\"n\">conn</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n</pre>\n<p>You can also pass in the database connection information separately to each method as\nkeyword arguments. These keyword arguments should be the same ones as required by the\n<a href=\"http://initd.org/psycopg/docs/module.html#psycopg2.connect\" rel=\"nofollow\">psycopg2.connect</a> function:</p>\n<pre><span class=\"n\">rtree_id</span> <span class=\"o\">=</span> <span class=\"n\">export_to_postgis</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"n\">schema</span><span class=\"o\">=</span><span class=\"s1\">'temp'</span><span class=\"p\">,</span> <span class=\"n\">user</span><span class=\"o\">=</span><span class=\"s2\">\"postgres\"</span><span class=\"p\">,</span> <span class=\"n\">password</span><span class=\"o\">=</span><span class=\"s2\">\"temp123!\"</span><span class=\"p\">,</span> <span class=\"n\">host</span><span class=\"o\">=</span><span class=\"s2\">\"localhost\"</span><span class=\"p\">,</span> <span class=\"n\">database</span><span class=\"o\">=</span><span class=\"s2\">\"mydb\"</span><span class=\"p\">)</span>\n</pre>\n<h2>References</h2>\n<p>[1]: Nanopoulos, Alexandros &amp; Papadopoulos, Apostolos (2003):\n<a href=\"https://pdfs.semanticscholar.org/4e07/e800fe71505fbad686b08334abb49d41fcda.pdf\" rel=\"nofollow\">\"R-Trees Have Grown Everywhere\"</a></p>\n<p>[2]:  Guttman, A. (1984):\n<a href=\"http://www-db.deis.unibo.it/courses/SI-LS/papers/Gut84.pdf\" rel=\"nofollow\">\"R-trees: a Dynamic Index Structure for Spatial Searching\"</a>\n(PDF), <em>Proceedings of the 1984 ACM SIGMOD international conference on Management of data \u2013 SIGMOD\n'84.</em> p. 47.</p>\n<p>[3]: Beckmann, Norbert, et al.\n<a href=\"https://infolab.usc.edu/csci599/Fall2001/paper/rstar-tree.pdf\" rel=\"nofollow\">\"The R*-tree: an efficient and robust access method for points and rectangles.\"</a>\n<em>Proceedings of the 1990 ACM SIGMOD international conference on Management of data.</em> 1990.</p>\n\n          </div>"}, "last_serial": 7154445, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "85fd3fa8f756670e7fc44934b1867d14", "sha256": "2c4645e449bd006143719e77dd8b35138d2fc9b9d222e60acde00bc591f97821"}, "downloads": -1, "filename": "rtreelib-0.0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "85fd3fa8f756670e7fc44934b1867d14", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 15278, "upload_time": "2019-04-14T00:51:32", "upload_time_iso_8601": "2019-04-14T00:51:32.037998Z", "url": "https://files.pythonhosted.org/packages/42/5c/01be84e62b4e3e332a0eec9bc67f2b864c8203a6f39325a7562874e52399/rtreelib-0.0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ebd3bf3922455ecf889b7c14ee96b971", "sha256": "6faf751c8dd9fae381bb0a05e525a28a05f38625fb784ee7d430c61a89092ef6"}, "downloads": -1, "filename": "rtreelib-0.0.1.tar.gz", "has_sig": false, "md5_digest": "ebd3bf3922455ecf889b7c14ee96b971", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 17968, "upload_time": "2019-04-14T00:51:34", "upload_time_iso_8601": "2019-04-14T00:51:34.093193Z", "url": "https://files.pythonhosted.org/packages/d4/0e/8cce4c74b0c15a5872c3ebe14324971bff400c3ae9095e87f0505e51956f/rtreelib-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "10db880fa7b998b9be654fa757b9afdc", "sha256": "18ef3ac7ef01eb4d6e8263483a536192f8dbeed5344ce8758c6d3d1e09697c14"}, "downloads": -1, "filename": "rtreelib-0.0.2-py3-none-any.whl", "has_sig": false, "md5_digest": "10db880fa7b998b9be654fa757b9afdc", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 27378, "upload_time": "2019-04-15T03:30:13", "upload_time_iso_8601": "2019-04-15T03:30:13.762911Z", "url": "https://files.pythonhosted.org/packages/5f/01/bed0bfdde7a10172c72965ba80772076d4794cdece43cbe7ea2dad60698d/rtreelib-0.0.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "95138b4caab429a8dc40abb1be9a6f9f", "sha256": "07aab5614fa0e7adb3e90a0f98c36633ace733f5d63081ad2fb905bcd247ee1b"}, "downloads": -1, "filename": "rtreelib-0.0.2.tar.gz", "has_sig": false, "md5_digest": "95138b4caab429a8dc40abb1be9a6f9f", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 29715, "upload_time": "2019-04-15T03:30:15", "upload_time_iso_8601": "2019-04-15T03:30:15.050276Z", "url": "https://files.pythonhosted.org/packages/2e/fe/16a34be140f53b1d5efd69456ec7c83af86d55e5ce5cfbdf6c39c49ed45e/rtreelib-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "085488f53d4af8b946ea979bed3294ce", "sha256": "f52ae895b2c7c6f3ba41ac59ac6b4d85c02cd3892cfad4eda49bf9fa41ae8799"}, "downloads": -1, "filename": "rtreelib-0.0.3-py3-none-any.whl", "has_sig": false, "md5_digest": "085488f53d4af8b946ea979bed3294ce", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 27589, "upload_time": "2020-03-02T02:22:31", "upload_time_iso_8601": "2020-03-02T02:22:31.745341Z", "url": "https://files.pythonhosted.org/packages/d6/c1/35728cceda225c8466f7b3775b0378f06194c299dbcc94558a1ba4ea1302/rtreelib-0.0.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1e7ca4246445b9eaad1a13b89af968ba", "sha256": "eedb3b4ece4d52212d648aa005184e07dfe544c0b7c101fd7d00ab60bed21b94"}, "downloads": -1, "filename": "rtreelib-0.0.3.tar.gz", "has_sig": false, "md5_digest": "1e7ca4246445b9eaad1a13b89af968ba", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 30211, "upload_time": "2020-03-02T02:22:33", "upload_time_iso_8601": "2020-03-02T02:22:33.095644Z", "url": "https://files.pythonhosted.org/packages/f0/bb/785b867666f4ecb7f12ec2f7a710a08ca46106ae5258f30013cf1e342676/rtreelib-0.0.3.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "078c1769d8d7e2b9c5ce2be7714cecb3", "sha256": "181fabc1bea69c1b963dbc48d493a6ed65c68c9952fb7ae039f6bac8b16dc960"}, "downloads": -1, "filename": "rtreelib-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "078c1769d8d7e2b9c5ce2be7714cecb3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 39709, "upload_time": "2020-03-18T01:40:58", "upload_time_iso_8601": "2020-03-18T01:40:58.853728Z", "url": "https://files.pythonhosted.org/packages/df/8a/5f7e3b6c72b7991d3dbea963a840d9f90203af29f8389fe7e438e5d892aa/rtreelib-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "474de723740d0503fc470e5fba1d2814", "sha256": "1d4ac31d844a3a1dc02d10f3eaef962e2d623a1fb2a4ec6d4df581cb8581a07e"}, "downloads": -1, "filename": "rtreelib-0.1.0.tar.gz", "has_sig": false, "md5_digest": "474de723740d0503fc470e5fba1d2814", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 39215, "upload_time": "2020-03-18T01:41:00", "upload_time_iso_8601": "2020-03-18T01:41:00.430359Z", "url": "https://files.pythonhosted.org/packages/51/ee/abb0cb93c314815505160bfc0866ea5f076af8c8384ed713a3df826b37cf/rtreelib-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "97c8adacc775e892e3c2b14be23f2f01", "sha256": "cedd4c9e4014f39b290f90f9a0a2bff10a852feb4cd9652ac1933f4f8a77cad3"}, "downloads": -1, "filename": "rtreelib-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "97c8adacc775e892e3c2b14be23f2f01", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 42467, "upload_time": "2020-05-03T02:08:26", "upload_time_iso_8601": "2020-05-03T02:08:26.285833Z", "url": "https://files.pythonhosted.org/packages/fc/b4/4494ed155b1027714c383a9ae7c952638abdc8e9264433de238139c77144/rtreelib-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d834634deadfb80040fb5398f7da96d1", "sha256": "f162d63ae5465d1f25d76ca55e2dc8524a4215c190f9442e18ce48d3d2b61a52"}, "downloads": -1, "filename": "rtreelib-0.2.0.tar.gz", "has_sig": false, "md5_digest": "d834634deadfb80040fb5398f7da96d1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 42902, "upload_time": "2020-05-03T02:08:27", "upload_time_iso_8601": "2020-05-03T02:08:27.439364Z", "url": "https://files.pythonhosted.org/packages/0d/38/24035d171c3eb441209f1dd126d27d812acfe0d755c4b14a9f104b6090db/rtreelib-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "97c8adacc775e892e3c2b14be23f2f01", "sha256": "cedd4c9e4014f39b290f90f9a0a2bff10a852feb4cd9652ac1933f4f8a77cad3"}, "downloads": -1, "filename": "rtreelib-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "97c8adacc775e892e3c2b14be23f2f01", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6.0", "size": 42467, "upload_time": "2020-05-03T02:08:26", "upload_time_iso_8601": "2020-05-03T02:08:26.285833Z", "url": "https://files.pythonhosted.org/packages/fc/b4/4494ed155b1027714c383a9ae7c952638abdc8e9264433de238139c77144/rtreelib-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d834634deadfb80040fb5398f7da96d1", "sha256": "f162d63ae5465d1f25d76ca55e2dc8524a4215c190f9442e18ce48d3d2b61a52"}, "downloads": -1, "filename": "rtreelib-0.2.0.tar.gz", "has_sig": false, "md5_digest": "d834634deadfb80040fb5398f7da96d1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6.0", "size": 42902, "upload_time": "2020-05-03T02:08:27", "upload_time_iso_8601": "2020-05-03T02:08:27.439364Z", "url": "https://files.pythonhosted.org/packages/0d/38/24035d171c3eb441209f1dd126d27d812acfe0d755c4b14a9f104b6090db/rtreelib-0.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:00:23 2020"}