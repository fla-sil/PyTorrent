{"info": {"author": "Marko Ristin", "author_email": "marko.ristin@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6"], "description": "pypackagery\n===========\n\n.. image:: https://api.travis-ci.com/Parquery/pypackagery.svg?branch=master\n    :target: https://api.travis-ci.com/Parquery/pypackagery.svg?branch=master\n    :alt: Build Status\n\n.. image:: https://coveralls.io/repos/github/Parquery/pypackagery/badge.svg?branch=master\n    :target: https://coveralls.io/github/Parquery/pypackagery?branch=master\n    :alt: Coverage\n\n.. image:: https://badge.fury.io/py/pypackagery.svg\n    :target: https://pypi.org/project/pypackagery/\n    :alt: PyPi\n\n.. image:: https://img.shields.io/pypi/pyversions/pypackagery.svg\n    :alt: PyPI - Python Version\n\n.. image:: https://readthedocs.org/projects/pypackagery/badge/?version=latest\n    :target: https://pypackagery.readthedocs.io/en/latest/?badge=latest\n    :alt: Documentation Status\n\nPypackagery packages a subset of a monorepo and determine the dependent packages.\n\nGiven a root directory of a Python code base, a list of Python files (from that code base) and a target directory,\npypackagery determines the dependent modules of the specified files. The scripts and the *local* dependencies are copied\nto the given target directory. The *external* dependencies (such as pypi packages) are not copied\n(and need not be installed), but the list containing a subset of external dependencies is generated instead.\n\nThe external dependencies of the monorepo need to be specified in\n``<root directory>/requirements.txt`` and ``<root directory>/module_to_requirement.tsv``.\n\nThe ``requirements.txt`` follows the Pip format\n(see `pip documentation <https://pip.pypa.io/en/stable/user_guide/#id1>`_). The file defines which external packages are\nneeded by the *whole* of the code base. Pypackagery will read this list and extract the subset needed by the specified\nPython files.\n\n``module_to_requirement.tsv`` defines the correspondence between Python modules and requirements as defined in\n``requirements.txt``. This correspondence needs to be manually defined since there is no way to automatically map\nPython modules to pip packages. The correspondance in ``module_to_requirement.tsv`` is given as\nlines of two tab-separated values. The first column is the full model name (such as ``PIL.Image``) and the second is\nthe name of the package in ``requirements.txt`` (such as ``pillow``). The version of the package should be omitted and\nshould be specified *only* in the ``requirements.txt``.\n\nPlease do not forget to add the ``#egg`` fragment to URLs and files in ``requirements.txt`` so that the name of the\npackage can be uniquely resolved when joining ``module_to_requirement.tsv`` and ``requirements.txt``.\n\nRelated Projects\n================\n\n* https://github.com/pantsbuild/pex -- a library tool for generating PEX (Python EXecutable) files. It packages all the\n  files in the virtual environment including all the requirements. This works for small code bases and light\n  requirements which are not frequently re-used among the components in the code base. However, when the requirements\n  are heavy (such as OpenCV or numpy) and frequently re-used in the code base, it is a waste of bandwidth and disk space\n  to package them repeatedly for each executable independently.\n\n* https://www.pantsbuild.org/, https://buckbuild.com/ and https://github.com/linkedin/pygradle are build systems that\n  can produce PEX files (with all the problems mentioned above). We considered using them and writing a plug-in to\n  achieve the same goal as pypackagery. Finally, we decided for a separate tool since these build systems are not\n  yet supported natively by IDEs (such as Pycharm) and actually break the expected Python development work flow.\n\n* https://blog.shazam.com/python-microlibs-5be9461ad979 presents a microlib approach where a monorepo is packaged in\n  separate pip packages. While we find the idea interesting, it adds an administration overhead since every library\n  needs to live in a separate package thus making bigger refactorings tedious and error-prone (*e.g.* are the\n  requirements updated correctly and are dependency conflicts reported early?). We found it easiest to have a global\n  list of the requirements (with modules mapped to requirements), so that a sole ``pip3 install -r requirements.txt``\n  would notify us of the conflicts.\n\n  If you wanted to work only on part of the code base, and do no want to install all the requirements, you can use\n  pypackagery to determine the required subset and install only those requirements that you need.\n\n  Since we deploy often on third-party sites, we also found it difficult to secure our deployments. Namely, packaging\n  the code base into microlibs practically implies that we need to give the remote machine access to our private pypi\n  repository. In case that we only want to deploy the subset of the code base, granting access to all packages would\n  unnecessarily open up a potential security hole. With pypackagery, we deploy only the files that are actually\n  used while the third-party dependencies are separately installed on the remote instance from a subset of requirements\n  ``subrequirements.txt`` with ``pip3 install -r subrequirements.txt``.\n\n\nUsage\n=====\nRequirement Specification\n-------------------------\nAs already mentioned, the requirements are expected to follow Pip format\n(see `pip documentation <https://pip.pypa.io/en/stable/user_guide/#id1>`_) and live in ``requirements.txt`` at the root\nof the code base. The mapping from modules to requirements is expected in ``module_to_requirement.tsv`` also at the root\nof the code base.\n\nAssume that the code base lives in ``~/workspace/some-project``.\n\nHere is an excerpt from ``~/workspace/some-project/requirements.txt``:\n\n.. code-block::\n\n    pillow==5.2.0\n    pytz==2018.5\n    pyzmq==17.1.2\n\nAnd here is an excerpt from ``~/workspace/some-project/module_to_requirement.tsv``\n(mind that it's tab separated):\n\n.. code-block::\n\n    PIL\tpillow\n    PIL.Image\tpillow\n    PIL.ImageFile\tpillow\n    PIL.ImageOps\tpillow\n    PIL.ImageStat\tpillow\n    PIL.ImageTk\tpillow\n    cv2\topencv-python\n\nDirectory\n---------\nAssume that the code base lives in ``~/workspace/some-project`` and we are interested to bundle everything\nin ``pipeline/out`` directory.\n\nTo determine the subset of the files and requirements, run the following command line:\n\n\n.. code-block:: bash\n\n    pypackagery \\\n        --root_dir ~/workspace/some-project \\\n        --initial_set ~/workspace/some-project/pipeline/out\n\nThis gives us a verbose, human-readable output like:\n\n.. code-block::\n\n    External dependencies:\n    Package name | Requirement spec\n    -------------+---------------------\n    pyzmq        | 'pyzmq==17.1.2'\n    temppathlib  | 'temppathlib==1.0.3'\n\n    Local dependencies:\n    pipeline/out/__init__.py\n    common/__init__.py\n    common/logging.py\n    common/proc.py\n\nIf we want to get the same output in JSON, we need to call:\n\n.. code-block:: bash\n\n    pypackagery \\\n        --root_dir ~/workspace/some-project \\\n        --initial_set ~/workspace/some-project/pipeline/out \\\n        --format json\n\nwhich gives us a JSON-encoded dependency graph:\n\n.. code-block:: json\n\n    {\n      \"requirements\": {\n        \"pyzmq\": {\n          \"name\": \"pyzmq\",\n          \"line\": \"pyzmq==17.1.2\\n\"\n        },\n        \"temppathlib\": {\n          \"name\": \"temppathlib\",\n          \"line\": \"temppathlib==1.0.3\\n\"\n        }\n      },\n      \"rel_paths\": [\n        \"pipeline/out/__init__.py\",\n        \"common/__init__.py\",\n        \"common/logging.py\",\n        \"common/proc.py\"\n      ],\n      \"unresolved_modules\": []\n    }\n\nFiles\n-----\nAssume again that the code base lives in ``~/workspace/some-project``. We would like to get a subset of the\ncode base required by a list of scripts. We need to specify the initial set as a list of files:\n\n.. code-block:: bash\n\n    pypackagery \\\n        --root_dir ~/workspace/some-project \\\n        --initial_set \\\n            ~/workspace/some-project/pipeline/input/receivery.py \\\n            ~/workspace/some-project/pipeline/input/snapshotry.py\n\nwhich gives us:\n\n.. code-block::\n\n    External dependencies:\n    Package name | Requirement spec\n    -------------+-------------------\n    icontract    | 'icontract==1.5.1'\n    pillow       | 'pillow==5.2.0'\n    protobuf     | 'protobuf==3.5.1'\n    pytz         | 'pytz==2018.5'\n    pyzmq        | 'pyzmq==17.1.2'\n    requests     | 'requests==2.19.1'\n\n    Local dependencies:\n    pipeline/__init__.py\n    pipeline/input/receivery.py\n    pipeline/input/snapshotry.py\n    common/__init__.py\n    common/img.py\n    common/logging.py\n    protoed/__init__.py\n    protoed/pipeline_pb2.py\n\nUnresolved Modules\n------------------\nIf there is a module which could not be resolved (neither in built-ins, nor specified in the requirements nor\nliving in the code base), the pypackagery will return a non-zero return code.\n\nIf you specify ``--dont_panic``, the return code will be 0 even if there are unresolved modules.\n\nModule ``packagery``\n--------------------\nPypackagery provides a module ``packagery`` which can be used to programmatically determine the dependencies of the\nsubset of the code base. For example, this is particularly useful for deployments to a remote machine where you\nwant to deploy only a part of the code base depending on some given configuration.\n\nHere is an example:\n\n.. code-block:: python\n\n    import pathlib\n\n    import packagery\n\n    root_dir = pathlib.Path('/some/codebase')\n\n    rel_pths = [\n        pathlib.Path(\"some/dir/file1.py\"),\n        pathlib.Path(\"some/other/dir/file2.py\")]\n\n    requirements_txt = root_dir / \"requirements.txt\"\n    module_to_requirement_tsv = root_dir / \"module_to_requirement.tsv\"\n\n    requirements = packagery.parse_requirements(\n        text=requirements_txt.read_text())\n\n    module_to_requirement = packagery.parse_module_to_requirement(\n        text=module_to_requirement_tsv.read_text(),\n        filename=module_to_requirement_tsv.as_posix())\n\n    pkg = packagery.collect_dependency_graph(\n        root_dir=root_dir,\n        rel_paths=rel_pths,\n        requirements=requirements,\n        module_to_requirement=module_to_requirement)\n\n    # do something with pkg ...\n\nMind that relative paths (given as ``rel_paths`` argument) all need to be files, not directories.\n\nDocumentation\n=============\nThe documentation is available on `readthedocs <https://pypackagery.readthedocs.io/en/latest/>`_.\n\nInstallation\n============\n\n* Create a virtual environment:\n\n.. code-block:: bash\n\n    python3 -m venv venv3\n\n* Activate it:\n\n.. code-block:: bash\n\n    source venv3/bin/activate\n\n* Install pypackagery with pip:\n\n.. code-block:: bash\n\n    pip3 install pypackagery\n\nDevelopment\n===========\n\n* Check out the repository.\n\n* In the repository root, create the virtual environment:\n\n.. code-block:: bash\n\n    python3 -m venv venv3\n\n* Activate the virtual environment:\n\n.. code-block:: bash\n\n    source venv3/bin/activate\n\n* Install the development dependencies:\n\n.. code-block:: bash\n\n    pip3 install -e .[dev]\n\nWe use tox for testing and packaging the distribution:\n\n.. code-block:: bash\n\n    tox\n\nPre-commit Checks\n-----------------\nWe provide a set of pre-commit checks that lint and check code for formatting.\n\nNamely, we use:\n\n* `yapf <https://github.com/google/yapf>`_ to check the formatting.\n* The style of the docstrings is checked with `pydocstyle <https://github.com/PyCQA/pydocstyle>`_.\n* Static type analysis is performed with `mypy <http://mypy-lang.org/>`_.\n* Various linter checks are done with `pylint <https://www.pylint.org/>`_.\n* Doctests are executed using the Python `doctest module <https://docs.python.org/3.5/library/doctest.html>`_.\n\nRun the pre-commit checks locally from an activated virtual environment with development dependencies:\n\n.. code-block:: bash\n\n    ./precommit.py\n\n* The pre-commit script can also automatically format the code:\n\n.. code-block:: bash\n\n    ./precommit.py  --overwrite\n\n\nVersioning\n==========\nWe follow `Semantic Versioning <http://semver.org/spec/v1.0.0.html>`_. The version X.Y.Z indicates:\n\n* X is the major version (backward-incompatible),\n* Y is the minor version (backward-compatible), and\n* Z is the patch version (backward-compatible bug fix).", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Parquery/pypackagery", "keywords": "package monorepo requirements", "license": "License :: OSI Approved :: MIT License", "maintainer": "", "maintainer_email": "", "name": "pypackagery", "package_url": "https://pypi.org/project/pypackagery/", "platform": "", "project_url": "https://pypi.org/project/pypackagery/", "project_urls": {"Homepage": "https://github.com/Parquery/pypackagery"}, "release_url": "https://pypi.org/project/pypackagery/1.0.4/", "requires_dist": null, "requires_python": "", "summary": "Package a subset of a monorepo and determine the dependent packages.", "version": "1.0.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"pypackagery\">\n<h2>pypackagery</h2>\n<a href=\"https://api.travis-ci.com/Parquery/pypackagery.svg?branch=master\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9ccc9d4e42f3953e52b84ff04f0fd89a0410887e/68747470733a2f2f6170692e7472617669732d63692e636f6d2f50617271756572792f70797061636b61676572792e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/Parquery/pypackagery?branch=master\" rel=\"nofollow\"><img alt=\"Coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/313f85ec1dc7193820236e2114ae4b017ebf56ff/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f50617271756572792f70797061636b61676572792f62616467652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://pypi.org/project/pypackagery/\" rel=\"nofollow\"><img alt=\"PyPi\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7e714819c13597448e372f258f5e6bf318b273e5/68747470733a2f2f62616467652e667572792e696f2f70792f70797061636b61676572792e737667\"></a>\n<img alt=\"PyPI - Python Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fc45fa9902d86798788ab137050e2a4f85250ad1/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f70797061636b61676572792e737667\">\n<a href=\"https://pypackagery.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4900ce71706d2e5ebeaf838a5527afbc692dc707/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f70797061636b61676572792f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<p>Pypackagery packages a subset of a monorepo and determine the dependent packages.</p>\n<p>Given a root directory of a Python code base, a list of Python files (from that code base) and a target directory,\npypackagery determines the dependent modules of the specified files. The scripts and the <em>local</em> dependencies are copied\nto the given target directory. The <em>external</em> dependencies (such as pypi packages) are not copied\n(and need not be installed), but the list containing a subset of external dependencies is generated instead.</p>\n<p>The external dependencies of the monorepo need to be specified in\n<tt>&lt;root <span class=\"pre\">directory&gt;/requirements.txt</span></tt> and <tt>&lt;root <span class=\"pre\">directory&gt;/module_to_requirement.tsv</span></tt>.</p>\n<p>The <tt>requirements.txt</tt> follows the Pip format\n(see <a href=\"https://pip.pypa.io/en/stable/user_guide/#id1\" rel=\"nofollow\">pip documentation</a>). The file defines which external packages are\nneeded by the <em>whole</em> of the code base. Pypackagery will read this list and extract the subset needed by the specified\nPython files.</p>\n<p><tt>module_to_requirement.tsv</tt> defines the correspondence between Python modules and requirements as defined in\n<tt>requirements.txt</tt>. This correspondence needs to be manually defined since there is no way to automatically map\nPython modules to pip packages. The correspondance in <tt>module_to_requirement.tsv</tt> is given as\nlines of two tab-separated values. The first column is the full model name (such as <tt>PIL.Image</tt>) and the second is\nthe name of the package in <tt>requirements.txt</tt> (such as <tt>pillow</tt>). The version of the package should be omitted and\nshould be specified <em>only</em> in the <tt>requirements.txt</tt>.</p>\n<p>Please do not forget to add the <tt>#egg</tt> fragment to URLs and files in <tt>requirements.txt</tt> so that the name of the\npackage can be uniquely resolved when joining <tt>module_to_requirement.tsv</tt> and <tt>requirements.txt</tt>.</p>\n</div>\n<div id=\"related-projects\">\n<h2>Related Projects</h2>\n<ul>\n<li><p><a href=\"https://github.com/pantsbuild/pex\" rel=\"nofollow\">https://github.com/pantsbuild/pex</a> \u2013 a library tool for generating PEX (Python EXecutable) files. It packages all the\nfiles in the virtual environment including all the requirements. This works for small code bases and light\nrequirements which are not frequently re-used among the components in the code base. However, when the requirements\nare heavy (such as OpenCV or numpy) and frequently re-used in the code base, it is a waste of bandwidth and disk space\nto package them repeatedly for each executable independently.</p>\n</li>\n<li><p><a href=\"https://www.pantsbuild.org/\" rel=\"nofollow\">https://www.pantsbuild.org/</a>, <a href=\"https://buckbuild.com/\" rel=\"nofollow\">https://buckbuild.com/</a> and <a href=\"https://github.com/linkedin/pygradle\" rel=\"nofollow\">https://github.com/linkedin/pygradle</a> are build systems that\ncan produce PEX files (with all the problems mentioned above). We considered using them and writing a plug-in to\nachieve the same goal as pypackagery. Finally, we decided for a separate tool since these build systems are not\nyet supported natively by IDEs (such as Pycharm) and actually break the expected Python development work flow.</p>\n</li>\n<li><p><a href=\"https://blog.shazam.com/python-microlibs-5be9461ad979\" rel=\"nofollow\">https://blog.shazam.com/python-microlibs-5be9461ad979</a> presents a microlib approach where a monorepo is packaged in\nseparate pip packages. While we find the idea interesting, it adds an administration overhead since every library\nneeds to live in a separate package thus making bigger refactorings tedious and error-prone (<em>e.g.</em> are the\nrequirements updated correctly and are dependency conflicts reported early?). We found it easiest to have a global\nlist of the requirements (with modules mapped to requirements), so that a sole <tt>pip3 install <span class=\"pre\">-r</span> requirements.txt</tt>\nwould notify us of the conflicts.</p>\n<p>If you wanted to work only on part of the code base, and do no want to install all the requirements, you can use\npypackagery to determine the required subset and install only those requirements that you need.</p>\n<p>Since we deploy often on third-party sites, we also found it difficult to secure our deployments. Namely, packaging\nthe code base into microlibs practically implies that we need to give the remote machine access to our private pypi\nrepository. In case that we only want to deploy the subset of the code base, granting access to all packages would\nunnecessarily open up a potential security hole. With pypackagery, we deploy only the files that are actually\nused while the third-party dependencies are separately installed on the remote instance from a subset of requirements\n<tt>subrequirements.txt</tt> with <tt>pip3 install <span class=\"pre\">-r</span> subrequirements.txt</tt>.</p>\n</li>\n</ul>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<div id=\"requirement-specification\">\n<h3>Requirement Specification</h3>\n<p>As already mentioned, the requirements are expected to follow Pip format\n(see <a href=\"https://pip.pypa.io/en/stable/user_guide/#id1\" rel=\"nofollow\">pip documentation</a>) and live in <tt>requirements.txt</tt> at the root\nof the code base. The mapping from modules to requirements is expected in <tt>module_to_requirement.tsv</tt> also at the root\nof the code base.</p>\n<p>Assume that the code base lives in <tt><span class=\"pre\">~/workspace/some-project</span></tt>.</p>\n<p>Here is an excerpt from <tt><span class=\"pre\">~/workspace/some-project/requirements.txt</span></tt>:</p>\n<pre>pillow==5.2.0\npytz==2018.5\npyzmq==17.1.2\n</pre>\n<p>And here is an excerpt from <tt><span class=\"pre\">~/workspace/some-project/module_to_requirement.tsv</span></tt>\n(mind that it\u2019s tab separated):</p>\n<pre>PIL pillow\nPIL.Image   pillow\nPIL.ImageFile       pillow\nPIL.ImageOps        pillow\nPIL.ImageStat       pillow\nPIL.ImageTk pillow\ncv2 opencv-python\n</pre>\n</div>\n<div id=\"directory\">\n<h3>Directory</h3>\n<p>Assume that the code base lives in <tt><span class=\"pre\">~/workspace/some-project</span></tt> and we are interested to bundle everything\nin <tt>pipeline/out</tt> directory.</p>\n<p>To determine the subset of the files and requirements, run the following command line:</p>\n<pre>pypackagery <span class=\"se\">\\\n</span>    --root_dir ~/workspace/some-project <span class=\"se\">\\\n</span>    --initial_set ~/workspace/some-project/pipeline/out\n</pre>\n<p>This gives us a verbose, human-readable output like:</p>\n<pre>External dependencies:\nPackage name | Requirement spec\n-------------+---------------------\npyzmq        | 'pyzmq==17.1.2'\ntemppathlib  | 'temppathlib==1.0.3'\n\nLocal dependencies:\npipeline/out/__init__.py\ncommon/__init__.py\ncommon/logging.py\ncommon/proc.py\n</pre>\n<p>If we want to get the same output in JSON, we need to call:</p>\n<pre>pypackagery <span class=\"se\">\\\n</span>    --root_dir ~/workspace/some-project <span class=\"se\">\\\n</span>    --initial_set ~/workspace/some-project/pipeline/out <span class=\"se\">\\\n</span>    --format json\n</pre>\n<p>which gives us a JSON-encoded dependency graph:</p>\n<pre><span class=\"p\">{</span>\n  <span class=\"nt\">\"requirements\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"nt\">\"pyzmq\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n      <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"pyzmq\"</span><span class=\"p\">,</span>\n      <span class=\"nt\">\"line\"</span><span class=\"p\">:</span> <span class=\"s2\">\"pyzmq==17.1.2\\n\"</span>\n    <span class=\"p\">},</span>\n    <span class=\"nt\">\"temppathlib\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n      <span class=\"nt\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"temppathlib\"</span><span class=\"p\">,</span>\n      <span class=\"nt\">\"line\"</span><span class=\"p\">:</span> <span class=\"s2\">\"temppathlib==1.0.3\\n\"</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">},</span>\n  <span class=\"nt\">\"rel_paths\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n    <span class=\"s2\">\"pipeline/out/__init__.py\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"common/__init__.py\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"common/logging.py\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"common/proc.py\"</span>\n  <span class=\"p\">],</span>\n  <span class=\"nt\">\"unresolved_modules\"</span><span class=\"p\">:</span> <span class=\"p\">[]</span>\n<span class=\"p\">}</span>\n</pre>\n</div>\n<div id=\"files\">\n<h3>Files</h3>\n<p>Assume again that the code base lives in <tt><span class=\"pre\">~/workspace/some-project</span></tt>. We would like to get a subset of the\ncode base required by a list of scripts. We need to specify the initial set as a list of files:</p>\n<pre>pypackagery <span class=\"se\">\\\n</span>    --root_dir ~/workspace/some-project <span class=\"se\">\\\n</span>    --initial_set <span class=\"se\">\\\n</span>        ~/workspace/some-project/pipeline/input/receivery.py <span class=\"se\">\\\n</span>        ~/workspace/some-project/pipeline/input/snapshotry.py\n</pre>\n<p>which gives us:</p>\n<pre>External dependencies:\nPackage name | Requirement spec\n-------------+-------------------\nicontract    | 'icontract==1.5.1'\npillow       | 'pillow==5.2.0'\nprotobuf     | 'protobuf==3.5.1'\npytz         | 'pytz==2018.5'\npyzmq        | 'pyzmq==17.1.2'\nrequests     | 'requests==2.19.1'\n\nLocal dependencies:\npipeline/__init__.py\npipeline/input/receivery.py\npipeline/input/snapshotry.py\ncommon/__init__.py\ncommon/img.py\ncommon/logging.py\nprotoed/__init__.py\nprotoed/pipeline_pb2.py\n</pre>\n</div>\n<div id=\"unresolved-modules\">\n<h3>Unresolved Modules</h3>\n<p>If there is a module which could not be resolved (neither in built-ins, nor specified in the requirements nor\nliving in the code base), the pypackagery will return a non-zero return code.</p>\n<p>If you specify <tt><span class=\"pre\">--dont_panic</span></tt>, the return code will be 0 even if there are unresolved modules.</p>\n</div>\n<div id=\"module-packagery\">\n<h3>Module <tt>packagery</tt></h3>\n<p>Pypackagery provides a module <tt>packagery</tt> which can be used to programmatically determine the dependencies of the\nsubset of the code base. For example, this is particularly useful for deployments to a remote machine where you\nwant to deploy only a part of the code base depending on some given configuration.</p>\n<p>Here is an example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">pathlib</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">packagery</span>\n\n<span class=\"n\">root_dir</span> <span class=\"o\">=</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s1\">'/some/codebase'</span><span class=\"p\">)</span>\n\n<span class=\"n\">rel_pths</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"some/dir/file1.py\"</span><span class=\"p\">),</span>\n    <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"some/other/dir/file2.py\"</span><span class=\"p\">)]</span>\n\n<span class=\"n\">requirements_txt</span> <span class=\"o\">=</span> <span class=\"n\">root_dir</span> <span class=\"o\">/</span> <span class=\"s2\">\"requirements.txt\"</span>\n<span class=\"n\">module_to_requirement_tsv</span> <span class=\"o\">=</span> <span class=\"n\">root_dir</span> <span class=\"o\">/</span> <span class=\"s2\">\"module_to_requirement.tsv\"</span>\n\n<span class=\"n\">requirements</span> <span class=\"o\">=</span> <span class=\"n\">packagery</span><span class=\"o\">.</span><span class=\"n\">parse_requirements</span><span class=\"p\">(</span>\n    <span class=\"n\">text</span><span class=\"o\">=</span><span class=\"n\">requirements_txt</span><span class=\"o\">.</span><span class=\"n\">read_text</span><span class=\"p\">())</span>\n\n<span class=\"n\">module_to_requirement</span> <span class=\"o\">=</span> <span class=\"n\">packagery</span><span class=\"o\">.</span><span class=\"n\">parse_module_to_requirement</span><span class=\"p\">(</span>\n    <span class=\"n\">text</span><span class=\"o\">=</span><span class=\"n\">module_to_requirement_tsv</span><span class=\"o\">.</span><span class=\"n\">read_text</span><span class=\"p\">(),</span>\n    <span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"n\">module_to_requirement_tsv</span><span class=\"o\">.</span><span class=\"n\">as_posix</span><span class=\"p\">())</span>\n\n<span class=\"n\">pkg</span> <span class=\"o\">=</span> <span class=\"n\">packagery</span><span class=\"o\">.</span><span class=\"n\">collect_dependency_graph</span><span class=\"p\">(</span>\n    <span class=\"n\">root_dir</span><span class=\"o\">=</span><span class=\"n\">root_dir</span><span class=\"p\">,</span>\n    <span class=\"n\">rel_paths</span><span class=\"o\">=</span><span class=\"n\">rel_pths</span><span class=\"p\">,</span>\n    <span class=\"n\">requirements</span><span class=\"o\">=</span><span class=\"n\">requirements</span><span class=\"p\">,</span>\n    <span class=\"n\">module_to_requirement</span><span class=\"o\">=</span><span class=\"n\">module_to_requirement</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># do something with pkg ...</span>\n</pre>\n<p>Mind that relative paths (given as <tt>rel_paths</tt> argument) all need to be files, not directories.</p>\n</div>\n</div>\n<div id=\"documentation\">\n<h2>Documentation</h2>\n<p>The documentation is available on <a href=\"https://pypackagery.readthedocs.io/en/latest/\" rel=\"nofollow\">readthedocs</a>.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<ul>\n<li>Create a virtual environment:</li>\n</ul>\n<pre>python3 -m venv venv3\n</pre>\n<ul>\n<li>Activate it:</li>\n</ul>\n<pre><span class=\"nb\">source</span> venv3/bin/activate\n</pre>\n<ul>\n<li>Install pypackagery with pip:</li>\n</ul>\n<pre>pip3 install pypackagery\n</pre>\n</div>\n<div id=\"development\">\n<h2>Development</h2>\n<ul>\n<li>Check out the repository.</li>\n<li>In the repository root, create the virtual environment:</li>\n</ul>\n<pre>python3 -m venv venv3\n</pre>\n<ul>\n<li>Activate the virtual environment:</li>\n</ul>\n<pre><span class=\"nb\">source</span> venv3/bin/activate\n</pre>\n<ul>\n<li>Install the development dependencies:</li>\n</ul>\n<pre>pip3 install -e .<span class=\"o\">[</span>dev<span class=\"o\">]</span>\n</pre>\n<p>We use tox for testing and packaging the distribution:</p>\n<pre>tox\n</pre>\n<div id=\"pre-commit-checks\">\n<h3>Pre-commit Checks</h3>\n<p>We provide a set of pre-commit checks that lint and check code for formatting.</p>\n<p>Namely, we use:</p>\n<ul>\n<li><a href=\"https://github.com/google/yapf\" rel=\"nofollow\">yapf</a> to check the formatting.</li>\n<li>The style of the docstrings is checked with <a href=\"https://github.com/PyCQA/pydocstyle\" rel=\"nofollow\">pydocstyle</a>.</li>\n<li>Static type analysis is performed with <a href=\"http://mypy-lang.org/\" rel=\"nofollow\">mypy</a>.</li>\n<li>Various linter checks are done with <a href=\"https://www.pylint.org/\" rel=\"nofollow\">pylint</a>.</li>\n<li>Doctests are executed using the Python <a href=\"https://docs.python.org/3.5/library/doctest.html\" rel=\"nofollow\">doctest module</a>.</li>\n</ul>\n<p>Run the pre-commit checks locally from an activated virtual environment with development dependencies:</p>\n<pre>./precommit.py\n</pre>\n<ul>\n<li>The pre-commit script can also automatically format the code:</li>\n</ul>\n<pre>./precommit.py  --overwrite\n</pre>\n</div>\n</div>\n<div id=\"versioning\">\n<h2>Versioning</h2>\n<p>We follow <a href=\"http://semver.org/spec/v1.0.0.html\" rel=\"nofollow\">Semantic Versioning</a>. The version X.Y.Z indicates:</p>\n<ul>\n<li>X is the major version (backward-incompatible),</li>\n<li>Y is the minor version (backward-compatible), and</li>\n<li>Z is the patch version (backward-compatible bug fix).</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 6548184, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "7c67a2afbec4e0ba65cd7a6b2baea6c4", "sha256": "0b81e4ce4a7e4313610d9e00cbaa379dc116f5ae574aa72ff23115cbbeed35e0"}, "downloads": -1, "filename": "pypackagery-1.0.0.tar.gz", "has_sig": false, "md5_digest": "7c67a2afbec4e0ba65cd7a6b2baea6c4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10398, "upload_time": "2018-09-18T07:22:57", "upload_time_iso_8601": "2018-09-18T07:22:57.532391Z", "url": "https://files.pythonhosted.org/packages/dd/27/b01060d7a724e96571d8056abd273f059203b48a7e279d0f0b2c305c9632/pypackagery-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "23715a44ad1d17ceff4eaf075abaa299", "sha256": "0359821a77663630a9060f7d3f6b8649afbb1136ee96e6cc5177bbea87641c30"}, "downloads": -1, "filename": "pypackagery-1.0.1.tar.gz", "has_sig": false, "md5_digest": "23715a44ad1d17ceff4eaf075abaa299", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11646, "upload_time": "2018-09-18T08:13:09", "upload_time_iso_8601": "2018-09-18T08:13:09.812988Z", "url": "https://files.pythonhosted.org/packages/fd/e8/05b4fcf5998e892b1b697b1640d12fe6cd82e45a134bd8dc1d6c055a7076/pypackagery-1.0.1.tar.gz", "yanked": false}], "1.0.2": [{"comment_text": "", "digests": {"md5": "bbf88990ca2a9df60b045f1323359621", "sha256": "2401ed459c2150e7847ab1213de003b38b97b96e7fa47e607ae31b59905a995d"}, "downloads": -1, "filename": "pypackagery-1.0.2.tar.gz", "has_sig": false, "md5_digest": "bbf88990ca2a9df60b045f1323359621", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13227, "upload_time": "2018-10-22T14:57:55", "upload_time_iso_8601": "2018-10-22T14:57:55.407669Z", "url": "https://files.pythonhosted.org/packages/76/44/d1e6689d383a2316427039c655114b01d8e39bfa3686822e46fa45dcd1ce/pypackagery-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "80696853c7927ee8c28f50b6200ef412", "sha256": "a52f7618e9bcffbc191c5f4630b844de3800459dc5181f2df15f6775b80c4479"}, "downloads": -1, "filename": "pypackagery-1.0.3.tar.gz", "has_sig": false, "md5_digest": "80696853c7927ee8c28f50b6200ef412", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13234, "upload_time": "2018-10-23T14:21:53", "upload_time_iso_8601": "2018-10-23T14:21:53.748814Z", "url": "https://files.pythonhosted.org/packages/0b/c4/1eae626d0083774c41add34070d4a39cf37ea0710aca2fdee911490f6129/pypackagery-1.0.3.tar.gz", "yanked": false}], "1.0.4": [{"comment_text": "", "digests": {"md5": "67b08e2553baee32851622da5c34a9c0", "sha256": "35873d40d120e231f056f29fb7983ee9651302b2a6e0dbf6102ce9b5a8817a0a"}, "downloads": -1, "filename": "pypackagery-1.0.4.tar.gz", "has_sig": false, "md5_digest": "67b08e2553baee32851622da5c34a9c0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11737, "upload_time": "2018-10-29T06:36:42", "upload_time_iso_8601": "2018-10-29T06:36:42.900269Z", "url": "https://files.pythonhosted.org/packages/e7/2e/a08c2ea422ac148bcb2b6a1353daa3aab3d24a79051c4dc7e1ac37c45bb4/pypackagery-1.0.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "67b08e2553baee32851622da5c34a9c0", "sha256": "35873d40d120e231f056f29fb7983ee9651302b2a6e0dbf6102ce9b5a8817a0a"}, "downloads": -1, "filename": "pypackagery-1.0.4.tar.gz", "has_sig": false, "md5_digest": "67b08e2553baee32851622da5c34a9c0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11737, "upload_time": "2018-10-29T06:36:42", "upload_time_iso_8601": "2018-10-29T06:36:42.900269Z", "url": "https://files.pythonhosted.org/packages/e7/2e/a08c2ea422ac148bcb2b6a1353daa3aab3d24a79051c4dc7e1ac37c45bb4/pypackagery-1.0.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:00:00 2020"}