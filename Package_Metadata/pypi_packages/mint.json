{"info": {"author": "Tim Perevezentsev", "author_email": "riffm2005@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "====\nmint\n====\n\n- about_\n\n- usage_\n\n- syntax_\n\n  - tags_\n\n  - attributes_\n\n  - escaping_\n\n  - python expressions_\n\n  - loops_\n\n  - conditions_\n\n  - comments_\n\n  - simplification_\n\n- inheritance_\n\n- utils_\n\n- CLI_\n\n\n.. _about:\n\n-----\nabout\n-----\n\n**mint** - is small, fast and easy to use (x)html templates engine.\nImplemented with python language.\n\nWhy use **mint**?:\n\nsingle python module\n    You can copy ``mint.py`` to your project package and use it.\n\nminimalistic syntax\n    Your templates will become smaller and more readable due to\n    indent based syntax.\n\nworks fast\n    **mint** uses ``ast`` python module from standard library\n    (since python2.6, thank you Armin and co). So all templates compiles to\n    optimized python byte code (during first call) which works fast.\n\nsmart\n    **mint** knows about (x)html tags and attributes,\n    so you get smart escaping. (There is a plan to implement html\n    validation during rendering)\n\nnot standing in your way\n    **mint** does't hide exceptions like some other template engines, and\n    shows line in your template file where exception was raised\n\nTemplate engine was inspired by haml (a template engine written in ruby),\nbut some concepts were redisigned for simplification and adoptation to python world.\n\n\nHome page:     https://github.com/riffm/mint\nIssue tracker: https://github.com/riffm/mint/issues\n\n.. _usage:\n\n-----\nusage\n-----\n\nSimple API::\n\n    >>> import mint\n    >>> loader = mint.Loader('./templates', cache=True)\n    >>> namespace = dict(a='a', b='b')\n    >>> result = loader.get_template('index.mint').render(**namespace)\n\n``mint.Loader`` accepts names of directories and then search for template files\nby name provided in ``get_template(name)`` call.\n\n.. _syntax:\n\n------\nsyntax\n------\n\n**mint** syntax is based on indention, so you see the document structure and\nupdate document fast. You can move blocks of code and do not search for\nbegining of parent tag and where it ends.\n\n\n.. _tags:\n\ntags\n----\n\nJust use ``@`` character before tag name to render a tag::\n\n    @tagname\n\nWhy **mint** does't use ``%`` char, like haml do?\nI think that ``@`` char is more readable and it is just third button on the keyboard,\nso you type it by one hand (without finger gymnastics).\nNext example shows tags structure::\n\n    @html\n        @head\n        @body\n\nIndented tags ``@head`` and ``@body`` are children for tag ``@html`` (parent tag).\n\nText is interpreted as text::\n\n    @div\n        @p\n            Text of paragraph\n\nSo last example will be rendered as::\n\n    <div>\n        <p>\n            Text of paragraph\n        </p>\n    </div>\n\nBy the way you can use short variant::\n\n    @div\n        @p Text of paragraph\n\n\n.. _attributes:\n\nattributes\n----------\n\nTo define attribute **mint** uses concept similar to method calls::\n\n    @div.id(content)\n\nPreviouse example will be rendered as::\n\n    <div id=\"content\"></div>\n\nTo define multiple attributes **mint** uses (so called) chaining::\n\n    @img.alt().src(/img/my_picture.png)\n\nPreviouse example will be rendered as::\n\n    <img alt=\"\" src=\"/img/my_picture.png\" />\n\nNote that **mint** knows about selfclosed html tags.\n\nWhy do not use python dictionary declaration syntax instead?\nSomething like ``{alt:\"\", src:\"/img/my_picture.png\"}``\n\nBecause it is overloaded for html templating. \"Chained-methods-call\" like\nsyntax uses less chars to type.\n\n**mint** alows to set/append value of tag attribute somewhere inside tag::\n\n    @div.class(main)\n        // set value of attribute\n        @.class(header)\n\n    @div.class(main)\n        // append value to attribute\n        @+class( header)\n\nwill be rendered as::\n\n    <div class=\"header\"></div>\n\n    <div class=\"main header\"></div>\n\nThis is very handy when you need to set content of tag and it's attributes based\non some condition.\n\n.. _escaping:\n\nescaping\n--------\n\nAs you know there are some chars we need to escape in xml.  And **mint** does this\nautomatically for you. It escapes all text inside tags and attributes.\nAutoescaping can't be turned off::\n\n    @a.href(/docs?type=1&published=true) docs\n    @p.class( ' \" < > & )\n        <div class=\"inside\" />\n\nWill be rendered as::\n\n    <a href=\"/docs?type=1&amp;published=true\">docs</a>\n    <p class=\"&#39; &quot; &lt; &gt; &amp;\">\n        &lt;div class=&quot;inside&quot; /&gt;\n    </p>\n\n\n.. _expressions:\n\npython expressions\n------------------\n\nOf course, template engine without possibility to insert python expressions is unusable.\nSo in **mint** you can do this with syntax similar to ``jinja2`` or ``django``::\n\n    @html\n        @head\n            @title {{ doc.title }}\n        @body\n            @div.id(content)\n                Here we have content {{ doc.content }}\n\nUnder the hood **mint** calls ``unicode`` on python expression\nand escapes result.\n\nNote that you can provide any valid python expression between tokens ``{{`` ``}}``.\nAlso note that you can use limited subset of python ``__builtins__``.\n\nIn **mint** templates expressions can be used inside text elements and inside attributes::\n\n    @p.class(title {{ doc.main_doc_class }}).id({{ doc.id }}) {{ doc.body }}\n\nAs you remember all content inserted in tags (as text) and in attributes is\nescaped by **mint**.  And this is good, but sometimes you need to insert\nunescaped html.  For this purpose mint uses special class ``mint.Markup``, which\nimplements ``__html__`` method (this is something like convention). To insert\nhtml inside templates you need to mark your python variables with\n``mint.Markup`` inside your python code.\n\nIn previous example if ``doc.body`` has html we need attribute ``body`` to return\n``mint.Markup(html_string)``. And that ``html_string`` will be inserted in template\nwithout escaping. That is the preferred way to insert markup inside html template.\n\nAlso note that there are two contexts to insert markup - tag and attribute.\nIn case of tag ``mint.Markup`` instances will be inserted without modifications.\nBut if you attemted to insert markup in attribute it will be additionaly escaped.\n\nFor example we have such python code::\n\n    class Doc(object):\n        def __init__(self, title, body):\n            self.title = mint.Markup(title)\n            self.body = mint.Markup(body)\n\n    doc = Doc('<b>title</b>', '<p>content of document</p>')\n\nAnd such template::\n\n    @div.class(doc)\n        @p.class(title).title({{ doc.title }}) {{ doc.title }}\n        {{ doc.body }}\n\nThe result will be::\n\n    <div class=\"doc\">\n        <p class=\"title\" title=\"&gt;b&lt;title&gt;/b&lt;\">\n            <b>title</b>\n        </p>\n        <p>content of document</p>\n    </div>\n\nThis feature of **mint** is very handy.\n\n.. _loops:\n\nloops\n-----\n\nIn **mint** you can use python statement ``for``::\n\n    @ul\n        #for img in images:\n            @li @img.src({{ img.file }})\n\nNote that::\n\n    @li @img.src({{ img.file }})\n\nis similar to::\n\n    @li\n        @img.src({{ img.file }})\n\nThis is inline tags notation.\n\n.. _conditions:\n\nconditions\n----------\n\nConditions are easy to write too::\n\n    #for doc in docs:\n        #if doc.id != current_id:\n            @a.href({{ url_for('doc', id=doc.id) }}) {{ doc.title }}\n        #elif doc.title == 'I need paragraph':\n            @p {{ doc.title }}\n        #else:\n            {{ doc.title }}\n\n\n.. _comments:\n\ncomments\n--------\nTo comment a line use token ``//``::\n\n    // In this div we provide content, yours C.O.\n    @div.id(content)\n\nXml comments are supported, use token ``--``::\n\n    -- In this div we provide content, yours C.O.\n    @div.id(content)\n\nto get::\n\n    <!-- In this div we provide content, yours C.O. -->\n    <div id=\"content\"></div>\n\nSometimes you need to use special tokens in text, so if a line starts with\ntoken ``\\`` line is not interpreted by **mint**::\n\n    @p.class(title) Here we have title\n    \\@p.class(title) Here we have title\n\nWill provide::\n\n    <p class=\"title\">Here we have title</p>\n    @p.class(title) Here we have title\n\n\n.. _simplification:\n\nsimplification\n--------------\n\nSimplification of syntax provides ambiguity. But it is very handy sometimes.\nIn **mint** templates you can write such things::\n\n    @ul\n        #for image in images:\n            @li.class(image) @img.alt().src({{ image.path }})\n\nThis simplification alows to write nested tags in one line, one by one. In\nprevious example all ``img`` tags will be inside ``li``.\n\nRemember rule #1: This records::\n\n    @div.id(1) @div.id(2) @div.id(3)\n\n    @div.id(1)\n        @div.id(2) @div.id(3)\n\n    @div.id(1)\n        @div.id(2)\n            @div.id(3)\n\nare the same.\n\nRule #2: you can append text to and only to last tag when you use syntax\nsimplification::\n\n    @ul\n        #for doc in docs:\n            @li @p.class(title) {{ doc.title }}\n                @p.class(descr) {{ doc.description }}\n\n``li`` will be rendered as::\n\n    <li>\n        <p class=\"title\">...</p>\n        <p class=\"descr\">...</p>\n    </li>\n\nBe careful when using syntax simplification.\n\n.. _inheritance:\n\n-----------\ninheritance\n-----------\n\n**mint** uses slots to implement template inheritance. Slot is nothing more but\npython function that retuns markup. Slot can be defined and called anywhere in template::\n\n    // layout.mint\n    @html\n        @head\n            @title {{ title }}\n        @body\n            @div.id(content)\n\n                #def content():\n                    @p.class(title) {{ title }}\n                    {{ text }}\n\n                #content()\n\n            @div.id(footer)\n\nAs you can see in previous example we define slot ``content`` and call it after that.\nDuring call of slot it's content will be inserted in template. And if we need to insert\ndifferent content in that place we should inherit ``layout.mint`` and override ``content``\nslot implementation::\n\n    // news.mint\n    #base: layout.mint\n\n    #def content():\n        #for item in news:\n            @a.href({{ url_for('news-item', id=item.id) }}) {{ news.title }}\n\nIt is simple and powerful concept.\n\nSlots are python functions, so they see all global variables passed to template and have\nown scope. This is very handy, because sometimes people have problems with such things\nin other templates engines.\n\nFor example we need a block inside ``for`` loop::\n\n    // layout.mint\n    @div.id(content)\n        #for item in items:\n            #loop_slot()\n\n    // photos.mint\n    #base: layout.mint\n\n    #def loop_slot():\n        @p.class(title) {{ item.title }}\n        @img.alt().src({{ item.image.path }})\n\nFor **mint** this is natural behavior. And ``item`` is just global variable for\nslot ``loop_slot``. But in this case it's better to provide ``item`` to slot\nexplicitly::\n\n    // layout.mint\n    @div.id(content)\n        #for item in items:\n            #loop_slot(item)\n\n    // photos.mint\n    #base: layout.mint\n\n    #def loop_slot(item):\n        @p.class(title) {{ item.title }}\n        @img.alt().src({{ item.image.path }})\n\nAlso we can call base slot inside overrided slot. In our case base slot will\npoint to slot with same name in our base template. ``__base__`` variable points\ninside current slot scope to implementation of current slot in parent template::\n\n    // base.mint\n    -- somewhere in head tag\n    #def js():\n        @script.type(text/javascript).src(/js/main.js)\n    #js()\n\n\n    // photos.mint\n    #base: base.mint\n    #def js():\n        #__base__()\n        @script.type(text/javascript).src(/js/photos.js)\n\nThis example will results in::\n\n    <!-- somewhere in head tag -->\n    <script type=\"text/javascript\" scr=\"/js/main.js\"></script>\n    <script type=\"text/javascript\" scr=\"/js/photos.js\"></script>\n\nSlots are plain python functions, slots returns ``Markup`` objects so we can pass slots\nor result of slot call to other slots.\n\nAnd more. We can use slots outside of templates. Lets take photos.mint from\nexample with ``for`` loop::\n\n    >>> import mint\n    >>> t = mint.Loader('.').get_template('photos.mint')\n    >>> loop_slot = t.slot('loop_slot')\n    >>> # lets take image somewhere\n    >>> item = images.get(1)\n    >>> loop_slot(item)\n    Markup(u'<p class=\"title\">...</p><img alt=\"\" src=\"...\" />')\n\nBut sometimes slots needs global variables, you must provide such variables\nwith kwargs in method ``slot(name, **globals)`` of ``Template`` object.\n\n\n.. _utils:\n\n-----\nutils\n-----\n\n**mint** provides global variable ``utils`` which contains useful constants and helper\nfunctions.\n\nDoctype declarations\n\n- ``utils.doctype.html_strict``\n- ``utils.doctype.html_transitional``\n- ``utils.doctype.xhtml_strict``\n- ``utils.doctype.xhtml_transitional``\n\nExample of usage::\n\n    {{ utils.doctype.html_strict }}\n    @html\n\nClass ``mint.Markup`` is ``utils.markup`` (this is replacement for hack ``{{ var|safe }}``)\n\n``utils.loop`` is helper function to use with ``for`` statement. It takes iterable\nobject and returns tuple of item and special object that consist of useful info for each\niteration::\n\n    #for item, l in utils.loop(items):\n        @a.href({{ item.url }})\n            {{ item.title }} {{ (l.first, l.last, l.odd) }} {{ l.cycle('one', 'two', 'three') }}\n\nIn previous example ``l.cycle('one', 'two', 'three')`` will return one of values provided\nin sequence. It is handy to colorize tables.\n\nHtml helpers\n\n- ``utils.script``\n- ``utils.scripts``\n- ``utils.link``\n\n\n.. _CLI:\n\n----------------------\nCommand Line Interface\n----------------------\n\n``mint`` has a CLI. To list available options use ``--help`` flag::\n\n    % python -m mint --help\n    Usage: mint.py [options] [template]\n\n    Options:\n      -h, --help        show this help message and exit\n      -c, --code        Show only python code of compiled template.\n      -t, --tokenize    Show tokens stream of template.\n      -r N, --repeat=N  Try to render template N times and display average time\n                        result.\n      -p, --pprint      Turn pretty print on.\n      -m, --monitor     Monitor current directory and subdirectories for changes\n                        in mint files. And render corresponding html files.\n\nCLI works in two modes:\n\n- rendering\n- monitoring\n\n\nThat's all folks!\n\n\n---------\nchangelog\n---------\n\nv0.5\n----\n\n* Smart indent. Tokenizer sets `indent level` for whole template equal indent\n  level of first indented line (as in python)\n\n* Mint nodes now based on `ast.AST` and to transform `mint` tree to `python`\n  tree we use `ast.NodeTransformer` subclass. This feature allows us write\n  transformers for other languages (js =)\n\n* Added `pretty printing` of html result. Default indention is two spaces and\n  is unchangable\n\n* Updated vim highlight for mint files\n\n* Added html helpers `utils.script`, `utils.link` and `utils.scripts`\n\n* New `CLI` interface. Some features\n\n  * shows result python code listing for mint template\n\n  * shows tokens stream for mint template\n\n  * renders templates and prints result to stdout (note: if no outer variables\n    used)\n\n  * measures average rendering time for template (note: if no outer variables\n    used)\n\n  * `monitoring` feature\n\n* Fixes\n\n\nv0.4.4\n------\n\nWorking implementation", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/riffm/mint", "keywords": null, "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "mint", "package_url": "https://pypi.org/project/mint/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/mint/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/riffm/mint"}, "release_url": "https://pypi.org/project/mint/0.5/", "requires_dist": null, "requires_python": null, "summary": "Simple indetion based template engine", "version": "0.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <ul>\n<li><a href=\"#about\" rel=\"nofollow\">about</a></li>\n<li><a href=\"#usage\" rel=\"nofollow\">usage</a></li>\n<li><a href=\"#syntax\" rel=\"nofollow\">syntax</a><ul>\n<li><a href=\"#tags\" rel=\"nofollow\">tags</a></li>\n<li><a href=\"#attributes\" rel=\"nofollow\">attributes</a></li>\n<li><a href=\"#escaping\" rel=\"nofollow\">escaping</a></li>\n<li>python <a href=\"#expressions\" rel=\"nofollow\">expressions</a></li>\n<li><a href=\"#loops\" rel=\"nofollow\">loops</a></li>\n<li><a href=\"#conditions\" rel=\"nofollow\">conditions</a></li>\n<li><a href=\"#comments\" rel=\"nofollow\">comments</a></li>\n<li><a href=\"#simplification\" rel=\"nofollow\">simplification</a></li>\n</ul>\n</li>\n<li><a href=\"#inheritance\" rel=\"nofollow\">inheritance</a></li>\n<li><a href=\"#utils\" rel=\"nofollow\">utils</a></li>\n<li><a href=\"#cli\" rel=\"nofollow\">CLI</a></li>\n</ul>\n<div id=\"id1\">\n<span id=\"about\"></span><h2>about</h2>\n<p><strong>mint</strong> - is small, fast and easy to use (x)html templates engine.\nImplemented with python language.</p>\n<p>Why use <strong>mint</strong>?:</p>\n<dl>\n<dt>single python module</dt>\n<dd>You can copy <tt>mint.py</tt> to your project package and use it.</dd>\n<dt>minimalistic syntax</dt>\n<dd>Your templates will become smaller and more readable due to\nindent based syntax.</dd>\n<dt>works fast</dt>\n<dd><strong>mint</strong> uses <tt>ast</tt> python module from standard library\n(since python2.6, thank you Armin and co). So all templates compiles to\noptimized python byte code (during first call) which works fast.</dd>\n<dt>smart</dt>\n<dd><strong>mint</strong> knows about (x)html tags and attributes,\nso you get smart escaping. (There is a plan to implement html\nvalidation during rendering)</dd>\n<dt>not standing in your way</dt>\n<dd><strong>mint</strong> does\u2019t hide exceptions like some other template engines, and\nshows line in your template file where exception was raised</dd>\n</dl>\n<p>Template engine was inspired by haml (a template engine written in ruby),\nbut some concepts were redisigned for simplification and adoptation to python world.</p>\n<p>Home page:     <a href=\"https://github.com/riffm/mint\" rel=\"nofollow\">https://github.com/riffm/mint</a>\nIssue tracker: <a href=\"https://github.com/riffm/mint/issues\" rel=\"nofollow\">https://github.com/riffm/mint/issues</a></p>\n</div>\n<div id=\"id2\">\n<span id=\"usage\"></span><h2>usage</h2>\n<p>Simple API:</p>\n<pre>&gt;&gt;&gt; import mint\n&gt;&gt;&gt; loader = mint.Loader('./templates', cache=True)\n&gt;&gt;&gt; namespace = dict(a='a', b='b')\n&gt;&gt;&gt; result = loader.get_template('index.mint').render(**namespace)\n</pre>\n<p><tt>mint.Loader</tt> accepts names of directories and then search for template files\nby name provided in <tt>get_template(name)</tt> call.</p>\n</div>\n<div id=\"id3\">\n<span id=\"syntax\"></span><h2>syntax</h2>\n<p><strong>mint</strong> syntax is based on indention, so you see the document structure and\nupdate document fast. You can move blocks of code and do not search for\nbegining of parent tag and where it ends.</p>\n<div id=\"id4\">\n<span id=\"tags\"></span><h3>tags</h3>\n<p>Just use <tt>@</tt> character before tag name to render a tag:</p>\n<pre>@tagname\n</pre>\n<p>Why <strong>mint</strong> does\u2019t use <tt>%</tt> char, like haml do?\nI think that <tt>@</tt> char is more readable and it is just third button on the keyboard,\nso you type it by one hand (without finger gymnastics).\nNext example shows tags structure:</p>\n<pre>@html\n    @head\n    @body\n</pre>\n<p>Indented tags <tt>@head</tt> and <tt>@body</tt> are children for tag <tt>@html</tt> (parent tag).</p>\n<p>Text is interpreted as text:</p>\n<pre>@div\n    @p\n        Text of paragraph\n</pre>\n<p>So last example will be rendered as:</p>\n<pre>&lt;div&gt;\n    &lt;p&gt;\n        Text of paragraph\n    &lt;/p&gt;\n&lt;/div&gt;\n</pre>\n<p>By the way you can use short variant:</p>\n<pre>@div\n    @p Text of paragraph\n</pre>\n</div>\n<div id=\"id5\">\n<span id=\"attributes\"></span><h3>attributes</h3>\n<p>To define attribute <strong>mint</strong> uses concept similar to method calls:</p>\n<pre>@div.id(content)\n</pre>\n<p>Previouse example will be rendered as:</p>\n<pre>&lt;div id=\"content\"&gt;&lt;/div&gt;\n</pre>\n<p>To define multiple attributes <strong>mint</strong> uses (so called) chaining:</p>\n<pre>@img.alt().src(/img/my_picture.png)\n</pre>\n<p>Previouse example will be rendered as:</p>\n<pre>&lt;img alt=\"\" src=\"/img/my_picture.png\" /&gt;\n</pre>\n<p>Note that <strong>mint</strong> knows about selfclosed html tags.</p>\n<p>Why do not use python dictionary declaration syntax instead?\nSomething like <tt><span class=\"pre\">{alt:\"\",</span> <span class=\"pre\">src:\"/img/my_picture.png\"}</span></tt></p>\n<p>Because it is overloaded for html templating. \u201cChained-methods-call\u201d like\nsyntax uses less chars to type.</p>\n<p><strong>mint</strong> alows to set/append value of tag attribute somewhere inside tag:</p>\n<pre>@div.class(main)\n    // set value of attribute\n    @.class(header)\n\n@div.class(main)\n    // append value to attribute\n    @+class( header)\n</pre>\n<p>will be rendered as:</p>\n<pre>&lt;div class=\"header\"&gt;&lt;/div&gt;\n\n&lt;div class=\"main header\"&gt;&lt;/div&gt;\n</pre>\n<p>This is very handy when you need to set content of tag and it\u2019s attributes based\non some condition.</p>\n</div>\n<div id=\"id6\">\n<span id=\"escaping\"></span><h3>escaping</h3>\n<p>As you know there are some chars we need to escape in xml.  And <strong>mint</strong> does this\nautomatically for you. It escapes all text inside tags and attributes.\nAutoescaping can\u2019t be turned off:</p>\n<pre>@a.href(/docs?type=1&amp;published=true) docs\n@p.class( ' \" &lt; &gt; &amp; )\n    &lt;div class=\"inside\" /&gt;\n</pre>\n<p>Will be rendered as:</p>\n<pre>&lt;a href=\"/docs?type=1&amp;amp;published=true\"&gt;docs&lt;/a&gt;\n&lt;p class=\"&amp;#39; &amp;quot; &amp;lt; &amp;gt; &amp;amp;\"&gt;\n    &amp;lt;div class=&amp;quot;inside&amp;quot; /&amp;gt;\n&lt;/p&gt;\n</pre>\n</div>\n<div id=\"python-expressions\">\n<span id=\"expressions\"></span><h3>python expressions</h3>\n<p>Of course, template engine without possibility to insert python expressions is unusable.\nSo in <strong>mint</strong> you can do this with syntax similar to <tt>jinja2</tt> or <tt>django</tt>:</p>\n<pre>@html\n    @head\n        @title {{ doc.title }}\n    @body\n        @div.id(content)\n            Here we have content {{ doc.content }}\n</pre>\n<p>Under the hood <strong>mint</strong> calls <tt>unicode</tt> on python expression\nand escapes result.</p>\n<p>Note that you can provide any valid python expression between tokens <tt>{{</tt> <tt>}}</tt>.\nAlso note that you can use limited subset of python <tt>__builtins__</tt>.</p>\n<p>In <strong>mint</strong> templates expressions can be used inside text elements and inside attributes:</p>\n<pre>@p.class(title {{ doc.main_doc_class }}).id({{ doc.id }}) {{ doc.body }}\n</pre>\n<p>As you remember all content inserted in tags (as text) and in attributes is\nescaped by <strong>mint</strong>.  And this is good, but sometimes you need to insert\nunescaped html.  For this purpose mint uses special class <tt>mint.Markup</tt>, which\nimplements <tt>__html__</tt> method (this is something like convention). To insert\nhtml inside templates you need to mark your python variables with\n<tt>mint.Markup</tt> inside your python code.</p>\n<p>In previous example if <tt>doc.body</tt> has html we need attribute <tt>body</tt> to return\n<tt>mint.Markup(html_string)</tt>. And that <tt>html_string</tt> will be inserted in template\nwithout escaping. That is the preferred way to insert markup inside html template.</p>\n<p>Also note that there are two contexts to insert markup - tag and attribute.\nIn case of tag <tt>mint.Markup</tt> instances will be inserted without modifications.\nBut if you attemted to insert markup in attribute it will be additionaly escaped.</p>\n<p>For example we have such python code:</p>\n<pre>class Doc(object):\n    def __init__(self, title, body):\n        self.title = mint.Markup(title)\n        self.body = mint.Markup(body)\n\ndoc = Doc('&lt;b&gt;title&lt;/b&gt;', '&lt;p&gt;content of document&lt;/p&gt;')\n</pre>\n<p>And such template:</p>\n<pre>@div.class(doc)\n    @p.class(title).title({{ doc.title }}) {{ doc.title }}\n    {{ doc.body }}\n</pre>\n<p>The result will be:</p>\n<pre>&lt;div class=\"doc\"&gt;\n    &lt;p class=\"title\" title=\"&amp;gt;b&amp;lt;title&amp;gt;/b&amp;lt;\"&gt;\n        &lt;b&gt;title&lt;/b&gt;\n    &lt;/p&gt;\n    &lt;p&gt;content of document&lt;/p&gt;\n&lt;/div&gt;\n</pre>\n<p>This feature of <strong>mint</strong> is very handy.</p>\n</div>\n<div id=\"id7\">\n<span id=\"loops\"></span><h3>loops</h3>\n<p>In <strong>mint</strong> you can use python statement <tt>for</tt>:</p>\n<pre>@ul\n    #for img in images:\n        @li @img.src({{ img.file }})\n</pre>\n<p>Note that:</p>\n<pre>@li @img.src({{ img.file }})\n</pre>\n<p>is similar to:</p>\n<pre>@li\n    @img.src({{ img.file }})\n</pre>\n<p>This is inline tags notation.</p>\n</div>\n<div id=\"id8\">\n<span id=\"conditions\"></span><h3>conditions</h3>\n<p>Conditions are easy to write too:</p>\n<pre>#for doc in docs:\n    #if doc.id != current_id:\n        @a.href({{ url_for('doc', id=doc.id) }}) {{ doc.title }}\n    #elif doc.title == 'I need paragraph':\n        @p {{ doc.title }}\n    #else:\n        {{ doc.title }}\n</pre>\n</div>\n<div id=\"id9\">\n<span id=\"comments\"></span><h3>comments</h3>\n<p>To comment a line use token <tt>//</tt>:</p>\n<pre>// In this div we provide content, yours C.O.\n@div.id(content)\n</pre>\n<p>Xml comments are supported, use token <tt><span class=\"pre\">--</span></tt>:</p>\n<pre>-- In this div we provide content, yours C.O.\n@div.id(content)\n</pre>\n<p>to get:</p>\n<pre>&lt;!-- In this div we provide content, yours C.O. --&gt;\n&lt;div id=\"content\"&gt;&lt;/div&gt;\n</pre>\n<p>Sometimes you need to use special tokens in text, so if a line starts with\ntoken <tt>\\</tt> line is not interpreted by <strong>mint</strong>:</p>\n<pre>@p.class(title) Here we have title\n\\@p.class(title) Here we have title\n</pre>\n<p>Will provide:</p>\n<pre>&lt;p class=\"title\"&gt;Here we have title&lt;/p&gt;\n@p.class(title) Here we have title\n</pre>\n</div>\n<div id=\"id10\">\n<span id=\"simplification\"></span><h3>simplification</h3>\n<p>Simplification of syntax provides ambiguity. But it is very handy sometimes.\nIn <strong>mint</strong> templates you can write such things:</p>\n<pre>@ul\n    #for image in images:\n        @li.class(image) @img.alt().src({{ image.path }})\n</pre>\n<p>This simplification alows to write nested tags in one line, one by one. In\nprevious example all <tt>img</tt> tags will be inside <tt>li</tt>.</p>\n<p>Remember rule #1: This records:</p>\n<pre>@div.id(1) @div.id(2) @div.id(3)\n\n@div.id(1)\n    @div.id(2) @div.id(3)\n\n@div.id(1)\n    @div.id(2)\n        @div.id(3)\n</pre>\n<p>are the same.</p>\n<p>Rule #2: you can append text to and only to last tag when you use syntax\nsimplification:</p>\n<pre>@ul\n    #for doc in docs:\n        @li @p.class(title) {{ doc.title }}\n            @p.class(descr) {{ doc.description }}\n</pre>\n<p><tt>li</tt> will be rendered as:</p>\n<pre>&lt;li&gt;\n    &lt;p class=\"title\"&gt;...&lt;/p&gt;\n    &lt;p class=\"descr\"&gt;...&lt;/p&gt;\n&lt;/li&gt;\n</pre>\n<p>Be careful when using syntax simplification.</p>\n</div>\n</div>\n<div id=\"id11\">\n<span id=\"inheritance\"></span><h2>inheritance</h2>\n<p><strong>mint</strong> uses slots to implement template inheritance. Slot is nothing more but\npython function that retuns markup. Slot can be defined and called anywhere in template:</p>\n<pre>// layout.mint\n@html\n    @head\n        @title {{ title }}\n    @body\n        @div.id(content)\n\n            #def content():\n                @p.class(title) {{ title }}\n                {{ text }}\n\n            #content()\n\n        @div.id(footer)\n</pre>\n<p>As you can see in previous example we define slot <tt>content</tt> and call it after that.\nDuring call of slot it\u2019s content will be inserted in template. And if we need to insert\ndifferent content in that place we should inherit <tt>layout.mint</tt> and override <tt>content</tt>\nslot implementation:</p>\n<pre>// news.mint\n#base: layout.mint\n\n#def content():\n    #for item in news:\n        @a.href({{ url_for('news-item', id=item.id) }}) {{ news.title }}\n</pre>\n<p>It is simple and powerful concept.</p>\n<p>Slots are python functions, so they see all global variables passed to template and have\nown scope. This is very handy, because sometimes people have problems with such things\nin other templates engines.</p>\n<p>For example we need a block inside <tt>for</tt> loop:</p>\n<pre>// layout.mint\n@div.id(content)\n    #for item in items:\n        #loop_slot()\n\n// photos.mint\n#base: layout.mint\n\n#def loop_slot():\n    @p.class(title) {{ item.title }}\n    @img.alt().src({{ item.image.path }})\n</pre>\n<p>For <strong>mint</strong> this is natural behavior. And <tt>item</tt> is just global variable for\nslot <tt>loop_slot</tt>. But in this case it\u2019s better to provide <tt>item</tt> to slot\nexplicitly:</p>\n<pre>// layout.mint\n@div.id(content)\n    #for item in items:\n        #loop_slot(item)\n\n// photos.mint\n#base: layout.mint\n\n#def loop_slot(item):\n    @p.class(title) {{ item.title }}\n    @img.alt().src({{ item.image.path }})\n</pre>\n<p>Also we can call base slot inside overrided slot. In our case base slot will\npoint to slot with same name in our base template. <tt>__base__</tt> variable points\ninside current slot scope to implementation of current slot in parent template:</p>\n<pre>// base.mint\n-- somewhere in head tag\n#def js():\n    @script.type(text/javascript).src(/js/main.js)\n#js()\n\n\n// photos.mint\n#base: base.mint\n#def js():\n    #__base__()\n    @script.type(text/javascript).src(/js/photos.js)\n</pre>\n<p>This example will results in:</p>\n<pre>&lt;!-- somewhere in head tag --&gt;\n&lt;script type=\"text/javascript\" scr=\"/js/main.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" scr=\"/js/photos.js\"&gt;&lt;/script&gt;\n</pre>\n<p>Slots are plain python functions, slots returns <tt>Markup</tt> objects so we can pass slots\nor result of slot call to other slots.</p>\n<p>And more. We can use slots outside of templates. Lets take photos.mint from\nexample with <tt>for</tt> loop:</p>\n<pre>&gt;&gt;&gt; import mint\n&gt;&gt;&gt; t = mint.Loader('.').get_template('photos.mint')\n&gt;&gt;&gt; loop_slot = t.slot('loop_slot')\n&gt;&gt;&gt; # lets take image somewhere\n&gt;&gt;&gt; item = images.get(1)\n&gt;&gt;&gt; loop_slot(item)\nMarkup(u'&lt;p class=\"title\"&gt;...&lt;/p&gt;&lt;img alt=\"\" src=\"...\" /&gt;')\n</pre>\n<p>But sometimes slots needs global variables, you must provide such variables\nwith kwargs in method <tt>slot(name, **globals)</tt> of <tt>Template</tt> object.</p>\n</div>\n<div id=\"id12\">\n<span id=\"utils\"></span><h2>utils</h2>\n<p><strong>mint</strong> provides global variable <tt>utils</tt> which contains useful constants and helper\nfunctions.</p>\n<p>Doctype declarations</p>\n<ul>\n<li><tt>utils.doctype.html_strict</tt></li>\n<li><tt>utils.doctype.html_transitional</tt></li>\n<li><tt>utils.doctype.xhtml_strict</tt></li>\n<li><tt>utils.doctype.xhtml_transitional</tt></li>\n</ul>\n<p>Example of usage:</p>\n<pre>{{ utils.doctype.html_strict }}\n@html\n</pre>\n<p>Class <tt>mint.Markup</tt> is <tt>utils.markup</tt> (this is replacement for hack <tt>{{ var|safe }}</tt>)</p>\n<p><tt>utils.loop</tt> is helper function to use with <tt>for</tt> statement. It takes iterable\nobject and returns tuple of item and special object that consist of useful info for each\niteration:</p>\n<pre>#for item, l in utils.loop(items):\n    @a.href({{ item.url }})\n        {{ item.title }} {{ (l.first, l.last, l.odd) }} {{ l.cycle('one', 'two', 'three') }}\n</pre>\n<p>In previous example <tt><span class=\"pre\">l.cycle('one',</span> 'two', 'three')</tt> will return one of values provided\nin sequence. It is handy to colorize tables.</p>\n<p>Html helpers</p>\n<ul>\n<li><tt>utils.script</tt></li>\n<li><tt>utils.scripts</tt></li>\n<li><tt>utils.link</tt></li>\n</ul>\n</div>\n<div id=\"command-line-interface\">\n<span id=\"cli\"></span><h2>Command Line Interface</h2>\n<p><tt>mint</tt> has a CLI. To list available options use <tt><span class=\"pre\">--help</span></tt> flag:</p>\n<pre>% python -m mint --help\nUsage: mint.py [options] [template]\n\nOptions:\n  -h, --help        show this help message and exit\n  -c, --code        Show only python code of compiled template.\n  -t, --tokenize    Show tokens stream of template.\n  -r N, --repeat=N  Try to render template N times and display average time\n                    result.\n  -p, --pprint      Turn pretty print on.\n  -m, --monitor     Monitor current directory and subdirectories for changes\n                    in mint files. And render corresponding html files.\n</pre>\n<p>CLI works in two modes:</p>\n<ul>\n<li>rendering</li>\n<li>monitoring</li>\n</ul>\n<p>That\u2019s all folks!</p>\n</div>\n<div id=\"changelog\">\n<h2>changelog</h2>\n<div id=\"v0-5\">\n<h3>v0.5</h3>\n<ul>\n<li>Smart indent. Tokenizer sets <cite>indent level</cite> for whole template equal indent\nlevel of first indented line (as in python)</li>\n<li>Mint nodes now based on <cite>ast.AST</cite> and to transform <cite>mint</cite> tree to <cite>python</cite>\ntree we use <cite>ast.NodeTransformer</cite> subclass. This feature allows us write\ntransformers for other languages (js =)</li>\n<li>Added <cite>pretty printing</cite> of html result. Default indention is two spaces and\nis unchangable</li>\n<li>Updated vim highlight for mint files</li>\n<li>Added html helpers <cite>utils.script</cite>, <cite>utils.link</cite> and <cite>utils.scripts</cite></li>\n<li>New <cite>CLI</cite> interface. Some features<ul>\n<li>shows result python code listing for mint template</li>\n<li>shows tokens stream for mint template</li>\n<li>renders templates and prints result to stdout (note: if no outer variables\nused)</li>\n<li>measures average rendering time for template (note: if no outer variables\nused)</li>\n<li><cite>monitoring</cite> feature</li>\n</ul>\n</li>\n<li>Fixes</li>\n</ul>\n</div>\n<div id=\"v0-4-4\">\n<h3>v0.4.4</h3>\n<p>Working implementation</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 794828, "releases": {"0.5": [{"comment_text": "", "digests": {"md5": "516f9a5233f6ce45350959acc7bfae57", "sha256": "30df771d00852c041d80a863b5ab2c331fb97748807611c40ae0db71a7ef2d2c"}, "downloads": -1, "filename": "mint-0.5.tar.gz", "has_sig": false, "md5_digest": "516f9a5233f6ce45350959acc7bfae57", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20484, "upload_time": "2011-08-02T12:47:47", "upload_time_iso_8601": "2011-08-02T12:47:47.470968Z", "url": "https://files.pythonhosted.org/packages/96/a1/9a1ad38ad36c38a3cdd4ffdfb945af099d278daf32533b12875d3736b3c8/mint-0.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "516f9a5233f6ce45350959acc7bfae57", "sha256": "30df771d00852c041d80a863b5ab2c331fb97748807611c40ae0db71a7ef2d2c"}, "downloads": -1, "filename": "mint-0.5.tar.gz", "has_sig": false, "md5_digest": "516f9a5233f6ce45350959acc7bfae57", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20484, "upload_time": "2011-08-02T12:47:47", "upload_time_iso_8601": "2011-08-02T12:47:47.470968Z", "url": "https://files.pythonhosted.org/packages/96/a1/9a1ad38ad36c38a3cdd4ffdfb945af099d278daf32533b12875d3736b3c8/mint-0.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:54:13 2020"}