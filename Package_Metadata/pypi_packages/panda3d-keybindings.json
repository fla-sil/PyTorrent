{"info": {"author": "TheCheapestPixels", "author_email": "TheCheapestPixels@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "panda3d-keybindings\n===================\n\nPanda3D comes with a nice API suite to work with input devices. In\nparticular, it has one for USB HIDs, and one for mouse and keyboard.\nWhat it does not have is a mechanism to build an abstraction over these\ndevices, so that a developer can define them in terms of a set of\nbuttons and axes, and it is a matter of configuration how actual inputs\non devices are mapped to those abstract inputs. A game's logic should\nnot be concerned with details like...\n\n* whether a 2D axis gets its values from a gamepad's stick or its four\n  buttons, from WASD, or a dance pad.\n* how the player wants the inputs from the devices combined. There may\n  be a different list of priorities for different abstract inputs with\n  regard what devices should be checked. A player may prefer to cotrol\n  character movement on a gamepad, but functions like invoking and\n  working in menus with the keyboard.\n* how input is preprocessed. Badly manufactured sticks create noise near\n  the center, and may require a dead zone. An axis' amplitude may need\n  to be scaled or squared.\n* devices connecting or disconnecting. From a game developer's\n  perspective, these events should be dealt with under the hood.\n* how devices are identified. A player may use two flight sticks for a\n  space simulator. If they're of different makes, they can be identified\n  \"uniquely\", and should be mappable independent of one another. Even\n  with two identical sticks, there should be a way to check which is\n  which (\"Press trigger on left stick\"), and label them accordingly.\n  NOTE: Not implemented yes.\n* providing an interface to work with the mappings. NOTE: Completely\n  inexistent so far.\n* if the state, when polled at different times during a frame, is still\n  the same; It just should be. This is quite an edge case, but may cause\n  hard to reproduce bugs. NOTE: Currently only very partially\n  implemented, but the difference between that and the current version\n  is, after all, only relevant for that edge case.\n\n\nStatus\n------\n\nThis project's state is alpha. The polling interface works quite well and is feature-rich.\n\n\nInstallation\n------------\n\n`pip install panda3d-keybindings`\n\n\nConcepts\n--------\n\n* A `virtual input` a button or axis (or other) with a semantic to the\n  game. It has\n  * a type, which is one of\n    * `button`: `True` if the button is pressed, `False` otherwise.\n    * `trigger`: `True` for the frame in which the button is pressed.\n    * `axis`: A `float`.\n    * `axis2d`: `panda3d.core.Vec2`.\n    * `axis3d`: `panda3d.core.Vec3`.\n  * a device order, stating the highest priority to the lowest to check\n    for presence and state when reading a context.\n  * a sensor definition for each usable device. This defines the\n    buttons / axes used, and specifies post-processing that is to be\n    done on them.\n* A `context` is a set of `virtual input`s that is read together. It is\n  an organizational unit to make it easy for the application to activate\n  or deactivate parts of the user input interface. For example, opening\n  the game's ingame menu may activate the `menu` context, and deactivate\n  the `character_movement` one.\n* When a device is connected, it is assigned to a `player`, or kept\n  unassigned for the time being. Players will only be able to read data\n  from devices assigned to them.\n  NOTE: Currently only single-player assigners exist off-the-shelf.\n* There's a TOML file that defines for each `player` and each `context`\n  in what order to check devices for a `virtual input`. If the first\n  enumerated device isn't assigned to the `player`, the next one will be\n  checked, and so on, until one is found that can be read.\n  NOTE: Currently no concept of players exists in the config file.\n  * Each entry should contain filterable data like device type, device\n    ID, etc.\n    NOTE: Utterly unimplemented.\n\n\nExample\n-------\n\nSetting up an application for use with this module is easy:\n\n    from direct.showbase.ShowBase import ShowBase\n    from keybindings.device_listener import add_device_listener\n    from keybindings.device_listener import SinglePlayerAssigner\n\n    ShowBase()\n    add_device_listener(\n        config_file='keybindings.toml',\n        assigner=SinglePlayerAssigner(),\n    )\n\nNow there is a `base.device_listener`.\n\nA keybinding configuration could look like this:\n\n    [demo_context]\n\n      [demo_context.demo_button]\n      _type = \"button\"\n      _device_order = [\"gamepad\", \"flight_stick\", \"keyboard\"]\n      gamepad = \"face_a\"\n      flight_stick = \"trigger\"\n      keyboard = \"q\"\n\n\nWhen the context `demo_context` is read, ...\n\n    base.device_listener.read_context('demo_context')\n\n...the result may look like this:\n\n    {'demo_button': False}\n\nThis means that due to the config snippet above, the device listener has\nchecked whether a gamepad is connected; If so, the state of `face_a` is used, if not, the `flight_stick` is tested next, and so on. In this example, a device has been found and the button has not been pressed.\n\nIf no device type is found to be connected, the returned state would be `None`. Do note that if a keyboard is listed as a possible option, it will be assumed to be present.\n\n\nTODO\n----\n\n* Document sensor definitions\n  'a', 'left_x,left_y', 'left_x:flip,left_y', 'mouse_pos_delta'\n* Sphinx documentation\n* Multi-user Assigner\n* Throw events\n* Freeze whole state each frame (currently only done for `mouse_*`)\n* Upgrade example\n* Add subconsoles for panda3d-cefconsole\n  * Configure keybindings\n  * Reassign devices\n* `setup.py`: Go over `packages=` again.\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/TheCheapestPixels/panda3d-keybindings", "keywords": "panda3d keybinding keybindings keymapping", "license": "", "maintainer": "", "maintainer_email": "", "name": "panda3d-keybindings", "package_url": "https://pypi.org/project/panda3d-keybindings/", "platform": "", "project_url": "https://pypi.org/project/panda3d-keybindings/", "project_urls": {"Homepage": "https://github.com/TheCheapestPixels/panda3d-keybindings"}, "release_url": "https://pypi.org/project/panda3d-keybindings/0.0.6b0/", "requires_dist": ["panda3d", "toml"], "requires_python": ">=3.5, <4.*", "summary": "A more abstract interface for using input devices in Panda3D.", "version": "0.0.6b0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>panda3d-keybindings</h1>\n<p>Panda3D comes with a nice API suite to work with input devices. In\nparticular, it has one for USB HIDs, and one for mouse and keyboard.\nWhat it does not have is a mechanism to build an abstraction over these\ndevices, so that a developer can define them in terms of a set of\nbuttons and axes, and it is a matter of configuration how actual inputs\non devices are mapped to those abstract inputs. A game's logic should\nnot be concerned with details like...</p>\n<ul>\n<li>whether a 2D axis gets its values from a gamepad's stick or its four\nbuttons, from WASD, or a dance pad.</li>\n<li>how the player wants the inputs from the devices combined. There may\nbe a different list of priorities for different abstract inputs with\nregard what devices should be checked. A player may prefer to cotrol\ncharacter movement on a gamepad, but functions like invoking and\nworking in menus with the keyboard.</li>\n<li>how input is preprocessed. Badly manufactured sticks create noise near\nthe center, and may require a dead zone. An axis' amplitude may need\nto be scaled or squared.</li>\n<li>devices connecting or disconnecting. From a game developer's\nperspective, these events should be dealt with under the hood.</li>\n<li>how devices are identified. A player may use two flight sticks for a\nspace simulator. If they're of different makes, they can be identified\n\"uniquely\", and should be mappable independent of one another. Even\nwith two identical sticks, there should be a way to check which is\nwhich (\"Press trigger on left stick\"), and label them accordingly.\nNOTE: Not implemented yes.</li>\n<li>providing an interface to work with the mappings. NOTE: Completely\ninexistent so far.</li>\n<li>if the state, when polled at different times during a frame, is still\nthe same; It just should be. This is quite an edge case, but may cause\nhard to reproduce bugs. NOTE: Currently only very partially\nimplemented, but the difference between that and the current version\nis, after all, only relevant for that edge case.</li>\n</ul>\n<h2>Status</h2>\n<p>This project's state is alpha. The polling interface works quite well and is feature-rich.</p>\n<h2>Installation</h2>\n<p><code>pip install panda3d-keybindings</code></p>\n<h2>Concepts</h2>\n<ul>\n<li>A <code>virtual input</code> a button or axis (or other) with a semantic to the\ngame. It has\n<ul>\n<li>a type, which is one of\n<ul>\n<li><code>button</code>: <code>True</code> if the button is pressed, <code>False</code> otherwise.</li>\n<li><code>trigger</code>: <code>True</code> for the frame in which the button is pressed.</li>\n<li><code>axis</code>: A <code>float</code>.</li>\n<li><code>axis2d</code>: <code>panda3d.core.Vec2</code>.</li>\n<li><code>axis3d</code>: <code>panda3d.core.Vec3</code>.</li>\n</ul>\n</li>\n<li>a device order, stating the highest priority to the lowest to check\nfor presence and state when reading a context.</li>\n<li>a sensor definition for each usable device. This defines the\nbuttons / axes used, and specifies post-processing that is to be\ndone on them.</li>\n</ul>\n</li>\n<li>A <code>context</code> is a set of <code>virtual input</code>s that is read together. It is\nan organizational unit to make it easy for the application to activate\nor deactivate parts of the user input interface. For example, opening\nthe game's ingame menu may activate the <code>menu</code> context, and deactivate\nthe <code>character_movement</code> one.</li>\n<li>When a device is connected, it is assigned to a <code>player</code>, or kept\nunassigned for the time being. Players will only be able to read data\nfrom devices assigned to them.\nNOTE: Currently only single-player assigners exist off-the-shelf.</li>\n<li>There's a TOML file that defines for each <code>player</code> and each <code>context</code>\nin what order to check devices for a <code>virtual input</code>. If the first\nenumerated device isn't assigned to the <code>player</code>, the next one will be\nchecked, and so on, until one is found that can be read.\nNOTE: Currently no concept of players exists in the config file.\n<ul>\n<li>Each entry should contain filterable data like device type, device\nID, etc.\nNOTE: Utterly unimplemented.</li>\n</ul>\n</li>\n</ul>\n<h2>Example</h2>\n<p>Setting up an application for use with this module is easy:</p>\n<pre><code>from direct.showbase.ShowBase import ShowBase\nfrom keybindings.device_listener import add_device_listener\nfrom keybindings.device_listener import SinglePlayerAssigner\n\nShowBase()\nadd_device_listener(\n    config_file='keybindings.toml',\n    assigner=SinglePlayerAssigner(),\n)\n</code></pre>\n<p>Now there is a <code>base.device_listener</code>.</p>\n<p>A keybinding configuration could look like this:</p>\n<pre><code>[demo_context]\n\n  [demo_context.demo_button]\n  _type = \"button\"\n  _device_order = [\"gamepad\", \"flight_stick\", \"keyboard\"]\n  gamepad = \"face_a\"\n  flight_stick = \"trigger\"\n  keyboard = \"q\"\n</code></pre>\n<p>When the context <code>demo_context</code> is read, ...</p>\n<pre><code>base.device_listener.read_context('demo_context')\n</code></pre>\n<p>...the result may look like this:</p>\n<pre><code>{'demo_button': False}\n</code></pre>\n<p>This means that due to the config snippet above, the device listener has\nchecked whether a gamepad is connected; If so, the state of <code>face_a</code> is used, if not, the <code>flight_stick</code> is tested next, and so on. In this example, a device has been found and the button has not been pressed.</p>\n<p>If no device type is found to be connected, the returned state would be <code>None</code>. Do note that if a keyboard is listed as a possible option, it will be assumed to be present.</p>\n<h2>TODO</h2>\n<ul>\n<li>Document sensor definitions\n'a', 'left_x,left_y', 'left_x:flip,left_y', 'mouse_pos_delta'</li>\n<li>Sphinx documentation</li>\n<li>Multi-user Assigner</li>\n<li>Throw events</li>\n<li>Freeze whole state each frame (currently only done for <code>mouse_*</code>)</li>\n<li>Upgrade example</li>\n<li>Add subconsoles for panda3d-cefconsole\n<ul>\n<li>Configure keybindings</li>\n<li>Reassign devices</li>\n</ul>\n</li>\n<li><code>setup.py</code>: Go over <code>packages=</code> again.</li>\n</ul>\n\n          </div>"}, "last_serial": 6599537, "releases": {"0.0.1b0": [{"comment_text": "", "digests": {"md5": "a6aa8022cb5929a3f9615d16422e025b", "sha256": "ac18e1bdd6814ba30952a37400d30370048b2bb33609ff7e1ee509799b424533"}, "downloads": -1, "filename": "panda3d_keybindings-0.0.1b0-py3-none-any.whl", "has_sig": false, "md5_digest": "a6aa8022cb5929a3f9615d16422e025b", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5, <3.8.*", "size": 4789, "upload_time": "2020-01-31T23:17:19", "upload_time_iso_8601": "2020-01-31T23:17:19.146989Z", "url": "https://files.pythonhosted.org/packages/91/94/82f80ba1ce5717daabf0df9ed102c3697ffc8ae53d6bdaa5491451f457f3/panda3d_keybindings-0.0.1b0-py3-none-any.whl", "yanked": false}], "0.0.2b0": [{"comment_text": "", "digests": {"md5": "372538ea1aaca6434f71a2b9741c7efe", "sha256": "f605240cc888e8dead16042cc00b6fb355951f440c42b9e7bc9c2d0e950ceac6"}, "downloads": -1, "filename": "panda3d_keybindings-0.0.2b0-py3-none-any.whl", "has_sig": false, "md5_digest": "372538ea1aaca6434f71a2b9741c7efe", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5, <3.8.*", "size": 4789, "upload_time": "2020-02-06T16:31:07", "upload_time_iso_8601": "2020-02-06T16:31:07.732727Z", "url": "https://files.pythonhosted.org/packages/52/bd/526d3b3eecbd26d8b3c1665476e7b0009acd8b890a33393f30fc4594603c/panda3d_keybindings-0.0.2b0-py3-none-any.whl", "yanked": false}], "0.0.3b0": [{"comment_text": "", "digests": {"md5": "0a69a6d4e97383664f098e2f0e4fda04", "sha256": "da6b46fdfe88021515e7acee09f50d4305125b16f1411d7359b9fc42ac94d7ec"}, "downloads": -1, "filename": "panda3d_keybindings-0.0.3b0-py3-none-any.whl", "has_sig": false, "md5_digest": "0a69a6d4e97383664f098e2f0e4fda04", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5, <3.8.*", "size": 4787, "upload_time": "2020-02-07T17:18:21", "upload_time_iso_8601": "2020-02-07T17:18:21.646792Z", "url": "https://files.pythonhosted.org/packages/f2/f7/bccb41a0f4c576dacf64903ca205b16b183e1c4824be79c0db275406f29e/panda3d_keybindings-0.0.3b0-py3-none-any.whl", "yanked": false}], "0.0.4b0": [{"comment_text": "", "digests": {"md5": "5a2400eea6b28859ca97ecaf1a2b759a", "sha256": "f6d1c44976c7a1079672966ff94ec10b7436c14de07b560d80dac335a63c729e"}, "downloads": -1, "filename": "panda3d_keybindings-0.0.4b0-py3-none-any.whl", "has_sig": false, "md5_digest": "5a2400eea6b28859ca97ecaf1a2b759a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5, <4.*", "size": 7933, "upload_time": "2020-02-09T23:05:04", "upload_time_iso_8601": "2020-02-09T23:05:04.416444Z", "url": "https://files.pythonhosted.org/packages/4e/03/b4f052842f1a9e5849beeb4ab83d3f9bbd576ed93bb240bd94475fa1d7b4/panda3d_keybindings-0.0.4b0-py3-none-any.whl", "yanked": false}], "0.0.5b0": [{"comment_text": "", "digests": {"md5": "57a30b183dad9e979e0c4ba66311cf5e", "sha256": "f2803297375dcc8be30eac385e9c1fe642b0be3fb9aaba8696e31e4040a77ff4"}, "downloads": -1, "filename": "panda3d_keybindings-0.0.5b0-py3-none-any.whl", "has_sig": false, "md5_digest": "57a30b183dad9e979e0c4ba66311cf5e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5, <4.*", "size": 11076, "upload_time": "2020-02-09T23:24:16", "upload_time_iso_8601": "2020-02-09T23:24:16.887948Z", "url": "https://files.pythonhosted.org/packages/50/4e/66026333a8450ac2f2fc5b59512c285e6b1b52a9118831c93dacd3b4aa04/panda3d_keybindings-0.0.5b0-py3-none-any.whl", "yanked": false}], "0.0.6b0": [{"comment_text": "", "digests": {"md5": "61263aa03a2a3e63f9b2342c6d1fe53c", "sha256": "a1d3ba6bb4cd05b677a32c9b41e05b8f2c27db1deed7edacecc89f977f9ef85d"}, "downloads": -1, "filename": "panda3d_keybindings-0.0.6b0-py3-none-any.whl", "has_sig": false, "md5_digest": "61263aa03a2a3e63f9b2342c6d1fe53c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5, <4.*", "size": 11082, "upload_time": "2020-02-09T23:30:18", "upload_time_iso_8601": "2020-02-09T23:30:18.796961Z", "url": "https://files.pythonhosted.org/packages/d1/4d/90ab73d67789f2cb7d4be6a3cfd5dc10ab08d65cbe46509448e8e125f438/panda3d_keybindings-0.0.6b0-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "61263aa03a2a3e63f9b2342c6d1fe53c", "sha256": "a1d3ba6bb4cd05b677a32c9b41e05b8f2c27db1deed7edacecc89f977f9ef85d"}, "downloads": -1, "filename": "panda3d_keybindings-0.0.6b0-py3-none-any.whl", "has_sig": false, "md5_digest": "61263aa03a2a3e63f9b2342c6d1fe53c", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5, <4.*", "size": 11082, "upload_time": "2020-02-09T23:30:18", "upload_time_iso_8601": "2020-02-09T23:30:18.796961Z", "url": "https://files.pythonhosted.org/packages/d1/4d/90ab73d67789f2cb7d4be6a3cfd5dc10ab08d65cbe46509448e8e125f438/panda3d_keybindings-0.0.6b0-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 02:59:39 2020"}