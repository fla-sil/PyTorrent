{"info": {"author": "Avinash Sajjanshetty", "author_email": "hi@avi.im", "bugtrack_url": null, "classifiers": ["Development Status :: 6 - Mature", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Natural Language :: English", "Operating System :: OS Independent", "Operating System :: POSIX", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Topic :: Internet", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Utilities"], "description": "# status - HTTP Status for Humans\n\n[![version](https://img.shields.io/pypi/v/python-status.svg)](https://pypi.python.org/pypi/python-status/)\n[![supported](https://img.shields.io/pypi/pyversions/python-status.svg)](https://pypi.python.org/pypi/python-status/)\n![license](https://img.shields.io/pypi/l/python-status.svg)\n\n`status` is a very simple python library which provides human understandable HTTP status codes and improves readability of your code. You don't have to use those ugly HTTP status numbers, but use easily understandable status names.\n\nDon't:\n\n    class PythonPeople(RequestHandler):\n        def post(self):\n            # do stuff\n            return ('That worked!', 201)\n\nBut, do this:\n\n    class PythonPeople(RequestHandler):\n        def post(self):\n            # do stuff\n            return ('That worked!', status.HTTP_201_CREATED)\n\n\nSee, that looks so much better. You can use this library wherever you want, from custom python scripts to Django, Flask etc apps. For example, if you were playing with [Requests](http://python-requests.org):\n\n    >>> response = requests.delete('http://some-url')\n    >>> response.status_code == status.HTTP_204_NO_CONTENT\n\n\n## Installation\n\n    pip install python-status\n\n\n## Usage\n\n`status` comes with HTTP response status codes and also some helpful methods to check the response status. Under the hood, status codes are merely an integer variable with meaningful variable names. Check `status.py` file.\n\n    >>> import status\n    >>> status.HTTP_200_OK == 200\n    True\n\nFor list of available status codes check `status.py` file.\n\n`status` also comes with some helpful methods to check the status of a response. They are `status.is_informational`, `status.is_success`, `status.is_redirect`, `status.is_client_error` and `status.is_server_error`.\n\n    >>> import status\n    >>> response = requests.delete('http://some-url')\n    >>> if status.is_success(code=response.status_code):\n            print('yay!')\n    >>> \n    yay!\n\n\n# Why?\n\nFor every project I was creating a `status.py` file in the root directory. So I thought it's better to release this as a package on PyPi and use it.\n\n\n# License\n\nPlease check `LICENSE` for more details.\n\n\n# Credits\n\n`status` is a fork of [Django Rest Framework](https://github.com/tomchristie/django-rest-framework)(DRF) and is independently maintained. The fork is entirely stripped of all DRF features and is not a submodule of DRF. And it doesn't come with any DRF functionalities.", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/avinassh/status/", "keywords": null, "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "python-status", "package_url": "https://pypi.org/project/python-status/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/python-status/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/avinassh/status/"}, "release_url": "https://pypi.org/project/python-status/1.0.1/", "requires_dist": null, "requires_python": null, "summary": "HTTP Status for Humans", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p># status - HTTP Status for Humans</p>\n<p>[![version](<a href=\"https://img.shields.io/pypi/v/python-status.svg)%5D(https://pypi.python.org/pypi/python-status/\" rel=\"nofollow\">https://img.shields.io/pypi/v/python-status.svg)](https://pypi.python.org/pypi/python-status/</a>)\n[![supported](<a href=\"https://img.shields.io/pypi/pyversions/python-status.svg)%5D(https://pypi.python.org/pypi/python-status/\" rel=\"nofollow\">https://img.shields.io/pypi/pyversions/python-status.svg)](https://pypi.python.org/pypi/python-status/</a>)\n![license](<a href=\"https://img.shields.io/pypi/l/python-status.svg\" rel=\"nofollow\">https://img.shields.io/pypi/l/python-status.svg</a>)</p>\n<p><cite>status</cite> is a very simple python library which provides human understandable HTTP status codes and improves readability of your code. You don\u2019t have to use those ugly HTTP status numbers, but use easily understandable status names.</p>\n<p>Don\u2019t:</p>\n<blockquote>\n<dl>\n<dt>class PythonPeople(RequestHandler):</dt>\n<dd><dl>\n<dt>def post(self):</dt>\n<dd># do stuff\nreturn (\u2018That worked!\u2019, 201)</dd>\n</dl>\n</dd>\n</dl>\n</blockquote>\n<p>But, do this:</p>\n<blockquote>\n<dl>\n<dt>class PythonPeople(RequestHandler):</dt>\n<dd><dl>\n<dt>def post(self):</dt>\n<dd># do stuff\nreturn (\u2018That worked!\u2019, status.HTTP_201_CREATED)</dd>\n</dl>\n</dd>\n</dl>\n</blockquote>\n<p>See, that looks so much better. You can use this library wherever you want, from custom python scripts to Django, Flask etc apps. For example, if you were playing with [Requests](<a href=\"http://python-requests.org\" rel=\"nofollow\">http://python-requests.org</a>):</p>\n<blockquote>\n<pre>&gt;&gt;&gt; response = requests.delete('http://some-url')\n&gt;&gt;&gt; response.status_code == status.HTTP_204_NO_CONTENT\n</pre>\n</blockquote>\n<p>## Installation</p>\n<blockquote>\npip install python-status</blockquote>\n<p>## Usage</p>\n<p><cite>status</cite> comes with HTTP response status codes and also some helpful methods to check the response status. Under the hood, status codes are merely an integer variable with meaningful variable names. Check <cite>status.py</cite> file.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import status\n&gt;&gt;&gt; status.HTTP_200_OK == 200\nTrue\n</pre>\n</blockquote>\n<p>For list of available status codes check <cite>status.py</cite> file.</p>\n<p><cite>status</cite> also comes with some helpful methods to check the status of a response. They are <cite>status.is_informational</cite>, <cite>status.is_success</cite>, <cite>status.is_redirect</cite>, <cite>status.is_client_error</cite> and <cite>status.is_server_error</cite>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import status\n&gt;&gt;&gt; response = requests.delete('http://some-url')\n&gt;&gt;&gt; if status.is_success(code=response.status_code):\n        print('yay!')\n&gt;&gt;&gt;\nyay!\n</pre>\n</blockquote>\n<p># Why?</p>\n<p>For every project I was creating a <cite>status.py</cite> file in the root directory. So I thought it\u2019s better to release this as a package on PyPi and use it.</p>\n<p># License</p>\n<p>Please check <cite>LICENSE</cite> for more details.</p>\n<p># Credits</p>\n<p><cite>status</cite> is a fork of [Django Rest Framework](<a href=\"https://github.com/tomchristie/django-rest-framework)(DRF\" rel=\"nofollow\">https://github.com/tomchristie/django-rest-framework)(DRF</a>) and is independently maintained. The fork is entirely stripped of all DRF features and is not a submodule of DRF. And it doesn\u2019t come with any DRF functionalities.</p>\n\n          </div>"}, "last_serial": 1773013, "releases": {"1.0.1": [{"comment_text": "", "digests": {"md5": "bf4306919bfb0f6e180fb9b1742f3b1c", "sha256": "4e9c824754e3669a4a6565fd4c3d6c0dd4130e779c541ad168e71110ebce3e53"}, "downloads": -1, "filename": "python-status-1.0.1.tar.gz", "has_sig": false, "md5_digest": "bf4306919bfb0f6e180fb9b1742f3b1c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3811, "upload_time": "2015-10-17T13:50:12", "upload_time_iso_8601": "2015-10-17T13:50:12.411007Z", "url": "https://files.pythonhosted.org/packages/fc/9d/c008b9ade09984a6b5cecce7a4f113b4fbda11a7ccace34770085cb8fd12/python-status-1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bf4306919bfb0f6e180fb9b1742f3b1c", "sha256": "4e9c824754e3669a4a6565fd4c3d6c0dd4130e779c541ad168e71110ebce3e53"}, "downloads": -1, "filename": "python-status-1.0.1.tar.gz", "has_sig": false, "md5_digest": "bf4306919bfb0f6e180fb9b1742f3b1c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3811, "upload_time": "2015-10-17T13:50:12", "upload_time_iso_8601": "2015-10-17T13:50:12.411007Z", "url": "https://files.pythonhosted.org/packages/fc/9d/c008b9ade09984a6b5cecce7a4f113b4fbda11a7ccace34770085cb8fd12/python-status-1.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:15:12 2020"}