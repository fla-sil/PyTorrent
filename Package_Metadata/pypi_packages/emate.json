{"info": {"author": "Bruno Messias; Thomas K Peron", "author_email": "messias.physics@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Science/Research", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering :: Information Analysis", "Topic :: Scientific/Engineering :: Mathematics", "Topic :: Scientific/Engineering :: Physics"], "description": "# ![eMaTe](emate.png)\n\neMaTe is a python package implemented in tensorflow which the main goal is provide useful methods capable of estimate spectral densities and trace functions of large sparse matrices. \n\n## Install                                                                                                              \n```\npip install emate\n```\n\n## Kernel Polynomial Method (KPM)\n\nThe Kernel Polynomial Method can\u00a0estimate the spectral density of large sparse Hermitan matrices with a computational cost almost linear. This method combines three key ingredients: the Chebyshev expansion + the stochastic trace estimator + kernel smoothing.\n\n\n### Example\n\n```python\nimport igraph as ig\nimport numpy as np\n\nN = 3000\nG = ig.Graph.Erdos_Renyi(N, 3/N)\n\nW = np.array(G.get_adjacency().data, dtype=np.float64)\nvals = np.linalg.eigvalsh(W).real\n```\n\n```python\nfrom emate.hermitian import pykpm\nfrom stdog.utils.misc import ig2sparse \n\nW = ig2sparse(G)\n\nnum_moments = 300\nnum_vecs = 200\nextra_points = 10\nek, rho = pykpm(W, num_moments, num_vecs, extra_points)\n```\n\n```python\nimport matplotlib.pyplot as plt\nplt.hist(vals, density=True, bins=100, alpha=.9, color=\"steelblue\")\nplt.scatter(ek, rho, c=\"tomato\", zorder=999, alpha=0.9, marker=\"d\")\n\n```\n\n![](docs/source/imgs/kpm.png)\n\n## Stochastic Lanczos Quadrature (SLQ)\n\n\n>The problem of estimating the trace of matrix functions appears in applications ranging from machine learning and scientific computing, to computational biology.[2] \n\n### Example\n\n#### Computing the Estrada index\n\n```python\nfrom emate.symmetric.slq import pyslq\nimport tensorflow as tf\n\ndef trace_function(eig_vals):\n    return tf.exp(eig_vals)\n\nnum_vecs = 100\nnum_steps = 50\napproximated_estrada_index, _ = pyslq(L_sparse, num_vecs, num_steps,  trace_function)\nexact_estrada_index =  np.sum(np.exp(vals_laplacian))\napproximated_estrada_index, exact_estrada_index\n```\nThe above code returns\n\n```\n(3058.012, 3063.16457163222)\n```\n#### Entropy\n```python\nimport scipy\nimport scipy.sparse\n\ndef entropy(eig_vals):\n  s = 0.\n  for val in eig_vals:\n    if val > 0:\n      s += -val*np.log(val)\n  return s\n\nL = np.array(G.laplacian(normalized=True), dtype=np.float64)\nvals_laplacian = np.linalg.eigvalsh(L).real\n\nexact_entropy =  entropy(vals_laplacian)\n\n\ndef trace_function(eig_vals):\n  def entropy(val):\n    return tf.cond(val>0, lambda:-val*tf.log(val), lambda: 0.)\n  \n  return tf.map_fn(entropy, eig_vals)\n \nL_sparse = scipy.sparse.coo_matrix(L)\n    \nnum_vecs = 100\nnum_steps = 50\napproximated_entropy, _ = pyslq(L_sparse, num_vecs, num_steps,  trace_function)\n\napproximated_entropy, exact_entropy\n```\n```\n(-509.46283, -512.5283224633046)\n```\n[[1] Hutchinson, M. F. (1990). A stochastic estimator of the trace of the influence matrix for laplacian smoothing splines. Communications in Statistics-Simulation and Computation, 19(2), 433-450.](https://www.tandfonline.com/doi/abs/10.1080/03610919008812866)\n\n[[2] Ubaru, S., Chen, J., & Saad, Y. (2017). Fast Estimation of tr(f(A)) via Stochastic Lanczos Quadrature. SIAM Journal on Matrix Analysis and Applications, 38(4), 1075-1099.](https://epubs.siam.org/doi/abs/10.1137/16M1104974)\n\n\n## Acknowledgements\n\nThis work has been supported also by FAPESP grants  11/50761-2  and  2015/22308-2.   Research  carriedout using the computational resources of the Center forMathematical  Sciences  Applied  to  Industry  (CeMEAI)funded by FAPESP (grant 2013/07375-0).", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/stdogpkg/emate/archive/v1.0.3.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/stdogpkg/emate", "keywords": "gpu,science,complex-networks,graphs,matrices,kpm,tensorflow,chebyshev,spectral,eigenvalues", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "emate", "package_url": "https://pypi.org/project/emate/", "platform": "", "project_url": "https://pypi.org/project/emate/", "project_urls": {"Download": "https://github.com/stdogpkg/emate/archive/v1.0.3.tar.gz", "Homepage": "https://github.com/stdogpkg/emate"}, "release_url": "https://pypi.org/project/emate/1.0.3/", "requires_dist": null, "requires_python": "", "summary": "", "version": "1.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1><img alt=\"eMaTe\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4763f40536d3c9e30f0d11f7a3e4591b2de1f288/656d6174652e706e67\"></h1>\n<p>eMaTe is a python package implemented in tensorflow which the main goal is provide useful methods capable of estimate spectral densities and trace functions of large sparse matrices.</p>\n<h2>Install</h2>\n<pre><code>pip install emate\n</code></pre>\n<h2>Kernel Polynomial Method (KPM)</h2>\n<p>The Kernel Polynomial Method can\u00a0estimate the spectral density of large sparse Hermitan matrices with a computational cost almost linear. This method combines three key ingredients: the Chebyshev expansion + the stochastic trace estimator + kernel smoothing.</p>\n<h3>Example</h3>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">igraph</span> <span class=\"k\">as</span> <span class=\"nn\">ig</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"mi\">3000</span>\n<span class=\"n\">G</span> <span class=\"o\">=</span> <span class=\"n\">ig</span><span class=\"o\">.</span><span class=\"n\">Graph</span><span class=\"o\">.</span><span class=\"n\">Erdos_Renyi</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"o\">/</span><span class=\"n\">N</span><span class=\"p\">)</span>\n\n<span class=\"n\">W</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">get_adjacency</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">)</span>\n<span class=\"n\">vals</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linalg</span><span class=\"o\">.</span><span class=\"n\">eigvalsh</span><span class=\"p\">(</span><span class=\"n\">W</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">real</span>\n</pre>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">emate.hermitian</span> <span class=\"kn\">import</span> <span class=\"n\">pykpm</span>\n<span class=\"kn\">from</span> <span class=\"nn\">stdog.utils.misc</span> <span class=\"kn\">import</span> <span class=\"n\">ig2sparse</span> \n\n<span class=\"n\">W</span> <span class=\"o\">=</span> <span class=\"n\">ig2sparse</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">)</span>\n\n<span class=\"n\">num_moments</span> <span class=\"o\">=</span> <span class=\"mi\">300</span>\n<span class=\"n\">num_vecs</span> <span class=\"o\">=</span> <span class=\"mi\">200</span>\n<span class=\"n\">extra_points</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"n\">ek</span><span class=\"p\">,</span> <span class=\"n\">rho</span> <span class=\"o\">=</span> <span class=\"n\">pykpm</span><span class=\"p\">(</span><span class=\"n\">W</span><span class=\"p\">,</span> <span class=\"n\">num_moments</span><span class=\"p\">,</span> <span class=\"n\">num_vecs</span><span class=\"p\">,</span> <span class=\"n\">extra_points</span><span class=\"p\">)</span>\n</pre>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">hist</span><span class=\"p\">(</span><span class=\"n\">vals</span><span class=\"p\">,</span> <span class=\"n\">density</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">bins</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=.</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"s2\">\"steelblue\"</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">scatter</span><span class=\"p\">(</span><span class=\"n\">ek</span><span class=\"p\">,</span> <span class=\"n\">rho</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"s2\">\"tomato\"</span><span class=\"p\">,</span> <span class=\"n\">zorder</span><span class=\"o\">=</span><span class=\"mi\">999</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.9</span><span class=\"p\">,</span> <span class=\"n\">marker</span><span class=\"o\">=</span><span class=\"s2\">\"d\"</span><span class=\"p\">)</span>\n</pre>\n<p><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7aeaa11757f319bd490ef08e6cb87a632ff0b01f/646f63732f736f757263652f696d67732f6b706d2e706e67\"></p>\n<h2>Stochastic Lanczos Quadrature (SLQ)</h2>\n<blockquote>\n<p>The problem of estimating the trace of matrix functions appears in applications ranging from machine learning and scientific computing, to computational biology.[2]</p>\n</blockquote>\n<h3>Example</h3>\n<h4>Computing the Estrada index</h4>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">emate.symmetric.slq</span> <span class=\"kn\">import</span> <span class=\"n\">pyslq</span>\n<span class=\"kn\">import</span> <span class=\"nn\">tensorflow</span> <span class=\"k\">as</span> <span class=\"nn\">tf</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">trace_function</span><span class=\"p\">(</span><span class=\"n\">eig_vals</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">eig_vals</span><span class=\"p\">)</span>\n\n<span class=\"n\">num_vecs</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>\n<span class=\"n\">num_steps</span> <span class=\"o\">=</span> <span class=\"mi\">50</span>\n<span class=\"n\">approximated_estrada_index</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">pyslq</span><span class=\"p\">(</span><span class=\"n\">L_sparse</span><span class=\"p\">,</span> <span class=\"n\">num_vecs</span><span class=\"p\">,</span> <span class=\"n\">num_steps</span><span class=\"p\">,</span>  <span class=\"n\">trace_function</span><span class=\"p\">)</span>\n<span class=\"n\">exact_estrada_index</span> <span class=\"o\">=</span>  <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">exp</span><span class=\"p\">(</span><span class=\"n\">vals_laplacian</span><span class=\"p\">))</span>\n<span class=\"n\">approximated_estrada_index</span><span class=\"p\">,</span> <span class=\"n\">exact_estrada_index</span>\n</pre>\n<p>The above code returns</p>\n<pre><code>(3058.012, 3063.16457163222)\n</code></pre>\n<h4>Entropy</h4>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">scipy</span>\n<span class=\"kn\">import</span> <span class=\"nn\">scipy.sparse</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">entropy</span><span class=\"p\">(</span><span class=\"n\">eig_vals</span><span class=\"p\">):</span>\n  <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"mf\">0.</span>\n  <span class=\"k\">for</span> <span class=\"n\">val</span> <span class=\"ow\">in</span> <span class=\"n\">eig_vals</span><span class=\"p\">:</span>\n    <span class=\"k\">if</span> <span class=\"n\">val</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n      <span class=\"n\">s</span> <span class=\"o\">+=</span> <span class=\"o\">-</span><span class=\"n\">val</span><span class=\"o\">*</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">)</span>\n  <span class=\"k\">return</span> <span class=\"n\">s</span>\n\n<span class=\"n\">L</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"n\">laplacian</span><span class=\"p\">(</span><span class=\"n\">normalized</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">)</span>\n<span class=\"n\">vals_laplacian</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">linalg</span><span class=\"o\">.</span><span class=\"n\">eigvalsh</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">real</span>\n\n<span class=\"n\">exact_entropy</span> <span class=\"o\">=</span>  <span class=\"n\">entropy</span><span class=\"p\">(</span><span class=\"n\">vals_laplacian</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">trace_function</span><span class=\"p\">(</span><span class=\"n\">eig_vals</span><span class=\"p\">):</span>\n  <span class=\"k\">def</span> <span class=\"nf\">entropy</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">cond</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"o\">&gt;</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"k\">lambda</span><span class=\"p\">:</span><span class=\"o\">-</span><span class=\"n\">val</span><span class=\"o\">*</span><span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">),</span> <span class=\"k\">lambda</span><span class=\"p\">:</span> <span class=\"mf\">0.</span><span class=\"p\">)</span>\n  \n  <span class=\"k\">return</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">map_fn</span><span class=\"p\">(</span><span class=\"n\">entropy</span><span class=\"p\">,</span> <span class=\"n\">eig_vals</span><span class=\"p\">)</span>\n \n<span class=\"n\">L_sparse</span> <span class=\"o\">=</span> <span class=\"n\">scipy</span><span class=\"o\">.</span><span class=\"n\">sparse</span><span class=\"o\">.</span><span class=\"n\">coo_matrix</span><span class=\"p\">(</span><span class=\"n\">L</span><span class=\"p\">)</span>\n    \n<span class=\"n\">num_vecs</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>\n<span class=\"n\">num_steps</span> <span class=\"o\">=</span> <span class=\"mi\">50</span>\n<span class=\"n\">approximated_entropy</span><span class=\"p\">,</span> <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">pyslq</span><span class=\"p\">(</span><span class=\"n\">L_sparse</span><span class=\"p\">,</span> <span class=\"n\">num_vecs</span><span class=\"p\">,</span> <span class=\"n\">num_steps</span><span class=\"p\">,</span>  <span class=\"n\">trace_function</span><span class=\"p\">)</span>\n\n<span class=\"n\">approximated_entropy</span><span class=\"p\">,</span> <span class=\"n\">exact_entropy</span>\n</pre>\n<pre><code>(-509.46283, -512.5283224633046)\n</code></pre>\n<p><a href=\"https://www.tandfonline.com/doi/abs/10.1080/03610919008812866\" rel=\"nofollow\">[1] Hutchinson, M. F. (1990). A stochastic estimator of the trace of the influence matrix for laplacian smoothing splines. Communications in Statistics-Simulation and Computation, 19(2), 433-450.</a></p>\n<p><a href=\"https://epubs.siam.org/doi/abs/10.1137/16M1104974\" rel=\"nofollow\">[2] Ubaru, S., Chen, J., &amp; Saad, Y. (2017). Fast Estimation of tr(f(A)) via Stochastic Lanczos Quadrature. SIAM Journal on Matrix Analysis and Applications, 38(4), 1075-1099.</a></p>\n<h2>Acknowledgements</h2>\n<p>This work has been supported also by FAPESP grants  11/50761-2  and  2015/22308-2.   Research  carriedout using the computational resources of the Center forMathematical  Sciences  Applied  to  Industry  (CeMEAI)funded by FAPESP (grant 2013/07375-0).</p>\n\n          </div>"}, "last_serial": 5842241, "releases": {"1.0.2": [{"comment_text": "", "digests": {"md5": "b1a36c7fd0d8a8bdfc4c657c98bb0860", "sha256": "c0d48f318b11f6e18309eb2c3e9ac8dbc9c7aeba408b888e234f17b14f274527"}, "downloads": -1, "filename": "emate-1.0.2.tar.gz", "has_sig": false, "md5_digest": "b1a36c7fd0d8a8bdfc4c657c98bb0860", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11857, "upload_time": "2019-09-04T15:44:18", "upload_time_iso_8601": "2019-09-04T15:44:18.034597Z", "url": "https://files.pythonhosted.org/packages/a5/ac/043928319b0641082bb97d865a123d2ae6cd784fac8e1b126e34fa8a5aa4/emate-1.0.2.tar.gz", "yanked": false}], "1.0.3": [{"comment_text": "", "digests": {"md5": "291db3bd9678e56e92846aea3a094551", "sha256": "67920f89ebec9bae6ff20671bf8bda5218bcdaf9742635f2ff5c367a1b60c382"}, "downloads": -1, "filename": "emate-1.0.3.tar.gz", "has_sig": false, "md5_digest": "291db3bd9678e56e92846aea3a094551", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13543, "upload_time": "2019-09-17T15:19:14", "upload_time_iso_8601": "2019-09-17T15:19:14.117682Z", "url": "https://files.pythonhosted.org/packages/a3/35/fa3d5b516d47303d85759efb3bbdc1e6c6a0b9c47f8f7f909348379540ab/emate-1.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "291db3bd9678e56e92846aea3a094551", "sha256": "67920f89ebec9bae6ff20671bf8bda5218bcdaf9742635f2ff5c367a1b60c382"}, "downloads": -1, "filename": "emate-1.0.3.tar.gz", "has_sig": false, "md5_digest": "291db3bd9678e56e92846aea3a094551", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13543, "upload_time": "2019-09-17T15:19:14", "upload_time_iso_8601": "2019-09-17T15:19:14.117682Z", "url": "https://files.pythonhosted.org/packages/a3/35/fa3d5b516d47303d85759efb3bbdc1e6c6a0b9c47f8f7f909348379540ab/emate-1.0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:46:41 2020"}