{"info": {"author": "Joe Cross", "author_email": "joe.mcross@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Web Environment", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Topic :: Internet :: WWW/HTTP :: Dynamic Content :: CGI Tools/Libraries", "Topic :: Internet :: WWW/HTTP :: WSGI", "Topic :: Internet :: WWW/HTTP :: WSGI :: Application", "Topic :: Internet :: WWW/HTTP :: WSGI :: Middleware", "Topic :: Internet :: WWW/HTTP :: WSGI :: Server", "Topic :: Software Development :: Libraries :: Application Frameworks", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# pyservice 0.8.0\n\n[![Build Status]\n(https://travis-ci.org/numberoverzero/pyservice.svg?branch=master)]\n(https://travis-ci.org/numberoverzero/pyservice)[![Coverage Status]\n(https://coveralls.io/repos/numberoverzero/pyservice/badge.png?branch=master)]\n(https://coveralls.io/r/numberoverzero/pyservice?branch=master)\n\nDownloads https://pypi.python.org/pypi/pyservice\n\nSource https://github.com/numberoverzero/pyservice\n\nMicroservice framework for high tps, designed for readability and code re-use\n\n# Installation\n\n`pip install pyservice`\n\n# Getting Started\n\npyservice was designed from the ground up to minimize request overhead, while\nstill exposing the relevant pieces of the request chain for extension.  The\nfile is less than 1000 lines including docstrings and comments\n(566 @ 12/12/14), which makes the source a great reference when you've got\nquestions.\n\nLet's get some code going.  First, we'll define a small api.  These are just\nnested dictonaries - feel free to load them from a json file.\n\n```python\n# Service/Client just use a dict for specifying an api\napi = {\n    \"debug\": True,\n    \"endpoint\": {\n        \"scheme\": \"http\",\n        \"host\": \"localhost\",\n        \"port\": 8080,\n        \"path\": \"/api/{version}/{operation}\"\n    },\n    \"operations\": [\"get_item\", \"put_item\"],\n    \"exceptions\": [\"IDRequired\", \"DoesNotExist\", \"ItemRequired\"]\n}\n```\n\nNext we'll set up the service, and define the get/put operations:\n\n```python\nimport uuid\nimport pyservice\n\nservice = pyservice.Service(**api)\nitems = {}\n\n\n@service.operation(name=\"put_item\")\ndef put_item(request, response, context):\n    if item not in request:\n        raise service.exceptions.ItemRequired(\"Need an item to put\")\n    id = uuid.uuid4()\n    items[id] = request.item\n    response.id = id\n\n\n@service.operation(name=\"get_item\")\ndef get_item(request, response, context):\n    if id not in request:\n        raise service.exceptions.IDRequired(\"Can't get an item without an ID\")\n    try:\n        item = items[request.id]\n    except KeyError:\n        raise service.exceptions.DoesNotExist(\"No item with id \" + response.id)\n    else:\n        response.item = item\n```\n\nFinally, to get a server running, we'll use the wsgiref reference server:\n\n```python\nfrom wsgiref.simple_server import make_server\n\ndef run_server():\n    print(\"Starting Server...\")\n    host, port = api[\"endpoint\"][\"host\"], api[\"endpoint\"][\"port\"]\n    httpd = make_server(host, port, service.wsgi_application)\n    httpd.serve_forever()\n\nif __name__ == \"__main__\":\n    run_server()\n```\n\nTo make a call from a client, we'll use the same `api` defined above.  The\nclient calls are even simpler:\n\n```python\nimport pyservice\n\n# ... Same api definition above\n\nclient = pyservice.Client(**api)\n\n# put\nitem = \"some string\"\nid = client.put_item(item=item)\n\n# get\nsame_item = client.get_item(id=id)\n\nassert item == same_item\n```\n\nWe can plug into calls in two scopes:\n\n* `request`, which is before the request and response bodies\n   have been created and after they've been consumed\n* `operation`, which is after the request and response bodies\n   have been created and before they've been consumed.\n\nThe difference is important for things like sqlalchemy, where serialization\nshould occur before the connection is closed.\n\n```python\n\n@service.plugin(scope=\"request\")\ndef some_plugin(context):\n    print(\"Before request '{}'\".format(context.operation))\n    context.process_request()\n    print(\"After request '{}'\".format(context.operation))\n\n@service.plugin(scope=\"operation\")\ndef some_plugin(request, response, context):\n    print(\"Before operation '{}'\".format(context.operation))\n    print(\"Request: {}\".format(request))\n    context.process_request()\n    print(\"Response: {}\".format(response))\n    print(\"After operation '{}'\".format(context.operation))\n```\n\n# Contributing\nContributions welcome!  Please make sure `tox` passes (including flake8) before submitting a PR.\n\n### Development\npyservice uses `tox`, `pytest` and `flake8`.  To get everything set up:\n\n```\n# RECOMMENDED: create a virtualenv with:\n#     mkvirtualenv pyservice\ngit clone https://github.com/numberoverzero/pyservice.git\npip install tox\ntox\n```\n\n### TODO\n* Documentation (0.9.0)\n  * Better README\n  * Better docstrings\n  * Examples\n    * Plugins\n    * Additional metadata\n    * Subclassing Client/Service\n    * Multiple versions\n* Plugins (1.0.0)\n  * Caching\n  * Auth[N/Z] + Whitelisting\n  * Logging\n  * Throttling\n  * SqlAlchemy\n  * Structures\n  * Redaction\n  * Patching\n  * Function unpacking decoration\n\n# API\n\n### Client\n\nTODO\n\n### Service\n\nTODO\n\n### Plugins\n\nTODO", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/numberoverzero/pyservice/", "keywords": "wsgi web api framework soa", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "pyservice", "package_url": "https://pypi.org/project/pyservice/", "platform": "any", "project_url": "https://pypi.org/project/pyservice/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/numberoverzero/pyservice/"}, "release_url": "https://pypi.org/project/pyservice/0.8.0/", "requires_dist": null, "requires_python": null, "summary": "web services with python made easy", "version": "0.8.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            # pyservice 0.8.0<br><br>[![Build Status]<br>(https://travis-ci.org/numberoverzero/pyservice.svg?branch=master)]<br>(https://travis-ci.org/numberoverzero/pyservice)[![Coverage Status]<br>(https://coveralls.io/repos/numberoverzero/pyservice/badge.png?branch=master)]<br>(https://coveralls.io/r/numberoverzero/pyservice?branch=master)<br><br>Downloads https://pypi.python.org/pypi/pyservice<br><br>Source https://github.com/numberoverzero/pyservice<br><br>Microservice framework for high tps, designed for readability and code re-use<br><br># Installation<br><br>`pip install pyservice`<br><br># Getting Started<br><br>pyservice was designed from the ground up to minimize request overhead, while<br>still exposing the relevant pieces of the request chain for extension.  The<br>file is less than 1000 lines including docstrings and comments<br>(566 @ 12/12/14), which makes the source a great reference when you've got<br>questions.<br><br>Let's get some code going.  First, we'll define a small api.  These are just<br>nested dictonaries - feel free to load them from a json file.<br><br>```python<br># Service/Client just use a dict for specifying an api<br>api = {<br>    \"debug\": True,<br>    \"endpoint\": {<br>        \"scheme\": \"http\",<br>        \"host\": \"localhost\",<br>        \"port\": 8080,<br>        \"path\": \"/api/{version}/{operation}\"<br>    },<br>    \"operations\": [\"get_item\", \"put_item\"],<br>    \"exceptions\": [\"IDRequired\", \"DoesNotExist\", \"ItemRequired\"]<br>}<br>```<br><br>Next we'll set up the service, and define the get/put operations:<br><br>```python<br>import uuid<br>import pyservice<br><br>service = pyservice.Service(**api)<br>items = {}<br><br><br>@service.operation(name=\"put_item\")<br>def put_item(request, response, context):<br>    if item not in request:<br>        raise service.exceptions.ItemRequired(\"Need an item to put\")<br>    id = uuid.uuid4()<br>    items[id] = request.item<br>    response.id = id<br><br><br>@service.operation(name=\"get_item\")<br>def get_item(request, response, context):<br>    if id not in request:<br>        raise service.exceptions.IDRequired(\"Can't get an item without an ID\")<br>    try:<br>        item = items[request.id]<br>    except KeyError:<br>        raise service.exceptions.DoesNotExist(\"No item with id \" + response.id)<br>    else:<br>        response.item = item<br>```<br><br>Finally, to get a server running, we'll use the wsgiref reference server:<br><br>```python<br>from wsgiref.simple_server import make_server<br><br>def run_server():<br>    print(\"Starting Server...\")<br>    host, port = api[\"endpoint\"][\"host\"], api[\"endpoint\"][\"port\"]<br>    httpd = make_server(host, port, service.wsgi_application)<br>    httpd.serve_forever()<br><br>if __name__ == \"__main__\":<br>    run_server()<br>```<br><br>To make a call from a client, we'll use the same `api` defined above.  The<br>client calls are even simpler:<br><br>```python<br>import pyservice<br><br># ... Same api definition above<br><br>client = pyservice.Client(**api)<br><br># put<br>item = \"some string\"<br>id = client.put_item(item=item)<br><br># get<br>same_item = client.get_item(id=id)<br><br>assert item == same_item<br>```<br><br>We can plug into calls in two scopes:<br><br>* `request`, which is before the request and response bodies<br>   have been created and after they've been consumed<br>* `operation`, which is after the request and response bodies<br>   have been created and before they've been consumed.<br><br>The difference is important for things like sqlalchemy, where serialization<br>should occur before the connection is closed.<br><br>```python<br><br>@service.plugin(scope=\"request\")<br>def some_plugin(context):<br>    print(\"Before request '{}'\".format(context.operation))<br>    context.process_request()<br>    print(\"After request '{}'\".format(context.operation))<br><br>@service.plugin(scope=\"operation\")<br>def some_plugin(request, response, context):<br>    print(\"Before operation '{}'\".format(context.operation))<br>    print(\"Request: {}\".format(request))<br>    context.process_request()<br>    print(\"Response: {}\".format(response))<br>    print(\"After operation '{}'\".format(context.operation))<br>```<br><br># Contributing<br>Contributions welcome!  Please make sure `tox` passes (including flake8) before submitting a PR.<br><br>### Development<br>pyservice uses `tox`, `pytest` and `flake8`.  To get everything set up:<br><br>```<br># RECOMMENDED: create a virtualenv with:<br>#     mkvirtualenv pyservice<br>git clone https://github.com/numberoverzero/pyservice.git<br>pip install tox<br>tox<br>```<br><br>### TODO<br>* Documentation (0.9.0)<br>  * Better README<br>  * Better docstrings<br>  * Examples<br>    * Plugins<br>    * Additional metadata<br>    * Subclassing Client/Service<br>    * Multiple versions<br>* Plugins (1.0.0)<br>  * Caching<br>  * Auth[N/Z] + Whitelisting<br>  * Logging<br>  * Throttling<br>  * SqlAlchemy<br>  * Structures<br>  * Redaction<br>  * Patching<br>  * Function unpacking decoration<br><br># API<br><br>### Client<br><br>TODO<br><br>### Service<br><br>TODO<br><br>### Plugins<br><br>TODO\n          </div>"}, "last_serial": 1342304, "releases": {"0.8.0": []}, "urls": [], "timestamp": "Fri May  8 02:57:04 2020"}