{"info": {"author": "Madra David", "author_email": "david@madradavid.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Django", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3", "Topic :: Internet :: WWW/HTTP"], "description": "Note\n-----------\nThis repo is cloned from `channels-api <https://github.com/linuxlewis/channels-api>`__\n\nChannels API\n------------\n\n.. image:: https://travis-ci.org/linuxlewis/channels-api.svg?branch=master\n    :target: https://travis-ci.org/linuxlewis/channels-api\n\nChannels API exposes a RESTful Streaming API over WebSockets using\nchannels. It provides a ``ResourceBinding`` which is comparable to Django\nRest Framework's ``ModelViewSet``. It is based on DRF serializer\nclasses.\n\nIt requires Python 3, Django 1.8, and Django Rest Framework 3.0\n\nTable of Contents\n-----------------\n\n-  `Getting Started <#getting-started>`__\n-  `ResourceBinding <#resourcebinding>`__\n-  `Subscriptions <#subscriptions>`__\n-  `Errors <#errors>`__\n-  `Roadmap <#roadmap>`__\n\n\nHow does it work?\n-----------------\n\nThe API builds on top of channels' ``WebsocketBinding`` class. It works by having\nthe client send a ``stream`` and ``payload`` parameters. This allows\nus to route messages to different streams (or resources) for a particular\naction. So ``POST /user`` would have a message that looks like the following\n\n.. code:: javascript\n\n    var msg = {\n      stream: \"users\",\n      payload: {\n        action: \"create\",\n        data: {\n          email: \"test@example.com\",\n          password: \"password\",\n        }\n      }\n    }\n\n    ws.send(JSON.stringify(msg))\n\nWhy?\n----\n\nYou're already using Django Rest Framework and want to expose similar\nlogic over WebSockets.\n\nWebSockets can publish updates to clients without a request. This is\nhelpful when a resource can be edited by multiple users across many platforms.\n\nGetting Started\n---------------\n\nThis tutorial assumes you're familiar with channels and have completed\nthe `Getting\nStarted <https://channels.readthedocs.io/en/latest/getting-started.html>`__\n\n-  Add ``channels_framework`` to requirements.txt\n\n.. code:: bash\n\n  pip install channels_framework\n\n-  Add ``channels_framework`` to ``INSTALLED_APPS``\n\n.. code:: python\n\n\n    INSTALLED_APPS = (\n        'rest_framework',\n        'channels',\n        'channels_framework'\n    )\n\n-  Add a ``WebsocketDemultiplexer`` to your ``channel_routing``\n\n.. code:: python\n\n    # proj/routing.py\n\n\n    from channels.generic.websockets import WebsocketDemultiplexer\n    from channels.routing import route_class\n\n    class APIDemultiplexer(WebsocketDemultiplexer):\n\n        mapping = {\n          'questions': 'questions_channel'\n        }\n\n    channel_routing = [\n        route_class(APIDemultiplexer)\n    ]\n\n-  Add your first resource binding\n\n.. code:: python\n\n\n    # polls/bindings.py\n\n    from channels_framework.bindings import ResourceBinding\n\n    from .models import Question\n    from .serializers import QuestionSerializer\n\n    class QuestionBinding(ResourceBinding):\n\n        model = Question\n        stream = \"questions\"\n        serializer_class = QuestionSerializer\n        queryset = Question.objects.all()\n\n\n    # proj/routing.py\n\n    from channels.routing import route_class, route\n\n    from polls.bindings import QuestionBinding\n\n    channel_routing = [\n      route_class(APIDemultiplexer),\n      route(\"question_channel\", QuestionBinding.consumer)\n    ]\n\nThat's it. You can now make REST WebSocket requests to the server.\n\n.. code:: javascript\n\n    var ws = new WebSocket(\"ws://\" + window.location.host + \"/\")\n\n    ws.onmessage = function(e){\n        console.log(e.data)\n    }\n\n    var msg = {\n      stream: \"questions\",\n      payload: {\n        action: \"create\",\n        data: {\n          question_text: \"What is your favorite python package?\"\n        },\n        request_id: \"some-guid\"\n      }\n    }\n    ws.send(JSON.stringify(msg))\n    // response\n    {\n      stream: \"questions\",\n      payload: {\n        action: \"create\",\n        data: {\n          id: \"1\",\n          question_text: \"What is your favorite python package\"\n        }\n        errors: [],\n        response_status: 200\n        request_id: \"some-guid\"\n      }\n    }\n\n-  Add the channels debugger page (Optional)\n\nThis page is helpful to debug API requests from the browser and see the\nresponse. It is only designed to be used when ``DEBUG=TRUE``.\n\n.. code:: python\n\n    # proj/urls.py\n\n    from django.conf.urls import include\n\n        urlpatterns = [\n            url(r'^channels-api/', include('channels_framework.urls'))\n        ]\n\nResourceBinding\n---------------\n\nBy default the ``ResourceBinding`` implements the following REST methods:\n\n- ``create``\n- ``retrieve``\n- ``update``\n- ``list``\n- ``delete``\n- ``subscribe``\n\nSee the test suite for usage examples for each method.\n\n\nList Pagination\n---------------\n\nPagination is handled by `django.core.paginator.Paginator`\n\nYou can configure the ``DEFAULT_PAGE_SIZE`` by overriding the settings.\n\n\n.. code:: python\n\n  # settings.py\n\n  channels_framework = {\n    'DEFAULT_PAGE_SIZE': 25\n  }\n\n\nSubscriptions\n-------------\n\nSubscriptions are a way to programmatically receive updates\nfrom the server whenever a resource is created, updated, or deleted\n\nBy default channels-api has implemented the following subscriptions\n\n- create a Resource\n- update any Resource\n- update this Resource\n- delete any Resource\n- delete this Resource\n\nTo subscribe to a particular event just use the subscribe action\nwith the parameters to filter\n\n.. code:: javascript\n\n  // get an event when any question is updated\n\n  var msg = {\n    stream: \"questions\",\n    payload: {\n      action: \"subscribe\",\n      data: {\n        action: \"update\"\n      }\n    }\n  }\n\n  // get an event when question(1) is updated\n  var msg = {\n    stream: \"questions\",\n    payload: {\n      action: \"subscribe\"\n      data: {\n        action: \"update\",\n        pk: \"1\"\n      }\n    }\n  }\n", "description_content_type": null, "docs_url": null, "download_url": "https://github.com/madra/channels-rest-framework/tarball/0.1", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/madra/channels-rest-framework", "keywords": null, "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "channelsrestframework", "package_url": "https://pypi.org/project/channelsrestframework/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/channelsrestframework/", "project_urls": {"Download": "https://github.com/madra/channels-rest-framework/tarball/0.1", "Homepage": "https://github.com/madra/channels-rest-framework"}, "release_url": "https://pypi.org/project/channelsrestframework/0.1.4/", "requires_dist": null, "requires_python": null, "summary": "Build a RESTful API on top of WebSockets using Django channels and Django Rest Framework.", "version": "0.1.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"note\">\n<h2>Note</h2>\n<p>This repo is cloned from <a href=\"https://github.com/linuxlewis/channels-api\" rel=\"nofollow\">channels-api</a></p>\n</div>\n<div id=\"channels-api\">\n<h2>Channels API</h2>\n<a href=\"https://travis-ci.org/linuxlewis/channels-api\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/linuxlewis/channels-api.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/76119ac5edfd7f8d9c33b175a46b2bf938145416/68747470733a2f2f7472617669732d63692e6f72672f6c696e75786c657769732f6368616e6e656c732d6170692e7376673f6272616e63683d6d6173746572\"></a>\n<p>Channels API exposes a RESTful Streaming API over WebSockets using\nchannels. It provides a <tt>ResourceBinding</tt> which is comparable to Django\nRest Framework\u2019s <tt>ModelViewSet</tt>. It is based on DRF serializer\nclasses.</p>\n<p>It requires Python 3, Django 1.8, and Django Rest Framework 3.0</p>\n</div>\n<div id=\"table-of-contents\">\n<h2>Table of Contents</h2>\n<ul>\n<li><a href=\"#getting-started\" rel=\"nofollow\">Getting Started</a></li>\n<li><a href=\"#resourcebinding\" rel=\"nofollow\">ResourceBinding</a></li>\n<li><a href=\"#subscriptions\" rel=\"nofollow\">Subscriptions</a></li>\n<li><a href=\"#errors\" rel=\"nofollow\">Errors</a></li>\n<li><a href=\"#roadmap\" rel=\"nofollow\">Roadmap</a></li>\n</ul>\n</div>\n<div id=\"how-does-it-work\">\n<h2>How does it work?</h2>\n<p>The API builds on top of channels\u2019 <tt>WebsocketBinding</tt> class. It works by having\nthe client send a <tt>stream</tt> and <tt>payload</tt> parameters. This allows\nus to route messages to different streams (or resources) for a particular\naction. So <tt>POST /user</tt> would have a message that looks like the following</p>\n<pre><span class=\"kd\">var</span> <span class=\"nx\">msg</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"nx\">stream</span><span class=\"o\">:</span> <span class=\"s2\">\"users\"</span><span class=\"p\">,</span>\n  <span class=\"nx\">payload</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">action</span><span class=\"o\">:</span> <span class=\"s2\">\"create\"</span><span class=\"p\">,</span>\n    <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">email</span><span class=\"o\">:</span> <span class=\"s2\">\"test@example.com\"</span><span class=\"p\">,</span>\n      <span class=\"nx\">password</span><span class=\"o\">:</span> <span class=\"s2\">\"password\"</span><span class=\"p\">,</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">ws</span><span class=\"p\">.</span><span class=\"nx\">send</span><span class=\"p\">(</span><span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"nx\">msg</span><span class=\"p\">))</span>\n</pre>\n</div>\n<div id=\"why\">\n<h2>Why?</h2>\n<p>You\u2019re already using Django Rest Framework and want to expose similar\nlogic over WebSockets.</p>\n<p>WebSockets can publish updates to clients without a request. This is\nhelpful when a resource can be edited by multiple users across many platforms.</p>\n</div>\n<div id=\"getting-started\">\n<h2>Getting Started</h2>\n<p>This tutorial assumes you\u2019re familiar with channels and have completed\nthe <a href=\"https://channels.readthedocs.io/en/latest/getting-started.html\" rel=\"nofollow\">Getting\nStarted</a></p>\n<ul>\n<li>Add <tt>channels_framework</tt> to requirements.txt</li>\n</ul>\n<pre>pip install channels_framework\n</pre>\n<ul>\n<li>Add <tt>channels_framework</tt> to <tt>INSTALLED_APPS</tt></li>\n</ul>\n<pre><span class=\"n\">INSTALLED_APPS</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n    <span class=\"s1\">'rest_framework'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'channels'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'channels_framework'</span>\n<span class=\"p\">)</span>\n</pre>\n<ul>\n<li>Add a <tt>WebsocketDemultiplexer</tt> to your <tt>channel_routing</tt></li>\n</ul>\n<pre><span class=\"c1\"># proj/routing.py</span>\n\n\n<span class=\"kn\">from</span> <span class=\"nn\">channels.generic.websockets</span> <span class=\"kn\">import</span> <span class=\"n\">WebsocketDemultiplexer</span>\n<span class=\"kn\">from</span> <span class=\"nn\">channels.routing</span> <span class=\"kn\">import</span> <span class=\"n\">route_class</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">APIDemultiplexer</span><span class=\"p\">(</span><span class=\"n\">WebsocketDemultiplexer</span><span class=\"p\">):</span>\n\n    <span class=\"n\">mapping</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n      <span class=\"s1\">'questions'</span><span class=\"p\">:</span> <span class=\"s1\">'questions_channel'</span>\n    <span class=\"p\">}</span>\n\n<span class=\"n\">channel_routing</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"n\">route_class</span><span class=\"p\">(</span><span class=\"n\">APIDemultiplexer</span><span class=\"p\">)</span>\n<span class=\"p\">]</span>\n</pre>\n<ul>\n<li>Add your first resource binding</li>\n</ul>\n<pre><span class=\"c1\"># polls/bindings.py</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">channels_framework.bindings</span> <span class=\"kn\">import</span> <span class=\"n\">ResourceBinding</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">.models</span> <span class=\"kn\">import</span> <span class=\"n\">Question</span>\n<span class=\"kn\">from</span> <span class=\"nn\">.serializers</span> <span class=\"kn\">import</span> <span class=\"n\">QuestionSerializer</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">QuestionBinding</span><span class=\"p\">(</span><span class=\"n\">ResourceBinding</span><span class=\"p\">):</span>\n\n    <span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">Question</span>\n    <span class=\"n\">stream</span> <span class=\"o\">=</span> <span class=\"s2\">\"questions\"</span>\n    <span class=\"n\">serializer_class</span> <span class=\"o\">=</span> <span class=\"n\">QuestionSerializer</span>\n    <span class=\"n\">queryset</span> <span class=\"o\">=</span> <span class=\"n\">Question</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">all</span><span class=\"p\">()</span>\n\n\n<span class=\"c1\"># proj/routing.py</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">channels.routing</span> <span class=\"kn\">import</span> <span class=\"n\">route_class</span><span class=\"p\">,</span> <span class=\"n\">route</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">polls.bindings</span> <span class=\"kn\">import</span> <span class=\"n\">QuestionBinding</span>\n\n<span class=\"n\">channel_routing</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n  <span class=\"n\">route_class</span><span class=\"p\">(</span><span class=\"n\">APIDemultiplexer</span><span class=\"p\">),</span>\n  <span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s2\">\"question_channel\"</span><span class=\"p\">,</span> <span class=\"n\">QuestionBinding</span><span class=\"o\">.</span><span class=\"n\">consumer</span><span class=\"p\">)</span>\n<span class=\"p\">]</span>\n</pre>\n<p>That\u2019s it. You can now make REST WebSocket requests to the server.</p>\n<pre><span class=\"kd\">var</span> <span class=\"nx\">ws</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">WebSocket</span><span class=\"p\">(</span><span class=\"s2\">\"ws://\"</span> <span class=\"o\">+</span> <span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">location</span><span class=\"p\">.</span><span class=\"nx\">host</span> <span class=\"o\">+</span> <span class=\"s2\">\"/\"</span><span class=\"p\">)</span>\n\n<span class=\"nx\">ws</span><span class=\"p\">.</span><span class=\"nx\">onmessage</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">){</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">e</span><span class=\"p\">.</span><span class=\"nx\">data</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">msg</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"nx\">stream</span><span class=\"o\">:</span> <span class=\"s2\">\"questions\"</span><span class=\"p\">,</span>\n  <span class=\"nx\">payload</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">action</span><span class=\"o\">:</span> <span class=\"s2\">\"create\"</span><span class=\"p\">,</span>\n    <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">question_text</span><span class=\"o\">:</span> <span class=\"s2\">\"What is your favorite python package?\"</span>\n    <span class=\"p\">},</span>\n    <span class=\"nx\">request_id</span><span class=\"o\">:</span> <span class=\"s2\">\"some-guid\"</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">ws</span><span class=\"p\">.</span><span class=\"nx\">send</span><span class=\"p\">(</span><span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"nx\">msg</span><span class=\"p\">))</span>\n<span class=\"c1\">// response\n</span><span class=\"p\">{</span>\n  <span class=\"nx\">stream</span><span class=\"o\">:</span> <span class=\"s2\">\"questions\"</span><span class=\"p\">,</span>\n  <span class=\"nx\">payload</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">action</span><span class=\"o\">:</span> <span class=\"s2\">\"create\"</span><span class=\"p\">,</span>\n    <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">id</span><span class=\"o\">:</span> <span class=\"s2\">\"1\"</span><span class=\"p\">,</span>\n      <span class=\"nx\">question_text</span><span class=\"o\">:</span> <span class=\"s2\">\"What is your favorite python package\"</span>\n    <span class=\"p\">}</span>\n    <span class=\"nx\">errors</span><span class=\"o\">:</span> <span class=\"p\">[],</span>\n    <span class=\"nx\">response_status</span><span class=\"o\">:</span> <span class=\"mi\">200</span>\n    <span class=\"nx\">request_id</span><span class=\"o\">:</span> <span class=\"s2\">\"some-guid\"</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n<ul>\n<li>Add the channels debugger page (Optional)</li>\n</ul>\n<p>This page is helpful to debug API requests from the browser and see the\nresponse. It is only designed to be used when <tt>DEBUG=TRUE</tt>.</p>\n<pre><span class=\"c1\"># proj/urls.py</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">django.conf.urls</span> <span class=\"kn\">import</span> <span class=\"n\">include</span>\n\n    <span class=\"n\">urlpatterns</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n        <span class=\"n\">url</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'^channels-api/'</span><span class=\"p\">,</span> <span class=\"n\">include</span><span class=\"p\">(</span><span class=\"s1\">'channels_framework.urls'</span><span class=\"p\">))</span>\n    <span class=\"p\">]</span>\n</pre>\n</div>\n<div id=\"resourcebinding\">\n<h2>ResourceBinding</h2>\n<p>By default the <tt>ResourceBinding</tt> implements the following REST methods:</p>\n<ul>\n<li><tt>create</tt></li>\n<li><tt>retrieve</tt></li>\n<li><tt>update</tt></li>\n<li><tt>list</tt></li>\n<li><tt>delete</tt></li>\n<li><tt>subscribe</tt></li>\n</ul>\n<p>See the test suite for usage examples for each method.</p>\n</div>\n<div id=\"list-pagination\">\n<h2>List Pagination</h2>\n<p>Pagination is handled by <cite>django.core.paginator.Paginator</cite></p>\n<p>You can configure the <tt>DEFAULT_PAGE_SIZE</tt> by overriding the settings.</p>\n<pre><span class=\"c1\"># settings.py</span>\n\n<span class=\"n\">channels_framework</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"s1\">'DEFAULT_PAGE_SIZE'</span><span class=\"p\">:</span> <span class=\"mi\">25</span>\n<span class=\"p\">}</span>\n</pre>\n</div>\n<div id=\"subscriptions\">\n<h2>Subscriptions</h2>\n<p>Subscriptions are a way to programmatically receive updates\nfrom the server whenever a resource is created, updated, or deleted</p>\n<p>By default channels-api has implemented the following subscriptions</p>\n<ul>\n<li>create a Resource</li>\n<li>update any Resource</li>\n<li>update this Resource</li>\n<li>delete any Resource</li>\n<li>delete this Resource</li>\n</ul>\n<p>To subscribe to a particular event just use the subscribe action\nwith the parameters to filter</p>\n<pre><span class=\"c1\">// get an event when any question is updated\n</span>\n<span class=\"kd\">var</span> <span class=\"nx\">msg</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"nx\">stream</span><span class=\"o\">:</span> <span class=\"s2\">\"questions\"</span><span class=\"p\">,</span>\n  <span class=\"nx\">payload</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">action</span><span class=\"o\">:</span> <span class=\"s2\">\"subscribe\"</span><span class=\"p\">,</span>\n    <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">action</span><span class=\"o\">:</span> <span class=\"s2\">\"update\"</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// get an event when question(1) is updated\n</span><span class=\"kd\">var</span> <span class=\"nx\">msg</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"nx\">stream</span><span class=\"o\">:</span> <span class=\"s2\">\"questions\"</span><span class=\"p\">,</span>\n  <span class=\"nx\">payload</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">action</span><span class=\"o\">:</span> <span class=\"s2\">\"subscribe\"</span>\n    <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">action</span><span class=\"o\">:</span> <span class=\"s2\">\"update\"</span><span class=\"p\">,</span>\n      <span class=\"nx\">pk</span><span class=\"o\">:</span> <span class=\"s2\">\"1\"</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n</div>\n\n          </div>"}, "last_serial": 2383270, "releases": {"0.1.4": [{"comment_text": "", "digests": {"md5": "3db796c24004fba2d8f66a1da7fbb7ef", "sha256": "a0cab242f0016cf1fb63eba486ce15b0dfb6e6ce08f1f76607fcb5f96e7d13e2"}, "downloads": -1, "filename": "channelsrestframework-0.1.4.tar.gz", "has_sig": false, "md5_digest": "3db796c24004fba2d8f66a1da7fbb7ef", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7853, "upload_time": "2016-10-06T01:40:16", "upload_time_iso_8601": "2016-10-06T01:40:16.503525Z", "url": "https://files.pythonhosted.org/packages/33/d8/5dffcaf4f0dda20bc8a1b37ef23c5356ac5e8bff2224e2f18e6699cb142f/channelsrestframework-0.1.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3db796c24004fba2d8f66a1da7fbb7ef", "sha256": "a0cab242f0016cf1fb63eba486ce15b0dfb6e6ce08f1f76607fcb5f96e7d13e2"}, "downloads": -1, "filename": "channelsrestframework-0.1.4.tar.gz", "has_sig": false, "md5_digest": "3db796c24004fba2d8f66a1da7fbb7ef", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7853, "upload_time": "2016-10-06T01:40:16", "upload_time_iso_8601": "2016-10-06T01:40:16.503525Z", "url": "https://files.pythonhosted.org/packages/33/d8/5dffcaf4f0dda20bc8a1b37ef23c5356ac5e8bff2224e2f18e6699cb142f/channelsrestframework-0.1.4.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:34:29 2020"}