{"info": {"author": "Zope Community", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Zope3", "Intended Audience :: Developers", "License :: OSI Approved :: Zope Public License", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Topic :: Internet :: WWW/HTTP"], "description": "This package provides a configurator which is designed to extend a component \nafter its creation for Zope3.\n\n\n.. contents::\n\n================\nThe Configurator\n================\n\nThe configurator is designed to extend a component after its\ncreation. Traditionally this is done by listening to ``ObjectCreatedEvent``\nevents. However, this low-level method does not suffice, since configuration\noften depends on other configuration steps and additional data is often needed\nto complete the configuration. And this is where the configurator comes\nin. It uses a separate plugin mechanism to implement the mentioned high-level\nfunctionality.\n\nBefore we can demonstrate the configuration mechanism, we'll have to create an\ninterface and a component on which the configuration can act upon:\n\n  >>> import zope.interface\n\n  >>> class ISomething(zope.interface.Interface):\n  ...     \"\"\"Some interesting interface.\"\"\"\n\n  >>> @zope.interface.implementer(ISomething)\n  ... class Something(object):\n  ...     \"\"\"Implementation of something.\"\"\"\n\n  >>> something = Something()\n\nNow we can have the configuration act on the component:\n\n  >>> from z3c import configurator\n  >>> configurator.configure(something, {})\n\nThe second argument is the data dictionary, which can be used to pass in\nadditional information that might be needed during the configuration. It is up\nto each plugin to interpret the data.\n\nOf course nothing happens, since no configuration plugins are\nregistered. Let's now create a new configuration plugin, which sets a new\nattribute on the component:\n\n  >>> import zope.component\n  >>> from z3c.configurator import interfaces\n\n  >>> class AddFooAttribute(configurator.ConfigurationPluginBase):\n  ...     zope.component.adapts(ISomething)\n  ...\n  ...     def __call__(self, data):\n  ...         setattr(self.context, 'foo', data.get('foo'))\n\n  >>> zope.component.provideAdapter(AddFooAttribute, name='add foo')\n\nIf we execute the configuration again, the attribute will be added:\n\n  >>> configurator.configure(something, {'foo': u'my value'})\n  >>> something.foo\n  u'my value'\n\n\nDependencies\n------------\n\nNow that we have simple configuration plugins, we can also develop plugins\nthat depend on another one. Let's create a configuration plugin that adds some\nadditional data to the foo attribute. Clearly, the foo attribute has to exist\nbefore this step can be taken. The ``dependencies`` attribute can be used to\nspecify all plugin dependencies by name:\n\n  >>> class ExtendFooAttribute(configurator.ConfigurationPluginBase):\n  ...     zope.component.adapts(ISomething)\n  ...     dependencies = ('add foo',)\n  ...\n  ...     def __call__(self, data):\n  ...         self.context.foo = u'Text: ' + self.context.foo\n\n  >>> zope.component.provideAdapter(ExtendFooAttribute, name='extend foo')\n\nIf we now execute the configuration again, the extended result should be seen:\n\n  >>> something = Something()\n  >>> configurator.configure(something, {'foo': u'my value'})\n  >>> something.foo\n  u'Text: my value'\n\n\nData Schemas\n------------\n\nFor purely informational purposes, a ``schema`` attribute is used on the\nplugin to describe the fields that the plugin expects from the data\ndictionary. For adding another simple attribute, this could look as follows:\n\n  >>> import zope.schema\n  >>> class IAddBar(zope.interface.Interface):\n  ...     bar = zope.schema.Text(title=u'Bar')\n\n  >>> class AddBarAttribute(configurator.SchemaConfigurationPluginBase):\n  ...     zope.component.adapts(ISomething)\n  ...     schema = IAddBar\n  ...\n  ...     def __call__(self, data):\n  ...         self.verify(data)\n  ...         setattr(self.context, 'bar', data.get('bar'))\n\n  >>> zope.component.provideAdapter(AddBarAttribute, name='add bar')\n\nThe advantage of using the base class for this case is that it provides a\n``verify()`` method that allows you to verify the data against the shema. We\ncan now run the configuration again:\n\n  >>> something = Something()\n  >>> configurator.configure(something, {'foo': u'my value', 'bar': u'value'})\n  >>> something.bar\n  u'value'\n\nThe value must exist and be valid:\n\n  >>> something = Something()\n  >>> configurator.configure(something, {'foo': u'my value'})\n  Traceback (most recent call last):\n  ...\n  RequiredMissing: bar\n\n  >>> something = Something()\n  >>> configurator.configure(something, {'foo': u'my value', 'bar': 1})\n  Traceback (most recent call last):\n  ...\n  WrongType: (1, <type 'unicode'>, 'bar')\n\n\nData Namespaces\n---------------\n\nIn order to not confuse attribute names if two plugins share a common\nname it is possible to pass data as a dictionary of dictionaries. The\nkeys of the dictionary is the name under which the plugins are\nregistered.\n\n  >>> something = Something()\n  >>> data = {u'add foo': {'foo': u'foo value'},\n  ...         u'add bar': {'bar': u'bar value'}}\n  >>> configurator.configure(something, data, useNameSpaces=True)\n  >>> something.foo, something.bar\n  (u'Text: foo value', u'bar value')\n\nNamed Configuration\n-------------------\n\nSometimes we do not want all registered configuration plugins to be\nexecuted. This can be achieved by providing the names argument to the\nconfigure function.\n\nLet us create a new something:\n\n  >>> something = Something()\n\nIf we now configure it without names we get both attributes set.\n\n  >>> configurator.configure(something, {'foo': u'my value', 'bar': u'asdf'})\n  >>> sorted(something.__dict__.items())\n  [('bar', 'asdf'), ('foo', 'Text: my value')]\n\nNow let us just configure the plugin 'add bar'.\n\n  >>> something = Something()\n  >>> configurator.configure(something, {'foo': u'my value', 'bar': u'asdf'},\n  ...     names=['add bar'])\n  >>> something.__dict__\n  {'bar': u'asdf'}\n\nDependencies of plugins are always executed - they don't have to be\nadded to the ```names``` argument.\n\n  >>> something = Something()\n  >>> configurator.configure(something, {'foo': u'my value'},\n  ...     names=['extend foo'])\n  >>> something.foo\n  u'Text: my value'\n\nNamed configurations are usefull when called manually through the web\n(see browser/README.txt). The configurator package does not look if a\nconfiguration is already applied if called twice. It is the\nresponsibility of the plugin to be aware that it doesn't do things\ntwice or delete things.\n\n\nWrong Implementations\n---------------------\n\nA configurator must provide a __call__ method.\n\n  >>> class CallNotImplemented(configurator.ConfigurationPluginBase):\n  ...     zope.component.adapts(ISomething)\n  >>> zope.component.provideAdapter(CallNotImplemented, name='no call')\n\n  >>> configurator.configure(something, None,  names=['no call'])\n  Traceback (most recent call last):\n  ...\n  NotImplementedError\n\nThe same must happen for a schema base configurator.\n\n  >>> class SchemaCallNotImplemented(configurator.SchemaConfigurationPluginBase):\n  ...     zope.component.adapts(ISomething)\n  >>> zope.component.provideAdapter(SchemaCallNotImplemented, name='schema no call')\n\n  >>> configurator.configure(something, None,  names=['schema no call'])\n  Traceback (most recent call last):\n  ...\n  NotImplementedError\n\n\nNo Recursion\n------------\n\nIt's possible to define recursive dependencies without to run into recursion \nerrors. Let's define a new plugin free object:\n\n  >>> class IFoo(zope.interface.Interface):\n  ...     \"\"\"Just a foo interface.\"\"\"\n\n  >>> @zope.interface.implementer(IFoo)\n  ... class Foo(object):\n  ...     \"\"\"Implementation of foo.\"\"\"\n\nLet's define another plugin named `first` which depends on a plugin named \n`second`.\n\n  >>> log = []\n  >>> class FirstPlugin(configurator.ConfigurationPluginBase):\n  ...     zope.component.adapts(IFoo)\n  ...     dependencies = ('second',)\n  ...\n  ...     def __call__(self, data):\n  ...         log.append('FirstPlugin called')\n\n  >>> zope.component.provideAdapter(FirstPlugin, name='first')\n\nAnd define a plugin named `second` which depends on `first`:\n\n  >>> class SecondPlugin(configurator.ConfigurationPluginBase):\n  ...     zope.component.adapts(IFoo)\n  ...     dependencies = ('first',)\n  ...\n  ...     def __call__(self, data):\n  ...         log.append('SecondPlugin called')\n\n  >>> zope.component.provideAdapter(SecondPlugin, name='second')\n\n  >>> foo = Foo()\n  >>> configurator.configure(foo, {})\n  >>> for msg in sorted(log): print(msg)\n  FirstPlugin called\n  SecondPlugin called\n\n\n=========================\nCalling Configurators TTW\n=========================\n\nA configuration view is registered to apply named configuration on any\nobject.  We defined two example configurators which we now gonna apply\nto the site object.\n\n  >>> from zope.testbrowser.testing import Browser\n  >>> browser = Browser()\n  >>> browser.addHeader('Authorization','Basic mgr:mgrpw')\n  >>> browser.handleErrors = False\n\n  >>> browser.open('http://localhost/manage')\n  >>> browser.url\n  'http://localhost/@@contents.html'\n\nThe view is registered in the zmi_views menu\n\n  >>> browser.getLink(u'Configurators').click()\n  >>> viewURL = browser.url\n  >>> viewURL\n  'http://localhost/@@configurators.html'\n\n  >>> sel = browser.getControl(name=\"form.pluginNames.to\")\n\nFirst we can choose from the registered named plugins.\n\n  >>> plugs = browser.getControl(name=\"form.pluginNames.from\").options\n  >>> sorted(plugs)\n  ['z3c.configurator.testing.setdescription',\n   'z3c.configurator.testing.settitle']\n  >>> browser.open(viewURL + '?form.pluginNames=z3c.configurator.testing.settitle')\n\nWe have choosen a plugin, so now we have a form for the arguments needed.\n\n  >>> browser.getControl('Some Argument').value\n  ''\n  >>> browser.getControl('Some Argument').value = \"New Title\"\n  >>> browser.getControl('Apply').click()\n\n\nXXX form.pluginNames have to be set, but we can't because the widget\nuses javascript.\n\n\n\n\n=======\nCHANGES\n=======\n\n\n2.0.0 (2015-11-09)\n------------------\n\n- Standardize namespace __init__\n\n\n2.0.0a1 (2013-03-04)\n--------------------\n\n- Added support for Python 3.3, dropped support for Python 2.4 and 2.5.\n\n\n1.3.0 (2010-12-12)\n------------------\n\n- Updated test set up to run with ZTK 1.0.\n\n\nVersion 1.2.1 (2009-12-27)\n--------------------------\n\n- Moved browser dependencies to 'zmi' extras\n\n\nVersion 1.2.0 (2009-12-19)\n--------------------------\n\n- Made registration of browser views conditional\n\n- Move packages required for testing to 'test' extras\n\n- Remove old zpkg-related SETUP.cfg file.\n\n- Copyright \"Zope Foundation and Contributors\"\n\n\nVersion 1.1.2 (2009-01-04)\n--------------------------\n\n- Added possibility to apply only specific named plugins in configure.\n\n- New option to configure allows to have namespaced data to resolve\n  naming conflicts.\n\n- Added a page to call configurators TTW. This is the first step\n  towards mergin z3c.configurator and z3c.sampledata into one package.\n\n- Added documentation to Pypi home page.\n\n- bugfix: Defining recursive dependent names in IConfigurationPlugin\n  dependencies, ends in recursive plugin lookup.\n\n- bugfix: SchemaConfigurationPluginBase now implements\n  ISchemaConfigurationPluginBase.\n\n\nVersion 1.1.1 (unknown)\n-----------------------\n\n- Initial Release", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/z3c.configurator", "keywords": "zope3 z3c configurator configuration", "license": "ZPL 2.1", "maintainer": null, "maintainer_email": null, "name": "z3c.configurator", "package_url": "https://pypi.org/project/z3c.configurator/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/z3c.configurator/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/z3c.configurator"}, "release_url": "https://pypi.org/project/z3c.configurator/2.0.0/", "requires_dist": null, "requires_python": null, "summary": "Dynamic configuration", "version": "2.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>This package provides a configurator which is designed to extend a component\nafter its creation for Zope3.</p>\n<div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#the-configurator\" id=\"id3\" rel=\"nofollow\">The Configurator</a><ul>\n<li><a href=\"#dependencies\" id=\"id4\" rel=\"nofollow\">Dependencies</a></li>\n<li><a href=\"#data-schemas\" id=\"id5\" rel=\"nofollow\">Data Schemas</a></li>\n<li><a href=\"#data-namespaces\" id=\"id6\" rel=\"nofollow\">Data Namespaces</a></li>\n<li><a href=\"#named-configuration\" id=\"id7\" rel=\"nofollow\">Named Configuration</a></li>\n<li><a href=\"#wrong-implementations\" id=\"id8\" rel=\"nofollow\">Wrong Implementations</a></li>\n<li><a href=\"#no-recursion\" id=\"id9\" rel=\"nofollow\">No Recursion</a></li>\n</ul>\n</li>\n<li><a href=\"#calling-configurators-ttw\" id=\"id10\" rel=\"nofollow\">Calling Configurators TTW</a></li>\n<li><a href=\"#changes\" id=\"id11\" rel=\"nofollow\">CHANGES</a><ul>\n<li><a href=\"#id1\" id=\"id12\" rel=\"nofollow\">2.0.0 (2015-11-09)</a></li>\n<li><a href=\"#a1-2013-03-04\" id=\"id13\" rel=\"nofollow\">2.0.0a1 (2013-03-04)</a></li>\n<li><a href=\"#id2\" id=\"id14\" rel=\"nofollow\">1.3.0 (2010-12-12)</a></li>\n<li><a href=\"#version-1-2-1-2009-12-27\" id=\"id15\" rel=\"nofollow\">Version 1.2.1 (2009-12-27)</a></li>\n<li><a href=\"#version-1-2-0-2009-12-19\" id=\"id16\" rel=\"nofollow\">Version 1.2.0 (2009-12-19)</a></li>\n<li><a href=\"#version-1-1-2-2009-01-04\" id=\"id17\" rel=\"nofollow\">Version 1.1.2 (2009-01-04)</a></li>\n<li><a href=\"#version-1-1-1-unknown\" id=\"id18\" rel=\"nofollow\">Version 1.1.1 (unknown)</a></li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"the-configurator\">\n<h2><a href=\"#id3\" rel=\"nofollow\">The Configurator</a></h2>\n<p>The configurator is designed to extend a component after its\ncreation. Traditionally this is done by listening to <tt>ObjectCreatedEvent</tt>\nevents. However, this low-level method does not suffice, since configuration\noften depends on other configuration steps and additional data is often needed\nto complete the configuration. And this is where the configurator comes\nin. It uses a separate plugin mechanism to implement the mentioned high-level\nfunctionality.</p>\n<p>Before we can demonstrate the configuration mechanism, we\u2019ll have to create an\ninterface and a component on which the configuration can act upon:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.interface\n</pre>\n<pre>&gt;&gt;&gt; class ISomething(zope.interface.Interface):\n...     \"\"\"Some interesting interface.\"\"\"\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(ISomething)\n... class Something(object):\n...     \"\"\"Implementation of something.\"\"\"\n</pre>\n<pre>&gt;&gt;&gt; something = Something()\n</pre>\n</blockquote>\n<p>Now we can have the configuration act on the component:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from z3c import configurator\n&gt;&gt;&gt; configurator.configure(something, {})\n</pre>\n</blockquote>\n<p>The second argument is the data dictionary, which can be used to pass in\nadditional information that might be needed during the configuration. It is up\nto each plugin to interpret the data.</p>\n<p>Of course nothing happens, since no configuration plugins are\nregistered. Let\u2019s now create a new configuration plugin, which sets a new\nattribute on the component:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; from z3c.configurator import interfaces\n</pre>\n<pre>&gt;&gt;&gt; class AddFooAttribute(configurator.ConfigurationPluginBase):\n...     zope.component.adapts(ISomething)\n...\n...     def __call__(self, data):\n...         setattr(self.context, 'foo', data.get('foo'))\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(AddFooAttribute, name='add foo')\n</pre>\n</blockquote>\n<p>If we execute the configuration again, the attribute will be added:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; configurator.configure(something, {'foo': u'my value'})\n&gt;&gt;&gt; something.foo\nu'my value'\n</pre>\n</blockquote>\n<div id=\"dependencies\">\n<h3><a href=\"#id4\" rel=\"nofollow\">Dependencies</a></h3>\n<p>Now that we have simple configuration plugins, we can also develop plugins\nthat depend on another one. Let\u2019s create a configuration plugin that adds some\nadditional data to the foo attribute. Clearly, the foo attribute has to exist\nbefore this step can be taken. The <tt>dependencies</tt> attribute can be used to\nspecify all plugin dependencies by name:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class ExtendFooAttribute(configurator.ConfigurationPluginBase):\n...     zope.component.adapts(ISomething)\n...     dependencies = ('add foo',)\n...\n...     def __call__(self, data):\n...         self.context.foo = u'Text: ' + self.context.foo\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(ExtendFooAttribute, name='extend foo')\n</pre>\n</blockquote>\n<p>If we now execute the configuration again, the extended result should be seen:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; something = Something()\n&gt;&gt;&gt; configurator.configure(something, {'foo': u'my value'})\n&gt;&gt;&gt; something.foo\nu'Text: my value'\n</pre>\n</blockquote>\n</div>\n<div id=\"data-schemas\">\n<h3><a href=\"#id5\" rel=\"nofollow\">Data Schemas</a></h3>\n<p>For purely informational purposes, a <tt>schema</tt> attribute is used on the\nplugin to describe the fields that the plugin expects from the data\ndictionary. For adding another simple attribute, this could look as follows:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import zope.schema\n&gt;&gt;&gt; class IAddBar(zope.interface.Interface):\n...     bar = zope.schema.Text(title=u'Bar')\n</pre>\n<pre>&gt;&gt;&gt; class AddBarAttribute(configurator.SchemaConfigurationPluginBase):\n...     zope.component.adapts(ISomething)\n...     schema = IAddBar\n...\n...     def __call__(self, data):\n...         self.verify(data)\n...         setattr(self.context, 'bar', data.get('bar'))\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(AddBarAttribute, name='add bar')\n</pre>\n</blockquote>\n<p>The advantage of using the base class for this case is that it provides a\n<tt>verify()</tt> method that allows you to verify the data against the shema. We\ncan now run the configuration again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; something = Something()\n&gt;&gt;&gt; configurator.configure(something, {'foo': u'my value', 'bar': u'value'})\n&gt;&gt;&gt; something.bar\nu'value'\n</pre>\n</blockquote>\n<p>The value must exist and be valid:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; something = Something()\n&gt;&gt;&gt; configurator.configure(something, {'foo': u'my value'})\nTraceback (most recent call last):\n...\nRequiredMissing: bar\n</pre>\n<pre>&gt;&gt;&gt; something = Something()\n&gt;&gt;&gt; configurator.configure(something, {'foo': u'my value', 'bar': 1})\nTraceback (most recent call last):\n...\nWrongType: (1, &lt;type 'unicode'&gt;, 'bar')\n</pre>\n</blockquote>\n</div>\n<div id=\"data-namespaces\">\n<h3><a href=\"#id6\" rel=\"nofollow\">Data Namespaces</a></h3>\n<p>In order to not confuse attribute names if two plugins share a common\nname it is possible to pass data as a dictionary of dictionaries. The\nkeys of the dictionary is the name under which the plugins are\nregistered.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; something = Something()\n&gt;&gt;&gt; data = {u'add foo': {'foo': u'foo value'},\n...         u'add bar': {'bar': u'bar value'}}\n&gt;&gt;&gt; configurator.configure(something, data, useNameSpaces=True)\n&gt;&gt;&gt; something.foo, something.bar\n(u'Text: foo value', u'bar value')\n</pre>\n</blockquote>\n</div>\n<div id=\"named-configuration\">\n<h3><a href=\"#id7\" rel=\"nofollow\">Named Configuration</a></h3>\n<p>Sometimes we do not want all registered configuration plugins to be\nexecuted. This can be achieved by providing the names argument to the\nconfigure function.</p>\n<p>Let us create a new something:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; something = Something()\n</pre>\n</blockquote>\n<p>If we now configure it without names we get both attributes set.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; configurator.configure(something, {'foo': u'my value', 'bar': u'asdf'})\n&gt;&gt;&gt; sorted(something.__dict__.items())\n[('bar', 'asdf'), ('foo', 'Text: my value')]\n</pre>\n</blockquote>\n<p>Now let us just configure the plugin \u2018add bar\u2019.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; something = Something()\n&gt;&gt;&gt; configurator.configure(something, {'foo': u'my value', 'bar': u'asdf'},\n...     names=['add bar'])\n&gt;&gt;&gt; something.__dict__\n{'bar': u'asdf'}\n</pre>\n</blockquote>\n<p>Dependencies of plugins are always executed - they don\u2019t have to be\nadded to the <tt>`names`</tt> argument.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; something = Something()\n&gt;&gt;&gt; configurator.configure(something, {'foo': u'my value'},\n...     names=['extend foo'])\n&gt;&gt;&gt; something.foo\nu'Text: my value'\n</pre>\n</blockquote>\n<p>Named configurations are usefull when called manually through the web\n(see browser/README.txt). The configurator package does not look if a\nconfiguration is already applied if called twice. It is the\nresponsibility of the plugin to be aware that it doesn\u2019t do things\ntwice or delete things.</p>\n</div>\n<div id=\"wrong-implementations\">\n<h3><a href=\"#id8\" rel=\"nofollow\">Wrong Implementations</a></h3>\n<p>A configurator must provide a __call__ method.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class CallNotImplemented(configurator.ConfigurationPluginBase):\n...     zope.component.adapts(ISomething)\n&gt;&gt;&gt; zope.component.provideAdapter(CallNotImplemented, name='no call')\n</pre>\n<pre>&gt;&gt;&gt; configurator.configure(something, None,  names=['no call'])\nTraceback (most recent call last):\n...\nNotImplementedError\n</pre>\n</blockquote>\n<p>The same must happen for a schema base configurator.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class SchemaCallNotImplemented(configurator.SchemaConfigurationPluginBase):\n...     zope.component.adapts(ISomething)\n&gt;&gt;&gt; zope.component.provideAdapter(SchemaCallNotImplemented, name='schema no call')\n</pre>\n<pre>&gt;&gt;&gt; configurator.configure(something, None,  names=['schema no call'])\nTraceback (most recent call last):\n...\nNotImplementedError\n</pre>\n</blockquote>\n</div>\n<div id=\"no-recursion\">\n<h3><a href=\"#id9\" rel=\"nofollow\">No Recursion</a></h3>\n<p>It\u2019s possible to define recursive dependencies without to run into recursion\nerrors. Let\u2019s define a new plugin free object:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class IFoo(zope.interface.Interface):\n...     \"\"\"Just a foo interface.\"\"\"\n</pre>\n<pre>&gt;&gt;&gt; @zope.interface.implementer(IFoo)\n... class Foo(object):\n...     \"\"\"Implementation of foo.\"\"\"\n</pre>\n</blockquote>\n<p>Let\u2019s define another plugin named <cite>first</cite> which depends on a plugin named\n<cite>second</cite>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; log = []\n&gt;&gt;&gt; class FirstPlugin(configurator.ConfigurationPluginBase):\n...     zope.component.adapts(IFoo)\n...     dependencies = ('second',)\n...\n...     def __call__(self, data):\n...         log.append('FirstPlugin called')\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(FirstPlugin, name='first')\n</pre>\n</blockquote>\n<p>And define a plugin named <cite>second</cite> which depends on <cite>first</cite>:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; class SecondPlugin(configurator.ConfigurationPluginBase):\n...     zope.component.adapts(IFoo)\n...     dependencies = ('first',)\n...\n...     def __call__(self, data):\n...         log.append('SecondPlugin called')\n</pre>\n<pre>&gt;&gt;&gt; zope.component.provideAdapter(SecondPlugin, name='second')\n</pre>\n<pre>&gt;&gt;&gt; foo = Foo()\n&gt;&gt;&gt; configurator.configure(foo, {})\n&gt;&gt;&gt; for msg in sorted(log): print(msg)\nFirstPlugin called\nSecondPlugin called\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"calling-configurators-ttw\">\n<h2><a href=\"#id10\" rel=\"nofollow\">Calling Configurators TTW</a></h2>\n<p>A configuration view is registered to apply named configuration on any\nobject.  We defined two example configurators which we now gonna apply\nto the site object.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zope.testbrowser.testing import Browser\n&gt;&gt;&gt; browser = Browser()\n&gt;&gt;&gt; browser.addHeader('Authorization','Basic mgr:mgrpw')\n&gt;&gt;&gt; browser.handleErrors = False\n</pre>\n<pre>&gt;&gt;&gt; browser.open('http://localhost/manage')\n&gt;&gt;&gt; browser.url\n'http://localhost/@@contents.html'\n</pre>\n</blockquote>\n<p>The view is registered in the zmi_views menu</p>\n<blockquote>\n<pre>&gt;&gt;&gt; browser.getLink(u'Configurators').click()\n&gt;&gt;&gt; viewURL = browser.url\n&gt;&gt;&gt; viewURL\n'http://localhost/@@configurators.html'\n</pre>\n<pre>&gt;&gt;&gt; sel = browser.getControl(name=\"form.pluginNames.to\")\n</pre>\n</blockquote>\n<p>First we can choose from the registered named plugins.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; plugs = browser.getControl(name=\"form.pluginNames.from\").options\n&gt;&gt;&gt; sorted(plugs)\n['z3c.configurator.testing.setdescription',\n 'z3c.configurator.testing.settitle']\n&gt;&gt;&gt; browser.open(viewURL + '?form.pluginNames=z3c.configurator.testing.settitle')\n</pre>\n</blockquote>\n<p>We have choosen a plugin, so now we have a form for the arguments needed.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; browser.getControl('Some Argument').value\n''\n&gt;&gt;&gt; browser.getControl('Some Argument').value = \"New Title\"\n&gt;&gt;&gt; browser.getControl('Apply').click()\n</pre>\n</blockquote>\n<p>XXX form.pluginNames have to be set, but we can\u2019t because the widget\nuses javascript.</p>\n</div>\n<div id=\"changes\">\n<h2><a href=\"#id11\" rel=\"nofollow\">CHANGES</a></h2>\n<div id=\"id1\">\n<h3><a href=\"#id12\" rel=\"nofollow\">2.0.0 (2015-11-09)</a></h3>\n<ul>\n<li>Standardize namespace __init__</li>\n</ul>\n</div>\n<div id=\"a1-2013-03-04\">\n<h3><a href=\"#id13\" rel=\"nofollow\">2.0.0a1 (2013-03-04)</a></h3>\n<ul>\n<li>Added support for Python 3.3, dropped support for Python 2.4 and 2.5.</li>\n</ul>\n</div>\n<div id=\"id2\">\n<h3><a href=\"#id14\" rel=\"nofollow\">1.3.0 (2010-12-12)</a></h3>\n<ul>\n<li>Updated test set up to run with ZTK 1.0.</li>\n</ul>\n</div>\n<div id=\"version-1-2-1-2009-12-27\">\n<h3><a href=\"#id15\" rel=\"nofollow\">Version 1.2.1 (2009-12-27)</a></h3>\n<ul>\n<li>Moved browser dependencies to \u2018zmi\u2019 extras</li>\n</ul>\n</div>\n<div id=\"version-1-2-0-2009-12-19\">\n<h3><a href=\"#id16\" rel=\"nofollow\">Version 1.2.0 (2009-12-19)</a></h3>\n<ul>\n<li>Made registration of browser views conditional</li>\n<li>Move packages required for testing to \u2018test\u2019 extras</li>\n<li>Remove old zpkg-related SETUP.cfg file.</li>\n<li>Copyright \u201cZope Foundation and Contributors\u201d</li>\n</ul>\n</div>\n<div id=\"version-1-1-2-2009-01-04\">\n<h3><a href=\"#id17\" rel=\"nofollow\">Version 1.1.2 (2009-01-04)</a></h3>\n<ul>\n<li>Added possibility to apply only specific named plugins in configure.</li>\n<li>New option to configure allows to have namespaced data to resolve\nnaming conflicts.</li>\n<li>Added a page to call configurators TTW. This is the first step\ntowards mergin z3c.configurator and z3c.sampledata into one package.</li>\n<li>Added documentation to Pypi home page.</li>\n<li>bugfix: Defining recursive dependent names in IConfigurationPlugin\ndependencies, ends in recursive plugin lookup.</li>\n<li>bugfix: SchemaConfigurationPluginBase now implements\nISchemaConfigurationPluginBase.</li>\n</ul>\n</div>\n<div id=\"version-1-1-1-unknown\">\n<h3><a href=\"#id18\" rel=\"nofollow\">Version 1.1.1 (unknown)</a></h3>\n<ul>\n<li>Initial Release</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1808172, "releases": {"1.1.1": [{"comment_text": "", "digests": {"md5": "4977e11ec9213ed31da98ee449e4daad", "sha256": "f3a16ac098f6dc9c581e41b3f78a0a62f4262979bb5beaf56cc27da0507cd435"}, "downloads": -1, "filename": "z3c.configurator-1.1.1.zip", "has_sig": false, "md5_digest": "4977e11ec9213ed31da98ee449e4daad", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22239, "upload_time": "2008-05-07T14:38:22", "upload_time_iso_8601": "2008-05-07T14:38:22Z", "url": "https://files.pythonhosted.org/packages/0e/80/46a5c956654d907402900dbfb6a18f797a79a6052b2b5d7547204e7d8b93/z3c.configurator-1.1.1.zip", "yanked": false}], "1.1.2": [{"comment_text": "", "digests": {"md5": "07ad807c74173e888ddb55e1ae806692", "sha256": "cc0099820384bdab9b708675774c098b4e9f70a2135ac3429e561f8901a59373"}, "downloads": -1, "filename": "z3c.configurator-1.1.2.tar.gz", "has_sig": false, "md5_digest": "07ad807c74173e888ddb55e1ae806692", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19379, "upload_time": "2009-01-04T21:21:32", "upload_time_iso_8601": "2009-01-04T21:21:32Z", "url": "https://files.pythonhosted.org/packages/cd/ff/e726d86eb636315839cadabaced0a31c209d58f68569adfb0e6e8506b27e/z3c.configurator-1.1.2.tar.gz", "yanked": false}], "1.2.0": [{"comment_text": "", "digests": {"md5": "9b88807b82f6cb464d6f286e6d67e00c", "sha256": "69aab356af6f83b9bb6af800189dd76a962592244aa732d4ce3719d682c15b50"}, "downloads": -1, "filename": "z3c.configurator-1.2.0.tar.gz", "has_sig": false, "md5_digest": "9b88807b82f6cb464d6f286e6d67e00c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17477, "upload_time": "2009-12-20T04:57:11", "upload_time_iso_8601": "2009-12-20T04:57:11.825988Z", "url": "https://files.pythonhosted.org/packages/22/6b/d0e18e834c77558b76f216c87b0c4f7de1cd5fc3af72ec979b4824c20039/z3c.configurator-1.2.0.tar.gz", "yanked": false}], "1.2.1": [{"comment_text": "", "digests": {"md5": "46b362a6fad0be43d10e929a05df4bf1", "sha256": "ff56f04e37f0e6ff1620564bbb47f6fde32da49220c095e0f04e36111ddac65c"}, "downloads": -1, "filename": "z3c.configurator-1.2.1.tar.gz", "has_sig": false, "md5_digest": "46b362a6fad0be43d10e929a05df4bf1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 14341, "upload_time": "2009-12-27T09:50:55", "upload_time_iso_8601": "2009-12-27T09:50:55.483824Z", "url": "https://files.pythonhosted.org/packages/d1/27/4888f12f543e19279e9bc98d6476920ffd55fb05c2ef8a284c42bac441b8/z3c.configurator-1.2.1.tar.gz", "yanked": false}], "1.3.0": [{"comment_text": "", "digests": {"md5": "cd8ec7d15bfcfedcb3b841f40a611ad6", "sha256": "cd5be0ee453780a810bc02a50fbf74fb9fa8445f7331bc6c36e07d9566856555"}, "downloads": -1, "filename": "z3c.configurator-1.3.0.tar.gz", "has_sig": false, "md5_digest": "cd8ec7d15bfcfedcb3b841f40a611ad6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15404, "upload_time": "2010-12-12T16:54:33", "upload_time_iso_8601": "2010-12-12T16:54:33.179447Z", "url": "https://files.pythonhosted.org/packages/3b/fe/c7ee05db7c82e686ba7e4d5b12cb2ca7d431e83321d3cea434f2ad30f4bc/z3c.configurator-1.3.0.tar.gz", "yanked": false}], "2.0.0": [{"comment_text": "", "digests": {"md5": "ec2351f4be5f0176f612432b3e9c0a2d", "sha256": "854d810cdfd92ae24207907313afb50f4ab9b5bf10e90aaa9f4cb1bffbeb6dac"}, "downloads": -1, "filename": "z3c.configurator-2.0.0.tar.gz", "has_sig": false, "md5_digest": "ec2351f4be5f0176f612432b3e9c0a2d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21083, "upload_time": "2015-11-09T16:36:37", "upload_time_iso_8601": "2015-11-09T16:36:37.695780Z", "url": "https://files.pythonhosted.org/packages/5a/9a/ab7a8a842f92542c0d6cb8bac405ea28dee4b7bf378b38d8144e2d61448c/z3c.configurator-2.0.0.tar.gz", "yanked": false}], "2.0.0a1": [{"comment_text": "", "digests": {"md5": "db60cc365eef8089d242be025da99044", "sha256": "4c169527e13b4eab7eca2b970e7f72fcc3e6e0b5767737dcce9620f9d11c2aa8"}, "downloads": -1, "filename": "z3c.configurator-2.0.0a1.zip", "has_sig": false, "md5_digest": "db60cc365eef8089d242be025da99044", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29606, "upload_time": "2013-03-04T09:36:10", "upload_time_iso_8601": "2013-03-04T09:36:10.052316Z", "url": "https://files.pythonhosted.org/packages/20/b9/bb8eb02d82ba40f5f9bcbd296e9dd77cd50282b58579cfed7842abae0e4f/z3c.configurator-2.0.0a1.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "ec2351f4be5f0176f612432b3e9c0a2d", "sha256": "854d810cdfd92ae24207907313afb50f4ab9b5bf10e90aaa9f4cb1bffbeb6dac"}, "downloads": -1, "filename": "z3c.configurator-2.0.0.tar.gz", "has_sig": false, "md5_digest": "ec2351f4be5f0176f612432b3e9c0a2d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21083, "upload_time": "2015-11-09T16:36:37", "upload_time_iso_8601": "2015-11-09T16:36:37.695780Z", "url": "https://files.pythonhosted.org/packages/5a/9a/ab7a8a842f92542c0d6cb8bac405ea28dee4b7bf378b38d8144e2d61448c/z3c.configurator-2.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:21:08 2020"}