{"info": {"author": "Fahrzin Hemmati", "author_email": "fahhem@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 2 - Pre-Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Programming Language :: C++", "Programming Language :: Python", "Programming Language :: Python :: 3", "Topic :: Software Development :: Code Generators", "Topic :: Software Development :: Libraries", "Topic :: System :: Networking", "Topic :: Utilities"], "description": "CARA\n====\n\n|Build Status| |Coverage Status| |Codacy Badge| |Documentation Status|\n|PyPI Version| |PyPI License|\n\ncara is a Cap'n proto Alternative RPC API. `Read the\ndocs! <http://cara.readthedocs.org/en/latest/>`__\n\nReason for creation\n-------------------\n\npycapnp is a straight C++ conversion and, while that's great and all,\nit's not pythonic. It also uses capnp's RPC layer and friends, which is\nfrom scratch and isn't very mature, while there are plenty of RPC\nlayers, event loops, etc already in python and well-maintained.\n\nRequirements\n------------\n\nTo install via setup.py (or pip), a capnproto installation must be\nlocatable by pkg-config. Installed via a normal 'sudo make install'\nshould work, other situations have not been tested.\n\nUsage\n-----\n\nFirst, generate the code from your .capnp files:\n\n::\n\n    capnp compile -ocara my_structs.capnp\n\nThen import them:\n\n::\n\n    import my_structs_capnp\n\nExample\n~~~~~~~\n\nmy\\_structs.capnp\n\n::\n\n    struct MyStruct {\n        field @0 :Text;\n        nested @1 :NestedStruct;\n        struct NestedStruct {\n            integer @0 :Int32;\n        }\n    }\n\nPython usage\n\n::\n\n    import my_structs_capnp\n\n    my_structs_capnp.MyStruct({'field': 'some text for here'})\n    # -- or --\n    m = my_structs_capnp.MyStruct.Create(field='some different text')\n\n    # All the classes masquerade as python builtins, like dict:\n    msgpack.packb(m) == b'\\x81\\x00\\xb3some different text'\n    # But it's slightly different... Look at Field Shrinking below to\n    # understand\n\nPseud Integration\n-----------------\n\nThere's also `pseud <https://github.com/ezeep/pseud>`__ integration.\nPseud supports tornado and gevent, but only tornado on Python 3, so\nthese examples used tornado. If you use Python 2, you're welcome to use\ngevent.\n\nThe first requirement imposed is that you call cara\\_pseud.setup\\_server\non your server and cara\\_pseud.setup\\_client on your client. Once both\nare called, you can start the server and client. For the server,\nregister an interface with the class or function you want to export. For\nthe client, wrap the client object with the interface you want to use it\nas. This API allows a server to export multiple interfaces and a client\nto use any number of them.\n\nExample\n~~~~~~~\n\nmy\\_ifaces.capnp\n\n::\n\n    interface SimpleEcho {\n        echo (text :Text) -> (text :Text);\n    }\n\n    interface BackAndForth {\n        interface Callback {\n            callback (callback :Callback) -> (result :Text);\n        }\n        callMeMaybe (callback :Callback) -> ();\n        otherFunc () -> ();\n    }\n\nPython usage:\n\n::\n\n    from cara import cara_pseud\n    from my_ifaces_capnp import SimpleEcho, BackAndForth\n\n    @tornado.gen.coroutine\n    def create_server():\n      server = pseud.Server(...)\n      server.bind(...)\n      cara_pseud.setup_server(server)\n      yield server.start()\n\n      # A function can be used to implement an interface with a single\n      # method. The name doesn't have to match either.\n      @cara_pseud.register_interface(server, SimpleEcho)\n      def func(text):\n        return text\n\n      # If an interface has multiple methods, a class is necessary. It also has\n      # to implement all the methods, but its name can be anything, too.\n      # It can subclass the interface or object, but if you choose the\n      # interface, the register_interface call can infer it from the class\n      # definition.\n      @cara_pseud.register_interface(server)\n      class Server(BackAndForth):\n        def callMeMaybe(self, callback):\n          # You can even use a lambda as an interface.\n          callback(lambda: 'internal callback')\n\n        def otherFunc(self):\n          pass\n\n    @tornado.gen.coroutine\n    def create_client():\n      server = pseud.Client(...)\n      server.connect(...)\n      cara_pseud.setup_client(server)\n      yield client.start()\n\n      echo_iface = SimpleEcho(client)\n      result = yield echo_iface.echo('test')\n      assert result == 'test'\n\n      # Now let's mess with this exported interface.\n      back_and_forth = BackAndForth(client)\n      # This is a special combination of fortunate accidents. A method with one\n      # argument that is an interface with one method can be called like a\n      # decorator. Though, you need to yield it still.\n      @back_and_forth.callMeMaybe\n      def callback(callback=None):\n        result = yield callback()\n        assert result == 'internal callback'\n      yield callback\n\n    io_loop.add_callback(create_server)\n    io_loop.add_callback(create_client)\n    io_loop.start()\n\nField Shrinking\n---------------\n\n::\n\n    # Notice there's no mention of 'field' in the result:\n    m = my_structs_capnp.MyStruct({'field': 'some text for here'})\n    msgpack.packb(m) == b'\\x81\\x00\\xb3some different text'\n    # Yet it's there when we pack the object directly.\n    m = {'field': 'some different text'}\n    msgpack.packb(m) == b'\\x81\\xa5field\\xb3some different text'\n\nThe difference is because a cara Struct uses the ordinals of the fields\ninstead of their names. This will only be an issue when sending the\npacked bytes over to another system that isn't using cara. If you send\nit back into cara, it'll unpack the fields correctly and you can use it\nlike the original pieces.\n\n::\n\n    original = my_structs_capnp.MyStruct.Create(nested={'integer': 2})\n    packed = msgpack.packb(original)\n    unpacked = msgpack.unpackb(packed)\n    # --> {1: {0: 2}}\n    result = my_structs_capnp.MyStruct(unpacked)\n    # --> MyStruct({nested: NestedStruct({integer: 2})})\n\nThis allows us to serialize a struct into a much smaller bytestring,\nespecially since 0-127 becomes a single byte in msgpack. As long as your\ncapnp schema changes are sufficiently backwards-compatible, you can\ndeserialize and lookup the field numbers to get the appropriate type.\n\n.. |Build Status| image:: https://img.shields.io/travis/chainreactionmfg/cara/master.svg\n   :target: https://travis-ci.org/chainreactionmfg/cara\n.. |Coverage Status| image:: https://img.shields.io/coveralls/chainreactionmfg/cara/master.svg\n   :target: https://coveralls.io/r/chainreactionmfg/cara\n.. |Codacy Badge| image:: https://img.shields.io/codacy/3cc5a370c923435e92b9ce1a7dbbbafe.svg\n   :target: https://www.codacy.com/public/fahhem/cara\n.. |Documentation Status| image:: https://readthedocs.org/projects/cara/badge/?version=latest&style=flat\n   :target: https://readthedocs.org/projects/cara/?badge=latest\n.. |PyPI Version| image:: https://img.shields.io/pypi/v/cara.svg\n   :target: https://pypi.python.org/pypi/cara\n.. |PyPI License| image:: https://img.shields.io/pypi/l/cara.svg\n   :target: https://pypi.python.org/pypi/cara", "description_content_type": null, "docs_url": null, "download_url": null, "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/chainreactionmfg/cara", "keywords": "cara pseud capnp network rpc schema", "license": "Apache 2.0", "maintainer": null, "maintainer_email": null, "name": "cara", "package_url": "https://pypi.org/project/cara/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/cara/", "project_urls": {"Homepage": "https://github.com/chainreactionmfg/cara"}, "release_url": "https://pypi.org/project/cara/0.10.3/", "requires_dist": null, "requires_python": null, "summary": "cara is a Cap'n proto Alternative RPC API.", "version": "0.10.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://travis-ci.org/chainreactionmfg/cara\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/3575ae4b4616a4951fb5cf85acbf42f3391906b5/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f636861696e7265616374696f6e6d66672f636172612f6d61737465722e737667\"></a> <a href=\"https://coveralls.io/r/chainreactionmfg/cara\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/5f537e0420d25076555b24e885588c6a8c9057ad/68747470733a2f2f696d672e736869656c64732e696f2f636f766572616c6c732f636861696e7265616374696f6e6d66672f636172612f6d61737465722e737667\"></a> <a href=\"https://www.codacy.com/public/fahhem/cara\" rel=\"nofollow\"><img alt=\"Codacy Badge\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/abcb0a18152a37842f30e4e305b5b25834da74d2/68747470733a2f2f696d672e736869656c64732e696f2f636f646163792f33636335613337306339323334333565393262396365316137646262626166652e737667\"></a> <a href=\"https://readthedocs.org/projects/cara/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6d1349ee0b7d42aa6773572a687b9ff14cfae047/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f636172612f62616467652f3f76657273696f6e3d6c6174657374267374796c653d666c6174\"></a>\n<a href=\"https://pypi.python.org/pypi/cara\" rel=\"nofollow\"><img alt=\"PyPI Version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e128f460604b445f9e9a3f17fc7b6dc86614f577/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f636172612e737667\"></a> <a href=\"https://pypi.python.org/pypi/cara\" rel=\"nofollow\"><img alt=\"PyPI License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6b364e74370d85388ecd45dbf18179c2eca40697/68747470733a2f2f696d672e736869656c64732e696f2f707970692f6c2f636172612e737667\"></a></p>\n<p>cara is a Cap\u2019n proto Alternative RPC API. <a href=\"http://cara.readthedocs.org/en/latest/\" rel=\"nofollow\">Read the\ndocs!</a></p>\n<div id=\"reason-for-creation\">\n<h2>Reason for creation</h2>\n<p>pycapnp is a straight C++ conversion and, while that\u2019s great and all,\nit\u2019s not pythonic. It also uses capnp\u2019s RPC layer and friends, which is\nfrom scratch and isn\u2019t very mature, while there are plenty of RPC\nlayers, event loops, etc already in python and well-maintained.</p>\n</div>\n<div id=\"requirements\">\n<h2>Requirements</h2>\n<p>To install via setup.py (or pip), a capnproto installation must be\nlocatable by pkg-config. Installed via a normal \u2018sudo make install\u2019\nshould work, other situations have not been tested.</p>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>First, generate the code from your .capnp files:</p>\n<pre>capnp compile -ocara my_structs.capnp\n</pre>\n<p>Then import them:</p>\n<pre>import my_structs_capnp\n</pre>\n<div id=\"example\">\n<h3>Example</h3>\n<p>my_structs.capnp</p>\n<pre>struct MyStruct {\n    field @0 :Text;\n    nested @1 :NestedStruct;\n    struct NestedStruct {\n        integer @0 :Int32;\n    }\n}\n</pre>\n<p>Python usage</p>\n<pre>import my_structs_capnp\n\nmy_structs_capnp.MyStruct({'field': 'some text for here'})\n# -- or --\nm = my_structs_capnp.MyStruct.Create(field='some different text')\n\n# All the classes masquerade as python builtins, like dict:\nmsgpack.packb(m) == b'\\x81\\x00\\xb3some different text'\n# But it's slightly different... Look at Field Shrinking below to\n# understand\n</pre>\n</div>\n</div>\n<div id=\"pseud-integration\">\n<h2>Pseud Integration</h2>\n<p>There\u2019s also <a href=\"https://github.com/ezeep/pseud\" rel=\"nofollow\">pseud</a> integration.\nPseud supports tornado and gevent, but only tornado on Python 3, so\nthese examples used tornado. If you use Python 2, you\u2019re welcome to use\ngevent.</p>\n<p>The first requirement imposed is that you call cara_pseud.setup_server\non your server and cara_pseud.setup_client on your client. Once both\nare called, you can start the server and client. For the server,\nregister an interface with the class or function you want to export. For\nthe client, wrap the client object with the interface you want to use it\nas. This API allows a server to export multiple interfaces and a client\nto use any number of them.</p>\n<div id=\"id1\">\n<h3>Example</h3>\n<p>my_ifaces.capnp</p>\n<pre>interface SimpleEcho {\n    echo (text :Text) -&gt; (text :Text);\n}\n\ninterface BackAndForth {\n    interface Callback {\n        callback (callback :Callback) -&gt; (result :Text);\n    }\n    callMeMaybe (callback :Callback) -&gt; ();\n    otherFunc () -&gt; ();\n}\n</pre>\n<p>Python usage:</p>\n<pre>from cara import cara_pseud\nfrom my_ifaces_capnp import SimpleEcho, BackAndForth\n\n@tornado.gen.coroutine\ndef create_server():\n  server = pseud.Server(...)\n  server.bind(...)\n  cara_pseud.setup_server(server)\n  yield server.start()\n\n  # A function can be used to implement an interface with a single\n  # method. The name doesn't have to match either.\n  @cara_pseud.register_interface(server, SimpleEcho)\n  def func(text):\n    return text\n\n  # If an interface has multiple methods, a class is necessary. It also has\n  # to implement all the methods, but its name can be anything, too.\n  # It can subclass the interface or object, but if you choose the\n  # interface, the register_interface call can infer it from the class\n  # definition.\n  @cara_pseud.register_interface(server)\n  class Server(BackAndForth):\n    def callMeMaybe(self, callback):\n      # You can even use a lambda as an interface.\n      callback(lambda: 'internal callback')\n\n    def otherFunc(self):\n      pass\n\n@tornado.gen.coroutine\ndef create_client():\n  server = pseud.Client(...)\n  server.connect(...)\n  cara_pseud.setup_client(server)\n  yield client.start()\n\n  echo_iface = SimpleEcho(client)\n  result = yield echo_iface.echo('test')\n  assert result == 'test'\n\n  # Now let's mess with this exported interface.\n  back_and_forth = BackAndForth(client)\n  # This is a special combination of fortunate accidents. A method with one\n  # argument that is an interface with one method can be called like a\n  # decorator. Though, you need to yield it still.\n  @back_and_forth.callMeMaybe\n  def callback(callback=None):\n    result = yield callback()\n    assert result == 'internal callback'\n  yield callback\n\nio_loop.add_callback(create_server)\nio_loop.add_callback(create_client)\nio_loop.start()\n</pre>\n</div>\n</div>\n<div id=\"field-shrinking\">\n<h2>Field Shrinking</h2>\n<pre># Notice there's no mention of 'field' in the result:\nm = my_structs_capnp.MyStruct({'field': 'some text for here'})\nmsgpack.packb(m) == b'\\x81\\x00\\xb3some different text'\n# Yet it's there when we pack the object directly.\nm = {'field': 'some different text'}\nmsgpack.packb(m) == b'\\x81\\xa5field\\xb3some different text'\n</pre>\n<p>The difference is because a cara Struct uses the ordinals of the fields\ninstead of their names. This will only be an issue when sending the\npacked bytes over to another system that isn\u2019t using cara. If you send\nit back into cara, it\u2019ll unpack the fields correctly and you can use it\nlike the original pieces.</p>\n<pre>original = my_structs_capnp.MyStruct.Create(nested={'integer': 2})\npacked = msgpack.packb(original)\nunpacked = msgpack.unpackb(packed)\n# --&gt; {1: {0: 2}}\nresult = my_structs_capnp.MyStruct(unpacked)\n# --&gt; MyStruct({nested: NestedStruct({integer: 2})})\n</pre>\n<p>This allows us to serialize a struct into a much smaller bytestring,\nespecially since 0-127 becomes a single byte in msgpack. As long as your\ncapnp schema changes are sufficiently backwards-compatible, you can\ndeserialize and lookup the field numbers to get the appropriate type.</p>\n</div>\n\n          </div>"}, "last_serial": 1505874, "releases": {"0.10.0": [{"comment_text": "", "digests": {"md5": "1f1fcef48fe85f20a7c7602cd2367d60", "sha256": "e91fe090411ba690608552915b23335364a38857531fc8ed7f68f86a2fef5da5"}, "downloads": -1, "filename": "cara-0.10.0.tar.gz", "has_sig": false, "md5_digest": "1f1fcef48fe85f20a7c7602cd2367d60", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 53349, "upload_time": "2015-03-03T09:09:33", "upload_time_iso_8601": "2015-03-03T09:09:33.693474Z", "url": "https://files.pythonhosted.org/packages/81/4e/74594dfc32d6902be993b99a03ace8f4a7b199f1d47970f112da8f94acc9/cara-0.10.0.tar.gz", "yanked": false}], "0.10.2": [{"comment_text": "", "digests": {"md5": "7ea609a398f6a1b9d860c1f9c1da8607", "sha256": "af6b6e47b1164e31da5c510956f72fabd7735672aad938b91cb05038c2a13ada"}, "downloads": -1, "filename": "cara-0.10.2.tar.gz", "has_sig": false, "md5_digest": "7ea609a398f6a1b9d860c1f9c1da8607", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 53357, "upload_time": "2015-03-03T10:11:45", "upload_time_iso_8601": "2015-03-03T10:11:45.628856Z", "url": "https://files.pythonhosted.org/packages/d0/38/b7d3bacd2211a142cb711a3902e856b59fdfd4bedfd5a4699fc6915841a2/cara-0.10.2.tar.gz", "yanked": false}], "0.10.3": [{"comment_text": "", "digests": {"md5": "a0b13f1b0c8c6248d6ba0d9e6b5c08d7", "sha256": "a2a8fa6c27af2725381b8417d466042d6030a0b884bb7d6cc147b58fad6e7686"}, "downloads": -1, "filename": "cara-0.10.3.tar.gz", "has_sig": false, "md5_digest": "a0b13f1b0c8c6248d6ba0d9e6b5c08d7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 53430, "upload_time": "2015-04-15T07:09:02", "upload_time_iso_8601": "2015-04-15T07:09:02.162041Z", "url": "https://files.pythonhosted.org/packages/fc/79/8118e63bc79969ceb1a27360dd21eed7ee528706e11fec6de2c7b1422cb5/cara-0.10.3.tar.gz", "yanked": false}], "0.8.1": [{"comment_text": "", "digests": {"md5": "ada33619f3dabbe16a0c1d33b825fa22", "sha256": "7176b1a6d760ae6c58e4482b329c0224d7f963a9e768c303eb2ab722ef690bff"}, "downloads": -1, "filename": "cara-0.8.1.tar.gz", "has_sig": false, "md5_digest": "ada33619f3dabbe16a0c1d33b825fa22", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 51095, "upload_time": "2015-02-18T16:10:48", "upload_time_iso_8601": "2015-02-18T16:10:48.741663Z", "url": "https://files.pythonhosted.org/packages/9b/46/19fc00a477920b1780321b1ce10edd196ef1d01f93f106ad7e59d0c4c22b/cara-0.8.1.tar.gz", "yanked": false}], "0.9.0": [{"comment_text": "", "digests": {"md5": "c2e3cdade803cd00aea4f25093ea37d7", "sha256": "143620707770bc93e99fe654911051a1aefe87df17b1b59f468c06bc42a51dbd"}, "downloads": -1, "filename": "cara-0.9.0.tar.gz", "has_sig": false, "md5_digest": "c2e3cdade803cd00aea4f25093ea37d7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52450, "upload_time": "2015-02-24T21:31:52", "upload_time_iso_8601": "2015-02-24T21:31:52.201106Z", "url": "https://files.pythonhosted.org/packages/d8/5d/ebc7fcb180f5731fc10bd336c04b43f65eb45c6d3afeb69314a4cee85bc9/cara-0.9.0.tar.gz", "yanked": false}], "0.9.1": [{"comment_text": "", "digests": {"md5": "f2d20793dd6b742bcb6257ff0596d994", "sha256": "0a28c55e0813f47a3d68a19b3fbee0d930d460ff1003fa4df2363f17ec9b29b8"}, "downloads": -1, "filename": "cara-0.9.1.tar.gz", "has_sig": false, "md5_digest": "f2d20793dd6b742bcb6257ff0596d994", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 52559, "upload_time": "2015-02-24T22:45:31", "upload_time_iso_8601": "2015-02-24T22:45:31.985970Z", "url": "https://files.pythonhosted.org/packages/e6/ae/d060fc33051891bc39d17a8872c1828a7fb87c6c1b0f29b520d0522a9f2a/cara-0.9.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "a0b13f1b0c8c6248d6ba0d9e6b5c08d7", "sha256": "a2a8fa6c27af2725381b8417d466042d6030a0b884bb7d6cc147b58fad6e7686"}, "downloads": -1, "filename": "cara-0.10.3.tar.gz", "has_sig": false, "md5_digest": "a0b13f1b0c8c6248d6ba0d9e6b5c08d7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 53430, "upload_time": "2015-04-15T07:09:02", "upload_time_iso_8601": "2015-04-15T07:09:02.162041Z", "url": "https://files.pythonhosted.org/packages/fc/79/8118e63bc79969ceb1a27360dd21eed7ee528706e11fec6de2c7b1422cb5/cara-0.10.3.tar.gz", "yanked": false}], "timestamp": "Thu May  7 22:35:26 2020"}