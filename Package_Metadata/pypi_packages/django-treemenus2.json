{"info": {"author": "Julien Phalip", "author_email": "jphalip@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "Environment :: Web Environment", "Framework :: Django", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.5", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Topic :: Internet :: WWW/HTTP", "Topic :: Internet :: WWW/HTTP :: Dynamic Content", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "=================\r\nDjango Tree Menus\r\n=================\r\n\r\n.. image:: https://travis-ci.org/jphalip/django-treemenus.png\r\n\r\nThis is a simple and generic tree-like menuing system for Django_ with an\r\neasy-to-use admin interface. It covers all the essentials for building\r\ntree-structured menus and should be enough for a lot of projects.\r\nIt is also easily extendable if you need to add some special behaviour to\r\nyour menu items.\r\n\r\ndjango-treemenus works with Django 1.0 and above and with python 2.5 and above.\r\n\r\n.. _Django: http://www.djangoproject.com/\r\n\r\nInstallation\r\n============\r\n\r\nInstalling an official release\r\n------------------------------\r\n\r\ndjango-treemenus is available on PyPI, and can be installed using Pip::\r\n\r\n    pip install django-treemenus\r\n\r\nAlternatively, official source releases are made available at https://pypi.python.org/pypi/django-treemenus\r\n\r\nDownload the .zip distribution file and unpack it. Inside is a script\r\nnamed ``setup.py``. Run this command::\r\n\r\n    python setup.py install\r\n\r\n...and the package will install automatically.\r\n\r\nInstalling the development version\r\n----------------------------------\r\n\r\nIf you prefer to update Django Tree Menus occasionally to get the latest bug\r\nfixes and improvements before they are included in an official release, do a\r\ngit clone instead::\r\n\r\n    git clone https://github.com/jphalip/django-treemenus\r\n\r\nThen add the ``treemenus`` folder to your PYTHONPATH or symlink (junction, if\r\nyou're on Windows), such as in your Python's ``site-packages`` directory.\r\n\r\nHooking Tree Menus to your project\r\n----------------------------------\r\n\r\n1. Add ``treemenus`` to the ``INSTALLED_APPS`` setting of your\r\n   Django project.\r\n\r\n2. Create django-treemenus tables by running the following command from the\r\n   root of your project::\r\n\r\n    python manage.py syncdb\r\n\r\n3. Create and add your custom templates to your project template folder. These\r\n   templates are necessary to specify how you want your menus to be displayed\r\n   on your site (See further below for more details on the use of templates).\r\n   Some sample templates are also provided in the package to get you started.\r\n\r\nBasic use\r\n=========\r\n\r\nTo build a menu, log into the admin interface, and click \"Menus\" under\r\nthe Treemenus application section, then click \"Add menu\". Give your new\r\nmenu a name and then save.\r\n\r\nThen, to create menu items, click on your menu in the menu list. You will\r\nthen see a table in the bottom part of the page with only one item: the\r\nmenu's root. Click \"Add an item\", select its parent (obviously, since this\r\nis the first item you're creating you can only select the root). Fill out\r\nthe item's details and click \"Save\". The new item now shows up in the table.\r\nNow keep going to build the whole structure of your tree menu by creating as\r\nmany branches as you like.\r\n\r\nWhen you've finished building your menu from the admin interface, you will\r\nhave to write the appropriate templates to display the menu on your site\r\n(see below).\r\n\r\nTemplates used by django-treemenus\r\n==================================\r\n\r\nThe views included in django-treemenus use two templates. You need to create\r\nyour own templates into your template folder or any folder referenced in the\r\n``TEMPLATE_DIRS`` setting of your project.\r\n\r\n``treemenus/menu.html``\r\n-----------------------\r\n\r\nTemplate to specify how to display a menu.\r\n\r\n**Context:**\r\n\r\n* ``menu``\r\n    Pointer to the menu to display. You can access its root item with\r\n    ``menu.root_item``.\r\n\r\n* ``menu_type`` (optional)\r\n    This variable will only be present if it has been specified when\r\n    calling the ``show_menu`` template tag. (See the \"Template tags\"\r\n    section for more details).\r\n\r\n**Example for this template**::\r\n\r\n    {% load tree_menu_tags %}\r\n\r\n    {% ifequal menu_type \"unordered-list\" %}\r\n        <ul>\r\n            {% for menu_item in menu.root_item.children %}\r\n                {% show_menu_item menu_item %}\r\n            {% endfor %}\r\n        </ul>\r\n    {% endifequal %}\r\n    {% ifequal menu_type \"ordered-list\" %}\r\n        <ol>\r\n            {% for menu_item in menu.root_item.children %}\r\n                {% show_menu_item menu_item %}\r\n            {% endfor %}\r\n        </ol>\r\n    {% endifequal %}\r\n\r\n\r\n``treemenus/menu_item.html``\r\n----------------------------\r\n\r\nTemplate to specify how to display a menu item.\r\n\r\n**Context:**\r\n\r\n* ``menu_item``\r\n    Pointer to the menu_item to display. You can directly access all\r\n    its methods and variables.\r\n\r\n* ``menu_type`` (optional)\r\n    This variable will only be accessible if it has been specified when\r\n    calling the ``show_menu`` template tag (See the \"Template tags\"\r\n    section for more details).\r\n\r\n**Example for this template**::\r\n\r\n    {% load tree_menu_tags %}\r\n    <li><a href=\"{{ menu_item.url }}\">{{ menu_item.caption }}</a>\r\n        {% if menu_item.children %}\r\n        <ul>\r\n            {% for child_item in menu_item.children %}\r\n            {% show_menu_item child_item %}\r\n            {% endfor %}\r\n        </ul>\r\n        {% endif %}\r\n    </li>\r\n\r\n\r\nTemplate tags\r\n=============\r\n\r\nThere a 3 template tags to let you display your menus. To be able to use them\r\nyou will first have to load the library they are contained in, with::\r\n\r\n    {% load tree_menu_tags %}\r\n\r\n``show_menu``\r\n-------------\r\n\r\nThis is the starting point. Call it wherever you want to display your menu\r\n(most of the time it will be in your site's base template).\r\n\r\nThere are two attributes:\r\n\r\n* ``menu_name``\r\n    Name of the menu to display, as it has been saved via the admin interface.\r\n* ``menu_type``\r\n    This attribute is optional. If it is given it is simply\r\n    passed to the ``treemenus/menu.html`` template. It does\r\n    not have any particular pre-defined function but can be\r\n    tested with (% ifequal menu_type \"sometype\" %} to\r\n    determine how to display the menu (See above example for\r\n    the template ``treemenus/menu.html``).\r\n\r\n**Example of use**::\r\n\r\n    {% show_menu \"TopMenu\" %}\r\n    ...\r\n    {% show_menu \"LeftMenu\" \"vertical\" %}\r\n    ...\r\n    {% show_menu \"RightMenu\" \"horizontal\" %}\r\n\r\n``show_menu_item``\r\n------------------\r\n\r\nThis tag allows you to display a menu item, which is the only attribute.\r\n\r\n**Example of use**::\r\n\r\n    {% show_menu_item menu_item %}\r\n\r\n``reverse_named_url``\r\n---------------------\r\n\r\nThis tag allows you to reverse the named URL of a menu item, which is passed as a\r\nsingle string. To know more about named URLs, refer to `the Django template documentation`_.\r\nFor example, the passed value could be 'latest_news' or 'show_profile user.id', and that\r\nwould be reversed to the corresponding URL (as defined in your URLConf).\r\n\r\n.. _the Django template documentation: https://docs.djangoproject.com/en/dev/ref/templates/builtins/#url\r\n\r\n**Example of use**::\r\n\r\n    <li><a href=\"{% reverse_named_url menu_item.named_url %}\">{{ menu_item.caption }}</a></li>\r\n\r\nAttributes and methods\r\n======================\r\n\r\nAs you've guessed it, you can manipulate two types of objects: menus and menu\r\nitems. In this section I present their attributes and methods, which you can use\r\nin your templates.\r\n\r\nMenu\r\n----\r\n\r\nThere is only one attribute that is available: ``root_item``, which points to...\r\nyou got it, the menu's root item.\r\n\r\nMenu item\r\n---------\r\n\r\n* ``menu``\r\n    Returns the menu to which it belongs.\r\n\r\n* ``url``\r\n    Returns the item's url.\r\n\r\n    **Example of use**::\r\n\r\n        <li><a href=\"{{ menu_item.url }}\">{{ menu_item.caption }}</a></li>\r\n\r\n* ``parent``\r\n    Returns the menu item's parent (that is, another menu item).\r\n\r\n* ``rank``\r\n    Returns the item's rank amongst its siblings. The first item of a branch has\r\n    a rank of 0, the second one has a rank of 1, etc. To change an item's ranking\r\n    you can move it up or down through the admin interface.\r\n\r\n    **Example of use**::\r\n\r\n        <li><a class=\"menuitem-{{ menu_item.rank }}\" href=\"{{ menu_item.url }}\">{{ menu_item.caption }}</a></li>\r\n\r\n* ``level``\r\n    Returns the item's level in the hierarchy. This is automatically calculated by\r\n    the system. For example, the root item has a level 0, and its children have a\r\n    level 1.\r\n\r\n    **Example of use**::\r\n\r\n        {% ifequal menu_item.level 1 %}\r\n            <li><a class=\"top-item\" href=\"{{ menu_item.url }}\">{{ menu_item.caption }}</a></li>\r\n        {% else %}\r\n            <li><a href=\"{{ menu_item.url }}\">{{ menu_item.caption }}</a></li>\r\n        {% endifequal %}\r\n\r\n* ``caption``\r\n    Returns the item's caption.\r\n\r\n* ``named_url``\r\n    Use this attribute if you want to use named URLs instead of raw URLs.\r\n\r\n    **Example of use**::\r\n\r\n        <li><a href=\"{% reverse_named_url menu_item.named_url %}\">{{ menu_item.caption }}</a></li>\r\n\r\n* ``has_children``\r\n    Returns True if the item has some children, False otherwise.\r\n\r\n* ``children``\r\n    Returns a list with the menu item's children, ordered by rank.\r\n\r\n    **Example of use**::\r\n\r\n        {% if menu_item.has_children %}\r\n            <li><a class=\"daddy\" href=\"{{ menu_item.url }}\">{{ menu_item.caption }}</a>\r\n                <ul>\r\n                    {% for child in menu_item.children %}\r\n                        {% show_menu_item child %}\r\n                    {% endfor %}\r\n                </ul>\r\n            </li>\r\n        {% else %}\r\n            <li><a href=\"{{ menu_item.url }}\">{{ menu_item.caption }}</a></li>\r\n        {% endif %}\r\n\r\n* ``siblings``\r\n    Returns a list with the menu item's siblings (i.e all other items that have the\r\n    same parent), ordered by rank.\r\n\r\nCustomizing/Extending\r\n=====================\r\n\r\nThe attributes and methods enumerated above provide the essential behaviour for a\r\ntree-structured menu. If that is not enough for you, it is also possible to add\r\ncustomized behaviour by extending the menu item definition. To do so, you need to\r\ncreate a model class that will contain all the extra attributes for your menu items.\r\n\r\nTo illustrate this, let's say that you'd like to add a ``published`` attribute to your\r\nmenu items so that they only show up on your site if ``published`` is turned to ``True``.\r\n\r\nTo do so, create a new application (let's call it ``menu_extension``), with the following\r\nstructure::\r\n\r\n    menu_extension\r\n        __init__.py\r\n        models.py\r\n        forms.py\r\n\r\nThen, in ``menu_extension.models.py`` add the following::\r\n\r\n    from django.db import models\r\n    from treemenus.models import MenuItem\r\n\r\n    class MenuItemExtension(models.Model):\r\n        menu_item = models.OneToOneField (MenuItem, related_name=\"extension\")\r\n        published = models.BooleanField(default=False)\r\n\r\nIt is required that your extension object has the attribute ``menu_item`` that is a **unique** link\r\nto a menu item object. This is what makes the extension possible.\r\nThen you can notice our attribute ``published``, feel free to add any other attribute there to\r\ncustomize your menu items.\r\n\r\nYou then need to create the database table that will store your extension data by adding\r\n``menu_extension`` to the ``INSTALLED_APPS`` setting of your Django project, and then running\r\nthe following command from the root of your project::\r\n\r\n    python manage.py syncdb\r\n\r\nNow, you need to specify a form to let you edit those extra attributes from the admin interface.\r\nIn your project's ``admin.py`` or your extension menu app's ``admin.py``, add the following::\r\n\r\n    from django.contrib import admin\r\n    from treemenus.admin import MenuAdmin, MenuItemAdmin\r\n    from treemenus.models import Menu\r\n    from menu_extension.models import MenuItemExtension\r\n\r\n    class MenuItemExtensionInline(admin.StackedInline):\r\n        model = MenuItemExtension\r\n        max_num = 1\r\n\r\n    class CustomMenuItemAdmin(MenuItemAdmin):\r\n        inlines = [MenuItemExtensionInline,]\r\n\r\n    class CustomMenuAdmin(MenuAdmin):\r\n        menu_item_admin_class = CustomMenuItemAdmin\r\n\r\n    admin.site.unregister(Menu) # Unregister the standard admin options\r\n    admin.site.register(Menu, CustomMenuAdmin) # Register the new, customized, admin options\r\n\r\nAnd that's it! Now, when creating or editing a menu item, you'll see an inline form with\r\nall the extension attributes (in this example, the ``published`` check box).\r\n\r\nNow, if you want to use ``published`` attribute in your template, you need to use the\r\nmenu item's ``extension`` method, as follows::\r\n\r\n    {% if menu_item.extension.published %}\r\n        <li><a href=\"{{ menu_item.url }}\">{{ menu_item.caption }}</a></li>\r\n    {% endif %}\r\n\r\nYour menu items will now only appear if their ``published`` check box has been ticked.\r\n\r\nUsing this technique, you can obviously extend your menu items with whatever attribute\r\nyou'd like. Other examples might be that you want to add special CSS styles to certain\r\nmenu items, or to make some of them show up only if the user is logged in, etc. Simply\r\nadd attributes in you extension model and make use of them in your templates to create\r\nspecial behaviour. See the 'Tips and Tricks' section for more ideas.\r\n\r\nTips and tricks\r\n===============\r\n\r\nIn this section I give some examples on using or extending menus.\r\nThese may just cover some of your own specific needs or at least inspire you and get\r\nyou started to make the most out of your menus.\r\n\r\nInternationalization\r\n--------------------\r\n\r\nMaking your menus multi-lingual is very easy if you use the `Django internationalization`_\r\nmodule. What you can do is apply the translation to the ``caption`` attribute\r\nof a menu_item. For example::\r\n\r\n    {% load i18n %}\r\n    ...\r\n    <li><a href=\"{{ menu_item.url }}\">{% trans menu_item.caption %}</a></li>\r\n\r\nThen, add manually the translation entries in your ``*.po`` file.\r\n\r\n.. _Django internationalization: https://docs.djangoproject.com/en/dev/topics/i18n/\r\n\r\nIf you use more complex or custom translation systems, you may simply define your\r\nextension class (or create it if you don't already have one) with a method to manage\r\nthe translation, for example::\r\n\r\n    class MenuItemExtension(models.Model):\r\n        menu_item = models.OneToOneField (MenuItem, related_name=\"extension\")\r\n        ...\r\n\r\n        def translation():\r\n            translation = do_something_with(self.menu_item.caption)\r\n            return translation\r\n\r\nAnd then in your template::\r\n\r\n    <li><a href=\"{{ menu_item.url }}\">{% trans menu_item.extension.translation %}</a></li>\r\n\r\nLogin restriction\r\n-----------------\r\n\r\nIf you want to make some of your menus items private and only available to logged in\r\nusers, that's simple! Simply define your extension class (or create it if you don't\r\nalready have one) like the following::\r\n\r\n    class MenuItemExtension(models.Model):\r\n        menu_item = models.OneToOneField (MenuItem, related_name=\"extension\")\r\n        protected = models.BooleanField(default=False)\r\n        ...\r\n\r\nAnd then in your template::\r\n\r\n    {% if menu_item.extension.protected %}\r\n        {% if user.is_authenticated %}\r\n            <li><a href=\"{{ menu_item.url }}\">{{ menu_item.caption }}</a></li>\r\n        {% endif %}\r\n    {% else %}\r\n        <li><a href=\"{{ menu_item.url }}\">{{ menu_item.caption }}</a></li>\r\n    {% endif %}\r\n\r\n(assuming that the context variable 'user' represents the currently logged-in user)\r\n\r\nAutomatically select menu items\r\n-------------------------------\r\n\r\nHere I'm going to explain how to automatically select a menu item when visiting\r\na given page of your site. This is a good example to illustrate the power of\r\nextensions for customizing your menu's behaviour.\r\nFor this example, let's say that you'd like to visually select the menu item\r\n'Contact' when visiting the url 'http://www.example.com/contact/'\r\n\r\nFirst, define your extension class (or create it if you don't already have one)\r\nlike the following::\r\n\r\n    class MenuItemExtension(models.Model):\r\n        menu_item = models.OneToOneField (MenuItem, related_name=\"extension\")\r\n        selected_patterns = models.TextField(blank=True)\r\n\r\n``selected_patterns`` is the attribute which will specify for what urls the menu\r\nitem should have the 'selected' status.\r\nRefer to the section on extensions above to see how to hook your extension class\r\nto your menus.\r\n\r\nNow, in the admin section, edit the 'Contact' menu item and type the following\r\nline in its ``selected_patterns`` textfield::\r\n\r\n    ^/contact/$\r\n\r\nHere we're using regular expressions so that gives us some flexibility to specify\r\nour 'selected' url patterns. Refer to the official python documentation on\r\n`regular expressions syntax`_ for more detailed information. In this example we're\r\nonly using one regular expression pattern (^/contact/$) but you could add as many\r\nas you'd like by typing a different pattern on each line of the textfield.\r\n\r\n.. _regular expressions syntax: http://docs.python.org/lib/re-syntax.html\r\n\r\nThen, in your ``menu_item.html`` template, use the following 'if' statement::\r\n\r\n    {% load menu_extension_filters %}\r\n    ...\r\n    <li><a href=\"{{ menu_item.url }}\" class=\"{% if menu_item.extension.selected_patterns|match_path:request.path %}selected{% endif %}\">{{ menu_item.caption }}</a></li>\r\n\r\nWith this code, every menu item whose attribute ``selected_patterns`` matches the\r\ncurrent url will be given the 'selected' CSS class (it's up to you to define in\r\nyour style sheet what that 'selected' class actually does - maybe change the colour\r\nor the font?). In this example we're allocating a special style to visually\r\ndistinguish the selected menu items, but you're obviously free to use the 'if'\r\nstatement above to do any form of disctinction you like (for example displaying\r\nall children of a selected menu, etc.)\r\nDon't forget to load the ``menu_extension_filters`` module, which we're going to\r\ncreate in a moment.\r\n\r\nWe now need to create the 'match_path' filter. In your ``menu_extension``\r\napplication (or whatever name you've given to your menu extension application)\r\ncreate a directory ``templatetags`` containing two files: ``__init__.py`` (leave it\r\nempty) and ``menu_extension_filters.py`` containing the following code::\r\n\r\n    import re\r\n    from django import template\r\n\r\n    register = template.Library()\r\n\r\n    def match_path(patterns, path):\r\n        if patterns:\r\n            for pattern in patterns.splitlines():\r\n                if re.compile(pattern).match(path):\r\n                    return True\r\n        return False\r\n    register.filter('match_path', match_path)\r\n\r\nWhat it does is test each pattern on each line of our patterns (remember, you can\r\nadd one pattern on each line of the ``selected_patterns`` textfield) and returns\r\ntrue if any of those matches the given path.\r\n\r\nFinally, to be able to access the current url through ``request.path`` in your\r\ntemplate, you need to do 2 things:\r\n\r\n1) Add ``django.core.context_processors.request`` to your\r\n``TEMPLATE_CONTEXT_PROCESSORS`` setting (see the Django documentation on `context\r\nprocessors`_ for more details).\r\n\r\n.. _context processors: https://docs.djangoproject.com/en/dev/ref/templates/api/#django-core-context-processors-request\r\n\r\n2) Use a RequestContext object in your views to pass to your templates. (see Django\r\ndocumentation on RequestContext_).\r\n\r\n.. _RequestContext: https://docs.djangoproject.com/en/dev/ref/templates/api/#subclassing-context-requestcontext\r\n\r\nThat's it!!\r\n===========\r\n\r\nPlease log any issue or bug report at https://github.com/jphalip/django-treemenus/issues\r\n\r\nEnjoy!\r\n\r\n`Julien Phalip`_ (project developer)\r\n\r\n.. _Julien Phalip: https://twitter.com/julienphalip\r\n", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/jphalip/django-treemenus/", "keywords": null, "license": "BSD", "maintainer": null, "maintainer_email": null, "name": "django-treemenus2", "package_url": "https://pypi.org/project/django-treemenus2/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/django-treemenus2/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/jphalip/django-treemenus/"}, "release_url": "https://pypi.org/project/django-treemenus2/0.9.3/", "requires_dist": null, "requires_python": null, "summary": "Tree-structured menuing application for Django.", "version": "0.9.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <img alt=\"https://travis-ci.org/jphalip/django-treemenus.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/400a60f3d703c5d90c13d1c4777d992847f62c7b/68747470733a2f2f7472617669732d63692e6f72672f6a7068616c69702f646a616e676f2d747265656d656e75732e706e67\">\n<p>This is a simple and generic tree-like menuing system for <a href=\"http://www.djangoproject.com/\" rel=\"nofollow\">Django</a> with an\neasy-to-use admin interface. It covers all the essentials for building\ntree-structured menus and should be enough for a lot of projects.\nIt is also easily extendable if you need to add some special behaviour to\nyour menu items.</p>\n<p>django-treemenus works with Django 1.0 and above and with python 2.5 and above.</p>\n<div id=\"installation\">\n<h2>Installation</h2>\n<div id=\"installing-an-official-release\">\n<h3>Installing an official release</h3>\n<p>django-treemenus is available on PyPI, and can be installed using Pip:</p>\n<pre>pip install django-treemenus\n</pre>\n<p>Alternatively, official source releases are made available at <a href=\"https://pypi.python.org/pypi/django-treemenus\" rel=\"nofollow\">https://pypi.python.org/pypi/django-treemenus</a></p>\n<p>Download the .zip distribution file and unpack it. Inside is a script\nnamed <tt>setup.py</tt>. Run this command:</p>\n<pre>python setup.py install\n</pre>\n<p>\u2026and the package will install automatically.</p>\n</div>\n<div id=\"installing-the-development-version\">\n<h3>Installing the development version</h3>\n<p>If you prefer to update Django Tree Menus occasionally to get the latest bug\nfixes and improvements before they are included in an official release, do a\ngit clone instead:</p>\n<pre>git clone https://github.com/jphalip/django-treemenus\n</pre>\n<p>Then add the <tt>treemenus</tt> folder to your PYTHONPATH or symlink (junction, if\nyou\u2019re on Windows), such as in your Python\u2019s <tt><span class=\"pre\">site-packages</span></tt> directory.</p>\n</div>\n<div id=\"hooking-tree-menus-to-your-project\">\n<h3>Hooking Tree Menus to your project</h3>\n<ol>\n<li><p>Add <tt>treemenus</tt> to the <tt>INSTALLED_APPS</tt> setting of your\nDjango project.</p>\n</li>\n<li><p>Create django-treemenus tables by running the following command from the\nroot of your project:</p>\n<pre>python manage.py syncdb\n</pre>\n</li>\n<li><p>Create and add your custom templates to your project template folder. These\ntemplates are necessary to specify how you want your menus to be displayed\non your site (See further below for more details on the use of templates).\nSome sample templates are also provided in the package to get you started.</p>\n</li>\n</ol>\n</div>\n</div>\n<div id=\"basic-use\">\n<h2>Basic use</h2>\n<p>To build a menu, log into the admin interface, and click \u201cMenus\u201d under\nthe Treemenus application section, then click \u201cAdd menu\u201d. Give your new\nmenu a name and then save.</p>\n<p>Then, to create menu items, click on your menu in the menu list. You will\nthen see a table in the bottom part of the page with only one item: the\nmenu\u2019s root. Click \u201cAdd an item\u201d, select its parent (obviously, since this\nis the first item you\u2019re creating you can only select the root). Fill out\nthe item\u2019s details and click \u201cSave\u201d. The new item now shows up in the table.\nNow keep going to build the whole structure of your tree menu by creating as\nmany branches as you like.</p>\n<p>When you\u2019ve finished building your menu from the admin interface, you will\nhave to write the appropriate templates to display the menu on your site\n(see below).</p>\n</div>\n<div id=\"templates-used-by-django-treemenus\">\n<h2>Templates used by django-treemenus</h2>\n<p>The views included in django-treemenus use two templates. You need to create\nyour own templates into your template folder or any folder referenced in the\n<tt>TEMPLATE_DIRS</tt> setting of your project.</p>\n<div id=\"treemenus-menu-html\">\n<h3><tt>treemenus/menu.html</tt></h3>\n<p>Template to specify how to display a menu.</p>\n<p><strong>Context:</strong></p>\n<ul>\n<li><dl>\n<dt><tt>menu</tt></dt>\n<dd>Pointer to the menu to display. You can access its root item with\n<tt>menu.root_item</tt>.</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>menu_type</tt> (optional)</dt>\n<dd>This variable will only be present if it has been specified when\ncalling the <tt>show_menu</tt> template tag. (See the \u201cTemplate tags\u201d\nsection for more details).</dd>\n</dl>\n</li>\n</ul>\n<p><strong>Example for this template</strong>:</p>\n<pre>{% load tree_menu_tags %}\n\n{% ifequal menu_type \"unordered-list\" %}\n    &lt;ul&gt;\n        {% for menu_item in menu.root_item.children %}\n            {% show_menu_item menu_item %}\n        {% endfor %}\n    &lt;/ul&gt;\n{% endifequal %}\n{% ifequal menu_type \"ordered-list\" %}\n    &lt;ol&gt;\n        {% for menu_item in menu.root_item.children %}\n            {% show_menu_item menu_item %}\n        {% endfor %}\n    &lt;/ol&gt;\n{% endifequal %}\n</pre>\n</div>\n<div id=\"treemenus-menu-item-html\">\n<h3><tt>treemenus/menu_item.html</tt></h3>\n<p>Template to specify how to display a menu item.</p>\n<p><strong>Context:</strong></p>\n<ul>\n<li><dl>\n<dt><tt>menu_item</tt></dt>\n<dd>Pointer to the menu_item to display. You can directly access all\nits methods and variables.</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>menu_type</tt> (optional)</dt>\n<dd>This variable will only be accessible if it has been specified when\ncalling the <tt>show_menu</tt> template tag (See the \u201cTemplate tags\u201d\nsection for more details).</dd>\n</dl>\n</li>\n</ul>\n<p><strong>Example for this template</strong>:</p>\n<pre>{% load tree_menu_tags %}\n&lt;li&gt;&lt;a href=\"{{ menu_item.url }}\"&gt;{{ menu_item.caption }}&lt;/a&gt;\n    {% if menu_item.children %}\n    &lt;ul&gt;\n        {% for child_item in menu_item.children %}\n        {% show_menu_item child_item %}\n        {% endfor %}\n    &lt;/ul&gt;\n    {% endif %}\n&lt;/li&gt;\n</pre>\n</div>\n</div>\n<div id=\"template-tags\">\n<h2>Template tags</h2>\n<p>There a 3 template tags to let you display your menus. To be able to use them\nyou will first have to load the library they are contained in, with:</p>\n<pre>{% load tree_menu_tags %}\n</pre>\n<div id=\"show-menu\">\n<h3><tt>show_menu</tt></h3>\n<p>This is the starting point. Call it wherever you want to display your menu\n(most of the time it will be in your site\u2019s base template).</p>\n<p>There are two attributes:</p>\n<ul>\n<li><dl>\n<dt><tt>menu_name</tt></dt>\n<dd>Name of the menu to display, as it has been saved via the admin interface.</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>menu_type</tt></dt>\n<dd>This attribute is optional. If it is given it is simply\npassed to the <tt>treemenus/menu.html</tt> template. It does\nnot have any particular pre-defined function but can be\ntested with (% ifequal menu_type \u201csometype\u201d %} to\ndetermine how to display the menu (See above example for\nthe template <tt>treemenus/menu.html</tt>).</dd>\n</dl>\n</li>\n</ul>\n<p><strong>Example of use</strong>:</p>\n<pre>{% show_menu \"TopMenu\" %}\n...\n{% show_menu \"LeftMenu\" \"vertical\" %}\n...\n{% show_menu \"RightMenu\" \"horizontal\" %}\n</pre>\n</div>\n<div id=\"show-menu-item\">\n<h3><tt>show_menu_item</tt></h3>\n<p>This tag allows you to display a menu item, which is the only attribute.</p>\n<p><strong>Example of use</strong>:</p>\n<pre>{% show_menu_item menu_item %}\n</pre>\n</div>\n<div id=\"reverse-named-url\">\n<h3><tt>reverse_named_url</tt></h3>\n<p>This tag allows you to reverse the named URL of a menu item, which is passed as a\nsingle string. To know more about named URLs, refer to <a href=\"https://docs.djangoproject.com/en/dev/ref/templates/builtins/#url\" rel=\"nofollow\">the Django template documentation</a>.\nFor example, the passed value could be \u2018latest_news\u2019 or \u2018show_profile user.id\u2019, and that\nwould be reversed to the corresponding URL (as defined in your URLConf).</p>\n<p><strong>Example of use</strong>:</p>\n<pre>&lt;li&gt;&lt;a href=\"{% reverse_named_url menu_item.named_url %}\"&gt;{{ menu_item.caption }}&lt;/a&gt;&lt;/li&gt;\n</pre>\n</div>\n</div>\n<div id=\"attributes-and-methods\">\n<h2>Attributes and methods</h2>\n<p>As you\u2019ve guessed it, you can manipulate two types of objects: menus and menu\nitems. In this section I present their attributes and methods, which you can use\nin your templates.</p>\n<div id=\"menu\">\n<h3>Menu</h3>\n<p>There is only one attribute that is available: <tt>root_item</tt>, which points to\u2026\nyou got it, the menu\u2019s root item.</p>\n</div>\n<div id=\"menu-item\">\n<h3>Menu item</h3>\n<ul>\n<li><dl>\n<dt><tt>menu</tt></dt>\n<dd><p>Returns the menu to which it belongs.</p>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>url</tt></dt>\n<dd><p>Returns the item\u2019s url.</p>\n<p><strong>Example of use</strong>:</p>\n<pre>&lt;li&gt;&lt;a href=\"{{ menu_item.url }}\"&gt;{{ menu_item.caption }}&lt;/a&gt;&lt;/li&gt;\n</pre>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>parent</tt></dt>\n<dd><p>Returns the menu item\u2019s parent (that is, another menu item).</p>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>rank</tt></dt>\n<dd><p>Returns the item\u2019s rank amongst its siblings. The first item of a branch has\na rank of 0, the second one has a rank of 1, etc. To change an item\u2019s ranking\nyou can move it up or down through the admin interface.</p>\n<p><strong>Example of use</strong>:</p>\n<pre>&lt;li&gt;&lt;a class=\"menuitem-{{ menu_item.rank }}\" href=\"{{ menu_item.url }}\"&gt;{{ menu_item.caption }}&lt;/a&gt;&lt;/li&gt;\n</pre>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>level</tt></dt>\n<dd><p>Returns the item\u2019s level in the hierarchy. This is automatically calculated by\nthe system. For example, the root item has a level 0, and its children have a\nlevel 1.</p>\n<p><strong>Example of use</strong>:</p>\n<pre>{% ifequal menu_item.level 1 %}\n    &lt;li&gt;&lt;a class=\"top-item\" href=\"{{ menu_item.url }}\"&gt;{{ menu_item.caption }}&lt;/a&gt;&lt;/li&gt;\n{% else %}\n    &lt;li&gt;&lt;a href=\"{{ menu_item.url }}\"&gt;{{ menu_item.caption }}&lt;/a&gt;&lt;/li&gt;\n{% endifequal %}\n</pre>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>caption</tt></dt>\n<dd><p>Returns the item\u2019s caption.</p>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>named_url</tt></dt>\n<dd><p>Use this attribute if you want to use named URLs instead of raw URLs.</p>\n<p><strong>Example of use</strong>:</p>\n<pre>&lt;li&gt;&lt;a href=\"{% reverse_named_url menu_item.named_url %}\"&gt;{{ menu_item.caption }}&lt;/a&gt;&lt;/li&gt;\n</pre>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>has_children</tt></dt>\n<dd><p>Returns True if the item has some children, False otherwise.</p>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>children</tt></dt>\n<dd><p>Returns a list with the menu item\u2019s children, ordered by rank.</p>\n<p><strong>Example of use</strong>:</p>\n<pre>{% if menu_item.has_children %}\n    &lt;li&gt;&lt;a class=\"daddy\" href=\"{{ menu_item.url }}\"&gt;{{ menu_item.caption }}&lt;/a&gt;\n        &lt;ul&gt;\n            {% for child in menu_item.children %}\n                {% show_menu_item child %}\n            {% endfor %}\n        &lt;/ul&gt;\n    &lt;/li&gt;\n{% else %}\n    &lt;li&gt;&lt;a href=\"{{ menu_item.url }}\"&gt;{{ menu_item.caption }}&lt;/a&gt;&lt;/li&gt;\n{% endif %}\n</pre>\n</dd>\n</dl>\n</li>\n<li><dl>\n<dt><tt>siblings</tt></dt>\n<dd><p>Returns a list with the menu item\u2019s siblings (i.e all other items that have the\nsame parent), ordered by rank.</p>\n</dd>\n</dl>\n</li>\n</ul>\n</div>\n</div>\n<div id=\"customizing-extending\">\n<h2>Customizing/Extending</h2>\n<p>The attributes and methods enumerated above provide the essential behaviour for a\ntree-structured menu. If that is not enough for you, it is also possible to add\ncustomized behaviour by extending the menu item definition. To do so, you need to\ncreate a model class that will contain all the extra attributes for your menu items.</p>\n<p>To illustrate this, let\u2019s say that you\u2019d like to add a <tt>published</tt> attribute to your\nmenu items so that they only show up on your site if <tt>published</tt> is turned to <tt>True</tt>.</p>\n<p>To do so, create a new application (let\u2019s call it <tt>menu_extension</tt>), with the following\nstructure:</p>\n<pre>menu_extension\n    __init__.py\n    models.py\n    forms.py\n</pre>\n<p>Then, in <tt>menu_extension.models.py</tt> add the following:</p>\n<pre>from django.db import models\nfrom treemenus.models import MenuItem\n\nclass MenuItemExtension(models.Model):\n    menu_item = models.OneToOneField (MenuItem, related_name=\"extension\")\n    published = models.BooleanField(default=False)\n</pre>\n<p>It is required that your extension object has the attribute <tt>menu_item</tt> that is a <strong>unique</strong> link\nto a menu item object. This is what makes the extension possible.\nThen you can notice our attribute <tt>published</tt>, feel free to add any other attribute there to\ncustomize your menu items.</p>\n<p>You then need to create the database table that will store your extension data by adding\n<tt>menu_extension</tt> to the <tt>INSTALLED_APPS</tt> setting of your Django project, and then running\nthe following command from the root of your project:</p>\n<pre>python manage.py syncdb\n</pre>\n<p>Now, you need to specify a form to let you edit those extra attributes from the admin interface.\nIn your project\u2019s <tt>admin.py</tt> or your extension menu app\u2019s <tt>admin.py</tt>, add the following:</p>\n<pre>from django.contrib import admin\nfrom treemenus.admin import MenuAdmin, MenuItemAdmin\nfrom treemenus.models import Menu\nfrom menu_extension.models import MenuItemExtension\n\nclass MenuItemExtensionInline(admin.StackedInline):\n    model = MenuItemExtension\n    max_num = 1\n\nclass CustomMenuItemAdmin(MenuItemAdmin):\n    inlines = [MenuItemExtensionInline,]\n\nclass CustomMenuAdmin(MenuAdmin):\n    menu_item_admin_class = CustomMenuItemAdmin\n\nadmin.site.unregister(Menu) # Unregister the standard admin options\nadmin.site.register(Menu, CustomMenuAdmin) # Register the new, customized, admin options\n</pre>\n<p>And that\u2019s it! Now, when creating or editing a menu item, you\u2019ll see an inline form with\nall the extension attributes (in this example, the <tt>published</tt> check box).</p>\n<p>Now, if you want to use <tt>published</tt> attribute in your template, you need to use the\nmenu item\u2019s <tt>extension</tt> method, as follows:</p>\n<pre>{% if menu_item.extension.published %}\n    &lt;li&gt;&lt;a href=\"{{ menu_item.url }}\"&gt;{{ menu_item.caption }}&lt;/a&gt;&lt;/li&gt;\n{% endif %}\n</pre>\n<p>Your menu items will now only appear if their <tt>published</tt> check box has been ticked.</p>\n<p>Using this technique, you can obviously extend your menu items with whatever attribute\nyou\u2019d like. Other examples might be that you want to add special CSS styles to certain\nmenu items, or to make some of them show up only if the user is logged in, etc. Simply\nadd attributes in you extension model and make use of them in your templates to create\nspecial behaviour. See the \u2018Tips and Tricks\u2019 section for more ideas.</p>\n</div>\n<div id=\"tips-and-tricks\">\n<h2>Tips and tricks</h2>\n<p>In this section I give some examples on using or extending menus.\nThese may just cover some of your own specific needs or at least inspire you and get\nyou started to make the most out of your menus.</p>\n<div id=\"internationalization\">\n<h3>Internationalization</h3>\n<p>Making your menus multi-lingual is very easy if you use the <a href=\"https://docs.djangoproject.com/en/dev/topics/i18n/\" rel=\"nofollow\">Django internationalization</a>\nmodule. What you can do is apply the translation to the <tt>caption</tt> attribute\nof a menu_item. For example:</p>\n<pre>{% load i18n %}\n...\n&lt;li&gt;&lt;a href=\"{{ menu_item.url }}\"&gt;{% trans menu_item.caption %}&lt;/a&gt;&lt;/li&gt;\n</pre>\n<p>Then, add manually the translation entries in your <tt>*.po</tt> file.</p>\n<p>If you use more complex or custom translation systems, you may simply define your\nextension class (or create it if you don\u2019t already have one) with a method to manage\nthe translation, for example:</p>\n<pre>class MenuItemExtension(models.Model):\n    menu_item = models.OneToOneField (MenuItem, related_name=\"extension\")\n    ...\n\n    def translation():\n        translation = do_something_with(self.menu_item.caption)\n        return translation\n</pre>\n<p>And then in your template:</p>\n<pre>&lt;li&gt;&lt;a href=\"{{ menu_item.url }}\"&gt;{% trans menu_item.extension.translation %}&lt;/a&gt;&lt;/li&gt;\n</pre>\n</div>\n<div id=\"login-restriction\">\n<h3>Login restriction</h3>\n<p>If you want to make some of your menus items private and only available to logged in\nusers, that\u2019s simple! Simply define your extension class (or create it if you don\u2019t\nalready have one) like the following:</p>\n<pre>class MenuItemExtension(models.Model):\n    menu_item = models.OneToOneField (MenuItem, related_name=\"extension\")\n    protected = models.BooleanField(default=False)\n    ...\n</pre>\n<p>And then in your template:</p>\n<pre>{% if menu_item.extension.protected %}\n    {% if user.is_authenticated %}\n        &lt;li&gt;&lt;a href=\"{{ menu_item.url }}\"&gt;{{ menu_item.caption }}&lt;/a&gt;&lt;/li&gt;\n    {% endif %}\n{% else %}\n    &lt;li&gt;&lt;a href=\"{{ menu_item.url }}\"&gt;{{ menu_item.caption }}&lt;/a&gt;&lt;/li&gt;\n{% endif %}\n</pre>\n<p>(assuming that the context variable \u2018user\u2019 represents the currently logged-in user)</p>\n</div>\n<div id=\"automatically-select-menu-items\">\n<h3>Automatically select menu items</h3>\n<p>Here I\u2019m going to explain how to automatically select a menu item when visiting\na given page of your site. This is a good example to illustrate the power of\nextensions for customizing your menu\u2019s behaviour.\nFor this example, let\u2019s say that you\u2019d like to visually select the menu item\n\u2018Contact\u2019 when visiting the url \u2018<a href=\"http://www.example.com/contact/\" rel=\"nofollow\">http://www.example.com/contact/</a>\u2019</p>\n<p>First, define your extension class (or create it if you don\u2019t already have one)\nlike the following:</p>\n<pre>class MenuItemExtension(models.Model):\n    menu_item = models.OneToOneField (MenuItem, related_name=\"extension\")\n    selected_patterns = models.TextField(blank=True)\n</pre>\n<p><tt>selected_patterns</tt> is the attribute which will specify for what urls the menu\nitem should have the \u2018selected\u2019 status.\nRefer to the section on extensions above to see how to hook your extension class\nto your menus.</p>\n<p>Now, in the admin section, edit the \u2018Contact\u2019 menu item and type the following\nline in its <tt>selected_patterns</tt> textfield:</p>\n<pre>^/contact/$\n</pre>\n<p>Here we\u2019re using regular expressions so that gives us some flexibility to specify\nour \u2018selected\u2019 url patterns. Refer to the official python documentation on\n<a href=\"http://docs.python.org/lib/re-syntax.html\" rel=\"nofollow\">regular expressions syntax</a> for more detailed information. In this example we\u2019re\nonly using one regular expression pattern (^/contact/$) but you could add as many\nas you\u2019d like by typing a different pattern on each line of the textfield.</p>\n<p>Then, in your <tt>menu_item.html</tt> template, use the following \u2018if\u2019 statement:</p>\n<pre>{% load menu_extension_filters %}\n...\n&lt;li&gt;&lt;a href=\"{{ menu_item.url }}\" class=\"{% if menu_item.extension.selected_patterns|match_path:request.path %}selected{% endif %}\"&gt;{{ menu_item.caption }}&lt;/a&gt;&lt;/li&gt;\n</pre>\n<p>With this code, every menu item whose attribute <tt>selected_patterns</tt> matches the\ncurrent url will be given the \u2018selected\u2019 CSS class (it\u2019s up to you to define in\nyour style sheet what that \u2018selected\u2019 class actually does - maybe change the colour\nor the font?). In this example we\u2019re allocating a special style to visually\ndistinguish the selected menu items, but you\u2019re obviously free to use the \u2018if\u2019\nstatement above to do any form of disctinction you like (for example displaying\nall children of a selected menu, etc.)\nDon\u2019t forget to load the <tt>menu_extension_filters</tt> module, which we\u2019re going to\ncreate in a moment.</p>\n<p>We now need to create the \u2018match_path\u2019 filter. In your <tt>menu_extension</tt>\napplication (or whatever name you\u2019ve given to your menu extension application)\ncreate a directory <tt>templatetags</tt> containing two files: <tt>__init__.py</tt> (leave it\nempty) and <tt>menu_extension_filters.py</tt> containing the following code:</p>\n<pre>import re\nfrom django import template\n\nregister = template.Library()\n\ndef match_path(patterns, path):\n    if patterns:\n        for pattern in patterns.splitlines():\n            if re.compile(pattern).match(path):\n                return True\n    return False\nregister.filter('match_path', match_path)\n</pre>\n<p>What it does is test each pattern on each line of our patterns (remember, you can\nadd one pattern on each line of the <tt>selected_patterns</tt> textfield) and returns\ntrue if any of those matches the given path.</p>\n<p>Finally, to be able to access the current url through <tt>request.path</tt> in your\ntemplate, you need to do 2 things:</p>\n<p>1) Add <tt>django.core.context_processors.request</tt> to your\n<tt>TEMPLATE_CONTEXT_PROCESSORS</tt> setting (see the Django documentation on <a href=\"https://docs.djangoproject.com/en/dev/ref/templates/api/#django-core-context-processors-request\" rel=\"nofollow\">context\nprocessors</a> for more details).</p>\n<p>2) Use a RequestContext object in your views to pass to your templates. (see Django\ndocumentation on <a href=\"https://docs.djangoproject.com/en/dev/ref/templates/api/#subclassing-context-requestcontext\" rel=\"nofollow\">RequestContext</a>).</p>\n</div>\n</div>\n<div id=\"that-s-it\">\n<h2>That\u2019s it!!</h2>\n<p>Please log any issue or bug report at <a href=\"https://github.com/jphalip/django-treemenus/issues\" rel=\"nofollow\">https://github.com/jphalip/django-treemenus/issues</a></p>\n<p>Enjoy!</p>\n<p><a href=\"https://twitter.com/julienphalip\" rel=\"nofollow\">Julien Phalip</a> (project developer)</p>\n</div>\n\n          </div>"}, "last_serial": 1856106, "releases": {"0.9.2a0": [{"comment_text": "", "digests": {"md5": "b5f75832adb62a40d9bd98cd7a414eca", "sha256": "0b7e59fd7e1f8db8b200a24ab96b355c85ee33e640ebc4920eba0607a99e44f2"}, "downloads": -1, "filename": "django-treemenus2-0.9.2a0.tar.gz", "has_sig": false, "md5_digest": "b5f75832adb62a40d9bd98cd7a414eca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18412, "upload_time": "2015-12-10T18:23:20", "upload_time_iso_8601": "2015-12-10T18:23:20.649412Z", "url": "https://files.pythonhosted.org/packages/b1/5c/010f8c658412b439400b6e8b8f1eec422f54020b0ddd3874f0119eae22a4/django-treemenus2-0.9.2a0.tar.gz", "yanked": false}], "0.9.3": [{"comment_text": "", "digests": {"md5": "006c55cee72ee7af80d1e3d621c6eda8", "sha256": "618e73cf85ae6dfb7222ab879681f01325ce3248c897c36950c512b15d4a801d"}, "downloads": -1, "filename": "django-treemenus2-0.9.3.tar.gz", "has_sig": false, "md5_digest": "006c55cee72ee7af80d1e3d621c6eda8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18401, "upload_time": "2015-12-10T18:25:42", "upload_time_iso_8601": "2015-12-10T18:25:42.091227Z", "url": "https://files.pythonhosted.org/packages/8d/fb/663b02fc9bc4d238cd5563efb9c857bb3a8fc484852af79d8e1b5979070e/django-treemenus2-0.9.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "006c55cee72ee7af80d1e3d621c6eda8", "sha256": "618e73cf85ae6dfb7222ab879681f01325ce3248c897c36950c512b15d4a801d"}, "downloads": -1, "filename": "django-treemenus2-0.9.3.tar.gz", "has_sig": false, "md5_digest": "006c55cee72ee7af80d1e3d621c6eda8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18401, "upload_time": "2015-12-10T18:25:42", "upload_time_iso_8601": "2015-12-10T18:25:42.091227Z", "url": "https://files.pythonhosted.org/packages/8d/fb/663b02fc9bc4d238cd5563efb9c857bb3a8fc484852af79d8e1b5979070e/django-treemenus2-0.9.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:52:19 2020"}