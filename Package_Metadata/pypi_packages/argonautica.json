{"info": {"author": "Brian Myers", "author_email": "brian.carl.myers@gmail.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "License :: OSI Approved :: MIT License", "Operating System :: MacOS :: MacOS X", "Operating System :: Microsoft :: Windows", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3 :: Only", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Programming Language :: Rust", "Topic :: Security :: Cryptography"], "description": "# argonautica-py\n\n[![Build Status](https://travis-ci.org/bcmyers/argonautica.svg?branch=master)](https://travis-ci.org/bcmyers/argonautica)\n[![Github.com](https://img.shields.io/badge/github-bcmyers%2Fargonautica-blue.svg)](http://www.github.com/bcmyers/argonautica)\n![License](https://img.shields.io/crates/l/argonautica.svg)\n[![PyPI](https://img.shields.io/pypi/v/argonautica.svg)](https://pypi.org/project/argonautica)\n\n## Overview\n\n**argonautica** is a Python package for hashing passwords that uses the cryptographically-secure [argon2](https://en.wikipedia.org/wiki/Argon2) hashing algorithm.\n\nArgon2 won the [Password Hashing Competition](https://password-hashing.net/) in 2015, a several year project to identify a successor to [bcrypt](https://en.wikipedia.org/wiki/Bcrypt), [scrypt](https://en.wikipedia.org/wiki/Scrypt), and other common hashing algorithms.\n\n**argonautica** was built with a simple use-case in mind: hashing passwords for storage in a\nwebsite's database. That said, it's also \"feature-complete\", meaning anything you can do with\nthe cannonical [C implementation](https://github.com/P-H-C/phc-winner-argon2) of argon2\nyou can do with argonautica\\*.\n\n<i>\\* Indeed, argonautica has a feature that even the cannonical C implementation\nlacks, i.e. hashing passwords with secret keys (the C implementation implements this, but\ndoes not expose it publicly)</i>\n\n## Alternatives\n\nThere are several Python packages that implement argon2, including the excellent [passlib](http://passlib.readthedocs.io/en/stable/), which uses [argon2_cffi](https://github.com/hynek/argon2_cffi), but...\n\n- AFAIK, **argonautica** is the only Python implementation of argon2 that supports hashing with secret keys. Not even the [cannonical C implementation](https://github.com/P-H-C/phc-winner-argon2) of argon2 exposes this feature publicly (it's in the code, but unfortunately not accessable via the public API).\n\n- **argonautica** is the only Python implementation of argon2 to use [SIMD](https://en.wikipedia.org/wiki/SIMD) instructions to peform it's hashing algorithm, which means it can be quite fast. The downside is that you have to compile it for your specific machine (this is why the `pip install argonautica` process takes time). That said, on the developer's early 2014 Macbook Air, which has [SIMD](https://en.wikipedia.org/wiki/SIMD) instruction through [AVX2](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions), argonautica runs ~30% faster than passlib on default settings.\n\n- **argonautica** supports the latest argon2 variant: argon2id, which, unless you have a reason not to, you should be using. A number of Python implementations do not yet support this variant.\n\n- Finally, **argonautica** is the only Python implementation of argon2 written in [Rust](https://www.rust-lang.org/en-US/) (as opposed to C or C++). [Rust](https://www.rust-lang.org/en-US/) is a \\\"systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.\\\"\n\n## Requirements\n\n- [Python](https://www.python.org/) version 3.4 or higher (or [PyPy](http://pypy.org/) version 3.5 or higher)\n- [Rust](https://www.rust-lang.org/en-US/) version 1.26 or higher\n- [LLVM](https://llvm.org/) version 3.9 or higher\n\n## Installation\n\n- **Rust:**\n  - Follow the instructions [here](https://www.rust-lang.org/en-US/install.html), which will just tell you to run the following command in your terminal and follow the on-screen instructions: `curl https://sh.rustup.rs -sSf \\| sh`\n- **LLVM:**\n  - macOS: `brew install llvm`, which requires [Homebrew](https://brew.sh/)\n  - Debian-based linux: `apt-get install llvm-dev libclang-dev clang`\n  - Arch linux: `pacman -S clang`\n  - Other linux: Use your distribution's package manager\n  - Windows: Download a pre-built binary [here](http://releases.llvm.org/download.html)\n- **argonautica:**\n  - `pip install --upgrade pip` or `pip install setuptools-rust`. Note: setuptool-rust is not required if you have pip version 10.0 or above\n  - `pip install argonautica`. Unfortunately, this step may take several minutes, as argonautica needs to compile it's Rust code for your specific CPU (due to its use of SIMD instructions). The upside, however, is that once compiled, argonautica should run blazingly fast\n\n## Usage\n\n### Hashing\n\n```python3\nfrom argonautica import Hasher\n\nhasher = Hasher(secret_key='somesecret')\nhash = hasher.hash(password='P@ssw0rd')\nprint(hash)\n# \ud83d\udc46 prints a random hash as the defeault `Hasher` uses a random salt by default\n```\n\n### Verifying\n\n```python3\nfrom argonautica import Verifier\n\nverifier = Verifier(secret_key='somesecret')\nis_valid = verifier.verify(\n    hash='$argon2id$v=19$m=4096,t=192,p=2$ULwasg5z5byOAork0UEhoTBVxIvAafKuceNz9NdCVXU$YxhaPnqRDys',\n    password='P@ssw0rd',\n)\nassert(is_valid)\n```\n\n### Configuration\n\n```python3\nfrom argonautica import Hasher, Verifier\nfrom argonautica.config import Backend, Variant, Version\n\nhasher = Hasher(secret_key=None)\n# \ud83d\udc46 A secret key (passed as a keyword argument) is required to instantiate a\n# Hasher, a Verifier, or an Argon2, but you are allowed to pass `None`\n# in order to forgo using a secret key (this is not recommended)\n\nhasher.additional_data = None  # Default is None\n# \ud83d\udc46 Although rarely used, argon2 allows you to hash a password\n# with not only salt and a secret key, but also with \"additional data\",\n# which acts as a kind of secondary secret key. Like a secret key, it affects\n# the outcome of the hash and is not stored in the string-encoded output, meaning\n# later, to verify against a hash created with additional data, you will need to\n# supply the same additional data manually to the Verifier (just like you have to\n# do with a secret key). Again, this is rarely used.\n\nhasher.backend = Backend.C  # Default is Backend.C\n# \ud83d\udc46 argonautica was designed to support multiple backends (meaning multiple\n# implementations of the underlying argon2 algorithm). Currently only the\n# C backend is supported, which uses the cannonical argon2 library written\n# in C to actually do the work. In the future a Rust backend will also be\n# supported, but, for the moment, you must use Backend.C, which is the\n# default. Using Backend.Rust will result in an error (again, for the\n# moment).\n\nhasher.hash_len = 32  # Default is 32\n# \ud83d\udc46 The hash length in bytes is configurable. The default is 32.\n# This is probably a good number to use. 16 is also probably fine.\n# You probably shouldn't go below 16\n\nhasher.iterations = 192  # Default is 192\n# \ud83d\udc46 Argon2 has a notion of \"iterations\" or \"time cost\". All else equal\n# and generally speaking, the greater the number of iterations, the\n# longer it takes to perform the hash and the more secure the resulting\n# hash. More iterations basically means more CPU load. This and \"memory\n# size\" (see below) are the two primary parameters to adjust in order\n# to increase or decrease the security of your hash. The default is\n# 192 iterations, which was chosen because, along with the default\n# memory size of 4096, this leads to a hashing time of approximately\n# 300 milliseconds on the early-2014 Macbook Air that is the developer's\n# machine. If you're going to use argonautica in production, you should\n# probably tweak this parameter (and the memory size parameter) in order\n# to increase the time it takes to hash to the maximum you can\n# reasonably allow for your use-case (e.g. to probably about 300-500\n# milliseconds for the use-case of hashing user passwords for a website)\n\nhasher.lanes = 2  # Default is multiprocessing.cpu_count()\n# \ud83d\udc46 Argon2 can break up its work into one or more \"lanes\" during some parts of\n# the hashing algorithm. If you configure it with multiple lanes and you also\n# use multiple threads (see below) the hashing algorithm will performed its\n# work in parallel in some parts, potentially speeding up the time it takes to\n# produce a hash without diminishing the security of the result. By default,\n# the number of lanes is set to the number of logical cores on your machine\n\nhasher.memory_size = 4096  # Default is 4096\n# \ud83d\udc46 Argon2 has a notion of \"memory size\" or \"memory cost\" (in kibibytes). All else\n# equal and generally speaking, the greater the memory size, the longer it takes to\n# perform the hash and the more secure the resulting hash. More memory size basically\n# means more memory used. This and \"iterations\" (see above) are, again, generally\n# speaking, the two parameters to adjust in order to increase or decrease the\n# security of your hash. The default is 4096 kibibytes, which was chosen because,\n# again, along with the default iterations of 192, this leads to a hashing time of\n# approximately 300 milliseconds on the early-2014 Macbook Air that is the\n# developer's machine. If you're going to use argonautica in production, you should\n# probably tweak this parameter (and the iterations parameter) in order to increase\n# the time it takes to hash to the maximum you can reasonably allow for your use-case\n# (e.g. to probably about 300-500 milliseconds for the use-case of hashing user\n# passwords for a website)\n\nhasher.threads = 2  # Default is multiprocessing.cpu_count()\n# \ud83d\udc46 If you have configured a Hasher to use more than one lane (see above), you\n# can get the hashing algorithm to run in parallel during some parts of the\n# computation by setting the number of threads to be greater than one as well,\n# potentially speeding up the time it takes to produce a hash without diminishing\n# the security of the result. By default, the number of threads is set to the number\n# of logical cores on your machine. If you set the number of threads to a number\n# greater than the number of lanes, `Hasher` will automatically reduce the number\n# of threads to the number of lanes\n\nhasher.variant = Variant.Argon2id  # Default is Variant.Argon2id\n# \ud83d\udc46 Argon2 has three variants: Argon2d, Argon2i, and Argon2id. Here is how these\n# variants are explained in the RFC: \"Argon2 has one primary variant: Argon2id,\n# and two supplementary variants: Argon2d and Argon2i. Argon2d uses data-dependent\n# memory access, which makes it suitable for ... applications with no threats from\n# side-channel timing attacks. Argon2i uses data-independent memory access, which\n# is preferred for password hashing and password-based key derivation. Argon2id\n# works as Argon2i for the first half of the first iteration over the memory, and\n# as Argon2d for the rest, thus providing both side-channel attack protection and\n# brute-force cost savings due to time-memory tradeoffs.\" If you do not know which\n# variant to use, use the default, which is Argon2id\n\nhasher.version = Version._0x13  # Default is Version._0x13\n# \ud83d\udc46 Argon2 has two versions: 0x10 and 0x13. The latest version is 0x13 (as of 5/18).\n# Unless you have a very specific reason not to, you should use the latest\n# version (0x13), which is also the default\n\nhash = hasher.hash(\n    password='P@ssw0rd',\n    salt='somesalt',       # You can set your own salt, or use the default: RandomSalt(32)\n)\nassert(hash == '$argon2id$v=19$m=4096,t=192,p=2$c29tZXNhbHQ$8nD3gRm+NeOcIiIrlnzDAdnK4iD+K0mVqFXowGs13M4')\n\nverifier = Verifier(secret_key=None)\nverifier.additional_data = None  # As with Hasher, you can configure a Verifier's additional data\nverifier.backend = Backend.C     # As with Hasher, you can configure a Verifier's backend\nverifier.threads = 2             # As with Hasher, you can configure a Verifier's threads\n\nis_valid = verifier.verify(\n    hash=hash,\n    password='P@ssw0rd'\n)\nassert(is_valid)\n```\n\n### Miscellaneous\n\n**mypy**\n\n- **argonautica** uses [mypy](http://mypy-lang.org/) type annotations everywhere in the code, which, in the author's humble opinion, is a very useful form of documentation; so if you're ever confused about what types to use for arguments, just pop open the code and take a look at the function signatures.\n\n**Argon2**\n\n`Argon2` is a convenience class that holds both a `Hasher` and a `Verifier`. If you'd like to use just one class that knows how both to hash and to verify, instantiate an `Argon2`. It works essentially the same way as `Hasher` and `Verifier` do.\n\n```python3\nfrom argonautica import Argon2\n\nargon2 = Argon2(secret_key='somesecret')\n\nhash = argon2.hash(password='P@ssw0rd')\nprint(hash)\n\nis_valid = argon2.verify(hash=hash, password='P@ssw0rd')\nassert(is_valid)\n```\n\n**RandomSalt**\n\n- `RandomSalt` is a special kind of salt that will create new random salt bytes before each hash. A RandomSalt knows its length (in number of bytes). The default `Hasher` uses a `RandomSalt` with length of 32 bytes, but you can use your own `RandomSalt` of custom length. When you instantiate a `RandomSalt`, the constructor takes a length, e.g. `my_random_salt = RandomSalt(16)`\n\n```python3\nfrom argonautica import Hasher\nfrom argonautica.data import RandomSalt\n\nhasher = Hasher(\n    salt=RandomSalt(16),\n    # \ud83d\udc46 Here we're using a RandomSalt of length of 16 bytes\n    # instead of the default, which is a RandomSalt of length 32 bytes\n    secret_key=\"somesecret\"\n)\nhash = hasher.hash(password='P@ssw0rd')\nprint(hash)\n```\n\n**HashRaw**\n\n- Hashing with **argonautica** produces a string-encoded hash, but sometimes you might want the \"raw material\" behind this hash, i.e. the raw hash bytes, the raw salt bytes, or raw parameters, which are the three component parts of a string-encoded hash. To obtain these raw parts...\n\n```python3\nfrom argonautica.utils import decode, HashRaw\n\nhash = '$argon2id$v=19$m=4096,t=128,p=2$c29tZXNhbHQ$WwD2/wGGTuw7u4BW8sLM0Q'\n\n# Create a `HashRaw` using the `decode` function\nhash_raw = decode(hash)\n\n# Pull out the raw parameters\niterations = hash_raw.iterations     # 128\nlanes = hash_raw.lanes               # 2\nmemory_size = hash_raw.memory_size   # 4096\nvariant = hash_raw.variant           # Variant.Argon2id\nversion = hash_raw.version           # Version._0x13\n\n# Pull out the raw bytes\nraw_hash_bytes = hash_raw.raw_hash_bytes  # b'[\\x00\\xf6\\xff\\x01\\x86N\\xec;\\xbb\\x80V\\xf2\\xc2\\xcc\\xd1'\nraw_salt_bytes = hash_raw.raw_salt_bytes  # b'somesalt'\n\n# Turn a `HashRaw` back into a string-encoded hash using the `encode` method\nhash2 = hash_raw.encode()\nassert(hash == hash2)\n```\n\n## License\n\n**argonautica** is licensed under either of:\n\n- [The Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0), or\n- [The MIT license](http://opensource.org/licenses/MIT)\n\nat your option.", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/bcmyers/argonautica/tree/master/argonautica-py", "keywords": "argon2 argon2d argon2i argon2id crypto cryptography hash hashing password security", "license": "MIT/Apache-2.0", "maintainer": "", "maintainer_email": "", "name": "argonautica", "package_url": "https://pypi.org/project/argonautica/", "platform": "", "project_url": "https://pypi.org/project/argonautica/", "project_urls": {"Docs": "https://github.com/bcmyers/argonautica/tree/master/argonautica-py", "Github": "https://github.com/bcmyers/argonautica/tree/master/argonautica-py", "Homepage": "https://github.com/bcmyers/argonautica/tree/master/argonautica-py"}, "release_url": "https://pypi.org/project/argonautica/0.1.5/", "requires_dist": null, "requires_python": ">=3.4", "summary": "Idiomatic Argon2 password hashing for Python", "version": "0.1.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>argonautica-py</h1>\n<p><a href=\"https://travis-ci.org/bcmyers/argonautica\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9baefa7cc23d421b2f596adfd9d1647175714d95/68747470733a2f2f7472617669732d63692e6f72672f62636d796572732f6172676f6e6175746963612e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"http://www.github.com/bcmyers/argonautica\" rel=\"nofollow\"><img alt=\"Github.com\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/611c7c7d443879422a565e4de3259d025ec9b84b/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6769746875622d62636d796572732532466172676f6e6175746963612d626c75652e737667\"></a>\n<img alt=\"License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/ea6ec8358c06c0c2a6c3c8c929383c63ab96d74f/68747470733a2f2f696d672e736869656c64732e696f2f6372617465732f6c2f6172676f6e6175746963612e737667\">\n<a href=\"https://pypi.org/project/argonautica\" rel=\"nofollow\"><img alt=\"PyPI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/339ade56d6025879887fa1b34461b6fd247c8bf4/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f6172676f6e6175746963612e737667\"></a></p>\n<h2>Overview</h2>\n<p><strong>argonautica</strong> is a Python package for hashing passwords that uses the cryptographically-secure <a href=\"https://en.wikipedia.org/wiki/Argon2\" rel=\"nofollow\">argon2</a> hashing algorithm.</p>\n<p>Argon2 won the <a href=\"https://password-hashing.net/\" rel=\"nofollow\">Password Hashing Competition</a> in 2015, a several year project to identify a successor to <a href=\"https://en.wikipedia.org/wiki/Bcrypt\" rel=\"nofollow\">bcrypt</a>, <a href=\"https://en.wikipedia.org/wiki/Scrypt\" rel=\"nofollow\">scrypt</a>, and other common hashing algorithms.</p>\n<p><strong>argonautica</strong> was built with a simple use-case in mind: hashing passwords for storage in a\nwebsite's database. That said, it's also \"feature-complete\", meaning anything you can do with\nthe cannonical <a href=\"https://github.com/P-H-C/phc-winner-argon2\" rel=\"nofollow\">C implementation</a> of argon2\nyou can do with argonautica*.</p>\n<p><i>* Indeed, argonautica has a feature that even the cannonical C implementation\nlacks, i.e. hashing passwords with secret keys (the C implementation implements this, but\ndoes not expose it publicly)</i></p>\n<h2>Alternatives</h2>\n<p>There are several Python packages that implement argon2, including the excellent <a href=\"http://passlib.readthedocs.io/en/stable/\" rel=\"nofollow\">passlib</a>, which uses <a href=\"https://github.com/hynek/argon2_cffi\" rel=\"nofollow\">argon2_cffi</a>, but...</p>\n<ul>\n<li>\n<p>AFAIK, <strong>argonautica</strong> is the only Python implementation of argon2 that supports hashing with secret keys. Not even the <a href=\"https://github.com/P-H-C/phc-winner-argon2\" rel=\"nofollow\">cannonical C implementation</a> of argon2 exposes this feature publicly (it's in the code, but unfortunately not accessable via the public API).</p>\n</li>\n<li>\n<p><strong>argonautica</strong> is the only Python implementation of argon2 to use <a href=\"https://en.wikipedia.org/wiki/SIMD\" rel=\"nofollow\">SIMD</a> instructions to peform it's hashing algorithm, which means it can be quite fast. The downside is that you have to compile it for your specific machine (this is why the <code>pip install argonautica</code> process takes time). That said, on the developer's early 2014 Macbook Air, which has <a href=\"https://en.wikipedia.org/wiki/SIMD\" rel=\"nofollow\">SIMD</a> instruction through <a href=\"https://en.wikipedia.org/wiki/Advanced_Vector_Extensions\" rel=\"nofollow\">AVX2</a>, argonautica runs ~30% faster than passlib on default settings.</p>\n</li>\n<li>\n<p><strong>argonautica</strong> supports the latest argon2 variant: argon2id, which, unless you have a reason not to, you should be using. A number of Python implementations do not yet support this variant.</p>\n</li>\n<li>\n<p>Finally, <strong>argonautica</strong> is the only Python implementation of argon2 written in <a href=\"https://www.rust-lang.org/en-US/\" rel=\"nofollow\">Rust</a> (as opposed to C or C++). <a href=\"https://www.rust-lang.org/en-US/\" rel=\"nofollow\">Rust</a> is a \"systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.\"</p>\n</li>\n</ul>\n<h2>Requirements</h2>\n<ul>\n<li><a href=\"https://www.python.org/\" rel=\"nofollow\">Python</a> version 3.4 or higher (or <a href=\"http://pypy.org/\" rel=\"nofollow\">PyPy</a> version 3.5 or higher)</li>\n<li><a href=\"https://www.rust-lang.org/en-US/\" rel=\"nofollow\">Rust</a> version 1.26 or higher</li>\n<li><a href=\"https://llvm.org/\" rel=\"nofollow\">LLVM</a> version 3.9 or higher</li>\n</ul>\n<h2>Installation</h2>\n<ul>\n<li><strong>Rust:</strong>\n<ul>\n<li>Follow the instructions <a href=\"https://www.rust-lang.org/en-US/install.html\" rel=\"nofollow\">here</a>, which will just tell you to run the following command in your terminal and follow the on-screen instructions: <code>curl https://sh.rustup.rs -sSf \\| sh</code></li>\n</ul>\n</li>\n<li><strong>LLVM:</strong>\n<ul>\n<li>macOS: <code>brew install llvm</code>, which requires <a href=\"https://brew.sh/\" rel=\"nofollow\">Homebrew</a></li>\n<li>Debian-based linux: <code>apt-get install llvm-dev libclang-dev clang</code></li>\n<li>Arch linux: <code>pacman -S clang</code></li>\n<li>Other linux: Use your distribution's package manager</li>\n<li>Windows: Download a pre-built binary <a href=\"http://releases.llvm.org/download.html\" rel=\"nofollow\">here</a></li>\n</ul>\n</li>\n<li><strong>argonautica:</strong>\n<ul>\n<li><code>pip install --upgrade pip</code> or <code>pip install setuptools-rust</code>. Note: setuptool-rust is not required if you have pip version 10.0 or above</li>\n<li><code>pip install argonautica</code>. Unfortunately, this step may take several minutes, as argonautica needs to compile it's Rust code for your specific CPU (due to its use of SIMD instructions). The upside, however, is that once compiled, argonautica should run blazingly fast</li>\n</ul>\n</li>\n</ul>\n<h2>Usage</h2>\n<h3>Hashing</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">argonautica</span> <span class=\"kn\">import</span> <span class=\"n\">Hasher</span>\n\n<span class=\"n\">hasher</span> <span class=\"o\">=</span> <span class=\"n\">Hasher</span><span class=\"p\">(</span><span class=\"n\">secret_key</span><span class=\"o\">=</span><span class=\"s1\">'somesecret'</span><span class=\"p\">)</span>\n<span class=\"nb\">hash</span> <span class=\"o\">=</span> <span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">hash</span><span class=\"p\">(</span><span class=\"n\">password</span><span class=\"o\">=</span><span class=\"s1\">'P@ssw0rd'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">hash</span><span class=\"p\">)</span>\n<span class=\"c1\"># \ud83d\udc46 prints a random hash as the defeault `Hasher` uses a random salt by default</span>\n</pre>\n<h3>Verifying</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">argonautica</span> <span class=\"kn\">import</span> <span class=\"n\">Verifier</span>\n\n<span class=\"n\">verifier</span> <span class=\"o\">=</span> <span class=\"n\">Verifier</span><span class=\"p\">(</span><span class=\"n\">secret_key</span><span class=\"o\">=</span><span class=\"s1\">'somesecret'</span><span class=\"p\">)</span>\n<span class=\"n\">is_valid</span> <span class=\"o\">=</span> <span class=\"n\">verifier</span><span class=\"o\">.</span><span class=\"n\">verify</span><span class=\"p\">(</span>\n    <span class=\"nb\">hash</span><span class=\"o\">=</span><span class=\"s1\">'$argon2id$v=19$m=4096,t=192,p=2$ULwasg5z5byOAork0UEhoTBVxIvAafKuceNz9NdCVXU$YxhaPnqRDys'</span><span class=\"p\">,</span>\n    <span class=\"n\">password</span><span class=\"o\">=</span><span class=\"s1\">'P@ssw0rd'</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n<span class=\"k\">assert</span><span class=\"p\">(</span><span class=\"n\">is_valid</span><span class=\"p\">)</span>\n</pre>\n<h3>Configuration</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">argonautica</span> <span class=\"kn\">import</span> <span class=\"n\">Hasher</span><span class=\"p\">,</span> <span class=\"n\">Verifier</span>\n<span class=\"kn\">from</span> <span class=\"nn\">argonautica.config</span> <span class=\"kn\">import</span> <span class=\"n\">Backend</span><span class=\"p\">,</span> <span class=\"n\">Variant</span><span class=\"p\">,</span> <span class=\"n\">Version</span>\n\n<span class=\"n\">hasher</span> <span class=\"o\">=</span> <span class=\"n\">Hasher</span><span class=\"p\">(</span><span class=\"n\">secret_key</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n<span class=\"c1\"># \ud83d\udc46 A secret key (passed as a keyword argument) is required to instantiate a</span>\n<span class=\"c1\"># Hasher, a Verifier, or an Argon2, but you are allowed to pass `None`</span>\n<span class=\"c1\"># in order to forgo using a secret key (this is not recommended)</span>\n\n<span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">additional_data</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>  <span class=\"c1\"># Default is None</span>\n<span class=\"c1\"># \ud83d\udc46 Although rarely used, argon2 allows you to hash a password</span>\n<span class=\"c1\"># with not only salt and a secret key, but also with \"additional data\",</span>\n<span class=\"c1\"># which acts as a kind of secondary secret key. Like a secret key, it affects</span>\n<span class=\"c1\"># the outcome of the hash and is not stored in the string-encoded output, meaning</span>\n<span class=\"c1\"># later, to verify against a hash created with additional data, you will need to</span>\n<span class=\"c1\"># supply the same additional data manually to the Verifier (just like you have to</span>\n<span class=\"c1\"># do with a secret key). Again, this is rarely used.</span>\n\n<span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">backend</span> <span class=\"o\">=</span> <span class=\"n\">Backend</span><span class=\"o\">.</span><span class=\"n\">C</span>  <span class=\"c1\"># Default is Backend.C</span>\n<span class=\"c1\"># \ud83d\udc46 argonautica was designed to support multiple backends (meaning multiple</span>\n<span class=\"c1\"># implementations of the underlying argon2 algorithm). Currently only the</span>\n<span class=\"c1\"># C backend is supported, which uses the cannonical argon2 library written</span>\n<span class=\"c1\"># in C to actually do the work. In the future a Rust backend will also be</span>\n<span class=\"c1\"># supported, but, for the moment, you must use Backend.C, which is the</span>\n<span class=\"c1\"># default. Using Backend.Rust will result in an error (again, for the</span>\n<span class=\"c1\"># moment).</span>\n\n<span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">hash_len</span> <span class=\"o\">=</span> <span class=\"mi\">32</span>  <span class=\"c1\"># Default is 32</span>\n<span class=\"c1\"># \ud83d\udc46 The hash length in bytes is configurable. The default is 32.</span>\n<span class=\"c1\"># This is probably a good number to use. 16 is also probably fine.</span>\n<span class=\"c1\"># You probably shouldn't go below 16</span>\n\n<span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">iterations</span> <span class=\"o\">=</span> <span class=\"mi\">192</span>  <span class=\"c1\"># Default is 192</span>\n<span class=\"c1\"># \ud83d\udc46 Argon2 has a notion of \"iterations\" or \"time cost\". All else equal</span>\n<span class=\"c1\"># and generally speaking, the greater the number of iterations, the</span>\n<span class=\"c1\"># longer it takes to perform the hash and the more secure the resulting</span>\n<span class=\"c1\"># hash. More iterations basically means more CPU load. This and \"memory</span>\n<span class=\"c1\"># size\" (see below) are the two primary parameters to adjust in order</span>\n<span class=\"c1\"># to increase or decrease the security of your hash. The default is</span>\n<span class=\"c1\"># 192 iterations, which was chosen because, along with the default</span>\n<span class=\"c1\"># memory size of 4096, this leads to a hashing time of approximately</span>\n<span class=\"c1\"># 300 milliseconds on the early-2014 Macbook Air that is the developer's</span>\n<span class=\"c1\"># machine. If you're going to use argonautica in production, you should</span>\n<span class=\"c1\"># probably tweak this parameter (and the memory size parameter) in order</span>\n<span class=\"c1\"># to increase the time it takes to hash to the maximum you can</span>\n<span class=\"c1\"># reasonably allow for your use-case (e.g. to probably about 300-500</span>\n<span class=\"c1\"># milliseconds for the use-case of hashing user passwords for a website)</span>\n\n<span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">lanes</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>  <span class=\"c1\"># Default is multiprocessing.cpu_count()</span>\n<span class=\"c1\"># \ud83d\udc46 Argon2 can break up its work into one or more \"lanes\" during some parts of</span>\n<span class=\"c1\"># the hashing algorithm. If you configure it with multiple lanes and you also</span>\n<span class=\"c1\"># use multiple threads (see below) the hashing algorithm will performed its</span>\n<span class=\"c1\"># work in parallel in some parts, potentially speeding up the time it takes to</span>\n<span class=\"c1\"># produce a hash without diminishing the security of the result. By default,</span>\n<span class=\"c1\"># the number of lanes is set to the number of logical cores on your machine</span>\n\n<span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">memory_size</span> <span class=\"o\">=</span> <span class=\"mi\">4096</span>  <span class=\"c1\"># Default is 4096</span>\n<span class=\"c1\"># \ud83d\udc46 Argon2 has a notion of \"memory size\" or \"memory cost\" (in kibibytes). All else</span>\n<span class=\"c1\"># equal and generally speaking, the greater the memory size, the longer it takes to</span>\n<span class=\"c1\"># perform the hash and the more secure the resulting hash. More memory size basically</span>\n<span class=\"c1\"># means more memory used. This and \"iterations\" (see above) are, again, generally</span>\n<span class=\"c1\"># speaking, the two parameters to adjust in order to increase or decrease the</span>\n<span class=\"c1\"># security of your hash. The default is 4096 kibibytes, which was chosen because,</span>\n<span class=\"c1\"># again, along with the default iterations of 192, this leads to a hashing time of</span>\n<span class=\"c1\"># approximately 300 milliseconds on the early-2014 Macbook Air that is the</span>\n<span class=\"c1\"># developer's machine. If you're going to use argonautica in production, you should</span>\n<span class=\"c1\"># probably tweak this parameter (and the iterations parameter) in order to increase</span>\n<span class=\"c1\"># the time it takes to hash to the maximum you can reasonably allow for your use-case</span>\n<span class=\"c1\"># (e.g. to probably about 300-500 milliseconds for the use-case of hashing user</span>\n<span class=\"c1\"># passwords for a website)</span>\n\n<span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">threads</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>  <span class=\"c1\"># Default is multiprocessing.cpu_count()</span>\n<span class=\"c1\"># \ud83d\udc46 If you have configured a Hasher to use more than one lane (see above), you</span>\n<span class=\"c1\"># can get the hashing algorithm to run in parallel during some parts of the</span>\n<span class=\"c1\"># computation by setting the number of threads to be greater than one as well,</span>\n<span class=\"c1\"># potentially speeding up the time it takes to produce a hash without diminishing</span>\n<span class=\"c1\"># the security of the result. By default, the number of threads is set to the number</span>\n<span class=\"c1\"># of logical cores on your machine. If you set the number of threads to a number</span>\n<span class=\"c1\"># greater than the number of lanes, `Hasher` will automatically reduce the number</span>\n<span class=\"c1\"># of threads to the number of lanes</span>\n\n<span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">variant</span> <span class=\"o\">=</span> <span class=\"n\">Variant</span><span class=\"o\">.</span><span class=\"n\">Argon2id</span>  <span class=\"c1\"># Default is Variant.Argon2id</span>\n<span class=\"c1\"># \ud83d\udc46 Argon2 has three variants: Argon2d, Argon2i, and Argon2id. Here is how these</span>\n<span class=\"c1\"># variants are explained in the RFC: \"Argon2 has one primary variant: Argon2id,</span>\n<span class=\"c1\"># and two supplementary variants: Argon2d and Argon2i. Argon2d uses data-dependent</span>\n<span class=\"c1\"># memory access, which makes it suitable for ... applications with no threats from</span>\n<span class=\"c1\"># side-channel timing attacks. Argon2i uses data-independent memory access, which</span>\n<span class=\"c1\"># is preferred for password hashing and password-based key derivation. Argon2id</span>\n<span class=\"c1\"># works as Argon2i for the first half of the first iteration over the memory, and</span>\n<span class=\"c1\"># as Argon2d for the rest, thus providing both side-channel attack protection and</span>\n<span class=\"c1\"># brute-force cost savings due to time-memory tradeoffs.\" If you do not know which</span>\n<span class=\"c1\"># variant to use, use the default, which is Argon2id</span>\n\n<span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">version</span> <span class=\"o\">=</span> <span class=\"n\">Version</span><span class=\"o\">.</span><span class=\"n\">_0x13</span>  <span class=\"c1\"># Default is Version._0x13</span>\n<span class=\"c1\"># \ud83d\udc46 Argon2 has two versions: 0x10 and 0x13. The latest version is 0x13 (as of 5/18).</span>\n<span class=\"c1\"># Unless you have a very specific reason not to, you should use the latest</span>\n<span class=\"c1\"># version (0x13), which is also the default</span>\n\n<span class=\"nb\">hash</span> <span class=\"o\">=</span> <span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">hash</span><span class=\"p\">(</span>\n    <span class=\"n\">password</span><span class=\"o\">=</span><span class=\"s1\">'P@ssw0rd'</span><span class=\"p\">,</span>\n    <span class=\"n\">salt</span><span class=\"o\">=</span><span class=\"s1\">'somesalt'</span><span class=\"p\">,</span>       <span class=\"c1\"># You can set your own salt, or use the default: RandomSalt(32)</span>\n<span class=\"p\">)</span>\n<span class=\"k\">assert</span><span class=\"p\">(</span><span class=\"nb\">hash</span> <span class=\"o\">==</span> <span class=\"s1\">'$argon2id$v=19$m=4096,t=192,p=2$c29tZXNhbHQ$8nD3gRm+NeOcIiIrlnzDAdnK4iD+K0mVqFXowGs13M4'</span><span class=\"p\">)</span>\n\n<span class=\"n\">verifier</span> <span class=\"o\">=</span> <span class=\"n\">Verifier</span><span class=\"p\">(</span><span class=\"n\">secret_key</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n<span class=\"n\">verifier</span><span class=\"o\">.</span><span class=\"n\">additional_data</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>  <span class=\"c1\"># As with Hasher, you can configure a Verifier's additional data</span>\n<span class=\"n\">verifier</span><span class=\"o\">.</span><span class=\"n\">backend</span> <span class=\"o\">=</span> <span class=\"n\">Backend</span><span class=\"o\">.</span><span class=\"n\">C</span>     <span class=\"c1\"># As with Hasher, you can configure a Verifier's backend</span>\n<span class=\"n\">verifier</span><span class=\"o\">.</span><span class=\"n\">threads</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>             <span class=\"c1\"># As with Hasher, you can configure a Verifier's threads</span>\n\n<span class=\"n\">is_valid</span> <span class=\"o\">=</span> <span class=\"n\">verifier</span><span class=\"o\">.</span><span class=\"n\">verify</span><span class=\"p\">(</span>\n    <span class=\"nb\">hash</span><span class=\"o\">=</span><span class=\"nb\">hash</span><span class=\"p\">,</span>\n    <span class=\"n\">password</span><span class=\"o\">=</span><span class=\"s1\">'P@ssw0rd'</span>\n<span class=\"p\">)</span>\n<span class=\"k\">assert</span><span class=\"p\">(</span><span class=\"n\">is_valid</span><span class=\"p\">)</span>\n</pre>\n<h3>Miscellaneous</h3>\n<p><strong>mypy</strong></p>\n<ul>\n<li><strong>argonautica</strong> uses <a href=\"http://mypy-lang.org/\" rel=\"nofollow\">mypy</a> type annotations everywhere in the code, which, in the author's humble opinion, is a very useful form of documentation; so if you're ever confused about what types to use for arguments, just pop open the code and take a look at the function signatures.</li>\n</ul>\n<p><strong>Argon2</strong></p>\n<p><code>Argon2</code> is a convenience class that holds both a <code>Hasher</code> and a <code>Verifier</code>. If you'd like to use just one class that knows how both to hash and to verify, instantiate an <code>Argon2</code>. It works essentially the same way as <code>Hasher</code> and <code>Verifier</code> do.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">argonautica</span> <span class=\"kn\">import</span> <span class=\"n\">Argon2</span>\n\n<span class=\"n\">argon2</span> <span class=\"o\">=</span> <span class=\"n\">Argon2</span><span class=\"p\">(</span><span class=\"n\">secret_key</span><span class=\"o\">=</span><span class=\"s1\">'somesecret'</span><span class=\"p\">)</span>\n\n<span class=\"nb\">hash</span> <span class=\"o\">=</span> <span class=\"n\">argon2</span><span class=\"o\">.</span><span class=\"n\">hash</span><span class=\"p\">(</span><span class=\"n\">password</span><span class=\"o\">=</span><span class=\"s1\">'P@ssw0rd'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">hash</span><span class=\"p\">)</span>\n\n<span class=\"n\">is_valid</span> <span class=\"o\">=</span> <span class=\"n\">argon2</span><span class=\"o\">.</span><span class=\"n\">verify</span><span class=\"p\">(</span><span class=\"nb\">hash</span><span class=\"o\">=</span><span class=\"nb\">hash</span><span class=\"p\">,</span> <span class=\"n\">password</span><span class=\"o\">=</span><span class=\"s1\">'P@ssw0rd'</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span><span class=\"p\">(</span><span class=\"n\">is_valid</span><span class=\"p\">)</span>\n</pre>\n<p><strong>RandomSalt</strong></p>\n<ul>\n<li><code>RandomSalt</code> is a special kind of salt that will create new random salt bytes before each hash. A RandomSalt knows its length (in number of bytes). The default <code>Hasher</code> uses a <code>RandomSalt</code> with length of 32 bytes, but you can use your own <code>RandomSalt</code> of custom length. When you instantiate a <code>RandomSalt</code>, the constructor takes a length, e.g. <code>my_random_salt = RandomSalt(16)</code></li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">argonautica</span> <span class=\"kn\">import</span> <span class=\"n\">Hasher</span>\n<span class=\"kn\">from</span> <span class=\"nn\">argonautica.data</span> <span class=\"kn\">import</span> <span class=\"n\">RandomSalt</span>\n\n<span class=\"n\">hasher</span> <span class=\"o\">=</span> <span class=\"n\">Hasher</span><span class=\"p\">(</span>\n    <span class=\"n\">salt</span><span class=\"o\">=</span><span class=\"n\">RandomSalt</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">),</span>\n    <span class=\"c1\"># \ud83d\udc46 Here we're using a RandomSalt of length of 16 bytes</span>\n    <span class=\"c1\"># instead of the default, which is a RandomSalt of length 32 bytes</span>\n    <span class=\"n\">secret_key</span><span class=\"o\">=</span><span class=\"s2\">\"somesecret\"</span>\n<span class=\"p\">)</span>\n<span class=\"nb\">hash</span> <span class=\"o\">=</span> <span class=\"n\">hasher</span><span class=\"o\">.</span><span class=\"n\">hash</span><span class=\"p\">(</span><span class=\"n\">password</span><span class=\"o\">=</span><span class=\"s1\">'P@ssw0rd'</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">hash</span><span class=\"p\">)</span>\n</pre>\n<p><strong>HashRaw</strong></p>\n<ul>\n<li>Hashing with <strong>argonautica</strong> produces a string-encoded hash, but sometimes you might want the \"raw material\" behind this hash, i.e. the raw hash bytes, the raw salt bytes, or raw parameters, which are the three component parts of a string-encoded hash. To obtain these raw parts...</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">argonautica.utils</span> <span class=\"kn\">import</span> <span class=\"n\">decode</span><span class=\"p\">,</span> <span class=\"n\">HashRaw</span>\n\n<span class=\"nb\">hash</span> <span class=\"o\">=</span> <span class=\"s1\">'$argon2id$v=19$m=4096,t=128,p=2$c29tZXNhbHQ$WwD2/wGGTuw7u4BW8sLM0Q'</span>\n\n<span class=\"c1\"># Create a `HashRaw` using the `decode` function</span>\n<span class=\"n\">hash_raw</span> <span class=\"o\">=</span> <span class=\"n\">decode</span><span class=\"p\">(</span><span class=\"nb\">hash</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Pull out the raw parameters</span>\n<span class=\"n\">iterations</span> <span class=\"o\">=</span> <span class=\"n\">hash_raw</span><span class=\"o\">.</span><span class=\"n\">iterations</span>     <span class=\"c1\"># 128</span>\n<span class=\"n\">lanes</span> <span class=\"o\">=</span> <span class=\"n\">hash_raw</span><span class=\"o\">.</span><span class=\"n\">lanes</span>               <span class=\"c1\"># 2</span>\n<span class=\"n\">memory_size</span> <span class=\"o\">=</span> <span class=\"n\">hash_raw</span><span class=\"o\">.</span><span class=\"n\">memory_size</span>   <span class=\"c1\"># 4096</span>\n<span class=\"n\">variant</span> <span class=\"o\">=</span> <span class=\"n\">hash_raw</span><span class=\"o\">.</span><span class=\"n\">variant</span>           <span class=\"c1\"># Variant.Argon2id</span>\n<span class=\"n\">version</span> <span class=\"o\">=</span> <span class=\"n\">hash_raw</span><span class=\"o\">.</span><span class=\"n\">version</span>           <span class=\"c1\"># Version._0x13</span>\n\n<span class=\"c1\"># Pull out the raw bytes</span>\n<span class=\"n\">raw_hash_bytes</span> <span class=\"o\">=</span> <span class=\"n\">hash_raw</span><span class=\"o\">.</span><span class=\"n\">raw_hash_bytes</span>  <span class=\"c1\"># b'[\\x00\\xf6\\xff\\x01\\x86N\\xec;\\xbb\\x80V\\xf2\\xc2\\xcc\\xd1'</span>\n<span class=\"n\">raw_salt_bytes</span> <span class=\"o\">=</span> <span class=\"n\">hash_raw</span><span class=\"o\">.</span><span class=\"n\">raw_salt_bytes</span>  <span class=\"c1\"># b'somesalt'</span>\n\n<span class=\"c1\"># Turn a `HashRaw` back into a string-encoded hash using the `encode` method</span>\n<span class=\"n\">hash2</span> <span class=\"o\">=</span> <span class=\"n\">hash_raw</span><span class=\"o\">.</span><span class=\"n\">encode</span><span class=\"p\">()</span>\n<span class=\"k\">assert</span><span class=\"p\">(</span><span class=\"nb\">hash</span> <span class=\"o\">==</span> <span class=\"n\">hash2</span><span class=\"p\">)</span>\n</pre>\n<h2>License</h2>\n<p><strong>argonautica</strong> is licensed under either of:</p>\n<ul>\n<li><a href=\"http://www.apache.org/licenses/LICENSE-2.0\" rel=\"nofollow\">The Apache License, Version 2.0</a>, or</li>\n<li><a href=\"http://opensource.org/licenses/MIT\" rel=\"nofollow\">The MIT license</a></li>\n</ul>\n<p>at your option.</p>\n\n          </div>"}, "last_serial": 4012320, "releases": {"0.1.4": [{"comment_text": "", "digests": {"md5": "40f5b54db77b118b84d2ca48f1ae88be", "sha256": "f719be41e89774bd4ee8b24580907a949e8ebd4860bed44dca4514e39df16ab0"}, "downloads": -1, "filename": "argonautica-0.1.4.tar.gz", "has_sig": false, "md5_digest": "40f5b54db77b118b84d2ca48f1ae88be", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 1918585, "upload_time": "2018-06-28T17:46:41", "upload_time_iso_8601": "2018-06-28T17:46:41.461122Z", "url": "https://files.pythonhosted.org/packages/4e/93/2c43b690dcb24603b3b1753833b2c39659fb70b76ddd4aae51a00f3e806d/argonautica-0.1.4.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "c13f83ed4a2c08f22fb5d987272afee9", "sha256": "907428e19a3bd6e47666226786345ac9aa38ab68ce85e899b487b91f0d361c7c"}, "downloads": -1, "filename": "argonautica-0.1.5.tar.gz", "has_sig": false, "md5_digest": "c13f83ed4a2c08f22fb5d987272afee9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 1918553, "upload_time": "2018-06-28T18:09:41", "upload_time_iso_8601": "2018-06-28T18:09:41.450037Z", "url": "https://files.pythonhosted.org/packages/00/cc/b13451e97971a886f47869721077c3fe2480a129c30c1a54bf2e81ab3272/argonautica-0.1.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c13f83ed4a2c08f22fb5d987272afee9", "sha256": "907428e19a3bd6e47666226786345ac9aa38ab68ce85e899b487b91f0d361c7c"}, "downloads": -1, "filename": "argonautica-0.1.5.tar.gz", "has_sig": false, "md5_digest": "c13f83ed4a2c08f22fb5d987272afee9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 1918553, "upload_time": "2018-06-28T18:09:41", "upload_time_iso_8601": "2018-06-28T18:09:41.450037Z", "url": "https://files.pythonhosted.org/packages/00/cc/b13451e97971a886f47869721077c3fe2480a129c30c1a54bf2e81ab3272/argonautica-0.1.5.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:17:18 2020"}