{"info": {"author": "Gerard Flanagan", "author_email": "grflanagan@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "epyparse.py\n===========\n\nFormatting and serialization of epydoc-parsed Python source code.\nSource code is only ever parsed textually, never imported.\n\n\nCommand line Usage\n------------------\n\nprettyprint\n~~~~~~~~~~~\n\nPretty print a representation of the API of a named object or file::\n\n    $ epyparse print -path <name_or_path> [options]\n\nwhich can be shortened to::\n\n    $ epyparse <name_or_path> [options]\n\nBy default, output is colored for the terminal, you can turn this off with\nthe `-nocolor` option.\n\nserialize\n~~~~~~~~~\n\nFlatten the recursive API structure of a named object or file to a sequence\nof individual dictionaries. Each dictionary is JSON-serialized and saved to\nits own file::\n\n    $ epyparse serialize -path <name_or_path> [options]\n\nBy default, files are written to the current working directory, you can\nspecify another directory with the `-out` option::\n\n    $ epyparse serialize -path <name_or_path> -out docs/api\n\nProgrammatic Usage\n------------------\n\nTop-level functions are `parsed`, `flattened`, `pprint` and `objectify`::\n\n    >>> from epyparse import parsed, flattened, pprint, objectify\n\nInput can be a file path::\n\n    >>> pprint('setup.py')\n    ################################################################################\n    #    setup\n    ################################################################################\n    \"\"\"\n    \"\"\"\n    <BLANKLINE>\n    import distutils.core.setup\n    import sys\n    import os\n    import epyparse\n    <BLANKLINE>\n\nwhich must exist::\n\n    >>> parsed('does/not/exist')\n    Traceback (most recent call last):\n        ...\n    IOError: No such file does/not/exist\n\nOr a named object::\n\n    >>> pprint('os.getenv')\n    def getenv(key, default=None):\n        \"\"\"\n        Get an environment variable, return None if it doesn't exist.\n        The optional second argument can specify an alternate default.\n        \"\"\"\n    <BLANKLINE>\n\nwhich must be accessible::\n\n    >>> pprint('does.not.exist')\n    Traceback (most recent call last):\n        ...\n    ImportError: No Python source file found.\n\nand not a builtin or c-based object::\n\n    >>> pprint('cStringIO.StringIO')\n    Traceback (most recent call last):\n        ...\n    ImportError: No Python source file for builtin modules.\n\nModules, functions, classes or methods can be accessed::\n\n    >>> pprint('StringIO.StringIO.write')\n    def write(self, s):\n        \"\"\"\n        Write a string to the file.\n    <BLANKLINE>\n        There is no return value.\n        \"\"\"\n    <BLANKLINE>\n\n\nParse to a nested dictionary\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nParse module::\n\n    >>> d = parsed('epydoc.apidoc')\n    >>> sorted(d.keys())\n    ['children', 'docstring', 'fullname', 'imports', 'type']\n    >>> d['type']\n    'module'\n    >>> for item in sorted(d['children'], key=lambda d: (d['type'], d['fullname'])):\n    ...     print item['type'], ' -> ', item['fullname']\n    class  ->  epydoc.apidoc.APIDoc\n    class  ->  epydoc.apidoc.ClassDoc\n    class  ->  epydoc.apidoc.ClassMethodDoc\n    class  ->  epydoc.apidoc.DocIndex\n    class  ->  epydoc.apidoc.DottedName\n    class  ->  epydoc.apidoc.GenericValueDoc\n    class  ->  epydoc.apidoc.ModuleDoc\n    class  ->  epydoc.apidoc.NamespaceDoc\n    class  ->  epydoc.apidoc.PropertyDoc\n    class  ->  epydoc.apidoc.RoutineDoc\n    class  ->  epydoc.apidoc.StaticMethodDoc\n    class  ->  epydoc.apidoc.ValueDoc\n    class  ->  epydoc.apidoc.VariableDoc\n    class  ->  epydoc.apidoc._Sentinel\n    function  ->  epydoc.apidoc._flatten\n    function  ->  epydoc.apidoc._pp_apidoc\n    function  ->  epydoc.apidoc._pp_dict\n    function  ->  epydoc.apidoc._pp_list\n    function  ->  epydoc.apidoc._pp_val\n    function  ->  epydoc.apidoc.pp_apidoc\n    function  ->  epydoc.apidoc.reachable_valdocs\n\nFlatten and JSON-serialize\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor the `Object.get_parent` and `Object.get_children` deserialization\nmethods to work, we rely on the convention that api objects have been\nsaved to the same directory with the canonical name as file name and\nwith no file extension::\n\n    >>> import os, json\n    >>> assert not os.path.exists('TESTOUT')\n    >>> os.mkdir('TESTOUT')\n    >>> for item in flattened('epydoc.apidoc'):\n    ...     print item['fullname']\n    ...     with open('TESTOUT/' + item['fullname'], 'w+b') as fp:\n    ...         json.dump(item, fp)\n    ...\n    epydoc.apidoc._flatten\n    epydoc.apidoc._pp_apidoc\n    epydoc.apidoc._pp_dict\n    epydoc.apidoc._pp_list\n    epydoc.apidoc._pp_val\n    epydoc.apidoc.pp_apidoc\n    epydoc.apidoc.reachable_valdocs\n    epydoc.apidoc.APIDoc.__cmp__\n    epydoc.apidoc.APIDoc.__hash__\n    epydoc.apidoc.APIDoc.__init__\n    epydoc.apidoc.APIDoc.__repr__\n    epydoc.apidoc.APIDoc._debug_setattr\n    epydoc.apidoc.APIDoc._debug_setattr\n    epydoc.apidoc.APIDoc.apidoc_links\n    epydoc.apidoc.APIDoc.is_detailed\n    epydoc.apidoc.APIDoc.merge_and_overwrite\n    epydoc.apidoc.APIDoc.pp\n    epydoc.apidoc.APIDoc.pp\n    epydoc.apidoc.APIDoc.specialize_to\n    epydoc.apidoc.APIDoc\n    epydoc.apidoc.ClassDoc._c3_merge\n    epydoc.apidoc.ClassDoc._c3_mro\n    epydoc.apidoc.ClassDoc._dfs_bases\n    epydoc.apidoc.ClassDoc._report_bad_base\n    epydoc.apidoc.ClassDoc.apidoc_links\n    epydoc.apidoc.ClassDoc.is_exception\n    epydoc.apidoc.ClassDoc.is_newstyle_class\n    epydoc.apidoc.ClassDoc.is_type\n    epydoc.apidoc.ClassDoc.mro\n    epydoc.apidoc.ClassDoc.select_variables\n    epydoc.apidoc.ClassDoc\n    epydoc.apidoc.ClassMethodDoc\n    epydoc.apidoc.DocIndex.__init__\n    epydoc.apidoc.DocIndex._get\n    epydoc.apidoc.DocIndex._get_from\n    epydoc.apidoc.DocIndex._get_module_classes\n    epydoc.apidoc.DocIndex._update_funcid_to_doc\n    epydoc.apidoc.DocIndex.container\n    epydoc.apidoc.DocIndex.find\n    epydoc.apidoc.DocIndex.get_valdoc\n    epydoc.apidoc.DocIndex.get_vardoc\n    epydoc.apidoc.DocIndex.reachable_valdocs\n    epydoc.apidoc.DocIndex.read_profiling_info\n    epydoc.apidoc.DocIndex\n    epydoc.apidoc.DottedName.InvalidDottedName\n    epydoc.apidoc.DottedName.__add__\n    epydoc.apidoc.DottedName.__cmp__\n    epydoc.apidoc.DottedName.__getitem__\n    epydoc.apidoc.DottedName.__hash__\n    epydoc.apidoc.DottedName.__init__\n    epydoc.apidoc.DottedName.__len__\n    epydoc.apidoc.DottedName.__radd__\n    epydoc.apidoc.DottedName.__repr__\n    epydoc.apidoc.DottedName.__str__\n    epydoc.apidoc.DottedName.container\n    epydoc.apidoc.DottedName.contextualize\n    epydoc.apidoc.DottedName.dominates\n    epydoc.apidoc.DottedName\n    epydoc.apidoc.GenericValueDoc.is_detailed\n    epydoc.apidoc.GenericValueDoc\n    epydoc.apidoc.ModuleDoc.apidoc_links\n    epydoc.apidoc.ModuleDoc.init_submodule_groups\n    epydoc.apidoc.ModuleDoc.select_variables\n    epydoc.apidoc.ModuleDoc\n    epydoc.apidoc.NamespaceDoc.__init__\n    epydoc.apidoc.NamespaceDoc._init_grouping\n    epydoc.apidoc.NamespaceDoc.apidoc_links\n    epydoc.apidoc.NamespaceDoc.group_names\n    epydoc.apidoc.NamespaceDoc.init_sorted_variables\n    epydoc.apidoc.NamespaceDoc.init_variable_groups\n    epydoc.apidoc.NamespaceDoc.is_detailed\n    epydoc.apidoc.NamespaceDoc.report_unused_groups\n    epydoc.apidoc.NamespaceDoc\n    epydoc.apidoc.PropertyDoc.apidoc_links\n    epydoc.apidoc.PropertyDoc.is_detailed\n    epydoc.apidoc.PropertyDoc\n    epydoc.apidoc.RoutineDoc.all_args\n    epydoc.apidoc.RoutineDoc.is_detailed\n    epydoc.apidoc.RoutineDoc\n    epydoc.apidoc.StaticMethodDoc\n    epydoc.apidoc.ValueDoc.__getstate__\n    epydoc.apidoc.ValueDoc.__repr__\n    epydoc.apidoc.ValueDoc.__setstate__\n    epydoc.apidoc.ValueDoc.apidoc_links\n    epydoc.apidoc.ValueDoc.pyval_repr\n    epydoc.apidoc.ValueDoc.summary_pyval_repr\n    epydoc.apidoc.ValueDoc\n    epydoc.apidoc.VariableDoc.__init__\n    epydoc.apidoc.VariableDoc.__repr__\n    epydoc.apidoc.VariableDoc._get_defining_module\n    epydoc.apidoc.VariableDoc.apidoc_links\n    epydoc.apidoc.VariableDoc.is_detailed\n    epydoc.apidoc.VariableDoc\n    epydoc.apidoc._Sentinel.__init__\n    epydoc.apidoc._Sentinel.__nonzero__\n    epydoc.apidoc._Sentinel.__repr__\n    epydoc.apidoc._Sentinel\n    epydoc.apidoc\n\nDeserialize to `Object`\n~~~~~~~~~~~~~~~~~~~~~~~\n\n::\n\n    >>> from epyparse import objectify\n    >>> obj = objectify('TESTOUT/epydoc.apidoc.APIDoc.merge_and_overwrite')\n\nThe returned `Object` type is a dict subclass::\n\n    >>> sorted(obj.keys())\n    [u'args', u'attributes', u'fullname', u'is_method', u'lineno', u'params', 'src', u'type']\n\nwith attribute-style access::\n\n    >>> obj.args\n    [u'self', u'other']\n    >>> obj.is_method\n    True\n    >>> obj.lineno * 0\n    0\n    >>> obj.params\n    [[u'ignore_hash_conflict', False]]\n    >>> obj.name\n    u'merge_and_overwrite'\n\n`Object.parent` gives the name of the parent object, if any::\n\n    >>> obj.parent\n    u'epydoc.apidoc.APIDoc'\n\nAnd, because we have serialized the parent to the same directory, we can\nretrieve it with the `Object.get_parent` method::\n\n    >>> parent = obj.get_parent()\n    >>> parent.fullname\n    u'epydoc.apidoc.APIDoc'\n    >>> parent.type\n    u'class'\n    >>> parent.name\n    u'APIDoc'\n\nSimilarly, `Object.members` returns the names of the object's members, if any::\n\n    >>> for name in sorted(parent.members):\n    ...     print parent.fullname + '.' + name\n    epydoc.apidoc.APIDoc.__cmp__\n    epydoc.apidoc.APIDoc.__hash__\n    epydoc.apidoc.APIDoc.__init__\n    epydoc.apidoc.APIDoc.__repr__\n    epydoc.apidoc.APIDoc._debug_setattr\n    epydoc.apidoc.APIDoc._debug_setattr\n    epydoc.apidoc.APIDoc.apidoc_links\n    epydoc.apidoc.APIDoc.is_detailed\n    epydoc.apidoc.APIDoc.merge_and_overwrite\n    epydoc.apidoc.APIDoc.pp\n    epydoc.apidoc.APIDoc.pp\n    epydoc.apidoc.APIDoc.specialize_to\n\nand `Object.get_members` deserializes each member::\n\n    >>> for child in sorted(parent.get_members(), key=lambda d: d['fullname']):\n    ...     print child.type, ' -> ', child.name\n    function  ->  __cmp__\n    function  ->  __hash__\n    function  ->  __init__\n    function  ->  __repr__\n    alias  ->  _debug_setattr\n    alias  ->  _debug_setattr\n    function  ->  apidoc_links\n    function  ->  is_detailed\n    function  ->  merge_and_overwrite\n    function  ->  pp\n    function  ->  pp\n    function  ->  specialize_to\n\nIntrospection - `inspect` vs. `Inspector`\n-----------------------------------------\n\n    >>> import inspect\n    >>> from epydoc.apidoc import APIDoc\n    >>> from epyparse import Inspector\n    >>> merge_and_overwrite_obj = obj\n    >>> APIDoc_obj = parent\n\nargspec (not identical but good enough for displaying the function signature)::\n\n    >>> inspect.getargspec(APIDoc.merge_and_overwrite)\n    ArgSpec(args=['self', 'other', 'ignore_hash_conflict'], varargs=None, keywords=None, defaults=(False,))\n    >>> Inspector.getargspec(merge_and_overwrite_obj)\n    ArgSpec(args=[u'self', u'other', u'ignore_hash_conflict'], varargs=None, keywords=None, defaults=(False,))\n\n    >>> inspect.getargspec(APIDoc.apidoc_links)\n    ArgSpec(args=['self'], varargs=None, keywords='filters', defaults=None)\n    >>> Inspector.getargspec(APIDoc_obj.get_member('apidoc_links'))\n    ArgSpec(args=[u'self'], varargs=None, keywords=u'filters', defaults=None)\n\nhasattr::\n\n    >>> hasattr(APIDoc, 'merge_and_overwrite')\n    True\n    >>> Inspector.hasattr(APIDoc_obj, 'merge_and_overwrite')\n    True\n    >>> Inspector.hasattr(APIDoc_obj, 'somethingsomethingorangessomething')\n    False\n\ndir\n---\n\n    >>> dir(merge_and_overwrite_obj)\n    ['__dict__', u'__doc__', u'__name__']\n    >>> sorted(dir(APIDoc_obj))[:7]\n    [u'__cmp__', '__dict__', u'__doc__', u'__hash__', u'__init__', u'__name__', u'__repr__']\n    >>> sorted(dir(APIDoc_obj))[7:13]\n    [u'_debug_setattr', u'_debug_setattr', u'apidoc_links', u'is_detailed', u'merge_and_overwrite', u'pp']\n    >>> module_obj = objectify('TESTOUT/epydoc.apidoc')\n    >>> sorted(dir(module_obj))[:7]\n    [u'APIDoc', u'ClassDoc', u'ClassMethodDoc', u'DocIndex', u'DottedName', u'GenericValueDoc', u'ModuleDoc']\n\n__doc__\n-------\n\n    >>> hasattr(APIDoc.merge_and_overwrite, '__doc__')\n    True\n    >>> hasattr(merge_and_overwrite_obj, '__doc__')\n    True\n    >>> Inspector.hasattr(merge_and_overwrite_obj, '__doc__')\n    True\n    >>> actual = ''.join(\n    ...   s.strip() for s in APIDoc.merge_and_overwrite.__doc__.splitlines() if s.strip()\n    ... )\n    ...\n    >>> serialized = ''.join(\n    ...   s.strip() for s in merge_and_overwrite_obj.__doc__.splitlines() if s.strip()\n    ... )\n    ...\n    >>> assert len(actual) and len(serialized)\n    >>> assert actual == serialized\n\n__dict__\n--------\n\n    >>> Inspector.hasattr(merge_and_overwrite_obj, '__dict__')\n    True\n    >>> d = Inspector.getattr(merge_and_overwrite_obj, '__dict__')\n    >>> d['__name__']\n    u'merge_and_overwrite'\n    >>> print d['__doc__'] #doctest: +ELLIPSIS\n    Combine C{self} and C{other} into a X{merged object}, such\n    that any changes made to one will affect the other.  Any...\n\nBase classes\n------------\n\n\nTidy up::\n\n    >>> import shutil\n    >>> shutil.rmtree('TESTOUT')", "description_content_type": null, "docs_url": null, "download_url": "http://pypi.python.org/packages/source/e/epyparse/epyparse-0.2.5.tar.gz", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/epyparse", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "epyparse", "package_url": "https://pypi.org/project/epyparse/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/epyparse/", "project_urls": {"Download": "http://pypi.python.org/packages/source/e/epyparse/epyparse-0.2.5.tar.gz", "Homepage": "http://pypi.python.org/pypi/epyparse"}, "release_url": "https://pypi.org/project/epyparse/0.2.5/", "requires_dist": null, "requires_python": null, "summary": "Generate API info for Python Packages via Epydoc", "version": "0.2.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Formatting and serialization of epydoc-parsed Python source code.\nSource code is only ever parsed textually, never imported.</p>\n<div id=\"command-line-usage\">\n<h2>Command line Usage</h2>\n<div id=\"prettyprint\">\n<h3>prettyprint</h3>\n<p>Pretty print a representation of the API of a named object or file:</p>\n<pre>$ epyparse print -path &lt;name_or_path&gt; [options]\n</pre>\n<p>which can be shortened to:</p>\n<pre>$ epyparse &lt;name_or_path&gt; [options]\n</pre>\n<p>By default, output is colored for the terminal, you can turn this off with\nthe <cite>-nocolor</cite> option.</p>\n</div>\n<div id=\"serialize\">\n<h3>serialize</h3>\n<p>Flatten the recursive API structure of a named object or file to a sequence\nof individual dictionaries. Each dictionary is JSON-serialized and saved to\nits own file:</p>\n<pre>$ epyparse serialize -path &lt;name_or_path&gt; [options]\n</pre>\n<p>By default, files are written to the current working directory, you can\nspecify another directory with the <cite>-out</cite> option:</p>\n<pre>$ epyparse serialize -path &lt;name_or_path&gt; -out docs/api\n</pre>\n</div>\n</div>\n<div id=\"programmatic-usage\">\n<h2>Programmatic Usage</h2>\n<p>Top-level functions are <cite>parsed</cite>, <cite>flattened</cite>, <cite>pprint</cite> and <cite>objectify</cite>:</p>\n<pre>&gt;&gt;&gt; from epyparse import parsed, flattened, pprint, objectify\n</pre>\n<p>Input can be a file path:</p>\n<pre>&gt;&gt;&gt; pprint('setup.py')\n################################################################################\n#    setup\n################################################################################\n\"\"\"\n\"\"\"\n&lt;BLANKLINE&gt;\nimport distutils.core.setup\nimport sys\nimport os\nimport epyparse\n&lt;BLANKLINE&gt;\n</pre>\n<p>which must exist:</p>\n<pre>&gt;&gt;&gt; parsed('does/not/exist')\nTraceback (most recent call last):\n    ...\nIOError: No such file does/not/exist\n</pre>\n<p>Or a named object:</p>\n<pre>&gt;&gt;&gt; pprint('os.getenv')\ndef getenv(key, default=None):\n    \"\"\"\n    Get an environment variable, return None if it doesn't exist.\n    The optional second argument can specify an alternate default.\n    \"\"\"\n&lt;BLANKLINE&gt;\n</pre>\n<p>which must be accessible:</p>\n<pre>&gt;&gt;&gt; pprint('does.not.exist')\nTraceback (most recent call last):\n    ...\nImportError: No Python source file found.\n</pre>\n<p>and not a builtin or c-based object:</p>\n<pre>&gt;&gt;&gt; pprint('cStringIO.StringIO')\nTraceback (most recent call last):\n    ...\nImportError: No Python source file for builtin modules.\n</pre>\n<p>Modules, functions, classes or methods can be accessed:</p>\n<pre>&gt;&gt;&gt; pprint('StringIO.StringIO.write')\ndef write(self, s):\n    \"\"\"\n    Write a string to the file.\n&lt;BLANKLINE&gt;\n    There is no return value.\n    \"\"\"\n&lt;BLANKLINE&gt;\n</pre>\n<div id=\"parse-to-a-nested-dictionary\">\n<h3>Parse to a nested dictionary</h3>\n<p>Parse module:</p>\n<pre>&gt;&gt;&gt; d = parsed('epydoc.apidoc')\n&gt;&gt;&gt; sorted(d.keys())\n['children', 'docstring', 'fullname', 'imports', 'type']\n&gt;&gt;&gt; d['type']\n'module'\n&gt;&gt;&gt; for item in sorted(d['children'], key=lambda d: (d['type'], d['fullname'])):\n...     print item['type'], ' -&gt; ', item['fullname']\nclass  -&gt;  epydoc.apidoc.APIDoc\nclass  -&gt;  epydoc.apidoc.ClassDoc\nclass  -&gt;  epydoc.apidoc.ClassMethodDoc\nclass  -&gt;  epydoc.apidoc.DocIndex\nclass  -&gt;  epydoc.apidoc.DottedName\nclass  -&gt;  epydoc.apidoc.GenericValueDoc\nclass  -&gt;  epydoc.apidoc.ModuleDoc\nclass  -&gt;  epydoc.apidoc.NamespaceDoc\nclass  -&gt;  epydoc.apidoc.PropertyDoc\nclass  -&gt;  epydoc.apidoc.RoutineDoc\nclass  -&gt;  epydoc.apidoc.StaticMethodDoc\nclass  -&gt;  epydoc.apidoc.ValueDoc\nclass  -&gt;  epydoc.apidoc.VariableDoc\nclass  -&gt;  epydoc.apidoc._Sentinel\nfunction  -&gt;  epydoc.apidoc._flatten\nfunction  -&gt;  epydoc.apidoc._pp_apidoc\nfunction  -&gt;  epydoc.apidoc._pp_dict\nfunction  -&gt;  epydoc.apidoc._pp_list\nfunction  -&gt;  epydoc.apidoc._pp_val\nfunction  -&gt;  epydoc.apidoc.pp_apidoc\nfunction  -&gt;  epydoc.apidoc.reachable_valdocs\n</pre>\n</div>\n<div id=\"flatten-and-json-serialize\">\n<h3>Flatten and JSON-serialize</h3>\n<p>For the <cite>Object.get_parent</cite> and <cite>Object.get_children</cite> deserialization\nmethods to work, we rely on the convention that api objects have been\nsaved to the same directory with the canonical name as file name and\nwith no file extension:</p>\n<pre>&gt;&gt;&gt; import os, json\n&gt;&gt;&gt; assert not os.path.exists('TESTOUT')\n&gt;&gt;&gt; os.mkdir('TESTOUT')\n&gt;&gt;&gt; for item in flattened('epydoc.apidoc'):\n...     print item['fullname']\n...     with open('TESTOUT/' + item['fullname'], 'w+b') as fp:\n...         json.dump(item, fp)\n...\nepydoc.apidoc._flatten\nepydoc.apidoc._pp_apidoc\nepydoc.apidoc._pp_dict\nepydoc.apidoc._pp_list\nepydoc.apidoc._pp_val\nepydoc.apidoc.pp_apidoc\nepydoc.apidoc.reachable_valdocs\nepydoc.apidoc.APIDoc.__cmp__\nepydoc.apidoc.APIDoc.__hash__\nepydoc.apidoc.APIDoc.__init__\nepydoc.apidoc.APIDoc.__repr__\nepydoc.apidoc.APIDoc._debug_setattr\nepydoc.apidoc.APIDoc._debug_setattr\nepydoc.apidoc.APIDoc.apidoc_links\nepydoc.apidoc.APIDoc.is_detailed\nepydoc.apidoc.APIDoc.merge_and_overwrite\nepydoc.apidoc.APIDoc.pp\nepydoc.apidoc.APIDoc.pp\nepydoc.apidoc.APIDoc.specialize_to\nepydoc.apidoc.APIDoc\nepydoc.apidoc.ClassDoc._c3_merge\nepydoc.apidoc.ClassDoc._c3_mro\nepydoc.apidoc.ClassDoc._dfs_bases\nepydoc.apidoc.ClassDoc._report_bad_base\nepydoc.apidoc.ClassDoc.apidoc_links\nepydoc.apidoc.ClassDoc.is_exception\nepydoc.apidoc.ClassDoc.is_newstyle_class\nepydoc.apidoc.ClassDoc.is_type\nepydoc.apidoc.ClassDoc.mro\nepydoc.apidoc.ClassDoc.select_variables\nepydoc.apidoc.ClassDoc\nepydoc.apidoc.ClassMethodDoc\nepydoc.apidoc.DocIndex.__init__\nepydoc.apidoc.DocIndex._get\nepydoc.apidoc.DocIndex._get_from\nepydoc.apidoc.DocIndex._get_module_classes\nepydoc.apidoc.DocIndex._update_funcid_to_doc\nepydoc.apidoc.DocIndex.container\nepydoc.apidoc.DocIndex.find\nepydoc.apidoc.DocIndex.get_valdoc\nepydoc.apidoc.DocIndex.get_vardoc\nepydoc.apidoc.DocIndex.reachable_valdocs\nepydoc.apidoc.DocIndex.read_profiling_info\nepydoc.apidoc.DocIndex\nepydoc.apidoc.DottedName.InvalidDottedName\nepydoc.apidoc.DottedName.__add__\nepydoc.apidoc.DottedName.__cmp__\nepydoc.apidoc.DottedName.__getitem__\nepydoc.apidoc.DottedName.__hash__\nepydoc.apidoc.DottedName.__init__\nepydoc.apidoc.DottedName.__len__\nepydoc.apidoc.DottedName.__radd__\nepydoc.apidoc.DottedName.__repr__\nepydoc.apidoc.DottedName.__str__\nepydoc.apidoc.DottedName.container\nepydoc.apidoc.DottedName.contextualize\nepydoc.apidoc.DottedName.dominates\nepydoc.apidoc.DottedName\nepydoc.apidoc.GenericValueDoc.is_detailed\nepydoc.apidoc.GenericValueDoc\nepydoc.apidoc.ModuleDoc.apidoc_links\nepydoc.apidoc.ModuleDoc.init_submodule_groups\nepydoc.apidoc.ModuleDoc.select_variables\nepydoc.apidoc.ModuleDoc\nepydoc.apidoc.NamespaceDoc.__init__\nepydoc.apidoc.NamespaceDoc._init_grouping\nepydoc.apidoc.NamespaceDoc.apidoc_links\nepydoc.apidoc.NamespaceDoc.group_names\nepydoc.apidoc.NamespaceDoc.init_sorted_variables\nepydoc.apidoc.NamespaceDoc.init_variable_groups\nepydoc.apidoc.NamespaceDoc.is_detailed\nepydoc.apidoc.NamespaceDoc.report_unused_groups\nepydoc.apidoc.NamespaceDoc\nepydoc.apidoc.PropertyDoc.apidoc_links\nepydoc.apidoc.PropertyDoc.is_detailed\nepydoc.apidoc.PropertyDoc\nepydoc.apidoc.RoutineDoc.all_args\nepydoc.apidoc.RoutineDoc.is_detailed\nepydoc.apidoc.RoutineDoc\nepydoc.apidoc.StaticMethodDoc\nepydoc.apidoc.ValueDoc.__getstate__\nepydoc.apidoc.ValueDoc.__repr__\nepydoc.apidoc.ValueDoc.__setstate__\nepydoc.apidoc.ValueDoc.apidoc_links\nepydoc.apidoc.ValueDoc.pyval_repr\nepydoc.apidoc.ValueDoc.summary_pyval_repr\nepydoc.apidoc.ValueDoc\nepydoc.apidoc.VariableDoc.__init__\nepydoc.apidoc.VariableDoc.__repr__\nepydoc.apidoc.VariableDoc._get_defining_module\nepydoc.apidoc.VariableDoc.apidoc_links\nepydoc.apidoc.VariableDoc.is_detailed\nepydoc.apidoc.VariableDoc\nepydoc.apidoc._Sentinel.__init__\nepydoc.apidoc._Sentinel.__nonzero__\nepydoc.apidoc._Sentinel.__repr__\nepydoc.apidoc._Sentinel\nepydoc.apidoc\n</pre>\n</div>\n<div id=\"deserialize-to-object\">\n<h3>Deserialize to <cite>Object</cite></h3>\n<pre>&gt;&gt;&gt; from epyparse import objectify\n&gt;&gt;&gt; obj = objectify('TESTOUT/epydoc.apidoc.APIDoc.merge_and_overwrite')\n</pre>\n<p>The returned <cite>Object</cite> type is a dict subclass:</p>\n<pre>&gt;&gt;&gt; sorted(obj.keys())\n[u'args', u'attributes', u'fullname', u'is_method', u'lineno', u'params', 'src', u'type']\n</pre>\n<p>with attribute-style access:</p>\n<pre>&gt;&gt;&gt; obj.args\n[u'self', u'other']\n&gt;&gt;&gt; obj.is_method\nTrue\n&gt;&gt;&gt; obj.lineno * 0\n0\n&gt;&gt;&gt; obj.params\n[[u'ignore_hash_conflict', False]]\n&gt;&gt;&gt; obj.name\nu'merge_and_overwrite'\n</pre>\n<p><cite>Object.parent</cite> gives the name of the parent object, if any:</p>\n<pre>&gt;&gt;&gt; obj.parent\nu'epydoc.apidoc.APIDoc'\n</pre>\n<p>And, because we have serialized the parent to the same directory, we can\nretrieve it with the <cite>Object.get_parent</cite> method:</p>\n<pre>&gt;&gt;&gt; parent = obj.get_parent()\n&gt;&gt;&gt; parent.fullname\nu'epydoc.apidoc.APIDoc'\n&gt;&gt;&gt; parent.type\nu'class'\n&gt;&gt;&gt; parent.name\nu'APIDoc'\n</pre>\n<p>Similarly, <cite>Object.members</cite> returns the names of the object\u2019s members, if any:</p>\n<pre>&gt;&gt;&gt; for name in sorted(parent.members):\n...     print parent.fullname + '.' + name\nepydoc.apidoc.APIDoc.__cmp__\nepydoc.apidoc.APIDoc.__hash__\nepydoc.apidoc.APIDoc.__init__\nepydoc.apidoc.APIDoc.__repr__\nepydoc.apidoc.APIDoc._debug_setattr\nepydoc.apidoc.APIDoc._debug_setattr\nepydoc.apidoc.APIDoc.apidoc_links\nepydoc.apidoc.APIDoc.is_detailed\nepydoc.apidoc.APIDoc.merge_and_overwrite\nepydoc.apidoc.APIDoc.pp\nepydoc.apidoc.APIDoc.pp\nepydoc.apidoc.APIDoc.specialize_to\n</pre>\n<p>and <cite>Object.get_members</cite> deserializes each member:</p>\n<pre>&gt;&gt;&gt; for child in sorted(parent.get_members(), key=lambda d: d['fullname']):\n...     print child.type, ' -&gt; ', child.name\nfunction  -&gt;  __cmp__\nfunction  -&gt;  __hash__\nfunction  -&gt;  __init__\nfunction  -&gt;  __repr__\nalias  -&gt;  _debug_setattr\nalias  -&gt;  _debug_setattr\nfunction  -&gt;  apidoc_links\nfunction  -&gt;  is_detailed\nfunction  -&gt;  merge_and_overwrite\nfunction  -&gt;  pp\nfunction  -&gt;  pp\nfunction  -&gt;  specialize_to\n</pre>\n</div>\n</div>\n<div id=\"introspection-inspect-vs-inspector\">\n<h2>Introspection - <cite>inspect</cite> vs. <cite>Inspector</cite></h2>\n<blockquote>\n<pre>&gt;&gt;&gt; import inspect\n&gt;&gt;&gt; from epydoc.apidoc import APIDoc\n&gt;&gt;&gt; from epyparse import Inspector\n&gt;&gt;&gt; merge_and_overwrite_obj = obj\n&gt;&gt;&gt; APIDoc_obj = parent\n</pre>\n</blockquote>\n<p>argspec (not identical but good enough for displaying the function signature):</p>\n<pre>&gt;&gt;&gt; inspect.getargspec(APIDoc.merge_and_overwrite)\nArgSpec(args=['self', 'other', 'ignore_hash_conflict'], varargs=None, keywords=None, defaults=(False,))\n&gt;&gt;&gt; Inspector.getargspec(merge_and_overwrite_obj)\nArgSpec(args=[u'self', u'other', u'ignore_hash_conflict'], varargs=None, keywords=None, defaults=(False,))\n\n&gt;&gt;&gt; inspect.getargspec(APIDoc.apidoc_links)\nArgSpec(args=['self'], varargs=None, keywords='filters', defaults=None)\n&gt;&gt;&gt; Inspector.getargspec(APIDoc_obj.get_member('apidoc_links'))\nArgSpec(args=[u'self'], varargs=None, keywords=u'filters', defaults=None)\n</pre>\n<p>hasattr:</p>\n<pre>&gt;&gt;&gt; hasattr(APIDoc, 'merge_and_overwrite')\nTrue\n&gt;&gt;&gt; Inspector.hasattr(APIDoc_obj, 'merge_and_overwrite')\nTrue\n&gt;&gt;&gt; Inspector.hasattr(APIDoc_obj, 'somethingsomethingorangessomething')\nFalse\n</pre>\n</div>\n<div id=\"dir\">\n<h2>dir</h2>\n<blockquote>\n<pre>&gt;&gt;&gt; dir(merge_and_overwrite_obj)\n['__dict__', u'__doc__', u'__name__']\n&gt;&gt;&gt; sorted(dir(APIDoc_obj))[:7]\n[u'__cmp__', '__dict__', u'__doc__', u'__hash__', u'__init__', u'__name__', u'__repr__']\n&gt;&gt;&gt; sorted(dir(APIDoc_obj))[7:13]\n[u'_debug_setattr', u'_debug_setattr', u'apidoc_links', u'is_detailed', u'merge_and_overwrite', u'pp']\n&gt;&gt;&gt; module_obj = objectify('TESTOUT/epydoc.apidoc')\n&gt;&gt;&gt; sorted(dir(module_obj))[:7]\n[u'APIDoc', u'ClassDoc', u'ClassMethodDoc', u'DocIndex', u'DottedName', u'GenericValueDoc', u'ModuleDoc']\n</pre>\n</blockquote>\n</div>\n<div id=\"doc\">\n<h2>__doc__</h2>\n<blockquote>\n<pre>&gt;&gt;&gt; hasattr(APIDoc.merge_and_overwrite, '__doc__')\nTrue\n&gt;&gt;&gt; hasattr(merge_and_overwrite_obj, '__doc__')\nTrue\n&gt;&gt;&gt; Inspector.hasattr(merge_and_overwrite_obj, '__doc__')\nTrue\n&gt;&gt;&gt; actual = ''.join(\n...   s.strip() for s in APIDoc.merge_and_overwrite.__doc__.splitlines() if s.strip()\n... )\n...\n&gt;&gt;&gt; serialized = ''.join(\n...   s.strip() for s in merge_and_overwrite_obj.__doc__.splitlines() if s.strip()\n... )\n...\n&gt;&gt;&gt; assert len(actual) and len(serialized)\n&gt;&gt;&gt; assert actual == serialized\n</pre>\n</blockquote>\n</div>\n<div id=\"dict\">\n<h2>__dict__</h2>\n<blockquote>\n<pre>&gt;&gt;&gt; Inspector.hasattr(merge_and_overwrite_obj, '__dict__')\nTrue\n&gt;&gt;&gt; d = Inspector.getattr(merge_and_overwrite_obj, '__dict__')\n&gt;&gt;&gt; d['__name__']\nu'merge_and_overwrite'\n&gt;&gt;&gt; print d['__doc__'] #doctest: +ELLIPSIS\nCombine C{self} and C{other} into a X{merged object}, such\nthat any changes made to one will affect the other.  Any...\n</pre>\n</blockquote>\n</div>\n<div id=\"base-classes\">\n<h2>Base classes</h2>\n<p>Tidy up:</p>\n<pre>&gt;&gt;&gt; import shutil\n&gt;&gt;&gt; shutil.rmtree('TESTOUT')\n</pre>\n</div>\n\n          </div>"}, "last_serial": 791695, "releases": {"0.2.5": [{"comment_text": "", "digests": {"md5": "fa8d23943932b33937d7181f51f73e73", "sha256": "56af84f2d5bfbdd4186d00018142091694a476d095bede1da68a4bc4184700f7"}, "downloads": -1, "filename": "epyparse-0.2.5.tar.gz", "has_sig": false, "md5_digest": "fa8d23943932b33937d7181f51f73e73", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10956, "upload_time": "2012-01-18T17:22:05", "upload_time_iso_8601": "2012-01-18T17:22:05.404119Z", "url": "https://files.pythonhosted.org/packages/7b/cb/9ca2a7dcb49a9ddab3ad3088b0064e922a33652cc8a5144f798c2ba29a8c/epyparse-0.2.5.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "b660acde138617ccb1d99b26929dc0e8", "sha256": "670add958dd03ab26fd294464924070b940821e3f509dfeaf9ae8e4d11e065b7"}, "downloads": -1, "filename": "epyparse-0.2.5.zip", "has_sig": false, "md5_digest": "b660acde138617ccb1d99b26929dc0e8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13873, "upload_time": "2012-01-18T17:22:05", "upload_time_iso_8601": "2012-01-18T17:22:05.943068Z", "url": "https://files.pythonhosted.org/packages/f5/79/61a44d311c8d11543d1dee214c70a3c5811c79c591f70a05edc1f53e566b/epyparse-0.2.5.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "fa8d23943932b33937d7181f51f73e73", "sha256": "56af84f2d5bfbdd4186d00018142091694a476d095bede1da68a4bc4184700f7"}, "downloads": -1, "filename": "epyparse-0.2.5.tar.gz", "has_sig": false, "md5_digest": "fa8d23943932b33937d7181f51f73e73", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10956, "upload_time": "2012-01-18T17:22:05", "upload_time_iso_8601": "2012-01-18T17:22:05.404119Z", "url": "https://files.pythonhosted.org/packages/7b/cb/9ca2a7dcb49a9ddab3ad3088b0064e922a33652cc8a5144f798c2ba29a8c/epyparse-0.2.5.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "b660acde138617ccb1d99b26929dc0e8", "sha256": "670add958dd03ab26fd294464924070b940821e3f509dfeaf9ae8e4d11e065b7"}, "downloads": -1, "filename": "epyparse-0.2.5.zip", "has_sig": false, "md5_digest": "b660acde138617ccb1d99b26929dc0e8", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13873, "upload_time": "2012-01-18T17:22:05", "upload_time_iso_8601": "2012-01-18T17:22:05.943068Z", "url": "https://files.pythonhosted.org/packages/f5/79/61a44d311c8d11543d1dee214c70a3c5811c79c591f70a05edc1f53e566b/epyparse-0.2.5.zip", "yanked": false}], "timestamp": "Fri May  8 00:45:53 2020"}