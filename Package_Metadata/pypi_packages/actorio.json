{"info": {"author": "Jonathan GAYVALLET", "author_email": "jonathan.mael.gayvallet@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Operating System :: MacOS :: MacOS X", "Operating System :: Microsoft :: Windows", "Operating System :: POSIX :: BSD", "Operating System :: POSIX :: Linux", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3 :: Only", "Programming Language :: Python :: Implementation :: CPython"], "description": "[![pipeline status](https://gitlab.com/python-actorio/actorio/badges/master/pipeline.svg)](https://gitlab.com/python-actorio/actorio/commits/master)\n[![coverage report](https://gitlab.com/python-actorio/actorio/badges/master/coverage.svg)](https://gitlab.com/python-actorio/actorio/commits/master)\n[![PyPI version](https://badge.fury.io/py/actorio.svg)](https://badge.fury.io/py/actorio)\n# Actorio - a simple actor framework for asyncio\n\nActorio is a Python asyncio implementation of the [actor model](https://en.wikipedia.org/wiki/Actor_model).\n\nThere already are Python actor model implementation such as\n[Thespian](https://github.com/kquick/Thespian) or [Pykka](https://github.com/jodal/pykka)\nbut they're currently lacking asyncio support.\n\nThe main goal of the Actor model is to cleanly define the critical section \nwithout having to deal with lock or any other synchronization mechanism.\n\nIt also helps with the [Single responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle),\neach `Actor` class should deal with one part of the fonctionnal requirements of the application and its API can be properly defined\n(ie, what kind of message does this actor accept and what kind of message does it produce), hence making actor testing easier,\nsince you don't have to mock the surrounding systems and just check if the message sequence if correct. \n\n\n*Current API is crude and provisional and is likely to change as syntax and concepts evolve.*\n\n\n### Rules of the actor model\n- An actor is an execution unit that executes concurrently with other actors.\n\n- An actor does not share state with anybody else, but it can have its own state.\n\n- An actor can only communicate with other actors by sending and receiving messages. It can only send messages to actors whose address it has.\n\n- When an actor receives a message it may take actions like:\n\n  - altering its own state, e.g. so that it can react differently to a future message\n  - sending messages to other actors\n  - starting new actors\n\n    None of the actions are required, and they may be applied in any order.\n\n- An actor only processes one message at a time. In other words, a single actor does not give you any concurrency, and it does not need to use locks internally to protect its own state.\n\n### Hello World\nA Hello world example:\n\nLet's start with the typical example of Hello World. In this case, we'll create an Actor, send it a message, wait for a response message, and print that response: \n\n```python\nfrom actorio import Actor, Message, DataMessage, ask\nimport asyncio\nclass Greeter(Actor):\n    # Here we override the handle_message method to send a `DataMessage` with the data \"Hello World!\".\n    async def handle_message(self, message: Message):\n        await message.sender.tell(DataMessage(data=\"Hello World!\", sender=self))\n\n\nasync def main():\n    # Let's create an instance of a Greeter actor and start it. \n    async with Greeter() as greeter:\n        # Then we'll just send it an empty message and wait for a response\n        reply : DataMessage = await ask(greeter, Message())\n    print(reply.data)\n\nasyncio.get_event_loop().run_until_complete(main())\n```\n\n### Actor spawning actors\nActor instances can spawn other actors during their execution. be it at startup, in the `mainloop_setup` async method or as a reaction to an event in any handler.\n\nThe actor should first be instanciated (with an `__init__` call) then be registered on its parent with a `register_child` async call.\n\nWhenever a child dies, the parent `handle_child_stopped` async method is called with the child actor object and the `asyncio.task` object for its execution loop. This way, the parent can take any action required.\n\nFor example, if we had to handle blocking operations. we could do something like:\n```python\nimport random\nimport asyncio\nfrom actorio import Actor, Message, DataMessage, EndMainLoop, Reference\nasync def blocking_operation():\n    #for the sake of this example, the blocking operation is a sleep\n    sleep_time = random.randint(0,10)\n    await asyncio.sleep(sleep_time)\n    return sleep_time\n\nclass RequestMessage(Message):\n    \"\"\"\n    A request to do some computation or blocking call\n    \"\"\"\n\nclass ResponseMessage(DataMessage):\n    \"\"\"\n    The result of a computation\n    \"\"\"\n\nclass Worker(Actor):\n    # Here we override the handle_message method to send a `ResponseMessage`\n    # with the result of the blocking operation as its data.\n    async def handle_message(self, message: Message):\n        sleep_time = await blocking_operation()\n        await message.sender.tell(ResponseMessage(data=sleep_time, sender=self))\n        # This actor only deals with one message then stops,\n        # raising an EndMainLoop exeception here will properly stop the actor\n        raise EndMainLoop() \n\nclass Manager(Actor):\n    async def handle_message(self, message: Message):\n        if isinstance(message, RequestMessage):\n            # We spawn and register the new child, we get its reference back\n            child = await self.register_child(Worker())\n            # We just transfer the message to the child, that way,\n            # we won't have to process its response\n            await child.tell(message)\n\nasync def main():\n    # We create an inbox for us, this is not an actor,\n    # just somewhere actors can send messages\n    me = Reference()\n    async with Manager() as manager:\n        # Then we start 10 long computations\n        for _ in range(10): await manager.tell(RequestMessage(sender=me))\n        # Then we'll listen to our inbox\n        # to get the responses as they come by\n        for _ in range(10):\n            message = await me.inbox.get()\n            print(\"Got a response with result {}\".format(message.data))\n\nasyncio.get_event_loop().run_until_complete(main())\n\n```\n### Handling external blocking events\nUsing message is great, but, most of the time, we also need to use other APIs that don't provide a message-based interface.\n\nIt's possible to register external blocking event and handler for those with the `register_input_task` method.\nThis methods takes a factory function for a coroutine and an async function to handle the task result.\n\n**The handler will not be called if the Actor is currently busy processing anything else\n(like a message or any other task), this way, there is no concurrency issue\nand each handler is called with a clean actor state**\n\n*For now, the order in which those events will be handled is not necessarily the order in which they happened* \n\nFor example, to use an `aiohttp` websocket :\n```python\nimport aiohttp\nfrom aiohttp import web\nfrom actorio import Actor, EndMainLoop\nimport asyncio\n\nclass Client(Actor):\n    def __init__(self, websocket: web.WebSocketResponse):\n        self.websocket = websocket\n        super().__init__()\n\n    # Here we define an input task handler,\n    # It will be called each time its registered event happens.\n    # The resulting `asyncio.Task` object will be passed as argument,\n    # this way, the handler can deal with any exception raised during event collection \n    async def handle_websocket_event(self, task: asyncio.Task):\n        try:\n            msg = task.result()\n        except Exception as e:\n            # In case of any exception, we just stop the Actor\n            self.logger.exception(e)\n            raise EndMainLoop()\n        if msg.type == aiohttp.WSMsgType.TEXT:\n            # if we receive text, we just send it back\n            # We could also just send a message to our inbox\n            await self.websocket.send_str(msg.data)\n        else:\n            # any other request just stops the Actor\n            raise EndMainLoop()\n\n    async def mainloop_setup(self):\n        self.register_input_task(self.websocket.receive, self.handle_websocket_event)\n        await super().mainloop_setup()\n\n\n\nasync def websocket_handler(request):\n    ws = web.WebSocketResponse()\n    await ws.prepare(request)\n\n    client_actor = Client(websocket=ws)\n\n    async with client_actor:\n        # We until the client's mainloop ends\n        await client_actor\n\n    return ws\n\napp = web.Application()\napp.add_routes([web.get('/', websocket_handler)])\nweb.run_app(app)\n```\n\nYou can then connect to the websocket and send it some messages, it will act as an echo server.\n\n", "description_content_type": "text/markdown; charset=UTF-8; variant=GFM", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://gitlab.com/python-actorio/actorio", "keywords": "", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "actorio", "package_url": "https://pypi.org/project/actorio/", "platform": "", "project_url": "https://pypi.org/project/actorio/", "project_urls": {"Homepage": "https://gitlab.com/python-actorio/actorio"}, "release_url": "https://pypi.org/project/actorio/0.1.4/", "requires_dist": ["pytz (>=2018.7)"], "requires_python": ">=3.6", "summary": "A simple actor framework for asyncio", "version": "0.1.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://gitlab.com/python-actorio/actorio/commits/master\" rel=\"nofollow\"><img alt=\"pipeline status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0f65bcfa3e9c6c0b5700250858bc9e0b17758503/68747470733a2f2f6769746c61622e636f6d2f707974686f6e2d6163746f72696f2f6163746f72696f2f6261646765732f6d61737465722f706970656c696e652e737667\"></a>\n<a href=\"https://gitlab.com/python-actorio/actorio/commits/master\" rel=\"nofollow\"><img alt=\"coverage report\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/a4552c041b424deb62ff4a504a29915564e854ab/68747470733a2f2f6769746c61622e636f6d2f707974686f6e2d6163746f72696f2f6163746f72696f2f6261646765732f6d61737465722f636f7665726167652e737667\"></a>\n<a href=\"https://badge.fury.io/py/actorio\" rel=\"nofollow\"><img alt=\"PyPI version\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d47b6e25bab58a0ef0b791e4fe4f0c3659721e16/68747470733a2f2f62616467652e667572792e696f2f70792f6163746f72696f2e737667\"></a></p>\n<h1>Actorio - a simple actor framework for asyncio</h1>\n<p>Actorio is a Python asyncio implementation of the <a href=\"https://en.wikipedia.org/wiki/Actor_model\" rel=\"nofollow\">actor model</a>.</p>\n<p>There already are Python actor model implementation such as\n<a href=\"https://github.com/kquick/Thespian\" rel=\"nofollow\">Thespian</a> or <a href=\"https://github.com/jodal/pykka\" rel=\"nofollow\">Pykka</a>\nbut they're currently lacking asyncio support.</p>\n<p>The main goal of the Actor model is to cleanly define the critical section\nwithout having to deal with lock or any other synchronization mechanism.</p>\n<p>It also helps with the <a href=\"https://en.wikipedia.org/wiki/Single_responsibility_principle\" rel=\"nofollow\">Single responsibility principle</a>,\neach <code>Actor</code> class should deal with one part of the fonctionnal requirements of the application and its API can be properly defined\n(ie, what kind of message does this actor accept and what kind of message does it produce), hence making actor testing easier,\nsince you don't have to mock the surrounding systems and just check if the message sequence if correct.</p>\n<p><em>Current API is crude and provisional and is likely to change as syntax and concepts evolve.</em></p>\n<h3>Rules of the actor model</h3>\n<ul>\n<li>\n<p>An actor is an execution unit that executes concurrently with other actors.</p>\n</li>\n<li>\n<p>An actor does not share state with anybody else, but it can have its own state.</p>\n</li>\n<li>\n<p>An actor can only communicate with other actors by sending and receiving messages. It can only send messages to actors whose address it has.</p>\n</li>\n<li>\n<p>When an actor receives a message it may take actions like:</p>\n<ul>\n<li>\n<p>altering its own state, e.g. so that it can react differently to a future message</p>\n</li>\n<li>\n<p>sending messages to other actors</p>\n</li>\n<li>\n<p>starting new actors</p>\n<p>None of the actions are required, and they may be applied in any order.</p>\n</li>\n</ul>\n</li>\n<li>\n<p>An actor only processes one message at a time. In other words, a single actor does not give you any concurrency, and it does not need to use locks internally to protect its own state.</p>\n</li>\n</ul>\n<h3>Hello World</h3>\n<p>A Hello world example:</p>\n<p>Let's start with the typical example of Hello World. In this case, we'll create an Actor, send it a message, wait for a response message, and print that response:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">actorio</span> <span class=\"kn\">import</span> <span class=\"n\">Actor</span><span class=\"p\">,</span> <span class=\"n\">Message</span><span class=\"p\">,</span> <span class=\"n\">DataMessage</span><span class=\"p\">,</span> <span class=\"n\">ask</span>\n<span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"k\">class</span> <span class=\"nc\">Greeter</span><span class=\"p\">(</span><span class=\"n\">Actor</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Here we override the handle_message method to send a `DataMessage` with the data \"Hello World!\".</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handle_message</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"n\">Message</span><span class=\"p\">):</span>\n        <span class=\"k\">await</span> <span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">tell</span><span class=\"p\">(</span><span class=\"n\">DataMessage</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"s2\">\"Hello World!\"</span><span class=\"p\">,</span> <span class=\"n\">sender</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"p\">))</span>\n\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"c1\"># Let's create an instance of a Greeter actor and start it. </span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">Greeter</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">greeter</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Then we'll just send it an empty message and wait for a response</span>\n        <span class=\"n\">reply</span> <span class=\"p\">:</span> <span class=\"n\">DataMessage</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">ask</span><span class=\"p\">(</span><span class=\"n\">greeter</span><span class=\"p\">,</span> <span class=\"n\">Message</span><span class=\"p\">())</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">reply</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">)</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">get_event_loop</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">run_until_complete</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n<h3>Actor spawning actors</h3>\n<p>Actor instances can spawn other actors during their execution. be it at startup, in the <code>mainloop_setup</code> async method or as a reaction to an event in any handler.</p>\n<p>The actor should first be instanciated (with an <code>__init__</code> call) then be registered on its parent with a <code>register_child</code> async call.</p>\n<p>Whenever a child dies, the parent <code>handle_child_stopped</code> async method is called with the child actor object and the <code>asyncio.task</code> object for its execution loop. This way, the parent can take any action required.</p>\n<p>For example, if we had to handle blocking operations. we could do something like:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">random</span>\n<span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n<span class=\"kn\">from</span> <span class=\"nn\">actorio</span> <span class=\"kn\">import</span> <span class=\"n\">Actor</span><span class=\"p\">,</span> <span class=\"n\">Message</span><span class=\"p\">,</span> <span class=\"n\">DataMessage</span><span class=\"p\">,</span> <span class=\"n\">EndMainLoop</span><span class=\"p\">,</span> <span class=\"n\">Reference</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">blocking_operation</span><span class=\"p\">():</span>\n    <span class=\"c1\">#for the sake of this example, the blocking operation is a sleep</span>\n    <span class=\"n\">sleep_time</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"n\">sleep_time</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">sleep_time</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">RequestMessage</span><span class=\"p\">(</span><span class=\"n\">Message</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">    A request to do some computation or blocking call</span>\n<span class=\"sd\">    \"\"\"</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">ResponseMessage</span><span class=\"p\">(</span><span class=\"n\">DataMessage</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"</span>\n<span class=\"sd\">    The result of a computation</span>\n<span class=\"sd\">    \"\"\"</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Worker</span><span class=\"p\">(</span><span class=\"n\">Actor</span><span class=\"p\">):</span>\n    <span class=\"c1\"># Here we override the handle_message method to send a `ResponseMessage`</span>\n    <span class=\"c1\"># with the result of the blocking operation as its data.</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handle_message</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"n\">Message</span><span class=\"p\">):</span>\n        <span class=\"n\">sleep_time</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">blocking_operation</span><span class=\"p\">()</span>\n        <span class=\"k\">await</span> <span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">sender</span><span class=\"o\">.</span><span class=\"n\">tell</span><span class=\"p\">(</span><span class=\"n\">ResponseMessage</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">sleep_time</span><span class=\"p\">,</span> <span class=\"n\">sender</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"p\">))</span>\n        <span class=\"c1\"># This actor only deals with one message then stops,</span>\n        <span class=\"c1\"># raising an EndMainLoop exeception here will properly stop the actor</span>\n        <span class=\"k\">raise</span> <span class=\"n\">EndMainLoop</span><span class=\"p\">()</span> \n\n<span class=\"k\">class</span> <span class=\"nc\">Manager</span><span class=\"p\">(</span><span class=\"n\">Actor</span><span class=\"p\">):</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handle_message</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"n\">Message</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">,</span> <span class=\"n\">RequestMessage</span><span class=\"p\">):</span>\n            <span class=\"c1\"># We spawn and register the new child, we get its reference back</span>\n            <span class=\"n\">child</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">register_child</span><span class=\"p\">(</span><span class=\"n\">Worker</span><span class=\"p\">())</span>\n            <span class=\"c1\"># We just transfer the message to the child, that way,</span>\n            <span class=\"c1\"># we won't have to process its response</span>\n            <span class=\"k\">await</span> <span class=\"n\">child</span><span class=\"o\">.</span><span class=\"n\">tell</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">)</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"c1\"># We create an inbox for us, this is not an actor,</span>\n    <span class=\"c1\"># just somewhere actors can send messages</span>\n    <span class=\"n\">me</span> <span class=\"o\">=</span> <span class=\"n\">Reference</span><span class=\"p\">()</span>\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">Manager</span><span class=\"p\">()</span> <span class=\"k\">as</span> <span class=\"n\">manager</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Then we start 10 long computations</span>\n        <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">):</span> <span class=\"k\">await</span> <span class=\"n\">manager</span><span class=\"o\">.</span><span class=\"n\">tell</span><span class=\"p\">(</span><span class=\"n\">RequestMessage</span><span class=\"p\">(</span><span class=\"n\">sender</span><span class=\"o\">=</span><span class=\"n\">me</span><span class=\"p\">))</span>\n        <span class=\"c1\"># Then we'll listen to our inbox</span>\n        <span class=\"c1\"># to get the responses as they come by</span>\n        <span class=\"k\">for</span> <span class=\"n\">_</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">):</span>\n            <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"k\">await</span> <span class=\"n\">me</span><span class=\"o\">.</span><span class=\"n\">inbox</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">()</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Got a response with result </span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">))</span>\n\n<span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">get_event_loop</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">run_until_complete</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">())</span>\n</pre>\n<h3>Handling external blocking events</h3>\n<p>Using message is great, but, most of the time, we also need to use other APIs that don't provide a message-based interface.</p>\n<p>It's possible to register external blocking event and handler for those with the <code>register_input_task</code> method.\nThis methods takes a factory function for a coroutine and an async function to handle the task result.</p>\n<p><strong>The handler will not be called if the Actor is currently busy processing anything else\n(like a message or any other task), this way, there is no concurrency issue\nand each handler is called with a clean actor state</strong></p>\n<p><em>For now, the order in which those events will be handled is not necessarily the order in which they happened</em></p>\n<p>For example, to use an <code>aiohttp</code> websocket :</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">aiohttp</span>\n<span class=\"kn\">from</span> <span class=\"nn\">aiohttp</span> <span class=\"kn\">import</span> <span class=\"n\">web</span>\n<span class=\"kn\">from</span> <span class=\"nn\">actorio</span> <span class=\"kn\">import</span> <span class=\"n\">Actor</span><span class=\"p\">,</span> <span class=\"n\">EndMainLoop</span>\n<span class=\"kn\">import</span> <span class=\"nn\">asyncio</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Client</span><span class=\"p\">(</span><span class=\"n\">Actor</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">websocket</span><span class=\"p\">:</span> <span class=\"n\">web</span><span class=\"o\">.</span><span class=\"n\">WebSocketResponse</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">websocket</span> <span class=\"o\">=</span> <span class=\"n\">websocket</span>\n        <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">()</span>\n\n    <span class=\"c1\"># Here we define an input task handler,</span>\n    <span class=\"c1\"># It will be called each time its registered event happens.</span>\n    <span class=\"c1\"># The resulting `asyncio.Task` object will be passed as argument,</span>\n    <span class=\"c1\"># this way, the handler can deal with any exception raised during event collection </span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handle_websocket_event</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">task</span><span class=\"p\">:</span> <span class=\"n\">asyncio</span><span class=\"o\">.</span><span class=\"n\">Task</span><span class=\"p\">):</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">msg</span> <span class=\"o\">=</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">()</span>\n        <span class=\"k\">except</span> <span class=\"ne\">Exception</span> <span class=\"k\">as</span> <span class=\"n\">e</span><span class=\"p\">:</span>\n            <span class=\"c1\"># In case of any exception, we just stop the Actor</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">exception</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">)</span>\n            <span class=\"k\">raise</span> <span class=\"n\">EndMainLoop</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"n\">msg</span><span class=\"o\">.</span><span class=\"n\">type</span> <span class=\"o\">==</span> <span class=\"n\">aiohttp</span><span class=\"o\">.</span><span class=\"n\">WSMsgType</span><span class=\"o\">.</span><span class=\"n\">TEXT</span><span class=\"p\">:</span>\n            <span class=\"c1\"># if we receive text, we just send it back</span>\n            <span class=\"c1\"># We could also just send a message to our inbox</span>\n            <span class=\"k\">await</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">websocket</span><span class=\"o\">.</span><span class=\"n\">send_str</span><span class=\"p\">(</span><span class=\"n\">msg</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"c1\"># any other request just stops the Actor</span>\n            <span class=\"k\">raise</span> <span class=\"n\">EndMainLoop</span><span class=\"p\">()</span>\n\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">mainloop_setup</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">register_input_task</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">websocket</span><span class=\"o\">.</span><span class=\"n\">receive</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">handle_websocket_event</span><span class=\"p\">)</span>\n        <span class=\"k\">await</span> <span class=\"nb\">super</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">mainloop_setup</span><span class=\"p\">()</span>\n\n\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">websocket_handler</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"n\">ws</span> <span class=\"o\">=</span> <span class=\"n\">web</span><span class=\"o\">.</span><span class=\"n\">WebSocketResponse</span><span class=\"p\">()</span>\n    <span class=\"k\">await</span> <span class=\"n\">ws</span><span class=\"o\">.</span><span class=\"n\">prepare</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">)</span>\n\n    <span class=\"n\">client_actor</span> <span class=\"o\">=</span> <span class=\"n\">Client</span><span class=\"p\">(</span><span class=\"n\">websocket</span><span class=\"o\">=</span><span class=\"n\">ws</span><span class=\"p\">)</span>\n\n    <span class=\"k\">async</span> <span class=\"k\">with</span> <span class=\"n\">client_actor</span><span class=\"p\">:</span>\n        <span class=\"c1\"># We until the client's mainloop ends</span>\n        <span class=\"k\">await</span> <span class=\"n\">client_actor</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">ws</span>\n\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"n\">web</span><span class=\"o\">.</span><span class=\"n\">Application</span><span class=\"p\">()</span>\n<span class=\"n\">app</span><span class=\"o\">.</span><span class=\"n\">add_routes</span><span class=\"p\">([</span><span class=\"n\">web</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'/'</span><span class=\"p\">,</span> <span class=\"n\">websocket_handler</span><span class=\"p\">)])</span>\n<span class=\"n\">web</span><span class=\"o\">.</span><span class=\"n\">run_app</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"p\">)</span>\n</pre>\n<p>You can then connect to the websocket and send it some messages, it will act as an echo server.</p>\n\n          </div>"}, "last_serial": 4568835, "releases": {"0.0.0.dev0": [{"comment_text": "", "digests": {"md5": "7260838464aab11489765bd6bd548158", "sha256": "1ec9d4a011f5e4250f8fd306eea8089b7a508ebae7c2704a0e7f06df4494e97a"}, "downloads": -1, "filename": "actorio-0.0.0.dev0-py3-none-any.whl", "has_sig": false, "md5_digest": "7260838464aab11489765bd6bd548158", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 5291, "upload_time": "2018-11-27T09:53:47", "upload_time_iso_8601": "2018-11-27T09:53:47.125263Z", "url": "https://files.pythonhosted.org/packages/ec/10/97ec89c3a4ee8dc217d3d1650cc5855fa7b8f5462896032647379b46dd64/actorio-0.0.0.dev0-py3-none-any.whl", "yanked": false}], "0.0.0.dev1": [{"comment_text": "", "digests": {"md5": "228ce4f26d9f5d0ae5f81f87d95bf2f4", "sha256": "f9ef0150c6b25dabd8d5495569a4b6c90a3820588a0294c1fb4a344a7875b194"}, "downloads": -1, "filename": "actorio-0.0.0.dev1-py3-none-any.whl", "has_sig": false, "md5_digest": "228ce4f26d9f5d0ae5f81f87d95bf2f4", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.5", "size": 5317, "upload_time": "2018-11-27T10:46:40", "upload_time_iso_8601": "2018-11-27T10:46:40.565371Z", "url": "https://files.pythonhosted.org/packages/60/49/a2c387cf42c913a9ceb092ea093649a12c2b09fc0efa7cd6bedbbf6010b3/actorio-0.0.0.dev1-py3-none-any.whl", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "f0f053fd2191456a07f88a6d0967391f", "sha256": "d8604ac313625a93585bb2d0b54598b2c529cbac695be412c5eec35b6a344d9c"}, "downloads": -1, "filename": "actorio-0.1.2-py3-none-any.whl", "has_sig": false, "md5_digest": "f0f053fd2191456a07f88a6d0967391f", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12311, "upload_time": "2018-12-04T13:51:15", "upload_time_iso_8601": "2018-12-04T13:51:15.272235Z", "url": "https://files.pythonhosted.org/packages/46/c5/452cdbd860e84a0984eb3a70e6916444da9b27eea9e518b12d41181f5de5/actorio-0.1.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ae812077f42c5b5c6752aee966050a43", "sha256": "725af2c27153214573d8041129be1a8e3502a929bba458b1bc9b465ae90f3b65"}, "downloads": -1, "filename": "actorio-0.1.2.tar.gz", "has_sig": false, "md5_digest": "ae812077f42c5b5c6752aee966050a43", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 16704, "upload_time": "2018-12-04T13:51:18", "upload_time_iso_8601": "2018-12-04T13:51:18.666426Z", "url": "https://files.pythonhosted.org/packages/87/32/adc241c705db1717ff53a89c7ec05f8cfe83deaeb83632b6b626999cd9cd/actorio-0.1.2.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "e3b44f12b13b3ccd0acb6b9d6af92144", "sha256": "23775b51600d1754088038fe5dc75ec1509d3f1513c09e0bc0a6b22fe788aa8a"}, "downloads": -1, "filename": "actorio-0.1.4-py3-none-any.whl", "has_sig": false, "md5_digest": "e3b44f12b13b3ccd0acb6b9d6af92144", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12845, "upload_time": "2018-12-06T17:40:54", "upload_time_iso_8601": "2018-12-06T17:40:54.020893Z", "url": "https://files.pythonhosted.org/packages/89/7d/64b3d71380994bde43551f3ea2b65154e46587f2f61181faf6be30eab7a5/actorio-0.1.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3370eb4cf52ae2199e4c9cf333cf4246", "sha256": "64ba524cde541039c0bc0a1b472ecb0f4ba98393e8793e44d1548b37576b5807"}, "downloads": -1, "filename": "actorio-0.1.4.tar.gz", "has_sig": false, "md5_digest": "3370eb4cf52ae2199e4c9cf333cf4246", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 17530, "upload_time": "2018-12-06T17:40:55", "upload_time_iso_8601": "2018-12-06T17:40:55.936958Z", "url": "https://files.pythonhosted.org/packages/c1/ab/58954a26014d6837e60b690b53a1c2007e80acf6fca854359b02edfe172f/actorio-0.1.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e3b44f12b13b3ccd0acb6b9d6af92144", "sha256": "23775b51600d1754088038fe5dc75ec1509d3f1513c09e0bc0a6b22fe788aa8a"}, "downloads": -1, "filename": "actorio-0.1.4-py3-none-any.whl", "has_sig": false, "md5_digest": "e3b44f12b13b3ccd0acb6b9d6af92144", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6", "size": 12845, "upload_time": "2018-12-06T17:40:54", "upload_time_iso_8601": "2018-12-06T17:40:54.020893Z", "url": "https://files.pythonhosted.org/packages/89/7d/64b3d71380994bde43551f3ea2b65154e46587f2f61181faf6be30eab7a5/actorio-0.1.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3370eb4cf52ae2199e4c9cf333cf4246", "sha256": "64ba524cde541039c0bc0a1b472ecb0f4ba98393e8793e44d1548b37576b5807"}, "downloads": -1, "filename": "actorio-0.1.4.tar.gz", "has_sig": false, "md5_digest": "3370eb4cf52ae2199e4c9cf333cf4246", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6", "size": 17530, "upload_time": "2018-12-06T17:40:55", "upload_time_iso_8601": "2018-12-06T17:40:55.936958Z", "url": "https://files.pythonhosted.org/packages/c1/ab/58954a26014d6837e60b690b53a1c2007e80acf6fca854359b02edfe172f/actorio-0.1.4.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:24:15 2020"}