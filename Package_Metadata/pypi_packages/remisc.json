{"info": {"author": "Brian Kirkpatrick", "author_email": "code@tythos.net", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Intended Audience :: Developers", "Intended Audience :: Information Technology", "Intended Audience :: Science/Research", "Intended Audience :: System Administrators", "License :: OSI Approved :: MIT License", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Topic :: Internet :: WWW/HTTP", "Topic :: Scientific/Engineering :: Information Analysis"], "description": "remisc\n======\n\nAnother framework!? What's the point? Aren't there a thousand-and-one web\nframeworks out there already? Don't *some* of them already support REST-oriented\noperations? (Spoiler: Sort of...) Who cares about scientific computing anyways?\n\nHere's the problem... Who needs a full-up MVC framework if all you're doing is\npassing system model data back and forth, or hosting a simulation service in a\ncloud environment? You don't. You need something model-centric, which doesn't\nassume clients are using a web browser. You need something that's going to\nprovide the supporting infrastructure, like WSGI mapping and automated operation\n& model documentation, with the least possible overhead of work and processing\npower. Focus on the unique part of your work--defining operations and the models\nthey use--and let *remisc* take care of everything else.\n\nServices\n--------\n\nA new microservice is defined by subclassing *remisc.service.Service*. Methods\nof this class can be decorated by *@remisc.service.isop*. These operations take\ntwo inputs, the urlparse object of the request and a dictionary of any arguments\nparsed from the URL's query string segment. They should return a textual\nresponse. A request will be mapped to an operation method by matching the method\nname to the top-level directory in the request URL (i.e., if a service is hosted\non http://mysvcs.com/, the request to http://mysvcs.com/test will look for the\nmethod *test* of the host Service-derived class.\n\nThe base Service class includes an *app()* method that defines a WSGI-compliant\napplication interface used to parse request arguments, map them to the\nappropriate method, and wrap the response generation process to return content.\n\nModels\n------\n\nFrequently, users must provide--or expect to receive--data formatted in\naccordance with specific models. Such data exchange formats can be defined by\nany class co-located with a Service-derived class, so long as they are\ndecorated by *@remisc.dxm.isdxm*.\n\nOperations\n----------\n\nSeveral default operations are built into the base Service class:\n\n_root\n~~~~~\n\nAny request without a top-level directory name will be routed to the *_root*\nmethod. As with any other method, this operation can be overridden by the user.\n\n_null\n~~~~~\n\nThis built-in operation returns an empty response. This is one way to hide error\nhandling--if you're really into that sort of thing.\n\n_help\n~~~~~\n\nThis is one of the most powerful behaviors of the *remisc* framework. The *_help*\noperation returns documentation of all operations and data exchange models for\nthe current Service-derived object. Operations are determined by evaluating all\ninstance methods for the @isdxm decorator. Data exchange models are determined\nby evaluating all classes co-located in the same module as the Service-derived\nclass for the @isdxm decorator. The response maps a JSON object to the\ndocstrings for each operation and data exchange model, so users can determine\nwhat operations the service provides and how it may utilize them.\n\nServing\n-------\n\nBy default, the *remisc* package includs a *server* module that utilizes the\ncore module *wsgiref*'s *simple_server* model to host a Service. All\nService-derived classes include a WSGI-compliant *app()* method invoked by the\nserver host process. For production runs, it is strongly advised to invoke that\nmethods from a production-level WSGI server instead.\n\nGetting Started\n---------------\n\nIn Action\n~~~~~~~~~\n\nWhen the *remisc.server.main* method is invoked directly, the reference WSGI\nserver in Python's core module *wsgiref* is used to host an instance of a given\n*remisc.service.Service* class. (If no class is provided, the base class is used\ninstead.) This can be done procedurally::\n\n >>> from remisc import server\n >>> server.main()\n Serving \"remisc.service.Service\" with wsgiref.simple_server @ 127.0.0.1:8000\n\nIf you use your web browser to load *http://127.0.0.1:8000*, you will see the\ndefault operation implemented by the *remisc.service.Service._root()* method\n(\"Here is the base.\"). You will also see, in the Python environment where you\nlaunched the server, how that request was mapped to an operation by the WSGI\napplication interface implemented by *remisc.service.Service.app()*::\n\n \"http://127.0.0.1:8000/\" => \"_root\"\n 127.0.0.1 - - [{date} {time}] \"GET / HTTP/1.1\" 200 {response time}\n \"http://127.0.0.1:8000/favicon.ico\" => \"_null\"\n 127.0.0.1 - - [{date} {time}] \"GET /favicon.ico HTTP/1.1\" 200 {response time}\n\nNote that most browsers implicitly request *favicon.ico* with each page request;\nthis is one useful application of the *_null* method, which is hard-coded to\nreply to such requests with an empty response.\n\nYou can view the base responses directly by browsing to the following URLs while\nyour test server is still running. Once you have seen the responses, press\nCTRL-C in the Python environment to stop the server.\n\n - http://127.0.0.1:8000/_root\n - http://127.0.0.1:8000/_null\n - http://127.0.0.1:8000/_help\n\nYour Own Service\n~~~~~~~~~~~~~~~~\n\nSubclassing *remisc.service.Service* will let you define your own operations and\noverride those already implemented. Make sure you decorate each method that\nimplements an operation with *@remisc.service.isop*. Such methods should take\ntwo arguments: a *urlparse* object capturing the original request, and an args\ndictionary constructed from the URL query string. The operation should return\nthe textual content of the response.\n\nFor example, let's implement a simple service *Joker* that implements a *joke*\noperation::\n\n >>> from remisc import service\n >>> class Joker(service.Service):\n >>>     @service.isop\n >>>     def joke(self, urlobj, args):\n >>>         return 'Why did the spam cross the road?\\n\\nTo evade the dead parrot!'\n\nWe can host this service by passing the class to the *remisc.server.main*\nfunction as the *Svc* parameter::\n\n >>> server.main(Svc=Joker)\n\nNow, try browsing to http://127.0.0.1:8000/joke. For a bonus, note that your new\noperation has automatically been added to the response at\nhttp://127.0.0.1:8000/_help!", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Tythos/remisc", "keywords": "rest server scientific computing microservice", "license": "MIT", "maintainer": null, "maintainer_email": null, "name": "remisc", "package_url": "https://pypi.org/project/remisc/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/remisc/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/Tythos/remisc"}, "release_url": "https://pypi.org/project/remisc/0.0.3/", "requires_dist": null, "requires_python": null, "summary": "REST-ful microservice framework for scientific computing", "version": "0.0.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Another framework!? What\u2019s the point? Aren\u2019t there a thousand-and-one web\nframeworks out there already? Don\u2019t <em>some</em> of them already support REST-oriented\noperations? (Spoiler: Sort of\u2026) Who cares about scientific computing anyways?</p>\n<p>Here\u2019s the problem\u2026 Who needs a full-up MVC framework if all you\u2019re doing is\npassing system model data back and forth, or hosting a simulation service in a\ncloud environment? You don\u2019t. You need something model-centric, which doesn\u2019t\nassume clients are using a web browser. You need something that\u2019s going to\nprovide the supporting infrastructure, like WSGI mapping and automated operation\n&amp; model documentation, with the least possible overhead of work and processing\npower. Focus on the unique part of your work\u2013defining operations and the models\nthey use\u2013and let <em>remisc</em> take care of everything else.</p>\n<div id=\"services\">\n<h2>Services</h2>\n<p>A new microservice is defined by subclassing <em>remisc.service.Service</em>. Methods\nof this class can be decorated by <em>@remisc.service.isop</em>. These operations take\ntwo inputs, the urlparse object of the request and a dictionary of any arguments\nparsed from the URL\u2019s query string segment. They should return a textual\nresponse. A request will be mapped to an operation method by matching the method\nname to the top-level directory in the request URL (i.e., if a service is hosted\non <a href=\"http://mysvcs.com/\" rel=\"nofollow\">http://mysvcs.com/</a>, the request to <a href=\"http://mysvcs.com/test\" rel=\"nofollow\">http://mysvcs.com/test</a> will look for the\nmethod <em>test</em> of the host Service-derived class.</p>\n<p>The base Service class includes an <em>app()</em> method that defines a WSGI-compliant\napplication interface used to parse request arguments, map them to the\nappropriate method, and wrap the response generation process to return content.</p>\n</div>\n<div id=\"models\">\n<h2>Models</h2>\n<p>Frequently, users must provide\u2013or expect to receive\u2013data formatted in\naccordance with specific models. Such data exchange formats can be defined by\nany class co-located with a Service-derived class, so long as they are\ndecorated by <em>@remisc.dxm.isdxm</em>.</p>\n</div>\n<div id=\"operations\">\n<h2>Operations</h2>\n<p>Several default operations are built into the base Service class:</p>\n<div id=\"root\">\n<h3>_root</h3>\n<p>Any request without a top-level directory name will be routed to the <em>_root</em>\nmethod. As with any other method, this operation can be overridden by the user.</p>\n</div>\n<div id=\"null\">\n<h3>_null</h3>\n<p>This built-in operation returns an empty response. This is one way to hide error\nhandling\u2013if you\u2019re really into that sort of thing.</p>\n</div>\n<div id=\"help\">\n<h3>_help</h3>\n<p>This is one of the most powerful behaviors of the <em>remisc</em> framework. The <em>_help</em>\noperation returns documentation of all operations and data exchange models for\nthe current Service-derived object. Operations are determined by evaluating all\ninstance methods for the @isdxm decorator. Data exchange models are determined\nby evaluating all classes co-located in the same module as the Service-derived\nclass for the @isdxm decorator. The response maps a JSON object to the\ndocstrings for each operation and data exchange model, so users can determine\nwhat operations the service provides and how it may utilize them.</p>\n</div>\n</div>\n<div id=\"serving\">\n<h2>Serving</h2>\n<p>By default, the <em>remisc</em> package includs a <em>server</em> module that utilizes the\ncore module <em>wsgiref</em>\u2019s <em>simple_server</em> model to host a Service. All\nService-derived classes include a WSGI-compliant <em>app()</em> method invoked by the\nserver host process. For production runs, it is strongly advised to invoke that\nmethods from a production-level WSGI server instead.</p>\n</div>\n<div id=\"getting-started\">\n<h2>Getting Started</h2>\n<div id=\"in-action\">\n<h3>In Action</h3>\n<p>When the <em>remisc.server.main</em> method is invoked directly, the reference WSGI\nserver in Python\u2019s core module <em>wsgiref</em> is used to host an instance of a given\n<em>remisc.service.Service</em> class. (If no class is provided, the base class is used\ninstead.) This can be done procedurally:</p>\n<pre>&gt;&gt;&gt; from remisc import server\n&gt;&gt;&gt; server.main()\nServing \"remisc.service.Service\" with wsgiref.simple_server @ 127.0.0.1:8000\n</pre>\n<p>If you use your web browser to load <em>http://127.0.0.1:8000</em>, you will see the\ndefault operation implemented by the <em>remisc.service.Service._root()</em> method\n(\u201cHere is the base.\u201d). You will also see, in the Python environment where you\nlaunched the server, how that request was mapped to an operation by the WSGI\napplication interface implemented by <em>remisc.service.Service.app()</em>:</p>\n<pre>\"http://127.0.0.1:8000/\" =&gt; \"_root\"\n127.0.0.1 - - [{date} {time}] \"GET / HTTP/1.1\" 200 {response time}\n\"http://127.0.0.1:8000/favicon.ico\" =&gt; \"_null\"\n127.0.0.1 - - [{date} {time}] \"GET /favicon.ico HTTP/1.1\" 200 {response time}\n</pre>\n<p>Note that most browsers implicitly request <em>favicon.ico</em> with each page request;\nthis is one useful application of the <em>_null</em> method, which is hard-coded to\nreply to such requests with an empty response.</p>\n<p>You can view the base responses directly by browsing to the following URLs while\nyour test server is still running. Once you have seen the responses, press\nCTRL-C in the Python environment to stop the server.</p>\n<blockquote>\n<ul>\n<li><a href=\"http://127.0.0.1:8000/_root\" rel=\"nofollow\">http://127.0.0.1:8000/_root</a></li>\n<li><a href=\"http://127.0.0.1:8000/_null\" rel=\"nofollow\">http://127.0.0.1:8000/_null</a></li>\n<li><a href=\"http://127.0.0.1:8000/_help\" rel=\"nofollow\">http://127.0.0.1:8000/_help</a></li>\n</ul>\n</blockquote>\n</div>\n<div id=\"your-own-service\">\n<h3>Your Own Service</h3>\n<p>Subclassing <em>remisc.service.Service</em> will let you define your own operations and\noverride those already implemented. Make sure you decorate each method that\nimplements an operation with <em>@remisc.service.isop</em>. Such methods should take\ntwo arguments: a <em>urlparse</em> object capturing the original request, and an args\ndictionary constructed from the URL query string. The operation should return\nthe textual content of the response.</p>\n<p>For example, let\u2019s implement a simple service <em>Joker</em> that implements a <em>joke</em>\noperation:</p>\n<pre>&gt;&gt;&gt; from remisc import service\n&gt;&gt;&gt; class Joker(service.Service):\n&gt;&gt;&gt;     @service.isop\n&gt;&gt;&gt;     def joke(self, urlobj, args):\n&gt;&gt;&gt;         return 'Why did the spam cross the road?\\n\\nTo evade the dead parrot!'\n</pre>\n<p>We can host this service by passing the class to the <em>remisc.server.main</em>\nfunction as the <em>Svc</em> parameter:</p>\n<pre>&gt;&gt;&gt; server.main(Svc=Joker)\n</pre>\n<p>Now, try browsing to <a href=\"http://127.0.0.1:8000/joke\" rel=\"nofollow\">http://127.0.0.1:8000/joke</a>. For a bonus, note that your new\noperation has automatically been added to the response at\n<a href=\"http://127.0.0.1:8000/_help\" rel=\"nofollow\">http://127.0.0.1:8000/_help</a>!</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 2169765, "releases": {"0.0.1": [], "0.0.2": [{"comment_text": "", "digests": {"md5": "28a5c170f762ede634b11a40580a5b51", "sha256": "1da73722dbfd62888368db352c55c1fc1986196e325b01ea6a94275320dff103"}, "downloads": -1, "filename": "remisc-0.0.2.tar.gz", "has_sig": false, "md5_digest": "28a5c170f762ede634b11a40580a5b51", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17381, "upload_time": "2016-06-15T23:45:40", "upload_time_iso_8601": "2016-06-15T23:45:40.199598Z", "url": "https://files.pythonhosted.org/packages/9e/dd/768c6a0d5ddaaaf1312ee16f5e8bcfa78a1c376aa23770b4d5f10cea0b62/remisc-0.0.2.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "b9688a2e92bffedde2b8739ea55fc2f0", "sha256": "cfceb99837dc4296be480d35d4e51630f09411f7d73268cf4f74a4d53a76ecc7"}, "downloads": -1, "filename": "remisc-0.0.3.tar.gz", "has_sig": false, "md5_digest": "b9688a2e92bffedde2b8739ea55fc2f0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20612, "upload_time": "2016-06-16T01:04:23", "upload_time_iso_8601": "2016-06-16T01:04:23.463166Z", "url": "https://files.pythonhosted.org/packages/81/4b/4b9ce4236bc5b555d97b6a43f0241215c2a2d8aa76b11d617fbceae3a64c/remisc-0.0.3.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "b9688a2e92bffedde2b8739ea55fc2f0", "sha256": "cfceb99837dc4296be480d35d4e51630f09411f7d73268cf4f74a4d53a76ecc7"}, "downloads": -1, "filename": "remisc-0.0.3.tar.gz", "has_sig": false, "md5_digest": "b9688a2e92bffedde2b8739ea55fc2f0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20612, "upload_time": "2016-06-16T01:04:23", "upload_time_iso_8601": "2016-06-16T01:04:23.463166Z", "url": "https://files.pythonhosted.org/packages/81/4b/4b9ce4236bc5b555d97b6a43f0241215c2a2d8aa76b11d617fbceae3a64c/remisc-0.0.3.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:04:55 2020"}