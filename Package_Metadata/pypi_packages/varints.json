{"info": {"author": "John Bailey", "author_email": "dev@brightsilence.com", "bugtrack_url": null, "classifiers": [], "description": "Variable Length Integer Encoding\n================================\n\n|Build Status|\n\nThis is a Python module which is intended to assist with variable-length\nencoding integers (and lists of integers) into more compact\nrepresentations which use less memory.\n\nNotes on Memory Usage\n---------------------\n\nGenerally in Python, integers are stored as\n`long <https://docs.python.org/2/library/stdtypes.html#numeric-types-int-float-long-complex>`__\nmeaning that they will use at least 32 bits. When storing many numbers\nwhich do not require 32 bits, this would seem to be significantly\nwasteful; variable length representation should be able to assist in\nsuch cases.\n\nUnfortunately, Python 2 gives us the following\n\n.. code:: python\n\n    >>> import sys\n    >>> i = 1\n    >>> sys.getsizeof(i)\n    12\n    >>> b = bytearray([0] * 4)\n    >>> sys.getsizeof(b)\n    29\n\nand the situation is no better in Python 3\n\n.. code:: python\n\n    >>> import sys\n    >>> i = 1\n    >>> sys.getsizeof(i)\n    14\n    >>> b = bytearray([0] * 4)\n    >>> sys.getsizeof(b)\n    33\n\nWhat we can see however is that the Python overhead for bytearray is\nfixed. Increasing the size of the bytearray only increases the memory\nusage by the amount of bytes we've used:\n\n.. code:: python\n\n    >>> import sys\n    >>> b1 = bytearray([0])\n    >>> sys.getsizeof(b1)\n    30\n    >>> b10 = bytearray([0] * 10)\n    >>> sys.getsizeof(b10)\n    40\n\nSo this means that currently:\n\n-  Memory overhead for bytearray objects is higher in Python 3 than\n   Python 2\n-  Using varint encoding will actually *cost* us memory rather than\n   saving us memory\n\nIf we consider arrays of numbers the situation is somewhat better. If we\ntake the example where we want to store ten zeros. A varint encoding\nshould mean that each zero can be stored in a single byte, meaning that\nwe'd end up with a bytearray with 10 elements. So ...\n\n.. code:: python\n\n    >>> import sys\n    >>> i1 = [0] * 10\n    >>> i1\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    >>> sys.getsizeof(i1)\n    72\n    >>> b1 = bytearray(i1)\n    >>> sys.getsizeof(b1)\n    36\n\nMeaning that:\n\n-  There is potential for saving memory by utilising varint encoding if\n   we are storing arrays of integers\n-  The amount of memory we save will depend on the numbers that are\n   being stored. The larger the varint representation, the smaller the\n   saving, hence the more numbers will need to be stored in order to\n   compensate for the bytearray overhead\n-  We will incur a processing overhead in order to save this memory.\n   e.g.\n-  Random access to varints stored in a bytearray would be O(n) rather\n   than O(1)\n-  We will incur an overhead each time we want to convert to and from\n   varint representation\n\nSo why use varint in Python? In the case that we need a compact method\nto store a list of (frequently small) numbers, and we do not generally\nneed random access to the numbers contained.\n\nOne application is during\n`tree-search <https://en.wikipedia.org/wiki/Search_tree>`__. Typically\nwe will end up with a number of nodes held in memory and not being\naccessed while other nodes in the tree are being processed. If we want\nto store a state associated with each node (e.g. pieces on a chess\nboard), then we can represent these as as list of integers and minimise\nthe memory usage by using varint representations.\n\n.. |Build Status| image:: https://travis-ci.org/bright-tools/varints.svg?branch=master\n   :target: https://travis-ci.org/bright-tools/varints", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/bright-tools/varints", "keywords": "varint,integer,variable,length", "license": "Apache", "maintainer": null, "maintainer_email": null, "name": "varints", "package_url": "https://pypi.org/project/varints/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/varints/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/bright-tools/varints"}, "release_url": "https://pypi.org/project/varints/0.1.3/", "requires_dist": null, "requires_python": null, "summary": "Variable-length encoding of integers", "version": "0.1.3", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://travis-ci.org/bright-tools/varints\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f62edf7194b0bb7e759d2564ef2ad9fde4fde47b/68747470733a2f2f7472617669732d63692e6f72672f6272696768742d746f6f6c732f766172696e74732e7376673f6272616e63683d6d6173746572\"></a></p>\n<p>This is a Python module which is intended to assist with variable-length\nencoding integers (and lists of integers) into more compact\nrepresentations which use less memory.</p>\n<div id=\"notes-on-memory-usage\">\n<h2>Notes on Memory Usage</h2>\n<p>Generally in Python, integers are stored as\n<a href=\"https://docs.python.org/2/library/stdtypes.html#numeric-types-int-float-long-complex\" rel=\"nofollow\">long</a>\nmeaning that they will use at least 32 bits. When storing many numbers\nwhich do not require 32 bits, this would seem to be significantly\nwasteful; variable length representation should be able to assist in\nsuch cases.</p>\n<p>Unfortunately, Python 2 gives us the following</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">getsizeof</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"mi\">12</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"nb\">bytearray</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">getsizeof</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"mi\">29</span>\n</pre>\n<p>and the situation is no better in Python 3</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">getsizeof</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span>\n<span class=\"mi\">14</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"nb\">bytearray</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">getsizeof</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"mi\">33</span>\n</pre>\n<p>What we can see however is that the Python overhead for bytearray is\nfixed. Increasing the size of the bytearray only increases the memory\nusage by the amount of bytes we\u2019ve used:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">b1</span> <span class=\"o\">=</span> <span class=\"nb\">bytearray</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">getsizeof</span><span class=\"p\">(</span><span class=\"n\">b1</span><span class=\"p\">)</span>\n<span class=\"mi\">30</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">b10</span> <span class=\"o\">=</span> <span class=\"nb\">bytearray</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">getsizeof</span><span class=\"p\">(</span><span class=\"n\">b10</span><span class=\"p\">)</span>\n<span class=\"mi\">40</span>\n</pre>\n<p>So this means that currently:</p>\n<ul>\n<li>Memory overhead for bytearray objects is higher in Python 3 than\nPython 2</li>\n<li>Using varint encoding will actually <em>cost</em> us memory rather than\nsaving us memory</li>\n</ul>\n<p>If we consider arrays of numbers the situation is somewhat better. If we\ntake the example where we want to store ten zeros. A varint encoding\nshould mean that each zero can be stored in a single byte, meaning that\nwe\u2019d end up with a bytearray with 10 elements. So \u2026</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">i1</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"mi\">10</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">i1</span>\n<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">getsizeof</span><span class=\"p\">(</span><span class=\"n\">i1</span><span class=\"p\">)</span>\n<span class=\"mi\">72</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">b1</span> <span class=\"o\">=</span> <span class=\"nb\">bytearray</span><span class=\"p\">(</span><span class=\"n\">i1</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">getsizeof</span><span class=\"p\">(</span><span class=\"n\">b1</span><span class=\"p\">)</span>\n<span class=\"mi\">36</span>\n</pre>\n<p>Meaning that:</p>\n<ul>\n<li>There is potential for saving memory by utilising varint encoding if\nwe are storing arrays of integers</li>\n<li>The amount of memory we save will depend on the numbers that are\nbeing stored. The larger the varint representation, the smaller the\nsaving, hence the more numbers will need to be stored in order to\ncompensate for the bytearray overhead</li>\n<li>We will incur a processing overhead in order to save this memory.\ne.g.</li>\n<li>Random access to varints stored in a bytearray would be O(n) rather\nthan O(1)</li>\n<li>We will incur an overhead each time we want to convert to and from\nvarint representation</li>\n</ul>\n<p>So why use varint in Python? In the case that we need a compact method\nto store a list of (frequently small) numbers, and we do not generally\nneed random access to the numbers contained.</p>\n<p>One application is during\n<a href=\"https://en.wikipedia.org/wiki/Search_tree\" rel=\"nofollow\">tree-search</a>. Typically\nwe will end up with a number of nodes held in memory and not being\naccessed while other nodes in the tree are being processed. If we want\nto store a state associated with each node (e.g. pieces on a chess\nboard), then we can represent these as as list of integers and minimise\nthe memory usage by using varint representations.</p>\n</div>\n\n          </div>"}, "last_serial": 2636693, "releases": {"0.1.3": []}, "urls": [], "timestamp": "Fri May  8 03:37:47 2020"}