{"info": {"author": "Jeremy Castagno", "author_email": "jdcasta@umich.edu", "bugtrack_url": null, "classifiers": [], "description": "<h1 align=\"center\">\n  Polylidar\n  <br>\n</h1>\n\n<h4 align=\"center\">Polygon Extraction from 2D and 3D Point Clouds</h4>\n\n<p align=\"center\">\n  <a href=\"#key-features\">Key Features</a> \u2022\n  <a href=\"#install\">Install</a> \u2022\n  <a href=\"#how-to-use\">How To Use</a> \u2022\n  <a href=\"#polylidar-use-cases\">Use Cases</a> \u2022\n  <a href=\"#credits\">Credits</a> \u2022\n  <a href=\"#related-methods\">Related</a> \u2022\n  <a href=\"#license\">License</a>\n</p>\n\n<p align=\"middle\">\n  <img src=\"https://raw.githubusercontent.com/JeremyBYU/polylidarv2/master/assets/2D_polygon_text.png\" height=\"100%\" />\n  <img src=\"https://raw.githubusercontent.com/JeremyBYU/polylidarv2/master/assets/combined.png\" height=\"100%\" /> \n</p>\n\n## Key Features\n\n* Fast (Multi)Polygon Extraction from 2D and 3D point clouds\n  * Written in C++ for portability\n  * Extremely fast. 100,000 3D point cloud takes ~130ms to process on laptop\n  * Polygons with holes may be returned\n* Python3 bindings using PyBind11\n  * Low overhead for calling python/cpp interface (no copying of point cloud data)\n* Python and C++ Examples\n* Cross platform\n  * Windows and Linux ready.\n\nPolylidar allows one to extract planar meshes from a point cloud **and** their polygon representations. The point cloud can be in 2, 3, or 4 dimensions (XY, XYZ, XYZC=Class). This module is written in C++ and can be used as a python module or standalone with a C++ project. Note the **lidar** in Poly**lidar** is a misnomer; it works with any point cloud, not just from LiDAR sensors. Click here for a basic demo in the browser: [![Binder](https://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/jeremybyu/polylidar/master?filepath=examples%2Fpython%2FBasicDemo.ipynb)\n\n## Install\n\n### Python Projects\n\n#### Pip install\n\n1. Install [conda](https://conda.io/projects/conda/en/latest/) or create a python virtual envrionment ([Why?](https://medium.freecodecamp.org/why-you-need-python-environments-and-how-to-manage-them-with-conda-85f155f4353c)). I recommend conda for Windows users.\n2. `conda install shapely` - Only for Windows users because conda handles windows binary dependency correctly.\n3. `pip install polylidar`\n\nBinary wheels are provided only for Windows x64 for Python 3.6-3.7. This means everyone else (Linux, MacOS) will need to have a C++ compiler (GCC or Clang) to compile the source during pip installation.\n\n#### Manual build from git clone\n\n1. Install [conda](https://conda.io/projects/conda/en/latest/) or create a python virtual envrionment ([Why?](https://medium.freecodecamp.org/why-you-need-python-environments-and-how-to-manage-them-with-conda-85f155f4353c)). I recommend conda for Windows users.\n2. `conda install shapely` - Only for Windows users because conda handles windows binary dependency correctly.\n3. `pip install -e \".[dev]\"`\n4. `pytest` - OPTIONAL, this will run a series of tests and benchmarks.\n\n### C++ Projects\n\n#### Simple Makefile\n\nSee `examples/cpp` for how to build.\n\n#### CMake\n\nYou can build Polylidar and an example project with CMake.\n\n1. `mkdir build && cd build`\n2. `cmake .. && make -j && cd ..`\n3. `./build/polylidar-simple` - Simple test program.\n\nTo integrate with a *different* CMake Project do the following:\n\n1. Add as a submodule into your repo: `git submodule add https://github.com/JeremyBYU/polylidar thirdparty/polylidar`\n2. Add the following to your CMakeLists.txt file:\n\n```CMakeList.txt\nadd_subdirectory(\"thirdparty/polylidar\")\n....\ntarget_link_libraries(MY_BINARY polylidar)\n\n```\n\n### Robust Geometric Predicates\n\nDelaunator (the 2D triangulation library used) does not use [robust geometric predicates](https://github.com/mikolalysenko/robust-arithmetic-notes) for its orientation and incircle tests; [reference](https://github.com/mapbox/delaunator/issues/43).  This means that the triangulation can be incorrect when points are nearly colinear or cocircular. A library developed by Jonathan Richard Shewchuk provides very fast adaptive precision floating point arithmetic for [geometric predicates](https://www.cs.cmu.edu/~quake/robust.html).  This library is released in the public domain and an updated version of it is maintained at this [repository](https://github.com/danshapero/predicates). I have included this source code in the folder `polylidar/predicates`.  \n\nIf you desire to have robust geometric predicates built into Polylidar you must set an environment variable, \"PL_USE_ROBUST_PREDICATES=1\" (-DPL_USE_ROBUST_PREDICATES for C++). The python file `setup.py` will read this environment variable and then include the robust geometric predicates into the build process. Without setting this variable none of the `predicates` source code is included in the python plugin.\n\n## How To Use\n\nYou can see a demo in action py running `python examples/python/basic2d.py`. More Python and C++ examples can be found in the `examples` folder.\n\nFunction exposed:\n\n```python\nfrom polylidar import extractPlanesAndPolygons, extractPolygons, Delaunator\n\nkwargs = dict(alpha=0.0, lmax=1.0)\n\n# You want everything!\ndelaunay, planes, polygons = extractPlanesAndPolygons(point_cloud, **kwargs)\n\n# Show me JUST the polygons!\npolygons = extractPolygons(point_cloud, **kwargs)\n\n# Also if you just want fast 2D delaunay triangulation, no polylidar\ndelaunay = Delaunator(point_cloud)\n```\n\n### API (WIP to improve documentation)\n\nWhat are the inputs to the code?  The input arguments are a **contiguous** numpy array with length N and 2,3,or 4 columns depending on your data.  There are also configuration options as well that you can pass as keyword arguments.\n\nWhat are the inputs?\n\n* points - Numpy array\n* Required - 2D Triangle Filtering\n  * alpha (double, default=1.0) - The maximum circumradius of a triangle.\n  * lmax (double,default=0.0 [inactive]) - Maximum edge length of any edge in a triangle. i.e. maximum point distance for spatial connectivity.\n* Optional - 3D Triangle Filtering (normal filtering aka planarity constraints)\n  * normalVector ([double, double, double]) - NOT IMPLEMENTED. Currently fixed to [0,0,1]. The normal vector of the planar mesh(s) you desire to extract.\n  * normThresh (double, default=0.9) - Any triangle whose `abs(normalVector * triangleNormal) < normThresh` is filtered\n  * zThresh (double,default=0.2) - Normal filtering is ignored (bypassed) if the the \"height\" (dz) of a triangle is less than zThresh. This is used to attenuate false-positive filtering in noisy pointclouds. \n  * normThreshMin (double, default=0.1) - Any triangle whose `abs(normalVector * triangleNormal) < normThreshMin` is filtered. This take priority over anything else, even zThresh bypass. Think of this as the bare minimum of flatness a triangle must have to remain in the mesh.\n* Optional - 3D Plane Filtering\n  * minTriangles (int) - Any planar mesh who has less than this quantity of triangles will not be returned\n* Optional - Triangle Filtering by Class (4th Dimension)\n  * allowedClass (double) - Will filter out triangles whose vertices are not classified the same as allowedClass\n\nWhat are the outputs?\n\n* Delaunay - This is a C++ class data structure that has information about your triangles, half edges, and point indices. Read more [here](https://mapbox.github.io/delaunator/).\n* planes - This is a *list* of C++ *vectors* holding `ints`. Each vector is an extracted plane.  The `ints` correspond to triangle indices.\n* polygons - This is a *list* of C++ `polygon` data structure.\n* polygon - This is a struct that has two fields: shell and holes. Shell is a *vector* of `ints`, where each int represents a *point* index. Holes is a list of a *vector* of `ints`. Each vector represents a hole in the polygon.\n\n\n## Polylidar Use Cases\n\n* [Polylidar-RealSense](https://github.com/JeremyBYU/polylidar-realsense) - Live ground floor detection with Intel RealSense camera using Polylidar\n* [PolylidarWeb](https://github.com/JeremyBYU/polylidarweb). A Typescript (javascript) version with live demos.\n* [Concave-Evaluation](https://github.com/JeremyBYU/concavehull-evaluation) - Evaluates and benchmarks several competing concavehull algorithms.\n\n\n## Credits\n\nThis software uses the following open source packages:\n\n* [Delaunator](https://github.com/mapbox/delaunator) - Original triangulation library\n* [DelaunatorCPP](https://github.com/delfrrr/delaunator-cpp) - Delaunator ported to C++ (used)\n* [parallel-hashmap](https://github.com/greg7mdp/parallel-hashmap) - Very fast hashmap library (used)\n* [PyBind11](https://github.com/pybind/pybind11) - Python C++ Binding (used)\n* [Robust Geometric Predicates](https://www.cs.cmu.edu/~quake/robust.html) - Original Robust Geometric predicates\n* [Updated Predicates](https://github.com/danshapero/predicates) -Updated geometric predicate library (used)\n\n## Related Methods\n\n* [CGAL Alpha Shapes](https://doc.cgal.org/latest/Alpha_shapes_2/index.html) - MultiPolygon with holes.\n* [PostGIS ConcaveHull](http://postgis.net/docs/ST_ConcaveHull.html) - Single Polygon with holes.\n* [Spatialite ConcaveHull](https://www.gaia-gis.it/fossil/libspatialite/wiki?name=tesselations-4.0) - MultiPolygon with holes.\n* [Concaveman](https://github.com/mapbox/concaveman) - A 2D concave hull extraction algorithm for 2D point sets.\n\n## Contributing\n\nAny help or suggestions would be appreciated! Some tools you may find useful when you install from `git clone` and build for development\n\n1. `pytest` - Run a series of tests and benchmarks.\n2. `nox` - Build environment for testing and build wheels.\n\n### Packaging\n\n1. `bash ./package.sh`\n\nTODO\n\n## License\n\nMIT\n\n---\n\n> GitHub [@jeremybyu](https://github.com/JeremyBYU)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "polylidar", "package_url": "https://pypi.org/project/polylidar/", "platform": "", "project_url": "https://pypi.org/project/polylidar/", "project_urls": {"Source": "https://github.com/JeremyBYU/polylidar"}, "release_url": "https://pypi.org/project/polylidar/0.0.8/", "requires_dist": ["numpy (>=1.15.0)", "pybind11 (>=2.2.4)", "shapely", "matplotlib", "descartes", "pytest ; extra == 'dev'", "pytest-xdist ; extra == 'dev'", "pytest-benchmark ; extra == 'dev'", "pylint ; extra == 'dev'", "twine ; extra == 'dev'", "autopep8 ; extra == 'dev'", "nox ; extra == 'dev'"], "requires_python": "", "summary": "Polygon extraction from Point Cloud data", "version": "0.0.8", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>\n  Polylidar\n  <br>\n</h1>\n<h4>Polygon Extraction from 2D and 3D Point Clouds</h4>\n<p align=\"center\">\n  <a href=\"#key-features\" rel=\"nofollow\">Key Features</a> \u2022\n  <a href=\"#install\" rel=\"nofollow\">Install</a> \u2022\n  <a href=\"#how-to-use\" rel=\"nofollow\">How To Use</a> \u2022\n  <a href=\"#polylidar-use-cases\" rel=\"nofollow\">Use Cases</a> \u2022\n  <a href=\"#credits\" rel=\"nofollow\">Credits</a> \u2022\n  <a href=\"#related-methods\" rel=\"nofollow\">Related</a> \u2022\n  <a href=\"#license\" rel=\"nofollow\">License</a>\n</p>\n<p align=\"middle\">\n  <img height=\"100%\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/574fc9607792ae2ecbf50e26f33541802ce9dd8c/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f4a6572656d794259552f706f6c796c6964617276322f6d61737465722f6173736574732f32445f706f6c79676f6e5f746578742e706e67\">\n  <img height=\"100%\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8cde4e59d6f34774b4bf4ee71fa4729348a4ae8d/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f4a6572656d794259552f706f6c796c6964617276322f6d61737465722f6173736574732f636f6d62696e65642e706e67\"> \n</p>\n<h2>Key Features</h2>\n<ul>\n<li>Fast (Multi)Polygon Extraction from 2D and 3D point clouds\n<ul>\n<li>Written in C++ for portability</li>\n<li>Extremely fast. 100,000 3D point cloud takes ~130ms to process on laptop</li>\n<li>Polygons with holes may be returned</li>\n</ul>\n</li>\n<li>Python3 bindings using PyBind11\n<ul>\n<li>Low overhead for calling python/cpp interface (no copying of point cloud data)</li>\n</ul>\n</li>\n<li>Python and C++ Examples</li>\n<li>Cross platform\n<ul>\n<li>Windows and Linux ready.</li>\n</ul>\n</li>\n</ul>\n<p>Polylidar allows one to extract planar meshes from a point cloud <strong>and</strong> their polygon representations. The point cloud can be in 2, 3, or 4 dimensions (XY, XYZ, XYZC=Class). This module is written in C++ and can be used as a python module or standalone with a C++ project. Note the <strong>lidar</strong> in Poly<strong>lidar</strong> is a misnomer; it works with any point cloud, not just from LiDAR sensors. Click here for a basic demo in the browser: <a href=\"https://mybinder.org/v2/gh/jeremybyu/polylidar/master?filepath=examples%2Fpython%2FBasicDemo.ipynb\" rel=\"nofollow\"><img alt=\"Binder\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/85e91bbb928104e4ce317951541520c6b9c170e1/68747470733a2f2f6d7962696e6465722e6f72672f62616467655f6c6f676f2e737667\"></a></p>\n<h2>Install</h2>\n<h3>Python Projects</h3>\n<h4>Pip install</h4>\n<ol>\n<li>Install <a href=\"https://conda.io/projects/conda/en/latest/\" rel=\"nofollow\">conda</a> or create a python virtual envrionment (<a href=\"https://medium.freecodecamp.org/why-you-need-python-environments-and-how-to-manage-them-with-conda-85f155f4353c\" rel=\"nofollow\">Why?</a>). I recommend conda for Windows users.</li>\n<li><code>conda install shapely</code> - Only for Windows users because conda handles windows binary dependency correctly.</li>\n<li><code>pip install polylidar</code></li>\n</ol>\n<p>Binary wheels are provided only for Windows x64 for Python 3.6-3.7. This means everyone else (Linux, MacOS) will need to have a C++ compiler (GCC or Clang) to compile the source during pip installation.</p>\n<h4>Manual build from git clone</h4>\n<ol>\n<li>Install <a href=\"https://conda.io/projects/conda/en/latest/\" rel=\"nofollow\">conda</a> or create a python virtual envrionment (<a href=\"https://medium.freecodecamp.org/why-you-need-python-environments-and-how-to-manage-them-with-conda-85f155f4353c\" rel=\"nofollow\">Why?</a>). I recommend conda for Windows users.</li>\n<li><code>conda install shapely</code> - Only for Windows users because conda handles windows binary dependency correctly.</li>\n<li><code>pip install -e \".[dev]\"</code></li>\n<li><code>pytest</code> - OPTIONAL, this will run a series of tests and benchmarks.</li>\n</ol>\n<h3>C++ Projects</h3>\n<h4>Simple Makefile</h4>\n<p>See <code>examples/cpp</code> for how to build.</p>\n<h4>CMake</h4>\n<p>You can build Polylidar and an example project with CMake.</p>\n<ol>\n<li><code>mkdir build &amp;&amp; cd build</code></li>\n<li><code>cmake .. &amp;&amp; make -j &amp;&amp; cd ..</code></li>\n<li><code>./build/polylidar-simple</code> - Simple test program.</li>\n</ol>\n<p>To integrate with a <em>different</em> CMake Project do the following:</p>\n<ol>\n<li>Add as a submodule into your repo: <code>git submodule add https://github.com/JeremyBYU/polylidar thirdparty/polylidar</code></li>\n<li>Add the following to your CMakeLists.txt file:</li>\n</ol>\n<pre>add_subdirectory(\"thirdparty/polylidar\")\n....\ntarget_link_libraries(MY_BINARY polylidar)\n</pre>\n<h3>Robust Geometric Predicates</h3>\n<p>Delaunator (the 2D triangulation library used) does not use <a href=\"https://github.com/mikolalysenko/robust-arithmetic-notes\" rel=\"nofollow\">robust geometric predicates</a> for its orientation and incircle tests; <a href=\"https://github.com/mapbox/delaunator/issues/43\" rel=\"nofollow\">reference</a>.  This means that the triangulation can be incorrect when points are nearly colinear or cocircular. A library developed by Jonathan Richard Shewchuk provides very fast adaptive precision floating point arithmetic for <a href=\"https://www.cs.cmu.edu/%7Equake/robust.html\" rel=\"nofollow\">geometric predicates</a>.  This library is released in the public domain and an updated version of it is maintained at this <a href=\"https://github.com/danshapero/predicates\" rel=\"nofollow\">repository</a>. I have included this source code in the folder <code>polylidar/predicates</code>.</p>\n<p>If you desire to have robust geometric predicates built into Polylidar you must set an environment variable, \"PL_USE_ROBUST_PREDICATES=1\" (-DPL_USE_ROBUST_PREDICATES for C++). The python file <code>setup.py</code> will read this environment variable and then include the robust geometric predicates into the build process. Without setting this variable none of the <code>predicates</code> source code is included in the python plugin.</p>\n<h2>How To Use</h2>\n<p>You can see a demo in action py running <code>python examples/python/basic2d.py</code>. More Python and C++ examples can be found in the <code>examples</code> folder.</p>\n<p>Function exposed:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">polylidar</span> <span class=\"kn\">import</span> <span class=\"n\">extractPlanesAndPolygons</span><span class=\"p\">,</span> <span class=\"n\">extractPolygons</span><span class=\"p\">,</span> <span class=\"n\">Delaunator</span>\n\n<span class=\"n\">kwargs</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"n\">lmax</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># You want everything!</span>\n<span class=\"n\">delaunay</span><span class=\"p\">,</span> <span class=\"n\">planes</span><span class=\"p\">,</span> <span class=\"n\">polygons</span> <span class=\"o\">=</span> <span class=\"n\">extractPlanesAndPolygons</span><span class=\"p\">(</span><span class=\"n\">point_cloud</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Show me JUST the polygons!</span>\n<span class=\"n\">polygons</span> <span class=\"o\">=</span> <span class=\"n\">extractPolygons</span><span class=\"p\">(</span><span class=\"n\">point_cloud</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Also if you just want fast 2D delaunay triangulation, no polylidar</span>\n<span class=\"n\">delaunay</span> <span class=\"o\">=</span> <span class=\"n\">Delaunator</span><span class=\"p\">(</span><span class=\"n\">point_cloud</span><span class=\"p\">)</span>\n</pre>\n<h3>API (WIP to improve documentation)</h3>\n<p>What are the inputs to the code?  The input arguments are a <strong>contiguous</strong> numpy array with length N and 2,3,or 4 columns depending on your data.  There are also configuration options as well that you can pass as keyword arguments.</p>\n<p>What are the inputs?</p>\n<ul>\n<li>points - Numpy array</li>\n<li>Required - 2D Triangle Filtering\n<ul>\n<li>alpha (double, default=1.0) - The maximum circumradius of a triangle.</li>\n<li>lmax (double,default=0.0 [inactive]) - Maximum edge length of any edge in a triangle. i.e. maximum point distance for spatial connectivity.</li>\n</ul>\n</li>\n<li>Optional - 3D Triangle Filtering (normal filtering aka planarity constraints)\n<ul>\n<li>normalVector ([double, double, double]) - NOT IMPLEMENTED. Currently fixed to [0,0,1]. The normal vector of the planar mesh(s) you desire to extract.</li>\n<li>normThresh (double, default=0.9) - Any triangle whose <code>abs(normalVector * triangleNormal) &lt; normThresh</code> is filtered</li>\n<li>zThresh (double,default=0.2) - Normal filtering is ignored (bypassed) if the the \"height\" (dz) of a triangle is less than zThresh. This is used to attenuate false-positive filtering in noisy pointclouds.</li>\n<li>normThreshMin (double, default=0.1) - Any triangle whose <code>abs(normalVector * triangleNormal) &lt; normThreshMin</code> is filtered. This take priority over anything else, even zThresh bypass. Think of this as the bare minimum of flatness a triangle must have to remain in the mesh.</li>\n</ul>\n</li>\n<li>Optional - 3D Plane Filtering\n<ul>\n<li>minTriangles (int) - Any planar mesh who has less than this quantity of triangles will not be returned</li>\n</ul>\n</li>\n<li>Optional - Triangle Filtering by Class (4th Dimension)\n<ul>\n<li>allowedClass (double) - Will filter out triangles whose vertices are not classified the same as allowedClass</li>\n</ul>\n</li>\n</ul>\n<p>What are the outputs?</p>\n<ul>\n<li>Delaunay - This is a C++ class data structure that has information about your triangles, half edges, and point indices. Read more <a href=\"https://mapbox.github.io/delaunator/\" rel=\"nofollow\">here</a>.</li>\n<li>planes - This is a <em>list</em> of C++ <em>vectors</em> holding <code>ints</code>. Each vector is an extracted plane.  The <code>ints</code> correspond to triangle indices.</li>\n<li>polygons - This is a <em>list</em> of C++ <code>polygon</code> data structure.</li>\n<li>polygon - This is a struct that has two fields: shell and holes. Shell is a <em>vector</em> of <code>ints</code>, where each int represents a <em>point</em> index. Holes is a list of a <em>vector</em> of <code>ints</code>. Each vector represents a hole in the polygon.</li>\n</ul>\n<h2>Polylidar Use Cases</h2>\n<ul>\n<li><a href=\"https://github.com/JeremyBYU/polylidar-realsense\" rel=\"nofollow\">Polylidar-RealSense</a> - Live ground floor detection with Intel RealSense camera using Polylidar</li>\n<li><a href=\"https://github.com/JeremyBYU/polylidarweb\" rel=\"nofollow\">PolylidarWeb</a>. A Typescript (javascript) version with live demos.</li>\n<li><a href=\"https://github.com/JeremyBYU/concavehull-evaluation\" rel=\"nofollow\">Concave-Evaluation</a> - Evaluates and benchmarks several competing concavehull algorithms.</li>\n</ul>\n<h2>Credits</h2>\n<p>This software uses the following open source packages:</p>\n<ul>\n<li><a href=\"https://github.com/mapbox/delaunator\" rel=\"nofollow\">Delaunator</a> - Original triangulation library</li>\n<li><a href=\"https://github.com/delfrrr/delaunator-cpp\" rel=\"nofollow\">DelaunatorCPP</a> - Delaunator ported to C++ (used)</li>\n<li><a href=\"https://github.com/greg7mdp/parallel-hashmap\" rel=\"nofollow\">parallel-hashmap</a> - Very fast hashmap library (used)</li>\n<li><a href=\"https://github.com/pybind/pybind11\" rel=\"nofollow\">PyBind11</a> - Python C++ Binding (used)</li>\n<li><a href=\"https://www.cs.cmu.edu/%7Equake/robust.html\" rel=\"nofollow\">Robust Geometric Predicates</a> - Original Robust Geometric predicates</li>\n<li><a href=\"https://github.com/danshapero/predicates\" rel=\"nofollow\">Updated Predicates</a> -Updated geometric predicate library (used)</li>\n</ul>\n<h2>Related Methods</h2>\n<ul>\n<li><a href=\"https://doc.cgal.org/latest/Alpha_shapes_2/index.html\" rel=\"nofollow\">CGAL Alpha Shapes</a> - MultiPolygon with holes.</li>\n<li><a href=\"http://postgis.net/docs/ST_ConcaveHull.html\" rel=\"nofollow\">PostGIS ConcaveHull</a> - Single Polygon with holes.</li>\n<li><a href=\"https://www.gaia-gis.it/fossil/libspatialite/wiki?name=tesselations-4.0\" rel=\"nofollow\">Spatialite ConcaveHull</a> - MultiPolygon with holes.</li>\n<li><a href=\"https://github.com/mapbox/concaveman\" rel=\"nofollow\">Concaveman</a> - A 2D concave hull extraction algorithm for 2D point sets.</li>\n</ul>\n<h2>Contributing</h2>\n<p>Any help or suggestions would be appreciated! Some tools you may find useful when you install from <code>git clone</code> and build for development</p>\n<ol>\n<li><code>pytest</code> - Run a series of tests and benchmarks.</li>\n<li><code>nox</code> - Build environment for testing and build wheels.</li>\n</ol>\n<h3>Packaging</h3>\n<ol>\n<li><code>bash ./package.sh</code></li>\n</ol>\n<p>TODO</p>\n<h2>License</h2>\n<p>MIT</p>\n<hr>\n<blockquote>\n<p>GitHub <a href=\"https://github.com/JeremyBYU\" rel=\"nofollow\">@jeremybyu</a></p>\n</blockquote>\n\n          </div>"}, "last_serial": 6610711, "releases": {"0.0.6": [{"comment_text": "", "digests": {"md5": "599fda825300082cdac2763538872f0b", "sha256": "4d7eb905f1cccba3e3e91baa29fe0e50aad74b752ee753fdd4d004adde13cc07"}, "downloads": -1, "filename": "polylidar-0.0.6-cp36-cp36m-win_amd64.whl", "has_sig": false, "md5_digest": "599fda825300082cdac2763538872f0b", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": null, "size": 320064, "upload_time": "2019-10-12T00:16:17", "upload_time_iso_8601": "2019-10-12T00:16:17.629397Z", "url": "https://files.pythonhosted.org/packages/a5/35/ecd97863009b6c4ea69940018df84e2030ce0c14561337a5df7b1df629fd/polylidar-0.0.6-cp36-cp36m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2e223185c8d4db0d0a8121d663c4b780", "sha256": "af4a0838b313316bbea44d8bcbdf00a547b6b7f77b6e93f4cbb6fb15f8ddb2d8"}, "downloads": -1, "filename": "polylidar-0.0.6-cp37-cp37m-win_amd64.whl", "has_sig": false, "md5_digest": "2e223185c8d4db0d0a8121d663c4b780", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 320386, "upload_time": "2019-10-12T00:16:19", "upload_time_iso_8601": "2019-10-12T00:16:19.446650Z", "url": "https://files.pythonhosted.org/packages/6e/11/30f47575c0c98cd30afabb5bf33b4616e34da73dfd366a31f39f319694ed/polylidar-0.0.6-cp37-cp37m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a62ab4bf6a1d50e968924d76a730e13a", "sha256": "39c24504f5c47563b80eddbbe8270c6c6ba5f64a113b18d1573d081fc1063a6c"}, "downloads": -1, "filename": "polylidar-0.0.6.tar.gz", "has_sig": false, "md5_digest": "a62ab4bf6a1d50e968924d76a730e13a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2315505, "upload_time": "2019-10-12T00:16:22", "upload_time_iso_8601": "2019-10-12T00:16:22.481856Z", "url": "https://files.pythonhosted.org/packages/7f/ce/334272c413eaa1b9daf0e941fb4e2c5071d4a778f8a48f3e3ba4afed97b2/polylidar-0.0.6.tar.gz", "yanked": false}], "0.0.7": [{"comment_text": "", "digests": {"md5": "caf3ca2ab79f483fccdba4d82ad99534", "sha256": "a92efabcab4b8f3a5ba04b9c7a4fb7f774482a0e9445d5a6a81ad6306097bca7"}, "downloads": -1, "filename": "polylidar-0.0.7-cp36-cp36m-win_amd64.whl", "has_sig": false, "md5_digest": "caf3ca2ab79f483fccdba4d82ad99534", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": null, "size": 319361, "upload_time": "2019-10-16T14:00:32", "upload_time_iso_8601": "2019-10-16T14:00:32.242782Z", "url": "https://files.pythonhosted.org/packages/8a/cc/f032a51a3ab36ee25c08a27b098b9f1f50fa3a7851c921d6187898e789a3/polylidar-0.0.7-cp36-cp36m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "306135fd563fcafe6ac41cc1b8247ca4", "sha256": "032d25685c65864833eabecf66341a7efd349a3d70f5d126dff9b80558d11c7a"}, "downloads": -1, "filename": "polylidar-0.0.7-cp37-cp37m-win_amd64.whl", "has_sig": false, "md5_digest": "306135fd563fcafe6ac41cc1b8247ca4", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 319790, "upload_time": "2019-10-16T14:00:49", "upload_time_iso_8601": "2019-10-16T14:00:49.070780Z", "url": "https://files.pythonhosted.org/packages/4a/a3/73ecda74fe97b4074876da5f964dce8ce9b0ae6704d5156e9f7879e7af9b/polylidar-0.0.7-cp37-cp37m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "934bdc167d3bc88ad020e1fb3b435c29", "sha256": "9be233af538b430ed016817ebe034a607e90afe96e1e6ce5fce0fc9c636bd1fd"}, "downloads": -1, "filename": "polylidar-0.0.7.tar.gz", "has_sig": false, "md5_digest": "934bdc167d3bc88ad020e1fb3b435c29", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 2325344, "upload_time": "2019-10-16T14:01:00", "upload_time_iso_8601": "2019-10-16T14:01:00.474784Z", "url": "https://files.pythonhosted.org/packages/2d/07/f5de09eac5edeeb589c764f47e835cc9d256b32961347e2d47bf03304299/polylidar-0.0.7.tar.gz", "yanked": false}], "0.0.8": [{"comment_text": "", "digests": {"md5": "2f0dd20048b82cfb394280fbd8918cf8", "sha256": "651c17b33b80799928c5dc9698cf43c32284363f2f00aeed438363143ca9e9b4"}, "downloads": -1, "filename": "polylidar-0.0.8-cp36-cp36m-win_amd64.whl", "has_sig": false, "md5_digest": "2f0dd20048b82cfb394280fbd8918cf8", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": null, "size": 339671, "upload_time": "2020-02-11T16:52:52", "upload_time_iso_8601": "2020-02-11T16:52:52.947731Z", "url": "https://files.pythonhosted.org/packages/8d/df/b53013860cc031a2f930d290d592b606cdff6927b8ebe1bf285f74650d2c/polylidar-0.0.8-cp36-cp36m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a428facb6b971c55392217d7eaeb0986", "sha256": "d35391980cca5e87c8656ca5d3167511d53df4cb5a5872d874db853eeec43f08"}, "downloads": -1, "filename": "polylidar-0.0.8-cp37-cp37m-win_amd64.whl", "has_sig": false, "md5_digest": "a428facb6b971c55392217d7eaeb0986", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 339978, "upload_time": "2020-02-11T16:52:54", "upload_time_iso_8601": "2020-02-11T16:52:54.330742Z", "url": "https://files.pythonhosted.org/packages/2f/a9/16bf571fb76fbf82f3b2ceaab8ee423aeff1cc21268a02869188f06e968b/polylidar-0.0.8-cp37-cp37m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3430144e050002d21f807200c00c6336", "sha256": "aa8c4a3c7a8e0e25302272a9c3e1be9477e67c3b6ae52e5d1a96c41b2a32f85f"}, "downloads": -1, "filename": "polylidar-0.0.8-cp38-cp38-win_amd64.whl", "has_sig": false, "md5_digest": "3430144e050002d21f807200c00c6336", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": null, "size": 278778, "upload_time": "2020-02-11T16:52:56", "upload_time_iso_8601": "2020-02-11T16:52:56.264999Z", "url": "https://files.pythonhosted.org/packages/40/45/f961193634e9d24d1eb1107c2585bcdc79376442666d0645cd791fd01cd1/polylidar-0.0.8-cp38-cp38-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "349dd34d5d7ea589f41028ace6f9fab5", "sha256": "db573fa55eec313dcb93d0365d6bd7de21c500b47f00befc35ff5abeb272168b"}, "downloads": -1, "filename": "polylidar-0.0.8.tar.gz", "has_sig": false, "md5_digest": "349dd34d5d7ea589f41028ace6f9fab5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3952606, "upload_time": "2020-02-11T16:53:00", "upload_time_iso_8601": "2020-02-11T16:53:00.565854Z", "url": "https://files.pythonhosted.org/packages/df/d9/ba1abb4a5b4ef51d29799f852d3b0bc4f8b8cfabec4e9d66cf736399a0ec/polylidar-0.0.8.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2f0dd20048b82cfb394280fbd8918cf8", "sha256": "651c17b33b80799928c5dc9698cf43c32284363f2f00aeed438363143ca9e9b4"}, "downloads": -1, "filename": "polylidar-0.0.8-cp36-cp36m-win_amd64.whl", "has_sig": false, "md5_digest": "2f0dd20048b82cfb394280fbd8918cf8", "packagetype": "bdist_wheel", "python_version": "cp36", "requires_python": null, "size": 339671, "upload_time": "2020-02-11T16:52:52", "upload_time_iso_8601": "2020-02-11T16:52:52.947731Z", "url": "https://files.pythonhosted.org/packages/8d/df/b53013860cc031a2f930d290d592b606cdff6927b8ebe1bf285f74650d2c/polylidar-0.0.8-cp36-cp36m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a428facb6b971c55392217d7eaeb0986", "sha256": "d35391980cca5e87c8656ca5d3167511d53df4cb5a5872d874db853eeec43f08"}, "downloads": -1, "filename": "polylidar-0.0.8-cp37-cp37m-win_amd64.whl", "has_sig": false, "md5_digest": "a428facb6b971c55392217d7eaeb0986", "packagetype": "bdist_wheel", "python_version": "cp37", "requires_python": null, "size": 339978, "upload_time": "2020-02-11T16:52:54", "upload_time_iso_8601": "2020-02-11T16:52:54.330742Z", "url": "https://files.pythonhosted.org/packages/2f/a9/16bf571fb76fbf82f3b2ceaab8ee423aeff1cc21268a02869188f06e968b/polylidar-0.0.8-cp37-cp37m-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3430144e050002d21f807200c00c6336", "sha256": "aa8c4a3c7a8e0e25302272a9c3e1be9477e67c3b6ae52e5d1a96c41b2a32f85f"}, "downloads": -1, "filename": "polylidar-0.0.8-cp38-cp38-win_amd64.whl", "has_sig": false, "md5_digest": "3430144e050002d21f807200c00c6336", "packagetype": "bdist_wheel", "python_version": "cp38", "requires_python": null, "size": 278778, "upload_time": "2020-02-11T16:52:56", "upload_time_iso_8601": "2020-02-11T16:52:56.264999Z", "url": "https://files.pythonhosted.org/packages/40/45/f961193634e9d24d1eb1107c2585bcdc79376442666d0645cd791fd01cd1/polylidar-0.0.8-cp38-cp38-win_amd64.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "349dd34d5d7ea589f41028ace6f9fab5", "sha256": "db573fa55eec313dcb93d0365d6bd7de21c500b47f00befc35ff5abeb272168b"}, "downloads": -1, "filename": "polylidar-0.0.8.tar.gz", "has_sig": false, "md5_digest": "349dd34d5d7ea589f41028ace6f9fab5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 3952606, "upload_time": "2020-02-11T16:53:00", "upload_time_iso_8601": "2020-02-11T16:53:00.565854Z", "url": "https://files.pythonhosted.org/packages/df/d9/ba1abb4a5b4ef51d29799f852d3b0bc4f8b8cfabec4e9d66cf736399a0ec/polylidar-0.0.8.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:51:45 2020"}