{"info": {"author": "Jordan Borean", "author_email": "jborean93@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.6", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6"], "description": "Python PsExec Library\n=====================\n\n|License| |Travis Build| |AppVeyor Build| |Coverage|\n\nThis library can run commands on a remote Windows host through Python.\nThis means that it can be run on any host with Python and does not\nrequire any binaries to be present or a specific OS. It uses SMB/RPC to\nexecutable commands in a similar fashion to the popular PsExec tool.\n\nThe executable wrapper that is sent to the service is based on the\n`PAExec <https://github.com/poweradminllc/PAExec>`__ library. PAExec is\nan free, redistributable and open source equivalent to Microsoft\u2019s\n`PsExec <https://docs.microsoft.com/en-us/sysinternals/downloads/psexec>`__\napplication. This program is stored as a binary in this package and is\nused to run the remote service and start the process execution.\n\nI would like to thank the developers of Power Admin for creating this\nlibrary as it has made this library a lot less complex than what it\nwould have been.\n\nFeatures\n--------\n\nWith pypsexec you can run commands of a remote Windows host like you\nwould with PsExec. Current you can use pypsexec to do the following;\n\n-  Run as a specific local or domain user or the user\n-  Run as the local SYSTEM account\n-  Run as an interactive process\n-  Specify the session the interactive process should run on\n-  Specify the run level of the user token, ``highest`` or ``limited``\n-  Set the priority of the process\n-  Set a timeout for the remote process\n-  Send input through the stdin pipe to the running process\n-  Set the processors the process can run on\n\nFurther Info\n------------\n\nWhile this info is not necessary for you to use this library it can help\npeople understand what is happening under the hood. This library runs\nthe following steps when running a command;\n\n-  Create an SMB connection to the host\n-  Copies across the PAExec binary to the ``ADMIN$`` share of the remote\n   host\n-  Binds the Windows Service Manager to the opened ``IPC$`` tree using\n   RPC\n-  Creates and starts a Windows service as the ``SYSTEM`` account to run\n   the binary copied\n-  Connect to the PAExec named pipe the service creates\n-  Sends the process details to the PAExec service through the pipe\n-  Send a request to the PAExec service to start the process based on\n   the settings sent\n-  Connect to the newly spawned process\u2019s stdout, stderr, stdin pipe (if\n   not interactive or async)\n-  Read the stdout/stderr pipe until the process is complete\n-  Get the return code of the new process\n-  Stop and remove the PAExec service\n-  Remove the PAExec binary from the ``ADMIN$`` share\n-  Disconnects from the SMB connection\n\nIn the case of a failed process, the PAExec service and binary may not\nbe removed from the host and may need to be done manually. This is only\nthe case for a critical error or the cleanup functions not being called.\n\nBy default the data being sent to and from the server is encrypted to\nstop people listening in on the network from snooping your data.\nUnfortunately this uses SMB encryption which was added in the SMB 3.x\ndialects so hosts running Windows 7, Server 2008, or Server 2008 R2 will\nnot work with encryption.\n\nThis means that any data sent over the wire on these older versions of\nWindows is viewable by anyone reading those packets. Any input or output\nof the process comes through these packets so any secrets sent over the\nnetwork won\u2019t be encrypted. PAExec tries to reduce this risk by doing a\nsimple XOR scramble of the settings set in ``run_executable`` so it\nisn\u2019t plaintext but it can be decoded by someone who knows the protocol.\n\nRequirements\n------------\n\n-  Python 2.7, 2.7, 3.4-3.6\n-  `smbprotocol <https://github.com/jborean93/smbprotocol>`__\n\nTo install pypsexec, simply run\n\n``pip install pypsexec``\n\nThis will download the required packages that are required and get your\nPython environment ready to do.\n\nOut of the box, pypsexec supports authenticating to a Windows host with\nNTLM authentication but users in a domain environment can take advantage\nof Kerberos authentication as well for added security. Currently the\nWindows implementation of the smbprotocol does not support Kerberos auth\nbut for other platforms you can add support by installing the kerberos\ncomponents of ``smbprotocol``;\n\n::\n\n    # for Debian/Ubuntu/etc:\n    sudo apt-get install gcc python-dev libkrb5-dev\n    pip install smbprotocol[kerberos]\n\n    # for RHEL/CentOS/etc:\n    sudo yum install gcc python-devel krb5-devel krb5-workstation python-devel\n    pip install smbprotocol[kerberos]\n\nFrom there to check that everything was installed correctly and the\ncorrect GSSAPI extensions are available on that host, run\n\n::\n\n    try:\n        from gssapi.raw import inquire_sec_context_by_oid\n        print(\"python-gssapi extension is available\")\n    except ImportError as exc:\n        print(\"python-gssapi extension is not available: %s\" % str(exc))\n\nIf it isn\u2019t available, then either a newer version of the system\u2019s\ngssapi implementation needs to be setup and python-gssapi compiled\nagainst that newer version.\n\nRemote Host Requirements\n------------------------\n\nThe goal of this package to be able to run executables on a vanilla\nremote Windows host with as little setup as possible. Unfortunately\nthere is still some setup required to get working depending on the OS\nversion and type that is being used. What pypsexec requires on the host\nis;\n\n-  SMB to be up and running on the Windows port and readable from the\n   Python host\n-  The ``ADMIN$`` share to be enabled with read/write access of the user\n   configured\n-  The above usually means the configured user is an administrator of\n   the Windows host\n-  At least SMB 2 on the host (Server 2008 and newer)\n\nFirewall Setup\n~~~~~~~~~~~~~~\n\nBy default, Windows blocks the SMB port 445 and it needs to be opened up\nbefore pypsexec can connect to the host. To do this run either one of\nthe following commands;\n\n::\n\n    # PowerShell (Windows 8 and Server 2012 or Newer)\n    Set-NetFirewallRule -Name FPS-SMB-In-TCP -Enabled True\n\n    # CMD (All OS's)\n    netsh advfirewall firewall set rule name=\"File and Printer Sharing (SMB-In)\" dir=in new enable=Yes\n\nThis will open up inbound traffic to port ``445`` which is used by SMB.\n\nUser Account Control\n~~~~~~~~~~~~~~~~~~~~\n\nOn the desktop variants of Windows (7, 8, 10), UAC is enabled by default\nand is set to filter a network logon of a local account of their\nAdministrative rights. Unfortunately pypsexec requires these rights to\nboth copy the executable to the ``ADMIN$`` share as well as create the\nPAExec service on the host. With the default setting it will receive an\n``ACCESS_IS_DENIED`` response when attempting either of the 2 as it\u2019s\ntoken does not have Administrative rights.\n\nTo get it working on these OS\u2019, either configure UAC to not filter local\naccount tokens from a network logon or disable UAC entirely. Disabling\nUAC is definitely an extreme step and should be avoided if possible but\ndisabling local token filtering means any network logons of an\nAdministrator account now gets the full rights of that user. To disable\nlocal token filter run the following;\n\n::\n\n    $reg_path = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n    $reg_prop_name = \"LocalAccountTokenFilterPolicy\"\n\n    $reg_key = Get-Item -Path $reg_path\n    $reg_prop = $reg_key.GetValue($reg_prop_name)\n    if ($null -ne $reg_prop) {\n        Remove-ItemProperty -Path $reg_path -Name $reg_prop_name\n    }\n\n    New-ItemProperty -Path $reg_path -Name $reg_prop_name -Value 1 -PropertyType DWord\n\nTo disable UAC entirely, run the following;\n\n::\n\n    $reg_path = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n    $reg_prop_name = \"EnableLUA\"\n\n    $reg_key = Get-Item -Path $reg_path\n    $reg_prop = $reg_key.GetValue($reg_prop_name)\n    if ($null -ne $reg_prop) {\n        Remove-ItemProperty -Path $reg_path -Name $reg_prop_name\n    }\n\n    New-ItemProperty -Path $reg_path -Name $reg_prop_name -Value 0 -PropertyType DWord\n\nAfter running either of these scripts, the Windows host needs to be\nrebooted before the policies are enacted.\n\nExamples\n--------\n\nHere is an example of how to run a command with this library\n\n::\n\n    from pypsexec.client import Client\n\n    # creates an encrypted connection to the host with the username and password\n    c = Client(\"hostname\", username=\"username\", password=\"password\")\n\n    # set encrypt=False for Windows 7, Server 2008\n    c = Client(\"hostname\", username=\"username\", password=\"password\", encrypt=False)\n\n    # if Kerberos is available, this will use the default credentials in the\n    # credential cache\n    c = Client(\"hostname\")\n\n    # you can also tell it to use a specific Kerberos principal in the cache\n    # without a password\n    c = Client(\"hostname\", username=\"username@DOMAIN.LOCAL\")\n\n    c.connect()\n    try:\n        c.create_service()\n\n        # After creating the service, you can run multiple exe's without\n        # reconnecting\n\n        # run a simple cmd.exe program with arguments\n        stdout, stderr, rc = c.run_executable(\"cmd.exe\",\n                                              arguments=\"/c echo Hello World\")\n\n        # run whoami.exe as the SYSTEM account\n        stdout, stderr, rc = c.run_executable(\"whoami.exe\", use_system_account=True)\n\n        # run command asynchronously (in background), the rc is the PID of the spawned service\n        stdout, stderr, rc = c.run_executable(\"longrunning.exe\",\n                                              arguments=\"/s other args\",\n                                              asynchronous=True)\n\n        # run whoami.exe as a specific user\n        stdout, stderr, rc = c.run_executable(\"whoami\",\n                                              arguments=\"/all\",\n                                              username=\"local-user\",\n                                              password=\"password\",\n                                              run_elevated=True)\n    finally:\n        c.remove_service()\n        c.disconnect()\n\nIn the case of a fatal failure, this project may leave behind some the\nPAExec payload in ``C:\\Windows`` or the service still installed. As\nthese are uniquely named they can build up over time. They can be\nmanually removed but you can also use pypsexec to cleanup them all up at\nonce. To do this run\n\n::\n\n    from pypsexec.client import Client\n\n    c = Client(\"server\", username=\"username\", password=\"password\")\n    c.connect()\n    c.cleanup()  # this is where the magic happens\n    c.disconnect()\n\nThe script will delete any files that match ``C:\\Windows\\PAExec-*`` and\nany services that match ``PAExec-*``. For an individual run, the\n``remove_service()`` function should still be used.\n\nClient Options\n~~~~~~~~~~~~~~\n\nWhen creating the main pypsexec ``Client`` object there are some\nconfiguration options that can be set to control the process. These args\nare;\n\n-  ``server``: This needs to be set and is the host or IP address of the\n   server to connect to\n-  ``username``: The username to connect with. Can be ``None`` if\n   ``python-gssapi`` is installed and a ticket has been granted in the\n   local credential cache\n-  ``password``: The password for ``username``. Can be ``None`` if\n   ``python-gssapi`` is installed and a ticket has been granted for the\n   user specified\n-  ``port``: Override the default port of ``445`` when connecting to the\n   server\n-  ``encrypt``: Whether to encrypt the messages or not, default is\n   ``True``. Server 2008, 2008 R2 and Windows 7 hosts do not support SMB\n   Encryption and need this to be set to ``False``\n\nRun Executable Options\n~~~~~~~~~~~~~~~~~~~~~~\n\nWhen calling ``run_executable``, there are multiple kwargs that can\ndefine how the remote process will work. These args are;\n\n-  ``executable``: (string) The path to the executable to be run\n-  ``arguments``: (string) Arguments for the executable\n-  ``processors``: (list) A list of processor numbers that the process\n   can run on\n-  ``asynchronous``: (bool) Doesn\u2019t wait until the process is complete\n   before returning. The ``rc`` returned by the function is the ``PID``\n   of the async process, default is ``False``\n-  ``load_profile``: (bool) Load the user\u2019s profile, default is ``True``\n-  ``interactive_session``: (int) The session ID to display the\n   interactive process when ``interactive=True``, default is ``0``\n-  ``interactive``: (bool) Runs the process as an interactive process.\n   The stdout and stderr buffers will be ``None`` if ``True``, default\n   ``False``\n-  ``run_elevated``: (bool) When ``username`` is defined, will elevated\n   permissions, default ``False``\n-  ``run_limited``: (bool) When ``username`` is defined, will run the\n   process under limited permissions, default ``False``\n-  ``username``: (string) Used to run the process under a different user\n   than the one that authenticated the SMB session\n-  ``password``: (string) The password for ``username``\n-  ``use_system_account``: (bool) Run the process as\n   ``NT AUTHORITY\\SYSTEM``\n-  ``working_dir``: (string) The working directory of the process,\n   default ``C:\\Windows\\System32``\n-  ``show_ui_on_win_logon``: (bool) Displays the UI on the Winlogon\n   secure desktop when ``use_system_account=True``, default ``False``\n-  ``priority``: (pypsexec.ProcessPriority) The priority level of the\n   process, default ``NORMAL_PRIORITY_CLASS``\n-  ``remote_log_path``: (string) A path on the remote host to log the\n   PAExec service details\n-  ``timeout_seconds``: (int) The maximum time the process can run for,\n   default is ``0`` (no timeout)\n-  ``stdout``: (pipe.OutputPipe) A class that implements pipe.OutputPipe\n   that controls how the stdout output is processed and returned, will\n   default to returning the byte string of the stdout. Is ignored when\n   ``interactive=True`` and ``asynchronous=True``\n-  ``stderr``: (pipe.OutputPipe) A class that implements pipe.OutputPipe\n   that controls how the stderr output is processed and returned, will\n   default to returning the byte string of the stderr. Is ignored when\n   ``interactive=True`` and ``asynchronous=True``\n-  ``stdin``: (bytes/generator) A byte string or generator that yields a\n   byte string to send over the stdin pipe, does not work with\n   ``interactive=True`` and ``asynchronous=True``\n\nLogging\n-------\n\nThis library uses the builtin Python logging library and can be used to\nfind out what is happening in the pypsexec process. Log messages are\nlogged to the ``pypsexec`` named logger as well as ``pypsexec.*`` where\n``*`` is each python script in the ``pypsexec`` directory.\n\nA way to enable the logging in your scripts through code is to add the\nfollowing to the top of the script being used;\n\n::\n\n    import logging\n\n    logger = logging.getLogger(\"pypsexec\")\n    logger.setLevel(logging.DEBUG)  # set to logging.INFO if you don't want DEBUG logs\n    ch = logging.StreamHandler()\n    ch.setLevel(logging.DEBUG)\n    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - '\n                                  '%(message)s')\n    ch.setFormatter(formatter)\n    logger.addHandler(ch)\n\nThese logs are generally useful when debugging issues as they give you a\nmore step by step snapshot of what it is doing and what may be going\nwrong. The debug level will also print out a human readable string of\neach SMB packet that is sent out from the client but this level can get\nreally verbose.\n\nTesting\n-------\n\nTo this module, you need to install some pre-requisites first. This can\nbe done by running;\n\n::\n\n    pip install -r requirements-test.txt\n\n    # you can also run tox by installing tox\n    pip install tox\n\nFrom there to run the basic tests run;\n\n::\n\n    py.test -v --pep8 --cov pypsexec --cov-report term-missing\n\n    # or with tox 2.7, 2.7, 3.4, 3.5, and 3.6\n    tox\n\nThere are extra tests that only run when certain environment variables\nare set. To run these tests set the following variables;\n\n-  ``PYPSEXEC_SERVER``: The hostname or IP to a Windows host\n-  ``PYPSEXEC_USERNAME``: The username to use authenticate with\n-  ``PYPSEXEC_PASSWORD``: The password for ``PYPSEXEC_USERNAME``\n\nFrom there, you can just run ``tox`` or ``py.test`` with these\nenvironment variables to run the integration tests.\n\nFuture\n------\n\nSome things I would be interested in looking at adding in the future\nwould be\n\n-  Add a Python script that can be called to run adhoc commands like\n   ``PsExec.exe``\n\n.. |License| image:: https://img.shields.io/badge/license-MIT-blue.svg\n   :target: https://github.com/jborean93/pypsexec/blob/master/LICENSE\n.. |Travis Build| image:: https://travis-ci.org/jborean93/pypsexec.svg\n   :target: https://travis-ci.org/jborean93/pypsexec\n.. |AppVeyor Build| image:: https://ci.appveyor.com/api/projects/status/github/jborean93/pypsexec?svg=true\n   :target: https://ci.appveyor.com/project/jborean93/pypsexec\n.. |Coverage| image:: https://coveralls.io/repos/jborean93/pypsexec/badge.svg\n   :target: https://coveralls.io/r/jborean93/pypsexec\n\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/jborean93/pypsexec", "keywords": "windows psexec paexec remote python", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "pypsexec", "package_url": "https://pypi.org/project/pypsexec/", "platform": "", "project_url": "https://pypi.org/project/pypsexec/", "project_urls": {"Homepage": "https://github.com/jborean93/pypsexec"}, "release_url": "https://pypi.org/project/pypsexec/0.1.0/", "requires_dist": ["smbprotocol", "six"], "requires_python": "", "summary": "Run commands on a remote Windows host using SMB/RPC", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://github.com/jborean93/pypsexec/blob/master/LICENSE\" rel=\"nofollow\"><img alt=\"License\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c88fab50b4a1dc0cd91faeb7ba5654d56e380260/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4d49542d626c75652e737667\"></a> <a href=\"https://travis-ci.org/jborean93/pypsexec\" rel=\"nofollow\"><img alt=\"Travis Build\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/e030c9fc0105187ebf0b5df66f7de91ca5422378/68747470733a2f2f7472617669732d63692e6f72672f6a626f7265616e39332f70797073657865632e737667\"></a> <a href=\"https://ci.appveyor.com/project/jborean93/pypsexec\" rel=\"nofollow\"><img alt=\"AppVeyor Build\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/2d48288d25c44fcc96909488c55322bc35046115/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f6a626f7265616e39332f70797073657865633f7376673d74727565\"></a> <a href=\"https://coveralls.io/r/jborean93/pypsexec\" rel=\"nofollow\"><img alt=\"Coverage\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8b112f88c8c496396ad5fd9ffe3c6f34c7ab90b7/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6a626f7265616e39332f70797073657865632f62616467652e737667\"></a></p>\n<p>This library can run commands on a remote Windows host through Python.\nThis means that it can be run on any host with Python and does not\nrequire any binaries to be present or a specific OS. It uses SMB/RPC to\nexecutable commands in a similar fashion to the popular PsExec tool.</p>\n<p>The executable wrapper that is sent to the service is based on the\n<a href=\"https://github.com/poweradminllc/PAExec\" rel=\"nofollow\">PAExec</a> library. PAExec is\nan free, redistributable and open source equivalent to Microsoft\u2019s\n<a href=\"https://docs.microsoft.com/en-us/sysinternals/downloads/psexec\" rel=\"nofollow\">PsExec</a>\napplication. This program is stored as a binary in this package and is\nused to run the remote service and start the process execution.</p>\n<p>I would like to thank the developers of Power Admin for creating this\nlibrary as it has made this library a lot less complex than what it\nwould have been.</p>\n<div id=\"features\">\n<h2>Features</h2>\n<p>With pypsexec you can run commands of a remote Windows host like you\nwould with PsExec. Current you can use pypsexec to do the following;</p>\n<ul>\n<li>Run as a specific local or domain user or the user</li>\n<li>Run as the local SYSTEM account</li>\n<li>Run as an interactive process</li>\n<li>Specify the session the interactive process should run on</li>\n<li>Specify the run level of the user token, <tt>highest</tt> or <tt>limited</tt></li>\n<li>Set the priority of the process</li>\n<li>Set a timeout for the remote process</li>\n<li>Send input through the stdin pipe to the running process</li>\n<li>Set the processors the process can run on</li>\n</ul>\n</div>\n<div id=\"further-info\">\n<h2>Further Info</h2>\n<p>While this info is not necessary for you to use this library it can help\npeople understand what is happening under the hood. This library runs\nthe following steps when running a command;</p>\n<ul>\n<li>Create an SMB connection to the host</li>\n<li>Copies across the PAExec binary to the <tt>ADMIN$</tt> share of the remote\nhost</li>\n<li>Binds the Windows Service Manager to the opened <tt>IPC$</tt> tree using\nRPC</li>\n<li>Creates and starts a Windows service as the <tt>SYSTEM</tt> account to run\nthe binary copied</li>\n<li>Connect to the PAExec named pipe the service creates</li>\n<li>Sends the process details to the PAExec service through the pipe</li>\n<li>Send a request to the PAExec service to start the process based on\nthe settings sent</li>\n<li>Connect to the newly spawned process\u2019s stdout, stderr, stdin pipe (if\nnot interactive or async)</li>\n<li>Read the stdout/stderr pipe until the process is complete</li>\n<li>Get the return code of the new process</li>\n<li>Stop and remove the PAExec service</li>\n<li>Remove the PAExec binary from the <tt>ADMIN$</tt> share</li>\n<li>Disconnects from the SMB connection</li>\n</ul>\n<p>In the case of a failed process, the PAExec service and binary may not\nbe removed from the host and may need to be done manually. This is only\nthe case for a critical error or the cleanup functions not being called.</p>\n<p>By default the data being sent to and from the server is encrypted to\nstop people listening in on the network from snooping your data.\nUnfortunately this uses SMB encryption which was added in the SMB 3.x\ndialects so hosts running Windows 7, Server 2008, or Server 2008 R2 will\nnot work with encryption.</p>\n<p>This means that any data sent over the wire on these older versions of\nWindows is viewable by anyone reading those packets. Any input or output\nof the process comes through these packets so any secrets sent over the\nnetwork won\u2019t be encrypted. PAExec tries to reduce this risk by doing a\nsimple XOR scramble of the settings set in <tt>run_executable</tt> so it\nisn\u2019t plaintext but it can be decoded by someone who knows the protocol.</p>\n</div>\n<div id=\"requirements\">\n<h2>Requirements</h2>\n<ul>\n<li>Python 2.7, 2.7, 3.4-3.6</li>\n<li><a href=\"https://github.com/jborean93/smbprotocol\" rel=\"nofollow\">smbprotocol</a></li>\n</ul>\n<p>To install pypsexec, simply run</p>\n<p><tt>pip install pypsexec</tt></p>\n<p>This will download the required packages that are required and get your\nPython environment ready to do.</p>\n<p>Out of the box, pypsexec supports authenticating to a Windows host with\nNTLM authentication but users in a domain environment can take advantage\nof Kerberos authentication as well for added security. Currently the\nWindows implementation of the smbprotocol does not support Kerberos auth\nbut for other platforms you can add support by installing the kerberos\ncomponents of <tt>smbprotocol</tt>;</p>\n<pre># for Debian/Ubuntu/etc:\nsudo apt-get install gcc python-dev libkrb5-dev\npip install smbprotocol[kerberos]\n\n# for RHEL/CentOS/etc:\nsudo yum install gcc python-devel krb5-devel krb5-workstation python-devel\npip install smbprotocol[kerberos]\n</pre>\n<p>From there to check that everything was installed correctly and the\ncorrect GSSAPI extensions are available on that host, run</p>\n<pre>try:\n    from gssapi.raw import inquire_sec_context_by_oid\n    print(\"python-gssapi extension is available\")\nexcept ImportError as exc:\n    print(\"python-gssapi extension is not available: %s\" % str(exc))\n</pre>\n<p>If it isn\u2019t available, then either a newer version of the system\u2019s\ngssapi implementation needs to be setup and python-gssapi compiled\nagainst that newer version.</p>\n</div>\n<div id=\"remote-host-requirements\">\n<h2>Remote Host Requirements</h2>\n<p>The goal of this package to be able to run executables on a vanilla\nremote Windows host with as little setup as possible. Unfortunately\nthere is still some setup required to get working depending on the OS\nversion and type that is being used. What pypsexec requires on the host\nis;</p>\n<ul>\n<li>SMB to be up and running on the Windows port and readable from the\nPython host</li>\n<li>The <tt>ADMIN$</tt> share to be enabled with read/write access of the user\nconfigured</li>\n<li>The above usually means the configured user is an administrator of\nthe Windows host</li>\n<li>At least SMB 2 on the host (Server 2008 and newer)</li>\n</ul>\n<div id=\"firewall-setup\">\n<h3>Firewall Setup</h3>\n<p>By default, Windows blocks the SMB port 445 and it needs to be opened up\nbefore pypsexec can connect to the host. To do this run either one of\nthe following commands;</p>\n<pre># PowerShell (Windows 8 and Server 2012 or Newer)\nSet-NetFirewallRule -Name FPS-SMB-In-TCP -Enabled True\n\n# CMD (All OS's)\nnetsh advfirewall firewall set rule name=\"File and Printer Sharing (SMB-In)\" dir=in new enable=Yes\n</pre>\n<p>This will open up inbound traffic to port <tt>445</tt> which is used by SMB.</p>\n</div>\n<div id=\"user-account-control\">\n<h3>User Account Control</h3>\n<p>On the desktop variants of Windows (7, 8, 10), UAC is enabled by default\nand is set to filter a network logon of a local account of their\nAdministrative rights. Unfortunately pypsexec requires these rights to\nboth copy the executable to the <tt>ADMIN$</tt> share as well as create the\nPAExec service on the host. With the default setting it will receive an\n<tt>ACCESS_IS_DENIED</tt> response when attempting either of the 2 as it\u2019s\ntoken does not have Administrative rights.</p>\n<p>To get it working on these OS\u2019, either configure UAC to not filter local\naccount tokens from a network logon or disable UAC entirely. Disabling\nUAC is definitely an extreme step and should be avoided if possible but\ndisabling local token filtering means any network logons of an\nAdministrator account now gets the full rights of that user. To disable\nlocal token filter run the following;</p>\n<pre>$reg_path = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n$reg_prop_name = \"LocalAccountTokenFilterPolicy\"\n\n$reg_key = Get-Item -Path $reg_path\n$reg_prop = $reg_key.GetValue($reg_prop_name)\nif ($null -ne $reg_prop) {\n    Remove-ItemProperty -Path $reg_path -Name $reg_prop_name\n}\n\nNew-ItemProperty -Path $reg_path -Name $reg_prop_name -Value 1 -PropertyType DWord\n</pre>\n<p>To disable UAC entirely, run the following;</p>\n<pre>$reg_path = \"HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System\"\n$reg_prop_name = \"EnableLUA\"\n\n$reg_key = Get-Item -Path $reg_path\n$reg_prop = $reg_key.GetValue($reg_prop_name)\nif ($null -ne $reg_prop) {\n    Remove-ItemProperty -Path $reg_path -Name $reg_prop_name\n}\n\nNew-ItemProperty -Path $reg_path -Name $reg_prop_name -Value 0 -PropertyType DWord\n</pre>\n<p>After running either of these scripts, the Windows host needs to be\nrebooted before the policies are enacted.</p>\n</div>\n</div>\n<div id=\"examples\">\n<h2>Examples</h2>\n<p>Here is an example of how to run a command with this library</p>\n<pre>from pypsexec.client import Client\n\n# creates an encrypted connection to the host with the username and password\nc = Client(\"hostname\", username=\"username\", password=\"password\")\n\n# set encrypt=False for Windows 7, Server 2008\nc = Client(\"hostname\", username=\"username\", password=\"password\", encrypt=False)\n\n# if Kerberos is available, this will use the default credentials in the\n# credential cache\nc = Client(\"hostname\")\n\n# you can also tell it to use a specific Kerberos principal in the cache\n# without a password\nc = Client(\"hostname\", username=\"username@DOMAIN.LOCAL\")\n\nc.connect()\ntry:\n    c.create_service()\n\n    # After creating the service, you can run multiple exe's without\n    # reconnecting\n\n    # run a simple cmd.exe program with arguments\n    stdout, stderr, rc = c.run_executable(\"cmd.exe\",\n                                          arguments=\"/c echo Hello World\")\n\n    # run whoami.exe as the SYSTEM account\n    stdout, stderr, rc = c.run_executable(\"whoami.exe\", use_system_account=True)\n\n    # run command asynchronously (in background), the rc is the PID of the spawned service\n    stdout, stderr, rc = c.run_executable(\"longrunning.exe\",\n                                          arguments=\"/s other args\",\n                                          asynchronous=True)\n\n    # run whoami.exe as a specific user\n    stdout, stderr, rc = c.run_executable(\"whoami\",\n                                          arguments=\"/all\",\n                                          username=\"local-user\",\n                                          password=\"password\",\n                                          run_elevated=True)\nfinally:\n    c.remove_service()\n    c.disconnect()\n</pre>\n<p>In the case of a fatal failure, this project may leave behind some the\nPAExec payload in <tt><span class=\"pre\">C:\\Windows</span></tt> or the service still installed. As\nthese are uniquely named they can build up over time. They can be\nmanually removed but you can also use pypsexec to cleanup them all up at\nonce. To do this run</p>\n<pre>from pypsexec.client import Client\n\nc = Client(\"server\", username=\"username\", password=\"password\")\nc.connect()\nc.cleanup()  # this is where the magic happens\nc.disconnect()\n</pre>\n<p>The script will delete any files that match <tt><span class=\"pre\">C:\\Windows\\PAExec-*</span></tt> and\nany services that match <tt><span class=\"pre\">PAExec-*</span></tt>. For an individual run, the\n<tt>remove_service()</tt> function should still be used.</p>\n<div id=\"client-options\">\n<h3>Client Options</h3>\n<p>When creating the main pypsexec <tt>Client</tt> object there are some\nconfiguration options that can be set to control the process. These args\nare;</p>\n<ul>\n<li><tt>server</tt>: This needs to be set and is the host or IP address of the\nserver to connect to</li>\n<li><tt>username</tt>: The username to connect with. Can be <tt>None</tt> if\n<tt><span class=\"pre\">python-gssapi</span></tt> is installed and a ticket has been granted in the\nlocal credential cache</li>\n<li><tt>password</tt>: The password for <tt>username</tt>. Can be <tt>None</tt> if\n<tt><span class=\"pre\">python-gssapi</span></tt> is installed and a ticket has been granted for the\nuser specified</li>\n<li><tt>port</tt>: Override the default port of <tt>445</tt> when connecting to the\nserver</li>\n<li><tt>encrypt</tt>: Whether to encrypt the messages or not, default is\n<tt>True</tt>. Server 2008, 2008 R2 and Windows 7 hosts do not support SMB\nEncryption and need this to be set to <tt>False</tt></li>\n</ul>\n</div>\n<div id=\"run-executable-options\">\n<h3>Run Executable Options</h3>\n<p>When calling <tt>run_executable</tt>, there are multiple kwargs that can\ndefine how the remote process will work. These args are;</p>\n<ul>\n<li><tt>executable</tt>: (string) The path to the executable to be run</li>\n<li><tt>arguments</tt>: (string) Arguments for the executable</li>\n<li><tt>processors</tt>: (list) A list of processor numbers that the process\ncan run on</li>\n<li><tt>asynchronous</tt>: (bool) Doesn\u2019t wait until the process is complete\nbefore returning. The <tt>rc</tt> returned by the function is the <tt>PID</tt>\nof the async process, default is <tt>False</tt></li>\n<li><tt>load_profile</tt>: (bool) Load the user\u2019s profile, default is <tt>True</tt></li>\n<li><tt>interactive_session</tt>: (int) The session ID to display the\ninteractive process when <tt>interactive=True</tt>, default is <tt>0</tt></li>\n<li><tt>interactive</tt>: (bool) Runs the process as an interactive process.\nThe stdout and stderr buffers will be <tt>None</tt> if <tt>True</tt>, default\n<tt>False</tt></li>\n<li><tt>run_elevated</tt>: (bool) When <tt>username</tt> is defined, will elevated\npermissions, default <tt>False</tt></li>\n<li><tt>run_limited</tt>: (bool) When <tt>username</tt> is defined, will run the\nprocess under limited permissions, default <tt>False</tt></li>\n<li><tt>username</tt>: (string) Used to run the process under a different user\nthan the one that authenticated the SMB session</li>\n<li><tt>password</tt>: (string) The password for <tt>username</tt></li>\n<li><tt>use_system_account</tt>: (bool) Run the process as\n<tt>NT AUTHORITY\\SYSTEM</tt></li>\n<li><tt>working_dir</tt>: (string) The working directory of the process,\ndefault <tt><span class=\"pre\">C:\\Windows\\System32</span></tt></li>\n<li><tt>show_ui_on_win_logon</tt>: (bool) Displays the UI on the Winlogon\nsecure desktop when <tt>use_system_account=True</tt>, default <tt>False</tt></li>\n<li><tt>priority</tt>: (pypsexec.ProcessPriority) The priority level of the\nprocess, default <tt>NORMAL_PRIORITY_CLASS</tt></li>\n<li><tt>remote_log_path</tt>: (string) A path on the remote host to log the\nPAExec service details</li>\n<li><tt>timeout_seconds</tt>: (int) The maximum time the process can run for,\ndefault is <tt>0</tt> (no timeout)</li>\n<li><tt>stdout</tt>: (pipe.OutputPipe) A class that implements pipe.OutputPipe\nthat controls how the stdout output is processed and returned, will\ndefault to returning the byte string of the stdout. Is ignored when\n<tt>interactive=True</tt> and <tt>asynchronous=True</tt></li>\n<li><tt>stderr</tt>: (pipe.OutputPipe) A class that implements pipe.OutputPipe\nthat controls how the stderr output is processed and returned, will\ndefault to returning the byte string of the stderr. Is ignored when\n<tt>interactive=True</tt> and <tt>asynchronous=True</tt></li>\n<li><tt>stdin</tt>: (bytes/generator) A byte string or generator that yields a\nbyte string to send over the stdin pipe, does not work with\n<tt>interactive=True</tt> and <tt>asynchronous=True</tt></li>\n</ul>\n</div>\n</div>\n<div id=\"logging\">\n<h2>Logging</h2>\n<p>This library uses the builtin Python logging library and can be used to\nfind out what is happening in the pypsexec process. Log messages are\nlogged to the <tt>pypsexec</tt> named logger as well as <tt>pypsexec.*</tt> where\n<tt>*</tt> is each python script in the <tt>pypsexec</tt> directory.</p>\n<p>A way to enable the logging in your scripts through code is to add the\nfollowing to the top of the script being used;</p>\n<pre>import logging\n\nlogger = logging.getLogger(\"pypsexec\")\nlogger.setLevel(logging.DEBUG)  # set to logging.INFO if you don't want DEBUG logs\nch = logging.StreamHandler()\nch.setLevel(logging.DEBUG)\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - '\n                              '%(message)s')\nch.setFormatter(formatter)\nlogger.addHandler(ch)\n</pre>\n<p>These logs are generally useful when debugging issues as they give you a\nmore step by step snapshot of what it is doing and what may be going\nwrong. The debug level will also print out a human readable string of\neach SMB packet that is sent out from the client but this level can get\nreally verbose.</p>\n</div>\n<div id=\"testing\">\n<h2>Testing</h2>\n<p>To this module, you need to install some pre-requisites first. This can\nbe done by running;</p>\n<pre>pip install -r requirements-test.txt\n\n# you can also run tox by installing tox\npip install tox\n</pre>\n<p>From there to run the basic tests run;</p>\n<pre>py.test -v --pep8 --cov pypsexec --cov-report term-missing\n\n# or with tox 2.7, 2.7, 3.4, 3.5, and 3.6\ntox\n</pre>\n<p>There are extra tests that only run when certain environment variables\nare set. To run these tests set the following variables;</p>\n<ul>\n<li><tt>PYPSEXEC_SERVER</tt>: The hostname or IP to a Windows host</li>\n<li><tt>PYPSEXEC_USERNAME</tt>: The username to use authenticate with</li>\n<li><tt>PYPSEXEC_PASSWORD</tt>: The password for <tt>PYPSEXEC_USERNAME</tt></li>\n</ul>\n<p>From there, you can just run <tt>tox</tt> or <tt>py.test</tt> with these\nenvironment variables to run the integration tests.</p>\n</div>\n<div id=\"future\">\n<h2>Future</h2>\n<p>Some things I would be interested in looking at adding in the future\nwould be</p>\n<ul>\n<li>Add a Python script that can be called to run adhoc commands like\n<tt>PsExec.exe</tt></li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 3646071, "releases": {"0.0.1.dev0": [{"comment_text": "", "digests": {"md5": "9f29a5d74552e0919eb898527309aa0c", "sha256": "c930ac53c689bd6ae0c966f919d5f0da528a6b53dc5ff8abcdb3778267c1f353"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9f29a5d74552e0919eb898527309aa0c", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 151058, "upload_time": "2018-02-20T04:11:26", "upload_time_iso_8601": "2018-02-20T04:11:26.176118Z", "url": "https://files.pythonhosted.org/packages/82/e1/5157ffa79fa3a9a960db963ca8a008563f979f8f1b849578da851c63adf5/pypsexec-0.0.1.dev0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ba31596bee3411e045bbce893136b215", "sha256": "9d8b06699fff565792626372751b007b6e677f94d5c7685704f0a5a9d6f20330"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev0.tar.gz", "has_sig": false, "md5_digest": "ba31596bee3411e045bbce893136b215", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 149120, "upload_time": "2018-02-20T04:11:30", "upload_time_iso_8601": "2018-02-20T04:11:30.984846Z", "url": "https://files.pythonhosted.org/packages/d9/d4/16d94844d7a38eca838cb001b8b4382246e9a286e0c150614f4394738cea/pypsexec-0.0.1.dev0.tar.gz", "yanked": false}], "0.0.1.dev1": [{"comment_text": "", "digests": {"md5": "f1b60bd015847be705688968f01ed036", "sha256": "0dbbd7e56117702ca1ae1e32542b40c15a89a754a772871cb9cd9c80182bea9a"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f1b60bd015847be705688968f01ed036", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 152969, "upload_time": "2018-02-20T20:57:30", "upload_time_iso_8601": "2018-02-20T20:57:30.317496Z", "url": "https://files.pythonhosted.org/packages/ed/79/24080b60d3aab7907fe2fb48c9396e7b0363f7124bfbc3998338d405286b/pypsexec-0.0.1.dev1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "54cd767027fc3e93d977f8babfac119c", "sha256": "45c90c0da37c44584ee2d7a0c99642df433befd02651663a00eae6510993c9b2"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev1.tar.gz", "has_sig": false, "md5_digest": "54cd767027fc3e93d977f8babfac119c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 150292, "upload_time": "2018-02-20T20:57:33", "upload_time_iso_8601": "2018-02-20T20:57:33.743411Z", "url": "https://files.pythonhosted.org/packages/4b/5b/331ad84b70c4a0c2a72bc5f58512c6a96806ebb9f669640dc73620bbdba3/pypsexec-0.0.1.dev1.tar.gz", "yanked": false}], "0.0.1.dev2": [{"comment_text": "", "digests": {"md5": "f11684239a4aa1ed97f7a2f45673ccd7", "sha256": "3a5f9cd86104c296bc9d5515c5b53f02770000d896506f331e6423ff64ef9fbe"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "f11684239a4aa1ed97f7a2f45673ccd7", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 155581, "upload_time": "2018-02-22T10:18:26", "upload_time_iso_8601": "2018-02-22T10:18:26.287705Z", "url": "https://files.pythonhosted.org/packages/5d/1c/cc136f0658d420a99a0bf0f5ee0ad48c3d83f9effbe8bf9f179e14ab86e3/pypsexec-0.0.1.dev2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fc58d79f525df920f318b5e4a1049154", "sha256": "3047c700634a08696e2e626a434185952e7f8a9ce833ef7dbfb42dfab9816262"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev2.tar.gz", "has_sig": false, "md5_digest": "fc58d79f525df920f318b5e4a1049154", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 152752, "upload_time": "2018-02-22T10:18:28", "upload_time_iso_8601": "2018-02-22T10:18:28.551082Z", "url": "https://files.pythonhosted.org/packages/34/c2/bc006427a53585593b6ca8186c21c2c3fdca44cbf44eee1925660f887f7c/pypsexec-0.0.1.dev2.tar.gz", "yanked": false}], "0.0.1.dev3": [{"comment_text": "", "digests": {"md5": "2d26339a58e51a0b058dd631ecfa1849", "sha256": "0a92fb9ad241901be311b6667a658cfbb6b90114c9bc2057f0d37d35a0484988"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "2d26339a58e51a0b058dd631ecfa1849", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 158442, "upload_time": "2018-02-23T07:18:42", "upload_time_iso_8601": "2018-02-23T07:18:42.707780Z", "url": "https://files.pythonhosted.org/packages/8d/f7/7bdbd71776ac3056f22ce38db5615d1534468d2379f0e51ee6d4df617e21/pypsexec-0.0.1.dev3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "457ab5b4cae497b3bfc6570da15fd565", "sha256": "5396f6d13140451e62ef60f515d52de199886e33c8247f1d0072a8edeb34f8c5"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev3.tar.gz", "has_sig": false, "md5_digest": "457ab5b4cae497b3bfc6570da15fd565", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 156119, "upload_time": "2018-02-23T07:18:45", "upload_time_iso_8601": "2018-02-23T07:18:45.737511Z", "url": "https://files.pythonhosted.org/packages/4a/01/ee37147f578dbfbfd0eb5f7cd1e9741aa65753556d657510cc6f406714ae/pypsexec-0.0.1.dev3.tar.gz", "yanked": false}], "0.0.1.dev4": [{"comment_text": "", "digests": {"md5": "4f8999bd004e5293b376bd34c2291cc7", "sha256": "20e28dad48f1fecbf9cccb2b1897d156227222021195a27e6c15248a29b9992d"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev4-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "4f8999bd004e5293b376bd34c2291cc7", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 158144, "upload_time": "2018-02-24T06:38:20", "upload_time_iso_8601": "2018-02-24T06:38:20.777640Z", "url": "https://files.pythonhosted.org/packages/32/7f/7687808d6b78c17c71d7974fe09de8452ee7019163598f212a7896482e60/pypsexec-0.0.1.dev4-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "44db2cd81dda1adb5dd41b6f69663fca", "sha256": "2c13e7449cfe8a04b68e0f289ca008150ae550d5c73619502a947ad51204af56"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev4.tar.gz", "has_sig": false, "md5_digest": "44db2cd81dda1adb5dd41b6f69663fca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 155819, "upload_time": "2018-02-24T06:38:23", "upload_time_iso_8601": "2018-02-24T06:38:23.516906Z", "url": "https://files.pythonhosted.org/packages/7a/2d/2be160c6c104e157d42652f45cab1eb8689a1f029546dcc0d74981682aa4/pypsexec-0.0.1.dev4.tar.gz", "yanked": false}], "0.0.1.dev5": [{"comment_text": "", "digests": {"md5": "9d06fe3fc27260eb24e4691a25b98f4f", "sha256": "934128fde5d4cb787e25a63c4247d4f498249fbf2affa59865842f4e81ae14df"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev5-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "9d06fe3fc27260eb24e4691a25b98f4f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 159170, "upload_time": "2018-02-26T05:57:59", "upload_time_iso_8601": "2018-02-26T05:57:59.182856Z", "url": "https://files.pythonhosted.org/packages/cc/65/dd29b58f63757c08845d0217294c5e584ff0cb9f3a3cf3da7f340e5c0b90/pypsexec-0.0.1.dev5-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6984444dd763e5547917d2af4daaa13a", "sha256": "d8cad8837d5334946ae9075d0d13f66162a85e190c0f0ff320a800e4026a7425"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev5.tar.gz", "has_sig": false, "md5_digest": "6984444dd763e5547917d2af4daaa13a", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 156814, "upload_time": "2018-02-26T05:58:01", "upload_time_iso_8601": "2018-02-26T05:58:01.174673Z", "url": "https://files.pythonhosted.org/packages/fc/5a/9a384eebae127cd5c9899877200dadfe93c784e9f466fa34502cb0db62eb/pypsexec-0.0.1.dev5.tar.gz", "yanked": false}], "0.0.1.dev6": [{"comment_text": "", "digests": {"md5": "a5cc65c2c15f4d41fe9fcdfa16196b8f", "sha256": "90a10ca209920dcdf6d8f5c08389d7735db88ca7e2afbd5e5b6a5ca671fe61ce"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev6-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a5cc65c2c15f4d41fe9fcdfa16196b8f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 159050, "upload_time": "2018-02-26T21:52:25", "upload_time_iso_8601": "2018-02-26T21:52:25.999441Z", "url": "https://files.pythonhosted.org/packages/0f/8c/b2e229b1b62b03d425dd5a7620b1f9b8cd897548e68ec89a93f4ab528ebc/pypsexec-0.0.1.dev6-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1c60eb20bcae56f2155949b61c3c6fce", "sha256": "a437fc89755ea25fb8acacffc8b6dc0ab02a8bc40d44b1f3865dbec5fc995d3b"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev6.tar.gz", "has_sig": false, "md5_digest": "1c60eb20bcae56f2155949b61c3c6fce", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 156688, "upload_time": "2018-02-26T21:52:27", "upload_time_iso_8601": "2018-02-26T21:52:27.804074Z", "url": "https://files.pythonhosted.org/packages/85/c7/487e773e32d7e46537f294aee3d6205a06205d6340574cd5928096b08a66/pypsexec-0.0.1.dev6.tar.gz", "yanked": false}], "0.0.1.dev7": [{"comment_text": "", "digests": {"md5": "db508c8865ac2db7c8fda9a3b3dfaeda", "sha256": "1b22f001ff367927ba4104df4be7eaea49aee77ec89ebad9f46f7ebc328f3457"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev7-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "db508c8865ac2db7c8fda9a3b3dfaeda", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 159423, "upload_time": "2018-03-06T23:28:56", "upload_time_iso_8601": "2018-03-06T23:28:56.163001Z", "url": "https://files.pythonhosted.org/packages/81/94/c55a0b6278fb67effff552b9b68a106a3ad066223629eed53ff9ef36db44/pypsexec-0.0.1.dev7-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0bf6230983244458d77b2c62b986ed26", "sha256": "a51298f2d4547f634ca773b60079431b357acfb7cb63362ba45e796ee31e6505"}, "downloads": -1, "filename": "pypsexec-0.0.1.dev7.tar.gz", "has_sig": false, "md5_digest": "0bf6230983244458d77b2c62b986ed26", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 157031, "upload_time": "2018-03-06T23:28:58", "upload_time_iso_8601": "2018-03-06T23:28:58.456401Z", "url": "https://files.pythonhosted.org/packages/9a/f7/0978b7927cbfa915bf3bd6cd3cdd2fe4eeb43c9f01cba159f76d5bbd9310/pypsexec-0.0.1.dev7.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "e3a5e4d4346328a8e31b1fdff2b3d118", "sha256": "1fe8c02e93a51428206528d6970ce9c6de48662ee2077bc05d1489e75a6cedd4"}, "downloads": -1, "filename": "pypsexec-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "e3a5e4d4346328a8e31b1fdff2b3d118", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 159302, "upload_time": "2018-03-07T00:43:40", "upload_time_iso_8601": "2018-03-07T00:43:40.319893Z", "url": "https://files.pythonhosted.org/packages/0e/10/d697f6352984c96288497bcc4d64bfdafbab33660cb7adc6149194ee1059/pypsexec-0.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ba41f21f7b49d2c518fe0a22629e82ee", "sha256": "0d4c54dfba4082ccd2ebb56c7ea7368b2cd533e2722838af0bf7fc9d7afa785d"}, "downloads": -1, "filename": "pypsexec-0.1.0.tar.gz", "has_sig": false, "md5_digest": "ba41f21f7b49d2c518fe0a22629e82ee", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 156994, "upload_time": "2018-03-07T00:43:42", "upload_time_iso_8601": "2018-03-07T00:43:42.699271Z", "url": "https://files.pythonhosted.org/packages/52/1f/05fb1a0cfaebc48d339be88d2c5bf312f59c90b661862cbd468047da4d90/pypsexec-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e3a5e4d4346328a8e31b1fdff2b3d118", "sha256": "1fe8c02e93a51428206528d6970ce9c6de48662ee2077bc05d1489e75a6cedd4"}, "downloads": -1, "filename": "pypsexec-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "e3a5e4d4346328a8e31b1fdff2b3d118", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 159302, "upload_time": "2018-03-07T00:43:40", "upload_time_iso_8601": "2018-03-07T00:43:40.319893Z", "url": "https://files.pythonhosted.org/packages/0e/10/d697f6352984c96288497bcc4d64bfdafbab33660cb7adc6149194ee1059/pypsexec-0.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ba41f21f7b49d2c518fe0a22629e82ee", "sha256": "0d4c54dfba4082ccd2ebb56c7ea7368b2cd533e2722838af0bf7fc9d7afa785d"}, "downloads": -1, "filename": "pypsexec-0.1.0.tar.gz", "has_sig": false, "md5_digest": "ba41f21f7b49d2c518fe0a22629e82ee", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 156994, "upload_time": "2018-03-07T00:43:42", "upload_time_iso_8601": "2018-03-07T00:43:42.699271Z", "url": "https://files.pythonhosted.org/packages/52/1f/05fb1a0cfaebc48d339be88d2c5bf312f59c90b661862cbd468047da4d90/pypsexec-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:59:01 2020"}