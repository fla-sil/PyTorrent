{"info": {"author": "Ronaldo Webb", "author_email": "mobil3.g3nius@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Intended Audience :: Developers", "Intended Audience :: End Users/Desktop", "Intended Audience :: System Administrators", "Programming Language :: Python", "Topic :: Communications :: Email", "Topic :: Software Development :: Bug Tracking"], "description": "============\r\nIntroduction\r\n============\r\n\r\nSometime in the development or implementation we encounter things to be processed by different specialization. For example, we receive a CSV file that is intended from importing to a table. We found out that the CSV file is not formatted to what the table can consume. Thus, we need to do two thing:\r\n\r\n1. Transform or create a CSV file to meet the table requirement based on the CSV file at hand.\r\n2. Wrap the contents of the transformed and newly created CSV to create the SQL statements that can be readily run against a database.\r\n\r\nAs we can see above, these then can be created by two different individuals one that is specialized in manipulating CSV file and knowledge in generating SQL scripts. Addition, these two thing must be run in sequence and not on the other way around. \r\n\r\nThis is the idea around the conveyor that the work is done in sequence and can use some tools.\r\n\r\n============\r\nInstallation\r\n============\r\n\r\nThe installation is as easy as downloading the conveyor-<version>-py3-none-any.whl package and run the following command in the download folder in the command line:\r\n\r\n**Command 1. Using pip module for installation**\r\n\r\nIf you have the wheel package\r\n::\r\n\r\n  python -m pip install mg_conveyor-<version>-py3-none-any.whl\r\n\r\nOr simply\r\n\r\n::\r\n\r\n  python -m pip install mg-conveyor\r\n\r\n==================\r\nUsing the conveyor \r\n==================\r\n\r\n**Conveyor** is not intended be used as a standalone command but a least a plugin must be made available to it to process. \r\n\r\nThe ISequencialPlugin Interface\r\n-------------------------------\r\n\r\nAs its name suggests it is executed based on sequence. This plugin needs the following methods to be implemented:\r\n\r\nMethods to be implemented\r\n^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n\tdef sequence(self)\r\n\tdef process(self, identity, context, *args, **kwargs)\r\n\r\nThe **sequence method** must return an integer that will dictate sequence on when it must be executed.\r\n\r\n.. note:: **Every plugin** must return a different sequence number.\r\n\r\nThe **process method** is the entrypoint for each plugin and this is where our plugin logic must reside. This method has two important parameters namely identity and context. Currently the identity is the name of the plugin (i.e. defined in the yapsy configuration file that is particularly the **Name** attribute) and the context contains some information about the plugin. Also this method must return one of the predefined status.\r\n\r\n**ISequencialPlugin Return Status**\r\n\r\n======================= ======================================================\r\nStatus                  Description\r\n======================= ======================================================\r\nSTATUS_SUCCESS\t\t\tFinished successfully.\r\nSTATUS_FAILED\t\t\tError encountered also abort the execution of conveyor\r\nSTATUS_ABORT            Abort the execution of conveyor.\r\nSTATUS_RETRY            The plugin is requesting an interactive retry.\r\nSTATUS_CONFIRM_RETRY    The user responded Y to the interactive retry.\r\nSTATUS_CONFIRM_ABORT    The user responded N to the interactive retry.\r\nSTATUS_SKIPPED          Skipped plugin\r\nSTATUS_STARTED          Plugin is currently started.\r\n======================= ======================================================\r\n\r\n**Example 1. Simple Plugin Implementation**\r\n\r\n::\r\n\r\n\timport mg_conveyor as conveyor\r\n\tclass PluginOne(conveyor.ISequencialPlugin):\r\n\t    def sequence(self):\r\n\t        return 100\r\n\t    def process(self, identity, context, *args, **kwargs):\r\n\t    \tprint(\"Hello Worlds.\")\r\n\t        return conveyor.STATUS_SUCCESS\r\n\r\nUsing the context Parameter\r\n^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nThe context parameter contains some information about the plugin like its status (i.e. CONTEXT_KEY_STATUS) and its instance (i.e. CONTEXT_KEY_PLUGIN_OBJECT). This parameter is just a simple dictionary. By default each plugin has its own context inside the context with the key as its identity (i.e. context[identity]). Thus, to get the plugin object of the current plugin we should access it like the following snippet inside the process method.\r\n\r\n::\r\n\r\n\tpluginObj = context[identity][CONTEXT_KEY_PLUGIN_OBJECT]\r\n\r\n**Pre-defined Context Keys per identity**\r\n\r\n========================= ============================================================\r\nStatus                    Description\r\n========================= ============================================================\r\nCONTEXT_KEY_STATUS\t\t  Contains the numerical equivalent of the **ISequencialPlugin Return Status**.\r\nCONTEXT_KEY_PLUGIN_OBJECT The instance of the plugin associated with the identity.\r\n========================= ============================================================\r\n\r\nThe context has another purpose that it can hold custom plugin information. To add a new entry to the context it is better to add it under the identity key. This can be done by the snippet below (i.e. inside the process method):\r\n\r\n::\r\n\r\n\tplugin_context = context[identity]\r\n\tplugin_context['item1']='This is item 1'\r\n\tplugin_context['item2']='This is item 2'\r\n\r\nMore over this context is shared by all the plugins loaded by the conveyor. Therefore, we can use the context to pass information between plugins. For example the result of the first plugin can be stored in the context and that item will be processed by the following plugin.\r\n\r\nYapsy Configuration File\r\n------------------------\r\n\r\nOnce the plugin is ready we must create a configuration file. Since we are using yapsy the sample configuration file is as follows:\r\n\r\n::\r\n\r\n\t[Core]\r\n\tName = Hello World\r\n\tModule = helloworld\r\n\r\n\t[Documentation]\r\n\tAuthor = Ronaldo Webb\r\n\tVersion = 0.1\r\n\tWebsite = http://www.ronella.xyz\r\n\tDescription = Test only\r\n\r\n.. note:: The **Name attribute** in this configuration file is the one being used as the **identity parameter** in the process method.\r\n\r\nSee `yapsy-plugin`_ for more information about the content of the configuration file.\r\n\r\n.. _yapsy-plugin: http://yapsy.sourceforge.net/PluginFileLocator.html\r\n\r\nThe IUtilityPlugin Interface\r\n-------------------------------\r\n\r\nThis plugin is the one that can be shared by all ISequencialPlugin implementations. Thus, we can think of the IUtilityPlugin implementation as a **tool** that the ISequencialPlugin (i.e. activing as a worker) can use to do its job properly. This tool is always available in the context and only has one method to be implemented. \r\n\r\nMethod to be implemented\r\n^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n\tdef use(self, *args, **kwargs)\r\n\r\nThe **use method** must contain the implmentation on what the ISequencialPlugin implementaion demands it to do according to what it's purpose as a tool. It can return any type therefore the a proper documentation of the return type is necessary.\r\n\r\nBuilt-in Properties\r\n^^^^^^^^^^^^^^^^^^^\r\n\r\nThe IUtilityPlugin has built-in properties as we can see in the following table:\r\n\r\n============ ==========================================================================================\r\nProperty     Description\r\n============ ==========================================================================================\r\nidentity     Contains the identity of the plugin (i.e. the Name attribute in yapsy configuration file.)\r\ncontext      The context shared by all the plugins.\r\nlocalContext This is equals to context[identity].\r\n============ ==========================================================================================\r\n\r\nAcquiring IUtilityPlugin from context\r\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nTo acquire an instance of the IUtilityPlugin we must know its identity (i.e. Name attribute in yapsy configuraiton file.). Once we have the instance we can call it's use method.\r\n\r\n**Example 2: Acquiring IUtilityPlugin**\r\n\r\nIf have **Utility** as the identity then in the process method of the ISequencialPlugin implementation we can retrieve its instance like in the snippet below:\r\n\r\n::\r\n\r\n    def process(self, identity, context, *args, **kwargs):\r\n        \r\n        utilObj = context['Utility'][conveyor.CONTEXT_KEY_PLUGIN_OBJECT].use()\r\n\r\n.. note:: We can pass any number of arguments to the use method.\r\n\r\nStarting The Conveyor\r\n---------------------\r\n\r\nOnce the plugin is working fine and the configuration file were created, we can now create an implmenetation to start the conveyor. The first thing that we must do is to instantiate the Conveyor class then load the plugins and finally start it. See the sample snippet below:\r\n\r\n**Example 3: Starting the Conveyor**\r\n\r\n::\r\n\r\n\tconv = conveyor.Conveyor()\r\n\tconv.loadPlugins([\"plugins\"])\r\n\tconv.start()\r\n\r\n.. note:: In the **loadPlugins method** we must pass in an **array of locations** of the plugins.\r\n\r\n========\r\nAppendix\r\n========\r\n\r\nComplete Hello World Implementation\r\n-----------------------------------\r\n\r\nplugins/helloworld_plugin.py\r\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n\timport mg_conveyor as conveyor\r\n\tclass PluginOne(conveyor.ISequencialPlugin):\r\n\t    def sequence(self):\r\n\t        return 100\r\n\t    def process(self, identity, context, *args, **kwargs):\r\n\t    \tprint(\"Hello World.\")\r\n\t        return conveyor.STATUS_SUCCESS\r\n\r\nplugins/helloworld.yapsy-plugin\r\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n\t[Core]\r\n\tName = Hello World\r\n\tModule = helloworld_plugin\r\n\r\n\t[Documentation]\r\n\tAuthor = Ronaldo Webb\r\n\tVersion = 0.1\r\n\tWebsite = http://www.ronella.xyz\r\n\tDescription = Test only\r\n\r\nhelloworld.py\r\n^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n    import mg_conveyor as conveyor\r\n    \r\n    if __name__ == '__main__':\r\n    \r\n        conv=conveyor.Conveyor()\r\n        conv.loadPlugins([\"plugins\"])\r\n        conv.start()      \r\n\r\nSample Context Usage\r\n--------------------\r\n\r\nplugins/plugin1.py\r\n^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n\timport mg_conveyor as conveyor\r\n\tclass Plugin(conveyor.ISequencialPlugin):\r\n\t    def sequence(self):\r\n\t        return 100\r\n\t    \r\n\t    def process(self, identity, context, *args, **kwargs):\r\n\t        plugin_context = context[identity]\r\n\t        \r\n\t        plugin_context['Message'] = \"From plugin 1\"\r\n\t        \r\n\t        return conveyor.STATUS_SUCCESS\r\n\r\nplugins/plugin1.yapsy-plugin\r\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n\t[Core]\r\n\tName = Plugin1\r\n\tModule = plugin1\r\n\r\n\t[Documentation]\r\n\tAuthor = Ronaldo Webb\r\n\tVersion = 0.1\r\n\tWebsite = http://www.ronella.xyz\r\n\tDescription = Test only\r\n\r\nplugins/plugin2.py\r\n^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n\timport mg_conveyor as conveyor\r\n\tclass Plugin(conveyor.ISequencialPlugin):\r\n\t    def sequence(self):\r\n\t        return 200\r\n\t    \r\n\t    def process(self, identity, context, *args, **kwargs):\r\n\t        \r\n\t        #Plugin1 is the Name found in plugin1.yapsy-plugin\r\n\t        plugin1_context = context['Plugin1']\r\n\t        \r\n\t        \r\n\t        print(\"I'm in plugin 2...\")\r\n\t        print(\"Message from plugin 1: \" + plugin1_context['Message'])\r\n\t        return conveyor.STATUS_SUCCESS\r\n\r\nplugins/plugin2.yapsy-plugin\r\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n\t[Core]\r\n\tName = Plugin2\r\n\tModule = plugin2\r\n\r\n\t[Documentation]\r\n\tAuthor = Ronaldo Webb\r\n\tVersion = 0.1\r\n\tWebsite = http://www.ronella.xyz\r\n\tDescription = Test only\r\n\r\ncontext_usage.py\r\n^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n\timport mg_conveyor as conveyor\r\n\r\n\tif __name__ == '__main__':\r\n\r\n\t    conv=conveyor.Conveyor()\r\n\t    conv.loadPlugins([\"plugins\"])\r\n\t    conv.start()      \r\n\r\nPassing Parameter to the Process Method\r\n---------------------------------------\r\n\r\nplugins/parameter.py\r\n^^^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n    import mg_conveyor as conveyor\r\n    class PluginOne(conveyor.ISequencialPlugin):\r\n\r\n        def sequence(self):\r\n            return 100\r\n\t    \r\n        def process(self, identity, context, *args, **kwargs):\r\n            print(\"Argument 1: \" + args[0])\r\n            print(\"Arguemnt 2: \" + args[1])\r\n            print(\"Parameter 1: \" + kwargs['param1'])\r\n            print(\"Parameter 2: \" + kwargs['param2'])\r\n            \r\n            return conveyor.STATUS_SUCCESS\r\n\r\nplugins/parameter.yapsy-plugin\r\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n\t[Core]\r\n\tName = Parameter Passing\r\n\tModule = parameter\r\n\r\n\t[Documentation]\r\n\tAuthor = Ronaldo Webb\r\n\tVersion = 0.1\r\n\tWebsite = http://www.ronella.xyz\r\n\tDescription = Test only\r\n\r\nprocess_parameter.py\r\n^^^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n    import mg_conveyor as conveyor\r\n    \r\n    if __name__ == '__main__':\r\n    \r\n        conv=conveyor.Conveyor()\r\n        conv.loadPlugins([\"plugins\"])\r\n        conv.start(\"arg0\"\r\n            , \"arg1\"\r\n            , param1=\"This is parameter 1\"\r\n            , param2=\"This is parameter 2\") \r\n\r\nBasic Sample for using IUtilityPlugin\r\n-------------------------------------\r\n\r\nutility.py\r\n^^^^^^^^^^\r\n\r\n::\r\n\r\n    import mg_conveyor as conveyor\r\n    \r\n    class Utility(conveyor.IUtilityPlugin):\r\n    \r\n        def __init__(self):\r\n            super().__init__()\r\n        \r\n        def use(self, *args, **kwargs):\r\n            \r\n            self.localContext['Message'] = \"I'm in Utility plugin\"\r\n            return \"This is a test.\"\r\n\r\nutility.yapsy-plugin\r\n^^^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n    [Core]\r\n    Name = Utility\r\n    Module = utility\r\n    \r\n    [Documentation]\r\n    Author = Ronaldo Webb\r\n    Version = 0.1\r\n    Website = http://www.ronella.xyz\r\n    Description = Test only\r\n\r\nsequence.py\r\n^^^^^^^^^^^\r\n\r\n::\r\n\r\n    import mg_conveyor as conveyor\r\n    \r\n    class PluginOne(conveyor.ISequencialPlugin):\r\n        def sequence(self):\r\n            return 100\r\n        \r\n        def process(self, identity, context, *args, **kwargs):\r\n            \r\n            utilCtx = context['Utility']\r\n            utilOutput = utilCtx[conveyor.CONTEXT_KEY_PLUGIN_OBJECT].use()\r\n            \r\n            if 'util_message' in kwargs:\r\n                kwargs['util_message'](utilCtx['Message'])\r\n                \r\n            if 'util_output' in kwargs:\r\n                kwargs['util_output'](utilOutput)\r\n            \r\n            return conveyor.STATUS_SUCCESS\r\n\r\nsequence.yapsy-plugin\r\n^^^^^^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n    [Core]\r\n    Name = Sequence\r\n    Module = sequence\r\n    \r\n    [Documentation]\r\n    Author = Ronaldo Webb\r\n    Version = 0.1\r\n    Website = http://www.ronella.xyz\r\n    Description = Test only\r\n\r\nutility_usage.py\r\n^^^^^^^^^^^^^^^^\r\n\r\n::\r\n\r\n\timport mg_conveyor as conveyor\r\n\r\n\tif __name__ == '__main__':\r\n\r\n\t    conv=conveyor.Conveyor()\r\n\t    conv.loadPlugins([\"plugins\"])\r\n\t    conv.start()", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://sourceforge.net/projects/mobgenconveyor", "keywords": "tool plugin utility development dev", "license": "UNKNOWN", "maintainer": "", "maintainer_email": "", "name": "mg-conveyor", "package_url": "https://pypi.org/project/mg-conveyor/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/mg-conveyor/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://sourceforge.net/projects/mobgenconveyor"}, "release_url": "https://pypi.org/project/mg-conveyor/1.0.0/", "requires_dist": null, "requires_python": null, "summary": "A tool for having a sequential execution of plugins", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>Sometime in the development or implementation we encounter things to be processed by different specialization. For example, we receive a CSV file that is intended from importing to a table. We found out that the CSV file is not formatted to what the table can consume. Thus, we need to do two thing:</p>\n<ol>\n<li>Transform or create a CSV file to meet the table requirement based on the CSV file at hand.</li>\n<li>Wrap the contents of the transformed and newly created CSV to create the SQL statements that can be readily run against a database.</li>\n</ol>\n<p>As we can see above, these then can be created by two different individuals one that is specialized in manipulating CSV file and knowledge in generating SQL scripts. Addition, these two thing must be run in sequence and not on the other way around.</p>\n<p>This is the idea around the conveyor that the work is done in sequence and can use some tools.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>The installation is as easy as downloading the conveyor-&lt;version&gt;-py3-none-any.whl package and run the following command in the download folder in the command line:</p>\n<p><strong>Command 1. Using pip module for installation</strong></p>\n<p>If you have the wheel package</p>\n<pre>python -m pip install mg_conveyor-&lt;version&gt;-py3-none-any.whl\n</pre>\n<p>Or simply</p>\n<pre>python -m pip install mg-conveyor\n</pre>\n</div>\n<div id=\"using-the-conveyor\">\n<h2>Using the conveyor</h2>\n<p><strong>Conveyor</strong> is not intended be used as a standalone command but a least a plugin must be made available to it to process.</p>\n<div id=\"the-isequencialplugin-interface\">\n<h3>The ISequencialPlugin Interface</h3>\n<p>As its name suggests it is executed based on sequence. This plugin needs the following methods to be implemented:</p>\n<div id=\"methods-to-be-implemented\">\n<h4>Methods to be implemented</h4>\n<pre>def sequence(self)\ndef process(self, identity, context, *args, **kwargs)\n</pre>\n<p>The <strong>sequence method</strong> must return an integer that will dictate sequence on when it must be executed.</p>\n<div>\n<p>Note</p>\n<p><strong>Every plugin</strong> must return a different sequence number.</p>\n</div>\n<p>The <strong>process method</strong> is the entrypoint for each plugin and this is where our plugin logic must reside. This method has two important parameters namely identity and context. Currently the identity is the name of the plugin (i.e. defined in the yapsy configuration file that is particularly the <strong>Name</strong> attribute) and the context contains some information about the plugin. Also this method must return one of the predefined status.</p>\n<p><strong>ISequencialPlugin Return Status</strong></p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Status</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>STATUS_SUCCESS</td>\n<td>Finished successfully.</td>\n</tr>\n<tr><td>STATUS_FAILED</td>\n<td>Error encountered also abort the execution of conveyor</td>\n</tr>\n<tr><td>STATUS_ABORT</td>\n<td>Abort the execution of conveyor.</td>\n</tr>\n<tr><td>STATUS_RETRY</td>\n<td>The plugin is requesting an interactive retry.</td>\n</tr>\n<tr><td>STATUS_CONFIRM_RETRY</td>\n<td>The user responded Y to the interactive retry.</td>\n</tr>\n<tr><td>STATUS_CONFIRM_ABORT</td>\n<td>The user responded N to the interactive retry.</td>\n</tr>\n<tr><td>STATUS_SKIPPED</td>\n<td>Skipped plugin</td>\n</tr>\n<tr><td>STATUS_STARTED</td>\n<td>Plugin is currently started.</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example 1. Simple Plugin Implementation</strong></p>\n<pre>import mg_conveyor as conveyor\nclass PluginOne(conveyor.ISequencialPlugin):\n    def sequence(self):\n        return 100\n    def process(self, identity, context, *args, **kwargs):\n        print(\"Hello Worlds.\")\n        return conveyor.STATUS_SUCCESS\n</pre>\n</div>\n<div id=\"using-the-context-parameter\">\n<h4>Using the context Parameter</h4>\n<p>The context parameter contains some information about the plugin like its status (i.e. CONTEXT_KEY_STATUS) and its instance (i.e. CONTEXT_KEY_PLUGIN_OBJECT). This parameter is just a simple dictionary. By default each plugin has its own context inside the context with the key as its identity (i.e. context[identity]). Thus, to get the plugin object of the current plugin we should access it like the following snippet inside the process method.</p>\n<pre>pluginObj = context[identity][CONTEXT_KEY_PLUGIN_OBJECT]\n</pre>\n<p><strong>Pre-defined Context Keys per identity</strong></p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Status</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>CONTEXT_KEY_STATUS</td>\n<td>Contains the numerical equivalent of the <strong>ISequencialPlugin Return Status</strong>.</td>\n</tr>\n<tr><td>CONTEXT_KEY_PLUGIN_OBJECT</td>\n<td>The instance of the plugin associated with the identity.</td>\n</tr>\n</tbody>\n</table>\n<p>The context has another purpose that it can hold custom plugin information. To add a new entry to the context it is better to add it under the identity key. This can be done by the snippet below (i.e. inside the process method):</p>\n<pre>plugin_context = context[identity]\nplugin_context['item1']='This is item 1'\nplugin_context['item2']='This is item 2'\n</pre>\n<p>More over this context is shared by all the plugins loaded by the conveyor. Therefore, we can use the context to pass information between plugins. For example the result of the first plugin can be stored in the context and that item will be processed by the following plugin.</p>\n</div>\n</div>\n<div id=\"yapsy-configuration-file\">\n<h3>Yapsy Configuration File</h3>\n<p>Once the plugin is ready we must create a configuration file. Since we are using yapsy the sample configuration file is as follows:</p>\n<pre>[Core]\nName = Hello World\nModule = helloworld\n\n[Documentation]\nAuthor = Ronaldo Webb\nVersion = 0.1\nWebsite = http://www.ronella.xyz\nDescription = Test only\n</pre>\n<div>\n<p>Note</p>\n<p>The <strong>Name attribute</strong> in this configuration file is the one being used as the <strong>identity parameter</strong> in the process method.</p>\n</div>\n<p>See <a href=\"http://yapsy.sourceforge.net/PluginFileLocator.html\" rel=\"nofollow\">yapsy-plugin</a> for more information about the content of the configuration file.</p>\n</div>\n<div id=\"the-iutilityplugin-interface\">\n<h3>The IUtilityPlugin Interface</h3>\n<p>This plugin is the one that can be shared by all ISequencialPlugin implementations. Thus, we can think of the IUtilityPlugin implementation as a <strong>tool</strong> that the ISequencialPlugin (i.e. activing as a worker) can use to do its job properly. This tool is always available in the context and only has one method to be implemented.</p>\n<div id=\"method-to-be-implemented\">\n<h4>Method to be implemented</h4>\n<pre>def use(self, *args, **kwargs)\n</pre>\n<p>The <strong>use method</strong> must contain the implmentation on what the ISequencialPlugin implementaion demands it to do according to what it\u2019s purpose as a tool. It can return any type therefore the a proper documentation of the return type is necessary.</p>\n</div>\n<div id=\"built-in-properties\">\n<h4>Built-in Properties</h4>\n<p>The IUtilityPlugin has built-in properties as we can see in the following table:</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>Property</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>identity</td>\n<td>Contains the identity of the plugin (i.e. the Name attribute in yapsy configuration file.)</td>\n</tr>\n<tr><td>context</td>\n<td>The context shared by all the plugins.</td>\n</tr>\n<tr><td>localContext</td>\n<td>This is equals to context[identity].</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div id=\"acquiring-iutilityplugin-from-context\">\n<h4>Acquiring IUtilityPlugin from context</h4>\n<p>To acquire an instance of the IUtilityPlugin we must know its identity (i.e. Name attribute in yapsy configuraiton file.). Once we have the instance we can call it\u2019s use method.</p>\n<p><strong>Example 2: Acquiring IUtilityPlugin</strong></p>\n<p>If have <strong>Utility</strong> as the identity then in the process method of the ISequencialPlugin implementation we can retrieve its instance like in the snippet below:</p>\n<pre>def process(self, identity, context, *args, **kwargs):\n\n    utilObj = context['Utility'][conveyor.CONTEXT_KEY_PLUGIN_OBJECT].use()\n</pre>\n<div>\n<p>Note</p>\n<p>We can pass any number of arguments to the use method.</p>\n</div>\n</div>\n</div>\n<div id=\"starting-the-conveyor\">\n<h3>Starting The Conveyor</h3>\n<p>Once the plugin is working fine and the configuration file were created, we can now create an implmenetation to start the conveyor. The first thing that we must do is to instantiate the Conveyor class then load the plugins and finally start it. See the sample snippet below:</p>\n<p><strong>Example 3: Starting the Conveyor</strong></p>\n<pre>conv = conveyor.Conveyor()\nconv.loadPlugins([\"plugins\"])\nconv.start()\n</pre>\n<div>\n<p>Note</p>\n<p>In the <strong>loadPlugins method</strong> we must pass in an <strong>array of locations</strong> of the plugins.</p>\n</div>\n</div>\n</div>\n<div id=\"appendix\">\n<h2>Appendix</h2>\n<div id=\"complete-hello-world-implementation\">\n<h3>Complete Hello World Implementation</h3>\n<div id=\"plugins-helloworld-plugin-py\">\n<h4>plugins/helloworld_plugin.py</h4>\n<pre>import mg_conveyor as conveyor\nclass PluginOne(conveyor.ISequencialPlugin):\n    def sequence(self):\n        return 100\n    def process(self, identity, context, *args, **kwargs):\n        print(\"Hello World.\")\n        return conveyor.STATUS_SUCCESS\n</pre>\n</div>\n<div id=\"plugins-helloworld-yapsy-plugin\">\n<h4>plugins/helloworld.yapsy-plugin</h4>\n<pre>[Core]\nName = Hello World\nModule = helloworld_plugin\n\n[Documentation]\nAuthor = Ronaldo Webb\nVersion = 0.1\nWebsite = http://www.ronella.xyz\nDescription = Test only\n</pre>\n</div>\n<div id=\"helloworld-py\">\n<h4>helloworld.py</h4>\n<pre>import mg_conveyor as conveyor\n\nif __name__ == '__main__':\n\n    conv=conveyor.Conveyor()\n    conv.loadPlugins([\"plugins\"])\n    conv.start()\n</pre>\n</div>\n</div>\n<div id=\"sample-context-usage\">\n<h3>Sample Context Usage</h3>\n<div id=\"plugins-plugin1-py\">\n<h4>plugins/plugin1.py</h4>\n<pre>import mg_conveyor as conveyor\nclass Plugin(conveyor.ISequencialPlugin):\n    def sequence(self):\n        return 100\n\n    def process(self, identity, context, *args, **kwargs):\n        plugin_context = context[identity]\n\n        plugin_context['Message'] = \"From plugin 1\"\n\n        return conveyor.STATUS_SUCCESS\n</pre>\n</div>\n<div id=\"plugins-plugin1-yapsy-plugin\">\n<h4>plugins/plugin1.yapsy-plugin</h4>\n<pre>[Core]\nName = Plugin1\nModule = plugin1\n\n[Documentation]\nAuthor = Ronaldo Webb\nVersion = 0.1\nWebsite = http://www.ronella.xyz\nDescription = Test only\n</pre>\n</div>\n<div id=\"plugins-plugin2-py\">\n<h4>plugins/plugin2.py</h4>\n<pre>import mg_conveyor as conveyor\nclass Plugin(conveyor.ISequencialPlugin):\n    def sequence(self):\n        return 200\n\n    def process(self, identity, context, *args, **kwargs):\n\n        #Plugin1 is the Name found in plugin1.yapsy-plugin\n        plugin1_context = context['Plugin1']\n\n\n        print(\"I'm in plugin 2...\")\n        print(\"Message from plugin 1: \" + plugin1_context['Message'])\n        return conveyor.STATUS_SUCCESS\n</pre>\n</div>\n<div id=\"plugins-plugin2-yapsy-plugin\">\n<h4>plugins/plugin2.yapsy-plugin</h4>\n<pre>[Core]\nName = Plugin2\nModule = plugin2\n\n[Documentation]\nAuthor = Ronaldo Webb\nVersion = 0.1\nWebsite = http://www.ronella.xyz\nDescription = Test only\n</pre>\n</div>\n<div id=\"context-usage-py\">\n<h4>context_usage.py</h4>\n<pre>import mg_conveyor as conveyor\n\nif __name__ == '__main__':\n\n    conv=conveyor.Conveyor()\n    conv.loadPlugins([\"plugins\"])\n    conv.start()\n</pre>\n</div>\n</div>\n<div id=\"passing-parameter-to-the-process-method\">\n<h3>Passing Parameter to the Process Method</h3>\n<div id=\"plugins-parameter-py\">\n<h4>plugins/parameter.py</h4>\n<pre>import mg_conveyor as conveyor\nclass PluginOne(conveyor.ISequencialPlugin):\n\n    def sequence(self):\n        return 100\n\n    def process(self, identity, context, *args, **kwargs):\n        print(\"Argument 1: \" + args[0])\n        print(\"Arguemnt 2: \" + args[1])\n        print(\"Parameter 1: \" + kwargs['param1'])\n        print(\"Parameter 2: \" + kwargs['param2'])\n\n        return conveyor.STATUS_SUCCESS\n</pre>\n</div>\n<div id=\"plugins-parameter-yapsy-plugin\">\n<h4>plugins/parameter.yapsy-plugin</h4>\n<pre>[Core]\nName = Parameter Passing\nModule = parameter\n\n[Documentation]\nAuthor = Ronaldo Webb\nVersion = 0.1\nWebsite = http://www.ronella.xyz\nDescription = Test only\n</pre>\n</div>\n<div id=\"process-parameter-py\">\n<h4>process_parameter.py</h4>\n<pre>import mg_conveyor as conveyor\n\nif __name__ == '__main__':\n\n    conv=conveyor.Conveyor()\n    conv.loadPlugins([\"plugins\"])\n    conv.start(\"arg0\"\n        , \"arg1\"\n        , param1=\"This is parameter 1\"\n        , param2=\"This is parameter 2\")\n</pre>\n</div>\n</div>\n<div id=\"basic-sample-for-using-iutilityplugin\">\n<h3>Basic Sample for using IUtilityPlugin</h3>\n<div id=\"utility-py\">\n<h4>utility.py</h4>\n<pre>import mg_conveyor as conveyor\n\nclass Utility(conveyor.IUtilityPlugin):\n\n    def __init__(self):\n        super().__init__()\n\n    def use(self, *args, **kwargs):\n\n        self.localContext['Message'] = \"I'm in Utility plugin\"\n        return \"This is a test.\"\n</pre>\n</div>\n<div id=\"utility-yapsy-plugin\">\n<h4>utility.yapsy-plugin</h4>\n<pre>[Core]\nName = Utility\nModule = utility\n\n[Documentation]\nAuthor = Ronaldo Webb\nVersion = 0.1\nWebsite = http://www.ronella.xyz\nDescription = Test only\n</pre>\n</div>\n<div id=\"sequence-py\">\n<h4>sequence.py</h4>\n<pre>import mg_conveyor as conveyor\n\nclass PluginOne(conveyor.ISequencialPlugin):\n    def sequence(self):\n        return 100\n\n    def process(self, identity, context, *args, **kwargs):\n\n        utilCtx = context['Utility']\n        utilOutput = utilCtx[conveyor.CONTEXT_KEY_PLUGIN_OBJECT].use()\n\n        if 'util_message' in kwargs:\n            kwargs['util_message'](utilCtx['Message'])\n\n        if 'util_output' in kwargs:\n            kwargs['util_output'](utilOutput)\n\n        return conveyor.STATUS_SUCCESS\n</pre>\n</div>\n<div id=\"sequence-yapsy-plugin\">\n<h4>sequence.yapsy-plugin</h4>\n<pre>[Core]\nName = Sequence\nModule = sequence\n\n[Documentation]\nAuthor = Ronaldo Webb\nVersion = 0.1\nWebsite = http://www.ronella.xyz\nDescription = Test only\n</pre>\n</div>\n<div id=\"utility-usage-py\">\n<h4>utility_usage.py</h4>\n<pre>import mg_conveyor as conveyor\n\nif __name__ == '__main__':\n\n    conv=conveyor.Conveyor()\n    conv.loadPlugins([\"plugins\"])\n    conv.start()\n</pre>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1407493, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "531654c18aa2e95ba23e2ad4acdd18c8", "sha256": "d9cac0efb86e936ae1aed81528c2eb93d021f99833d42c85e782aa5b44bf8606"}, "downloads": -1, "filename": "mg_conveyor-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "531654c18aa2e95ba23e2ad4acdd18c8", "packagetype": "bdist_wheel", "python_version": "3.4", "requires_python": null, "size": 12137, "upload_time": "2015-02-03T09:40:17", "upload_time_iso_8601": "2015-02-03T09:40:17.961777Z", "url": "https://files.pythonhosted.org/packages/f5/e2/abeee4e5f80c2040bfa47bfe516d661598113f10c2faad7011acfed00ee9/mg_conveyor-1.0.0-py3-none-any.whl", "yanked": false}], "1.0.0b": [{"comment_text": "", "digests": {"md5": "90210d0a2fce6b8fe21112dd48b10672", "sha256": "c6c9460e5792e9f3f3ac65d346eafc751aff2f3cbab9a45171443e849b3a2f93"}, "downloads": -1, "filename": "mg_conveyor-1.0.0b-py3-none-any.whl", "has_sig": false, "md5_digest": "90210d0a2fce6b8fe21112dd48b10672", "packagetype": "bdist_wheel", "python_version": "3.4", "requires_python": null, "size": 12154, "upload_time": "2015-02-03T09:22:04", "upload_time_iso_8601": "2015-02-03T09:22:04.805149Z", "url": "https://files.pythonhosted.org/packages/9b/3f/d35542c2d384f94498bf98f03b6c3bb136e95363297ae0197df4c8fd7a3a/mg_conveyor-1.0.0b-py3-none-any.whl", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "531654c18aa2e95ba23e2ad4acdd18c8", "sha256": "d9cac0efb86e936ae1aed81528c2eb93d021f99833d42c85e782aa5b44bf8606"}, "downloads": -1, "filename": "mg_conveyor-1.0.0-py3-none-any.whl", "has_sig": false, "md5_digest": "531654c18aa2e95ba23e2ad4acdd18c8", "packagetype": "bdist_wheel", "python_version": "3.4", "requires_python": null, "size": 12137, "upload_time": "2015-02-03T09:40:17", "upload_time_iso_8601": "2015-02-03T09:40:17.961777Z", "url": "https://files.pythonhosted.org/packages/f5/e2/abeee4e5f80c2040bfa47bfe516d661598113f10c2faad7011acfed00ee9/mg_conveyor-1.0.0-py3-none-any.whl", "yanked": false}], "timestamp": "Fri May  8 00:55:28 2020"}