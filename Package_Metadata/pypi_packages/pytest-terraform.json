{"info": {"author": "Kapil Thangavelu", "author_email": "kapilt@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8", "Topic :: Software Development :: Testing", "Topic :: System :: Distributed Computing", "Topic :: System :: Systems Administration"], "description": "# Introduction\n\npytest_terraform is a pytest plugin that enables executing terraform\nto provision infrastructure in a unit/functional test as a fixture.\n\nThis plugin features uses a fixture factory pattern to enable dynamic\nconstruction of fixtures as either as test decorators or module level\nvariables.\n\n\n## Philosophy\n\nThe usage/philosophy of this plugin is based on using flight recording\nfor unit tests against cloud infrastructure. In flight recording rather\nthan mocking or stubbing infrastructure, actual resources are created\nand interacted with with responses recorded, with those responses\nsubsequently replayed for fast test execution. Beyond the fidelity\noffered, this also enables these tests to be executed/re-recorded against\nlive infrastructure for additional functional/release testing.\n\n\n## Decorator Usage\n\n```python\nfrom pytest_terraform import terraform\nfrom boto3 import Session\n\n@terraform('aws_sqs')\ndef test_sqs(aws_sqs):\n   queue_url = aws_sqs['test_queue.queue_url']\n   print(queue_url)\n\n\ndef test_sqs_deliver(aws_sqs):\n   # once a fixture has been defined with a decorator\n   # it can be reused in the same module by name\n   pass\n\n@terraform('aws_sqs')\ndef test_sqs_dlq(aws_sqs):\n   # or referenced again via decorator, if redefined\n   # with decorator the fixture parameters much match.\n   pass\n```\n\n*Note* the fixture name should match the terraform module name.\n\n## Variable Usage\n\n```python\nfrom pytest_terraform import terraform\n\ngcp_pub_sub = terraform.fixture('gcp_pub_sub')\n\ndef test_queue(gcp_pub_sub):\n\tprint(gcp_pub_sub.resources)\n```\n\n*Note* the fixture variable name should match the terraform module name.\n\n## Fixture Usage\n\nThe pytest fixtures have access to everything within the terraform\nstate file, with some helpers.\n\n```\ndef test_\n\n```\n\n*Note* The terraform state file is considered an internal\nimplementation detail of terraform, not a stable interface. Also\n\n\n## Fixture support\n\n- This plugin supports all the standard pytest scopes, scope names can\n  be passed into the constructors.\n\n- It does not currently support parameterization of terraform fixtures,\n  although test functions can freely usee both.\n\n## Replay Support\n\nBy default fixtures will save a `tf_resources.json` back to the module\ndirectory, that will be used when in replay mode.\n\n## Rewriting recorded\n\nTODO\n\n## XDist Compatibility\n\npytest_terraform supports pytest-xdist in multi-process (not distributed)\nmode\n\nWhen run with python-xdist, pytest_terraform treats all non functional\nscopes as per test run fixtures across all workers, honoring their\noriginal scope lifecycle but with global semantics, instead of once\nper worker. ie. terraform non function scope fixtures are run once\nper test run, not per worker.\n\nThis in contrast to what regular fixtures do by default with\npytest-xdist, where they are executed at least once per worker. for\ninfrastructure thats potentially time instensive to setup, this can\nnegate some of the benefits of running tests in parallel, which is\nwhy pytest-terraform uses global semantics.\n\n\n### Fixture Resources\n\nthe tests will need to access fixture provisioned resources, to do so\nthe fixture will return a terraform resources instance for each\nterraform root module fixture which will have available a mapping of\nterraform resource type names to terraform resource names to provider\nids, which will be inferred from the tfstate.json.\n\n### Replay support\n\nFor tests executing with replay we'll need to store the fixture\nresource id mapping and serialize them to disk from a live\nprovisioning run to enable a replay run. On replay we'll pick up the\nserialized resource ids and return them as the fixture results. We'll\nneed to do this once per scope instantiation (session, module,\npackage, function). Note this will be effectively be an independent\nmechanism from the existing one as it needs to handled pre test\nexecution, where as the current record/replay mechanism is done within\na test execution. Some of the DRY violation could be addressed by\nrefactoring the existing mechanisms to look at fixture decorated\nattribute on the test instance.\n\nConfiguring record vs replay\n\n```\n--tf-record=false|no\n--tf-replay=yes\n```\n\n### Root module references\n\n`terraform_remote_state` can be used to introduce a dependency between\na scoped root modules on an individual test, note we are not\nattempting to support same scope inter fixture dependencies as that\nimposes additional scheduling constraints outside of pytest native\ncapabilities. The higher scoped root module will need to have output\nvariables to enable this consumption.\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/cloud-custodian/pytest-terraform", "keywords": "", "license": "Apache-2.0", "maintainer": "", "maintainer_email": "", "name": "pytest-terraform", "package_url": "https://pypi.org/project/pytest-terraform/", "platform": "", "project_url": "https://pypi.org/project/pytest-terraform/", "project_urls": {"Homepage": "https://github.com/cloud-custodian/pytest-terraform", "Repository": "https://github.com/cloud-custodian/pytest-terraform"}, "release_url": "https://pypi.org/project/pytest-terraform/0.1.0/", "requires_dist": ["pytest (>=5.3.5,<5.4.0)"], "requires_python": ">=3.6,<4.0", "summary": "A pytest plugin for using terraform fixtures", "version": "0.1.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Introduction</h1>\n<p>pytest_terraform is a pytest plugin that enables executing terraform\nto provision infrastructure in a unit/functional test as a fixture.</p>\n<p>This plugin features uses a fixture factory pattern to enable dynamic\nconstruction of fixtures as either as test decorators or module level\nvariables.</p>\n<h2>Philosophy</h2>\n<p>The usage/philosophy of this plugin is based on using flight recording\nfor unit tests against cloud infrastructure. In flight recording rather\nthan mocking or stubbing infrastructure, actual resources are created\nand interacted with with responses recorded, with those responses\nsubsequently replayed for fast test execution. Beyond the fidelity\noffered, this also enables these tests to be executed/re-recorded against\nlive infrastructure for additional functional/release testing.</p>\n<h2>Decorator Usage</h2>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pytest_terraform</span> <span class=\"kn\">import</span> <span class=\"n\">terraform</span>\n<span class=\"kn\">from</span> <span class=\"nn\">boto3</span> <span class=\"kn\">import</span> <span class=\"n\">Session</span>\n\n<span class=\"nd\">@terraform</span><span class=\"p\">(</span><span class=\"s1\">'aws_sqs'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">test_sqs</span><span class=\"p\">(</span><span class=\"n\">aws_sqs</span><span class=\"p\">):</span>\n   <span class=\"n\">queue_url</span> <span class=\"o\">=</span> <span class=\"n\">aws_sqs</span><span class=\"p\">[</span><span class=\"s1\">'test_queue.queue_url'</span><span class=\"p\">]</span>\n   <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">queue_url</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">test_sqs_deliver</span><span class=\"p\">(</span><span class=\"n\">aws_sqs</span><span class=\"p\">):</span>\n   <span class=\"c1\"># once a fixture has been defined with a decorator</span>\n   <span class=\"c1\"># it can be reused in the same module by name</span>\n   <span class=\"k\">pass</span>\n\n<span class=\"nd\">@terraform</span><span class=\"p\">(</span><span class=\"s1\">'aws_sqs'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">test_sqs_dlq</span><span class=\"p\">(</span><span class=\"n\">aws_sqs</span><span class=\"p\">):</span>\n   <span class=\"c1\"># or referenced again via decorator, if redefined</span>\n   <span class=\"c1\"># with decorator the fixture parameters much match.</span>\n   <span class=\"k\">pass</span>\n</pre>\n<p><em>Note</em> the fixture name should match the terraform module name.</p>\n<h2>Variable Usage</h2>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pytest_terraform</span> <span class=\"kn\">import</span> <span class=\"n\">terraform</span>\n\n<span class=\"n\">gcp_pub_sub</span> <span class=\"o\">=</span> <span class=\"n\">terraform</span><span class=\"o\">.</span><span class=\"n\">fixture</span><span class=\"p\">(</span><span class=\"s1\">'gcp_pub_sub'</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_queue</span><span class=\"p\">(</span><span class=\"n\">gcp_pub_sub</span><span class=\"p\">):</span>\n\t<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">gcp_pub_sub</span><span class=\"o\">.</span><span class=\"n\">resources</span><span class=\"p\">)</span>\n</pre>\n<p><em>Note</em> the fixture variable name should match the terraform module name.</p>\n<h2>Fixture Usage</h2>\n<p>The pytest fixtures have access to everything within the terraform\nstate file, with some helpers.</p>\n<pre><code>def test_\n\n</code></pre>\n<p><em>Note</em> The terraform state file is considered an internal\nimplementation detail of terraform, not a stable interface. Also</p>\n<h2>Fixture support</h2>\n<ul>\n<li>\n<p>This plugin supports all the standard pytest scopes, scope names can\nbe passed into the constructors.</p>\n</li>\n<li>\n<p>It does not currently support parameterization of terraform fixtures,\nalthough test functions can freely usee both.</p>\n</li>\n</ul>\n<h2>Replay Support</h2>\n<p>By default fixtures will save a <code>tf_resources.json</code> back to the module\ndirectory, that will be used when in replay mode.</p>\n<h2>Rewriting recorded</h2>\n<p>TODO</p>\n<h2>XDist Compatibility</h2>\n<p>pytest_terraform supports pytest-xdist in multi-process (not distributed)\nmode</p>\n<p>When run with python-xdist, pytest_terraform treats all non functional\nscopes as per test run fixtures across all workers, honoring their\noriginal scope lifecycle but with global semantics, instead of once\nper worker. ie. terraform non function scope fixtures are run once\nper test run, not per worker.</p>\n<p>This in contrast to what regular fixtures do by default with\npytest-xdist, where they are executed at least once per worker. for\ninfrastructure thats potentially time instensive to setup, this can\nnegate some of the benefits of running tests in parallel, which is\nwhy pytest-terraform uses global semantics.</p>\n<h3>Fixture Resources</h3>\n<p>the tests will need to access fixture provisioned resources, to do so\nthe fixture will return a terraform resources instance for each\nterraform root module fixture which will have available a mapping of\nterraform resource type names to terraform resource names to provider\nids, which will be inferred from the tfstate.json.</p>\n<h3>Replay support</h3>\n<p>For tests executing with replay we'll need to store the fixture\nresource id mapping and serialize them to disk from a live\nprovisioning run to enable a replay run. On replay we'll pick up the\nserialized resource ids and return them as the fixture results. We'll\nneed to do this once per scope instantiation (session, module,\npackage, function). Note this will be effectively be an independent\nmechanism from the existing one as it needs to handled pre test\nexecution, where as the current record/replay mechanism is done within\na test execution. Some of the DRY violation could be addressed by\nrefactoring the existing mechanisms to look at fixture decorated\nattribute on the test instance.</p>\n<p>Configuring record vs replay</p>\n<pre><code>--tf-record=false|no\n--tf-replay=yes\n</code></pre>\n<h3>Root module references</h3>\n<p><code>terraform_remote_state</code> can be used to introduce a dependency between\na scoped root modules on an individual test, note we are not\nattempting to support same scope inter fixture dependencies as that\nimposes additional scheduling constraints outside of pytest native\ncapabilities. The higher scoped root module will need to have output\nvariables to enable this consumption.</p>\n\n          </div>"}, "last_serial": 7041753, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "74ee987503961d004683cc510d44eed3", "sha256": "38d3cf644b53a8dc8214f52190fb520c94ee99986b896f64b2022914c080f57e"}, "downloads": -1, "filename": "pytest_terraform-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "74ee987503961d004683cc510d44eed3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 12281, "upload_time": "2020-04-17T17:00:51", "upload_time_iso_8601": "2020-04-17T17:00:51.062483Z", "url": "https://files.pythonhosted.org/packages/7a/15/d7a64006b67ab1967759d7b183e7c708e8961649c7618db76a10a91f9959/pytest_terraform-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1a6a487e6135ac99d0c5eb1d051ae489", "sha256": "f49c19b1a542f43d73528188a3df256573f09505dba36e65cc016d2c67357277"}, "downloads": -1, "filename": "pytest-terraform-0.1.0.tar.gz", "has_sig": false, "md5_digest": "1a6a487e6135ac99d0c5eb1d051ae489", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 12120, "upload_time": "2020-04-17T17:00:49", "upload_time_iso_8601": "2020-04-17T17:00:49.114496Z", "url": "https://files.pythonhosted.org/packages/53/e3/677c68ea0a8de9c5b8beaa7e548a2812d8f10b61ec963e676e16594f08d7/pytest-terraform-0.1.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "74ee987503961d004683cc510d44eed3", "sha256": "38d3cf644b53a8dc8214f52190fb520c94ee99986b896f64b2022914c080f57e"}, "downloads": -1, "filename": "pytest_terraform-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "74ee987503961d004683cc510d44eed3", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.6,<4.0", "size": 12281, "upload_time": "2020-04-17T17:00:51", "upload_time_iso_8601": "2020-04-17T17:00:51.062483Z", "url": "https://files.pythonhosted.org/packages/7a/15/d7a64006b67ab1967759d7b183e7c708e8961649c7618db76a10a91f9959/pytest_terraform-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1a6a487e6135ac99d0c5eb1d051ae489", "sha256": "f49c19b1a542f43d73528188a3df256573f09505dba36e65cc016d2c67357277"}, "downloads": -1, "filename": "pytest-terraform-0.1.0.tar.gz", "has_sig": false, "md5_digest": "1a6a487e6135ac99d0c5eb1d051ae489", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.6,<4.0", "size": 12120, "upload_time": "2020-04-17T17:00:49", "upload_time_iso_8601": "2020-04-17T17:00:49.114496Z", "url": "https://files.pythonhosted.org/packages/53/e3/677c68ea0a8de9c5b8beaa7e548a2812d8f10b61ec963e676e16594f08d7/pytest-terraform-0.1.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:54:39 2020"}