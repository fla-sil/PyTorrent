{"info": {"author": "Fabio Pachelli Pacheco", "author_email": "nanook.labs@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.5", "Topic :: Software Development :: Build Tools"], "description": "JSON Differ and Schema Matcher\n==============================\n\nUse this Lib to create a structure schema of a given JSON and also to check if a given JSON matches a given schema or simply to diff 2 JSONs.\n\n\nWhy Should I Use This?\n----------------------\n\nI made this for use when validating a JSON REST API using Behave. I wanted to be sure that the JSON's structure is correct, no matter it's content.\n\nYou may use it for whatever you want :)\n\n\nDiffer Features\n---------------\n\n- Diff 2 JSONs\n\n\nSchema Features\n---------------\n\n- Export schema for a given JSON\n- Validate a given schema\n- Check if a given JSON matches a given schema\n- Highlight any unmatched data between JSON and schema\n\n\n\nDiffer Usage\n------------\n\ndiff_jsons()\n\"\"\"\"\"\"\"\"\"\"\"\"\nShow differences between 2 JSONs\n::\n\n    In [1]: from json_schema.json_differ import diff_jsons\n\n    In [2]: diff_jsons('{\"a\": \"1\"}', '{\"a\": 2}')\n    {\n        \"a\": \"'2' should match 'str:1'\"\n    }\n    Out[2]: False\n\n    In [3]: diff_jsons('{\"a\": \"1\"}', '{\"a\": \"1\"}')\n    Out[3]: True\n\n\nSchema Usage\n------------\n\njson_schema.loads()\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\nLoad schema function. Receive a schema and return and JsonSchema object instance.\n::\n\n    In [1]: from json_schema import json_schema\n\n    In [2]: my_schema = '{\"my_key\": \"int:0:10|str\"}'\n\n    In [3]: my_schema_object = json_schema.loads(my_schema)\n\n    In [4]: my_schema_object\n    Out[4]: <json_schema.JsonSchema at 0x10aa96f10>\n\njson_schema.dumps()\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\nDump schema function. Receive a JSON and return an automaticaly created schema. Its very userful when working with some large or complex JSON. Be aware that you may have to adapt its returned schema to work with your JSON variations. For example, if your JSON have some optional value that, this time, is null the schema created will expect that that value is AWAYS null.\n:: \n\n    In [1]: from json_schema import json_schema\n\n    In [2]: my_json = '{\"parrot\": [\"is no more\", \"It has ceased to be\"], \"ex-parrot\": true, \"volts\": 2000}'\n\n    In [3]: my_automatic_schema = json_schema.dumps(my_json)\n\n    In [4]: my_automatic_schema\n    Out[4]: '{\"ex-parrot\": \"bool\", \"parrot\": [\"str\", \"...\"], \"volts\": \"int\"}'\n\n\njson_schema.match()\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\nCheck if a given JSON matches a given schema.\n::\n\n    In [1]: from json_schema import json_schema\n\n    In [2]: my_json = '{\"parrot\": [\"is no more\", \"It has ceased to be\"], \"ex-parrot\": true, \"volts\": 2000}'\n\n    In [3]: my_schema = '{\"ex-parrot\": \"bool\", \"parrot\": [\"str\", \"...\"], \"volts\": \"int\"}'\n\n    In [4]: json_schema.match(my_json, my_schema)\n    Out[4]: True\n\n\nJsonSchema Object\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\nObject that contains all validations e checkups for that given schema.\n\nJsonSchema.full_check()\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\nCheck and highlights any errors found.\n::\n\n    In [1]: from json_schema import json_schema\n\n    In [2]: my_schema = '{\"ex-parrot\": \"bool\", \"parrot\": [\"str\", \"...\"], \"volts\": \"int\"}'\n\n    In [3]: JS = json_schema.loads(my_schema)\n\n    In [4]: my_json = '{\"parrot\": [\"is no more\", \"It has ceased to be\"], \"ex-parrot\": true, \"volts\": 2000}'\n\n    In [5]: JS.full_check(my_json)\n    {\n        \"ex-parrot\": true, \n        \"parrot\": [\n            true, \n            true\n        ], \n        \"volts\": true\n    }\n\n    In [6]: other_json = '{\"parrot\": [\"is no more\", \"It has ceased to be\"], \"ex-parrot\": true, \"volts\": \"foobar\"}'\n\n    In [7]: JS.full_check(other_json)\n    {\n        \"ex-parrot\": true, \n        \"parrot\": [\n            true, \n            true\n        ], \n        \"volts\": \"'foobar' should match 'int'\"\n    }\n\n\nUsage Example\n-------------\n\n::\n\n    In [1]: from json_schema import json_schema\n\n    In [2]: um_json = '''{\"chave_list\": [1, 2],\n                          \"chave_dict\": {\"chave\": \"valor\"},\n                          \"chave_int\": 1,\n                          \"chave_float\": 1.2,\n                          \"chave_string\": \"1\"}'''\n\n    In [3]: esquema = json_schema.dumps(um_json)\n\n    In [4]: print esquema\n    {\"chave_list\": [\"int\", \"...\"], \"chave_dict\": {\"chave\": \"str\"}, \"chave_int\": \"int\", \"chave_float\": \"float\", \"chave_string\": \"str\"}\n\n    In [5]: js = json_schema.loads(esquema)\n\n    In [6]: js\n    Out[6]: <json_schema.JsonSchema at 0x1064f0f50>\n\n    In [7]: js == um_json\n    Out[7]: True\n\n\nValidators\n----------\n\nstring\n\"\"\"\"\"\"\n\nWill match only if that given JSON data is string.\n\n::\n\n    '{\"my_key\": \"str\"}'\n\nWill match any of those:\n::\n\n    '{\"my_key\": \"my_value\"}'\n    '{\"my_key\": \"my value\"}'\n    '{\"my_key\": \"\"}'\n    '{\"my_key\": \"123\"}'\n    '{\"my_key\": \"3.567\"}'\n\nIt my have max length limit using \"str:max_len\"\n\n::\n\n    '{\"my_key\": \"str:3\"}'\n\nWill match any of those:\n::\n\n    '{\"my_key\": \"\"}'\n    '{\"my_key\": \"a\"}'\n    '{\"my_key\": \"ab\"}'\n    '{\"my_key\": \"abc\"}'\n    '{\"my_key\": \"123\"}'\n\nBut not match those:\n::\n\n    '{\"my_key\": \"abcd\"}'\n    '{\"my_key\": \"abcde\"}'\n    '{\"my_key\": \"1234\"}'\n\nOr direct string match using \"str:string_to_match\"\n\n::\n\n    '{\"my_key\": \"str:Foo Bar\"}'\n\nWill match only:\n::\n\n    '{\"my_key\": \"Foo Bar\"}'\n\nAnd not match those:\n::\n\n    '{\"my_key\": \"foo bar\"}'\n    '{\"my_key\": \"Foo bar\"}'\n    '{\"my_key\": \"anything else\"}'\n\nint\n\"\"\"\n\nWill match only if that given JSON data is integer.\n\n::\n\n    '{\"my_key\": \"int\"}'\n\nWill match any of those:\n::\n\n    '{\"my_key\": 0}'\n    '{\"my_key\": 1}'\n    '{\"my_key\": 12345}'\n    '{\"my_key\": -1}'\n    '{\"my_key\": -123}'\n\nIt my have min:max value limit using \"int:min:max\"\n\n::\n\n    '{\"my_key\": \"int:-3:3\"}'\n\nWill match any of those:\n::\n\n    '{\"my_key\": 0}'\n    '{\"my_key\": -1}'\n    '{\"my_key\": -3}'\n    '{\"my_key\": 1}'\n    '{\"my_key\": 3}'\n\nBut not match those:\n::\n\n    '{\"my_key\": -4}'\n    '{\"my_key\": 4}'\n    '{\"my_key\": 12345}'\n\n\nfloat\n\"\"\"\"\"\n\nSame as int but for float values\n::\n\n    '{\"my_key\": \"float\"}'\n\nWill match any of those:\n::\n\n    '{\"my_key\": 0.0}'\n    '{\"my_key\": 1.1}'\n    '{\"my_key\": 123.45}'\n    '{\"my_key\": -1.1}'\n    '{\"my_key\": -12.3}'\n\nIt my have min:max value limit using \"float:min:max\"\n\n::\n\n    '{\"my_key\": \"float:-3.1:3.5\"}'\n\nWill match any of those:\n::\n\n    '{\"my_key\": 0.0}'\n    '{\"my_key\": -1.2}'\n    '{\"my_key\": -3.1}'\n    '{\"my_key\": 1.0}'\n    '{\"my_key\": 3.5}'\n\nBut not match those:\n::\n\n    '{\"my_key\": -4.0}'\n    '{\"my_key\": 4.0}'\n    '{\"my_key\": 123.45}'\n    '{\"my_key\": 2}'\n\n\nurl\n\"\"\"\n\nWill match only if that given JSON data is a string that contains a valid URL.\n\n::\n\n    '{\"my_key\": \"url\"}'\n\nWill match any of those:\n::\n\n    '{\"my_key\": \"http://example.com\"}'\n    '{\"my_key\": \"https://example.com\"}'\n    '{\"my_key\": \"ftp://example.com\"}'\n    '{\"my_key\": \"ftps://example.com\"}'\n\nValidation is made using the folowing python regular expression code\n::\n\n    regex = re.compile(r'^(?:http|ftp)s?://'  # HTTP, HTTPS, FTP, FTPS\n                       # Dominio\n                       r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'\n                       # Localhost\n                       r'localhost|'\n                       # IP\n                       r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n                       # Porta\n                       r'(?::\\d+)?'\n                       r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return True if regex.match(item) else False\n\n\nbool\n\"\"\"\"\n\nWill match only if that given JSON data is boolean.\n\n::\n\n    '{\"my_key\": \"bool\"}'\n\nWill match only:\n::\n\n    '{\"my_key\": true}'\n    '{\"my_key\": false}'\n\nYou may also match it's value:\n::\n\n    '{\"my_key\": \"bool:True\"}'\n    '{\"my_key\": \"bool:False\"}'\n\n\nregex\n\"\"\"\"\"\n\nWill match only if that given JSON data is string and match some regex string.\n\n::\n\n    '{\"my_key\": \"regex:[regex string]\"}'\n\nExample:\n::\n\n    In [1]: from json_schema import json_schema\n\n    In [2]: json_schema.loads('{\"my_key\": \"regex:^[0-9]{2}:[0-9]{2}:[0-9]{2}\"}') == '{\"my_key\": \"00:00:00\"}'\n    Out[2]: True\n\n    In [3]: json_schema.loads('{\"my_key\": \"regex:^[0-9]{2}:[0-9]{2}:[0-9]{2}\"}') == '{\"my_key\": \"00:00:0\"}'\n    Out[3]: False\n\n    In [4]: json_schema.loads('{\"my_key\": \"regex:^[0-9]{2}:[0-9]{2}:[0-9]{2}\"}') == '{\"my_key\": \"00:00:AA\"}'\n    Out[4]: False\n\n\npython\n\"\"\"\"\"\"\n\nWill match only if that given python code return True.\nThe value in JSON will be used as 'value' variable.\n\n::\n\n    '{\"my_key\": \"python:[python code]\"}'\n\nExample:\n::\n\n    In [1]: from json_schema import json_schema\n\n    In [2]: json_schema.loads('{\"my_key\": \"python:value.upper() == value\"}') == '{\"my_key\": \"FOOBAR\"}'\n    Out[2]: True\n\n    In [3]: json_schema.loads('{\"my_key\": \"python:value.upper() == value\"}') == '{\"my_key\": \"FooBar\"}'\n    Out[3]: False\n\n    In [4]: json_schema.loads('{\"my_key\": \"python:value%2 == 2\"}') == '{\"my_key\": 10}'\n    Out[4]: True\n\n    In [5]: json_schema.loads('{\"my_key\": \"python:value%2 == 2\"}') == '{\"my_key\": 11}'\n    Out[5]: False\n\n\ndatetime\n\"\"\"\"\"\"\"\"\n\nWill match only if that given value match with datetime string formatter\nhttps://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior\n\n::\n\n    '{\"my_key\": \"datetime:format string\"}'\n\nExample:\n::\n\n    In [1]: from json_schema import json_schema\n\n    In [2]: json_schema.loads('{\"my_key\": \"datetime:%Y-%m-%d\"}') == '{\"my_key\": \"2015-07-07\"}'\n    Out[2]: True\n\n    In [3]: json_schema.loads('{\"my_key\": \"datetime:%Y-%m-%d\"}') == '{\"my_key\": \"2015-17-07\"}'\n    Out[3]: False\n\n    In [4]: json_schema.loads('{\"my_key\": \"datetime:%d/%m/%Y %H:%M:%S\"}') == '{\"my_key\": \"13/04/1984 11:22:33\"}'\n    Out[4]: True\n\n    In [5]: json_schema.loads('{\"my_key\": \"datetime:%d/%m/%Y %H:%M:%S\"}') == '{\"my_key\": \"04/13/1984 11:22:33\"}'\n    Out[5]: False\n\n\n\nany\n\"\"\"\n\nWill match anything but null.\n\n::\n\n    '{\"my_key\": \"any\"}'\n\nWill match any of those:\n::\n\n    '{\"my_key\": 10}'\n    '{\"my_key\": \"foo\"}'\n    '{\"my_key\": 1.5}'\n    '{\"my_key\": true}'\n    '{\"my_key\": \"\"}'\n\nBut not\n\n::\n\n    '{\"my_key\": null}'\n\nnull\n\"\"\"\"\n\nWill match only null values.\n\n::\n\n    '{\"my_key\": \"null\"}'\n\nWill match:\n::\n\n    '{\"my_key\": null}'\n\nBut not\n::\n\n    '{\"my_key\": 10}'\n    '{\"my_key\": \"foo\"}'\n    '{\"my_key\": 1.5}'\n    '{\"my_key\": true}'\n    '{\"my_key\": \"\"}'\n\nempty\n\"\"\"\"\"\n\nWill match empty structures.\n\nSupported:\n::\n\n    '{\"my_key\": \"empty:list\"}'\n    '{\"my_key\": \"empty:dict\"}'\n    '{\"my_key\": \"empty:hash\"}'\n    '{\"my_key\": \"empty:object\"}'\n\nTypes 'hash', 'dict' and 'object' are actually same\n\n::\n\n    '{\"my_key\": \"empty:list\"}'\n\n\nWill match:\n::\n\n    '{\"my_key\": []}'\n\nAnd\n::\n\n    '{\"my_key\": \"empty:object\"}'\n\n\nWill match:\n::\n\n    '{\"my_key\": {}}'\n\n\nBut not\n\n::\n\n    '{\"my_key\": null}'\n\n\nEspecial validations\n--------------------\n\n'|' - OR operator\n\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nWill match if any of validators match.\n::\n\n    '{\"my_key\": \"str|int\"}'\n\nWill match:\n::\n\n    '{\"my_key\": \"foo\"}'\n    '{\"my_key\": 123}'\n\nExample\n::\n\n    In [1]: from json_schema import json_schema\n\n    In [2]: json_schema.loads('{\"my_key\": \"int|str\"}') == '{\"my_key\": \"foo\"}'\n    Out[2]: True\n\n    In [3]: json_schema.loads('{\"my_key\": \"int|str\"}') == '{\"my_key\": 123}'\n    Out[3]: True\n\n    In [4]: json_schema.loads('{\"my_key\": \"int:0:10|str:3\"}') == '{\"my_key\": \"foo\"}'\n    Out[4]: True\n\n    In [5]: json_schema.loads('{\"my_key\": \"int:0:10|str:3\"}') == '{\"my_key\": 3}'\n    Out[5]: True\n\n    In [6]: json_schema.loads('{\"my_key\": \"int:0:10|str:2\"}') == '{\"my_key\": \"foo\"}'\n    Out[6]: False\n\n    In [7]: json_schema.loads('{\"my_key\": \"int:10|str\"}') == '{\"my_key\": 123}'\n    Out[7]: False\n\n\nThis will match everything:\n::\n\n    '{\"my_key\": \"any|null\"}'\n\n\nArrays\n\"\"\"\"\"\"\n\nArrays are ordered so your schema order matters as also its size.\n::\n\n    '{\"my_key\": [\"str\", \"str\", \"int\"]}'\n\nWill match:\n::\n\n    '{\"my_key\": [\"foo\", \"bar\", 123]}'\n\nBut not\n::\n\n    '{\"my_key\": [\"foo\", 123, \"bar\"]}'\n    '{\"my_key\": [\"foo\", \"bar\", 123, 123]}'\n\nIf you dont know the size of your array you may user a special 2 item arrays as follows\n::\n\n    '{\"my_key\": [\"str\", \"...\"]}'\n\nThat will match:\n::\n\n    '{\"my_key\": [\"foo\"]}'\n    '{\"my_key\": [\"foo\", \"bar\"]}'\n    '{\"my_key\": [\"foo\", \"bar\", \"Hello World\"]}'\n    '{\"my_key\": [\"foo\", \"bar\", \"Hello World\", \"etc\"]}'\n\nOr even:\n::\n\n    '{\"my_key\": [\"str|int\", \"...\"]}'\n\nThat will match:\n::\n\n    '{\"my_key\": [\"foo\"]}'\n    '{\"my_key\": [123]}'\n    '{\"my_key\": [\"foo\", \"bar\"]}'\n    '{\"my_key\": [\"foo\", 123, \"Hello World\"]}'\n    '{\"my_key\": [123, \"bar\", \"Hello World\", 0]}'\n\n\nHashs (dicts)\n\"\"\"\"\"\"\"\"\"\"\"\"\"\n\nHashs are not ordered so your schema order does not matters but its keys does.\n::\n\n    '{\"my_key\": {\"internal_key_1\": \"str\", \"internal_key_2\": \"int\"}'\n\nWill match:\n::\n\n    '{\"my_key\": {\"internal_key_1\": \"foo\", \"internal_key_2\": 123}'\n    '{\"my_key\": {\"internal_key_2\": 123, \"internal_key_2\": \"foo\"}'\n\nBut not\n::\n\n    '{\"my_key\": {\"internal_key_1\": 123, \"internal_key_2\": \"foo\"}'\n    '{\"my_key\": {\"internal_key_1\": \"foo\", \"internal_key_3\": 123}'\n    '{\"my_key\": {\"internal_key_1\": \"foo\", \"internal_key_2\": 123, \"fizz\": \"buzz\"}'\n\n\nRecursivity\n\"\"\"\"\"\"\"\"\"\"\"\n\nAll validations are recursive so they will check into arrays, hashs, array of arrays, etc.\n::\n\n    '[{\"my_key\": [\"str|int\", \"...\"]}, {\"my_key\": \"str\"}, \"int\", [\"int|str\", \"str\"]'\n\nWill match:\n::\n\n    '[{\"my_key\": [1, \"foo\", \"bar\", 100]}, {\"my_key\": \"foo\"}, 12345, [123, \"foo\"]'\n\n\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "https://github.com/nano-labs/json_schema/archive/release/0.1.7.1.zip", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/nano-labs/json_schema", "keywords": "json schema diff differ comparison", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "json-schema-matcher", "package_url": "https://pypi.org/project/json-schema-matcher/", "platform": "", "project_url": "https://pypi.org/project/json-schema-matcher/", "project_urls": {"Download": "https://github.com/nano-labs/json_schema/archive/release/0.1.7.1.zip", "Homepage": "https://github.com/nano-labs/json_schema"}, "release_url": "https://pypi.org/project/json-schema-matcher/0.1.7.1/", "requires_dist": null, "requires_python": "", "summary": "Use this Lib to create a structure schema of a given JSON and also to check if a given JSON matches a given schema.", "version": "0.1.7.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Use this Lib to create a structure schema of a given JSON and also to check if a given JSON matches a given schema or simply to diff 2 JSONs.</p>\n<div id=\"why-should-i-use-this\">\n<h2>Why Should I Use This?</h2>\n<p>I made this for use when validating a JSON REST API using Behave. I wanted to be sure that the JSON\u2019s structure is correct, no matter it\u2019s content.</p>\n<p>You may use it for whatever you want :)</p>\n</div>\n<div id=\"differ-features\">\n<h2>Differ Features</h2>\n<ul>\n<li>Diff 2 JSONs</li>\n</ul>\n</div>\n<div id=\"schema-features\">\n<h2>Schema Features</h2>\n<ul>\n<li>Export schema for a given JSON</li>\n<li>Validate a given schema</li>\n<li>Check if a given JSON matches a given schema</li>\n<li>Highlight any unmatched data between JSON and schema</li>\n</ul>\n</div>\n<div id=\"differ-usage\">\n<h2>Differ Usage</h2>\n<h2 id=\"diff-jsons\"><span class=\"section-subtitle\">diff_jsons()</span></h2>\n<p>Show differences between 2 JSONs</p>\n<pre>In [1]: from json_schema.json_differ import diff_jsons\n\nIn [2]: diff_jsons('{\"a\": \"1\"}', '{\"a\": 2}')\n{\n    \"a\": \"'2' should match 'str:1'\"\n}\nOut[2]: False\n\nIn [3]: diff_jsons('{\"a\": \"1\"}', '{\"a\": \"1\"}')\nOut[3]: True\n</pre>\n</div>\n<div id=\"schema-usage\">\n<h2>Schema Usage</h2>\n<div id=\"json-schema-loads\">\n<h3>json_schema.loads()</h3>\n<p>Load schema function. Receive a schema and return and JsonSchema object instance.</p>\n<pre>In [1]: from json_schema import json_schema\n\nIn [2]: my_schema = '{\"my_key\": \"int:0:10|str\"}'\n\nIn [3]: my_schema_object = json_schema.loads(my_schema)\n\nIn [4]: my_schema_object\nOut[4]: &lt;json_schema.JsonSchema at 0x10aa96f10&gt;\n</pre>\n</div>\n<div id=\"json-schema-dumps\">\n<h3>json_schema.dumps()</h3>\n<p>Dump schema function. Receive a JSON and return an automaticaly created schema. Its very userful when working with some large or complex JSON. Be aware that you may have to adapt its returned schema to work with your JSON variations. For example, if your JSON have some optional value that, this time, is null the schema created will expect that that value is AWAYS null.</p>\n<pre>In [1]: from json_schema import json_schema\n\nIn [2]: my_json = '{\"parrot\": [\"is no more\", \"It has ceased to be\"], \"ex-parrot\": true, \"volts\": 2000}'\n\nIn [3]: my_automatic_schema = json_schema.dumps(my_json)\n\nIn [4]: my_automatic_schema\nOut[4]: '{\"ex-parrot\": \"bool\", \"parrot\": [\"str\", \"...\"], \"volts\": \"int\"}'\n</pre>\n</div>\n<div id=\"json-schema-match\">\n<h3>json_schema.match()</h3>\n<p>Check if a given JSON matches a given schema.</p>\n<pre>In [1]: from json_schema import json_schema\n\nIn [2]: my_json = '{\"parrot\": [\"is no more\", \"It has ceased to be\"], \"ex-parrot\": true, \"volts\": 2000}'\n\nIn [3]: my_schema = '{\"ex-parrot\": \"bool\", \"parrot\": [\"str\", \"...\"], \"volts\": \"int\"}'\n\nIn [4]: json_schema.match(my_json, my_schema)\nOut[4]: True\n</pre>\n</div>\n<div id=\"jsonschema-object\">\n<h3>JsonSchema Object</h3>\n<p>Object that contains all validations e checkups for that given schema.</p>\n</div>\n<div id=\"jsonschema-full-check\">\n<h3>JsonSchema.full_check()</h3>\n<p>Check and highlights any errors found.</p>\n<pre>In [1]: from json_schema import json_schema\n\nIn [2]: my_schema = '{\"ex-parrot\": \"bool\", \"parrot\": [\"str\", \"...\"], \"volts\": \"int\"}'\n\nIn [3]: JS = json_schema.loads(my_schema)\n\nIn [4]: my_json = '{\"parrot\": [\"is no more\", \"It has ceased to be\"], \"ex-parrot\": true, \"volts\": 2000}'\n\nIn [5]: JS.full_check(my_json)\n{\n    \"ex-parrot\": true,\n    \"parrot\": [\n        true,\n        true\n    ],\n    \"volts\": true\n}\n\nIn [6]: other_json = '{\"parrot\": [\"is no more\", \"It has ceased to be\"], \"ex-parrot\": true, \"volts\": \"foobar\"}'\n\nIn [7]: JS.full_check(other_json)\n{\n    \"ex-parrot\": true,\n    \"parrot\": [\n        true,\n        true\n    ],\n    \"volts\": \"'foobar' should match 'int'\"\n}\n</pre>\n</div>\n</div>\n<div id=\"usage-example\">\n<h2>Usage Example</h2>\n<pre>In [1]: from json_schema import json_schema\n\nIn [2]: um_json = '''{\"chave_list\": [1, 2],\n                      \"chave_dict\": {\"chave\": \"valor\"},\n                      \"chave_int\": 1,\n                      \"chave_float\": 1.2,\n                      \"chave_string\": \"1\"}'''\n\nIn [3]: esquema = json_schema.dumps(um_json)\n\nIn [4]: print esquema\n{\"chave_list\": [\"int\", \"...\"], \"chave_dict\": {\"chave\": \"str\"}, \"chave_int\": \"int\", \"chave_float\": \"float\", \"chave_string\": \"str\"}\n\nIn [5]: js = json_schema.loads(esquema)\n\nIn [6]: js\nOut[6]: &lt;json_schema.JsonSchema at 0x1064f0f50&gt;\n\nIn [7]: js == um_json\nOut[7]: True\n</pre>\n</div>\n<div id=\"validators\">\n<h2>Validators</h2>\n<div id=\"string\">\n<h3>string</h3>\n<p>Will match only if that given JSON data is string.</p>\n<pre>'{\"my_key\": \"str\"}'\n</pre>\n<p>Will match any of those:</p>\n<pre>'{\"my_key\": \"my_value\"}'\n'{\"my_key\": \"my value\"}'\n'{\"my_key\": \"\"}'\n'{\"my_key\": \"123\"}'\n'{\"my_key\": \"3.567\"}'\n</pre>\n<p>It my have max length limit using \u201cstr:max_len\u201d</p>\n<pre>'{\"my_key\": \"str:3\"}'\n</pre>\n<p>Will match any of those:</p>\n<pre>'{\"my_key\": \"\"}'\n'{\"my_key\": \"a\"}'\n'{\"my_key\": \"ab\"}'\n'{\"my_key\": \"abc\"}'\n'{\"my_key\": \"123\"}'\n</pre>\n<p>But not match those:</p>\n<pre>'{\"my_key\": \"abcd\"}'\n'{\"my_key\": \"abcde\"}'\n'{\"my_key\": \"1234\"}'\n</pre>\n<p>Or direct string match using \u201cstr:string_to_match\u201d</p>\n<pre>'{\"my_key\": \"str:Foo Bar\"}'\n</pre>\n<p>Will match only:</p>\n<pre>'{\"my_key\": \"Foo Bar\"}'\n</pre>\n<p>And not match those:</p>\n<pre>'{\"my_key\": \"foo bar\"}'\n'{\"my_key\": \"Foo bar\"}'\n'{\"my_key\": \"anything else\"}'\n</pre>\n</div>\n<div id=\"int\">\n<h3>int</h3>\n<p>Will match only if that given JSON data is integer.</p>\n<pre>'{\"my_key\": \"int\"}'\n</pre>\n<p>Will match any of those:</p>\n<pre>'{\"my_key\": 0}'\n'{\"my_key\": 1}'\n'{\"my_key\": 12345}'\n'{\"my_key\": -1}'\n'{\"my_key\": -123}'\n</pre>\n<p>It my have min:max value limit using \u201cint:min:max\u201d</p>\n<pre>'{\"my_key\": \"int:-3:3\"}'\n</pre>\n<p>Will match any of those:</p>\n<pre>'{\"my_key\": 0}'\n'{\"my_key\": -1}'\n'{\"my_key\": -3}'\n'{\"my_key\": 1}'\n'{\"my_key\": 3}'\n</pre>\n<p>But not match those:</p>\n<pre>'{\"my_key\": -4}'\n'{\"my_key\": 4}'\n'{\"my_key\": 12345}'\n</pre>\n</div>\n<div id=\"float\">\n<h3>float</h3>\n<p>Same as int but for float values</p>\n<pre>'{\"my_key\": \"float\"}'\n</pre>\n<p>Will match any of those:</p>\n<pre>'{\"my_key\": 0.0}'\n'{\"my_key\": 1.1}'\n'{\"my_key\": 123.45}'\n'{\"my_key\": -1.1}'\n'{\"my_key\": -12.3}'\n</pre>\n<p>It my have min:max value limit using \u201cfloat:min:max\u201d</p>\n<pre>'{\"my_key\": \"float:-3.1:3.5\"}'\n</pre>\n<p>Will match any of those:</p>\n<pre>'{\"my_key\": 0.0}'\n'{\"my_key\": -1.2}'\n'{\"my_key\": -3.1}'\n'{\"my_key\": 1.0}'\n'{\"my_key\": 3.5}'\n</pre>\n<p>But not match those:</p>\n<pre>'{\"my_key\": -4.0}'\n'{\"my_key\": 4.0}'\n'{\"my_key\": 123.45}'\n'{\"my_key\": 2}'\n</pre>\n</div>\n<div id=\"url\">\n<h3>url</h3>\n<p>Will match only if that given JSON data is a string that contains a valid URL.</p>\n<pre>'{\"my_key\": \"url\"}'\n</pre>\n<p>Will match any of those:</p>\n<pre>'{\"my_key\": \"http://example.com\"}'\n'{\"my_key\": \"https://example.com\"}'\n'{\"my_key\": \"ftp://example.com\"}'\n'{\"my_key\": \"ftps://example.com\"}'\n</pre>\n<p>Validation is made using the folowing python regular expression code</p>\n<pre>regex = re.compile(r'^(?:http|ftp)s?://'  # HTTP, HTTPS, FTP, FTPS\n                   # Dominio\n                   r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'\n                   # Localhost\n                   r'localhost|'\n                   # IP\n                   r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'\n                   # Porta\n                   r'(?::\\d+)?'\n                   r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\nreturn True if regex.match(item) else False\n</pre>\n</div>\n<div id=\"bool\">\n<h3>bool</h3>\n<p>Will match only if that given JSON data is boolean.</p>\n<pre>'{\"my_key\": \"bool\"}'\n</pre>\n<p>Will match only:</p>\n<pre>'{\"my_key\": true}'\n'{\"my_key\": false}'\n</pre>\n<p>You may also match it\u2019s value:</p>\n<pre>'{\"my_key\": \"bool:True\"}'\n'{\"my_key\": \"bool:False\"}'\n</pre>\n</div>\n<div id=\"regex\">\n<h3>regex</h3>\n<p>Will match only if that given JSON data is string and match some regex string.</p>\n<pre>'{\"my_key\": \"regex:[regex string]\"}'\n</pre>\n<p>Example:</p>\n<pre>In [1]: from json_schema import json_schema\n\nIn [2]: json_schema.loads('{\"my_key\": \"regex:^[0-9]{2}:[0-9]{2}:[0-9]{2}\"}') == '{\"my_key\": \"00:00:00\"}'\nOut[2]: True\n\nIn [3]: json_schema.loads('{\"my_key\": \"regex:^[0-9]{2}:[0-9]{2}:[0-9]{2}\"}') == '{\"my_key\": \"00:00:0\"}'\nOut[3]: False\n\nIn [4]: json_schema.loads('{\"my_key\": \"regex:^[0-9]{2}:[0-9]{2}:[0-9]{2}\"}') == '{\"my_key\": \"00:00:AA\"}'\nOut[4]: False\n</pre>\n</div>\n<div id=\"python\">\n<h3>python</h3>\n<p>Will match only if that given python code return True.\nThe value in JSON will be used as \u2018value\u2019 variable.</p>\n<pre>'{\"my_key\": \"python:[python code]\"}'\n</pre>\n<p>Example:</p>\n<pre>In [1]: from json_schema import json_schema\n\nIn [2]: json_schema.loads('{\"my_key\": \"python:value.upper() == value\"}') == '{\"my_key\": \"FOOBAR\"}'\nOut[2]: True\n\nIn [3]: json_schema.loads('{\"my_key\": \"python:value.upper() == value\"}') == '{\"my_key\": \"FooBar\"}'\nOut[3]: False\n\nIn [4]: json_schema.loads('{\"my_key\": \"python:value%2 == 2\"}') == '{\"my_key\": 10}'\nOut[4]: True\n\nIn [5]: json_schema.loads('{\"my_key\": \"python:value%2 == 2\"}') == '{\"my_key\": 11}'\nOut[5]: False\n</pre>\n</div>\n<div id=\"datetime\">\n<h3>datetime</h3>\n<p>Will match only if that given value match with datetime string formatter\n<a href=\"https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior\" rel=\"nofollow\">https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior</a></p>\n<pre>'{\"my_key\": \"datetime:format string\"}'\n</pre>\n<p>Example:</p>\n<pre>In [1]: from json_schema import json_schema\n\nIn [2]: json_schema.loads('{\"my_key\": \"datetime:%Y-%m-%d\"}') == '{\"my_key\": \"2015-07-07\"}'\nOut[2]: True\n\nIn [3]: json_schema.loads('{\"my_key\": \"datetime:%Y-%m-%d\"}') == '{\"my_key\": \"2015-17-07\"}'\nOut[3]: False\n\nIn [4]: json_schema.loads('{\"my_key\": \"datetime:%d/%m/%Y %H:%M:%S\"}') == '{\"my_key\": \"13/04/1984 11:22:33\"}'\nOut[4]: True\n\nIn [5]: json_schema.loads('{\"my_key\": \"datetime:%d/%m/%Y %H:%M:%S\"}') == '{\"my_key\": \"04/13/1984 11:22:33\"}'\nOut[5]: False\n</pre>\n</div>\n<div id=\"any\">\n<h3>any</h3>\n<p>Will match anything but null.</p>\n<pre>'{\"my_key\": \"any\"}'\n</pre>\n<p>Will match any of those:</p>\n<pre>'{\"my_key\": 10}'\n'{\"my_key\": \"foo\"}'\n'{\"my_key\": 1.5}'\n'{\"my_key\": true}'\n'{\"my_key\": \"\"}'\n</pre>\n<p>But not</p>\n<pre>'{\"my_key\": null}'\n</pre>\n</div>\n<div id=\"null\">\n<h3>null</h3>\n<p>Will match only null values.</p>\n<pre>'{\"my_key\": \"null\"}'\n</pre>\n<p>Will match:</p>\n<pre>'{\"my_key\": null}'\n</pre>\n<p>But not</p>\n<pre>'{\"my_key\": 10}'\n'{\"my_key\": \"foo\"}'\n'{\"my_key\": 1.5}'\n'{\"my_key\": true}'\n'{\"my_key\": \"\"}'\n</pre>\n</div>\n<div id=\"empty\">\n<h3>empty</h3>\n<p>Will match empty structures.</p>\n<p>Supported:</p>\n<pre>'{\"my_key\": \"empty:list\"}'\n'{\"my_key\": \"empty:dict\"}'\n'{\"my_key\": \"empty:hash\"}'\n'{\"my_key\": \"empty:object\"}'\n</pre>\n<p>Types \u2018hash\u2019, \u2018dict\u2019 and \u2018object\u2019 are actually same</p>\n<pre>'{\"my_key\": \"empty:list\"}'\n</pre>\n<p>Will match:</p>\n<pre>'{\"my_key\": []}'\n</pre>\n<p>And</p>\n<pre>'{\"my_key\": \"empty:object\"}'\n</pre>\n<p>Will match:</p>\n<pre>'{\"my_key\": {}}'\n</pre>\n<p>But not</p>\n<pre>'{\"my_key\": null}'\n</pre>\n</div>\n</div>\n<div id=\"especial-validations\">\n<h2>Especial validations</h2>\n<div id=\"or-operator\">\n<h3>\u2018|\u2019 - OR operator</h3>\n<p>Will match if any of validators match.</p>\n<pre>'{\"my_key\": \"str|int\"}'\n</pre>\n<p>Will match:</p>\n<pre>'{\"my_key\": \"foo\"}'\n'{\"my_key\": 123}'\n</pre>\n<p>Example</p>\n<pre>In [1]: from json_schema import json_schema\n\nIn [2]: json_schema.loads('{\"my_key\": \"int|str\"}') == '{\"my_key\": \"foo\"}'\nOut[2]: True\n\nIn [3]: json_schema.loads('{\"my_key\": \"int|str\"}') == '{\"my_key\": 123}'\nOut[3]: True\n\nIn [4]: json_schema.loads('{\"my_key\": \"int:0:10|str:3\"}') == '{\"my_key\": \"foo\"}'\nOut[4]: True\n\nIn [5]: json_schema.loads('{\"my_key\": \"int:0:10|str:3\"}') == '{\"my_key\": 3}'\nOut[5]: True\n\nIn [6]: json_schema.loads('{\"my_key\": \"int:0:10|str:2\"}') == '{\"my_key\": \"foo\"}'\nOut[6]: False\n\nIn [7]: json_schema.loads('{\"my_key\": \"int:10|str\"}') == '{\"my_key\": 123}'\nOut[7]: False\n</pre>\n<p>This will match everything:</p>\n<pre>'{\"my_key\": \"any|null\"}'\n</pre>\n</div>\n<div id=\"arrays\">\n<h3>Arrays</h3>\n<p>Arrays are ordered so your schema order matters as also its size.</p>\n<pre>'{\"my_key\": [\"str\", \"str\", \"int\"]}'\n</pre>\n<p>Will match:</p>\n<pre>'{\"my_key\": [\"foo\", \"bar\", 123]}'\n</pre>\n<p>But not</p>\n<pre>'{\"my_key\": [\"foo\", 123, \"bar\"]}'\n'{\"my_key\": [\"foo\", \"bar\", 123, 123]}'\n</pre>\n<p>If you dont know the size of your array you may user a special 2 item arrays as follows</p>\n<pre>'{\"my_key\": [\"str\", \"...\"]}'\n</pre>\n<p>That will match:</p>\n<pre>'{\"my_key\": [\"foo\"]}'\n'{\"my_key\": [\"foo\", \"bar\"]}'\n'{\"my_key\": [\"foo\", \"bar\", \"Hello World\"]}'\n'{\"my_key\": [\"foo\", \"bar\", \"Hello World\", \"etc\"]}'\n</pre>\n<p>Or even:</p>\n<pre>'{\"my_key\": [\"str|int\", \"...\"]}'\n</pre>\n<p>That will match:</p>\n<pre>'{\"my_key\": [\"foo\"]}'\n'{\"my_key\": [123]}'\n'{\"my_key\": [\"foo\", \"bar\"]}'\n'{\"my_key\": [\"foo\", 123, \"Hello World\"]}'\n'{\"my_key\": [123, \"bar\", \"Hello World\", 0]}'\n</pre>\n</div>\n<div id=\"hashs-dicts\">\n<h3>Hashs (dicts)</h3>\n<p>Hashs are not ordered so your schema order does not matters but its keys does.</p>\n<pre>'{\"my_key\": {\"internal_key_1\": \"str\", \"internal_key_2\": \"int\"}'\n</pre>\n<p>Will match:</p>\n<pre>'{\"my_key\": {\"internal_key_1\": \"foo\", \"internal_key_2\": 123}'\n'{\"my_key\": {\"internal_key_2\": 123, \"internal_key_2\": \"foo\"}'\n</pre>\n<p>But not</p>\n<pre>'{\"my_key\": {\"internal_key_1\": 123, \"internal_key_2\": \"foo\"}'\n'{\"my_key\": {\"internal_key_1\": \"foo\", \"internal_key_3\": 123}'\n'{\"my_key\": {\"internal_key_1\": \"foo\", \"internal_key_2\": 123, \"fizz\": \"buzz\"}'\n</pre>\n</div>\n<div id=\"recursivity\">\n<h3>Recursivity</h3>\n<p>All validations are recursive so they will check into arrays, hashs, array of arrays, etc.</p>\n<pre>'[{\"my_key\": [\"str|int\", \"...\"]}, {\"my_key\": \"str\"}, \"int\", [\"int|str\", \"str\"]'\n</pre>\n<p>Will match:</p>\n<pre>'[{\"my_key\": [1, \"foo\", \"bar\", 100]}, {\"my_key\": \"foo\"}, 12345, [123, \"foo\"]'\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4073095, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "161cf691e67ff421bb442c79b23f9f3d", "sha256": "57ce0525aa1062de65b4be0eed05a157741fc93544e0ee463c60d4c0c85ded21"}, "downloads": -1, "filename": "json-schema-matcher-0.1.1.tar.gz", "has_sig": false, "md5_digest": "161cf691e67ff421bb442c79b23f9f3d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 13154, "upload_time": "2016-01-12T21:26:23", "upload_time_iso_8601": "2016-01-12T21:26:23.551565Z", "url": "https://files.pythonhosted.org/packages/f5/ee/c50c6ace3200b2526eae97aa2a29fc435594ea2b176b492a1a8061bb25da/json-schema-matcher-0.1.1.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "7391945598b2fdd8304bb400da31094d", "sha256": "fa5dcbcd45f0bad597ed54210155ce40721f02e4271822664d3349f567e676d6"}, "downloads": -1, "filename": "json-schema-matcher-0.1.3.tar.gz", "has_sig": false, "md5_digest": "7391945598b2fdd8304bb400da31094d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 10380, "upload_time": "2016-03-04T19:35:57", "upload_time_iso_8601": "2016-03-04T19:35:57.766525Z", "url": "https://files.pythonhosted.org/packages/2f/1d/46c081db1991cd032a6897d03f0045296a506749fd33ba52ae1460616c3a/json-schema-matcher-0.1.3.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "aa59cd9762731ebc68f60d3b49f0053e", "sha256": "80003e2a88cdddeffc379eea7c007da5ad597c19367b734b59423676289d6903"}, "downloads": -1, "filename": "json-schema-matcher-0.1.5.tar.gz", "has_sig": false, "md5_digest": "aa59cd9762731ebc68f60d3b49f0053e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11179, "upload_time": "2016-03-09T20:33:43", "upload_time_iso_8601": "2016-03-09T20:33:43.061362Z", "url": "https://files.pythonhosted.org/packages/91/d8/22e1204058ac60cc45605af4cffac1be88ce7e7256d83d7bc7d131abf4cc/json-schema-matcher-0.1.5.tar.gz", "yanked": false}], "0.1.7": [{"comment_text": "", "digests": {"md5": "70353d84e277a35614a4292a3ccfcced", "sha256": "af83cff7b1c75d5ef6fcf0b158b4760e68124eace952d78e6094fb5dea58fc93"}, "downloads": -1, "filename": "json_schema_matcher-0.1.7-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "70353d84e277a35614a4292a3ccfcced", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15086, "upload_time": "2018-04-06T15:01:59", "upload_time_iso_8601": "2018-04-06T15:01:59.124922Z", "url": "https://files.pythonhosted.org/packages/fd/a4/66f68f7e4fe2be0319b219d31b7f15c766dcc011f495f72087fd86917806/json_schema_matcher-0.1.7-py2.py3-none-any.whl", "yanked": false}], "0.1.7.1": [{"comment_text": "", "digests": {"md5": "53d3f3f3325f1b6e1a9087c36737aa1e", "sha256": "8a647686b422a9223d8f8724117e6fd5afc13638c3801dccdef8f73d9ce1b9e8"}, "downloads": -1, "filename": "json_schema_matcher-0.1.7.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "53d3f3f3325f1b6e1a9087c36737aa1e", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15128, "upload_time": "2018-07-17T10:35:19", "upload_time_iso_8601": "2018-07-17T10:35:19.747142Z", "url": "https://files.pythonhosted.org/packages/89/bb/ec2c99e6bfac7b8662f3a4b1788b8bf0f18996d7e17892ce43590d968f34/json_schema_matcher-0.1.7.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d076054497fc1ab40469be5c379fb1b5", "sha256": "f910175601b8e53fd34c8e61f6cd013d75a90b26f92934dd2cac724176c24226"}, "downloads": -1, "filename": "json-schema-matcher-0.1.7.1.tar.gz", "has_sig": false, "md5_digest": "d076054497fc1ab40469be5c379fb1b5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11143, "upload_time": "2018-07-17T10:35:21", "upload_time_iso_8601": "2018-07-17T10:35:21.271647Z", "url": "https://files.pythonhosted.org/packages/70/b3/c3cdf35890851a43737a1c6adff990bf8d7b3d2116e13964fcaea671be48/json-schema-matcher-0.1.7.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "53d3f3f3325f1b6e1a9087c36737aa1e", "sha256": "8a647686b422a9223d8f8724117e6fd5afc13638c3801dccdef8f73d9ce1b9e8"}, "downloads": -1, "filename": "json_schema_matcher-0.1.7.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "53d3f3f3325f1b6e1a9087c36737aa1e", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 15128, "upload_time": "2018-07-17T10:35:19", "upload_time_iso_8601": "2018-07-17T10:35:19.747142Z", "url": "https://files.pythonhosted.org/packages/89/bb/ec2c99e6bfac7b8662f3a4b1788b8bf0f18996d7e17892ce43590d968f34/json_schema_matcher-0.1.7.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d076054497fc1ab40469be5c379fb1b5", "sha256": "f910175601b8e53fd34c8e61f6cd013d75a90b26f92934dd2cac724176c24226"}, "downloads": -1, "filename": "json-schema-matcher-0.1.7.1.tar.gz", "has_sig": false, "md5_digest": "d076054497fc1ab40469be5c379fb1b5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 11143, "upload_time": "2018-07-17T10:35:21", "upload_time_iso_8601": "2018-07-17T10:35:21.271647Z", "url": "https://files.pythonhosted.org/packages/70/b3/c3cdf35890851a43737a1c6adff990bf8d7b3d2116e13964fcaea671be48/json-schema-matcher-0.1.7.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:51:38 2020"}