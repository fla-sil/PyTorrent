{"info": {"author": "Danilo de Jesus da Silva Bellini", "author_email": "danilo.bellini@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "Intended Audience :: Education", "Intended Audience :: Other Audience", "Intended Audience :: Science/Research", "License :: OSI Approved :: GNU General Public License v3 (GPLv3)", "Operating System :: MacOS", "Operating System :: Microsoft :: Windows", "Operating System :: OS Independent", "Operating System :: POSIX :: Linux", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.2", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: Implementation :: CPython", "Programming Language :: Python :: Implementation :: PyPy", "Topic :: Artistic Software", "Topic :: Multimedia :: Sound/Audio", "Topic :: Multimedia :: Sound/Audio :: Analysis", "Topic :: Multimedia :: Sound/Audio :: Capture/Recording", "Topic :: Multimedia :: Sound/Audio :: Editors", "Topic :: Multimedia :: Sound/Audio :: Mixers", "Topic :: Multimedia :: Sound/Audio :: Players", "Topic :: Multimedia :: Sound/Audio :: Sound Synthesis", "Topic :: Multimedia :: Sound/Audio :: Speech", "Topic :: Scientific/Engineering", "Topic :: Software Development", "Topic :: Software Development :: Libraries", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "AudioLazy\n=========\n\n.. list-table::\n  :stub-columns: 1\n\n  * - Development\n    - |travis| |coveralls|\n  * - Last release\n    - |v| |pyversions| |implementation|\n  * - PyPI status\n    - |format| |status| |l|\n\n.. |travis| image::\n  https://img.shields.io/travis/danilobellini/audiolazy/master.svg\n  :target: https://travis-ci.org/danilobellini/audiolazy\n  :alt: Travis CI builds\n\n.. |coveralls| image::\n  https://img.shields.io/coveralls/danilobellini/audiolazy/master.svg\n  :target: https://coveralls.io/r/danilobellini/audiolazy\n  :alt: Coveralls coverage report\n\n.. |v| image::\n  https://img.shields.io/pypi/v/audiolazy.svg\n  :target: https://pypi.python.org/pypi/audiolazy\n  :alt: Last stable version (PyPI)\n\n.. |pyversions| image::\n  https://img.shields.io/pypi/pyversions/audiolazy.svg\n  :target: https://pypi.python.org/pypi/audiolazy\n  :alt: Python versions (PyPI)\n\n.. |implementation| image::\n  https://img.shields.io/pypi/implementation/audiolazy.svg\n  :target: https://pypi.python.org/pypi/audiolazy\n  :alt: Python implementations (PyPI)\n\n.. |format| image::\n  https://img.shields.io/pypi/format/audiolazy.svg\n  :target: https://pypi.python.org/pypi/audiolazy\n  :alt: Distribution format (PyPI)\n\n.. |status| image::\n  https://img.shields.io/pypi/status/audiolazy.svg\n  :target: https://pypi.python.org/pypi/audiolazy\n  :alt: Project status (PyPI)\n\n.. |l| image::\n  https://img.shields.io/pypi/l/audiolazy.svg\n  :target: https://pypi.python.org/pypi/audiolazy\n  :alt: License (PyPI)\n\nLaziness and object representation\n----------------------------------\n\nThere are several tools and packages that let the Python use and\nexpressiveness look like languages such as MatLab and Octave. However, the\neager evaluation done by most of these tools make it difficult, perhaps\nimpossible, to use them for real time audio processing. To avoid such\neagerness, one can make the calculations only when data is requested, not\nwhen the path to the data is given. This is the core idea in laziness that\nallows:\n\n- Real-time application (you don't need to wait until all data is\n  processed to have a result);\n- Endless data sequence representation;\n- Data-flow representation;\n- Task elimination when a reverse task is done: instead of doing something\n  to then undo, nothing needs to be done, and no conscious optimization\n  need to be done for that.\n\nAnother difficulty concerns expressive code creation for audio processing in\nblocks through indexes and vectors. Sometimes, that's unavoidable, or at\nleast such avoidance would limit the power of the system that works with\nsequence data.\n\nBlock sequences can be found from sample sequences being both objects, where\nthe latter can be the result of a method or function over the former. The\ninformation needed for such is the block size and where would start the next\nblock. Although one can think about the last block and the exact index where\nit would start, most of the time spent in steps like this one happens to be\nan implementation issue that just keep the focus away from the problem being\nworked on. To allow a thing like an endless data sequence, there should be\nno need to know when something stops.\n\nProbably an engineer would find the use of equations and structures from\nelectrical engineering theory much cleaner to understand than storing\neverything into data arrays, mainly when common operations are done to these\nrepresentations. What is the product of the filter with numerator\n``[1, 7, 2]`` and denominator ``[1, 0.5, 0.2]`` as its system equation with\nthe one that has the arrays reversed like ``[2, 7, 1]``? That might be simple,\nand the reversed would avoid questions like \"what comes first, the zero or the\n[minus] two exponent?\", but maybe we could get more efficient ourselves if we\nhad something easier: multiplication could be written once and for all and\nwith a representation programmers are used to see. This would be even more\nexpressive if we could get rid from the asymmetry of a method call like\n``filt1.multiply_by(filt2)``, since multiplication in this case should be\ncommutative. The use of natural operators is possible in a language that\nallows operator overloading, but for such we need to describe\nthose equations and structures as objects and object relationships.\n\nThe name ``Hz`` can be a number that would allow conversion to a default DSP\ninternal rad/samples unit, so one can write things like ``freq = 440 * Hz``.\nThis isn't difficult in probably any language, but can help in expressiveness,\nalready. If (almost) everything would need data in \"samples\" or \"rad/sample\"\nunits, constants for converting these from \"second\" and \"hertz\" would help\nwith the code expressiveness. A comb filter ``comb.tau(delay=30*s, tau=40*s)``\ncan represent a comb filter with the given delay and time constant, both in\nsamples, but with a more clear meaning for the reader than it would have with\nan expression like ``[1] + [0] * 239999 + [alpha]``. Would it be needed to\nstore all those zeros while just using the filter to get a frequency response\nplot?\n\nIt's possible to avoid some of these problems with well-chosen constants,\nduck typing, overloaded operators, functions as first-class citizens, object\noriented together with functional style programming, etc.., resources\nthat the Python language gives us for free.\n\nWhat does it do?\n----------------\n\nPrioritizing code expressiveness, clarity and simplicity, without precluding\nthe lazy evaluation, and aiming to be used together with Numpy, Scipy and\nMatplotlib as well as default Python structures like lists and generators,\nAudioLazy is a package written in pure Python proposing digital audio signal\nprocessing (DSP), featuring:\n\n- A ``Stream`` class for finite and endless signals representation with\n  elementwise operators (auto-broadcast with non-iterables) in a common\n  Python iterable container accepting heterogeneous data;\n- Strongly sample-based representation (Stream class) with easy conversion\n  to block representation using the ``Stream.blocks(size, hop)`` method;\n- Sample-based interactive processing with ``ControlStream``;\n- ``Streamix`` mixer for iterables given their starting time deltas;\n- Multi-thread audio I/O integration with PyAudio;\n- Linear filtering with Z-transform filters directly as equations (e.g.\n  ``filt = 1 / (1 - .3 * z ** -1)``), including linear time variant filters\n  (i.e., the ``a`` in ``a * z ** k`` can be a Stream instance), cascade\n  filters (behaves as a list of filters), resonators, etc.. Each\n  ``LinearFilter`` instance is compiled just in time when called;\n- Zeros and poles plots and frequency response plotting integration with\n  MatPlotLib;\n- Linear Predictive Coding (LPC) directly to ``ZFilter`` instances, from\n  which you can find PARCOR coeffs and LSFs;\n- Both sample-based (e.g., zero-cross rate, envelope, moving average,\n  clipping, unwrapping) and block-based (e.g., window functions, DFT,\n  autocorrelation, lag matrix) analysis and processing tools;\n- A simple synthesizer (Table lookup, Karplus-Strong) with processing tools\n  (Linear ADSR envelope, fade in/out, fixed duration line stream) and basic\n  wave data generation (sinusoid, white noise, impulse);\n- Biological auditory periphery modeling (ERB and gammatone filter models);\n- Multiple implementation organization as ``StrategyDict`` instances:\n  callable dictionaries that allows the same name to have several different\n  implementations (e.g. ``erb``, ``gammatone``, ``lowpass``, ``resonator``,\n  ``lpc``, ``window``);\n- Converters among MIDI pitch numbers, strings like \"F#4\" and frequencies;\n- Polynomials, Stream-based functions from itertools, math, cmath, and more!\n  Go try yourself! =)\n\nInstalling\n----------\n\nThe package works both on Linux and on Windows. You can find the last stable\nversion at `PyPI <http://pypi.python.org/pypi/audiolazy>`_ and install it with\nthe usual Python installing mechanism::\n\n  python setup.py install\n\nIf you have pip, you can go directly (use ``-U`` for update or reinstall)::\n\n  pip install audiolazy\n\nfor downloading (from PyPI) and installing the package for you, or::\n\n  pip install -U .\n\nTo install from a path that has the ``setup.py`` file and the package data\nuncompressed previously.\n\nFor the *bleeding-edge* version, you can install directly from the github\nrepository (requires ``git`` for cloning)::\n\n  pip install -U git+git://github.com/danilobellini/audiolazy.git\n\nFor older versions, you can install from the PyPI link or directly from the\ngithub repository, based on the repository tags. For example, to install the\nversion 0.04 (requires ``git`` for cloning)::\n\n  pip install -U git+git://github.com/danilobellini/audiolazy.git@v0.04\n\nThe package doesn't have any strong dependency for its core besides the Python\nitself (versions 2.7, 3.2 or newer) as well as its standard library, but you\nmight need:\n\n- PyAudio: needed for playing and recording audio (``AudioIO`` class);\n- NumPy: needed for doing some maths, such as finding the LSFs from a filter\n  or roots from a polynomial;\n- MatPlotLib: needed for all default plotting, like in ``LinearFilter.plot``\n  method and several examples;\n- SciPy (testing and examples only): used as an oracle for LTI filter testing\n  and for the Butterworth filter example;\n- Sympy (testing only): used for testing linear filters with time-varying\n  matrices of symbolic coeffs where the Stream samples are these matrices;\n- tox for testing all at once, or pytest, pytest-cov and pytest-timeout for\n  testing in a single environment (testing only): runs test suite and\n  shows code coverage status;\n- wxPython (example only): used by one example with FM synthesis in an\n  interactive GUI;\n- Tkinter (example only): needed for the pitch follower based on the\n  zero-crossing rate example GUI;\n- Music21 (example only): there's one example that gets the Bach chorals from\n  that package corpora for synthesizing and playing;\n- Sphinx (documentation only): it can create the software documentation in\n  several different file formats.\n\nBeside examples and tests, only the filter plotting with ``plot`` and\n``zplot`` methods needs MatPlotLib. Also, the routines that needs NumPy up to\nnow are:\n\n- Root finding with ``zeros`` and ``poles`` properties (filter classes) or\n  with ``roots`` property (Poly class);\n- Some Linear Predictive Coding (``lpc``) strategies: ``nautocor``,\n  ``autocor`` and ``covar``;\n- Line Spectral Frequencies ``lsf`` and ``lsf_stable`` functions.\n\nGetting started\n---------------\n\nBefore all examples below, it's easier to get everything from audiolazy\nnamespace:\n\n.. code-block:: python\n\n  from audiolazy import *\n\nAll modules starts with \"lazy\\_\", but their data is already loaded in the main\nnamespace. These two lines of code do the same thing:\n\n.. code-block:: python\n\n  from audiolazy.lazy_stream import Stream\n  from audiolazy import Stream\n\nEndless iterables with operators (be careful with loops through an endless\niterator!):\n\n.. code-block:: python\n\n  >>> a = Stream(2, -2, -1) # Periodic\n  >>> b = Stream(3, 7, 5, 4) # Periodic\n  >>> c = a + b # Elementwise sum, periodic\n  >>> c.take(15) # First 15 elements from the Stream object\n  [5, 5, 4, 6, 1, 6, 7, 2, 2, 9, 3, 3, 5, 5, 4]\n\nAnd also finite iterators (you can think on any Stream as a generator with\nelementwise operators):\n\n.. code-block:: python\n\n  >>> a = Stream([1, 2, 3, 2, 1]) # Finite, since it's a cast from an iterable\n  >>> b = Stream(3, 7, 5, 4) # Periodic\n  >>> c = a + b # Elementwise sum, finite\n  >>> list(c)\n  [4, 9, 8, 6, 4]\n\nLTI Filtering from system equations (Z-transform). After this, try summing,\ncomposing, multiplying ZFilter objects:\n\n.. code-block:: python\n\n  >>> filt = 1 - z ** -1 # Diff between a sample and the previous one\n  >>> filt\n  1 - z^-1\n  >>> data = filt([.1, .2, .4, .3, .2, -.1, -.3, -.2]) # Past memory has 0.0\n  >>> data # This should have internally [.1, .1, .2, -.1, -.1, -.3, -.2, .1]\n  <audiolazy.lazy_stream.Stream object at ...>\n  >>> data *= 10 # Elementwise gain\n  >>> [int(round(x)) for x in data] # Streams are iterables\n  [1, 1, 2, -1, -1, -3, -2, 1]\n  >>> data_int = filt([1, 2, 4, 3, 2, -1, -3, -2], zero=0) # Now zero is int\n  >>> list(data_int)\n  [1, 1, 2, -1, -1, -3, -2, 1]\n\nLTI Filter frequency response plot (needs MatPlotLib):\n\n.. code-block:: python\n\n  (1 + z ** -2).plot().show()\n\n.. image:: https://raw.github.com/danilobellini/audiolazy/master/images/filt_plot.png\n\nThe ``matplotlib.figure.Figure.show`` method won't work unless you're\nusing a newer version of MatPlotLib (works on MatPlotLib 1.2.0), but you still\ncan save the above plot directly to a PDF, PNG, etc. with older versions\n(e.g. MatPlotLib 1.0.1):\n\n.. code-block:: python\n\n  (1 + z ** -2).plot().savefig(\"my_plot.pdf\")\n\nOn the other hand, you can always show the figure using MatPlotLib directly:\n\n.. code-block:: python\n\n  from matplotlib import pyplot as plt # Or \"import pylab as plt\"\n  filt = 1 + z ** -2\n  fig1 = filt.plot(plt.figure()) # Argument not needed on the first figure\n  fig2 = filt.zplot(plt.figure()) # The argument ensures a new figure\n  plt.show()\n\nCascadeFilter instances and ParallelFilter instances are lists of filters with\nthe same operator behavior as a list, and also works for plotting linear\nfilters. Constructors accepts both a filter and an iterable with filters.\nFor example, a zeros and poles plot (needs MatPlotLib):\n\n.. code-block:: python\n\n  filt1 = CascadeFilter(0.2 - z ** -3) # 3 zeros\n  filt2 = CascadeFilter(1 / (1 -.8 * z ** -1 + .6 * z ** -2)) # 2 poles\n  # Here __add__ concatenates and __mul__ by an integer make reference copies\n  filt = (filt1 * 5 + filt2 * 10) # 15 zeros and 20 poles\n  filt.zplot().show()\n\n.. image:: https://raw.github.com/danilobellini/audiolazy/master/images/cascade_plot.png\n\nLinear Predictive Coding (LPC) autocorrelation method analysis filter\nfrequency response plot (needs MatPlotLib):\n\n.. code-block:: python\n\n  lpc([1, -2, 3, -4, -3, 2, -3, 2, 1], order=3).plot().show()\n\n.. image:: https://raw.github.com/danilobellini/audiolazy/master/images/lpc_plot.png\n\nLinear Predictive Coding covariance method analysis and synthesis filter,\nfollowed by the frequency response plot together with block data DFT\n(MatPlotLib):\n\n.. code-block:: python\n\n  >>> data = Stream(-1., 0., 1., 0.) # Periodic\n  >>> blk = data.take(200)\n  >>> analysis_filt = lpc.covar(blk, 4)\n  >>> analysis_filt\n  1 + 0.5 * z^-2 - 0.5 * z^-4\n  >>> residual = list(analysis_filt(blk))\n  >>> residual[:10]\n  [-1.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n  >>> synth_filt = 1 / analysis_filt\n  >>> synth_filt(residual).take(10)\n  [-1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 1.0, 0.0, -1.0, 0.0]\n  >>> amplified_blk = list(Stream(blk) * -200) # For alignment w/ DFT\n  >>> synth_filt.plot(blk=amplified_blk).show()\n\n.. image:: https://raw.github.com/danilobellini/audiolazy/master/images/dft_lpc_plot.png\n\nAudioLazy doesn't need any audio card to process audio, but needs PyAudio to\nplay some sound:\n\n.. code-block:: python\n\n  rate = 44100 # Sampling rate, in samples/second\n  s, Hz = sHz(rate) # Seconds and hertz\n  ms = 1e-3 * s\n  note1 = karplus_strong(440 * Hz) # Pluck \"digitar\" synth\n  note2 = zeros(300 * ms).append(karplus_strong(880 * Hz))\n  notes = (note1 + note2) * .5\n  sound = notes.take(int(2 * s)) # 2 seconds of a Karplus-Strong note\n  with AudioIO(True) as player: # True means \"wait for all sounds to stop\"\n    player.play(sound, rate=rate)\n\nSee also the docstrings and the \"examples\" directory at the github repository\nfor more help. Also, the huge test suite might help you understanding how the\npackage works and how to use it.\n\nProject files\n-------------\n\nThere are several files and directories in the AudioLazy repository (as well\nas in the source distribution):\n\n================ =============================================================\nFile/Directory   Description\n================ =============================================================\naudiolazy/       AudioLazy package modules source code\naudiolazy/tests/ Testing subpackage\ndocs/            Documentation generation scripts\nexamples/        Examples for some AudioLazy use cases\nimages/          Images referenced by some reStructuredText documentation file\nmath/            Proof for some formula used by AudioLazy using Sympy CAS\nCHANGES.rst      AudioLazy History, a.k.a. change log\nconftest.py      Configuration for py.test, to work properly with doctests on\n                 StrategyDict strategies and on an environment missing Numpy\nCOPYING.txt      License file\nMANIFEST.in      List of extra distributed files to be included in the tarball\n                 that doesn't need to be installed together with the package\nREADME.rst       Some general information about the AudioLazy project\nsetup.py         General Python setup script for installation, testing, etc.\ntox.ini          Configuration for tox, py.test and pytest-cov\n.travis.yml      Travis-CI configuration (not in PyPI tarball/\"egg\" source\n                 distribution)\n================ =============================================================\n\nThe ``examples`` and the ``math`` directories might be useful for an AudioLazy\nuser. All Python files in these two directories are scripts intended to run on\nboth Python 2 and 3 unless they need something not yet available for Python 3\n(e.g. wxPython), most of them have some external dependency.\n\nAudioLazy changes history\n-------------------------\n\n*** Version 0.6 (Examples, STFT, phon2dB, tox, CI, wave file) ***\n\n+ examples:\n\n  - Formant synthesis for voiced \"ah-eh-ee-oh-oo\"\n  - Musical keyboard synth example with a QWERTY keyboard (also via jack!)\n  - Random synthesis with saving and memoization\n  - Aesthetics for the Tkinter GUI examples\n  - Matplotlib animated plot with mic input data (also works via jack!)\n  - Perceptual experiment with butterworth filters (Scipy) applied to white\n    noise (based on the Demonstrations to Auditory Scene Analysis)\n  - Psychoacoustics using ISO/FDIS 226:2003\n\n    * Equal loudness contour curves plotting\n    * Constant phon chirp playing\n\n  - Partial recreation of the \"Windows and Figures of Merit\" F. Harris\n    comparison table and window plots\n  - Playing/synthesizing \"Ode to Joy\" from its \"score\" written as code\n  - All recording/playback examples now prepared for using both the default\n    API and receiving it as an argument like \"jack\" or \"alsa\"\n  - Realtime STFT (Short Time Fourier Transform) effects:\n\n    * Robotize\n    * \"Roll\" the magnitude spectrum while keeping the phase\n\n+ general:\n\n  - Tox for testing with CPython 2.7, CPython 3.2~3.6 and PyPy\n  - Continuous integration wih Travis CI and Coveralls\n  - New ``_internals.py`` module to avoid exposing package internals together\n    with the API, which also allowed the new simplified ``__init__.py``\n  - Renewed setup.py in both its internals (e.g. using AST instead of\n    string manipulation to avoid importing the package before installation)\n    and its interface (e.g. the ``test`` command now calls ``tox``)\n  - New ``conftest.py`` for testing doctests from strategies inside\n    StrategyDict instances without the need of a ``__test__`` in the module\n    and for skipping doctests known to need Numpy when it's not available\n  - New ``math`` directory for adding scripts with symbolic math calculations\n    (with Sympy) done for designing (or as a proof) for parts of the\n    AudioLazy code. All lowpass and highpass strategies have their design\n    explicitly explained there\n\n+ lazy_analysis:\n\n  - New ``overlap_add`` StrategyDict instance, allowing resynth after block\n    processing/analysis, featuring block size auto-detection and window\n    normalization to keep the output in the [-1; 1] range. Has 2\n    implementations keeping the same interface:\n\n    * ``numpy`` (*default*): needs Numpy arrays internally\n    * ``list``: uses lists instead, doesn't need Numpy and was tested on Pypy\n\n  - New ``stft`` StrategyDict instance, allowing Short Time Fourier Transform\n    block processors / phase vocoder by:\n\n    * Passing a function as the first parameter\n    * Using a ``stft`` strategies as a decorator\n    * Creating new strategies by avoiding the only positional parameter\n\n    It was created with three Numpy-based strategies:\n\n    * ``rfft``, ``real`` or ``base`` (*default*): needs ``numpy.fft.rfft``\n      internally, as well as its inverse, to process a block in the\n      frequency domain with values up to the Nyquist frequency, by assuming\n      the input signal is real\n    * ``cfft`` or ``complex``: Alike to the default approach but uses the\n      ``numpy.fft.fft`` for a full complex-valued block in frequency domain,\n      which means the output is a complex signal\n    * ``cfftr`` or ``complex_real``: same to ``stft.cfft`` strategy, but\n      keeps only the real part of the result\n\n    Parameters allows changing the default zero-phase behavior (``before``\n    and ``after`` functions), the transform and inverse transform functions,\n    the overlap-add strategy (as well as its parameters), and obviously the\n    block size and hop\n\n  - The ``window`` StrategyDict now returns the \"periodic\" window data\n    instead of the \"symmetric\" window to be used with the STFT directly\n  - New ``wsymm`` StrategyDict with the same strategies from ``window`` but\n    returning a \"symmetric\" window\n  - Default ``window`` strategy is the Hann window (the same for ``wsymm``)\n  - New ``cos`` strategy for ``window`` and ``wsymm`` implementing cosine to\n    the power of alpha\n\n+ lazy_auditory:\n\n  - New ``phon2dB`` StrategyDict instance with the ISO/FDIS 226:2003 model\n    for getting a SPL (Sound Pressure Level) in dBs from a phon value\n\n+ lazy_core:\n\n  - Add support to the new ``@`` matrix multiplication operator\n  - ``OpMethod.get()`` now accepts numbers ``\"1\"`` and ``\"2\"`` as strings for\n    unary and binary query for operators, and ``\"all\"`` is the new default, so\n    ``OpMethod.get(without=\"2 ~\")`` would get all operators but the [reversed\n    or not] binary ones and the invert operator, which means it would yield\n    only the unary ``\"+\"`` (pos) and ``-`` (neg), as probably was expected;\n    OpMethod also had a bug fix regarding the shift operators\n  - Strategy name autocomplete works on IPython since StrategyDict now\n    changes its instance dictionary (e.g. ``vars(window)``) instead of\n    depending on the ``__getattr__`` method\n  - ``StrategyDict.strategy`` method now allows the strategy function name to\n    be kept by using the new ``keep_name`` keyword-only argument. It might be\n    helpful for adding built-in functions as well as other immutable\n    callables as multi-name strategies with the same behavior as the item\n    assignment for adding a strategy\n  - The default strategy in a StrategyDict instance is now removed when all\n    its keys/names are removed. The new default is the next added strategy\n  - Strategies can be removed both by their item name and their attribute,\n    and removing an attribute that isn't an strategy recovers the strategy\n    attribute if its name belongs to a strategy\n  - MultiKeyDict methods ``key2keys`` and ``value2keys`` to help getting a\n    tuple with all keys that points to the same value, ordered by the\n    insertion order\n\n+ lazy_filters:\n\n  - LinearFilter coefficients can now be a Stream of Numpy matrices, as well\n    as Sympy symbols (including symbolic matrices).\n  - New simple lowpass/highpass IIR filter strategies:\n\n    * ``highpass.z`` (taken as the new ``highpass`` default)\n    * ``lowpass.z``\n    * ``highpass.pole_exp``\n    * ``highpass.z_exp``\n    * ``lowpass.z_exp``\n\n    Where the ``\"z\"`` name denotes the presence of a single zero (besides the\n    single pole) and ``\"_exp\"`` denotes the exponential approximation from\n    a matched Z-Transform pole value from the equivalent or mirrored analog\n    filter equation (Laplace). The absence of such suffix denotes it was\n    designed directly as a digital filter.\n\n+ lazy_io:\n\n  - New ``api`` keyword argument for AudioIO, allowing e.g. integration with\n    JACK (for now this needs ``chunks.size = 1``)\n  - ``AudioIO.open`` and ``AudioIO.record`` now allows keyword arguments, to\n    be passed directly to PyAudio, including the now default \"channels\"\n    keyword (old \"nchannels\" keyword still works, for backward compatibility)\n\n+ lazy_math:\n\n  - Signal function ``sign`` now works on Python 3\n\n+ lazy_misc:\n\n  - New ``cached`` decorator caching the results for a function without\n    keyword arguments\n\n+ lazy_poly:\n\n  - Complex numbers and Sympy symbols can now be used as Poly powers\n  - Poly instances are now based on OrderedDict (stores the creation order\n    internally) and Poly.terms now support both a ``sort`` and a ``reverse``\n    keyword arguments to choose the yielding order (sorted by powers, keep\n    creation order or reverse any of these)\n  - Immutable Poly behavior is now based on a cached frozenset (doesn't depend\n    on the terms order) and includes Poly.zero as a read-only property (after\n    the hash is required)\n  - The Horner-like polynomial evaluation scheme (which needs sorting) is now\n    enabled/disabled via a keyword argument. By default, it's enabled just for\n    simple polynomials, but optional when powers are sortable (e.g. in a\n    Laurent polynomial)\n\n+ lazy_text:\n\n  - New ``format_docstring`` decorator that use format-style templates to\n    assign docstrings to functions, intended to avoid docstring copies on\n    StrategyDict instances.\n\n+ lazy_wav (*new!*):\n\n  - ``WavStream`` class for opening Wave files. Can load 24-bit audio files!\n    Tested with 8 bits files (unsigned int) and 16/24/32 bits (signed int)\n    mono and stereo files, both casting the data to a float in [-1;1) interval\n    (default) and keeping the original integer data as it is\n\n+ multiple modules:\n\n  - (*lazy_math and lazy_stream*) Renamed the elementwised ``abs`` to\n    ``absolute``, so no Python built-in name is ever replaced when importing\n    with ``from audiolazy import *``. Also, the built-in ``abs`` now can be\n    used directly with Stream instances\n  - (*lazy_analysis and lazy_misc*) Renamed ``freq2lag`` and ``lag2freq`` to\n    use ``2`` instead of ``_to_``, and moved them to lazy_misc\n\n\n*** Version 0.05 (Python 2 & 3, more examples, refactoring, polinomials) ***\n\n+ examples:\n\n  - Pitch follower via zero-crossing rate with Tkinter GUI\n  - Pi with Madhava-Gregory-Leibniz series and Machin formula using Stream\n  - LPC plot with DFT, showing two formants (magnitude peaks)\n  - A somehow disturbing example based on Shepard \"going higher\" tone\n  - Linear Periodically Time Variant filter example\n  - Now the Bach choral player can play in loop\n  - New DFT-based pitch follower (guitar tuner like) and better ZCR-based\n    pitch follower by using a simple limiter\n  - Butterworth filter from SciPy as a ZFilter instance, with plots\n\n+ general:\n\n  - Now with 82% code coverage in tests\n  - Mock testing for audio output\n  - Bugfixes (``envelope.abs``, ``midi2str``, ``StreamTeeHub.blocks``, etc.)\n  - Extended domain for some functions by using ``inf`` and ``nan``\n  - Removed deprecated ``Stream.tee()`` method\n  - Constants ``DEFAULT_CHUNK_SIZE`` and ``LATEX_PI_SYMBOL`` were removed:\n    the default values are now changeable and inside ``chunks`` and\n    ``float_str``, respectively (see docstrings for more details)\n  - No more distinction between ``__div__`` and ``__truediv__`` (Python 2.7)\n  - Now AudioLazy works with Python 3.2 and 3.3!\n  - Test skipping for tests that depends upon something that is Python\n    version-specific\n  - Test \"xfail\" using XFailer classes when depending package (e.g. pyaudio)\n    is unavailable in the testing environment\n\n+ lazy_compat (*new!*):\n\n  - Module for Python 2.x and 3.x compatibility resources (constants\n    and functions) without AudioLazy dependencies (i.e., no Stream here)\n  - Common place for iterable-based version of itertools/built-ins in both\n    Python 2 and 3 starting with \"x\": ``xmap``, ``xfilter``, ``xzip``,\n    ``xrange``, ``xzip_longest``. Versions with \"i\" are kept in lazy_itertools\n    module to return Stream instances (``imap``, ``izip``, ``izip.longest``,\n    etc.), and Python 2 list-based behaviour of ``range`` is kept as\n    ``orange`` (a fruitful name)\n  - New ``meta`` function for creating metaclasses always in a \"Python 3\n    look-alike\" style, keeping the semantics (including the inheritance\n    hierarchy, which won't have any extra \"dummy\" class)\n\n+ lazy_core:\n\n  - New ``OpMethod`` class with 33 operator method instances and querying\n  - Changed ``AbstractOperatorOverloaderMeta`` to the new OpMethod-based\n    interface\n  - Now StrategyDict changes the module ``__test__`` so that doctests from\n    strategies are found by the doctest finder.\n\n+ lazy_filters:\n\n  - ZFilter instances are now better prepared for Stream coeffs and\n    operator-based filter creation, as well as a new copy helper method\n  - Filters are now hashable (e.g., they can be used in sets)\n\n+ lazy_io:\n\n  - New RecStream class for recording Stream instances with a ``stop`` method\n  - Now chunks is a StrategyDict here, instead of two lazy_misc functions\n  - Now the default chunk size is stored in chunks.size, and can be changed\n\n+ lazy_itertools:\n\n  - New ``accumulate`` itertool from Python 3, available also in Python 2\n    yielding a Stream. This is a new StrategyDict with one more strategy in\n    Python 3\n  - Strategy ``chain.from_iterable`` is now available (Stream version\n    itertool), and ``chain`` is now a StrategyDict\n  - Now ``izip`` is a StrategyDict, with ``izip.smallest`` (*default*) and\n    ``izip.longest`` strategies\n\n+ lazy_misc:\n\n  - New ``rint`` for \"round integer\" operations as well as other higher step\n    integer quantization\n  - Now ``almost_eq`` is a single StrategyDict with both ``bits`` (*default*,\n    comparison by significand/mantissa bits) and ``diff`` (absolute value\n    difference) strategies\n\n+ lazy_poly:\n\n  - New ``x`` Poly object (to be used like the ``z`` ZFilter instance)\n  - Waring-Lagrange polynomial interpolator StrategyDict\n  - General resample based on Waring-Lagrange interpolators, working with\n    time-varying sample rate\n  - New methods ``Poly.is_polynomial()`` and ``Poly.is_laurent()``\n  - New property ``Poly.order`` for common polynomials\n  - Now ``Poly.integrate()`` and ``Poly.diff()`` methods returns Poly\n    instances, and the ``zero`` from the caller Poly is always kept in\n    result (this includes many bugfixes)\n  - Poly instances are now better prepared for Stream coeffs and evaluation,\n    including a helper ``Poly.copy()`` method\n  - Poly is now hashable and have __setitem__ (using both isn't allowed for\n    the same instance)\n\n+ lazy_stream:\n\n  - Stream.take now accepts floats, so with first ``sHz`` output as\n    ``s`` (for second) you can now use ``my_stream.take(20 * s)`` directly,\n    as well as a \"take all\" feature ``my_stream.take(inf)``\n  - New ``Stream.peek()`` method, allowing taking items while keeping them\n    as the next to be yielded by the Stream or StreamTeeHub\n  - New ``Stream.skip()`` method for neglecting the leading items without\n    storing them\n  - New ``Stream.limit()`` method, to enforce a maximum \"length\"\n  - StreamTeeHub methods ``skip()``, ``limit()``, ``append()``, ``map()`` and\n    ``filter()`` returns the modified copy as a Stream instance (i.e., works\n    like ``Stream(my_stream_tee_hub).method_name()``)\n  - Control over the module name in ``tostream`` (needed for lazy_itertools)\n\n+ lazy_synth:\n\n  - Input \"dur\" in ``ones()``, ``zeros()``, ``white_noise()`` and\n    ``impulse()`` now can be inf (besides None)\n  - Impulse now have ``one=1.`` and ``zero=0.`` arguments\n  - New ``gauss_noise`` for Normal / Gaussian-distributed noise\n  - White-noise limits parametrization\n\n+ lazy_text (*new!*):\n\n  - Got all text/string formatting functions from lazy_misc\n  - Namespace clean-up: new StrategyDict ``float_str`` embraces older\n    rational/pi/auto formatters in one instance\n\n*** Version 0.04 (Documentation, LPC, Plots!) ***\n\n+ examples:\n\n  - Random Bach Choral playing example (needs Music21 corpus)\n\n+ general:\n\n  - Sphinx documentation!\n  - Self-generated package and module summary at the docstring\n  - Integration with NumPy (tested on 1.5.0, 1.6.1 and 1.6.2) and MatPlotLib\n    (tested on 1.0.1 and 1.2.0)\n  - More docstrings and doctests, besides lots of corrections\n  - Itemized package description, installation instructions and getting\n    started examples with plots in README.rst\n  - Now with 5400+ tests and 75% code coverage\n\n+ lazy_analysis:\n\n  - One-dimensional autocorrelation function with ``acorr`` and lag\n    \"covariance\" (due to lpc.covar) with ``lag_matrix``\n  - DFT for any frequency, given a block\n  - Three envelope filtering strategies (time domain)\n  - Three moving average filter strategies\n  - Signal clipping function\n  - Signal unwrap, defaults to the ``2 * pi`` radians range but configurable\n    to other units and max signal difference allowed\n  - New AMDF algorithm as a non-linear filter\n\n+ lazy_core:\n\n  - StrategyDict instances now are singletons of a new class, which have\n    lazy non-memoized docstrings based on their contents\n\n+ lazy_filters:\n\n  - ZFilter composition/substitution, e.g., ``(1 + z ** -1)(1 / z)`` results\n    to the ZFilter instance ``1 + z``\n  - New LinearFilter.plot() directly plots the frequency response of a LTI\n    filter to a MatPlotLib figure. Configurable:\n\n    * Linear (*default*) or logarithmic frequency scale\n    * Linear, squared or dB (*default*) magnitude scale\n    * Plots together the DFT of a given block, if needed. Useful for LPC\n    * Phase unwrapping (defaults to True)\n    * Allows frequency in Hz and in rad/sample. When using radians units,\n      the tick locator is based on ``pi``, as well as the formatter\n\n  - New LinearFilter.zplot() for plotting the zero-pole plane of a LTI filter\n    directly into a MatPlotLib figure\n  - New LinearFilterProperties read-only properties ``numpolyz`` and\n    ``denpolyz`` returning polynomials based on ``x = z`` instead of the\n    polynomials based on ``x = z ** -1`` returned from ``numpoly`` and\n    ``denpoly``\n  - New LinearFilter properties ``poles`` and ``zeros``, based on NumPy\n  - New class ``FilterList`` for filter grouping with a ``callables``\n    property, for casting from lists with constant gain values as filters.\n    It is an instance of ``FilterListMeta`` (old CascadeFilterMeta), and\n    CascadeFilter now inherits from this FilterList\n  - More LinearFilter behaviour into FilterList: Plotting (``plot`` and\n    ``zplot``), ``poles``, ``zeros``, ``is_lti`` and ``is_causal``\n  - New ``ParallelFilter`` class, inheriting from FilterList\n  - Now comb is a StrategyDict too, with 3 strategies:\n\n    * ``comb.fb`` (*default*): Feedback comb filter (IIR or time variant)\n    * ``comb.tau``: Same to the feedback strategy, but with a time decay\n      ``tau`` parameter (time in samples up to ``1/e`` amplitude, or\n      -8.686 dB) instead of a gain ``alpha``\n    * ``comb.ff``: Feed-forward comb filter (FIR or time variant)\n\n+ lazy_lpc (*new!*):\n\n  - Linear Predictive Coding (LPC) coefficients as a ZFilter from:\n\n    * ``lpc.autocor`` (*default*): Auto-selects autocorrelation implementation\n      (Faster)\n    * ``lpc.nautocor``: Autocorrelation, with linear system solved by NumPy\n      (Safer)\n    * ``lpc.kautocor``: Autocorrelation, using the Levinson-Durbin algorithm\n    * ``lpc.covar`` or ``lpc.ncovar``: Covariance, with linear system solved\n      by NumPy\n    * ``lpc.kcovar``: Covariance, slower. Mainly for those without NumPy\n    * ``levinson_durbin``: Same to the ``lpc.kautocor``, but with the\n      autocorrelation vector as the input, not the signal data\n\n  - Toeplitz matrix as a list of lists\n  - Partial correlation coefficients (PARCOR) or reflection coefficients\n  - Line Spectral Frequencies (LSF)\n  - Stability testers for filters with LSF and PARCOR\n\n+ lazy_math:\n\n  - New ``sign`` gets the sign of a given sequence.\n\n+ lazy_midi:\n\n  - Completed converters between frequency (in hertz), string and MIDI pitch\n    numbers\n  - New ``octaves`` for finding all octaves in a frequency range given one\n    frequency\n\n+ lazy_misc:\n\n  - New ``rational_formatter``: casts floats to strings, perhaps with a symbol\n    string as multiplier\n  - New ``pi_formatter``: same to ``rational_formatter``, but with the symbol\n    fixed to pi, mainly for use in MatPlotLib labels\n\n+ lazy_poly:\n\n  - New Poly.roots property, based on NumPy\n\n+ lazy_stream:\n\n  - Streamix class for mixing Streams based on delta starting times,\n    automatically managing the need for multiple \"tracks\"\n\n+ lazy_synth:\n\n  - Karplus-Strong algorithm now uses ``tau`` time decay constant instead of\n    the comb filter ``alpha`` gain.\n\n\n*** Version 0.03 (Time variant filters, examples, etc.. Major changes!) ***\n\n+ examples (*new!*):\n\n  - Gammatone frequency and impulse response plots example\n  - FM synthesis example for benchmarking with CPython and PyPy\n  - Simple I/O wire example, connecting the input directly to the output\n  - Modulo Counter graphics w/ FM synthesis audio in a wxPython application\n  - Window functions plot example (all window strategies)\n\n+ general:\n\n  - Namespace cleanup with __all__\n  - Lots of optimization and refactoring, also on tests and setup.py\n  - Better docstrings and README.rst\n  - Doctests (with pytest) and code coverage (needs pytest-cov)\n  - Now with 5200+ tests and 79% code coverage\n\n+ lazy_analysis (*new!*):\n\n  - New ``window`` StrategyDict instance, with:\n\n    * Hamming (*default*)\n    * Hann\n    * Rectangular\n    * Bartlett (triangular with zero endpoints)\n    * Triangular (without zeros)\n    * Blackman\n\n+ lazy_auditory (*new!*):\n\n  - Two ERB (Equivalent Rectangular Bandwidth) models (both by Glasberg and\n    Moore)\n  - Function to find gammatone bandwidth from ERB for any gammatone order\n  - Three gammatone filter implementations: sampled impulse response, Slaney,\n    Klapuri\n\n+ lazy_core:\n\n  - MultiKeyDict: an \"inversible\" dict (i.e., a dict whose values must be\n    hashable) that may have several keys for each value\n  - StrategyDict: callable dict to store multiple function implementations\n    in. Inherits from MultiKeyDict, so the same strategy may have multiple\n    names. It's also an iterable on its values (functions)\n\n+ lazy_filters:\n\n  - LTI and LTIFreq no longer exists! They were renamed to LinearFilter and\n    ZFilter since filters now can have Streams as coefficients (they don't\n    need to be \"Time Invariant\" anymore)\n  - Linear filters are now iterables, allowing:\n\n    * Comparison with almost_eq like ``assert almost_eq(filt1, filt2)``\n    * Expression like ``numerator_data, denominator_data = filt``, where\n      each data is a list of pairs that can be used as input for Poly,\n      LinearFilter or ZFilter\n\n  - LinearFilterProperties class, implementing numlist, denlist, numdict and\n    dendict, besides numerator and denominator, from numpoly and denpoly\n  - Comparison \"==\" and \"!=\" are now strict\n  - CascadeFilter: list of filters that behave as a filter\n  - LinearFilter.__call__ now has the \"zero\" optional argument (allows\n    non-float)\n  - LinearFilter.__call__ memory input can be a function or a Stream\n  - LinearFilter.linearize: linear interpolated delay-line from fractional\n    delays\n  - Feedback comb filter\n  - 4 resonator filter models with 2-poles with exponential approximation\n    for finding the radius from the bandwidth\n  - Simple one pole lowpass and highpass filters\n\n+ lazy_io:\n\n  - AudioIO.record method, creating audio Stream instances from device data\n\n+ lazy_itertools:\n\n  - Now with a changed tee function that allows not-iterable inputs,\n    helpful to let the same code work with Stream instances and constants\n\n+ lazy_math (*new!*):\n\n  - dB10, dB20 functions for converting amplitude (squared or linear,\n    respectively) to logarithmic dB (power) values from complex-numbers\n    (like the ones returned by LinearFilter.freq_response)\n  - Most functions from math module, but working decorated with elementwise\n    (``sin``, ``cos``, ``sqrt``, etc.), and the constants ``e`` and ``pi``\n  - Other functions: ``factorial``, ``ln`` (the ``log`` from math), ``log2``,\n    ``cexp`` (the ``exp`` from cmath) and ``phase`` (from cmath)\n\n+ lazy_midi:\n\n  - MIDI pitch numbers and Hz frequency converters from strings like \"C#4\"\n\n+ lazy_misc:\n\n  - Elementwise decorator now based on both argument keyword and position\n\n+ lazy_poly:\n\n  - Horner-like scheme for Poly.__call__ evaluation\n  - Poly now can have Streams as coefficients\n  - Comparison \"==\" and \"!=\" are now strict\n\n+ lazy_stream:\n\n  - Methods and attributes from Stream elements can be used directly,\n    elementwise, like ``my_stream.imag`` and ``my_stream.conjugate()`` in a\n    stream with complex numbers\n  - New thub() function and StreamTeeHub class: tee (or \"T\") hub auto-copier\n    to help working with Stream instances *almost* the same way as you do with\n    numbers\n\n+ lazy_synth:\n\n  - Karplus-Strong synthesis algorithm\n  - ADSR envelope\n  - Impulse, ones, zeros/zeroes and white noise Stream generator\n  - Faster sinusoid not based on the TableLookup class\n\n\n*** Version 0.02 (Interactive Stream objects & Table lookup synthesis!) ***\n\n+ general:\n\n  - 10 new tests\n\n+ lazy_midi (*new!*):\n\n  - MIDI to frequency (Hz) conversor\n\n+ lazy_misc:\n\n  - sHz function for explicit time (s) and frequency (Hz) units conversion\n\n+ lazy_stream:\n\n  - Interactive processing with ControlStream instances\n  - Stream class now allows inheritance\n\n+ lazy_synth (*new!*):\n\n  - TableLookup class, with sinusoid and sawtooth instances\n  - Endless counter with modulo, allowing Stream inputs, mainly created for\n    TableLookup instances\n  - Line, fade in, fade out, ADS attack with endless sustain\n\n\n*** Version 0.01 (First \"pre-alpha\" version!) ***\n\n+ general:\n\n  - 4786 tests (including parametrized tests), based on pytest\n\n+ lazy_core:\n\n  - AbstractOperatorOverloaderMeta class to help massive operator\n    overloading as needed by Stream, Poly and LTIFreq (now ZFilter) classes\n\n+ lazy_filters:\n\n  - LTI filters, callable objects with operators and derivatives, returning\n    Stream instances\n  - Explicit filter formulas with the ``z`` object, e.g.\n    ``filt = 1 / (.5 + z ** -1)``\n\n+ lazy_io:\n\n  - Multi-thread audio playing (based on PyAudio), with context manager\n    interface\n\n+ lazy_itertools:\n\n  - Stream-based version of all itertools\n\n+ lazy_misc:\n\n  - Block-based processing, given size and (optionally) hop\n  - Simple zero padding generator\n  - Elementwise decorator for functions\n  - Bit-based and diff-based \"almost equal\" comparison function for floats\n    and iterables with floats. Also works with (finite) generators\n\n+ lazy_poly:\n\n  - Poly: polynomials based on dictionaries, with list interface and\n    operators\n\n+ lazy_stream:\n\n  - Stream: each instance is basically a generator with elementwise\n    operators\n  - Decorator ``tostream`` so generator functions can return Stream objects", "description_content_type": null, "docs_url": "https://pythonhosted.org/audiolazy/", "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/danilobellini/audiolazy", "keywords": null, "license": "GPLv3", "maintainer": null, "maintainer_email": null, "name": "audiolazy", "package_url": "https://pypi.org/project/audiolazy/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/audiolazy/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://github.com/danilobellini/audiolazy"}, "release_url": "https://pypi.org/project/audiolazy/0.6/", "requires_dist": null, "requires_python": null, "summary": "Real-Time Expressive Digital Signal Processing (DSP) Package for Python!", "version": "0.6", "yanked": false, "html_description": "<div class=\"project-description\">\n            <table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<tbody>\n<tr><th>Development</th>\n<td><a href=\"https://travis-ci.org/danilobellini/audiolazy\" rel=\"nofollow\"><img alt=\"Travis CI builds\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/eb939fc27829d8b36bd022fd623851df548b8488/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f64616e696c6f62656c6c696e692f617564696f6c617a792f6d61737465722e737667\"></a> <a href=\"https://coveralls.io/r/danilobellini/audiolazy\" rel=\"nofollow\"><img alt=\"Coveralls coverage report\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/427918c753ebf5c5448ac4b960aff74d4f896fd1/68747470733a2f2f696d672e736869656c64732e696f2f636f766572616c6c732f64616e696c6f62656c6c696e692f617564696f6c617a792f6d61737465722e737667\"></a></td>\n</tr>\n<tr><th>Last release</th>\n<td><a href=\"https://pypi.python.org/pypi/audiolazy\" rel=\"nofollow\"><img alt=\"Last stable version (PyPI)\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6eea2d330edb06201bcaa4494b140101000b1ebf/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f617564696f6c617a792e737667\"></a> <a href=\"https://pypi.python.org/pypi/audiolazy\" rel=\"nofollow\"><img alt=\"Python versions (PyPI)\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/497aa4943f5411150a44658e162890fa54167da6/68747470733a2f2f696d672e736869656c64732e696f2f707970692f707976657273696f6e732f617564696f6c617a792e737667\"></a> <a href=\"https://pypi.python.org/pypi/audiolazy\" rel=\"nofollow\"><img alt=\"Python implementations (PyPI)\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/662b7faf3bbd982de1ebf8c88c5948ab13bd1bef/68747470733a2f2f696d672e736869656c64732e696f2f707970692f696d706c656d656e746174696f6e2f617564696f6c617a792e737667\"></a></td>\n</tr>\n<tr><th>PyPI status</th>\n<td><a href=\"https://pypi.python.org/pypi/audiolazy\" rel=\"nofollow\"><img alt=\"Distribution format (PyPI)\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4de9f985a8ba483301527c04390c3af67cb3e069/68747470733a2f2f696d672e736869656c64732e696f2f707970692f666f726d61742f617564696f6c617a792e737667\"></a> <a href=\"https://pypi.python.org/pypi/audiolazy\" rel=\"nofollow\"><img alt=\"Project status (PyPI)\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7a517111fb71663930c95ed91a277376916b039d/68747470733a2f2f696d672e736869656c64732e696f2f707970692f7374617475732f617564696f6c617a792e737667\"></a> <a href=\"https://pypi.python.org/pypi/audiolazy\" rel=\"nofollow\"><img alt=\"License (PyPI)\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c898512d20eb00966d56b84484ea2f68ca5d36a1/68747470733a2f2f696d672e736869656c64732e696f2f707970692f6c2f617564696f6c617a792e737667\"></a></td>\n</tr>\n</tbody>\n</table>\n<div id=\"laziness-and-object-representation\">\n<h2>Laziness and object representation</h2>\n<p>There are several tools and packages that let the Python use and\nexpressiveness look like languages such as MatLab and Octave. However, the\neager evaluation done by most of these tools make it difficult, perhaps\nimpossible, to use them for real time audio processing. To avoid such\neagerness, one can make the calculations only when data is requested, not\nwhen the path to the data is given. This is the core idea in laziness that\nallows:</p>\n<ul>\n<li>Real-time application (you don\u2019t need to wait until all data is\nprocessed to have a result);</li>\n<li>Endless data sequence representation;</li>\n<li>Data-flow representation;</li>\n<li>Task elimination when a reverse task is done: instead of doing something\nto then undo, nothing needs to be done, and no conscious optimization\nneed to be done for that.</li>\n</ul>\n<p>Another difficulty concerns expressive code creation for audio processing in\nblocks through indexes and vectors. Sometimes, that\u2019s unavoidable, or at\nleast such avoidance would limit the power of the system that works with\nsequence data.</p>\n<p>Block sequences can be found from sample sequences being both objects, where\nthe latter can be the result of a method or function over the former. The\ninformation needed for such is the block size and where would start the next\nblock. Although one can think about the last block and the exact index where\nit would start, most of the time spent in steps like this one happens to be\nan implementation issue that just keep the focus away from the problem being\nworked on. To allow a thing like an endless data sequence, there should be\nno need to know when something stops.</p>\n<p>Probably an engineer would find the use of equations and structures from\nelectrical engineering theory much cleaner to understand than storing\neverything into data arrays, mainly when common operations are done to these\nrepresentations. What is the product of the filter with numerator\n<tt>[1, 7, 2]</tt> and denominator <tt>[1, 0.5, 0.2]</tt> as its system equation with\nthe one that has the arrays reversed like <tt>[2, 7, 1]</tt>? That might be simple,\nand the reversed would avoid questions like \u201cwhat comes first, the zero or the\n[minus] two exponent?\u201d, but maybe we could get more efficient ourselves if we\nhad something easier: multiplication could be written once and for all and\nwith a representation programmers are used to see. This would be even more\nexpressive if we could get rid from the asymmetry of a method call like\n<tt>filt1.multiply_by(filt2)</tt>, since multiplication in this case should be\ncommutative. The use of natural operators is possible in a language that\nallows operator overloading, but for such we need to describe\nthose equations and structures as objects and object relationships.</p>\n<p>The name <tt>Hz</tt> can be a number that would allow conversion to a default DSP\ninternal rad/samples unit, so one can write things like <tt>freq = 440 * Hz</tt>.\nThis isn\u2019t difficult in probably any language, but can help in expressiveness,\nalready. If (almost) everything would need data in \u201csamples\u201d or \u201crad/sample\u201d\nunits, constants for converting these from \u201csecond\u201d and \u201chertz\u201d would help\nwith the code expressiveness. A comb filter <tt>comb.tau(delay=30*s, tau=40*s)</tt>\ncan represent a comb filter with the given delay and time constant, both in\nsamples, but with a more clear meaning for the reader than it would have with\nan expression like <tt>[1] + [0] * 239999 + [alpha]</tt>. Would it be needed to\nstore all those zeros while just using the filter to get a frequency response\nplot?</p>\n<p>It\u2019s possible to avoid some of these problems with well-chosen constants,\nduck typing, overloaded operators, functions as first-class citizens, object\noriented together with functional style programming, etc.., resources\nthat the Python language gives us for free.</p>\n</div>\n<div id=\"what-does-it-do\">\n<h2>What does it do?</h2>\n<p>Prioritizing code expressiveness, clarity and simplicity, without precluding\nthe lazy evaluation, and aiming to be used together with Numpy, Scipy and\nMatplotlib as well as default Python structures like lists and generators,\nAudioLazy is a package written in pure Python proposing digital audio signal\nprocessing (DSP), featuring:</p>\n<ul>\n<li>A <tt>Stream</tt> class for finite and endless signals representation with\nelementwise operators (auto-broadcast with non-iterables) in a common\nPython iterable container accepting heterogeneous data;</li>\n<li>Strongly sample-based representation (Stream class) with easy conversion\nto block representation using the <tt>Stream.blocks(size, hop)</tt> method;</li>\n<li>Sample-based interactive processing with <tt>ControlStream</tt>;</li>\n<li><tt>Streamix</tt> mixer for iterables given their starting time deltas;</li>\n<li>Multi-thread audio I/O integration with PyAudio;</li>\n<li>Linear filtering with Z-transform filters directly as equations (e.g.\n<tt>filt = 1 / (1 - .3 * z ** <span class=\"pre\">-1)</span></tt>), including linear time variant filters\n(i.e., the <tt>a</tt> in <tt>a * z ** k</tt> can be a Stream instance), cascade\nfilters (behaves as a list of filters), resonators, etc.. Each\n<tt>LinearFilter</tt> instance is compiled just in time when called;</li>\n<li>Zeros and poles plots and frequency response plotting integration with\nMatPlotLib;</li>\n<li>Linear Predictive Coding (LPC) directly to <tt>ZFilter</tt> instances, from\nwhich you can find PARCOR coeffs and LSFs;</li>\n<li>Both sample-based (e.g., zero-cross rate, envelope, moving average,\nclipping, unwrapping) and block-based (e.g., window functions, DFT,\nautocorrelation, lag matrix) analysis and processing tools;</li>\n<li>A simple synthesizer (Table lookup, Karplus-Strong) with processing tools\n(Linear ADSR envelope, fade in/out, fixed duration line stream) and basic\nwave data generation (sinusoid, white noise, impulse);</li>\n<li>Biological auditory periphery modeling (ERB and gammatone filter models);</li>\n<li>Multiple implementation organization as <tt>StrategyDict</tt> instances:\ncallable dictionaries that allows the same name to have several different\nimplementations (e.g. <tt>erb</tt>, <tt>gammatone</tt>, <tt>lowpass</tt>, <tt>resonator</tt>,\n<tt>lpc</tt>, <tt>window</tt>);</li>\n<li>Converters among MIDI pitch numbers, strings like \u201cF#4\u201d and frequencies;</li>\n<li>Polynomials, Stream-based functions from itertools, math, cmath, and more!\nGo try yourself! =)</li>\n</ul>\n</div>\n<div id=\"installing\">\n<h2>Installing</h2>\n<p>The package works both on Linux and on Windows. You can find the last stable\nversion at <a href=\"http://pypi.python.org/pypi/audiolazy\" rel=\"nofollow\">PyPI</a> and install it with\nthe usual Python installing mechanism:</p>\n<pre>python setup.py install\n</pre>\n<p>If you have pip, you can go directly (use <tt><span class=\"pre\">-U</span></tt> for update or reinstall):</p>\n<pre>pip install audiolazy\n</pre>\n<p>for downloading (from PyPI) and installing the package for you, or:</p>\n<pre>pip install -U .\n</pre>\n<p>To install from a path that has the <tt>setup.py</tt> file and the package data\nuncompressed previously.</p>\n<p>For the <em>bleeding-edge</em> version, you can install directly from the github\nrepository (requires <tt>git</tt> for cloning):</p>\n<pre>pip install -U git+git://github.com/danilobellini/audiolazy.git\n</pre>\n<p>For older versions, you can install from the PyPI link or directly from the\ngithub repository, based on the repository tags. For example, to install the\nversion 0.04 (requires <tt>git</tt> for cloning):</p>\n<pre>pip install -U git+git://github.com/danilobellini/audiolazy.git@v0.04\n</pre>\n<p>The package doesn\u2019t have any strong dependency for its core besides the Python\nitself (versions 2.7, 3.2 or newer) as well as its standard library, but you\nmight need:</p>\n<ul>\n<li>PyAudio: needed for playing and recording audio (<tt>AudioIO</tt> class);</li>\n<li>NumPy: needed for doing some maths, such as finding the LSFs from a filter\nor roots from a polynomial;</li>\n<li>MatPlotLib: needed for all default plotting, like in <tt>LinearFilter.plot</tt>\nmethod and several examples;</li>\n<li>SciPy (testing and examples only): used as an oracle for LTI filter testing\nand for the Butterworth filter example;</li>\n<li>Sympy (testing only): used for testing linear filters with time-varying\nmatrices of symbolic coeffs where the Stream samples are these matrices;</li>\n<li>tox for testing all at once, or pytest, pytest-cov and pytest-timeout for\ntesting in a single environment (testing only): runs test suite and\nshows code coverage status;</li>\n<li>wxPython (example only): used by one example with FM synthesis in an\ninteractive GUI;</li>\n<li>Tkinter (example only): needed for the pitch follower based on the\nzero-crossing rate example GUI;</li>\n<li>Music21 (example only): there\u2019s one example that gets the Bach chorals from\nthat package corpora for synthesizing and playing;</li>\n<li>Sphinx (documentation only): it can create the software documentation in\nseveral different file formats.</li>\n</ul>\n<p>Beside examples and tests, only the filter plotting with <tt>plot</tt> and\n<tt>zplot</tt> methods needs MatPlotLib. Also, the routines that needs NumPy up to\nnow are:</p>\n<ul>\n<li>Root finding with <tt>zeros</tt> and <tt>poles</tt> properties (filter classes) or\nwith <tt>roots</tt> property (Poly class);</li>\n<li>Some Linear Predictive Coding (<tt>lpc</tt>) strategies: <tt>nautocor</tt>,\n<tt>autocor</tt> and <tt>covar</tt>;</li>\n<li>Line Spectral Frequencies <tt>lsf</tt> and <tt>lsf_stable</tt> functions.</li>\n</ul>\n</div>\n<div id=\"getting-started\">\n<h2>Getting started</h2>\n<p>Before all examples below, it\u2019s easier to get everything from audiolazy\nnamespace:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">audiolazy</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n</pre>\n<p>All modules starts with \u201clazy_\u201d, but their data is already loaded in the main\nnamespace. These two lines of code do the same thing:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">audiolazy.lazy_stream</span> <span class=\"kn\">import</span> <span class=\"n\">Stream</span>\n<span class=\"kn\">from</span> <span class=\"nn\">audiolazy</span> <span class=\"kn\">import</span> <span class=\"n\">Stream</span>\n</pre>\n<p>Endless iterables with operators (be careful with loops through an endless\niterator!):</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">Stream</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\"># Periodic</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">Stream</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"c1\"># Periodic</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span> <span class=\"c1\"># Elementwise sum, periodic</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">)</span> <span class=\"c1\"># First 15 elements from the Stream object</span>\n<span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">]</span>\n</pre>\n<p>And also finite iterators (you can think on any Stream as a generator with\nelementwise operators):</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">Stream</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])</span> <span class=\"c1\"># Finite, since it's a cast from an iterable</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">Stream</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"c1\"># Periodic</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span> <span class=\"c1\"># Elementwise sum, finite</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span>\n<span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">]</span>\n</pre>\n<p>LTI Filtering from system equations (Z-transform). After this, try summing,\ncomposing, multiplying ZFilter objects:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">filt</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">z</span> <span class=\"o\">**</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"c1\"># Diff between a sample and the previous one</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">filt</span>\n<span class=\"mi\">1</span> <span class=\"o\">-</span> <span class=\"n\">z</span><span class=\"o\">^-</span><span class=\"mi\">1</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">filt</span><span class=\"p\">([</span><span class=\"o\">.</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">.</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">.</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"o\">.</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"o\">.</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">-.</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-.</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"o\">-.</span><span class=\"mi\">2</span><span class=\"p\">])</span> <span class=\"c1\"># Past memory has 0.0</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">data</span> <span class=\"c1\"># This should have internally [.1, .1, .2, -.1, -.1, -.3, -.2, .1]</span>\n<span class=\"o\">&lt;</span><span class=\"n\">audiolazy</span><span class=\"o\">.</span><span class=\"n\">lazy_stream</span><span class=\"o\">.</span><span class=\"n\">Stream</span> <span class=\"nb\">object</span> <span class=\"n\">at</span> <span class=\"o\">...&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">data</span> <span class=\"o\">*=</span> <span class=\"mi\">10</span> <span class=\"c1\"># Elementwise gain</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"nb\">round</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">data</span><span class=\"p\">]</span> <span class=\"c1\"># Streams are iterables</span>\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">data_int</span> <span class=\"o\">=</span> <span class=\"n\">filt</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"n\">zero</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\"># Now zero is int</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">data_int</span><span class=\"p\">)</span>\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>\n</pre>\n<p>LTI Filter frequency response plot (needs MatPlotLib):</p>\n<pre><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">z</span> <span class=\"o\">**</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<img alt=\"https://raw.github.com/danilobellini/audiolazy/master/images/filt_plot.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1f2a2c9c4815c1602b6d18c6c5536df872b78dc4/68747470733a2f2f7261772e6769746875622e636f6d2f64616e696c6f62656c6c696e692f617564696f6c617a792f6d61737465722f696d616765732f66696c745f706c6f742e706e67\">\n<p>The <tt>matplotlib.figure.Figure.show</tt> method won\u2019t work unless you\u2019re\nusing a newer version of MatPlotLib (works on MatPlotLib 1.2.0), but you still\ncan save the above plot directly to a PDF, PNG, etc. with older versions\n(e.g. MatPlotLib 1.0.1):</p>\n<pre><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">z</span> <span class=\"o\">**</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">savefig</span><span class=\"p\">(</span><span class=\"s2\">\"my_plot.pdf\"</span><span class=\"p\">)</span>\n</pre>\n<p>On the other hand, you can always show the figure using MatPlotLib directly:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">matplotlib</span> <span class=\"kn\">import</span> <span class=\"n\">pyplot</span> <span class=\"k\">as</span> <span class=\"n\">plt</span> <span class=\"c1\"># Or \"import pylab as plt\"</span>\n<span class=\"n\">filt</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">z</span> <span class=\"o\">**</span> <span class=\"o\">-</span><span class=\"mi\">2</span>\n<span class=\"n\">fig1</span> <span class=\"o\">=</span> <span class=\"n\">filt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"p\">())</span> <span class=\"c1\"># Argument not needed on the first figure</span>\n<span class=\"n\">fig2</span> <span class=\"o\">=</span> <span class=\"n\">filt</span><span class=\"o\">.</span><span class=\"n\">zplot</span><span class=\"p\">(</span><span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">figure</span><span class=\"p\">())</span> <span class=\"c1\"># The argument ensures a new figure</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<p>CascadeFilter instances and ParallelFilter instances are lists of filters with\nthe same operator behavior as a list, and also works for plotting linear\nfilters. Constructors accepts both a filter and an iterable with filters.\nFor example, a zeros and poles plot (needs MatPlotLib):</p>\n<pre><span class=\"n\">filt1</span> <span class=\"o\">=</span> <span class=\"n\">CascadeFilter</span><span class=\"p\">(</span><span class=\"mf\">0.2</span> <span class=\"o\">-</span> <span class=\"n\">z</span> <span class=\"o\">**</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"c1\"># 3 zeros</span>\n<span class=\"n\">filt2</span> <span class=\"o\">=</span> <span class=\"n\">CascadeFilter</span><span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">-.</span><span class=\"mi\">8</span> <span class=\"o\">*</span> <span class=\"n\">z</span> <span class=\"o\">**</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"o\">.</span><span class=\"mi\">6</span> <span class=\"o\">*</span> <span class=\"n\">z</span> <span class=\"o\">**</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"c1\"># 2 poles</span>\n<span class=\"c1\"># Here __add__ concatenates and __mul__ by an integer make reference copies</span>\n<span class=\"n\">filt</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">filt1</span> <span class=\"o\">*</span> <span class=\"mi\">5</span> <span class=\"o\">+</span> <span class=\"n\">filt2</span> <span class=\"o\">*</span> <span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"c1\"># 15 zeros and 20 poles</span>\n<span class=\"n\">filt</span><span class=\"o\">.</span><span class=\"n\">zplot</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<img alt=\"https://raw.github.com/danilobellini/audiolazy/master/images/cascade_plot.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8c53aa441f2d00418e4715eda5dff7cfd9942f65/68747470733a2f2f7261772e6769746875622e636f6d2f64616e696c6f62656c6c696e692f617564696f6c617a792f6d61737465722f696d616765732f636173636164655f706c6f742e706e67\">\n<p>Linear Predictive Coding (LPC) autocorrelation method analysis filter\nfrequency response plot (needs MatPlotLib):</p>\n<pre><span class=\"n\">lpc</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">order</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<img alt=\"https://raw.github.com/danilobellini/audiolazy/master/images/lpc_plot.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4b3240685bda3b80c230b8a9dc11bf2a7bd16803/68747470733a2f2f7261772e6769746875622e636f6d2f64616e696c6f62656c6c696e692f617564696f6c617a792f6d61737465722f696d616765732f6c70635f706c6f742e706e67\">\n<p>Linear Predictive Coding covariance method analysis and synthesis filter,\nfollowed by the frequency response plot together with block data DFT\n(MatPlotLib):</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">Stream</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mf\">1.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">1.</span><span class=\"p\">,</span> <span class=\"mf\">0.</span><span class=\"p\">)</span> <span class=\"c1\"># Periodic</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">blk</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">analysis_filt</span> <span class=\"o\">=</span> <span class=\"n\">lpc</span><span class=\"o\">.</span><span class=\"n\">covar</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">analysis_filt</span>\n<span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"mf\">0.5</span> <span class=\"o\">*</span> <span class=\"n\">z</span><span class=\"o\">^-</span><span class=\"mi\">2</span> <span class=\"o\">-</span> <span class=\"mf\">0.5</span> <span class=\"o\">*</span> <span class=\"n\">z</span><span class=\"o\">^-</span><span class=\"mi\">4</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">residual</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">analysis_filt</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">))</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">residual</span><span class=\"p\">[:</span><span class=\"mi\">10</span><span class=\"p\">]</span>\n<span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">synth_filt</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">/</span> <span class=\"n\">analysis_filt</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">synth_filt</span><span class=\"p\">(</span><span class=\"n\">residual</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">0.0</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">amplified_blk</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">Stream</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"o\">-</span><span class=\"mi\">200</span><span class=\"p\">)</span> <span class=\"c1\"># For alignment w/ DFT</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">synth_filt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"o\">=</span><span class=\"n\">amplified_blk</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</pre>\n<img alt=\"https://raw.github.com/danilobellini/audiolazy/master/images/dft_lpc_plot.png\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/feae60d992f5a551b31f732f5930db2ade23b13b/68747470733a2f2f7261772e6769746875622e636f6d2f64616e696c6f62656c6c696e692f617564696f6c617a792f6d61737465722f696d616765732f6466745f6c70635f706c6f742e706e67\">\n<p>AudioLazy doesn\u2019t need any audio card to process audio, but needs PyAudio to\nplay some sound:</p>\n<pre><span class=\"n\">rate</span> <span class=\"o\">=</span> <span class=\"mi\">44100</span> <span class=\"c1\"># Sampling rate, in samples/second</span>\n<span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">Hz</span> <span class=\"o\">=</span> <span class=\"n\">sHz</span><span class=\"p\">(</span><span class=\"n\">rate</span><span class=\"p\">)</span> <span class=\"c1\"># Seconds and hertz</span>\n<span class=\"n\">ms</span> <span class=\"o\">=</span> <span class=\"mf\">1e-3</span> <span class=\"o\">*</span> <span class=\"n\">s</span>\n<span class=\"n\">note1</span> <span class=\"o\">=</span> <span class=\"n\">karplus_strong</span><span class=\"p\">(</span><span class=\"mi\">440</span> <span class=\"o\">*</span> <span class=\"n\">Hz</span><span class=\"p\">)</span> <span class=\"c1\"># Pluck \"digitar\" synth</span>\n<span class=\"n\">note2</span> <span class=\"o\">=</span> <span class=\"n\">zeros</span><span class=\"p\">(</span><span class=\"mi\">300</span> <span class=\"o\">*</span> <span class=\"n\">ms</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">karplus_strong</span><span class=\"p\">(</span><span class=\"mi\">880</span> <span class=\"o\">*</span> <span class=\"n\">Hz</span><span class=\"p\">))</span>\n<span class=\"n\">notes</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">note1</span> <span class=\"o\">+</span> <span class=\"n\">note2</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"o\">.</span><span class=\"mi\">5</span>\n<span class=\"n\">sound</span> <span class=\"o\">=</span> <span class=\"n\">notes</span><span class=\"o\">.</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">s</span><span class=\"p\">))</span> <span class=\"c1\"># 2 seconds of a Karplus-Strong note</span>\n<span class=\"k\">with</span> <span class=\"n\">AudioIO</span><span class=\"p\">(</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">player</span><span class=\"p\">:</span> <span class=\"c1\"># True means \"wait for all sounds to stop\"</span>\n  <span class=\"n\">player</span><span class=\"o\">.</span><span class=\"n\">play</span><span class=\"p\">(</span><span class=\"n\">sound</span><span class=\"p\">,</span> <span class=\"n\">rate</span><span class=\"o\">=</span><span class=\"n\">rate</span><span class=\"p\">)</span>\n</pre>\n<p>See also the docstrings and the \u201cexamples\u201d directory at the github repository\nfor more help. Also, the huge test suite might help you understanding how the\npackage works and how to use it.</p>\n</div>\n<div id=\"project-files\">\n<h2>Project files</h2>\n<p>There are several files and directories in the AudioLazy repository (as well\nas in the source distribution):</p>\n<table>\n<colgroup>\n<col>\n<col>\n</colgroup>\n<thead>\n<tr><th>File/Directory</th>\n<th>Description</th>\n</tr>\n</thead>\n<tbody>\n<tr><td>audiolazy/</td>\n<td>AudioLazy package modules source code</td>\n</tr>\n<tr><td>audiolazy/tests/</td>\n<td>Testing subpackage</td>\n</tr>\n<tr><td>docs/</td>\n<td>Documentation generation scripts</td>\n</tr>\n<tr><td>examples/</td>\n<td>Examples for some AudioLazy use cases</td>\n</tr>\n<tr><td>images/</td>\n<td>Images referenced by some reStructuredText documentation file</td>\n</tr>\n<tr><td>math/</td>\n<td>Proof for some formula used by AudioLazy using Sympy CAS</td>\n</tr>\n<tr><td>CHANGES.rst</td>\n<td>AudioLazy History, a.k.a. change log</td>\n</tr>\n<tr><td>conftest.py</td>\n<td>Configuration for py.test, to work properly with doctests on\nStrategyDict strategies and on an environment missing Numpy</td>\n</tr>\n<tr><td>COPYING.txt</td>\n<td>License file</td>\n</tr>\n<tr><td>MANIFEST.in</td>\n<td>List of extra distributed files to be included in the tarball\nthat doesn\u2019t need to be installed together with the package</td>\n</tr>\n<tr><td>README.rst</td>\n<td>Some general information about the AudioLazy project</td>\n</tr>\n<tr><td>setup.py</td>\n<td>General Python setup script for installation, testing, etc.</td>\n</tr>\n<tr><td>tox.ini</td>\n<td>Configuration for tox, py.test and pytest-cov</td>\n</tr>\n<tr><td>.travis.yml</td>\n<td>Travis-CI configuration (not in PyPI tarball/\u201degg\u201d source\ndistribution)</td>\n</tr>\n</tbody>\n</table>\n<p>The <tt>examples</tt> and the <tt>math</tt> directories might be useful for an AudioLazy\nuser. All Python files in these two directories are scripts intended to run on\nboth Python 2 and 3 unless they need something not yet available for Python 3\n(e.g. wxPython), most of them have some external dependency.</p>\n</div>\n<div id=\"audiolazy-changes-history\">\n<h2>AudioLazy changes history</h2>\n<p><strong>* Version 0.6 (Examples, STFT, phon2dB, tox, CI, wave file) *</strong></p>\n<ul>\n<li><p>examples:</p>\n<ul>\n<li>Formant synthesis for voiced \u201cah-eh-ee-oh-oo\u201d</li>\n<li>Musical keyboard synth example with a QWERTY keyboard (also via jack!)</li>\n<li>Random synthesis with saving and memoization</li>\n<li>Aesthetics for the Tkinter GUI examples</li>\n<li>Matplotlib animated plot with mic input data (also works via jack!)</li>\n<li>Perceptual experiment with butterworth filters (Scipy) applied to white\nnoise (based on the Demonstrations to Auditory Scene Analysis)</li>\n<li>Psychoacoustics using ISO/FDIS 226:2003<ul>\n<li>Equal loudness contour curves plotting</li>\n<li>Constant phon chirp playing</li>\n</ul>\n</li>\n<li>Partial recreation of the \u201cWindows and Figures of Merit\u201d F. Harris\ncomparison table and window plots</li>\n<li>Playing/synthesizing \u201cOde to Joy\u201d from its \u201cscore\u201d written as code</li>\n<li>All recording/playback examples now prepared for using both the default\nAPI and receiving it as an argument like \u201cjack\u201d or \u201calsa\u201d</li>\n<li>Realtime STFT (Short Time Fourier Transform) effects:<ul>\n<li>Robotize</li>\n<li>\u201cRoll\u201d the magnitude spectrum while keeping the phase</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>general:</p>\n<ul>\n<li>Tox for testing with CPython 2.7, CPython 3.2~3.6 and PyPy</li>\n<li>Continuous integration wih Travis CI and Coveralls</li>\n<li>New <tt>_internals.py</tt> module to avoid exposing package internals together\nwith the API, which also allowed the new simplified <tt>__init__.py</tt></li>\n<li>Renewed setup.py in both its internals (e.g. using AST instead of\nstring manipulation to avoid importing the package before installation)\nand its interface (e.g. the <tt>test</tt> command now calls <tt>tox</tt>)</li>\n<li>New <tt>conftest.py</tt> for testing doctests from strategies inside\nStrategyDict instances without the need of a <tt>__test__</tt> in the module\nand for skipping doctests known to need Numpy when it\u2019s not available</li>\n<li>New <tt>math</tt> directory for adding scripts with symbolic math calculations\n(with Sympy) done for designing (or as a proof) for parts of the\nAudioLazy code. All lowpass and highpass strategies have their design\nexplicitly explained there</li>\n</ul>\n</li>\n<li><p>lazy_analysis:</p>\n<ul>\n<li><p>New <tt>overlap_add</tt> StrategyDict instance, allowing resynth after block\nprocessing/analysis, featuring block size auto-detection and window\nnormalization to keep the output in the [-1; 1] range. Has 2\nimplementations keeping the same interface:</p>\n<ul>\n<li><tt>numpy</tt> (<em>default</em>): needs Numpy arrays internally</li>\n<li><tt>list</tt>: uses lists instead, doesn\u2019t need Numpy and was tested on Pypy</li>\n</ul>\n</li>\n<li><p>New <tt>stft</tt> StrategyDict instance, allowing Short Time Fourier Transform\nblock processors / phase vocoder by:</p>\n<ul>\n<li>Passing a function as the first parameter</li>\n<li>Using a <tt>stft</tt> strategies as a decorator</li>\n<li>Creating new strategies by avoiding the only positional parameter</li>\n</ul>\n<p>It was created with three Numpy-based strategies:</p>\n<ul>\n<li><tt>rfft</tt>, <tt>real</tt> or <tt>base</tt> (<em>default</em>): needs <tt>numpy.fft.rfft</tt>\ninternally, as well as its inverse, to process a block in the\nfrequency domain with values up to the Nyquist frequency, by assuming\nthe input signal is real</li>\n<li><tt>cfft</tt> or <tt>complex</tt>: Alike to the default approach but uses the\n<tt>numpy.fft.fft</tt> for a full complex-valued block in frequency domain,\nwhich means the output is a complex signal</li>\n<li><tt>cfftr</tt> or <tt>complex_real</tt>: same to <tt>stft.cfft</tt> strategy, but\nkeeps only the real part of the result</li>\n</ul>\n<p>Parameters allows changing the default zero-phase behavior (<tt>before</tt>\nand <tt>after</tt> functions), the transform and inverse transform functions,\nthe overlap-add strategy (as well as its parameters), and obviously the\nblock size and hop</p>\n</li>\n<li><p>The <tt>window</tt> StrategyDict now returns the \u201cperiodic\u201d window data\ninstead of the \u201csymmetric\u201d window to be used with the STFT directly</p>\n</li>\n<li><p>New <tt>wsymm</tt> StrategyDict with the same strategies from <tt>window</tt> but\nreturning a \u201csymmetric\u201d window</p>\n</li>\n<li><p>Default <tt>window</tt> strategy is the Hann window (the same for <tt>wsymm</tt>)</p>\n</li>\n<li><p>New <tt>cos</tt> strategy for <tt>window</tt> and <tt>wsymm</tt> implementing cosine to\nthe power of alpha</p>\n</li>\n</ul>\n</li>\n<li><p>lazy_auditory:</p>\n<ul>\n<li>New <tt>phon2dB</tt> StrategyDict instance with the ISO/FDIS 226:2003 model\nfor getting a SPL (Sound Pressure Level) in dBs from a phon value</li>\n</ul>\n</li>\n<li><p>lazy_core:</p>\n<ul>\n<li>Add support to the new <tt>@</tt> matrix multiplication operator</li>\n<li><tt>OpMethod.get()</tt> now accepts numbers <tt>\"1\"</tt> and <tt>\"2\"</tt> as strings for\nunary and binary query for operators, and <tt>\"all\"</tt> is the new default, so\n<tt><span class=\"pre\">OpMethod.get(without=\"2</span> ~\")</tt> would get all operators but the [reversed\nor not] binary ones and the invert operator, which means it would yield\nonly the unary <tt>\"+\"</tt> (pos) and <tt>-</tt> (neg), as probably was expected;\nOpMethod also had a bug fix regarding the shift operators</li>\n<li>Strategy name autocomplete works on IPython since StrategyDict now\nchanges its instance dictionary (e.g. <tt>vars(window)</tt>) instead of\ndepending on the <tt>__getattr__</tt> method</li>\n<li><tt>StrategyDict.strategy</tt> method now allows the strategy function name to\nbe kept by using the new <tt>keep_name</tt> keyword-only argument. It might be\nhelpful for adding built-in functions as well as other immutable\ncallables as multi-name strategies with the same behavior as the item\nassignment for adding a strategy</li>\n<li>The default strategy in a StrategyDict instance is now removed when all\nits keys/names are removed. The new default is the next added strategy</li>\n<li>Strategies can be removed both by their item name and their attribute,\nand removing an attribute that isn\u2019t an strategy recovers the strategy\nattribute if its name belongs to a strategy</li>\n<li>MultiKeyDict methods <tt>key2keys</tt> and <tt>value2keys</tt> to help getting a\ntuple with all keys that points to the same value, ordered by the\ninsertion order</li>\n</ul>\n</li>\n<li><p>lazy_filters:</p>\n<ul>\n<li><p>LinearFilter coefficients can now be a Stream of Numpy matrices, as well\nas Sympy symbols (including symbolic matrices).</p>\n</li>\n<li><p>New simple lowpass/highpass IIR filter strategies:</p>\n<ul>\n<li><tt>highpass.z</tt> (taken as the new <tt>highpass</tt> default)</li>\n<li><tt>lowpass.z</tt></li>\n<li><tt>highpass.pole_exp</tt></li>\n<li><tt>highpass.z_exp</tt></li>\n<li><tt>lowpass.z_exp</tt></li>\n</ul>\n<p>Where the <tt>\"z\"</tt> name denotes the presence of a single zero (besides the\nsingle pole) and <tt>\"_exp\"</tt> denotes the exponential approximation from\na matched Z-Transform pole value from the equivalent or mirrored analog\nfilter equation (Laplace). The absence of such suffix denotes it was\ndesigned directly as a digital filter.</p>\n</li>\n</ul>\n</li>\n<li><p>lazy_io:</p>\n<ul>\n<li>New <tt>api</tt> keyword argument for AudioIO, allowing e.g. integration with\nJACK (for now this needs <tt>chunks.size = 1</tt>)</li>\n<li><tt>AudioIO.open</tt> and <tt>AudioIO.record</tt> now allows keyword arguments, to\nbe passed directly to PyAudio, including the now default \u201cchannels\u201d\nkeyword (old \u201cnchannels\u201d keyword still works, for backward compatibility)</li>\n</ul>\n</li>\n<li><p>lazy_math:</p>\n<ul>\n<li>Signal function <tt>sign</tt> now works on Python 3</li>\n</ul>\n</li>\n<li><p>lazy_misc:</p>\n<ul>\n<li>New <tt>cached</tt> decorator caching the results for a function without\nkeyword arguments</li>\n</ul>\n</li>\n<li><p>lazy_poly:</p>\n<ul>\n<li>Complex numbers and Sympy symbols can now be used as Poly powers</li>\n<li>Poly instances are now based on OrderedDict (stores the creation order\ninternally) and Poly.terms now support both a <tt>sort</tt> and a <tt>reverse</tt>\nkeyword arguments to choose the yielding order (sorted by powers, keep\ncreation order or reverse any of these)</li>\n<li>Immutable Poly behavior is now based on a cached frozenset (doesn\u2019t depend\non the terms order) and includes Poly.zero as a read-only property (after\nthe hash is required)</li>\n<li>The Horner-like polynomial evaluation scheme (which needs sorting) is now\nenabled/disabled via a keyword argument. By default, it\u2019s enabled just for\nsimple polynomials, but optional when powers are sortable (e.g. in a\nLaurent polynomial)</li>\n</ul>\n</li>\n<li><p>lazy_text:</p>\n<ul>\n<li>New <tt>format_docstring</tt> decorator that use format-style templates to\nassign docstrings to functions, intended to avoid docstring copies on\nStrategyDict instances.</li>\n</ul>\n</li>\n<li><p>lazy_wav (<em>new!</em>):</p>\n<ul>\n<li><tt>WavStream</tt> class for opening Wave files. Can load 24-bit audio files!\nTested with 8 bits files (unsigned int) and 16/24/32 bits (signed int)\nmono and stereo files, both casting the data to a float in [-1;1) interval\n(default) and keeping the original integer data as it is</li>\n</ul>\n</li>\n<li><p>multiple modules:</p>\n<ul>\n<li>(<em>lazy_math and lazy_stream</em>) Renamed the elementwised <tt>abs</tt> to\n<tt>absolute</tt>, so no Python built-in name is ever replaced when importing\nwith <tt>from audiolazy import *</tt>. Also, the built-in <tt>abs</tt> now can be\nused directly with Stream instances</li>\n<li>(<em>lazy_analysis and lazy_misc</em>) Renamed <tt>freq2lag</tt> and <tt>lag2freq</tt> to\nuse <tt>2</tt> instead of <tt>_to_</tt>, and moved them to lazy_misc</li>\n</ul>\n</li>\n</ul>\n<p><strong>* Version 0.05 (Python 2 &amp; 3, more examples, refactoring, polinomials) *</strong></p>\n<ul>\n<li>examples:<ul>\n<li>Pitch follower via zero-crossing rate with Tkinter GUI</li>\n<li>Pi with Madhava-Gregory-Leibniz series and Machin formula using Stream</li>\n<li>LPC plot with DFT, showing two formants (magnitude peaks)</li>\n<li>A somehow disturbing example based on Shepard \u201cgoing higher\u201d tone</li>\n<li>Linear Periodically Time Variant filter example</li>\n<li>Now the Bach choral player can play in loop</li>\n<li>New DFT-based pitch follower (guitar tuner like) and better ZCR-based\npitch follower by using a simple limiter</li>\n<li>Butterworth filter from SciPy as a ZFilter instance, with plots</li>\n</ul>\n</li>\n<li>general:<ul>\n<li>Now with 82% code coverage in tests</li>\n<li>Mock testing for audio output</li>\n<li>Bugfixes (<tt>envelope.abs</tt>, <tt>midi2str</tt>, <tt>StreamTeeHub.blocks</tt>, etc.)</li>\n<li>Extended domain for some functions by using <tt>inf</tt> and <tt>nan</tt></li>\n<li>Removed deprecated <tt>Stream.tee()</tt> method</li>\n<li>Constants <tt>DEFAULT_CHUNK_SIZE</tt> and <tt>LATEX_PI_SYMBOL</tt> were removed:\nthe default values are now changeable and inside <tt>chunks</tt> and\n<tt>float_str</tt>, respectively (see docstrings for more details)</li>\n<li>No more distinction between <tt>__div__</tt> and <tt>__truediv__</tt> (Python 2.7)</li>\n<li>Now AudioLazy works with Python 3.2 and 3.3!</li>\n<li>Test skipping for tests that depends upon something that is Python\nversion-specific</li>\n<li>Test \u201cxfail\u201d using XFailer classes when depending package (e.g. pyaudio)\nis unavailable in the testing environment</li>\n</ul>\n</li>\n<li>lazy_compat (<em>new!</em>):<ul>\n<li>Module for Python 2.x and 3.x compatibility resources (constants\nand functions) without AudioLazy dependencies (i.e., no Stream here)</li>\n<li>Common place for iterable-based version of itertools/built-ins in both\nPython 2 and 3 starting with \u201cx\u201d: <tt>xmap</tt>, <tt>xfilter</tt>, <tt>xzip</tt>,\n<tt>xrange</tt>, <tt>xzip_longest</tt>. Versions with \u201ci\u201d are kept in lazy_itertools\nmodule to return Stream instances (<tt>imap</tt>, <tt>izip</tt>, <tt>izip.longest</tt>,\netc.), and Python 2 list-based behaviour of <tt>range</tt> is kept as\n<tt>orange</tt> (a fruitful name)</li>\n<li>New <tt>meta</tt> function for creating metaclasses always in a \u201cPython 3\nlook-alike\u201d style, keeping the semantics (including the inheritance\nhierarchy, which won\u2019t have any extra \u201cdummy\u201d class)</li>\n</ul>\n</li>\n<li>lazy_core:<ul>\n<li>New <tt>OpMethod</tt> class with 33 operator method instances and querying</li>\n<li>Changed <tt>AbstractOperatorOverloaderMeta</tt> to the new OpMethod-based\ninterface</li>\n<li>Now StrategyDict changes the module <tt>__test__</tt> so that doctests from\nstrategies are found by the doctest finder.</li>\n</ul>\n</li>\n<li>lazy_filters:<ul>\n<li>ZFilter instances are now better prepared for Stream coeffs and\noperator-based filter creation, as well as a new copy helper method</li>\n<li>Filters are now hashable (e.g., they can be used in sets)</li>\n</ul>\n</li>\n<li>lazy_io:<ul>\n<li>New RecStream class for recording Stream instances with a <tt>stop</tt> method</li>\n<li>Now chunks is a StrategyDict here, instead of two lazy_misc functions</li>\n<li>Now the default chunk size is stored in chunks.size, and can be changed</li>\n</ul>\n</li>\n<li>lazy_itertools:<ul>\n<li>New <tt>accumulate</tt> itertool from Python 3, available also in Python 2\nyielding a Stream. This is a new StrategyDict with one more strategy in\nPython 3</li>\n<li>Strategy <tt>chain.from_iterable</tt> is now available (Stream version\nitertool), and <tt>chain</tt> is now a StrategyDict</li>\n<li>Now <tt>izip</tt> is a StrategyDict, with <tt>izip.smallest</tt> (<em>default</em>) and\n<tt>izip.longest</tt> strategies</li>\n</ul>\n</li>\n<li>lazy_misc:<ul>\n<li>New <tt>rint</tt> for \u201cround integer\u201d operations as well as other higher step\ninteger quantization</li>\n<li>Now <tt>almost_eq</tt> is a single StrategyDict with both <tt>bits</tt> (<em>default</em>,\ncomparison by significand/mantissa bits) and <tt>diff</tt> (absolute value\ndifference) strategies</li>\n</ul>\n</li>\n<li>lazy_poly:<ul>\n<li>New <tt>x</tt> Poly object (to be used like the <tt>z</tt> ZFilter instance)</li>\n<li>Waring-Lagrange polynomial interpolator StrategyDict</li>\n<li>General resample based on Waring-Lagrange interpolators, working with\ntime-varying sample rate</li>\n<li>New methods <tt>Poly.is_polynomial()</tt> and <tt>Poly.is_laurent()</tt></li>\n<li>New property <tt>Poly.order</tt> for common polynomials</li>\n<li>Now <tt>Poly.integrate()</tt> and <tt>Poly.diff()</tt> methods returns Poly\ninstances, and the <tt>zero</tt> from the caller Poly is always kept in\nresult (this includes many bugfixes)</li>\n<li>Poly instances are now better prepared for Stream coeffs and evaluation,\nincluding a helper <tt>Poly.copy()</tt> method</li>\n<li>Poly is now hashable and have __setitem__ (using both isn\u2019t allowed for\nthe same instance)</li>\n</ul>\n</li>\n<li>lazy_stream:<ul>\n<li>Stream.take now accepts floats, so with first <tt>sHz</tt> output as\n<tt>s</tt> (for second) you can now use <tt>my_stream.take(20 * s)</tt> directly,\nas well as a \u201ctake all\u201d feature <tt>my_stream.take(inf)</tt></li>\n<li>New <tt>Stream.peek()</tt> method, allowing taking items while keeping them\nas the next to be yielded by the Stream or StreamTeeHub</li>\n<li>New <tt>Stream.skip()</tt> method for neglecting the leading items without\nstoring them</li>\n<li>New <tt>Stream.limit()</tt> method, to enforce a maximum \u201clength\u201d</li>\n<li>StreamTeeHub methods <tt>skip()</tt>, <tt>limit()</tt>, <tt>append()</tt>, <tt>map()</tt> and\n<tt>filter()</tt> returns the modified copy as a Stream instance (i.e., works\nlike <tt><span class=\"pre\">Stream(my_stream_tee_hub).method_name()</span></tt>)</li>\n<li>Control over the module name in <tt>tostream</tt> (needed for lazy_itertools)</li>\n</ul>\n</li>\n<li>lazy_synth:<ul>\n<li>Input \u201cdur\u201d in <tt>ones()</tt>, <tt>zeros()</tt>, <tt>white_noise()</tt> and\n<tt>impulse()</tt> now can be inf (besides None)</li>\n<li>Impulse now have <tt>one=1.</tt> and <tt>zero=0.</tt> arguments</li>\n<li>New <tt>gauss_noise</tt> for Normal / Gaussian-distributed noise</li>\n<li>White-noise limits parametrization</li>\n</ul>\n</li>\n<li>lazy_text (<em>new!</em>):<ul>\n<li>Got all text/string formatting functions from lazy_misc</li>\n<li>Namespace clean-up: new StrategyDict <tt>float_str</tt> embraces older\nrational/pi/auto formatters in one instance</li>\n</ul>\n</li>\n</ul>\n<p><strong>* Version 0.04 (Documentation, LPC, Plots!) *</strong></p>\n<ul>\n<li>examples:<ul>\n<li>Random Bach Choral playing example (needs Music21 corpus)</li>\n</ul>\n</li>\n<li>general:<ul>\n<li>Sphinx documentation!</li>\n<li>Self-generated package and module summary at the docstring</li>\n<li>Integration with NumPy (tested on 1.5.0, 1.6.1 and 1.6.2) and MatPlotLib\n(tested on 1.0.1 and 1.2.0)</li>\n<li>More docstrings and doctests, besides lots of corrections</li>\n<li>Itemized package description, installation instructions and getting\nstarted examples with plots in README.rst</li>\n<li>Now with 5400+ tests and 75% code coverage</li>\n</ul>\n</li>\n<li>lazy_analysis:<ul>\n<li>One-dimensional autocorrelation function with <tt>acorr</tt> and lag\n\u201ccovariance\u201d (due to lpc.covar) with <tt>lag_matrix</tt></li>\n<li>DFT for any frequency, given a block</li>\n<li>Three envelope filtering strategies (time domain)</li>\n<li>Three moving average filter strategies</li>\n<li>Signal clipping function</li>\n<li>Signal unwrap, defaults to the <tt>2 * pi</tt> radians range but configurable\nto other units and max signal difference allowed</li>\n<li>New AMDF algorithm as a non-linear filter</li>\n</ul>\n</li>\n<li>lazy_core:<ul>\n<li>StrategyDict instances now are singletons of a new class, which have\nlazy non-memoized docstrings based on their contents</li>\n</ul>\n</li>\n<li>lazy_filters:<ul>\n<li>ZFilter composition/substitution, e.g., <tt>(1 + z ** <span class=\"pre\">-1)(1</span> / z)</tt> results\nto the ZFilter instance <tt>1 + z</tt></li>\n<li>New LinearFilter.plot() directly plots the frequency response of a LTI\nfilter to a MatPlotLib figure. Configurable:<ul>\n<li>Linear (<em>default</em>) or logarithmic frequency scale</li>\n<li>Linear, squared or dB (<em>default</em>) magnitude scale</li>\n<li>Plots together the DFT of a given block, if needed. Useful for LPC</li>\n<li>Phase unwrapping (defaults to True)</li>\n<li>Allows frequency in Hz and in rad/sample. When using radians units,\nthe tick locator is based on <tt>pi</tt>, as well as the formatter</li>\n</ul>\n</li>\n<li>New LinearFilter.zplot() for plotting the zero-pole plane of a LTI filter\ndirectly into a MatPlotLib figure</li>\n<li>New LinearFilterProperties read-only properties <tt>numpolyz</tt> and\n<tt>denpolyz</tt> returning polynomials based on <tt>x = z</tt> instead of the\npolynomials based on <tt>x = z ** <span class=\"pre\">-1</span></tt> returned from <tt>numpoly</tt> and\n<tt>denpoly</tt></li>\n<li>New LinearFilter properties <tt>poles</tt> and <tt>zeros</tt>, based on NumPy</li>\n<li>New class <tt>FilterList</tt> for filter grouping with a <tt>callables</tt>\nproperty, for casting from lists with constant gain values as filters.\nIt is an instance of <tt>FilterListMeta</tt> (old CascadeFilterMeta), and\nCascadeFilter now inherits from this FilterList</li>\n<li>More LinearFilter behaviour into FilterList: Plotting (<tt>plot</tt> and\n<tt>zplot</tt>), <tt>poles</tt>, <tt>zeros</tt>, <tt>is_lti</tt> and <tt>is_causal</tt></li>\n<li>New <tt>ParallelFilter</tt> class, inheriting from FilterList</li>\n<li>Now comb is a StrategyDict too, with 3 strategies:<ul>\n<li><tt>comb.fb</tt> (<em>default</em>): Feedback comb filter (IIR or time variant)</li>\n<li><tt>comb.tau</tt>: Same to the feedback strategy, but with a time decay\n<tt>tau</tt> parameter (time in samples up to <tt>1/e</tt> amplitude, or\n-8.686 dB) instead of a gain <tt>alpha</tt></li>\n<li><tt>comb.ff</tt>: Feed-forward comb filter (FIR or time variant)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>lazy_lpc (<em>new!</em>):<ul>\n<li>Linear Predictive Coding (LPC) coefficients as a ZFilter from:<ul>\n<li><tt>lpc.autocor</tt> (<em>default</em>): Auto-selects autocorrelation implementation\n(Faster)</li>\n<li><tt>lpc.nautocor</tt>: Autocorrelation, with linear system solved by NumPy\n(Safer)</li>\n<li><tt>lpc.kautocor</tt>: Autocorrelation, using the Levinson-Durbin algorithm</li>\n<li><tt>lpc.covar</tt> or <tt>lpc.ncovar</tt>: Covariance, with linear system solved\nby NumPy</li>\n<li><tt>lpc.kcovar</tt>: Covariance, slower. Mainly for those without NumPy</li>\n<li><tt>levinson_durbin</tt>: Same to the <tt>lpc.kautocor</tt>, but with the\nautocorrelation vector as the input, not the signal data</li>\n</ul>\n</li>\n<li>Toeplitz matrix as a list of lists</li>\n<li>Partial correlation coefficients (PARCOR) or reflection coefficients</li>\n<li>Line Spectral Frequencies (LSF)</li>\n<li>Stability testers for filters with LSF and PARCOR</li>\n</ul>\n</li>\n<li>lazy_math:<ul>\n<li>New <tt>sign</tt> gets the sign of a given sequence.</li>\n</ul>\n</li>\n<li>lazy_midi:<ul>\n<li>Completed converters between frequency (in hertz), string and MIDI pitch\nnumbers</li>\n<li>New <tt>octaves</tt> for finding all octaves in a frequency range given one\nfrequency</li>\n</ul>\n</li>\n<li>lazy_misc:<ul>\n<li>New <tt>rational_formatter</tt>: casts floats to strings, perhaps with a symbol\nstring as multiplier</li>\n<li>New <tt>pi_formatter</tt>: same to <tt>rational_formatter</tt>, but with the symbol\nfixed to pi, mainly for use in MatPlotLib labels</li>\n</ul>\n</li>\n<li>lazy_poly:<ul>\n<li>New Poly.roots property, based on NumPy</li>\n</ul>\n</li>\n<li>lazy_stream:<ul>\n<li>Streamix class for mixing Streams based on delta starting times,\nautomatically managing the need for multiple \u201ctracks\u201d</li>\n</ul>\n</li>\n<li>lazy_synth:<ul>\n<li>Karplus-Strong algorithm now uses <tt>tau</tt> time decay constant instead of\nthe comb filter <tt>alpha</tt> gain.</li>\n</ul>\n</li>\n</ul>\n<p><strong>* Version 0.03 (Time variant filters, examples, etc.. Major changes!) *</strong></p>\n<ul>\n<li>examples (<em>new!</em>):<ul>\n<li>Gammatone frequency and impulse response plots example</li>\n<li>FM synthesis example for benchmarking with CPython and PyPy</li>\n<li>Simple I/O wire example, connecting the input directly to the output</li>\n<li>Modulo Counter graphics w/ FM synthesis audio in a wxPython application</li>\n<li>Window functions plot example (all window strategies)</li>\n</ul>\n</li>\n<li>general:<ul>\n<li>Namespace cleanup with __all__</li>\n<li>Lots of optimization and refactoring, also on tests and setup.py</li>\n<li>Better docstrings and README.rst</li>\n<li>Doctests (with pytest) and code coverage (needs pytest-cov)</li>\n<li>Now with 5200+ tests and 79% code coverage</li>\n</ul>\n</li>\n<li>lazy_analysis (<em>new!</em>):<ul>\n<li>New <tt>window</tt> StrategyDict instance, with:<ul>\n<li>Hamming (<em>default</em>)</li>\n<li>Hann</li>\n<li>Rectangular</li>\n<li>Bartlett (triangular with zero endpoints)</li>\n<li>Triangular (without zeros)</li>\n<li>Blackman</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>lazy_auditory (<em>new!</em>):<ul>\n<li>Two ERB (Equivalent Rectangular Bandwidth) models (both by Glasberg and\nMoore)</li>\n<li>Function to find gammatone bandwidth from ERB for any gammatone order</li>\n<li>Three gammatone filter implementations: sampled impulse response, Slaney,\nKlapuri</li>\n</ul>\n</li>\n<li>lazy_core:<ul>\n<li>MultiKeyDict: an \u201cinversible\u201d dict (i.e., a dict whose values must be\nhashable) that may have several keys for each value</li>\n<li>StrategyDict: callable dict to store multiple function implementations\nin. Inherits from MultiKeyDict, so the same strategy may have multiple\nnames. It\u2019s also an iterable on its values (functions)</li>\n</ul>\n</li>\n<li>lazy_filters:<ul>\n<li>LTI and LTIFreq no longer exists! They were renamed to LinearFilter and\nZFilter since filters now can have Streams as coefficients (they don\u2019t\nneed to be \u201cTime Invariant\u201d anymore)</li>\n<li>Linear filters are now iterables, allowing:<ul>\n<li>Comparison with almost_eq like <tt>assert almost_eq(filt1, filt2)</tt></li>\n<li>Expression like <tt>numerator_data, denominator_data = filt</tt>, where\neach data is a list of pairs that can be used as input for Poly,\nLinearFilter or ZFilter</li>\n</ul>\n</li>\n<li>LinearFilterProperties class, implementing numlist, denlist, numdict and\ndendict, besides numerator and denominator, from numpoly and denpoly</li>\n<li>Comparison \u201c==\u201d and \u201c!=\u201d are now strict</li>\n<li>CascadeFilter: list of filters that behave as a filter</li>\n<li>LinearFilter.__call__ now has the \u201czero\u201d optional argument (allows\nnon-float)</li>\n<li>LinearFilter.__call__ memory input can be a function or a Stream</li>\n<li>LinearFilter.linearize: linear interpolated delay-line from fractional\ndelays</li>\n<li>Feedback comb filter</li>\n<li>4 resonator filter models with 2-poles with exponential approximation\nfor finding the radius from the bandwidth</li>\n<li>Simple one pole lowpass and highpass filters</li>\n</ul>\n</li>\n<li>lazy_io:<ul>\n<li>AudioIO.record method, creating audio Stream instances from device data</li>\n</ul>\n</li>\n<li>lazy_itertools:<ul>\n<li>Now with a changed tee function that allows not-iterable inputs,\nhelpful to let the same code work with Stream instances and constants</li>\n</ul>\n</li>\n<li>lazy_math (<em>new!</em>):<ul>\n<li>dB10, dB20 functions for converting amplitude (squared or linear,\nrespectively) to logarithmic dB (power) values from complex-numbers\n(like the ones returned by LinearFilter.freq_response)</li>\n<li>Most functions from math module, but working decorated with elementwise\n(<tt>sin</tt>, <tt>cos</tt>, <tt>sqrt</tt>, etc.), and the constants <tt>e</tt> and <tt>pi</tt></li>\n<li>Other functions: <tt>factorial</tt>, <tt>ln</tt> (the <tt>log</tt> from math), <tt>log2</tt>,\n<tt>cexp</tt> (the <tt>exp</tt> from cmath) and <tt>phase</tt> (from cmath)</li>\n</ul>\n</li>\n<li>lazy_midi:<ul>\n<li>MIDI pitch numbers and Hz frequency converters from strings like \u201cC#4\u201d</li>\n</ul>\n</li>\n<li>lazy_misc:<ul>\n<li>Elementwise decorator now based on both argument keyword and position</li>\n</ul>\n</li>\n<li>lazy_poly:<ul>\n<li>Horner-like scheme for Poly.__call__ evaluation</li>\n<li>Poly now can have Streams as coefficients</li>\n<li>Comparison \u201c==\u201d and \u201c!=\u201d are now strict</li>\n</ul>\n</li>\n<li>lazy_stream:<ul>\n<li>Methods and attributes from Stream elements can be used directly,\nelementwise, like <tt>my_stream.imag</tt> and <tt>my_stream.conjugate()</tt> in a\nstream with complex numbers</li>\n<li>New thub() function and StreamTeeHub class: tee (or \u201cT\u201d) hub auto-copier\nto help working with Stream instances <em>almost</em> the same way as you do with\nnumbers</li>\n</ul>\n</li>\n<li>lazy_synth:<ul>\n<li>Karplus-Strong synthesis algorithm</li>\n<li>ADSR envelope</li>\n<li>Impulse, ones, zeros/zeroes and white noise Stream generator</li>\n<li>Faster sinusoid not based on the TableLookup class</li>\n</ul>\n</li>\n</ul>\n<p><strong>* Version 0.02 (Interactive Stream objects &amp; Table lookup synthesis!) *</strong></p>\n<ul>\n<li>general:<ul>\n<li>10 new tests</li>\n</ul>\n</li>\n<li>lazy_midi (<em>new!</em>):<ul>\n<li>MIDI to frequency (Hz) conversor</li>\n</ul>\n</li>\n<li>lazy_misc:<ul>\n<li>sHz function for explicit time (s) and frequency (Hz) units conversion</li>\n</ul>\n</li>\n<li>lazy_stream:<ul>\n<li>Interactive processing with ControlStream instances</li>\n<li>Stream class now allows inheritance</li>\n</ul>\n</li>\n<li>lazy_synth (<em>new!</em>):<ul>\n<li>TableLookup class, with sinusoid and sawtooth instances</li>\n<li>Endless counter with modulo, allowing Stream inputs, mainly created for\nTableLookup instances</li>\n<li>Line, fade in, fade out, ADS attack with endless sustain</li>\n</ul>\n</li>\n</ul>\n<p><strong>* Version 0.01 (First \u201cpre-alpha\u201d version!) *</strong></p>\n<ul>\n<li>general:<ul>\n<li>4786 tests (including parametrized tests), based on pytest</li>\n</ul>\n</li>\n<li>lazy_core:<ul>\n<li>AbstractOperatorOverloaderMeta class to help massive operator\noverloading as needed by Stream, Poly and LTIFreq (now ZFilter) classes</li>\n</ul>\n</li>\n<li>lazy_filters:<ul>\n<li>LTI filters, callable objects with operators and derivatives, returning\nStream instances</li>\n<li>Explicit filter formulas with the <tt>z</tt> object, e.g.\n<tt>filt = 1 / (.5 + z ** <span class=\"pre\">-1)</span></tt></li>\n</ul>\n</li>\n<li>lazy_io:<ul>\n<li>Multi-thread audio playing (based on PyAudio), with context manager\ninterface</li>\n</ul>\n</li>\n<li>lazy_itertools:<ul>\n<li>Stream-based version of all itertools</li>\n</ul>\n</li>\n<li>lazy_misc:<ul>\n<li>Block-based processing, given size and (optionally) hop</li>\n<li>Simple zero padding generator</li>\n<li>Elementwise decorator for functions</li>\n<li>Bit-based and diff-based \u201calmost equal\u201d comparison function for floats\nand iterables with floats. Also works with (finite) generators</li>\n</ul>\n</li>\n<li>lazy_poly:<ul>\n<li>Poly: polynomials based on dictionaries, with list interface and\noperators</li>\n</ul>\n</li>\n<li>lazy_stream:<ul>\n<li>Stream: each instance is basically a generator with elementwise\noperators</li>\n<li>Decorator <tt>tostream</tt> so generator functions can return Stream objects</li>\n</ul>\n</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 2371025, "releases": {"0.01dev": [{"comment_text": "", "digests": {"md5": "f8aa248b31bfb67017358d599a4461cf", "sha256": "03fdecfc9262026a30cfff12d0d64a27a0a0d036fab314018455d55ee212b340"}, "downloads": -1, "filename": "audiolazy-0.01dev.tar.gz", "has_sig": false, "md5_digest": "f8aa248b31bfb67017358d599a4461cf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27627, "upload_time": "2012-10-10T17:14:22", "upload_time_iso_8601": "2012-10-10T17:14:22.789264Z", "url": "https://files.pythonhosted.org/packages/a3/58/5286344a732bbb242cca176c3236b296a3cda166e4dd2f6ff5c54011c5ff/audiolazy-0.01dev.tar.gz", "yanked": false}], "0.02dev": [{"comment_text": "", "digests": {"md5": "9904ae05f073744904929056e60808c3", "sha256": "03570a78de10cd8291ec4b15053f480de4454c643f0e449a3642128087ad344c"}, "downloads": -1, "filename": "audiolazy-0.02dev.tar.gz", "has_sig": false, "md5_digest": "9904ae05f073744904929056e60808c3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30642, "upload_time": "2012-10-11T17:52:04", "upload_time_iso_8601": "2012-10-11T17:52:04.891939Z", "url": "https://files.pythonhosted.org/packages/8a/5a/a2501b05758dfe9967f2cbf3fc12522bec7ffb6bbbaedc6aa4689e76535d/audiolazy-0.02dev.tar.gz", "yanked": false}], "0.03": [{"comment_text": "", "digests": {"md5": "163b87ea7d7a32b26208342f0f7361ef", "sha256": "c801dfd74cb3fb8c7c51ee779b1202947580d94356aba701f8818dd46968f40f"}, "downloads": -1, "filename": "audiolazy-0.03.tar.gz", "has_sig": false, "md5_digest": "163b87ea7d7a32b26208342f0f7361ef", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 46103, "upload_time": "2013-01-23T14:22:27", "upload_time_iso_8601": "2013-01-23T14:22:27.015501Z", "url": "https://files.pythonhosted.org/packages/81/8a/e9b6369db3c5aaae96f3f6b89856825625b480fe7667944c3fb52f365680/audiolazy-0.03.tar.gz", "yanked": false}], "0.04": [{"comment_text": "", "digests": {"md5": "159f5cf46543238881099f7bf042ee59", "sha256": "7e4d4a9b64385fb8c40c02675d319878255e33f311664ea9f23a55da69401a8a"}, "downloads": -1, "filename": "audiolazy-0.04.tar.gz", "has_sig": false, "md5_digest": "159f5cf46543238881099f7bf042ee59", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 90189, "upload_time": "2013-02-18T23:09:15", "upload_time_iso_8601": "2013-02-18T23:09:15.095987Z", "url": "https://files.pythonhosted.org/packages/82/77/401a147394d0c6a35449d64d9f1f1ef67f9b94bb95e2cd0655ec27a914ca/audiolazy-0.04.tar.gz", "yanked": false}], "0.05": [{"comment_text": "", "digests": {"md5": "e681fe245bb63b9bac9782f956f25298", "sha256": "02286c07d8d107a47aa8de856c4220b96f92143f7ceb015cd5c54685c1feaef6"}, "downloads": -1, "filename": "audiolazy-0.05.tar.gz", "has_sig": false, "md5_digest": "e681fe245bb63b9bac9782f956f25298", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 105170, "upload_time": "2013-09-12T03:30:39", "upload_time_iso_8601": "2013-09-12T03:30:39.340084Z", "url": "https://files.pythonhosted.org/packages/8c/2d/4d446690c76599c2858fc4cf47419eb5dbbe466965fd8aab09064387d83e/audiolazy-0.05.tar.gz", "yanked": false}], "0.6": [{"comment_text": "", "digests": {"md5": "98f9af2eaa85c7006ecae5f6bdd1b037", "sha256": "1990e9374ea5ff59c37e1d1f72ab9308f1b0adbe446460e4da57bafbc93ffa10"}, "downloads": -1, "filename": "audiolazy-0.6-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "98f9af2eaa85c7006ecae5f6bdd1b037", "packagetype": "bdist_wheel", "python_version": "3.5", "requires_python": null, "size": 121325, "upload_time": "2016-09-29T13:09:58", "upload_time_iso_8601": "2016-09-29T13:09:58.959763Z", "url": "https://files.pythonhosted.org/packages/65/97/0b9528016ce0d4d11380d9864b6fe3b3f7d8b358a841e3489fa84fd18792/audiolazy-0.6-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dd4bdad44e0d7766952ecc1365ae9c1e", "sha256": "c879bab2832daf1bcbaaf52ba5829eb7cdae5f606e4c74eaea1fc826652bbc97"}, "downloads": -1, "filename": "audiolazy-0.6.tar.gz", "has_sig": false, "md5_digest": "dd4bdad44e0d7766952ecc1365ae9c1e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 470681, "upload_time": "2016-09-29T13:09:49", "upload_time_iso_8601": "2016-09-29T13:09:49.200329Z", "url": "https://files.pythonhosted.org/packages/6f/9d/670be88d77346a9ad53e961aef1c33b5e7cb4831ad58f635f8b8c5c1db4c/audiolazy-0.6.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "c3850eb493e793beedbec86ab88fcb1b", "sha256": "4c1237fa1cda75ce5f809594345f3ac6c095fdebc50ea72660c628e4592995d0"}, "downloads": -1, "filename": "audiolazy-0.6.zip", "has_sig": false, "md5_digest": "c3850eb493e793beedbec86ab88fcb1b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 532115, "upload_time": "2016-09-29T13:09:53", "upload_time_iso_8601": "2016-09-29T13:09:53.848635Z", "url": "https://files.pythonhosted.org/packages/5a/ce/06e7f52f0a8564533fc2d7598f83d22b31835f28270d31a5d92c68fa3f8a/audiolazy-0.6.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "98f9af2eaa85c7006ecae5f6bdd1b037", "sha256": "1990e9374ea5ff59c37e1d1f72ab9308f1b0adbe446460e4da57bafbc93ffa10"}, "downloads": -1, "filename": "audiolazy-0.6-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "98f9af2eaa85c7006ecae5f6bdd1b037", "packagetype": "bdist_wheel", "python_version": "3.5", "requires_python": null, "size": 121325, "upload_time": "2016-09-29T13:09:58", "upload_time_iso_8601": "2016-09-29T13:09:58.959763Z", "url": "https://files.pythonhosted.org/packages/65/97/0b9528016ce0d4d11380d9864b6fe3b3f7d8b358a841e3489fa84fd18792/audiolazy-0.6-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dd4bdad44e0d7766952ecc1365ae9c1e", "sha256": "c879bab2832daf1bcbaaf52ba5829eb7cdae5f606e4c74eaea1fc826652bbc97"}, "downloads": -1, "filename": "audiolazy-0.6.tar.gz", "has_sig": false, "md5_digest": "dd4bdad44e0d7766952ecc1365ae9c1e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 470681, "upload_time": "2016-09-29T13:09:49", "upload_time_iso_8601": "2016-09-29T13:09:49.200329Z", "url": "https://files.pythonhosted.org/packages/6f/9d/670be88d77346a9ad53e961aef1c33b5e7cb4831ad58f635f8b8c5c1db4c/audiolazy-0.6.tar.gz", "yanked": false}, {"comment_text": "", "digests": {"md5": "c3850eb493e793beedbec86ab88fcb1b", "sha256": "4c1237fa1cda75ce5f809594345f3ac6c095fdebc50ea72660c628e4592995d0"}, "downloads": -1, "filename": "audiolazy-0.6.zip", "has_sig": false, "md5_digest": "c3850eb493e793beedbec86ab88fcb1b", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 532115, "upload_time": "2016-09-29T13:09:53", "upload_time_iso_8601": "2016-09-29T13:09:53.848635Z", "url": "https://files.pythonhosted.org/packages/5a/ce/06e7f52f0a8564533fc2d7598f83d22b31835f28270d31a5d92c68fa3f8a/audiolazy-0.6.zip", "yanked": false}], "timestamp": "Thu May  7 18:16:27 2020"}