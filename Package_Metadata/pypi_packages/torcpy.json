{"info": {"author": "Panagiotis Chatzidoukas", "author_email": "phadjido@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved", "Operating System :: OS Independent", "Programming Language :: Python :: 3"], "description": "# torcpy: supporting task-based parallelism in Python\n\n## 1. Introduction ##\n\n**torcpy** is a platform-agnostic adaptive load balancing library that orchestrates scheduling of multiple function evaluations on both shared and distributed memory platforms.\n\nAs an open-source tasking library, **torcpy**, aims at providing a parallel computing framework that:\n- offers a unified approach for expressing and executing task-based parallelism on both shared and distributed memory platforms\n- takes advantage of MPI internally in a transparent to the user way but also allows the use of legacy MPI code at the application level\n- provides lightweight support for parallel nested loops and map functions\n- supports task stealing at all levels of parallelism\n- exports the above functionalities through a simple and single Python package\n\ntorcpy exports an interface compatible with PEP 3148. Therefore tasks (futures) can be spawned and joined with the *submit* and *wait* calls. A parallel *map* function is provided, while *spmd* allows for switching\nto the typical SPMD execution mode that is natively supported by MPI.\n\n## 2. Installation and testing\n\n### 2.1 Installation\n\nPrerequisites: `python3 >= 5` and `pip3`.\n\n```bash\ngit clone git@github.com:IBM/torc_py.git\ncd torc_py\npip3 install .\n```\n\nObservation:\nThe main requirements are *mpi4py* and *termcolor*, while *numpy*, *cma*, *h5py* and *pillow* are needed by some examples.\n\n\n### 2.2. Testing\n\nWe use the file `examples\\ex00_masterworker.py` to demonstrate the execution of the tasking library using multiple processes and threads. The task function receives as input a number `x`, sleeps for one second and then computes and returns as result the square value `x*x`. The main task spawns `ntasks` (= four) tasks that are distributed cyclically, by default, to the available workers and then calls `wait`, waiting for their completion. Finally, it prints the task results and reports the elapsed time.\n\nThe MPI processes start with the execution of `__main__` and call `torcpy.start(main)`, which initializes the tasking library and then executes the primary application task (with task function `main()`) on the process with rank 0.  \n\n```python\nimport time\nimport threading\nimport torcpy\n\ndef work(x):\n    time.sleep(1)\n    y = x**2\n    print(\"work inp={:.3f}, out={:.3f} ...on node {:d} worker {} thread {}\".format(x, y, torcpy.node_id(), torcpy.worker_id(), threading.get_ident()), flush=True)\n    return y\n\ndef main():\n    ntasks = 4\n    sequence = range(1, ntasks + 1)\n\n    t0 = torcpy.gettime()\n    tasks = []\n    for i in sequence:\n        task = torcpy.submit(work, i)\n        tasks.append(task)\n    torcpy.wait()\n    t1 = torcpy.gettime()\n\n    for t in tasks:\n        print(\"Received: {}^2={:.3f}\".format(t.input(), t.result()))\n\n    print(\"Elapsed time={:.2f} s\".format(t1 - t0))\n\nif __name__ == '__main__':\n    torcpy.start(main)\n```\n\n### 2.3 Execution of tests\n\n#### 2.3.1. One MPI process with one worker\n\nThis is similar to the sequential execution of the code with the main difference that the task functions are executed not immediately but in deferred mode. No MPI communication takes place and the tasks are directly inserted in the local queue. Upon `torcpy.wait()`, the current (primary) application task suspends its execution, the scheduling loop of the underlying worker is activated and the child tasks are fetched and executed. When the last child task completes, the primary task resumes and prints the results. Moreover, the tasking library reports how many tasks where created and executed by each MPI process.\n\n```console\n$ mpirun -n 1 python3 ex00_masterworker.py\nTORCPY: main starts\nwork inp=1.000, out=1.000 ...on node 0 worker 0 thread 4536538560\nwork inp=2.000, out=4.000 ...on node 0 worker 0 thread 4536538560\nwork inp=3.000, out=9.000 ...on node 0 worker 0 thread 4536538560\nwork inp=4.000, out=16.000 ...on node 0 worker 0 thread 4536538560\nReceived: 1^2=1.000\nReceived: 2^2=4.000\nReceived: 3^2=9.000\nReceived: 4^2=16.000\nElapsed time=4.03 s\nTORCPY: node[0]: created=4, executed=4\n```\n\n#### 2.3.2. Two MPI process with one worker each\n\nTwo MPI processes (*nodes*) are started with rank 0 and 1, respectively. Each process has a single worker thread, with global id 0 and 1, accordingly. The primary task runs on rank 0 and spawns the four tasks. The first and the third tasks are submitted locally to worker 0 while the second and fourth tasks are send to worker 1.\n\n```console\n$ mpirun -n 2 python3 ex00_masterworker.py\nTORCPY: main starts\nwork inp=1.000, out=1.000 ...on node 0 worker 0 thread 4585866688\nwork inp=2.000, out=4.000 ...on node 1 worker 1 thread 4623332800\nwork inp=3.000, out=9.000 ...on node 0 worker 0 thread 4585866688\nwork inp=4.000, out=16.000 ...on node 1 worker 1 thread 4623332800\nReceived: 1^2=1.000\nReceived: 2^2=4.000\nReceived: 3^2=9.000\nReceived: 4^2=16.000\nElapsed time=2.03 s\nTORCPY: node[0]: created=4, executed=2\nTORCPY: node[1]: created=0, executed=2\n```\n\n#### 2.3.3. One MPI process with two workers\n\nThe single MPI process is initialized with two worker threads, with global ids 0 and 1. The four tasks are inserted in the local process queue and extracted and executed by the two workers. The primary task is executed by worker 0 and it is also tied to it, therefore it always continues on the same worker.\n\n```console\n$ mpirun -n 1 -env TORCPY_WORKERS=2  python3 ex00_masterworker.py\nTORCPY: main starts\nwork inp=1.000, out=1.000 ...on node 0 worker 0 thread 4607645120\nwork inp=2.000, out=4.000 ...on node 0 worker 1 thread 123145550958592\nwork inp=3.000, out=9.000 ...on node 0 worker 0 thread 4607645120\nwork inp=4.000, out=16.000 ...on node 0 worker 1 thread 123145550958592\nReceived: 1^2=1.000\nReceived: 2^2=4.000\nReceived: 3^2=9.000\nReceived: 4^2=16.000\nElapsed time=2.02 s\nTORCPY: node[0]: created=4, executed=4\n```\n\n#### 2.3.4 Two MPI processes with two workers each\n\nThere are two MPI processes with two workers each, therefore workers 0 and 1 belong to the process with rank 0 and workers 2 and 3 to rank 1. Since task distribution is performed on a worker basis, the first and the second tasks are submitted locally to node 0 while the third and fourth tasks are send to node 1. Eventually, every worker executes one task and the application is executed 4x times faster.\n\n```console\n$ mpirun -n 2 -env TORCPY_WORKERS=2  python3 ex00_masterworker.py\nTORCPY: main starts\nwork inp=2.000, out=4.000 ...on node 0 worker 0 thread 4560111040\nwork inp=1.000, out=1.000 ...on node 0 worker 1 thread 123145531727872\nwork inp=4.000, out=16.000 ...on node 1 worker 2 thread 4643915200\nwork inp=3.000, out=9.000 ...on node 1 worker 3 thread 123145537077248\nReceived: 1^2=1.000\nReceived: 2^2=4.000\nReceived: 3^2=9.000\nReceived: 4^2=16.000\nElapsed time=1.04 s\nTORCPY: node[0]: created=4, executed=2\nTORCPY: node[1]: created=0, executed=2\n```\n\n## 3. Examples\n\nPlease note that the `torcpy` module is imported as `torc` in the following examples.\n\n### 3.1. Submit and wait\n\nThe primary task spawns and distributes cyclically 10 tasks to the available workers, waits for their completion and finally prints the results.\n\n```python\nimport torcpy as torc\n\n\ndef work(x):\n    return x * x\n\n\ndef main():\n    data = range(10)\n    tasks = []\n    for d in data:\n        tasks.append(torc.submit(work, d))\n    torc.wait()\n    for t in tasks:\n        print(t.result())\n\nif __name__ == '__main__':\n    torc.start(main)\n```\n\n### 3.2. Parallel map\n\nEquivalent to the previous example but this time using the `map` function with default chunk size equal to 1.\n\n```python\nimport torcpy as torc\n\ndef work(x):\n    return x*x\n\ndef main():\n    data = range(10)\n    results = torc.map(work, data)\n    print(results)\n\nif __name__ == '__main__':\n    torc.start(main)\n```    \n\n\n### 3.3. Simple callback example\n\nFour tasks are spawned and executed by the available workers. When a task completes, it is passed as argument to a callback task that is executed by the worker threads of the node (process) where the parent task is active.\n\n```python\nimport torcpy as torc\nimport threading\n\n\ndef cb(task):\n    arg = task.result()\n    tid = threading.get_ident()\n    print(\"thread {}: callback with arg={}\".format(tid, arg), flush=True)\n\n\ndef work(x):\n    tid = threading.get_ident()\n    y = x * x\n    print(\"thread {}: work inp={}, out={} ... on node {}\".format(tid, x, y, torc.node_id()), flush=True)\n    return y\n\n\ndef main():\n    ntasks = 4\n    sequence = range(1, ntasks+1)\n\n    t_all = []\n    for i in sequence:\n        task = torc.submit(work, i, callback=cb)\n        t_all.append(task)\n    torc.wait()\n\n    for task in t_all:\n        print(\"Received: {}^2={}\".format(task.input(), task.result()))\n\n\nif __name__ == '__main__':\n    torc.start(main)\n```\n\n\n### 3.4. Hierarchical parallelism: recursive Fibonacci\n\nMultiple levels of parallelism are exploited in this commonly used parallelization example of recursive Fibonacci.\n\n```python\nimport torcpy as torc\n\n\ndef fib(n):\n    if n == 0:\n        result = 0\n    elif n == 1:\n        result = 1\n    else:\n        n_1 = n - 1\n        n_2 = n - 2\n        if n < 30:\n            result1 = fib(n_1)\n            result2 = fib(n_2)\n            result = result1 + result2\n        else:\n            task1 = torc.submit(fib, n_1)\n            task2 = torc.submit(fib, n_2)\n            torc.wait()\n            result = task1.result() + task2.result()\n\n    return result\n\n\ndef main():\n    n = 35\n    result = fib(n)\n\n    print(\"fib({}) = {}\".format(n, result))\n```\n\n### 3.5. Calling MPI SPMD code: MPI_Bcast  \n\nThe global array `A` is initialized by the primary application task (`main`) on MPI process 0.\nNext, the `spmd` function triggers the execution of `bcast_task` on all MPI processes, thus switching\nto the SPMD execution model and allowing for direct data broadcast using `Bcast`.\n\n```python\nimport numpy\nimport torcpy as torc\nfrom mpi4py import MPI\n\nN = 3\nA = numpy.zeros(N, dtype=numpy.float64)\n\n\ndef bcast_task(root):\n    global A\n    comm = MPI.COMM_WORLD\n    # Broadcast A from rank 0\n    comm.Bcast([A, MPI.DOUBLE], root=root)\n\n\ndef work():\n    global A\n    print(\"node:{} -> A={}\".format(torc.node_id(), A))\n\n\ndef main():\n    global A\n\n    # primary task initializes array A on rank 0\n    for i in range(0, N):\n        A[i] = 100*i\n\n    torc.spmd(bcast_task, torc.node_id())  # 2nd arg (root) is 0 and can be omitted\n\n    torc.spmd(work)\n```\n\n\n### 3.6. Reduction operation using callbacks\n\nIn this example, the callback function adds the task result to a global variable, implementing thus\na reduction operation. This example assumes that a single worker thread per MPI process is used and that callbacks are instantiated as tasks that are executed by worker threads.\n\n```python\nimport torcpy as torc\n\nsum_v = 0\n\n\ndef cb(task):\n    global sum_v\n    arg = task.result()\n    sum_v = sum_v + arg\n\n\ndef work(x):\n    y = x ** 2\n    return y\n\n\ndef main():\n    data = range(10)\n\n    tasks = []\n    for d in data:\n        t = torc.submit(work, d, callback=cb)\n        tasks.append(t)\n\n    torc.wait()\n    print(\"Sum=\", sum_v)\n\n\nif __name__ == '__main__':\n    torc.start(main)\n```\n\n\n### 3.7. Late switch from SPMD to master-worker and image preprocessing\n\n```python\nimport os\nimport sys\nimport time\nfrom PIL import Image\nimport torcpy as torc\n\nfiles = []\n\n\ndef get_files(path):\n    all_files = []\n    for dirpath, dirnames, filenames in os.walk(path):\n        for f in filenames:\n            if f.endswith('.jpg') | f.endswith('.jpeg') | f.endswith('.png'):\n                all_files.append(os.path.join(dirpath, f))\n\n    return sorted(all_files)\n\n\ndef work(i):\n    global files\n    f = files[i]\n    with Image.open(f) as im:\n        im = im.resize((32, 32))\n        # do something more here\n\n    return None\n\n\ndef main():\n    global files\n\n    # SPMD execution: torcpy and MPI initialization\n    torc.init()\n\n    # SPMD execution: common global initialization takes place here\n    if len(sys.argv) == 1:\n        if torc.node_id() == 0:\n            print(\"usage: python3 {} <path>\".format(os.path.basename(__file__)))\n        return\n\n    files = get_files(sys.argv[1])\n\n    # Switching to master-worker\n    torc.launch(None)\n\n    t0 = time.time()\n    _ = torc.map(work, range(len(files)))\n    t1 = time.time()\n    print(\"t1-t0=\", t1-t0)\n\n    torc.shutdown()\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### 3.8. Parallel numerical optimization\n\n```python\nimport cma  # python package for numerical optimization\nimport torcpy as torc\n\ndef rosenbrock(x):\n    \"\"\"Rosenbrock test objective function\"\"\"\n    n = len(x)\n    if n < 2:\n      raise ValueError('dimension must be greater one')\n    return sum(100 * (x[i]**2 - x[i+1])**2 + (x[i] - 1)**2 for i in range(n-1))\n\ndef main():\n    es = cma.CMAEvolutionStrategy(2 * [0], 0.5, {'popsize':640})\n    while not es.stop():\n        solutions = es.ask()\n        es.tell(solutions, torc.map(rosenbrock, solutions))\n        es.logger.add(es)  # write data to disc to be plotted\n        es.disp()\n\n    cma.plot()\n```\n\n\n### 3.9. Demonstration of work stealing\n\nAll 16 tasks are submitted by the primary task, running on node 0, to the worker thread of rank 1.\nThe idle workers that find the local queue empty, issue steal requests and eventually retreive a task from the queue of rank 1. The primary task resumes when all the child tasks have completed and their results are available on rank 0.\n\n```python\nimport time\nimport torcpy as torc\n\n\ndef work(x):\n    time.sleep(1)\n    y = x*x\n    print(\"taskfun inp={}, out={} ...on node {:d}\".format(x, y, torc.node_id()), flush=True)\n    return y\n\n\ndef main():\n    nodes = torc.num_nodes()\n    if nodes < 2:\n        print(\"This examples needs at least two MPI processes. Exiting...\")\n        return\n    local_workers = torc.num_local_workers()\n    if local_workers > 1:\n        print(\"This examples should use one worker thread per MPI process. Exiting...\")\n        return\n\n    ntasks = 16\n    sequence = range(1, ntasks + 1)\n\n    t0 = torc.gettime()\n    t_all = []\n    for i in sequence:\n        try:\n            task = torc.submit(work, i, qid=1)\n            t_all.append(task)\n        except ValueError:\n            print(\"torc.submit: invalid argument\")\n\n    torc.enable_stealing()\n    torc.wait()\n    t1 = torc.gettime()\n    torc.disable_stealing()\n\n    for task in t_all:\n        print(\"Received: {}^2={}\".format(task.input(), task.result()))\n\n    print(\"Elapsed time={:.2f} s\".format(t1 - t0))\n\n\nif __name__ == '__main__':\n    torc.start(main)\n```\n\n\n## 4. Application Programming Interface\n\n### 4.1. Task management routines\n\n- `submit(f, *args, qid=-1, callback=None, **kwargs)`:\nsubmits a new task that corresponds to the asynchronous execution of function `f()` with input arguments `args`. The task is submitted to the worker with global identifier `qid`. If `qid` is equal to -1, then cyclic distribution of tasks to processes is performed. The `callback` function is called on the rank that spawned the task, when the task completes and its results have been returned to that node.\n- `map(f, *seq, chunksize=1)`: executes function `f()` on a sequence (list) of arguments.\nIt returns a list with the results of all tasks. It is similar to the `map()` function of Python and other packages, allowing for straightforward usage of existing codes.\n- `wait(tasks=None)`: the current task waits for all its child tasks to finish. The underlying worker thread is released and can execute other tasks.\n- `as_completed(tasks=None)`: similar to `wait` but returns the finished child tasks in the order they completed their execution.\n\n### 4.2. Application setup\n\n- `start(f)`: initializes the library, launches function `f()` on process with rank 0 as the primary application task. When `f()` completes, it shutdowns the library. It is a collective function that must be called within `__main__`.\n\n```python\nif __name__ == '__main__':\n    torcpy.start(main)\n```\n\n### 4.3. Low-level application setup\n\n- `init()`: initializes the tasking library.\n- `launch(f)`: launches function `f()` as primary application task on the MPI process with rank 0. It is a collective call that must be called by all MPI processes. If `f == NULL` then the function returns on rank 0 but activates the scheduling loop of the main worker thread on all other MPI processes. Therefore, the current function becomes the primary application task running on rank 0.\n- `shutdown()`: shutdowns the tasking library.\n\n### 4.4. MPI code\n\n- `spmd(f, *args)`: executes function `f()` on all MPI processes. It allows for dynamic switching from the master-worker to the SPMD execution mode, allowing thus legacy MPI code to be used within the function.\n\n### 4.5. Additional calls\n\n- `enable_stealing(), disable_stealing()`: control task stealing between MPI processes.\n- `gettime()`: current time in seconds (float).\n- `worker_id(), num_workers()`: return the global worker thread id and the total number of workers.\n- `node_id(), num_nodes()`: return the rank of the calling MPI process and the number of MPI processes.\n\n### 4.6 Context manager\n\n### 4.7. Environment variables\n\n- `TORCPY_WORKERS` (integer): number of worker threads used by each MPI processor. Default value is 1.\n- `TORCPY_STEALING` (boolean): determines if internode task-stealing is enabled or not. Default value is \"False\".\n- `TORCPY_SERVER_YIELDTIME` (float): for how many seconds an idle server thread will sleep releasing the processor. Default value is 0.01.\n- `TORCPY_WORKER_YIELDTIME` (float): for how many seconds an idle worker thread will sleep releasing the processor. Default value is 0.01.\n\n\n## 5. Design and architecture\n\nThe library is implemented on top of MPI and multithreading and it can considered as the pure Python implementation of the [*TORC*](https://github.com/phadjido/torc_lite) C/C++ runtime library [Hadjidoukas:2012], a software package for programming and running unaltered task-parallel programs on both shared and distributed memory platforms. The library supports platform agnostic nested parallelism and automatic load balancing in large scale computing architectures. It has been used at the core of the [\u03a04U](https://github.ibm.com/cselab/pi4u) framework [Hadjidoukas:2015], allowing for HPC implementations, for both multicore and GPU clusters, of algorithms such as Transitional Markov Chain Monte Carlo (TMCMC) and Approximate Bayesian Computational Subset-simulation.\n\n*torcpy* is mainly built on top of the following third-party Python packages: *mpi4py*, *threading*, *queue*.\nTasks are instantiated as Python dictionaries, which introduce less overhead than objects. The result of the task function is transparently stored in the task descriptor (future) on the MPI process that spawned the task. According to PEP 3184, the result can be then accessed as `task.result()`. Similarly, the input parameters can be accessed as `task.input()`.\n\nAll remote operations are performed asynchronously through a server thread. This thread is responsible for:\n- inserting incoming tasks to the local queue of the process\n- receiving the completed tasks and their results\n- serving task stealing requests\n\nThe internal architecture of *torcpy* is depicted in the following figure:\n\n![](./doc/torc_architecture.png)\n\n\n## 6. Performance evaluation\n\nTORC, the C/C++ counterpart of torcpy has been used extensively on small and large scale HPC environments\nsuch as the Euler cluster (ETH) and the Piz Daint (CSCS) supercomputer. TORC has been used to orchestrate the scheduling of function evaluations of the TMCMC method within \u03a04U on multiple cluster nodes. The TMCMC method was able to achieve an overall parallel efficiency of more than 90% on 1024 compute nodes of Piz Daint running hybrid MPI+GPU molecular simulation codes with highly variable time-to-solution between simulations with different interaction parameters.\n\n### 6.1. Preprocessing of image datasets\n\nA typical preprocessing stage of Deep Learning workloads includes the transformation of datasets of raw images to a single file in HDF5 format. The images are organized in subfolders, where the name of each subfolder denotes the label of the enclosed images. For each image, the file is opened and the binary data are loaded to a buffer (numpy array). This operations includes data decompression if the image is stored in JPEG format. Then, the image is resized and rescaled and additional preprocessing filters might be also applied. Finally, the result is written to an HDF5 file, that we will be used at the training phase of deep learning.\n\n```python\ndef process_train_image(i, target_dim):\n    global reader, pipe\n\n    # load the image and its label\n    im, label = reader.get_train_image(i)        \n\n    # apply preprocessing filters\n    im = pipe.filter(im)\n\n    # resize accordingly\n    dx = image_to_4d_tensor(im, target_dim)\n    dy = label\n\n    # return results\n    return dx, dy\n```\n\nThe parallelization of the sequential for loop is performed with the map function, using a chunk size of 32 so as to reduce the number of spawned tasks.\n\n```python\nsequence_i = range(n_train)\nsequence_t = [target_dim] * n_train\n\n# parallel map with chunksize\ntask_results = torcpy.map(process_train_image, sequence_i, sequence_t, chunksize=32)\n\n# write the results to the HDF5 dataset\ni = 0\nfor t in task_results:\n    dx, dy = t\n    dataset_x[i, :, :, :] = dx\n    dataset_y[i] = dy\n    i = i+1\n```\n\n### 6.2. Results\n\n[Imagenet](http://www.image-net.org/) is very large dataset of 1000 classes, each with 1300 images stored in JPEG format. We preprocess the images of 10 training classes of the Imagenet dataset. We perform our experiments on a single IBM Power8 node equipped with 20 cores and 8 threads each. The software configuration includes Python 3.5, mpi4py/3.0.1 and OpenMPI/3.1.2.\n\nWe spawn a single MPI process per core and then utilize 1,2 and 4 workers per process. The command for running the benchmark for various numbers of processes (*NR*) and local workers (*NW*) on the specific computing platform is as follows:\n\n```console\nmpirun -n $NR -x TORCPY_WORKERS=$NW --bind-to core --map-by socket --mca btl self,tcp  python3 benchmark.py\n```\n\nThe measurements include the time for spawning the parallelism, executing the preprocessing in parallel and waiting for the completion of all tasks, i.e. collecting the results back. We observe that the application exhibits good scaling and achieves ~78% efficiency when 20 processes of one worker thread each are used. The performance does not scale linearly with the number of cores as image decompression and processing stress the memory subsystem of the node. We also observe that multithreading further improves the performance, allowing for a maximum achieved speedup of 22x (20 processes, 4 threads).\n\n![](./doc/preprocessing_performance.png)\n\n\n## 7. Related work ##\n\nThere is a number of Python packages and frameworks that enable the orchestration and execution of task-based parallelism on various computing platforms. On single-node multi-core systems Python provides two packages: the [*multiprocessing*](https://docs.python.org/3/library/multiprocessing.html) and the [*concurrent.futures*](https://docs.python.org/3/library/concurrent.futures.html). The [*futures* package of *mpi4py*](https://mpi4py.readthedocs.io/en/stable/mpi4py.futures.html) provides an extension of *futures* on top of the MPI programming model. [*DTM*](http://deap.gel.ulaval.ca/doc/0.9/api/dtm.html) is an MPI-based framework that supports task-based parallelism. However, *DTM* is obsolete and has been replaced by [*Scoop*](http://pyscoop.org), which follows a more distributed-based approach without relying on MPI. This is also the case for the [*Celery*](http://www.celeryproject.org/) and [*Dask*](http://dask.pydata.org/en/latest/) frameworks, which mainly target cloud computing environments. Finally, [*PycompSS*](https://pypi.org/project/pycompss/) is a compiler-based approach, where task functions and code parallelization is based on annotations.    \n\n\n|Framework           | Clusters | Nested parallelism           | MPI |\n|--------------------|----------|------------------------------|-----|\n| *multiprocessing*  | No       | No                           | No  |\n| *futures*          | No       | No                           | No  |\n| *mpi4py.futures*   | Yes      | No                           | No  |\n| *dtm (deap 0.9.2)* | Yes      | Inefficiently (threads)      | Yes |\n| *scoop (0.7.1.1)*  | Yes      | Yes, coroutines              | No  |\n| *celery (4.2.0)*   | Yes      | No                           | No  |\n| *dask (1.2.2)*     | Yes      | Inefficiently (more workers) | No  |\n| *pycompss (2.4)*   | Yes      | Yes                          | No  |\n| **torcpy**         | Yes      | Yes                          | Yes |\n\n\n\n## Authors and contacts\n - Panagiotis Chatzidoukas, IBM Research - Zurich, hat@zurich.ibm.com\n - Cristiano Malossi, IBM Research - Zurich, acm@zurich.ibm.com\n - Costas Bekas, IBM Research - Zurich, bek@zurich.ibm.com\n\n## Acknowledgments\n\nWe would like to thank our colleagues in the IBM OCL team: Roxana Istrate, Florian Scheidegger, Andrea Bartezzaghi and Nico Gorbach.\nThis work was supported by VIMMP (Virtual Materials Marketplace Project) (Horizon 2020, GA No 760907).\n\n## References\n\n[Hadjidoukas:2012] A Runtime Library for Platform-Independent Task Parallelism. PDP 2012: 229-236. 2011\n[[DOI]](https://doi.org/10.1109/PDP.2012.89)  \n[Hadjidoukas:2015] \"\u03a04U: a high performance computing framework for Bayesian uncertainty quantification of complex models\",\" Journal of Computational Physics, 284:1\u201321, 2015. [[DOI]](https://doi.org/10.1016/j.jcp.2014.12.006)\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/ibm/torc_py/", "keywords": "", "license": "Eclipse Public License v1.0", "maintainer": "", "maintainer_email": "", "name": "torcpy", "package_url": "https://pypi.org/project/torcpy/", "platform": "", "project_url": "https://pypi.org/project/torcpy/", "project_urls": {"Homepage": "http://github.com/ibm/torc_py/"}, "release_url": "https://pypi.org/project/torcpy/0.1.1/", "requires_dist": ["mpi4py", "numpy", "termcolor", "cma", "pillow", "coloredlogs", "pytest"], "requires_python": "", "summary": "TORC Tasking library", "version": "0.1.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>torcpy: supporting task-based parallelism in Python</h1>\n<h2>1. Introduction</h2>\n<p><strong>torcpy</strong> is a platform-agnostic adaptive load balancing library that orchestrates scheduling of multiple function evaluations on both shared and distributed memory platforms.</p>\n<p>As an open-source tasking library, <strong>torcpy</strong>, aims at providing a parallel computing framework that:</p>\n<ul>\n<li>offers a unified approach for expressing and executing task-based parallelism on both shared and distributed memory platforms</li>\n<li>takes advantage of MPI internally in a transparent to the user way but also allows the use of legacy MPI code at the application level</li>\n<li>provides lightweight support for parallel nested loops and map functions</li>\n<li>supports task stealing at all levels of parallelism</li>\n<li>exports the above functionalities through a simple and single Python package</li>\n</ul>\n<p>torcpy exports an interface compatible with PEP 3148. Therefore tasks (futures) can be spawned and joined with the <em>submit</em> and <em>wait</em> calls. A parallel <em>map</em> function is provided, while <em>spmd</em> allows for switching\nto the typical SPMD execution mode that is natively supported by MPI.</p>\n<h2>2. Installation and testing</h2>\n<h3>2.1 Installation</h3>\n<p>Prerequisites: <code>python3 &gt;= 5</code> and <code>pip3</code>.</p>\n<pre>git clone git@github.com:IBM/torc_py.git\n<span class=\"nb\">cd</span> torc_py\npip3 install .\n</pre>\n<p>Observation:\nThe main requirements are <em>mpi4py</em> and <em>termcolor</em>, while <em>numpy</em>, <em>cma</em>, <em>h5py</em> and <em>pillow</em> are needed by some examples.</p>\n<h3>2.2. Testing</h3>\n<p>We use the file <code>examples\\ex00_masterworker.py</code> to demonstrate the execution of the tasking library using multiple processes and threads. The task function receives as input a number <code>x</code>, sleeps for one second and then computes and returns as result the square value <code>x*x</code>. The main task spawns <code>ntasks</code> (= four) tasks that are distributed cyclically, by default, to the available workers and then calls <code>wait</code>, waiting for their completion. Finally, it prints the task results and reports the elapsed time.</p>\n<p>The MPI processes start with the execution of <code>__main__</code> and call <code>torcpy.start(main)</code>, which initializes the tasking library and then executes the primary application task (with task function <code>main()</code>) on the process with rank 0.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">time</span>\n<span class=\"kn\">import</span> <span class=\"nn\">threading</span>\n<span class=\"kn\">import</span> <span class=\"nn\">torcpy</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">work</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">**</span><span class=\"mi\">2</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"work inp=</span><span class=\"si\">{:.3f}</span><span class=\"s2\">, out=</span><span class=\"si\">{:.3f}</span><span class=\"s2\"> ...on node </span><span class=\"si\">{:d}</span><span class=\"s2\"> worker </span><span class=\"si\">{}</span><span class=\"s2\"> thread </span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">torcpy</span><span class=\"o\">.</span><span class=\"n\">node_id</span><span class=\"p\">(),</span> <span class=\"n\">torcpy</span><span class=\"o\">.</span><span class=\"n\">worker_id</span><span class=\"p\">(),</span> <span class=\"n\">threading</span><span class=\"o\">.</span><span class=\"n\">get_ident</span><span class=\"p\">()),</span> <span class=\"n\">flush</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">y</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">ntasks</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>\n    <span class=\"n\">sequence</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ntasks</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n    <span class=\"n\">t0</span> <span class=\"o\">=</span> <span class=\"n\">torcpy</span><span class=\"o\">.</span><span class=\"n\">gettime</span><span class=\"p\">()</span>\n    <span class=\"n\">tasks</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">sequence</span><span class=\"p\">:</span>\n        <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">torcpy</span><span class=\"o\">.</span><span class=\"n\">submit</span><span class=\"p\">(</span><span class=\"n\">work</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">)</span>\n        <span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"p\">)</span>\n    <span class=\"n\">torcpy</span><span class=\"o\">.</span><span class=\"n\">wait</span><span class=\"p\">()</span>\n    <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"n\">torcpy</span><span class=\"o\">.</span><span class=\"n\">gettime</span><span class=\"p\">()</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">tasks</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Received: </span><span class=\"si\">{}</span><span class=\"s2\">^2=</span><span class=\"si\">{:.3f}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">input</span><span class=\"p\">(),</span> <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">()))</span>\n\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Elapsed time=</span><span class=\"si\">{:.2f}</span><span class=\"s2\"> s\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">t1</span> <span class=\"o\">-</span> <span class=\"n\">t0</span><span class=\"p\">))</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">torcpy</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">)</span>\n</pre>\n<h3>2.3 Execution of tests</h3>\n<h4>2.3.1. One MPI process with one worker</h4>\n<p>This is similar to the sequential execution of the code with the main difference that the task functions are executed not immediately but in deferred mode. No MPI communication takes place and the tasks are directly inserted in the local queue. Upon <code>torcpy.wait()</code>, the current (primary) application task suspends its execution, the scheduling loop of the underlying worker is activated and the child tasks are fetched and executed. When the last child task completes, the primary task resumes and prints the results. Moreover, the tasking library reports how many tasks where created and executed by each MPI process.</p>\n<pre><span class=\"gp\">$</span> mpirun -n <span class=\"m\">1</span> python3 ex00_masterworker.py\n<span class=\"go\">TORCPY: main starts</span>\n<span class=\"go\">work inp=1.000, out=1.000 ...on node 0 worker 0 thread 4536538560</span>\n<span class=\"go\">work inp=2.000, out=4.000 ...on node 0 worker 0 thread 4536538560</span>\n<span class=\"go\">work inp=3.000, out=9.000 ...on node 0 worker 0 thread 4536538560</span>\n<span class=\"go\">work inp=4.000, out=16.000 ...on node 0 worker 0 thread 4536538560</span>\n<span class=\"go\">Received: 1^2=1.000</span>\n<span class=\"go\">Received: 2^2=4.000</span>\n<span class=\"go\">Received: 3^2=9.000</span>\n<span class=\"go\">Received: 4^2=16.000</span>\n<span class=\"go\">Elapsed time=4.03 s</span>\n<span class=\"go\">TORCPY: node[0]: created=4, executed=4</span>\n</pre>\n<h4>2.3.2. Two MPI process with one worker each</h4>\n<p>Two MPI processes (<em>nodes</em>) are started with rank 0 and 1, respectively. Each process has a single worker thread, with global id 0 and 1, accordingly. The primary task runs on rank 0 and spawns the four tasks. The first and the third tasks are submitted locally to worker 0 while the second and fourth tasks are send to worker 1.</p>\n<pre><span class=\"gp\">$</span> mpirun -n <span class=\"m\">2</span> python3 ex00_masterworker.py\n<span class=\"go\">TORCPY: main starts</span>\n<span class=\"go\">work inp=1.000, out=1.000 ...on node 0 worker 0 thread 4585866688</span>\n<span class=\"go\">work inp=2.000, out=4.000 ...on node 1 worker 1 thread 4623332800</span>\n<span class=\"go\">work inp=3.000, out=9.000 ...on node 0 worker 0 thread 4585866688</span>\n<span class=\"go\">work inp=4.000, out=16.000 ...on node 1 worker 1 thread 4623332800</span>\n<span class=\"go\">Received: 1^2=1.000</span>\n<span class=\"go\">Received: 2^2=4.000</span>\n<span class=\"go\">Received: 3^2=9.000</span>\n<span class=\"go\">Received: 4^2=16.000</span>\n<span class=\"go\">Elapsed time=2.03 s</span>\n<span class=\"go\">TORCPY: node[0]: created=4, executed=2</span>\n<span class=\"go\">TORCPY: node[1]: created=0, executed=2</span>\n</pre>\n<h4>2.3.3. One MPI process with two workers</h4>\n<p>The single MPI process is initialized with two worker threads, with global ids 0 and 1. The four tasks are inserted in the local process queue and extracted and executed by the two workers. The primary task is executed by worker 0 and it is also tied to it, therefore it always continues on the same worker.</p>\n<pre><span class=\"gp\">$</span> mpirun -n <span class=\"m\">1</span> -env <span class=\"nv\">TORCPY_WORKERS</span><span class=\"o\">=</span><span class=\"m\">2</span>  python3 ex00_masterworker.py\n<span class=\"go\">TORCPY: main starts</span>\n<span class=\"go\">work inp=1.000, out=1.000 ...on node 0 worker 0 thread 4607645120</span>\n<span class=\"go\">work inp=2.000, out=4.000 ...on node 0 worker 1 thread 123145550958592</span>\n<span class=\"go\">work inp=3.000, out=9.000 ...on node 0 worker 0 thread 4607645120</span>\n<span class=\"go\">work inp=4.000, out=16.000 ...on node 0 worker 1 thread 123145550958592</span>\n<span class=\"go\">Received: 1^2=1.000</span>\n<span class=\"go\">Received: 2^2=4.000</span>\n<span class=\"go\">Received: 3^2=9.000</span>\n<span class=\"go\">Received: 4^2=16.000</span>\n<span class=\"go\">Elapsed time=2.02 s</span>\n<span class=\"go\">TORCPY: node[0]: created=4, executed=4</span>\n</pre>\n<h4>2.3.4 Two MPI processes with two workers each</h4>\n<p>There are two MPI processes with two workers each, therefore workers 0 and 1 belong to the process with rank 0 and workers 2 and 3 to rank 1. Since task distribution is performed on a worker basis, the first and the second tasks are submitted locally to node 0 while the third and fourth tasks are send to node 1. Eventually, every worker executes one task and the application is executed 4x times faster.</p>\n<pre><span class=\"gp\">$</span> mpirun -n <span class=\"m\">2</span> -env <span class=\"nv\">TORCPY_WORKERS</span><span class=\"o\">=</span><span class=\"m\">2</span>  python3 ex00_masterworker.py\n<span class=\"go\">TORCPY: main starts</span>\n<span class=\"go\">work inp=2.000, out=4.000 ...on node 0 worker 0 thread 4560111040</span>\n<span class=\"go\">work inp=1.000, out=1.000 ...on node 0 worker 1 thread 123145531727872</span>\n<span class=\"go\">work inp=4.000, out=16.000 ...on node 1 worker 2 thread 4643915200</span>\n<span class=\"go\">work inp=3.000, out=9.000 ...on node 1 worker 3 thread 123145537077248</span>\n<span class=\"go\">Received: 1^2=1.000</span>\n<span class=\"go\">Received: 2^2=4.000</span>\n<span class=\"go\">Received: 3^2=9.000</span>\n<span class=\"go\">Received: 4^2=16.000</span>\n<span class=\"go\">Elapsed time=1.04 s</span>\n<span class=\"go\">TORCPY: node[0]: created=4, executed=2</span>\n<span class=\"go\">TORCPY: node[1]: created=0, executed=2</span>\n</pre>\n<h2>3. Examples</h2>\n<p>Please note that the <code>torcpy</code> module is imported as <code>torc</code> in the following examples.</p>\n<h3>3.1. Submit and wait</h3>\n<p>The primary task spawns and distributes cyclically 10 tasks to the available workers, waits for their completion and finally prints the results.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">torcpy</span> <span class=\"k\">as</span> <span class=\"nn\">torc</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">work</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">x</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n    <span class=\"n\">tasks</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">d</span> <span class=\"ow\">in</span> <span class=\"n\">data</span><span class=\"p\">:</span>\n        <span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">submit</span><span class=\"p\">(</span><span class=\"n\">work</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">))</span>\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">wait</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">tasks</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">())</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">)</span>\n</pre>\n<h3>3.2. Parallel map</h3>\n<p>Equivalent to the previous example but this time using the <code>map</code> function with default chunk size equal to 1.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">torcpy</span> <span class=\"k\">as</span> <span class=\"nn\">torc</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">work</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">x</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n    <span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">work</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">)</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">results</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">)</span>\n</pre>\n<h3>3.3. Simple callback example</h3>\n<p>Four tasks are spawned and executed by the available workers. When a task completes, it is passed as argument to a callback task that is executed by the worker threads of the node (process) where the parent task is active.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">torcpy</span> <span class=\"k\">as</span> <span class=\"nn\">torc</span>\n<span class=\"kn\">import</span> <span class=\"nn\">threading</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">cb</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"p\">):</span>\n    <span class=\"n\">arg</span> <span class=\"o\">=</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">()</span>\n    <span class=\"n\">tid</span> <span class=\"o\">=</span> <span class=\"n\">threading</span><span class=\"o\">.</span><span class=\"n\">get_ident</span><span class=\"p\">()</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"thread </span><span class=\"si\">{}</span><span class=\"s2\">: callback with arg=</span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">tid</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">),</span> <span class=\"n\">flush</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">work</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"n\">tid</span> <span class=\"o\">=</span> <span class=\"n\">threading</span><span class=\"o\">.</span><span class=\"n\">get_ident</span><span class=\"p\">()</span>\n    <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">x</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"thread </span><span class=\"si\">{}</span><span class=\"s2\">: work inp=</span><span class=\"si\">{}</span><span class=\"s2\">, out=</span><span class=\"si\">{}</span><span class=\"s2\"> ... on node </span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">tid</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">node_id</span><span class=\"p\">()),</span> <span class=\"n\">flush</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">y</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">ntasks</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>\n    <span class=\"n\">sequence</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ntasks</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n    <span class=\"n\">t_all</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">sequence</span><span class=\"p\">:</span>\n        <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">submit</span><span class=\"p\">(</span><span class=\"n\">work</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"n\">cb</span><span class=\"p\">)</span>\n        <span class=\"n\">t_all</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"p\">)</span>\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">wait</span><span class=\"p\">()</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">task</span> <span class=\"ow\">in</span> <span class=\"n\">t_all</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Received: </span><span class=\"si\">{}</span><span class=\"s2\">^2=</span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">input</span><span class=\"p\">(),</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">()))</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">)</span>\n</pre>\n<h3>3.4. Hierarchical parallelism: recursive Fibonacci</h3>\n<p>Multiple levels of parallelism are exploited in this commonly used parallelization example of recursive Fibonacci.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">torcpy</span> <span class=\"k\">as</span> <span class=\"nn\">torc</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">fib</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">elif</span> <span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">n_1</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n        <span class=\"n\">n_2</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"mi\">2</span>\n        <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"mi\">30</span><span class=\"p\">:</span>\n            <span class=\"n\">result1</span> <span class=\"o\">=</span> <span class=\"n\">fib</span><span class=\"p\">(</span><span class=\"n\">n_1</span><span class=\"p\">)</span>\n            <span class=\"n\">result2</span> <span class=\"o\">=</span> <span class=\"n\">fib</span><span class=\"p\">(</span><span class=\"n\">n_2</span><span class=\"p\">)</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">result1</span> <span class=\"o\">+</span> <span class=\"n\">result2</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"n\">task1</span> <span class=\"o\">=</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">submit</span><span class=\"p\">(</span><span class=\"n\">fib</span><span class=\"p\">,</span> <span class=\"n\">n_1</span><span class=\"p\">)</span>\n            <span class=\"n\">task2</span> <span class=\"o\">=</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">submit</span><span class=\"p\">(</span><span class=\"n\">fib</span><span class=\"p\">,</span> <span class=\"n\">n_2</span><span class=\"p\">)</span>\n            <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">wait</span><span class=\"p\">()</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">task1</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"n\">task2</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">()</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">result</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"mi\">35</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">fib</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"fib(</span><span class=\"si\">{}</span><span class=\"s2\">) = </span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">result</span><span class=\"p\">))</span>\n</pre>\n<h3>3.5. Calling MPI SPMD code: MPI_Bcast</h3>\n<p>The global array <code>A</code> is initialized by the primary application task (<code>main</code>) on MPI process 0.\nNext, the <code>spmd</code> function triggers the execution of <code>bcast_task</code> on all MPI processes, thus switching\nto the SPMD execution model and allowing for direct data broadcast using <code>Bcast</code>.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">numpy</span>\n<span class=\"kn\">import</span> <span class=\"nn\">torcpy</span> <span class=\"k\">as</span> <span class=\"nn\">torc</span>\n<span class=\"kn\">from</span> <span class=\"nn\">mpi4py</span> <span class=\"kn\">import</span> <span class=\"n\">MPI</span>\n\n<span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n<span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">float64</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">bcast_task</span><span class=\"p\">(</span><span class=\"n\">root</span><span class=\"p\">):</span>\n    <span class=\"k\">global</span> <span class=\"n\">A</span>\n    <span class=\"n\">comm</span> <span class=\"o\">=</span> <span class=\"n\">MPI</span><span class=\"o\">.</span><span class=\"n\">COMM_WORLD</span>\n    <span class=\"c1\"># Broadcast A from rank 0</span>\n    <span class=\"n\">comm</span><span class=\"o\">.</span><span class=\"n\">Bcast</span><span class=\"p\">([</span><span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">MPI</span><span class=\"o\">.</span><span class=\"n\">DOUBLE</span><span class=\"p\">],</span> <span class=\"n\">root</span><span class=\"o\">=</span><span class=\"n\">root</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">work</span><span class=\"p\">():</span>\n    <span class=\"k\">global</span> <span class=\"n\">A</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"node:</span><span class=\"si\">{}</span><span class=\"s2\"> -&gt; A=</span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">node_id</span><span class=\"p\">(),</span> <span class=\"n\">A</span><span class=\"p\">))</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">global</span> <span class=\"n\">A</span>\n\n    <span class=\"c1\"># primary task initializes array A on rank 0</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">):</span>\n        <span class=\"n\">A</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"o\">*</span><span class=\"n\">i</span>\n\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">spmd</span><span class=\"p\">(</span><span class=\"n\">bcast_task</span><span class=\"p\">,</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">node_id</span><span class=\"p\">())</span>  <span class=\"c1\"># 2nd arg (root) is 0 and can be omitted</span>\n\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">spmd</span><span class=\"p\">(</span><span class=\"n\">work</span><span class=\"p\">)</span>\n</pre>\n<h3>3.6. Reduction operation using callbacks</h3>\n<p>In this example, the callback function adds the task result to a global variable, implementing thus\na reduction operation. This example assumes that a single worker thread per MPI process is used and that callbacks are instantiated as tasks that are executed by worker threads.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">torcpy</span> <span class=\"k\">as</span> <span class=\"nn\">torc</span>\n\n<span class=\"n\">sum_v</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">cb</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"p\">):</span>\n    <span class=\"k\">global</span> <span class=\"n\">sum_v</span>\n    <span class=\"n\">arg</span> <span class=\"o\">=</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">()</span>\n    <span class=\"n\">sum_v</span> <span class=\"o\">=</span> <span class=\"n\">sum_v</span> <span class=\"o\">+</span> <span class=\"n\">arg</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">work</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">**</span> <span class=\"mi\">2</span>\n    <span class=\"k\">return</span> <span class=\"n\">y</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n\n    <span class=\"n\">tasks</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">d</span> <span class=\"ow\">in</span> <span class=\"n\">data</span><span class=\"p\">:</span>\n        <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">submit</span><span class=\"p\">(</span><span class=\"n\">work</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"n\">cb</span><span class=\"p\">)</span>\n        <span class=\"n\">tasks</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">)</span>\n\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">wait</span><span class=\"p\">()</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Sum=\"</span><span class=\"p\">,</span> <span class=\"n\">sum_v</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">)</span>\n</pre>\n<h3>3.7. Late switch from SPMD to master-worker and image preprocessing</h3>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n<span class=\"kn\">from</span> <span class=\"nn\">PIL</span> <span class=\"kn\">import</span> <span class=\"n\">Image</span>\n<span class=\"kn\">import</span> <span class=\"nn\">torcpy</span> <span class=\"k\">as</span> <span class=\"nn\">torc</span>\n\n<span class=\"n\">files</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">get_files</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">):</span>\n    <span class=\"n\">all_files</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">dirpath</span><span class=\"p\">,</span> <span class=\"n\">dirnames</span><span class=\"p\">,</span> <span class=\"n\">filenames</span> <span class=\"ow\">in</span> <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">walk</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">):</span>\n        <span class=\"k\">for</span> <span class=\"n\">f</span> <span class=\"ow\">in</span> <span class=\"n\">filenames</span><span class=\"p\">:</span>\n            <span class=\"k\">if</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">endswith</span><span class=\"p\">(</span><span class=\"s1\">'.jpg'</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">endswith</span><span class=\"p\">(</span><span class=\"s1\">'.jpeg'</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">endswith</span><span class=\"p\">(</span><span class=\"s1\">'.png'</span><span class=\"p\">):</span>\n                <span class=\"n\">all_files</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">(</span><span class=\"n\">dirpath</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">))</span>\n\n    <span class=\"k\">return</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">all_files</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">work</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">):</span>\n    <span class=\"k\">global</span> <span class=\"n\">files</span>\n    <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">files</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span>\n    <span class=\"k\">with</span> <span class=\"n\">Image</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">im</span><span class=\"p\">:</span>\n        <span class=\"n\">im</span> <span class=\"o\">=</span> <span class=\"n\">im</span><span class=\"o\">.</span><span class=\"n\">resize</span><span class=\"p\">((</span><span class=\"mi\">32</span><span class=\"p\">,</span> <span class=\"mi\">32</span><span class=\"p\">))</span>\n        <span class=\"c1\"># do something more here</span>\n\n    <span class=\"k\">return</span> <span class=\"kc\">None</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">global</span> <span class=\"n\">files</span>\n\n    <span class=\"c1\"># SPMD execution: torcpy and MPI initialization</span>\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">init</span><span class=\"p\">()</span>\n\n    <span class=\"c1\"># SPMD execution: common global initialization takes place here</span>\n    <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">node_id</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"usage: python3 </span><span class=\"si\">{}</span><span class=\"s2\"> &lt;path&gt;\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">basename</span><span class=\"p\">(</span><span class=\"vm\">__file__</span><span class=\"p\">)))</span>\n        <span class=\"k\">return</span>\n\n    <span class=\"n\">files</span> <span class=\"o\">=</span> <span class=\"n\">get_files</span><span class=\"p\">(</span><span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n\n    <span class=\"c1\"># Switching to master-worker</span>\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">launch</span><span class=\"p\">(</span><span class=\"kc\">None</span><span class=\"p\">)</span>\n\n    <span class=\"n\">t0</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span>\n    <span class=\"n\">_</span> <span class=\"o\">=</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">work</span><span class=\"p\">,</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">files</span><span class=\"p\">)))</span>\n    <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">time</span><span class=\"p\">()</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"t1-t0=\"</span><span class=\"p\">,</span> <span class=\"n\">t1</span><span class=\"o\">-</span><span class=\"n\">t0</span><span class=\"p\">)</span>\n\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">shutdown</span><span class=\"p\">()</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">\"__main__\"</span><span class=\"p\">:</span>\n    <span class=\"n\">main</span><span class=\"p\">()</span>\n</pre>\n<h3>3.8. Parallel numerical optimization</h3>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">cma</span>  <span class=\"c1\"># python package for numerical optimization</span>\n<span class=\"kn\">import</span> <span class=\"nn\">torcpy</span> <span class=\"k\">as</span> <span class=\"nn\">torc</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">rosenbrock</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"Rosenbrock test objective function\"\"\"</span>\n    <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n      <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s1\">'dimension must be greater one'</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"mi\">100</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">])</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">**</span><span class=\"mi\">2</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">es</span> <span class=\"o\">=</span> <span class=\"n\">cma</span><span class=\"o\">.</span><span class=\"n\">CMAEvolutionStrategy</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"s1\">'popsize'</span><span class=\"p\">:</span><span class=\"mi\">640</span><span class=\"p\">})</span>\n    <span class=\"k\">while</span> <span class=\"ow\">not</span> <span class=\"n\">es</span><span class=\"o\">.</span><span class=\"n\">stop</span><span class=\"p\">():</span>\n        <span class=\"n\">solutions</span> <span class=\"o\">=</span> <span class=\"n\">es</span><span class=\"o\">.</span><span class=\"n\">ask</span><span class=\"p\">()</span>\n        <span class=\"n\">es</span><span class=\"o\">.</span><span class=\"n\">tell</span><span class=\"p\">(</span><span class=\"n\">solutions</span><span class=\"p\">,</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">rosenbrock</span><span class=\"p\">,</span> <span class=\"n\">solutions</span><span class=\"p\">))</span>\n        <span class=\"n\">es</span><span class=\"o\">.</span><span class=\"n\">logger</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">es</span><span class=\"p\">)</span>  <span class=\"c1\"># write data to disc to be plotted</span>\n        <span class=\"n\">es</span><span class=\"o\">.</span><span class=\"n\">disp</span><span class=\"p\">()</span>\n\n    <span class=\"n\">cma</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">()</span>\n</pre>\n<h3>3.9. Demonstration of work stealing</h3>\n<p>All 16 tasks are submitted by the primary task, running on node 0, to the worker thread of rank 1.\nThe idle workers that find the local queue empty, issue steal requests and eventually retreive a task from the queue of rank 1. The primary task resumes when all the child tasks have completed and their results are available on rank 0.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">time</span>\n<span class=\"kn\">import</span> <span class=\"nn\">torcpy</span> <span class=\"k\">as</span> <span class=\"nn\">torc</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">work</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">*</span><span class=\"n\">x</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"taskfun inp=</span><span class=\"si\">{}</span><span class=\"s2\">, out=</span><span class=\"si\">{}</span><span class=\"s2\"> ...on node </span><span class=\"si\">{:d}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">node_id</span><span class=\"p\">()),</span> <span class=\"n\">flush</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">y</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"n\">nodes</span> <span class=\"o\">=</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">num_nodes</span><span class=\"p\">()</span>\n    <span class=\"k\">if</span> <span class=\"n\">nodes</span> <span class=\"o\">&lt;</span> <span class=\"mi\">2</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"This examples needs at least two MPI processes. Exiting...\"</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span>\n    <span class=\"n\">local_workers</span> <span class=\"o\">=</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">num_local_workers</span><span class=\"p\">()</span>\n    <span class=\"k\">if</span> <span class=\"n\">local_workers</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"This examples should use one worker thread per MPI process. Exiting...\"</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span>\n\n    <span class=\"n\">ntasks</span> <span class=\"o\">=</span> <span class=\"mi\">16</span>\n    <span class=\"n\">sequence</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ntasks</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\n    <span class=\"n\">t0</span> <span class=\"o\">=</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">gettime</span><span class=\"p\">()</span>\n    <span class=\"n\">t_all</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">sequence</span><span class=\"p\">:</span>\n        <span class=\"k\">try</span><span class=\"p\">:</span>\n            <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">submit</span><span class=\"p\">(</span><span class=\"n\">work</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">qid</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">t_all</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"p\">)</span>\n        <span class=\"k\">except</span> <span class=\"ne\">ValueError</span><span class=\"p\">:</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"torc.submit: invalid argument\"</span><span class=\"p\">)</span>\n\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">enable_stealing</span><span class=\"p\">()</span>\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">wait</span><span class=\"p\">()</span>\n    <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">gettime</span><span class=\"p\">()</span>\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">disable_stealing</span><span class=\"p\">()</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">task</span> <span class=\"ow\">in</span> <span class=\"n\">t_all</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Received: </span><span class=\"si\">{}</span><span class=\"s2\">^2=</span><span class=\"si\">{}</span><span class=\"s2\">\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">input</span><span class=\"p\">(),</span> <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"n\">result</span><span class=\"p\">()))</span>\n\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\"Elapsed time=</span><span class=\"si\">{:.2f}</span><span class=\"s2\"> s\"</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"n\">t1</span> <span class=\"o\">-</span> <span class=\"n\">t0</span><span class=\"p\">))</span>\n\n\n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">torc</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">)</span>\n</pre>\n<h2>4. Application Programming Interface</h2>\n<h3>4.1. Task management routines</h3>\n<ul>\n<li><code>submit(f, *args, qid=-1, callback=None, **kwargs)</code>:\nsubmits a new task that corresponds to the asynchronous execution of function <code>f()</code> with input arguments <code>args</code>. The task is submitted to the worker with global identifier <code>qid</code>. If <code>qid</code> is equal to -1, then cyclic distribution of tasks to processes is performed. The <code>callback</code> function is called on the rank that spawned the task, when the task completes and its results have been returned to that node.</li>\n<li><code>map(f, *seq, chunksize=1)</code>: executes function <code>f()</code> on a sequence (list) of arguments.\nIt returns a list with the results of all tasks. It is similar to the <code>map()</code> function of Python and other packages, allowing for straightforward usage of existing codes.</li>\n<li><code>wait(tasks=None)</code>: the current task waits for all its child tasks to finish. The underlying worker thread is released and can execute other tasks.</li>\n<li><code>as_completed(tasks=None)</code>: similar to <code>wait</code> but returns the finished child tasks in the order they completed their execution.</li>\n</ul>\n<h3>4.2. Application setup</h3>\n<ul>\n<li><code>start(f)</code>: initializes the library, launches function <code>f()</code> on process with rank 0 as the primary application task. When <code>f()</code> completes, it shutdowns the library. It is a collective function that must be called within <code>__main__</code>.</li>\n</ul>\n<pre><span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s1\">'__main__'</span><span class=\"p\">:</span>\n    <span class=\"n\">torcpy</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">(</span><span class=\"n\">main</span><span class=\"p\">)</span>\n</pre>\n<h3>4.3. Low-level application setup</h3>\n<ul>\n<li><code>init()</code>: initializes the tasking library.</li>\n<li><code>launch(f)</code>: launches function <code>f()</code> as primary application task on the MPI process with rank 0. It is a collective call that must be called by all MPI processes. If <code>f == NULL</code> then the function returns on rank 0 but activates the scheduling loop of the main worker thread on all other MPI processes. Therefore, the current function becomes the primary application task running on rank 0.</li>\n<li><code>shutdown()</code>: shutdowns the tasking library.</li>\n</ul>\n<h3>4.4. MPI code</h3>\n<ul>\n<li><code>spmd(f, *args)</code>: executes function <code>f()</code> on all MPI processes. It allows for dynamic switching from the master-worker to the SPMD execution mode, allowing thus legacy MPI code to be used within the function.</li>\n</ul>\n<h3>4.5. Additional calls</h3>\n<ul>\n<li><code>enable_stealing(), disable_stealing()</code>: control task stealing between MPI processes.</li>\n<li><code>gettime()</code>: current time in seconds (float).</li>\n<li><code>worker_id(), num_workers()</code>: return the global worker thread id and the total number of workers.</li>\n<li><code>node_id(), num_nodes()</code>: return the rank of the calling MPI process and the number of MPI processes.</li>\n</ul>\n<h3>4.6 Context manager</h3>\n<h3>4.7. Environment variables</h3>\n<ul>\n<li><code>TORCPY_WORKERS</code> (integer): number of worker threads used by each MPI processor. Default value is 1.</li>\n<li><code>TORCPY_STEALING</code> (boolean): determines if internode task-stealing is enabled or not. Default value is \"False\".</li>\n<li><code>TORCPY_SERVER_YIELDTIME</code> (float): for how many seconds an idle server thread will sleep releasing the processor. Default value is 0.01.</li>\n<li><code>TORCPY_WORKER_YIELDTIME</code> (float): for how many seconds an idle worker thread will sleep releasing the processor. Default value is 0.01.</li>\n</ul>\n<h2>5. Design and architecture</h2>\n<p>The library is implemented on top of MPI and multithreading and it can considered as the pure Python implementation of the <a href=\"https://github.com/phadjido/torc_lite\" rel=\"nofollow\"><em>TORC</em></a> C/C++ runtime library [Hadjidoukas:2012], a software package for programming and running unaltered task-parallel programs on both shared and distributed memory platforms. The library supports platform agnostic nested parallelism and automatic load balancing in large scale computing architectures. It has been used at the core of the <a href=\"https://github.ibm.com/cselab/pi4u\" rel=\"nofollow\">\u03a04U</a> framework [Hadjidoukas:2015], allowing for HPC implementations, for both multicore and GPU clusters, of algorithms such as Transitional Markov Chain Monte Carlo (TMCMC) and Approximate Bayesian Computational Subset-simulation.</p>\n<p><em>torcpy</em> is mainly built on top of the following third-party Python packages: <em>mpi4py</em>, <em>threading</em>, <em>queue</em>.\nTasks are instantiated as Python dictionaries, which introduce less overhead than objects. The result of the task function is transparently stored in the task descriptor (future) on the MPI process that spawned the task. According to PEP 3184, the result can be then accessed as <code>task.result()</code>. Similarly, the input parameters can be accessed as <code>task.input()</code>.</p>\n<p>All remote operations are performed asynchronously through a server thread. This thread is responsible for:</p>\n<ul>\n<li>inserting incoming tasks to the local queue of the process</li>\n<li>receiving the completed tasks and their results</li>\n<li>serving task stealing requests</li>\n</ul>\n<p>The internal architecture of <em>torcpy</em> is depicted in the following figure:</p>\n<p><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/386b158ac7b0490610bf31d765d76165e9f2e85e/2e2f646f632f746f72635f6172636869746563747572652e706e67\"></p>\n<h2>6. Performance evaluation</h2>\n<p>TORC, the C/C++ counterpart of torcpy has been used extensively on small and large scale HPC environments\nsuch as the Euler cluster (ETH) and the Piz Daint (CSCS) supercomputer. TORC has been used to orchestrate the scheduling of function evaluations of the TMCMC method within \u03a04U on multiple cluster nodes. The TMCMC method was able to achieve an overall parallel efficiency of more than 90% on 1024 compute nodes of Piz Daint running hybrid MPI+GPU molecular simulation codes with highly variable time-to-solution between simulations with different interaction parameters.</p>\n<h3>6.1. Preprocessing of image datasets</h3>\n<p>A typical preprocessing stage of Deep Learning workloads includes the transformation of datasets of raw images to a single file in HDF5 format. The images are organized in subfolders, where the name of each subfolder denotes the label of the enclosed images. For each image, the file is opened and the binary data are loaded to a buffer (numpy array). This operations includes data decompression if the image is stored in JPEG format. Then, the image is resized and rescaled and additional preprocessing filters might be also applied. Finally, the result is written to an HDF5 file, that we will be used at the training phase of deep learning.</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">process_train_image</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">target_dim</span><span class=\"p\">):</span>\n    <span class=\"k\">global</span> <span class=\"n\">reader</span><span class=\"p\">,</span> <span class=\"n\">pipe</span>\n\n    <span class=\"c1\"># load the image and its label</span>\n    <span class=\"n\">im</span><span class=\"p\">,</span> <span class=\"n\">label</span> <span class=\"o\">=</span> <span class=\"n\">reader</span><span class=\"o\">.</span><span class=\"n\">get_train_image</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span>        \n\n    <span class=\"c1\"># apply preprocessing filters</span>\n    <span class=\"n\">im</span> <span class=\"o\">=</span> <span class=\"n\">pipe</span><span class=\"o\">.</span><span class=\"n\">filter</span><span class=\"p\">(</span><span class=\"n\">im</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># resize accordingly</span>\n    <span class=\"n\">dx</span> <span class=\"o\">=</span> <span class=\"n\">image_to_4d_tensor</span><span class=\"p\">(</span><span class=\"n\">im</span><span class=\"p\">,</span> <span class=\"n\">target_dim</span><span class=\"p\">)</span>\n    <span class=\"n\">dy</span> <span class=\"o\">=</span> <span class=\"n\">label</span>\n\n    <span class=\"c1\"># return results</span>\n    <span class=\"k\">return</span> <span class=\"n\">dx</span><span class=\"p\">,</span> <span class=\"n\">dy</span>\n</pre>\n<p>The parallelization of the sequential for loop is performed with the map function, using a chunk size of 32 so as to reduce the number of spawned tasks.</p>\n<pre><span class=\"n\">sequence_i</span> <span class=\"o\">=</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">n_train</span><span class=\"p\">)</span>\n<span class=\"n\">sequence_t</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">target_dim</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">n_train</span>\n\n<span class=\"c1\"># parallel map with chunksize</span>\n<span class=\"n\">task_results</span> <span class=\"o\">=</span> <span class=\"n\">torcpy</span><span class=\"o\">.</span><span class=\"n\">map</span><span class=\"p\">(</span><span class=\"n\">process_train_image</span><span class=\"p\">,</span> <span class=\"n\">sequence_i</span><span class=\"p\">,</span> <span class=\"n\">sequence_t</span><span class=\"p\">,</span> <span class=\"n\">chunksize</span><span class=\"o\">=</span><span class=\"mi\">32</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># write the results to the HDF5 dataset</span>\n<span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"k\">for</span> <span class=\"n\">t</span> <span class=\"ow\">in</span> <span class=\"n\">task_results</span><span class=\"p\">:</span>\n    <span class=\"n\">dx</span><span class=\"p\">,</span> <span class=\"n\">dy</span> <span class=\"o\">=</span> <span class=\"n\">t</span>\n    <span class=\"n\">dataset_x</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"p\">:,</span> <span class=\"p\">:,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"n\">dx</span>\n    <span class=\"n\">dataset_y</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">dy</span>\n    <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span>\n</pre>\n<h3>6.2. Results</h3>\n<p><a href=\"http://www.image-net.org/\" rel=\"nofollow\">Imagenet</a> is very large dataset of 1000 classes, each with 1300 images stored in JPEG format. We preprocess the images of 10 training classes of the Imagenet dataset. We perform our experiments on a single IBM Power8 node equipped with 20 cores and 8 threads each. The software configuration includes Python 3.5, mpi4py/3.0.1 and OpenMPI/3.1.2.</p>\n<p>We spawn a single MPI process per core and then utilize 1,2 and 4 workers per process. The command for running the benchmark for various numbers of processes (<em>NR</em>) and local workers (<em>NW</em>) on the specific computing platform is as follows:</p>\n<pre><span class=\"go\">mpirun -n $NR -x TORCPY_WORKERS=$NW --bind-to core --map-by socket --mca btl self,tcp  python3 benchmark.py</span>\n</pre>\n<p>The measurements include the time for spawning the parallelism, executing the preprocessing in parallel and waiting for the completion of all tasks, i.e. collecting the results back. We observe that the application exhibits good scaling and achieves ~78% efficiency when 20 processes of one worker thread each are used. The performance does not scale linearly with the number of cores as image decompression and processing stress the memory subsystem of the node. We also observe that multithreading further improves the performance, allowing for a maximum achieved speedup of 22x (20 processes, 4 threads).</p>\n<p><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/eb3843667903d4959d22fb71463424937077c48e/2e2f646f632f70726570726f63657373696e675f706572666f726d616e63652e706e67\"></p>\n<h2>7. Related work</h2>\n<p>There is a number of Python packages and frameworks that enable the orchestration and execution of task-based parallelism on various computing platforms. On single-node multi-core systems Python provides two packages: the <a href=\"https://docs.python.org/3/library/multiprocessing.html\" rel=\"nofollow\"><em>multiprocessing</em></a> and the <a href=\"https://docs.python.org/3/library/concurrent.futures.html\" rel=\"nofollow\"><em>concurrent.futures</em></a>. The <a href=\"https://mpi4py.readthedocs.io/en/stable/mpi4py.futures.html\" rel=\"nofollow\"><em>futures</em> package of <em>mpi4py</em></a> provides an extension of <em>futures</em> on top of the MPI programming model. <a href=\"http://deap.gel.ulaval.ca/doc/0.9/api/dtm.html\" rel=\"nofollow\"><em>DTM</em></a> is an MPI-based framework that supports task-based parallelism. However, <em>DTM</em> is obsolete and has been replaced by <a href=\"http://pyscoop.org\" rel=\"nofollow\"><em>Scoop</em></a>, which follows a more distributed-based approach without relying on MPI. This is also the case for the <a href=\"http://www.celeryproject.org/\" rel=\"nofollow\"><em>Celery</em></a> and <a href=\"http://dask.pydata.org/en/latest/\" rel=\"nofollow\"><em>Dask</em></a> frameworks, which mainly target cloud computing environments. Finally, <a href=\"https://pypi.org/project/pycompss/\" rel=\"nofollow\"><em>PycompSS</em></a> is a compiler-based approach, where task functions and code parallelization is based on annotations.</p>\n<table>\n<thead>\n<tr>\n<th>Framework</th>\n<th>Clusters</th>\n<th>Nested parallelism</th>\n<th>MPI</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><em>multiprocessing</em></td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td><em>futures</em></td>\n<td>No</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td><em>mpi4py.futures</em></td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td><em>dtm (deap 0.9.2)</em></td>\n<td>Yes</td>\n<td>Inefficiently (threads)</td>\n<td>Yes</td>\n</tr>\n<tr>\n<td><em>scoop (0.7.1.1)</em></td>\n<td>Yes</td>\n<td>Yes, coroutines</td>\n<td>No</td>\n</tr>\n<tr>\n<td><em>celery (4.2.0)</em></td>\n<td>Yes</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td><em>dask (1.2.2)</em></td>\n<td>Yes</td>\n<td>Inefficiently (more workers)</td>\n<td>No</td>\n</tr>\n<tr>\n<td><em>pycompss (2.4)</em></td>\n<td>Yes</td>\n<td>Yes</td>\n<td>No</td>\n</tr>\n<tr>\n<td><strong>torcpy</strong></td>\n<td>Yes</td>\n<td>Yes</td>\n<td>Yes</td>\n</tr></tbody></table>\n<h2>Authors and contacts</h2>\n<ul>\n<li>Panagiotis Chatzidoukas, IBM Research - Zurich, <a href=\"mailto:hat@zurich.ibm.com\">hat@zurich.ibm.com</a></li>\n<li>Cristiano Malossi, IBM Research - Zurich, <a href=\"mailto:acm@zurich.ibm.com\">acm@zurich.ibm.com</a></li>\n<li>Costas Bekas, IBM Research - Zurich, <a href=\"mailto:bek@zurich.ibm.com\">bek@zurich.ibm.com</a></li>\n</ul>\n<h2>Acknowledgments</h2>\n<p>We would like to thank our colleagues in the IBM OCL team: Roxana Istrate, Florian Scheidegger, Andrea Bartezzaghi and Nico Gorbach.\nThis work was supported by VIMMP (Virtual Materials Marketplace Project) (Horizon 2020, GA No 760907).</p>\n<h2>References</h2>\n<p>[Hadjidoukas:2012] A Runtime Library for Platform-Independent Task Parallelism. PDP 2012: 229-236. 2011\n<a href=\"https://doi.org/10.1109/PDP.2012.89\" rel=\"nofollow\">[DOI]</a><br>\n[Hadjidoukas:2015] \"\u03a04U: a high performance computing framework for Bayesian uncertainty quantification of complex models\",\" Journal of Computational Physics, 284:1\u201321, 2015. <a href=\"https://doi.org/10.1016/j.jcp.2014.12.006\" rel=\"nofollow\">[DOI]</a></p>\n\n          </div>"}, "last_serial": 6452118, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "71beacab57883794fd1fda69511ec164", "sha256": "a2e2b07a70191964889a5d5edae4a06cc37afeeb52bdb1422bb3849b10c08dbf"}, "downloads": -1, "filename": "torcpy-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "71beacab57883794fd1fda69511ec164", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 26619, "upload_time": "2019-10-29T14:26:08", "upload_time_iso_8601": "2019-10-29T14:26:08.447672Z", "url": "https://files.pythonhosted.org/packages/d6/f5/dd168720c81f2222a1c131d2c716c1ac8e70a3aab1f98dbb14ca61da028a/torcpy-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "ab9975d9231e6203488cc6afbbc45aaf", "sha256": "52785c7e7df63805b3061453e48c20e2533ace6e0dbbf45f9d72f33c3e1fb414"}, "downloads": -1, "filename": "torcpy-0.1.tar.gz", "has_sig": false, "md5_digest": "ab9975d9231e6203488cc6afbbc45aaf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 31897, "upload_time": "2019-10-29T14:26:11", "upload_time_iso_8601": "2019-10-29T14:26:11.948230Z", "url": "https://files.pythonhosted.org/packages/ec/70/0b7752d5d749eea5dbdd387420996817457dc1144037283c365ce4408f57/torcpy-0.1.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "4fd26eb69cf56a145eadfe2d2f7809e6", "sha256": "fe1af7413c278871698aa0cce99ae5dec61c62c0e70397bfd1fced4cc7c1f4c9"}, "downloads": -1, "filename": "torcpy-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "4fd26eb69cf56a145eadfe2d2f7809e6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 20730, "upload_time": "2020-01-14T15:04:05", "upload_time_iso_8601": "2020-01-14T15:04:05.573627Z", "url": "https://files.pythonhosted.org/packages/8d/17/bf19dbce022c3e8f7b38e664d4bcaa88e657a856839d4e914bf9fa0d9c30/torcpy-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8cfd5ecec57d26dd2c5af1adcf1c639f", "sha256": "a672c51729ee549154b59a424916a9fc4ee17ac8430b75177ba840a08eb41767"}, "downloads": -1, "filename": "torcpy-0.1.1.tar.gz", "has_sig": false, "md5_digest": "8cfd5ecec57d26dd2c5af1adcf1c639f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32170, "upload_time": "2020-01-14T15:04:07", "upload_time_iso_8601": "2020-01-14T15:04:07.921665Z", "url": "https://files.pythonhosted.org/packages/df/23/cc779a7241ba2b7a1773ac8495f21f35fb4684fe179b3e3393ad83716e01/torcpy-0.1.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4fd26eb69cf56a145eadfe2d2f7809e6", "sha256": "fe1af7413c278871698aa0cce99ae5dec61c62c0e70397bfd1fced4cc7c1f4c9"}, "downloads": -1, "filename": "torcpy-0.1.1-py3-none-any.whl", "has_sig": false, "md5_digest": "4fd26eb69cf56a145eadfe2d2f7809e6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 20730, "upload_time": "2020-01-14T15:04:05", "upload_time_iso_8601": "2020-01-14T15:04:05.573627Z", "url": "https://files.pythonhosted.org/packages/8d/17/bf19dbce022c3e8f7b38e664d4bcaa88e657a856839d4e914bf9fa0d9c30/torcpy-0.1.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8cfd5ecec57d26dd2c5af1adcf1c639f", "sha256": "a672c51729ee549154b59a424916a9fc4ee17ac8430b75177ba840a08eb41767"}, "downloads": -1, "filename": "torcpy-0.1.1.tar.gz", "has_sig": false, "md5_digest": "8cfd5ecec57d26dd2c5af1adcf1c639f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32170, "upload_time": "2020-01-14T15:04:07", "upload_time_iso_8601": "2020-01-14T15:04:07.921665Z", "url": "https://files.pythonhosted.org/packages/df/23/cc779a7241ba2b7a1773ac8495f21f35fb4684fe179b3e3393ad83716e01/torcpy-0.1.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:50:02 2020"}