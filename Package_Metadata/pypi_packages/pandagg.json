{"info": {"author": "L\u00e9onard Binet", "author_email": "leonardbinet@gmail.com", "bugtrack_url": null, "classifiers": [], "description": "## What is it?\n\n**pandagg** is a Python package providing a simple interface to manipulate ElasticSearch queries and aggregations.\n\n***Disclaimer*** *:this is a pre-release version*\n## Features\n\n- flexible aggregation and search queries declaration\n- query validation based on provided mapping\n- parsing of aggregation results in handy formats: tree with interactive navigation, csv-like tabular breakdown, and others\n- mapping interactive navigation\n\n\n## Usage\n\n### Documentation\nFull documentation and user-guide are available [here on read-the-docs](https://pandagg.readthedocs.io/en/latest/).\n\n### Quick sneak peek \n**Elasticsearch dict syntax**\n```\n>>> from pandagg.query import Query\n\n>>> expected_query = {'bool': {'must': [\n    {'terms': {'genres': ['Action', 'Thriller']}},\n    {'range': {'rank': {'gte': 7}}},\n    {'nested': {\n        'path': 'roles',\n        'query': {'bool': {'must': [\n            {'term': {'roles.gender': {'value': 'F'}}},\n            {'term': {'roles.role': {'value': 'Reporter'}}}]}\n         }\n    }}\n]}}\n>>> q = Query(expected_query)\n>>> q\n<Query>\nbool\n\u2514\u2500\u2500 must\n    \u251c\u2500\u2500 nested\n    \u2502   \u251c\u2500\u2500 path=\"roles\"\n    \u2502   \u2514\u2500\u2500 query\n    \u2502       \u2514\u2500\u2500 bool\n    \u2502           \u2514\u2500\u2500 must\n    \u2502               \u251c\u2500\u2500 term, field=roles.gender, value=\"F\"\n    \u2502               \u2514\u2500\u2500 term, field=roles.role, value=\"Reporter\"\n    \u251c\u2500\u2500 range, field=rank, gte=7\n    \u2514\u2500\u2500 terms, field=genres, values=['Action', 'Thriller']\n```\n\n**DSL syntax**\n```\nfrom pandagg.query import Nested, Bool, Query, Range, Term, Terms\n>>> q = Query(\n    Bool(must=[\n        TermsFilter('genres', terms=['Action', 'Thriller']),\n        Range('rank', gte=7),\n        Nested(\n            path='roles', \n            query=Bool(must=[\n                Term('roles.gender', value='F'),\n                Term('roles.role', value='Reporter')\n            ])\n        )\n    ])\n)\n\n# serialized query is computed by `query_dict` method\n>>> q.query_dict() == expected_query\nTrue\n```\n\n**Chained syntax**\n\n```\n>>> from pandagg.query import Query, Range, Term\n\n>>> q = Query()\\\n    .query({'terms': {'genres': ['Action', 'Thriller']}})\\\n    .nested(path='roles', _name='nested_roles', query=Term('roles.gender', value='F'))\\\n    .query(Range('rank', gte=7))\\\n    .query(Term('roles.role', value='Reporter'), parent='nested_roles')\n\n>>> q\n<Query>\nbool\n\u2514\u2500\u2500 must\n    \u251c\u2500\u2500 nested\n    \u2502   \u251c\u2500\u2500 path=\"roles\"\n    \u2502   \u2514\u2500\u2500 query\n    \u2502       \u2514\u2500\u2500 bool\n    \u2502           \u2514\u2500\u2500 must\n    \u2502               \u251c\u2500\u2500 term, field=roles.gender, value=\"F\"\n    \u2502               \u2514\u2500\u2500 term, field=roles.role, value=\"Reporter\"\n    \u251c\u2500\u2500 range, field=rank, gte=7\n    \u2514\u2500\u2500 terms, field=genres, values=['Action', 'Thriller']\n     \n```\nNotes:\n - both DSL and dict syntaxes are accepted in `Query` compound clauses methods (`query`, `nested`, `must` etc).\n - the last query uses the nested clause `_name` to detect where it should be inserted\n\n## Installation\n```\npip install pandagg\n```\n\n## Dependencies\n**Hard dependency**: [ligthtree](https://pypi.org/project/lighttree/): 0.0.2 or higher\n\n**Soft dependency**: to parse aggregation results as tabular dataframe: [pandas](https://github.com/pandas-dev/pandas/)\n\n## Motivations\n\n`pandagg` only focuses on read operations (queries and aggregations), a \nhigh level python client [elasticsearch-dsl](https://github.com/elastic/elasticsearch-dsl-py) already exists for ElasticSearch, \nbut despite many qualities, in some cases its api was not always convenient when dealing with deeply \nnested queries and aggregations.\n\nThe fundamental difference between those libraries is how they deal with the tree structure of aggregation queries\nand their responses.\n\nSuppose we have this aggregation structure: (types of agg don't matter). Let's call all of **A**, **B**, **C**, **D** our aggregation **nodes**, and the whole structure our **tree**.\n```\nA           (Terms agg)\n\u2514\u2500\u2500 B       (Filters agg)\n    \u251c\u2500\u2500 C   (Avg agg)\n    \u2514\u2500\u2500 D   (Sum agg)\n```\n\n\nQuestion is who has the charge of storing the **tree structure** (how **nodes** are connected)?\n\nIn ***elasticsearch-dsl*** library, each aggregation **node** is responsible of knowing which are its direct children.\n\nIn ***pandagg***, all **nodes** are agnostic about which are their parents/children, and a **tree** object is in charge\nof storing this structure. It is thus possible to add/update/remove aggregation **nodes** or **sub-trees** in\nspecific locations of the initial **tree**, thus allowing more flexible ways to build your queries.\n\n## Contributing\n\nAll contributions, bug reports, bug fixes, documentation improvements, enhancements and ideas are welcome.\n\n\n## Roadmap\n\n- implement CI workflow: python2/3 tests, coverage\n- nested fields: automatic handling and validation in `Query` instances\n- `Query.query`, `Agg.agg`, `Agg.groupby` methods: allow passing of `tree` instance, in addition to current `dict` and `node` syntaxes\n- documentation; explain challenges induced by nested `nodes` syntaxes: for instance why are nested query clauses\nsaved in `children` attribute before tree deserialization\n- extend test coverage on `named` queries serialization\n- evaluate interest and tradeoffs of using metaclasses like similarly to `elasticsearch-dsl` library to declare `node` classes\n- on aggregation `nodes`, ensure all allowed `fields` are listed\n- on aggregation response `tree`, use `Query` DSL to compute bucket filters\n- package versions for different ElasticSearch versions", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/alkemics/pandagg", "keywords": "elasticsearch aggregation pandas", "license": "", "maintainer": "", "maintainer_email": "", "name": "pandagg", "package_url": "https://pypi.org/project/pandagg/", "platform": "", "project_url": "https://pypi.org/project/pandagg/", "project_urls": {"Homepage": "https://github.com/alkemics/pandagg"}, "release_url": "https://pypi.org/project/pandagg/0.0.2/", "requires_dist": null, "requires_python": "", "summary": "Python package provided to make elasticsearch aggregations and queries easy.", "version": "0.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h2>What is it?</h2>\n<p><strong>pandagg</strong> is a Python package providing a simple interface to manipulate ElasticSearch queries and aggregations.</p>\n<p><em><strong>Disclaimer</strong></em> <em>:this is a pre-release version</em></p>\n<h2>Features</h2>\n<ul>\n<li>flexible aggregation and search queries declaration</li>\n<li>query validation based on provided mapping</li>\n<li>parsing of aggregation results in handy formats: tree with interactive navigation, csv-like tabular breakdown, and others</li>\n<li>mapping interactive navigation</li>\n</ul>\n<h2>Usage</h2>\n<h3>Documentation</h3>\n<p>Full documentation and user-guide are available <a href=\"https://pandagg.readthedocs.io/en/latest/\" rel=\"nofollow\">here on read-the-docs</a>.</p>\n<h3>Quick sneak peek</h3>\n<p><strong>Elasticsearch dict syntax</strong></p>\n<pre><code>&gt;&gt;&gt; from pandagg.query import Query\n\n&gt;&gt;&gt; expected_query = {'bool': {'must': [\n    {'terms': {'genres': ['Action', 'Thriller']}},\n    {'range': {'rank': {'gte': 7}}},\n    {'nested': {\n        'path': 'roles',\n        'query': {'bool': {'must': [\n            {'term': {'roles.gender': {'value': 'F'}}},\n            {'term': {'roles.role': {'value': 'Reporter'}}}]}\n         }\n    }}\n]}}\n&gt;&gt;&gt; q = Query(expected_query)\n&gt;&gt;&gt; q\n&lt;Query&gt;\nbool\n\u2514\u2500\u2500 must\n    \u251c\u2500\u2500 nested\n    \u2502   \u251c\u2500\u2500 path=\"roles\"\n    \u2502   \u2514\u2500\u2500 query\n    \u2502       \u2514\u2500\u2500 bool\n    \u2502           \u2514\u2500\u2500 must\n    \u2502               \u251c\u2500\u2500 term, field=roles.gender, value=\"F\"\n    \u2502               \u2514\u2500\u2500 term, field=roles.role, value=\"Reporter\"\n    \u251c\u2500\u2500 range, field=rank, gte=7\n    \u2514\u2500\u2500 terms, field=genres, values=['Action', 'Thriller']\n</code></pre>\n<p><strong>DSL syntax</strong></p>\n<pre><code>from pandagg.query import Nested, Bool, Query, Range, Term, Terms\n&gt;&gt;&gt; q = Query(\n    Bool(must=[\n        TermsFilter('genres', terms=['Action', 'Thriller']),\n        Range('rank', gte=7),\n        Nested(\n            path='roles', \n            query=Bool(must=[\n                Term('roles.gender', value='F'),\n                Term('roles.role', value='Reporter')\n            ])\n        )\n    ])\n)\n\n# serialized query is computed by `query_dict` method\n&gt;&gt;&gt; q.query_dict() == expected_query\nTrue\n</code></pre>\n<p><strong>Chained syntax</strong></p>\n<pre><code>&gt;&gt;&gt; from pandagg.query import Query, Range, Term\n\n&gt;&gt;&gt; q = Query()\\\n    .query({'terms': {'genres': ['Action', 'Thriller']}})\\\n    .nested(path='roles', _name='nested_roles', query=Term('roles.gender', value='F'))\\\n    .query(Range('rank', gte=7))\\\n    .query(Term('roles.role', value='Reporter'), parent='nested_roles')\n\n&gt;&gt;&gt; q\n&lt;Query&gt;\nbool\n\u2514\u2500\u2500 must\n    \u251c\u2500\u2500 nested\n    \u2502   \u251c\u2500\u2500 path=\"roles\"\n    \u2502   \u2514\u2500\u2500 query\n    \u2502       \u2514\u2500\u2500 bool\n    \u2502           \u2514\u2500\u2500 must\n    \u2502               \u251c\u2500\u2500 term, field=roles.gender, value=\"F\"\n    \u2502               \u2514\u2500\u2500 term, field=roles.role, value=\"Reporter\"\n    \u251c\u2500\u2500 range, field=rank, gte=7\n    \u2514\u2500\u2500 terms, field=genres, values=['Action', 'Thriller']\n     \n</code></pre>\n<p>Notes:</p>\n<ul>\n<li>both DSL and dict syntaxes are accepted in <code>Query</code> compound clauses methods (<code>query</code>, <code>nested</code>, <code>must</code> etc).</li>\n<li>the last query uses the nested clause <code>_name</code> to detect where it should be inserted</li>\n</ul>\n<h2>Installation</h2>\n<pre><code>pip install pandagg\n</code></pre>\n<h2>Dependencies</h2>\n<p><strong>Hard dependency</strong>: <a href=\"https://pypi.org/project/lighttree/\" rel=\"nofollow\">ligthtree</a>: 0.0.2 or higher</p>\n<p><strong>Soft dependency</strong>: to parse aggregation results as tabular dataframe: <a href=\"https://github.com/pandas-dev/pandas/\" rel=\"nofollow\">pandas</a></p>\n<h2>Motivations</h2>\n<p><code>pandagg</code> only focuses on read operations (queries and aggregations), a\nhigh level python client <a href=\"https://github.com/elastic/elasticsearch-dsl-py\" rel=\"nofollow\">elasticsearch-dsl</a> already exists for ElasticSearch,\nbut despite many qualities, in some cases its api was not always convenient when dealing with deeply\nnested queries and aggregations.</p>\n<p>The fundamental difference between those libraries is how they deal with the tree structure of aggregation queries\nand their responses.</p>\n<p>Suppose we have this aggregation structure: (types of agg don't matter). Let's call all of <strong>A</strong>, <strong>B</strong>, <strong>C</strong>, <strong>D</strong> our aggregation <strong>nodes</strong>, and the whole structure our <strong>tree</strong>.</p>\n<pre><code>A           (Terms agg)\n\u2514\u2500\u2500 B       (Filters agg)\n    \u251c\u2500\u2500 C   (Avg agg)\n    \u2514\u2500\u2500 D   (Sum agg)\n</code></pre>\n<p>Question is who has the charge of storing the <strong>tree structure</strong> (how <strong>nodes</strong> are connected)?</p>\n<p>In <em><strong>elasticsearch-dsl</strong></em> library, each aggregation <strong>node</strong> is responsible of knowing which are its direct children.</p>\n<p>In <em><strong>pandagg</strong></em>, all <strong>nodes</strong> are agnostic about which are their parents/children, and a <strong>tree</strong> object is in charge\nof storing this structure. It is thus possible to add/update/remove aggregation <strong>nodes</strong> or <strong>sub-trees</strong> in\nspecific locations of the initial <strong>tree</strong>, thus allowing more flexible ways to build your queries.</p>\n<h2>Contributing</h2>\n<p>All contributions, bug reports, bug fixes, documentation improvements, enhancements and ideas are welcome.</p>\n<h2>Roadmap</h2>\n<ul>\n<li>implement CI workflow: python2/3 tests, coverage</li>\n<li>nested fields: automatic handling and validation in <code>Query</code> instances</li>\n<li><code>Query.query</code>, <code>Agg.agg</code>, <code>Agg.groupby</code> methods: allow passing of <code>tree</code> instance, in addition to current <code>dict</code> and <code>node</code> syntaxes</li>\n<li>documentation; explain challenges induced by nested <code>nodes</code> syntaxes: for instance why are nested query clauses\nsaved in <code>children</code> attribute before tree deserialization</li>\n<li>extend test coverage on <code>named</code> queries serialization</li>\n<li>evaluate interest and tradeoffs of using metaclasses like similarly to <code>elasticsearch-dsl</code> library to declare <code>node</code> classes</li>\n<li>on aggregation <code>nodes</code>, ensure all allowed <code>fields</code> are listed</li>\n<li>on aggregation response <code>tree</code>, use <code>Query</code> DSL to compute bucket filters</li>\n<li>package versions for different ElasticSearch versions</li>\n</ul>\n\n          </div>"}, "last_serial": 7012861, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "37899bc6b23755697b4cca53c8bc2693", "sha256": "256a0436568af02cc1a6ed444bc9346c2e3a5b4c7977e55b4558bc22a95604b6"}, "downloads": -1, "filename": "pandagg-0.0.1-py2-none-any.whl", "has_sig": false, "md5_digest": "37899bc6b23755697b4cca53c8bc2693", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 139890, "upload_time": "2020-03-02T17:13:55", "upload_time_iso_8601": "2020-03-02T17:13:55.382413Z", "url": "https://files.pythonhosted.org/packages/13/11/aa2bb303cc8ecc6f7f22e48444135130258c2899156456cd297b27f34522/pandagg-0.0.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "adb4aa04ad12a7e01681cb502d599c45", "sha256": "1c4c2d761842238be6f48c2216989d5b49bbb4a9ec442f351fd13d0290992d0f"}, "downloads": -1, "filename": "pandagg-0.0.1.tar.gz", "has_sig": false, "md5_digest": "adb4aa04ad12a7e01681cb502d599c45", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 68247, "upload_time": "2020-03-02T17:13:58", "upload_time_iso_8601": "2020-03-02T17:13:58.014451Z", "url": "https://files.pythonhosted.org/packages/ad/b3/627e2a6863c946e7ca2410f82e58489b9ac82aad083f939896b73fe52b24/pandagg-0.0.1.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "5b5fbd5e7dd91bd1f0be3121f3891b1c", "sha256": "194c42da177f1d001385bc43766cc3d431ef9315fef2594342f8e6c8e0ace6df"}, "downloads": -1, "filename": "pandagg-0.0.2.tar.gz", "has_sig": false, "md5_digest": "5b5fbd5e7dd91bd1f0be3121f3891b1c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 66640, "upload_time": "2020-04-13T21:17:27", "upload_time_iso_8601": "2020-04-13T21:17:27.002294Z", "url": "https://files.pythonhosted.org/packages/65/72/dac1e4b893b6f9d34fba047e244572827246b76f8adc0ae61a460baa3ebd/pandagg-0.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "5b5fbd5e7dd91bd1f0be3121f3891b1c", "sha256": "194c42da177f1d001385bc43766cc3d431ef9315fef2594342f8e6c8e0ace6df"}, "downloads": -1, "filename": "pandagg-0.0.2.tar.gz", "has_sig": false, "md5_digest": "5b5fbd5e7dd91bd1f0be3121f3891b1c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 66640, "upload_time": "2020-04-13T21:17:27", "upload_time_iso_8601": "2020-04-13T21:17:27.002294Z", "url": "https://files.pythonhosted.org/packages/65/72/dac1e4b893b6f9d34fba047e244572827246b76f8adc0ae61a460baa3ebd/pandagg-0.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:59:38 2020"}