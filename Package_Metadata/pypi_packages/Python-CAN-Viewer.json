{"info": {"author": "Kristian Sloth Lauszus", "author_email": "lauszus@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: GNU General Public License v2 (GPLv2)", "Operating System :: OS Independent", "Programming Language :: Python :: 2", "Programming Language :: Python :: 3"], "description": "# Python CAN Viewer\n\n#### Developed by Kristian Lauszus, 2018\n\nThe code is released under the GNU General Public License.\n_________\n[![PyPI](https://img.shields.io/pypi/v/python_can_viewer.svg)](https://pypi.org/project/Python-CAN-Viewer)\n[![Build Status](https://travis-ci.com/Lauszus/python_can_viewer.svg?branch=master)](https://travis-ci.com/Lauszus/python_can_viewer)\n[![Build status](https://ci.appveyor.com/api/projects/status/r4xl2v4aeh350fpd/branch/master?svg=true)](https://ci.appveyor.com/project/Lauszus/python-can-viewer/branch/master)\n[![codecov](https://codecov.io/gh/Lauszus/python_can_viewer/branch/master/graph/badge.svg)](https://codecov.io/gh/Lauszus/python_can_viewer)\n\nA simple CAN viewer terminal application written in Python. Python 2, Python 3, pypy and pypy3 are supported.\n\n## Usage\n\nThe program can be installed via pip:\n\n```bash\npip install python_can_viewer\n```\n\nTo run the script simply execute:\n\n```bash\npython -m python_can_viewer\n```\n\nA screenshot of the application can be seen below:\n\n<img src=\"https://github.com/Lauszus/python_can_viewer/raw/master/screenshot.png\" width=400/>\n\nThe first column is the number of times a frame with the particular ID has been received, next is the timestamp of the frame relative to the first received message. The third column is the time between the current frame relative to the previous one. Next is the length of the frame and then the data.\n\nThe last two columns are the decoded CANopen function code and node ID. If CANopen is not used, then they can simply be ignored.\n\n### Command line arguments\n\nBy default it will be using the ```socketcan``` interface. All interfaces supported by [python-can](https://github.com/hardbyte/python-can) are supported and can be specified using the ```-i``` argument.\n\nThe full usage page can be seen below:\n\n```\nUsage: python -m python_can_viewer [-h] [--version] [-b BITRATE] [-c CHANNEL]\n                                   [-d {<id>:<format>,<id>:<format>:<scaling1>:...:<scalingN>,file.txt}]\n                                   [-f {<can_id>:<can_mask>,<can_id>~<can_mask>}]\n                                   [-i {iscan,ixxat,kvaser,neovi,nican,pcan,serial,slcan,socketcan,socketcan_ctypes,socketcan_native,usb2can,vector,virtual}]\n                                   [--ignore-canopen]\n\nA simple CAN viewer terminal application written in Python\n\nOptional arguments:\n  -h, --help            Show this help message and exit\n  --version             Show program's version number and exit\n  -b, --bitrate BITRATE\n                        Bitrate to use for the given CAN interface\n  -c, --channel CHANNEL\n                        Most backend interfaces require some sort of channel.\n                        for example with the serial interface the channel\n                        might be a rfcomm device: \"/dev/rfcomm0\" with the\n                        socketcan interfaces valid channel examples include:\n                        \"can0\", \"vcan0\". (default: use default for the\n                        specified interface)\n  -d, --decode {<id>:<format>,<id>:<format>:<scaling1>:...:<scalingN>,file.txt}\n                        Specify how to convert the raw bytes into real values.\n                        The ID of the frame is given as the first argument and the format as the second.\n                        The Python struct package is used to unpack the received data\n                        where the format characters have the following meaning:\n                              < = little-endian, > = big-endian\n                              x = pad byte\n                              c = char\n                              ? = bool\n                              b = int8_t, B = uint8_t\n                              h = int16, H = uint16\n                              l = int32_t, L = uint32_t\n                              q = int64_t, Q = uint64_t\n                              f = float (32-bits), d = double (64-bits)\n                        Fx to convert six bytes with ID 0x100 into uint8_t, uint16 and uint32_t:\n                          $ python -m python_can_viewer -d \"100:<BHL\"\n                        Note that the IDs are always interpreted as hex values.\n                        An optional conversion from integers to real units can be given\n                        as additional arguments. In order to convert from raw integer\n                        values the values are multiplied with the corresponding scaling value,\n                        similarly the values are divided by the scaling value in order\n                        to convert from real units to raw integer values.\n                        Fx lets say the uint8_t needs no conversion, but the uint16 and the uint32_t\n                        needs to be divided by 10 and 100 respectively:\n                          $ python -m python_can_viewer -d \"101:<BHL:1:10.0:100.0\"\n                        Be aware that integer division is performed if the scaling value is an integer.\n                        Multiple arguments are separated by spaces:\n                          $ python -m python_can_viewer -d \"100:<BHL\" \"101:<BHL:1:10.0:100.0\"\n                        Alternatively a file containing the conversion strings separated by new lines\n                        can be given as input:\n                          $ cat file.txt\n                              100:<BHL\n                              101:<BHL:1:10.0:100.0\n                          $ python -m python_can_viewer -d file.txt\n  -f, --filter {<can_id>:<can_mask>,<can_id>~<can_mask>}\n                        Comma separated CAN filters for the given CAN interface:\n                              <can_id>:<can_mask> (matches when <received_can_id> & mask == can_id & mask)\n                              <can_id>~<can_mask> (matches when <received_can_id> & mask != can_id & mask)\n                        Fx to show only frames with ID 0x100 to 0x103:\n                              python -m python_can_viewer -f 100:7FC\n                        Note that the ID and mask are alway interpreted as hex values\n  -i, --interface {iscan,ixxat,kvaser,neovi,nican,pcan,serial,slcan,socketcan,socketcan_ctypes,socketcan_native,usb2can,vector,virtual}\n                        Specify the backend CAN interface to use. (default: \"socketcan\")\n  --ignore-canopen      Do not print CANopen information\n```\n\n### Shortcuts\n\n| Key      | Description             |\n|:--------:|:-----------------------:|\n| ESC/q    | Exit the viewer         |\n| c        | Clear the stored frames |\n| SPACE    | Pause the viewer        |\n| UP/DOWN  | Scroll the viewer       |\n\n### Misc\n\nI would recommend the following board for testing on a Raspberry Pi: <http://skpang.co.uk/catalog/pican2-canbus-board-for-raspberry-pi-23-p-1475.html>.\n\nThe CAN interface can be setup like so:\n\n```bash\nsudo apt-get -y install can-utils\nsudo raspi-config nonint do_spi 0\nsudo sh -c 'echo \"dtoverlay=mcp2515-can0,oscillator=16000000,interrupt=25\" >> /boot/config.txt'\nsudo sh -c 'echo \"dtoverlay=spi0-hw-cs\" >> /boot/config.txt'\n```\n\nFor more information send me an email at <lauszus@gmail.com>.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/Lauszus/python_can_viewer", "keywords": "", "license": "GPLv2", "maintainer": "", "maintainer_email": "", "name": "Python-CAN-Viewer", "package_url": "https://pypi.org/project/Python-CAN-Viewer/", "platform": "", "project_url": "https://pypi.org/project/Python-CAN-Viewer/", "project_urls": {"Homepage": "https://github.com/Lauszus/python_can_viewer"}, "release_url": "https://pypi.org/project/Python-CAN-Viewer/0.2.0/", "requires_dist": ["python-can (>=2.0.0)", "six", "typing", "windows-curses; platform_system == \"Windows\"", "future; extra == 'test'", "mock; extra == 'test'", "pytest; extra == 'test'", "pytest-runner; extra == 'test'", "coverage; extra == 'test'", "codecov; extra == 'test'"], "requires_python": ">=2.7", "summary": "A simple CAN viewer terminal application written in Python", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Python CAN Viewer</h1>\n<h4>Developed by Kristian Lauszus, 2018</h4>\n<p>The code is released under the GNU General Public License.</p>\n<hr>\n<p><a href=\"https://pypi.org/project/Python-CAN-Viewer\" rel=\"nofollow\"><img alt=\"PyPI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7802117e608e04af805e0394bc15428c883a31a7/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f707974686f6e5f63616e5f7669657765722e737667\"></a>\n<a href=\"https://travis-ci.com/Lauszus/python_can_viewer\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c04ae22b1cbe2e72bf0cf9fd4bce26a4f9dfe943/68747470733a2f2f7472617669732d63692e636f6d2f4c6175737a75732f707974686f6e5f63616e5f7669657765722e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://ci.appveyor.com/project/Lauszus/python-can-viewer/branch/master\" rel=\"nofollow\"><img alt=\"Build status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/4920d28d498d8f42faaad18d4888d3fcf461738d/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f7234786c3276346165683335306670642f6272616e63682f6d61737465723f7376673d74727565\"></a>\n<a href=\"https://codecov.io/gh/Lauszus/python_can_viewer\" rel=\"nofollow\"><img alt=\"codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8d4368e5d5e0be0937e142b4e9d439cb62ca956a/68747470733a2f2f636f6465636f762e696f2f67682f4c6175737a75732f707974686f6e5f63616e5f7669657765722f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a></p>\n<p>A simple CAN viewer terminal application written in Python. Python 2, Python 3, pypy and pypy3 are supported.</p>\n<h2>Usage</h2>\n<p>The program can be installed via pip:</p>\n<pre>pip install python_can_viewer\n</pre>\n<p>To run the script simply execute:</p>\n<pre>python -m python_can_viewer\n</pre>\n<p>A screenshot of the application can be seen below:</p>\n<img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/6a2338a6f5f79e4ce289317a46ec4e2434143fae/68747470733a2f2f6769746875622e636f6d2f4c6175737a75732f707974686f6e5f63616e5f7669657765722f7261772f6d61737465722f73637265656e73686f742e706e67\" width=\"400/\">\n<p>The first column is the number of times a frame with the particular ID has been received, next is the timestamp of the frame relative to the first received message. The third column is the time between the current frame relative to the previous one. Next is the length of the frame and then the data.</p>\n<p>The last two columns are the decoded CANopen function code and node ID. If CANopen is not used, then they can simply be ignored.</p>\n<h3>Command line arguments</h3>\n<p>By default it will be using the <code>socketcan</code> interface. All interfaces supported by <a href=\"https://github.com/hardbyte/python-can\" rel=\"nofollow\">python-can</a> are supported and can be specified using the <code>-i</code> argument.</p>\n<p>The full usage page can be seen below:</p>\n<pre><code>Usage: python -m python_can_viewer [-h] [--version] [-b BITRATE] [-c CHANNEL]\n                                   [-d {&lt;id&gt;:&lt;format&gt;,&lt;id&gt;:&lt;format&gt;:&lt;scaling1&gt;:...:&lt;scalingN&gt;,file.txt}]\n                                   [-f {&lt;can_id&gt;:&lt;can_mask&gt;,&lt;can_id&gt;~&lt;can_mask&gt;}]\n                                   [-i {iscan,ixxat,kvaser,neovi,nican,pcan,serial,slcan,socketcan,socketcan_ctypes,socketcan_native,usb2can,vector,virtual}]\n                                   [--ignore-canopen]\n\nA simple CAN viewer terminal application written in Python\n\nOptional arguments:\n  -h, --help            Show this help message and exit\n  --version             Show program's version number and exit\n  -b, --bitrate BITRATE\n                        Bitrate to use for the given CAN interface\n  -c, --channel CHANNEL\n                        Most backend interfaces require some sort of channel.\n                        for example with the serial interface the channel\n                        might be a rfcomm device: \"/dev/rfcomm0\" with the\n                        socketcan interfaces valid channel examples include:\n                        \"can0\", \"vcan0\". (default: use default for the\n                        specified interface)\n  -d, --decode {&lt;id&gt;:&lt;format&gt;,&lt;id&gt;:&lt;format&gt;:&lt;scaling1&gt;:...:&lt;scalingN&gt;,file.txt}\n                        Specify how to convert the raw bytes into real values.\n                        The ID of the frame is given as the first argument and the format as the second.\n                        The Python struct package is used to unpack the received data\n                        where the format characters have the following meaning:\n                              &lt; = little-endian, &gt; = big-endian\n                              x = pad byte\n                              c = char\n                              ? = bool\n                              b = int8_t, B = uint8_t\n                              h = int16, H = uint16\n                              l = int32_t, L = uint32_t\n                              q = int64_t, Q = uint64_t\n                              f = float (32-bits), d = double (64-bits)\n                        Fx to convert six bytes with ID 0x100 into uint8_t, uint16 and uint32_t:\n                          $ python -m python_can_viewer -d \"100:&lt;BHL\"\n                        Note that the IDs are always interpreted as hex values.\n                        An optional conversion from integers to real units can be given\n                        as additional arguments. In order to convert from raw integer\n                        values the values are multiplied with the corresponding scaling value,\n                        similarly the values are divided by the scaling value in order\n                        to convert from real units to raw integer values.\n                        Fx lets say the uint8_t needs no conversion, but the uint16 and the uint32_t\n                        needs to be divided by 10 and 100 respectively:\n                          $ python -m python_can_viewer -d \"101:&lt;BHL:1:10.0:100.0\"\n                        Be aware that integer division is performed if the scaling value is an integer.\n                        Multiple arguments are separated by spaces:\n                          $ python -m python_can_viewer -d \"100:&lt;BHL\" \"101:&lt;BHL:1:10.0:100.0\"\n                        Alternatively a file containing the conversion strings separated by new lines\n                        can be given as input:\n                          $ cat file.txt\n                              100:&lt;BHL\n                              101:&lt;BHL:1:10.0:100.0\n                          $ python -m python_can_viewer -d file.txt\n  -f, --filter {&lt;can_id&gt;:&lt;can_mask&gt;,&lt;can_id&gt;~&lt;can_mask&gt;}\n                        Comma separated CAN filters for the given CAN interface:\n                              &lt;can_id&gt;:&lt;can_mask&gt; (matches when &lt;received_can_id&gt; &amp; mask == can_id &amp; mask)\n                              &lt;can_id&gt;~&lt;can_mask&gt; (matches when &lt;received_can_id&gt; &amp; mask != can_id &amp; mask)\n                        Fx to show only frames with ID 0x100 to 0x103:\n                              python -m python_can_viewer -f 100:7FC\n                        Note that the ID and mask are alway interpreted as hex values\n  -i, --interface {iscan,ixxat,kvaser,neovi,nican,pcan,serial,slcan,socketcan,socketcan_ctypes,socketcan_native,usb2can,vector,virtual}\n                        Specify the backend CAN interface to use. (default: \"socketcan\")\n  --ignore-canopen      Do not print CANopen information\n</code></pre>\n<h3>Shortcuts</h3>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Key</th>\n<th align=\"center\">Description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">ESC/q</td>\n<td align=\"center\">Exit the viewer</td>\n</tr>\n<tr>\n<td align=\"center\">c</td>\n<td align=\"center\">Clear the stored frames</td>\n</tr>\n<tr>\n<td align=\"center\">SPACE</td>\n<td align=\"center\">Pause the viewer</td>\n</tr>\n<tr>\n<td align=\"center\">UP/DOWN</td>\n<td align=\"center\">Scroll the viewer</td>\n</tr></tbody></table>\n<h3>Misc</h3>\n<p>I would recommend the following board for testing on a Raspberry Pi: <a href=\"http://skpang.co.uk/catalog/pican2-canbus-board-for-raspberry-pi-23-p-1475.html\" rel=\"nofollow\">http://skpang.co.uk/catalog/pican2-canbus-board-for-raspberry-pi-23-p-1475.html</a>.</p>\n<p>The CAN interface can be setup like so:</p>\n<pre>sudo apt-get -y install can-utils\nsudo raspi-config nonint do_spi <span class=\"m\">0</span>\nsudo sh -c <span class=\"s1\">'echo \"dtoverlay=mcp2515-can0,oscillator=16000000,interrupt=25\" &gt;&gt; /boot/config.txt'</span>\nsudo sh -c <span class=\"s1\">'echo \"dtoverlay=spi0-hw-cs\" &gt;&gt; /boot/config.txt'</span>\n</pre>\n<p>For more information send me an email at <a href=\"mailto:lauszus@gmail.com\">lauszus@gmail.com</a>.</p>\n\n          </div>"}, "last_serial": 4160304, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "05ccd00bc560520118fd34f966abe590", "sha256": "2525f270c2cfe9f092810814d059bf65dec14bfacb318b7949b2ce3a36476791"}, "downloads": -1, "filename": "Python_CAN_Viewer-0.1.0-py3-none-any.whl", "has_sig": false, "md5_digest": "05ccd00bc560520118fd34f966abe590", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=2.7", "size": 14956, "upload_time": "2018-07-17T15:35:05", "upload_time_iso_8601": "2018-07-17T15:35:05.134913Z", "url": "https://files.pythonhosted.org/packages/5a/7e/905d5d4bb1a3978b0d5a5516cfef70dfc8df66b8cd29c57509afe0788091/Python_CAN_Viewer-0.1.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "484d58bb2a863648c9db29999ae9b8f7", "sha256": "16eacfbb85f05a9f34ed6f7a444654647cf2f2542eea3ed11177ad706c177aa2"}, "downloads": -1, "filename": "Python CAN Viewer-0.1.0.tar.gz", "has_sig": false, "md5_digest": "484d58bb2a863648c9db29999ae9b8f7", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7", "size": 19216, "upload_time": "2018-07-17T15:35:06", "upload_time_iso_8601": "2018-07-17T15:35:06.603135Z", "url": "https://files.pythonhosted.org/packages/97/60/51618e8160d0b75f66663d8e3946a3507d2a2b4997c288fe4fa8ee443950/Python%20CAN%20Viewer-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "28efe6546e4d9e313f3170aa6d796ab6", "sha256": "6dadee2cc045be13c49de95e165568e8483da6f95434fdbc64c5b86847ffae48"}, "downloads": -1, "filename": "Python_CAN_Viewer-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "28efe6546e4d9e313f3170aa6d796ab6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=2.7", "size": 12216, "upload_time": "2018-08-11T20:24:52", "upload_time_iso_8601": "2018-08-11T20:24:52.239592Z", "url": "https://files.pythonhosted.org/packages/39/c3/ce11ca45d6713a9658a262905bfddc98fa8e914db7a6418cc7c03159206e/Python_CAN_Viewer-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d669c137286a0e05d23c01e1ed2e2a38", "sha256": "7b198c22475c4d116f1882bd8c7391e43061dcbc98b30c2baab9bbfabaa98e6b"}, "downloads": -1, "filename": "Python CAN Viewer-0.2.0.tar.gz", "has_sig": false, "md5_digest": "d669c137286a0e05d23c01e1ed2e2a38", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7", "size": 17787, "upload_time": "2018-08-11T20:24:53", "upload_time_iso_8601": "2018-08-11T20:24:53.542353Z", "url": "https://files.pythonhosted.org/packages/e5/64/45adc0db555bc15ffc72c83ca5a3575661742064f6f9875e5174138407cf/Python%20CAN%20Viewer-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "28efe6546e4d9e313f3170aa6d796ab6", "sha256": "6dadee2cc045be13c49de95e165568e8483da6f95434fdbc64c5b86847ffae48"}, "downloads": -1, "filename": "Python_CAN_Viewer-0.2.0-py3-none-any.whl", "has_sig": false, "md5_digest": "28efe6546e4d9e313f3170aa6d796ab6", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=2.7", "size": 12216, "upload_time": "2018-08-11T20:24:52", "upload_time_iso_8601": "2018-08-11T20:24:52.239592Z", "url": "https://files.pythonhosted.org/packages/39/c3/ce11ca45d6713a9658a262905bfddc98fa8e914db7a6418cc7c03159206e/Python_CAN_Viewer-0.2.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d669c137286a0e05d23c01e1ed2e2a38", "sha256": "7b198c22475c4d116f1882bd8c7391e43061dcbc98b30c2baab9bbfabaa98e6b"}, "downloads": -1, "filename": "Python CAN Viewer-0.2.0.tar.gz", "has_sig": false, "md5_digest": "d669c137286a0e05d23c01e1ed2e2a38", "packagetype": "sdist", "python_version": "source", "requires_python": ">=2.7", "size": 17787, "upload_time": "2018-08-11T20:24:53", "upload_time_iso_8601": "2018-08-11T20:24:53.542353Z", "url": "https://files.pythonhosted.org/packages/e5/64/45adc0db555bc15ffc72c83ca5a3575661742064f6f9875e5174138407cf/Python%20CAN%20Viewer-0.2.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:18:32 2020"}