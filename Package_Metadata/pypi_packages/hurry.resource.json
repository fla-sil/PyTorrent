{"info": {"author": "Martijn Faassen", "author_email": "faassen@startifact.com", "bugtrack_url": null, "classifiers": [], "description": "hurry.resource\n**************\n\n.. Important::\n   hurry.resource has been superseded by the\n   `Fanstatic <http://fanstatic.org>`_ project!\n\nIntroduction\n============\n\nResources are files that are used as resources in the display of a web\npage, such as CSS files, Javascript files and images. Resources\npackaged together in a directory to be published as such are called a\nresource *library*.\n\nWhen a resource is included in the ``head`` section of a HTML page, we\ncall this a resource *inclusion*. An inclusion is of a particular\nresource in a particular library. There are two forms of this kind of\ninclusion in HTML: javascript is included using the ``script`` tag,\nand CSS (and KSS) are included using a ``link`` tag.\n\nInclusions may depend on other inclusions. A javascript resource may\nfor instance be built on top of another javascript resource. This\nmeans both of them should be loaded when the page displays.\n\nPage components may actually require a certain inclusion in order to\nbe functional. A widget may for instance expect a particular\nJavascript library to loaded. We call this an *inclusion requirement*\nof the component.\n\n``hurry.resource`` provides a simple API to specify resource\nlibraries, inclusion and inclusion requirements.\n\nA resource library\n==================\n\nWe define a library ``foo``. It takes two arguments, the name of the\nlibrary as it should be published under in a URL and uniquely identify\nit, and a path to the root of the resources (rootpath) that this\nlibrary publishes::\n\n  >>> from hurry.resource import Library\n  >>> foo = Library('foo', 'dummy')\n\nThe full path to the directory with the resources is reconstructed from\nthe package that the Library is defined in::\n\n  >>> foo.path #doctest: +ELLIPSIS\n  '.../hurry.resource/src/hurry/resource/dummy'\n\nEntry points\n============\n\nLibraries can be exposed for registration by whatever web framework\nthat hurry.resource is integrated with. This web framework can then\nexpose the library path on a URL somewhere. This is done using the\n``hurry.resource.libraries`` entry point. To register ``Library``\ninstances ``foo`` and ``bar`` in your package as entry points include\na section like this in your ``setup.py``::\n\n      entry_points={\n        'hurry.resource.libraries': [\n            'foo = mypackage.foomodule:foo',\n            'bar = mypackage.barmodule:bar',\n            ],\n        }\n\nThere is an API to help you obtain all registered libraries::\n\n  >>> from hurry.resource import libraries\n\nNothing is registered however::\n\n  >>> list(libraries())\n  []\n\nIt would be nice to now have some tests that see whether entry points\nactually get picked up so, but that would require an involved test\nsetup that we find difficult to construct.\n\nInclusion\n=========\n\nWe now create an inclusion of a particular resource in a library. This\ninclusion needs ``a.js`` from ``library`` and ``b.js`` as well::\n\n  >>> from hurry.resource import ResourceInclusion\n  >>> x1 = ResourceInclusion(foo, 'a.js')\n  >>> x2 = ResourceInclusion(foo, 'b.css')\n\nLet's now make an inclusion ``y1`` that depends on ``x1`` and ``x2``::\n\n  >>> y1 = ResourceInclusion(foo, 'c.js', depends=[x1, x2])\n\nInclusion requirements\n======================\n\nWhen rendering a web page we want to require the inclusion of a\nresource anywhere within the request handling process. We might for\ninstance have a widget that takes care of rendering its own HTML but\nalso needs a resource to be included in the page header.\n\nWe have a special object that represents the needed inclusions during\na certain request cycle::\n\n  >>> from hurry.resource import NeededInclusions\n  >>> needed = NeededInclusions()\n\nWe state that a resource is needed by calling the ``need`` method on\nthis object::\n\n  >>> needed.need(y1)\n\nLet's now see what resources are needed by this inclusion::\n\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'b.css' in library 'foo'>,\n   <ResourceInclusion 'a.js' in library 'foo'>,\n   <ResourceInclusion 'c.js' in library 'foo'>]\n\nAs you can see, ``css`` resources are sorted before ``js`` resources.\n\nGrouping resources\n==================\n\nIt is also possible to define a group that doesn't get rendered\nitself, but groups other resources together that should be rendered::\n\n  >>> from hurry.resource import GroupInclusion\n  >>> group = GroupInclusion([x1, x2])\n\nWhen we need a group, we'll get all inclusions referenced in it::\n\n  >>> needed = NeededInclusions()\n  >>> needed.need(group)\n  >>> group.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'a.js' in library 'foo'>,\n   <ResourceInclusion 'b.css' in library 'foo'>]\n\nA group can also be depended on; it won't show up in the list of\ninclusions directly::\n\n  >>> more_stuff = ResourceInclusion(foo, 'more_stuff.js', depends=[group])\n  >>> more_stuff.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'a.js' in library 'foo'>,\n   <ResourceInclusion 'b.css' in library 'foo'>,\n   <ResourceInclusion 'more_stuff.js' in library 'foo'>]\n\nA convenience spelling\n======================\n\nWhen specifying that we want a resource inclusion to be rendered, we\nnow need access to the current ``NeededInclusions`` object and the\nresource inclusion itself.\n\nLet's introduce a more convenient spelling of needs now::\n\n  y1.need()\n\nWe can require a resource without reference to the needed inclusions\nobject directly as there is typically only a single set of needed\ninclusions that is generated during the rendering of a page.\n\nSo let's try out this spelling to see it fail::\n\n  >>> y1.need()\n  Traceback (most recent call last):\n    ...\n  NotImplementedError: need to implement plugin.get_current_needed_inclusions()\n\nWe get an error because we haven't configured the framework yet. The\nsystem says we need to implement\n``plugin.get_current_needed_inclusions()`` first. This is a method\nthat we need to implement so we can tell the system how to obtain the\ncurrent ``NeededInclusions`` object.\n\nThis needed inclusions should be maintained on an object that is going\nto be present throughout the request/response cycle that generates the\nweb page that has the inclusions on them. One place where\nwe can maintain the needed inclusions is the request object\nitself, if we indeed have global access to it. Alternatively you could\nstore the currently needed inclusions in a thread local variable.\n\nLet's introduce a simple request object (your mileage may vary in your\nown web framework)::\n\n  >>> class Request(object):\n  ...    def __init__(self):\n  ...        self.needed = NeededInclusions()\n\nWe now make a request, imitating what happens during a typical\nrequest/response cycle in a web framework::\n\n  >>> request = Request()\n\nWe now define a plugin class that implements the\n``get_current_needed_inclusions()`` method by obtaining it from the\nrequest::\n\n  >>> class Plugin(object):\n  ...   def get_current_needed_inclusions(self):\n  ...       return request.needed\n\nWe now need to register this plugin with the framework::\n\n  >>> from hurry.resource import register_plugin\n  >>> register_plugin(Plugin())\n\nThere is an API to retrieve the current needed inclusions, so let's\ncheck which resources our request needs currently::\n\n  >>> from hurry.resource import get_current_needed_inclusions\n  >>> get_current_needed_inclusions().inclusions()\n  []\n\nNothing yet. We now make ``y1`` needed using our simplified spelling::\n\n  >>> y1.need()\n\nThe resource inclusion will now indeed be needed::\n\n  >>> get_current_needed_inclusions().inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'b.css' in library 'foo'>,\n   <ResourceInclusion 'a.js' in library 'foo'>,\n   <ResourceInclusion 'c.js' in library 'foo'>]\n\nLet's go back to the original spelling of ``needed.need(y)``\nnow. While this is a bit more cumbersome to use in application code, it is\neasier to read for the purposes of this document.\n\nA note on optimization\n======================\n\nThere are various optimizations for resource inclusion that\n``hurry.resource`` supports. Because some optimizations can make\ndebugging more difficult, the optimizations are disabled by default.\n\nWe will summarize the optimization features here and tell you how to\nenable them. Later sections below go into more details.\n\n* minified resources. Resources can specify minified versions using\n  the mode system. You can use ``hurry.resource.mode('minified')``\n  somewhere in the request handling of your application. This will\n  make sure that resources included on your page are supplied as\n  minified versions, if these are available.\n\n* rolling up of resources.  Resource libraries can specify rollup\n  resources that combine multiple resources into one. This reduces the\n  amount of server requests to be made by the web browser, and can\n  help with caching. To enable rolling up, call\n  ``hurry.resource.rollup`` somewhere in your request handling.\n\n* javascript inclusions at the bottom of the web page. If your\n  framework integration uses the special ``render_topbottom`` method,\n  you can enable the inclusion of javascript files at the bottom by\n  calling ``hurry.resource.bottom()``. This will only include\n  resources at the bottom that have explicitly declared themselves to\n  be *bottom-safe*. You can declare a resource bottom safe by passing\n  ``bottom=True`` when constructing a ``ResourceInclusion``. If you\n  want to force all javascript to be including at the bottom of the\n  page by default, you can call ``hurry.resource.bottom(force=True)``.\n\nTo find out more about these and other optimizations, please read this\n`best practices article`_ that describes some common optimizations to\nspeed up page load times.\n\n.. _`best practices article`: http://developer.yahoo.com/performance/rules.html\n\nMultiple requirements\n=====================\n\nIn this section, we will show what happens in various scenarios where\nwe requiring multiple ``ResourceInclusion`` objects.\n\nWe create a new set of needed inclusions::\n\n  >>> needed = NeededInclusions()\n  >>> needed.inclusions()\n  []\n\nWe need ``y1`` again::\n\n  >>> needed.need(y1)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'b.css' in library 'foo'>,\n   <ResourceInclusion 'a.js' in library 'foo'>,\n   <ResourceInclusion 'c.js' in library 'foo'>]\n\nNeeding the same inclusion twice won't make any difference for the\nresources needed. So when we need ``y1`` again, we see no difference\nin the needed resources::\n\n  >>> needed.need(y1)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'b.css' in library 'foo'>,\n   <ResourceInclusion 'a.js' in library 'foo'>,\n   <ResourceInclusion 'c.js' in library 'foo'>]\n\nNeeding ``x1`` or ``x2`` won't make any difference either, as ``y1``\nalready required ``x1`` and ``x2``::\n\n  >>> needed.need(x1)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'b.css' in library 'foo'>,\n   <ResourceInclusion 'a.js' in library 'foo'>,\n   <ResourceInclusion 'c.js' in library 'foo'>]\n  >>> needed.need(x2)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'b.css' in library 'foo'>,\n   <ResourceInclusion 'a.js' in library 'foo'>,\n   <ResourceInclusion 'c.js' in library 'foo'>]\n\nLet's do it in reverse, and require the ``x1`` and ``x2`` resources\nbefore we need those in ``y1``. Again this makes no difference::\n\n  >>> needed = NeededInclusions()\n  >>> needed.need(x1)\n  >>> needed.need(x2)\n  >>> needed.need(y1)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'b.css' in library 'foo'>,\n   <ResourceInclusion 'a.js' in library 'foo'>,\n   <ResourceInclusion 'c.js' in library 'foo'>]\n\nLet's try it with more complicated dependency structures now::\n\n  >>> needed = NeededInclusions()\n  >>> a1 = ResourceInclusion(foo, 'a1.js')\n  >>> a2 = ResourceInclusion(foo, 'a2.js', depends=[a1])\n  >>> a3 = ResourceInclusion(foo, 'a3.js', depends=[a2])\n  >>> a4 = ResourceInclusion(foo, 'a4.js', depends=[a1])\n  >>> needed.need(a3)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'a1.js' in library 'foo'>,\n   <ResourceInclusion 'a2.js' in library 'foo'>,\n   <ResourceInclusion 'a3.js' in library 'foo'>]\n  >>> needed.need(a4)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'a1.js' in library 'foo'>,\n   <ResourceInclusion 'a2.js' in library 'foo'>,\n   <ResourceInclusion 'a3.js' in library 'foo'>,\n   <ResourceInclusion 'a4.js' in library 'foo'>]\n\nIf we reverse the requirements for ``a4`` and ``a3``, we get the following\ninclusion structure, based on the order in which need was expressed::\n\n  >>> needed = NeededInclusions()\n  >>> needed.need(a4)\n  >>> needed.need(a3)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'a1.js' in library 'foo'>,\n   <ResourceInclusion 'a4.js' in library 'foo'>,\n   <ResourceInclusion 'a2.js' in library 'foo'>,\n   <ResourceInclusion 'a3.js' in library 'foo'>]\n\nLet's look at the order in which resources are listed when we need\nsomething that ends up depending on everything::\n\n  >>> a5 = ResourceInclusion(foo, 'a5.js', depends=[a4, a3])\n  >>> needed = NeededInclusions()\n  >>> needed.need(a5)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'a1.js' in library 'foo'>,\n   <ResourceInclusion 'a4.js' in library 'foo'>,\n   <ResourceInclusion 'a2.js' in library 'foo'>,\n   <ResourceInclusion 'a3.js' in library 'foo'>,\n   <ResourceInclusion 'a5.js' in library 'foo'>]\n\nWhen we introduce the extra inclusion of ``a3`` earlier on, we still\nget a valid list of inclusions given the dependency structure, even\nthough the sorting order is different::\n\n  >>> needed = NeededInclusions()\n  >>> needed.need(a3)\n  >>> needed.need(a5)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'a1.js' in library 'foo'>,\n   <ResourceInclusion 'a2.js' in library 'foo'>,\n   <ResourceInclusion 'a3.js' in library 'foo'>,\n   <ResourceInclusion 'a4.js' in library 'foo'>,\n   <ResourceInclusion 'a5.js' in library 'foo'>]\n\nModes\n=====\n\nA resource can optionally exist in several modes, such as for instance\na minified and a debug version. Let's define a resource that exists in\ntwo modes (a main one and a debug alternative)::\n\n  >>> k1 = ResourceInclusion(foo, 'k.js', debug='k-debug.js')\n\nLet's need this resource::\n\n  >>> needed = NeededInclusions()\n  >>> needed.need(k1)\n\nBy default, we get ``k.js``::\n\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'k.js' in library 'foo'>]\n\nWe can however also get the resource for mode ``debug`` and get\n``k-debug.js``::\n\n  >>> needed.mode('debug')\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'k-debug.js' in library 'foo'>]\n\nModes can also be specified fully with a resource inclusion, which allows\nyou to specify a different ``library`` argumnent::\n\n  >>> k2 = ResourceInclusion(foo, 'k2.js',\n  ...                        debug=ResourceInclusion(foo, 'k2-debug.js'))\n  >>> needed = NeededInclusions()\n  >>> needed.need(k2)\n\nBy default we get ``k2.js``::\n\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'k2.js' in library 'foo'>]\n\nWe can however also get the resource for mode ``debug`` and get\n``k2-debug.js``::\n\n  >>> needed.mode('debug')\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'k2-debug.js' in library 'foo'>]\n\nNote that modes are assumed to be identical in dependency structure;\nthey functionally should do the same.\n\nIf you request a mode and a resource doesn't support it, it will\nreturn its default resource instead::\n\n  >>> needed = NeededInclusions()\n  >>> needed.mode('minified')\n  >>> needed.need(k1)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'k.js' in library 'foo'>]\n\n``hurry.resource`` suggests resource libraries follow the following\nconventions for modes:\n\n  * default - the original source text, non-minified, and without any\n    special extra debugging functionality.\n\n  * debug - an optional version of the source text that offers more\n    debugging support, such as logging.\n\n  * minified - an optional minified (compressed) form of the resource.\n\nIn the case of rollups, several resources can be consolidated into one\nlarger one for optimization purposes. A library might only offer a\nminified version of a rollup resource; if the developer wants to\ndebug, it is expected he uses the resources in non-rolledup format.\nIn this case you should make a resource inclusion where the default\nmode is equal to the minified mode, like this::\n\n  >>> example = ResourceInclusion(foo, 'k.js', minified='k.js')\n\nIf the developer wants to debug, he will need to disable rolling up\n(by calling ``hurry.resource.rollup(disable=True)``, or by simply\nnever calling ``hurry.resource.rollup()`` in the request cycle).\n\nMode convenience\n================\n\nLike for ``need``, there is also a convenience spelling for\n``mode``. It uses ``ICurrentNeededInclusions``, which we've already\nset up to look at the ``request.needed`` variable. Let's set up\na new request::\n\n  >>> request = Request()\n\nLet's set up a resource and need it::\n\n  >>> l1 = ResourceInclusion(foo, 'l1.js', debug='l1-debug.js')\n  >>> l1.need()\n\nLet's look at the resources needed by default::\n\n  >>> c = get_current_needed_inclusions()\n  >>> c.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'l1.js' in library 'foo'>]\n\nLet's now change the mode using the convenience\n``hurry.resource.mode`` spelling::\n\n  >>> from hurry.resource import mode\n  >>> mode('debug')\n\nWhen we request the resources now, we get them in the ``debug`` mode::\n\n  >>> c.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'l1-debug.js' in library 'foo'>]\n\n\"Rollups\"\n=========\n\nFor performance reasons it's often useful to consolidate multiple\nresources into a single, larger resource, a so-called\n\"rollup\". Multiple javascript files could for instance be offered in a\nsingle, larger one. These consolidations can be specified as a\nresource::\n\n  >>> b1 = ResourceInclusion(foo, 'b1.js')\n  >>> b2 = ResourceInclusion(foo, 'b2.js')\n  >>> giant = ResourceInclusion(foo, 'giant.js', supersedes=[b1, b2])\n\nRolling up of resources is not enabled by default, as sometimes a\nlibrary only offers these rollups in minified form, and automatically\nrolling up would not be nice during debugging. It's therefore a\nperformance feature you can enable.\n\nWithout rollups enabled nothing special happens::\n\n  >>> needed = NeededInclusions()\n  >>> needed.need(b1)\n  >>> needed.need(b2)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'b1.js' in library 'foo'>, <ResourceInclusion 'b2.js' in library 'foo'>]\n\nLet's enable rollups::\n\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n\nThe convenience spelling to enable rollups during request handling\nlooks like this::\n\n  hurry.resource.rollup()\n\nIf we now find multiple resources that are also part of a\nconsolidation, the system automatically collapses them::\n\n  >>> needed.need(b1)\n  >>> needed.need(b2)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'giant.js' in library 'foo'>]\n\nThe system will by default only consolidate exactly. That is, if only a single\nresource out of two is present, the consolidation will not be triggered::\n\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n  >>> needed.need(b1)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'b1.js' in library 'foo'>]\n\nLet's look at this with a larger consolidation of 3 resources::\n\n  >>> c1 = ResourceInclusion(foo, 'c1.css')\n  >>> c2 = ResourceInclusion(foo, 'c2.css')\n  >>> c3 = ResourceInclusion(foo, 'c3.css')\n  >>> giantc = ResourceInclusion(foo, 'giantc.css', supersedes=[c1, c2, c3])\n\nIt will not roll up one resource::\n\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n  >>> needed.need(c1)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'c1.css' in library 'foo'>]\n\nNeither will it roll up two resources::\n\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n  >>> needed.need(c1)\n  >>> needed.need(c2)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'c1.css' in library 'foo'>,\n   <ResourceInclusion 'c2.css' in library 'foo'>]\n\nIt will however roll up three resources::\n\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n  >>> needed.need(c1)\n  >>> needed.need(c2)\n  >>> needed.need(c3)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'giantc.css' in library 'foo'>]\n\nThe default behavior is to play it safe: we cannot be certain that we\ndo not include too much if we were to include ``giantc.css`` if only\nc1 and c2 are required. This is especially important with CSS\nlibraries: if only ``c1.css`` and ``c2.css`` are to be included in a\npage, including ``giantc.css`` is not appropriate as that also\nincludes the content of ``c3.css``, which might override and extend\nthe behavior of ``c1.css`` and ``c2.css``.\n\nThe situation is sometimes different with Javascript libraries, which\ncan be written in such a way that a larger rollup will just include\nmore functions, but will not actually affect page behavior. If we have\na rollup resource that we don't mind kicking in even if part of the\nrequirements have been met, we can indicate this::\n\n  >>> d1 = ResourceInclusion(foo, 'd1.js')\n  >>> d2 = ResourceInclusion(foo, 'd2.js')\n  >>> d3 = ResourceInclusion(foo, 'd3.js')\n  >>> giantd = ResourceInclusion(foo, 'giantd.js', supersedes=[d1, d2, d3],\n  ...            eager_superseder=True)\n\nWe will see ``giantd.js`` kick in even if we only require ``d1`` and\n``d2``::\n\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n  >>> needed.need(d1)\n  >>> needed.need(d2)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'giantd.js' in library 'foo'>]\n\nIn fact even if we only need a single resource the eager superseder will\nshow up instead::\n\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n  >>> needed.need(d1)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'giantd.js' in library 'foo'>]\n\nIf there are two potential eager superseders, the biggest one will\nbe taken::\n\n  >>> d4 = ResourceInclusion(foo, 'd4.js')\n  >>> giantd_bigger = ResourceInclusion(foo, 'giantd-bigger.js',\n  ...   supersedes=[d1, d2, d3, d4], eager_superseder=True)\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n  >>> needed.need(d1)\n  >>> needed.need(d2)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'giantd-bigger.js' in library 'foo'>]\n\nIf there is a potential non-eager superseder and an eager one, the eager one\nwill be taken::\n\n  >>> giantd_noneager = ResourceInclusion(foo, 'giantd-noneager.js',\n  ...   supersedes=[d1, d2, d3, d4])\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n  >>> needed.need(d1)\n  >>> needed.need(d2)\n  >>> needed.need(d3)\n  >>> needed.need(d4)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'giantd-bigger.js' in library 'foo'>]\n\nA resource can be part of multiple rollups. In this case the rollup\nthat rolls up the most resources is used. So, if there are two\npotential non-eager superseders, the one that rolls up the most\nresources will be used::\n\n  >>> e1 = ResourceInclusion(foo, 'e1.js')\n  >>> e2 = ResourceInclusion(foo, 'e2.js')\n  >>> e3 = ResourceInclusion(foo, 'e3.js')\n  >>> giante_two = ResourceInclusion(foo, 'giante-two.js',\n  ...   supersedes=[e1, e2])\n  >>> giante_three = ResourceInclusion(foo, 'giante-three.js',\n  ...   supersedes=[e1, e2, e3])\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n  >>> needed.need(e1)\n  >>> needed.need(e2)\n  >>> needed.need(e3)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'giante-three.js' in library 'foo'>]\n\nConsolidation also works with modes::\n\n  >>> f1 = ResourceInclusion(foo, 'f1.js', debug='f1-debug.js')\n  >>> f2 = ResourceInclusion(foo, 'f2.js', debug='f2-debug.js')\n  >>> giantf = ResourceInclusion(foo, 'giantf.js', supersedes=[f1, f2],\n  ...                            debug='giantf-debug.js')\n\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n  >>> needed.need(f1)\n  >>> needed.need(f2)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'giantf.js' in library 'foo'>]\n  >>> needed.mode('debug')\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'giantf-debug.js' in library 'foo'>]\n\nWhat if the rolled up resources have no mode but the superseding resource\ndoes? In this case the superseding resource's mode has no meaning, so\nmodes have no effect::\n\n  >>> g1 = ResourceInclusion(foo, 'g1.js')\n  >>> g2 = ResourceInclusion(foo, 'g2.js')\n  >>> giantg = ResourceInclusion(foo, 'giantg.js', supersedes=[g1, g2],\n  ...                            debug='giantg-debug.js')\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n  >>> needed.need(g1)\n  >>> needed.need(g2)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'giantg.js' in library 'foo'>]\n  >>> needed.mode('debug')\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'giantg.js' in library 'foo'>]\n\nWhat if the rolled up resources have a mode but the superseding resource\ndoes not? Let's look at that scenario::\n\n  >>> h1 = ResourceInclusion(foo, 'h1.js', debug='h1-debug.js')\n  >>> h2 = ResourceInclusion(foo, 'h2.js', debug='h2-debug.js')\n  >>> gianth = ResourceInclusion(foo, 'gianth.js', supersedes=[h1, h2])\n  >>> needed = NeededInclusions()\n  >>> needed.rollup()\n  >>> needed.need(h1)\n  >>> needed.need(h2)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'gianth.js' in library 'foo'>]\n\nSince there is no superseder for the debug mode, we will get the two\nresources, not rolled up::\n\n  >>> needed.mode('debug')\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'h1-debug.js' in library 'foo'>,\n   <ResourceInclusion 'h2-debug.js' in library 'foo'>]\n\nRendering resources\n===================\n\nLet's define some needed resource inclusions::\n\n  >>> needed = NeededInclusions()\n  >>> needed.need(y1)\n  >>> needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'b.css' in library 'foo'>,\n   <ResourceInclusion 'a.js' in library 'foo'>,\n   <ResourceInclusion 'c.js' in library 'foo'>]\n\nNow let's try to render these inclusions::\n\n  >>> print needed.render()\n  Traceback (most recent call last):\n    ...\n  AttributeError: 'Plugin' object has no attribute 'get_library_url'\n\nThat didn't work. In order to render an inclusion, we need to tell\n``hurry.resource`` how to get the URL for a resource inclusion. We\nalready know the relative URL, so we need to specify how to get a URL\nto the library itself that the relative URL can be added to.\n\nWe'll extend the existing plugin that already knows how to obtain the\ncurrent needed inclusions. For the purposes of this document, we\ndefine a function that renders resources as some static URL on\nlocalhost::\n\n  >>> class NewPlugin(Plugin):\n  ...   def get_library_url(self, library):\n  ...     return 'http://localhost/static/%s' % library.name\n\nLet's register the plugin::\n\n  >>> register_plugin(NewPlugin())\n\nRendering the inclusions now will result in the HTML fragments we\nneed to include on the top of our page (just under the ``<head>`` tag\nfor instance)::\n\n  >>> print needed.render()\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n\nLet's set this a currently needed inclusions::\n\n  >>> request.needed = needed\n\nThere is a function available as well for rendering the resources for\nthe currently needed inclusion::\n\n  >>> from hurry import resource\n  >>> print resource.render()\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n\nInserting resources in HTML\n===========================\n\nWhen you have the HTML it can be convenient to have a way to insert\nresources directly into some HTML.\n\nThe insertion system assumes a HTML text that has a ``<head>`` tag in it::\n\n  >>> html = \"<html><head>something more</head></html>\"\n\nTo insert the resources directly in HTML we can use ``render_into_html``\non ``needed``::\n\n  >>> print needed.render_into_html(html)\n  <html><head>\n      <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n  something more</head></html>\n\nThe top-level convenience function does this for the currently needed\nresources::\n\n  >>> print resource.render_into_html(html)\n  <html><head>\n      <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n  something more</head></html>\n\nSee below for a way to insert into HTML when bottom fragments are\ninvolved.\n\nTop and bottom fragments\n========================\n\nIt's also possible to render the resource inclusions into two\nfragments, some to be included just after the ``<head>`` tag, but some\nto be included at the very bottom of the HTML page, just before the\n``</body>`` tag. This is useful as it can `speed up page load times`_.\n\n.. _`speed up page load times`: http://developer.yahoo.com/performance/rules.html\n\nLet's look at the same resources, now rendered separately into ``top``\nand ``bottom`` fragments::\n\n  >>> top, bottom = needed.render_topbottom()\n  >>> print top\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n  >>> print bottom\n  <BLANKLINE>\n\nThere is effectively no change; all the resources are still on the\ntop. We can enable bottom rendering by calling the ``bottom`` method before\nwe render::\n\n  >>> needed.bottom()\n\nSince none of the resources indicated it was safe to render them at\nthe bottom, even this explicit call will not result in any changes::\n\n  >>> top, bottom = needed.render_topbottom()\n  >>> print top\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n  >>> print bottom\n  <BLANKLINE>\n\n``bottom(force=True)`` will however force all javascript inclusions to be\nrendered in the bottom fragment::\n\n  >>> needed.bottom(force=True)\n  >>> top, bottom = needed.render_topbottom()\n  >>> print top\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  >>> print bottom\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n\nLet's now introduce a javascript resource that says it is safe to be\nincluded on the bottom::\n\n  >>> y2 = ResourceInclusion(foo, 'y2.js', bottom=True)\n\nWhen we start over without ``bottom`` enabled, we get this resource\nshow up in the top fragment after all::\n\n  >>> needed = NeededInclusions()\n  >>> needed.need(y1)\n  >>> needed.need(y2)\n\n  >>> top, bottom = needed.render_topbottom()\n  >>> print top\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/y2.js\"></script>\n  >>> print bottom\n  <BLANKLINE>\n\nWe now tell the system that it's safe to render inclusions at the bottom::\n\n  >>> needed.bottom()\n\nWe now see the resource ``y2`` show up in the bottom fragment::\n\n  >>> top, bottom = needed.render_topbottom()\n  >>> print top\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n  >>> print bottom\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/y2.js\"></script>\n\nThere's also a convenience function for the currently needed inclusion::\n\n  >>> request.needed = needed\n  >>> top, bottom = resource.render_topbottom()\n  >>> print top\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n  >>> print bottom\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/y2.js\"></script>\n\nWhen we force bottom rendering of Javascript, there is no effect of\nmaking a resource bottom-safe: all ``.js`` resources will be rendered\nat the bottom anyway::\n\n  >>> needed.bottom(force=True)\n  >>> top, bottom = needed.render_topbottom()\n  >>> print top\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  >>> print bottom\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/y2.js\"></script>\n\nNote that if ``bottom`` is enabled, it makes no sense to have a\nresource inclusion ``b`` that depends on a resource inclusion ``a``\nwhere ``a`` is bottom-safe and ``b``, that depends on it, is not\nbottom-safe. In this case ``a`` would be included on the page at the\nbottom *after* ``b`` in the ``<head>`` section, and this might lead to\nordering problems. Likewise a rollup resource shouldn't combine\nresources where some are bottom-safe and others aren't.\n\nThe system makes no sanity checks for misconfiguration of\nbottom-safety however; it could be the user simply never enables\n``bottom`` mode at all and doesn't care about this issue. In this case\nthe user will want to write Javascript code that isn't safe to be\nincluded at the bottom of the page and still be able to depend on\nJavascript code that is.\n\nInserting top and bottom resources in HTML\n==========================================\n\nYou can also insert top and bottom fragments into HTML. This assumes a\nHTML text that has a ``<head>`` tag in it as well as a ``</body>``\ntag::\n\n  >>> html = \"<html><head>rest of head</head><body>rest of body</body></html>\"\n\nTo insert the resources directly in HTML we can use\n``render_topbottom_into_html`` on ``needed``::\n\n  >>> print needed.render_topbottom_into_html(html)\n  <html><head>\n      <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  rest of head</head><body>rest of body<script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/y2.js\"></script></body></html>\n\nThere's also a function available to do this for the currently needed\nresources::\n\n  >>> print resource.render_topbottom_into_html(html)\n  <html><head>\n      <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  rest of head</head><body>rest of body<script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/y2.js\"></script></body></html>\n\nUsing WSGI middleware to insert into HTML\n=========================================\n\nThere is also a WSGI middleware available to insert the top (and bottom)\ninto the HTML. We are using WebOb to create a response object that will\nserve as our WSGI application.\n\nWe create a simple WSGI application. In our application we declare that\nwe need a resource (``y1``) and put that in the WSGI ``environ`` under the\nkey ``hurry.resource.needed``::\n\n  >>> def app(environ, start_response):\n  ...    start_response('200 OK', [])\n  ...    needed = environ['hurry.resource.needed'] = NeededInclusions()\n  ...    needed.need(y1)\n  ...    return ['<html><head></head><body</body></html>']\n\nWe now wrap this in our middleware, so that the middleware is activated::\n\n  >>> from hurry.resource.wsgi import Middleware\n  >>> wrapped_app = Middleware(app)\n\nNow we make a request (using webob for convenience)::\n\n  >>> import webob\n  >>> req = webob.Request.blank('/')\n  >>> res = req.get_response(wrapped_app)\n\nWe can now see that the resources are added to the HTML by the middleware::\n\n  >>> print res.body\n  <html><head>\n      <link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" />\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"></script>\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"></script>\n  </head><body</body></html>\n\nWhen we set the response Content-Type to non-HTML, the middleware\nwon't be active even if we need things and the body appears to contain\nHTML::\n\n  >>> def app(environ, start_response):\n  ...    start_response('200 OK', [('Content-Type', 'text/plain')])\n  ...    needed = environ['hurry.resource.needed'] = NeededInclusions()\n  ...    needed.need(y1)\n  ...    return ['<html><head></head><body</body></html>']\n  >>> wrapped_app = Middleware(app)\n  >>> req = webob.Request.blank('/')\n  >>> res = req.get_response(wrapped_app)\n  >>> res.body\n  '<html><head></head><body</body></html>'\n\nbottom convenience\n==================\n\nLike for ``need`` and ``mode``, there is also a convenience spelling for\n``bottom``::\n\n  >>> request = Request()\n  >>> l1 = ResourceInclusion(foo, 'l1.js', bottom=True)\n  >>> l1.need()\n\nLet's look at the resources needed by default::\n\n  >>> c = get_current_needed_inclusions()\n  >>> top, bottom = c.render_topbottom()\n  >>> print top\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/l1.js\"></script>\n  >>> print bottom\n  <BLANKLINE>\n\nLet's now change the bottom mode using the convenience\n``hurry.resource.bottom`` spelling::\n\n  >>> from hurry.resource import bottom\n  >>> bottom()\n\nRe-rendering will show it's honoring the bottom setting::\n\n  >>> top, bottom = c.render_topbottom()\n  >>> print top\n  <BLANKLINE>\n  >>> print bottom\n  <script type=\"text/javascript\" src=\"http://localhost/static/foo/l1.js\"></script>\n\nGenerating resource code\n========================\n\nSometimes it is useful to generate code that expresses a complex\nresource dependency structure. One example of that is in\n``hurry.yui``. We can use the ``generate_code`` function to render resource\ninclusions::\n\n  >>> i1 = ResourceInclusion(foo, 'i1.js')\n  >>> i2 = ResourceInclusion(foo, 'i2.js', depends=[i1])\n  >>> i3 = ResourceInclusion(foo, 'i3.js', depends=[i2])\n  >>> i4 = ResourceInclusion(foo, 'i4.js', depends=[i1])\n  >>> i5 = ResourceInclusion(foo, 'i5.js', depends=[i4, i3])\n\n  >>> from hurry.resource import generate_code\n  >>> print generate_code(i1=i1, i2=i2, i3=i3, i4=i4, i5=i5)\n  from hurry.resource import Library, ResourceInclusion\n  <BLANKLINE>\n  foo = Library('foo', 'dummy')\n  <BLANKLINE>\n  i1 = ResourceInclusion(foo, 'i1.js')\n  i2 = ResourceInclusion(foo, 'i2.js', depends=[i1])\n  i3 = ResourceInclusion(foo, 'i3.js', depends=[i2])\n  i4 = ResourceInclusion(foo, 'i4.js', depends=[i1])\n  i5 = ResourceInclusion(foo, 'i5.js', depends=[i4, i3])\n\nLet's look at a more complicated example with modes and superseders::\n\n  >>> j1 = ResourceInclusion(foo, 'j1.js', debug='j1-debug.js')\n  >>> j2 = ResourceInclusion(foo, 'j2.js', debug='j2-debug.js')\n  >>> giantj = ResourceInclusion(foo, 'giantj.js', supersedes=[j1, j2],\n  ...                            debug='giantj-debug.js')\n\n  >>> print generate_code(j1=j1, j2=j2, giantj=giantj)\n  from hurry.resource import Library, ResourceInclusion\n  <BLANKLINE>\n  foo = Library('foo', 'dummy')\n  <BLANKLINE>\n  j1 = ResourceInclusion(foo, 'j1.js', debug='j1-debug.js')\n  j2 = ResourceInclusion(foo, 'j2.js', debug='j2-debug.js')\n  giantj = ResourceInclusion(foo, 'giantj.js', supersedes=[j1, j2], debug='giantj-debug.js')\n\nWe can control the name the inclusion will get in the source code by\nusing keyword parameters::\n\n  >>> print generate_code(hoi=i1)\n  from hurry.resource import Library, ResourceInclusion\n  <BLANKLINE>\n  foo = Library('foo', 'dummy')\n  <BLANKLINE>\n  hoi = ResourceInclusion(foo, 'i1.js')\n\n  >>> print generate_code(hoi=i1, i2=i2)\n  from hurry.resource import Library, ResourceInclusion\n  <BLANKLINE>\n  foo = Library('foo', 'dummy')\n  <BLANKLINE>\n  hoi = ResourceInclusion(foo, 'i1.js')\n  i2 = ResourceInclusion(foo, 'i2.js', depends=[hoi])\n\nSorting inclusions by dependency\n================================\n\nThis is more a footnote than something that you should be concerned\nabout. In case assumptions in this library are wrong or there are\nother reasons you would like to sort resource inclusions that come in\nsome arbitrary order into one where the dependency relation makes\nsense, you can use ``sort_inclusions_topological``::\n\n  >>> from hurry.resource import sort_inclusions_topological\n\nLet's make a list of resource inclusions not sorted by dependency::\n\n  >>> i = [a5, a3, a1, a2, a4]\n  >>> sort_inclusions_topological(i) #doctest: +NORMALIZE_WHITESPACE\n  [<ResourceInclusion 'a1.js' in library 'foo'>,\n   <ResourceInclusion 'a4.js' in library 'foo'>,\n   <ResourceInclusion 'a2.js' in library 'foo'>,\n   <ResourceInclusion 'a3.js' in library 'foo'>,\n   <ResourceInclusion 'a5.js' in library 'foo'>]\n\n\nInclusion renderers\n===================\n\nThe HTML fragments for inclusions are rendered by ``inclusion renderers``\nthat are simple functions registered per extension.\n\nRenderers are registered in the ``inclusion_renderers`` dictionary:\n\n  >>> from hurry.resource.core import inclusion_renderers\n  >>> sorted(inclusion_renderers)\n  ['.css', '.js', '.kss']\n\nRenderers render HTML fragments using given resource URL:\n\n  >>> inclusion_renderers['.js']('http://localhost/script.js')\n  '<script type=\"text/javascript\" src=\"http://localhost/script.js\"></script>'\n\nLet's create an inclusion of unknown resource:\n\n  >>> a6 = ResourceInclusion(foo, 'nothing.unknown')\n\n  >>> from hurry.resource.core import render_inclusions\n  >>> render_inclusions([a6]) #doctest: +NORMALIZE_WHITESPACE +ELLIPSIS\n  Traceback (most recent call last):\n  ...\n  UnknownResourceExtension: Unknown resource extension .unknown for resource\n                            inclusion: <ResourceInclusion 'nothing.unknown'\n                            in library 'foo'>\n\nNow let's add a renderer for our \".unknown\" extension and try again:\n\n  >>> def render_unknown(url):\n  ...     return '<link rel=\"unknown\" href=\"%s\" />' % url\n  >>> inclusion_renderers['.unknown'] = render_unknown\n\n  >>> render_inclusions([a6])\n  '<link rel=\"unknown\" href=\"http://localhost/static/foo/nothing.unknown\" />'\n\nCHANGES\n*******\n\n.. Important::\n   hurry.resource has been superseded by the\n   `Fanstatic <http://fanstatic.org>`_ project!\n\n0.10 (2010-07-24)\n=================\n\n* The WSGI Middleware depends on WebOb, which is an optional\n  dependency. Don't expose it into the ``__init__.py`` therefore, as\n  that needs to be independent of WebOb. To use the middleware import\n  it directly from ``hurry.resource.wsgi``.\n\n* The ``Library`` factory now has to be called with a rootpath\n  argument as the second argument. This is a path to the actual\n  resource directory that the library represents, relative to the\n  directory of the package. This is needed to make `` hurry.resource``\n  useful for frameworks not based on ``zope.configuration``.\n\n  This breaks backwards compatibility with previous versions of\n  ``hurry.resource``; all code that uses ``Library`` should be\n  adjusted. Please also update their ``setup.py`` to depend on\n  ``hurry.resource >= 0.10``.\n\n* Packages should register their ``Library`` instances with\n  ``hurry.resource`` using the ``hurry.resource.libraries`` entry\n  point.\n\n0.9 (2010-07-13)\n================\n\n* WSGI support: ``hurry.resource.Middleware`` can be used to wrap WSGI\n  applications. If the application supplies a ``NeededInclusions``\n  object in ``environ`` with the key ``hurry.resource.needed``, the\n  middleware will pick up on this and insert the needed inclusions.\n\n  The WebOb library is needed to make this work and depending on\n  ``hurry.resource [wsgi]`` will pull in the required dependency.\n\n* Fixed some typos in README.txt.\n\n0.4.1 (2009-12-16)\n==================\n\n* Fix restructured text.\n\n0.4 (2009-12-16)\n================\n\n* Expose a ``GroupInclusion`` that only exists to depend on other\n  inclusions. This way it becomes possible to expose a set of\n  different resources together without there being a central resource\n  that depends on them. The GroupInclusion itself is therefore not\n  rendered.\n\n* Create ``render_into_html`` and ``render_topbottom_into_html``\n  functionality, which insert the rendered inclusions into HTML.\n\n* Expose ``render``, ``render_into_html``, ``render_topbottom`` and\n  ``render_topbottom_into_html`` as top-level functions in\n  ``hurry.resource``.\n\n* Fix NameError when trying to render an inclusion with unknown extension.\n\n* Document inclusion renderers mechanism in the README.txt.\n\n0.3 (2008-10-15)\n================\n\nFeatures added\n--------------\n\n* Consolidating resources into rollups is now disabled by\n  default. This is to help developers with debugging; rollups are\n  typically minified for optimization purposes, and libraries such as\n  YUI do not offer rollups in non-minified form. Since rollups must\n  now be explicitly enabled by the application developer\n  (``hurry.resource.rollup()``), an application developer who needs to\n  debug can choose not to call it (or call\n  ``hurry.resource.rollup(disable=True``).\n\n* Added an optimization section to the documentation.\n\n* Added some more details about how modes are expected to be used to\n  the documentation.\n\nBug fixes\n---------\n\n* ``hurry.resource.bottom`` now takes a second optional ``disable``\n  parameter.\n\n0.2 (2008-10-13)\n================\n\n* Changed the API to set the mode. Instead of passing it to ``render``\n  and ``inclusions``, the requested mode can be set with the ``mode``\n  method on ``INeededInclusions``. For convenience there is a ``mode``\n  function as well that can be imported directly from\n  ``hurry.resource`` that sets the mode for the current needed\n  inclusions.\n\n* Added support for rendering resources into two fragments, one to\n  be included at the top of the HTML page in the ``<head>`` section,\n  the other to be included just before the ``</body>`` section. In\n  some circumstances doing this can `speed up page load time`_.\n\n  .. _`speed up page load time`: http://developer.yahoo.net/blog/archives/2007/07/high_performanc_5.html\n\n0.1 (2008-10-07)\n================\n\n* Initial public release.\n\nDownload\n********", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/hurry.resource", "keywords": "", "license": "ZPL 2.1", "maintainer": null, "maintainer_email": null, "name": "hurry.resource", "package_url": "https://pypi.org/project/hurry.resource/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/hurry.resource/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/hurry.resource"}, "release_url": "https://pypi.org/project/hurry.resource/0.10/", "requires_dist": null, "requires_python": null, "summary": "Flexible resources for web applications.", "version": "0.10", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"hurry-resource\">\n<h2>hurry.resource</h2>\n<div>\n<p>Important</p>\n<p>hurry.resource has been superseded by the\n<a href=\"http://fanstatic.org\" rel=\"nofollow\">Fanstatic</a> project!</p>\n</div>\n<div id=\"introduction\">\n<h3>Introduction</h3>\n<p>Resources are files that are used as resources in the display of a web\npage, such as CSS files, Javascript files and images. Resources\npackaged together in a directory to be published as such are called a\nresource <em>library</em>.</p>\n<p>When a resource is included in the <tt>head</tt> section of a HTML page, we\ncall this a resource <em>inclusion</em>. An inclusion is of a particular\nresource in a particular library. There are two forms of this kind of\ninclusion in HTML: javascript is included using the <tt>script</tt> tag,\nand CSS (and KSS) are included using a <tt>link</tt> tag.</p>\n<p>Inclusions may depend on other inclusions. A javascript resource may\nfor instance be built on top of another javascript resource. This\nmeans both of them should be loaded when the page displays.</p>\n<p>Page components may actually require a certain inclusion in order to\nbe functional. A widget may for instance expect a particular\nJavascript library to loaded. We call this an <em>inclusion requirement</em>\nof the component.</p>\n<p><tt>hurry.resource</tt> provides a simple API to specify resource\nlibraries, inclusion and inclusion requirements.</p>\n</div>\n<div id=\"a-resource-library\">\n<h3>A resource library</h3>\n<p>We define a library <tt>foo</tt>. It takes two arguments, the name of the\nlibrary as it should be published under in a URL and uniquely identify\nit, and a path to the root of the resources (rootpath) that this\nlibrary publishes:</p>\n<pre>&gt;&gt;&gt; from hurry.resource import Library\n&gt;&gt;&gt; foo = Library('foo', 'dummy')\n</pre>\n<p>The full path to the directory with the resources is reconstructed from\nthe package that the Library is defined in:</p>\n<pre>&gt;&gt;&gt; foo.path #doctest: +ELLIPSIS\n'.../hurry.resource/src/hurry/resource/dummy'\n</pre>\n</div>\n<div id=\"entry-points\">\n<h3>Entry points</h3>\n<p>Libraries can be exposed for registration by whatever web framework\nthat hurry.resource is integrated with. This web framework can then\nexpose the library path on a URL somewhere. This is done using the\n<tt>hurry.resource.libraries</tt> entry point. To register <tt>Library</tt>\ninstances <tt>foo</tt> and <tt>bar</tt> in your package as entry points include\na section like this in your <tt>setup.py</tt>:</p>\n<pre>entry_points={\n  'hurry.resource.libraries': [\n      'foo = mypackage.foomodule:foo',\n      'bar = mypackage.barmodule:bar',\n      ],\n  }\n</pre>\n<p>There is an API to help you obtain all registered libraries:</p>\n<pre>&gt;&gt;&gt; from hurry.resource import libraries\n</pre>\n<p>Nothing is registered however:</p>\n<pre>&gt;&gt;&gt; list(libraries())\n[]\n</pre>\n<p>It would be nice to now have some tests that see whether entry points\nactually get picked up so, but that would require an involved test\nsetup that we find difficult to construct.</p>\n</div>\n<div id=\"inclusion\">\n<h3>Inclusion</h3>\n<p>We now create an inclusion of a particular resource in a library. This\ninclusion needs <tt>a.js</tt> from <tt>library</tt> and <tt>b.js</tt> as well:</p>\n<pre>&gt;&gt;&gt; from hurry.resource import ResourceInclusion\n&gt;&gt;&gt; x1 = ResourceInclusion(foo, 'a.js')\n&gt;&gt;&gt; x2 = ResourceInclusion(foo, 'b.css')\n</pre>\n<p>Let\u2019s now make an inclusion <tt>y1</tt> that depends on <tt>x1</tt> and <tt>x2</tt>:</p>\n<pre>&gt;&gt;&gt; y1 = ResourceInclusion(foo, 'c.js', depends=[x1, x2])\n</pre>\n</div>\n<div id=\"inclusion-requirements\">\n<h3>Inclusion requirements</h3>\n<p>When rendering a web page we want to require the inclusion of a\nresource anywhere within the request handling process. We might for\ninstance have a widget that takes care of rendering its own HTML but\nalso needs a resource to be included in the page header.</p>\n<p>We have a special object that represents the needed inclusions during\na certain request cycle:</p>\n<pre>&gt;&gt;&gt; from hurry.resource import NeededInclusions\n&gt;&gt;&gt; needed = NeededInclusions()\n</pre>\n<p>We state that a resource is needed by calling the <tt>need</tt> method on\nthis object:</p>\n<pre>&gt;&gt;&gt; needed.need(y1)\n</pre>\n<p>Let\u2019s now see what resources are needed by this inclusion:</p>\n<pre>&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'b.css' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'c.js' in library 'foo'&gt;]\n</pre>\n<p>As you can see, <tt>css</tt> resources are sorted before <tt>js</tt> resources.</p>\n</div>\n<div id=\"grouping-resources\">\n<h3>Grouping resources</h3>\n<p>It is also possible to define a group that doesn\u2019t get rendered\nitself, but groups other resources together that should be rendered:</p>\n<pre>&gt;&gt;&gt; from hurry.resource import GroupInclusion\n&gt;&gt;&gt; group = GroupInclusion([x1, x2])\n</pre>\n<p>When we need a group, we\u2019ll get all inclusions referenced in it:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.need(group)\n&gt;&gt;&gt; group.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'a.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'b.css' in library 'foo'&gt;]\n</pre>\n<p>A group can also be depended on; it won\u2019t show up in the list of\ninclusions directly:</p>\n<pre>&gt;&gt;&gt; more_stuff = ResourceInclusion(foo, 'more_stuff.js', depends=[group])\n&gt;&gt;&gt; more_stuff.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'a.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'b.css' in library 'foo'&gt;,\n &lt;ResourceInclusion 'more_stuff.js' in library 'foo'&gt;]\n</pre>\n</div>\n<div id=\"a-convenience-spelling\">\n<h3>A convenience spelling</h3>\n<p>When specifying that we want a resource inclusion to be rendered, we\nnow need access to the current <tt>NeededInclusions</tt> object and the\nresource inclusion itself.</p>\n<p>Let\u2019s introduce a more convenient spelling of needs now:</p>\n<pre>y1.need()\n</pre>\n<p>We can require a resource without reference to the needed inclusions\nobject directly as there is typically only a single set of needed\ninclusions that is generated during the rendering of a page.</p>\n<p>So let\u2019s try out this spelling to see it fail:</p>\n<pre>&gt;&gt;&gt; y1.need()\nTraceback (most recent call last):\n  ...\nNotImplementedError: need to implement plugin.get_current_needed_inclusions()\n</pre>\n<p>We get an error because we haven\u2019t configured the framework yet. The\nsystem says we need to implement\n<tt>plugin.get_current_needed_inclusions()</tt> first. This is a method\nthat we need to implement so we can tell the system how to obtain the\ncurrent <tt>NeededInclusions</tt> object.</p>\n<p>This needed inclusions should be maintained on an object that is going\nto be present throughout the request/response cycle that generates the\nweb page that has the inclusions on them. One place where\nwe can maintain the needed inclusions is the request object\nitself, if we indeed have global access to it. Alternatively you could\nstore the currently needed inclusions in a thread local variable.</p>\n<p>Let\u2019s introduce a simple request object (your mileage may vary in your\nown web framework):</p>\n<pre>&gt;&gt;&gt; class Request(object):\n...    def __init__(self):\n...        self.needed = NeededInclusions()\n</pre>\n<p>We now make a request, imitating what happens during a typical\nrequest/response cycle in a web framework:</p>\n<pre>&gt;&gt;&gt; request = Request()\n</pre>\n<p>We now define a plugin class that implements the\n<tt>get_current_needed_inclusions()</tt> method by obtaining it from the\nrequest:</p>\n<pre>&gt;&gt;&gt; class Plugin(object):\n...   def get_current_needed_inclusions(self):\n...       return request.needed\n</pre>\n<p>We now need to register this plugin with the framework:</p>\n<pre>&gt;&gt;&gt; from hurry.resource import register_plugin\n&gt;&gt;&gt; register_plugin(Plugin())\n</pre>\n<p>There is an API to retrieve the current needed inclusions, so let\u2019s\ncheck which resources our request needs currently:</p>\n<pre>&gt;&gt;&gt; from hurry.resource import get_current_needed_inclusions\n&gt;&gt;&gt; get_current_needed_inclusions().inclusions()\n[]\n</pre>\n<p>Nothing yet. We now make <tt>y1</tt> needed using our simplified spelling:</p>\n<pre>&gt;&gt;&gt; y1.need()\n</pre>\n<p>The resource inclusion will now indeed be needed:</p>\n<pre>&gt;&gt;&gt; get_current_needed_inclusions().inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'b.css' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'c.js' in library 'foo'&gt;]\n</pre>\n<p>Let\u2019s go back to the original spelling of <tt>needed.need(y)</tt>\nnow. While this is a bit more cumbersome to use in application code, it is\neasier to read for the purposes of this document.</p>\n</div>\n<div id=\"a-note-on-optimization\">\n<h3>A note on optimization</h3>\n<p>There are various optimizations for resource inclusion that\n<tt>hurry.resource</tt> supports. Because some optimizations can make\ndebugging more difficult, the optimizations are disabled by default.</p>\n<p>We will summarize the optimization features here and tell you how to\nenable them. Later sections below go into more details.</p>\n<ul>\n<li>minified resources. Resources can specify minified versions using\nthe mode system. You can use <tt><span class=\"pre\">hurry.resource.mode('minified')</span></tt>\nsomewhere in the request handling of your application. This will\nmake sure that resources included on your page are supplied as\nminified versions, if these are available.</li>\n<li>rolling up of resources.  Resource libraries can specify rollup\nresources that combine multiple resources into one. This reduces the\namount of server requests to be made by the web browser, and can\nhelp with caching. To enable rolling up, call\n<tt>hurry.resource.rollup</tt> somewhere in your request handling.</li>\n<li>javascript inclusions at the bottom of the web page. If your\nframework integration uses the special <tt>render_topbottom</tt> method,\nyou can enable the inclusion of javascript files at the bottom by\ncalling <tt>hurry.resource.bottom()</tt>. This will only include\nresources at the bottom that have explicitly declared themselves to\nbe <em>bottom-safe</em>. You can declare a resource bottom safe by passing\n<tt>bottom=True</tt> when constructing a <tt>ResourceInclusion</tt>. If you\nwant to force all javascript to be including at the bottom of the\npage by default, you can call <tt>hurry.resource.bottom(force=True)</tt>.</li>\n</ul>\n<p>To find out more about these and other optimizations, please read this\n<a href=\"http://developer.yahoo.com/performance/rules.html\" rel=\"nofollow\">best practices article</a> that describes some common optimizations to\nspeed up page load times.</p>\n</div>\n<div id=\"multiple-requirements\">\n<h3>Multiple requirements</h3>\n<p>In this section, we will show what happens in various scenarios where\nwe requiring multiple <tt>ResourceInclusion</tt> objects.</p>\n<p>We create a new set of needed inclusions:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.inclusions()\n[]\n</pre>\n<p>We need <tt>y1</tt> again:</p>\n<pre>&gt;&gt;&gt; needed.need(y1)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'b.css' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'c.js' in library 'foo'&gt;]\n</pre>\n<p>Needing the same inclusion twice won\u2019t make any difference for the\nresources needed. So when we need <tt>y1</tt> again, we see no difference\nin the needed resources:</p>\n<pre>&gt;&gt;&gt; needed.need(y1)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'b.css' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'c.js' in library 'foo'&gt;]\n</pre>\n<p>Needing <tt>x1</tt> or <tt>x2</tt> won\u2019t make any difference either, as <tt>y1</tt>\nalready required <tt>x1</tt> and <tt>x2</tt>:</p>\n<pre>&gt;&gt;&gt; needed.need(x1)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'b.css' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'c.js' in library 'foo'&gt;]\n&gt;&gt;&gt; needed.need(x2)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'b.css' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'c.js' in library 'foo'&gt;]\n</pre>\n<p>Let\u2019s do it in reverse, and require the <tt>x1</tt> and <tt>x2</tt> resources\nbefore we need those in <tt>y1</tt>. Again this makes no difference:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.need(x1)\n&gt;&gt;&gt; needed.need(x2)\n&gt;&gt;&gt; needed.need(y1)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'b.css' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'c.js' in library 'foo'&gt;]\n</pre>\n<p>Let\u2019s try it with more complicated dependency structures now:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; a1 = ResourceInclusion(foo, 'a1.js')\n&gt;&gt;&gt; a2 = ResourceInclusion(foo, 'a2.js', depends=[a1])\n&gt;&gt;&gt; a3 = ResourceInclusion(foo, 'a3.js', depends=[a2])\n&gt;&gt;&gt; a4 = ResourceInclusion(foo, 'a4.js', depends=[a1])\n&gt;&gt;&gt; needed.need(a3)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'a1.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a2.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a3.js' in library 'foo'&gt;]\n&gt;&gt;&gt; needed.need(a4)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'a1.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a2.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a3.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a4.js' in library 'foo'&gt;]\n</pre>\n<p>If we reverse the requirements for <tt>a4</tt> and <tt>a3</tt>, we get the following\ninclusion structure, based on the order in which need was expressed:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.need(a4)\n&gt;&gt;&gt; needed.need(a3)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'a1.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a4.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a2.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a3.js' in library 'foo'&gt;]\n</pre>\n<p>Let\u2019s look at the order in which resources are listed when we need\nsomething that ends up depending on everything:</p>\n<pre>&gt;&gt;&gt; a5 = ResourceInclusion(foo, 'a5.js', depends=[a4, a3])\n&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.need(a5)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'a1.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a4.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a2.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a3.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a5.js' in library 'foo'&gt;]\n</pre>\n<p>When we introduce the extra inclusion of <tt>a3</tt> earlier on, we still\nget a valid list of inclusions given the dependency structure, even\nthough the sorting order is different:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.need(a3)\n&gt;&gt;&gt; needed.need(a5)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'a1.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a2.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a3.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a4.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a5.js' in library 'foo'&gt;]\n</pre>\n</div>\n<div id=\"modes\">\n<h3>Modes</h3>\n<p>A resource can optionally exist in several modes, such as for instance\na minified and a debug version. Let\u2019s define a resource that exists in\ntwo modes (a main one and a debug alternative):</p>\n<pre>&gt;&gt;&gt; k1 = ResourceInclusion(foo, 'k.js', debug='k-debug.js')\n</pre>\n<p>Let\u2019s need this resource:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.need(k1)\n</pre>\n<p>By default, we get <tt>k.js</tt>:</p>\n<pre>&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'k.js' in library 'foo'&gt;]\n</pre>\n<p>We can however also get the resource for mode <tt>debug</tt> and get\n<tt><span class=\"pre\">k-debug.js</span></tt>:</p>\n<pre>&gt;&gt;&gt; needed.mode('debug')\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'k-debug.js' in library 'foo'&gt;]\n</pre>\n<p>Modes can also be specified fully with a resource inclusion, which allows\nyou to specify a different <tt>library</tt> argumnent:</p>\n<pre>&gt;&gt;&gt; k2 = ResourceInclusion(foo, 'k2.js',\n...                        debug=ResourceInclusion(foo, 'k2-debug.js'))\n&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.need(k2)\n</pre>\n<p>By default we get <tt>k2.js</tt>:</p>\n<pre>&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'k2.js' in library 'foo'&gt;]\n</pre>\n<p>We can however also get the resource for mode <tt>debug</tt> and get\n<tt><span class=\"pre\">k2-debug.js</span></tt>:</p>\n<pre>&gt;&gt;&gt; needed.mode('debug')\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'k2-debug.js' in library 'foo'&gt;]\n</pre>\n<p>Note that modes are assumed to be identical in dependency structure;\nthey functionally should do the same.</p>\n<p>If you request a mode and a resource doesn\u2019t support it, it will\nreturn its default resource instead:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.mode('minified')\n&gt;&gt;&gt; needed.need(k1)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'k.js' in library 'foo'&gt;]\n</pre>\n<p><tt>hurry.resource</tt> suggests resource libraries follow the following\nconventions for modes:</p>\n<blockquote>\n<ul>\n<li>default - the original source text, non-minified, and without any\nspecial extra debugging functionality.</li>\n<li>debug - an optional version of the source text that offers more\ndebugging support, such as logging.</li>\n<li>minified - an optional minified (compressed) form of the resource.</li>\n</ul>\n</blockquote>\n<p>In the case of rollups, several resources can be consolidated into one\nlarger one for optimization purposes. A library might only offer a\nminified version of a rollup resource; if the developer wants to\ndebug, it is expected he uses the resources in non-rolledup format.\nIn this case you should make a resource inclusion where the default\nmode is equal to the minified mode, like this:</p>\n<pre>&gt;&gt;&gt; example = ResourceInclusion(foo, 'k.js', minified='k.js')\n</pre>\n<p>If the developer wants to debug, he will need to disable rolling up\n(by calling <tt>hurry.resource.rollup(disable=True)</tt>, or by simply\nnever calling <tt>hurry.resource.rollup()</tt> in the request cycle).</p>\n</div>\n<div id=\"mode-convenience\">\n<h3>Mode convenience</h3>\n<p>Like for <tt>need</tt>, there is also a convenience spelling for\n<tt>mode</tt>. It uses <tt>ICurrentNeededInclusions</tt>, which we\u2019ve already\nset up to look at the <tt>request.needed</tt> variable. Let\u2019s set up\na new request:</p>\n<pre>&gt;&gt;&gt; request = Request()\n</pre>\n<p>Let\u2019s set up a resource and need it:</p>\n<pre>&gt;&gt;&gt; l1 = ResourceInclusion(foo, 'l1.js', debug='l1-debug.js')\n&gt;&gt;&gt; l1.need()\n</pre>\n<p>Let\u2019s look at the resources needed by default:</p>\n<pre>&gt;&gt;&gt; c = get_current_needed_inclusions()\n&gt;&gt;&gt; c.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'l1.js' in library 'foo'&gt;]\n</pre>\n<p>Let\u2019s now change the mode using the convenience\n<tt>hurry.resource.mode</tt> spelling:</p>\n<pre>&gt;&gt;&gt; from hurry.resource import mode\n&gt;&gt;&gt; mode('debug')\n</pre>\n<p>When we request the resources now, we get them in the <tt>debug</tt> mode:</p>\n<pre>&gt;&gt;&gt; c.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'l1-debug.js' in library 'foo'&gt;]\n</pre>\n</div>\n<div id=\"rollups\">\n<h3>\u201cRollups\u201d</h3>\n<p>For performance reasons it\u2019s often useful to consolidate multiple\nresources into a single, larger resource, a so-called\n\u201crollup\u201d. Multiple javascript files could for instance be offered in a\nsingle, larger one. These consolidations can be specified as a\nresource:</p>\n<pre>&gt;&gt;&gt; b1 = ResourceInclusion(foo, 'b1.js')\n&gt;&gt;&gt; b2 = ResourceInclusion(foo, 'b2.js')\n&gt;&gt;&gt; giant = ResourceInclusion(foo, 'giant.js', supersedes=[b1, b2])\n</pre>\n<p>Rolling up of resources is not enabled by default, as sometimes a\nlibrary only offers these rollups in minified form, and automatically\nrolling up would not be nice during debugging. It\u2019s therefore a\nperformance feature you can enable.</p>\n<p>Without rollups enabled nothing special happens:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.need(b1)\n&gt;&gt;&gt; needed.need(b2)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'b1.js' in library 'foo'&gt;, &lt;ResourceInclusion 'b2.js' in library 'foo'&gt;]\n</pre>\n<p>Let\u2019s enable rollups:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n</pre>\n<p>The convenience spelling to enable rollups during request handling\nlooks like this:</p>\n<pre>hurry.resource.rollup()\n</pre>\n<p>If we now find multiple resources that are also part of a\nconsolidation, the system automatically collapses them:</p>\n<pre>&gt;&gt;&gt; needed.need(b1)\n&gt;&gt;&gt; needed.need(b2)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'giant.js' in library 'foo'&gt;]\n</pre>\n<p>The system will by default only consolidate exactly. That is, if only a single\nresource out of two is present, the consolidation will not be triggered:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n&gt;&gt;&gt; needed.need(b1)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'b1.js' in library 'foo'&gt;]\n</pre>\n<p>Let\u2019s look at this with a larger consolidation of 3 resources:</p>\n<pre>&gt;&gt;&gt; c1 = ResourceInclusion(foo, 'c1.css')\n&gt;&gt;&gt; c2 = ResourceInclusion(foo, 'c2.css')\n&gt;&gt;&gt; c3 = ResourceInclusion(foo, 'c3.css')\n&gt;&gt;&gt; giantc = ResourceInclusion(foo, 'giantc.css', supersedes=[c1, c2, c3])\n</pre>\n<p>It will not roll up one resource:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n&gt;&gt;&gt; needed.need(c1)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'c1.css' in library 'foo'&gt;]\n</pre>\n<p>Neither will it roll up two resources:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n&gt;&gt;&gt; needed.need(c1)\n&gt;&gt;&gt; needed.need(c2)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'c1.css' in library 'foo'&gt;,\n &lt;ResourceInclusion 'c2.css' in library 'foo'&gt;]\n</pre>\n<p>It will however roll up three resources:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n&gt;&gt;&gt; needed.need(c1)\n&gt;&gt;&gt; needed.need(c2)\n&gt;&gt;&gt; needed.need(c3)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'giantc.css' in library 'foo'&gt;]\n</pre>\n<p>The default behavior is to play it safe: we cannot be certain that we\ndo not include too much if we were to include <tt>giantc.css</tt> if only\nc1 and c2 are required. This is especially important with CSS\nlibraries: if only <tt>c1.css</tt> and <tt>c2.css</tt> are to be included in a\npage, including <tt>giantc.css</tt> is not appropriate as that also\nincludes the content of <tt>c3.css</tt>, which might override and extend\nthe behavior of <tt>c1.css</tt> and <tt>c2.css</tt>.</p>\n<p>The situation is sometimes different with Javascript libraries, which\ncan be written in such a way that a larger rollup will just include\nmore functions, but will not actually affect page behavior. If we have\na rollup resource that we don\u2019t mind kicking in even if part of the\nrequirements have been met, we can indicate this:</p>\n<pre>&gt;&gt;&gt; d1 = ResourceInclusion(foo, 'd1.js')\n&gt;&gt;&gt; d2 = ResourceInclusion(foo, 'd2.js')\n&gt;&gt;&gt; d3 = ResourceInclusion(foo, 'd3.js')\n&gt;&gt;&gt; giantd = ResourceInclusion(foo, 'giantd.js', supersedes=[d1, d2, d3],\n...            eager_superseder=True)\n</pre>\n<p>We will see <tt>giantd.js</tt> kick in even if we only require <tt>d1</tt> and\n<tt>d2</tt>:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n&gt;&gt;&gt; needed.need(d1)\n&gt;&gt;&gt; needed.need(d2)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'giantd.js' in library 'foo'&gt;]\n</pre>\n<p>In fact even if we only need a single resource the eager superseder will\nshow up instead:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n&gt;&gt;&gt; needed.need(d1)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'giantd.js' in library 'foo'&gt;]\n</pre>\n<p>If there are two potential eager superseders, the biggest one will\nbe taken:</p>\n<pre>&gt;&gt;&gt; d4 = ResourceInclusion(foo, 'd4.js')\n&gt;&gt;&gt; giantd_bigger = ResourceInclusion(foo, 'giantd-bigger.js',\n...   supersedes=[d1, d2, d3, d4], eager_superseder=True)\n&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n&gt;&gt;&gt; needed.need(d1)\n&gt;&gt;&gt; needed.need(d2)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'giantd-bigger.js' in library 'foo'&gt;]\n</pre>\n<p>If there is a potential non-eager superseder and an eager one, the eager one\nwill be taken:</p>\n<pre>&gt;&gt;&gt; giantd_noneager = ResourceInclusion(foo, 'giantd-noneager.js',\n...   supersedes=[d1, d2, d3, d4])\n&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n&gt;&gt;&gt; needed.need(d1)\n&gt;&gt;&gt; needed.need(d2)\n&gt;&gt;&gt; needed.need(d3)\n&gt;&gt;&gt; needed.need(d4)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'giantd-bigger.js' in library 'foo'&gt;]\n</pre>\n<p>A resource can be part of multiple rollups. In this case the rollup\nthat rolls up the most resources is used. So, if there are two\npotential non-eager superseders, the one that rolls up the most\nresources will be used:</p>\n<pre>&gt;&gt;&gt; e1 = ResourceInclusion(foo, 'e1.js')\n&gt;&gt;&gt; e2 = ResourceInclusion(foo, 'e2.js')\n&gt;&gt;&gt; e3 = ResourceInclusion(foo, 'e3.js')\n&gt;&gt;&gt; giante_two = ResourceInclusion(foo, 'giante-two.js',\n...   supersedes=[e1, e2])\n&gt;&gt;&gt; giante_three = ResourceInclusion(foo, 'giante-three.js',\n...   supersedes=[e1, e2, e3])\n&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n&gt;&gt;&gt; needed.need(e1)\n&gt;&gt;&gt; needed.need(e2)\n&gt;&gt;&gt; needed.need(e3)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'giante-three.js' in library 'foo'&gt;]\n</pre>\n<p>Consolidation also works with modes:</p>\n<pre>&gt;&gt;&gt; f1 = ResourceInclusion(foo, 'f1.js', debug='f1-debug.js')\n&gt;&gt;&gt; f2 = ResourceInclusion(foo, 'f2.js', debug='f2-debug.js')\n&gt;&gt;&gt; giantf = ResourceInclusion(foo, 'giantf.js', supersedes=[f1, f2],\n...                            debug='giantf-debug.js')\n\n&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n&gt;&gt;&gt; needed.need(f1)\n&gt;&gt;&gt; needed.need(f2)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'giantf.js' in library 'foo'&gt;]\n&gt;&gt;&gt; needed.mode('debug')\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'giantf-debug.js' in library 'foo'&gt;]\n</pre>\n<p>What if the rolled up resources have no mode but the superseding resource\ndoes? In this case the superseding resource\u2019s mode has no meaning, so\nmodes have no effect:</p>\n<pre>&gt;&gt;&gt; g1 = ResourceInclusion(foo, 'g1.js')\n&gt;&gt;&gt; g2 = ResourceInclusion(foo, 'g2.js')\n&gt;&gt;&gt; giantg = ResourceInclusion(foo, 'giantg.js', supersedes=[g1, g2],\n...                            debug='giantg-debug.js')\n&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n&gt;&gt;&gt; needed.need(g1)\n&gt;&gt;&gt; needed.need(g2)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'giantg.js' in library 'foo'&gt;]\n&gt;&gt;&gt; needed.mode('debug')\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'giantg.js' in library 'foo'&gt;]\n</pre>\n<p>What if the rolled up resources have a mode but the superseding resource\ndoes not? Let\u2019s look at that scenario:</p>\n<pre>&gt;&gt;&gt; h1 = ResourceInclusion(foo, 'h1.js', debug='h1-debug.js')\n&gt;&gt;&gt; h2 = ResourceInclusion(foo, 'h2.js', debug='h2-debug.js')\n&gt;&gt;&gt; gianth = ResourceInclusion(foo, 'gianth.js', supersedes=[h1, h2])\n&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.rollup()\n&gt;&gt;&gt; needed.need(h1)\n&gt;&gt;&gt; needed.need(h2)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'gianth.js' in library 'foo'&gt;]\n</pre>\n<p>Since there is no superseder for the debug mode, we will get the two\nresources, not rolled up:</p>\n<pre>&gt;&gt;&gt; needed.mode('debug')\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'h1-debug.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'h2-debug.js' in library 'foo'&gt;]\n</pre>\n</div>\n<div id=\"rendering-resources\">\n<h3>Rendering resources</h3>\n<p>Let\u2019s define some needed resource inclusions:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.need(y1)\n&gt;&gt;&gt; needed.inclusions() #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'b.css' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'c.js' in library 'foo'&gt;]\n</pre>\n<p>Now let\u2019s try to render these inclusions:</p>\n<pre>&gt;&gt;&gt; print needed.render()\nTraceback (most recent call last):\n  ...\nAttributeError: 'Plugin' object has no attribute 'get_library_url'\n</pre>\n<p>That didn\u2019t work. In order to render an inclusion, we need to tell\n<tt>hurry.resource</tt> how to get the URL for a resource inclusion. We\nalready know the relative URL, so we need to specify how to get a URL\nto the library itself that the relative URL can be added to.</p>\n<p>We\u2019ll extend the existing plugin that already knows how to obtain the\ncurrent needed inclusions. For the purposes of this document, we\ndefine a function that renders resources as some static URL on\nlocalhost:</p>\n<pre>&gt;&gt;&gt; class NewPlugin(Plugin):\n...   def get_library_url(self, library):\n...     return 'http://localhost/static/%s' % library.name\n</pre>\n<p>Let\u2019s register the plugin:</p>\n<pre>&gt;&gt;&gt; register_plugin(NewPlugin())\n</pre>\n<p>Rendering the inclusions now will result in the HTML fragments we\nneed to include on the top of our page (just under the <tt>&lt;head&gt;</tt> tag\nfor instance):</p>\n<pre>&gt;&gt;&gt; print needed.render()\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\n</pre>\n<p>Let\u2019s set this a currently needed inclusions:</p>\n<pre>&gt;&gt;&gt; request.needed = needed\n</pre>\n<p>There is a function available as well for rendering the resources for\nthe currently needed inclusion:</p>\n<pre>&gt;&gt;&gt; from hurry import resource\n&gt;&gt;&gt; print resource.render()\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\n</pre>\n</div>\n<div id=\"inserting-resources-in-html\">\n<h3>Inserting resources in HTML</h3>\n<p>When you have the HTML it can be convenient to have a way to insert\nresources directly into some HTML.</p>\n<p>The insertion system assumes a HTML text that has a <tt>&lt;head&gt;</tt> tag in it:</p>\n<pre>&gt;&gt;&gt; html = \"&lt;html&gt;&lt;head&gt;something more&lt;/head&gt;&lt;/html&gt;\"\n</pre>\n<p>To insert the resources directly in HTML we can use <tt>render_into_html</tt>\non <tt>needed</tt>:</p>\n<pre>&gt;&gt;&gt; print needed.render_into_html(html)\n&lt;html&gt;&lt;head&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\nsomething more&lt;/head&gt;&lt;/html&gt;\n</pre>\n<p>The top-level convenience function does this for the currently needed\nresources:</p>\n<pre>&gt;&gt;&gt; print resource.render_into_html(html)\n&lt;html&gt;&lt;head&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\nsomething more&lt;/head&gt;&lt;/html&gt;\n</pre>\n<p>See below for a way to insert into HTML when bottom fragments are\ninvolved.</p>\n</div>\n<div id=\"top-and-bottom-fragments\">\n<h3>Top and bottom fragments</h3>\n<p>It\u2019s also possible to render the resource inclusions into two\nfragments, some to be included just after the <tt>&lt;head&gt;</tt> tag, but some\nto be included at the very bottom of the HTML page, just before the\n<tt>&lt;/body&gt;</tt> tag. This is useful as it can <a href=\"http://developer.yahoo.com/performance/rules.html\" rel=\"nofollow\">speed up page load times</a>.</p>\n<p>Let\u2019s look at the same resources, now rendered separately into <tt>top</tt>\nand <tt>bottom</tt> fragments:</p>\n<pre>&gt;&gt;&gt; top, bottom = needed.render_topbottom()\n&gt;&gt;&gt; print top\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\n&gt;&gt;&gt; print bottom\n&lt;BLANKLINE&gt;\n</pre>\n<p>There is effectively no change; all the resources are still on the\ntop. We can enable bottom rendering by calling the <tt>bottom</tt> method before\nwe render:</p>\n<pre>&gt;&gt;&gt; needed.bottom()\n</pre>\n<p>Since none of the resources indicated it was safe to render them at\nthe bottom, even this explicit call will not result in any changes:</p>\n<pre>&gt;&gt;&gt; top, bottom = needed.render_topbottom()\n&gt;&gt;&gt; print top\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\n&gt;&gt;&gt; print bottom\n&lt;BLANKLINE&gt;\n</pre>\n<p><tt>bottom(force=True)</tt> will however force all javascript inclusions to be\nrendered in the bottom fragment:</p>\n<pre>&gt;&gt;&gt; needed.bottom(force=True)\n&gt;&gt;&gt; top, bottom = needed.render_topbottom()\n&gt;&gt;&gt; print top\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\n&gt;&gt;&gt; print bottom\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\n</pre>\n<p>Let\u2019s now introduce a javascript resource that says it is safe to be\nincluded on the bottom:</p>\n<pre>&gt;&gt;&gt; y2 = ResourceInclusion(foo, 'y2.js', bottom=True)\n</pre>\n<p>When we start over without <tt>bottom</tt> enabled, we get this resource\nshow up in the top fragment after all:</p>\n<pre>&gt;&gt;&gt; needed = NeededInclusions()\n&gt;&gt;&gt; needed.need(y1)\n&gt;&gt;&gt; needed.need(y2)\n\n&gt;&gt;&gt; top, bottom = needed.render_topbottom()\n&gt;&gt;&gt; print top\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/y2.js\"&gt;&lt;/script&gt;\n&gt;&gt;&gt; print bottom\n&lt;BLANKLINE&gt;\n</pre>\n<p>We now tell the system that it\u2019s safe to render inclusions at the bottom:</p>\n<pre>&gt;&gt;&gt; needed.bottom()\n</pre>\n<p>We now see the resource <tt>y2</tt> show up in the bottom fragment:</p>\n<pre>&gt;&gt;&gt; top, bottom = needed.render_topbottom()\n&gt;&gt;&gt; print top\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\n&gt;&gt;&gt; print bottom\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/y2.js\"&gt;&lt;/script&gt;\n</pre>\n<p>There\u2019s also a convenience function for the currently needed inclusion:</p>\n<pre>&gt;&gt;&gt; request.needed = needed\n&gt;&gt;&gt; top, bottom = resource.render_topbottom()\n&gt;&gt;&gt; print top\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\n&gt;&gt;&gt; print bottom\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/y2.js\"&gt;&lt;/script&gt;\n</pre>\n<p>When we force bottom rendering of Javascript, there is no effect of\nmaking a resource bottom-safe: all <tt>.js</tt> resources will be rendered\nat the bottom anyway:</p>\n<pre>&gt;&gt;&gt; needed.bottom(force=True)\n&gt;&gt;&gt; top, bottom = needed.render_topbottom()\n&gt;&gt;&gt; print top\n&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\n&gt;&gt;&gt; print bottom\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/y2.js\"&gt;&lt;/script&gt;\n</pre>\n<p>Note that if <tt>bottom</tt> is enabled, it makes no sense to have a\nresource inclusion <tt>b</tt> that depends on a resource inclusion <tt>a</tt>\nwhere <tt>a</tt> is bottom-safe and <tt>b</tt>, that depends on it, is not\nbottom-safe. In this case <tt>a</tt> would be included on the page at the\nbottom <em>after</em> <tt>b</tt> in the <tt>&lt;head&gt;</tt> section, and this might lead to\nordering problems. Likewise a rollup resource shouldn\u2019t combine\nresources where some are bottom-safe and others aren\u2019t.</p>\n<p>The system makes no sanity checks for misconfiguration of\nbottom-safety however; it could be the user simply never enables\n<tt>bottom</tt> mode at all and doesn\u2019t care about this issue. In this case\nthe user will want to write Javascript code that isn\u2019t safe to be\nincluded at the bottom of the page and still be able to depend on\nJavascript code that is.</p>\n</div>\n<div id=\"inserting-top-and-bottom-resources-in-html\">\n<h3>Inserting top and bottom resources in HTML</h3>\n<p>You can also insert top and bottom fragments into HTML. This assumes a\nHTML text that has a <tt>&lt;head&gt;</tt> tag in it as well as a <tt>&lt;/body&gt;</tt>\ntag:</p>\n<pre>&gt;&gt;&gt; html = \"&lt;html&gt;&lt;head&gt;rest of head&lt;/head&gt;&lt;body&gt;rest of body&lt;/body&gt;&lt;/html&gt;\"\n</pre>\n<p>To insert the resources directly in HTML we can use\n<tt>render_topbottom_into_html</tt> on <tt>needed</tt>:</p>\n<pre>&gt;&gt;&gt; print needed.render_topbottom_into_html(html)\n&lt;html&gt;&lt;head&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\nrest of head&lt;/head&gt;&lt;body&gt;rest of body&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/y2.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n</pre>\n<p>There\u2019s also a function available to do this for the currently needed\nresources:</p>\n<pre>&gt;&gt;&gt; print resource.render_topbottom_into_html(html)\n&lt;html&gt;&lt;head&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\nrest of head&lt;/head&gt;&lt;body&gt;rest of body&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/y2.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n</pre>\n</div>\n<div id=\"using-wsgi-middleware-to-insert-into-html\">\n<h3>Using WSGI middleware to insert into HTML</h3>\n<p>There is also a WSGI middleware available to insert the top (and bottom)\ninto the HTML. We are using WebOb to create a response object that will\nserve as our WSGI application.</p>\n<p>We create a simple WSGI application. In our application we declare that\nwe need a resource (<tt>y1</tt>) and put that in the WSGI <tt>environ</tt> under the\nkey <tt>hurry.resource.needed</tt>:</p>\n<pre>&gt;&gt;&gt; def app(environ, start_response):\n...    start_response('200 OK', [])\n...    needed = environ['hurry.resource.needed'] = NeededInclusions()\n...    needed.need(y1)\n...    return ['&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&lt;/body&gt;&lt;/html&gt;']\n</pre>\n<p>We now wrap this in our middleware, so that the middleware is activated:</p>\n<pre>&gt;&gt;&gt; from hurry.resource.wsgi import Middleware\n&gt;&gt;&gt; wrapped_app = Middleware(app)\n</pre>\n<p>Now we make a request (using webob for convenience):</p>\n<pre>&gt;&gt;&gt; import webob\n&gt;&gt;&gt; req = webob.Request.blank('/')\n&gt;&gt;&gt; res = req.get_response(wrapped_app)\n</pre>\n<p>We can now see that the resources are added to the HTML by the middleware:</p>\n<pre>&gt;&gt;&gt; print res.body\n&lt;html&gt;&lt;head&gt;\n    &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://localhost/static/foo/b.css\" /&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/a.js\"&gt;&lt;/script&gt;\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/c.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;&lt;body&lt;/body&gt;&lt;/html&gt;\n</pre>\n<p>When we set the response Content-Type to non-HTML, the middleware\nwon\u2019t be active even if we need things and the body appears to contain\nHTML:</p>\n<pre>&gt;&gt;&gt; def app(environ, start_response):\n...    start_response('200 OK', [('Content-Type', 'text/plain')])\n...    needed = environ['hurry.resource.needed'] = NeededInclusions()\n...    needed.need(y1)\n...    return ['&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&lt;/body&gt;&lt;/html&gt;']\n&gt;&gt;&gt; wrapped_app = Middleware(app)\n&gt;&gt;&gt; req = webob.Request.blank('/')\n&gt;&gt;&gt; res = req.get_response(wrapped_app)\n&gt;&gt;&gt; res.body\n'&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&lt;/body&gt;&lt;/html&gt;'\n</pre>\n</div>\n<div id=\"bottom-convenience\">\n<h3>bottom convenience</h3>\n<p>Like for <tt>need</tt> and <tt>mode</tt>, there is also a convenience spelling for\n<tt>bottom</tt>:</p>\n<pre>&gt;&gt;&gt; request = Request()\n&gt;&gt;&gt; l1 = ResourceInclusion(foo, 'l1.js', bottom=True)\n&gt;&gt;&gt; l1.need()\n</pre>\n<p>Let\u2019s look at the resources needed by default:</p>\n<pre>&gt;&gt;&gt; c = get_current_needed_inclusions()\n&gt;&gt;&gt; top, bottom = c.render_topbottom()\n&gt;&gt;&gt; print top\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/l1.js\"&gt;&lt;/script&gt;\n&gt;&gt;&gt; print bottom\n&lt;BLANKLINE&gt;\n</pre>\n<p>Let\u2019s now change the bottom mode using the convenience\n<tt>hurry.resource.bottom</tt> spelling:</p>\n<pre>&gt;&gt;&gt; from hurry.resource import bottom\n&gt;&gt;&gt; bottom()\n</pre>\n<p>Re-rendering will show it\u2019s honoring the bottom setting:</p>\n<pre>&gt;&gt;&gt; top, bottom = c.render_topbottom()\n&gt;&gt;&gt; print top\n&lt;BLANKLINE&gt;\n&gt;&gt;&gt; print bottom\n&lt;script type=\"text/javascript\" src=\"http://localhost/static/foo/l1.js\"&gt;&lt;/script&gt;\n</pre>\n</div>\n<div id=\"generating-resource-code\">\n<h3>Generating resource code</h3>\n<p>Sometimes it is useful to generate code that expresses a complex\nresource dependency structure. One example of that is in\n<tt>hurry.yui</tt>. We can use the <tt>generate_code</tt> function to render resource\ninclusions:</p>\n<pre>&gt;&gt;&gt; i1 = ResourceInclusion(foo, 'i1.js')\n&gt;&gt;&gt; i2 = ResourceInclusion(foo, 'i2.js', depends=[i1])\n&gt;&gt;&gt; i3 = ResourceInclusion(foo, 'i3.js', depends=[i2])\n&gt;&gt;&gt; i4 = ResourceInclusion(foo, 'i4.js', depends=[i1])\n&gt;&gt;&gt; i5 = ResourceInclusion(foo, 'i5.js', depends=[i4, i3])\n\n&gt;&gt;&gt; from hurry.resource import generate_code\n&gt;&gt;&gt; print generate_code(i1=i1, i2=i2, i3=i3, i4=i4, i5=i5)\nfrom hurry.resource import Library, ResourceInclusion\n&lt;BLANKLINE&gt;\nfoo = Library('foo', 'dummy')\n&lt;BLANKLINE&gt;\ni1 = ResourceInclusion(foo, 'i1.js')\ni2 = ResourceInclusion(foo, 'i2.js', depends=[i1])\ni3 = ResourceInclusion(foo, 'i3.js', depends=[i2])\ni4 = ResourceInclusion(foo, 'i4.js', depends=[i1])\ni5 = ResourceInclusion(foo, 'i5.js', depends=[i4, i3])\n</pre>\n<p>Let\u2019s look at a more complicated example with modes and superseders:</p>\n<pre>&gt;&gt;&gt; j1 = ResourceInclusion(foo, 'j1.js', debug='j1-debug.js')\n&gt;&gt;&gt; j2 = ResourceInclusion(foo, 'j2.js', debug='j2-debug.js')\n&gt;&gt;&gt; giantj = ResourceInclusion(foo, 'giantj.js', supersedes=[j1, j2],\n...                            debug='giantj-debug.js')\n\n&gt;&gt;&gt; print generate_code(j1=j1, j2=j2, giantj=giantj)\nfrom hurry.resource import Library, ResourceInclusion\n&lt;BLANKLINE&gt;\nfoo = Library('foo', 'dummy')\n&lt;BLANKLINE&gt;\nj1 = ResourceInclusion(foo, 'j1.js', debug='j1-debug.js')\nj2 = ResourceInclusion(foo, 'j2.js', debug='j2-debug.js')\ngiantj = ResourceInclusion(foo, 'giantj.js', supersedes=[j1, j2], debug='giantj-debug.js')\n</pre>\n<p>We can control the name the inclusion will get in the source code by\nusing keyword parameters:</p>\n<pre>&gt;&gt;&gt; print generate_code(hoi=i1)\nfrom hurry.resource import Library, ResourceInclusion\n&lt;BLANKLINE&gt;\nfoo = Library('foo', 'dummy')\n&lt;BLANKLINE&gt;\nhoi = ResourceInclusion(foo, 'i1.js')\n\n&gt;&gt;&gt; print generate_code(hoi=i1, i2=i2)\nfrom hurry.resource import Library, ResourceInclusion\n&lt;BLANKLINE&gt;\nfoo = Library('foo', 'dummy')\n&lt;BLANKLINE&gt;\nhoi = ResourceInclusion(foo, 'i1.js')\ni2 = ResourceInclusion(foo, 'i2.js', depends=[hoi])\n</pre>\n</div>\n<div id=\"sorting-inclusions-by-dependency\">\n<h3>Sorting inclusions by dependency</h3>\n<p>This is more a footnote than something that you should be concerned\nabout. In case assumptions in this library are wrong or there are\nother reasons you would like to sort resource inclusions that come in\nsome arbitrary order into one where the dependency relation makes\nsense, you can use <tt>sort_inclusions_topological</tt>:</p>\n<pre>&gt;&gt;&gt; from hurry.resource import sort_inclusions_topological\n</pre>\n<p>Let\u2019s make a list of resource inclusions not sorted by dependency:</p>\n<pre>&gt;&gt;&gt; i = [a5, a3, a1, a2, a4]\n&gt;&gt;&gt; sort_inclusions_topological(i) #doctest: +NORMALIZE_WHITESPACE\n[&lt;ResourceInclusion 'a1.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a4.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a2.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a3.js' in library 'foo'&gt;,\n &lt;ResourceInclusion 'a5.js' in library 'foo'&gt;]\n</pre>\n</div>\n<div id=\"inclusion-renderers\">\n<h3>Inclusion renderers</h3>\n<p>The HTML fragments for inclusions are rendered by <tt>inclusion renderers</tt>\nthat are simple functions registered per extension.</p>\n<p>Renderers are registered in the <tt>inclusion_renderers</tt> dictionary:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from hurry.resource.core import inclusion_renderers\n&gt;&gt;&gt; sorted(inclusion_renderers)\n['.css', '.js', '.kss']\n</pre>\n</blockquote>\n<p>Renderers render HTML fragments using given resource URL:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; inclusion_renderers['.js']('http://localhost/script.js')\n'&lt;script type=\"text/javascript\" src=\"http://localhost/script.js\"&gt;&lt;/script&gt;'\n</pre>\n</blockquote>\n<p>Let\u2019s create an inclusion of unknown resource:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; a6 = ResourceInclusion(foo, 'nothing.unknown')\n</pre>\n<pre>&gt;&gt;&gt; from hurry.resource.core import render_inclusions\n&gt;&gt;&gt; render_inclusions([a6]) #doctest: +NORMALIZE_WHITESPACE +ELLIPSIS\nTraceback (most recent call last):\n...\nUnknownResourceExtension: Unknown resource extension .unknown for resource\n                          inclusion: &lt;ResourceInclusion 'nothing.unknown'\n                          in library 'foo'&gt;\n</pre>\n</blockquote>\n<p>Now let\u2019s add a renderer for our \u201c.unknown\u201d extension and try again:</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def render_unknown(url):\n...     return '&lt;link rel=\"unknown\" href=\"%s\" /&gt;' % url\n&gt;&gt;&gt; inclusion_renderers['.unknown'] = render_unknown\n</pre>\n<pre>&gt;&gt;&gt; render_inclusions([a6])\n'&lt;link rel=\"unknown\" href=\"http://localhost/static/foo/nothing.unknown\" /&gt;'\n</pre>\n</blockquote>\n</div>\n</div>\n<div id=\"changes\">\n<h2>CHANGES</h2>\n<div>\n<p>Important</p>\n<p>hurry.resource has been superseded by the\n<a href=\"http://fanstatic.org\" rel=\"nofollow\">Fanstatic</a> project!</p>\n</div>\n<div id=\"id2\">\n<h3>0.10 (2010-07-24)</h3>\n<ul>\n<li><p>The WSGI Middleware depends on WebOb, which is an optional\ndependency. Don\u2019t expose it into the <tt>__init__.py</tt> therefore, as\nthat needs to be independent of WebOb. To use the middleware import\nit directly from <tt>hurry.resource.wsgi</tt>.</p>\n</li>\n<li><p>The <tt>Library</tt> factory now has to be called with a rootpath\nargument as the second argument. This is a path to the actual\nresource directory that the library represents, relative to the\ndirectory of the package. This is needed to make `` hurry.resource``\nuseful for frameworks not based on <tt>zope.configuration</tt>.</p>\n<p>This breaks backwards compatibility with previous versions of\n<tt>hurry.resource</tt>; all code that uses <tt>Library</tt> should be\nadjusted. Please also update their <tt>setup.py</tt> to depend on\n<tt>hurry.resource &gt;= 0.10</tt>.</p>\n</li>\n<li><p>Packages should register their <tt>Library</tt> instances with\n<tt>hurry.resource</tt> using the <tt>hurry.resource.libraries</tt> entry\npoint.</p>\n</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>0.9 (2010-07-13)</h3>\n<ul>\n<li><p>WSGI support: <tt>hurry.resource.Middleware</tt> can be used to wrap WSGI\napplications. If the application supplies a <tt>NeededInclusions</tt>\nobject in <tt>environ</tt> with the key <tt>hurry.resource.needed</tt>, the\nmiddleware will pick up on this and insert the needed inclusions.</p>\n<p>The WebOb library is needed to make this work and depending on\n<tt>hurry.resource [wsgi]</tt> will pull in the required dependency.</p>\n</li>\n<li><p>Fixed some typos in README.txt.</p>\n</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>0.4.1 (2009-12-16)</h3>\n<ul>\n<li>Fix restructured text.</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3>0.4 (2009-12-16)</h3>\n<ul>\n<li>Expose a <tt>GroupInclusion</tt> that only exists to depend on other\ninclusions. This way it becomes possible to expose a set of\ndifferent resources together without there being a central resource\nthat depends on them. The GroupInclusion itself is therefore not\nrendered.</li>\n<li>Create <tt>render_into_html</tt> and <tt>render_topbottom_into_html</tt>\nfunctionality, which insert the rendered inclusions into HTML.</li>\n<li>Expose <tt>render</tt>, <tt>render_into_html</tt>, <tt>render_topbottom</tt> and\n<tt>render_topbottom_into_html</tt> as top-level functions in\n<tt>hurry.resource</tt>.</li>\n<li>Fix NameError when trying to render an inclusion with unknown extension.</li>\n<li>Document inclusion renderers mechanism in the README.txt.</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3>0.3 (2008-10-15)</h3>\n<div id=\"features-added\">\n<h4>Features added</h4>\n<ul>\n<li>Consolidating resources into rollups is now disabled by\ndefault. This is to help developers with debugging; rollups are\ntypically minified for optimization purposes, and libraries such as\nYUI do not offer rollups in non-minified form. Since rollups must\nnow be explicitly enabled by the application developer\n(<tt>hurry.resource.rollup()</tt>), an application developer who needs to\ndebug can choose not to call it (or call\n<tt>hurry.resource.rollup(disable=True</tt>).</li>\n<li>Added an optimization section to the documentation.</li>\n<li>Added some more details about how modes are expected to be used to\nthe documentation.</li>\n</ul>\n</div>\n<div id=\"bug-fixes\">\n<h4>Bug fixes</h4>\n<ul>\n<li><tt>hurry.resource.bottom</tt> now takes a second optional <tt>disable</tt>\nparameter.</li>\n</ul>\n</div>\n</div>\n<div id=\"id7\">\n<h3>0.2 (2008-10-13)</h3>\n<ul>\n<li>Changed the API to set the mode. Instead of passing it to <tt>render</tt>\nand <tt>inclusions</tt>, the requested mode can be set with the <tt>mode</tt>\nmethod on <tt>INeededInclusions</tt>. For convenience there is a <tt>mode</tt>\nfunction as well that can be imported directly from\n<tt>hurry.resource</tt> that sets the mode for the current needed\ninclusions.</li>\n<li>Added support for rendering resources into two fragments, one to\nbe included at the top of the HTML page in the <tt>&lt;head&gt;</tt> section,\nthe other to be included just before the <tt>&lt;/body&gt;</tt> section. In\nsome circumstances doing this can <a href=\"http://developer.yahoo.net/blog/archives/2007/07/high_performanc_5.html\" rel=\"nofollow\">speed up page load time</a>.</li>\n</ul>\n</div>\n<div id=\"id8\">\n<h3>0.1 (2008-10-07)</h3>\n<ul>\n<li>Initial public release.</li>\n</ul>\n</div>\n</div>\n<div id=\"download\">\n<h2>Download</h2>\n</div>\n\n          </div>"}, "last_serial": 793131, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "3446bd6219a01dffb965bd511e185540", "sha256": "d722bd836131f23d62f45859ca2ba6c8adb46584c5f9fb33dddc7a6cf656ce46"}, "downloads": -1, "filename": "hurry.resource-0.1.tar.gz", "has_sig": false, "md5_digest": "3446bd6219a01dffb965bd511e185540", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21316, "upload_time": "2008-10-07T15:41:25", "upload_time_iso_8601": "2008-10-07T15:41:25Z", "url": "https://files.pythonhosted.org/packages/aa/98/ce9e83b43d37a406964b6a0afd3259101b88553f20a7090e1cbfef18960a/hurry.resource-0.1.tar.gz", "yanked": false}], "0.10": [{"comment_text": "", "digests": {"md5": "0187bee8cbb72f30d73ccf54446e3137", "sha256": "bb9690b11ab9b4f814f04503b24e75587160138008be0a927326e8cea249d3b7"}, "downloads": -1, "filename": "hurry.resource-0.10.tar.gz", "has_sig": false, "md5_digest": "0187bee8cbb72f30d73ccf54446e3137", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42650, "upload_time": "2010-07-24T18:13:58", "upload_time_iso_8601": "2010-07-24T18:13:58.629179Z", "url": "https://files.pythonhosted.org/packages/e3/54/703c36d94eddac4227c86ae1559db59c45129fe58867136944999ddd5661/hurry.resource-0.10.tar.gz", "yanked": false}], "0.2": [{"comment_text": "", "digests": {"md5": "958d546262ef55b91a80f88cb81da3d3", "sha256": "03cb6cab71d43636207e48e7b366ac724d3d4774e8f79b6e41971a4dcd480190"}, "downloads": -1, "filename": "hurry.resource-0.2.tar.gz", "has_sig": false, "md5_digest": "958d546262ef55b91a80f88cb81da3d3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26737, "upload_time": "2008-10-13T19:52:20", "upload_time_iso_8601": "2008-10-13T19:52:20Z", "url": "https://files.pythonhosted.org/packages/e6/b6/2d9643bfe7dc87eec24049cf213b0ad64df171a581bc90f06e591e73aaab/hurry.resource-0.2.tar.gz", "yanked": false}], "0.3": [{"comment_text": "", "digests": {"md5": "fbe1cb31608bad1c2aee63f4910db6cb", "sha256": "60ef6fad302135bbf9fad169be7db571f21e960db45c9f81220d360f55aa2a7c"}, "downloads": -1, "filename": "hurry.resource-0.3.tar.gz", "has_sig": false, "md5_digest": "fbe1cb31608bad1c2aee63f4910db6cb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30796, "upload_time": "2008-10-15T17:26:14", "upload_time_iso_8601": "2008-10-15T17:26:14Z", "url": "https://files.pythonhosted.org/packages/d7/82/54fcd5dd9474fa8f8b930029ea58598002f02717fbad027054b6c91961e3/hurry.resource-0.3.tar.gz", "yanked": false}], "0.4": [], "0.4.1": [{"comment_text": "", "digests": {"md5": "410158acccf162bce0583468c4b0a1fa", "sha256": "310d06bd204c4dd29559e7495edc81d72a95a64109ee8103b4e4102e0e5e2730"}, "downloads": -1, "filename": "hurry.resource-0.4.1.tar.gz", "has_sig": false, "md5_digest": "410158acccf162bce0583468c4b0a1fa", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 36062, "upload_time": "2009-12-16T18:39:58", "upload_time_iso_8601": "2009-12-16T18:39:58.847559Z", "url": "https://files.pythonhosted.org/packages/b8/0b/31444bc3f6170496673926b26680394ce8858c3f2c81f1f527da663a2980/hurry.resource-0.4.1.tar.gz", "yanked": false}], "0.9": [{"comment_text": "", "digests": {"md5": "75bf27ce09c574d32b5ad341c46c8926", "sha256": "388f415c9131788c71e869cc2747d1db58f2324640e17e72d447dac5475620d1"}, "downloads": -1, "filename": "hurry.resource-0.9.tar.gz", "has_sig": false, "md5_digest": "75bf27ce09c574d32b5ad341c46c8926", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 40356, "upload_time": "2010-07-13T17:38:26", "upload_time_iso_8601": "2010-07-13T17:38:26.132083Z", "url": "https://files.pythonhosted.org/packages/cc/47/07ce867631e506893d93d8aff8145ea27bbb38ead0b5745029a1fe38e1ba/hurry.resource-0.9.tar.gz", "yanked": false}], "0.9.1": [{"comment_text": "", "digests": {"md5": "ba069d277e024c58defe4b3a85bcb30f", "sha256": "f9c005d3c9d06aaf0a45aa795f89b8b24a36ecfe57131d7922ddb2ba7de71e69"}, "downloads": -1, "filename": "hurry.resource-0.9.1.tar.gz", "has_sig": false, "md5_digest": "ba069d277e024c58defe4b3a85bcb30f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 41116, "upload_time": "2011-02-15T10:54:28", "upload_time_iso_8601": "2011-02-15T10:54:28.988549Z", "url": "https://files.pythonhosted.org/packages/09/20/a09ab6d0ad0dd60d26d5432a906470135c238619e4589512ec4974562b56/hurry.resource-0.9.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0187bee8cbb72f30d73ccf54446e3137", "sha256": "bb9690b11ab9b4f814f04503b24e75587160138008be0a927326e8cea249d3b7"}, "downloads": -1, "filename": "hurry.resource-0.10.tar.gz", "has_sig": false, "md5_digest": "0187bee8cbb72f30d73ccf54446e3137", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 42650, "upload_time": "2010-07-24T18:13:58", "upload_time_iso_8601": "2010-07-24T18:13:58.629179Z", "url": "https://files.pythonhosted.org/packages/e3/54/703c36d94eddac4227c86ae1559db59c45129fe58867136944999ddd5661/hurry.resource-0.10.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:49:45 2020"}