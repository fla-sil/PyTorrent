{"info": {"author": "Nikolay Stanchev", "author_email": "nikist97.ns@gmail.com", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: Apache Software License", "Programming Language :: Python :: 3", "Topic :: Software Development :: Libraries :: Python Modules"], "description": "# Abstract and Tree-like Data Structures - Python\n\n**_The repository contains Python-based implementations for popular data structures._**\n\n### Installation:\nPlease use 'pip install pythonic-data-structures'.\n\n### Issues:\nPlease register any issues you find in the github repository so that they can be fixed as soon as possible.\n\n### Requirements:\nThere are no dependencies on external libraries. However, a Python 3.x version is required.\n\n### Docs:\n_Navigate to data structures:_ [Stack](#stack), [Queue](#queue), [Min Binary Heap](#minbh), \n[Max Binary Heap](#maxbh), [Priority Queue](#pq), [Duplicate Priority Queue](#dpq), [Graph](#graph)\n<br><br>\n\n\n### Data Structures\n\n**_Implementation for Stack, Queue, Max Binary Heap, Min Binary Heap, Priority Queue and Graph in Python_** <br>\n**These are located in the AbstractDataStructures.py and TreeDataStructures.py modules** <br><br>\n\n- **_Stack<a name=\"stack\"></a> (First-In-Last-Out)_** <br>\nThe Stack's implementation wraps around the python deque object, but is also generic: you can specify the type of elements \nin the stack in the constructor. If not specified, it is set to None and elements of any type can be added to the stack. The\nimplementation includes all the common operations of a stack: peek, push, pop, size, etc.<br>\n\n_API_ :\n```python\nfrom DataStructures.AbstractDataStructures import Stack # import the stack data structure\n\nstack = Stack() # type is set to None, items of any types can be added\nstack = Stack(elements_type = int) # type is set to int, hence only integers can be pushed\n\nstack.size # the number of elements in the stack\nlen(stack) # same as stack.size\n\nstr(stack) # returns the string representation of the python deque object containing the elements of the stack\n\nitem = \"test_item\"\nstack.contains(item) # returns True if the item is in the stack and False otherwise\n# contains raises a StackTypeError if the type of the stack is not None and is different than the type of the parameter\nboolean = item in stack \n# same as boolean = stack.contains(item)\n\nstack.type # returns the type of the elements in the stack, None if no type is specified when initialised\n\nstack.peek() # returns the last element that was added to the stack, but doesn't remove it\n# peek returns None if there are no elements in the stack\n\nstack.pop() # same as peek(), but removes the last element that was added to the stack\n# pop raises an EmptyStackError if there are no elements in the stack\n\nelement = \"test_item\"\nstack.push(element) # pushes the element to the top of the stack\n# push raises a StackTypeError if the stack has a specified type for elements and the argument is not of that type\n\n# the implementation includes an iterator\nfor element in stack:\n    print(element)\n# keep in mind that the iterator uses stack.pop() to get the next element, hence\n# after the iteration is over the stack would be empty\n\nstack.remove(element) # removes the element from the stack\n# raises a StackTypeError if the stack has a specified type for elements and the argument is not of that type\n# raises a StackElementError if the stack doesn't contain the element specified as argument\n```\n\n<br> <br>\n\n- **_Queue<a name=\"queue\"></a> (First-In-First-Out)_** <br>\nThe Queue's implementation wraps around the python deque object, but is also generic: you can specify the type of elements in the queue in the constructor.\nIf not specified, it is set to None and elements of any type can be added to the queue. The\nimplementation includes all the common operations of a queue: enqueue, dequeue, peek, size, etc.<br>\n\n_API_ :\n```python\nfrom DataStructures.AbstractDataStructures import Queue # import the queue data structure\nqueue = Queue() # type is set to None, items of any types can be added\nqueue = Queue(elements_type = str) # type is set to str, hence only strings can be enqueued\n\nqueue.size # the number of elements in the queue\nlen(queue) # same as queue.size\n\nstr(queue) # returns the string representation of the python deque object containing the elements of the queue\n\nitem = \"test_item\"\nqueue.contains(item) # returns True if the item is in the queue and False otherwise\n# contains raises a QueueTypeError if the type of the queue is not None and is different \n# than the type of the parameter\nboolean = item in queue \n# same as boolean = queue.contains(item)\n\nqueue.type # the type of the elements in the queue, None if no type is specified when initialised\n\nqueue.peek() # returns the first element that was added to the queue, but doesn't remove it\n# peek returns None if there are no elements in the queue\n\nqueue.dequeue() # same as peek(), but removes the first element that was added to the queue\n# dequeue raises a EmptyQueueError if there are no elements in the queue\n\nelement = \"test_element\"\nqueue.enqueue(element) # enqueues the element to the back of the queue\n# enqueue raises a QueueTypeError if the queue has a specified type for elements\n# and the argument is not of that type\n\n# the implementation includes an iterator\nfor element in queue:\n    print(element)\n# keep in mind that the iterator uses queue.dequeue() to get the next element, hence\n# after the iteration is over the queue would be empty\n\nqueue.remove(element) # removes the element from the queue\n# raises a QueueTypeError if the queue has a specified type for elements and the argument is not of that type\n# raises a QueueElementError if the queue doesn't contain the element specified as argument\n```\n\n\n<br> <br>\n\n\n- **_BinaryHeap_** <br>\nThe BinaryHeap's implementation is generic: you can specify the type of elements in the heap in the constructor. If not \nspecified, it is set to int, hence only integers can be added to the heap. The BinaryHeap class is abstract. You cannot \ninstantiate it. The implementation includes two types of heaps, which you can use: MinBinaryHeap and MaxBinaryHeap.\n<br>\n\n**MinBinaryHeap** - a heap with its root being the minimum element <br>\nMinBinaryHeap implements the common operations of a heap: add, replace_root, remove_min, peek_min, size, etc.\n\n<br>\n\n**MaxBinaryHeap** - a heap with its root being the maximum element <br>\nMaxBinaryHeap implements the common operations of a heap: add, replace_root, remove_max, peek_max, size, etc.\n\n<br>\n\nMinBinaryHeap<a name=\"minbh\"></a> _API_ : \n```python\nfrom DataStructures.AbstractDataStructures import MinBinaryHeap # import the min heap\n\nmin_heap = MinBinaryHeap() # type is set to default - int, hence only integers can be added\n# creates an empty heap\n\nmin_heap = MinBinaryHeap(str) # type is set to str, hence only strings can be added\n# creates an empty heap\n\nmin_heap.size # the number of elements in the heap\nlen(min_heap) # same as min_heap.size\n\nstr(min_heap) # returns a string of the list of elements in the heap\n\nmin_heap.type # the type of elements in the heap\n\nelement = \"test_element\"\nmin_heap.add(element) # adds the element to the min binary heap on the place it should be located\n# add raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap\n\nmin_heap.peek_min() # returns the minimum element (the root), but doesn't remove it from the heap\n# returns None if heap is empty\n\nmin_heap.remove_min() # returns the minimum element (the root) and removes it from the heap\n# the method replaces the root with the second minimum element in the heap\n# it raises a EmptyBinaryHeapError if the heap is empty\n\n# returns the minimum element (the root) and removes it from the heap, by replacing it with the element argument\nmin_heap.replace_root(element) \n# same as min_heap.remove_min() followed by min_heap.add(element), but replace_root() is faster\n# raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap\n# raises a EmptyBinaryHeapError if the heap is empty\n\nmin_heap.get_sorted_elements() # returns a list with the sorted elements from the heap, the heap remains unchanged\n# the order is ascending; returns an empty list if the heap is empty\n\n# the iterator goes through each element in the heap in ascending order\nfor element in min_heap:\n    print(element)\n# keep in mind that using the iterator will remove each element you go through from the heap, since it uses remove_min()\n# to generate the next element, hence when the iterator is finished the heap would be empty;\n# if you want to keep the elements in the heap, use get_sorted_elements() (although it's slightly slower)\n\n# another example with the iterator\nheap_iter = iter(min_heap)\nwhile True:\n    try:\n        print(next(heap_iter))\n    except StopIteration:\n        break\nmin_heap.size # will return 0 after iteration is finished, as explained above\n\nold_element, new_element = 10, 100\nmin_heap.replace(old_element, new_element) # replaces the old element with the new element and readjusts the heap after\n# the replacement\n# raises a BinaryHeapTypeError if the type of the first or the second argument is not the same as the type of the \n# elements in the heap\n# raises a BinaryHeapElementError if the old_element argument is not contained in the heap\n# raises a EmptyBinaryHeapError if the heap is empty\n\nmin_heap.remove(element)  # removes the element and readjusts the heap after deletion\n# raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap\n# raises a BinaryHeapElementError if the element argument is not contained in the heap\n# raises a EmptyBinaryHeapError if the heap is empty\n```\n\n<br>\n\nMaxBinaryHeap<a name=\"maxbh\"></a> _API_:\n```python\nfrom DataStructures.AbstractDataStructures import MaxBinaryHeap # import the max heap\n\nmax_heap = MaxBinaryHeap() # type is set to default - int, hence only integers can be added\n# creates an empty heap\n\nmax_heap = MaxBinaryHeap(str) # type is set to str, hence only strings can be added\n# creates an empty heap\n\nmax_heap.size # the number of elements in the heap\nlen(max_heap) # same as max_heap.size\n\nstr(max_heap) # returns a string of the list of elements in the heap\n\nmax_heap.type # the type of elements in the heap\n\nelement = \"test_element\"\nmax_heap.add(element) # adds the element to the max binary heap on the place it should be located\n# add raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap\n\nmax_heap.peek_max() # returns the maximum element (the root), but doesn't remove it from the heap\n# returns None if heap is empty\n\nmax_heap.remove_max() # returns the maximum element (the root) and removes it from the heap\n# the method replaces the root with the second maximum element in the heap\n# it raises a EmptyBinaryHeapError if the heap is empty\n\n# returns the maximum element (the root) and removes it from the heap, by replacing it with the element argument\nmax_heap.replace_root(element) \n# same as max_heap.remove_max() followed by max_heap.add(element), but replace_root() is faster\n# raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap\n# raises a EmptyBinaryHeapError if the heap is empty\n\nmax_heap.get_sorted_elements() # returns a list with the sorted elements from the heap, the heap remains unchanged\n# the order is descending; returns an empty list if the heap is empty\n\n# the iterator goes through each element in the heap in descending order\nfor element in max_heap:\n    print(element)\n# keep in mind that using the iterator will remove each element you go through from the heap, since it uses remove_max()\n# to generate the next element, hence when the iterator is finished the heap would be empty;\n# if you want to keep the elements in the heap, use get_sorted_elements() (although it's slightly slower)\n\n# another example with the iterator\nheap_iter = iter(max_heap)\nwhile True:\n    try:\n        print(next(heap_iter))\n    except StopIteration:\n        break\nmax_heap.size # will return 0 after iteration is finished, as explained above\n\nold_element, new_element = 10, 100\nmax_heap.replace(old_element, new_element) # replaces the old element with the new element and readjusts the heap after\n# the replacement\n# raises a BinaryHeapTypeError if the type of the first or the second argument is not the same as the type of the \n# elements in the heap\n# raises a BinaryHeapElementError if the old_element argument is not contained in the heap\n# raises a EmptyBinaryHeapError if the heap is empty\n\nmax_heap.remove(element)  # removes the element and readjusts the heap after deletion\n# raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap\n# raises a BinaryHeapElementError if the element argument is not contained in the heap\n# raises a EmptyBinaryHeapError if the heap is empty\n```\n\n\n<br> <br>\n\n- **_Priority Queue<a name=\"pq\"></a>_** <br>\nThe Priority Queue's implementation is generic: you can specify the type of elements in the queue in the constructor. \nIf not specified, it is set to None, hence objects of all types can be added to the priority queue. You can also set the reverse\nargument in the constructor. If reverse is set to False (default) the queue dequeues the element with the greatest priority, \nelse if the reverse argument is set to True - it dequeues the element with the lowest priority. The implementation includes \nall the common operations of a priority queue: enqueue, dequeue, peek, size, etc.<br>\n\n_API_ :\n```python\nfrom DataStructures.AbstractDataStructures import PriorityQueue # import the priority queue data structure\n\npriority_queue = PriorityQueue() # type is set to default None, hence objects of all types can be enqueued to the queue\n# the reverse argument is set to default False, hence dequeue returns the element with the highest priority\n\npriority_queue = PriorityQueue(elements_type=str, reverse=True) # type is set to str, hence only strings can be enqueued\n# the reverse argument is set to True, hence dequeue returns the element with the lowest priority\n\npriority_queue.size # the number of elements in the queue\nlen(priority_queue) # same as priority_queue.size\n\n\nstr(priority_queue) # returns a string of the dictionary linking priorities with elements in the queue\n\npriority_queue.type # the type of elements that can be enqueued in the priority queue\n# if this method returns None, objects of all types can be enqueued\n\npriority_queue.reversed # True if the queue dequeues the element with the lowest priority\n# returns False if the queue dequeues the element with the highest priority\n\npriority = 10\npriority_queue.contains_priority(priority) # returns True if the queue has an element linked to the given priority and False otherwise\n# contains raises a PriorityQueueTypeError if type of priority is not int\n\nelement = \"test_element\"\npriority_queue.contains_element(element) # returns True if an element is contained in the queue\n# raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given element\nboolean = element in priority_queue # same as priority_queue.contains_element(element)\n\nitem = \"test_item\"\npriority_queue.enqueue(item, priority) # enqueues the given item and links it the given priority\n# raises PriorityQueueTypeError if type(priority) is not int\n# raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given item\n# keep in mind that if there is another element linked to the same priority, the old element will be replaced\n# by the new element\npriority_queue.enqueue(\"first_item\", 5)\npriority_queue.enqueue(\"second_item\", 5)\n# doing this will link priority 5 to str object \"second_item\" while str object \"first_item\" will be ignored and \n# removed from the queue\n# Another thing to note is that you can enqueue the same element to different priorities\npriority_queue.enqueue(\"item\", 10)\npriority_queue.enqueue(\"item\", 11)\n\npriority_queue.peek() # returns element with minimum or maximum priority in the queue, but doesn't remove it from the queue\n# if priority_queue.reversed is False, it returns the element with the maximum priority\n# if priority_queue.reversed is True, it returns the element with the minimum priority\n# returns None if the queue is empty\n\npriority_queue.dequeue() # same as priority_queue.peek(), but removes the returned element from the queue\n# raises a EmptyPriorityQueueError if the queue is empty \n\npriority_queue.get_element(priority) # returns the element linked to the given priority\n# returns None if no element is linked to this priority\n# raises a PriorityQueueTypeError if type(priority) is not int\n\n# the implementation includes an iterator too\nfor item in priority_queue:\n    print(item)\n# keep in mind that the iterator uses priority_queue.dequeue() to get the next element, hence after the iteration \n# is finished the priority_queue will be empty\n\npriority_queue.replace_priority(element, priority) # replaces the given element's priority with the new priority argument\n# returns a boolean representing whether the element's priority has been replaced\n# raises PriorityQueueTypeError if type(priority) is not int\n# raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given element\n# raises PriorityQueueElementError if the element is not contained in the queue\n# if there is another element already assigned to the new priority, the old element will be replaced with the element \n# given as argument, thus the old element will be ignored and removed\n\n# you can also pass a third argument to the replace_priority method - comparison\ncomparison_type = 1\npriority_queue.replace_priority(element, priority, comparison=comparison_type)\n# returns a boolean representing whether the element's priority has been replaced\n# by doing so the priority of the element will only be replaced if a certain type of comparison between \n# the two priorities holds\n# if comparison is 1, the priorities will be replaced if the new priority is greater than the old priority\n# if comparison is -1, the priorities will be replaced if the new priority is less than the old priority\n# if comparison is None (default), the priorities will always be replaced\n# raises ValueError if comparison is not -1, 1 or None\n\npriority_queue.remove_element(element) # finds and removes the element from the queue\n# raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given element\n# raises PriorityQueueElementError if the queue doesn't contain the element\n```\n\n<br> <br>\n\n- **_Duplicate Priority Queue<a name=\"dpq\"></a>_** <br>\nThe Duplicate Priority Queue behaves exactly as the normal Priority Queue with the only difference being that it allows\nelements with duplicated priorities. This, however is not true for the normal Priority Queue, since in its implementation\nif you enqueue an element with a priority that is already linked to some old element, then the old element would be replaced\nby the new enqueued element. By using a duplicate priority queue, no elements are ignored. Instead, if you dequeue and there \nare two elements with the same priority, then they will be dequeued in the order they were enqueued.<br>\n\n_API_ :\n```python\nfrom DataStructures.AbstractDataStructures import DuplicatePriorityQueue # import the priority queue data structure\n\nqueue = DuplicatePriorityQueue() # type is set to default None, hence objects of all types can be enqueued to the queue\n# the reverse argument is set to default False, hence dequeue returns the element with the highest priority\n\nqueue = DuplicatePriorityQueue(elements_type=str, reverse=True) # type is set to str, hence only strings can be enqueued\n# the reverse argument is set to True, hence dequeue returns the element with the lowest priority\n\nqueue.size # the number of elements in the queue, \n# elements with the same priority are NOT counted as one element, but as ordinary elements\nlen(queue) # same as queue.size\n\nstr(queue) # returns a string of the dictionary linking priorities with elements in the queue\n# keep in mind that if there is a priority linked to more than one element, the string representation will return\n# the priority linked to a Queue object\n\nqueue.type # the type of elements that can be enqueued in the priority queue\n# if this method returns None, objects of all types can be enqueued\n\nqueue.reversed # returns True if the queue dequeues the element with the lowest priority\n# returns False if the queue dequeues the element with the highest priority\n\npriority = 10\nqueue.contains_priority(priority) # returns True if the queue has an element or elements linked to the given priority and False otherwise\n# contains raises a PriorityQueueTypeError if type of priority is not int\n\nelement = \"test_element\"\nqueue.contains_element(element) # returns True if an element is contained in the queue\n# raises PriorityQueueTypeError if queue.type is not None and is different than the type of the given element\nboolean = element in queue # same as queue.contains_element(element)\n\nitem = \"test_item\"\nqueue.enqueue(item, priority) # enqueues the given item and links it the given priority\n# raises PriorityQueueTypeError if type(priority) is not int\n# raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given item\n# in this implementation of a priority queue, if there is already an item with the given priority in the queue, then both \n# items will be retained and when dequeueing they will be dequeued in the order they were enqueued\nqueue.enqueue(\"first_item\", 5)\nqueue.enqueue(\"second_item\", 5)\nqueue.dequeue() # dequeues \"first_item\"\nqueue.dequeue() # dequeues \"second_item\"\n# Another thing to note is that you can enqueue the same element to different priorities\nqueue.enqueue(\"item\", 10)\nqueue.enqueue(\"item\", 11)\n\nqueue.peek() # returns element with minimum or maximum priority in the queue, but doesn't remove it from the queue\n# if priority_queue.reversed is False, it returns the element with the maximum priority\n# if priority_queue.reversed is True, it returns the element with the minimum priority\n# returns None if the queue is empty\n# if there are more than one elements with the same priority, peek() will return the first element that was enqueued\n\nqueue.dequeue() # same as priority_queue.peek(), but removes the returned element from the queue\n# raises a EmptyPriorityQueueError if the queue is empty \n# if there are more than one elements with the same priority, dequeue() will return and remove them in the order they were\n# enqueued\n\nqueue.get_element(priority) # returns the element linked to the given priority\n# returns None if no element is linked to this priority\n# raises a PriorityQueueTypeError if type(priority) is not int\n# if there are more than one elements with the same priority, get() will return the first element that was enqueued\n\n# the implementation includes an iterator too\nfor item in queue:\n    print(item)\n# keep in mind that the iterator uses priority_queue.dequeue() to get the next element, hence after the iteration \n# is finished the queue will be empty\n\nqueue.replace_priority(element, priority) # replaces the given element's priority with the new priority argument\n# raises PriorityQueueTypeError if type(priority) is not int\n# raises PriorityQueueTypeError if queue.type is not None and is different than the type of the given element\n# raises PriorityQueueElementError if the element is not contained in the queue\n# in this implementation duplicated priorities are allowed, hence no elements will be ignored even if there is already\n# an element assigned to the new priority\n\n# you can also pass a third argument to the replace_priority method - comparison\ncomparison_type = 1\nqueue.replace_priority(element, priority, comparison=comparison_type)\n# by doing so the priority of the element will only be replaced if a certain type of comparison between \n# the two priorities holds\n# if comparison is 1, the priorities will be replaced if the new priority is greater than the old priority\n# if comparison is -1, the priorities will be replaced if the new priority is less than the old priority\n# if comparison is None (default), the priorities will always be replaced\n# raises ValueError if comparison is not -1, 1 or None\n\nqueue.remove_element(element) # finds and removes the element from the queue\n# raises PriorityQueueTypeError if queue.type is not None and is different than the type of the given element\n# raises PriorityQueueElementError if the queue doesn't contain the element\n```\n\n<br> <br>\n\n- **_Graph<a name=\"graph\"></a>_** <br>\nThe graph's implementation is generic: you can specify the type of elements in the graph in the constructor. \nIf not specified, it is set to None, hence objects of all types can be added to the graph. You can also set the\ndirected, oriented and weighted arguments in the constructor if you want to have a graph with a special feature.\nBy default, those arguments are set to False. Keep in mind that you cannot initialize a graph, which is oriented and\nnot directed at the same time. <br>\nNodes of the graph are stored in a list and a set, which allows fast checking\nwhether the graph contains a certain node in cost of memory. The graph doesn't support duplicate node values <br>\nEdges of the graph are stored in a square matrix: 2-dimensional list which is resized automatically when needed. \nThe initial length of the edges list is 5. A value of None in the matrix represents the absence of an edge. If the graph\nis not weighted a value of 1 represents the presence of a node. If the graph is weighted, an edge would be represented by \nits weight in the matrix and it must be either float or int. <br>\nThe indices in the 2-dimensional list are the indices of the nodes in the list. E.g. <br> \nif the list of nodes is:\n```python\nnodes = [5.5, \"word\", 100]\n```\nand we have a non-directed and non-weighted graph with an edge between 5.5 and 100, the edges matrix will be\n```python\nedges = [\n[None, None, 1, None, None],\n[None, None, None, None, None],\n[1, None, None, None, None],\n[None, None, None, None, None],\n[None, None, None, None, None]\n]\n```\nNote the initial size of the matrix, which is 5 by 5 matrix. The indices of 5.5 and 100 in the list of nodes are 0 and 2\nrespectively and the graph is not directed. That's why edges[0][2] = edges[2][0] = 1.\n\n_API_ :\n```python\nfrom DataStructures.AbstractDataStructures import Graph # import the graph data structure\n\ngraph = Graph() # initialize a graph with None elements type, hence all types of elements can be added to the graph\n# the initialized graph is also neither directed, nor oriented, nor weighted\n\ngraph = Graph(elements_type=int, directed=True, oriented=False, weighted=True)\n# only integers can be added to the initialized graph; the graph is directed, but not oriented; the graph is also weighted\n \ngraph = Graph(elements_type=str, directed=False, oriented=True, weighted=True)\n# this raises an InvalidGraphError since a graph cannot be oriented and not directed at the same time\n\ngraph = Graph(float, True, True, True)\n# only floats can be added to the initialized graph; the graph is directed, oriented and weighted\n\ngraph.size # the number of elements in the graph\nlen(graph) # same as graph.size\n\nstr(graph) # returns a string in the format 'Graph: directed - boolean, oriented - boolean, weighted - boolean'\n\ngraph.type # the type of node values in the graph, returns None if all types of elements are allowed\n# if this method doesn't return None, only nodes of the returned type can be added to the graph\n\ngraph.directed # True if the graph is directed and False otherwise\n\ngraph.oriented # True if the graph is oriented and False otherwise\n\ngraph.weighted # True if the graph is weighted and False otherwise\n\nitem = \"test_element\"\ngraph.contains(item) # returns True if item is in the set of nodes of the graph and False otherwise\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of the argument\nboolean = item in graph # same as graph.contains(item)\n\nfirst_item = \"first_test_item\"\nsecond_item = \"second_test_item\"\ngraph.contains_edge(first_item, second_item) # returns True if an edge from first_item to second_item exists\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments\n# raises a GraphElementError if first_item or second_item is not a node that the graph contains\n# if the graph is not directed the result will be the same even if you reverse the order of the arguments\n\ngraph.get_edge_weight(first_item, second_item)\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments\n# raises a GraphElementError if first_item or second_item is not a node that the graph contains\n# raises a GraphEdgeError if the graph is not weighted\n# raises a GraphEdgeError if an edge between first_item and second_item doesn't exist\n# if the graph is not directed the result will be the same even if you reverse the order of the arguments\n\ngraph.nodes() # returns a deep copy of the list of nodes of the graph\n# a deep copy is returned to avoid manual changes of the graph by changing the elements in the returned list\n \ngraph.add_node(item) # adds item to the nodes of the graph if it is not already added\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of the argument\n# raises an GraphElementError if item is None\n# if item is already added as a node to the graph, the function does nothing\n\ngraph.remove_node(item) \n# raises a GraphTypeError if the type of the graph is not None and is different than the type of the argument\n# raises a GraphElementError if item is not a node in the graph\n# remove a node in the graph also removes all edges related to this node (going to and from this node)\n\nold_node = \"test_old_node\"\nnew_node = \"test_new_node\"\ngraph.replace_node(old_node, new_node) # replaces old_node with new_node in the graph list of nodes if possible\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments\n# raises a GraphElementError if old_node is not a node the graph contains\n# raises a GraphElementError if new_node is a node the graph contains, since duplicate nodes are not allowed\n\n# the replacing of a node in the graph doesn't affect the edges in the graph, e.g.\nconnected_nodes = graph.edges_of(old_node)\ngraph.replace_node(old_node, new_node)\nnew_connected_nodes = graph.edges_of(new_node)\nprint(connected_nodes == new_connected_nodes) \n# will print True, since edges of the old node are not affected, only the value is replaced\n# the method is useful, since it retains the edges of the old node \n# and is faster than first removing the old node and then adding the new node\n\n\ngraph.edges() # returns a deep copy of the square matrix (2D list) representing the edges of the graph\n# a deep copy is returned to avoid manual changes of the graph by changing the elements in the returned list\n\ngraph.edges_of(item) # returns a list of all nodes to which there is an edge from the argument\n# returns an empty list if there are no such nodes\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of the argument\n# raises a GraphElementError if the item if not a node in the graph\n\nedge_weight = \"test_edge_weight\"\ngraph.add_edge(first_item, second_item, edge_weight) # adds an edge from first_item to second_item with the given edge_weight if appropriate\n# edge_weight should only be specified if the graph is weighted, otherwise, just skip this argument (set to None by default)\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments\n# raises a GraphTypeError if edge_weight is specified and is not of type float or int\n# raises a GraphElementError if first_item or second_item is not a node that the graph contains\n# raises a GraphEdgeError if the graph is weighted and edge_weight is not specified or it is None\n# raises a GraphEdgeError if the graph is oriented and an edge from second_item to first_item already exists\n\ngraph.remove_edge(first_item, second_item) # removes the edge from first_item to second_item\n# if the graph is not directed, this function removes the edge from second_item to first_item too\n# raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments\n# raises a GraphElementError if first_item or second_item is not a node that the graph contains\n# raises a GraphEdgeError if there is no edge from first_item to second_item\n\n# the implementation includes an iterator too\nfor node in graph:\n    print(node)\n# the iterator goes through all nodes in the graph\n# the __iter__ method actually returns the iterator of the list of nodes of the graph\n```", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/nikist97/Python-DataStructures", "keywords": "data structures,data,structures,python,abstract,generic,graph,heap,queue,stack", "license": "Apache 2.0", "maintainer": "", "maintainer_email": "", "name": "pythonic-data-structures", "package_url": "https://pypi.org/project/pythonic-data-structures/", "platform": "", "project_url": "https://pypi.org/project/pythonic-data-structures/", "project_urls": {"Homepage": "https://github.com/nikist97/Python-DataStructures"}, "release_url": "https://pypi.org/project/pythonic-data-structures/0.2.1/", "requires_dist": null, "requires_python": ">=3", "summary": "Python-based implementations for many data structures.", "version": "0.2.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Abstract and Tree-like Data Structures - Python</h1>\n<p><strong><em>The repository contains Python-based implementations for popular data structures.</em></strong></p>\n<h3>Installation:</h3>\n<p>Please use 'pip install pythonic-data-structures'.</p>\n<h3>Issues:</h3>\n<p>Please register any issues you find in the github repository so that they can be fixed as soon as possible.</p>\n<h3>Requirements:</h3>\n<p>There are no dependencies on external libraries. However, a Python 3.x version is required.</p>\n<h3>Docs:</h3>\n<p><em>Navigate to data structures:</em> <a href=\"#stack\" rel=\"nofollow\">Stack</a>, <a href=\"#queue\" rel=\"nofollow\">Queue</a>, <a href=\"#minbh\" rel=\"nofollow\">Min Binary Heap</a>,\n<a href=\"#maxbh\" rel=\"nofollow\">Max Binary Heap</a>, <a href=\"#pq\" rel=\"nofollow\">Priority Queue</a>, <a href=\"#dpq\" rel=\"nofollow\">Duplicate Priority Queue</a>, <a href=\"#graph\" rel=\"nofollow\">Graph</a>\n<br><br></p>\n<h3>Data Structures</h3>\n<p><strong><em>Implementation for Stack, Queue, Max Binary Heap, Min Binary Heap, Priority Queue and Graph in Python</em></strong> <br>\n<strong>These are located in the AbstractDataStructures.py and TreeDataStructures.py modules</strong> <br><br></p>\n<ul>\n<li><strong><em>Stack<a></a> (First-In-Last-Out)</em></strong> <br>\nThe Stack's implementation wraps around the python deque object, but is also generic: you can specify the type of elements\nin the stack in the constructor. If not specified, it is set to None and elements of any type can be added to the stack. The\nimplementation includes all the common operations of a stack: peek, push, pop, size, etc.<br></li>\n</ul>\n<p><em>API</em> :</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">DataStructures.AbstractDataStructures</span> <span class=\"kn\">import</span> <span class=\"n\">Stack</span> <span class=\"c1\"># import the stack data structure</span>\n\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">Stack</span><span class=\"p\">()</span> <span class=\"c1\"># type is set to None, items of any types can be added</span>\n<span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"n\">Stack</span><span class=\"p\">(</span><span class=\"n\">elements_type</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"c1\"># type is set to int, hence only integers can be pushed</span>\n\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"c1\"># the number of elements in the stack</span>\n<span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">stack</span><span class=\"p\">)</span> <span class=\"c1\"># same as stack.size</span>\n\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">stack</span><span class=\"p\">)</span> <span class=\"c1\"># returns the string representation of the python deque object containing the elements of the stack</span>\n\n<span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_item\"</span>\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span> <span class=\"c1\"># returns True if the item is in the stack and False otherwise</span>\n<span class=\"c1\"># contains raises a StackTypeError if the type of the stack is not None and is different than the type of the parameter</span>\n<span class=\"n\">boolean</span> <span class=\"o\">=</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">stack</span> \n<span class=\"c1\"># same as boolean = stack.contains(item)</span>\n\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">type</span> <span class=\"c1\"># returns the type of the elements in the stack, None if no type is specified when initialised</span>\n\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">peek</span><span class=\"p\">()</span> <span class=\"c1\"># returns the last element that was added to the stack, but doesn't remove it</span>\n<span class=\"c1\"># peek returns None if there are no elements in the stack</span>\n\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">pop</span><span class=\"p\">()</span> <span class=\"c1\"># same as peek(), but removes the last element that was added to the stack</span>\n<span class=\"c1\"># pop raises an EmptyStackError if there are no elements in the stack</span>\n\n<span class=\"n\">element</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_item\"</span>\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span> <span class=\"c1\"># pushes the element to the top of the stack</span>\n<span class=\"c1\"># push raises a StackTypeError if the stack has a specified type for elements and the argument is not of that type</span>\n\n<span class=\"c1\"># the implementation includes an iterator</span>\n<span class=\"k\">for</span> <span class=\"n\">element</span> <span class=\"ow\">in</span> <span class=\"n\">stack</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span>\n<span class=\"c1\"># keep in mind that the iterator uses stack.pop() to get the next element, hence</span>\n<span class=\"c1\"># after the iteration is over the stack would be empty</span>\n\n<span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span> <span class=\"c1\"># removes the element from the stack</span>\n<span class=\"c1\"># raises a StackTypeError if the stack has a specified type for elements and the argument is not of that type</span>\n<span class=\"c1\"># raises a StackElementError if the stack doesn't contain the element specified as argument</span>\n</pre>\n<p><br> <br></p>\n<ul>\n<li><strong><em>Queue<a></a> (First-In-First-Out)</em></strong> <br>\nThe Queue's implementation wraps around the python deque object, but is also generic: you can specify the type of elements in the queue in the constructor.\nIf not specified, it is set to None and elements of any type can be added to the queue. The\nimplementation includes all the common operations of a queue: enqueue, dequeue, peek, size, etc.<br></li>\n</ul>\n<p><em>API</em> :</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">DataStructures.AbstractDataStructures</span> <span class=\"kn\">import</span> <span class=\"n\">Queue</span> <span class=\"c1\"># import the queue data structure</span>\n<span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">Queue</span><span class=\"p\">()</span> <span class=\"c1\"># type is set to None, items of any types can be added</span>\n<span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">Queue</span><span class=\"p\">(</span><span class=\"n\">elements_type</span> <span class=\"o\">=</span> <span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"c1\"># type is set to str, hence only strings can be enqueued</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"c1\"># the number of elements in the queue</span>\n<span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"p\">)</span> <span class=\"c1\"># same as queue.size</span>\n\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"p\">)</span> <span class=\"c1\"># returns the string representation of the python deque object containing the elements of the queue</span>\n\n<span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_item\"</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span> <span class=\"c1\"># returns True if the item is in the queue and False otherwise</span>\n<span class=\"c1\"># contains raises a QueueTypeError if the type of the queue is not None and is different </span>\n<span class=\"c1\"># than the type of the parameter</span>\n<span class=\"n\">boolean</span> <span class=\"o\">=</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">queue</span> \n<span class=\"c1\"># same as boolean = queue.contains(item)</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">type</span> <span class=\"c1\"># the type of the elements in the queue, None if no type is specified when initialised</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">peek</span><span class=\"p\">()</span> <span class=\"c1\"># returns the first element that was added to the queue, but doesn't remove it</span>\n<span class=\"c1\"># peek returns None if there are no elements in the queue</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">dequeue</span><span class=\"p\">()</span> <span class=\"c1\"># same as peek(), but removes the first element that was added to the queue</span>\n<span class=\"c1\"># dequeue raises a EmptyQueueError if there are no elements in the queue</span>\n\n<span class=\"n\">element</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_element\"</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span> <span class=\"c1\"># enqueues the element to the back of the queue</span>\n<span class=\"c1\"># enqueue raises a QueueTypeError if the queue has a specified type for elements</span>\n<span class=\"c1\"># and the argument is not of that type</span>\n\n<span class=\"c1\"># the implementation includes an iterator</span>\n<span class=\"k\">for</span> <span class=\"n\">element</span> <span class=\"ow\">in</span> <span class=\"n\">queue</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span>\n<span class=\"c1\"># keep in mind that the iterator uses queue.dequeue() to get the next element, hence</span>\n<span class=\"c1\"># after the iteration is over the queue would be empty</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span> <span class=\"c1\"># removes the element from the queue</span>\n<span class=\"c1\"># raises a QueueTypeError if the queue has a specified type for elements and the argument is not of that type</span>\n<span class=\"c1\"># raises a QueueElementError if the queue doesn't contain the element specified as argument</span>\n</pre>\n<p><br> <br></p>\n<ul>\n<li><strong><em>BinaryHeap</em></strong> <br>\nThe BinaryHeap's implementation is generic: you can specify the type of elements in the heap in the constructor. If not\nspecified, it is set to int, hence only integers can be added to the heap. The BinaryHeap class is abstract. You cannot\ninstantiate it. The implementation includes two types of heaps, which you can use: MinBinaryHeap and MaxBinaryHeap.</li>\n</ul>\n<br>\n<p><strong>MinBinaryHeap</strong> - a heap with its root being the minimum element <br>\nMinBinaryHeap implements the common operations of a heap: add, replace_root, remove_min, peek_min, size, etc.</p>\n<br>\n<p><strong>MaxBinaryHeap</strong> - a heap with its root being the maximum element <br>\nMaxBinaryHeap implements the common operations of a heap: add, replace_root, remove_max, peek_max, size, etc.</p>\n<br>\n<p>MinBinaryHeap<a></a> <em>API</em> :</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">DataStructures.AbstractDataStructures</span> <span class=\"kn\">import</span> <span class=\"n\">MinBinaryHeap</span> <span class=\"c1\"># import the min heap</span>\n\n<span class=\"n\">min_heap</span> <span class=\"o\">=</span> <span class=\"n\">MinBinaryHeap</span><span class=\"p\">()</span> <span class=\"c1\"># type is set to default - int, hence only integers can be added</span>\n<span class=\"c1\"># creates an empty heap</span>\n\n<span class=\"n\">min_heap</span> <span class=\"o\">=</span> <span class=\"n\">MinBinaryHeap</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"c1\"># type is set to str, hence only strings can be added</span>\n<span class=\"c1\"># creates an empty heap</span>\n\n<span class=\"n\">min_heap</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"c1\"># the number of elements in the heap</span>\n<span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">min_heap</span><span class=\"p\">)</span> <span class=\"c1\"># same as min_heap.size</span>\n\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">min_heap</span><span class=\"p\">)</span> <span class=\"c1\"># returns a string of the list of elements in the heap</span>\n\n<span class=\"n\">min_heap</span><span class=\"o\">.</span><span class=\"n\">type</span> <span class=\"c1\"># the type of elements in the heap</span>\n\n<span class=\"n\">element</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_element\"</span>\n<span class=\"n\">min_heap</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span> <span class=\"c1\"># adds the element to the min binary heap on the place it should be located</span>\n<span class=\"c1\"># add raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap</span>\n\n<span class=\"n\">min_heap</span><span class=\"o\">.</span><span class=\"n\">peek_min</span><span class=\"p\">()</span> <span class=\"c1\"># returns the minimum element (the root), but doesn't remove it from the heap</span>\n<span class=\"c1\"># returns None if heap is empty</span>\n\n<span class=\"n\">min_heap</span><span class=\"o\">.</span><span class=\"n\">remove_min</span><span class=\"p\">()</span> <span class=\"c1\"># returns the minimum element (the root) and removes it from the heap</span>\n<span class=\"c1\"># the method replaces the root with the second minimum element in the heap</span>\n<span class=\"c1\"># it raises a EmptyBinaryHeapError if the heap is empty</span>\n\n<span class=\"c1\"># returns the minimum element (the root) and removes it from the heap, by replacing it with the element argument</span>\n<span class=\"n\">min_heap</span><span class=\"o\">.</span><span class=\"n\">replace_root</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span> \n<span class=\"c1\"># same as min_heap.remove_min() followed by min_heap.add(element), but replace_root() is faster</span>\n<span class=\"c1\"># raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap</span>\n<span class=\"c1\"># raises a EmptyBinaryHeapError if the heap is empty</span>\n\n<span class=\"n\">min_heap</span><span class=\"o\">.</span><span class=\"n\">get_sorted_elements</span><span class=\"p\">()</span> <span class=\"c1\"># returns a list with the sorted elements from the heap, the heap remains unchanged</span>\n<span class=\"c1\"># the order is ascending; returns an empty list if the heap is empty</span>\n\n<span class=\"c1\"># the iterator goes through each element in the heap in ascending order</span>\n<span class=\"k\">for</span> <span class=\"n\">element</span> <span class=\"ow\">in</span> <span class=\"n\">min_heap</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span>\n<span class=\"c1\"># keep in mind that using the iterator will remove each element you go through from the heap, since it uses remove_min()</span>\n<span class=\"c1\"># to generate the next element, hence when the iterator is finished the heap would be empty;</span>\n<span class=\"c1\"># if you want to keep the elements in the heap, use get_sorted_elements() (although it's slightly slower)</span>\n\n<span class=\"c1\"># another example with the iterator</span>\n<span class=\"n\">heap_iter</span> <span class=\"o\">=</span> <span class=\"nb\">iter</span><span class=\"p\">(</span><span class=\"n\">min_heap</span><span class=\"p\">)</span>\n<span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">heap_iter</span><span class=\"p\">))</span>\n    <span class=\"k\">except</span> <span class=\"ne\">StopIteration</span><span class=\"p\">:</span>\n        <span class=\"k\">break</span>\n<span class=\"n\">min_heap</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"c1\"># will return 0 after iteration is finished, as explained above</span>\n\n<span class=\"n\">old_element</span><span class=\"p\">,</span> <span class=\"n\">new_element</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">100</span>\n<span class=\"n\">min_heap</span><span class=\"o\">.</span><span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"n\">old_element</span><span class=\"p\">,</span> <span class=\"n\">new_element</span><span class=\"p\">)</span> <span class=\"c1\"># replaces the old element with the new element and readjusts the heap after</span>\n<span class=\"c1\"># the replacement</span>\n<span class=\"c1\"># raises a BinaryHeapTypeError if the type of the first or the second argument is not the same as the type of the </span>\n<span class=\"c1\"># elements in the heap</span>\n<span class=\"c1\"># raises a BinaryHeapElementError if the old_element argument is not contained in the heap</span>\n<span class=\"c1\"># raises a EmptyBinaryHeapError if the heap is empty</span>\n\n<span class=\"n\">min_heap</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span>  <span class=\"c1\"># removes the element and readjusts the heap after deletion</span>\n<span class=\"c1\"># raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap</span>\n<span class=\"c1\"># raises a BinaryHeapElementError if the element argument is not contained in the heap</span>\n<span class=\"c1\"># raises a EmptyBinaryHeapError if the heap is empty</span>\n</pre>\n<br>\n<p>MaxBinaryHeap<a></a> <em>API</em>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">DataStructures.AbstractDataStructures</span> <span class=\"kn\">import</span> <span class=\"n\">MaxBinaryHeap</span> <span class=\"c1\"># import the max heap</span>\n\n<span class=\"n\">max_heap</span> <span class=\"o\">=</span> <span class=\"n\">MaxBinaryHeap</span><span class=\"p\">()</span> <span class=\"c1\"># type is set to default - int, hence only integers can be added</span>\n<span class=\"c1\"># creates an empty heap</span>\n\n<span class=\"n\">max_heap</span> <span class=\"o\">=</span> <span class=\"n\">MaxBinaryHeap</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"c1\"># type is set to str, hence only strings can be added</span>\n<span class=\"c1\"># creates an empty heap</span>\n\n<span class=\"n\">max_heap</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"c1\"># the number of elements in the heap</span>\n<span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">max_heap</span><span class=\"p\">)</span> <span class=\"c1\"># same as max_heap.size</span>\n\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">max_heap</span><span class=\"p\">)</span> <span class=\"c1\"># returns a string of the list of elements in the heap</span>\n\n<span class=\"n\">max_heap</span><span class=\"o\">.</span><span class=\"n\">type</span> <span class=\"c1\"># the type of elements in the heap</span>\n\n<span class=\"n\">element</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_element\"</span>\n<span class=\"n\">max_heap</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span> <span class=\"c1\"># adds the element to the max binary heap on the place it should be located</span>\n<span class=\"c1\"># add raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap</span>\n\n<span class=\"n\">max_heap</span><span class=\"o\">.</span><span class=\"n\">peek_max</span><span class=\"p\">()</span> <span class=\"c1\"># returns the maximum element (the root), but doesn't remove it from the heap</span>\n<span class=\"c1\"># returns None if heap is empty</span>\n\n<span class=\"n\">max_heap</span><span class=\"o\">.</span><span class=\"n\">remove_max</span><span class=\"p\">()</span> <span class=\"c1\"># returns the maximum element (the root) and removes it from the heap</span>\n<span class=\"c1\"># the method replaces the root with the second maximum element in the heap</span>\n<span class=\"c1\"># it raises a EmptyBinaryHeapError if the heap is empty</span>\n\n<span class=\"c1\"># returns the maximum element (the root) and removes it from the heap, by replacing it with the element argument</span>\n<span class=\"n\">max_heap</span><span class=\"o\">.</span><span class=\"n\">replace_root</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span> \n<span class=\"c1\"># same as max_heap.remove_max() followed by max_heap.add(element), but replace_root() is faster</span>\n<span class=\"c1\"># raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap</span>\n<span class=\"c1\"># raises a EmptyBinaryHeapError if the heap is empty</span>\n\n<span class=\"n\">max_heap</span><span class=\"o\">.</span><span class=\"n\">get_sorted_elements</span><span class=\"p\">()</span> <span class=\"c1\"># returns a list with the sorted elements from the heap, the heap remains unchanged</span>\n<span class=\"c1\"># the order is descending; returns an empty list if the heap is empty</span>\n\n<span class=\"c1\"># the iterator goes through each element in the heap in descending order</span>\n<span class=\"k\">for</span> <span class=\"n\">element</span> <span class=\"ow\">in</span> <span class=\"n\">max_heap</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span>\n<span class=\"c1\"># keep in mind that using the iterator will remove each element you go through from the heap, since it uses remove_max()</span>\n<span class=\"c1\"># to generate the next element, hence when the iterator is finished the heap would be empty;</span>\n<span class=\"c1\"># if you want to keep the elements in the heap, use get_sorted_elements() (although it's slightly slower)</span>\n\n<span class=\"c1\"># another example with the iterator</span>\n<span class=\"n\">heap_iter</span> <span class=\"o\">=</span> <span class=\"nb\">iter</span><span class=\"p\">(</span><span class=\"n\">max_heap</span><span class=\"p\">)</span>\n<span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">heap_iter</span><span class=\"p\">))</span>\n    <span class=\"k\">except</span> <span class=\"ne\">StopIteration</span><span class=\"p\">:</span>\n        <span class=\"k\">break</span>\n<span class=\"n\">max_heap</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"c1\"># will return 0 after iteration is finished, as explained above</span>\n\n<span class=\"n\">old_element</span><span class=\"p\">,</span> <span class=\"n\">new_element</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">100</span>\n<span class=\"n\">max_heap</span><span class=\"o\">.</span><span class=\"n\">replace</span><span class=\"p\">(</span><span class=\"n\">old_element</span><span class=\"p\">,</span> <span class=\"n\">new_element</span><span class=\"p\">)</span> <span class=\"c1\"># replaces the old element with the new element and readjusts the heap after</span>\n<span class=\"c1\"># the replacement</span>\n<span class=\"c1\"># raises a BinaryHeapTypeError if the type of the first or the second argument is not the same as the type of the </span>\n<span class=\"c1\"># elements in the heap</span>\n<span class=\"c1\"># raises a BinaryHeapElementError if the old_element argument is not contained in the heap</span>\n<span class=\"c1\"># raises a EmptyBinaryHeapError if the heap is empty</span>\n\n<span class=\"n\">max_heap</span><span class=\"o\">.</span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span>  <span class=\"c1\"># removes the element and readjusts the heap after deletion</span>\n<span class=\"c1\"># raises a BinaryHeapTypeError if the type of the argument is not the same as the type of the elements in the heap</span>\n<span class=\"c1\"># raises a BinaryHeapElementError if the element argument is not contained in the heap</span>\n<span class=\"c1\"># raises a EmptyBinaryHeapError if the heap is empty</span>\n</pre>\n<p><br> <br></p>\n<ul>\n<li><strong><em>Priority Queue<a></a></em></strong> <br>\nThe Priority Queue's implementation is generic: you can specify the type of elements in the queue in the constructor.\nIf not specified, it is set to None, hence objects of all types can be added to the priority queue. You can also set the reverse\nargument in the constructor. If reverse is set to False (default) the queue dequeues the element with the greatest priority,\nelse if the reverse argument is set to True - it dequeues the element with the lowest priority. The implementation includes\nall the common operations of a priority queue: enqueue, dequeue, peek, size, etc.<br></li>\n</ul>\n<p><em>API</em> :</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">DataStructures.AbstractDataStructures</span> <span class=\"kn\">import</span> <span class=\"n\">PriorityQueue</span> <span class=\"c1\"># import the priority queue data structure</span>\n\n<span class=\"n\">priority_queue</span> <span class=\"o\">=</span> <span class=\"n\">PriorityQueue</span><span class=\"p\">()</span> <span class=\"c1\"># type is set to default None, hence objects of all types can be enqueued to the queue</span>\n<span class=\"c1\"># the reverse argument is set to default False, hence dequeue returns the element with the highest priority</span>\n\n<span class=\"n\">priority_queue</span> <span class=\"o\">=</span> <span class=\"n\">PriorityQueue</span><span class=\"p\">(</span><span class=\"n\">elements_type</span><span class=\"o\">=</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">reverse</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># type is set to str, hence only strings can be enqueued</span>\n<span class=\"c1\"># the reverse argument is set to True, hence dequeue returns the element with the lowest priority</span>\n\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"c1\"># the number of elements in the queue</span>\n<span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">priority_queue</span><span class=\"p\">)</span> <span class=\"c1\"># same as priority_queue.size</span>\n\n\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">priority_queue</span><span class=\"p\">)</span> <span class=\"c1\"># returns a string of the dictionary linking priorities with elements in the queue</span>\n\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">type</span> <span class=\"c1\"># the type of elements that can be enqueued in the priority queue</span>\n<span class=\"c1\"># if this method returns None, objects of all types can be enqueued</span>\n\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">reversed</span> <span class=\"c1\"># True if the queue dequeues the element with the lowest priority</span>\n<span class=\"c1\"># returns False if the queue dequeues the element with the highest priority</span>\n\n<span class=\"n\">priority</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">contains_priority</span><span class=\"p\">(</span><span class=\"n\">priority</span><span class=\"p\">)</span> <span class=\"c1\"># returns True if the queue has an element linked to the given priority and False otherwise</span>\n<span class=\"c1\"># contains raises a PriorityQueueTypeError if type of priority is not int</span>\n\n<span class=\"n\">element</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_element\"</span>\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">contains_element</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span> <span class=\"c1\"># returns True if an element is contained in the queue</span>\n<span class=\"c1\"># raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given element</span>\n<span class=\"n\">boolean</span> <span class=\"o\">=</span> <span class=\"n\">element</span> <span class=\"ow\">in</span> <span class=\"n\">priority_queue</span> <span class=\"c1\"># same as priority_queue.contains_element(element)</span>\n\n<span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_item\"</span>\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">,</span> <span class=\"n\">priority</span><span class=\"p\">)</span> <span class=\"c1\"># enqueues the given item and links it the given priority</span>\n<span class=\"c1\"># raises PriorityQueueTypeError if type(priority) is not int</span>\n<span class=\"c1\"># raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given item</span>\n<span class=\"c1\"># keep in mind that if there is another element linked to the same priority, the old element will be replaced</span>\n<span class=\"c1\"># by the new element</span>\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"s2\">\"first_item\"</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"s2\">\"second_item\"</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"c1\"># doing this will link priority 5 to str object \"second_item\" while str object \"first_item\" will be ignored and </span>\n<span class=\"c1\"># removed from the queue</span>\n<span class=\"c1\"># Another thing to note is that you can enqueue the same element to different priorities</span>\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"s2\">\"item\"</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"s2\">\"item\"</span><span class=\"p\">,</span> <span class=\"mi\">11</span><span class=\"p\">)</span>\n\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">peek</span><span class=\"p\">()</span> <span class=\"c1\"># returns element with minimum or maximum priority in the queue, but doesn't remove it from the queue</span>\n<span class=\"c1\"># if priority_queue.reversed is False, it returns the element with the maximum priority</span>\n<span class=\"c1\"># if priority_queue.reversed is True, it returns the element with the minimum priority</span>\n<span class=\"c1\"># returns None if the queue is empty</span>\n\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">dequeue</span><span class=\"p\">()</span> <span class=\"c1\"># same as priority_queue.peek(), but removes the returned element from the queue</span>\n<span class=\"c1\"># raises a EmptyPriorityQueueError if the queue is empty </span>\n\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">get_element</span><span class=\"p\">(</span><span class=\"n\">priority</span><span class=\"p\">)</span> <span class=\"c1\"># returns the element linked to the given priority</span>\n<span class=\"c1\"># returns None if no element is linked to this priority</span>\n<span class=\"c1\"># raises a PriorityQueueTypeError if type(priority) is not int</span>\n\n<span class=\"c1\"># the implementation includes an iterator too</span>\n<span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">priority_queue</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span>\n<span class=\"c1\"># keep in mind that the iterator uses priority_queue.dequeue() to get the next element, hence after the iteration </span>\n<span class=\"c1\"># is finished the priority_queue will be empty</span>\n\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">replace_priority</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"n\">priority</span><span class=\"p\">)</span> <span class=\"c1\"># replaces the given element's priority with the new priority argument</span>\n<span class=\"c1\"># returns a boolean representing whether the element's priority has been replaced</span>\n<span class=\"c1\"># raises PriorityQueueTypeError if type(priority) is not int</span>\n<span class=\"c1\"># raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given element</span>\n<span class=\"c1\"># raises PriorityQueueElementError if the element is not contained in the queue</span>\n<span class=\"c1\"># if there is another element already assigned to the new priority, the old element will be replaced with the element </span>\n<span class=\"c1\"># given as argument, thus the old element will be ignored and removed</span>\n\n<span class=\"c1\"># you can also pass a third argument to the replace_priority method - comparison</span>\n<span class=\"n\">comparison_type</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">replace_priority</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"n\">priority</span><span class=\"p\">,</span> <span class=\"n\">comparison</span><span class=\"o\">=</span><span class=\"n\">comparison_type</span><span class=\"p\">)</span>\n<span class=\"c1\"># returns a boolean representing whether the element's priority has been replaced</span>\n<span class=\"c1\"># by doing so the priority of the element will only be replaced if a certain type of comparison between </span>\n<span class=\"c1\"># the two priorities holds</span>\n<span class=\"c1\"># if comparison is 1, the priorities will be replaced if the new priority is greater than the old priority</span>\n<span class=\"c1\"># if comparison is -1, the priorities will be replaced if the new priority is less than the old priority</span>\n<span class=\"c1\"># if comparison is None (default), the priorities will always be replaced</span>\n<span class=\"c1\"># raises ValueError if comparison is not -1, 1 or None</span>\n\n<span class=\"n\">priority_queue</span><span class=\"o\">.</span><span class=\"n\">remove_element</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span> <span class=\"c1\"># finds and removes the element from the queue</span>\n<span class=\"c1\"># raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given element</span>\n<span class=\"c1\"># raises PriorityQueueElementError if the queue doesn't contain the element</span>\n</pre>\n<p><br> <br></p>\n<ul>\n<li><strong><em>Duplicate Priority Queue<a></a></em></strong> <br>\nThe Duplicate Priority Queue behaves exactly as the normal Priority Queue with the only difference being that it allows\nelements with duplicated priorities. This, however is not true for the normal Priority Queue, since in its implementation\nif you enqueue an element with a priority that is already linked to some old element, then the old element would be replaced\nby the new enqueued element. By using a duplicate priority queue, no elements are ignored. Instead, if you dequeue and there\nare two elements with the same priority, then they will be dequeued in the order they were enqueued.<br></li>\n</ul>\n<p><em>API</em> :</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">DataStructures.AbstractDataStructures</span> <span class=\"kn\">import</span> <span class=\"n\">DuplicatePriorityQueue</span> <span class=\"c1\"># import the priority queue data structure</span>\n\n<span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">DuplicatePriorityQueue</span><span class=\"p\">()</span> <span class=\"c1\"># type is set to default None, hence objects of all types can be enqueued to the queue</span>\n<span class=\"c1\"># the reverse argument is set to default False, hence dequeue returns the element with the highest priority</span>\n\n<span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"n\">DuplicatePriorityQueue</span><span class=\"p\">(</span><span class=\"n\">elements_type</span><span class=\"o\">=</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">reverse</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span> <span class=\"c1\"># type is set to str, hence only strings can be enqueued</span>\n<span class=\"c1\"># the reverse argument is set to True, hence dequeue returns the element with the lowest priority</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"c1\"># the number of elements in the queue, </span>\n<span class=\"c1\"># elements with the same priority are NOT counted as one element, but as ordinary elements</span>\n<span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"p\">)</span> <span class=\"c1\"># same as queue.size</span>\n\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">queue</span><span class=\"p\">)</span> <span class=\"c1\"># returns a string of the dictionary linking priorities with elements in the queue</span>\n<span class=\"c1\"># keep in mind that if there is a priority linked to more than one element, the string representation will return</span>\n<span class=\"c1\"># the priority linked to a Queue object</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">type</span> <span class=\"c1\"># the type of elements that can be enqueued in the priority queue</span>\n<span class=\"c1\"># if this method returns None, objects of all types can be enqueued</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">reversed</span> <span class=\"c1\"># returns True if the queue dequeues the element with the lowest priority</span>\n<span class=\"c1\"># returns False if the queue dequeues the element with the highest priority</span>\n\n<span class=\"n\">priority</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">contains_priority</span><span class=\"p\">(</span><span class=\"n\">priority</span><span class=\"p\">)</span> <span class=\"c1\"># returns True if the queue has an element or elements linked to the given priority and False otherwise</span>\n<span class=\"c1\"># contains raises a PriorityQueueTypeError if type of priority is not int</span>\n\n<span class=\"n\">element</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_element\"</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">contains_element</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span> <span class=\"c1\"># returns True if an element is contained in the queue</span>\n<span class=\"c1\"># raises PriorityQueueTypeError if queue.type is not None and is different than the type of the given element</span>\n<span class=\"n\">boolean</span> <span class=\"o\">=</span> <span class=\"n\">element</span> <span class=\"ow\">in</span> <span class=\"n\">queue</span> <span class=\"c1\"># same as queue.contains_element(element)</span>\n\n<span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_item\"</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">,</span> <span class=\"n\">priority</span><span class=\"p\">)</span> <span class=\"c1\"># enqueues the given item and links it the given priority</span>\n<span class=\"c1\"># raises PriorityQueueTypeError if type(priority) is not int</span>\n<span class=\"c1\"># raises PriorityQueueTypeError if priority_queue.type is not None and is different than the type of the given item</span>\n<span class=\"c1\"># in this implementation of a priority queue, if there is already an item with the given priority in the queue, then both </span>\n<span class=\"c1\"># items will be retained and when dequeueing they will be dequeued in the order they were enqueued</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"s2\">\"first_item\"</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"s2\">\"second_item\"</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">dequeue</span><span class=\"p\">()</span> <span class=\"c1\"># dequeues \"first_item\"</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">dequeue</span><span class=\"p\">()</span> <span class=\"c1\"># dequeues \"second_item\"</span>\n<span class=\"c1\"># Another thing to note is that you can enqueue the same element to different priorities</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"s2\">\"item\"</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">enqueue</span><span class=\"p\">(</span><span class=\"s2\">\"item\"</span><span class=\"p\">,</span> <span class=\"mi\">11</span><span class=\"p\">)</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">peek</span><span class=\"p\">()</span> <span class=\"c1\"># returns element with minimum or maximum priority in the queue, but doesn't remove it from the queue</span>\n<span class=\"c1\"># if priority_queue.reversed is False, it returns the element with the maximum priority</span>\n<span class=\"c1\"># if priority_queue.reversed is True, it returns the element with the minimum priority</span>\n<span class=\"c1\"># returns None if the queue is empty</span>\n<span class=\"c1\"># if there are more than one elements with the same priority, peek() will return the first element that was enqueued</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">dequeue</span><span class=\"p\">()</span> <span class=\"c1\"># same as priority_queue.peek(), but removes the returned element from the queue</span>\n<span class=\"c1\"># raises a EmptyPriorityQueueError if the queue is empty </span>\n<span class=\"c1\"># if there are more than one elements with the same priority, dequeue() will return and remove them in the order they were</span>\n<span class=\"c1\"># enqueued</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">get_element</span><span class=\"p\">(</span><span class=\"n\">priority</span><span class=\"p\">)</span> <span class=\"c1\"># returns the element linked to the given priority</span>\n<span class=\"c1\"># returns None if no element is linked to this priority</span>\n<span class=\"c1\"># raises a PriorityQueueTypeError if type(priority) is not int</span>\n<span class=\"c1\"># if there are more than one elements with the same priority, get() will return the first element that was enqueued</span>\n\n<span class=\"c1\"># the implementation includes an iterator too</span>\n<span class=\"k\">for</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">queue</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span>\n<span class=\"c1\"># keep in mind that the iterator uses priority_queue.dequeue() to get the next element, hence after the iteration </span>\n<span class=\"c1\"># is finished the queue will be empty</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">replace_priority</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"n\">priority</span><span class=\"p\">)</span> <span class=\"c1\"># replaces the given element's priority with the new priority argument</span>\n<span class=\"c1\"># raises PriorityQueueTypeError if type(priority) is not int</span>\n<span class=\"c1\"># raises PriorityQueueTypeError if queue.type is not None and is different than the type of the given element</span>\n<span class=\"c1\"># raises PriorityQueueElementError if the element is not contained in the queue</span>\n<span class=\"c1\"># in this implementation duplicated priorities are allowed, hence no elements will be ignored even if there is already</span>\n<span class=\"c1\"># an element assigned to the new priority</span>\n\n<span class=\"c1\"># you can also pass a third argument to the replace_priority method - comparison</span>\n<span class=\"n\">comparison_type</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">replace_priority</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">,</span> <span class=\"n\">priority</span><span class=\"p\">,</span> <span class=\"n\">comparison</span><span class=\"o\">=</span><span class=\"n\">comparison_type</span><span class=\"p\">)</span>\n<span class=\"c1\"># by doing so the priority of the element will only be replaced if a certain type of comparison between </span>\n<span class=\"c1\"># the two priorities holds</span>\n<span class=\"c1\"># if comparison is 1, the priorities will be replaced if the new priority is greater than the old priority</span>\n<span class=\"c1\"># if comparison is -1, the priorities will be replaced if the new priority is less than the old priority</span>\n<span class=\"c1\"># if comparison is None (default), the priorities will always be replaced</span>\n<span class=\"c1\"># raises ValueError if comparison is not -1, 1 or None</span>\n\n<span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"n\">remove_element</span><span class=\"p\">(</span><span class=\"n\">element</span><span class=\"p\">)</span> <span class=\"c1\"># finds and removes the element from the queue</span>\n<span class=\"c1\"># raises PriorityQueueTypeError if queue.type is not None and is different than the type of the given element</span>\n<span class=\"c1\"># raises PriorityQueueElementError if the queue doesn't contain the element</span>\n</pre>\n<p><br> <br></p>\n<ul>\n<li><strong><em>Graph<a></a></em></strong> <br>\nThe graph's implementation is generic: you can specify the type of elements in the graph in the constructor.\nIf not specified, it is set to None, hence objects of all types can be added to the graph. You can also set the\ndirected, oriented and weighted arguments in the constructor if you want to have a graph with a special feature.\nBy default, those arguments are set to False. Keep in mind that you cannot initialize a graph, which is oriented and\nnot directed at the same time. <br>\nNodes of the graph are stored in a list and a set, which allows fast checking\nwhether the graph contains a certain node in cost of memory. The graph doesn't support duplicate node values <br>\nEdges of the graph are stored in a square matrix: 2-dimensional list which is resized automatically when needed.\nThe initial length of the edges list is 5. A value of None in the matrix represents the absence of an edge. If the graph\nis not weighted a value of 1 represents the presence of a node. If the graph is weighted, an edge would be represented by\nits weight in the matrix and it must be either float or int. <br>\nThe indices in the 2-dimensional list are the indices of the nodes in the list. E.g. <br>\nif the list of nodes is:</li>\n</ul>\n<pre><span class=\"n\">nodes</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mf\">5.5</span><span class=\"p\">,</span> <span class=\"s2\">\"word\"</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">]</span>\n</pre>\n<p>and we have a non-directed and non-weighted graph with an edge between 5.5 and 100, the edges matrix will be</p>\n<pre><span class=\"n\">edges</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n<span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">],</span>\n<span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">],</span>\n<span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">],</span>\n<span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">],</span>\n<span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">]</span>\n<span class=\"p\">]</span>\n</pre>\n<p>Note the initial size of the matrix, which is 5 by 5 matrix. The indices of 5.5 and 100 in the list of nodes are 0 and 2\nrespectively and the graph is not directed. That's why edges[0][2] = edges[2][0] = 1.</p>\n<p><em>API</em> :</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">DataStructures.AbstractDataStructures</span> <span class=\"kn\">import</span> <span class=\"n\">Graph</span> <span class=\"c1\"># import the graph data structure</span>\n\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">Graph</span><span class=\"p\">()</span> <span class=\"c1\"># initialize a graph with None elements type, hence all types of elements can be added to the graph</span>\n<span class=\"c1\"># the initialized graph is also neither directed, nor oriented, nor weighted</span>\n\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">Graph</span><span class=\"p\">(</span><span class=\"n\">elements_type</span><span class=\"o\">=</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">directed</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">oriented</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">weighted</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"c1\"># only integers can be added to the initialized graph; the graph is directed, but not oriented; the graph is also weighted</span>\n \n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">Graph</span><span class=\"p\">(</span><span class=\"n\">elements_type</span><span class=\"o\">=</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">directed</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">oriented</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"n\">weighted</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"c1\"># this raises an InvalidGraphError since a graph cannot be oriented and not directed at the same time</span>\n\n<span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"n\">Graph</span><span class=\"p\">(</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">,</span> <span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"c1\"># only floats can be added to the initialized graph; the graph is directed, oriented and weighted</span>\n\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"c1\"># the number of elements in the graph</span>\n<span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">graph</span><span class=\"p\">)</span> <span class=\"c1\"># same as graph.size</span>\n\n<span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">graph</span><span class=\"p\">)</span> <span class=\"c1\"># returns a string in the format 'Graph: directed - boolean, oriented - boolean, weighted - boolean'</span>\n\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">type</span> <span class=\"c1\"># the type of node values in the graph, returns None if all types of elements are allowed</span>\n<span class=\"c1\"># if this method doesn't return None, only nodes of the returned type can be added to the graph</span>\n\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">directed</span> <span class=\"c1\"># True if the graph is directed and False otherwise</span>\n\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">oriented</span> <span class=\"c1\"># True if the graph is oriented and False otherwise</span>\n\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">weighted</span> <span class=\"c1\"># True if the graph is weighted and False otherwise</span>\n\n<span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_element\"</span>\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">contains</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span> <span class=\"c1\"># returns True if item is in the set of nodes of the graph and False otherwise</span>\n<span class=\"c1\"># raises a GraphTypeError if the type of the graph is not None and is different than the type of the argument</span>\n<span class=\"n\">boolean</span> <span class=\"o\">=</span> <span class=\"n\">item</span> <span class=\"ow\">in</span> <span class=\"n\">graph</span> <span class=\"c1\"># same as graph.contains(item)</span>\n\n<span class=\"n\">first_item</span> <span class=\"o\">=</span> <span class=\"s2\">\"first_test_item\"</span>\n<span class=\"n\">second_item</span> <span class=\"o\">=</span> <span class=\"s2\">\"second_test_item\"</span>\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">contains_edge</span><span class=\"p\">(</span><span class=\"n\">first_item</span><span class=\"p\">,</span> <span class=\"n\">second_item</span><span class=\"p\">)</span> <span class=\"c1\"># returns True if an edge from first_item to second_item exists</span>\n<span class=\"c1\"># raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments</span>\n<span class=\"c1\"># raises a GraphElementError if first_item or second_item is not a node that the graph contains</span>\n<span class=\"c1\"># if the graph is not directed the result will be the same even if you reverse the order of the arguments</span>\n\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">get_edge_weight</span><span class=\"p\">(</span><span class=\"n\">first_item</span><span class=\"p\">,</span> <span class=\"n\">second_item</span><span class=\"p\">)</span>\n<span class=\"c1\"># raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments</span>\n<span class=\"c1\"># raises a GraphElementError if first_item or second_item is not a node that the graph contains</span>\n<span class=\"c1\"># raises a GraphEdgeError if the graph is not weighted</span>\n<span class=\"c1\"># raises a GraphEdgeError if an edge between first_item and second_item doesn't exist</span>\n<span class=\"c1\"># if the graph is not directed the result will be the same even if you reverse the order of the arguments</span>\n\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">()</span> <span class=\"c1\"># returns a deep copy of the list of nodes of the graph</span>\n<span class=\"c1\"># a deep copy is returned to avoid manual changes of the graph by changing the elements in the returned list</span>\n \n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">add_node</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span> <span class=\"c1\"># adds item to the nodes of the graph if it is not already added</span>\n<span class=\"c1\"># raises a GraphTypeError if the type of the graph is not None and is different than the type of the argument</span>\n<span class=\"c1\"># raises an GraphElementError if item is None</span>\n<span class=\"c1\"># if item is already added as a node to the graph, the function does nothing</span>\n\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">remove_node</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span> \n<span class=\"c1\"># raises a GraphTypeError if the type of the graph is not None and is different than the type of the argument</span>\n<span class=\"c1\"># raises a GraphElementError if item is not a node in the graph</span>\n<span class=\"c1\"># remove a node in the graph also removes all edges related to this node (going to and from this node)</span>\n\n<span class=\"n\">old_node</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_old_node\"</span>\n<span class=\"n\">new_node</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_new_node\"</span>\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">replace_node</span><span class=\"p\">(</span><span class=\"n\">old_node</span><span class=\"p\">,</span> <span class=\"n\">new_node</span><span class=\"p\">)</span> <span class=\"c1\"># replaces old_node with new_node in the graph list of nodes if possible</span>\n<span class=\"c1\"># raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments</span>\n<span class=\"c1\"># raises a GraphElementError if old_node is not a node the graph contains</span>\n<span class=\"c1\"># raises a GraphElementError if new_node is a node the graph contains, since duplicate nodes are not allowed</span>\n\n<span class=\"c1\"># the replacing of a node in the graph doesn't affect the edges in the graph, e.g.</span>\n<span class=\"n\">connected_nodes</span> <span class=\"o\">=</span> <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edges_of</span><span class=\"p\">(</span><span class=\"n\">old_node</span><span class=\"p\">)</span>\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">replace_node</span><span class=\"p\">(</span><span class=\"n\">old_node</span><span class=\"p\">,</span> <span class=\"n\">new_node</span><span class=\"p\">)</span>\n<span class=\"n\">new_connected_nodes</span> <span class=\"o\">=</span> <span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edges_of</span><span class=\"p\">(</span><span class=\"n\">new_node</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">connected_nodes</span> <span class=\"o\">==</span> <span class=\"n\">new_connected_nodes</span><span class=\"p\">)</span> \n<span class=\"c1\"># will print True, since edges of the old node are not affected, only the value is replaced</span>\n<span class=\"c1\"># the method is useful, since it retains the edges of the old node </span>\n<span class=\"c1\"># and is faster than first removing the old node and then adding the new node</span>\n\n\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">()</span> <span class=\"c1\"># returns a deep copy of the square matrix (2D list) representing the edges of the graph</span>\n<span class=\"c1\"># a deep copy is returned to avoid manual changes of the graph by changing the elements in the returned list</span>\n\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">edges_of</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">)</span> <span class=\"c1\"># returns a list of all nodes to which there is an edge from the argument</span>\n<span class=\"c1\"># returns an empty list if there are no such nodes</span>\n<span class=\"c1\"># raises a GraphTypeError if the type of the graph is not None and is different than the type of the argument</span>\n<span class=\"c1\"># raises a GraphElementError if the item if not a node in the graph</span>\n\n<span class=\"n\">edge_weight</span> <span class=\"o\">=</span> <span class=\"s2\">\"test_edge_weight\"</span>\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">add_edge</span><span class=\"p\">(</span><span class=\"n\">first_item</span><span class=\"p\">,</span> <span class=\"n\">second_item</span><span class=\"p\">,</span> <span class=\"n\">edge_weight</span><span class=\"p\">)</span> <span class=\"c1\"># adds an edge from first_item to second_item with the given edge_weight if appropriate</span>\n<span class=\"c1\"># edge_weight should only be specified if the graph is weighted, otherwise, just skip this argument (set to None by default)</span>\n<span class=\"c1\"># raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments</span>\n<span class=\"c1\"># raises a GraphTypeError if edge_weight is specified and is not of type float or int</span>\n<span class=\"c1\"># raises a GraphElementError if first_item or second_item is not a node that the graph contains</span>\n<span class=\"c1\"># raises a GraphEdgeError if the graph is weighted and edge_weight is not specified or it is None</span>\n<span class=\"c1\"># raises a GraphEdgeError if the graph is oriented and an edge from second_item to first_item already exists</span>\n\n<span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"n\">remove_edge</span><span class=\"p\">(</span><span class=\"n\">first_item</span><span class=\"p\">,</span> <span class=\"n\">second_item</span><span class=\"p\">)</span> <span class=\"c1\"># removes the edge from first_item to second_item</span>\n<span class=\"c1\"># if the graph is not directed, this function removes the edge from second_item to first_item too</span>\n<span class=\"c1\"># raises a GraphTypeError if the type of the graph is not None and is different than the type of any of the arguments</span>\n<span class=\"c1\"># raises a GraphElementError if first_item or second_item is not a node that the graph contains</span>\n<span class=\"c1\"># raises a GraphEdgeError if there is no edge from first_item to second_item</span>\n\n<span class=\"c1\"># the implementation includes an iterator too</span>\n<span class=\"k\">for</span> <span class=\"n\">node</span> <span class=\"ow\">in</span> <span class=\"n\">graph</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">)</span>\n<span class=\"c1\"># the iterator goes through all nodes in the graph</span>\n<span class=\"c1\"># the __iter__ method actually returns the iterator of the list of nodes of the graph</span>\n</pre>\n\n          </div>"}, "last_serial": 4656729, "releases": {"0.1": [{"comment_text": "", "digests": {"md5": "a5c955985cc1594ccf3b062df5622429", "sha256": "dfd97a1d2f5ed752a0093f10063bd8c2e5847c4d4a1513f30149675c2ad9d2db"}, "downloads": -1, "filename": "pythonic_data_structures-0.1-py3-none-any.whl", "has_sig": false, "md5_digest": "a5c955985cc1594ccf3b062df5622429", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 19027, "upload_time": "2018-06-10T18:10:20", "upload_time_iso_8601": "2018-06-10T18:10:20.599035Z", "url": "https://files.pythonhosted.org/packages/aa/e0/190ec7bb6d11b612b81432568cfb70c4c94c8cfee5ba0f9b6e149821cb50/pythonic_data_structures-0.1-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "df58085e344fecfddcd4efa275cc49b2", "sha256": "e64f74515fac6ef2fe184d1df649d13c9e0742dfede0ae8802be3abc3165490a"}, "downloads": -1, "filename": "pythonic-data-structures-0.1.tar.gz", "has_sig": false, "md5_digest": "df58085e344fecfddcd4efa275cc49b2", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3", "size": 28242, "upload_time": "2018-06-10T18:10:22", "upload_time_iso_8601": "2018-06-10T18:10:22.378911Z", "url": "https://files.pythonhosted.org/packages/9c/92/6e26b280ae75a7872f6f6b5e17523842caccb45398454bcf1c9852fa815b/pythonic-data-structures-0.1.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "2ac2cc8c92e7edc0986986b8bca6d9d9", "sha256": "33003e27471daba887163bec47eba43165b1d7dfaf41310437cbd3c4b0b4eaa7"}, "downloads": -1, "filename": "pythonic-data-structures-0.2.1.tar.gz", "has_sig": false, "md5_digest": "2ac2cc8c92e7edc0986986b8bca6d9d9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3", "size": 27621, "upload_time": "2019-01-03T15:16:15", "upload_time_iso_8601": "2019-01-03T15:16:15.213250Z", "url": "https://files.pythonhosted.org/packages/57/e6/d2dc3d7b4973938e0982519dde3c56d1266925f6e0dc1646017af4f1a4eb/pythonic-data-structures-0.2.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "2ac2cc8c92e7edc0986986b8bca6d9d9", "sha256": "33003e27471daba887163bec47eba43165b1d7dfaf41310437cbd3c4b0b4eaa7"}, "downloads": -1, "filename": "pythonic-data-structures-0.2.1.tar.gz", "has_sig": false, "md5_digest": "2ac2cc8c92e7edc0986986b8bca6d9d9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3", "size": 27621, "upload_time": "2019-01-03T15:16:15", "upload_time_iso_8601": "2019-01-03T15:16:15.213250Z", "url": "https://files.pythonhosted.org/packages/57/e6/d2dc3d7b4973938e0982519dde3c56d1266925f6e0dc1646017af4f1a4eb/pythonic-data-structures-0.2.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:17:15 2020"}