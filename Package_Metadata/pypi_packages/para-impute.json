{"info": {"author": "Fangzhou Li", "author_email": "fzli0805@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Topic :: Software Development :: Build Tools"], "description": "# para-impute\n\nThe para-impute package is a parallelized missing value imputation Python package specialized for high-performance computing (HPC) environment. Currently, the package includes iterative random forest imputation algorithm, (also known as MissForest in R) [1].\n\n### Installation\n\n```\npip install para-impute\n```\n\n## Random Forest Imputer\n\nIn order to fully utilize the advantage provided by HPC, the package uses a novel parallelization approach to the missing value imputation task:\n- Splitting dataset features into different nodes\n- Splitting decision trees of random forest into different cores within each node\n\nRandom forest imputer relies on [RandomForestRegressor](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html#sklearn.ensemble.RandomForestRegressor) [2] and [RandomForestClassifier](https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier) [3] of Scikit-learn, so it is currently not available to directly take categorical variables. Instead, please use [one-hot encoder](https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html) [5] to transform your dataset. You should also input a list of column indices of categorical variable while fitting missing value datasets (see Methods in API section).\n\n### Pseudocode\n\n```\nPROGRAM RFImputer(Xmis)\n    N <- nrows(Xmis)\n    P <- ncols(Xmis)\n    Ximp <- Arrange the columns of Xmis in ascending order of the amount of missing values\n    Ximp <- Impute each missing values by the mean of all observed values in the same column\n\n    For each column C of Ximp\n        Obsi[C] <- indices of observed values\n        Misi[C] <- indices of missing values\n\n    While not meeting stopping criteria, iterate\n        Xold <- Copy Ximp\n        For each column D of Ximp\n            ObsX <- Ximp[Obsi[D], All columns except D]\n            ObsY <- Ximp[Obsi[D], D]\n            MisX <- Ximp[Misi[D], All columns except D]\n            MisY <- RandomForest(X_train=Obs, Y_train=ObsY, X_test=MisX)\n            Ximp[Misi[D], D] <- MisY\n\n    return Ximp\n```\nNote: Stopping criteria is defined as follow: when the first time the difference between the dataset of current and previous iteration increases, it stops the iteration and returns the dataset of previous iteration. The metrics for calculating difference are different for numerical and categorical variables.\n- For numerical variables, the difference is calculated by Root Mean Square Error (RMSE):\n```\ndiff = sum((Ximp - Xold) ** 2) / sum(Ximp ** 2)\n```\n- For categorical variables, the difference is calculated by error rate:\n```\ndiff = count(Ximp!=Xold) / #NA\n```\nFor mixed-type dataset (containing both numerical and categorical variables), either one of differences will trigger the stopping criteria.\n\n### Usage\n\n#### Input\n\nAn array-like data structure, with missing values represented by either float('nan') or np.nan:\n```python\n# Example 1\n>>> nan = float('nan')\n>>> Xmis = [[1.0, 2.0, 3.0],\n            [1.5, nan, 2.0],\n            [2.0, 1.0, nan]]\n\n# Example 2\n>>> nan = np.nan\n>>> Xmis = np.array([[1.0, 2.0, 3.0],\n                     [1.5, nan, 2.0],\n                     [2.0, 1.0, nan]])\n```\n#### Output\n\nA Numpy Array having the same shape and the same value, except the missing values, as the input:\n```python\n# Example 1\n>>> from pimpute import RFImputer\n\n>>> imputer = RFImputer(parallel='local')\n>>> Ximp = imputer.impute(Xmis)\n>>> Ximp\narray([[1.  , 2.  , 3.  ],\n       [1.5 , 1.51, 2.  ],\n       [2.  , 1.  , 2.27]])\n\n# Example 2\n>>> Xmis = array([[1. , 2. , 3. , 1. , 0. ],\n                  [1.5, nan, 2. , 0. , 1. ],\n                  [2. , 1. , nan, nan, nan]])\n>>> Ximp = imputer.impute(Xmis, cat_var=[3, 4])\n>>> Ximp\narray([[1.  , 2.  , 3.  , 1.  , 0.  ],\n       [1.5 , 1.52, 2.  , 0.  , 1.  ],\n       [2.  , 1.  , 2.45, 0.  , 1.  ]])\n```\n\n#### SLURM\n\nIf you run on 'slurm' mode, make sure you have accessed in machines that have installed SLURM.\n```python\n>>> from pimpute import RFImputer\n\n>>> nan = np.nan\n>>> Xmis = np.array([[1.0, 2.0, nan],\n                     [1.1, 2.2, 3.3],\n                     [1.5, nan, 5.0]])\n>>> imputer = RFImputer(max_iter=10, n_estimators=100, n_nodes=3, n_cores=10, parallel='slurm')\n>>> Ximp = imputer.impute(Xmis)\niteration 1\nSubmitted batch job 4836926\nSubmitted batch job 4836927\nSubmitted batch job 4836928\niteration 2\nSubmitted batch job 4836929\nSubmitted batch job 4836930\nSubmitted batch job 4836931\niteration 3\nSubmitted batch job 4836932\nSubmitted batch job 4836933\nSubmitted batch job 4836934\n>>> Ximp\narray([[1.  , 2.  , 3.  ],\n       [1.5 , 1.6 , 2.  ],\n       [2.  , 1.  , 2.2]])\n```\n\n## API\n```\nRFImputer(self, max_iter=10, init_imp='mean', n_estimators=100,\n                    max_depth=None, min_samples_split=2, min_samples_leaf=1,\n                    min_weight_fraction_leaf=0.0, max_features='sqrt',\n                    max_leaf_nodes=None, min_impurity_decrease=0.0,\n                    bootstrap=True, random_state=None, verbose=0,\n                    warm_start=False, class_weight=None, partition=None,\n                    n_cores=1, n_nodes=1, node_features=1, memory=2000,\n                    time='1:00:00', parallel='local'):\n\nParameters\n__________\nNOTE: Parameters are consisted by RFImputer parameters, RandomForest\nparameters, and SLURM parameters. Since RandomForest is implemented in\nscikit-learn, many parameters description will be directly referred to [2],\n[3], [4] that also use scikit-learn.\n\nmax_iter : int, optional (default=10)\n    The maximum number of iterations to achieve convergence. [What happens when it passes this? Warning?]\n\ninit_imp : string (default='mean')\n    The mode of initial imputation during the preprocessing:\n    - If 'mean', each missing value will be imputed with mean/mode value\n    - If 'zero', each missing value will be imputed with zero\n\nn_estimators : integer, optional (default=100)\n    The number of trees in the forest.\n\nmax_depth : integer or None, optional (default=None)\n    The maximum depth of the tree. If None, then nodes are expanded until all\n    leaves are pure or until\n    all leaves contain less than min_samples_split samples.\n\nmin_samples_split : int, float, optional (default=2)\n    The minimum number of samples required to split an internal node:\n    - If int, then consider min_samples_split as the minimum number.\n    - If float, then min_samples_split is a fraction and ceil(\n    min_samples_split * n_samples) are the minimum number of samples for\n    each split.\n\nmin_samples_leaf : int, float, optional (default=1)\n    The minimum number of samples required to be at a leaf node. A split point\n    at any depth will only be considered if it leaves at least\n    min_samples_leaf training samples in each of the left and right branches.\n    This may have the effect of\n    smoothing the model, especially in regression.\n    - If int, then consider min_samples_leaf as the minimum number.\n    - If float, then min_samples_leaf is a fraction and ceil(min_samples_leaf\n        * n_samples) are the minimum number of samples for each node.\n\nmin_weight_fraction_leaf : float, optional (default=0.)\n    The minimum weighted fraction of the sum total of weights (of all the\n    input samples) required to be at a leaf node. Samples have equal weight\n    when sample_weight is not provided.\n\nmax_features : int, float, string or None, optional (default='sqrt')\n    The number of features to consider when looking for the best split:\n\n    - If int, then consider max_features features at each split.\n    - If float, then max_features is a fraction and int(max_features *\n        n_features) features are considered at each split.\n    - If 'auto', then max_features=sqrt(n_features).\n    - If 'sqrt', then max_features=sqrt(n_features) (same as \u201cauto\u201d).\n    - If 'log2', then max_features=log2(n_features).\n    - If None, then max_features=n_features.\n    Note: the search for a split does not stop until at least one valid\n    partition of the node samples is found, even if it requires to effectively\n    inspect more than max_features features.\n\nmax_leaf_nodes : int or None, optional (default=None)\n    Grow trees with max_leaf_nodes in best-first fashion. Best nodes are\n    defined as relative reduction in impurity. If None then unlimited number\n    of leaf nodes.\n\nmin_impurity_decrease : float, optional (default=0.)\n    A node will be split if this split induces a decrease of the impurity\n    greater than or equal to this value.\n\n    The weighted impurity decrease equation is the following:\n\n    N_t / N * (impurity - N_t_R / N_t * right_impurity\n                        - N_t_L / N_t * left_impurity)\n    where N is the total number of samples, N_t is the number of samples at\n    the current node, N_t_L is the number of samples in the left child, and\n    N_t_R is the number of samples in the right child.\n\n    N, N_t, N_t_R and N_t_L all refer to the weighted sum, if sample_weight is\n    passed.\n\nbootstrap : boolean, optional (default=True)\n    Whether bootstrap samples are used when building trees. If False, the\n    whole datset is used to build each tree.\n\nrandom_state : int, RandomState instance or None, optional (default=None)\n    If int, random_state is the seed used by the random number generator; If\n    RandomState instance, random_state is the random number generator; If\n    None, the random number generator is the RandomState instance used by\n    np.random.\n\nverbose : int, optional (default=0)\n    Controls the verbosity when fitting and predicting.\n\nwarm_start : bool, optional (default=False)\n    When set to True, reuse the solution of the previous call to fit and add\n    more estimators to the ensemble, otherwise, just fit a whole new forest.\n    See the Glossary.\n\nclass_weight : dict, list of dicts, \u201cbalanced\u201d, \u201cbalanced_subsample\u201d or None,\noptional (default=None)\n    Weights associated with classes in the form {class_label: weight}. If not\n    given, all classes are supposed to have weight one. For multi-output\n    problems, a list of dicts can be provided in the same order as the columns\n    of y.\n\n    Note that for multioutput (including multilabel) weights should be defined\n    for each class of every column in its own dict. For example, for\n    four-class multilabel classification weights should be [{0: 1, 1: 1}, {0:\n        1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of [{1:1}, {2:5}, {3:1},\n        {4:1}].\n\n    The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights\n    inversely proportional to class frequencies in the input data as n_samples\n    / (n_classes * np.bincount(y))\n\n    The \u201cbalanced_subsample\u201d mode is the same as \u201cbalanced\u201d except that\n    weights are computed based on the bootstrap sample for every tree grown.\n\n    For multi-output, the weights of each column of y will be multiplied.\n\n    Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\npartition : string, optional (default=None)\n    SLURM parameter, specify your partition on SLURM. Default is specified by\n    the administrator of your HPC\n\nn_cores : int, optional (default=1)\n    The number of cores to process. If parallel == 'local', then n_cores is\n    exactly the same as n_jobs of Scikit-learn. Setting n_jobs to -1 on local\n    machine will use all available cores. If parallel = 'slurm', each node\n    uses n_cores number of cores, and it is no longer available to be set to\n    -1.\n\nn_nodes : int, optional (default=1)\n    SLURM parameter, specify how many machines (nodes) to use to process\n\nnode_features : int, optional (default=1)\n    SLURM parameter, specify how many variables to run in each node\n    concurrently. Set the number as high as possible to minimize the overhead\n    of parallelization. However, if you set this number too high, it will not\n    guarantee you will use all n_nodes number of nodes. Recommended number of\n    this parameter is #features / #n_nodes.\n\nmemory : int, optional (default=2000)\n    SLURM parameter. specify how much memory in term of MB to allocate for\n    each node.\n\ntime : string, optional (default='1:00:00')\n    SLURM parameter, specify the time limit of your process to survive. The\n    format should be strictly follow:\n    - 'minutes'\n    - 'minutes:seconds'\n    - 'hours:minutes:seconds'\n    - 'days-hours'\n    - 'days-hours:minutes'\n    - 'days-hours:minutes:seconds'\n\nparallel : string, optional (default='local')\n    - If 'local', impute on local machine\n    - If 'slurm', impute in parallel on SLURM machines\n\nAttributes\n__________\nvar_ : list\n    A list having the same length as the number of variables. Its elements are\n    1, 0, and 1 for numerical, 0 for categorical\n\nMethods\n_______\nfit_transform(self, xmis, cat_var=None)\uff1a\n    return the imputed dataset\n\n    Parameters\n    __________\n    xmis : {array-like}, shape (n_samples, n_features)\n        Input data, where 'n_samples' is the number of samples and\n        'n_features' is the number of features.\n\n    cat_var : list of ints (default=None)\n        Specifying the index of columns of categorical variable.\n\n    Return\n    ______\n    ximp : {array_like}, shape (n_samples, n_features)\n        Acquired after imputing all nan of xmis.\n\n```\n\n## Credits\n\n- [ChengEn Tan](https://github.com/bigghost2054) helped the implementation of parallelization\n- [Ilias Tagkoupolos](https://github.com/itagkopoulos) as the project advisor\n\n## Reference\n\n- [1] Stekhoven, Daniel J., and Peter B\u00fchlmann. \"MissForest\u2014non-parametric missing value imputation for mixed-type data.\" Bioinformatics 28.1 (2011): 112-118.\n- [2] https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html#sklearn.ensemble.RandomForestRegressor\n- [3] https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier\n- [4] https://github.com/epsilon-machine/missingpy\n- [5] https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/fangzhouli/para-impute", "keywords": "impute,imputation,missing data,missing value,missing value imputation,random forest,HPC,high-performance computing,computer cluster,SLURM", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "para-impute", "package_url": "https://pypi.org/project/para-impute/", "platform": "", "project_url": "https://pypi.org/project/para-impute/", "project_urls": {"Homepage": "https://github.com/fangzhouli/para-impute"}, "release_url": "https://pypi.org/project/para-impute/1.0.0/", "requires_dist": null, "requires_python": "", "summary": "Missing value imputation package for high-performance computing", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>para-impute</h1>\n<p>The para-impute package is a parallelized missing value imputation Python package specialized for high-performance computing (HPC) environment. Currently, the package includes iterative random forest imputation algorithm, (also known as MissForest in R) [1].</p>\n<h3>Installation</h3>\n<pre><code>pip install para-impute\n</code></pre>\n<h2>Random Forest Imputer</h2>\n<p>In order to fully utilize the advantage provided by HPC, the package uses a novel parallelization approach to the missing value imputation task:</p>\n<ul>\n<li>Splitting dataset features into different nodes</li>\n<li>Splitting decision trees of random forest into different cores within each node</li>\n</ul>\n<p>Random forest imputer relies on <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html#sklearn.ensemble.RandomForestRegressor\" rel=\"nofollow\">RandomForestRegressor</a> [2] and <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier\" rel=\"nofollow\">RandomForestClassifier</a> [3] of Scikit-learn, so it is currently not available to directly take categorical variables. Instead, please use <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html\" rel=\"nofollow\">one-hot encoder</a> [5] to transform your dataset. You should also input a list of column indices of categorical variable while fitting missing value datasets (see Methods in API section).</p>\n<h3>Pseudocode</h3>\n<pre><code>PROGRAM RFImputer(Xmis)\n    N &lt;- nrows(Xmis)\n    P &lt;- ncols(Xmis)\n    Ximp &lt;- Arrange the columns of Xmis in ascending order of the amount of missing values\n    Ximp &lt;- Impute each missing values by the mean of all observed values in the same column\n\n    For each column C of Ximp\n        Obsi[C] &lt;- indices of observed values\n        Misi[C] &lt;- indices of missing values\n\n    While not meeting stopping criteria, iterate\n        Xold &lt;- Copy Ximp\n        For each column D of Ximp\n            ObsX &lt;- Ximp[Obsi[D], All columns except D]\n            ObsY &lt;- Ximp[Obsi[D], D]\n            MisX &lt;- Ximp[Misi[D], All columns except D]\n            MisY &lt;- RandomForest(X_train=Obs, Y_train=ObsY, X_test=MisX)\n            Ximp[Misi[D], D] &lt;- MisY\n\n    return Ximp\n</code></pre>\n<p>Note: Stopping criteria is defined as follow: when the first time the difference between the dataset of current and previous iteration increases, it stops the iteration and returns the dataset of previous iteration. The metrics for calculating difference are different for numerical and categorical variables.</p>\n<ul>\n<li>For numerical variables, the difference is calculated by Root Mean Square Error (RMSE):</li>\n</ul>\n<pre><code>diff = sum((Ximp - Xold) ** 2) / sum(Ximp ** 2)\n</code></pre>\n<ul>\n<li>For categorical variables, the difference is calculated by error rate:</li>\n</ul>\n<pre><code>diff = count(Ximp!=Xold) / #NA\n</code></pre>\n<p>For mixed-type dataset (containing both numerical and categorical variables), either one of differences will trigger the stopping criteria.</p>\n<h3>Usage</h3>\n<h4>Input</h4>\n<p>An array-like data structure, with missing values represented by either float('nan') or np.nan:</p>\n<pre><span class=\"c1\"># Example 1</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">nan</span> <span class=\"o\">=</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"s1\">'nan'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Xmis</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">2.0</span><span class=\"p\">,</span> <span class=\"mf\">3.0</span><span class=\"p\">],</span>\n            <span class=\"p\">[</span><span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"n\">nan</span><span class=\"p\">,</span> <span class=\"mf\">2.0</span><span class=\"p\">],</span>\n            <span class=\"p\">[</span><span class=\"mf\">2.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">nan</span><span class=\"p\">]]</span>\n\n<span class=\"c1\"># Example 2</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">nan</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nan</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Xmis</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">2.0</span><span class=\"p\">,</span> <span class=\"mf\">3.0</span><span class=\"p\">],</span>\n                     <span class=\"p\">[</span><span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"n\">nan</span><span class=\"p\">,</span> <span class=\"mf\">2.0</span><span class=\"p\">],</span>\n                     <span class=\"p\">[</span><span class=\"mf\">2.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">nan</span><span class=\"p\">]])</span>\n</pre>\n<h4>Output</h4>\n<p>A Numpy Array having the same shape and the same value, except the missing values, as the input:</p>\n<pre><span class=\"c1\"># Example 1</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pimpute</span> <span class=\"kn\">import</span> <span class=\"n\">RFImputer</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">imputer</span> <span class=\"o\">=</span> <span class=\"n\">RFImputer</span><span class=\"p\">(</span><span class=\"n\">parallel</span><span class=\"o\">=</span><span class=\"s1\">'local'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Ximp</span> <span class=\"o\">=</span> <span class=\"n\">imputer</span><span class=\"o\">.</span><span class=\"n\">impute</span><span class=\"p\">(</span><span class=\"n\">Xmis</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Ximp</span>\n<span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">1.</span>  <span class=\"p\">,</span> <span class=\"mf\">2.</span>  <span class=\"p\">,</span> <span class=\"mf\">3.</span>  <span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mf\">1.5</span> <span class=\"p\">,</span> <span class=\"mf\">1.51</span><span class=\"p\">,</span> <span class=\"mf\">2.</span>  <span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mf\">2.</span>  <span class=\"p\">,</span> <span class=\"mf\">1.</span>  <span class=\"p\">,</span> <span class=\"mf\">2.27</span><span class=\"p\">]])</span>\n\n<span class=\"c1\"># Example 2</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Xmis</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">1.</span> <span class=\"p\">,</span> <span class=\"mf\">2.</span> <span class=\"p\">,</span> <span class=\"mf\">3.</span> <span class=\"p\">,</span> <span class=\"mf\">1.</span> <span class=\"p\">,</span> <span class=\"mf\">0.</span> <span class=\"p\">],</span>\n                  <span class=\"p\">[</span><span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"n\">nan</span><span class=\"p\">,</span> <span class=\"mf\">2.</span> <span class=\"p\">,</span> <span class=\"mf\">0.</span> <span class=\"p\">,</span> <span class=\"mf\">1.</span> <span class=\"p\">],</span>\n                  <span class=\"p\">[</span><span class=\"mf\">2.</span> <span class=\"p\">,</span> <span class=\"mf\">1.</span> <span class=\"p\">,</span> <span class=\"n\">nan</span><span class=\"p\">,</span> <span class=\"n\">nan</span><span class=\"p\">,</span> <span class=\"n\">nan</span><span class=\"p\">]])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Ximp</span> <span class=\"o\">=</span> <span class=\"n\">imputer</span><span class=\"o\">.</span><span class=\"n\">impute</span><span class=\"p\">(</span><span class=\"n\">Xmis</span><span class=\"p\">,</span> <span class=\"n\">cat_var</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Ximp</span>\n<span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">1.</span>  <span class=\"p\">,</span> <span class=\"mf\">2.</span>  <span class=\"p\">,</span> <span class=\"mf\">3.</span>  <span class=\"p\">,</span> <span class=\"mf\">1.</span>  <span class=\"p\">,</span> <span class=\"mf\">0.</span>  <span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mf\">1.5</span> <span class=\"p\">,</span> <span class=\"mf\">1.52</span><span class=\"p\">,</span> <span class=\"mf\">2.</span>  <span class=\"p\">,</span> <span class=\"mf\">0.</span>  <span class=\"p\">,</span> <span class=\"mf\">1.</span>  <span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mf\">2.</span>  <span class=\"p\">,</span> <span class=\"mf\">1.</span>  <span class=\"p\">,</span> <span class=\"mf\">2.45</span><span class=\"p\">,</span> <span class=\"mf\">0.</span>  <span class=\"p\">,</span> <span class=\"mf\">1.</span>  <span class=\"p\">]])</span>\n</pre>\n<h4>SLURM</h4>\n<p>If you run on 'slurm' mode, make sure you have accessed in machines that have installed SLURM.</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">pimpute</span> <span class=\"kn\">import</span> <span class=\"n\">RFImputer</span>\n\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">nan</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">nan</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Xmis</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">2.0</span><span class=\"p\">,</span> <span class=\"n\">nan</span><span class=\"p\">],</span>\n                     <span class=\"p\">[</span><span class=\"mf\">1.1</span><span class=\"p\">,</span> <span class=\"mf\">2.2</span><span class=\"p\">,</span> <span class=\"mf\">3.3</span><span class=\"p\">],</span>\n                     <span class=\"p\">[</span><span class=\"mf\">1.5</span><span class=\"p\">,</span> <span class=\"n\">nan</span><span class=\"p\">,</span> <span class=\"mf\">5.0</span><span class=\"p\">]])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">imputer</span> <span class=\"o\">=</span> <span class=\"n\">RFImputer</span><span class=\"p\">(</span><span class=\"n\">max_iter</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">n_estimators</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"n\">n_nodes</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">n_cores</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">parallel</span><span class=\"o\">=</span><span class=\"s1\">'slurm'</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Ximp</span> <span class=\"o\">=</span> <span class=\"n\">imputer</span><span class=\"o\">.</span><span class=\"n\">impute</span><span class=\"p\">(</span><span class=\"n\">Xmis</span><span class=\"p\">)</span>\n<span class=\"n\">iteration</span> <span class=\"mi\">1</span>\n<span class=\"n\">Submitted</span> <span class=\"n\">batch</span> <span class=\"n\">job</span> <span class=\"mi\">4836926</span>\n<span class=\"n\">Submitted</span> <span class=\"n\">batch</span> <span class=\"n\">job</span> <span class=\"mi\">4836927</span>\n<span class=\"n\">Submitted</span> <span class=\"n\">batch</span> <span class=\"n\">job</span> <span class=\"mi\">4836928</span>\n<span class=\"n\">iteration</span> <span class=\"mi\">2</span>\n<span class=\"n\">Submitted</span> <span class=\"n\">batch</span> <span class=\"n\">job</span> <span class=\"mi\">4836929</span>\n<span class=\"n\">Submitted</span> <span class=\"n\">batch</span> <span class=\"n\">job</span> <span class=\"mi\">4836930</span>\n<span class=\"n\">Submitted</span> <span class=\"n\">batch</span> <span class=\"n\">job</span> <span class=\"mi\">4836931</span>\n<span class=\"n\">iteration</span> <span class=\"mi\">3</span>\n<span class=\"n\">Submitted</span> <span class=\"n\">batch</span> <span class=\"n\">job</span> <span class=\"mi\">4836932</span>\n<span class=\"n\">Submitted</span> <span class=\"n\">batch</span> <span class=\"n\">job</span> <span class=\"mi\">4836933</span>\n<span class=\"n\">Submitted</span> <span class=\"n\">batch</span> <span class=\"n\">job</span> <span class=\"mi\">4836934</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">Ximp</span>\n<span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"mf\">1.</span>  <span class=\"p\">,</span> <span class=\"mf\">2.</span>  <span class=\"p\">,</span> <span class=\"mf\">3.</span>  <span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mf\">1.5</span> <span class=\"p\">,</span> <span class=\"mf\">1.6</span> <span class=\"p\">,</span> <span class=\"mf\">2.</span>  <span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mf\">2.</span>  <span class=\"p\">,</span> <span class=\"mf\">1.</span>  <span class=\"p\">,</span> <span class=\"mf\">2.2</span><span class=\"p\">]])</span>\n</pre>\n<h2>API</h2>\n<pre><code>RFImputer(self, max_iter=10, init_imp='mean', n_estimators=100,\n                    max_depth=None, min_samples_split=2, min_samples_leaf=1,\n                    min_weight_fraction_leaf=0.0, max_features='sqrt',\n                    max_leaf_nodes=None, min_impurity_decrease=0.0,\n                    bootstrap=True, random_state=None, verbose=0,\n                    warm_start=False, class_weight=None, partition=None,\n                    n_cores=1, n_nodes=1, node_features=1, memory=2000,\n                    time='1:00:00', parallel='local'):\n\nParameters\n__________\nNOTE: Parameters are consisted by RFImputer parameters, RandomForest\nparameters, and SLURM parameters. Since RandomForest is implemented in\nscikit-learn, many parameters description will be directly referred to [2],\n[3], [4] that also use scikit-learn.\n\nmax_iter : int, optional (default=10)\n    The maximum number of iterations to achieve convergence. [What happens when it passes this? Warning?]\n\ninit_imp : string (default='mean')\n    The mode of initial imputation during the preprocessing:\n    - If 'mean', each missing value will be imputed with mean/mode value\n    - If 'zero', each missing value will be imputed with zero\n\nn_estimators : integer, optional (default=100)\n    The number of trees in the forest.\n\nmax_depth : integer or None, optional (default=None)\n    The maximum depth of the tree. If None, then nodes are expanded until all\n    leaves are pure or until\n    all leaves contain less than min_samples_split samples.\n\nmin_samples_split : int, float, optional (default=2)\n    The minimum number of samples required to split an internal node:\n    - If int, then consider min_samples_split as the minimum number.\n    - If float, then min_samples_split is a fraction and ceil(\n    min_samples_split * n_samples) are the minimum number of samples for\n    each split.\n\nmin_samples_leaf : int, float, optional (default=1)\n    The minimum number of samples required to be at a leaf node. A split point\n    at any depth will only be considered if it leaves at least\n    min_samples_leaf training samples in each of the left and right branches.\n    This may have the effect of\n    smoothing the model, especially in regression.\n    - If int, then consider min_samples_leaf as the minimum number.\n    - If float, then min_samples_leaf is a fraction and ceil(min_samples_leaf\n        * n_samples) are the minimum number of samples for each node.\n\nmin_weight_fraction_leaf : float, optional (default=0.)\n    The minimum weighted fraction of the sum total of weights (of all the\n    input samples) required to be at a leaf node. Samples have equal weight\n    when sample_weight is not provided.\n\nmax_features : int, float, string or None, optional (default='sqrt')\n    The number of features to consider when looking for the best split:\n\n    - If int, then consider max_features features at each split.\n    - If float, then max_features is a fraction and int(max_features *\n        n_features) features are considered at each split.\n    - If 'auto', then max_features=sqrt(n_features).\n    - If 'sqrt', then max_features=sqrt(n_features) (same as \u201cauto\u201d).\n    - If 'log2', then max_features=log2(n_features).\n    - If None, then max_features=n_features.\n    Note: the search for a split does not stop until at least one valid\n    partition of the node samples is found, even if it requires to effectively\n    inspect more than max_features features.\n\nmax_leaf_nodes : int or None, optional (default=None)\n    Grow trees with max_leaf_nodes in best-first fashion. Best nodes are\n    defined as relative reduction in impurity. If None then unlimited number\n    of leaf nodes.\n\nmin_impurity_decrease : float, optional (default=0.)\n    A node will be split if this split induces a decrease of the impurity\n    greater than or equal to this value.\n\n    The weighted impurity decrease equation is the following:\n\n    N_t / N * (impurity - N_t_R / N_t * right_impurity\n                        - N_t_L / N_t * left_impurity)\n    where N is the total number of samples, N_t is the number of samples at\n    the current node, N_t_L is the number of samples in the left child, and\n    N_t_R is the number of samples in the right child.\n\n    N, N_t, N_t_R and N_t_L all refer to the weighted sum, if sample_weight is\n    passed.\n\nbootstrap : boolean, optional (default=True)\n    Whether bootstrap samples are used when building trees. If False, the\n    whole datset is used to build each tree.\n\nrandom_state : int, RandomState instance or None, optional (default=None)\n    If int, random_state is the seed used by the random number generator; If\n    RandomState instance, random_state is the random number generator; If\n    None, the random number generator is the RandomState instance used by\n    np.random.\n\nverbose : int, optional (default=0)\n    Controls the verbosity when fitting and predicting.\n\nwarm_start : bool, optional (default=False)\n    When set to True, reuse the solution of the previous call to fit and add\n    more estimators to the ensemble, otherwise, just fit a whole new forest.\n    See the Glossary.\n\nclass_weight : dict, list of dicts, \u201cbalanced\u201d, \u201cbalanced_subsample\u201d or None,\noptional (default=None)\n    Weights associated with classes in the form {class_label: weight}. If not\n    given, all classes are supposed to have weight one. For multi-output\n    problems, a list of dicts can be provided in the same order as the columns\n    of y.\n\n    Note that for multioutput (including multilabel) weights should be defined\n    for each class of every column in its own dict. For example, for\n    four-class multilabel classification weights should be [{0: 1, 1: 1}, {0:\n        1, 1: 5}, {0: 1, 1: 1}, {0: 1, 1: 1}] instead of [{1:1}, {2:5}, {3:1},\n        {4:1}].\n\n    The \u201cbalanced\u201d mode uses the values of y to automatically adjust weights\n    inversely proportional to class frequencies in the input data as n_samples\n    / (n_classes * np.bincount(y))\n\n    The \u201cbalanced_subsample\u201d mode is the same as \u201cbalanced\u201d except that\n    weights are computed based on the bootstrap sample for every tree grown.\n\n    For multi-output, the weights of each column of y will be multiplied.\n\n    Note that these weights will be multiplied with sample_weight (passed\n        through the fit method) if sample_weight is specified.\n\npartition : string, optional (default=None)\n    SLURM parameter, specify your partition on SLURM. Default is specified by\n    the administrator of your HPC\n\nn_cores : int, optional (default=1)\n    The number of cores to process. If parallel == 'local', then n_cores is\n    exactly the same as n_jobs of Scikit-learn. Setting n_jobs to -1 on local\n    machine will use all available cores. If parallel = 'slurm', each node\n    uses n_cores number of cores, and it is no longer available to be set to\n    -1.\n\nn_nodes : int, optional (default=1)\n    SLURM parameter, specify how many machines (nodes) to use to process\n\nnode_features : int, optional (default=1)\n    SLURM parameter, specify how many variables to run in each node\n    concurrently. Set the number as high as possible to minimize the overhead\n    of parallelization. However, if you set this number too high, it will not\n    guarantee you will use all n_nodes number of nodes. Recommended number of\n    this parameter is #features / #n_nodes.\n\nmemory : int, optional (default=2000)\n    SLURM parameter. specify how much memory in term of MB to allocate for\n    each node.\n\ntime : string, optional (default='1:00:00')\n    SLURM parameter, specify the time limit of your process to survive. The\n    format should be strictly follow:\n    - 'minutes'\n    - 'minutes:seconds'\n    - 'hours:minutes:seconds'\n    - 'days-hours'\n    - 'days-hours:minutes'\n    - 'days-hours:minutes:seconds'\n\nparallel : string, optional (default='local')\n    - If 'local', impute on local machine\n    - If 'slurm', impute in parallel on SLURM machines\n\nAttributes\n__________\nvar_ : list\n    A list having the same length as the number of variables. Its elements are\n    1, 0, and 1 for numerical, 0 for categorical\n\nMethods\n_______\nfit_transform(self, xmis, cat_var=None)\uff1a\n    return the imputed dataset\n\n    Parameters\n    __________\n    xmis : {array-like}, shape (n_samples, n_features)\n        Input data, where 'n_samples' is the number of samples and\n        'n_features' is the number of features.\n\n    cat_var : list of ints (default=None)\n        Specifying the index of columns of categorical variable.\n\n    Return\n    ______\n    ximp : {array_like}, shape (n_samples, n_features)\n        Acquired after imputing all nan of xmis.\n\n</code></pre>\n<h2>Credits</h2>\n<ul>\n<li><a href=\"https://github.com/bigghost2054\" rel=\"nofollow\">ChengEn Tan</a> helped the implementation of parallelization</li>\n<li><a href=\"https://github.com/itagkopoulos\" rel=\"nofollow\">Ilias Tagkoupolos</a> as the project advisor</li>\n</ul>\n<h2>Reference</h2>\n<ul>\n<li>[1] Stekhoven, Daniel J., and Peter B\u00fchlmann. \"MissForest\u2014non-parametric missing value imputation for mixed-type data.\" Bioinformatics 28.1 (2011): 112-118.</li>\n<li>[2] <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html#sklearn.ensemble.RandomForestRegressor\" rel=\"nofollow\">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestRegressor.html#sklearn.ensemble.RandomForestRegressor</a></li>\n<li>[3] <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier\" rel=\"nofollow\">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html#sklearn.ensemble.RandomForestClassifier</a></li>\n<li>[4] <a href=\"https://github.com/epsilon-machine/missingpy\" rel=\"nofollow\">https://github.com/epsilon-machine/missingpy</a></li>\n<li>[5] <a href=\"https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html\" rel=\"nofollow\">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html</a></li>\n</ul>\n\n          </div>"}, "last_serial": 6199461, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "290b59e5cd4365b55a9d6ac86d2dde65", "sha256": "580e29eef78f6931ab309ae2fc705209ab2f3c52fcada7ebbab9b2d2596afe7e"}, "downloads": -1, "filename": "para-impute-1.0.0.tar.gz", "has_sig": false, "md5_digest": "290b59e5cd4365b55a9d6ac86d2dde65", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16729, "upload_time": "2019-11-26T06:51:01", "upload_time_iso_8601": "2019-11-26T06:51:01.367801Z", "url": "https://files.pythonhosted.org/packages/9c/e0/c0448ad087756b7dcde28681d525599f8e47aa53fe301526b6d0ad31be4e/para-impute-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "290b59e5cd4365b55a9d6ac86d2dde65", "sha256": "580e29eef78f6931ab309ae2fc705209ab2f3c52fcada7ebbab9b2d2596afe7e"}, "downloads": -1, "filename": "para-impute-1.0.0.tar.gz", "has_sig": false, "md5_digest": "290b59e5cd4365b55a9d6ac86d2dde65", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16729, "upload_time": "2019-11-26T06:51:01", "upload_time_iso_8601": "2019-11-26T06:51:01.367801Z", "url": "https://files.pythonhosted.org/packages/9c/e0/c0448ad087756b7dcde28681d525599f8e47aa53fe301526b6d0ad31be4e/para-impute-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:58:40 2020"}