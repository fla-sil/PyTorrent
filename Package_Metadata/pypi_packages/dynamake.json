{"info": {"author": "Oren Ben-Kiki", "author_email": "oren@ben-kiki.org", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Software Development :: Build Tools"], "description": "DynaMake - Dynamic Make in Python\n=================================\n\n.. image:: https://travis-ci.org/tanaylab/dynamake.svg?branch=master\n    :target: https://travis-ci.org/tanaylab/dynamake\n    :alt: Build Status\n\n.. image:: https://readthedocs.org/projects/dynamake/badge/?version=latest\n    :target: https://dynamake.readthedocs.io/en/latest/?badge=latest\n    :alt: Documentation Status\n\nWHY\n---\n\n    *\"What the world needs is another build tool\"*\n\n    -- Way too many people\n\nSo, why yet *another* one?\n\nDynaMake's raisons d'etre are:\n\n* First class support for dynamic build graphs.\n\n* Fine-grained configuration control.\n\n* Python implementation.\n\nDynaMake was created to address a concrete need for repeatable configurable processing in the\ncontext of scientific computation pipelines, but should be applicable in wider problem domains.\n\nDynamic Build Graphs\n....................\n\nThis is a fancy way of saying that the following are supported:\n\n**Dynamic inputs**: The full set of inputs of a build step may depend on a subset of its inputs.\n\nAn example of dynamic inputs is compiling a C source file, which actually depends on all the\nincluded header files. For a more complex example, consider data analysis where the input data is\nclassified into one of several categories. The actual analysis results are obtained by a\ncategory-specific algorithm, which generates different input files for the final consolidation step.\n\nDynamic inputs are supported in various ways by most build tools - some of these ways being more\nconvoluted than others. DynaMake provides natural first-class support for such cases.\n\n**Dynamic outputs**: The set of outputs of a build step may depend on its inputs.\n\nAn example of dynamic outputs is running a clustering step on some large data, which may produce any\nnumber of clusters. Each of these clusters needs to go through some further processing. Perhaps only\nsome of these clusters need to be processed (based on some expensive-to-compute filter).\n\nDynamic outputs are sufficiently common in scientific computation pipelines that they are a major\nsource of pain. There are workarounds, for sure. But almost no existing tool has direct support for\nthem, and of the few tools that do, most do it as an afterthought. Since this issue has wide-ranging\nimplications on the build tool, this means they typically don't do it well. A notable exception is\n`Shake <https://shakebuild.com/>`_, which DynaMake is heavily inspired by.\n\nThe problem with dynamic outputs (and, to a lesser extent, dynamic inputs) is that they make other\nbuild tool features really hard to implement. Therefore, retrofitting them into an existing build\ntool causes some features to break. In the worst case this leads to silent broken builds.\n\nSome examples of features that become very difficult in the presence of a dynamic build graph are:\n\n* The ability to aggressively optimize the case when a build needs to do nothing at all, and\n  in general reduce the build system overhead.\n\n* The ability to perform a dry run that accurately lists *all* the steps that will be needed to\n  build an arbitrary target.\n\n* Having a purely declarative build language, which can be more easily learned than any programming\n  language (even Python :-) and may be processed as pure data by additional tools.\n\nConfiguration Control\n.....................\n\nThis is a fancy way of saying that you can tweak the parameters of arbitrary steps of a complex\npipeline, and then only execute the affected parts of the pipeline, either all the way to the final\nresults or just to obtain some intermediate results to examine. This use case occurs *a lot* in\nscientific computation pipelines.\n\nConfiguration parameters can be either specified as explicit command line options for executed\nactions, or inside configuration files(s). A few build tools will trigger a rebuild if the command\nline options have changed. All build tools will allow adding a configuration file as a dependency;\nhowever, this requires setting up a per-invocation configuration file which can become very unwieldy\nfor a large pipeline - especially when the \"same\" pattern step needs to be invoked with different\nconfigurations depending on the exact files (e.g., different compilation flags for different source\nfiles).\n\nDynaMake automates the generation of a per-invocation configuration file, based on a single central\nconfiguration file, so that on modification, only the affected actions are invoked. In addition,\nDynaMake tracks the list of inputs, outputs, actions and their command line options, so that any\nchange in the pipeline itself will trigger the invocation of the affected actions.\n\nThis functionality requires keeping additional persistent state between invocation. This state is\nstored as human-readable (YAML) files in a special directory (by default, ``.dynamake``, but you can\noverride it using the ``DYNAMAKE_PERSISTENT_DIR`` environment variable). The file names are legible\n(based on the step name and its parameters, if any), so it is easy to examine them after the fact to\nunderstand exactly which parameter values were used where.\n\nIn rare cases, there are good reasons to avoid any such additional persistent state. DynaMake allows\ndisabling these features, switching to relying only on the modification times of the input files.\nThis of course results in less reliable rebuilds.\n\nPython\n......\n\nDynaMake was initially created to address the needs of automating scientific computation pipelines\n(specifically in bio-informatics, specifically in single-cell RNA sequencing, not that it matters).\nHowever, it is a general-purpose build tool, which may be useful for a wide range of users.\n\nDynaMake is heavily inspired by `Shake <https://shakebuild.com/>`_. However, ``shake`` is\nimplemented in `Haskell <https://www.haskell.org/>`_. Haskell is unlikely to be pre-installed on a\ntypical machine, and installing it (and ``shake``) is far from trivial, especially when one has no\n``sudo`` privileges. Also, writing ``shake`` rules uses Haskell syntax which, while being simple and\nat times superior, is pretty different from that of most popular programming languages.\n\nIn contrast, Python is much more likely to already be installed on a typical machine. It is trivial\nto just type ``pip install --user dynamake`` (or ``sudo pip install dynamake`` if you have ``sudo``\nprivileges). The build rules are simple Python scripts, which means most people are already familiar\nwith the language, or are in the process of becoming so for other reasons.\n\nUsing a proven and familiar language is also preferable to coming up with a whole new build-oriented\nlanguage, especially when creating a general-purpose build tool. The GNU ``make`` syntax is a\nwarning for how such specialized languages inevitably devolve into a general-purpose mess.\n\nWHY NOT\n-------\n\nDynaMake's unique blend of features comes at some costs:\n\n* It is a new, immature tool. As such, it lacks some features it could/should provide,\n  is less efficient than it could be, and you may encounter the occasional bug. Hopefully this will\n  improve with time. If you want DynaMake-like features with a proven track record, you should\n  consider ``shake``.\n\n* The provided goals, as described above, may be a poor fit for your use case.\n\n  If your build graph and configuration are truly static, consider using `Ninja\n  <https://ninja-build.org/>`_ which tries to maximize the benefits of such a static build pipeline.\n  It is almost the opposite of DynaMake in this respect.\n\n  If your build graph is only \"mostly static\" (e.g., just needs a restricted form of dynamic inputs,\n  such as included header files), then you have (too) many other options to list here. Using the\n  classical ``make`` is a good default choice.\n\n* It is a low-level build tool, on par with ``make`` and ``ninja``.\n\n  If you are looking for a tool that comes with a lot of built-in rules for dealing with specific\n  computer languages (say, C/C++), and will automatically deal with cross-platform issues,\n  consider using `CMake <https://cmake.org/>`_ or `XMake <https://xmake.io/>`_ instead.\n\nWHAT\n----\n\nDynaMake is essentially a Python library. There is a ``dynamake`` universal executable script\nprovided with the package, similar to `SCons <https://scons.org/>`_, but you still need to write\nyour build script in Python, using the library's utilities, and you can also easily invoke the\nprovided ``make`` main function from your code. You can even directly invoke the build functionality\nfrom your own custom main function.\n\nDynaMake build steps may invoke applications written in any language, which are configured in any\nway (command line flags, configuration files, etc.).\n\nAs a convenience, DynaMake also provides utilities for writing Python \"configurable applications\"\nwhich make heavy use of DynaMake's automated configuration control. A ``dynamain`` universal\nexecutable script removes the need to wrap each Python function in its own executable script, and\nyou can easily invoke the provided ``main`` function from your code. You can even directly invoke\nthe configurable application functions from your own custom main function.\n\nBuild Scripts\n.............\n\nA typical build script consists of a set of step functions, which are functions decorated with\n``dynamake.make.step``. This requires an explicit ``output=...`` parameter listing the\nfile(s) created by the step.\n\nHere is a DynaMake build script which copies the file ``foo`` to the file ``bar``, if ``bar`` does\nnot exist, or if ``foo`` is newer than ``bar``:\n\n.. code-block:: python\n\n    import dynamake.make as dm\n\n    @dm.step(output='foo')\n    async def copy_bar_to_foo() -> None:\n        dm.require('bar')\n        await dm.shell('cp bar foo')\n\nThis is essentially equivalent to the ``make`` rule:\n\n.. code-block:: make\n\n    foo: bar\n            cp bar foo\n\nThat is, DynaMake will only execute the shell command ``cp bar foo`` if the ``foo`` file is missing\nor is older than the ``bar`` file. In general, DynaMake will skip actions unless it finds a\nsufficient reason to execute them. If there are multiple actions in a step, and DynaMake skipped\nsome to discover that a later action needs to be executed, then DynaMake restarts the step, and this\ntime executes all actions. That is, step functions are (should be) \"idempotent\"; re-running a step\nmultiple times should have no effect.\n\nThe Python version is more verbose, so if this was all there was to it, ``make`` would have been\npreferable. However, DynaMake allows one to specify scripts that are impossible in ``make``,\njustifying the additional syntax.\n\nFor example, inside each step, you can do the following:\n\n* Invoke ``dynamake.make.require`` to ensure the specified path exists and is and up-to-date.\n  Building of required input files is done asynchronously (concurrently).\n\n* Invoke ``await`` of ``dynamake.make.sync`` to ensure all required input files specified so\n  far have completed to build.\n\n* Invoke ``await`` of ``dynamake.make.shell`` or ``dynamake.make.spawn`` to trigger\n  the execution of a shell command or an external program. This will automatically ``sync`` first\n  to ensure all required input files have completed to build.\n\n.. note::\n\n   **Inside a step, do not simply ``await`` co-routines that are not provided by DynaMake.**\n\n   DynaMake tracks the current step, and invoking ``await`` of some other co-routines will confuse\n   it. Use ``dynamake.make.done`` to ``await`` on external co-routines. That is, write\n   ``await done(something())`` rather than ``await something()``.\n\n* Use Python code to examine the file system (it is recommended to use\n  ``dynamake.stat.Stat`` for cached ``stat`` operations), analyze the content of\n  required input files (following a ``sync``), perform control flow operations (branches, loops),\n  invoke Python functions which do any of these things, etc.\n\n.. note::\n\n    **The correctness of the ``stat`` cache depends on accurate listing of each action's inputs and\n    outputs.**\n\n    In general DynaMake needs these lists to be accurate for correct operation. This is true of\n    almost any build tool. In theory, one could use ``strace`` to automatically extract the true\n    lists of inputs and outputs, but this is complex, fragile (breaks for programs running on\n    cluster servers), and impacts the performance.\n\nThe ability to mix general Python code together with ``make`` functionality is what gives DynaMake\nits additional power over static build tools like ``make`` or ``ninja``. The following examples\nwill demonstrate some common idioms using this power.\n\nPattern Steps\n.............\n\nA more generic script might be:\n\n.. code-block:: python\n\n    import dynamake.make as dm\n    from c_source_files import scan_included_files  # Assume this for simplicity.\n\n    # Naive: does not handle a cycle of files including each other,\n    # does not allow for missing include files (e.g. in #ifdef),\n    # doesn't cache results, etc.\n    def require_included_files(paths: *Strings) -> None:\n        dm.require(*paths)\n        sync()\n        for included_path in dm.each_string(*paths):\n            require_included_files(scan_included_files(included_path))\n\n    @dm.step(output='obj/{*name}.o')\n    async def make_object(**kwargs: str) -> None:\n        source_path = 'src/{name}.c'.format(**kwargs)\n        source_path = dm.fmt(kwargs, 'src/{name}.c')  # Same as above\n        source_path = dm.e('src/{name}.c')  # Same as above\n        require_included_files(source_path)\n        await dm.espawn('cc', '-o', 'obj/{name}.o', source_path)\n\n    @dm.step(output='bin/main')\n    async def make_executable() -> None:\n        object_paths = dm.glob_fmt('src/{*name}.c', 'obj/{name}.o')\n        dm.require(object_paths)\n        await dm.spawn('ld', '-o', 'bin/main.o', object_paths)\n\nThis demonstrates some additional concepts:\n\n* If the ``output`` of a step contains a ``dynamake.patterns.capture`` pattern, then the\n  extracted values are passed to the function as string arguments. These can be used inside the\n  function to generate file names (in the above, the source file names).\n\n  This is similar to ``make`` pattern rules, but is more powerful, as you can specify multiple parts\n  of the file name to be captured. A pattern such as ``foo/{*phase}/{*part}/bar`` is essentially\n  impossible to express in ``make``.\n\n  When a target is ``require``-d, it is matched against these patterns, and the unique step that\n  matches the target is triggered, with the appropriate (extracted) arguments. It is an error for\n  more than one step to match. If no step matches, the target is assumed to be a source file, and\n  must exist on the disk. Otherwise, DynaMake complains it doesn't know how to make this target.\n\n* DynaMake provides many functions to deal with ``glob``-ing, capturing, and formatting lists\n  of strings, listed in the ``dynamake.patterns`` module. These make it convenient to perform\n  common operations. For example, ````dynamake.make.e``` is equivalent to\n  ``dynamake.patterns.fmt`` using the ``kwargs`` of the current step. This is an extremely\n  common operation so we give it such a short function name. Another example is\n  ``dynamake.patterns.glob_fmt`` which uses a ``glob`` to obtain a list of file names, then\n  ``extract`` some part(s) of each, then ``fmt`` some other pattern(s) using these values.\n\n* Most DynaMake functions accept ``Strings``, that is, either a single string, or a list of\n  strings, or a list of list of strings, etc.; but they return either a single string or a flat list\n  of strings. This makes it easy to pass the output of one function to another. You can also use\n  this in your own functions, for example in ``require_included_files``.\n\n* The ``output`` of a step is also ``Strings``, that is, may be a list of files that are created\n  by the actions in the step. In contrast, many tools (most notably, ``make``) can't handle the\n  notion of multiple outputs from a single step.\n\n* The ``require_included_files`` is an example of how a step can examine the content of some\n  required input file(s) to determine whether it needs additional required input file(s), or, in\n  general, to make any decisions on how to proceed further. Note that it tries to ``require`` as\n  many files as possible concurrently before invoking ``sync``. Actual processing\n  (``scan_included_files``) is done serially.\n\nDynamic Outputs\n...............\n\nWhen a step may produce a dynamic set of outputs, it must specify an ``output`` pattern\nwhich includes some non captured parts (whose name starts with ``_``). For example:\n\n.. code-block:: python\n\n    import dynamake.make as dm\n\n    @dm.step(output=['unzipped_messages/{*id}/{*_part}.txt',\n                     'unzipped_messages/{*id}/.all.done')\n    async def unzip_message(**kwargs: str) -> None:\n        dm.require('zipped_messages/{id}.zip'.format(**kwargs))\n        await dm.shell('unzip ...')\n        await dm.eshell('touch unzipped_messages/{id}/.all.done')\n\nNote that only ``id`` will be set in ``kwargs``. DynaMake assumes that the same invocation will\ngenerate all ``_part`` values in one call. This demonstrates another point: if a step specifies\nmultiple ``output`` patterns, each must capture the same named argument(s) (in this case ``name``),\nbut may include different (or no) non-captured path parts.\n\nThe ``dynamake.make.eshell`` is equivalent to ``shell(e(...))``, that is, it automatically\nformats all the string(s) using the step's ``kwargs``. DynaMake defines several additional such\nfunctions with an ``e`` prefix, for example ``dynamake.make.erequire`` and\n``dynamake.make.eglob_paths``.\n\nRequiring *any* of the specific output files will cause the step to be invoked and ensure *all*\noutputs are up-to-date. A common trick, demonstrated above, it to have an additional final file\nserve as a convenient way to require all the files. This allows to query the filesystem for the full\nlist of files. For example, assume each part needs to be processed:\n\n.. code-block:: python\n\n    @dm.step(output='processed_messages/{*id}/{*part}.txt')\n    async def process_part(**kwargs) -> None:\n        dm.require('unzipped_messages/{id}/{part}.txt'.format(**kwargs))\n        ...\n\nAnd that all parts need to be collected together:\n\n.. code-block:: python\n\n    @dm.step(output='collected_messages/{*id}.txt')\n    async def collect_parts(**kwargs) -> None:\n        dm.require('unzipped_messages/{id}/.all.done'.format(**kwargs))\n        await dm.sync()\n        all_parts = dm.eglob_fmt('unzipped_messages/{id}/{*part}.txt',\n                                 'processed_messages/{id}/{*part}.txt')\n        await dm.eshell('cat', sorted(all_parts), '>', 'collected_messages/{id}.txt')\n\nThis sort of flow can only be approximated using static build tools. Typically this is done using\nexplicit build phases, instead of a unified build script. This results in brittle build systems,\nwhere the safe best practice if anything changes is to \"delete all files and rebuild\" to ensure the\nresults are correct.\n\nUniversal Main Program\n......................\n\nInstalling DynaMake provides a universal executable build script called ``dynamake``, which is a\nthin wrapper around the generic ``dynamake.make.make`` main function. The easiest way to\ninvoke DynaMake is to place your steps inside ``DynaMake.py`` (or modules included by\n``DynaMake.py``) and invoke this ``dynamake`` script. You can also specify explicit ``--module``\noptions in the command line to directly import your step functions from other Python modules.\n\nYou can write your own executable script:\n\n.. code-block:: python\n\n    import argparse\n    import dynamake.make as dm\n    import my_steps\n\n    dm.make(argparse.ArgumentParser(description='...'))\n\nWhich will come pre-loaded with your own steps, and allow you to tweak the program's help message\nand other aspects, if needed. This is especially useful if you are writing a package that wants to\nprovide pre-canned steps for performing some complex operation (such as a scientific computation\npipeline).\n\nFinally, you can directly invoke the lower-level API to use build steps as part of your code.\nSee the implementation of the ``make`` function and the API documentation for details.\n\nAnnotations\n...........\n\nDynaMake allows attaching annotations (``dynamake.patterns.AnnotatedStr``) to strings (and\npatterns). Multiple annotations may be applied to the same string. The provided string processing\nfunctions preserve these (that is, pass the annotations from the input(s) to the output(s)). These\nannotations are used by DynaMake to modify the handling of required and output files, and in some\ncases, control formatting.\n\n* ``dynamake.patterns.optional`` indicates that an output need not exist at the end of the\n  step, or a required file need not exist for the following actions to succeed. That is, invoking\n  ``require(optional('foo'))`` will invoke the step that provides ``foo``. If there is no such step,\n  then ``foo`` need not exist on the disk. If this step exists, and succeeds, but does not in fact\n  create ``foo``, and specifies ``output=optional('foo')``, then DynaMake will accept this and\n  continue. If either of the steps did not specify the ``optional`` annotation, then DynaMake will\n  complain and abort the build.\n\n* ``dynamake.patterns.exists`` ignores the modification time of an input or an output,\n  instead just considering whether it exists. That is, invoking ``require(exists('foo'))``\n  will attempt to build ``foo`` but will ignore its timestamp when deciding whether to\n  skip the execution of following actions in this step. Specifying ``output=exists('foo')``\n  will disable touching the output file to ensure it is newer than the required input file(s)\n  (regardless of the setting of ``--touch_success_outputs``).\n\n* ``dynamake.patterns.precious`` prevents output file(s) from being removed\n  (regardless of the setting of ``--remove_stale_outputs`` and ``--remove_failed_outputs``).\n\n* ``dynamake.patterns.phony`` marks an output as a non-file target. Typically the\n  default top-level ``all`` target is ``phony``, as well as similar top-level targets such as\n  ``clean``. When a step has any ``phony`` output(s), its actions are always executed, and a\n  synthetic modification time is assigned to it: one nanosecond newer than the newest required\n  input.\n\n  If using persistent state to track actions (see below), this state will ignore any parts of\n  invoked commands that are marked as ``phony``. This prevents changes irrelevant command line\n  options from triggering a rebuild. For example, changing the value passed to the ``--jobs``\n  command line option of a program should not impact its outputs, and therefore should not trigger a\n  rebuild.\n\n  TODO: Clarify distinction between phony and optional (especially when using persistent state).\n\n* ``dynamake.patterns.emphasized`` is used by ``shell`` and ``spawn``. Arguments\n  so annotated are printed in **bold** in the log file. This makes it easier to see the important\n  bits of long command lines.\n\nControl Flags\n.............\n\nThe behavior of DynaMake can be tweaked by modifying the options specified in\n``dynamake.make.Make``. This is typically done by specifying the appropriate command line\noption which is then handled by the provided ``make`` main function.\n\n* ``--rebuild_changed_actions`` controls whether DynaMake uses the persistent state to track\n  the list of outputs, inputs, invoked sub-steps, and actions with their command line options. This\n  ensures that builds are repeatable (barring changes to the environment, such as compiler versions\n  etc.). By default this is ``True``.\n\n  Persistent state is kept in YAML files named ``.dynamake/step_name.actions.yaml`` or, for\n  parameterized steps, ``.dynamake/step_name/param=value&...&param=value.actions.yaml``. As a\n  convenience, this state also includes the start and end time of each of the invoked actions. This\n  allows post-processing tools to analyze the behavior of the build script (as an alternative to\n  analyzing the log messages).\n\n* ``--failure_aborts_build`` controls whether DynaMake stops the build process on the first\n  failure. Otherwise, it attempts to continue to build as many unaffected targets as possible.\n  By default this is ``True``.\n\n* ``--remove_stale_outputs`` controls whether DynaMake removes all (non-``precious``) outputs\n  before executing the first action of a step. By default this is ``True``.\n\n* ``--wait_nfs_outputs`` controls whether DynaMake will wait before pronouncing that an output\n  file has not been created by the step action(s). This may be needed if the action executes on a\n  server in a cluster using an NFS shared file system, as NFS clients are typically caching ``stat``\n  results (for performance).\n\n* ``--nfs_outputs_timeout`` controls the amount of time DynaMake will wait for output files\n  to appear after the last step action is done. By default this is 60 seconds, which is the\n  default NFS stat cache timeout. However, heavily loaded NFS servers have been known to\n  lag for longer of periods of time.\n\n* ``--touch_success_outputs`` controls whether DynaMake should touch (non-``exists``) output\n  file(s) to ensure their modification time is later than that of (non-``exists``) required input\n  files(s). By default this is ``False`` because DynaMake uses the nanosecond modification time,\n  which is supported on most modern file systems. The modification times on old file systems used a\n  1-second resolution, which could result in the output having the same modification time as the\n  input for a fast operation.\n\n  This option might still be needed if an output is a directory (not a file) and is ``precious`` or\n  ``--remove_stale_outputs`` is ``False``. In this case, the modification time of a pre-existing\n  directory will not necessarily be updated to reflect the fact that output file(s) in it were\n  created or modified by the action(s). In general it is not advised to depend on the modification\n  time of directories; it is better to specify a glob matching the expected files inside them, or\n  use an explicit timestamp file.\n\n* ``--remove_failed_outputs`` controls whether DynaMake should remove (non-``precious``) output\n  files when a step action has failed. This prevents corrupt output file(s) from remaining on\n  the disk and being used in later invocations or by other programs. By default this is ``True``.\n\n* ``-remove_empty_directories`` controls whether DynaMake will remove empty directories resulting\n  from removing any output file(s). By default this is ``False``.\n\n* ``--jobs`` controls the maximal number of ``shell`` or ``spawn`` actions that are invoked at the\n  same time. By default this is the number of (logical) processors in the system (``nproc``). A\n  value of ``1`` will force executing one action at a time. You can override this default using the\n  ``DYNAMAKE_JOBS`` environment variable.\n\n  A value of ``0`` will allow for unlimited number of parallel actions. This is useful if actions\n  are to be be executed on a cluster of servers instead of on the local machine, or if some other\n  resource(s) are used to restrict the number of parallel actions (see below).\n\n.. note::\n\n    **The DynaMake python code itself is not parallel.**\n\n    DynaMake always runs on a single process. Parallelism is the result of DynaMake executing an\n    external action, and instead of waiting for it to complete, switching over to a different step\n    and processing it until it also executes an external action, and so on. Thus actions may execute\n    in parallel, while the Python code is still doing only one thing at a time. This greatly\n    simplifies reasoning about the code. Specifically, if a piece of code contains no ``await``\n    calls, then it is guaranteed to \"atomically\" execute to completion, so there is no need for a\n    lock or a mutex to synchronize between the steps, even when they share some data.\n\nBuild Configuration\n...................\n\nThe above control flags are an example of global build configuration parameters. In general, such\nparameters have a default, can be overridden by some command line option, and may be used by any\n(possibly nested) function of the program.\n\nThe use of global configuration parameters isn't unique to DynaMake scripts. Therefore, it has been\nfactored out and is provided on its own via the ``dynamake.application`` module, described\nbelow.\n\nA quick example of how such parameters can be used is:\n\n.. code-block:: python\n\n    import dynamake.make as dm\n\n    dm.Param('mode', ...)\n\n    MODE_FLAGS = {\n        'debug': [ ... ],\n        'release': [ ... ],\n    }\n\n    @dm.step(output='obj/{*name}.o')\n    async def make_object(mode: str = dm.env(), **kwargs: str) -> None:\n        dm.require('src/{name}.c'.format(**kwargs))\n        await dm.espawn('cc', '-o', 'obj/{name}.o', MODE_FLAGS[mode], source_path)\n\nThat is, constructing a new ``dynamake.application.Param`` specifies the default value and\ncommand line option(s) for the parameter, and using ``dynamake.application.env`` as the\nparameter's default value will ensure the proper value is passed to the step invocation.\n\nThe provided ``make`` main function will also load the parameter values specified in the file\n``DynaConf.yaml``, if it exists, or any files specified using the ``--config`` command line option.\n\nParallel Resources\n..................\n\nAs mentioned above, DynaMake will perform all ``require`` operations concurrently, up to the next\n``sync`` call of the step (which automatically happens before any ``shell`` or ``spawn`` action). As\na result, by default DynaMake will execute several actions in parallel, subject to the setting of\n``--jobs``.\n\nIt is possible to define some additional resources using ``dynamake.make.resources`` to\nrestrict parallel execution. For example, specifying ``resource_parameters(ram=1, io=1)`` will\ncreate two new resources, ``ram`` and ``io``, which must have been previously defined using\nconfiguration ``Param`` calls. The values specified are the default consumption for actions that do\nnot specify an explicit value.\n\nThen, when invoking ``shell`` or ``spawn``, it is possible to add ``ram=...`` and/or ``io=...``\nnamed arguments to the call, to override the expected resource consumption of the action. DynaMake\nwill ensure that the sum of these expected consumptions will never exceed the established limit.\n\nAction Configuration\n....................\n\nA major use case of DynaMake is fine-grained control over configuration parameters\nfor controlling step actions.\n\nFor example, let's allow configuring the compilation flags in the above example(s):\n\n.. code-block:: python\n\n    import dynamake.make as dm\n\n    @dm.step(output='obj/{*name}.o')\n    async def make_object(**kwargs: str) -> None:\n        dm.require('src/{name}.c'.format(**kwargs))\n        await dm.espawn('cc', '-o', 'obj/{name}.o', dm.config_param('flags'), source_path)\n\nAnd create a YAML configuration file as follows:\n\n.. code-block:: yaml\n\n   - when:\n       step: make_object\n     then:\n       flags: [-g, -O2]\n\n   - when:\n       step: make_object\n       name: main\n     then:\n       flags: [-g, -O3]\n\nThis configuration file needs to be loaded using ``dynamake.config.Config.load``. The\nprovided ``make`` main function will automatically load the ``DynaMake.yaml`` configuration file, if\nit exists, followed by any file specified using the ``--step_config`` command line option(s), if\nany.\n\n.. note::\n\n    **Do not confuse build and step configuration files.**\n\n    The ``DynaConf.yaml`` and ``--config`` files control the **build** configuration parameters.\n    The ``DynaMake.yaml`` and ``--step_config`` control control the **steps** configuration\n    parameters. Thus the ``DynaConf.yaml`` contains simple build parameter values, while\n    ``DynaMake.yaml`` contains configuration **rules** used to decide on the parameter values for\n    each build step invocation.\n\nExplicitly using configuration parameters as shown above is needed when executing generic programs.\nIf, however, the action invokes a program implemented using the ``dynamake.application``\nfunctions, it is possible to do better, by using a generated action configuration file. For\nexample:\n\n.. code-block:: python\n\n    @dm.step(output='foo')\n    async def make_foo() -> None:\n        require('bar')\n        await spawn('dynamain', 'bar_to_foo', '--config', dm.config_file(), ...)\n\nIf ``dynamake.make.config_file`` is invoked, then DynaMake will generate a configuration file\ncontaining just the parameter values for this specific step invocation. If this file is missing or\ncontains different values, than it will trigger the actions, even if the output files otherwise seem\nup-to-date. Thus, even if the main ``DynaConf.yaml`` file is modified, an action will only be\nrebuilt if its own effective parameter values have changed.\n\nThe paths to the generated configuration files are similar to the path to the persistent state\nfiles: ``.dynamake/step_name.config.yaml`` or\n``.dynamake/step_name/param=value&param=value.config.yaml``. Thus, if for some reason you want to\navoid all persistent state, you should not use this functionality.\n\nAs an additional convenience, DynaMake provides the ``dynamake.make.submit`` function which\nallows the action configuration file to specify a ``run_prefix`` and/or ``run_suffix`` around what\nwould otherwise be a normal `spawn` action. For example:\n\n.. code-block:: python\n\n    @dm.step(output='foo')\n    async def make_foo() -> None:\n        require('bar')\n        await spawn('compute_foo_from_bar', ...)\n\nCombined with the YAML configuration file:\n\n.. code-block:: yaml\n\n    - when:\n        step: make_foo\n      then:\n        run_prefix: run_on_compute_cluster\n\nWill result in DynaMake executing the ``shell`` command ``run_on_compute_cluster\ncompute_foo_from_bar ...``. Both the prefix and suffix are marked as ``phony`` so modifying them\nwill not trigger a rebuild. By default both prefix and suffix are empty, in which case ``submit``\nbehaves identically to ``spawn``.\n\nLogging\n.......\n\nComplex build scripts are notoriously difficult to debug. To help alleviate this pain, DynaMake\nuses the standard Python logging mechanism, and supports the following logging levels:\n\n* ``INFO`` prints only the executed actions. This is similar to the default ``make`` behavior.\n  Use this if you just want to know what is being run, when all is well. If\n  ``--log_skipped_actions`` is set, then this will also log skipped actions.\n\n* ``WHY`` also prints the reason for executing each action (which output file does not exist and\n  needs to be created, which input file is newer than which output file, etc.). This is useful\n  for debugging the logic of the build script.\n\n* ``TRACE`` also prints each step invocation. This can further help in debugging the logic of the\n  build script.\n\n* ``DEBUG`` prints a lot of very detailed information about the flow. Expanded globs, the full\n  list of input and output files, the configuration files used, etc. This is useful in the hopefully\n  very rare cases when the terse output from the ``WHY`` and ``TRACE`` levels is not sufficient for\n  figuring out what went wrong.\n\nThe ``WHY`` and ``TRACE`` levels are not a standard python log level. They are defined to be between\n``DEBUG`` and ``INFO``, in the proper order.\n\nIf using the provided ``make`` main function, the logging level can be set using the ``--log-level``\ncommand line option. The default log level is ``WARN`` which means the only expected output would\nbe from the actions themselves.\n\nConfigurable Applications\n.........................\n\nA major use case for DynaMake is automating scientific computation pipelines. Such pipelines involve\nmultiple actions, which are often also implemented in Python. Each such action also has its own\nconfiguration parameters, which we'd like to control using action configuration as described\nabove.\n\nA realistic system has multiple such functions that need to be invoked. It is a hassle to have to\ncreate a separate script for invoking each such function. A way around this is to create a single\nscript which takes the function name as a command-line argument.\n\nDynaMake therefore factors out support for configurable Python-based programs, allowing users to\nimplement their own. The ``dynamake`` script itself can be seen as just another such customized\nprogram.\n\nDynaMake installs a universal ``dynamain`` script which is a thin wrapper for a provided\n``dynamake.application.main`` function. This script automatically imports ``DynaMain.py`` if\nit exists, and any other modules specified by the ``--module`` command line option.\n\nSimilarly to the ``make`` main function, you can implement your own custom script:\n\n.. code-block:: python\n\n    import argparse\n    import dynamake.application as da\n    import my_functions\n\n    da.main(argparse.ArgumentParser(description='...'))\n\nYou can also directly invoke the lower-level API to directly invoke the functions.\nSee the implementation of the ``main`` function and the API documentation for details.\n\nHere is a trivial example configurable function which can be invoked from the command line using\nthis mechanisms:\n\n.. code-block:: python\n\n    import dynamake.application as da\n\n    da.Param(name='bar', default=1, parser=int, description='The number of bars')\n\n    @da.config(top=True)\n    def foo() -> None:\n        do_bar()\n\n    @da.config()\n    def do_bar(bar: int = env()) -> None:\n        print(bar)\n\nThe usage pattern of the library is as follows:\n\n* First, one must declare all the parameters of all the configured functions by creating\n  ``dynamake.application.Param`` objects.\n\n* All functions that use such parameters must be decorated with\n  ``dynamake.application.config``. They must either be annotated as top level using\n  ``top=True``, or be directly invoked from another configured function (and, ultimately, from a\n  top-level function).\n\n* Some parameters are already defined and managed for you, such as ``log_level`` to control logging\n  and ``random_seed`` to control the random number generation. The latter is only added if you\n  specify ``random=True`` when invoking ``config``. Similarly, ``jobs`` controls the number of\n  processors used in parallel, and is only added if you specify ``parallel=True`` when invoking\n  ``config``.\n\n.. note::\n\n   **The automatic detection of invocations of one configurable function from another is\n   simplistic.**\n\n   Basically, if we see inside the function source the name of another function, and this isn't the\n   name of a variable being assigned to, then we assume this is a call. This isn't 100% complete;\n   for example this will not detect cases where ``foo`` calls a non-configured ``bar`` which then\n   calls a configured ``baz``. However it works \"well enough\" for simple code.\n\n* The configured parameters must use ``dynamake.application.env`` as the parameter's default\n  value. This will inject the proper value at each point.\n\nTo invoke this function from the command line, run ``dynamain foo`` (or, possibly, ``dynamain\n--module my_functions foo``, or ``dynamain --config my_configuration.yaml foo``, etc.). A possible\nconfiguration file for this program would be:\n\n.. code-block:: python\n\n   bar: 2  # The program will print 2 instead of the default 1.\n\nThe ``main`` function is self-documenting. Running it with the ``--help`` command line option will\nlist all the available top-level functions. Running it with ``--help function_name`` will print the\nfunction's documentation, and list all the parameters used by it (or any configurable function it\nindirectly invokes).\n\nThe ``dynamain.application.Prog.logger`` provides access to Python's logging facilities,\nconfigured by the ``--log_level`` command line option. That is, just write\n``Prog.logger.debug(...)`` etc.\n\nThe ``dynamain.application.parallel`` function allows multiple invocations of some function\nin parallel. The number of processes used is controlled by the ``--jobs`` command line option. Any\nnested ``parallel`` invocation will execute serially, to ensure this limit is respected. To make it\neasier to debug code, ``dynamain.application.serial`` has exactly the same interface, but\nexecutes the calls serially.\n\nFinally, you can override the value of some configuration parameters for some code. For example,\nthe following:\n\n.. code-block:: python\n\n    import dynamake.application as da\n\n    da.Param(name='foo', default=1, parser=int, description='The number of foos')\n\n    @config()\n    def print_foo(title: str, foo: int = env()) -> None:\n        print(title, foo)\n\n    @config\n    def override_foo() -> None:\n        print_foo('global:')\n        print_foo('explicit:', foo=2)\n        with (da.override(foo=3)):\n            print_foo('override:')\n\nWill print:\n\n.. code-block:: yaml\n\n    global: 1\n    explicit: 2\n    override: 3\n\nWHAT NOT (YET)\n--------------\n\nSince DynaMake is very new, there are many features that should be implemented, but haven't been\nworked on yet:\n\n* Improve the documentation. This README covers the basics but there are additional features that\n  are only mentioned in the class and function documentation, and deserves a better description.\n\n* Allow forcing rebuilding (some) targets.\n\n* Dry run. While it is impossible in general to print the full set of dry run actions, if should\n  be easy to just print the 1st action(s) that need to be executed. This should provide most of the\n  value.\n\n* Allow automated clean actions based on the collected step outputs. If there's nothing\n  to be done when building some target(s), then all generated output files (with or without the\n  ultimate targets) should be fair game to being removed as part of a clean action. However, due to\n  the dry-run problem, we can't automatically clean outputs of actions that depend on actions that\n  still need to be executed.\n\n* Allow skipping generating intermediate files if otherwise no actions need to be done. This is very\n  hard to do with a dynamic build graph - probably impossible in the general case, but common\n  cases might be possible(?)\n\n* Generate a tree (actually a DAG) of step invocations. This can be collected from the persistent\n  state files.\n\n* Generate a visualization of the timeline of action executions showing start and end times, and\n  possibly also resources consumption. In case of distributed actions, make a distinction between\n  submission and completion times and actual start/end times to track the cluster/grid overheads.\n\n* Allow registering additional file formats for the generated configuration files, to allow using\n  them for non-DynaMake external actions.\n\n* Allow using checksums instead of timestamps to determine if actions can be skipped, either\n  by default or on a per-file basis.", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/tanaylab/dynamake.git", "keywords": "make logging configuration", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "dynamake", "package_url": "https://pypi.org/project/dynamake/", "platform": "", "project_url": "https://pypi.org/project/dynamake/", "project_urls": {"Homepage": "https://github.com/tanaylab/dynamake.git"}, "release_url": "https://pypi.org/project/dynamake/0.4.25/", "requires_dist": null, "requires_python": "", "summary": "Dynamic Make in Python", "version": "0.4.25", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://travis-ci.org/tanaylab/dynamake\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/94091906fc7a2dd11a572601319cae0d3fe7c36e/68747470733a2f2f7472617669732d63692e6f72672f74616e61796c61622f64796e616d616b652e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://dynamake.readthedocs.io/en/latest/?badge=latest\" rel=\"nofollow\"><img alt=\"Documentation Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/577d219b73236098771250e6434994a086962a6d/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f64796e616d616b652f62616467652f3f76657273696f6e3d6c6174657374\"></a>\n<div id=\"why\">\n<h2>WHY</h2>\n<blockquote>\n<p><em>\u201cWhat the world needs is another build tool\u201d</em></p>\n<p>\u2014Way too many people</p>\n</blockquote>\n<p>So, why yet <em>another</em> one?</p>\n<p>DynaMake\u2019s raisons d\u2019etre are:</p>\n<ul>\n<li>First class support for dynamic build graphs.</li>\n<li>Fine-grained configuration control.</li>\n<li>Python implementation.</li>\n</ul>\n<p>DynaMake was created to address a concrete need for repeatable configurable processing in the\ncontext of scientific computation pipelines, but should be applicable in wider problem domains.</p>\n<div id=\"dynamic-build-graphs\">\n<h3>Dynamic Build Graphs</h3>\n<p>This is a fancy way of saying that the following are supported:</p>\n<p><strong>Dynamic inputs</strong>: The full set of inputs of a build step may depend on a subset of its inputs.</p>\n<p>An example of dynamic inputs is compiling a C source file, which actually depends on all the\nincluded header files. For a more complex example, consider data analysis where the input data is\nclassified into one of several categories. The actual analysis results are obtained by a\ncategory-specific algorithm, which generates different input files for the final consolidation step.</p>\n<p>Dynamic inputs are supported in various ways by most build tools - some of these ways being more\nconvoluted than others. DynaMake provides natural first-class support for such cases.</p>\n<p><strong>Dynamic outputs</strong>: The set of outputs of a build step may depend on its inputs.</p>\n<p>An example of dynamic outputs is running a clustering step on some large data, which may produce any\nnumber of clusters. Each of these clusters needs to go through some further processing. Perhaps only\nsome of these clusters need to be processed (based on some expensive-to-compute filter).</p>\n<p>Dynamic outputs are sufficiently common in scientific computation pipelines that they are a major\nsource of pain. There are workarounds, for sure. But almost no existing tool has direct support for\nthem, and of the few tools that do, most do it as an afterthought. Since this issue has wide-ranging\nimplications on the build tool, this means they typically don\u2019t do it well. A notable exception is\n<a href=\"https://shakebuild.com/\" rel=\"nofollow\">Shake</a>, which DynaMake is heavily inspired by.</p>\n<p>The problem with dynamic outputs (and, to a lesser extent, dynamic inputs) is that they make other\nbuild tool features really hard to implement. Therefore, retrofitting them into an existing build\ntool causes some features to break. In the worst case this leads to silent broken builds.</p>\n<p>Some examples of features that become very difficult in the presence of a dynamic build graph are:</p>\n<ul>\n<li>The ability to aggressively optimize the case when a build needs to do nothing at all, and\nin general reduce the build system overhead.</li>\n<li>The ability to perform a dry run that accurately lists <em>all</em> the steps that will be needed to\nbuild an arbitrary target.</li>\n<li>Having a purely declarative build language, which can be more easily learned than any programming\nlanguage (even Python :-) and may be processed as pure data by additional tools.</li>\n</ul>\n</div>\n<div id=\"configuration-control\">\n<h3>Configuration Control</h3>\n<p>This is a fancy way of saying that you can tweak the parameters of arbitrary steps of a complex\npipeline, and then only execute the affected parts of the pipeline, either all the way to the final\nresults or just to obtain some intermediate results to examine. This use case occurs <em>a lot</em> in\nscientific computation pipelines.</p>\n<p>Configuration parameters can be either specified as explicit command line options for executed\nactions, or inside configuration files(s). A few build tools will trigger a rebuild if the command\nline options have changed. All build tools will allow adding a configuration file as a dependency;\nhowever, this requires setting up a per-invocation configuration file which can become very unwieldy\nfor a large pipeline - especially when the \u201csame\u201d pattern step needs to be invoked with different\nconfigurations depending on the exact files (e.g., different compilation flags for different source\nfiles).</p>\n<p>DynaMake automates the generation of a per-invocation configuration file, based on a single central\nconfiguration file, so that on modification, only the affected actions are invoked. In addition,\nDynaMake tracks the list of inputs, outputs, actions and their command line options, so that any\nchange in the pipeline itself will trigger the invocation of the affected actions.</p>\n<p>This functionality requires keeping additional persistent state between invocation. This state is\nstored as human-readable (YAML) files in a special directory (by default, <tt>.dynamake</tt>, but you can\noverride it using the <tt>DYNAMAKE_PERSISTENT_DIR</tt> environment variable). The file names are legible\n(based on the step name and its parameters, if any), so it is easy to examine them after the fact to\nunderstand exactly which parameter values were used where.</p>\n<p>In rare cases, there are good reasons to avoid any such additional persistent state. DynaMake allows\ndisabling these features, switching to relying only on the modification times of the input files.\nThis of course results in less reliable rebuilds.</p>\n</div>\n<div id=\"python\">\n<h3>Python</h3>\n<p>DynaMake was initially created to address the needs of automating scientific computation pipelines\n(specifically in bio-informatics, specifically in single-cell RNA sequencing, not that it matters).\nHowever, it is a general-purpose build tool, which may be useful for a wide range of users.</p>\n<p>DynaMake is heavily inspired by <a href=\"https://shakebuild.com/\" rel=\"nofollow\">Shake</a>. However, <tt>shake</tt> is\nimplemented in <a href=\"https://www.haskell.org/\" rel=\"nofollow\">Haskell</a>. Haskell is unlikely to be pre-installed on a\ntypical machine, and installing it (and <tt>shake</tt>) is far from trivial, especially when one has no\n<tt>sudo</tt> privileges. Also, writing <tt>shake</tt> rules uses Haskell syntax which, while being simple and\nat times superior, is pretty different from that of most popular programming languages.</p>\n<p>In contrast, Python is much more likely to already be installed on a typical machine. It is trivial\nto just type <tt>pip install <span class=\"pre\">--user</span> dynamake</tt> (or <tt>sudo pip install dynamake</tt> if you have <tt>sudo</tt>\nprivileges). The build rules are simple Python scripts, which means most people are already familiar\nwith the language, or are in the process of becoming so for other reasons.</p>\n<p>Using a proven and familiar language is also preferable to coming up with a whole new build-oriented\nlanguage, especially when creating a general-purpose build tool. The GNU <tt>make</tt> syntax is a\nwarning for how such specialized languages inevitably devolve into a general-purpose mess.</p>\n</div>\n</div>\n<div id=\"why-not\">\n<h2>WHY NOT</h2>\n<p>DynaMake\u2019s unique blend of features comes at some costs:</p>\n<ul>\n<li><p>It is a new, immature tool. As such, it lacks some features it could/should provide,\nis less efficient than it could be, and you may encounter the occasional bug. Hopefully this will\nimprove with time. If you want DynaMake-like features with a proven track record, you should\nconsider <tt>shake</tt>.</p>\n</li>\n<li><p>The provided goals, as described above, may be a poor fit for your use case.</p>\n<p>If your build graph and configuration are truly static, consider using <a href=\"https://ninja-build.org/\" rel=\"nofollow\">Ninja</a> which tries to maximize the benefits of such a static build pipeline.\nIt is almost the opposite of DynaMake in this respect.</p>\n<p>If your build graph is only \u201cmostly static\u201d (e.g., just needs a restricted form of dynamic inputs,\nsuch as included header files), then you have (too) many other options to list here. Using the\nclassical <tt>make</tt> is a good default choice.</p>\n</li>\n<li><p>It is a low-level build tool, on par with <tt>make</tt> and <tt>ninja</tt>.</p>\n<p>If you are looking for a tool that comes with a lot of built-in rules for dealing with specific\ncomputer languages (say, C/C++), and will automatically deal with cross-platform issues,\nconsider using <a href=\"https://cmake.org/\" rel=\"nofollow\">CMake</a> or <a href=\"https://xmake.io/\" rel=\"nofollow\">XMake</a> instead.</p>\n</li>\n</ul>\n</div>\n<div id=\"what\">\n<h2>WHAT</h2>\n<p>DynaMake is essentially a Python library. There is a <tt>dynamake</tt> universal executable script\nprovided with the package, similar to <a href=\"https://scons.org/\" rel=\"nofollow\">SCons</a>, but you still need to write\nyour build script in Python, using the library\u2019s utilities, and you can also easily invoke the\nprovided <tt>make</tt> main function from your code. You can even directly invoke the build functionality\nfrom your own custom main function.</p>\n<p>DynaMake build steps may invoke applications written in any language, which are configured in any\nway (command line flags, configuration files, etc.).</p>\n<p>As a convenience, DynaMake also provides utilities for writing Python \u201cconfigurable applications\u201d\nwhich make heavy use of DynaMake\u2019s automated configuration control. A <tt>dynamain</tt> universal\nexecutable script removes the need to wrap each Python function in its own executable script, and\nyou can easily invoke the provided <tt>main</tt> function from your code. You can even directly invoke\nthe configurable application functions from your own custom main function.</p>\n<div id=\"build-scripts\">\n<h3>Build Scripts</h3>\n<p>A typical build script consists of a set of step functions, which are functions decorated with\n<tt>dynamake.make.step</tt>. This requires an explicit <tt><span class=\"pre\">output=...</span></tt> parameter listing the\nfile(s) created by the step.</p>\n<p>Here is a DynaMake build script which copies the file <tt>foo</tt> to the file <tt>bar</tt>, if <tt>bar</tt> does\nnot exist, or if <tt>foo</tt> is newer than <tt>bar</tt>:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">dynamake.make</span> <span class=\"k\">as</span> <span class=\"nn\">dm</span>\n\n<span class=\"nd\">@dm</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"o\">=</span><span class=\"s1\">'foo'</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">copy_bar_to_foo</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">require</span><span class=\"p\">(</span><span class=\"s1\">'bar'</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">shell</span><span class=\"p\">(</span><span class=\"s1\">'cp bar foo'</span><span class=\"p\">)</span>\n</pre>\n<p>This is essentially equivalent to the <tt>make</tt> rule:</p>\n<pre><span class=\"nf\">foo</span><span class=\"o\">:</span> <span class=\"n\">bar</span>\n        cp bar foo\n</pre>\n<p>That is, DynaMake will only execute the shell command <tt>cp bar foo</tt> if the <tt>foo</tt> file is missing\nor is older than the <tt>bar</tt> file. In general, DynaMake will skip actions unless it finds a\nsufficient reason to execute them. If there are multiple actions in a step, and DynaMake skipped\nsome to discover that a later action needs to be executed, then DynaMake restarts the step, and this\ntime executes all actions. That is, step functions are (should be) \u201cidempotent\u201d; re-running a step\nmultiple times should have no effect.</p>\n<p>The Python version is more verbose, so if this was all there was to it, <tt>make</tt> would have been\npreferable. However, DynaMake allows one to specify scripts that are impossible in <tt>make</tt>,\njustifying the additional syntax.</p>\n<p>For example, inside each step, you can do the following:</p>\n<ul>\n<li>Invoke <tt>dynamake.make.require</tt> to ensure the specified path exists and is and up-to-date.\nBuilding of required input files is done asynchronously (concurrently).</li>\n<li>Invoke <tt>await</tt> of <tt>dynamake.make.sync</tt> to ensure all required input files specified so\nfar have completed to build.</li>\n<li>Invoke <tt>await</tt> of <tt>dynamake.make.shell</tt> or <tt>dynamake.make.spawn</tt> to trigger\nthe execution of a shell command or an external program. This will automatically <tt>sync</tt> first\nto ensure all required input files have completed to build.</li>\n</ul>\n<div>\n<p>Note</p>\n<p><strong>Inside a step, do not simply ``await`` co-routines that are not provided by DynaMake.</strong></p>\n<p>DynaMake tracks the current step, and invoking <tt>await</tt> of some other co-routines will confuse\nit. Use <tt>dynamake.make.done</tt> to <tt>await</tt> on external co-routines. That is, write\n<tt>await <span class=\"pre\">done(something())</span></tt> rather than <tt>await something()</tt>.</p>\n</div>\n<ul>\n<li>Use Python code to examine the file system (it is recommended to use\n<tt>dynamake.stat.Stat</tt> for cached <tt>stat</tt> operations), analyze the content of\nrequired input files (following a <tt>sync</tt>), perform control flow operations (branches, loops),\ninvoke Python functions which do any of these things, etc.</li>\n</ul>\n<div>\n<p>Note</p>\n<p><strong>The correctness of the ``stat`` cache depends on accurate listing of each action\u2019s inputs and\noutputs.</strong></p>\n<p>In general DynaMake needs these lists to be accurate for correct operation. This is true of\nalmost any build tool. In theory, one could use <tt>strace</tt> to automatically extract the true\nlists of inputs and outputs, but this is complex, fragile (breaks for programs running on\ncluster servers), and impacts the performance.</p>\n</div>\n<p>The ability to mix general Python code together with <tt>make</tt> functionality is what gives DynaMake\nits additional power over static build tools like <tt>make</tt> or <tt>ninja</tt>. The following examples\nwill demonstrate some common idioms using this power.</p>\n</div>\n<div id=\"pattern-steps\">\n<h3>Pattern Steps</h3>\n<p>A more generic script might be:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">dynamake.make</span> <span class=\"k\">as</span> <span class=\"nn\">dm</span>\n<span class=\"kn\">from</span> <span class=\"nn\">c_source_files</span> <span class=\"kn\">import</span> <span class=\"n\">scan_included_files</span>  <span class=\"c1\"># Assume this for simplicity.</span>\n\n<span class=\"c1\"># Naive: does not handle a cycle of files including each other,</span>\n<span class=\"c1\"># does not allow for missing include files (e.g. in #ifdef),</span>\n<span class=\"c1\"># doesn't cache results, etc.</span>\n<span class=\"k\">def</span> <span class=\"nf\">require_included_files</span><span class=\"p\">(</span><span class=\"n\">paths</span><span class=\"p\">:</span> <span class=\"o\">*</span><span class=\"n\">Strings</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">require</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">paths</span><span class=\"p\">)</span>\n    <span class=\"n\">sync</span><span class=\"p\">()</span>\n    <span class=\"k\">for</span> <span class=\"n\">included_path</span> <span class=\"ow\">in</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">each_string</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">paths</span><span class=\"p\">):</span>\n        <span class=\"n\">require_included_files</span><span class=\"p\">(</span><span class=\"n\">scan_included_files</span><span class=\"p\">(</span><span class=\"n\">included_path</span><span class=\"p\">))</span>\n\n<span class=\"nd\">@dm</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"o\">=</span><span class=\"s1\">'obj/{*name}.o'</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">make_object</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">source_path</span> <span class=\"o\">=</span> <span class=\"s1\">'src/</span><span class=\"si\">{name}</span><span class=\"s1\">.c'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>\n    <span class=\"n\">source_path</span> <span class=\"o\">=</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">fmt</span><span class=\"p\">(</span><span class=\"n\">kwargs</span><span class=\"p\">,</span> <span class=\"s1\">'src/</span><span class=\"si\">{name}</span><span class=\"s1\">.c'</span><span class=\"p\">)</span>  <span class=\"c1\"># Same as above</span>\n    <span class=\"n\">source_path</span> <span class=\"o\">=</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">e</span><span class=\"p\">(</span><span class=\"s1\">'src/</span><span class=\"si\">{name}</span><span class=\"s1\">.c'</span><span class=\"p\">)</span>  <span class=\"c1\"># Same as above</span>\n    <span class=\"n\">require_included_files</span><span class=\"p\">(</span><span class=\"n\">source_path</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">espawn</span><span class=\"p\">(</span><span class=\"s1\">'cc'</span><span class=\"p\">,</span> <span class=\"s1\">'-o'</span><span class=\"p\">,</span> <span class=\"s1\">'obj/</span><span class=\"si\">{name}</span><span class=\"s1\">.o'</span><span class=\"p\">,</span> <span class=\"n\">source_path</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@dm</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"o\">=</span><span class=\"s1\">'bin/main'</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">make_executable</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">object_paths</span> <span class=\"o\">=</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">glob_fmt</span><span class=\"p\">(</span><span class=\"s1\">'src/{*name}.c'</span><span class=\"p\">,</span> <span class=\"s1\">'obj/</span><span class=\"si\">{name}</span><span class=\"s1\">.o'</span><span class=\"p\">)</span>\n    <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">require</span><span class=\"p\">(</span><span class=\"n\">object_paths</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">spawn</span><span class=\"p\">(</span><span class=\"s1\">'ld'</span><span class=\"p\">,</span> <span class=\"s1\">'-o'</span><span class=\"p\">,</span> <span class=\"s1\">'bin/main.o'</span><span class=\"p\">,</span> <span class=\"n\">object_paths</span><span class=\"p\">)</span>\n</pre>\n<p>This demonstrates some additional concepts:</p>\n<ul>\n<li><p>If the <tt>output</tt> of a step contains a <tt>dynamake.patterns.capture</tt> pattern, then the\nextracted values are passed to the function as string arguments. These can be used inside the\nfunction to generate file names (in the above, the source file names).</p>\n<p>This is similar to <tt>make</tt> pattern rules, but is more powerful, as you can specify multiple parts\nof the file name to be captured. A pattern such as <tt><span class=\"pre\">foo/{*phase}/{*part}/bar</span></tt> is essentially\nimpossible to express in <tt>make</tt>.</p>\n<p>When a target is <tt>require</tt>-d, it is matched against these patterns, and the unique step that\nmatches the target is triggered, with the appropriate (extracted) arguments. It is an error for\nmore than one step to match. If no step matches, the target is assumed to be a source file, and\nmust exist on the disk. Otherwise, DynaMake complains it doesn\u2019t know how to make this target.</p>\n</li>\n<li><p>DynaMake provides many functions to deal with <tt>glob</tt>-ing, capturing, and formatting lists\nof strings, listed in the <tt>dynamake.patterns</tt> module. These make it convenient to perform\ncommon operations. For example, <tt>``dynamake.make.e`</tt> is equivalent to\n<tt>dynamake.patterns.fmt</tt> using the <tt>kwargs</tt> of the current step. This is an extremely\ncommon operation so we give it such a short function name. Another example is\n<tt>dynamake.patterns.glob_fmt</tt> which uses a <tt>glob</tt> to obtain a list of file names, then\n<tt>extract</tt> some part(s) of each, then <tt>fmt</tt> some other pattern(s) using these values.</p>\n</li>\n<li><p>Most DynaMake functions accept <tt>Strings</tt>, that is, either a single string, or a list of\nstrings, or a list of list of strings, etc.; but they return either a single string or a flat list\nof strings. This makes it easy to pass the output of one function to another. You can also use\nthis in your own functions, for example in <tt>require_included_files</tt>.</p>\n</li>\n<li><p>The <tt>output</tt> of a step is also <tt>Strings</tt>, that is, may be a list of files that are created\nby the actions in the step. In contrast, many tools (most notably, <tt>make</tt>) can\u2019t handle the\nnotion of multiple outputs from a single step.</p>\n</li>\n<li><p>The <tt>require_included_files</tt> is an example of how a step can examine the content of some\nrequired input file(s) to determine whether it needs additional required input file(s), or, in\ngeneral, to make any decisions on how to proceed further. Note that it tries to <tt>require</tt> as\nmany files as possible concurrently before invoking <tt>sync</tt>. Actual processing\n(<tt>scan_included_files</tt>) is done serially.</p>\n</li>\n</ul>\n</div>\n<div id=\"dynamic-outputs\">\n<h3>Dynamic Outputs</h3>\n<p>When a step may produce a dynamic set of outputs, it must specify an <tt>output</tt> pattern\nwhich includes some non captured parts (whose name starts with <tt>_</tt>). For example:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">dynamake.make</span> <span class=\"k\">as</span> <span class=\"nn\">dm</span>\n\n<span class=\"nd\">@dm</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s1\">'unzipped_messages/{*id}/{*_part}.txt'</span><span class=\"p\">,</span>\n                 <span class=\"s1\">'unzipped_messages/{*id}/.all.done'</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">unzip_message</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">require</span><span class=\"p\">(</span><span class=\"s1\">'zipped_messages/</span><span class=\"si\">{id}</span><span class=\"s1\">.zip'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">))</span>\n    <span class=\"k\">await</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">shell</span><span class=\"p\">(</span><span class=\"s1\">'unzip ...'</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">eshell</span><span class=\"p\">(</span><span class=\"s1\">'touch unzipped_messages/</span><span class=\"si\">{id}</span><span class=\"s1\">/.all.done'</span><span class=\"p\">)</span>\n</pre>\n<p>Note that only <tt>id</tt> will be set in <tt>kwargs</tt>. DynaMake assumes that the same invocation will\ngenerate all <tt>_part</tt> values in one call. This demonstrates another point: if a step specifies\nmultiple <tt>output</tt> patterns, each must capture the same named argument(s) (in this case <tt>name</tt>),\nbut may include different (or no) non-captured path parts.</p>\n<p>The <tt>dynamake.make.eshell</tt> is equivalent to <tt><span class=\"pre\">shell(e(...))</span></tt>, that is, it automatically\nformats all the string(s) using the step\u2019s <tt>kwargs</tt>. DynaMake defines several additional such\nfunctions with an <tt>e</tt> prefix, for example <tt>dynamake.make.erequire</tt> and\n<tt>dynamake.make.eglob_paths</tt>.</p>\n<p>Requiring <em>any</em> of the specific output files will cause the step to be invoked and ensure <em>all</em>\noutputs are up-to-date. A common trick, demonstrated above, it to have an additional final file\nserve as a convenient way to require all the files. This allows to query the filesystem for the full\nlist of files. For example, assume each part needs to be processed:</p>\n<pre><span class=\"nd\">@dm</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"o\">=</span><span class=\"s1\">'processed_messages/{*id}/{*part}.txt'</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">process_part</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">require</span><span class=\"p\">(</span><span class=\"s1\">'unzipped_messages/</span><span class=\"si\">{id}</span><span class=\"s1\">/</span><span class=\"si\">{part}</span><span class=\"s1\">.txt'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">))</span>\n    <span class=\"o\">...</span>\n</pre>\n<p>And that all parts need to be collected together:</p>\n<pre><span class=\"nd\">@dm</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"o\">=</span><span class=\"s1\">'collected_messages/{*id}.txt'</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">collect_parts</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">require</span><span class=\"p\">(</span><span class=\"s1\">'unzipped_messages/</span><span class=\"si\">{id}</span><span class=\"s1\">/.all.done'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">))</span>\n    <span class=\"k\">await</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">sync</span><span class=\"p\">()</span>\n    <span class=\"n\">all_parts</span> <span class=\"o\">=</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">eglob_fmt</span><span class=\"p\">(</span><span class=\"s1\">'unzipped_messages/</span><span class=\"si\">{id}</span><span class=\"s1\">/{*part}.txt'</span><span class=\"p\">,</span>\n                             <span class=\"s1\">'processed_messages/</span><span class=\"si\">{id}</span><span class=\"s1\">/{*part}.txt'</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">eshell</span><span class=\"p\">(</span><span class=\"s1\">'cat'</span><span class=\"p\">,</span> <span class=\"nb\">sorted</span><span class=\"p\">(</span><span class=\"n\">all_parts</span><span class=\"p\">),</span> <span class=\"s1\">'&gt;'</span><span class=\"p\">,</span> <span class=\"s1\">'collected_messages/</span><span class=\"si\">{id}</span><span class=\"s1\">.txt'</span><span class=\"p\">)</span>\n</pre>\n<p>This sort of flow can only be approximated using static build tools. Typically this is done using\nexplicit build phases, instead of a unified build script. This results in brittle build systems,\nwhere the safe best practice if anything changes is to \u201cdelete all files and rebuild\u201d to ensure the\nresults are correct.</p>\n</div>\n<div id=\"universal-main-program\">\n<h3>Universal Main Program</h3>\n<p>Installing DynaMake provides a universal executable build script called <tt>dynamake</tt>, which is a\nthin wrapper around the generic <tt>dynamake.make.make</tt> main function. The easiest way to\ninvoke DynaMake is to place your steps inside <tt>DynaMake.py</tt> (or modules included by\n<tt>DynaMake.py</tt>) and invoke this <tt>dynamake</tt> script. You can also specify explicit <tt><span class=\"pre\">--module</span></tt>\noptions in the command line to directly import your step functions from other Python modules.</p>\n<p>You can write your own executable script:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">argparse</span>\n<span class=\"kn\">import</span> <span class=\"nn\">dynamake.make</span> <span class=\"k\">as</span> <span class=\"nn\">dm</span>\n<span class=\"kn\">import</span> <span class=\"nn\">my_steps</span>\n\n<span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">make</span><span class=\"p\">(</span><span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">ArgumentParser</span><span class=\"p\">(</span><span class=\"n\">description</span><span class=\"o\">=</span><span class=\"s1\">'...'</span><span class=\"p\">))</span>\n</pre>\n<p>Which will come pre-loaded with your own steps, and allow you to tweak the program\u2019s help message\nand other aspects, if needed. This is especially useful if you are writing a package that wants to\nprovide pre-canned steps for performing some complex operation (such as a scientific computation\npipeline).</p>\n<p>Finally, you can directly invoke the lower-level API to use build steps as part of your code.\nSee the implementation of the <tt>make</tt> function and the API documentation for details.</p>\n</div>\n<div id=\"annotations\">\n<h3>Annotations</h3>\n<p>DynaMake allows attaching annotations (<tt>dynamake.patterns.AnnotatedStr</tt>) to strings (and\npatterns). Multiple annotations may be applied to the same string. The provided string processing\nfunctions preserve these (that is, pass the annotations from the input(s) to the output(s)). These\nannotations are used by DynaMake to modify the handling of required and output files, and in some\ncases, control formatting.</p>\n<ul>\n<li><p><tt>dynamake.patterns.optional</tt> indicates that an output need not exist at the end of the\nstep, or a required file need not exist for the following actions to succeed. That is, invoking\n<tt><span class=\"pre\">require(optional('foo'))</span></tt> will invoke the step that provides <tt>foo</tt>. If there is no such step,\nthen <tt>foo</tt> need not exist on the disk. If this step exists, and succeeds, but does not in fact\ncreate <tt>foo</tt>, and specifies <tt><span class=\"pre\">output=optional('foo')</span></tt>, then DynaMake will accept this and\ncontinue. If either of the steps did not specify the <tt>optional</tt> annotation, then DynaMake will\ncomplain and abort the build.</p>\n</li>\n<li><p><tt>dynamake.patterns.exists</tt> ignores the modification time of an input or an output,\ninstead just considering whether it exists. That is, invoking <tt><span class=\"pre\">require(exists('foo'))</span></tt>\nwill attempt to build <tt>foo</tt> but will ignore its timestamp when deciding whether to\nskip the execution of following actions in this step. Specifying <tt><span class=\"pre\">output=exists('foo')</span></tt>\nwill disable touching the output file to ensure it is newer than the required input file(s)\n(regardless of the setting of <tt><span class=\"pre\">--touch_success_outputs</span></tt>).</p>\n</li>\n<li><p><tt>dynamake.patterns.precious</tt> prevents output file(s) from being removed\n(regardless of the setting of <tt><span class=\"pre\">--remove_stale_outputs</span></tt> and <tt><span class=\"pre\">--remove_failed_outputs</span></tt>).</p>\n</li>\n<li><p><tt>dynamake.patterns.phony</tt> marks an output as a non-file target. Typically the\ndefault top-level <tt>all</tt> target is <tt>phony</tt>, as well as similar top-level targets such as\n<tt>clean</tt>. When a step has any <tt>phony</tt> output(s), its actions are always executed, and a\nsynthetic modification time is assigned to it: one nanosecond newer than the newest required\ninput.</p>\n<p>If using persistent state to track actions (see below), this state will ignore any parts of\ninvoked commands that are marked as <tt>phony</tt>. This prevents changes irrelevant command line\noptions from triggering a rebuild. For example, changing the value passed to the <tt><span class=\"pre\">--jobs</span></tt>\ncommand line option of a program should not impact its outputs, and therefore should not trigger a\nrebuild.</p>\n<p>TODO: Clarify distinction between phony and optional (especially when using persistent state).</p>\n</li>\n<li><p><tt>dynamake.patterns.emphasized</tt> is used by <tt>shell</tt> and <tt>spawn</tt>. Arguments\nso annotated are printed in <strong>bold</strong> in the log file. This makes it easier to see the important\nbits of long command lines.</p>\n</li>\n</ul>\n</div>\n<div id=\"control-flags\">\n<h3>Control Flags</h3>\n<p>The behavior of DynaMake can be tweaked by modifying the options specified in\n<tt>dynamake.make.Make</tt>. This is typically done by specifying the appropriate command line\noption which is then handled by the provided <tt>make</tt> main function.</p>\n<ul>\n<li><p><tt><span class=\"pre\">--rebuild_changed_actions</span></tt> controls whether DynaMake uses the persistent state to track\nthe list of outputs, inputs, invoked sub-steps, and actions with their command line options. This\nensures that builds are repeatable (barring changes to the environment, such as compiler versions\netc.). By default this is <tt>True</tt>.</p>\n<p>Persistent state is kept in YAML files named <tt>.dynamake/step_name.actions.yaml</tt> or, for\nparameterized steps, <tt><span class=\"pre\">.dynamake/step_name/param=value&amp;...&amp;param=value.actions.yaml</span></tt>. As a\nconvenience, this state also includes the start and end time of each of the invoked actions. This\nallows post-processing tools to analyze the behavior of the build script (as an alternative to\nanalyzing the log messages).</p>\n</li>\n<li><p><tt><span class=\"pre\">--failure_aborts_build</span></tt> controls whether DynaMake stops the build process on the first\nfailure. Otherwise, it attempts to continue to build as many unaffected targets as possible.\nBy default this is <tt>True</tt>.</p>\n</li>\n<li><p><tt><span class=\"pre\">--remove_stale_outputs</span></tt> controls whether DynaMake removes all (non-<tt>precious</tt>) outputs\nbefore executing the first action of a step. By default this is <tt>True</tt>.</p>\n</li>\n<li><p><tt><span class=\"pre\">--wait_nfs_outputs</span></tt> controls whether DynaMake will wait before pronouncing that an output\nfile has not been created by the step action(s). This may be needed if the action executes on a\nserver in a cluster using an NFS shared file system, as NFS clients are typically caching <tt>stat</tt>\nresults (for performance).</p>\n</li>\n<li><p><tt><span class=\"pre\">--nfs_outputs_timeout</span></tt> controls the amount of time DynaMake will wait for output files\nto appear after the last step action is done. By default this is 60 seconds, which is the\ndefault NFS stat cache timeout. However, heavily loaded NFS servers have been known to\nlag for longer of periods of time.</p>\n</li>\n<li><p><tt><span class=\"pre\">--touch_success_outputs</span></tt> controls whether DynaMake should touch (non-<tt>exists</tt>) output\nfile(s) to ensure their modification time is later than that of (non-<tt>exists</tt>) required input\nfiles(s). By default this is <tt>False</tt> because DynaMake uses the nanosecond modification time,\nwhich is supported on most modern file systems. The modification times on old file systems used a\n1-second resolution, which could result in the output having the same modification time as the\ninput for a fast operation.</p>\n<p>This option might still be needed if an output is a directory (not a file) and is <tt>precious</tt> or\n<tt><span class=\"pre\">--remove_stale_outputs</span></tt> is <tt>False</tt>. In this case, the modification time of a pre-existing\ndirectory will not necessarily be updated to reflect the fact that output file(s) in it were\ncreated or modified by the action(s). In general it is not advised to depend on the modification\ntime of directories; it is better to specify a glob matching the expected files inside them, or\nuse an explicit timestamp file.</p>\n</li>\n<li><p><tt><span class=\"pre\">--remove_failed_outputs</span></tt> controls whether DynaMake should remove (non-<tt>precious</tt>) output\nfiles when a step action has failed. This prevents corrupt output file(s) from remaining on\nthe disk and being used in later invocations or by other programs. By default this is <tt>True</tt>.</p>\n</li>\n<li><p><tt><span class=\"pre\">-remove_empty_directories</span></tt> controls whether DynaMake will remove empty directories resulting\nfrom removing any output file(s). By default this is <tt>False</tt>.</p>\n</li>\n<li><p><tt><span class=\"pre\">--jobs</span></tt> controls the maximal number of <tt>shell</tt> or <tt>spawn</tt> actions that are invoked at the\nsame time. By default this is the number of (logical) processors in the system (<tt>nproc</tt>). A\nvalue of <tt>1</tt> will force executing one action at a time. You can override this default using the\n<tt>DYNAMAKE_JOBS</tt> environment variable.</p>\n<p>A value of <tt>0</tt> will allow for unlimited number of parallel actions. This is useful if actions\nare to be be executed on a cluster of servers instead of on the local machine, or if some other\nresource(s) are used to restrict the number of parallel actions (see below).</p>\n</li>\n</ul>\n<div>\n<p>Note</p>\n<p><strong>The DynaMake python code itself is not parallel.</strong></p>\n<p>DynaMake always runs on a single process. Parallelism is the result of DynaMake executing an\nexternal action, and instead of waiting for it to complete, switching over to a different step\nand processing it until it also executes an external action, and so on. Thus actions may execute\nin parallel, while the Python code is still doing only one thing at a time. This greatly\nsimplifies reasoning about the code. Specifically, if a piece of code contains no <tt>await</tt>\ncalls, then it is guaranteed to \u201catomically\u201d execute to completion, so there is no need for a\nlock or a mutex to synchronize between the steps, even when they share some data.</p>\n</div>\n</div>\n<div id=\"build-configuration\">\n<h3>Build Configuration</h3>\n<p>The above control flags are an example of global build configuration parameters. In general, such\nparameters have a default, can be overridden by some command line option, and may be used by any\n(possibly nested) function of the program.</p>\n<p>The use of global configuration parameters isn\u2019t unique to DynaMake scripts. Therefore, it has been\nfactored out and is provided on its own via the <tt>dynamake.application</tt> module, described\nbelow.</p>\n<p>A quick example of how such parameters can be used is:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">dynamake.make</span> <span class=\"k\">as</span> <span class=\"nn\">dm</span>\n\n<span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">Param</span><span class=\"p\">(</span><span class=\"s1\">'mode'</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"n\">MODE_FLAGS</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'debug'</span><span class=\"p\">:</span> <span class=\"p\">[</span> <span class=\"o\">...</span> <span class=\"p\">],</span>\n    <span class=\"s1\">'release'</span><span class=\"p\">:</span> <span class=\"p\">[</span> <span class=\"o\">...</span> <span class=\"p\">],</span>\n<span class=\"p\">}</span>\n\n<span class=\"nd\">@dm</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"o\">=</span><span class=\"s1\">'obj/{*name}.o'</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">make_object</span><span class=\"p\">(</span><span class=\"n\">mode</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">env</span><span class=\"p\">(),</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">require</span><span class=\"p\">(</span><span class=\"s1\">'src/</span><span class=\"si\">{name}</span><span class=\"s1\">.c'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">))</span>\n    <span class=\"k\">await</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">espawn</span><span class=\"p\">(</span><span class=\"s1\">'cc'</span><span class=\"p\">,</span> <span class=\"s1\">'-o'</span><span class=\"p\">,</span> <span class=\"s1\">'obj/</span><span class=\"si\">{name}</span><span class=\"s1\">.o'</span><span class=\"p\">,</span> <span class=\"n\">MODE_FLAGS</span><span class=\"p\">[</span><span class=\"n\">mode</span><span class=\"p\">],</span> <span class=\"n\">source_path</span><span class=\"p\">)</span>\n</pre>\n<p>That is, constructing a new <tt>dynamake.application.Param</tt> specifies the default value and\ncommand line option(s) for the parameter, and using <tt>dynamake.application.env</tt> as the\nparameter\u2019s default value will ensure the proper value is passed to the step invocation.</p>\n<p>The provided <tt>make</tt> main function will also load the parameter values specified in the file\n<tt>DynaConf.yaml</tt>, if it exists, or any files specified using the <tt><span class=\"pre\">--config</span></tt> command line option.</p>\n</div>\n<div id=\"parallel-resources\">\n<h3>Parallel Resources</h3>\n<p>As mentioned above, DynaMake will perform all <tt>require</tt> operations concurrently, up to the next\n<tt>sync</tt> call of the step (which automatically happens before any <tt>shell</tt> or <tt>spawn</tt> action). As\na result, by default DynaMake will execute several actions in parallel, subject to the setting of\n<tt><span class=\"pre\">--jobs</span></tt>.</p>\n<p>It is possible to define some additional resources using <tt>dynamake.make.resources</tt> to\nrestrict parallel execution. For example, specifying <tt>resource_parameters(ram=1, io=1)</tt> will\ncreate two new resources, <tt>ram</tt> and <tt>io</tt>, which must have been previously defined using\nconfiguration <tt>Param</tt> calls. The values specified are the default consumption for actions that do\nnot specify an explicit value.</p>\n<p>Then, when invoking <tt>shell</tt> or <tt>spawn</tt>, it is possible to add <tt><span class=\"pre\">ram=...</span></tt> and/or <tt><span class=\"pre\">io=...</span></tt>\nnamed arguments to the call, to override the expected resource consumption of the action. DynaMake\nwill ensure that the sum of these expected consumptions will never exceed the established limit.</p>\n</div>\n<div id=\"action-configuration\">\n<h3>Action Configuration</h3>\n<p>A major use case of DynaMake is fine-grained control over configuration parameters\nfor controlling step actions.</p>\n<p>For example, let\u2019s allow configuring the compilation flags in the above example(s):</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">dynamake.make</span> <span class=\"k\">as</span> <span class=\"nn\">dm</span>\n\n<span class=\"nd\">@dm</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"o\">=</span><span class=\"s1\">'obj/{*name}.o'</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">make_object</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">require</span><span class=\"p\">(</span><span class=\"s1\">'src/</span><span class=\"si\">{name}</span><span class=\"s1\">.c'</span><span class=\"o\">.</span><span class=\"n\">format</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">))</span>\n    <span class=\"k\">await</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">espawn</span><span class=\"p\">(</span><span class=\"s1\">'cc'</span><span class=\"p\">,</span> <span class=\"s1\">'-o'</span><span class=\"p\">,</span> <span class=\"s1\">'obj/</span><span class=\"si\">{name}</span><span class=\"s1\">.o'</span><span class=\"p\">,</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">config_param</span><span class=\"p\">(</span><span class=\"s1\">'flags'</span><span class=\"p\">),</span> <span class=\"n\">source_path</span><span class=\"p\">)</span>\n</pre>\n<p>And create a YAML configuration file as follows:</p>\n<pre><span class=\"p-Indicator\">-</span> <span class=\"nt\">when</span><span class=\"p\">:</span>\n    <span class=\"nt\">step</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">make_object</span>\n  <span class=\"nt\">then</span><span class=\"p\">:</span>\n    <span class=\"nt\">flags</span><span class=\"p\">:</span> <span class=\"p-Indicator\">[</span><span class=\"nv\">-g</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">-O2</span><span class=\"p-Indicator\">]</span>\n\n<span class=\"p-Indicator\">-</span> <span class=\"nt\">when</span><span class=\"p\">:</span>\n    <span class=\"nt\">step</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">make_object</span>\n    <span class=\"nt\">name</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">main</span>\n  <span class=\"nt\">then</span><span class=\"p\">:</span>\n    <span class=\"nt\">flags</span><span class=\"p\">:</span> <span class=\"p-Indicator\">[</span><span class=\"nv\">-g</span><span class=\"p-Indicator\">,</span> <span class=\"nv\">-O3</span><span class=\"p-Indicator\">]</span>\n</pre>\n<p>This configuration file needs to be loaded using <tt>dynamake.config.Config.load</tt>. The\nprovided <tt>make</tt> main function will automatically load the <tt>DynaMake.yaml</tt> configuration file, if\nit exists, followed by any file specified using the <tt><span class=\"pre\">--step_config</span></tt> command line option(s), if\nany.</p>\n<div>\n<p>Note</p>\n<p><strong>Do not confuse build and step configuration files.</strong></p>\n<p>The <tt>DynaConf.yaml</tt> and <tt><span class=\"pre\">--config</span></tt> files control the <strong>build</strong> configuration parameters.\nThe <tt>DynaMake.yaml</tt> and <tt><span class=\"pre\">--step_config</span></tt> control control the <strong>steps</strong> configuration\nparameters. Thus the <tt>DynaConf.yaml</tt> contains simple build parameter values, while\n<tt>DynaMake.yaml</tt> contains configuration <strong>rules</strong> used to decide on the parameter values for\neach build step invocation.</p>\n</div>\n<p>Explicitly using configuration parameters as shown above is needed when executing generic programs.\nIf, however, the action invokes a program implemented using the <tt>dynamake.application</tt>\nfunctions, it is possible to do better, by using a generated action configuration file. For\nexample:</p>\n<pre><span class=\"nd\">@dm</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"o\">=</span><span class=\"s1\">'foo'</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">make_foo</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">require</span><span class=\"p\">(</span><span class=\"s1\">'bar'</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">spawn</span><span class=\"p\">(</span><span class=\"s1\">'dynamain'</span><span class=\"p\">,</span> <span class=\"s1\">'bar_to_foo'</span><span class=\"p\">,</span> <span class=\"s1\">'--config'</span><span class=\"p\">,</span> <span class=\"n\">dm</span><span class=\"o\">.</span><span class=\"n\">config_file</span><span class=\"p\">(),</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n<p>If <tt>dynamake.make.config_file</tt> is invoked, then DynaMake will generate a configuration file\ncontaining just the parameter values for this specific step invocation. If this file is missing or\ncontains different values, than it will trigger the actions, even if the output files otherwise seem\nup-to-date. Thus, even if the main <tt>DynaConf.yaml</tt> file is modified, an action will only be\nrebuilt if its own effective parameter values have changed.</p>\n<p>The paths to the generated configuration files are similar to the path to the persistent state\nfiles: <tt>.dynamake/step_name.config.yaml</tt> or\n<tt>.dynamake/step_name/param=value&amp;param=value.config.yaml</tt>. Thus, if for some reason you want to\navoid all persistent state, you should not use this functionality.</p>\n<p>As an additional convenience, DynaMake provides the <tt>dynamake.make.submit</tt> function which\nallows the action configuration file to specify a <tt>run_prefix</tt> and/or <tt>run_suffix</tt> around what\nwould otherwise be a normal <cite>spawn</cite> action. For example:</p>\n<pre><span class=\"nd\">@dm</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">(</span><span class=\"n\">output</span><span class=\"o\">=</span><span class=\"s1\">'foo'</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">make_foo</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">require</span><span class=\"p\">(</span><span class=\"s1\">'bar'</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">spawn</span><span class=\"p\">(</span><span class=\"s1\">'compute_foo_from_bar'</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n<p>Combined with the YAML configuration file:</p>\n<pre><span class=\"p-Indicator\">-</span> <span class=\"nt\">when</span><span class=\"p\">:</span>\n    <span class=\"nt\">step</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">make_foo</span>\n  <span class=\"nt\">then</span><span class=\"p\">:</span>\n    <span class=\"nt\">run_prefix</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">run_on_compute_cluster</span>\n</pre>\n<p>Will result in DynaMake executing the <tt>shell</tt> command <tt>run_on_compute_cluster\ncompute_foo_from_bar ...</tt>. Both the prefix and suffix are marked as <tt>phony</tt> so modifying them\nwill not trigger a rebuild. By default both prefix and suffix are empty, in which case <tt>submit</tt>\nbehaves identically to <tt>spawn</tt>.</p>\n</div>\n<div id=\"logging\">\n<h3>Logging</h3>\n<p>Complex build scripts are notoriously difficult to debug. To help alleviate this pain, DynaMake\nuses the standard Python logging mechanism, and supports the following logging levels:</p>\n<ul>\n<li><tt>INFO</tt> prints only the executed actions. This is similar to the default <tt>make</tt> behavior.\nUse this if you just want to know what is being run, when all is well. If\n<tt><span class=\"pre\">--log_skipped_actions</span></tt> is set, then this will also log skipped actions.</li>\n<li><tt>WHY</tt> also prints the reason for executing each action (which output file does not exist and\nneeds to be created, which input file is newer than which output file, etc.). This is useful\nfor debugging the logic of the build script.</li>\n<li><tt>TRACE</tt> also prints each step invocation. This can further help in debugging the logic of the\nbuild script.</li>\n<li><tt>DEBUG</tt> prints a lot of very detailed information about the flow. Expanded globs, the full\nlist of input and output files, the configuration files used, etc. This is useful in the hopefully\nvery rare cases when the terse output from the <tt>WHY</tt> and <tt>TRACE</tt> levels is not sufficient for\nfiguring out what went wrong.</li>\n</ul>\n<p>The <tt>WHY</tt> and <tt>TRACE</tt> levels are not a standard python log level. They are defined to be between\n<tt>DEBUG</tt> and <tt>INFO</tt>, in the proper order.</p>\n<p>If using the provided <tt>make</tt> main function, the logging level can be set using the <tt><span class=\"pre\">--log-level</span></tt>\ncommand line option. The default log level is <tt>WARN</tt> which means the only expected output would\nbe from the actions themselves.</p>\n</div>\n<div id=\"configurable-applications\">\n<h3>Configurable Applications</h3>\n<p>A major use case for DynaMake is automating scientific computation pipelines. Such pipelines involve\nmultiple actions, which are often also implemented in Python. Each such action also has its own\nconfiguration parameters, which we\u2019d like to control using action configuration as described\nabove.</p>\n<p>A realistic system has multiple such functions that need to be invoked. It is a hassle to have to\ncreate a separate script for invoking each such function. A way around this is to create a single\nscript which takes the function name as a command-line argument.</p>\n<p>DynaMake therefore factors out support for configurable Python-based programs, allowing users to\nimplement their own. The <tt>dynamake</tt> script itself can be seen as just another such customized\nprogram.</p>\n<p>DynaMake installs a universal <tt>dynamain</tt> script which is a thin wrapper for a provided\n<tt>dynamake.application.main</tt> function. This script automatically imports <tt>DynaMain.py</tt> if\nit exists, and any other modules specified by the <tt><span class=\"pre\">--module</span></tt> command line option.</p>\n<p>Similarly to the <tt>make</tt> main function, you can implement your own custom script:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">argparse</span>\n<span class=\"kn\">import</span> <span class=\"nn\">dynamake.application</span> <span class=\"k\">as</span> <span class=\"nn\">da</span>\n<span class=\"kn\">import</span> <span class=\"nn\">my_functions</span>\n\n<span class=\"n\">da</span><span class=\"o\">.</span><span class=\"n\">main</span><span class=\"p\">(</span><span class=\"n\">argparse</span><span class=\"o\">.</span><span class=\"n\">ArgumentParser</span><span class=\"p\">(</span><span class=\"n\">description</span><span class=\"o\">=</span><span class=\"s1\">'...'</span><span class=\"p\">))</span>\n</pre>\n<p>You can also directly invoke the lower-level API to directly invoke the functions.\nSee the implementation of the <tt>main</tt> function and the API documentation for details.</p>\n<p>Here is a trivial example configurable function which can be invoked from the command line using\nthis mechanisms:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">dynamake.application</span> <span class=\"k\">as</span> <span class=\"nn\">da</span>\n\n<span class=\"n\">da</span><span class=\"o\">.</span><span class=\"n\">Param</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'bar'</span><span class=\"p\">,</span> <span class=\"n\">default</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">parser</span><span class=\"o\">=</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">description</span><span class=\"o\">=</span><span class=\"s1\">'The number of bars'</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@da</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"p\">(</span><span class=\"n\">top</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">foo</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">do_bar</span><span class=\"p\">()</span>\n\n<span class=\"nd\">@da</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"p\">()</span>\n<span class=\"k\">def</span> <span class=\"nf\">do_bar</span><span class=\"p\">(</span><span class=\"n\">bar</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"n\">env</span><span class=\"p\">())</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">bar</span><span class=\"p\">)</span>\n</pre>\n<p>The usage pattern of the library is as follows:</p>\n<ul>\n<li>First, one must declare all the parameters of all the configured functions by creating\n<tt>dynamake.application.Param</tt> objects.</li>\n<li>All functions that use such parameters must be decorated with\n<tt>dynamake.application.config</tt>. They must either be annotated as top level using\n<tt>top=True</tt>, or be directly invoked from another configured function (and, ultimately, from a\ntop-level function).</li>\n<li>Some parameters are already defined and managed for you, such as <tt>log_level</tt> to control logging\nand <tt>random_seed</tt> to control the random number generation. The latter is only added if you\nspecify <tt>random=True</tt> when invoking <tt>config</tt>. Similarly, <tt>jobs</tt> controls the number of\nprocessors used in parallel, and is only added if you specify <tt>parallel=True</tt> when invoking\n<tt>config</tt>.</li>\n</ul>\n<div>\n<p>Note</p>\n<p><strong>The automatic detection of invocations of one configurable function from another is\nsimplistic.</strong></p>\n<p>Basically, if we see inside the function source the name of another function, and this isn\u2019t the\nname of a variable being assigned to, then we assume this is a call. This isn\u2019t 100% complete;\nfor example this will not detect cases where <tt>foo</tt> calls a non-configured <tt>bar</tt> which then\ncalls a configured <tt>baz</tt>. However it works \u201cwell enough\u201d for simple code.</p>\n</div>\n<ul>\n<li>The configured parameters must use <tt>dynamake.application.env</tt> as the parameter\u2019s default\nvalue. This will inject the proper value at each point.</li>\n</ul>\n<p>To invoke this function from the command line, run <tt>dynamain foo</tt> (or, possibly, <tt>dynamain\n<span class=\"pre\">--module</span> my_functions foo</tt>, or <tt>dynamain <span class=\"pre\">--config</span> my_configuration.yaml foo</tt>, etc.). A possible\nconfiguration file for this program would be:</p>\n<pre><span class=\"n\">bar</span><span class=\"p\">:</span> <span class=\"mi\">2</span>  <span class=\"c1\"># The program will print 2 instead of the default 1.</span>\n</pre>\n<p>The <tt>main</tt> function is self-documenting. Running it with the <tt><span class=\"pre\">--help</span></tt> command line option will\nlist all the available top-level functions. Running it with <tt><span class=\"pre\">--help</span> function_name</tt> will print the\nfunction\u2019s documentation, and list all the parameters used by it (or any configurable function it\nindirectly invokes).</p>\n<p>The <tt>dynamain.application.Prog.logger</tt> provides access to Python\u2019s logging facilities,\nconfigured by the <tt><span class=\"pre\">--log_level</span></tt> command line option. That is, just write\n<tt><span class=\"pre\">Prog.logger.debug(...)</span></tt> etc.</p>\n<p>The <tt>dynamain.application.parallel</tt> function allows multiple invocations of some function\nin parallel. The number of processes used is controlled by the <tt><span class=\"pre\">--jobs</span></tt> command line option. Any\nnested <tt>parallel</tt> invocation will execute serially, to ensure this limit is respected. To make it\neasier to debug code, <tt>dynamain.application.serial</tt> has exactly the same interface, but\nexecutes the calls serially.</p>\n<p>Finally, you can override the value of some configuration parameters for some code. For example,\nthe following:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">dynamake.application</span> <span class=\"k\">as</span> <span class=\"nn\">da</span>\n\n<span class=\"n\">da</span><span class=\"o\">.</span><span class=\"n\">Param</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">'foo'</span><span class=\"p\">,</span> <span class=\"n\">default</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">parser</span><span class=\"o\">=</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">description</span><span class=\"o\">=</span><span class=\"s1\">'The number of foos'</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@config</span><span class=\"p\">()</span>\n<span class=\"k\">def</span> <span class=\"nf\">print_foo</span><span class=\"p\">(</span><span class=\"n\">title</span><span class=\"p\">:</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">foo</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"n\">env</span><span class=\"p\">())</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">title</span><span class=\"p\">,</span> <span class=\"n\">foo</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@config</span>\n<span class=\"k\">def</span> <span class=\"nf\">override_foo</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">print_foo</span><span class=\"p\">(</span><span class=\"s1\">'global:'</span><span class=\"p\">)</span>\n    <span class=\"n\">print_foo</span><span class=\"p\">(</span><span class=\"s1\">'explicit:'</span><span class=\"p\">,</span> <span class=\"n\">foo</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"k\">with</span> <span class=\"p\">(</span><span class=\"n\">da</span><span class=\"o\">.</span><span class=\"n\">override</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)):</span>\n        <span class=\"n\">print_foo</span><span class=\"p\">(</span><span class=\"s1\">'override:'</span><span class=\"p\">)</span>\n</pre>\n<p>Will print:</p>\n<pre><span class=\"nt\">global</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">1</span>\n<span class=\"nt\">explicit</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">2</span>\n<span class=\"nt\">override</span><span class=\"p\">:</span> <span class=\"l-Scalar-Plain\">3</span>\n</pre>\n</div>\n</div>\n<div id=\"what-not-yet\">\n<h2>WHAT NOT (YET)</h2>\n<p>Since DynaMake is very new, there are many features that should be implemented, but haven\u2019t been\nworked on yet:</p>\n<ul>\n<li>Improve the documentation. This README covers the basics but there are additional features that\nare only mentioned in the class and function documentation, and deserves a better description.</li>\n<li>Allow forcing rebuilding (some) targets.</li>\n<li>Dry run. While it is impossible in general to print the full set of dry run actions, if should\nbe easy to just print the 1st action(s) that need to be executed. This should provide most of the\nvalue.</li>\n<li>Allow automated clean actions based on the collected step outputs. If there\u2019s nothing\nto be done when building some target(s), then all generated output files (with or without the\nultimate targets) should be fair game to being removed as part of a clean action. However, due to\nthe dry-run problem, we can\u2019t automatically clean outputs of actions that depend on actions that\nstill need to be executed.</li>\n<li>Allow skipping generating intermediate files if otherwise no actions need to be done. This is very\nhard to do with a dynamic build graph - probably impossible in the general case, but common\ncases might be possible(?)</li>\n<li>Generate a tree (actually a DAG) of step invocations. This can be collected from the persistent\nstate files.</li>\n<li>Generate a visualization of the timeline of action executions showing start and end times, and\npossibly also resources consumption. In case of distributed actions, make a distinction between\nsubmission and completion times and actual start/end times to track the cluster/grid overheads.</li>\n<li>Allow registering additional file formats for the generated configuration files, to allow using\nthem for non-DynaMake external actions.</li>\n<li>Allow using checksums instead of timestamps to determine if actions can be skipped, either\nby default or on a per-file basis.</li>\n</ul>\n</div>\n\n          </div>"}, "last_serial": 6013444, "releases": {"0.4.25": [{"comment_text": "", "digests": {"md5": "450fb49e7765da88774374efd5ad011d", "sha256": "296d90f96bc8712b872366f802349351a652e2f7798c398fd67609274cd996c1"}, "downloads": -1, "filename": "dynamake-0.4.25.tar.gz", "has_sig": false, "md5_digest": "450fb49e7765da88774374efd5ad011d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 100377, "upload_time": "2019-10-22T13:32:13", "upload_time_iso_8601": "2019-10-22T13:32:13.060644Z", "url": "https://files.pythonhosted.org/packages/f5/9c/7210080a24c10bb903ebe4924f829c8a57f2b1294985cad745e861ffd486/dynamake-0.4.25.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "450fb49e7765da88774374efd5ad011d", "sha256": "296d90f96bc8712b872366f802349351a652e2f7798c398fd67609274cd996c1"}, "downloads": -1, "filename": "dynamake-0.4.25.tar.gz", "has_sig": false, "md5_digest": "450fb49e7765da88774374efd5ad011d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 100377, "upload_time": "2019-10-22T13:32:13", "upload_time_iso_8601": "2019-10-22T13:32:13.060644Z", "url": "https://files.pythonhosted.org/packages/f5/9c/7210080a24c10bb903ebe4924f829c8a57f2b1294985cad745e861ffd486/dynamake-0.4.25.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:48:44 2020"}