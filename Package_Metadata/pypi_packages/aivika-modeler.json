{"info": {"author": "David E. Sorokin", "author_email": "david.sorokin@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: BSD License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Topic :: Scientific/Engineering"], "description": "Aivika Modeler is a simulation modeling tool for Python\n=======================================================\n\nUsing Aivika Modeler, you can create quite fast discrete event simulation\nmodels that are translated into native code. Also you can run the simulation\nexperiments by the Monte Carlo method, specifying that how the results should\nbe processed. It can plot Time Series, Deviation chart by the confidence\ninterval, plot histograms, save the results in the CSV files for the\nfurther analysis and more. All is defined in just a few lines of code written\nin Python. Then the report of the simulation experiment with charts, statistics\nsummary and links to the saved CSV files is automatically opened in your Web\nbrowser.\n\nExample\n-------\n\nTo take a taste of Aivika Modeler, here is a complete simulation model and\nthe corresponding experiment that define a simple queue network. The model\ncontains a transact generator, two bounded queues, two servers and the arrival\ntimer that measures the processing of transacts. The experiment launches\n1000 simulation runs in parallel, plots charts and then opens a report with\nthe results of simulation in the Web browser. The compilation, simulation\nand chart plotting took about 1 minute on my laptop.\n\n  Example: *Work Stations in Series*\n\n  This is a model of two work stations connected in a series and separated by\n  finite queues. It is described in different sources [1, 2]. So, this is\n  chapter 7 of [2] and section 5.14 of [1].\n\n  [1] A. Alan B. Pritsker, Simulation with Visual SLAM and AweSim, 2nd ed.\n\n  [2] \u0422\u0440\u0443\u0431 \u0418.\u0418., \u041e\u0431\u044a\u0435\u043a\u0442\u043d\u043e-\u043e\u0440\u0438\u0435\u043d\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043d\u0430 C++: \u0423\u0447\u0435\u0431\u043d\u044b\u0439 \u043a\u0443\u0440\u0441. - \u0421\u041f\u0431.: \u041f\u0438\u0442\u0435\u0440, 2006\n\n  The maintenance facility of a large manufacturer performs two operations.\n  These operations must be performed in series; operation 2 always follows\n  operation 1. The units that are maintained are bulky, and space is available\n  for only eight units including the units being worked on. A proposed design\n  leaves space for two units between the work stations, and space for four units\n  before work station 1. [..] Current company policy is to subcontract\n  the maintenance of a unit if it cannot gain access to the in-house facility.\n\n  Historical data indicates that the time interval between requests for\n  maintenance is exponentially distributed with a mean of 0.4 time units.\n  Service times are also exponentially distributed with the first station\n  requiring on the average 0.25 time units and the second station, 0.5 time\n  units. Units are transported automatically from work station 1 to work\n  station 2 in a negligible amount of time. If the queue of work station 2 is\n  full, that is, if there are two units awaiting for work station 2, the first\n  station is blocked and a unit cannot leave the station. A blocked work\n  station cannot server other units.\n\n.. code:: python\n\n  #!/usr/local/bin/python3\n\n  from simulation.aivika.modeler import *\n\n  model = MainModel()\n\n  # the transacts can have assignable and updatable fields, but it is not used here\n  data_type = TransactType(model, 'Transact')\n\n  # it will help us to measure the processing time of transacts\n  timer = create_arrival_timer(model,\n      name = 'timer', descr = 'Measures the processing time')\n  timer_source = timer.add_result_source()\n\n  # this is a generator of transacts\n  input_stream = exponential_random_stream(data_type, 0.4)\n\n  # a queue before the first workstation\n  queue1 = create_queue(model, data_type, 4,\n      name = 'queue1', descr = 'Queue no. 1')\n  queue1_source = queue1.add_result_source()\n\n  # another queue before the second workstation\n  queue2 = create_queue(model, data_type, 2,\n      name = 'queue2', descr = 'Queue no. 2')\n  queue2_source = queue2.add_result_source()\n\n  # the first workstation activity is modeled by the server\n  workstation1 = exponential_random_server(data_type, 0.25,\n      name = 'workstation1', descr = 'Workstation no. 1')\n  workstation1_source = workstation1.add_result_source()\n\n  # this is the second workstation\n  workstation2 = exponential_random_server(data_type, 0.5,\n      name = 'workstation2', descr = 'Workstation no. 2')\n  workstation2_source = workstation2.add_result_source()\n\n  # try to enqueue the arrivals; otherwise, count them as lost\n  enqueue_stream_or_remove_item(queue1, input_stream)\n\n  # a chain of streams originated from the first queue\n  stream2 = dequeue_stream(queue1)\n  stream3 = server_stream(workstation1, stream2)\n  enqueue_stream(queue2, stream3)\n\n  # another chain of streams, which must be terminated already\n  stream4 = dequeue_stream(queue2)\n  stream5 = server_stream(workstation2, stream4)\n  stream5 = arrival_timer_stream(timer, stream5)\n  terminate_stream(stream5)\n\n  # reset the statistics after 30 time units\n  reset_time = 30\n  reset_queue(queue1, reset_time)\n  reset_queue(queue2, reset_time)\n  reset_server(workstation1, reset_time)\n  reset_server(workstation2, reset_time)\n  reset_arrival_timer(timer, reset_time)\n\n  # it defines the simulation specs\n  specs = Specs(0, 300, 0.1)\n\n  processing_factors = [workstation1_source.processing_factor,\n      workstation2_source.processing_factor]\n\n  # define what to display in the report\n  views = [ExperimentSpecsView(),\n           InfoView(),\n           FinalStatsView(title = 'Processing Time (Statistics Summary)',\n              series = [timer_source.processing_time]),\n           DeviationChartView(title = 'Processing Factor (Chart)',\n              right_y_series = processing_factors),\n           FinalHistogramView(title = 'Processing Factor (Histogram)',\n              series = processing_factors),\n           FinalStatsView(title = 'Processing Factor (Statistics Summary)',\n              series = processing_factors),\n           FinalStatsView(title = 'Lost Items (Statistics Summary)',\n              series = [queue1_source.enqueue_lost_count]),\n           DeviationChartView(title = 'Queue Size (Chart)',\n              right_y_series = [queue1_source.count,\n                                queue2_source.count]),\n           FinalStatsView(title = 'Queue Size (Statistics Summary)',\n              series = [queue1_source.count_stats,\n                        queue2_source.count_stats]),\n           DeviationChartView(title = 'Queue Wait Time (Chart)',\n              right_y_series = [queue1_source.wait_time,\n                                queue2_source.wait_time]),\n           FinalStatsView(title = 'Queue Wait Time (Statistics Summary)',\n              series = [queue1_source.wait_time,\n                        queue2_source.wait_time])]\n\n  # it will render the report\n  renderer = ExperimentRendererUsingDiagrams(views)\n\n  # it defines the simulation experiment with 1000 runs\n  experiment = Experiment(renderer, run_count = 1000)\n\n  # it compiles the model and runs the simulation experiment\n  model.run(specs, experiment)\n\nAfter running the simulation experiment, you will see the Deviation charts\nthat will show the confidence intervals by rule 3 sigma. Also you will see\na general information about the experiment as well as histograms and summary\nstatistics sections for some properties such as the queue size, queue wait time,\nthe processing time of transacts and the server processing factor\nin the final time point.\n\nHow It Works\n------------\n\nThe model written in Python is translated into its Haskell representation\nbased on using the Aivika simulation libraries, namely `aivika\n<http://hackage.haskell.org/package/aivika>`_ and `aivika-transformers\n<http://hackage.haskell.org/package/aivika-transformers>`_.\nThen the translated model is compiled by GHC into native code and executed.\nThe simulation itself should be quite fast and efficient.\n\nFor the first time, the process of compiling and preparing the model\nfor running may take a few minutes. On next time, it may take just\na few seconds.\n\nInstallation\n------------\n\nThere is one prerequisite, though. To use Aivika Modeler, you must have\n`Stack <http://docs.haskellstack.org/>`_ installed on your computer.\nThe main operating systems are supported: Windows, Linux and macOS.\n\nThen you can install the ``aivika-modeler`` package using *pip* in usual way.\n\nLicense\n-------\n\nAivika Modeler is licensed under the open-source BSD3 license like that how\nthe main libraries of Aivika itself are licensed under this license.\n\nCombining Haskell and Python\n-------------------------------\n\nIn most cases you do not need to know the Haskell programming language.\nThe knowledge of Python will be sufficient to create and run many simulation\nmodels. But if you will need a non-standard component, for example, to simulate\nthe TCP/IP protocol, then you or somebody else will have to write its\nimplementation in Haskell and then create the corresponding wrapper in\nPython so that it would be possible to use the component from Python.\n\nThere is a separation of concerns. Python is used as a high-level glue for\ncombining components to build the complete simulation model, while Haskell is\nused as a high-level modeling language for writing such components.\n\nGPSS\n----\n\nAivika itself also supports a DSL, which is very similar to the popular GPSS\nmodeling language but not fully equivalent, though. This DSL is implemented in\npackage `aivika-gpss <http://hackage.haskell.org/package/aivika-gpss>`_.\nThere are plans to add the corresponding support to Aivika Modeler too.\nPlease stay tuned.\n\nWebsite\n--------\n\nYou can find a more full information on website `www.aivikasoft.com\n<http://www.aivikasoft.com>`_.\n\n\n", "description_content_type": null, "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/dsorokin/aivika-modeler", "keywords": "simulation,discrete event simulation,simulation library,queue network", "license": "BSD3", "maintainer": "", "maintainer_email": "", "name": "aivika-modeler", "package_url": "https://pypi.org/project/aivika-modeler/", "platform": "", "project_url": "https://pypi.org/project/aivika-modeler/", "project_urls": {"Homepage": "https://github.com/dsorokin/aivika-modeler"}, "release_url": "https://pypi.org/project/aivika-modeler/1.0.0/", "requires_dist": null, "requires_python": "", "summary": "A discrete event simulation modeling tool", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>Using Aivika Modeler, you can create quite fast discrete event simulation\nmodels that are translated into native code. Also you can run the simulation\nexperiments by the Monte Carlo method, specifying that how the results should\nbe processed. It can plot Time Series, Deviation chart by the confidence\ninterval, plot histograms, save the results in the CSV files for the\nfurther analysis and more. All is defined in just a few lines of code written\nin Python. Then the report of the simulation experiment with charts, statistics\nsummary and links to the saved CSV files is automatically opened in your Web\nbrowser.</p>\n<div id=\"example\">\n<h2>Example</h2>\n<p>To take a taste of Aivika Modeler, here is a complete simulation model and\nthe corresponding experiment that define a simple queue network. The model\ncontains a transact generator, two bounded queues, two servers and the arrival\ntimer that measures the processing of transacts. The experiment launches\n1000 simulation runs in parallel, plots charts and then opens a report with\nthe results of simulation in the Web browser. The compilation, simulation\nand chart plotting took about 1 minute on my laptop.</p>\n<blockquote>\n<p>Example: <em>Work Stations in Series</em></p>\n<p>This is a model of two work stations connected in a series and separated by\nfinite queues. It is described in different sources [1, 2]. So, this is\nchapter 7 of [2] and section 5.14 of [1].</p>\n<p>[1] A. Alan B. Pritsker, Simulation with Visual SLAM and AweSim, 2nd ed.</p>\n<p>[2] \u0422\u0440\u0443\u0431 \u0418.\u0418., \u041e\u0431\u044a\u0435\u043a\u0442\u043d\u043e-\u043e\u0440\u0438\u0435\u043d\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u0435 \u043c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043d\u0430 C++: \u0423\u0447\u0435\u0431\u043d\u044b\u0439 \u043a\u0443\u0440\u0441. - \u0421\u041f\u0431.: \u041f\u0438\u0442\u0435\u0440, 2006</p>\n<p>The maintenance facility of a large manufacturer performs two operations.\nThese operations must be performed in series; operation 2 always follows\noperation 1. The units that are maintained are bulky, and space is available\nfor only eight units including the units being worked on. A proposed design\nleaves space for two units between the work stations, and space for four units\nbefore work station 1. [..] Current company policy is to subcontract\nthe maintenance of a unit if it cannot gain access to the in-house facility.</p>\n<p>Historical data indicates that the time interval between requests for\nmaintenance is exponentially distributed with a mean of 0.4 time units.\nService times are also exponentially distributed with the first station\nrequiring on the average 0.25 time units and the second station, 0.5 time\nunits. Units are transported automatically from work station 1 to work\nstation 2 in a negligible amount of time. If the queue of work station 2 is\nfull, that is, if there are two units awaiting for work station 2, the first\nstation is blocked and a unit cannot leave the station. A blocked work\nstation cannot server other units.</p>\n</blockquote>\n<pre><span class=\"ch\">#!/usr/local/bin/python3</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">simulation.aivika.modeler</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">MainModel</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># the transacts can have assignable and updatable fields, but it is not used here</span>\n<span class=\"n\">data_type</span> <span class=\"o\">=</span> <span class=\"n\">TransactType</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">,</span> <span class=\"s1\">'Transact'</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># it will help us to measure the processing time of transacts</span>\n<span class=\"n\">timer</span> <span class=\"o\">=</span> <span class=\"n\">create_arrival_timer</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">,</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'timer'</span><span class=\"p\">,</span> <span class=\"n\">descr</span> <span class=\"o\">=</span> <span class=\"s1\">'Measures the processing time'</span><span class=\"p\">)</span>\n<span class=\"n\">timer_source</span> <span class=\"o\">=</span> <span class=\"n\">timer</span><span class=\"o\">.</span><span class=\"n\">add_result_source</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># this is a generator of transacts</span>\n<span class=\"n\">input_stream</span> <span class=\"o\">=</span> <span class=\"n\">exponential_random_stream</span><span class=\"p\">(</span><span class=\"n\">data_type</span><span class=\"p\">,</span> <span class=\"mf\">0.4</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># a queue before the first workstation</span>\n<span class=\"n\">queue1</span> <span class=\"o\">=</span> <span class=\"n\">create_queue</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">,</span> <span class=\"n\">data_type</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'queue1'</span><span class=\"p\">,</span> <span class=\"n\">descr</span> <span class=\"o\">=</span> <span class=\"s1\">'Queue no. 1'</span><span class=\"p\">)</span>\n<span class=\"n\">queue1_source</span> <span class=\"o\">=</span> <span class=\"n\">queue1</span><span class=\"o\">.</span><span class=\"n\">add_result_source</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># another queue before the second workstation</span>\n<span class=\"n\">queue2</span> <span class=\"o\">=</span> <span class=\"n\">create_queue</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">,</span> <span class=\"n\">data_type</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'queue2'</span><span class=\"p\">,</span> <span class=\"n\">descr</span> <span class=\"o\">=</span> <span class=\"s1\">'Queue no. 2'</span><span class=\"p\">)</span>\n<span class=\"n\">queue2_source</span> <span class=\"o\">=</span> <span class=\"n\">queue2</span><span class=\"o\">.</span><span class=\"n\">add_result_source</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># the first workstation activity is modeled by the server</span>\n<span class=\"n\">workstation1</span> <span class=\"o\">=</span> <span class=\"n\">exponential_random_server</span><span class=\"p\">(</span><span class=\"n\">data_type</span><span class=\"p\">,</span> <span class=\"mf\">0.25</span><span class=\"p\">,</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'workstation1'</span><span class=\"p\">,</span> <span class=\"n\">descr</span> <span class=\"o\">=</span> <span class=\"s1\">'Workstation no. 1'</span><span class=\"p\">)</span>\n<span class=\"n\">workstation1_source</span> <span class=\"o\">=</span> <span class=\"n\">workstation1</span><span class=\"o\">.</span><span class=\"n\">add_result_source</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># this is the second workstation</span>\n<span class=\"n\">workstation2</span> <span class=\"o\">=</span> <span class=\"n\">exponential_random_server</span><span class=\"p\">(</span><span class=\"n\">data_type</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span>\n    <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s1\">'workstation2'</span><span class=\"p\">,</span> <span class=\"n\">descr</span> <span class=\"o\">=</span> <span class=\"s1\">'Workstation no. 2'</span><span class=\"p\">)</span>\n<span class=\"n\">workstation2_source</span> <span class=\"o\">=</span> <span class=\"n\">workstation2</span><span class=\"o\">.</span><span class=\"n\">add_result_source</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># try to enqueue the arrivals; otherwise, count them as lost</span>\n<span class=\"n\">enqueue_stream_or_remove_item</span><span class=\"p\">(</span><span class=\"n\">queue1</span><span class=\"p\">,</span> <span class=\"n\">input_stream</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># a chain of streams originated from the first queue</span>\n<span class=\"n\">stream2</span> <span class=\"o\">=</span> <span class=\"n\">dequeue_stream</span><span class=\"p\">(</span><span class=\"n\">queue1</span><span class=\"p\">)</span>\n<span class=\"n\">stream3</span> <span class=\"o\">=</span> <span class=\"n\">server_stream</span><span class=\"p\">(</span><span class=\"n\">workstation1</span><span class=\"p\">,</span> <span class=\"n\">stream2</span><span class=\"p\">)</span>\n<span class=\"n\">enqueue_stream</span><span class=\"p\">(</span><span class=\"n\">queue2</span><span class=\"p\">,</span> <span class=\"n\">stream3</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># another chain of streams, which must be terminated already</span>\n<span class=\"n\">stream4</span> <span class=\"o\">=</span> <span class=\"n\">dequeue_stream</span><span class=\"p\">(</span><span class=\"n\">queue2</span><span class=\"p\">)</span>\n<span class=\"n\">stream5</span> <span class=\"o\">=</span> <span class=\"n\">server_stream</span><span class=\"p\">(</span><span class=\"n\">workstation2</span><span class=\"p\">,</span> <span class=\"n\">stream4</span><span class=\"p\">)</span>\n<span class=\"n\">stream5</span> <span class=\"o\">=</span> <span class=\"n\">arrival_timer_stream</span><span class=\"p\">(</span><span class=\"n\">timer</span><span class=\"p\">,</span> <span class=\"n\">stream5</span><span class=\"p\">)</span>\n<span class=\"n\">terminate_stream</span><span class=\"p\">(</span><span class=\"n\">stream5</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># reset the statistics after 30 time units</span>\n<span class=\"n\">reset_time</span> <span class=\"o\">=</span> <span class=\"mi\">30</span>\n<span class=\"n\">reset_queue</span><span class=\"p\">(</span><span class=\"n\">queue1</span><span class=\"p\">,</span> <span class=\"n\">reset_time</span><span class=\"p\">)</span>\n<span class=\"n\">reset_queue</span><span class=\"p\">(</span><span class=\"n\">queue2</span><span class=\"p\">,</span> <span class=\"n\">reset_time</span><span class=\"p\">)</span>\n<span class=\"n\">reset_server</span><span class=\"p\">(</span><span class=\"n\">workstation1</span><span class=\"p\">,</span> <span class=\"n\">reset_time</span><span class=\"p\">)</span>\n<span class=\"n\">reset_server</span><span class=\"p\">(</span><span class=\"n\">workstation2</span><span class=\"p\">,</span> <span class=\"n\">reset_time</span><span class=\"p\">)</span>\n<span class=\"n\">reset_arrival_timer</span><span class=\"p\">(</span><span class=\"n\">timer</span><span class=\"p\">,</span> <span class=\"n\">reset_time</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># it defines the simulation specs</span>\n<span class=\"n\">specs</span> <span class=\"o\">=</span> <span class=\"n\">Specs</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">300</span><span class=\"p\">,</span> <span class=\"mf\">0.1</span><span class=\"p\">)</span>\n\n<span class=\"n\">processing_factors</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">workstation1_source</span><span class=\"o\">.</span><span class=\"n\">processing_factor</span><span class=\"p\">,</span>\n    <span class=\"n\">workstation2_source</span><span class=\"o\">.</span><span class=\"n\">processing_factor</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># define what to display in the report</span>\n<span class=\"n\">views</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">ExperimentSpecsView</span><span class=\"p\">(),</span>\n         <span class=\"n\">InfoView</span><span class=\"p\">(),</span>\n         <span class=\"n\">FinalStatsView</span><span class=\"p\">(</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"s1\">'Processing Time (Statistics Summary)'</span><span class=\"p\">,</span>\n            <span class=\"n\">series</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">timer_source</span><span class=\"o\">.</span><span class=\"n\">processing_time</span><span class=\"p\">]),</span>\n         <span class=\"n\">DeviationChartView</span><span class=\"p\">(</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"s1\">'Processing Factor (Chart)'</span><span class=\"p\">,</span>\n            <span class=\"n\">right_y_series</span> <span class=\"o\">=</span> <span class=\"n\">processing_factors</span><span class=\"p\">),</span>\n         <span class=\"n\">FinalHistogramView</span><span class=\"p\">(</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"s1\">'Processing Factor (Histogram)'</span><span class=\"p\">,</span>\n            <span class=\"n\">series</span> <span class=\"o\">=</span> <span class=\"n\">processing_factors</span><span class=\"p\">),</span>\n         <span class=\"n\">FinalStatsView</span><span class=\"p\">(</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"s1\">'Processing Factor (Statistics Summary)'</span><span class=\"p\">,</span>\n            <span class=\"n\">series</span> <span class=\"o\">=</span> <span class=\"n\">processing_factors</span><span class=\"p\">),</span>\n         <span class=\"n\">FinalStatsView</span><span class=\"p\">(</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"s1\">'Lost Items (Statistics Summary)'</span><span class=\"p\">,</span>\n            <span class=\"n\">series</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">queue1_source</span><span class=\"o\">.</span><span class=\"n\">enqueue_lost_count</span><span class=\"p\">]),</span>\n         <span class=\"n\">DeviationChartView</span><span class=\"p\">(</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"s1\">'Queue Size (Chart)'</span><span class=\"p\">,</span>\n            <span class=\"n\">right_y_series</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">queue1_source</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">,</span>\n                              <span class=\"n\">queue2_source</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">]),</span>\n         <span class=\"n\">FinalStatsView</span><span class=\"p\">(</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"s1\">'Queue Size (Statistics Summary)'</span><span class=\"p\">,</span>\n            <span class=\"n\">series</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">queue1_source</span><span class=\"o\">.</span><span class=\"n\">count_stats</span><span class=\"p\">,</span>\n                      <span class=\"n\">queue2_source</span><span class=\"o\">.</span><span class=\"n\">count_stats</span><span class=\"p\">]),</span>\n         <span class=\"n\">DeviationChartView</span><span class=\"p\">(</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"s1\">'Queue Wait Time (Chart)'</span><span class=\"p\">,</span>\n            <span class=\"n\">right_y_series</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">queue1_source</span><span class=\"o\">.</span><span class=\"n\">wait_time</span><span class=\"p\">,</span>\n                              <span class=\"n\">queue2_source</span><span class=\"o\">.</span><span class=\"n\">wait_time</span><span class=\"p\">]),</span>\n         <span class=\"n\">FinalStatsView</span><span class=\"p\">(</span><span class=\"n\">title</span> <span class=\"o\">=</span> <span class=\"s1\">'Queue Wait Time (Statistics Summary)'</span><span class=\"p\">,</span>\n            <span class=\"n\">series</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">queue1_source</span><span class=\"o\">.</span><span class=\"n\">wait_time</span><span class=\"p\">,</span>\n                      <span class=\"n\">queue2_source</span><span class=\"o\">.</span><span class=\"n\">wait_time</span><span class=\"p\">])]</span>\n\n<span class=\"c1\"># it will render the report</span>\n<span class=\"n\">renderer</span> <span class=\"o\">=</span> <span class=\"n\">ExperimentRendererUsingDiagrams</span><span class=\"p\">(</span><span class=\"n\">views</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># it defines the simulation experiment with 1000 runs</span>\n<span class=\"n\">experiment</span> <span class=\"o\">=</span> <span class=\"n\">Experiment</span><span class=\"p\">(</span><span class=\"n\">renderer</span><span class=\"p\">,</span> <span class=\"n\">run_count</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># it compiles the model and runs the simulation experiment</span>\n<span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">specs</span><span class=\"p\">,</span> <span class=\"n\">experiment</span><span class=\"p\">)</span>\n</pre>\n<p>After running the simulation experiment, you will see the Deviation charts\nthat will show the confidence intervals by rule 3 sigma. Also you will see\na general information about the experiment as well as histograms and summary\nstatistics sections for some properties such as the queue size, queue wait time,\nthe processing time of transacts and the server processing factor\nin the final time point.</p>\n</div>\n<div id=\"how-it-works\">\n<h2>How It Works</h2>\n<p>The model written in Python is translated into its Haskell representation\nbased on using the Aivika simulation libraries, namely <a href=\"http://hackage.haskell.org/package/aivika\" rel=\"nofollow\">aivika</a> and <a href=\"http://hackage.haskell.org/package/aivika-transformers\" rel=\"nofollow\">aivika-transformers</a>.\nThen the translated model is compiled by GHC into native code and executed.\nThe simulation itself should be quite fast and efficient.</p>\n<p>For the first time, the process of compiling and preparing the model\nfor running may take a few minutes. On next time, it may take just\na few seconds.</p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<p>There is one prerequisite, though. To use Aivika Modeler, you must have\n<a href=\"http://docs.haskellstack.org/\" rel=\"nofollow\">Stack</a> installed on your computer.\nThe main operating systems are supported: Windows, Linux and macOS.</p>\n<p>Then you can install the <tt><span class=\"pre\">aivika-modeler</span></tt> package using <em>pip</em> in usual way.</p>\n</div>\n<div id=\"license\">\n<h2>License</h2>\n<p>Aivika Modeler is licensed under the open-source BSD3 license like that how\nthe main libraries of Aivika itself are licensed under this license.</p>\n</div>\n<div id=\"combining-haskell-and-python\">\n<h2>Combining Haskell and Python</h2>\n<p>In most cases you do not need to know the Haskell programming language.\nThe knowledge of Python will be sufficient to create and run many simulation\nmodels. But if you will need a non-standard component, for example, to simulate\nthe TCP/IP protocol, then you or somebody else will have to write its\nimplementation in Haskell and then create the corresponding wrapper in\nPython so that it would be possible to use the component from Python.</p>\n<p>There is a separation of concerns. Python is used as a high-level glue for\ncombining components to build the complete simulation model, while Haskell is\nused as a high-level modeling language for writing such components.</p>\n</div>\n<div id=\"gpss\">\n<h2>GPSS</h2>\n<p>Aivika itself also supports a DSL, which is very similar to the popular GPSS\nmodeling language but not fully equivalent, though. This DSL is implemented in\npackage <a href=\"http://hackage.haskell.org/package/aivika-gpss\" rel=\"nofollow\">aivika-gpss</a>.\nThere are plans to add the corresponding support to Aivika Modeler too.\nPlease stay tuned.</p>\n</div>\n<div id=\"website\">\n<h2>Website</h2>\n<p>You can find a more full information on website <a href=\"http://www.aivikasoft.com\" rel=\"nofollow\">www.aivikasoft.com</a>.</p>\n</div>\n\n          </div>"}, "last_serial": 3093368, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "765865622382c017b65be501dc7ebbf3", "sha256": "c145b8b89e5eb7173a65525745491302873f974aa844871a8d9e3228c24356d6"}, "downloads": -1, "filename": "aivika_modeler-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "765865622382c017b65be501dc7ebbf3", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 56964, "upload_time": "2017-08-13T07:47:14", "upload_time_iso_8601": "2017-08-13T07:47:14.294559Z", "url": "https://files.pythonhosted.org/packages/6f/a9/c5a64f768241505bc059484c2cc620616711c4a63b2a3610b2b58e9a6ffa/aivika_modeler-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "970becb47a4ad41f56ee23b3ca91ac6e", "sha256": "e0f480249e30477c92c8294878b72a7f25c3c927e6e0edf1de6f73516425a956"}, "downloads": -1, "filename": "aivika-modeler-1.0.0.tar.gz", "has_sig": false, "md5_digest": "970becb47a4ad41f56ee23b3ca91ac6e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30997, "upload_time": "2017-08-13T07:47:16", "upload_time_iso_8601": "2017-08-13T07:47:16.323815Z", "url": "https://files.pythonhosted.org/packages/ac/61/6230f897fe09db8f2f24c9df4808cb325853a3e5bcf83a0b0eb39c95b7d6/aivika-modeler-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "765865622382c017b65be501dc7ebbf3", "sha256": "c145b8b89e5eb7173a65525745491302873f974aa844871a8d9e3228c24356d6"}, "downloads": -1, "filename": "aivika_modeler-1.0.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "765865622382c017b65be501dc7ebbf3", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 56964, "upload_time": "2017-08-13T07:47:14", "upload_time_iso_8601": "2017-08-13T07:47:14.294559Z", "url": "https://files.pythonhosted.org/packages/6f/a9/c5a64f768241505bc059484c2cc620616711c4a63b2a3610b2b58e9a6ffa/aivika_modeler-1.0.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "970becb47a4ad41f56ee23b3ca91ac6e", "sha256": "e0f480249e30477c92c8294878b72a7f25c3c927e6e0edf1de6f73516425a956"}, "downloads": -1, "filename": "aivika-modeler-1.0.0.tar.gz", "has_sig": false, "md5_digest": "970becb47a4ad41f56ee23b3ca91ac6e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30997, "upload_time": "2017-08-13T07:47:16", "upload_time_iso_8601": "2017-08-13T07:47:16.323815Z", "url": "https://files.pythonhosted.org/packages/ac/61/6230f897fe09db8f2f24c9df4808cb325853a3e5bcf83a0b0eb39c95b7d6/aivika-modeler-1.0.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 16:20:18 2020"}