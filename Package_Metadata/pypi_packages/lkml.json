{"info": {"author": "Josh Temple", "author_email": "", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.7", "Topic :: Software Development"], "description": "[![CircleCI](https://img.shields.io/circleci/build/github/joshtemple/lkml.svg)](https://circleci.com/gh/joshtemple/lkml)\n[![Codecov](https://img.shields.io/codecov/c/github/joshtemple/lkml.svg)](https://codecov.io/gh/joshtemple/lkml)\n[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg)](https://github.com/psf/black)\n\n# lkml\n\nA speedy LookML parser and serializer implemented in pure Python.\n\n`lkml.load` parses LookML strings to Python objects or JSON strings. `lkml.dump` serializes (generates) LookML strings from Python objects.\n\nWhy should you use `lkml`?\n- Tested on **over 160K lines of LookML** from public repositories on GitHub\n- Parses a typical view or model file in < **10 ms** (excludes I/O time)\n- Written in pure, modern Python 3.7 with **no external dependencies**\n- A **full unit test suite** with excellent coverage\n\nInterested in contributing to `lkml`? Check out the [contributor guidelines](CONTRIBUTING.md).\n\n## How do I install it?\n\n`lkml` is available to install on [pip](https://pypi.org/project/lkml/) via the following command:\n\n```\npip install lkml\n```\n\n## How do I run it?\n\nYou can run `lkml` from the command line (parsing only) or import it as a Python package (parsing and serializing).\n\n`lkml` uses a similar interface as the `json` and `yaml` Python packages. The package has two functions:\n - `load`, which accepts a file object and returns a dictionary with the parsed result\n - `dump`, which accepts a Python dictionary and an optional file object to write to. If no file object is provided, `dump` returns the serialized string directly.\n\n### How does `lkml` represent LookML in Python?\n\n`lkml` represents LookML as a nested dictionary structure in Python. Within this documentation, we'll refer to LookML field names (e.g. `sql_table_name`, `view`, `join`) as **keys**.\n\nDuring parsing,\n\n* Blocks with keys like `dimension` and `view` become dictionaries. `lkml` adds a key called `name` if the block has a name (e.g. the name of the dimension or view)\n* Keys with literal values like `hidden: yes` become keys and values `{\"hidden\": \"yes\"}` in their parent dictionaries\n* Lists (e.g. `fields`) become lists in their parent dictionaries\n\nA number of LookML keys can be repeated, like `dimension`, `include`, or `view`. `lkml` collects these **repeated keys** into lists with a pluralized key (e.g. `dimension` becomes `dimensions`).\n\nHere's an example of some LookML that has been parsed into a dictionary. Note that the repeated key `join` has been transformed into a plural key `joins`: a list of dictionaries representing each join.\n\n```python\n{\n  \"connection\": \"connection_name\",\n  \"explores\": [\n    {\n      \"label\": \"Explore\",\n      \"joins\": [\n        {\n          \"relationship\": \"many_to_one\",\n          \"type\": \"inner\",\n          \"sql_on\": \"${view_one.dimension} = ${view_two.dimension}\",\n          \"name\": \"view_two\"\n        },\n        {\n          \"relationship\": \"one_to_many\",\n          \"type\": \"inner\",\n          \"sql_on\": \"${view_one.dimension} = ${view_three.dimension}\",\n          \"name\": \"view_three\"\n        }\n      ],\n      \"name\": \"view_one\"\n    },\n  ]\n}\n```\n\n### Parsing LookML in Python\n\nParsing LookML in Python is simple with `lkml`. Imagine the view below.\n\n```lookml\nview: view_name {\n  sql_table_name: analytics.orders ;;\n\n  dimension: order_id {\n    primary_key: yes\n    type: number\n    sql: ${TABLE}.order_id ;;\n  }\n}\n```\n`lkml.load` accepts a file object or a LookML string and returns the parsed result as a dictionary. Here we pass it a file object.\n```python\nimport lkml\n\nwith open('path/to/file.view.lkml', 'r') as file:\n    parsed = lkml.load(file)\n```\n\n`load`  returns this dictionary.\n\n```python\n{\n  \"views\": [\n    {\n      \"sql_table_name\": \"analytics.orders\",\n      \"dimensions\": [\n        {\n          \"primary_key\": \"yes\",\n          \"type\": \"number\",\n          \"sql\": \"${TABLE}.order_id\",\n          \"name\": \"order_id\",\n        }\n      ],\n      \"name\": \"view_name\"\n    }\n  ]\n}\n```\n\nNotice how the name of the dimension, `order_id`, is preserved in the `name` key of the first element of the list value of `dimensions`. Similarly, the name of the view is also preserved.\n\n\n### Serializing (generating) LookML in Python\n\n`lkml.dump` accepts a Python dictionary representing the LookML that you would like to generate. If you pass a file object as an input argument, it will write the serialized result to that file. If not, it returns a LookML string.\n\n`lkml` does not validate the LookML it generates. `lkml.dump`'s only standard is that the serialized output could be successfully parsed by `lkml.load`. It's entirely possible to generate invalid LookML if the input is malformed. For help representing the input object appropriately, see the section on representing LookML in Python above.\n\n`lkml` descends through the dictionary, writing LookML based on the **keys and values** it finds.\n\n* **If the value is a dictionary**, `lkml` creates a block. Dictionaries can have an optional key called `name` (in this case, the name of this dimension is `price`), as well as a number of key/value pairs. To name a block, include the `name` key in the dictionary to be serialized. Here's an example of a dictionary we might provide to `lkml.dump`.\n\n  ```python\n  {\n    \"dimension\": {\n      \"type\": \"number\",\n      \"label\": \"Unit Price\",\n      \"sql\": \"${TABLE}.price\",\n      \"name\": \"price\"\n    }\n  }\n  ```\n\n  And here's the resulting block of LookML that is generated.\n\n  ```lookml\n  dimension: price {\n    type: number\n    label: \"Unit Price\"\n    sql: ${TABLE}.price ;;\n  }\n  ```\n\n* **If the value is a list**, `lkml` checks the key against a list of known repeatable keys. In the example above, we used a nested dictionary to represent a dimension block. However, LookML allows multiple blocks with the same key (e.g. `dimension`, `view`, `set`, etc.). Since Python dictionaries cannot have duplicate keys, we represent these repeated keys in our dictionary as a single key/value pair, where the key is a pluralized version of the original key (`dimensions` instead of `dimension`), and the value is a list of objects that represent each individual field.\n\n  For example, multiple joins on an explore should be represented as follows.\n\n  ```python\n  \"joins\": [\n    {\n      \"relationship\": \"many_to_one\",\n      \"type\": \"inner\",\n      \"sql_on\": \"${view_one.dimension} = ${view_two.dimension}\",\n      \"name\": \"view_two\"\n    },\n    {\n      \"relationship\": \"one_to_many\",\n      \"type\": \"inner\",\n      \"sql_on\": \"${view_one.dimension} = ${view_three.dimension}\",\n      \"name\": \"view_three\"\n    }\n  ]\n  ```\n\n  If the key is _not_ in the list of known repeated keys, `lkml` creates a list. Here's an example of a list in LookML.\n\n  ```lookml\n  fields: [orders.price, orders.ordered_date, orders.order_id]\n  ```\n\n* **If the value is a string**, `lkml` creates a quoted or unquoted string based on the key. For example, the value for `label` would be quoted, but the value for `hidden` would not. Values with keys like `sql_table_name` or `html` that indicate an expression automatically have a trailing space and `;;` appended.\n\nLet's say we've parsed the example view from **\"Parsing LookML in Python\"** above. We've parsed it into a dictionary and now we want to modify it. We want to change the `type` of the dimension `order_id` from `number` to `string`. Using `lkml`, it's easy to modify the value of `type` in Python and dump it to LookML.\n\nFirst, we'll modify the value of `type` in the parsed dictionary.\n```python\nparsed['views'][0]['dimensions'][0]['type'] = 'string'\n```\n\nNext, we'll dump the dictionary back to LookML in a new file.\n\n```python\nwith open('path/to/new.view.lkml', 'w+') as file:\n    lkml.dump(parsed, file)\n```\n\nHere's the output.\n\n```lookml\nview: {\n  sql_table_name: analytics.orders ;;\n\n  dimension: order_id {\n    primary_key: yes\n    type: string\n    sql: ${TABLE}.order_id ;;\n  }\n}\n```\n\n### Parsing LookML from the command line\n\nAt the command line, `lkml` accepts a single positional argument: the path to the LookML file to parse. It returns the parsed result to `stdout` as a JSON string.\n\nHere's an example.\n\n```bash\nlkml path/to/file.view.lkml\n```\n\nIf you would like to save the result to a file, you can pipe the output as follows.\n\n```bash\nlkml path/to/file.view.lkml > path/to/result.json\n```\n\nWhen running from the command line, pass the debug flag (`-d` or `--debug`) to observe how the parser is attempting to navigate and parse the file.\n\n```bash\nlkml path/to/file.view.lkml --debug\n```\n\nThe debug statements indicate how the parser is descending through the LookML, expecting certain grammar (e.g. `[pair] = key value`), and checking tokens against the expected grammar.\n\n```\nlkml.parser . Try to parse [pair] = key value\nlkml.parser . . Try to parse [key] = literal ':'\nlkml.parser . . . Check LiteralToken(type) == LiteralToken\nlkml.parser . . . Check ValueToken() == ValueToken\nlkml.parser . . Successfully parsed key.\nlkml.parser . . Try to parse [value] = literal / quoted_literal / expression_block\nlkml.parser . . . Check LiteralToken(full_outer) == QuotedLiteralToken or LiteralToken\nlkml.parser . . Successfully parsed value.\nlkml.parser . Successfully parsed pair.\n```\n\n## How does it work?\n\n`lkml` is made up of three components, a [lexer](https://en.wikipedia.org/wiki/Lexical_analysis), a parser, and a serializer. The parser is a [recursive descent parser](https://en.wikipedia.org/wiki/Recursive_descent_parser) with backtracking.\n\nFirst, the lexer scans through the input string character by character and generates a stream of relevant tokens. The lexer skips over whitespace when it's not relevant.\n\nFor example, the input string:\n\n```\n\"sql: ${TABLE}.order_date ;;\"\n```\n\nwould be broken into the tuple of tokens:\n\n ```\n (\n     LiteralToken(sql),\n     ValueToken(),\n     ExpressionBlockToken(${TABLE}.order_date),\n     ExpressionBlockEndToken()\n )\n ```\n\nNext, the parser scans through the stream of tokens. It marks its position in the stream, then attempts to identify a matching rule in the grammar. If the rule is made up of other rules (this is a called a non-terminal), it descends recursively through the constituent rules looking for tokens that match.\n\nIf it doesn't find a match for a rule, it backtracks to a previously marked point in the stream and tries the next available rule. If the parser runs out of rules to try, it raises a syntax error.\n\nAs the parser finds matches, it adds the relevant token values to its syntax tree, which is eventually returned to the user if the input parses successfully.\n\nTo dump LookML to a string, `lkml` calls the serializer, which navigates through the Python dictionary provided, writing out blocks, sets, pairs, keys, and values where needed.\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "https://github.com/joshtemple/lkml/tarball/0.2.2", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/joshtemple/lkml", "keywords": "lookml looker parser", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "lkml", "package_url": "https://pypi.org/project/lkml/", "platform": "", "project_url": "https://pypi.org/project/lkml/", "project_urls": {"Download": "https://github.com/joshtemple/lkml/tarball/0.2.2", "Homepage": "https://github.com/joshtemple/lkml"}, "release_url": "https://pypi.org/project/lkml/0.2.2/", "requires_dist": null, "requires_python": "", "summary": "A speedy LookML parser implemented in pure Python.", "version": "0.2.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://circleci.com/gh/joshtemple/lkml\" rel=\"nofollow\"><img alt=\"CircleCI\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/1b2fe6e092abee5ee39e5113a03015bfadd83e10/68747470733a2f2f696d672e736869656c64732e696f2f636972636c6563692f6275696c642f6769746875622f6a6f736874656d706c652f6c6b6d6c2e737667\"></a>\n<a href=\"https://codecov.io/gh/joshtemple/lkml\" rel=\"nofollow\"><img alt=\"Codecov\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/f9798cfc2d712e9d6c23869c67c0c2bbcc9e7715/68747470733a2f2f696d672e736869656c64732e696f2f636f6465636f762f632f6769746875622f6a6f736874656d706c652f6c6b6d6c2e737667\"></a>\n<a href=\"https://github.com/psf/black\" rel=\"nofollow\"><img alt=\"Code style: black\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fbfdc7754183ecf079bc71ddeabaf88f6cbc5c00/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e737667\"></a></p>\n<h1>lkml</h1>\n<p>A speedy LookML parser and serializer implemented in pure Python.</p>\n<p><code>lkml.load</code> parses LookML strings to Python objects or JSON strings. <code>lkml.dump</code> serializes (generates) LookML strings from Python objects.</p>\n<p>Why should you use <code>lkml</code>?</p>\n<ul>\n<li>Tested on <strong>over 160K lines of LookML</strong> from public repositories on GitHub</li>\n<li>Parses a typical view or model file in &lt; <strong>10 ms</strong> (excludes I/O time)</li>\n<li>Written in pure, modern Python 3.7 with <strong>no external dependencies</strong></li>\n<li>A <strong>full unit test suite</strong> with excellent coverage</li>\n</ul>\n<p>Interested in contributing to <code>lkml</code>? Check out the <a href=\"CONTRIBUTING.md\" rel=\"nofollow\">contributor guidelines</a>.</p>\n<h2>How do I install it?</h2>\n<p><code>lkml</code> is available to install on <a href=\"https://pypi.org/project/lkml/\" rel=\"nofollow\">pip</a> via the following command:</p>\n<pre><code>pip install lkml\n</code></pre>\n<h2>How do I run it?</h2>\n<p>You can run <code>lkml</code> from the command line (parsing only) or import it as a Python package (parsing and serializing).</p>\n<p><code>lkml</code> uses a similar interface as the <code>json</code> and <code>yaml</code> Python packages. The package has two functions:</p>\n<ul>\n<li><code>load</code>, which accepts a file object and returns a dictionary with the parsed result</li>\n<li><code>dump</code>, which accepts a Python dictionary and an optional file object to write to. If no file object is provided, <code>dump</code> returns the serialized string directly.</li>\n</ul>\n<h3>How does <code>lkml</code> represent LookML in Python?</h3>\n<p><code>lkml</code> represents LookML as a nested dictionary structure in Python. Within this documentation, we'll refer to LookML field names (e.g. <code>sql_table_name</code>, <code>view</code>, <code>join</code>) as <strong>keys</strong>.</p>\n<p>During parsing,</p>\n<ul>\n<li>Blocks with keys like <code>dimension</code> and <code>view</code> become dictionaries. <code>lkml</code> adds a key called <code>name</code> if the block has a name (e.g. the name of the dimension or view)</li>\n<li>Keys with literal values like <code>hidden: yes</code> become keys and values <code>{\"hidden\": \"yes\"}</code> in their parent dictionaries</li>\n<li>Lists (e.g. <code>fields</code>) become lists in their parent dictionaries</li>\n</ul>\n<p>A number of LookML keys can be repeated, like <code>dimension</code>, <code>include</code>, or <code>view</code>. <code>lkml</code> collects these <strong>repeated keys</strong> into lists with a pluralized key (e.g. <code>dimension</code> becomes <code>dimensions</code>).</p>\n<p>Here's an example of some LookML that has been parsed into a dictionary. Note that the repeated key <code>join</code> has been transformed into a plural key <code>joins</code>: a list of dictionaries representing each join.</p>\n<pre><span class=\"p\">{</span>\n  <span class=\"s2\">\"connection\"</span><span class=\"p\">:</span> <span class=\"s2\">\"connection_name\"</span><span class=\"p\">,</span>\n  <span class=\"s2\">\"explores\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n    <span class=\"p\">{</span>\n      <span class=\"s2\">\"label\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Explore\"</span><span class=\"p\">,</span>\n      <span class=\"s2\">\"joins\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n        <span class=\"p\">{</span>\n          <span class=\"s2\">\"relationship\"</span><span class=\"p\">:</span> <span class=\"s2\">\"many_to_one\"</span><span class=\"p\">,</span>\n          <span class=\"s2\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"inner\"</span><span class=\"p\">,</span>\n          <span class=\"s2\">\"sql_on\"</span><span class=\"p\">:</span> <span class=\"s2\">\"$</span><span class=\"si\">{view_one.dimension}</span><span class=\"s2\"> = $</span><span class=\"si\">{view_two.dimension}</span><span class=\"s2\">\"</span><span class=\"p\">,</span>\n          <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"view_two\"</span>\n        <span class=\"p\">},</span>\n        <span class=\"p\">{</span>\n          <span class=\"s2\">\"relationship\"</span><span class=\"p\">:</span> <span class=\"s2\">\"one_to_many\"</span><span class=\"p\">,</span>\n          <span class=\"s2\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"inner\"</span><span class=\"p\">,</span>\n          <span class=\"s2\">\"sql_on\"</span><span class=\"p\">:</span> <span class=\"s2\">\"$</span><span class=\"si\">{view_one.dimension}</span><span class=\"s2\"> = $</span><span class=\"si\">{view_three.dimension}</span><span class=\"s2\">\"</span><span class=\"p\">,</span>\n          <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"view_three\"</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">],</span>\n      <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"view_one\"</span>\n    <span class=\"p\">},</span>\n  <span class=\"p\">]</span>\n<span class=\"p\">}</span>\n</pre>\n<h3>Parsing LookML in Python</h3>\n<p>Parsing LookML in Python is simple with <code>lkml</code>. Imagine the view below.</p>\n<pre>view: view_name {\n  sql_table_name: analytics.orders ;;\n\n  dimension: order_id {\n    primary_key: yes\n    type: number\n    sql: ${TABLE}.order_id ;;\n  }\n}\n</pre>\n<p><code>lkml.load</code> accepts a file object or a LookML string and returns the parsed result as a dictionary. Here we pass it a file object.</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">lkml</span>\n\n<span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'path/to/file.view.lkml'</span><span class=\"p\">,</span> <span class=\"s1\">'r'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">file</span><span class=\"p\">:</span>\n    <span class=\"n\">parsed</span> <span class=\"o\">=</span> <span class=\"n\">lkml</span><span class=\"o\">.</span><span class=\"n\">load</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">)</span>\n</pre>\n<p><code>load</code>  returns this dictionary.</p>\n<pre><span class=\"p\">{</span>\n  <span class=\"s2\">\"views\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n    <span class=\"p\">{</span>\n      <span class=\"s2\">\"sql_table_name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"analytics.orders\"</span><span class=\"p\">,</span>\n      <span class=\"s2\">\"dimensions\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n        <span class=\"p\">{</span>\n          <span class=\"s2\">\"primary_key\"</span><span class=\"p\">:</span> <span class=\"s2\">\"yes\"</span><span class=\"p\">,</span>\n          <span class=\"s2\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"number\"</span><span class=\"p\">,</span>\n          <span class=\"s2\">\"sql\"</span><span class=\"p\">:</span> <span class=\"s2\">\"$</span><span class=\"si\">{TABLE}</span><span class=\"s2\">.order_id\"</span><span class=\"p\">,</span>\n          <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"order_id\"</span><span class=\"p\">,</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">],</span>\n      <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"view_name\"</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">]</span>\n<span class=\"p\">}</span>\n</pre>\n<p>Notice how the name of the dimension, <code>order_id</code>, is preserved in the <code>name</code> key of the first element of the list value of <code>dimensions</code>. Similarly, the name of the view is also preserved.</p>\n<h3>Serializing (generating) LookML in Python</h3>\n<p><code>lkml.dump</code> accepts a Python dictionary representing the LookML that you would like to generate. If you pass a file object as an input argument, it will write the serialized result to that file. If not, it returns a LookML string.</p>\n<p><code>lkml</code> does not validate the LookML it generates. <code>lkml.dump</code>'s only standard is that the serialized output could be successfully parsed by <code>lkml.load</code>. It's entirely possible to generate invalid LookML if the input is malformed. For help representing the input object appropriately, see the section on representing LookML in Python above.</p>\n<p><code>lkml</code> descends through the dictionary, writing LookML based on the <strong>keys and values</strong> it finds.</p>\n<ul>\n<li>\n<p><strong>If the value is a dictionary</strong>, <code>lkml</code> creates a block. Dictionaries can have an optional key called <code>name</code> (in this case, the name of this dimension is <code>price</code>), as well as a number of key/value pairs. To name a block, include the <code>name</code> key in the dictionary to be serialized. Here's an example of a dictionary we might provide to <code>lkml.dump</code>.</p>\n<pre><span class=\"p\">{</span>\n  <span class=\"s2\">\"dimension\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"number\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"label\"</span><span class=\"p\">:</span> <span class=\"s2\">\"Unit Price\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"sql\"</span><span class=\"p\">:</span> <span class=\"s2\">\"$</span><span class=\"si\">{TABLE}</span><span class=\"s2\">.price\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"price\"</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</pre>\n<p>And here's the resulting block of LookML that is generated.</p>\n<pre>dimension: price {\n  type: number\n  label: \"Unit Price\"\n  sql: ${TABLE}.price ;;\n}\n</pre>\n</li>\n<li>\n<p><strong>If the value is a list</strong>, <code>lkml</code> checks the key against a list of known repeatable keys. In the example above, we used a nested dictionary to represent a dimension block. However, LookML allows multiple blocks with the same key (e.g. <code>dimension</code>, <code>view</code>, <code>set</code>, etc.). Since Python dictionaries cannot have duplicate keys, we represent these repeated keys in our dictionary as a single key/value pair, where the key is a pluralized version of the original key (<code>dimensions</code> instead of <code>dimension</code>), and the value is a list of objects that represent each individual field.</p>\n<p>For example, multiple joins on an explore should be represented as follows.</p>\n<pre><span class=\"s2\">\"joins\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n  <span class=\"p\">{</span>\n    <span class=\"s2\">\"relationship\"</span><span class=\"p\">:</span> <span class=\"s2\">\"many_to_one\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"inner\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"sql_on\"</span><span class=\"p\">:</span> <span class=\"s2\">\"$</span><span class=\"si\">{view_one.dimension}</span><span class=\"s2\"> = $</span><span class=\"si\">{view_two.dimension}</span><span class=\"s2\">\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"view_two\"</span>\n  <span class=\"p\">},</span>\n  <span class=\"p\">{</span>\n    <span class=\"s2\">\"relationship\"</span><span class=\"p\">:</span> <span class=\"s2\">\"one_to_many\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"type\"</span><span class=\"p\">:</span> <span class=\"s2\">\"inner\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"sql_on\"</span><span class=\"p\">:</span> <span class=\"s2\">\"$</span><span class=\"si\">{view_one.dimension}</span><span class=\"s2\"> = $</span><span class=\"si\">{view_three.dimension}</span><span class=\"s2\">\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"view_three\"</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">]</span>\n</pre>\n<p>If the key is <em>not</em> in the list of known repeated keys, <code>lkml</code> creates a list. Here's an example of a list in LookML.</p>\n<pre>fields: [orders.price, orders.ordered_date, orders.order_id]\n</pre>\n</li>\n<li>\n<p><strong>If the value is a string</strong>, <code>lkml</code> creates a quoted or unquoted string based on the key. For example, the value for <code>label</code> would be quoted, but the value for <code>hidden</code> would not. Values with keys like <code>sql_table_name</code> or <code>html</code> that indicate an expression automatically have a trailing space and <code>;;</code> appended.</p>\n</li>\n</ul>\n<p>Let's say we've parsed the example view from <strong>\"Parsing LookML in Python\"</strong> above. We've parsed it into a dictionary and now we want to modify it. We want to change the <code>type</code> of the dimension <code>order_id</code> from <code>number</code> to <code>string</code>. Using <code>lkml</code>, it's easy to modify the value of <code>type</code> in Python and dump it to LookML.</p>\n<p>First, we'll modify the value of <code>type</code> in the parsed dictionary.</p>\n<pre><span class=\"n\">parsed</span><span class=\"p\">[</span><span class=\"s1\">'views'</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"s1\">'dimensions'</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"s1\">'type'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">'string'</span>\n</pre>\n<p>Next, we'll dump the dictionary back to LookML in a new file.</p>\n<pre><span class=\"k\">with</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"s1\">'path/to/new.view.lkml'</span><span class=\"p\">,</span> <span class=\"s1\">'w+'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">file</span><span class=\"p\">:</span>\n    <span class=\"n\">lkml</span><span class=\"o\">.</span><span class=\"n\">dump</span><span class=\"p\">(</span><span class=\"n\">parsed</span><span class=\"p\">,</span> <span class=\"n\">file</span><span class=\"p\">)</span>\n</pre>\n<p>Here's the output.</p>\n<pre>view: {\n  sql_table_name: analytics.orders ;;\n\n  dimension: order_id {\n    primary_key: yes\n    type: string\n    sql: ${TABLE}.order_id ;;\n  }\n}\n</pre>\n<h3>Parsing LookML from the command line</h3>\n<p>At the command line, <code>lkml</code> accepts a single positional argument: the path to the LookML file to parse. It returns the parsed result to <code>stdout</code> as a JSON string.</p>\n<p>Here's an example.</p>\n<pre>lkml path/to/file.view.lkml\n</pre>\n<p>If you would like to save the result to a file, you can pipe the output as follows.</p>\n<pre>lkml path/to/file.view.lkml &gt; path/to/result.json\n</pre>\n<p>When running from the command line, pass the debug flag (<code>-d</code> or <code>--debug</code>) to observe how the parser is attempting to navigate and parse the file.</p>\n<pre>lkml path/to/file.view.lkml --debug\n</pre>\n<p>The debug statements indicate how the parser is descending through the LookML, expecting certain grammar (e.g. <code>[pair] = key value</code>), and checking tokens against the expected grammar.</p>\n<pre><code>lkml.parser . Try to parse [pair] = key value\nlkml.parser . . Try to parse [key] = literal ':'\nlkml.parser . . . Check LiteralToken(type) == LiteralToken\nlkml.parser . . . Check ValueToken() == ValueToken\nlkml.parser . . Successfully parsed key.\nlkml.parser . . Try to parse [value] = literal / quoted_literal / expression_block\nlkml.parser . . . Check LiteralToken(full_outer) == QuotedLiteralToken or LiteralToken\nlkml.parser . . Successfully parsed value.\nlkml.parser . Successfully parsed pair.\n</code></pre>\n<h2>How does it work?</h2>\n<p><code>lkml</code> is made up of three components, a <a href=\"https://en.wikipedia.org/wiki/Lexical_analysis\" rel=\"nofollow\">lexer</a>, a parser, and a serializer. The parser is a <a href=\"https://en.wikipedia.org/wiki/Recursive_descent_parser\" rel=\"nofollow\">recursive descent parser</a> with backtracking.</p>\n<p>First, the lexer scans through the input string character by character and generates a stream of relevant tokens. The lexer skips over whitespace when it's not relevant.</p>\n<p>For example, the input string:</p>\n<pre><code>\"sql: ${TABLE}.order_date ;;\"\n</code></pre>\n<p>would be broken into the tuple of tokens:</p>\n<pre><code>(\n    LiteralToken(sql),\n    ValueToken(),\n    ExpressionBlockToken(${TABLE}.order_date),\n    ExpressionBlockEndToken()\n)\n</code></pre>\n<p>Next, the parser scans through the stream of tokens. It marks its position in the stream, then attempts to identify a matching rule in the grammar. If the rule is made up of other rules (this is a called a non-terminal), it descends recursively through the constituent rules looking for tokens that match.</p>\n<p>If it doesn't find a match for a rule, it backtracks to a previously marked point in the stream and tries the next available rule. If the parser runs out of rules to try, it raises a syntax error.</p>\n<p>As the parser finds matches, it adds the relevant token values to its syntax tree, which is eventually returned to the user if the input parses successfully.</p>\n<p>To dump LookML to a string, <code>lkml</code> calls the serializer, which navigates through the Python dictionary provided, writing out blocks, sets, pairs, keys, and values where needed.</p>\n\n          </div>"}, "last_serial": 6024178, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "1cbb708aa03156d5aeaa94df4efbf415", "sha256": "c85933d24c1350426575ad6d92b8f18bb93f053d57e57b3a819f3b4492a4836b"}, "downloads": -1, "filename": "lkml-0.0.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "1cbb708aa03156d5aeaa94df4efbf415", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8766, "upload_time": "2019-06-26T16:21:08", "upload_time_iso_8601": "2019-06-26T16:21:08.307199Z", "url": "https://files.pythonhosted.org/packages/8b/77/aa1ddbe7b63ea61e581b0185bfef0dc193bf4c350803cd197cebd46d7820/lkml-0.0.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "51712c33fbc5e5cab71efd7e179ae48f", "sha256": "f9a387b962a32a4a5384b914102d3b3f351e3e15894f1ad318949b8f5671c345"}, "downloads": -1, "filename": "lkml-0.0.1.tar.gz", "has_sig": false, "md5_digest": "51712c33fbc5e5cab71efd7e179ae48f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8090, "upload_time": "2019-06-26T16:21:10", "upload_time_iso_8601": "2019-06-26T16:21:10.710704Z", "url": "https://files.pythonhosted.org/packages/ae/39/ef333f773d895078b15b690c0b7f78f74ab0fa4a3ad8083706e9aa765619/lkml-0.0.1.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "846cb1ee83f67575bb266eaf13998528", "sha256": "e0361304a82222b7c3cb9aedea233bf1bc0150d9870e7d2333b897816c641e5b"}, "downloads": -1, "filename": "lkml-0.1.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "846cb1ee83f67575bb266eaf13998528", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 8886, "upload_time": "2019-06-27T19:11:27", "upload_time_iso_8601": "2019-06-27T19:11:27.864428Z", "url": "https://files.pythonhosted.org/packages/a9/41/abc760ad864c3d396b77798b838d3f337ce27520c62f0699b562523c4224/lkml-0.1.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "27c9da5a8470d192c0c3d27eb48d2c19", "sha256": "b8c07f9d63033937d07041416b538a45cd3f62466cc6545e46e30f20527070f2"}, "downloads": -1, "filename": "lkml-0.1.0.tar.gz", "has_sig": false, "md5_digest": "27c9da5a8470d192c0c3d27eb48d2c19", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8093, "upload_time": "2019-06-27T19:11:29", "upload_time_iso_8601": "2019-06-27T19:11:29.299856Z", "url": "https://files.pythonhosted.org/packages/bb/23/b9b291b551d2c5e13615f6e37ea1e7a2f8923207ba63a11c861d1eb4a3eb/lkml-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "fd6213f8960a27c9bd7683abaee828b9", "sha256": "deeb162b7e72b309211d612bf5cf387f209d7a06100aadc7f54aac463b84cdaa"}, "downloads": -1, "filename": "lkml-0.1.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "fd6213f8960a27c9bd7683abaee828b9", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 9005, "upload_time": "2019-07-08T18:45:16", "upload_time_iso_8601": "2019-07-08T18:45:16.004405Z", "url": "https://files.pythonhosted.org/packages/a2/5a/43768f31b4ebe4181e63f51e9bef1c2a680971a4fbc51d7bf3bd4aafb548/lkml-0.1.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "2f9a655cf6a8d3093fc449fbb6546daf", "sha256": "1d44fa47611fc40ccebfdf10fa7971f8ace0eda00788101c1c22d035ed8f4b76"}, "downloads": -1, "filename": "lkml-0.1.1.tar.gz", "has_sig": false, "md5_digest": "2f9a655cf6a8d3093fc449fbb6546daf", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8240, "upload_time": "2019-07-08T18:45:17", "upload_time_iso_8601": "2019-07-08T18:45:17.679905Z", "url": "https://files.pythonhosted.org/packages/65/56/57e9e0ba5606839ff068f1ccd531d36d41e11d943516b3819846077c68f1/lkml-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "53e41b04740760563a87085278926518", "sha256": "c92c823eb91fd2352e7d981f72c000a671c94129457bae28a85bbc8188fdd245"}, "downloads": -1, "filename": "lkml-0.1.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "53e41b04740760563a87085278926518", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 9168, "upload_time": "2019-07-26T14:59:29", "upload_time_iso_8601": "2019-07-26T14:59:29.783218Z", "url": "https://files.pythonhosted.org/packages/74/5c/1d08053cf0a7df7d3d8fe86ad9a11fcdf6de4780a16656b0429ab07eb214/lkml-0.1.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "f55bea4bfdbd2300c90b9ffb17edda51", "sha256": "e9ebb85b08596c6e80fa1a2df4ec9f541eac1b94efd74deb9945dc08e0884028"}, "downloads": -1, "filename": "lkml-0.1.2.tar.gz", "has_sig": false, "md5_digest": "f55bea4bfdbd2300c90b9ffb17edda51", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8381, "upload_time": "2019-07-26T14:59:30", "upload_time_iso_8601": "2019-07-26T14:59:30.993481Z", "url": "https://files.pythonhosted.org/packages/2a/db/b8096dc68a5fa28e899b144c0c0c3738457fc1c76bf4b011d265fa3cc0a5/lkml-0.1.2.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "83d3b8c624235a0529bf125172c3f7fd", "sha256": "6cc609fa672bef2ec745906452b804d4e457f4f2fe4281cb1616226c5a20baea"}, "downloads": -1, "filename": "lkml-0.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "83d3b8c624235a0529bf125172c3f7fd", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 17758, "upload_time": "2019-08-16T14:42:48", "upload_time_iso_8601": "2019-08-16T14:42:48.524396Z", "url": "https://files.pythonhosted.org/packages/3e/37/3172a7f49969728bb2f17492788492d1b65735bd97cd78e8326747a847e3/lkml-0.2.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3c95f49a3a4700bbdcd5dab4abb4f378", "sha256": "00c63a4bd7849c78ef1f2f35e36f6994c97cfd75bbb483b6101ed8e7ac835ae9"}, "downloads": -1, "filename": "lkml-0.2.0.tar.gz", "has_sig": false, "md5_digest": "3c95f49a3a4700bbdcd5dab4abb4f378", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19374, "upload_time": "2019-08-16T14:42:50", "upload_time_iso_8601": "2019-08-16T14:42:50.076466Z", "url": "https://files.pythonhosted.org/packages/54/f3/6af5ad1f211e069ccd824802a2fc6bd9c73df82bd62d41a2178525784693/lkml-0.2.0.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "0eeb2a8c09b61a4105203514a5f4052f", "sha256": "5a38b9c337e08893847b8fffc34040f2865bf510571726fe2b2f655b37a88437"}, "downloads": -1, "filename": "lkml-0.2.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "0eeb2a8c09b61a4105203514a5f4052f", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 17762, "upload_time": "2019-10-15T22:07:17", "upload_time_iso_8601": "2019-10-15T22:07:17.658785Z", "url": "https://files.pythonhosted.org/packages/91/73/5239e3a358ed2c27f8a30f40661a4dccdac8097e323f89a3b7c18ae8b036/lkml-0.2.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dcfc092df615f049553f321fd5e857fb", "sha256": "13d9ed08965d3606d79a000e9e7b12e2cf2c6555c93962a0db88715c28ac0552"}, "downloads": -1, "filename": "lkml-0.2.1.tar.gz", "has_sig": false, "md5_digest": "dcfc092df615f049553f321fd5e857fb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19394, "upload_time": "2019-10-15T22:07:19", "upload_time_iso_8601": "2019-10-15T22:07:19.422864Z", "url": "https://files.pythonhosted.org/packages/23/9c/2404876615971ce1ba85c624d5a1fbc19cd4fd422f5026835c405089b23e/lkml-0.2.1.tar.gz", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "cbcd7bcb277e008f53036715266ac4e9", "sha256": "c78b4fa12393cc227ce12a1b75fd99b14a16fb0f183fc90bdab9b0a3cc577616"}, "downloads": -1, "filename": "lkml-0.2.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "cbcd7bcb277e008f53036715266ac4e9", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 17778, "upload_time": "2019-10-24T14:29:05", "upload_time_iso_8601": "2019-10-24T14:29:05.848686Z", "url": "https://files.pythonhosted.org/packages/e9/58/773a8fcfaa4571fb76af20520f879f1a562bc0316387a5779ea76dbf2784/lkml-0.2.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9f4dc510364a9a9e4fc07dff5be0e70d", "sha256": "87c8d632c932010397aa197a70d5fd49d587fcf11db829662e7457c40c1a09f1"}, "downloads": -1, "filename": "lkml-0.2.2.tar.gz", "has_sig": false, "md5_digest": "9f4dc510364a9a9e4fc07dff5be0e70d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19403, "upload_time": "2019-10-24T14:29:17", "upload_time_iso_8601": "2019-10-24T14:29:17.280796Z", "url": "https://files.pythonhosted.org/packages/35/5a/abb99cf1e5ea4c130c039a9b6cc39004a84d7a52f8fdacdc88272b3ea2b9/lkml-0.2.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "cbcd7bcb277e008f53036715266ac4e9", "sha256": "c78b4fa12393cc227ce12a1b75fd99b14a16fb0f183fc90bdab9b0a3cc577616"}, "downloads": -1, "filename": "lkml-0.2.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "cbcd7bcb277e008f53036715266ac4e9", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 17778, "upload_time": "2019-10-24T14:29:05", "upload_time_iso_8601": "2019-10-24T14:29:05.848686Z", "url": "https://files.pythonhosted.org/packages/e9/58/773a8fcfaa4571fb76af20520f879f1a562bc0316387a5779ea76dbf2784/lkml-0.2.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "9f4dc510364a9a9e4fc07dff5be0e70d", "sha256": "87c8d632c932010397aa197a70d5fd49d587fcf11db829662e7457c40c1a09f1"}, "downloads": -1, "filename": "lkml-0.2.2.tar.gz", "has_sig": false, "md5_digest": "9f4dc510364a9a9e4fc07dff5be0e70d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19403, "upload_time": "2019-10-24T14:29:17", "upload_time_iso_8601": "2019-10-24T14:29:17.280796Z", "url": "https://files.pythonhosted.org/packages/35/5a/abb99cf1e5ea4c130c039a9b6cc39004a84d7a52f8fdacdc88272b3ea2b9/lkml-0.2.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:44:57 2020"}