{"info": {"author": "Yann Bouyeron", "author_email": "yann.bouyeron@hotmail.fr", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Intended Audience :: Developers", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7", "Topic :: Software Development :: Build Tools"], "description": "# Genopy\n\n\nAnalyses g\u00e9n\u00e9tiques et phylog\u00e9n\u00e9tiques pour les SVT\n\n\n## Sommaire:\n\n[Installation](#installgenopy)\n\n[Cr\u00e9er des s\u00e9quences](#creatseq)\n\n[Cr\u00e9er des fichiers fasta](#creatfasta)\n\n[Convertir des fichiers .edi (anagene) en fichiers fasta](#convedi)\n\n[Rechercher et afficher des s\u00e9quences](#openseq)\n\n[Transcrire](#transc)\n\n[Traduire](#transl)\n\n[R\u00e9tro-Transcrire](#rt)\n\n[Afficher les tables du code g\u00e9n\u00e9tique](#tablecode)\n\n[Comparer des s\u00e9quences: alignement par paires](#needlewater)\n\n[Comparer des s\u00e9quences: alignement multiple (clustal)](#clustal)\n\n[Afficher et sauvegarder une matrice de distances](#matrix)\n\n[Tracer un arbre phylog\u00e9n\u00e9tique \u00e0 partir d'une matrice de distances](#phylomatrix)\n\n[Tracer un arbre phylog\u00e9n\u00e9tique \u00e0 partir d'une liste de s\u00e9quences](#phyloseq)\n\n\n\n\n## Installation\n\n<a name =\"installgenopy\"></a>\n\n\n### Installation des d\u00e9pendances.\n\nGenopy requiert python >= 3.4 et des d\u00e9pendances python qui ne sont pas pr\u00e9sentes dans la librairie standard (numpy, biopython, pandas, matplotlib, seaborn, ipfshttpclient) et des d\u00e9pendances non python (Clustalw, Emboss, Rebase, Phylip).\n\n#### Installation des d\u00e9pendances Python.\n\n\tsudo pip install numpy biopython pandas matplotlib seaborn ipfshttpclient\n\nSi vous avez plusieurs versions de python et que vous souhaitez installer Genopy pour la version de python 3.6 (par exemple):\n\n\tsudo python3.6 -m pip install numpy biopython pandas matplotlib seaborn ipfshttpclient\n\n#### Installation de Clustalw\n\n[http://www.clustal.org/clustal2/](http://www.clustal.org/clustal2/)\n\nSur Debian:\n\n\tsudo apt-get install clustalw\n\n#### Installation de Emboss\n\n[http://emboss.sourceforge.net/download/](http://emboss.sourceforge.net/download/)\n\nSur Debian:\n\n\tsudo apt-get install emboss\n\n\n#### Installation rebase pour emboss. (Facultatif)\n\nRebase permet  d\u2019utiliser certaines fonctions li\u00e9es aux enzymes de restriction; il s'agit notamment des fonctions restrict et remap.\n\n1: placez vous dans le r\u00e9pertoire de rebase\n\n\tcd /usr/share/EMBOSS/data/REBASE\n\n2: t\u00e9l\u00e9charger les fichiers withrefm et proto depuis le serveur ftp de rebase\n\n\tsudo wget ftp://ftp.ebi.ac.uk/pub/databases/rebase/withrefm*\n\nPuis \n\n\tsudo wget ftp://ftp.ebi.ac.uk/pub/databases/rebase/proto*\n\n3: d\u00e9compresser \n\n\tsudo uncompress withrefm.707.gz\n\nEt \n\n\tsudo uncompress proto.707.gz\n\nVous n'aurez pas forc\u00e9ment le version 707.... c'est \u00e0 adapter\n\n4: extraire rebase\n\n\trebaseextract\n\nEt voil\u00e0... c'est termin\u00e9.\n\n#### Installation de Phylip\n\n[http://evolution.genetics.washington.edu/phylip/install.html](http://evolution.genetics.washington.edu/phylip/install.html)\n\n\nSur Debian:\n\n\tsudo apt-get install phylip\n\n### Installation de genopy\n\n#### Avec pip:\n\n    sudo pip install genopy\n\nOu, pour une version donn\u00e9e de python (exemple 3.6):\n\n    sudo python3.6 -m pip install genopy\n\n\n#### Depuis github:\n\n\tgit clone https://github.com/YannBouyeron/genopy\n\n\tcd genopy\n\n\tsudo python setup.py install\n\n\n## Licence\n\nCe code est sous licence <a href=\"http://www.gnu.org/licenses\">GPL3</a>\n\n\n## Exemple\n\n\n\t>>> import genopy as gp\n\t>>>\n\t>>> list_seq = gp.search(\"primates\")\n\n\n\t>>> list_seq\n\t[SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCA...CAT', SingleLetterAlphabet()), id='Refhumaine.adn', name='Refhumaine.adn', description=' Refhumaine.adn', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGTACCGACCCATTTCCAG...GGA', SingleLetterAlphabet()), id='Orangoutan.adn', name='Orangoutan.adn', description='Orangoutan.adn  ORANG-OUTAN', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAAATTTAAGTGCCACCCAAGTATTGGCTCATTCACTA...ACG', SingleLetterAlphabet()), id='Bonobo.adn', name='Bonobo.adn', description='Bonobo.adn  BONOBO', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGAGACAAATTTGGGTGCCACCCAAGTATTAGCTAACCCACCA...CCC', SingleLetterAlphabet()), id='G\u0001orille.adn', name='Gorille.adn', description='Gorille.adn  GORILLE', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAAATTTAAGTACCACCTAAGTATTGGCCTATTCATTA...CAC', SingleLetterAlphabet()), id='Pan_AJ586556.adn', name='Pan_AJ586556.adn', description='Pan_AJ586556.adn  AJ586556-PAN', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAAATTTAAGTACCACCTAAGTACTGGCTCATTCATTA...CGG', SingleLetterAlphabet()), id='Pan_AJ586557.adn', name='Pan_AJ586557.adn', description='Pan_AJ586557.adn  AJ586557-PAN', dbxrefs=[]), SeqRecord(seq=Seq('TTCTATAGGGGGGAAAGAACTCAAAGAACAACCTAAGTACTAACTTAATCTCCC...AGT', SingleLetterAlphabet()), id='Colobe.adn', name='Colobe.adn', description='Colobe.adn  COLOBE', dbxrefs=[])]\n\t>>> \n\n\n\t>>> list_seq[1]\n\tSeqRecord(seq=Seq('TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGTACCGACCCATTTCCAG...GGA', SingleLetterAlphabet()), id='Orangoutan.adn', name='Orangoutan.adn', description='Orangoutan.adn  ORANG-OUTAN', dbxrefs=[])\n\t>>> \n\t>>> for i in list_seq:\n\t...     print(i.name)\n\t... \n\tRefhumaine.adn\n\tOrangoutan.adn\n\tBonobo.adn\n\tGorille.adn\n\tPan_AJ586556.adn\n\tPan_AJ586557.adn\n\tColobe.adn\n\t>>> \n\n\n\n\t>>> list_seq[1].name\n\t'Orangoutan.adn'\n\t>>> \n\n\t>>> gp.show(list_seq[1])\n\n\n          TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGTACCGACCCATTTCCAGCGGCCT\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   10        20        30        40        50        60\n\n          ATGTATTTCGTACATTCCTGCCAGCCAACATGAATATCACCCAACACAACAATCGCTTAA\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   70        80        90        100       110       120\n\n          CCACCTATAACACATACAAAGCCCAATCCACACCCAACCTCCACCCCCCGCTTACAAGCA\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   130       140       150       160       170       180\n\n          AGTACCCCCCCATGCCCCCCCACCCAAACACATACATCGATTCCCCCACATAACCCCTTC\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   190       200       210       220       230       240\n\n          CCCCCCCGCATACCAACCAACCCAATCAAGCTTTAAAGTACATAGCACATAACACCCCTA\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   250       260       270       280       290       300\n\n          CCGTACATAGCACATTTCTACTAACTCCCTGCTTAACCCTACGGA\n          ----:----|----:----|----:----|----:----|----:\n                   310       320       330       340\n\n\n\n\n\t>>> c = gp.clustal(*list_seq[1:5])\n\t>>> \n\t>>> gp.showgenix(c)\n\n\n    \t                *************   ** ****  ** *****  ****    *  *      *      \n\tBonobo.adn              TTCTTTCATGGGGAAGCAAATTTAAGTGCCACCCAAGTATTGGCTCATTCACTA-TAACC\n\tPan_AJ586556.adn        TTCTTTCATGGGGAAGCAAATTTAAGTACCACCTAAGTATTGGCCTATTCATTA-CAACC\n\tGorille.adn             TTCTTTCATGGGGAGACAAATTTGGGTGCCACCCAAGTATTAGCTAACCCACCAACAATT\n\tOrangoutan.adn          TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGTACCGACCCATTT-CCAGCGGCC\n\n    \t                ----:----|----:----|----:----|----:----|----:----|----:----|\n        \t                         10        20        30        40        50        60\n\n\n\n\t...\n\t...\n\n\n\n\t>>> m = gp.matrix(c)\n\n\t>>> print(m)\n\tBonobo.adn       0\n\tPan_AJ586556.adn 0.13276836158192096    0\n\tGorille.adn      0.25988700564971756    0.2542372881355932    0\n\tOrangoutan.adn   0.3220338983050848     0.3220338983050848    0.36723163841807904     0\n       \t         Bonobo.adn             Pan_AJ586556.adn      Gorille.adn             Orangoutan.adn\n\n\n\t>>> tree = gp.tree_nj(m)\n\n\n\t  _______________ Bonobo.adn\n\t |\n\t_|______________ Pan_AJ586556.adn\n\t |\n\t |         ___________________________________________________ Orangoutan.adn\n\t |________|\n\t          |___________________________________ Gorille.adn\n\n\n## Tutoriel\n\n<a name=\"creatseq\"></a>\n\n### Cr\u00e9er des s\u00e9quences\n\nLe module genopy d\u00e9pend de biopython, on peut cr\u00e9er des sequences sous deux types d'objets diff\u00e9rents: les objets Seq et SeqRecord. \n\nCr\u00e9er un objet Seq\n\n    >>> from genopy import *\n\n    >>> s1 = Seq(\"ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGCATAGCATCGATGTAGCTTAGCCGT\") \n    >>> s1\n    Seq('ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGCATAGCATCGATGTAGCT...CGT')\n\nLa fonction toSeq de genopy permet de cr\u00e9er plus facilement des objets Seq. Elle ajoute automatiquement le type.\n\n    >>> s2 = toSeq(\"ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGAATAGCATCGATGTAGCTTACCCGT\")\n    >>> s2\n    Seq('ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGAATAGCATCGATGTAGCT...CGT', IUPACUnambiguousDNA()) \n\nLes objets SeqRecord contiennent davantage d'informations:\n\n    >>> sr1 = SeqRecord(s1, id=\"sequence1\", name=\"sequence1\", description=\"une sequence\")\n    >>> sr1\n    SeqRecord(seq=Seq('ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGCATAGCATCGATGTAGCT...CGT'), id='sequence1', name='sequence1',      description='une sequence', dbxrefs=[])\n\n    >>> sr2 = SeqRecord(s2, id=\"sequence2\", name=\"sequence2\", description=\"une autre sequence\")\n    >>> sr2\n    SeqRecord(seq=Seq('ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGAATAGCATCGATGTAGCT...CGT', IUPACUnambiguousDNA()), id='sequence2', name='sequence2', description='une sequence', dbxrefs=[])\n\n<a name=\"creatfasta\"></a>\n\n### Sauvegarder un ou plusieurs SeqRecord dans un ou plusieurs fichiers fasta\n\nCr\u00e9er un fasta contenant un seul SeqRecord. Le fichier fasta serra enregistr\u00e9 dans le repertoire courant et portera le nom du SeqRecord avec l'extension .fas\n\n    >>> mkfas(sr1)\n\n\nCr\u00e9er plusieurs fichiers fasta mono s\u00e9quence:\n\n    >>> mkfas(sr1, sr2)\n\nCr\u00e9er un fasta multisequence contenant plusieurs SeqRecord. Le fichier fasta serra enregistr\u00e9 dans le path indiqu\u00e9 en argument:\n\n    >>> mkfasx(\"myfasta.fas\", sr1, sr2)\n\n##### Cr\u00e9er un SeqRecord et un fasta avec la fonction creat()\n\n    >>> help(creat)\n    Help on function creat in module genopy:\n\n    creat(seq_name, seq, des='', out=False)\n        Cr\u00e9ation d'un SeqRecord et d'un fasta mono s\u00e9quence\n\n    arguments:\n            seq_name: (str) nom de la s\u00e9quence cr\u00e9\u00e9e\n            seq: (str) ou (Seq) ou (SeqRecord) la s\u00e9quence\n            des: (str) d\u00e9scription du SeqRecord\n            out (bool): si False (d\u00e9faut) , le fasta n'est pas cr\u00e9\u00e9\n\n    retrun: \n            le SeqRecord cr\u00e9\u00e9\n\n\n\n    >>> s = creat(\"un_adn\", \"ATCTCGTAGCTAGT\", des=\"human adn\", out=True)\n    >>> s\n    SeqRecord(seq=Seq('ATCTCGTAGCTAGT', IUPACUnambiguousDNA()), id='un_adn', name='un_adn', description='human adn', dbxrefs=[])\n\n\n\n<a name=\"convedi\"></a>\n\n### Convertir des fichiers anag\u00e8ne avec l'extension .edi en fichiers fasta\n\nOn commence par importer les modules genopy et os:\n\n    >>> from genopy import *\n    >>> import os\n\nOn liste les fichiers du repertoire dans lequel on se trouve (ou un autre repertoire si on indique son path en argument de listdir):\n\n    >>> ld = os.listdir()\n    >>> \n    >>> ld\n    ['__pycache__', 'genes-Opsines.edi', 'emb.aln', 'comp.aln', 'primates.fas', 'allelesFamillechoree.edi', 'genopy.py', 'tyrfamille4.fas', 'globines-beta-vertebres.fas', 'comp.dnd', 'myfasta.fas']\n\nOn remarque ici deux fichiers en .edi\nOn utilise une boucle for pour selectionner les fichiers .edi et les convertir en .fas grace \u00e0 la fonction edi2fasta. Cette fonction attend 2 arguments: edi2fasta(file_name.edi, file_name.fas):\n\n    >>> for i in ld:\n    ...     if i[len(i)-4:] == \".edi\":\n    ...             edi2fasta(i, i[:len(i)-4]+\".fas\")\n    ... \n    >>> \n\nOn liste \u00e0 nouveau les fichiers du repertoire:\n\n    >>> os.listdir()\n    ['__pycache__', 'genes-Opsines.edi', 'allelesFamillechoree.fas', 'emb.aln', 'comp.aln', 'primates.fas', 'allelesFamillechoree.edi', 'genopy.py', 'genes-Opsines.fas', 'tyrfamille4.fas', 'globines-beta-vertebres.fas', 'comp.dnd', 'myfasta.fas']\n\n\n<a name=\"openseq\"></a>\n\n### Ouvrir des s\u00e9quences\n\nLes s\u00e9quences doivent \u00eatre h\u00e9berg\u00e9es localement.\n\nOn commence par rechercher les s\u00e9quences avec la fonction 'search()' :\n\n    >>> from genopy import *\n    >>>\n    >>> q = search(\"Opsine\")\n    >>> \n    >>> q\n    [SeqRecord(seq=Seq('ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGC...TGA', SingleLetterAlphabet()), id='gene_opsine_rouge', name='gen\u0001e_opsine_rouge', description='gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA', dbxrefs=[]), SeqRecord(seq=Seq('ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGC...TGA', SingleLetterAlphabet()), id='gene_opsine_verte', name='gene_opsine_verte', descripti\u0001on='gene_opsine_verte red opsin Homo sapiens opsin 1 (cone pigments), mRNA', dbxrefs=[]), SeqRecord(seq=Seq('ATGAGAAAAATGTCGGAGGAAGAGTTTTATCTGTTCAAAAATATCTCTTCAGTG...TGA', SingleLetterAlphabet()), id='gene_opsine_bleue', name='gene_opsine_bleue', description='gene_opsine_bleue Blue\u0001 opsin Homo sapiens opsin 1 (cone pigments), mRNA', dbxrefs=[])]\n\nOn obtient une liste de SeqRecord correspondant \u00e0 notre recherche.\n\n    >>> len(q)\n    3\n    >>> \n    >>> for i, j in enumerate(q):\n    ...     print(str(i) + \" \" + j.name)\n    ... \n    0 gene_opsine_rouge\n    1 gene_opsine_verte\n    2 gene_opsine_bleue\n\nOn peut alors afficher la s\u00e9quence du g\u00e8ne de l'opsine verte dont l'indice dans la liste est 1 avec la fonction 'show()':\n\n    >>> show(q[1])\n\n\n          ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGCTATGAG\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   10        20        30        40        50        60\n\n          GACAGCACCCAGTCCAGCATCTTCACCTACACCAACAGCAACTCCACCAGAGGCCCCTTC\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   70        80        90        100       110       120\n\n          GAAGGCCCGAATTACCACATCGCTCCCAGATGGGTGTACCACCTCACCAGTGTCTGGATG\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   130       140       150       160       170       180\n\n          ATCTTTGTGGTCATTGCATCCGTTTTCACAAATGGGCTTGTGCTGGCGGCCACCATGAAG\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   190       200       210       220       230       240\n\n          TTCAAGAAGCTGCGCCACCCGCTGAACTGGATCCTGGTGAACCTGGCGGTCGCTGACCTG\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   250       260       270       280       290       300\n\n          GCAGAGACCGTCATCGCCAGCACTATCAGCGTTGTGAACCAGGTCTATGGCTACTTCGTG\n          ----:----|----:----|----:----|----:----|----:----|----:----|\n                   310       320       330       340       350       360\n\n\n\n(la s\u00e9quence n'est pas repr\u00e9sent\u00e9e entierement dans ce tutoriel)\n\n\n\n### Transcrire, Traduire, R\u00e9tro-transcrire\n\n<a name=\"transc\"></a>\n\n    >>> from genopy import *\n    >>>\n    >>> q = search(\"Opsine\")\n    >>> dna = q[0]\n    >>> \n    >>> dna\n    SeqRecord(seq=Seq('ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGC...TGA', SingleLetterAlphabet()), id='gene_opsine_rouge', name='gene_opsine_rouge', description='gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA', dbxrefs=[])\n\n#### Transcrire\n\n    >>> rna = transcribe(dna)\n    >>> rna\n    SeqRecord(seq=Seq('AUGGCCCAGCAGUGGAGCCUCCAAAGGCUCGCAGGCCGCCAUCCGCAGGACAGC...UGA', RNAAlphabet()), id='gene_opsine_rouge.rna', name='gene_opsine_rouge.rna', description='transcription de [gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA]', dbxrefs=[])\n\n\n<a name=\"transl\"></a>\n\n#### Traduire\n\n    >>> help(translate)\n    Help on function translate in module genopy:\n\n    translate(*seq, table_id=1, to_stop=True, stop_symbol=' ', cds=True, out=False)\n    Traduction d'un ou plusieurs dna ou rna SeqRecord. \n\n    arguments:\n        *seq: liste de dna ou rna Seq ou SeqRecord\n        table_id: indice de la table du code g\u00e9n\u00e9tique \u00e0 utiliser (par defaut: 1 c'est le code standard)\n        to_stop: bool  True par d\u00e9faut: la traduction s'arrete au codon stop\n        stop_symbol: repr\u00e9sentation de l'arret de la traduction\n        cds: coding sequence: bool  True par d\u00e9faut: la traduction commence au condon initiateur et se termine au codon stop\n        out: bool False par d\u00e9faut. Si out == True, chaque sequence peptidique est sauvegard\u00e9e dans un fasta. \n\n    return: proteine SeqRecord ou une liste de proteines SeqRecord\n\n> ORF: open reading frame ou phase ouverte de lecture, c'est la s\u00e9quence du brin non transcrit (brin codant) de l'adn (ou de l'arn pr\u00e9-messager) situ\u00e9e entre le premier codon initiateur jusqu'au premier codon stop \n> \n> CDS: coding sequence ou s\u00e9quence codante, c'est l'ORF sans les introns\n\nIl est possible de choisir la table du code g\u00e9n\u00e9tique utilis\u00e9e (par d\u00e9faut c'est le code standard)\n\nL'argument to_stop = True permet d'arreter la traduction au codon stop\n\nL'argument stop_symbol permet de sp\u00e9cifier la repr\u00e9sentation de l'arret de la traduction\n\nL'argument cds = True implique que la traduction commencera au premier codon initiateur rencontr\u00e9 et se terminera au premier codon stop rencontr\u00e9 sur le cadre de lecture. La majorit\u00e9 des s\u00e9quences import\u00e9es depuis anangene sont d\u00e9j\u00e0 des CDS, donc ca change rien; mais ce n'est pas le cas des fasta t\u00e9l\u00e9charg\u00e9s depuis les banques de s\u00e9quences. \n\n    >>> pep = translate(rna)\n    >>> pep\n    SeqRecord(seq=Seq('MAQQWSLQRLAGRHPQDSYEDSTQSSIFTYTNSNSTRGPFEGPNYHIAPRWVYH...SPA', ExtendedIUPACProtein()), id='gene_opsine_rouge.rna.prot', name='gene_opsine_rouge.rna.prot', description='traduction de [transcription de [gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigmen\u0001ts), mRNA]]', dbxrefs=[])\n\n    >>> show(pep)\n\n\n          MetAlaGlnGlnTrpSerLeuGlnArgLeuAlaGlyArgHisProGlnAspSerTyrGluAspSerThrGlnSerSerIlePheThrTyr\n           -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                      10                            20                            30\n\n          ThrAsnSerAsnSerThrArgGlyProPheGluGlyProAsnTyrHisIleAlaProArgTrpValTyrHisLeuThrSerValTrpMet\n           -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                      40                            50                            60\n\n          IlePheValValThrAlaSerValPheThrAsnGlyLeuValLeuAlaAlaThrMetLysPheLysLysLeuArgHisProLeuAsnTrp\n           -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                      70                            80                            90\n\n          IleLeuValAsnLeuAlaValAlaAspLeuAlaGluThrValIleAlaSerThrIleSerIleValAsnGlnValSerGlyTyrPheVal\n           -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                      100                           110                           120\n\n          LeuGlyHisProMetCysValLeuGluGlyTyrThrValSerLeuCysGlyIleThrGlyLeuTrpSerLeuAlaIleIleSerTrpGlu\n           -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                      130                           140                           150\n\n<a name=\"rt\"></a>\n\n#### R\u00e9tro transcrire\n\n    >>> rna\n    SeqRecord(seq=Seq('AUGGCCCAGCAGUGGAGCCUCCAAAGGCUCGCAGGCCGCCAUCCGCAGGACAGC...UGA', RNAAlphabet()), id='gene_opsine_rouge.rna', name='gene_opsine_rouge.rna', description='transcription de [gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA]', dbxrefs=[])\n\n\n    >>> dna_c = retro_transcribe(rna)\n    >>> dna_c\n    SeqRecord(seq=Seq('ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGC...TGA', DNAAlphabet()), id='gene_opsine_rouge.rna.dnac', name='gene_opsine_rouge.rna.dnac', description='retro transcription de [transcription de [gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA]]', dbxrefs=[])\n\n    >>> dna.seq == dna_c.seq\n    True\n\n<a name=\"tablecode\"></a>\n\n### Afficher les tables du code g\u00e9n\u00e9tique\n\n    >>> from genopy import *\n    >>>\n    >>> codegen()\n\n\n    1 : Standard\n    2 : Vertebrate Mitochondrial\n    3 : Yeast Mitochondrial\n    4 : Mold Mitochondrial\n    5 : Invertebrate Mitochondrial\n    6 : Ciliate Nuclear\n    9 : Echinoderm Mitochondrial\n    10 : Euplotid Nuclear\n    11 : Bacterial\n    12 : Alternative Yeast Nuclear\n    13 : Ascidian Mitochondrial\n    14 : Alternative Flatworm Mitochondrial\n    15 : Blepharisma Macronuclear\n    16 : Chlorophycean Mitochondrial\n    21 : Trematode Mitochondrial\n    22 : Scenedesmus obliquus Mitochondrial\n    23 : Thraustochytrium Mitochondrial\n    24 : Pterobranchia Mitochondrial\n    25 : Candidate Division SR1\n    26 : Pachysolen tannophilus Nuclear\n    27 : Karyorelict Nuclear\n    28 : Condylostoma Nuclear\n    29 : Mesodinium Nuclear\n    30 : Peritrich Nuclear\n    31 : Blastocrithidia Nuclear\n\n\n\n\n    Entrez le num\u00e9ro de la table \u00e0 afficher: 1\n\n\n    RNA table: \n\n    Table 1 Standard, SGC0\n\n      |  U      |  C      |  A      |  G      |\n    --+---------+---------+---------+---------+--\n    U | UUU F   | UCU S   | UAU Y   | UGU C   | U\n    U | UUC F   | UCC S   | UAC Y   | UGC C   | C\n    U | UUA L   | UCA S   | UAA Stop| UGA Stop| A\n    U | UUG L(s)| UCG S   | UAG Stop| UGG W   | G\n    --+---------+---------+---------+---------+--\n    C | CUU L   | CCU P   | CAU H   | CGU R   | U\n    C | CUC L   | CCC P   | CAC H   | CGC R   | C\n    C | CUA L   | CCA P   | CAA Q   | CGA R   | A\n    C | CUG L(s)| CCG P   | CAG Q   | CGG R   | G\n    --+---------+---------+---------+---------+--\n    A | AUU I   | ACU T   | AAU N   | AGU S   | U\n    A | AUC I   | ACC T   | AAC N   | AGC S   | C\n    A | AUA I   | ACA T   | AAA K   | AGA R   | A\n    A | AUG M(s)| ACG T   | AAG K   | AGG R   | G\n    --+---------+---------+---------+---------+--\n    G | GUU V   | GCU A   | GAU D   | GGU G   | U\n    G | GUC V   | GCC A   | GAC D   | GGC G   | C\n    G | GUA V   | GCA A   | GAA E   | GGA G   | A\n    G | GUG V   | GCG A   | GAG E   | GGG G   | G\n    --+---------+---------+---------+---------+--\n\n\n    <Bio.Data.CodonTable.NCBICodonTableRNA object at 0x74a047d0>\n\n\n\n\n    >>> cg = codegen(1, bydna=True)\n\n\n    DNA table: \n\n    Table 1 Standard, SGC0\n\n      |  T      |  C      |  A      |  G      |\n    --+---------+---------+---------+---------+--\n    T | TTT F   | TCT S   | TAT Y   | TGT C   | T\n    T | TTC F   | TCC S   | TAC Y   | TGC C   | C\n    T | TTA L   | TCA S   | TAA Stop| TGA Stop| A\n    T | TTG L(s)| TCG S   | TAG Stop| TGG W   | G\n    --+---------+---------+---------+---------+--\n    C | CTT L   | CCT P   | CAT H   | CGT R   | T\n    C | CTC L   | CCC P   | CAC H   | CGC R   | C\n    C | CTA L   | CCA P   | CAA Q   | CGA R   | A\n    C | CTG L(s)| CCG P   | CAG Q   | CGG R   | G\n    --+---------+---------+---------+---------+--\n    A | ATT I   | ACT T   | AAT N   | AGT S   | T\n    A | ATC I   | ACC T   | AAC N   | AGC S   | C\n    A | ATA I   | ACA T   | AAA K   | AGA R   | A\n    A | ATG M(s)| ACG T   | AAG K   | AGG R   | G\n    --+---------+---------+---------+---------+--\n    G | GTT V   | GCT A   | GAT D   | GGT G   | T\n    G | GTC V   | GCC A   | GAC D   | GGC G   | C\n    G | GTA V   | GCA A   | GAA E   | GGA G   | A\n    G | GTG V   | GCG A   | GAG E   | GGG G   | G\n    --+---------+---------+---------+---------+--\n\n\n    >>> cg.\n    cg.back_table           cg.id                   cg.nucleotide_alphabet  cg.start_codons         \n    cg.forward_table        cg.names                cg.protein_alphabet     cg.stop_codons          \n\n    >>> cg.start_codons\n    ['TTG', 'CTG', 'ATG']\n\n    >>> cg.back_table\n    {'K': 'AAG', 'N': 'AAT', 'T': 'ACT', 'R': 'CGT', 'S': 'TCT', 'I': 'ATT', 'M': 'ATG', 'Q': 'CAG', 'H': 'CAT', 'P': 'CCT', 'L': 'TTG', 'E': 'GAG', 'D': 'GAT', 'A': 'GCT', 'G': 'GGT', 'V': 'GTT', 'Y': 'TAT', 'C': 'TGT', 'W': 'TGG', 'F': 'TTT', None: 'TAA'}\n\n    >>> cg.forward_table\n    {'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L', 'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S', 'TAT': 'Y', 'TAC': 'Y', 'TGT': 'C', 'TGC': 'C', 'TGG': 'W', 'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L', 'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P', 'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q', 'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R', 'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M', 'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T', 'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K', 'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R', 'GTT': 'V', 'GTC': 'V',\u0001 'GTA': 'V', 'GTG': 'V', 'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A', 'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E', 'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'}\n\n    >>> cg.forward_table[\"AAC\"]\n    'N' \n\n\n\n\n<a name=\"needlewater\"></a>\n\n### Comparer deux s\u00e9quences: alignement par Needle ou Water\n\nOn commence par rechercher des s\u00e9quences:\n\n    >>> from genopy import *\n    >>>\n    >>> q = search(\"primates\")\n    >>> \n    >>> len(q)\n    7\n    >>> \n    >>> q[0]\n    SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCA...CAT', SingleLetterAlphabet()), id='Refhumaine.adn', name='Refhumaine.adn', description=' Refhumaine.adn', dbxrefs=[])\n\nOn va ensuite comparer les s\u00e9quences 2 \u00e0 2. \n\nIl est possible de faire un alignement global (needle) ou local (water)\n\n    >>> help(needle)\n    Help on function needle in module genopy:\n\n    needle(*seq, gapopen=10, gapextend=0.5, out='emb.aln')\n        Alignement global par la m\u00e9thode de Needleman\n\n    arguments:\n\n            seq: couple de 2 SeqRecord \u00e0 aligner\n            gapopen: p\u00e9nalit\u00e9 de gap\n            gapextend: p\u00e9nalit\u00e9 d'expansion\n            out: nom du fichier emboss cr\u00e9\u00e9\n\n    return: un objet align\n\nL'alignement est enregistr\u00e9 par d\u00e9faut dans le fichier emb.aln (qui serra \u00e9cras\u00e9 au prochain alignement r\u00e9alis\u00e9)\n\nDans les 2 cas on peut eventuellement modifier les p\u00e9nalit\u00e9s pour les ouvertures ou les extensions de gap.\n\n\n    >>> n = needle(q[0], q[1])\n    >>> \n    >>> w = water(q[0], q[1])\n    >>> \n    >>> n\n    <<class 'Bio.Align.MultipleSeqAlignment'> instance (2 records of length 365, SingleLetterAlphabet()) at 70615df0>\n    >>> w\n    <<class 'Bio.Align.MultipleSeqAlignment'> instance (2 records of length 361, SingleLetterAlphabet()) at 7061def0>\n\n\nOn obtient des objets \"align\" que l'on peut alors exploiter de diff\u00e9rentes fa\u00e7ons:\n\nObtenir des informations de base sur l'alignement:\n\n    >>> print(n)\n    SingleLetterAlphabet() alignment with 2 rows and 365 columns\n    TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGAC...--- Refhumaine.adn\n    TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGT----AC...GGA Orangoutan.adn\n\n    >>> n.\n    n.add_sequence(          n.append(                n.extend(                n.get_alignment_length(  \n    n.annotations            n.column_annotations     n.format(                n.sort(                  \n\n    >>> n.get_alignment_length()\n    365\n\n    >>> len(n)\n    2\n\n    >>> n[0]\n    SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCA...---', SingleLetterAlphabet()), id='Refhumaine.adn', name='<unknown name>', description='Refhumaine.adn', dbxrefs=[])\n\n\n\nAfficher l'alignement avec les fonctions shogenix(), showanag(), (ou showgenix3() pour les s\u00e9quences peptidiques avec acides amin\u00e9s repr\u00e9sent\u00e9s \u00e0 trois lettres)\n\nL'affichage via showgenix repr\u00e9sente toutes les s\u00e9quences. Les similitudes sont symbolis\u00e9es par une * et les d\u00e9l\u00e9tions par des - . \n\n    >>> showgenix(n)\n\n\n                          ************* * *********** ****** ***    **  ******   ** * \n    Refhumaine.adn        TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCAACAACC\n    Orangoutan.adn        TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGT----ACCGACCCATTTCCAGCG\n\n                          ----:----|----:----|----:----|----:----|----:----|----:----|\n                                   10        20        30        40        50        60\n\n\n\n                          * ****************** ********** *********   **   ** **  *** \n    Refhumaine.adn        G-CTATGTATTTCGTACATTACTGCCAGCCACCATGAATATTGTACGGTAC-CATAAAT-\n    Orangoutan.adn        GCCTATGTATTTCGTACATTCCTGCCAGCCAACATGAATAT--CACCCAACACAACAATC\n\n                          ----:----|----:----|----:----|----:----|----:----|----:----|\n                                   70        80        90        100       110       120\n\n\nL'affichage via showanag utilise le m\u00eame mode de symbolisation que le logiciel anagene.\n\n    >>> showanag(n)\n\n\n                          ************* * *********** ****** ***    **  ******   ** * \n    Refhumaine.adn        TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCAACAACC\n    Orangoutan.adn        -------------G-T-----------A------C---____--CG------TTC--G-G\n\n                          ----:----|----:----|----:----|----:----|----:----|----:----|\n                                   10        20        30        40        50        60\n\n\n\n                          * ****************** ********** *********   **   ** **  *** \n    Refhumaine.adn        G_CTATGTATTTCGTACATTACTGCCAGCCACCATGAATATTGTACGGTAC_CATAAAT_\n    Orangoutan.adn        -C------------------C----------A---------__C--CCA--A--AC---C\n\n                          ----:----|----:----|----:----|----:----|----:----|----:----|\n                                   70        80        90        100       110       120\n\n\n\n\n\nIl est aussi possible de lire l'alignement enregistr\u00e9 dans le fichier emb.aln avec la fonction reademboss() \n\n\n\n    >>> n = needle(q[0], q[1])\n\n    >>> reademboss(\"emb.aln\")    # ou reademboss()\n\n    ########################################\n    # Program: needle\n    # Rundate: Sun 14 Jul 2019 11:13:59\n    # Commandline: needle\n    #    -outfile emb.aln\n    #    -asequence seqa.fas\n    #    -bsequence seqb.fas\n    #    -gapopen 10\n    #    -gapextend 0.5\n    # Align_format: srspair\n    # Report_file: emb.aln\n    ########################################\n\n    #=======================================\n    #\n    # Aligned_sequences: 2\n    # 1: Refhumaine.adn\n    # 2: Orangoutan.adn\n    # Matrix: EDNAFULL\n    # Gap_penalty: 10.0\n    # Extend_penalty: 0.5\n    #\n    # Length: 365\n    # Identity:     255/365 (69.9%)\n    # Similarity:   255/365 (69.9%)\n    # Gaps:          40/365 (11.0%)\n    # Score: 824.5\n    # \n    #\n    #=======================================\n\n    Refhumaine.ad      1 TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCC     50\n                         |||||||||||||.|.|||||||||||.||||||.|||    ||..||||\n    Orangoutan.ad      1 TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGT----ACCGACCC     46\n\n    Refhumaine.ad     51 ATCAACAACCG-CTATGTATTTCGTACATTACTGCCAGCCACCATGAATA     99\n                         ||...||.|.| ||||||||||||||||||.||||||||||.||||||||\n    Orangoutan.ad     47 ATTTCCAGCGGCCTATGTATTTCGTACATTCCTGCCAGCCAACATGAATA     96\n\n\n    #---------------------------------------\n    #---------------------------------------\n\n    <<class 'Bio.Align.MultipleSeqAlignment'> instance (2 records of length 365, SingleLetterAlphabet()) at 70603ab0>\n\n\n(Les alignements ne sont pas repr\u00e9sent\u00e9s en entier dans ce tutoriel)\n\nIl est possible d'afficher le % de similitudes ou de diff\u00e9rences en utilisant la fonction reademboss (comme ci dessous) ou en affichant la matrice de distance avec la fonction matrix()\n\n    >>> m = matrix(n)\n    >>> print(m)\n    Refhumaine.adn  0\n    rangoutan.adn   0.3013698630136986      0\n                    Refhumaine.adn          Orangoutan.adn\n\n<a name=\"clustal\"></a>\n\n### Comparaison multiple de s\u00e9quences avec Clustal\n\nOn commence par importer des s\u00e9quences:\n\n    >>> from genopy import *\n    >>>\n    >>> q = search(\"tyr\")\n    >>> \n    >>> len(q)\n    25\n    >>> \n    >>> q[0]\n    SeqRecord(seq=Seq('ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGC...TAA', SingleLetterAlphabet()), id='Tyrcod2', name='Tyrcod2', description=\"Tyrcod2  Partie strictement codante d'un allele du gene de la tyrosinase (ref erence 2).\", dbxrefs=[])\n\nPuis on utilise la fonction clustal: exemple ici pour comparer les s\u00e9quence d\u2019index 5, 6, 7, 8\n\n    >>> c = clustal(*q[5:9])  # ou clustal(q[5], q[6], q[7], q[8])\n    >>> c\n    <<class 'Bio.Align.MultipleSeqAlignment'> instance (4 records of length 1590, SingleLetterAlphabet()) at 704f06f0>\n\n\nAffichage simple: \n\n    >>> print(c)\n    SingleLetterAlphabet() alignment with 4 rows and 1590 columns\n    ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGAC...TAA F4_I2all1\n    ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGAC...TAA F4_I2all2\n    ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGAC...TAA F4_I1all2\n    ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGAC...TAA F4_I1all1\n    >>> \n\nM\u00e9thodes applicables \u00e0 l'objet align:\n\n    >>> c.\n    c.add_sequence(          c.append(                c.extend(                c.get_alignment_length(  \n    c.annotations            c.column_annotations     c.format(                c.sort(                  \n\nAffichage au format clustal:\n\n    >>> print(c.format(\"clustal\"))\n    CLUSTAL 2.1 multiple sequence alignment\n\n\n    F4_I2all1     ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGC\n    F4_I2all2     ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGC\n    F4_I1all2     ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGC\n    F4_I1all1     ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGC\n                  **************************************************\n\n\nAffichage au format phylip:\n\n    >>> print(c.format(\"phylip\"))\n    4 1590\n    F4_I2all1  ATGCTCCTGG CTGTTTTGTA CTGCCTGCTG TGGAGTTTCC AGACCTCCGC\n    F4_I2all2  ATGCTCCTGG CTGTTTTGTA CTGCCTGCTG TGGAGTTTCC AGACCTCCGC\n    F4_I1all2  ATGCTCCTGG CTGTTTTGTA CTGCCTGCTG TGGAGTTTCC AGACCTCCGC\n    F4_I1all1  ATGCTCCTGG CTGTTTTGTA CTGCCTGCTG TGGAGTTTCC AGACCTCCGC\n\n               TGGCCATTTC CCTAGAGCCT GTGTCTCCTC TAAGAACCTG ATGGAGAAGG\n               TGGCCATTTC CCTAGAGCCT GTGTCTCCTC TAAGAACCTG ATGGAGAAGG\n               TGGCCATTTC CCTAGAGCCT GTGTCTCCTC TAAGAACCTG ATGGAGAAGG\n               TGGCCATTTC CCTAGAGCCT GTGTCTCCTC TAAGAACCTG ATGGAGAAGG\n\n\nAffichage au format genix:\n\n    >>> showgenix(c)\n\n\n                     ************************************************************\n    F4_I2all1        ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGCCATTTC\n    F4_I2all2        ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGCCATTTC\n    F4_I1all2        ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGCCATTTC\n    F4_I1all1        ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGCCATTTC\n\n                     ----:----|----:----|----:----|----:----|----:----|----:----|\n                              10        20        30        40        50        60\n\nIl est aussi possible de faire un affichage de l'alignement au format anagene avec la fonction showanag().\n\n<a name=\"matrix\"></a>\n\n#### Afficher une matrice de distances:\n\nLa fonction matrix attend un alignement (needle, water ou clustal) en argument obligatoire:\n\n    >>> m = matrix(c)\n    >>> print(m)\n    F4_I2all1       0\n    F4_I2all2       0.0006289308176100628   0\n    F4_I1all2       0.0012578616352201255   0.0006289308176100628   0\n    F4_I1all1       0.0012578616352201255   0.0006289308176100628   0.0012578616352201255   0\n                    F4_I2all1               F4_I2all2               F4_I1all2               F4_I1all1\n\nLa matrice peut \u00eatre convertie en table HTML et d\u00e9ploy\u00e9e sur [IPFS](https://gist.github.com/YannBouyeron/53e6d67782dcff5995754b0a7333fa0b) avec la fonction matrix2ipfs:\n\n    >>> matrix2ipfs(m)\n    'QmcMhGpqsiCoyoPmbUf4xuX7ayMNiVHEkU44t4XMyWm2AK'\n\nOn obtient le hash du fichier HTML, consultable sur votre noeud ipfs ou via ipfs.io: https://ipfs.io/ipfs/<hash>:\n\n[https://ipfs.io/ipfs/QmcMhGpqsiCoyoPmbUf4xuX7ayMNiVHEkU44t4XMyWm2AK](https://ipfs.io/ipfs/QmcMhGpqsiCoyoPmbUf4xuX7ayMNiVHEkU44t4XMyWm2AK)\n\nLa matrice peut aussi \u00eatre sauvegard\u00e9e sous forme d'image png qui serra enregistr\u00e9e localement:\n\n    >>> matrix2png(m, path=\"ma_matrice.png\")\n    <matplotlib.axes._subplots.AxesSubplot object at 0x704f0a50>\n\n\n<p align=\"center\">\n  <img src=\"Images/ma_matrice.png\">\n</p>\n\n<a name=\"phylomatrix\"></a>\n\n### Construire un arbre phylog\u00e9n\u00e9tique \u00e0 partir d'une matrice de distances\n\n    >>> from genopy import *\n    >>>\n    >>> q = search(\"tyr\")\n    >>> c = clustal(*q[5:10])\n    >>> m = matrix(c)\n\n    >>> print(m)\n    F4_I2all2       0\n    4_II1all1       0.0                     0\n    F4_I2all1       0.0006289308176100628   0.0006289308176100628   0\n    F4_I1all2       0.0006289308176100628   0.0006289308176100628   0.0012578616352201255   0\n    F4_I1all1       0.0006289308176100628   0.0006289308176100628   0.0012578616352201255   0.0012578616352201255   0\n                    F4_I2all2               F4_II1all1              F4_I2all1               F4_I1all2               F4_I1all1\n\n\nNeighbor-joining:\n\n    >>> help(tree_nj)\n\n    Help on function tree_nj in module genopy:\n\n    tree_nj(dm)\n        Cr\u00e9ation d'un arbre nj \u00e0 partir de la matrice de distance retourn\u00e9e par la fonction matrix\n        return: tree\n\n\n\n    >>> nj = tree_nj(m)\n\n\n     , F4_I2all2\n     |\n     | F4_II1all1\n     |\n     |_________________________________________________________________ F4_I2all1\n    _|\n     |_________________________________________________________________ F4_I1all2\n     |\n     |_________________________________________________________________ F4_I1all1\n\n\n    >>> nj\n    Tree(rooted=True)\n\n\nUPGMA:\n\n    >>> help(tree_upgma)\n\n    Help on function tree_upgma in module genopy:\n\n    tree_upgma(dm)\n        Cr\u00e9ation d'un arbre upgma \u00e0 partir de la matrice de distance retourn\u00e9e par la fonction matrix\n        return: tree\n\n\n    >>> up = tree_upgma(m)\n\n\n      _________________________________________________________________ F4_I2all1\n    _|\n     |         ________________________________________________________ F4_I1all2\n     |________|\n              |                   _____________________________________ F4_I1all1\n              |__________________|\n                                 |                                     , F4_II1all1\n                                 |_____________________________________|\n                                                                       | F4_I2all2\n\n\nParcimonie:\n\n    >>> help(parsimony_tree)\n\n    Help on function parsimony_tree in module genopy:\n\n    parsimony_tree(align, starting_tree)\n        Cr\u00e9ation d'un arbre bas\u00e9 sur la m\u00e9thode de parcimonie \u00e0 partir de l'alignement et d'un arbre de d\u00e9part (nj)\n\n    arguments:\n            align: objet align retourn\u00e9 par clustal()\n            satrting_tree: objet tree retourn\u00e9 par tree_nj()\n\n    return: tree\n\n\n    >>> pa = parsimony_tree(c, nj)\n\n\n      _________________________________________________________________ F4_I2all1\n     |\n     , F4_II1all1\n     |\n     | F4_I2all2\n    _|\n     |_________________________________________________________________ F4_I1all1\n     |\n     |_________________________________________________________________ F4_I1all2\n\n\n\nPour afficher les distances sur les branches de l'arbre:\n\n     >>> nj = tree_nj(m)\n\n     >>> dnj = draw_tree(nj, distance=True)\n\n\n<a name=\"phyloseq\"></a>\n\n### Construire un arbre phylog\u00e9n\u00e9tique \u00e0 partir d'une liste de s\u00e9quences\n\n    >>> from genopy import *\n    >>>\n    >>> q = search(\"tyr\")\n    >>> \n    >>> len(q)\n    25\n    >>> \n    >>> help(phylo)\n\n    Help on function phylo in module genopy:\n\n    phylo(*seq, out='comp.aln')\n        M\u00e9thode simplifi\u00e9e de cr\u00e9ation d'un arbre phylog\u00e9n\u00e9tique \u00e0 partir d'une liste de SeqRecord\n\n            argument: *seq: liste de SeqRecord \u00e0 aligner\n            return: (align, stdout, tree)\n\n\n    >>> p = phylo(*q[3:7])\n\n\n               Tyralb_TS  F4_I1all2  Tyralb_A5  F4_I1all1\n    Tyralb_TS   0.000000   0.000000   0.001887   0.001258\n    F4_I1all2   0.000000   0.000000   0.001887   0.001258\n    Tyralb_A5   0.001887   0.001887   0.000000   0.000629\n    F4_I1all1   0.001258   0.001258   0.000629   0.000000\n\n\n\n\n                                                   ______________________ Tyralb_A5\n      ____________________________________________|\n     |                                            | F4_I1all1\n    _|\n     | Tyralb_TS\n     |\n     | F4_I1all2\n\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "genopy", "package_url": "https://pypi.org/project/genopy/", "platform": "", "project_url": "https://pypi.org/project/genopy/", "project_urls": {"Source": "https://github.com/YannBouyeron/genopy/"}, "release_url": "https://pypi.org/project/genopy/0.0.2/", "requires_dist": ["numpy", "biopython", "pandas", "matplotlib", "seaborn", "ipfshttpclient"], "requires_python": ">=3.4", "summary": "Analyses genetiques et phylogenetiques", "version": "0.0.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>Genopy</h1>\n<p>Analyses g\u00e9n\u00e9tiques et phylog\u00e9n\u00e9tiques pour les SVT</p>\n<h2>Sommaire:</h2>\n<p><a href=\"#installgenopy\" rel=\"nofollow\">Installation</a></p>\n<p><a href=\"#creatseq\" rel=\"nofollow\">Cr\u00e9er des s\u00e9quences</a></p>\n<p><a href=\"#creatfasta\" rel=\"nofollow\">Cr\u00e9er des fichiers fasta</a></p>\n<p><a href=\"#convedi\" rel=\"nofollow\">Convertir des fichiers .edi (anagene) en fichiers fasta</a></p>\n<p><a href=\"#openseq\" rel=\"nofollow\">Rechercher et afficher des s\u00e9quences</a></p>\n<p><a href=\"#transc\" rel=\"nofollow\">Transcrire</a></p>\n<p><a href=\"#transl\" rel=\"nofollow\">Traduire</a></p>\n<p><a href=\"#rt\" rel=\"nofollow\">R\u00e9tro-Transcrire</a></p>\n<p><a href=\"#tablecode\" rel=\"nofollow\">Afficher les tables du code g\u00e9n\u00e9tique</a></p>\n<p><a href=\"#needlewater\" rel=\"nofollow\">Comparer des s\u00e9quences: alignement par paires</a></p>\n<p><a href=\"#clustal\" rel=\"nofollow\">Comparer des s\u00e9quences: alignement multiple (clustal)</a></p>\n<p><a href=\"#matrix\" rel=\"nofollow\">Afficher et sauvegarder une matrice de distances</a></p>\n<p><a href=\"#phylomatrix\" rel=\"nofollow\">Tracer un arbre phylog\u00e9n\u00e9tique \u00e0 partir d'une matrice de distances</a></p>\n<p><a href=\"#phyloseq\" rel=\"nofollow\">Tracer un arbre phylog\u00e9n\u00e9tique \u00e0 partir d'une liste de s\u00e9quences</a></p>\n<h2>Installation</h2>\n<p><a></a></p>\n<h3>Installation des d\u00e9pendances.</h3>\n<p>Genopy requiert python &gt;= 3.4 et des d\u00e9pendances python qui ne sont pas pr\u00e9sentes dans la librairie standard (numpy, biopython, pandas, matplotlib, seaborn, ipfshttpclient) et des d\u00e9pendances non python (Clustalw, Emboss, Rebase, Phylip).</p>\n<h4>Installation des d\u00e9pendances Python.</h4>\n<pre><code>sudo pip install numpy biopython pandas matplotlib seaborn ipfshttpclient\n</code></pre>\n<p>Si vous avez plusieurs versions de python et que vous souhaitez installer Genopy pour la version de python 3.6 (par exemple):</p>\n<pre><code>sudo python3.6 -m pip install numpy biopython pandas matplotlib seaborn ipfshttpclient\n</code></pre>\n<h4>Installation de Clustalw</h4>\n<p><a href=\"http://www.clustal.org/clustal2/\" rel=\"nofollow\">http://www.clustal.org/clustal2/</a></p>\n<p>Sur Debian:</p>\n<pre><code>sudo apt-get install clustalw\n</code></pre>\n<h4>Installation de Emboss</h4>\n<p><a href=\"http://emboss.sourceforge.net/download/\" rel=\"nofollow\">http://emboss.sourceforge.net/download/</a></p>\n<p>Sur Debian:</p>\n<pre><code>sudo apt-get install emboss\n</code></pre>\n<h4>Installation rebase pour emboss. (Facultatif)</h4>\n<p>Rebase permet  d\u2019utiliser certaines fonctions li\u00e9es aux enzymes de restriction; il s'agit notamment des fonctions restrict et remap.</p>\n<p>1: placez vous dans le r\u00e9pertoire de rebase</p>\n<pre><code>cd /usr/share/EMBOSS/data/REBASE\n</code></pre>\n<p>2: t\u00e9l\u00e9charger les fichiers withrefm et proto depuis le serveur ftp de rebase</p>\n<pre><code>sudo wget ftp://ftp.ebi.ac.uk/pub/databases/rebase/withrefm*\n</code></pre>\n<p>Puis</p>\n<pre><code>sudo wget ftp://ftp.ebi.ac.uk/pub/databases/rebase/proto*\n</code></pre>\n<p>3: d\u00e9compresser</p>\n<pre><code>sudo uncompress withrefm.707.gz\n</code></pre>\n<p>Et</p>\n<pre><code>sudo uncompress proto.707.gz\n</code></pre>\n<p>Vous n'aurez pas forc\u00e9ment le version 707.... c'est \u00e0 adapter</p>\n<p>4: extraire rebase</p>\n<pre><code>rebaseextract\n</code></pre>\n<p>Et voil\u00e0... c'est termin\u00e9.</p>\n<h4>Installation de Phylip</h4>\n<p><a href=\"http://evolution.genetics.washington.edu/phylip/install.html\" rel=\"nofollow\">http://evolution.genetics.washington.edu/phylip/install.html</a></p>\n<p>Sur Debian:</p>\n<pre><code>sudo apt-get install phylip\n</code></pre>\n<h3>Installation de genopy</h3>\n<h4>Avec pip:</h4>\n<pre><code>sudo pip install genopy\n</code></pre>\n<p>Ou, pour une version donn\u00e9e de python (exemple 3.6):</p>\n<pre><code>sudo python3.6 -m pip install genopy\n</code></pre>\n<h4>Depuis github:</h4>\n<pre><code>git clone https://github.com/YannBouyeron/genopy\n\ncd genopy\n\nsudo python setup.py install\n</code></pre>\n<h2>Licence</h2>\n<p>Ce code est sous licence <a href=\"http://www.gnu.org/licenses\" rel=\"nofollow\">GPL3</a></p>\n<h2>Exemple</h2>\n<pre><code>&gt;&gt;&gt; import genopy as gp\n&gt;&gt;&gt;\n&gt;&gt;&gt; list_seq = gp.search(\"primates\")\n\n\n&gt;&gt;&gt; list_seq\n[SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCA...CAT', SingleLetterAlphabet()), id='Refhumaine.adn', name='Refhumaine.adn', description=' Refhumaine.adn', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGTACCGACCCATTTCCAG...GGA', SingleLetterAlphabet()), id='Orangoutan.adn', name='Orangoutan.adn', description='Orangoutan.adn  ORANG-OUTAN', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAAATTTAAGTGCCACCCAAGTATTGGCTCATTCACTA...ACG', SingleLetterAlphabet()), id='Bonobo.adn', name='Bonobo.adn', description='Bonobo.adn  BONOBO', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGAGACAAATTTGGGTGCCACCCAAGTATTAGCTAACCCACCA...CCC', SingleLetterAlphabet()), id='G?orille.adn', name='Gorille.adn', description='Gorille.adn  GORILLE', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAAATTTAAGTACCACCTAAGTATTGGCCTATTCATTA...CAC', SingleLetterAlphabet()), id='Pan_AJ586556.adn', name='Pan_AJ586556.adn', description='Pan_AJ586556.adn  AJ586556-PAN', dbxrefs=[]), SeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAAATTTAAGTACCACCTAAGTACTGGCTCATTCATTA...CGG', SingleLetterAlphabet()), id='Pan_AJ586557.adn', name='Pan_AJ586557.adn', description='Pan_AJ586557.adn  AJ586557-PAN', dbxrefs=[]), SeqRecord(seq=Seq('TTCTATAGGGGGGAAAGAACTCAAAGAACAACCTAAGTACTAACTTAATCTCCC...AGT', SingleLetterAlphabet()), id='Colobe.adn', name='Colobe.adn', description='Colobe.adn  COLOBE', dbxrefs=[])]\n&gt;&gt;&gt; \n\n\n&gt;&gt;&gt; list_seq[1]\nSeqRecord(seq=Seq('TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGTACCGACCCATTTCCAG...GGA', SingleLetterAlphabet()), id='Orangoutan.adn', name='Orangoutan.adn', description='Orangoutan.adn  ORANG-OUTAN', dbxrefs=[])\n&gt;&gt;&gt; \n&gt;&gt;&gt; for i in list_seq:\n...     print(i.name)\n... \nRefhumaine.adn\nOrangoutan.adn\nBonobo.adn\nGorille.adn\nPan_AJ586556.adn\nPan_AJ586557.adn\nColobe.adn\n&gt;&gt;&gt; \n\n\n\n&gt;&gt;&gt; list_seq[1].name\n'Orangoutan.adn'\n&gt;&gt;&gt; \n\n&gt;&gt;&gt; gp.show(list_seq[1])\n\n\n      TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGTACCGACCCATTTCCAGCGGCCT\n      ----:----|----:----|----:----|----:----|----:----|----:----|\n               10        20        30        40        50        60\n\n      ATGTATTTCGTACATTCCTGCCAGCCAACATGAATATCACCCAACACAACAATCGCTTAA\n      ----:----|----:----|----:----|----:----|----:----|----:----|\n               70        80        90        100       110       120\n\n      CCACCTATAACACATACAAAGCCCAATCCACACCCAACCTCCACCCCCCGCTTACAAGCA\n      ----:----|----:----|----:----|----:----|----:----|----:----|\n               130       140       150       160       170       180\n\n      AGTACCCCCCCATGCCCCCCCACCCAAACACATACATCGATTCCCCCACATAACCCCTTC\n      ----:----|----:----|----:----|----:----|----:----|----:----|\n               190       200       210       220       230       240\n\n      CCCCCCCGCATACCAACCAACCCAATCAAGCTTTAAAGTACATAGCACATAACACCCCTA\n      ----:----|----:----|----:----|----:----|----:----|----:----|\n               250       260       270       280       290       300\n\n      CCGTACATAGCACATTTCTACTAACTCCCTGCTTAACCCTACGGA\n      ----:----|----:----|----:----|----:----|----:\n               310       320       330       340\n\n\n\n\n&gt;&gt;&gt; c = gp.clustal(*list_seq[1:5])\n&gt;&gt;&gt; \n&gt;&gt;&gt; gp.showgenix(c)\n\n\n\t                *************   ** ****  ** *****  ****    *  *      *      \nBonobo.adn              TTCTTTCATGGGGAAGCAAATTTAAGTGCCACCCAAGTATTGGCTCATTCACTA-TAACC\nPan_AJ586556.adn        TTCTTTCATGGGGAAGCAAATTTAAGTACCACCTAAGTATTGGCCTATTCATTA-CAACC\nGorille.adn             TTCTTTCATGGGGAGACAAATTTGGGTGCCACCCAAGTATTAGCTAACCCACCAACAATT\nOrangoutan.adn          TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGTACCGACCCATTT-CCAGCGGCC\n\n\t                ----:----|----:----|----:----|----:----|----:----|----:----|\n    \t                         10        20        30        40        50        60\n\n\n\n...\n...\n\n\n\n&gt;&gt;&gt; m = gp.matrix(c)\n\n&gt;&gt;&gt; print(m)\nBonobo.adn       0\nPan_AJ586556.adn 0.13276836158192096    0\nGorille.adn      0.25988700564971756    0.2542372881355932    0\nOrangoutan.adn   0.3220338983050848     0.3220338983050848    0.36723163841807904     0\n   \t         Bonobo.adn             Pan_AJ586556.adn      Gorille.adn             Orangoutan.adn\n\n\n&gt;&gt;&gt; tree = gp.tree_nj(m)\n\n\n  _______________ Bonobo.adn\n |\n_|______________ Pan_AJ586556.adn\n |\n |         ___________________________________________________ Orangoutan.adn\n |________|\n          |___________________________________ Gorille.adn\n</code></pre>\n<h2>Tutoriel</h2>\n<p><a></a></p>\n<h3>Cr\u00e9er des s\u00e9quences</h3>\n<p>Le module genopy d\u00e9pend de biopython, on peut cr\u00e9er des sequences sous deux types d'objets diff\u00e9rents: les objets Seq et SeqRecord.</p>\n<p>Cr\u00e9er un objet Seq</p>\n<pre><code>&gt;&gt;&gt; from genopy import *\n\n&gt;&gt;&gt; s1 = Seq(\"ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGCATAGCATCGATGTAGCTTAGCCGT\") \n&gt;&gt;&gt; s1\nSeq('ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGCATAGCATCGATGTAGCT...CGT')\n</code></pre>\n<p>La fonction toSeq de genopy permet de cr\u00e9er plus facilement des objets Seq. Elle ajoute automatiquement le type.</p>\n<pre><code>&gt;&gt;&gt; s2 = toSeq(\"ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGAATAGCATCGATGTAGCTTACCCGT\")\n&gt;&gt;&gt; s2\nSeq('ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGAATAGCATCGATGTAGCT...CGT', IUPACUnambiguousDNA()) \n</code></pre>\n<p>Les objets SeqRecord contiennent davantage d'informations:</p>\n<pre><code>&gt;&gt;&gt; sr1 = SeqRecord(s1, id=\"sequence1\", name=\"sequence1\", description=\"une sequence\")\n&gt;&gt;&gt; sr1\nSeqRecord(seq=Seq('ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGCATAGCATCGATGTAGCT...CGT'), id='sequence1', name='sequence1',      description='une sequence', dbxrefs=[])\n\n&gt;&gt;&gt; sr2 = SeqRecord(s2, id=\"sequence2\", name=\"sequence2\", description=\"une autre sequence\")\n&gt;&gt;&gt; sr2\nSeqRecord(seq=Seq('ATTCGCTCGTAATAGATGGCTCTATATAGATAGGCGAATAGCATCGATGTAGCT...CGT', IUPACUnambiguousDNA()), id='sequence2', name='sequence2', description='une sequence', dbxrefs=[])\n</code></pre>\n<p><a></a></p>\n<h3>Sauvegarder un ou plusieurs SeqRecord dans un ou plusieurs fichiers fasta</h3>\n<p>Cr\u00e9er un fasta contenant un seul SeqRecord. Le fichier fasta serra enregistr\u00e9 dans le repertoire courant et portera le nom du SeqRecord avec l'extension .fas</p>\n<pre><code>&gt;&gt;&gt; mkfas(sr1)\n</code></pre>\n<p>Cr\u00e9er plusieurs fichiers fasta mono s\u00e9quence:</p>\n<pre><code>&gt;&gt;&gt; mkfas(sr1, sr2)\n</code></pre>\n<p>Cr\u00e9er un fasta multisequence contenant plusieurs SeqRecord. Le fichier fasta serra enregistr\u00e9 dans le path indiqu\u00e9 en argument:</p>\n<pre><code>&gt;&gt;&gt; mkfasx(\"myfasta.fas\", sr1, sr2)\n</code></pre>\n<h5>Cr\u00e9er un SeqRecord et un fasta avec la fonction creat()</h5>\n<pre><code>&gt;&gt;&gt; help(creat)\nHelp on function creat in module genopy:\n\ncreat(seq_name, seq, des='', out=False)\n    Cr\u00e9ation d'un SeqRecord et d'un fasta mono s\u00e9quence\n\narguments:\n        seq_name: (str) nom de la s\u00e9quence cr\u00e9\u00e9e\n        seq: (str) ou (Seq) ou (SeqRecord) la s\u00e9quence\n        des: (str) d\u00e9scription du SeqRecord\n        out (bool): si False (d\u00e9faut) , le fasta n'est pas cr\u00e9\u00e9\n\nretrun: \n        le SeqRecord cr\u00e9\u00e9\n\n\n\n&gt;&gt;&gt; s = creat(\"un_adn\", \"ATCTCGTAGCTAGT\", des=\"human adn\", out=True)\n&gt;&gt;&gt; s\nSeqRecord(seq=Seq('ATCTCGTAGCTAGT', IUPACUnambiguousDNA()), id='un_adn', name='un_adn', description='human adn', dbxrefs=[])\n</code></pre>\n<p><a></a></p>\n<h3>Convertir des fichiers anag\u00e8ne avec l'extension .edi en fichiers fasta</h3>\n<p>On commence par importer les modules genopy et os:</p>\n<pre><code>&gt;&gt;&gt; from genopy import *\n&gt;&gt;&gt; import os\n</code></pre>\n<p>On liste les fichiers du repertoire dans lequel on se trouve (ou un autre repertoire si on indique son path en argument de listdir):</p>\n<pre><code>&gt;&gt;&gt; ld = os.listdir()\n&gt;&gt;&gt; \n&gt;&gt;&gt; ld\n['__pycache__', 'genes-Opsines.edi', 'emb.aln', 'comp.aln', 'primates.fas', 'allelesFamillechoree.edi', 'genopy.py', 'tyrfamille4.fas', 'globines-beta-vertebres.fas', 'comp.dnd', 'myfasta.fas']\n</code></pre>\n<p>On remarque ici deux fichiers en .edi\nOn utilise une boucle for pour selectionner les fichiers .edi et les convertir en .fas grace \u00e0 la fonction edi2fasta. Cette fonction attend 2 arguments: edi2fasta(file_name.edi, file_name.fas):</p>\n<pre><code>&gt;&gt;&gt; for i in ld:\n...     if i[len(i)-4:] == \".edi\":\n...             edi2fasta(i, i[:len(i)-4]+\".fas\")\n... \n&gt;&gt;&gt; \n</code></pre>\n<p>On liste \u00e0 nouveau les fichiers du repertoire:</p>\n<pre><code>&gt;&gt;&gt; os.listdir()\n['__pycache__', 'genes-Opsines.edi', 'allelesFamillechoree.fas', 'emb.aln', 'comp.aln', 'primates.fas', 'allelesFamillechoree.edi', 'genopy.py', 'genes-Opsines.fas', 'tyrfamille4.fas', 'globines-beta-vertebres.fas', 'comp.dnd', 'myfasta.fas']\n</code></pre>\n<p><a></a></p>\n<h3>Ouvrir des s\u00e9quences</h3>\n<p>Les s\u00e9quences doivent \u00eatre h\u00e9berg\u00e9es localement.</p>\n<p>On commence par rechercher les s\u00e9quences avec la fonction 'search()' :</p>\n<pre><code>&gt;&gt;&gt; from genopy import *\n&gt;&gt;&gt;\n&gt;&gt;&gt; q = search(\"Opsine\")\n&gt;&gt;&gt; \n&gt;&gt;&gt; q\n[SeqRecord(seq=Seq('ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGC...TGA', SingleLetterAlphabet()), id='gene_opsine_rouge', name='gen?e_opsine_rouge', description='gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA', dbxrefs=[]), SeqRecord(seq=Seq('ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGC...TGA', SingleLetterAlphabet()), id='gene_opsine_verte', name='gene_opsine_verte', descripti?on='gene_opsine_verte red opsin Homo sapiens opsin 1 (cone pigments), mRNA', dbxrefs=[]), SeqRecord(seq=Seq('ATGAGAAAAATGTCGGAGGAAGAGTTTTATCTGTTCAAAAATATCTCTTCAGTG...TGA', SingleLetterAlphabet()), id='gene_opsine_bleue', name='gene_opsine_bleue', description='gene_opsine_bleue Blue? opsin Homo sapiens opsin 1 (cone pigments), mRNA', dbxrefs=[])]\n</code></pre>\n<p>On obtient une liste de SeqRecord correspondant \u00e0 notre recherche.</p>\n<pre><code>&gt;&gt;&gt; len(q)\n3\n&gt;&gt;&gt; \n&gt;&gt;&gt; for i, j in enumerate(q):\n...     print(str(i) + \" \" + j.name)\n... \n0 gene_opsine_rouge\n1 gene_opsine_verte\n2 gene_opsine_bleue\n</code></pre>\n<p>On peut alors afficher la s\u00e9quence du g\u00e8ne de l'opsine verte dont l'indice dans la liste est 1 avec la fonction 'show()':</p>\n<pre><code>&gt;&gt;&gt; show(q[1])\n\n\n      ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGCTATGAG\n      ----:----|----:----|----:----|----:----|----:----|----:----|\n               10        20        30        40        50        60\n\n      GACAGCACCCAGTCCAGCATCTTCACCTACACCAACAGCAACTCCACCAGAGGCCCCTTC\n      ----:----|----:----|----:----|----:----|----:----|----:----|\n               70        80        90        100       110       120\n\n      GAAGGCCCGAATTACCACATCGCTCCCAGATGGGTGTACCACCTCACCAGTGTCTGGATG\n      ----:----|----:----|----:----|----:----|----:----|----:----|\n               130       140       150       160       170       180\n\n      ATCTTTGTGGTCATTGCATCCGTTTTCACAAATGGGCTTGTGCTGGCGGCCACCATGAAG\n      ----:----|----:----|----:----|----:----|----:----|----:----|\n               190       200       210       220       230       240\n\n      TTCAAGAAGCTGCGCCACCCGCTGAACTGGATCCTGGTGAACCTGGCGGTCGCTGACCTG\n      ----:----|----:----|----:----|----:----|----:----|----:----|\n               250       260       270       280       290       300\n\n      GCAGAGACCGTCATCGCCAGCACTATCAGCGTTGTGAACCAGGTCTATGGCTACTTCGTG\n      ----:----|----:----|----:----|----:----|----:----|----:----|\n               310       320       330       340       350       360\n</code></pre>\n<p>(la s\u00e9quence n'est pas repr\u00e9sent\u00e9e entierement dans ce tutoriel)</p>\n<h3>Transcrire, Traduire, R\u00e9tro-transcrire</h3>\n<p><a></a></p>\n<pre><code>&gt;&gt;&gt; from genopy import *\n&gt;&gt;&gt;\n&gt;&gt;&gt; q = search(\"Opsine\")\n&gt;&gt;&gt; dna = q[0]\n&gt;&gt;&gt; \n&gt;&gt;&gt; dna\nSeqRecord(seq=Seq('ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGC...TGA', SingleLetterAlphabet()), id='gene_opsine_rouge', name='gene_opsine_rouge', description='gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA', dbxrefs=[])\n</code></pre>\n<h4>Transcrire</h4>\n<pre><code>&gt;&gt;&gt; rna = transcribe(dna)\n&gt;&gt;&gt; rna\nSeqRecord(seq=Seq('AUGGCCCAGCAGUGGAGCCUCCAAAGGCUCGCAGGCCGCCAUCCGCAGGACAGC...UGA', RNAAlphabet()), id='gene_opsine_rouge.rna', name='gene_opsine_rouge.rna', description='transcription de [gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA]', dbxrefs=[])\n</code></pre>\n<p><a></a></p>\n<h4>Traduire</h4>\n<pre><code>&gt;&gt;&gt; help(translate)\nHelp on function translate in module genopy:\n\ntranslate(*seq, table_id=1, to_stop=True, stop_symbol=' ', cds=True, out=False)\nTraduction d'un ou plusieurs dna ou rna SeqRecord. \n\narguments:\n    *seq: liste de dna ou rna Seq ou SeqRecord\n    table_id: indice de la table du code g\u00e9n\u00e9tique \u00e0 utiliser (par defaut: 1 c'est le code standard)\n    to_stop: bool  True par d\u00e9faut: la traduction s'arrete au codon stop\n    stop_symbol: repr\u00e9sentation de l'arret de la traduction\n    cds: coding sequence: bool  True par d\u00e9faut: la traduction commence au condon initiateur et se termine au codon stop\n    out: bool False par d\u00e9faut. Si out == True, chaque sequence peptidique est sauvegard\u00e9e dans un fasta. \n\nreturn: proteine SeqRecord ou une liste de proteines SeqRecord\n</code></pre>\n<blockquote>\n<p>ORF: open reading frame ou phase ouverte de lecture, c'est la s\u00e9quence du brin non transcrit (brin codant) de l'adn (ou de l'arn pr\u00e9-messager) situ\u00e9e entre le premier codon initiateur jusqu'au premier codon stop</p>\n<p>CDS: coding sequence ou s\u00e9quence codante, c'est l'ORF sans les introns</p>\n</blockquote>\n<p>Il est possible de choisir la table du code g\u00e9n\u00e9tique utilis\u00e9e (par d\u00e9faut c'est le code standard)</p>\n<p>L'argument to_stop = True permet d'arreter la traduction au codon stop</p>\n<p>L'argument stop_symbol permet de sp\u00e9cifier la repr\u00e9sentation de l'arret de la traduction</p>\n<p>L'argument cds = True implique que la traduction commencera au premier codon initiateur rencontr\u00e9 et se terminera au premier codon stop rencontr\u00e9 sur le cadre de lecture. La majorit\u00e9 des s\u00e9quences import\u00e9es depuis anangene sont d\u00e9j\u00e0 des CDS, donc ca change rien; mais ce n'est pas le cas des fasta t\u00e9l\u00e9charg\u00e9s depuis les banques de s\u00e9quences.</p>\n<pre><code>&gt;&gt;&gt; pep = translate(rna)\n&gt;&gt;&gt; pep\nSeqRecord(seq=Seq('MAQQWSLQRLAGRHPQDSYEDSTQSSIFTYTNSNSTRGPFEGPNYHIAPRWVYH...SPA', ExtendedIUPACProtein()), id='gene_opsine_rouge.rna.prot', name='gene_opsine_rouge.rna.prot', description='traduction de [transcription de [gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigmen?ts), mRNA]]', dbxrefs=[])\n\n&gt;&gt;&gt; show(pep)\n\n\n      MetAlaGlnGlnTrpSerLeuGlnArgLeuAlaGlyArgHisProGlnAspSerTyrGluAspSerThrGlnSerSerIlePheThrTyr\n       -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                  10                            20                            30\n\n      ThrAsnSerAsnSerThrArgGlyProPheGluGlyProAsnTyrHisIleAlaProArgTrpValTyrHisLeuThrSerValTrpMet\n       -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                  40                            50                            60\n\n      IlePheValValThrAlaSerValPheThrAsnGlyLeuValLeuAlaAlaThrMetLysPheLysLysLeuArgHisProLeuAsnTrp\n       -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                  70                            80                            90\n\n      IleLeuValAsnLeuAlaValAlaAspLeuAlaGluThrValIleAlaSerThrIleSerIleValAsnGlnValSerGlyTyrPheVal\n       -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                  100                           110                           120\n\n      LeuGlyHisProMetCysValLeuGluGlyTyrThrValSerLeuCysGlyIleThrGlyLeuTrpSerLeuAlaIleIleSerTrpGlu\n       -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  |  -  -  -  -  :  -  -  -  -  | \n                                  130                           140                           150\n</code></pre>\n<p><a></a></p>\n<h4>R\u00e9tro transcrire</h4>\n<pre><code>&gt;&gt;&gt; rna\nSeqRecord(seq=Seq('AUGGCCCAGCAGUGGAGCCUCCAAAGGCUCGCAGGCCGCCAUCCGCAGGACAGC...UGA', RNAAlphabet()), id='gene_opsine_rouge.rna', name='gene_opsine_rouge.rna', description='transcription de [gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA]', dbxrefs=[])\n\n\n&gt;&gt;&gt; dna_c = retro_transcribe(rna)\n&gt;&gt;&gt; dna_c\nSeqRecord(seq=Seq('ATGGCCCAGCAGTGGAGCCTCCAAAGGCTCGCAGGCCGCCATCCGCAGGACAGC...TGA', DNAAlphabet()), id='gene_opsine_rouge.rna.dnac', name='gene_opsine_rouge.rna.dnac', description='retro transcription de [transcription de [gene_opsine_rouge red opsin Homo sapiens opsin 1 (cone pigments), mRNA]]', dbxrefs=[])\n\n&gt;&gt;&gt; dna.seq == dna_c.seq\nTrue\n</code></pre>\n<p><a></a></p>\n<h3>Afficher les tables du code g\u00e9n\u00e9tique</h3>\n<pre><code>&gt;&gt;&gt; from genopy import *\n&gt;&gt;&gt;\n&gt;&gt;&gt; codegen()\n\n\n1 : Standard\n2 : Vertebrate Mitochondrial\n3 : Yeast Mitochondrial\n4 : Mold Mitochondrial\n5 : Invertebrate Mitochondrial\n6 : Ciliate Nuclear\n9 : Echinoderm Mitochondrial\n10 : Euplotid Nuclear\n11 : Bacterial\n12 : Alternative Yeast Nuclear\n13 : Ascidian Mitochondrial\n14 : Alternative Flatworm Mitochondrial\n15 : Blepharisma Macronuclear\n16 : Chlorophycean Mitochondrial\n21 : Trematode Mitochondrial\n22 : Scenedesmus obliquus Mitochondrial\n23 : Thraustochytrium Mitochondrial\n24 : Pterobranchia Mitochondrial\n25 : Candidate Division SR1\n26 : Pachysolen tannophilus Nuclear\n27 : Karyorelict Nuclear\n28 : Condylostoma Nuclear\n29 : Mesodinium Nuclear\n30 : Peritrich Nuclear\n31 : Blastocrithidia Nuclear\n\n\n\n\nEntrez le num\u00e9ro de la table \u00e0 afficher: 1\n\n\nRNA table: \n\nTable 1 Standard, SGC0\n\n  |  U      |  C      |  A      |  G      |\n--+---------+---------+---------+---------+--\nU | UUU F   | UCU S   | UAU Y   | UGU C   | U\nU | UUC F   | UCC S   | UAC Y   | UGC C   | C\nU | UUA L   | UCA S   | UAA Stop| UGA Stop| A\nU | UUG L(s)| UCG S   | UAG Stop| UGG W   | G\n--+---------+---------+---------+---------+--\nC | CUU L   | CCU P   | CAU H   | CGU R   | U\nC | CUC L   | CCC P   | CAC H   | CGC R   | C\nC | CUA L   | CCA P   | CAA Q   | CGA R   | A\nC | CUG L(s)| CCG P   | CAG Q   | CGG R   | G\n--+---------+---------+---------+---------+--\nA | AUU I   | ACU T   | AAU N   | AGU S   | U\nA | AUC I   | ACC T   | AAC N   | AGC S   | C\nA | AUA I   | ACA T   | AAA K   | AGA R   | A\nA | AUG M(s)| ACG T   | AAG K   | AGG R   | G\n--+---------+---------+---------+---------+--\nG | GUU V   | GCU A   | GAU D   | GGU G   | U\nG | GUC V   | GCC A   | GAC D   | GGC G   | C\nG | GUA V   | GCA A   | GAA E   | GGA G   | A\nG | GUG V   | GCG A   | GAG E   | GGG G   | G\n--+---------+---------+---------+---------+--\n\n\n&lt;Bio.Data.CodonTable.NCBICodonTableRNA object at 0x74a047d0&gt;\n\n\n\n\n&gt;&gt;&gt; cg = codegen(1, bydna=True)\n\n\nDNA table: \n\nTable 1 Standard, SGC0\n\n  |  T      |  C      |  A      |  G      |\n--+---------+---------+---------+---------+--\nT | TTT F   | TCT S   | TAT Y   | TGT C   | T\nT | TTC F   | TCC S   | TAC Y   | TGC C   | C\nT | TTA L   | TCA S   | TAA Stop| TGA Stop| A\nT | TTG L(s)| TCG S   | TAG Stop| TGG W   | G\n--+---------+---------+---------+---------+--\nC | CTT L   | CCT P   | CAT H   | CGT R   | T\nC | CTC L   | CCC P   | CAC H   | CGC R   | C\nC | CTA L   | CCA P   | CAA Q   | CGA R   | A\nC | CTG L(s)| CCG P   | CAG Q   | CGG R   | G\n--+---------+---------+---------+---------+--\nA | ATT I   | ACT T   | AAT N   | AGT S   | T\nA | ATC I   | ACC T   | AAC N   | AGC S   | C\nA | ATA I   | ACA T   | AAA K   | AGA R   | A\nA | ATG M(s)| ACG T   | AAG K   | AGG R   | G\n--+---------+---------+---------+---------+--\nG | GTT V   | GCT A   | GAT D   | GGT G   | T\nG | GTC V   | GCC A   | GAC D   | GGC G   | C\nG | GTA V   | GCA A   | GAA E   | GGA G   | A\nG | GTG V   | GCG A   | GAG E   | GGG G   | G\n--+---------+---------+---------+---------+--\n\n\n&gt;&gt;&gt; cg.\ncg.back_table           cg.id                   cg.nucleotide_alphabet  cg.start_codons         \ncg.forward_table        cg.names                cg.protein_alphabet     cg.stop_codons          \n\n&gt;&gt;&gt; cg.start_codons\n['TTG', 'CTG', 'ATG']\n\n&gt;&gt;&gt; cg.back_table\n{'K': 'AAG', 'N': 'AAT', 'T': 'ACT', 'R': 'CGT', 'S': 'TCT', 'I': 'ATT', 'M': 'ATG', 'Q': 'CAG', 'H': 'CAT', 'P': 'CCT', 'L': 'TTG', 'E': 'GAG', 'D': 'GAT', 'A': 'GCT', 'G': 'GGT', 'V': 'GTT', 'Y': 'TAT', 'C': 'TGT', 'W': 'TGG', 'F': 'TTT', None: 'TAA'}\n\n&gt;&gt;&gt; cg.forward_table\n{'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L', 'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S', 'TAT': 'Y', 'TAC': 'Y', 'TGT': 'C', 'TGC': 'C', 'TGG': 'W', 'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L', 'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P', 'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q', 'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R', 'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M', 'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T', 'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K', 'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R', 'GTT': 'V', 'GTC': 'V',? 'GTA': 'V', 'GTG': 'V', 'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A', 'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E', 'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'}\n\n&gt;&gt;&gt; cg.forward_table[\"AAC\"]\n'N' \n</code></pre>\n<p><a></a></p>\n<h3>Comparer deux s\u00e9quences: alignement par Needle ou Water</h3>\n<p>On commence par rechercher des s\u00e9quences:</p>\n<pre><code>&gt;&gt;&gt; from genopy import *\n&gt;&gt;&gt;\n&gt;&gt;&gt; q = search(\"primates\")\n&gt;&gt;&gt; \n&gt;&gt;&gt; len(q)\n7\n&gt;&gt;&gt; \n&gt;&gt;&gt; q[0]\nSeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCA...CAT', SingleLetterAlphabet()), id='Refhumaine.adn', name='Refhumaine.adn', description=' Refhumaine.adn', dbxrefs=[])\n</code></pre>\n<p>On va ensuite comparer les s\u00e9quences 2 \u00e0 2.</p>\n<p>Il est possible de faire un alignement global (needle) ou local (water)</p>\n<pre><code>&gt;&gt;&gt; help(needle)\nHelp on function needle in module genopy:\n\nneedle(*seq, gapopen=10, gapextend=0.5, out='emb.aln')\n    Alignement global par la m\u00e9thode de Needleman\n\narguments:\n\n        seq: couple de 2 SeqRecord \u00e0 aligner\n        gapopen: p\u00e9nalit\u00e9 de gap\n        gapextend: p\u00e9nalit\u00e9 d'expansion\n        out: nom du fichier emboss cr\u00e9\u00e9\n\nreturn: un objet align\n</code></pre>\n<p>L'alignement est enregistr\u00e9 par d\u00e9faut dans le fichier emb.aln (qui serra \u00e9cras\u00e9 au prochain alignement r\u00e9alis\u00e9)</p>\n<p>Dans les 2 cas on peut eventuellement modifier les p\u00e9nalit\u00e9s pour les ouvertures ou les extensions de gap.</p>\n<pre><code>&gt;&gt;&gt; n = needle(q[0], q[1])\n&gt;&gt;&gt; \n&gt;&gt;&gt; w = water(q[0], q[1])\n&gt;&gt;&gt; \n&gt;&gt;&gt; n\n&lt;&lt;class 'Bio.Align.MultipleSeqAlignment'&gt; instance (2 records of length 365, SingleLetterAlphabet()) at 70615df0&gt;\n&gt;&gt;&gt; w\n&lt;&lt;class 'Bio.Align.MultipleSeqAlignment'&gt; instance (2 records of length 361, SingleLetterAlphabet()) at 7061def0&gt;\n</code></pre>\n<p>On obtient des objets \"align\" que l'on peut alors exploiter de diff\u00e9rentes fa\u00e7ons:</p>\n<p>Obtenir des informations de base sur l'alignement:</p>\n<pre><code>&gt;&gt;&gt; print(n)\nSingleLetterAlphabet() alignment with 2 rows and 365 columns\nTTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGAC...--- Refhumaine.adn\nTTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGT----AC...GGA Orangoutan.adn\n\n&gt;&gt;&gt; n.\nn.add_sequence(          n.append(                n.extend(                n.get_alignment_length(  \nn.annotations            n.column_annotations     n.format(                n.sort(                  \n\n&gt;&gt;&gt; n.get_alignment_length()\n365\n\n&gt;&gt;&gt; len(n)\n2\n\n&gt;&gt;&gt; n[0]\nSeqRecord(seq=Seq('TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCA...---', SingleLetterAlphabet()), id='Refhumaine.adn', name='&lt;unknown name&gt;', description='Refhumaine.adn', dbxrefs=[])\n</code></pre>\n<p>Afficher l'alignement avec les fonctions shogenix(), showanag(), (ou showgenix3() pour les s\u00e9quences peptidiques avec acides amin\u00e9s repr\u00e9sent\u00e9s \u00e0 trois lettres)</p>\n<p>L'affichage via showgenix repr\u00e9sente toutes les s\u00e9quences. Les similitudes sont symbolis\u00e9es par une * et les d\u00e9l\u00e9tions par des - .</p>\n<pre><code>&gt;&gt;&gt; showgenix(n)\n\n\n                      ************* * *********** ****** ***    **  ******   ** * \nRefhumaine.adn        TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCAACAACC\nOrangoutan.adn        TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGT----ACCGACCCATTTCCAGCG\n\n                      ----:----|----:----|----:----|----:----|----:----|----:----|\n                               10        20        30        40        50        60\n\n\n\n                      * ****************** ********** *********   **   ** **  *** \nRefhumaine.adn        G-CTATGTATTTCGTACATTACTGCCAGCCACCATGAATATTGTACGGTAC-CATAAAT-\nOrangoutan.adn        GCCTATGTATTTCGTACATTCCTGCCAGCCAACATGAATAT--CACCCAACACAACAATC\n\n                      ----:----|----:----|----:----|----:----|----:----|----:----|\n                               70        80        90        100       110       120\n</code></pre>\n<p>L'affichage via showanag utilise le m\u00eame mode de symbolisation que le logiciel anagene.</p>\n<pre><code>&gt;&gt;&gt; showanag(n)\n\n\n                      ************* * *********** ****** ***    **  ******   ** * \nRefhumaine.adn        TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCCATCAACAACC\nOrangoutan.adn        -------------G-T-----------A------C---____--CG------TTC--G-G\n\n                      ----:----|----:----|----:----|----:----|----:----|----:----|\n                               10        20        30        40        50        60\n\n\n\n                      * ****************** ********** *********   **   ** **  *** \nRefhumaine.adn        G_CTATGTATTTCGTACATTACTGCCAGCCACCATGAATATTGTACGGTAC_CATAAAT_\nOrangoutan.adn        -C------------------C----------A---------__C--CCA--A--AC---C\n\n                      ----:----|----:----|----:----|----:----|----:----|----:----|\n                               70        80        90        100       110       120\n</code></pre>\n<p>Il est aussi possible de lire l'alignement enregistr\u00e9 dans le fichier emb.aln avec la fonction reademboss()</p>\n<pre><code>&gt;&gt;&gt; n = needle(q[0], q[1])\n\n&gt;&gt;&gt; reademboss(\"emb.aln\")    # ou reademboss()\n\n########################################\n# Program: needle\n# Rundate: Sun 14 Jul 2019 11:13:59\n# Commandline: needle\n#    -outfile emb.aln\n#    -asequence seqa.fas\n#    -bsequence seqb.fas\n#    -gapopen 10\n#    -gapextend 0.5\n# Align_format: srspair\n# Report_file: emb.aln\n########################################\n\n#=======================================\n#\n# Aligned_sequences: 2\n# 1: Refhumaine.adn\n# 2: Orangoutan.adn\n# Matrix: EDNAFULL\n# Gap_penalty: 10.0\n# Extend_penalty: 0.5\n#\n# Length: 365\n# Identity:     255/365 (69.9%)\n# Similarity:   255/365 (69.9%)\n# Gaps:          40/365 (11.0%)\n# Score: 824.5\n# \n#\n#=======================================\n\nRefhumaine.ad      1 TTCTTTCATGGGGAAGCAGATTTGGGTGCCACCCAAGTATTGACTCACCC     50\n                     |||||||||||||.|.|||||||||||.||||||.|||    ||..||||\nOrangoutan.ad      1 TTCTTTCATGGGGGATCAGATTTGGGTACCACCCCAGT----ACCGACCC     46\n\nRefhumaine.ad     51 ATCAACAACCG-CTATGTATTTCGTACATTACTGCCAGCCACCATGAATA     99\n                     ||...||.|.| ||||||||||||||||||.||||||||||.||||||||\nOrangoutan.ad     47 ATTTCCAGCGGCCTATGTATTTCGTACATTCCTGCCAGCCAACATGAATA     96\n\n\n#---------------------------------------\n#---------------------------------------\n\n&lt;&lt;class 'Bio.Align.MultipleSeqAlignment'&gt; instance (2 records of length 365, SingleLetterAlphabet()) at 70603ab0&gt;\n</code></pre>\n<p>(Les alignements ne sont pas repr\u00e9sent\u00e9s en entier dans ce tutoriel)</p>\n<p>Il est possible d'afficher le % de similitudes ou de diff\u00e9rences en utilisant la fonction reademboss (comme ci dessous) ou en affichant la matrice de distance avec la fonction matrix()</p>\n<pre><code>&gt;&gt;&gt; m = matrix(n)\n&gt;&gt;&gt; print(m)\nRefhumaine.adn  0\nrangoutan.adn   0.3013698630136986      0\n                Refhumaine.adn          Orangoutan.adn\n</code></pre>\n<p><a></a></p>\n<h3>Comparaison multiple de s\u00e9quences avec Clustal</h3>\n<p>On commence par importer des s\u00e9quences:</p>\n<pre><code>&gt;&gt;&gt; from genopy import *\n&gt;&gt;&gt;\n&gt;&gt;&gt; q = search(\"tyr\")\n&gt;&gt;&gt; \n&gt;&gt;&gt; len(q)\n25\n&gt;&gt;&gt; \n&gt;&gt;&gt; q[0]\nSeqRecord(seq=Seq('ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGC...TAA', SingleLetterAlphabet()), id='Tyrcod2', name='Tyrcod2', description=\"Tyrcod2  Partie strictement codante d'un allele du gene de la tyrosinase (ref erence 2).\", dbxrefs=[])\n</code></pre>\n<p>Puis on utilise la fonction clustal: exemple ici pour comparer les s\u00e9quence d\u2019index 5, 6, 7, 8</p>\n<pre><code>&gt;&gt;&gt; c = clustal(*q[5:9])  # ou clustal(q[5], q[6], q[7], q[8])\n&gt;&gt;&gt; c\n&lt;&lt;class 'Bio.Align.MultipleSeqAlignment'&gt; instance (4 records of length 1590, SingleLetterAlphabet()) at 704f06f0&gt;\n</code></pre>\n<p>Affichage simple:</p>\n<pre><code>&gt;&gt;&gt; print(c)\nSingleLetterAlphabet() alignment with 4 rows and 1590 columns\nATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGAC...TAA F4_I2all1\nATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGAC...TAA F4_I2all2\nATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGAC...TAA F4_I1all2\nATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGAC...TAA F4_I1all1\n&gt;&gt;&gt; \n</code></pre>\n<p>M\u00e9thodes applicables \u00e0 l'objet align:</p>\n<pre><code>&gt;&gt;&gt; c.\nc.add_sequence(          c.append(                c.extend(                c.get_alignment_length(  \nc.annotations            c.column_annotations     c.format(                c.sort(                  \n</code></pre>\n<p>Affichage au format clustal:</p>\n<pre><code>&gt;&gt;&gt; print(c.format(\"clustal\"))\nCLUSTAL 2.1 multiple sequence alignment\n\n\nF4_I2all1     ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGC\nF4_I2all2     ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGC\nF4_I1all2     ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGC\nF4_I1all1     ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGC\n              **************************************************\n</code></pre>\n<p>Affichage au format phylip:</p>\n<pre><code>&gt;&gt;&gt; print(c.format(\"phylip\"))\n4 1590\nF4_I2all1  ATGCTCCTGG CTGTTTTGTA CTGCCTGCTG TGGAGTTTCC AGACCTCCGC\nF4_I2all2  ATGCTCCTGG CTGTTTTGTA CTGCCTGCTG TGGAGTTTCC AGACCTCCGC\nF4_I1all2  ATGCTCCTGG CTGTTTTGTA CTGCCTGCTG TGGAGTTTCC AGACCTCCGC\nF4_I1all1  ATGCTCCTGG CTGTTTTGTA CTGCCTGCTG TGGAGTTTCC AGACCTCCGC\n\n           TGGCCATTTC CCTAGAGCCT GTGTCTCCTC TAAGAACCTG ATGGAGAAGG\n           TGGCCATTTC CCTAGAGCCT GTGTCTCCTC TAAGAACCTG ATGGAGAAGG\n           TGGCCATTTC CCTAGAGCCT GTGTCTCCTC TAAGAACCTG ATGGAGAAGG\n           TGGCCATTTC CCTAGAGCCT GTGTCTCCTC TAAGAACCTG ATGGAGAAGG\n</code></pre>\n<p>Affichage au format genix:</p>\n<pre><code>&gt;&gt;&gt; showgenix(c)\n\n\n                 ************************************************************\nF4_I2all1        ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGCCATTTC\nF4_I2all2        ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGCCATTTC\nF4_I1all2        ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGCCATTTC\nF4_I1all1        ATGCTCCTGGCTGTTTTGTACTGCCTGCTGTGGAGTTTCCAGACCTCCGCTGGCCATTTC\n\n                 ----:----|----:----|----:----|----:----|----:----|----:----|\n                          10        20        30        40        50        60\n</code></pre>\n<p>Il est aussi possible de faire un affichage de l'alignement au format anagene avec la fonction showanag().</p>\n<p><a></a></p>\n<h4>Afficher une matrice de distances:</h4>\n<p>La fonction matrix attend un alignement (needle, water ou clustal) en argument obligatoire:</p>\n<pre><code>&gt;&gt;&gt; m = matrix(c)\n&gt;&gt;&gt; print(m)\nF4_I2all1       0\nF4_I2all2       0.0006289308176100628   0\nF4_I1all2       0.0012578616352201255   0.0006289308176100628   0\nF4_I1all1       0.0012578616352201255   0.0006289308176100628   0.0012578616352201255   0\n                F4_I2all1               F4_I2all2               F4_I1all2               F4_I1all1\n</code></pre>\n<p>La matrice peut \u00eatre convertie en table HTML et d\u00e9ploy\u00e9e sur <a href=\"https://gist.github.com/YannBouyeron/53e6d67782dcff5995754b0a7333fa0b\" rel=\"nofollow\">IPFS</a> avec la fonction matrix2ipfs:</p>\n<pre><code>&gt;&gt;&gt; matrix2ipfs(m)\n'QmcMhGpqsiCoyoPmbUf4xuX7ayMNiVHEkU44t4XMyWm2AK'\n</code></pre>\n<p>On obtient le hash du fichier HTML, consultable sur votre noeud ipfs ou via ipfs.io: <a href=\"https://ipfs.io/ipfs/\" rel=\"nofollow\">https://ipfs.io/ipfs/</a>&lt;hash&gt;:</p>\n<p><a href=\"https://ipfs.io/ipfs/QmcMhGpqsiCoyoPmbUf4xuX7ayMNiVHEkU44t4XMyWm2AK\" rel=\"nofollow\">https://ipfs.io/ipfs/QmcMhGpqsiCoyoPmbUf4xuX7ayMNiVHEkU44t4XMyWm2AK</a></p>\n<p>La matrice peut aussi \u00eatre sauvegard\u00e9e sous forme d'image png qui serra enregistr\u00e9e localement:</p>\n<pre><code>&gt;&gt;&gt; matrix2png(m, path=\"ma_matrice.png\")\n&lt;matplotlib.axes._subplots.AxesSubplot object at 0x704f0a50&gt;\n</code></pre>\n<p align=\"center\">\n  <img src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/39e613e0b9a7f4a39ad6bcb2c5e1d21cd8eac422/496d616765732f6d615f6d6174726963652e706e67\">\n</p>\n<p><a></a></p>\n<h3>Construire un arbre phylog\u00e9n\u00e9tique \u00e0 partir d'une matrice de distances</h3>\n<pre><code>&gt;&gt;&gt; from genopy import *\n&gt;&gt;&gt;\n&gt;&gt;&gt; q = search(\"tyr\")\n&gt;&gt;&gt; c = clustal(*q[5:10])\n&gt;&gt;&gt; m = matrix(c)\n\n&gt;&gt;&gt; print(m)\nF4_I2all2       0\n4_II1all1       0.0                     0\nF4_I2all1       0.0006289308176100628   0.0006289308176100628   0\nF4_I1all2       0.0006289308176100628   0.0006289308176100628   0.0012578616352201255   0\nF4_I1all1       0.0006289308176100628   0.0006289308176100628   0.0012578616352201255   0.0012578616352201255   0\n                F4_I2all2               F4_II1all1              F4_I2all1               F4_I1all2               F4_I1all1\n</code></pre>\n<p>Neighbor-joining:</p>\n<pre><code>&gt;&gt;&gt; help(tree_nj)\n\nHelp on function tree_nj in module genopy:\n\ntree_nj(dm)\n    Cr\u00e9ation d'un arbre nj \u00e0 partir de la matrice de distance retourn\u00e9e par la fonction matrix\n    return: tree\n\n\n\n&gt;&gt;&gt; nj = tree_nj(m)\n\n\n , F4_I2all2\n |\n | F4_II1all1\n |\n |_________________________________________________________________ F4_I2all1\n_|\n |_________________________________________________________________ F4_I1all2\n |\n |_________________________________________________________________ F4_I1all1\n\n\n&gt;&gt;&gt; nj\nTree(rooted=True)\n</code></pre>\n<p>UPGMA:</p>\n<pre><code>&gt;&gt;&gt; help(tree_upgma)\n\nHelp on function tree_upgma in module genopy:\n\ntree_upgma(dm)\n    Cr\u00e9ation d'un arbre upgma \u00e0 partir de la matrice de distance retourn\u00e9e par la fonction matrix\n    return: tree\n\n\n&gt;&gt;&gt; up = tree_upgma(m)\n\n\n  _________________________________________________________________ F4_I2all1\n_|\n |         ________________________________________________________ F4_I1all2\n |________|\n          |                   _____________________________________ F4_I1all1\n          |__________________|\n                             |                                     , F4_II1all1\n                             |_____________________________________|\n                                                                   | F4_I2all2\n</code></pre>\n<p>Parcimonie:</p>\n<pre><code>&gt;&gt;&gt; help(parsimony_tree)\n\nHelp on function parsimony_tree in module genopy:\n\nparsimony_tree(align, starting_tree)\n    Cr\u00e9ation d'un arbre bas\u00e9 sur la m\u00e9thode de parcimonie \u00e0 partir de l'alignement et d'un arbre de d\u00e9part (nj)\n\narguments:\n        align: objet align retourn\u00e9 par clustal()\n        satrting_tree: objet tree retourn\u00e9 par tree_nj()\n\nreturn: tree\n\n\n&gt;&gt;&gt; pa = parsimony_tree(c, nj)\n\n\n  _________________________________________________________________ F4_I2all1\n |\n , F4_II1all1\n |\n | F4_I2all2\n_|\n |_________________________________________________________________ F4_I1all1\n |\n |_________________________________________________________________ F4_I1all2\n</code></pre>\n<p>Pour afficher les distances sur les branches de l'arbre:</p>\n<pre><code> &gt;&gt;&gt; nj = tree_nj(m)\n\n &gt;&gt;&gt; dnj = draw_tree(nj, distance=True)\n</code></pre>\n<p><a></a></p>\n<h3>Construire un arbre phylog\u00e9n\u00e9tique \u00e0 partir d'une liste de s\u00e9quences</h3>\n<pre><code>&gt;&gt;&gt; from genopy import *\n&gt;&gt;&gt;\n&gt;&gt;&gt; q = search(\"tyr\")\n&gt;&gt;&gt; \n&gt;&gt;&gt; len(q)\n25\n&gt;&gt;&gt; \n&gt;&gt;&gt; help(phylo)\n\nHelp on function phylo in module genopy:\n\nphylo(*seq, out='comp.aln')\n    M\u00e9thode simplifi\u00e9e de cr\u00e9ation d'un arbre phylog\u00e9n\u00e9tique \u00e0 partir d'une liste de SeqRecord\n\n        argument: *seq: liste de SeqRecord \u00e0 aligner\n        return: (align, stdout, tree)\n\n\n&gt;&gt;&gt; p = phylo(*q[3:7])\n\n\n           Tyralb_TS  F4_I1all2  Tyralb_A5  F4_I1all1\nTyralb_TS   0.000000   0.000000   0.001887   0.001258\nF4_I1all2   0.000000   0.000000   0.001887   0.001258\nTyralb_A5   0.001887   0.001887   0.000000   0.000629\nF4_I1all1   0.001258   0.001258   0.000629   0.000000\n\n\n\n\n                                               ______________________ Tyralb_A5\n  ____________________________________________|\n |                                            | F4_I1all1\n_|\n | Tyralb_TS\n |\n | F4_I1all2\n</code></pre>\n\n          </div>"}, "last_serial": 5548059, "releases": {"0.0.2": [{"comment_text": "", "digests": {"md5": "815e1c5cb6ea3b1be8df4e6ca26ee42e", "sha256": "7eafccef2038ec0a6bc0d736d3045bccaa2b098874a8d889521c22143392c045"}, "downloads": -1, "filename": "genopy-0.0.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "815e1c5cb6ea3b1be8df4e6ca26ee42e", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.4", "size": 32866, "upload_time": "2019-07-17T22:48:25", "upload_time_iso_8601": "2019-07-17T22:48:25.199217Z", "url": "https://files.pythonhosted.org/packages/cc/41/b6796e9ab1a3537f1e9e8d51aba4d12f370a2a7a64e7d859b99587173f81/genopy-0.0.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "910a95d16c2fe612edccdbe22d224148", "sha256": "d736f4cae8230b560f1b0d038f9e24c77c3e316de97eb57bd5e40ee7b30d9d7b"}, "downloads": -1, "filename": "genopy-0.0.2.tar.gz", "has_sig": false, "md5_digest": "910a95d16c2fe612edccdbe22d224148", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 42972, "upload_time": "2019-07-17T22:48:29", "upload_time_iso_8601": "2019-07-17T22:48:29.297738Z", "url": "https://files.pythonhosted.org/packages/26/f4/574ecb8294b8bb811b99114647c1187ae32dbf99899a324be662230031ba/genopy-0.0.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "815e1c5cb6ea3b1be8df4e6ca26ee42e", "sha256": "7eafccef2038ec0a6bc0d736d3045bccaa2b098874a8d889521c22143392c045"}, "downloads": -1, "filename": "genopy-0.0.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "815e1c5cb6ea3b1be8df4e6ca26ee42e", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": ">=3.4", "size": 32866, "upload_time": "2019-07-17T22:48:25", "upload_time_iso_8601": "2019-07-17T22:48:25.199217Z", "url": "https://files.pythonhosted.org/packages/cc/41/b6796e9ab1a3537f1e9e8d51aba4d12f370a2a7a64e7d859b99587173f81/genopy-0.0.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "910a95d16c2fe612edccdbe22d224148", "sha256": "d736f4cae8230b560f1b0d038f9e24c77c3e316de97eb57bd5e40ee7b30d9d7b"}, "downloads": -1, "filename": "genopy-0.0.2.tar.gz", "has_sig": false, "md5_digest": "910a95d16c2fe612edccdbe22d224148", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.4", "size": 42972, "upload_time": "2019-07-17T22:48:29", "upload_time_iso_8601": "2019-07-17T22:48:29.297738Z", "url": "https://files.pythonhosted.org/packages/26/f4/574ecb8294b8bb811b99114647c1187ae32dbf99899a324be662230031ba/genopy-0.0.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:58:15 2020"}