{"info": {"author": "Renaud Parent", "author_email": "renaud.parent@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Framework :: Django", "Framework :: Django :: 1.10", "Framework :: Django :: 1.8", "Framework :: Django :: 1.9", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Natural Language :: English", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Topic :: Software Development :: Libraries :: Application Frameworks"], "description": "=============================\ndjango-lock-tokens\n=============================\n\n.. image:: https://badge.fury.io/py/django-lock-tokens.svg\n    :target: https://badge.fury.io/py/django-lock-tokens\n\n.. image:: https://travis-ci.org/rparent/django-lock-tokens.svg?branch=master\n    :target: https://travis-ci.org/rparent/django-lock-tokens\n\n.. image:: https://codecov.io/gh/rparent/django-lock-tokens/branch/master/graph/badge.svg\n    :target: https://codecov.io/gh/rparent/django-lock-tokens\n\ndjango-lock-tokens is a Django application that provides a locking mechanism to prevent concurrency editing.\n\nIt is not user-based nor session-based, it is just token based. When you lock a resource, you are given a token string with an expiration date, and you will need to provide this token to unlock that resource.\n\nThe application provides some useful functions to handle this token mechanism with sessions if you want to, and a REST API (with a javascript client for it) to deal with lock tokens without sessions.\n\n\nHere is a non exhaustive list of the features coming with this token-based approach, to help you choose ``django-lock-tokens`` (or not!) over other concurrent edition preventing solutions:\n\n- No need to modify your models to use the locking mechanism : you don't \"pollute\" your datamodel with \"non-data\" fields. This also means you can use the locking mechanism on third party models that cannot be modified\n- No need to use sessions (but you can still use it if you want to)\n- Ability to check if an object is locked BEFORE trying to modify it\n- Rest API (+ javascript client to use it) out-of-the-box\n- Admin interface integration\n\n\nTable of Contents\n-----------------\n\n1. `Requirements`_\n2. `Install`_\n3. `TL;DR`_\n4. `How it works`_\n5. `LockableModel proxy`_\n6. `LockableModelAdmin for admin interface`_\n7. `Session-based usage: lock_tokens.sessions module`_\n8. `Session-based usage: lock_tokens.decorators module`_\n9. `REST API`_\n10. `REST API Javascript client`_\n11. `Settings`_\n12. `Tests`_\n\n\nRequirements\n------------\n\n* Python (2.7, 3.3, 3.4, 3.5)\n* Django (1.8, 1.9, 1.10, 1.11, 2.0, 2.1)\n\n\nInstall\n-------\n\n1. Run ``pip install django-lock-tokens``\n\n2. Add ``lock_tokens`` to your ``INSTALLED_APPS`` setting. As django-lock-tokens uses the ``contenttypes`` framework, make sure it is also available in your ``INSTALLED_APPS`` setting:\n\n.. code:: python\n\n    INSTALLED_APPS = [\n        ...\n        'django.contrib.contenttypes',\n        ...\n        'lock_tokens.apps.LockTokensConfig',\n    ]\n\n3. Run ``python manage.py migrate`` from the root of your django project to install the lock tokens model.\n\n4. If you want to use the ``LockableAdmin`` and all the session-based functionalities, make sure you have enabled a session middleware in your settings, for example:\n\n.. code:: python\n\n    MIDDLEWARE_CLASSES = (\n        ...\n        'django.contrib.sessions.middleware.SessionMiddleware',\n        ...\n    )\n\n5. If you want to use the REST API, include ``lock_tokens.urls`` with the correct namespace in your ``urls.py`` like this (it is mandatory if you want to use the ``LockableModelAdmin``):\n\n.. code:: python\n\n    urlpatterns = [\n      ...\n      url(r'^lock_tokens/', include('lock_tokens.urls', namespace='lock-tokens')),\n      ...\n    ]\n\nTL;DR\n-----\n\nAfter having completed previous steps, using the locking mechanism in your views is as simple as this:\n\n.. code:: python\n\n    from django.http import HttpResponseForbidden\n    from lock_tokens.exceptions import AlreadyLockedError, UnlockForbiddenError\n    from lock_tokens.sessions import check_for_session, lock_for_session, unlock_for_session\n\n    from my_app.models import MyModel\n\n\n    def view_with_object_edition(request):\n        \"\"\"This view locks the instance of MyModel that is to be edited.\"\"\"\n        # Get MyModel instance:\n        obj = MyModel.objects.get(...)\n        try:\n            lock_for_session(obj, request.session)\n        except AlreadyLockedError:\n            return HttpResponseForbidden(\"This resource is locked, sorry !\")\n        # ... Do stuff\n        return render(...)\n\n\n    def view_that_saves_object(request):\n        \"\"\"This view locks the instance of MyModel that is to be edited.\"\"\"\n        # Get MyModel instance:\n        obj = MyModel.objects.get(...)\n        if not check_for_session(obj, request.session):\n            return HttpResponseForbidden(\"Cannot modify the object, you don't have the lock.\")\n        # ... Do stuff\n        unlock_for_session(obj, request.session)\n        return render(...)\n\n\nOr use it directly in your Django templates to handle locking on the client side::\n\n    {% load lock_tokens_tags %}\n    {% lock_tokens_api_client %}\n    ...\n    <script type=\"text/javascript\">\n        window.addEventListener('lock_tokens.clientready', function () {\n            LockTokens.lock(...);\n            ...\n            LockTokens.unlock(...);\n        });\n    </script>\n\nHow it works\n------------\n\nTo avoid concurrency editing, ``django-lock-tokens`` provides some interfaces to lock and check lock on any model instance before changing it (including third party model instances).\nThis is handled via an internal model (``LockToken``). There can be only one ``LockToken`` instance per model instance.\n\nThe lock token lifecycle is the following:\n\n  1. When a lock is created for an object by an entity, it is valid for a certain amount of time. The entity is given a **lock token key** (a string) that it must hold to perform actions with valid lock required. A new ``LockToken`` instance is created in database, after having deleted a potential expired instance in database.\n  2. If the entity that holds the lock token key no longer needs the lock on the object, it can unlock this object by providing the lock token key. The ``LockToken`` instance is then removed from database.\n  3. The entity that holds the lock token key can also renew the lock token by providing the lock token key.\n  4. If the lock token is not renewed until the expiration time, it becomes expired, but stays in database until a new lock is created on this instance (or the entity that holds the lock token key deletes it).\n\nSo to use this mechanism correctly, you should **require** a valid lock token key and renew the lock in any method where an object is saved and you want to prevent concurrency editing. Based on the 4 previous points, we can see that there can be 3 cases for a lock token key:\n\n  1. The lock token key has a corresponding lock token in database, and it has not expired.\n  2. The lock token key has a corresponding lock token in database, but it has expired.\n  3. The lock token key has no correponding lock token in database for the object.\n\nFor case 1, it is ok to save the object and then unlock the object by deleting the lock token. The token key is still **VALID**.\n\nFor case 2, the lock has expired but no other entity has created a lock on the object in the meantime. So it is still ok to save the object as it will not overwrite any changes. The token key is still **VALID**.\n\nIn case 3, it means that the lock token created by the entity has expired, and that another entity has taken a lock on the object in the meantime and could have done some changes on it. So it is not ok to save changes. The token key is **INVALID**.\n\nHere is an example to understand the case 3:\n\n  1. Alice takes a lock on an object and opens up its editing interface. *A ``LockToken`` instance ``lt1`` is created in database, and Alice is given a lock token key*\n  2. Alice walks away from her computer, the lock expires. *``lt1`` is still in database*\n  3. Bob takes a lock on the same object. *``lt1`` is deleted from database, and a new ``LockToken`` instance ``lt2`` is created*\n  4. Bob edits the object in the interface, clicks save. The object is modified and the lock is released. *``lt2`` is deleted. The object has no longer any lock in database*\n  5. Alice returns, clicks save. The lock token key she holds has become invalid, so she gets an error.\n\nThis example shows how it is important to require a **VALID** lock token key to prevent concurrency editing.\n\n``LockableModel`` proxy\n-----------------------\n\nTo make one of your models lockable, use the ``LockableModel`` class. ``LockableModel`` is just a Django proxy model, which simply provides additional locking methods to your models.\n\nSo you can either make your models inherit from ``LockableModel``:\n\n.. code:: python\n\n    from lock_tokens.models import LockableModel\n\n    class MyModel(LockableModel):\n        ...\n\n    obj = MyModel.get(...)\n    token = obj.lock()\n\n\nor you can simply use it as a proxy on a given model instance:\n\n.. code:: python\n\n    from lock_tokens.models import LockableModel\n\n    from my_app.models import MyModel\n\n    obj = MyModel.get(...)\n    token = LockableModel.lock(obj)\n\n\nThis can be useful if you don't want to expose the locking methods for your models everywhere, or if you want to lock resources that come from a third party application.\n\nNote that as ``LockableModel`` is just a proxy model, make your models inherit from it won't change their fields so there will be no additional migrations required.\n\nAdditionally, if your model inherits from ``LockableModel``, the ``objects`` Manager has a specific method that allows you to get and lock a model like so:\n\n.. code:: python\n\n    >>>obj, token = MyModel.get_and_lock(...<usual get arguments>)\n\nIf you already overrided the default ``objects`` manager with a custom one and that you want to get this method available, make your custom manager inherit from ``lock_tokens.managers.LockableModelManager``.\n\n\n``LockableModel.lock(self, token=None)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nLocks the given object, or renew existing lock if the token parameter is provided.\n\nReturns a ``dict`` containing a token a its expiration date.\n\nRaises a ``lock_tokens.exceptions.AlreadyLockedError`` if the resource is already locked, and a ``lock_tokens.exceptions.InvalidToken`` if the specified token is invalid.\n\nExample:\n\n.. code:: python\n\n    def test(myObject):\n        try:\n            token = myObject.lock()\n        except AlreadyLockedError:\n            print \"This object is already locked\"\n        return token\n\n\n    >>>token = test(obj)\n    {\"token\": \"9692ac52a27a40308b82b49b77357c97\", \"expires\": \"2016-06-23 09:48:06\"}\n    >>>test(obj)\n    \"This object is already locked\"\n    >>>test(obj, token['token'])\n    {\"token\": \"9692ac52a27a40308b82b49b77357c97\", \"expires\": \"2016-06-23 09:48:26\"}\n\n\n``LockableModel.unlock(self, token)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUnlocks the given object if the provided token is correct.\n\nRaises a ``lock_tokens.exceptions.UnlockForbiddenError``\n\n``LockableModel.is_locked(self)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns a boolean that indicates whether the given object is currently locked or not.\n\n``LockableModel.check_lock(self, token)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nReturns a boolean that indicates if the given token is valid for this object. Will also return ``True`` with a warning if the object is not locked (lock expired or no lock).\n\n\n``LockableModelAdmin`` for admin interface\n------------------------------------------\n\nIf you want to make the admin interface lock-aware, and lock objects that are edited,\nsimply make your ``ModelAdmin`` class inherit from ``LockableModelAdmin``:\n\n.. code:: python\n\n    from lock_tokens.admin import LockableModelAdmin\n    from django.contrib import admin\n\n    from my_app.models import MyModel\n\n    class MyModelAdmin(LockableModelAdmin):\n        ...\n\n    admin.site.register(MyModel, MyModelAdmin)\n\n\nWith this, when accessing a given instance of ``MyModel`` from the admin interface,\nit will check that the instance is not locked. If it is not, it will lock it. If it is,\nthen there will be a warning message displayed to inform that the object cannot be edited,\nand the saving buttons will not appear. And if despite this, the change form is sent, it will raise a ``PermissionDenied`` exception so you will get a HTTP 403 error.\n\nOverrinding `change_form_template` in `LockableModelAdmin`\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nIf you want to override the `change_form_template`, but still make sure the lock will be released when leaving the page without saving, don't forget to add the `admin_lock_handler` template tag. This template tag needs 4 arguments: the application name of the object, the model name of the object, the object id and the lock token key. So don't forget to add those (especially the lock token) into your template context if you also override the `change_view` method.\n\nExample to add the template tag to your custom template if you don't override `change_view`:\n\n.. code:: html\n\n    ...\n    {% load lock_tokens_tags %}\n    ...\n    {% if lock_token %}\n      {% admin_lock_handler opts.app_label opts.model_name original.id lock_token %}\n    {% endif %}\n\n\n\n\nSession-based usage: ``lock_tokens.sessions`` module\n----------------------------------------------------\n\nIn most cases, it will be the easiest way to deal with lock tokens, as you won't need to handle them at all.\n\n``lock_for_session(obj, session, force_new=False)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nLock an object in the given session. This function will try to lock the object,\nand if it succeeds, it will hold the token value in a session variable.\n\nThere is a `force_new` optional parameter that you can set to `True` if you want to force a new lock generation without using a potentially existing token key stored in session. This is to be used with caution (i.e. exclusively in methods that only read the object, not in methods that save it) as it could lead to a potential overwriting if the session holds an invalid token.\nTo sum up: do not set this parameter to `True` unless you are sure of what you are doing!\n\nRaises a ``lock_tokens.exceptions.AlreadyLockedError`` if the resource is already locked, and a ``lock_tokens.exceptions.InvalidToken`` error if the session holds an invalid token.\n\n``unlock_for_session(obj, session)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUnlocks an object in the given session.\n\nRaises a ``lock_tokens.exceptions.UnlockForbiddenError`` if the session does not hold the lock on the object.\n\n``check_for_session(obj, session)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nCheck if an object has a valid lock in the given session.\n\nReturns ``True`` if the session holds a valid lock (even if it has expired), and ``False`` if the session holds an invalid lock or no lock.\n\nSession-based usage: ``lock_tokens.decorators`` module\n------------------------------------------------------\n\nThis module provides view decorators for common use cases.\n\n``locks_object(model, get_object_id_callable)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nLocks an object before executing view, and keep lock token in the request session. Does not unlock it when the view returns.\n\nArguments:\n\n- ``model``: the concerned django Model\n- ``get_object_id_callable``: a callable that will return the concerned object id based on the view arguments\n\nExample:\n\n.. code:: python\n\n    from lock_tokens.decorators import locks_object\n\n    @locks_object(MyModel, lambda request: request.GET.get('my_model_id'))\n    def myview(request):\n        # In this example the view will lock the MyModel instance with the id\n        # provided in the request GET parameter my_model_id\n        ...\n\n    @locks_object(MyModel, lambda request, object_id: object_id)\n    def anotherview(request, object_id):\n        # In this example the view will lock the MyModel instance with the id\n        # provided as the second view argument\n        ...\n\n\n``holds_lock_on_object(model, get_object_id_callable)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nLocks an object before executing view, and keep lock token in the request session. Hold lock until the view is finished executing, then release it.\n\nArguments:\n\n- ``model``: the concerned django Model\n- ``get_object_id_callable``: a callable that will return the concerned object id based on the view arguments\n\nSee examples for ``locks_object``.\n\n\nREST API\n--------\n\nIf you want to use locking mechanism from outside your views, there is a simple HTTP API to handle tokens. It does not use sessions at all, so you need to handle the tokens yourself in this case.\n\nHere are the different entry points, where ``<app_label>`` is the name of the application of the concerned model, ``<model>`` is the name of the model, ``<object_id>`` is the id of the cmodel instance, and ``<token>`` is the lock token value.\n\n*POST* ``/lock_tokens/<app_label>/<model>/<object_id>/``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nLocks object. Returns a JSON response with \"token\" and \"expires\" keys.\n\nReturns a 404 HTTP error if the object could not be found.\n\nReturns a 403 HTTP error if the object is already locked.\n\n*GET* ``/lock_tokens/<app_label>/<model>/<object_id>/<token>/``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nReturns a JSON response with \"token\" and \"expires\" keys.\n\nReturns a 404 HTTP error if the object could not be found.\n\nReturns a 403 HTTP error if the token is incorrect.\n\n*PATCH* ``/lock_tokens/<app_label>/<model>/<object_id>/<token>/``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nRenews the lock on the object. Returns a JSON response with \"token\" and \"expires\" keys.\n\nReturns a 404 HTTP error if the object could not be found.\n\nReturns a 403 HTTP error if the token is incorrect.\n\n*DELETE* ``/lock_tokens/<app_label>/<model>/<object_id>/<token>/``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nUnlocks object.\n\nReturns a 404 HTTP error if the object could not be found.\n\nReturns a 403 HTTP error if the token is incorrect.\n\n\nREST API Javascript client\n--------------------------\n\nThe application includes a javascript client to interact with the API. To enable it, simply add the following lines to your template, somewhere in the ``<body>`` section ::\n\n\n    {% load lock_tokens_tags %}\n    {% lock_tokens_api_client %}\n\nDon't forget to include the REST API urls with the correct namespace as described in section 1, otherwise it won't work.\n\nAdding those lines in your template will create a variable named ``LockTokens``, and emit a ``lock_tokens.clientready`` event when it is available in the javascript scope. This object has the following methods (parameters are self-describing):\n\n``LockTokens.lock(app_label, model, object_id, callback)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nLocks the corresponding object. When the call to the API is completed, calls the ``callback`` method with a ``lock_tokens.Token`` instance as an argument, or ``null`` if the API request failed.\n\nNB: The ``LockTokens`` handles the tokens for you, so you don't need to read API responses and/or store tokens yourself.\n\n``LockTokens.register_existing_lock_token(app_label, model, object_id, token_string, callback)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAdd an existing token to the ``LockTokens`` registry. This method is useful for example when you want to handle on client side a lock that has been set on the server side. You must provide the token string in addition to other parameters, the client will make a call to the API to ensure the token is valid and get its expiration date. Calls the ``callback`` method with a ``lock_tokens.Token`` instance as an argument, or ``null`` if the registration failed.\n\n``LockTokens.unlock(app_label, model, object_id, callback)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nLocks the corresponding object. When the call to the API is completed, calls the ``callback`` method with a boolean that indicates whether the API request has succeeded. Note that this method can be called only on an object that has been locked or registered as locked by the ``LockTokens`` object.\n\n``LockTokens.hold_lock(app_label, model, object_id)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nHolds a lock on the corresponding object. It is like the ``lock`` method, except it renews the token each time it is about to expire. A call to ``unlock`` will stop the lock holding.\n\n\n``LockTokens.clear_all_locks(callback)``\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nUnlocks all registered objects. Calls ``callback`` with no arguments when unlocking of every objects is done.\n\n\nSettings\n--------\n\nYou can override ``lock_token`` default settings by adding a ``dict`` named ``LOCK_TOKENS`` to your ``settings.py`` like so:\n\n.. code:: python\n\n    LOCK_TOKENS = {\n        'API_CSRF_EXEMPT': True,\n        'DATEFORMAT': \"%Y%m%d%H%M%S\",\n        'TIMEOUT': 60,\n    }\n\n\nTIMEOUT\n^^^^^^^\n\nThe validity duration for a lock token in seconds. Defaults to ``3600`` (one hour).\n\nDATEFORMAT\n^^^^^^^^^^\n\nThe format of the expiration date returned in the token ``dict``. Defaults to ``\"%Y-%m-%d %H:%M:%S %Z\"``\n\nAPI_CSRF_EXEMPT\n^^^^^^^^^^^^^^^\n\nA boolean that indicates whether to deactivate CSRF checks on the API views or not. Defaults to ``False``.\n\nTests\n-----\n\nTo run tests simply run from the root of the repository:\n\n::\n\n    source <YOURVIRTUALENV>/bin/activate\n    (myenv) $ pip install tox\n    (myenv) $ tox\n\n\nCredits\n-------\n\nTools used in rendering this package:\n\n*  Cookiecutter_\n*  `cookiecutter-djangopackage`_\n\n.. _Cookiecutter: https://github.com/audreyr/cookiecutter\n.. _`cookiecutter-djangopackage`: https://github.com/pydanny/cookiecutter-djangopackage\n\n\n\n\nHistory\n-------\n\n0.2.5 (2019-02-07)\n^^^^^^^^^^^^^^^^^^\n\n- Fix issue #10_\n\n.. _10: https://github.com/rparent/django-lock-tockens/issues/10\n\n0.2.4 (2018-11_30)\n^^^^^^^^^^^^^^^^^^\n- The HTTP API endpoint to get token information now returns the token information even when it has expired, because it is still valid to use (see this_)\n\n.. _this: https://github.com/rparent/django-lock-tokens#how-it-works\n\n0.2.3 (2018-10-31)\n^^^^^^^^^^^^^^^^^^\n- Fixes ``LockableModel`` for Python 2.7\n\n0.2.2 (2018-10-31)\n^^^^^^^^^^^^^^^^^^\n- Fixes ``LockableModel`` to allow to use it as a proxy\n\n0.2.1 (2018-10-04)\n^^^^^^^^^^^^^^^^^^\n- Fixes ``LockToken.save`` method to prevent potential transaction errors\n- Adds a template tag to handle lock on the client side when overriding default ``change_form_template`` in ``LockableModelAdmin``\n- Better handling of invalid lock token strings (see discussion here_) to prevent overwriting\n\n.. _here: https://github.com/rparent/django-lock-tokens/issues/6\n\n0.1.4 (2017-09-07)\n^^^^^^^^^^^^^^^^^^\n\n- Adds a ``created`` field to the ``LockToken`` model", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/rparent/django-lock-tokens", "keywords": "django-lock-tokens", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "django-lock-tokens", "package_url": "https://pypi.org/project/django-lock-tokens/", "platform": "", "project_url": "https://pypi.org/project/django-lock-tokens/", "project_urls": {"Homepage": "https://github.com/rparent/django-lock-tokens"}, "release_url": "https://pypi.org/project/django-lock-tokens/0.2.5/", "requires_dist": null, "requires_python": "", "summary": "A Django application that provides a locking mechanism to prevent concurrency editing.", "version": "0.2.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            <a href=\"https://badge.fury.io/py/django-lock-tokens\" rel=\"nofollow\"><img alt=\"https://badge.fury.io/py/django-lock-tokens.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/602ce7b1193157f5aa4ab16ee42647fc264eee3b/68747470733a2f2f62616467652e667572792e696f2f70792f646a616e676f2d6c6f636b2d746f6b656e732e737667\"></a>\n<a href=\"https://travis-ci.org/rparent/django-lock-tokens\" rel=\"nofollow\"><img alt=\"https://travis-ci.org/rparent/django-lock-tokens.svg?branch=master\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/9214932cecb1ed80ab55d5782284cbc80111d16c/68747470733a2f2f7472617669732d63692e6f72672f72706172656e742f646a616e676f2d6c6f636b2d746f6b656e732e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://codecov.io/gh/rparent/django-lock-tokens\" rel=\"nofollow\"><img alt=\"https://codecov.io/gh/rparent/django-lock-tokens/branch/master/graph/badge.svg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/22e0052258b83efad9a5bf52c549a6be2ac30459/68747470733a2f2f636f6465636f762e696f2f67682f72706172656e742f646a616e676f2d6c6f636b2d746f6b656e732f6272616e63682f6d61737465722f67726170682f62616467652e737667\"></a>\n<p>django-lock-tokens is a Django application that provides a locking mechanism to prevent concurrency editing.</p>\n<p>It is not user-based nor session-based, it is just token based. When you lock a resource, you are given a token string with an expiration date, and you will need to provide this token to unlock that resource.</p>\n<p>The application provides some useful functions to handle this token mechanism with sessions if you want to, and a REST API (with a javascript client for it) to deal with lock tokens without sessions.</p>\n<p>Here is a non exhaustive list of the features coming with this token-based approach, to help you choose <tt><span class=\"pre\">django-lock-tokens</span></tt> (or not!) over other concurrent edition preventing solutions:</p>\n<ul>\n<li>No need to modify your models to use the locking mechanism : you don\u2019t \u201cpollute\u201d your datamodel with \u201cnon-data\u201d fields. This also means you can use the locking mechanism on third party models that cannot be modified</li>\n<li>No need to use sessions (but you can still use it if you want to)</li>\n<li>Ability to check if an object is locked BEFORE trying to modify it</li>\n<li>Rest API (+ javascript client to use it) out-of-the-box</li>\n<li>Admin interface integration</li>\n</ul>\n<div id=\"table-of-contents\">\n<h2>Table of Contents</h2>\n<ol>\n<li><a href=\"#requirements\" rel=\"nofollow\">Requirements</a></li>\n<li><a href=\"#install\" rel=\"nofollow\">Install</a></li>\n<li><a href=\"#tl-dr\" rel=\"nofollow\">TL;DR</a></li>\n<li><a href=\"#how-it-works\" rel=\"nofollow\">How it works</a></li>\n<li><a href=\"#lockablemodel-proxy\" rel=\"nofollow\">LockableModel proxy</a></li>\n<li><a href=\"#lockablemodeladmin-for-admin-interface\" rel=\"nofollow\">LockableModelAdmin for admin interface</a></li>\n<li><a href=\"#session-based-usage-lock-tokens-sessions-module\" rel=\"nofollow\">Session-based usage: lock_tokens.sessions module</a></li>\n<li><a href=\"#session-based-usage-lock-tokens-decorators-module\" rel=\"nofollow\">Session-based usage: lock_tokens.decorators module</a></li>\n<li><a href=\"#rest-api\" rel=\"nofollow\">REST API</a></li>\n<li><a href=\"#rest-api-javascript-client\" rel=\"nofollow\">REST API Javascript client</a></li>\n<li><a href=\"#settings\" rel=\"nofollow\">Settings</a></li>\n<li><a href=\"#tests\" rel=\"nofollow\">Tests</a></li>\n</ol>\n</div>\n<div id=\"requirements\">\n<h2>Requirements</h2>\n<ul>\n<li>Python (2.7, 3.3, 3.4, 3.5)</li>\n<li>Django (1.8, 1.9, 1.10, 1.11, 2.0, 2.1)</li>\n</ul>\n</div>\n<div id=\"install\">\n<h2>Install</h2>\n<ol>\n<li>Run <tt>pip install <span class=\"pre\">django-lock-tokens</span></tt></li>\n<li>Add <tt>lock_tokens</tt> to your <tt>INSTALLED_APPS</tt> setting. As django-lock-tokens uses the <tt>contenttypes</tt> framework, make sure it is also available in your <tt>INSTALLED_APPS</tt> setting:</li>\n</ol>\n<pre><span class=\"n\">INSTALLED_APPS</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"o\">...</span>\n    <span class=\"s1\">'django.contrib.contenttypes'</span><span class=\"p\">,</span>\n    <span class=\"o\">...</span>\n    <span class=\"s1\">'lock_tokens.apps.LockTokensConfig'</span><span class=\"p\">,</span>\n<span class=\"p\">]</span>\n</pre>\n<ol>\n<li>Run <tt>python manage.py migrate</tt> from the root of your django project to install the lock tokens model.</li>\n<li>If you want to use the <tt>LockableAdmin</tt> and all the session-based functionalities, make sure you have enabled a session middleware in your settings, for example:</li>\n</ol>\n<pre><span class=\"n\">MIDDLEWARE_CLASSES</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n    <span class=\"o\">...</span>\n    <span class=\"s1\">'django.contrib.sessions.middleware.SessionMiddleware'</span><span class=\"p\">,</span>\n    <span class=\"o\">...</span>\n<span class=\"p\">)</span>\n</pre>\n<ol>\n<li>If you want to use the REST API, include <tt>lock_tokens.urls</tt> with the correct namespace in your <tt>urls.py</tt> like this (it is mandatory if you want to use the <tt>LockableModelAdmin</tt>):</li>\n</ol>\n<pre><span class=\"n\">urlpatterns</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n  <span class=\"o\">...</span>\n  <span class=\"n\">url</span><span class=\"p\">(</span><span class=\"sa\">r</span><span class=\"s1\">'^lock_tokens/'</span><span class=\"p\">,</span> <span class=\"n\">include</span><span class=\"p\">(</span><span class=\"s1\">'lock_tokens.urls'</span><span class=\"p\">,</span> <span class=\"n\">namespace</span><span class=\"o\">=</span><span class=\"s1\">'lock-tokens'</span><span class=\"p\">)),</span>\n  <span class=\"o\">...</span>\n<span class=\"p\">]</span>\n</pre>\n</div>\n<div id=\"tl-dr\">\n<h2>TL;DR</h2>\n<p>After having completed previous steps, using the locking mechanism in your views is as simple as this:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">django.http</span> <span class=\"kn\">import</span> <span class=\"n\">HttpResponseForbidden</span>\n<span class=\"kn\">from</span> <span class=\"nn\">lock_tokens.exceptions</span> <span class=\"kn\">import</span> <span class=\"n\">AlreadyLockedError</span><span class=\"p\">,</span> <span class=\"n\">UnlockForbiddenError</span>\n<span class=\"kn\">from</span> <span class=\"nn\">lock_tokens.sessions</span> <span class=\"kn\">import</span> <span class=\"n\">check_for_session</span><span class=\"p\">,</span> <span class=\"n\">lock_for_session</span><span class=\"p\">,</span> <span class=\"n\">unlock_for_session</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">my_app.models</span> <span class=\"kn\">import</span> <span class=\"n\">MyModel</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">view_with_object_edition</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"This view locks the instance of MyModel that is to be edited.\"\"\"</span>\n    <span class=\"c1\"># Get MyModel instance:</span>\n    <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"n\">MyModel</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">lock_for_session</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"p\">)</span>\n    <span class=\"k\">except</span> <span class=\"n\">AlreadyLockedError</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">HttpResponseForbidden</span><span class=\"p\">(</span><span class=\"s2\">\"This resource is locked, sorry !\"</span><span class=\"p\">)</span>\n    <span class=\"c1\"># ... Do stuff</span>\n    <span class=\"k\">return</span> <span class=\"n\">render</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">view_that_saves_object</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"sd\">\"\"\"This view locks the instance of MyModel that is to be edited.\"\"\"</span>\n    <span class=\"c1\"># Get MyModel instance:</span>\n    <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"n\">MyModel</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">check_for_session</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">HttpResponseForbidden</span><span class=\"p\">(</span><span class=\"s2\">\"Cannot modify the object, you don't have the lock.\"</span><span class=\"p\">)</span>\n    <span class=\"c1\"># ... Do stuff</span>\n    <span class=\"n\">unlock_for_session</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">session</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">render</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n<p>Or use it directly in your Django templates to handle locking on the client side:</p>\n<pre>{% load lock_tokens_tags %}\n{% lock_tokens_api_client %}\n...\n&lt;script type=\"text/javascript\"&gt;\n    window.addEventListener('lock_tokens.clientready', function () {\n        LockTokens.lock(...);\n        ...\n        LockTokens.unlock(...);\n    });\n&lt;/script&gt;\n</pre>\n</div>\n<div id=\"how-it-works\">\n<h2>How it works</h2>\n<p>To avoid concurrency editing, <tt><span class=\"pre\">django-lock-tokens</span></tt> provides some interfaces to lock and check lock on any model instance before changing it (including third party model instances).\nThis is handled via an internal model (<tt>LockToken</tt>). There can be only one <tt>LockToken</tt> instance per model instance.</p>\n<p>The lock token lifecycle is the following:</p>\n<blockquote>\n<ol>\n<li>When a lock is created for an object by an entity, it is valid for a certain amount of time. The entity is given a <strong>lock token key</strong> (a string) that it must hold to perform actions with valid lock required. A new <tt>LockToken</tt> instance is created in database, after having deleted a potential expired instance in database.</li>\n<li>If the entity that holds the lock token key no longer needs the lock on the object, it can unlock this object by providing the lock token key. The <tt>LockToken</tt> instance is then removed from database.</li>\n<li>The entity that holds the lock token key can also renew the lock token by providing the lock token key.</li>\n<li>If the lock token is not renewed until the expiration time, it becomes expired, but stays in database until a new lock is created on this instance (or the entity that holds the lock token key deletes it).</li>\n</ol>\n</blockquote>\n<p>So to use this mechanism correctly, you should <strong>require</strong> a valid lock token key and renew the lock in any method where an object is saved and you want to prevent concurrency editing. Based on the 4 previous points, we can see that there can be 3 cases for a lock token key:</p>\n<blockquote>\n<ol>\n<li>The lock token key has a corresponding lock token in database, and it has not expired.</li>\n<li>The lock token key has a corresponding lock token in database, but it has expired.</li>\n<li>The lock token key has no correponding lock token in database for the object.</li>\n</ol>\n</blockquote>\n<p>For case 1, it is ok to save the object and then unlock the object by deleting the lock token. The token key is still <strong>VALID</strong>.</p>\n<p>For case 2, the lock has expired but no other entity has created a lock on the object in the meantime. So it is still ok to save the object as it will not overwrite any changes. The token key is still <strong>VALID</strong>.</p>\n<p>In case 3, it means that the lock token created by the entity has expired, and that another entity has taken a lock on the object in the meantime and could have done some changes on it. So it is not ok to save changes. The token key is <strong>INVALID</strong>.</p>\n<p>Here is an example to understand the case 3:</p>\n<blockquote>\n<ol>\n<li>Alice takes a lock on an object and opens up its editing interface. <em>A ``LockToken`` instance ``lt1`` is created in database, and Alice is given a lock token key</em></li>\n<li>Alice walks away from her computer, the lock expires. <em>``lt1`` is still in database</em></li>\n<li>Bob takes a lock on the same object. <em>``lt1`` is deleted from database, and a new ``LockToken`` instance ``lt2`` is created</em></li>\n<li>Bob edits the object in the interface, clicks save. The object is modified and the lock is released. <em>``lt2`` is deleted. The object has no longer any lock in database</em></li>\n<li>Alice returns, clicks save. The lock token key she holds has become invalid, so she gets an error.</li>\n</ol>\n</blockquote>\n<p>This example shows how it is important to require a <strong>VALID</strong> lock token key to prevent concurrency editing.</p>\n</div>\n<div id=\"lockablemodel-proxy\">\n<h2><tt>LockableModel</tt> proxy</h2>\n<p>To make one of your models lockable, use the <tt>LockableModel</tt> class. <tt>LockableModel</tt> is just a Django proxy model, which simply provides additional locking methods to your models.</p>\n<p>So you can either make your models inherit from <tt>LockableModel</tt>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">lock_tokens.models</span> <span class=\"kn\">import</span> <span class=\"n\">LockableModel</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModel</span><span class=\"p\">(</span><span class=\"n\">LockableModel</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n\n<span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"n\">MyModel</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"n\">token</span> <span class=\"o\">=</span> <span class=\"n\">obj</span><span class=\"o\">.</span><span class=\"n\">lock</span><span class=\"p\">()</span>\n</pre>\n<p>or you can simply use it as a proxy on a given model instance:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">lock_tokens.models</span> <span class=\"kn\">import</span> <span class=\"n\">LockableModel</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">my_app.models</span> <span class=\"kn\">import</span> <span class=\"n\">MyModel</span>\n\n<span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"n\">MyModel</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n<span class=\"n\">token</span> <span class=\"o\">=</span> <span class=\"n\">LockableModel</span><span class=\"o\">.</span><span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n</pre>\n<p>This can be useful if you don\u2019t want to expose the locking methods for your models everywhere, or if you want to lock resources that come from a third party application.</p>\n<p>Note that as <tt>LockableModel</tt> is just a proxy model, make your models inherit from it won\u2019t change their fields so there will be no additional migrations required.</p>\n<p>Additionally, if your model inherits from <tt>LockableModel</tt>, the <tt>objects</tt> Manager has a specific method that allows you to get and lock a model like so:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">token</span> <span class=\"o\">=</span> <span class=\"n\">MyModel</span><span class=\"o\">.</span><span class=\"n\">get_and_lock</span><span class=\"p\">(</span><span class=\"o\">...&lt;</span><span class=\"n\">usual</span> <span class=\"n\">get</span> <span class=\"n\">arguments</span><span class=\"o\">&gt;</span><span class=\"p\">)</span>\n</pre>\n<p>If you already overrided the default <tt>objects</tt> manager with a custom one and that you want to get this method available, make your custom manager inherit from <tt>lock_tokens.managers.LockableModelManager</tt>.</p>\n<div id=\"lockablemodel-lock-self-token-none\">\n<h3><tt>LockableModel.lock(self, token=None)</tt></h3>\n<p>Locks the given object, or renew existing lock if the token parameter is provided.</p>\n<p>Returns a <tt>dict</tt> containing a token a its expiration date.</p>\n<p>Raises a <tt>lock_tokens.exceptions.AlreadyLockedError</tt> if the resource is already locked, and a <tt>lock_tokens.exceptions.InvalidToken</tt> if the specified token is invalid.</p>\n<p>Example:</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">test</span><span class=\"p\">(</span><span class=\"n\">myObject</span><span class=\"p\">):</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">token</span> <span class=\"o\">=</span> <span class=\"n\">myObject</span><span class=\"o\">.</span><span class=\"n\">lock</span><span class=\"p\">()</span>\n    <span class=\"k\">except</span> <span class=\"n\">AlreadyLockedError</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span> <span class=\"s2\">\"This object is already locked\"</span>\n    <span class=\"k\">return</span> <span class=\"n\">token</span>\n\n\n<span class=\"o\">&gt;&gt;&gt;</span><span class=\"n\">token</span> <span class=\"o\">=</span> <span class=\"n\">test</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n<span class=\"p\">{</span><span class=\"s2\">\"token\"</span><span class=\"p\">:</span> <span class=\"s2\">\"9692ac52a27a40308b82b49b77357c97\"</span><span class=\"p\">,</span> <span class=\"s2\">\"expires\"</span><span class=\"p\">:</span> <span class=\"s2\">\"2016-06-23 09:48:06\"</span><span class=\"p\">}</span>\n<span class=\"o\">&gt;&gt;&gt;</span><span class=\"n\">test</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">)</span>\n<span class=\"s2\">\"This object is already locked\"</span>\n<span class=\"o\">&gt;&gt;&gt;</span><span class=\"n\">test</span><span class=\"p\">(</span><span class=\"n\">obj</span><span class=\"p\">,</span> <span class=\"n\">token</span><span class=\"p\">[</span><span class=\"s1\">'token'</span><span class=\"p\">])</span>\n<span class=\"p\">{</span><span class=\"s2\">\"token\"</span><span class=\"p\">:</span> <span class=\"s2\">\"9692ac52a27a40308b82b49b77357c97\"</span><span class=\"p\">,</span> <span class=\"s2\">\"expires\"</span><span class=\"p\">:</span> <span class=\"s2\">\"2016-06-23 09:48:26\"</span><span class=\"p\">}</span>\n</pre>\n</div>\n<div id=\"lockablemodel-unlock-self-token\">\n<h3><tt>LockableModel.unlock(self, token)</tt></h3>\n<p>Unlocks the given object if the provided token is correct.</p>\n<p>Raises a <tt>lock_tokens.exceptions.UnlockForbiddenError</tt></p>\n</div>\n<div id=\"lockablemodel-is-locked-self\">\n<h3><tt>LockableModel.is_locked(self)</tt></h3>\n<p>Returns a boolean that indicates whether the given object is currently locked or not.</p>\n</div>\n<div id=\"lockablemodel-check-lock-self-token\">\n<h3><tt>LockableModel.check_lock(self, token)</tt></h3>\n<p>Returns a boolean that indicates if the given token is valid for this object. Will also return <tt>True</tt> with a warning if the object is not locked (lock expired or no lock).</p>\n</div>\n</div>\n<div id=\"lockablemodeladmin-for-admin-interface\">\n<h2><tt>LockableModelAdmin</tt> for admin interface</h2>\n<p>If you want to make the admin interface lock-aware, and lock objects that are edited,\nsimply make your <tt>ModelAdmin</tt> class inherit from <tt>LockableModelAdmin</tt>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">lock_tokens.admin</span> <span class=\"kn\">import</span> <span class=\"n\">LockableModelAdmin</span>\n<span class=\"kn\">from</span> <span class=\"nn\">django.contrib</span> <span class=\"kn\">import</span> <span class=\"n\">admin</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">my_app.models</span> <span class=\"kn\">import</span> <span class=\"n\">MyModel</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyModelAdmin</span><span class=\"p\">(</span><span class=\"n\">LockableModelAdmin</span><span class=\"p\">):</span>\n    <span class=\"o\">...</span>\n\n<span class=\"n\">admin</span><span class=\"o\">.</span><span class=\"n\">site</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"n\">MyModel</span><span class=\"p\">,</span> <span class=\"n\">MyModelAdmin</span><span class=\"p\">)</span>\n</pre>\n<p>With this, when accessing a given instance of <tt>MyModel</tt> from the admin interface,\nit will check that the instance is not locked. If it is not, it will lock it. If it is,\nthen there will be a warning message displayed to inform that the object cannot be edited,\nand the saving buttons will not appear. And if despite this, the change form is sent, it will raise a <tt>PermissionDenied</tt> exception so you will get a HTTP 403 error.</p>\n<div id=\"overrinding-change-form-template-in-lockablemodeladmin\">\n<h3>Overrinding <cite>change_form_template</cite> in <cite>LockableModelAdmin</cite></h3>\n<p>If you want to override the <cite>change_form_template</cite>, but still make sure the lock will be released when leaving the page without saving, don\u2019t forget to add the <cite>admin_lock_handler</cite> template tag. This template tag needs 4 arguments: the application name of the object, the model name of the object, the object id and the lock token key. So don\u2019t forget to add those (especially the lock token) into your template context if you also override the <cite>change_view</cite> method.</p>\n<p>Example to add the template tag to your custom template if you don\u2019t override <cite>change_view</cite>:</p>\n<pre>...\n{% load lock_tokens_tags %}\n...\n{% if lock_token %}\n  {% admin_lock_handler opts.app_label opts.model_name original.id lock_token %}\n{% endif %}\n</pre>\n</div>\n</div>\n<div id=\"session-based-usage-lock-tokens-sessions-module\">\n<h2>Session-based usage: <tt>lock_tokens.sessions</tt> module</h2>\n<p>In most cases, it will be the easiest way to deal with lock tokens, as you won\u2019t need to handle them at all.</p>\n<div id=\"lock-for-session-obj-session-force-new-false\">\n<h3><tt>lock_for_session(obj, session, force_new=False)</tt></h3>\n<p>Lock an object in the given session. This function will try to lock the object,\nand if it succeeds, it will hold the token value in a session variable.</p>\n<p>There is a <cite>force_new</cite> optional parameter that you can set to <cite>True</cite> if you want to force a new lock generation without using a potentially existing token key stored in session. This is to be used with caution (i.e. exclusively in methods that only read the object, not in methods that save it) as it could lead to a potential overwriting if the session holds an invalid token.\nTo sum up: do not set this parameter to <cite>True</cite> unless you are sure of what you are doing!</p>\n<p>Raises a <tt>lock_tokens.exceptions.AlreadyLockedError</tt> if the resource is already locked, and a <tt>lock_tokens.exceptions.InvalidToken</tt> error if the session holds an invalid token.</p>\n</div>\n<div id=\"unlock-for-session-obj-session\">\n<h3><tt>unlock_for_session(obj, session)</tt></h3>\n<p>Unlocks an object in the given session.</p>\n<p>Raises a <tt>lock_tokens.exceptions.UnlockForbiddenError</tt> if the session does not hold the lock on the object.</p>\n</div>\n<div id=\"check-for-session-obj-session\">\n<h3><tt>check_for_session(obj, session)</tt></h3>\n<p>Check if an object has a valid lock in the given session.</p>\n<p>Returns <tt>True</tt> if the session holds a valid lock (even if it has expired), and <tt>False</tt> if the session holds an invalid lock or no lock.</p>\n</div>\n</div>\n<div id=\"session-based-usage-lock-tokens-decorators-module\">\n<h2>Session-based usage: <tt>lock_tokens.decorators</tt> module</h2>\n<p>This module provides view decorators for common use cases.</p>\n<div id=\"locks-object-model-get-object-id-callable\">\n<h3><tt>locks_object(model, get_object_id_callable)</tt></h3>\n<p>Locks an object before executing view, and keep lock token in the request session. Does not unlock it when the view returns.</p>\n<p>Arguments:</p>\n<ul>\n<li><tt>model</tt>: the concerned django Model</li>\n<li><tt>get_object_id_callable</tt>: a callable that will return the concerned object id based on the view arguments</li>\n</ul>\n<p>Example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">lock_tokens.decorators</span> <span class=\"kn\">import</span> <span class=\"n\">locks_object</span>\n\n<span class=\"nd\">@locks_object</span><span class=\"p\">(</span><span class=\"n\">MyModel</span><span class=\"p\">,</span> <span class=\"k\">lambda</span> <span class=\"n\">request</span><span class=\"p\">:</span> <span class=\"n\">request</span><span class=\"o\">.</span><span class=\"n\">GET</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"s1\">'my_model_id'</span><span class=\"p\">))</span>\n<span class=\"k\">def</span> <span class=\"nf\">myview</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">):</span>\n    <span class=\"c1\"># In this example the view will lock the MyModel instance with the id</span>\n    <span class=\"c1\"># provided in the request GET parameter my_model_id</span>\n    <span class=\"o\">...</span>\n\n<span class=\"nd\">@locks_object</span><span class=\"p\">(</span><span class=\"n\">MyModel</span><span class=\"p\">,</span> <span class=\"k\">lambda</span> <span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"n\">object_id</span><span class=\"p\">:</span> <span class=\"n\">object_id</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">anotherview</span><span class=\"p\">(</span><span class=\"n\">request</span><span class=\"p\">,</span> <span class=\"n\">object_id</span><span class=\"p\">):</span>\n    <span class=\"c1\"># In this example the view will lock the MyModel instance with the id</span>\n    <span class=\"c1\"># provided as the second view argument</span>\n    <span class=\"o\">...</span>\n</pre>\n</div>\n<div id=\"holds-lock-on-object-model-get-object-id-callable\">\n<h3><tt>holds_lock_on_object(model, get_object_id_callable)</tt></h3>\n<p>Locks an object before executing view, and keep lock token in the request session. Hold lock until the view is finished executing, then release it.</p>\n<p>Arguments:</p>\n<ul>\n<li><tt>model</tt>: the concerned django Model</li>\n<li><tt>get_object_id_callable</tt>: a callable that will return the concerned object id based on the view arguments</li>\n</ul>\n<p>See examples for <tt>locks_object</tt>.</p>\n</div>\n</div>\n<div id=\"rest-api\">\n<h2>REST API</h2>\n<p>If you want to use locking mechanism from outside your views, there is a simple HTTP API to handle tokens. It does not use sessions at all, so you need to handle the tokens yourself in this case.</p>\n<p>Here are the different entry points, where <tt>&lt;app_label&gt;</tt> is the name of the application of the concerned model, <tt>&lt;model&gt;</tt> is the name of the model, <tt>&lt;object_id&gt;</tt> is the id of the cmodel instance, and <tt>&lt;token&gt;</tt> is the lock token value.</p>\n<div id=\"post-lock-tokens-app-label-model-object-id\">\n<h3><em>POST</em> <tt><span class=\"pre\">/lock_tokens/&lt;app_label&gt;/&lt;model&gt;/&lt;object_id&gt;/</span></tt></h3>\n<p>Locks object. Returns a JSON response with \u201ctoken\u201d and \u201cexpires\u201d keys.</p>\n<p>Returns a 404 HTTP error if the object could not be found.</p>\n<p>Returns a 403 HTTP error if the object is already locked.</p>\n</div>\n<div id=\"get-lock-tokens-app-label-model-object-id-token\">\n<h3><em>GET</em> <tt><span class=\"pre\">/lock_tokens/&lt;app_label&gt;/&lt;model&gt;/&lt;object_id&gt;/&lt;token&gt;/</span></tt></h3>\n<p>Returns a JSON response with \u201ctoken\u201d and \u201cexpires\u201d keys.</p>\n<p>Returns a 404 HTTP error if the object could not be found.</p>\n<p>Returns a 403 HTTP error if the token is incorrect.</p>\n</div>\n<div id=\"patch-lock-tokens-app-label-model-object-id-token\">\n<h3><em>PATCH</em> <tt><span class=\"pre\">/lock_tokens/&lt;app_label&gt;/&lt;model&gt;/&lt;object_id&gt;/&lt;token&gt;/</span></tt></h3>\n<p>Renews the lock on the object. Returns a JSON response with \u201ctoken\u201d and \u201cexpires\u201d keys.</p>\n<p>Returns a 404 HTTP error if the object could not be found.</p>\n<p>Returns a 403 HTTP error if the token is incorrect.</p>\n</div>\n<div id=\"delete-lock-tokens-app-label-model-object-id-token\">\n<h3><em>DELETE</em> <tt><span class=\"pre\">/lock_tokens/&lt;app_label&gt;/&lt;model&gt;/&lt;object_id&gt;/&lt;token&gt;/</span></tt></h3>\n<p>Unlocks object.</p>\n<p>Returns a 404 HTTP error if the object could not be found.</p>\n<p>Returns a 403 HTTP error if the token is incorrect.</p>\n</div>\n</div>\n<div id=\"rest-api-javascript-client\">\n<h2>REST API Javascript client</h2>\n<p>The application includes a javascript client to interact with the API. To enable it, simply add the following lines to your template, somewhere in the <tt>&lt;body&gt;</tt> section</p>\n<pre>{% load lock_tokens_tags %}\n{% lock_tokens_api_client %}\n</pre>\n<p>Don\u2019t forget to include the REST API urls with the correct namespace as described in section 1, otherwise it won\u2019t work.</p>\n<p>Adding those lines in your template will create a variable named <tt>LockTokens</tt>, and emit a <tt>lock_tokens.clientready</tt> event when it is available in the javascript scope. This object has the following methods (parameters are self-describing):</p>\n<div id=\"locktokens-lock-app-label-model-object-id-callback\">\n<h3><tt>LockTokens.lock(app_label, model, object_id, callback)</tt></h3>\n<p>Locks the corresponding object. When the call to the API is completed, calls the <tt>callback</tt> method with a <tt>lock_tokens.Token</tt> instance as an argument, or <tt>null</tt> if the API request failed.</p>\n<p>NB: The <tt>LockTokens</tt> handles the tokens for you, so you don\u2019t need to read API responses and/or store tokens yourself.</p>\n</div>\n<div id=\"locktokens-register-existing-lock-token-app-label-model-object-id-token-string-callback\">\n<h3><tt>LockTokens.register_existing_lock_token(app_label, model, object_id, token_string, callback)</tt></h3>\n<p>Add an existing token to the <tt>LockTokens</tt> registry. This method is useful for example when you want to handle on client side a lock that has been set on the server side. You must provide the token string in addition to other parameters, the client will make a call to the API to ensure the token is valid and get its expiration date. Calls the <tt>callback</tt> method with a <tt>lock_tokens.Token</tt> instance as an argument, or <tt>null</tt> if the registration failed.</p>\n</div>\n<div id=\"locktokens-unlock-app-label-model-object-id-callback\">\n<h3><tt>LockTokens.unlock(app_label, model, object_id, callback)</tt></h3>\n<p>Locks the corresponding object. When the call to the API is completed, calls the <tt>callback</tt> method with a boolean that indicates whether the API request has succeeded. Note that this method can be called only on an object that has been locked or registered as locked by the <tt>LockTokens</tt> object.</p>\n</div>\n<div id=\"locktokens-hold-lock-app-label-model-object-id\">\n<h3><tt>LockTokens.hold_lock(app_label, model, object_id)</tt></h3>\n<p>Holds a lock on the corresponding object. It is like the <tt>lock</tt> method, except it renews the token each time it is about to expire. A call to <tt>unlock</tt> will stop the lock holding.</p>\n</div>\n<div id=\"locktokens-clear-all-locks-callback\">\n<h3><tt>LockTokens.clear_all_locks(callback)</tt></h3>\n<p>Unlocks all registered objects. Calls <tt>callback</tt> with no arguments when unlocking of every objects is done.</p>\n</div>\n</div>\n<div id=\"settings\">\n<h2>Settings</h2>\n<p>You can override <tt>lock_token</tt> default settings by adding a <tt>dict</tt> named <tt>LOCK_TOKENS</tt> to your <tt>settings.py</tt> like so:</p>\n<pre><span class=\"n\">LOCK_TOKENS</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">'API_CSRF_EXEMPT'</span><span class=\"p\">:</span> <span class=\"kc\">True</span><span class=\"p\">,</span>\n    <span class=\"s1\">'DATEFORMAT'</span><span class=\"p\">:</span> <span class=\"s2\">\"%Y%m</span><span class=\"si\">%d</span><span class=\"s2\">%H%M%S\"</span><span class=\"p\">,</span>\n    <span class=\"s1\">'TIMEOUT'</span><span class=\"p\">:</span> <span class=\"mi\">60</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n</pre>\n<div id=\"timeout\">\n<h3>TIMEOUT</h3>\n<p>The validity duration for a lock token in seconds. Defaults to <tt>3600</tt> (one hour).</p>\n</div>\n<div id=\"dateformat\">\n<h3>DATEFORMAT</h3>\n<p>The format of the expiration date returned in the token <tt>dict</tt>. Defaults to <tt><span class=\"pre\">\"%Y-%m-%d</span> <span class=\"pre\">%H:%M:%S</span> %Z\"</tt></p>\n</div>\n<div id=\"api-csrf-exempt\">\n<h3>API_CSRF_EXEMPT</h3>\n<p>A boolean that indicates whether to deactivate CSRF checks on the API views or not. Defaults to <tt>False</tt>.</p>\n</div>\n</div>\n<div id=\"tests\">\n<h2>Tests</h2>\n<p>To run tests simply run from the root of the repository:</p>\n<pre>source &lt;YOURVIRTUALENV&gt;/bin/activate\n(myenv) $ pip install tox\n(myenv) $ tox\n</pre>\n</div>\n<div id=\"credits\">\n<h2>Credits</h2>\n<p>Tools used in rendering this package:</p>\n<ul>\n<li><a href=\"https://github.com/audreyr/cookiecutter\" rel=\"nofollow\">Cookiecutter</a></li>\n<li><a href=\"https://github.com/pydanny/cookiecutter-djangopackage\" rel=\"nofollow\">cookiecutter-djangopackage</a></li>\n</ul>\n</div>\n<div id=\"history\">\n<h2>History</h2>\n<div id=\"id1\">\n<h3>0.2.5 (2019-02-07)</h3>\n<ul>\n<li>Fix issue #10_</li>\n</ul>\n</div>\n<div id=\"id3\">\n<h3>0.2.4 (2018-11_30)</h3>\n<ul>\n<li>The HTTP API endpoint to get token information now returns the token information even when it has expired, because it is still valid to use (see <a href=\"https://github.com/rparent/django-lock-tokens#how-it-works\" rel=\"nofollow\">this</a>)</li>\n</ul>\n</div>\n<div id=\"id4\">\n<h3>0.2.3 (2018-10-31)</h3>\n<ul>\n<li>Fixes <tt>LockableModel</tt> for Python 2.7</li>\n</ul>\n</div>\n<div id=\"id5\">\n<h3>0.2.2 (2018-10-31)</h3>\n<ul>\n<li>Fixes <tt>LockableModel</tt> to allow to use it as a proxy</li>\n</ul>\n</div>\n<div id=\"id6\">\n<h3>0.2.1 (2018-10-04)</h3>\n<ul>\n<li>Fixes <tt>LockToken.save</tt> method to prevent potential transaction errors</li>\n<li>Adds a template tag to handle lock on the client side when overriding default <tt>change_form_template</tt> in <tt>LockableModelAdmin</tt></li>\n<li>Better handling of invalid lock token strings (see discussion <a href=\"https://github.com/rparent/django-lock-tokens/issues/6\" rel=\"nofollow\">here</a>) to prevent overwriting</li>\n</ul>\n</div>\n<div id=\"id7\">\n<h3>0.1.4 (2017-09-07)</h3>\n<ul>\n<li>Adds a <tt>created</tt> field to the <tt>LockToken</tt> model</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4790716, "releases": {"0.1.1": [{"comment_text": "", "digests": {"md5": "12245a30f3a0350603d741fd98bebd4f", "sha256": "dd6d9266bc51e1896dbc9b1d75a56a469dcd341b861de325f6f3292eb1876598"}, "downloads": -1, "filename": "django_lock_tokens-0.1.1-py2-none-any.whl", "has_sig": false, "md5_digest": "12245a30f3a0350603d741fd98bebd4f", "packagetype": "bdist_wheel", "python_version": "2.7", "requires_python": null, "size": 21563, "upload_time": "2016-10-21T14:09:54", "upload_time_iso_8601": "2016-10-21T14:09:54.960260Z", "url": "https://files.pythonhosted.org/packages/52/60/f2f4139c847d3f2a26860f84d83c2fedf1ccd7574bf15eb998ca0d4219da/django_lock_tokens-0.1.1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "085ed747c7ae122962ed55ce13c95891", "sha256": "01a6e0440b997077cae1eee8a18d6750e7453b1e30d7d4455cf71fcb77438510"}, "downloads": -1, "filename": "django-lock-tokens-0.1.1.tar.gz", "has_sig": false, "md5_digest": "085ed747c7ae122962ed55ce13c95891", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17826, "upload_time": "2016-10-21T14:09:52", "upload_time_iso_8601": "2016-10-21T14:09:52.555136Z", "url": "https://files.pythonhosted.org/packages/44/6b/dcf3fedf88a2c17654982c02556128788359bae1ad3d2b12f33a29aeb173/django-lock-tokens-0.1.1.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "8480dcd117e1767c37c5ddd565a380b4", "sha256": "74fb2a7e815162ff614e9e694a9a383bc3242bcb2aa3633611c15fed941a7157"}, "downloads": -1, "filename": "django-lock-tokens-0.1.3.tar.gz", "has_sig": false, "md5_digest": "8480dcd117e1767c37c5ddd565a380b4", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18609, "upload_time": "2016-12-02T11:44:29", "upload_time_iso_8601": "2016-12-02T11:44:29.410143Z", "url": "https://files.pythonhosted.org/packages/01/53/9cbf2676b4b400805b1b29327bde8ac7635aa8571401720a9941460fb17f/django-lock-tokens-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "0645715e0275bc0fc7684e4ee3b86598", "sha256": "15cb34ea63af3f896a90029f6f5a93d352428642d12b30de41cd82e3a0d53a59"}, "downloads": -1, "filename": "django_lock_tokens-0.1.4-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "0645715e0275bc0fc7684e4ee3b86598", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 25529, "upload_time": "2017-09-07T17:30:20", "upload_time_iso_8601": "2017-09-07T17:30:20.556665Z", "url": "https://files.pythonhosted.org/packages/47/31/9eff391c9f1de828cc199c3386845b1df398813bdd1b254cfd814d859f1e/django_lock_tokens-0.1.4-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "dfac2ab42a3f88f5045d4ad56af4c8ae", "sha256": "6a32f18e1d83ee59bf1e3e83081d3292e1b98c220cfdfd398254e5ca6bbed015"}, "downloads": -1, "filename": "django_lock_tokens-0.1.4-py3.5.egg", "has_sig": false, "md5_digest": "dfac2ab42a3f88f5045d4ad56af4c8ae", "packagetype": "bdist_egg", "python_version": "3.5", "requires_python": null, "size": 37518, "upload_time": "2018-10-04T19:44:40", "upload_time_iso_8601": "2018-10-04T19:44:40.275133Z", "url": "https://files.pythonhosted.org/packages/ad/72/340d452dc8c30b31d64050245647cbcb2c37d473e9a7a570acdcd8e026dd/django_lock_tokens-0.1.4-py3.5.egg", "yanked": false}, {"comment_text": "", "digests": {"md5": "0ea6e076986d5f562673762d863a4616", "sha256": "49b40196d96daaa99a4c784e1c48bb5ce36ffb0ecb2718d750c956f9dc6b198a"}, "downloads": -1, "filename": "django-lock-tokens-0.1.4.tar.gz", "has_sig": false, "md5_digest": "0ea6e076986d5f562673762d863a4616", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21237, "upload_time": "2017-09-07T17:28:13", "upload_time_iso_8601": "2017-09-07T17:28:13.768777Z", "url": "https://files.pythonhosted.org/packages/8b/a4/1be3ba62ed3c34f0228576c0e0e8628cb698f41badc2245d446303b352cf/django-lock-tokens-0.1.4.tar.gz", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "ab8953cefcbc10083de367b1125e9f0d", "sha256": "ddb63f34f6db36b8ea07b6c29d067ef672e66b832813ca6d9fe4361c2d0add1e"}, "downloads": -1, "filename": "django-lock-tokens-0.2.1.tar.gz", "has_sig": false, "md5_digest": "ab8953cefcbc10083de367b1125e9f0d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30551, "upload_time": "2018-10-04T19:44:42", "upload_time_iso_8601": "2018-10-04T19:44:42.518124Z", "url": "https://files.pythonhosted.org/packages/83/47/52e6e364463f5320d21c6177babfced33f44d5a6dc8b3c26c9eb979bce58/django-lock-tokens-0.2.1.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "f75e56877fa1ffc5e282cfab0757e5e1", "sha256": "f4bc6389b3b8de67badc06c13a01124aaa95a4296600585e7b83cfbc072f565a"}, "downloads": -1, "filename": "django-lock-tokens-0.2.3.tar.gz", "has_sig": false, "md5_digest": "f75e56877fa1ffc5e282cfab0757e5e1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 30805, "upload_time": "2018-10-31T18:37:59", "upload_time_iso_8601": "2018-10-31T18:37:59.268835Z", "url": "https://files.pythonhosted.org/packages/1c/88/159be2d5b6e0a1e21e22d15c3f1cc12c2405aee6b6076db387d3a7bd42fa/django-lock-tokens-0.2.3.tar.gz", "yanked": false}], "0.2.4": [{"comment_text": "", "digests": {"md5": "f6ca1fc5de74a0d3dfccf6405af2cd66", "sha256": "a0929acd2d05b89e3cb448f0ebb2cfd855b31775e2b256e3128b459225305691"}, "downloads": -1, "filename": "django-lock-tokens-0.2.4.tar.gz", "has_sig": false, "md5_digest": "f6ca1fc5de74a0d3dfccf6405af2cd66", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32234, "upload_time": "2018-11-29T21:13:29", "upload_time_iso_8601": "2018-11-29T21:13:29.495086Z", "url": "https://files.pythonhosted.org/packages/ef/b1/e9b821c4d55b778a9b514283072c98a29cdf370c90e9b217072b5399297e/django-lock-tokens-0.2.4.tar.gz", "yanked": false}], "0.2.5": [{"comment_text": "", "digests": {"md5": "02c3a36d6dfec2b027c90fd873fab9ea", "sha256": "cc7d513fabe2b93f00caced63dfce8c682bf09d42690a7f1349946345b3fdef4"}, "downloads": -1, "filename": "django-lock-tokens-0.2.5.tar.gz", "has_sig": false, "md5_digest": "02c3a36d6dfec2b027c90fd873fab9ea", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32425, "upload_time": "2019-02-07T12:07:39", "upload_time_iso_8601": "2019-02-07T12:07:39.840954Z", "url": "https://files.pythonhosted.org/packages/2e/0b/21de529ddc7ecf5752773fe81cc52d0901aba9833e5d657726fd2d347977/django-lock-tokens-0.2.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "02c3a36d6dfec2b027c90fd873fab9ea", "sha256": "cc7d513fabe2b93f00caced63dfce8c682bf09d42690a7f1349946345b3fdef4"}, "downloads": -1, "filename": "django-lock-tokens-0.2.5.tar.gz", "has_sig": false, "md5_digest": "02c3a36d6dfec2b027c90fd873fab9ea", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32425, "upload_time": "2019-02-07T12:07:39", "upload_time_iso_8601": "2019-02-07T12:07:39.840954Z", "url": "https://files.pythonhosted.org/packages/2e/0b/21de529ddc7ecf5752773fe81cc52d0901aba9833e5d657726fd2d347977/django-lock-tokens-0.2.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:35:17 2020"}