{"info": {"author": "SignalFx, Inc.", "author_email": "signalfx-oss@splunk.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: Apache Software License", "Natural Language :: English", "Programming Language :: Python", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Programming Language :: Python :: 3.7"], "description": "# SignalFx-Tracing Library for Python: An OpenTracing Auto-Instrumentor\n\nThis utility provides users with the ability of automatically configuring\nOpenTracing 2.0-compatible community-contributed [instrumentation libraries](https://github.com/opentracing-contrib)\nfor their Python 2.7 and 3.4+ applications via a single function.\n\n```python\nfrom signalfx_tracing import auto_instrument, create_tracer\n\ntracer = create_tracer(service_name='MyService')\nauto_instrument(tracer)\n```\n\nIf auto-instrumentation of all applicable libraries and frameworks isn't desired,\nenabling instrumentation individually can be done by specifying your target module:\n\n```python\nfrom signalfx_tracing import create_tracer, instrument, uninstrument\n\ntracer = create_tracer()\ninstrument(tracer, flask=True)\n# or\ninstrument(flask=True)  # uses the global Tracer from opentracing.tracer by default\n\nimport flask\n\ntraced_app = flask.Flask('MyTracedApplication')\n\n@traced_app.route('/hello_world')\ndef traced_route():\n    # Obtain active span created by traced middleware\n    span = tracer.scope_manager.active.span\n    span.set_tag('Hello', 'World')\n    span.log_kv({'event': 'initiated'})\n    return 'Hello!'  # Span is automatically finished after request handler\n\nuninstrument('flask')  # prevent future registrations\n\nuntraced_app = flask.Flask('MyUntracedApplication')\n\n@untraced_app.route('/untraced_hello_world')\ndef untraced_route():\n    return 'Goodbye!'\n```\n\n**Note: Both `instrument()` and `auto_instrument()` invocations can be converted to no-ops if the\n`SIGNALFX_TRACING_ENABLED` environment variable is set to `False` or `0`.  This can be helpful when developing your\nauto-instrumented application locally or in test environments.**\n\n## Supported Frameworks and Libraries\n\n* [Celery 3.1+](./signalfx_tracing/libraries/celery_/README.md) - `instrument(celery=True)`\n* [Django 1.8+](./signalfx_tracing/libraries/django_/README.md) - `instrument(django=True)`\n* [Elasticsearch 2.0+](./signalfx_tracing/libraries/elasticsearch_/README.md) - `instrument(elasticsearch=True)`\n* [Flask 0.10+](./signalfx_tracing/libraries/flask_/README.md) - `instrument(flask=True)`\n* [Psycopg 2.7+](./signalfx_tracing/libraries/psycopg2_/README.md) - `instrument(psycopg2=True)`\n* [PyMongo 3.1+](./signalfx_tracing/libraries/pymongo_/README.md) - `instrument(pymongo=True)`\n* [PyMySQL 0.8+](./signalfx_tracing/libraries/pymysql_/README.md) - `instrument(pymysql=True)`\n* [Redis-Py 2.10+](./signalfx_tracing/libraries/redis_/README.md) - `instrument(redis=True)`\n* [Requests 2.0+](./signalfx_tracing/libraries/requests_/README.md) - `instrument(requests=True)`\n* [Tornado 4.3-6.x](./signalfx_tracing/libraries/tornado_/README.md) - `instrument(tornado=True)`\n\n## Installation and Configuration\n\n### Library and Instrumentors\nThe SignalFx-Tracing Library for Python works by detecting your libraries and frameworks and configuring available\ninstrumentors for distributed tracing via the Python [OpenTracing API 2.0](https://pypi.org/project/opentracing/2.0.0/). \nBy default, its footprint is small and doesn't declare any instrumentors as dependencies. That is, it operates on the\nassumption that you have 2.0-compatible instrumentors installed as needed. As adoption of this API is done on a\nper-instrumentor basis, it's highly recommended you use the helpful [bootstrap utility](./scripts/README.md) for\nobtaining and installing any applicable, feature-ready instrumentors along with a compatible tracer:\n\n```sh\n  $ pip install signalfx-tracing\n  $ sfx-py-trace-bootstrap\n```\n\nFor example, if your environment has Requests and Flask in its Python path, the corresponding OpenTracing\ninstrumentors will be pip installed.  Again, since OpenTracing-Contrib instrumentation support of API 2.0 is not\nubiquitous, this bootstrap selectively installs custom instrumentors listed in\n[the instrumentor requirements file](./requirements-inst.txt).  As such, we suggest being sure to uninstall any previous\ninstrumentor versions before running the bootstrapper, ideally in a clean environment.\n\nTo run the instrumentor bootstrap process without installing the suggested tracer, you can run the following from this\nproject's source tree:\n\n```sh\n  $ scripts/bootstrap.py --deps-only\n```\n\nYou can also specify a target installation directory, which will include the most recent `signalfx-tracing` as provided\nby PyPI:\n\n```sh\n  $ sfx-py-trace-bootstrap -t /my/site/packages/directory\n```\n\nIt's also possible to install the supported instrumentors as package extras from a cloned repository:\n\n```bash\n  $ git clone https://github.com/signalfx/signalfx-python-tracing.git\n  # Supported extras are dbapi, django, flask, pymongo, pymysql, redis, requests, tornado\n  $ pip install './signalfx-python-tracing[django,redis,requests]'\n```\n\n**Note: For pip versions earlier than 18.0, it's necessary to include `--process-dependency-links` to\nobtain the desired instrumentor versions.**\n\n```bash\n  $ git clone https://github.com/signalfx/signalfx-python-tracing.git\n  # pip versions <18.0\n  $ pip install --process-dependency-links './signalfx-python-tracing[jaeger,tornado]'\n```\n\n### Tracer\nNot all stable versions of OpenTracing-compatible tracers support the 2.0 API, so we provide\nand recommend installing a modified [Jaeger Client](https://github.com/jaegertracing/jaeger-client-python)\nready for reporting to SignalFx. You can obtain an instance of the suggested Jaeger tracer using a\n `signalfx_tracing.utils.create_tracer()` helper, provided you've run:\n\n```sh\n  $ sfx-py-trace-bootstrap\n\n  # or as package extra\n  $ pip install './signalfx-python-tracing[jaeger]'\n  # please use required --process-dependency-links for pip versions <18.0 \n  $ pip install --process-dependency-links './signalfx-python-tracing[jaeger]'\n\n  # or from project source tree, along with applicable instrumentors\n  $ scripts/bootstrap.py --jaeger\n\n  # or to avoid applicable instrumentors\n  $ scripts/bootstrap.py --jaeger-only\n```\n\nBy default `create_tracer()` will enable tracing with constant sampling (100% chance of tracing) and report each span\ndirectly to SignalFx. Where applicable, context propagation will be done via\n[B3 headers](https://github.com/openzipkin/b3-propagation).\n\n```python\nfrom signalfx_tracing import create_tracer\n\n# sets the global opentracing.tracer by default:\ntracer = create_tracer()  # uses 'SIGNALFX_ACCESS_TOKEN' environment variable if provided\n\n# or directly provide your organization access token if not using the Smart Agent to analyze spans:\ntracer = create_tracer('<OrganizationAccessToken>', ...)\n\n# or to disable setting the global tracer:\ntracer = create_tracer(set_global=False)\n```\n\nAll other `create_tracer()` arguments are those that can be passed to a `jaeger_client.Config` constructor:\n```python\nfrom tornado_opentracing.scope_managers import TornadoScopeManager\nfrom signalfx_tracing import create_tracer\n\ntracer = create_tracer(\n    '<OptionalOrganizationAccessToken>',\n    config=dict(jaeger_endpoint='http://localhost:9080/v1/trace'),\n    service_name='MyTracedApplication',\n    scope_manager=TornadoScopeManager  # Necessary for span scope in Tornado applications\n)\n```\n\nIf a `config` dictionary isn't provided or doesn't specify the desired items for your tracer, the following environment\nvariables are checked for before selecting a default value:\n\n| Config kwarg | environment variable | default value |\n|--------------|----------------------|---------------|\n| `service_name` | `SIGNALFX_SERVICE_NAME` | `'SignalFx-Tracing'` |\n| `jaeger_endpoint` | `SIGNALFX_ENDPOINT_URL` | `'http://localhost:9080/v1/trace'` |\n| `jaeger_password` | `SIGNALFX_ACCESS_TOKEN` | `None` |\n| `['sampler']['type']` | `SIGNALFX_SAMPLER_TYPE` | `'const'` |\n| `['sampler']['param']` | `SIGNALFX_SAMPLER_PARAM` | `1` |\n| `propagation` | `SIGNALFX_PROPAGATION` | `'b3'` |\n\n\n**Note: By default `create_tracer()` will store the initial tracer created upon first invocation and return\nthat instance for subsequent invocations.  If for some reason multiple tracers are needed, you can provide\n`create_tracer(allow_multiple=True)` as a named argument.**\n\n## Usage\n\n### Application Runner\nThe SignalFx-Tracing Library for Python's auto-instrumentation configuration can be performed while loading\nyour framework-based and library-utilizing application as described in the corresponding\n[instrumentation instructions](#supported-frameworks-and-libraries).\nHowever, if you have installed the recommended [Jaeger client](#Tracer) (`sfx-py-trace-bootstrap`) and would like to\nautomatically instrument your applicable program with the default settings, a helpful `sfx-py-trace` entry point\nis provided by the installer:\n\n```sh\n  $ sfx-py-trace my_application.py --app_arg_one --app_arg_two\n  # Or if your Smart Agent is not available at the default endpoint url:\n  $ SIGNALFX_ENDPOINT_URL='http://MySmartAgent:9080/v1/trace' sfx-py-trace my_application.py\n```\n\n**Note: `sfx-py-trace` cannot, by itself, enable auto-instrumentation of Django projects, as the `signalfx_tracing`\ninstrumentor must still be added to the project settings' installed apps.  Once the application is specified,\n`sfx-py-trace` may be used as described in the [Django instrumentation documentation](./signalfx_tracing/libraries/django_/README.md).**\n\nThis command line script loader will create a Jaeger tracer instance using the access token specified via\nenvironment variable or argument to report your spans to SignalFx.  It will then call `auto_instrument()` before\nrunning your target application file in its own module namespace.  It's important to note that due to potential\ndeadlocks in importing forking code, the standard Jaeger tracer cannot be initialized as a side effect of an import\nstatement (see: [Python threading doc](https://docs.python.org/2/library/threading.html#importing-in-threaded-code) and\n[known Jaeger issue](https://github.com/jaegertracing/jaeger-client-python/issues/60#issuecomment-318909730)).\nBecause of this issue, and for general lack of HTTP reporting support, we highly suggest you use our modified [Jaeger\ntracer](#Tracer) that provides deferred thread creation to avoid this constraint.\n\nThe application runner will by default attempt to instrument all available libraries for which there are corresponding\ninstrumentations installed on your system.  If you would like to prevent the tracing of particular libraries at run time,\nyou can set the `SIGNALFX_<LIBRARY_NAME>_ENABLED=False` environment variables when launching the `sfx-py-trace` process.\nFor example, to prevent auto-instrumentation of Tornado, you could run:\n\n```sh\n  $ SIGNALFX_TORNADO_ENABLED=False sfx-py-trace my_application.py\n```\n\nThe supported value of each library name is the uppercase form of the corresponding `instrument()`\n[keyword argument](#Supported-Frameworks-and-Libraries).\n\n### Trace Decorator\nNot all applications follow the basic architectural patterns allowed by their frameworks, and no single tool will be\nable to represent all use cases without user input.  To meaningfully unite isolated traces into a single, more\nrepresentative structure, or to decompose large spans into functional units, manual instrumentation will\nbecome necessary.  The SignalFx-Tracing Library provides a helpful function decorator to automatically create spans\nfor tracing your custom logic:\n\n```python\nfrom signalfx_tracing import trace\nimport opentracing\n\nfrom my_app import annotate, compute, report\n\n\n@trace  # uses global opentracing.tracer set by signalfx_tracing.utils.create_tracer()\ndef my_function(arg):  # default span operation name is the name of the function\n    # span will automatically trace duration of my_function() without any modifications necessary\n    annotated = annotate(arg)\n    return MyBusinessLogic().my_other_function(annotated)\n\n\nclass MyBusinessLogic:\n\n    @classmethod  # It's necessary to declare @trace after @classmethod and @staticmethod\n    @trace('MyOperation')  # Specify span operation name\n    def my_other_function(cls, arg):\n        # Using OpenTracing api, it's possible to modify current spans.\n        # This active span is 'MyOperation', the current traced function and child of 'my_function'.\n        span = opentracing.tracer.active_span\n        span.set_tag('MyAnnotation', arg)\n        value = cls.my_additional_function(arg)\n        return report(value)\n\n    @staticmethod\n    @trace('MyOtherOperation',  # Specify span operation name and tags\n           dict(tag_name='tag_value',\n                another_tag_name='another_tag_value'))\n    def my_additional_function(arg):\n        span = opentracing.tracer.active_span  # This active span is 'MyOtherOperation', the child of 'MyOperation'.\n        value = compute(arg)\n        span.set_tag('ComputedValue', value)\n        return value\n```\n\nIn the above example, any invocation of `my_function()` will result in a trace consisting of at least three spans\nwhose relationship mirrors the call graph.  If `my_function()` were to be called from another traced function or\nauto-instrumented request handler, its resulting span would be parented by that caller function's span.\n\n**Note: As the example shows, `@trace` must be applied to traced methods before the `@classmethod` and `@staticmethod`\ndecorators are evaluated (declared after), as the utility doesn't account for their respective descriptor\nimplementations at this time. Not doing so will likely cause undesired behavior in your application.**", "description_content_type": "text/markdown", "docs_url": null, "download_url": "http://github.com/signalfx/signalfx-python-tracing/tarball/master", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/signalfx/signalfx-python-tracing", "keywords": "", "license": "Apache Software License v2", "maintainer": "", "maintainer_email": "", "name": "signalfx-tracing", "package_url": "https://pypi.org/project/signalfx-tracing/", "platform": "", "project_url": "https://pypi.org/project/signalfx-tracing/", "project_urls": {"Download": "http://github.com/signalfx/signalfx-python-tracing/tarball/master", "Homepage": "http://github.com/signalfx/signalfx-python-tracing"}, "release_url": "https://pypi.org/project/signalfx-tracing/0.0.16/", "requires_dist": null, "requires_python": "", "summary": "Provides auto-instrumentation for OpenTracing-traced libraries and frameworks", "version": "0.0.16", "yanked": false, "html_description": "<div class=\"project-description\">\n            <h1>SignalFx-Tracing Library for Python: An OpenTracing Auto-Instrumentor</h1>\n<p>This utility provides users with the ability of automatically configuring\nOpenTracing 2.0-compatible community-contributed <a href=\"https://github.com/opentracing-contrib\" rel=\"nofollow\">instrumentation libraries</a>\nfor their Python 2.7 and 3.4+ applications via a single function.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">signalfx_tracing</span> <span class=\"kn\">import</span> <span class=\"n\">auto_instrument</span><span class=\"p\">,</span> <span class=\"n\">create_tracer</span>\n\n<span class=\"n\">tracer</span> <span class=\"o\">=</span> <span class=\"n\">create_tracer</span><span class=\"p\">(</span><span class=\"n\">service_name</span><span class=\"o\">=</span><span class=\"s1\">'MyService'</span><span class=\"p\">)</span>\n<span class=\"n\">auto_instrument</span><span class=\"p\">(</span><span class=\"n\">tracer</span><span class=\"p\">)</span>\n</pre>\n<p>If auto-instrumentation of all applicable libraries and frameworks isn't desired,\nenabling instrumentation individually can be done by specifying your target module:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">signalfx_tracing</span> <span class=\"kn\">import</span> <span class=\"n\">create_tracer</span><span class=\"p\">,</span> <span class=\"n\">instrument</span><span class=\"p\">,</span> <span class=\"n\">uninstrument</span>\n\n<span class=\"n\">tracer</span> <span class=\"o\">=</span> <span class=\"n\">create_tracer</span><span class=\"p\">()</span>\n<span class=\"n\">instrument</span><span class=\"p\">(</span><span class=\"n\">tracer</span><span class=\"p\">,</span> <span class=\"n\">flask</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"c1\"># or</span>\n<span class=\"n\">instrument</span><span class=\"p\">(</span><span class=\"n\">flask</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>  <span class=\"c1\"># uses the global Tracer from opentracing.tracer by default</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">flask</span>\n\n<span class=\"n\">traced_app</span> <span class=\"o\">=</span> <span class=\"n\">flask</span><span class=\"o\">.</span><span class=\"n\">Flask</span><span class=\"p\">(</span><span class=\"s1\">'MyTracedApplication'</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@traced_app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/hello_world'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">traced_route</span><span class=\"p\">():</span>\n    <span class=\"c1\"># Obtain active span created by traced middleware</span>\n    <span class=\"n\">span</span> <span class=\"o\">=</span> <span class=\"n\">tracer</span><span class=\"o\">.</span><span class=\"n\">scope_manager</span><span class=\"o\">.</span><span class=\"n\">active</span><span class=\"o\">.</span><span class=\"n\">span</span>\n    <span class=\"n\">span</span><span class=\"o\">.</span><span class=\"n\">set_tag</span><span class=\"p\">(</span><span class=\"s1\">'Hello'</span><span class=\"p\">,</span> <span class=\"s1\">'World'</span><span class=\"p\">)</span>\n    <span class=\"n\">span</span><span class=\"o\">.</span><span class=\"n\">log_kv</span><span class=\"p\">({</span><span class=\"s1\">'event'</span><span class=\"p\">:</span> <span class=\"s1\">'initiated'</span><span class=\"p\">})</span>\n    <span class=\"k\">return</span> <span class=\"s1\">'Hello!'</span>  <span class=\"c1\"># Span is automatically finished after request handler</span>\n\n<span class=\"n\">uninstrument</span><span class=\"p\">(</span><span class=\"s1\">'flask'</span><span class=\"p\">)</span>  <span class=\"c1\"># prevent future registrations</span>\n\n<span class=\"n\">untraced_app</span> <span class=\"o\">=</span> <span class=\"n\">flask</span><span class=\"o\">.</span><span class=\"n\">Flask</span><span class=\"p\">(</span><span class=\"s1\">'MyUntracedApplication'</span><span class=\"p\">)</span>\n\n<span class=\"nd\">@untraced_app</span><span class=\"o\">.</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"s1\">'/untraced_hello_world'</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">untraced_route</span><span class=\"p\">():</span>\n    <span class=\"k\">return</span> <span class=\"s1\">'Goodbye!'</span>\n</pre>\n<p><strong>Note: Both <code>instrument()</code> and <code>auto_instrument()</code> invocations can be converted to no-ops if the\n<code>SIGNALFX_TRACING_ENABLED</code> environment variable is set to <code>False</code> or <code>0</code>.  This can be helpful when developing your\nauto-instrumented application locally or in test environments.</strong></p>\n<h2>Supported Frameworks and Libraries</h2>\n<ul>\n<li><a href=\"./signalfx_tracing/libraries/celery_/README.md\" rel=\"nofollow\">Celery 3.1+</a> - <code>instrument(celery=True)</code></li>\n<li><a href=\"./signalfx_tracing/libraries/django_/README.md\" rel=\"nofollow\">Django 1.8+</a> - <code>instrument(django=True)</code></li>\n<li><a href=\"./signalfx_tracing/libraries/elasticsearch_/README.md\" rel=\"nofollow\">Elasticsearch 2.0+</a> - <code>instrument(elasticsearch=True)</code></li>\n<li><a href=\"./signalfx_tracing/libraries/flask_/README.md\" rel=\"nofollow\">Flask 0.10+</a> - <code>instrument(flask=True)</code></li>\n<li><a href=\"./signalfx_tracing/libraries/psycopg2_/README.md\" rel=\"nofollow\">Psycopg 2.7+</a> - <code>instrument(psycopg2=True)</code></li>\n<li><a href=\"./signalfx_tracing/libraries/pymongo_/README.md\" rel=\"nofollow\">PyMongo 3.1+</a> - <code>instrument(pymongo=True)</code></li>\n<li><a href=\"./signalfx_tracing/libraries/pymysql_/README.md\" rel=\"nofollow\">PyMySQL 0.8+</a> - <code>instrument(pymysql=True)</code></li>\n<li><a href=\"./signalfx_tracing/libraries/redis_/README.md\" rel=\"nofollow\">Redis-Py 2.10+</a> - <code>instrument(redis=True)</code></li>\n<li><a href=\"./signalfx_tracing/libraries/requests_/README.md\" rel=\"nofollow\">Requests 2.0+</a> - <code>instrument(requests=True)</code></li>\n<li><a href=\"./signalfx_tracing/libraries/tornado_/README.md\" rel=\"nofollow\">Tornado 4.3-6.x</a> - <code>instrument(tornado=True)</code></li>\n</ul>\n<h2>Installation and Configuration</h2>\n<h3>Library and Instrumentors</h3>\n<p>The SignalFx-Tracing Library for Python works by detecting your libraries and frameworks and configuring available\ninstrumentors for distributed tracing via the Python <a href=\"https://pypi.org/project/opentracing/2.0.0/\" rel=\"nofollow\">OpenTracing API 2.0</a>.\nBy default, its footprint is small and doesn't declare any instrumentors as dependencies. That is, it operates on the\nassumption that you have 2.0-compatible instrumentors installed as needed. As adoption of this API is done on a\nper-instrumentor basis, it's highly recommended you use the helpful <a href=\"./scripts/README.md\" rel=\"nofollow\">bootstrap utility</a> for\nobtaining and installing any applicable, feature-ready instrumentors along with a compatible tracer:</p>\n<pre>  $ pip install signalfx-tracing\n  $ sfx-py-trace-bootstrap\n</pre>\n<p>For example, if your environment has Requests and Flask in its Python path, the corresponding OpenTracing\ninstrumentors will be pip installed.  Again, since OpenTracing-Contrib instrumentation support of API 2.0 is not\nubiquitous, this bootstrap selectively installs custom instrumentors listed in\n<a href=\"./requirements-inst.txt\" rel=\"nofollow\">the instrumentor requirements file</a>.  As such, we suggest being sure to uninstall any previous\ninstrumentor versions before running the bootstrapper, ideally in a clean environment.</p>\n<p>To run the instrumentor bootstrap process without installing the suggested tracer, you can run the following from this\nproject's source tree:</p>\n<pre>  $ scripts/bootstrap.py --deps-only\n</pre>\n<p>You can also specify a target installation directory, which will include the most recent <code>signalfx-tracing</code> as provided\nby PyPI:</p>\n<pre>  $ sfx-py-trace-bootstrap -t /my/site/packages/directory\n</pre>\n<p>It's also possible to install the supported instrumentors as package extras from a cloned repository:</p>\n<pre>  $ git clone https://github.com/signalfx/signalfx-python-tracing.git\n  <span class=\"c1\"># Supported extras are dbapi, django, flask, pymongo, pymysql, redis, requests, tornado</span>\n  $ pip install <span class=\"s1\">'./signalfx-python-tracing[django,redis,requests]'</span>\n</pre>\n<p><strong>Note: For pip versions earlier than 18.0, it's necessary to include <code>--process-dependency-links</code> to\nobtain the desired instrumentor versions.</strong></p>\n<pre>  $ git clone https://github.com/signalfx/signalfx-python-tracing.git\n  <span class=\"c1\"># pip versions &lt;18.0</span>\n  $ pip install --process-dependency-links <span class=\"s1\">'./signalfx-python-tracing[jaeger,tornado]'</span>\n</pre>\n<h3>Tracer</h3>\n<p>Not all stable versions of OpenTracing-compatible tracers support the 2.0 API, so we provide\nand recommend installing a modified <a href=\"https://github.com/jaegertracing/jaeger-client-python\" rel=\"nofollow\">Jaeger Client</a>\nready for reporting to SignalFx. You can obtain an instance of the suggested Jaeger tracer using a\n<code>signalfx_tracing.utils.create_tracer()</code> helper, provided you've run:</p>\n<pre>  $ sfx-py-trace-bootstrap\n\n  <span class=\"c1\"># or as package extra</span>\n  $ pip install <span class=\"s1\">'./signalfx-python-tracing[jaeger]'</span>\n  <span class=\"c1\"># please use required --process-dependency-links for pip versions &lt;18.0 </span>\n  $ pip install --process-dependency-links <span class=\"s1\">'./signalfx-python-tracing[jaeger]'</span>\n\n  <span class=\"c1\"># or from project source tree, along with applicable instrumentors</span>\n  $ scripts/bootstrap.py --jaeger\n\n  <span class=\"c1\"># or to avoid applicable instrumentors</span>\n  $ scripts/bootstrap.py --jaeger-only\n</pre>\n<p>By default <code>create_tracer()</code> will enable tracing with constant sampling (100% chance of tracing) and report each span\ndirectly to SignalFx. Where applicable, context propagation will be done via\n<a href=\"https://github.com/openzipkin/b3-propagation\" rel=\"nofollow\">B3 headers</a>.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">signalfx_tracing</span> <span class=\"kn\">import</span> <span class=\"n\">create_tracer</span>\n\n<span class=\"c1\"># sets the global opentracing.tracer by default:</span>\n<span class=\"n\">tracer</span> <span class=\"o\">=</span> <span class=\"n\">create_tracer</span><span class=\"p\">()</span>  <span class=\"c1\"># uses 'SIGNALFX_ACCESS_TOKEN' environment variable if provided</span>\n\n<span class=\"c1\"># or directly provide your organization access token if not using the Smart Agent to analyze spans:</span>\n<span class=\"n\">tracer</span> <span class=\"o\">=</span> <span class=\"n\">create_tracer</span><span class=\"p\">(</span><span class=\"s1\">'&lt;OrganizationAccessToken&gt;'</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># or to disable setting the global tracer:</span>\n<span class=\"n\">tracer</span> <span class=\"o\">=</span> <span class=\"n\">create_tracer</span><span class=\"p\">(</span><span class=\"n\">set_global</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n</pre>\n<p>All other <code>create_tracer()</code> arguments are those that can be passed to a <code>jaeger_client.Config</code> constructor:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">tornado_opentracing.scope_managers</span> <span class=\"kn\">import</span> <span class=\"n\">TornadoScopeManager</span>\n<span class=\"kn\">from</span> <span class=\"nn\">signalfx_tracing</span> <span class=\"kn\">import</span> <span class=\"n\">create_tracer</span>\n\n<span class=\"n\">tracer</span> <span class=\"o\">=</span> <span class=\"n\">create_tracer</span><span class=\"p\">(</span>\n    <span class=\"s1\">'&lt;OptionalOrganizationAccessToken&gt;'</span><span class=\"p\">,</span>\n    <span class=\"n\">config</span><span class=\"o\">=</span><span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">jaeger_endpoint</span><span class=\"o\">=</span><span class=\"s1\">'http://localhost:9080/v1/trace'</span><span class=\"p\">),</span>\n    <span class=\"n\">service_name</span><span class=\"o\">=</span><span class=\"s1\">'MyTracedApplication'</span><span class=\"p\">,</span>\n    <span class=\"n\">scope_manager</span><span class=\"o\">=</span><span class=\"n\">TornadoScopeManager</span>  <span class=\"c1\"># Necessary for span scope in Tornado applications</span>\n<span class=\"p\">)</span>\n</pre>\n<p>If a <code>config</code> dictionary isn't provided or doesn't specify the desired items for your tracer, the following environment\nvariables are checked for before selecting a default value:</p>\n<table>\n<thead>\n<tr>\n<th>Config kwarg</th>\n<th>environment variable</th>\n<th>default value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>service_name</code></td>\n<td><code>SIGNALFX_SERVICE_NAME</code></td>\n<td><code>'SignalFx-Tracing'</code></td>\n</tr>\n<tr>\n<td><code>jaeger_endpoint</code></td>\n<td><code>SIGNALFX_ENDPOINT_URL</code></td>\n<td><code>'http://localhost:9080/v1/trace'</code></td>\n</tr>\n<tr>\n<td><code>jaeger_password</code></td>\n<td><code>SIGNALFX_ACCESS_TOKEN</code></td>\n<td><code>None</code></td>\n</tr>\n<tr>\n<td><code>['sampler']['type']</code></td>\n<td><code>SIGNALFX_SAMPLER_TYPE</code></td>\n<td><code>'const'</code></td>\n</tr>\n<tr>\n<td><code>['sampler']['param']</code></td>\n<td><code>SIGNALFX_SAMPLER_PARAM</code></td>\n<td><code>1</code></td>\n</tr>\n<tr>\n<td><code>propagation</code></td>\n<td><code>SIGNALFX_PROPAGATION</code></td>\n<td><code>'b3'</code></td>\n</tr></tbody></table>\n<p><strong>Note: By default <code>create_tracer()</code> will store the initial tracer created upon first invocation and return\nthat instance for subsequent invocations.  If for some reason multiple tracers are needed, you can provide\n<code>create_tracer(allow_multiple=True)</code> as a named argument.</strong></p>\n<h2>Usage</h2>\n<h3>Application Runner</h3>\n<p>The SignalFx-Tracing Library for Python's auto-instrumentation configuration can be performed while loading\nyour framework-based and library-utilizing application as described in the corresponding\n<a href=\"#supported-frameworks-and-libraries\" rel=\"nofollow\">instrumentation instructions</a>.\nHowever, if you have installed the recommended <a href=\"#Tracer\" rel=\"nofollow\">Jaeger client</a> (<code>sfx-py-trace-bootstrap</code>) and would like to\nautomatically instrument your applicable program with the default settings, a helpful <code>sfx-py-trace</code> entry point\nis provided by the installer:</p>\n<pre>  $ sfx-py-trace my_application.py --app_arg_one --app_arg_two\n  <span class=\"c1\"># Or if your Smart Agent is not available at the default endpoint url:</span>\n  $ <span class=\"nv\">SIGNALFX_ENDPOINT_URL</span><span class=\"o\">=</span><span class=\"s1\">'http://MySmartAgent:9080/v1/trace'</span> sfx-py-trace my_application.py\n</pre>\n<p><strong>Note: <code>sfx-py-trace</code> cannot, by itself, enable auto-instrumentation of Django projects, as the <code>signalfx_tracing</code>\ninstrumentor must still be added to the project settings' installed apps.  Once the application is specified,\n<code>sfx-py-trace</code> may be used as described in the <a href=\"./signalfx_tracing/libraries/django_/README.md\" rel=\"nofollow\">Django instrumentation documentation</a>.</strong></p>\n<p>This command line script loader will create a Jaeger tracer instance using the access token specified via\nenvironment variable or argument to report your spans to SignalFx.  It will then call <code>auto_instrument()</code> before\nrunning your target application file in its own module namespace.  It's important to note that due to potential\ndeadlocks in importing forking code, the standard Jaeger tracer cannot be initialized as a side effect of an import\nstatement (see: <a href=\"https://docs.python.org/2/library/threading.html#importing-in-threaded-code\" rel=\"nofollow\">Python threading doc</a> and\n<a href=\"https://github.com/jaegertracing/jaeger-client-python/issues/60#issuecomment-318909730\" rel=\"nofollow\">known Jaeger issue</a>).\nBecause of this issue, and for general lack of HTTP reporting support, we highly suggest you use our modified <a href=\"#Tracer\" rel=\"nofollow\">Jaeger\ntracer</a> that provides deferred thread creation to avoid this constraint.</p>\n<p>The application runner will by default attempt to instrument all available libraries for which there are corresponding\ninstrumentations installed on your system.  If you would like to prevent the tracing of particular libraries at run time,\nyou can set the <code>SIGNALFX_&lt;LIBRARY_NAME&gt;_ENABLED=False</code> environment variables when launching the <code>sfx-py-trace</code> process.\nFor example, to prevent auto-instrumentation of Tornado, you could run:</p>\n<pre>  $ <span class=\"nv\">SIGNALFX_TORNADO_ENABLED</span><span class=\"o\">=</span>False sfx-py-trace my_application.py\n</pre>\n<p>The supported value of each library name is the uppercase form of the corresponding <code>instrument()</code>\n<a href=\"#Supported-Frameworks-and-Libraries\" rel=\"nofollow\">keyword argument</a>.</p>\n<h3>Trace Decorator</h3>\n<p>Not all applications follow the basic architectural patterns allowed by their frameworks, and no single tool will be\nable to represent all use cases without user input.  To meaningfully unite isolated traces into a single, more\nrepresentative structure, or to decompose large spans into functional units, manual instrumentation will\nbecome necessary.  The SignalFx-Tracing Library provides a helpful function decorator to automatically create spans\nfor tracing your custom logic:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">signalfx_tracing</span> <span class=\"kn\">import</span> <span class=\"n\">trace</span>\n<span class=\"kn\">import</span> <span class=\"nn\">opentracing</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">my_app</span> <span class=\"kn\">import</span> <span class=\"n\">annotate</span><span class=\"p\">,</span> <span class=\"n\">compute</span><span class=\"p\">,</span> <span class=\"n\">report</span>\n\n\n<span class=\"nd\">@trace</span>  <span class=\"c1\"># uses global opentracing.tracer set by signalfx_tracing.utils.create_tracer()</span>\n<span class=\"k\">def</span> <span class=\"nf\">my_function</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>  <span class=\"c1\"># default span operation name is the name of the function</span>\n    <span class=\"c1\"># span will automatically trace duration of my_function() without any modifications necessary</span>\n    <span class=\"n\">annotated</span> <span class=\"o\">=</span> <span class=\"n\">annotate</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">MyBusinessLogic</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">my_other_function</span><span class=\"p\">(</span><span class=\"n\">annotated</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">MyBusinessLogic</span><span class=\"p\">:</span>\n\n    <span class=\"nd\">@classmethod</span>  <span class=\"c1\"># It's necessary to declare @trace after @classmethod and @staticmethod</span>\n    <span class=\"nd\">@trace</span><span class=\"p\">(</span><span class=\"s1\">'MyOperation'</span><span class=\"p\">)</span>  <span class=\"c1\"># Specify span operation name</span>\n    <span class=\"k\">def</span> <span class=\"nf\">my_other_function</span><span class=\"p\">(</span><span class=\"bp\">cls</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Using OpenTracing api, it's possible to modify current spans.</span>\n        <span class=\"c1\"># This active span is 'MyOperation', the current traced function and child of 'my_function'.</span>\n        <span class=\"n\">span</span> <span class=\"o\">=</span> <span class=\"n\">opentracing</span><span class=\"o\">.</span><span class=\"n\">tracer</span><span class=\"o\">.</span><span class=\"n\">active_span</span>\n        <span class=\"n\">span</span><span class=\"o\">.</span><span class=\"n\">set_tag</span><span class=\"p\">(</span><span class=\"s1\">'MyAnnotation'</span><span class=\"p\">,</span> <span class=\"n\">arg</span><span class=\"p\">)</span>\n        <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"bp\">cls</span><span class=\"o\">.</span><span class=\"n\">my_additional_function</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">report</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n\n    <span class=\"nd\">@staticmethod</span>\n    <span class=\"nd\">@trace</span><span class=\"p\">(</span><span class=\"s1\">'MyOtherOperation'</span><span class=\"p\">,</span>  <span class=\"c1\"># Specify span operation name and tags</span>\n           <span class=\"nb\">dict</span><span class=\"p\">(</span><span class=\"n\">tag_name</span><span class=\"o\">=</span><span class=\"s1\">'tag_value'</span><span class=\"p\">,</span>\n                <span class=\"n\">another_tag_name</span><span class=\"o\">=</span><span class=\"s1\">'another_tag_value'</span><span class=\"p\">))</span>\n    <span class=\"k\">def</span> <span class=\"nf\">my_additional_function</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">):</span>\n        <span class=\"n\">span</span> <span class=\"o\">=</span> <span class=\"n\">opentracing</span><span class=\"o\">.</span><span class=\"n\">tracer</span><span class=\"o\">.</span><span class=\"n\">active_span</span>  <span class=\"c1\"># This active span is 'MyOtherOperation', the child of 'MyOperation'.</span>\n        <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">compute</span><span class=\"p\">(</span><span class=\"n\">arg</span><span class=\"p\">)</span>\n        <span class=\"n\">span</span><span class=\"o\">.</span><span class=\"n\">set_tag</span><span class=\"p\">(</span><span class=\"s1\">'ComputedValue'</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">value</span>\n</pre>\n<p>In the above example, any invocation of <code>my_function()</code> will result in a trace consisting of at least three spans\nwhose relationship mirrors the call graph.  If <code>my_function()</code> were to be called from another traced function or\nauto-instrumented request handler, its resulting span would be parented by that caller function's span.</p>\n<p><strong>Note: As the example shows, <code>@trace</code> must be applied to traced methods before the <code>@classmethod</code> and <code>@staticmethod</code>\ndecorators are evaluated (declared after), as the utility doesn't account for their respective descriptor\nimplementations at this time. Not doing so will likely cause undesired behavior in your application.</strong></p>\n\n          </div>"}, "last_serial": 6846688, "releases": {"0.0.0": [{"comment_text": "", "digests": {"md5": "885663d0d099551d24bf33f848a8d359", "sha256": "62a4960a65694a0d63c5e13a5d68b0b497f644a915ca53ae01d8b14e8f5a32bb"}, "downloads": -1, "filename": "signalfx-tracing-0.0.0.tar.gz", "has_sig": false, "md5_digest": "885663d0d099551d24bf33f848a8d359", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29252, "upload_time": "2018-12-14T22:06:48", "upload_time_iso_8601": "2018-12-14T22:06:48.388097Z", "url": "https://files.pythonhosted.org/packages/91/4c/42eefa24022a593e38be6698d7d94511712f24fdfd6c8c5d0b1b19231eba/signalfx-tracing-0.0.0.tar.gz", "yanked": false}], "0.0.0.1": [{"comment_text": "", "digests": {"md5": "cda4bf853e24bde4ac4b5920028b121d", "sha256": "69c57ffdf77aabee9f701af89f3259521c9f94243ecb999bdcb4adc42c833991"}, "downloads": -1, "filename": "signalfx-tracing-0.0.0.1.tar.gz", "has_sig": false, "md5_digest": "cda4bf853e24bde4ac4b5920028b121d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19381, "upload_time": "2018-12-17T15:39:02", "upload_time_iso_8601": "2018-12-17T15:39:02.637831Z", "url": "https://files.pythonhosted.org/packages/a0/a9/0b1f02f300cad2c42c651f01ca7987dec24cab4af6164533e58aa08ab989/signalfx-tracing-0.0.0.1.tar.gz", "yanked": false}], "0.0.1": [{"comment_text": "", "digests": {"md5": "dfe6c4aeb7a5e6332883429b4410f916", "sha256": "51316bf357379d38410e3df64a390b74b8c793fc70ef9812101b83b075378fa9"}, "downloads": -1, "filename": "signalfx-tracing-0.0.1.tar.gz", "has_sig": false, "md5_digest": "dfe6c4aeb7a5e6332883429b4410f916", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19431, "upload_time": "2018-12-18T00:59:38", "upload_time_iso_8601": "2018-12-18T00:59:38.976656Z", "url": "https://files.pythonhosted.org/packages/28/85/d0a7cf863dc804b23fbbf7434b037b104a36dab04a14daf293160e4472aa/signalfx-tracing-0.0.1.tar.gz", "yanked": false}], "0.0.10": [{"comment_text": "", "digests": {"md5": "29505e0f928f7425ab9c4c361e6fd961", "sha256": "7ee2f11dda8adddc3f6f487f01a0e28fb39d0526aafb1ebf5a28db3bb46663dd"}, "downloads": -1, "filename": "signalfx-tracing-0.0.10.tar.gz", "has_sig": false, "md5_digest": "29505e0f928f7425ab9c4c361e6fd961", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23635, "upload_time": "2019-05-06T15:42:06", "upload_time_iso_8601": "2019-05-06T15:42:06.463778Z", "url": "https://files.pythonhosted.org/packages/71/6c/40cfcf6dc0e4ebe787b3d27c2498ec66e1996ba08afb72a9463a808c5ab6/signalfx-tracing-0.0.10.tar.gz", "yanked": false}], "0.0.11": [{"comment_text": "", "digests": {"md5": "47d858aae403587a214ed32b9544c199", "sha256": "7b597f3d4f90136f30cb2c23c840deb2f756ae8c7e74e22c5eab941b962a2195"}, "downloads": -1, "filename": "signalfx-tracing-0.0.11.tar.gz", "has_sig": false, "md5_digest": "47d858aae403587a214ed32b9544c199", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26961, "upload_time": "2019-07-12T13:46:02", "upload_time_iso_8601": "2019-07-12T13:46:02.071479Z", "url": "https://files.pythonhosted.org/packages/d9/e6/fad1aca7cb3f5cfa579086019ee7d7f71a30a363dcf2d6ff62f5bc9b6d56/signalfx-tracing-0.0.11.tar.gz", "yanked": false}], "0.0.12": [{"comment_text": "", "digests": {"md5": "4177ef985efea9959df0bf0d0bada457", "sha256": "5f0c677048ed035799ad0e0396ed8f7430cbde6c8f30f1dca9809cea6d572650"}, "downloads": -1, "filename": "signalfx-tracing-0.0.12.tar.gz", "has_sig": false, "md5_digest": "4177ef985efea9959df0bf0d0bada457", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27095, "upload_time": "2019-07-19T18:44:30", "upload_time_iso_8601": "2019-07-19T18:44:30.145837Z", "url": "https://files.pythonhosted.org/packages/4b/05/3cf6d2e35a880e3e1387196a549daff4c00254e3090180a2e12e58f4f683/signalfx-tracing-0.0.12.tar.gz", "yanked": false}], "0.0.12.1": [{"comment_text": "", "digests": {"md5": "20353dabaa5c477cbb3dced06ef22f19", "sha256": "31fcf5c623ef51a447c8e1370ae8d1c57c049a192bb8df1486566591ccfbbfaf"}, "downloads": -1, "filename": "signalfx-tracing-0.0.12.1.tar.gz", "has_sig": false, "md5_digest": "20353dabaa5c477cbb3dced06ef22f19", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27120, "upload_time": "2019-07-23T21:41:51", "upload_time_iso_8601": "2019-07-23T21:41:51.282189Z", "url": "https://files.pythonhosted.org/packages/de/a6/45326bf14fb6e84a8fd39deb18a1693865752b21424576b6ed8cf4ec0882/signalfx-tracing-0.0.12.1.tar.gz", "yanked": false}], "0.0.13": [{"comment_text": "", "digests": {"md5": "bba83a937806b2b99696052a1c9f228f", "sha256": "fe63b9825eea2ecc2f0d1cf65ac3e1643a391cd984cdffc134c092ef02ee9f22"}, "downloads": -1, "filename": "signalfx-tracing-0.0.13.tar.gz", "has_sig": false, "md5_digest": "bba83a937806b2b99696052a1c9f228f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28075, "upload_time": "2019-09-25T11:05:53", "upload_time_iso_8601": "2019-09-25T11:05:53.178166Z", "url": "https://files.pythonhosted.org/packages/ad/39/08e82def093678166b0ced3b8fce2c76a8dba0e4a811b5714d21d561ccb2/signalfx-tracing-0.0.13.tar.gz", "yanked": false}], "0.0.14": [{"comment_text": "", "digests": {"md5": "f941c5ae56056bd88d65a4f9a79b3759", "sha256": "19fef76644ea597618f321740005da54a9c7064b802479bc374963ec4aab883a"}, "downloads": -1, "filename": "signalfx-tracing-0.0.14.tar.gz", "has_sig": false, "md5_digest": "f941c5ae56056bd88d65a4f9a79b3759", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28104, "upload_time": "2019-11-06T15:19:17", "upload_time_iso_8601": "2019-11-06T15:19:17.491910Z", "url": "https://files.pythonhosted.org/packages/23/db/74ba1fb9830bd9647d9e2950179ce5c4fd7e73f023fa49210b61741c6c41/signalfx-tracing-0.0.14.tar.gz", "yanked": false}], "0.0.14.1": [{"comment_text": "", "digests": {"md5": "1eb5d531947522d4439d1d305689b7cb", "sha256": "beb642789959430c86c5651561c6fa5070b2eac2e3edef4bed68aa4732f1df67"}, "downloads": -1, "filename": "signalfx-tracing-0.0.14.1.tar.gz", "has_sig": false, "md5_digest": "1eb5d531947522d4439d1d305689b7cb", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28120, "upload_time": "2019-11-06T15:24:25", "upload_time_iso_8601": "2019-11-06T15:24:25.951324Z", "url": "https://files.pythonhosted.org/packages/2b/b3/78a7292a4230a70c39ad6ba86ee22d7eb0ac87a0a23774d4ec24f327feec/signalfx-tracing-0.0.14.1.tar.gz", "yanked": false}], "0.0.15": [{"comment_text": "", "digests": {"md5": "31525151ece58ec9878afb22fd7e8758", "sha256": "6b53e967c2193cac5429275389db4e0bfac1c3e39165ee966a7bd0f22ba3804b"}, "downloads": -1, "filename": "signalfx-tracing-0.0.15.tar.gz", "has_sig": false, "md5_digest": "31525151ece58ec9878afb22fd7e8758", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28779, "upload_time": "2020-02-14T21:50:40", "upload_time_iso_8601": "2020-02-14T21:50:40.801248Z", "url": "https://files.pythonhosted.org/packages/da/cc/bbf3c832238aca54e44d8ee33726a2e0ef9ac0149f6da89b5068c1ef339f/signalfx-tracing-0.0.15.tar.gz", "yanked": false}], "0.0.16": [{"comment_text": "", "digests": {"md5": "80ea2b5753ec018253f94f2f260f0152", "sha256": "4da80392e946efecb846e6b1619f1dcdf7daeabe97ed05fb6024cd850879621d"}, "downloads": -1, "filename": "signalfx-tracing-0.0.16.tar.gz", "has_sig": false, "md5_digest": "80ea2b5753ec018253f94f2f260f0152", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28556, "upload_time": "2020-03-19T23:21:46", "upload_time_iso_8601": "2020-03-19T23:21:46.981018Z", "url": "https://files.pythonhosted.org/packages/36/f0/0f72d802384e765407a3f054087cd2c6f0710c0a225a0f5d0900b0069ac9/signalfx-tracing-0.0.16.tar.gz", "yanked": false}], "0.0.2": [{"comment_text": "", "digests": {"md5": "288cd7ff10470e05c015cf2fe702a73d", "sha256": "9ced3de8f19513fb5460fa386f5fbeaf12aea18aaf7e4aafd912e1e7c72b9ba4"}, "downloads": -1, "filename": "signalfx-tracing-0.0.2.tar.gz", "has_sig": false, "md5_digest": "288cd7ff10470e05c015cf2fe702a73d", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19568, "upload_time": "2019-01-04T22:32:12", "upload_time_iso_8601": "2019-01-04T22:32:12.349759Z", "url": "https://files.pythonhosted.org/packages/a5/df/592e95afe4d75f122c053e485c8fdc7f60d70df2bb8bd45476d034e4d685/signalfx-tracing-0.0.2.tar.gz", "yanked": false}], "0.0.2.1": [{"comment_text": "", "digests": {"md5": "7b0dec6d7a1bb26e98470b30fc0dd117", "sha256": "a5e80e38126a962ac33face80a14685ec51b1353c9e20c023e121d12ac76fae9"}, "downloads": -1, "filename": "signalfx-tracing-0.0.2.1.tar.gz", "has_sig": false, "md5_digest": "7b0dec6d7a1bb26e98470b30fc0dd117", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19562, "upload_time": "2019-01-04T22:35:19", "upload_time_iso_8601": "2019-01-04T22:35:19.328144Z", "url": "https://files.pythonhosted.org/packages/76/74/42b70f188d56ba56578a92d0fcffab820f7ef28a04044d149a05f8e4cc01/signalfx-tracing-0.0.2.1.tar.gz", "yanked": false}], "0.0.3": [{"comment_text": "", "digests": {"md5": "2d1385177d998b1a8a9410b9f7552566", "sha256": "294ea628436b11afbe98e71ff3bf6d750bc2ca7fd82548fe7c2b7b8f4bcfdb39"}, "downloads": -1, "filename": "signalfx-tracing-0.0.3.tar.gz", "has_sig": false, "md5_digest": "2d1385177d998b1a8a9410b9f7552566", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20189, "upload_time": "2019-01-09T20:48:32", "upload_time_iso_8601": "2019-01-09T20:48:32.012664Z", "url": "https://files.pythonhosted.org/packages/76/9c/620af371ac158dccb8a67d65607a90cb8d22f0fb93358f18e0eed43351da/signalfx-tracing-0.0.3.tar.gz", "yanked": false}], "0.0.4": [{"comment_text": "", "digests": {"md5": "3d35fa4b2b3d224ad06f713d6f74635c", "sha256": "9f23b9310f0d1172d08940da229b4133dfc381fc5a75b59364cf28626ba49855"}, "downloads": -1, "filename": "signalfx-tracing-0.0.4.tar.gz", "has_sig": false, "md5_digest": "3d35fa4b2b3d224ad06f713d6f74635c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 20928, "upload_time": "2019-01-17T20:44:25", "upload_time_iso_8601": "2019-01-17T20:44:25.363597Z", "url": "https://files.pythonhosted.org/packages/83/f6/4d87c82b3b5657bf4abeeccaad5ec5f8b274f060ae48ad74abec6648be4d/signalfx-tracing-0.0.4.tar.gz", "yanked": false}], "0.0.5": [{"comment_text": "", "digests": {"md5": "02bcbce8029d72af5e5c3dc95bd7c1e1", "sha256": "98689b7f35670c6331bd991d3028c3fc80981c1d8592baaafe7819c07fbb9abc"}, "downloads": -1, "filename": "signalfx-tracing-0.0.5.tar.gz", "has_sig": false, "md5_digest": "02bcbce8029d72af5e5c3dc95bd7c1e1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21962, "upload_time": "2019-02-04T14:20:48", "upload_time_iso_8601": "2019-02-04T14:20:48.693821Z", "url": "https://files.pythonhosted.org/packages/95/18/c7ecc15f8adb007a30899b184b1a74bf889929f73b0d373326eb70a00c15/signalfx-tracing-0.0.5.tar.gz", "yanked": false}], "0.0.6": [{"comment_text": "", "digests": {"md5": "b8b6d5375cefa2073bd41afc11f3912f", "sha256": "24cd447d317c7a4bf18abd3ee10812314c92f2bd259b6f868e4d343bdfe83054"}, "downloads": -1, "filename": "signalfx-tracing-0.0.6.tar.gz", "has_sig": false, "md5_digest": "b8b6d5375cefa2073bd41afc11f3912f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25048, "upload_time": "2019-02-06T14:51:42", "upload_time_iso_8601": "2019-02-06T14:51:42.150557Z", "url": "https://files.pythonhosted.org/packages/29/06/ba4290c8fdaee5c946315913c4de65dcf23bf6c2b226d8587a05ac981992/signalfx-tracing-0.0.6.tar.gz", "yanked": false}], "0.0.7": [{"comment_text": "", "digests": {"md5": "8740902c2575b75171c2b7a36c064cec", "sha256": "439ec18d7aa742baf2a6299b56f6fc86f10784020ed14cab6bf50af2ff76093a"}, "downloads": -1, "filename": "signalfx-tracing-0.0.7.tar.gz", "has_sig": false, "md5_digest": "8740902c2575b75171c2b7a36c064cec", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 25360, "upload_time": "2019-02-21T22:18:31", "upload_time_iso_8601": "2019-02-21T22:18:31.504415Z", "url": "https://files.pythonhosted.org/packages/a6/c4/406148627ca1de2501539dc32c8855c2db0a5ae85d9d60d5dc1ce36ffc55/signalfx-tracing-0.0.7.tar.gz", "yanked": false}], "0.0.8": [{"comment_text": "", "digests": {"md5": "a5364029cd499924e77a25e1719e0093", "sha256": "92ea99883aa5f634b1d9fa8688b0288fc89bd88cdb5a43476b30288ee00d6b2e"}, "downloads": -1, "filename": "signalfx-tracing-0.0.8.tar.gz", "has_sig": false, "md5_digest": "a5364029cd499924e77a25e1719e0093", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26393, "upload_time": "2019-03-18T18:57:43", "upload_time_iso_8601": "2019-03-18T18:57:43.904525Z", "url": "https://files.pythonhosted.org/packages/48/83/5b45ae05d62eb9ca07fdcd9fec35b9cc168378cdc004e115bd66b4ddd0b6/signalfx-tracing-0.0.8.tar.gz", "yanked": false}], "0.0.9": [{"comment_text": "", "digests": {"md5": "52a44f14e06829acf072ab3755e25fdd", "sha256": "7e67d5e4d2ef7d06a53bd9cf7689ea11abd1e2c301a0d02849d11849a8862a24"}, "downloads": -1, "filename": "signalfx-tracing-0.0.9.tar.gz", "has_sig": false, "md5_digest": "52a44f14e06829acf072ab3755e25fdd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26634, "upload_time": "2019-03-25T13:37:30", "upload_time_iso_8601": "2019-03-25T13:37:30.195259Z", "url": "https://files.pythonhosted.org/packages/9a/50/55731e15d00a82137d7f33aabc8e2f7bd126b34674de36c57c2cf5f0cfba/signalfx-tracing-0.0.9.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "80ea2b5753ec018253f94f2f260f0152", "sha256": "4da80392e946efecb846e6b1619f1dcdf7daeabe97ed05fb6024cd850879621d"}, "downloads": -1, "filename": "signalfx-tracing-0.0.16.tar.gz", "has_sig": false, "md5_digest": "80ea2b5753ec018253f94f2f260f0152", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28556, "upload_time": "2020-03-19T23:21:46", "upload_time_iso_8601": "2020-03-19T23:21:46.981018Z", "url": "https://files.pythonhosted.org/packages/36/f0/0f72d802384e765407a3f054087cd2c6f0710c0a225a0f5d0900b0069ac9/signalfx-tracing-0.0.16.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:11:45 2020"}