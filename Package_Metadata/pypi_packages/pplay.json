{"info": {"author": "Ales Stibal", "author_email": "astib@mag0.net", "bugtrack_url": null, "classifiers": ["License :: OSI Approved :: GNU Lesser General Public License v2 or later (LGPLv2+)", "Operating System :: OS Independent", "Programming Language :: Python :: 2"], "description": "Support\n=======\n\nFor comments, feedback or new feature discussion feel free to drop a message to **pplay-users@googlegroups.com** mailing list.\nIf you can make use of .deb package, visit `download section <https://bitbucket.org/astibal/pplay/downloads/>`_ of this site.\n\nHistory\n=======\n\nrecently I've been in the need of reproducing some issue with DLP, while I was provided with pcap when DLP was not involved in the traffic flow and everything was working.\nOriginally I was trying to utilize netcat, however I've always ended up with some (my) mistake, or simply I just sent CR when it should have been CRLF... Reproduction was frankly tedious task.\n\nThen I gave up on manual work, and tried tcpreplay. This is really fantastic tool in case you want to replay *exactly* what you have in pcap. However I quickly realized that DLP is changing sequential numbers of inspected TCP traffic, so it couldn't have been used it too!! Looking around the net, I decided to write something myself which will help me now and next time it can help others too. \n\nQuick start\n===========\n\nPPlay is tool to replay/resend application data, it doesn't care of transport layer parameters (which we want, reasons described above). It will grab only the payload from connection you explicitly specify and will make new connection and plays the content in the right order. Of course, you will need to run pplay on server and on client too, with the same pcap file parameter and also with other quite important arguments.\n\nAll data about to be sent will be printed out to be confirmed by you. When receiving data, it will tell you if they differ from what we expect and how much; there are 3 levels, OK, modified, different. If they differ significantly (marked as different), they will not be considered as the part of the expected data, so in most cases the logic of packet ordering will stay stable.\n\nOutput is colored; RED means anything related to received stuff, GREEN everything to data to be sent, or YELLOW for command line and other data eligible to be sent in the future but not now. WHITE is usually program notifications. At the first sight pplay's output might look bit a messy, but colors really help.\n\nReplaying PCAP\n==============\n\nList connections you have available\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block::\n\n   $ pplay.py --pcap samples/post-chunked-response.pcap --list\n\n   10.0.0.20:59471 -> 192.168.132.1:80 (starting at frame 0)\n   192.168.132.1:80 -> 10.0.0.20:59471 (starting at frame 1)\n\nRun server side pplay instance\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block::\n\n   $ ./pplay.py --pcap samples/post-chunked-response.pcap --server 127.0.0.2:9999 --connection 10.0.0.20:59471\n\nRun client side instance\n~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block::\n\n   $ ./pplay.py --pcap samples/post-chunked-response.pcap --client 127.0.0.2:9999 --connection 10.0.0.20:59471\n\nReplaying SMCAP (smithproxy captures)\n=====================================\n\nRun server pplay instance\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block::\n\n   $ sudo ./pplay.py  --server 127.0.0.2:9999 --smcap samples/smcap_sample.smcap  --ssl\n                               listen on this IP:PORT                             optionally wrap it with SSL\n\nRun client pplay instance\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block::\n\n   $ ./pplay.py --smcap samples/smcap_sample.smcap --client 127.0.0.2:9999 --ssl\n                                                            connect here     optionally wrap payload with SSL\n\nReplaying PPlayScript\n=====================\n\npplay also knows how to export data to a \"script\". This is extremely convenient to do if you are repeating the same test again and again, needing to change parts of the payload dynamically. Output script is in fact a python class, containing also all necessary data, no --pcap or --smcap arguments are needed anymore.\n\nYou can produce script with --export <scriptname> (filename will be scriptname.py). You can then use it by --script scriptname (instead of --pcap or --smcap arguments).\nFor example:\n\n.. code-block::\n\n   $ ./pplay.py --pcap samples/post-chunked-response.pcap  --connection 10.0.0.20:59471 --export stuff\n\n   Template python script has been exported to file stuff.py\n\nYou can use \"script\" as the sniff file (NOTE: missing .py in --script argument)\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block::\n\n   $ ./pplay.py --script stuff --server 127.0.0.2:9999\n   $ ./pplay.py --script stuff --client 127.0.0.2:9999\n\nMain purpose of it is the need of dynamic modification of the payload, or other \"smart\" stuff, that cannot be predicted and programmed for you in pplay directly.\n\nSimplistic script example:\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block::\n\n   #!python\n\n   import datetime\n\n   class PPlayScript:\n\n       def __init__(self,pplay):\n           # access to pplay engine\n           self.pplay = pplay\n\n           self.packets = []\n           self.packets.append('C1\\r\\n')\n           self.packets.append('S1\\r\\n')\n           self.packets.append('C2\\r\\n')\n           self.packets.append('S2\\r\\n')\n\n           self.origins = {}\n\n           self.server_port = 80\n           self.origins['client']=[0,2]\n           self.origins['server']=[1,3]\n\n\n\n       def before_send(self,role,index,data):\n           # when None returned, no changes will be applied and packets[ origins[role][index] ] will be used\n           if role == 'server' and index == 1:\n               return data + \": %s\"  % (datetime.datetime.now(),)\n\n           return None\n\n       def after_received(self,role,index,data):\n           # return value is ignored: use it as data gathering for further processing\n           return None\n\nAs you might see this gives to your hands power to export existing payload with --export and modify it on the fly as you want. You can make a string templates from it and just paste values as desired, or you can write even quite complex code around!\n\nCreating and using self-contained package\n=========================================\n\nThis feature is extremely useful for automation. You can use SMCAP, PCAP or pplayscript, embed it into pplay itself, \nand use this self-contained pplay version by executing it over the SSH (or the other way, SSH is just the most obvious). \n\nThe rest is just the same normal pplay. Please note that pplay over ssh needs a bit different approach, so we execute it with:\n\n.. code-block::\n\n    --nostdin   - (it's already used by SSH)\n    --auto      - will make transaction waiting times a fraction of second\n    --script +  - (there is plus character) this will instruct to *play embedded pplayscript*\n    --exitoneot - once we received/sent last message in the transaction, exit.\n\n\nLaunch embedded server\n~~~~~~~~~~~~~~~~~~~~~~\n\nPack smcap file into pplay, resulting file in /tmp/smbla.py -- smbla.py will contain pplay and also data from provided smcap file and launch server (on r32 host, options suitable for automation), using packed pplay:\n\n.. code-block::\n\n   pplay.py --smcap samples/smcap_sample.smcap --pack /tmp/smbla\n   ssh r32 python - --script + --server 8002 --auto 0.1 --nostdin --exitoneot < /tmp/smbla.py\n\nLaunch embbedded client\n~~~~~~~~~~~~~~~~~~~~~~~\n\n.. code-block::\n\n   python - --script + --client 10.16.16.1:8002 --auto 0.1 --nostdin --exitoneot < /tmp/smbla.py\n\nPlease note that you need to have installed python-scapy on both remote servers. Of course, SSH needs to be reachable (i.e. you need to create firewall pin-holes for it).\nAlso for (and only for) the automation you might want to create ssh key without the passphrase.\n\nMore details\n============\n\nPPlay forgets everything about original IP addresses. It's because you will be testing it in your lab testbed. Only thing it will remember is the the destination port, for server side pplay it's important, meaning the port where it should *listen* for incoming connections. But that's really it.\n\nClient-side pplay will connect to the server-side. Once connected, you will see on one side green hex data and on the other yellow hex data. For HTTP, the client-side would be typically green, since HTTP comes with the request first. On the line above green hex data you will also see e.g. \"[1/2] (in sync) offer to send -->\". In sync is important here. Those data should be sent now according to pcap.\nIf you see yellow data, that side is not on it's turn, and you will not see also \"(in sync)\" above them.\n\nYellow or green, pplay will act on behalf of you by default in 5 seconds => green data will be sent.\nHint: you can set --noauto, or --auto `<big_seconds>` program argument to change autosend feature. This feature could be also toggled on/off during the operation with \"i\" command shortcut.\n\nLaunch on remote SSH server\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n**new in version 1.7.0**\nYou have learned so far how to \"pack\" data inside *pplay*. It's pretty useful, but you need to always *--pack*\\ , create a file, send it to the other side, and execute there.\nEven though in previous examples we mentioned how to send *pack*\\ ed over ssh stdin, you still need linux command-line ssh.\nSince version 1.7.0 you can actually utilize --remote-ssh parameter, and pplay will send over ssh itself!\n\n.. code-block::\n\n   # this will run pplay on remote server, listening there on port 8000, packing all data needed to impersonate \n   # server from pcap file\n\n   pplay --pcap some_sniffer.pcap --connection 1.1.1.1:12345 --server 8000 --remote-ssh 12.13.14.15:2222 \\\n       --exitoneot --auto 0.1\n\n.. code-block::\n\n   # this will run pplay on remote server, impersonating client, packing all data needed from pcap file\n\n   pplay --pcap some_sniffer.pcap --connection 1.1.1.1:12345 --client 12.13.14.15:8000 \n       --remote-ssh 12.13.14.88:2222 --exitoneot --auto 0.1\n\nNice on this is you don't need anything on remote servers, just pure python. Nothing else is needed.\n\n**Limitation:** since python on remote server receives pplay from stdin which must be closed to actually launch it, commands from standard input are not supported and --nostdin is automatically added to remote command line. Recommended running with ``--exitoneot`` and ``--auto``.\n\nConnect client using SOCKS\n~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAnother useful feature might be to use proxy for client outgoing connection (perhaps you are testing such a proxy, like I am).\nTo do so, use --socks parameter, taking IP address optionally suffixed with a port, ie. 10.0.0.1:1080\n\nCommands\n--------\n\nBelow hex data (green or yellow), there is some contextual help for you: pplay is waiting for your override action to it's default -- autosend. At the time being, you can enter:\n\n.. code-block::\n\n   \"y\" or hit <enter> to send data\n   \"s\" to skip them\n   \"c\" to send CR only\n   \"l\" to send LF only\n   \"x\" to send CR+LF characters\n   \"i\" to disable/enable autosend feature\n   \"r\" command to replace content of the payload with something else. \n       It does have 'vi'-like syntax: r/POST/GET/0 will replace string \"POST\" with \"GET\". \n       Trailing number means max. number of replacements, 0=all\n\n\nData sources\n------------\n\nPPlay also supports smithproxy output, just use --smcap instead of --pcap argument option.\nYou can wrap the traffic into SSL, just use --ssl option. With smithproxy together, pplay is quite powerful pair of tools: you can easily replay \"decrypted\" smcap file from smithproxy and wrap it again into SSL to further test.\n\nHint: Smithproxy it's SSL mitm proxy written by me in C/C++, faking certificate subject. It utilizes iptables TPROXY target. SSL traffic is signed by local CA and plaintext is logged into files.\n\nRequirements\n============\n\nTool doesn't have too requirements. You have to have installed scapy and colorama python packages.\n\nScapy is used to parse pcaps and to have scapy available for future features - runs on Linux, Mac and Windows (see instructions how to install scapy on windows here). It's known to not work in Cygwin.\n\nNote: I am deciding to drop scapy in the future.\nColorama is responsible for multiplatform coloring. On windows, unpack zip-file, run cmd and run python setup.py install. That should make it.\n\nI would recommend to run pplay in linux, I haven't tested it on Windows yet.\n\nSMCAP2PCAP tool\n===============\n\nThis tool is a bit hack. Basically it replays smcap file, while using tcpdump to sniff the traffic. There are dozens of reasons why you would like to convert smcap file to pcap. This is the tool for that purpose.\n\nAlso, this tools is very basic. There is only argument it takes: smcap file. Name and location of the converted pcap will be printed out.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://bitbucket.org/astibal/pplay", "keywords": "", "license": "", "maintainer": "", "maintainer_email": "", "name": "pplay", "package_url": "https://pypi.org/project/pplay/", "platform": "", "project_url": "https://pypi.org/project/pplay/", "project_urls": {"Homepage": "https://bitbucket.org/astibal/pplay"}, "release_url": "https://pypi.org/project/pplay/1.7.4.post1/", "requires_dist": ["colorama", "paramiko", "pysocks", "requests", "scapy"], "requires_python": "", "summary": "tool to replay and work with pcap and smcap (smithproxy capture) files", "version": "1.7.4.post1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"support\">\n<h2>Support</h2>\n<p>For comments, feedback or new feature discussion feel free to drop a message to <strong>pplay-users@googlegroups.com</strong> mailing list.\nIf you can make use of .deb package, visit <a href=\"https://bitbucket.org/astibal/pplay/downloads/\" rel=\"nofollow\">download section</a> of this site.</p>\n</div>\n<div id=\"history\">\n<h2>History</h2>\n<p>recently I\u2019ve been in the need of reproducing some issue with DLP, while I was provided with pcap when DLP was not involved in the traffic flow and everything was working.\nOriginally I was trying to utilize netcat, however I\u2019ve always ended up with some (my) mistake, or simply I just sent CR when it should have been CRLF\u2026 Reproduction was frankly tedious task.</p>\n<p>Then I gave up on manual work, and tried tcpreplay. This is really fantastic tool in case you want to replay <em>exactly</em> what you have in pcap. However I quickly realized that DLP is changing sequential numbers of inspected TCP traffic, so it couldn\u2019t have been used it too!! Looking around the net, I decided to write something myself which will help me now and next time it can help others too.</p>\n</div>\n<div id=\"quick-start\">\n<h2>Quick start</h2>\n<p>PPlay is tool to replay/resend application data, it doesn\u2019t care of transport layer parameters (which we want, reasons described above). It will grab only the payload from connection you explicitly specify and will make new connection and plays the content in the right order. Of course, you will need to run pplay on server and on client too, with the same pcap file parameter and also with other quite important arguments.</p>\n<p>All data about to be sent will be printed out to be confirmed by you. When receiving data, it will tell you if they differ from what we expect and how much; there are 3 levels, OK, modified, different. If they differ significantly (marked as different), they will not be considered as the part of the expected data, so in most cases the logic of packet ordering will stay stable.</p>\n<p>Output is colored; RED means anything related to received stuff, GREEN everything to data to be sent, or YELLOW for command line and other data eligible to be sent in the future but not now. WHITE is usually program notifications. At the first sight pplay\u2019s output might look bit a messy, but colors really help.</p>\n</div>\n<div id=\"replaying-pcap\">\n<h2>Replaying PCAP</h2>\n<div id=\"list-connections-you-have-available\">\n<h3>List connections you have available</h3>\n<pre>$ pplay.py --pcap samples/post-chunked-response.pcap --list\n\n10.0.0.20:59471 -&gt; 192.168.132.1:80 (starting at frame 0)\n192.168.132.1:80 -&gt; 10.0.0.20:59471 (starting at frame 1)\n</pre>\n</div>\n<div id=\"run-server-side-pplay-instance\">\n<h3>Run server side pplay instance</h3>\n<pre>$ ./pplay.py --pcap samples/post-chunked-response.pcap --server 127.0.0.2:9999 --connection 10.0.0.20:59471\n</pre>\n</div>\n<div id=\"run-client-side-instance\">\n<h3>Run client side instance</h3>\n<pre>$ ./pplay.py --pcap samples/post-chunked-response.pcap --client 127.0.0.2:9999 --connection 10.0.0.20:59471\n</pre>\n</div>\n</div>\n<div id=\"replaying-smcap-smithproxy-captures\">\n<h2>Replaying SMCAP (smithproxy captures)</h2>\n<div id=\"run-server-pplay-instance\">\n<h3>Run server pplay instance</h3>\n<pre>$ sudo ./pplay.py  --server 127.0.0.2:9999 --smcap samples/smcap_sample.smcap  --ssl\n                            listen on this IP:PORT                             optionally wrap it with SSL\n</pre>\n</div>\n<div id=\"run-client-pplay-instance\">\n<h3>Run client pplay instance</h3>\n<pre>$ ./pplay.py --smcap samples/smcap_sample.smcap --client 127.0.0.2:9999 --ssl\n                                                         connect here     optionally wrap payload with SSL\n</pre>\n</div>\n</div>\n<div id=\"replaying-pplayscript\">\n<h2>Replaying PPlayScript</h2>\n<p>pplay also knows how to export data to a \u201cscript\u201d. This is extremely convenient to do if you are repeating the same test again and again, needing to change parts of the payload dynamically. Output script is in fact a python class, containing also all necessary data, no \u2013pcap or \u2013smcap arguments are needed anymore.</p>\n<p>You can produce script with \u2013export &lt;scriptname&gt; (filename will be scriptname.py). You can then use it by \u2013script scriptname (instead of \u2013pcap or \u2013smcap arguments).\nFor example:</p>\n<pre>$ ./pplay.py --pcap samples/post-chunked-response.pcap  --connection 10.0.0.20:59471 --export stuff\n\nTemplate python script has been exported to file stuff.py\n</pre>\n<div id=\"you-can-use-script-as-the-sniff-file-note-missing-py-in-script-argument\">\n<h3>You can use \u201cscript\u201d as the sniff file (NOTE: missing .py in \u2013script argument)</h3>\n<pre>$ ./pplay.py --script stuff --server 127.0.0.2:9999\n$ ./pplay.py --script stuff --client 127.0.0.2:9999\n</pre>\n<p>Main purpose of it is the need of dynamic modification of the payload, or other \u201csmart\u201d stuff, that cannot be predicted and programmed for you in pplay directly.</p>\n</div>\n<div id=\"simplistic-script-example\">\n<h3>Simplistic script example:</h3>\n<pre>#!python\n\nimport datetime\n\nclass PPlayScript:\n\n    def __init__(self,pplay):\n        # access to pplay engine\n        self.pplay = pplay\n\n        self.packets = []\n        self.packets.append('C1\\r\\n')\n        self.packets.append('S1\\r\\n')\n        self.packets.append('C2\\r\\n')\n        self.packets.append('S2\\r\\n')\n\n        self.origins = {}\n\n        self.server_port = 80\n        self.origins['client']=[0,2]\n        self.origins['server']=[1,3]\n\n\n\n    def before_send(self,role,index,data):\n        # when None returned, no changes will be applied and packets[ origins[role][index] ] will be used\n        if role == 'server' and index == 1:\n            return data + \": %s\"  % (datetime.datetime.now(),)\n\n        return None\n\n    def after_received(self,role,index,data):\n        # return value is ignored: use it as data gathering for further processing\n        return None\n</pre>\n<p>As you might see this gives to your hands power to export existing payload with \u2013export and modify it on the fly as you want. You can make a string templates from it and just paste values as desired, or you can write even quite complex code around!</p>\n</div>\n</div>\n<div id=\"creating-and-using-self-contained-package\">\n<h2>Creating and using self-contained package</h2>\n<p>This feature is extremely useful for automation. You can use SMCAP, PCAP or pplayscript, embed it into pplay itself,\nand use this self-contained pplay version by executing it over the SSH (or the other way, SSH is just the most obvious).</p>\n<p>The rest is just the same normal pplay. Please note that pplay over ssh needs a bit different approach, so we execute it with:</p>\n<pre>--nostdin   - (it's already used by SSH)\n--auto      - will make transaction waiting times a fraction of second\n--script +  - (there is plus character) this will instruct to *play embedded pplayscript*\n--exitoneot - once we received/sent last message in the transaction, exit.\n</pre>\n<div id=\"launch-embedded-server\">\n<h3>Launch embedded server</h3>\n<p>Pack smcap file into pplay, resulting file in /tmp/smbla.py \u2013 smbla.py will contain pplay and also data from provided smcap file and launch server (on r32 host, options suitable for automation), using packed pplay:</p>\n<pre>pplay.py --smcap samples/smcap_sample.smcap --pack /tmp/smbla\nssh r32 python - --script + --server 8002 --auto 0.1 --nostdin --exitoneot &lt; /tmp/smbla.py\n</pre>\n</div>\n<div id=\"launch-embbedded-client\">\n<h3>Launch embbedded client</h3>\n<pre>python - --script + --client 10.16.16.1:8002 --auto 0.1 --nostdin --exitoneot &lt; /tmp/smbla.py\n</pre>\n<p>Please note that you need to have installed python-scapy on both remote servers. Of course, SSH needs to be reachable (i.e. you need to create firewall pin-holes for it).\nAlso for (and only for) the automation you might want to create ssh key without the passphrase.</p>\n</div>\n</div>\n<div id=\"more-details\">\n<h2>More details</h2>\n<p>PPlay forgets everything about original IP addresses. It\u2019s because you will be testing it in your lab testbed. Only thing it will remember is the the destination port, for server side pplay it\u2019s important, meaning the port where it should <em>listen</em> for incoming connections. But that\u2019s really it.</p>\n<p>Client-side pplay will connect to the server-side. Once connected, you will see on one side green hex data and on the other yellow hex data. For HTTP, the client-side would be typically green, since HTTP comes with the request first. On the line above green hex data you will also see e.g. \u201c[1/2] (in sync) offer to send \u2013&gt;\u201d. In sync is important here. Those data should be sent now according to pcap.\nIf you see yellow data, that side is not on it\u2019s turn, and you will not see also \u201c(in sync)\u201d above them.</p>\n<p>Yellow or green, pplay will act on behalf of you by default in 5 seconds =&gt; green data will be sent.\nHint: you can set \u2013noauto, or \u2013auto <cite>&lt;big_seconds&gt;</cite> program argument to change autosend feature. This feature could be also toggled on/off during the operation with \u201ci\u201d command shortcut.</p>\n<div id=\"launch-on-remote-ssh-server\">\n<h3>Launch on remote SSH server</h3>\n<p><strong>new in version 1.7.0</strong>\nYou have learned so far how to \u201cpack\u201d data inside <em>pplay</em>. It\u2019s pretty useful, but you need to always <em>\u2013pack</em>, create a file, send it to the other side, and execute there.\nEven though in previous examples we mentioned how to send <em>pack</em>ed over ssh stdin, you still need linux command-line ssh.\nSince version 1.7.0 you can actually utilize \u2013remote-ssh parameter, and pplay will send over ssh itself!</p>\n<pre># this will run pplay on remote server, listening there on port 8000, packing all data needed to impersonate\n# server from pcap file\n\npplay --pcap some_sniffer.pcap --connection 1.1.1.1:12345 --server 8000 --remote-ssh 12.13.14.15:2222 \\\n    --exitoneot --auto 0.1\n</pre>\n<pre># this will run pplay on remote server, impersonating client, packing all data needed from pcap file\n\npplay --pcap some_sniffer.pcap --connection 1.1.1.1:12345 --client 12.13.14.15:8000\n    --remote-ssh 12.13.14.88:2222 --exitoneot --auto 0.1\n</pre>\n<p>Nice on this is you don\u2019t need anything on remote servers, just pure python. Nothing else is needed.</p>\n<p><strong>Limitation:</strong> since python on remote server receives pplay from stdin which must be closed to actually launch it, commands from standard input are not supported and \u2013nostdin is automatically added to remote command line. Recommended running with <tt><span class=\"pre\">--exitoneot</span></tt> and <tt><span class=\"pre\">--auto</span></tt>.</p>\n</div>\n<div id=\"connect-client-using-socks\">\n<h3>Connect client using SOCKS</h3>\n<p>Another useful feature might be to use proxy for client outgoing connection (perhaps you are testing such a proxy, like I am).\nTo do so, use \u2013socks parameter, taking IP address optionally suffixed with a port, ie. 10.0.0.1:1080</p>\n<div id=\"commands\">\n<h4>Commands</h4>\n<p>Below hex data (green or yellow), there is some contextual help for you: pplay is waiting for your override action to it\u2019s default \u2013 autosend. At the time being, you can enter:</p>\n<pre>\"y\" or hit &lt;enter&gt; to send data\n\"s\" to skip them\n\"c\" to send CR only\n\"l\" to send LF only\n\"x\" to send CR+LF characters\n\"i\" to disable/enable autosend feature\n\"r\" command to replace content of the payload with something else.\n    It does have 'vi'-like syntax: r/POST/GET/0 will replace string \"POST\" with \"GET\".\n    Trailing number means max. number of replacements, 0=all\n</pre>\n</div>\n<div id=\"data-sources\">\n<h4>Data sources</h4>\n<p>PPlay also supports smithproxy output, just use \u2013smcap instead of \u2013pcap argument option.\nYou can wrap the traffic into SSL, just use \u2013ssl option. With smithproxy together, pplay is quite powerful pair of tools: you can easily replay \u201cdecrypted\u201d smcap file from smithproxy and wrap it again into SSL to further test.</p>\n<p>Hint: Smithproxy it\u2019s SSL mitm proxy written by me in C/C++, faking certificate subject. It utilizes iptables TPROXY target. SSL traffic is signed by local CA and plaintext is logged into files.</p>\n</div>\n</div>\n</div>\n<div id=\"requirements\">\n<h2>Requirements</h2>\n<p>Tool doesn\u2019t have too requirements. You have to have installed scapy and colorama python packages.</p>\n<p>Scapy is used to parse pcaps and to have scapy available for future features - runs on Linux, Mac and Windows (see instructions how to install scapy on windows here). It\u2019s known to not work in Cygwin.</p>\n<p>Note: I am deciding to drop scapy in the future.\nColorama is responsible for multiplatform coloring. On windows, unpack zip-file, run cmd and run python setup.py install. That should make it.</p>\n<p>I would recommend to run pplay in linux, I haven\u2019t tested it on Windows yet.</p>\n</div>\n<div id=\"smcap2pcap-tool\">\n<h2>SMCAP2PCAP tool</h2>\n<p>This tool is a bit hack. Basically it replays smcap file, while using tcpdump to sniff the traffic. There are dozens of reasons why you would like to convert smcap file to pcap. This is the tool for that purpose.</p>\n<p>Also, this tools is very basic. There is only argument it takes: smcap file. Name and location of the converted pcap will be printed out.</p>\n</div>\n\n          </div>"}, "last_serial": 6217701, "releases": {"1.7.3": [{"comment_text": "", "digests": {"md5": "96d06670256f310d46b63f277bdb02bc", "sha256": "cf52c8549b0b8d631c5310c1bbb1a1efac2a9e64d341641ec277c2097270693e"}, "downloads": -1, "filename": "pplay-1.7.3-py2-none-any.whl", "has_sig": false, "md5_digest": "96d06670256f310d46b63f277bdb02bc", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 23180, "upload_time": "2019-11-18T08:45:39", "upload_time_iso_8601": "2019-11-18T08:45:39.658533Z", "url": "https://files.pythonhosted.org/packages/9f/24/8a2d1dbc950c33566e9ca3d6977829b99fbda534439c480e5c43ce0009c8/pplay-1.7.3-py2-none-any.whl", "yanked": false}], "1.7.3.post1": [{"comment_text": "", "digests": {"md5": "570bccd87cd5cdcbb44ba204078b171e", "sha256": "4c5a648cdcc915e2e197a821daa0f89f9b21d802f9cebb34d38abb2576ab6f97"}, "downloads": -1, "filename": "pplay-1.7.3.post1-py2-none-any.whl", "has_sig": false, "md5_digest": "570bccd87cd5cdcbb44ba204078b171e", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 23281, "upload_time": "2019-11-18T09:05:41", "upload_time_iso_8601": "2019-11-18T09:05:41.337008Z", "url": "https://files.pythonhosted.org/packages/4e/02/f7a0dc981dcb7b7d26dd46befeaaafe2573dec60a761ea2d673abb13d765/pplay-1.7.3.post1-py2-none-any.whl", "yanked": false}], "1.7.3.post2": [{"comment_text": "", "digests": {"md5": "25fbf6ba43eba681b0212c1399a0faed", "sha256": "35f32884e50ca518fc036f368fb636814d1a72c8200da780b1e979880cf7948e"}, "downloads": -1, "filename": "pplay-1.7.3.post2-py2-none-any.whl", "has_sig": false, "md5_digest": "25fbf6ba43eba681b0212c1399a0faed", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 23281, "upload_time": "2019-11-18T09:20:08", "upload_time_iso_8601": "2019-11-18T09:20:08.556502Z", "url": "https://files.pythonhosted.org/packages/00/42/5601fd08a23ff33ffa7f2942097cfd42bb18b41d9a6de840ee582f379a4d/pplay-1.7.3.post2-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "665c3cee22e35e153a8b304e82852bb6", "sha256": "96ab8e75af31fb6caa1dbb6e2a0d88e2b2e80f9f09de92967725329d83d22323"}, "downloads": -1, "filename": "pplay-1.7.3.post2.tar.gz", "has_sig": false, "md5_digest": "665c3cee22e35e153a8b304e82852bb6", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22772, "upload_time": "2019-11-18T09:20:10", "upload_time_iso_8601": "2019-11-18T09:20:10.268658Z", "url": "https://files.pythonhosted.org/packages/b4/bc/f596174b9a3abc5bce09f38d53f11c7141e3201dcf386f6a80dc92661f01/pplay-1.7.3.post2.tar.gz", "yanked": false}], "1.7.3.post3": [{"comment_text": "", "digests": {"md5": "ab159d1652282dd872de91c25bd4bc94", "sha256": "24bd6e703837f4ca4bffba606b8ed47e82573e5105b13d0cb049c565ea44f794"}, "downloads": -1, "filename": "pplay-1.7.3.post3-py2-none-any.whl", "has_sig": false, "md5_digest": "ab159d1652282dd872de91c25bd4bc94", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 23282, "upload_time": "2019-11-18T09:25:59", "upload_time_iso_8601": "2019-11-18T09:25:59.392058Z", "url": "https://files.pythonhosted.org/packages/7b/87/e6365170b3e98384e597f8815aaedcb426ca0121928825625ad8bddc4124/pplay-1.7.3.post3-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "80453b39699fe19653b90f30b5054b1f", "sha256": "8dbd6da5f7aab7a2799b830d73fbe707981501941bf00f139349b85b26cb1cb3"}, "downloads": -1, "filename": "pplay-1.7.3.post3.tar.gz", "has_sig": false, "md5_digest": "80453b39699fe19653b90f30b5054b1f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22780, "upload_time": "2019-11-18T09:26:00", "upload_time_iso_8601": "2019-11-18T09:26:00.870577Z", "url": "https://files.pythonhosted.org/packages/2b/a7/ec5284c1d33fd9dbc56aa7d92554c9b5a3b67486b75e466b2a55975e2ab1/pplay-1.7.3.post3.tar.gz", "yanked": false}], "1.7.3.post4": [{"comment_text": "", "digests": {"md5": "5a5fc85394a3593af24b2861dba2d55f", "sha256": "c831983ced63696fd1eee0c5cc7f293cf3de692589c1f08e6870e749fd04e2fb"}, "downloads": -1, "filename": "pplay-1.7.3.post4-py2-none-any.whl", "has_sig": false, "md5_digest": "5a5fc85394a3593af24b2861dba2d55f", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 23320, "upload_time": "2019-11-18T09:33:48", "upload_time_iso_8601": "2019-11-18T09:33:48.865435Z", "url": "https://files.pythonhosted.org/packages/55/5e/3b7771e2d83226bba8bbbf465a8032b78276236610914a494b8dce79623a/pplay-1.7.3.post4-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "d7079fe9b372cc6d87caab6537b9db85", "sha256": "7f9b24e9a8ba6627d3da787aa76029eaf96f354c27259a1c41eb27ee0849d8bd"}, "downloads": -1, "filename": "pplay-1.7.3.post4.tar.gz", "has_sig": false, "md5_digest": "d7079fe9b372cc6d87caab6537b9db85", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 22868, "upload_time": "2019-11-18T09:33:50", "upload_time_iso_8601": "2019-11-18T09:33:50.390932Z", "url": "https://files.pythonhosted.org/packages/34/0e/c7e5d7140c8d4a6d8c32596f59ac5543a1a0e9a8455dd102f1a94b511b95/pplay-1.7.3.post4.tar.gz", "yanked": false}], "1.7.3.post5": [{"comment_text": "", "digests": {"md5": "c3cf6c747ec049b4a2ef112d700908fa", "sha256": "d9b544544f541202e42e482b3c18e0d3e904a60f77ac86eeb4a696c850feff7e"}, "downloads": -1, "filename": "pplay-1.7.3.post5-py2-none-any.whl", "has_sig": false, "md5_digest": "c3cf6c747ec049b4a2ef112d700908fa", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 24299, "upload_time": "2019-11-18T09:37:19", "upload_time_iso_8601": "2019-11-18T09:37:19.789584Z", "url": "https://files.pythonhosted.org/packages/0b/62/e5b6ec5748e51c0991936abe50b9f54dd302057a46c3d6bda505b5461c47/pplay-1.7.3.post5-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "e5e20eaf2c10d289437b851fd18ef6a5", "sha256": "c10152b20dbdc62fc56912d81ace592248d5d80dac70f6544305ce92752243da"}, "downloads": -1, "filename": "pplay-1.7.3.post5.tar.gz", "has_sig": false, "md5_digest": "e5e20eaf2c10d289437b851fd18ef6a5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23633, "upload_time": "2019-11-18T09:37:21", "upload_time_iso_8601": "2019-11-18T09:37:21.532285Z", "url": "https://files.pythonhosted.org/packages/61/0d/e56c07fb102b19435ad0737c4232961357f017c8a7ce6a79841d4c80d8de/pplay-1.7.3.post5.tar.gz", "yanked": false}], "1.7.4.post1": [{"comment_text": "", "digests": {"md5": "d262fbcaf35bc641aafa94d022675b2d", "sha256": "70f7d1182c15c7a13ec7e8375d274930388f1a68d0d5bacb967db62699b1431b"}, "downloads": -1, "filename": "pplay-1.7.4.post1-py2-none-any.whl", "has_sig": false, "md5_digest": "d262fbcaf35bc641aafa94d022675b2d", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 29674, "upload_time": "2019-11-29T10:30:59", "upload_time_iso_8601": "2019-11-29T10:30:59.245161Z", "url": "https://files.pythonhosted.org/packages/ce/e5/f06d9ddffdfddca840f465b932fdb20ada987193bab320f58159c3b380bc/pplay-1.7.4.post1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1ea600c96ce1d1bbf78348224e75d1ae", "sha256": "1895668fbf2e23c925bac8051a0b4e87f04ba754583781f713fde9e6076e75fc"}, "downloads": -1, "filename": "pplay-1.7.4.post1.tar.gz", "has_sig": false, "md5_digest": "1ea600c96ce1d1bbf78348224e75d1ae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28668, "upload_time": "2019-11-29T10:31:00", "upload_time_iso_8601": "2019-11-29T10:31:00.974021Z", "url": "https://files.pythonhosted.org/packages/fb/ea/38bad81f904a7f1f4a5a7f8954c0ddc4a409034304ee35547c7a86b0c0d0/pplay-1.7.4.post1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "d262fbcaf35bc641aafa94d022675b2d", "sha256": "70f7d1182c15c7a13ec7e8375d274930388f1a68d0d5bacb967db62699b1431b"}, "downloads": -1, "filename": "pplay-1.7.4.post1-py2-none-any.whl", "has_sig": false, "md5_digest": "d262fbcaf35bc641aafa94d022675b2d", "packagetype": "bdist_wheel", "python_version": "py2", "requires_python": null, "size": 29674, "upload_time": "2019-11-29T10:30:59", "upload_time_iso_8601": "2019-11-29T10:30:59.245161Z", "url": "https://files.pythonhosted.org/packages/ce/e5/f06d9ddffdfddca840f465b932fdb20ada987193bab320f58159c3b380bc/pplay-1.7.4.post1-py2-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1ea600c96ce1d1bbf78348224e75d1ae", "sha256": "1895668fbf2e23c925bac8051a0b4e87f04ba754583781f713fde9e6076e75fc"}, "downloads": -1, "filename": "pplay-1.7.4.post1.tar.gz", "has_sig": false, "md5_digest": "1ea600c96ce1d1bbf78348224e75d1ae", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28668, "upload_time": "2019-11-29T10:31:00", "upload_time_iso_8601": "2019-11-29T10:31:00.974021Z", "url": "https://files.pythonhosted.org/packages/fb/ea/38bad81f904a7f1f4a5a7f8954c0ddc4a409034304ee35547c7a86b0c0d0/pplay-1.7.4.post1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:20:29 2020"}