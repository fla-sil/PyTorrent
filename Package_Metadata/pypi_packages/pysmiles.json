{"info": {"author": "P C Kroon", "author_email": "p.c.kroon@rug.nl", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "Intended Audience :: Science/Research", "License :: OSI Approved :: Apache Software License", "Operating System :: OS Independent", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering :: Bio-Informatics", "Topic :: Scientific/Engineering :: Chemistry"], "description": "[![Build Status](https://travis-ci.org/pckroon/pysmiles.svg?branch=master)](https://travis-ci.org/pckroon/pysmiles)\n[![Coverage Status](https://coveralls.io/repos/github/pckroon/pysmiles/badge.svg?branch=master)](https://coveralls.io/github/pckroon/pysmiles?branch=master)\n\n# pysmiles: The lightweight and pure-python SMILES reader and writer\n\nThis is a small project I started because I couldn't find any SMILES reader or\nwriter that was easy to install (read: Python only). Currently, the writer is\nextremely basic, and although it should produce valid SMILES they won't be\npretty. The reader is in a better state, and should be usable.\n\nSMILES strings are assumed to be as specified by the\n[OpenSmiles standard][opensmiles].\n\n## Molecules\nMolecules are depicted as [Networkx][networkx] graphs. Atoms are the nodes of\nthe graph, and bonds are the edges. Nodes can have the following attributes:\n- element: str. This describes the element of the atom. Defaults to '\\*'\n    meaning unknown.\n- aromatic: bool. Whether the atom is part of an (anti)-aromatic system. \n    Defaults to False.\n- isotope: float. The mass of the atom. Defaults to unknown.\n- hcount: int. The number of implicit hydrogens attached to this atom.\n    Defaults to 0.\n- charge: int. The charge of this atom. Defaults to 0.\n- class: int. The \"class\" of this atom. Defaults to 0.\n\nEdges have the following attributes:\n- order: Number. The bond order. 1.5 is used for aromatic bonds. Defaults to 1.\n\nThere is currently no way of specifying stereo chemical information, and this\nis discarded upon reading. Somewhere in the future this will probably be\nstored in the \"stereo\" attribute of nodes.\n\n## Reading SMILES\nThe function `read_smiles(smiles, explicit_hydrogen=False,\nzero_order_bonds=True, reinterpret_aromatic=True)` can be used to parse a\nSMILES string. It should not be used to validate whether a string is a valid\nSMILES string --- the function does very little validation whether your SMILES string makes chemical sense.\nEdges in the created molecule will always have an 'order'\nattribute. Nodes will have the relevant attributes in so far they are\nspecified. Atoms for which the element is not known (\\*) will not have an\nelement attribute.\n- `explicit_hydrogen` determines whether hydrogen atoms should be\n    represented as explicit nodes in the created molecule, or implicit in the\n    'hcount' attribute.\n- `zero_order_bonds` determines whether zero-order bonds (.) in the SMILES\n    string should result in edges in the produced molecule.\n- `reinterpret_aromatic` determines whether aromaticity should be \n    reinterpreted, and determined from the constructed molecule, or whether\n    the aromaticity specifications from the SMILES string (lower case \n    elements) should be taken as leading. If `True`, will also set bond orders \n    to 1 for bonds that are not part of an aromatic ring and have a bond order \n    of 1.5. If `False`, will create a molecule using *only* the information in \n    the SMILES string.\n\n## Writing SMILES\nThe function `write_smiles(molecule, default_element='*', start=None)` can be\nused to write SMILES strings from a molecule. The function does *not* check \nwhether your molecule makes chemical sense. Instead, it writes a SMILES \nrepresentation of the molecule you provided, and nothing else.\n- `default_element` is the element to use for nodes that do not have an \n    'element' attribute.\n- `start` is the key of the node where the depth first traversal should be \n    started. Something clever is done if not specified.\n\n## Additional functions\nIn addition to these two core functions, four more functions are exposed that\ncan help in creating chemically relevant molecules with minimal work.\n\n- `fill_valence(mol, respect_hcount=True, respect_bond_order=True,\n                 max_bond_order=3)`\n    This function will fill the valence of all atoms in your molecule by \n    incrementing the 'hcount' and, if specified, bond orders. Note that it does\n    not use 'charge' attribute to find the correct valence.\n    - `repect_hcount`: bool. Whether existing hcounts can be overwritten.\n    - `respect_bond_order`: bool. Whether bond orders can be changed\n    - `max_bond_order`: int. The maximum bond order that will be set.\n- `add_explicit_hydrogens(mol)`\n    This function transforms implicit hydrogens, specified by 'hcount' \n    attributes, to explicit nodes.\n- `remove_explicit_hydrogens(mol)`\n    This function does the inverse of `add_explicit_hydrogens`: it will remove\n    explicit hydrogen nodes and add them to the relevant 'hcount' attributes.\n- `correct_aromatic_rings(mol)`\n    This function marks all (anti)-aromatic atoms in your molecule, and sets \n    all bonds between (anti)-aromatic atoms to order 1.5.\n    It fills the valence of all atoms (see also `fill_valence`) before trying\n    to figure our which atoms are aromatic. It works by first finding all \n    atoms that are in a ring. Next, for every atom in every ring it is checked\n    whether the atoms are sp2 hybridized (note that this is a vague term. \n    Strictly speaking we check whether their element is something that *could*\n    be aromatic, and whether they have 2 or 3 bonds.). Finally, the number of \n    electrons per ring is counted, and if this is even, the atoms in the ring\n    are said to be aromatic.\n    This function is the most fragile in the whole library, and I expect it to\n    produce wrong answers in some cases. In particular for fused (aromatic)\n    ring systems (such as indole) and rings with extracyclic heteroatoms\n    (O=C1C=CC=C1). Buyer beware.\n\n## Examples\n### Reading\n```python\nfrom pysmiles import read_smiles\n\nsmiles = 'C1CC[13CH2]CC1C1CCCCC1'\nmol = read_smiles(smiles)\n\nprint(mol.nodes(data='element'))\n# [(0, 'C'),\n#  (1, 'C'),\n#  (2, 'C'),\n#  (3, 'C'),\n#  (4, 'C'),\n#  (5, 'C'),\n#  (6, 'C'),\n#  (7, 'C'),\n#  (8, 'C'),\n#  (9, 'C'),\n#  (10, 'C'),\n#  (11, 'C')]\nprint(mol.nodes(data='hcount'))\n# [(0, 2),\n#  (1, 2),\n#  (2, 2),\n#  (3, 2),\n#  (4, 2),\n#  (5, 1),\n#  (6, 1),\n#  (7, 2),\n#  (8, 2),\n#  (9, 2),\n#  (10, 2),\n#  (11, 2)]\n\nmol_with_H = read_smiles(smiles, explicit_hydrogen=True)\nprint(mol_with_H.nodes(data='element'))\n# [(0, 'C'),\n#  (1, 'C'),\n#  (2, 'C'),\n#  (3, 'C'),\n#  (4, 'C'),\n#  (5, 'C'),\n#  (6, 'C'),\n#  (7, 'C'),\n#  (8, 'C'),\n#  (9, 'C'),\n#  (10, 'C'),\n#  (11, 'C'),\n#  (12, 'H'),\n#  (13, 'H'),\n#  (14, 'H'),\n#  (15, 'H'),\n#  (16, 'H'),\n#  (17, 'H'),\n#  (18, 'H'),\n#  (19, 'H'),\n#  (20, 'H'),\n#  (21, 'H'),\n#  (22, 'H'),\n#  (23, 'H'),\n#  (24, 'H'),\n#  (25, 'H'),\n#  (26, 'H'),\n#  (27, 'H'),\n#  (28, 'H'),\n#  (29, 'H'),\n#  (30, 'H'),\n#  (31, 'H'),\n#  (32, 'H'),\n# (33, 'H')]\n```\n\n### Writing\n```python\nimport networkx as nx\nfrom pysmiles import write_smiles, fill_valence\n\nmol = nx.Graph()\nmol.add_edges_from([(0, 1), (1, 2), (1, 3), (3, 4), (1, 5), (3, 6)])\nfor idx, ele in enumerate('CCCCOCO'):\n    mol.nodes[idx]['element'] = ele\nmol.nodes[4]['charge'] = -1\nmol.nodes[4]['hcount'] = 0\nmol.edges[3, 6]['order'] = 2\n\nprint(write_smiles(mol))\n# [O-]C(=O)C([C])([C])[C]\nfill_valence(mol, respect_hcount=True)\nprint(write_smiles(mol))\n# [O-]C(=O)C(C)(C)C\n```\n\n## Limitations\n- The writer produces non-recommended SMILES strings (as per OpenSmiles).\n- `fill_valence` does not use 'charge' to find the correct valence.\n- `correct_aromatic_rings` is fragile.\n- There is currently no way of specifying stereo chemical information. The \n    parser can deal with it, but it will be discarded.\n- It is not on PyPI\n- It only processes SMILES. This might later be extended to e.g. InChi, SLN,\n    SMARTS, etc.\n\n## Requirements\n- [networkx][networkx]\n\n## Similar projects\nThere are more python projects that deal with SMILES, and I try to list at \nleast some of them here. If yours is missing, feel free to open up a PR.\n- [PySMILE](https://github.com/jhosmer/PySmile): A similar named project, \n    capable of encoding/decoding SMILE format objects. Doesn't deal with \n    SMILES.\n- [RDKit](https://github.com/rdkit/rdkit): A collection of cheminformatics and \n    machine-learning software, capable of reading and writing SMILES, InChi, \n    and others.\n- [OpenEye Chem toolkit](https://www.eyesopen.com/oechem-tk): The OpenEye \n    chemistry toolkit is a programming library for chemistry and \n    cheminformatics. It is capable of dealing with (canonical) SMILES and \n    InChi.\n\n## License\nPySmiles is distributed under the Apache 2.0 license.\n    Copyright 2018 Peter C Kroon\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n        http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n\n[opensmiles]: http://opensmiles.org/\n[networkx]: https://networkx.github.io/", "description_content_type": "text/markdown; charset=UTF-8", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/pckroon/pysmiles", "keywords": "SMILES cheminformatics chemistry", "license": "Apache 2.0", "maintainer": "", "maintainer_email": "", "name": "pysmiles", "package_url": "https://pypi.org/project/pysmiles/", "platform": "", "project_url": "https://pypi.org/project/pysmiles/", "project_urls": {"Homepage": "https://github.com/pckroon/pysmiles"}, "release_url": "https://pypi.org/project/pysmiles/1.0.0/", "requires_dist": null, "requires_python": "", "summary": "A lightweight SMILES reader and writer", "version": "1.0.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://travis-ci.org/pckroon/pysmiles\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/7d8e646ccc17e50574f74ab9798ddd1a1401c617/68747470733a2f2f7472617669732d63692e6f72672f70636b726f6f6e2f7079736d696c65732e7376673f6272616e63683d6d6173746572\"></a>\n<a href=\"https://coveralls.io/github/pckroon/pysmiles?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/dec96a5b1510224532f266f98445ffcce1831ccf/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f70636b726f6f6e2f7079736d696c65732f62616467652e7376673f6272616e63683d6d6173746572\"></a></p>\n<h1>pysmiles: The lightweight and pure-python SMILES reader and writer</h1>\n<p>This is a small project I started because I couldn't find any SMILES reader or\nwriter that was easy to install (read: Python only). Currently, the writer is\nextremely basic, and although it should produce valid SMILES they won't be\npretty. The reader is in a better state, and should be usable.</p>\n<p>SMILES strings are assumed to be as specified by the\n<a href=\"http://opensmiles.org/\" rel=\"nofollow\">OpenSmiles standard</a>.</p>\n<h2>Molecules</h2>\n<p>Molecules are depicted as <a href=\"https://networkx.github.io/\" rel=\"nofollow\">Networkx</a> graphs. Atoms are the nodes of\nthe graph, and bonds are the edges. Nodes can have the following attributes:</p>\n<ul>\n<li>element: str. This describes the element of the atom. Defaults to '*'\nmeaning unknown.</li>\n<li>aromatic: bool. Whether the atom is part of an (anti)-aromatic system.\nDefaults to False.</li>\n<li>isotope: float. The mass of the atom. Defaults to unknown.</li>\n<li>hcount: int. The number of implicit hydrogens attached to this atom.\nDefaults to 0.</li>\n<li>charge: int. The charge of this atom. Defaults to 0.</li>\n<li>class: int. The \"class\" of this atom. Defaults to 0.</li>\n</ul>\n<p>Edges have the following attributes:</p>\n<ul>\n<li>order: Number. The bond order. 1.5 is used for aromatic bonds. Defaults to 1.</li>\n</ul>\n<p>There is currently no way of specifying stereo chemical information, and this\nis discarded upon reading. Somewhere in the future this will probably be\nstored in the \"stereo\" attribute of nodes.</p>\n<h2>Reading SMILES</h2>\n<p>The function <code>read_smiles(smiles, explicit_hydrogen=False, zero_order_bonds=True, reinterpret_aromatic=True)</code> can be used to parse a\nSMILES string. It should not be used to validate whether a string is a valid\nSMILES string --- the function does very little validation whether your SMILES string makes chemical sense.\nEdges in the created molecule will always have an 'order'\nattribute. Nodes will have the relevant attributes in so far they are\nspecified. Atoms for which the element is not known (*) will not have an\nelement attribute.</p>\n<ul>\n<li><code>explicit_hydrogen</code> determines whether hydrogen atoms should be\nrepresented as explicit nodes in the created molecule, or implicit in the\n'hcount' attribute.</li>\n<li><code>zero_order_bonds</code> determines whether zero-order bonds (.) in the SMILES\nstring should result in edges in the produced molecule.</li>\n<li><code>reinterpret_aromatic</code> determines whether aromaticity should be\nreinterpreted, and determined from the constructed molecule, or whether\nthe aromaticity specifications from the SMILES string (lower case\nelements) should be taken as leading. If <code>True</code>, will also set bond orders\nto 1 for bonds that are not part of an aromatic ring and have a bond order\nof 1.5. If <code>False</code>, will create a molecule using <em>only</em> the information in\nthe SMILES string.</li>\n</ul>\n<h2>Writing SMILES</h2>\n<p>The function <code>write_smiles(molecule, default_element='*', start=None)</code> can be\nused to write SMILES strings from a molecule. The function does <em>not</em> check\nwhether your molecule makes chemical sense. Instead, it writes a SMILES\nrepresentation of the molecule you provided, and nothing else.</p>\n<ul>\n<li><code>default_element</code> is the element to use for nodes that do not have an\n'element' attribute.</li>\n<li><code>start</code> is the key of the node where the depth first traversal should be\nstarted. Something clever is done if not specified.</li>\n</ul>\n<h2>Additional functions</h2>\n<p>In addition to these two core functions, four more functions are exposed that\ncan help in creating chemically relevant molecules with minimal work.</p>\n<ul>\n<li><code>fill_valence(mol, respect_hcount=True, respect_bond_order=True, max_bond_order=3)</code>\nThis function will fill the valence of all atoms in your molecule by\nincrementing the 'hcount' and, if specified, bond orders. Note that it does\nnot use 'charge' attribute to find the correct valence.\n<ul>\n<li><code>repect_hcount</code>: bool. Whether existing hcounts can be overwritten.</li>\n<li><code>respect_bond_order</code>: bool. Whether bond orders can be changed</li>\n<li><code>max_bond_order</code>: int. The maximum bond order that will be set.</li>\n</ul>\n</li>\n<li><code>add_explicit_hydrogens(mol)</code>\nThis function transforms implicit hydrogens, specified by 'hcount'\nattributes, to explicit nodes.</li>\n<li><code>remove_explicit_hydrogens(mol)</code>\nThis function does the inverse of <code>add_explicit_hydrogens</code>: it will remove\nexplicit hydrogen nodes and add them to the relevant 'hcount' attributes.</li>\n<li><code>correct_aromatic_rings(mol)</code>\nThis function marks all (anti)-aromatic atoms in your molecule, and sets\nall bonds between (anti)-aromatic atoms to order 1.5.\nIt fills the valence of all atoms (see also <code>fill_valence</code>) before trying\nto figure our which atoms are aromatic. It works by first finding all\natoms that are in a ring. Next, for every atom in every ring it is checked\nwhether the atoms are sp2 hybridized (note that this is a vague term.\nStrictly speaking we check whether their element is something that <em>could</em>\nbe aromatic, and whether they have 2 or 3 bonds.). Finally, the number of\nelectrons per ring is counted, and if this is even, the atoms in the ring\nare said to be aromatic.\nThis function is the most fragile in the whole library, and I expect it to\nproduce wrong answers in some cases. In particular for fused (aromatic)\nring systems (such as indole) and rings with extracyclic heteroatoms\n(O=C1C=CC=C1). Buyer beware.</li>\n</ul>\n<h2>Examples</h2>\n<h3>Reading</h3>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pysmiles</span> <span class=\"kn\">import</span> <span class=\"n\">read_smiles</span>\n\n<span class=\"n\">smiles</span> <span class=\"o\">=</span> <span class=\"s1\">'C1CC[13CH2]CC1C1CCCCC1'</span>\n<span class=\"n\">mol</span> <span class=\"o\">=</span> <span class=\"n\">read_smiles</span><span class=\"p\">(</span><span class=\"n\">smiles</span><span class=\"p\">)</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mol</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"s1\">'element'</span><span class=\"p\">))</span>\n<span class=\"c1\"># [(0, 'C'),</span>\n<span class=\"c1\">#  (1, 'C'),</span>\n<span class=\"c1\">#  (2, 'C'),</span>\n<span class=\"c1\">#  (3, 'C'),</span>\n<span class=\"c1\">#  (4, 'C'),</span>\n<span class=\"c1\">#  (5, 'C'),</span>\n<span class=\"c1\">#  (6, 'C'),</span>\n<span class=\"c1\">#  (7, 'C'),</span>\n<span class=\"c1\">#  (8, 'C'),</span>\n<span class=\"c1\">#  (9, 'C'),</span>\n<span class=\"c1\">#  (10, 'C'),</span>\n<span class=\"c1\">#  (11, 'C')]</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mol</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"s1\">'hcount'</span><span class=\"p\">))</span>\n<span class=\"c1\"># [(0, 2),</span>\n<span class=\"c1\">#  (1, 2),</span>\n<span class=\"c1\">#  (2, 2),</span>\n<span class=\"c1\">#  (3, 2),</span>\n<span class=\"c1\">#  (4, 2),</span>\n<span class=\"c1\">#  (5, 1),</span>\n<span class=\"c1\">#  (6, 1),</span>\n<span class=\"c1\">#  (7, 2),</span>\n<span class=\"c1\">#  (8, 2),</span>\n<span class=\"c1\">#  (9, 2),</span>\n<span class=\"c1\">#  (10, 2),</span>\n<span class=\"c1\">#  (11, 2)]</span>\n\n<span class=\"n\">mol_with_H</span> <span class=\"o\">=</span> <span class=\"n\">read_smiles</span><span class=\"p\">(</span><span class=\"n\">smiles</span><span class=\"p\">,</span> <span class=\"n\">explicit_hydrogen</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">mol_with_H</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"s1\">'element'</span><span class=\"p\">))</span>\n<span class=\"c1\"># [(0, 'C'),</span>\n<span class=\"c1\">#  (1, 'C'),</span>\n<span class=\"c1\">#  (2, 'C'),</span>\n<span class=\"c1\">#  (3, 'C'),</span>\n<span class=\"c1\">#  (4, 'C'),</span>\n<span class=\"c1\">#  (5, 'C'),</span>\n<span class=\"c1\">#  (6, 'C'),</span>\n<span class=\"c1\">#  (7, 'C'),</span>\n<span class=\"c1\">#  (8, 'C'),</span>\n<span class=\"c1\">#  (9, 'C'),</span>\n<span class=\"c1\">#  (10, 'C'),</span>\n<span class=\"c1\">#  (11, 'C'),</span>\n<span class=\"c1\">#  (12, 'H'),</span>\n<span class=\"c1\">#  (13, 'H'),</span>\n<span class=\"c1\">#  (14, 'H'),</span>\n<span class=\"c1\">#  (15, 'H'),</span>\n<span class=\"c1\">#  (16, 'H'),</span>\n<span class=\"c1\">#  (17, 'H'),</span>\n<span class=\"c1\">#  (18, 'H'),</span>\n<span class=\"c1\">#  (19, 'H'),</span>\n<span class=\"c1\">#  (20, 'H'),</span>\n<span class=\"c1\">#  (21, 'H'),</span>\n<span class=\"c1\">#  (22, 'H'),</span>\n<span class=\"c1\">#  (23, 'H'),</span>\n<span class=\"c1\">#  (24, 'H'),</span>\n<span class=\"c1\">#  (25, 'H'),</span>\n<span class=\"c1\">#  (26, 'H'),</span>\n<span class=\"c1\">#  (27, 'H'),</span>\n<span class=\"c1\">#  (28, 'H'),</span>\n<span class=\"c1\">#  (29, 'H'),</span>\n<span class=\"c1\">#  (30, 'H'),</span>\n<span class=\"c1\">#  (31, 'H'),</span>\n<span class=\"c1\">#  (32, 'H'),</span>\n<span class=\"c1\"># (33, 'H')]</span>\n</pre>\n<h3>Writing</h3>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">networkx</span> <span class=\"k\">as</span> <span class=\"nn\">nx</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pysmiles</span> <span class=\"kn\">import</span> <span class=\"n\">write_smiles</span><span class=\"p\">,</span> <span class=\"n\">fill_valence</span>\n\n<span class=\"n\">mol</span> <span class=\"o\">=</span> <span class=\"n\">nx</span><span class=\"o\">.</span><span class=\"n\">Graph</span><span class=\"p\">()</span>\n<span class=\"n\">mol</span><span class=\"o\">.</span><span class=\"n\">add_edges_from</span><span class=\"p\">([(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">)])</span>\n<span class=\"k\">for</span> <span class=\"n\">idx</span><span class=\"p\">,</span> <span class=\"n\">ele</span> <span class=\"ow\">in</span> <span class=\"nb\">enumerate</span><span class=\"p\">(</span><span class=\"s1\">'CCCCOCO'</span><span class=\"p\">):</span>\n    <span class=\"n\">mol</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">[</span><span class=\"n\">idx</span><span class=\"p\">][</span><span class=\"s1\">'element'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ele</span>\n<span class=\"n\">mol</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">][</span><span class=\"s1\">'charge'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n<span class=\"n\">mol</span><span class=\"o\">.</span><span class=\"n\">nodes</span><span class=\"p\">[</span><span class=\"mi\">4</span><span class=\"p\">][</span><span class=\"s1\">'hcount'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">mol</span><span class=\"o\">.</span><span class=\"n\">edges</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">][</span><span class=\"s1\">'order'</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">write_smiles</span><span class=\"p\">(</span><span class=\"n\">mol</span><span class=\"p\">))</span>\n<span class=\"c1\"># [O-]C(=O)C([C])([C])[C]</span>\n<span class=\"n\">fill_valence</span><span class=\"p\">(</span><span class=\"n\">mol</span><span class=\"p\">,</span> <span class=\"n\">respect_hcount</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">write_smiles</span><span class=\"p\">(</span><span class=\"n\">mol</span><span class=\"p\">))</span>\n<span class=\"c1\"># [O-]C(=O)C(C)(C)C</span>\n</pre>\n<h2>Limitations</h2>\n<ul>\n<li>The writer produces non-recommended SMILES strings (as per OpenSmiles).</li>\n<li><code>fill_valence</code> does not use 'charge' to find the correct valence.</li>\n<li><code>correct_aromatic_rings</code> is fragile.</li>\n<li>There is currently no way of specifying stereo chemical information. The\nparser can deal with it, but it will be discarded.</li>\n<li>It is not on PyPI</li>\n<li>It only processes SMILES. This might later be extended to e.g. InChi, SLN,\nSMARTS, etc.</li>\n</ul>\n<h2>Requirements</h2>\n<ul>\n<li><a href=\"https://networkx.github.io/\" rel=\"nofollow\">networkx</a></li>\n</ul>\n<h2>Similar projects</h2>\n<p>There are more python projects that deal with SMILES, and I try to list at\nleast some of them here. If yours is missing, feel free to open up a PR.</p>\n<ul>\n<li><a href=\"https://github.com/jhosmer/PySmile\" rel=\"nofollow\">PySMILE</a>: A similar named project,\ncapable of encoding/decoding SMILE format objects. Doesn't deal with\nSMILES.</li>\n<li><a href=\"https://github.com/rdkit/rdkit\" rel=\"nofollow\">RDKit</a>: A collection of cheminformatics and\nmachine-learning software, capable of reading and writing SMILES, InChi,\nand others.</li>\n<li><a href=\"https://www.eyesopen.com/oechem-tk\" rel=\"nofollow\">OpenEye Chem toolkit</a>: The OpenEye\nchemistry toolkit is a programming library for chemistry and\ncheminformatics. It is capable of dealing with (canonical) SMILES and\nInChi.</li>\n</ul>\n<h2>License</h2>\n<p>PySmiles is distributed under the Apache 2.0 license.\nCopyright 2018 Peter C Kroon</p>\n<pre><code>Licensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>\n\n          </div>"}, "last_serial": 4954916, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "c906641a83ba7b547726fc24dcc63ce0", "sha256": "a11bd3024ad98c9d3f63857ec577f34ebc2c211aab8999bcb3fa4a3529b04316"}, "downloads": -1, "filename": "pysmiles-1.0.0.tar.gz", "has_sig": false, "md5_digest": "c906641a83ba7b547726fc24dcc63ce0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32895, "upload_time": "2019-03-18T16:33:52", "upload_time_iso_8601": "2019-03-18T16:33:52.646727Z", "url": "https://files.pythonhosted.org/packages/f3/fa/0fa99007864c6e21040fd1bbf6414bd57f998c540ed13da6d714653fb562/pysmiles-1.0.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "c906641a83ba7b547726fc24dcc63ce0", "sha256": "a11bd3024ad98c9d3f63857ec577f34ebc2c211aab8999bcb3fa4a3529b04316"}, "downloads": -1, "filename": "pysmiles-1.0.0.tar.gz", "has_sig": false, "md5_digest": "c906641a83ba7b547726fc24dcc63ce0", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 32895, "upload_time": "2019-03-18T16:33:52", "upload_time_iso_8601": "2019-03-18T16:33:52.646727Z", "url": "https://files.pythonhosted.org/packages/f3/fa/0fa99007864c6e21040fd1bbf6414bd57f998c540ed13da6d714653fb562/pysmiles-1.0.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:56:32 2020"}