{"info": {"author": "Wojciech Mu\u0142a", "author_email": "wojciech_mula@poczta.onet.pl", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: BSD License", "Programming Language :: C", "Topic :: Software Development :: Libraries", "Topic :: Text Editors :: Text Processing"], "description": "========================================================================\n                               pyDAWG\n========================================================================\n\n.. contents::\n\nIntroduction\n============\n\n``PyDAWG`` is a python module implements DAWG__ graph structure,\nwhich allow to store set of strings and check existence of a string in\nlinear time (in terms of a string length).\n\nDAWG is constructed by **incremental algorithm** described in *Incremental\nalgorithm for sorted data*, **Jan Daciuk**, **Stoyan Mihov**, **Bruce Watson**,\nand **Richard Watson**, Computational Linguistics, 26(1), March 2000.\nProf. Jan Daciuk offers also some useful documentation, presentations and\neven sample code on `his site`__.\n\nThe algorithm asserts that input words are **sorted** in\n`lexicographic order`__; default Python ``sort()``\norders strings correctly.\n\nAlso **minimal perfect hashing** (MPH) is supported, i.e. there is a function\nthat maps words to unique number; this function is bidirectional, its possible\nto find number for given word or get word from number.\n\n__ http://en.wikipedia.org/wiki/DAWG\n__ http://www.eti.pg.gda.pl/katedry/kiw/pracownicy/Jan.Daciuk/personal/\n__ http://en.wikipedia.org/wiki/lexicographic%20order\n\n------------------------------------------------------------------------\n\nThere are two versions of module:\n\n* **C extension**, compatible only with Python3;\n* pure python module, compatible with Python 2 and 3.\n\nPython module implements subset of C extension API.\n\n\nLicense\n=======\n\nLibrary is licensed under very liberal three-clauses BSD license.\nSome portions has been released into public domain.\n\nFull text of license is available in LICENSE file.\n\n\nAuthor\n======\n\nWojciech Mu\u0142a, wojciech_mula@poczta.onet.pl\n\n\nInstallation\n============\n\nCompile time settings (can be change in setup.py):\n\n* ``DAWG_UNICODE`` --- if defined, DAWG accepts and returns\n  unicode strings, else bytes are supported\n\n* ``DAWG_PERFECT_HASHING`` --- when defined, minimal perfect\n  hashing is enabled (methods word2index and index2word are\n  available)\n\n\nJust run::\n\n\t\t$ python setup.py install\n\nIf compilation succed, module is ready to use.\n\n\nAPI\n===\n\n\nModule\n------\n\nModule ``pydawg`` provides class ``DAWG`` and following members:\n\n* ``EMPTY``, ``ACTIVE``, ``CLOSED`` --- symbolic constants for\n  ``state`` member of ``DAWG`` object\n* ``perfect_hashing`` -- see `Minimal perfect hashing`_\n* ``unicode`` -- see `Unicode and bytes`_\n\n\nUnicode and bytes\n~~~~~~~~~~~~~~~~~\n\nType of strings accepted and returned by ``DAWG`` methods can be\neither **unicode** or **bytes**, depending on compile time\nsettings (preprocessor definition ``DAWG_UNICODE``). Value of\nmodule member ``unicode`` informs about chosen type.\n\n\n\n\n``DAWG`` class\n--------------\n\n``DAWG`` class is picklable__, and also provide independent\nway of marshaling with methods ``binload()`` and ``bindump()``.\n\n__ http://docs.python.org/py3k/library/pickle.html\n\n\nProperty\n~~~~~~~~\n\n``state`` [read-only integer]\n\tFollowing values are possible:\n\n\t* ``pydawg.EMPTY`` --- no words in a set;\n\t* ``pydawg.ACTIVE`` --- there is at least one word in a set,\n\t  and adding new words is possible (see ``add_word`` & ``add_word_unchecked``);\n\t* ``pydawg.CLOSED`` --- there is at least one word in a set,\n\t  but adding new words is not allowed (see ``close``/``freeze``).\n\n\nBasic mathods\n~~~~~~~~~~~~~\n\n``add_word(word) => bool``\n\tAdd word, returns True if word didn't exists in a set.\n\tProcedure checks if ``word`` is greater then previously \n\tadded word (in lexicography order).\n\n``add_word_unchecked(word) => bool``\n\tDoes the same thing as ``add_word`` but do not check ``word``\n\torder. Method should be used if one is sure, that input data\n\tsatisfy\talgorithm requirements, i.e. words order is valid.\n\n``exists(word) => bool`` or ``word in ...``\n\tCheck if word is in set.\n\n``match(word) => bool``\n\tCheck if word or any of its prefix is in a set.\n\n``longest_prefix(word) => int``\n\tReturns length of the longest prefix of word that exists in a set.\n\n``len()`` protocol\n\tReturns number of distinct words.\n\n``words() => list``\n\tReturns list of all words.\n\n``find_all([word, [wildchar, [how]]]) => iterator``\n\tReturns iterator that match words depending on ``word`` argument.\n\n\t``find_all()``\n\t\tdoes the same job as ``iter()``\n\n\t``find_all(prefix)``\n\t\tYields words that share a prefix\n\n\t``find_all(pattern, wildchar, [how])``\n\t\tYields words that match a ``pattern`` with given ``wildchar`` (wildchar\n\t\tmatches any char). Parameter ``how`` controls which words are matched:\n\t\t\n\t\t``MATCH_EXACT_LENGTH``\n\t\t\twords with the same length as a pattern\n\n\t\t``MATCH_AT_LEAST_PREFIX``\n\t\t\twords of length not less then pattern\n\n\t\t``MATCH_AT_MOST_PREFIX``\n\t\t\twords of length no greater then pattern\n\n\n``clear()``\n\tErase all words from set.\n\n``close()`` or ``freeze()``\n\tDon't allow to add any new words, ``state`` value become\n\t``pydawg.CLOSED``. Also free memory occupied by\ta hash table\n\tused to perform incremental algorithm (see also\t``get_hash_stats()``).\n\n\tCan be reverted only by ``clear()``.\n\n\nIterator\n~~~~~~~~\n\nClass supports ``iter`` protocol, i.e. ``iter(DAWGobject)`` returns\niterator, a lazy version of ``words()`` method.\n\n\nMinimal perfect hashing\n~~~~~~~~~~~~~~~~~~~~~~~\n\nMinimal `perfect hashing`__ (MPH) allows to find unique number\nrepresenting any word from DAWG, and also find word with given number.\nNumbers are in always in range 1 ... ``len(DAWG)``.\n\nFinally, this feature makes possible to perform fast lookups as\nin a regular dictionary.\n\nAlgorithm used for MPH is described in *Applications of Finite Automata\nRepresenting Large Vocabularies*, **Claudio Lucchesi** and **Tomasz\nKowaltowski**, Software Practice and Experience, 23(1), pp. 15--30, Jan.\n1993.\n\nMPH feature is enabled during compilation time if preprocessor\ndefinition ``DAWG_PERFECT_HASHING`` exists. Module member\n``perfect_hashing`` reflects this setting.\n\n__ http://en.wikipedia.org/wiki/perfect%20hashing\n\n.. warning::\n\tWords numbering is done for the whole DAWG. If new words\n\tare added with ``add_word`` or ``add_word_unchecked``,\n\tthen current numbering is lost and when method ``word2index``\n\tor ``index2word`` is called, then DAWG is renumbered.\n\t\n\tBecause of that frequent mixing these two groups of method\n\twill degrade performance.\n\n\n``word2index(word) => index``\n\tReturns index of word, or None if word is not present in a DAWG.\n\n``index2word(index) => word``\n\tReturns words associated with index, or None if index isn't valid.\n\n\nExample\n#######\n\n::\n\n\tD = pydawg.DAWG()\n\n\t# fill DAWG with keys\n\tfor key in sorted(dict):\n\t\tD.add_word_unchecked(key)\n\n\t# prepare values array\n\tV = [None] * len(D)\n\n\tfor key, value in dict.items():\n\t\tindex = D.word2index(key)\n\t\tassert index is not None\n\n\t\tV[index - 1] = value\n\t\t\n\t\n\t# lookups are possible now\n\tfor word in user_input:\n\t\tindex = D.word2index(word)\n\t\tif index is not None:\n\t\t\tprint(word, \"=>\", V[index - 1])\n\n\nOther\n~~~~~\n\n``dump() => (set of nodes, set of edges)``\n\tReturns sets describing DAWG, elements are tuples.\n\t\n\tNode tuple:\n\n\t* unique id of node (number)\n\t* end of word marker\n\n\tEdge tuple:\n\n\t* source node id\n\t* edge label --- letter\n\t* destination node id\n\n\tDistribution contains program ``dump2dot.py`` that shows how to\n\tconvert output of this function to `graphviz`__ DOT language.\n\n\t__ http://graphviz.org\n\n``bindump() => bytes``\n\tReturns binary DAWG data.\n\n``binload(bytes)``\n\tRestore DAWG from binary data. Example::\n\n\t\timport pydawg\n\n\t\tA = pydawg.DAWG()\n\t\twith open('dump', 'wb') as f:\n\t\t\tf.write(A.bindump())\n\n\t\tB = pydawg.DAWG()\n\t\twith open('dump', 'rb') as f:\n\t\t\tB.binload(f.read())\n\n``get_stats() => dict``\n\tReturns dictionary containing some statistics about\n\tunderlaying data structure:\n\n\t* ``words_count``\t--- number of distinct words (same as ``len(dawg)``)\n\t* ``longest_word``\t--- length of the longest word\n\t* ``nodes_count``\t--- number of nodes\n\t* ``edges_count``\t--- number of edges\n\t* ``sizeof_node``\t--- size of single node (in bytes)\n\t* ``sizeof_edge``\t--- size of single node (in bytes)\n\t* ``graph_size``\t--- size of whole graph (in bytes); it's about\n\t  ``nodes_count * sizeof_node + edges_count * sizeof_edge``\n\n``get_hash_stats() => dict``\n\tReturns some statistics about hash table used by DAWG.\n\n\t* ``table_size``   --- number of table's elements\n\t* ``element_size`` --- size of single table item\n\t* ``items_count``  --- number of items saved in a table\n\t* ``item_size``    --- size of single item\n\n\tApprox memory occupied by hash table is\n\t``table_size * element_size + items_count * item_size``.\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/WojciechMula/pyDAWG", "keywords": "dawg", "license": "BSD (3 clauses)", "maintainer": "", "maintainer_email": "", "name": "pyDAWG", "package_url": "https://pypi.org/project/pyDAWG/", "platform": "Linux", "project_url": "https://pypi.org/project/pyDAWG/", "project_urls": {"Homepage": "http://github.com/WojciechMula/pyDAWG"}, "release_url": "https://pypi.org/project/pyDAWG/1.0.1/", "requires_dist": null, "requires_python": "", "summary": "Directed Acyclic Word Graph (DAWG) allows to store huge strings set in compacted form", "version": "1.0.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"contents\">\n<p>Contents</p>\n<ul>\n<li><a href=\"#introduction\" id=\"id7\" rel=\"nofollow\">Introduction</a></li>\n<li><a href=\"#license\" id=\"id8\" rel=\"nofollow\">License</a></li>\n<li><a href=\"#author\" id=\"id9\" rel=\"nofollow\">Author</a></li>\n<li><a href=\"#installation\" id=\"id10\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#api\" id=\"id11\" rel=\"nofollow\">API</a><ul>\n<li><a href=\"#module\" id=\"id12\" rel=\"nofollow\">Module</a><ul>\n<li><a href=\"#unicode-and-bytes\" id=\"id13\" rel=\"nofollow\">Unicode and bytes</a></li>\n</ul>\n</li>\n<li><a href=\"#dawg-class\" id=\"id14\" rel=\"nofollow\"><tt>DAWG</tt> class</a><ul>\n<li><a href=\"#property\" id=\"id15\" rel=\"nofollow\">Property</a></li>\n<li><a href=\"#basic-mathods\" id=\"id16\" rel=\"nofollow\">Basic mathods</a></li>\n<li><a href=\"#iterator\" id=\"id17\" rel=\"nofollow\">Iterator</a></li>\n<li><a href=\"#minimal-perfect-hashing\" id=\"id18\" rel=\"nofollow\">Minimal perfect hashing</a><ul>\n<li><a href=\"#example\" id=\"id19\" rel=\"nofollow\">Example</a></li>\n</ul>\n</li>\n<li><a href=\"#other\" id=\"id20\" rel=\"nofollow\">Other</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>\n<div id=\"introduction\">\n<h2><a href=\"#id7\" rel=\"nofollow\">Introduction</a></h2>\n<p><tt>PyDAWG</tt> is a python module implements <a href=\"http://en.wikipedia.org/wiki/DAWG\" rel=\"nofollow\">DAWG</a> graph structure,\nwhich allow to store set of strings and check existence of a string in\nlinear time (in terms of a string length).</p>\n<p>DAWG is constructed by <strong>incremental algorithm</strong> described in <em>Incremental\nalgorithm for sorted data</em>, <strong>Jan Daciuk</strong>, <strong>Stoyan Mihov</strong>, <strong>Bruce Watson</strong>,\nand <strong>Richard Watson</strong>, Computational Linguistics, 26(1), March 2000.\nProf. Jan Daciuk offers also some useful documentation, presentations and\neven sample code on <a href=\"http://www.eti.pg.gda.pl/katedry/kiw/pracownicy/Jan.Daciuk/personal/\" rel=\"nofollow\">his site</a>.</p>\n<p>The algorithm asserts that input words are <strong>sorted</strong> in\n<a href=\"http://en.wikipedia.org/wiki/lexicographic%20order\" rel=\"nofollow\">lexicographic order</a>; default Python <tt>sort()</tt>\norders strings correctly.</p>\n<p>Also <strong>minimal perfect hashing</strong> (MPH) is supported, i.e. there is a function\nthat maps words to unique number; this function is bidirectional, its possible\nto find number for given word or get word from number.</p>\n<hr class=\"docutils\">\n<p>There are two versions of module:</p>\n<ul>\n<li><strong>C extension</strong>, compatible only with Python3;</li>\n<li>pure python module, compatible with Python 2 and 3.</li>\n</ul>\n<p>Python module implements subset of C extension API.</p>\n</div>\n<div id=\"license\">\n<h2><a href=\"#id8\" rel=\"nofollow\">License</a></h2>\n<p>Library is licensed under very liberal three-clauses BSD license.\nSome portions has been released into public domain.</p>\n<p>Full text of license is available in LICENSE file.</p>\n</div>\n<div id=\"author\">\n<h2><a href=\"#id9\" rel=\"nofollow\">Author</a></h2>\n<p>Wojciech Mu\u0142a, <a href=\"mailto:wojciech_mula%40poczta.onet.pl\">wojciech_mula<span>@</span>poczta<span>.</span>onet<span>.</span>pl</a></p>\n</div>\n<div id=\"installation\">\n<h2><a href=\"#id10\" rel=\"nofollow\">Installation</a></h2>\n<p>Compile time settings (can be change in setup.py):</p>\n<ul>\n<li><tt>DAWG_UNICODE</tt> \u2014 if defined, DAWG accepts and returns\nunicode strings, else bytes are supported</li>\n<li><tt>DAWG_PERFECT_HASHING</tt> \u2014 when defined, minimal perfect\nhashing is enabled (methods word2index and index2word are\navailable)</li>\n</ul>\n<p>Just run:</p>\n<pre>$ python setup.py install\n</pre>\n<p>If compilation succed, module is ready to use.</p>\n</div>\n<div id=\"api\">\n<h2><a href=\"#id11\" rel=\"nofollow\">API</a></h2>\n<div id=\"module\">\n<h3><a href=\"#id12\" rel=\"nofollow\">Module</a></h3>\n<p>Module <tt>pydawg</tt> provides class <tt>DAWG</tt> and following members:</p>\n<ul>\n<li><tt>EMPTY</tt>, <tt>ACTIVE</tt>, <tt>CLOSED</tt> \u2014 symbolic constants for\n<tt>state</tt> member of <tt>DAWG</tt> object</li>\n<li><tt>perfect_hashing</tt> \u2013 see <a href=\"#minimal-perfect-hashing\" rel=\"nofollow\">Minimal perfect hashing</a></li>\n<li><tt>unicode</tt> \u2013 see <a href=\"#unicode-and-bytes\" rel=\"nofollow\">Unicode and bytes</a></li>\n</ul>\n<div id=\"unicode-and-bytes\">\n<h4><a href=\"#id13\" rel=\"nofollow\">Unicode and bytes</a></h4>\n<p>Type of strings accepted and returned by <tt>DAWG</tt> methods can be\neither <strong>unicode</strong> or <strong>bytes</strong>, depending on compile time\nsettings (preprocessor definition <tt>DAWG_UNICODE</tt>). Value of\nmodule member <tt>unicode</tt> informs about chosen type.</p>\n</div>\n</div>\n<div id=\"dawg-class\">\n<h3><a href=\"#id14\" rel=\"nofollow\"><tt>DAWG</tt> class</a></h3>\n<p><tt>DAWG</tt> class is <a href=\"http://docs.python.org/py3k/library/pickle.html\" rel=\"nofollow\">picklable</a>, and also provide independent\nway of marshaling with methods <tt>binload()</tt> and <tt>bindump()</tt>.</p>\n<div id=\"property\">\n<h4><a href=\"#id15\" rel=\"nofollow\">Property</a></h4>\n<dl>\n<dt><tt>state</tt> [read-only integer]</dt>\n<dd><p>Following values are possible:</p>\n<ul>\n<li><tt>pydawg.EMPTY</tt> \u2014 no words in a set;</li>\n<li><tt>pydawg.ACTIVE</tt> \u2014 there is at least one word in a set,\nand adding new words is possible (see <tt>add_word</tt> &amp; <tt>add_word_unchecked</tt>);</li>\n<li><tt>pydawg.CLOSED</tt> \u2014 there is at least one word in a set,\nbut adding new words is not allowed (see <tt>close</tt>/<tt>freeze</tt>).</li>\n</ul>\n</dd>\n</dl>\n</div>\n<div id=\"basic-mathods\">\n<h4><a href=\"#id16\" rel=\"nofollow\">Basic mathods</a></h4>\n<dl>\n<dt><tt>add_word(word) =&gt; bool</tt></dt>\n<dd>Add word, returns True if word didn\u2019t exists in a set.\nProcedure checks if <tt>word</tt> is greater then previously\nadded word (in lexicography order).</dd>\n<dt><tt>add_word_unchecked(word) =&gt; bool</tt></dt>\n<dd>Does the same thing as <tt>add_word</tt> but do not check <tt>word</tt>\norder. Method should be used if one is sure, that input data\nsatisfy algorithm requirements, i.e. words order is valid.</dd>\n<dt><tt>exists(word) =&gt; bool</tt> or <tt>word in ...</tt></dt>\n<dd>Check if word is in set.</dd>\n<dt><tt>match(word) =&gt; bool</tt></dt>\n<dd>Check if word or any of its prefix is in a set.</dd>\n<dt><tt>longest_prefix(word) =&gt; int</tt></dt>\n<dd>Returns length of the longest prefix of word that exists in a set.</dd>\n<dt><tt>len()</tt> protocol</dt>\n<dd>Returns number of distinct words.</dd>\n<dt><tt>words() =&gt; list</tt></dt>\n<dd>Returns list of all words.</dd>\n<dt><tt><span class=\"pre\">find_all([word,</span> [wildchar, <span class=\"pre\">[how]]])</span> =&gt; iterator</tt></dt>\n<dd><p>Returns iterator that match words depending on <tt>word</tt> argument.</p>\n<dl>\n<dt><tt>find_all()</tt></dt>\n<dd>does the same job as <tt>iter()</tt></dd>\n<dt><tt>find_all(prefix)</tt></dt>\n<dd>Yields words that share a prefix</dd>\n<dt><tt>find_all(pattern, wildchar, [how])</tt></dt>\n<dd><p>Yields words that match a <tt>pattern</tt> with given <tt>wildchar</tt> (wildchar\nmatches any char). Parameter <tt>how</tt> controls which words are matched:</p>\n<dl>\n<dt><tt>MATCH_EXACT_LENGTH</tt></dt>\n<dd>words with the same length as a pattern</dd>\n<dt><tt>MATCH_AT_LEAST_PREFIX</tt></dt>\n<dd>words of length not less then pattern</dd>\n<dt><tt>MATCH_AT_MOST_PREFIX</tt></dt>\n<dd>words of length no greater then pattern</dd>\n</dl>\n</dd>\n</dl>\n</dd>\n<dt><tt>clear()</tt></dt>\n<dd>Erase all words from set.</dd>\n<dt><tt>close()</tt> or <tt>freeze()</tt></dt>\n<dd><p>Don\u2019t allow to add any new words, <tt>state</tt> value become\n<tt>pydawg.CLOSED</tt>. Also free memory occupied by a hash table\nused to perform incremental algorithm (see also <tt>get_hash_stats()</tt>).</p>\n<p>Can be reverted only by <tt>clear()</tt>.</p>\n</dd>\n</dl>\n</div>\n<div id=\"iterator\">\n<h4><a href=\"#id17\" rel=\"nofollow\">Iterator</a></h4>\n<p>Class supports <tt>iter</tt> protocol, i.e. <tt>iter(DAWGobject)</tt> returns\niterator, a lazy version of <tt>words()</tt> method.</p>\n</div>\n<div id=\"minimal-perfect-hashing\">\n<h4><a href=\"#id18\" rel=\"nofollow\">Minimal perfect hashing</a></h4>\n<p>Minimal <a href=\"http://en.wikipedia.org/wiki/perfect%20hashing\" rel=\"nofollow\">perfect hashing</a> (MPH) allows to find unique number\nrepresenting any word from DAWG, and also find word with given number.\nNumbers are in always in range 1 \u2026 <tt>len(DAWG)</tt>.</p>\n<p>Finally, this feature makes possible to perform fast lookups as\nin a regular dictionary.</p>\n<p>Algorithm used for MPH is described in <em>Applications of Finite Automata\nRepresenting Large Vocabularies</em>, <strong>Claudio Lucchesi</strong> and <strong>Tomasz\nKowaltowski</strong>, Software Practice and Experience, 23(1), pp. 15\u201330, Jan.\n1993.</p>\n<p>MPH feature is enabled during compilation time if preprocessor\ndefinition <tt>DAWG_PERFECT_HASHING</tt> exists. Module member\n<tt>perfect_hashing</tt> reflects this setting.</p>\n<div>\n<p>Warning</p>\n<p>Words numbering is done for the whole DAWG. If new words\nare added with <tt>add_word</tt> or <tt>add_word_unchecked</tt>,\nthen current numbering is lost and when method <tt>word2index</tt>\nor <tt>index2word</tt> is called, then DAWG is renumbered.</p>\n<p>Because of that frequent mixing these two groups of method\nwill degrade performance.</p>\n</div>\n<dl>\n<dt><tt>word2index(word) =&gt; index</tt></dt>\n<dd>Returns index of word, or None if word is not present in a DAWG.</dd>\n<dt><tt>index2word(index) =&gt; word</tt></dt>\n<dd>Returns words associated with index, or None if index isn\u2019t valid.</dd>\n</dl>\n<div id=\"example\">\n<h5><a href=\"#id19\" rel=\"nofollow\">Example</a></h5>\n<pre>D = pydawg.DAWG()\n\n# fill DAWG with keys\nfor key in sorted(dict):\n        D.add_word_unchecked(key)\n\n# prepare values array\nV = [None] * len(D)\n\nfor key, value in dict.items():\n        index = D.word2index(key)\n        assert index is not None\n\n        V[index - 1] = value\n\n\n# lookups are possible now\nfor word in user_input:\n        index = D.word2index(word)\n        if index is not None:\n                print(word, \"=&gt;\", V[index - 1])\n</pre>\n</div>\n</div>\n<div id=\"other\">\n<h4><a href=\"#id20\" rel=\"nofollow\">Other</a></h4>\n<dl>\n<dt><tt>dump() =&gt; (set of nodes, set of edges)</tt></dt>\n<dd><p>Returns sets describing DAWG, elements are tuples.</p>\n<p>Node tuple:</p>\n<ul>\n<li>unique id of node (number)</li>\n<li>end of word marker</li>\n</ul>\n<p>Edge tuple:</p>\n<ul>\n<li>source node id</li>\n<li>edge label \u2014 letter</li>\n<li>destination node id</li>\n</ul>\n<p>Distribution contains program <tt>dump2dot.py</tt> that shows how to\nconvert output of this function to <a href=\"http://graphviz.org\" rel=\"nofollow\">graphviz</a> DOT language.</p>\n</dd>\n<dt><tt>bindump() =&gt; bytes</tt></dt>\n<dd>Returns binary DAWG data.</dd>\n<dt><tt>binload(bytes)</tt></dt>\n<dd><p>Restore DAWG from binary data. Example:</p>\n<pre>import pydawg\n\nA = pydawg.DAWG()\nwith open('dump', 'wb') as f:\n        f.write(A.bindump())\n\nB = pydawg.DAWG()\nwith open('dump', 'rb') as f:\n        B.binload(f.read())\n</pre>\n</dd>\n<dt><tt>get_stats() =&gt; dict</tt></dt>\n<dd><p>Returns dictionary containing some statistics about\nunderlaying data structure:</p>\n<ul>\n<li><tt>words_count</tt>       \u2014 number of distinct words (same as <tt>len(dawg)</tt>)</li>\n<li><tt>longest_word</tt>      \u2014 length of the longest word</li>\n<li><tt>nodes_count</tt>       \u2014 number of nodes</li>\n<li><tt>edges_count</tt>       \u2014 number of edges</li>\n<li><tt>sizeof_node</tt>       \u2014 size of single node (in bytes)</li>\n<li><tt>sizeof_edge</tt>       \u2014 size of single node (in bytes)</li>\n<li><tt>graph_size</tt>        \u2014 size of whole graph (in bytes); it\u2019s about\n<tt>nodes_count * sizeof_node + edges_count * sizeof_edge</tt></li>\n</ul>\n</dd>\n<dt><tt>get_hash_stats() =&gt; dict</tt></dt>\n<dd><p>Returns some statistics about hash table used by DAWG.</p>\n<ul>\n<li><tt>table_size</tt>   \u2014 number of table\u2019s elements</li>\n<li><tt>element_size</tt> \u2014 size of single table item</li>\n<li><tt>items_count</tt>  \u2014 number of items saved in a table</li>\n<li><tt>item_size</tt>    \u2014 size of single item</li>\n</ul>\n<p>Approx memory occupied by hash table is\n<tt>table_size * element_size + items_count * item_size</tt>.</p>\n</dd>\n</dl>\n</div>\n</div>\n</div>\n\n          </div>"}, "last_serial": 3810757, "releases": {"1.0.0": [{"comment_text": "", "digests": {"md5": "e4ad879fb6cfc0d9ff4c07e3cad8245e", "sha256": "d8d91178e4aab0642387ae77a72d900f842dfbc2963e262918af97cba53b2ed5"}, "downloads": -1, "filename": "pyDAWG-1.0.0.tar.gz", "has_sig": false, "md5_digest": "e4ad879fb6cfc0d9ff4c07e3cad8245e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 26378, "upload_time": "2014-11-26T17:19:22", "upload_time_iso_8601": "2014-11-26T17:19:22.676787Z", "url": "https://files.pythonhosted.org/packages/db/15/494d4ad17f0755151bac865491334e915efddbed84bec848aaeb5ec7da1f/pyDAWG-1.0.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "bd627ed2a0694ffdeb4cb2f1de7d524f", "sha256": "20577c9bdb67ba244ce9d32a2f000394af1b789c6a5e4113fa43ff1f3eeed3b3"}, "downloads": -1, "filename": "pyDAWG-1.0.1.tar.gz", "has_sig": false, "md5_digest": "bd627ed2a0694ffdeb4cb2f1de7d524f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28670, "upload_time": "2018-04-26T15:40:16", "upload_time_iso_8601": "2018-04-26T15:40:16.280314Z", "url": "https://files.pythonhosted.org/packages/2e/5e/cf8fb76e2a74195dd4771d809d119ec32b75479dda7eac7c4df3f3db353d/pyDAWG-1.0.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "bd627ed2a0694ffdeb4cb2f1de7d524f", "sha256": "20577c9bdb67ba244ce9d32a2f000394af1b789c6a5e4113fa43ff1f3eeed3b3"}, "downloads": -1, "filename": "pyDAWG-1.0.1.tar.gz", "has_sig": false, "md5_digest": "bd627ed2a0694ffdeb4cb2f1de7d524f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 28670, "upload_time": "2018-04-26T15:40:16", "upload_time_iso_8601": "2018-04-26T15:40:16.280314Z", "url": "https://files.pythonhosted.org/packages/2e/5e/cf8fb76e2a74195dd4771d809d119ec32b75479dda7eac7c4df3f3db353d/pyDAWG-1.0.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:07:19 2020"}