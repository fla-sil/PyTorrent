{"info": {"author": "Martin Winks", "author_email": "cat@snejugal.ru", "bugtrack_url": null, "classifiers": ["Framework :: AsyncIO", "Intended Audience :: Developers", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.7", "Programming Language :: Python :: 3.8"], "description": "\ud83c\udf77 Garnet\n===================================\n\nGarnet \u2014 bot-friendly telethon\n-----------------------------------\n\n.. invisible-content-till-nel\n.. _aioredis: https://github.com/aio-libs/aioredis\n.. _cryptg: https://pypi.org/project/cryptg/\n.. _telethon: https://pypi.org/project/Telethon/\n.. _orjson: https://pypi.org/project/orjson/\n.. _ujson: https://pypi.org/project/ujson/\n.. _hachoir: https://pypi.org/project/hachoir/\n.. _aiohttp: https://pypi.org/project/aiohttp/\n.. _Alex: https://github.com/JrooTJunior\n\n.. image:: https://raw.githubusercontent.com/uwinx/garnet/master/static/pomegranate.jpg\n\n.. image:: https://img.shields.io/badge/code%20style-black-000000.svg\n    :target: https://github.com/python/black\n    :alt: aioqiwi-code-style\n\n\nInstall::\n\n    pip install telegram-garnet\n\n\n**Dependencies:**\n    - ``telethon`` - main dependency telethon_\n**Extras:**\n    - ``aioredis`` - redis driver if you use RedisStorage* aioredis_\n    - ``orjson`` || ``ujson`` - RedisStorage/JSONStorage de-&& serialization orjson_ ujson_\n    - ``cryptg``, ``hachoir``, ``aiohttp`` - boost telethon itself cryptg_ hachoir_ aiohttp_\n\n---------------------------------\n\ud83c\udf1a \ud83c\udf1d FSM-Storage types\n---------------------------------\n\n- File - json storage, the main idea behind JSON storage is a custom reload of file and usage of memory session for writing, so the data in json storage not always actual\n\n- Memory - powerful in-memory map<str> based storage, only thing - not persistent\n\n- Redis - (requires aioredis_) - redis is fast key-value storage, if you're using your data is durable and persistent\n\n\nPomegranate implements updates dispatching and checks callback's filters wrapping all callbacks into ``garnet::Callback`` object\n\n----------------\n\ud83d\ude0b Filters\n----------------\n\n``Filter`` object is the essential part of Pomegranate, the do state checking and other stuff.\n\nBasically, it's ``func`` from ``MyEventBuilder(func=lambda self: <bool>)`` but a way more complicated and not stored in EventBuilder, it's stored in callback object\n\n\nUseful filters\n\n1) \ud83d\udce8 **Messages**\n\n\n`Following examples will include pattern`\n\n\n.. code:: python\n\n    from garnet import MessageText, TelegramClient\n    bot = TelegramClient.from_env().start_as_bot()\n\n    # // our code here //\n\n    bot.run_until_disconnected()\n\n.. code:: python\n\n    # handling /start and /help\n    @bot.on(MessageText.commands(\"help\", \"start\"))\n    async def cmd_handler(message: custom.Message):\n        await message.reply(\"Hey there!\")\n\n    # handling exact words\n    my_secret = \"abcxyz\"\n    @bot.on(MessageText.exact(my_secret))\n    async def secret_handler(message: custom.Message):\n        await message.reply(\"Secret entered correctly! Welcome!\")\n\nMessageText or text(``from garnet import text``) includes following comparisons all returning <bool>\n - ``.exact(x)`` -> ``event.raw_text == x``\n - ``.commands(*x)`` -> ``event.raw_text.split()[0][1:] in x``\n - ``.match(x)`` -> ``re.compile(x).match(event.raw_text)``\n - ``.between(*x)`` -> ``event.raw_text in x``\n - ``.isdigit()`` -> ``(event.raw_text or \"\").isdigit()``\n - ``.startswith(x)`` -> ``event.raw_text.startswith(x)``\n\n\n\n2) \ud83d\udc40 **CurrentState class**  [``from garnet import CurrentState``]\n\nOnce great minds decided that state checking will be in filters without adding ``state`` as handler decorator parameter and further storing state in ``callback.(arg)``\n``CurrentState`` class methods return ``Filter``. There are two problems that Filter object really solves, ``Filter``'s function can be any kind of callable(async,sync), filters also have a flag ``requires_context``, FSMProxy is passed if true\n\nSee `FSM example <https://github.com/uwinx/garnet/blob/master/examples/fsm.py>`_ to understand how CurrentState works\n\nIncludes following methods all returning <bool>\n - ``.exact(x)`` or ``CurrentState == x`` -> ``await context.get_state() == x``\n - ``CurrentState == [x, y, z]`` -> ``await context.get_state() in [x, y, z]``\n - ``CurrentState == all`` or ``CurrentState == any`` -> ``await context.get_state() is not None``\n\n\n3) \ud83e\udd94 Custom **Filter**\n\nIf you want to write your own filter, do it.\n\n\n.. code:: python\n\n    from garnet import Filter, FSMProxy\n\n    async def myFunc(event): ...\n    async def myFuncContextRequires(event, context: FSMProxy): ...\n    def normal_func(event): ...\n\n    @bot.on(Filter(normal_func), Filter(myFunc), Filter(myFuncContextRequires, requires_context=True))\n    async def handler(event, context: FSMProxy): ...\n    # same as\n    @bot.on(normal_func, myFunc, Filter(myFuncContextRequires, requires_context=True))\n    async def handler(event): ...\n\nSo the handler can take strict ``context`` argument and also ignore it\n\n-----------------------\nOn start|finish\n-----------------------\n\n``garnet::TelegramClient`` contains three lists on_start on_background and on_finish, their instance is ``PseudoFrozenList`` which freezes at calling ``.run_until_disconnected``\n``PseudoFrozenList`` has three main methods::\n\n    .append(*items)\n    .remove(*items)\n    .freeze()\n    .__call__(func)   # for shiny decorator\n\n``items`` in case of TelegramClient means unpacked container of async-defined functions taking on position arguments\n\nUsage example:\n\n.. code-block:: python\n\n    # my_module.py\n    class MyPostgresDatabase:\n        ...\n        async def close_pool(self, bot): await self.pool.safe_close()\n        async def open_pool(self, bot): await self.pool.open_conn_pool()\n\n    # garnethon.py\n    from garnet import TelegramClient\n    from my_module import MyPostgresDatabase\n\n    db = MyPostgresDatabase()\n    bot = TelegramClient.from_env().start_as_bot()\n    bot.on_start.append(db.open_pool)\n    bot.on_finish.append(db.close_pool)\n    ...\n\n    @bot.on_background\n    async def xyz(cl: TelegramClient):\n        while True:\n           ...\n\n    bot.run_until_connected()\n\n\n-------------------------------------------------\n\ud83d\udce6 Router and Migrating to garnet using Router\n-------------------------------------------------\n\nThink of router as just a dummy container of handlers(callbacks)\n\n`garnet::router::Router` may be helpful if you have telethon's `event.register` registered handlers. One thing: Router, I believe, is correct and more obvious way of registering event handlers. Example:\n\n**Migrate from telethon to garnet, also use for bot.on cases(soon better example)**\n\n.. code-block:: python\n\n    # my_handlers.py\n\n    # telethon register(bad) will raise Warning in garnet\n    from telethon import events\n\n    @events.register(event_type)\n    async def handler(event): ...\n\n    # garnet's telethon-like router\n    from garnet.router import TelethonRouter\n\n    router = TelethonRouter()\n\n    @router(event_type)\n    async def handler(event): ...\n\n\n\nThe advantage of routers is evidence of registering handlers when you have module-separated handlers. `events.register` was doing well, but blindly importing modules to register handlers and don't use them(modules) doesn't seem like a good idea.\n\n\nExample of registering router in bot application\n\n\n.. code-block:: python\n\n    # handlers/messages.py\n    from garnet.router import Router\n\n    router = Router()\n\n    @router()\n    async def handler(event): ...\n\n    # handlers/cb_query.py\n    from garnet.events import CallbackQuery\n    from garnet.router import Router\n\n    router = Router()\n\n    @router(event=CallbackQuery())\n    async def handler(event): ...\n\n    # entry.py ()\n    from garnet import TelegramClient\n\n    from handlers import messages, cb_query\n\n    tg = TelegramClient.from_env().start_as_bot()\n    tg.bind_routers(messages, cb_query)\n    ...\n\n`TelethonRouter` and `Router` both have following remarkable methods:\n\n::\n\n    .message_handler(*filters)\n    .callback_query_handler(*filters)\n    .chat_action_handler(*filters)\n    .message_edited_handler(*filters)\n    .album_handler(*filters)\n\n--------------------\n\ud83c\udf6c Context magic\n--------------------\n\nOne of the sweetest parts of garnet. Using `contextvars` we reach incredibly beautiful code :D\n*this is not FSMContext don't confuse with context magic provided by contextvars*\n\nAs an example, bot that doesn't requires `TelegramClient` to answer messages directly.\n\n.. code-block:: python\n\n    from garnet.functions.messages import reply, message, respond\n\n    @bot.message_handler()\n    async def handler():\n        # message() - function to get current Message event\n        await message().respond(\"ok\")\n        await message().reply(\"ok\")\n        # the same result, but shortcuts\n        await respond(\"ok\")\n        await reply(\"Ok\")\n\n\n\n-----------------\nWhat's more \u2753\n-----------------\n\nClass-based handlers are also can be implemented with garnet conveniently. Use your imagination and ``garnet::callbacks::base::Callback`` as a parent class\n\nAwesome bitwise operation supported filters(I highly recommend to use them)::\n\n    # & (conjunction), | (disjunction), ~ (inversion), ^ (exclusive disjunction)\n    # also: ==, != (idk why)\n    @bot.on(MessageText.exact(\".\") | MessageText.exact(\"..\"))\n\n\n``Len`` attribute in ``MessageText`` which has cmp methods::\n\n\n    @bot.on((MessageText.Len <= 14) | (MessageText.Len >= 88))\n\n\nUsing `client = TelegramClient.start` assignment and start client on the fly, make annotation or typing.cast to have better hints.\n\n---------------\nAbout\n---------------\n\nYou can find me in tg by `@martin_winks <https://telegram.me/martin_winks>`_ and yeah I receive donates as well as all contributors do(support `lonamiwebs <http://paypal.me/lonamiwebs>`_ and `JRootJunior <https://opencollective.com/aiogram/organization/0/website>`_).\n\n\n---------------------\n\ud83e\udd17 Credits\n---------------------\n\nFinite-state machine was ported from cool BotAPI library 'aiogram', special thanks to Alex_\n", "description_content_type": "text/x-rst", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/uwinx/garnet", "keywords": "telegram,telethon,telegram-bot,bot", "license": "", "maintainer": "", "maintainer_email": "", "name": "telegram-garnet", "package_url": "https://pypi.org/project/telegram-garnet/", "platform": "", "project_url": "https://pypi.org/project/telegram-garnet/", "project_urls": {"Homepage": "https://github.com/uwinx/garnet", "Repository": "https://github.com/uwinx/garnet"}, "release_url": "https://pypi.org/project/telegram-garnet/0.2.4/", "requires_dist": ["Telethon (>=1.10.8,<2.0)"], "requires_python": ">=3.7,<4.0", "summary": "Garnet - cool add-on for Telethon", "version": "0.2.4", "yanked": false, "html_description": "<div class=\"project-description\">\n            <img alt=\"https://raw.githubusercontent.com/uwinx/garnet/master/static/pomegranate.jpg\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/8d4164ed84881e60493ffec25ec9ea1c663652a3/68747470733a2f2f7261772e67697468756275736572636f6e74656e742e636f6d2f7577696e782f6761726e65742f6d61737465722f7374617469632f706f6d656772616e6174652e6a7067\">\n<a href=\"https://github.com/python/black\" rel=\"nofollow\"><img alt=\"aioqiwi-code-style\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/fbfdc7754183ecf079bc71ddeabaf88f6cbc5c00/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f636f64652532307374796c652d626c61636b2d3030303030302e737667\"></a>\n<p>Install:</p>\n<pre>pip install telegram-garnet\n</pre>\n<dl>\n<dt><strong>Dependencies:</strong></dt>\n<dd><ul>\n<li><tt>telethon</tt> - main dependency <a href=\"https://pypi.org/project/Telethon/\" rel=\"nofollow\">telethon</a></li>\n</ul>\n</dd>\n<dt><strong>Extras:</strong></dt>\n<dd><ul>\n<li><tt>aioredis</tt> - redis driver if you use RedisStorage* <a href=\"https://github.com/aio-libs/aioredis\" rel=\"nofollow\">aioredis</a></li>\n<li><tt>orjson</tt> || <tt>ujson</tt> - RedisStorage/JSONStorage de-&amp;&amp; serialization <a href=\"https://pypi.org/project/orjson/\" rel=\"nofollow\">orjson</a> <a href=\"https://pypi.org/project/ujson/\" rel=\"nofollow\">ujson</a></li>\n<li><tt>cryptg</tt>, <tt>hachoir</tt>, <tt>aiohttp</tt> - boost telethon itself <a href=\"https://pypi.org/project/cryptg/\" rel=\"nofollow\">cryptg</a> <a href=\"https://pypi.org/project/hachoir/\" rel=\"nofollow\">hachoir</a> <a href=\"https://pypi.org/project/aiohttp/\" rel=\"nofollow\">aiohttp</a></li>\n</ul>\n</dd>\n</dl>\n<div id=\"fsm-storage-types\">\n<h2>\ud83c\udf1a \ud83c\udf1d FSM-Storage types</h2>\n<ul>\n<li>File - json storage, the main idea behind JSON storage is a custom reload of file and usage of memory session for writing, so the data in json storage not always actual</li>\n<li>Memory - powerful in-memory map&lt;str&gt; based storage, only thing - not persistent</li>\n<li>Redis - (requires <a href=\"https://github.com/aio-libs/aioredis\" rel=\"nofollow\">aioredis</a>) - redis is fast key-value storage, if you\u2019re using your data is durable and persistent</li>\n</ul>\n<p>Pomegranate implements updates dispatching and checks callback\u2019s filters wrapping all callbacks into <tt><span class=\"pre\">garnet::Callback</span></tt> object</p>\n</div>\n<div id=\"filters\">\n<h2>\ud83d\ude0b Filters</h2>\n<p><tt>Filter</tt> object is the essential part of Pomegranate, the do state checking and other stuff.</p>\n<p>Basically, it\u2019s <tt>func</tt> from <tt>MyEventBuilder(func=lambda self: &lt;bool&gt;)</tt> but a way more complicated and not stored in EventBuilder, it\u2019s stored in callback object</p>\n<p>Useful filters</p>\n<ol>\n<li>\ud83d\udce8 <strong>Messages</strong></li>\n</ol>\n<p><cite>Following examples will include pattern</cite></p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">garnet</span> <span class=\"kn\">import</span> <span class=\"n\">MessageText</span><span class=\"p\">,</span> <span class=\"n\">TelegramClient</span>\n<span class=\"n\">bot</span> <span class=\"o\">=</span> <span class=\"n\">TelegramClient</span><span class=\"o\">.</span><span class=\"n\">from_env</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">start_as_bot</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># // our code here //</span>\n\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">run_until_disconnected</span><span class=\"p\">()</span>\n</pre>\n<pre><span class=\"c1\"># handling /start and /help</span>\n<span class=\"nd\">@bot</span><span class=\"o\">.</span><span class=\"n\">on</span><span class=\"p\">(</span><span class=\"n\">MessageText</span><span class=\"o\">.</span><span class=\"n\">commands</span><span class=\"p\">(</span><span class=\"s2\">\"help\"</span><span class=\"p\">,</span> <span class=\"s2\">\"start\"</span><span class=\"p\">))</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">cmd_handler</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"n\">custom</span><span class=\"o\">.</span><span class=\"n\">Message</span><span class=\"p\">):</span>\n    <span class=\"k\">await</span> <span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">reply</span><span class=\"p\">(</span><span class=\"s2\">\"Hey there!\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># handling exact words</span>\n<span class=\"n\">my_secret</span> <span class=\"o\">=</span> <span class=\"s2\">\"abcxyz\"</span>\n<span class=\"nd\">@bot</span><span class=\"o\">.</span><span class=\"n\">on</span><span class=\"p\">(</span><span class=\"n\">MessageText</span><span class=\"o\">.</span><span class=\"n\">exact</span><span class=\"p\">(</span><span class=\"n\">my_secret</span><span class=\"p\">))</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">secret_handler</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"n\">custom</span><span class=\"o\">.</span><span class=\"n\">Message</span><span class=\"p\">):</span>\n    <span class=\"k\">await</span> <span class=\"n\">message</span><span class=\"o\">.</span><span class=\"n\">reply</span><span class=\"p\">(</span><span class=\"s2\">\"Secret entered correctly! Welcome!\"</span><span class=\"p\">)</span>\n</pre>\n<dl>\n<dt>MessageText or text(<tt>from garnet import text</tt>) includes following comparisons all returning &lt;bool&gt;</dt>\n<dd><ul>\n<li><tt>.exact(x)</tt> -&gt; <tt>event.raw_text == x</tt></li>\n<li><tt><span class=\"pre\">.commands(*x)</span></tt> -&gt; <tt><span class=\"pre\">event.raw_text.split()[0][1:]</span> in x</tt></li>\n<li><tt>.match(x)</tt> -&gt; <tt><span class=\"pre\">re.compile(x).match(event.raw_text)</span></tt></li>\n<li><tt><span class=\"pre\">.between(*x)</span></tt> -&gt; <tt>event.raw_text in x</tt></li>\n<li><tt>.isdigit()</tt> -&gt; <tt>(event.raw_text or <span class=\"pre\">\"\").isdigit()</span></tt></li>\n<li><tt>.startswith(x)</tt> -&gt; <tt>event.raw_text.startswith(x)</tt></li>\n</ul>\n</dd>\n</dl>\n<ol>\n<li>\ud83d\udc40 <strong>CurrentState class</strong>  [<tt>from garnet import CurrentState</tt>]</li>\n</ol>\n<p>Once great minds decided that state checking will be in filters without adding <tt>state</tt> as handler decorator parameter and further storing state in <tt><span class=\"pre\">callback.(arg)</span></tt>\n<tt>CurrentState</tt> class methods return <tt>Filter</tt>. There are two problems that Filter object really solves, <tt>Filter</tt>\u2019s function can be any kind of callable(async,sync), filters also have a flag <tt>requires_context</tt>, FSMProxy is passed if true</p>\n<p>See <a href=\"https://github.com/uwinx/garnet/blob/master/examples/fsm.py\" rel=\"nofollow\">FSM example</a> to understand how CurrentState works</p>\n<dl>\n<dt>Includes following methods all returning &lt;bool&gt;</dt>\n<dd><ul>\n<li><tt>.exact(x)</tt> or <tt>CurrentState == x</tt> -&gt; <tt>await context.get_state() == x</tt></li>\n<li><tt>CurrentState == [x, y, z]</tt> -&gt; <tt>await context.get_state() in [x, y, z]</tt></li>\n<li><tt>CurrentState == all</tt> or <tt>CurrentState == any</tt> -&gt; <tt>await context.get_state() is not None</tt></li>\n</ul>\n</dd>\n</dl>\n<ol>\n<li>\ud83e\udd94 Custom <strong>Filter</strong></li>\n</ol>\n<p>If you want to write your own filter, do it.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">garnet</span> <span class=\"kn\">import</span> <span class=\"n\">Filter</span><span class=\"p\">,</span> <span class=\"n\">FSMProxy</span>\n\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">myFunc</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">myFuncContextRequires</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">,</span> <span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">FSMProxy</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n<span class=\"k\">def</span> <span class=\"nf\">normal_func</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n\n<span class=\"nd\">@bot</span><span class=\"o\">.</span><span class=\"n\">on</span><span class=\"p\">(</span><span class=\"n\">Filter</span><span class=\"p\">(</span><span class=\"n\">normal_func</span><span class=\"p\">),</span> <span class=\"n\">Filter</span><span class=\"p\">(</span><span class=\"n\">myFunc</span><span class=\"p\">),</span> <span class=\"n\">Filter</span><span class=\"p\">(</span><span class=\"n\">myFuncContextRequires</span><span class=\"p\">,</span> <span class=\"n\">requires_context</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">))</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">,</span> <span class=\"n\">context</span><span class=\"p\">:</span> <span class=\"n\">FSMProxy</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n<span class=\"c1\"># same as</span>\n<span class=\"nd\">@bot</span><span class=\"o\">.</span><span class=\"n\">on</span><span class=\"p\">(</span><span class=\"n\">normal_func</span><span class=\"p\">,</span> <span class=\"n\">myFunc</span><span class=\"p\">,</span> <span class=\"n\">Filter</span><span class=\"p\">(</span><span class=\"n\">myFuncContextRequires</span><span class=\"p\">,</span> <span class=\"n\">requires_context</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">))</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre>\n<p>So the handler can take strict <tt>context</tt> argument and also ignore it</p>\n</div>\n<div id=\"on-start-finish\">\n<h2>On start|finish</h2>\n<p><tt><span class=\"pre\">garnet::TelegramClient</span></tt> contains three lists on_start on_background and on_finish, their instance is <tt>PseudoFrozenList</tt> which freezes at calling <tt>.run_until_disconnected</tt>\n<tt>PseudoFrozenList</tt> has three main methods:</p>\n<pre>.append(*items)\n.remove(*items)\n.freeze()\n.__call__(func)   # for shiny decorator\n</pre>\n<p><tt>items</tt> in case of TelegramClient means unpacked container of async-defined functions taking on position arguments</p>\n<p>Usage example:</p>\n<pre><span class=\"c1\"># my_module.py</span>\n<span class=\"k\">class</span> <span class=\"nc\">MyPostgresDatabase</span><span class=\"p\">:</span>\n    <span class=\"o\">...</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">close_pool</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">bot</span><span class=\"p\">):</span> <span class=\"k\">await</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">pool</span><span class=\"o\">.</span><span class=\"n\">safe_close</span><span class=\"p\">()</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">open_pool</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">bot</span><span class=\"p\">):</span> <span class=\"k\">await</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">pool</span><span class=\"o\">.</span><span class=\"n\">open_conn_pool</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># garnethon.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">garnet</span> <span class=\"kn\">import</span> <span class=\"n\">TelegramClient</span>\n<span class=\"kn\">from</span> <span class=\"nn\">my_module</span> <span class=\"kn\">import</span> <span class=\"n\">MyPostgresDatabase</span>\n\n<span class=\"n\">db</span> <span class=\"o\">=</span> <span class=\"n\">MyPostgresDatabase</span><span class=\"p\">()</span>\n<span class=\"n\">bot</span> <span class=\"o\">=</span> <span class=\"n\">TelegramClient</span><span class=\"o\">.</span><span class=\"n\">from_env</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">start_as_bot</span><span class=\"p\">()</span>\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">on_start</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">open_pool</span><span class=\"p\">)</span>\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">on_finish</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">db</span><span class=\"o\">.</span><span class=\"n\">close_pool</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n\n<span class=\"nd\">@bot</span><span class=\"o\">.</span><span class=\"n\">on_background</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">xyz</span><span class=\"p\">(</span><span class=\"n\">cl</span><span class=\"p\">:</span> <span class=\"n\">TelegramClient</span><span class=\"p\">):</span>\n    <span class=\"k\">while</span> <span class=\"kc\">True</span><span class=\"p\">:</span>\n       <span class=\"o\">...</span>\n\n<span class=\"n\">bot</span><span class=\"o\">.</span><span class=\"n\">run_until_connected</span><span class=\"p\">()</span>\n</pre>\n</div>\n<div id=\"router-and-migrating-to-garnet-using-router\">\n<h2>\ud83d\udce6 Router and Migrating to garnet using Router</h2>\n<p>Think of router as just a dummy container of handlers(callbacks)</p>\n<p><cite>garnet::router::Router</cite> may be helpful if you have telethon\u2019s <cite>event.register</cite> registered handlers. One thing: Router, I believe, is correct and more obvious way of registering event handlers. Example:</p>\n<p><strong>Migrate from telethon to garnet, also use for bot.on cases(soon better example)</strong></p>\n<pre><span class=\"c1\"># my_handlers.py</span>\n\n<span class=\"c1\"># telethon register(bad) will raise Warning in garnet</span>\n<span class=\"kn\">from</span> <span class=\"nn\">telethon</span> <span class=\"kn\">import</span> <span class=\"n\">events</span>\n\n<span class=\"nd\">@events</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"n\">event_type</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n\n<span class=\"c1\"># garnet's telethon-like router</span>\n<span class=\"kn\">from</span> <span class=\"nn\">garnet.router</span> <span class=\"kn\">import</span> <span class=\"n\">TelethonRouter</span>\n\n<span class=\"n\">router</span> <span class=\"o\">=</span> <span class=\"n\">TelethonRouter</span><span class=\"p\">()</span>\n\n<span class=\"nd\">@router</span><span class=\"p\">(</span><span class=\"n\">event_type</span><span class=\"p\">)</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n</pre>\n<p>The advantage of routers is evidence of registering handlers when you have module-separated handlers. <cite>events.register</cite> was doing well, but blindly importing modules to register handlers and don\u2019t use them(modules) doesn\u2019t seem like a good idea.</p>\n<p>Example of registering router in bot application</p>\n<pre><span class=\"c1\"># handlers/messages.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">garnet.router</span> <span class=\"kn\">import</span> <span class=\"n\">Router</span>\n\n<span class=\"n\">router</span> <span class=\"o\">=</span> <span class=\"n\">Router</span><span class=\"p\">()</span>\n\n<span class=\"nd\">@router</span><span class=\"p\">()</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n\n<span class=\"c1\"># handlers/cb_query.py</span>\n<span class=\"kn\">from</span> <span class=\"nn\">garnet.events</span> <span class=\"kn\">import</span> <span class=\"n\">CallbackQuery</span>\n<span class=\"kn\">from</span> <span class=\"nn\">garnet.router</span> <span class=\"kn\">import</span> <span class=\"n\">Router</span>\n\n<span class=\"n\">router</span> <span class=\"o\">=</span> <span class=\"n\">Router</span><span class=\"p\">()</span>\n\n<span class=\"nd\">@router</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"o\">=</span><span class=\"n\">CallbackQuery</span><span class=\"p\">())</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">(</span><span class=\"n\">event</span><span class=\"p\">):</span> <span class=\"o\">...</span>\n\n<span class=\"c1\"># entry.py ()</span>\n<span class=\"kn\">from</span> <span class=\"nn\">garnet</span> <span class=\"kn\">import</span> <span class=\"n\">TelegramClient</span>\n\n<span class=\"kn\">from</span> <span class=\"nn\">handlers</span> <span class=\"kn\">import</span> <span class=\"n\">messages</span><span class=\"p\">,</span> <span class=\"n\">cb_query</span>\n\n<span class=\"n\">tg</span> <span class=\"o\">=</span> <span class=\"n\">TelegramClient</span><span class=\"o\">.</span><span class=\"n\">from_env</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">start_as_bot</span><span class=\"p\">()</span>\n<span class=\"n\">tg</span><span class=\"o\">.</span><span class=\"n\">bind_routers</span><span class=\"p\">(</span><span class=\"n\">messages</span><span class=\"p\">,</span> <span class=\"n\">cb_query</span><span class=\"p\">)</span>\n<span class=\"o\">...</span>\n</pre>\n<p><cite>TelethonRouter</cite> and <cite>Router</cite> both have following remarkable methods:</p>\n<pre>.message_handler(*filters)\n.callback_query_handler(*filters)\n.chat_action_handler(*filters)\n.message_edited_handler(*filters)\n.album_handler(*filters)\n</pre>\n</div>\n<div id=\"context-magic\">\n<h2>\ud83c\udf6c Context magic</h2>\n<p>One of the sweetest parts of garnet. Using <cite>contextvars</cite> we reach incredibly beautiful code :D\n<em>this is not FSMContext don\u2019t confuse with context magic provided by contextvars</em></p>\n<p>As an example, bot that doesn\u2019t requires <cite>TelegramClient</cite> to answer messages directly.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">garnet.functions.messages</span> <span class=\"kn\">import</span> <span class=\"n\">reply</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">,</span> <span class=\"n\">respond</span>\n\n<span class=\"nd\">@bot</span><span class=\"o\">.</span><span class=\"n\">message_handler</span><span class=\"p\">()</span>\n<span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">handler</span><span class=\"p\">():</span>\n    <span class=\"c1\"># message() - function to get current Message event</span>\n    <span class=\"k\">await</span> <span class=\"n\">message</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">respond</span><span class=\"p\">(</span><span class=\"s2\">\"ok\"</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">message</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">reply</span><span class=\"p\">(</span><span class=\"s2\">\"ok\"</span><span class=\"p\">)</span>\n    <span class=\"c1\"># the same result, but shortcuts</span>\n    <span class=\"k\">await</span> <span class=\"n\">respond</span><span class=\"p\">(</span><span class=\"s2\">\"ok\"</span><span class=\"p\">)</span>\n    <span class=\"k\">await</span> <span class=\"n\">reply</span><span class=\"p\">(</span><span class=\"s2\">\"Ok\"</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"what-s-more\">\n<h2>What\u2019s more \u2753</h2>\n<p>Class-based handlers are also can be implemented with garnet conveniently. Use your imagination and <tt><span class=\"pre\">garnet::callbacks::base::Callback</span></tt> as a parent class</p>\n<p>Awesome bitwise operation supported filters(I highly recommend to use them):</p>\n<pre># &amp; (conjunction), | (disjunction), ~ (inversion), ^ (exclusive disjunction)\n# also: ==, != (idk why)\n@bot.on(MessageText.exact(\".\") | MessageText.exact(\"..\"))\n</pre>\n<p><tt>Len</tt> attribute in <tt>MessageText</tt> which has cmp methods:</p>\n<pre>@bot.on((MessageText.Len &lt;= 14) | (MessageText.Len &gt;= 88))\n</pre>\n<p>Using <cite>client = TelegramClient.start</cite> assignment and start client on the fly, make annotation or typing.cast to have better hints.</p>\n</div>\n<div id=\"about\">\n<h2>About</h2>\n<p>You can find me in tg by <a href=\"https://telegram.me/martin_winks\" rel=\"nofollow\">@martin_winks</a> and yeah I receive donates as well as all contributors do(support <a href=\"http://paypal.me/lonamiwebs\" rel=\"nofollow\">lonamiwebs</a> and <a href=\"https://opencollective.com/aiogram/organization/0/website\" rel=\"nofollow\">JRootJunior</a>).</p>\n</div>\n<div id=\"credits\">\n<h2>\ud83e\udd17 Credits</h2>\n<p>Finite-state machine was ported from cool BotAPI library \u2018aiogram\u2019, special thanks to <a href=\"https://github.com/JrooTJunior\" rel=\"nofollow\">Alex</a></p>\n</div>\n\n          </div>"}, "last_serial": 7014818, "releases": {"0.2.2": [{"comment_text": "", "digests": {"md5": "d6f415df852ddf31483036ff4835e66e", "sha256": "c3248c5dad371450bcb327cf43b344adae0968b64061ef2d235c8e09d200e78d"}, "downloads": -1, "filename": "telegram_garnet-0.2.2-py3-none-any.whl", "has_sig": false, "md5_digest": "d6f415df852ddf31483036ff4835e66e", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7,<4.0", "size": 32235, "upload_time": "2020-04-06T00:35:33", "upload_time_iso_8601": "2020-04-06T00:35:33.432919Z", "url": "https://files.pythonhosted.org/packages/10/c4/97a9a073d970dd4d1e0023118d1f0c68b87ab7cf60b6e837a0223ecfeb3e/telegram_garnet-0.2.2-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0776e50f15e1a3f695b91bf76afca58a", "sha256": "e4180b4c827d5a01771df629c736e83236695867c61dedea9f1fb7bfe67e4357"}, "downloads": -1, "filename": "telegram-garnet-0.2.2.tar.gz", "has_sig": false, "md5_digest": "0776e50f15e1a3f695b91bf76afca58a", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7,<4.0", "size": 26077, "upload_time": "2020-04-06T00:35:30", "upload_time_iso_8601": "2020-04-06T00:35:30.325990Z", "url": "https://files.pythonhosted.org/packages/ab/45/7d8b7c0d80661f72c12d218d4c27eff5004f7762db820b7522842ebb2b73/telegram-garnet-0.2.2.tar.gz", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "5d6090470864d9d611a4572917748471", "sha256": "46e8fbe405b988bce0120185c3b5be562f91d1df9e4afcf1eda514bd9b6eaa02"}, "downloads": -1, "filename": "telegram_garnet-0.2.3-py3-none-any.whl", "has_sig": false, "md5_digest": "5d6090470864d9d611a4572917748471", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7,<4.0", "size": 32085, "upload_time": "2020-04-14T05:10:30", "upload_time_iso_8601": "2020-04-14T05:10:30.897344Z", "url": "https://files.pythonhosted.org/packages/85/cc/7ec352952bd96757334ff8cdb6291f6541e5c4fedf39a0234abb1dc69365/telegram_garnet-0.2.3-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "31aefab41547c1bdaf46b14c384553a6", "sha256": "dc6c396c560b011f342272529f19370eab95fb54dd8e18c6e6983a0c4bce69a4"}, "downloads": -1, "filename": "telegram-garnet-0.2.3.tar.gz", "has_sig": false, "md5_digest": "31aefab41547c1bdaf46b14c384553a6", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7,<4.0", "size": 25923, "upload_time": "2020-04-14T05:10:29", "upload_time_iso_8601": "2020-04-14T05:10:29.176105Z", "url": "https://files.pythonhosted.org/packages/13/a3/f12d58bba3b487c2797da0a7edb7becae8d5cd28f6da3689aa3546946419/telegram-garnet-0.2.3.tar.gz", "yanked": false}], "0.2.4": [{"comment_text": "", "digests": {"md5": "3096d424d5671c81e2c4a6515cec9274", "sha256": "c97f5d5a0d8894c8d38c8431cb84b8f364acc98a4cc89e18b1939173c2f1b48c"}, "downloads": -1, "filename": "telegram_garnet-0.2.4-py3-none-any.whl", "has_sig": false, "md5_digest": "3096d424d5671c81e2c4a6515cec9274", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7,<4.0", "size": 32054, "upload_time": "2020-04-14T05:49:09", "upload_time_iso_8601": "2020-04-14T05:49:09.709165Z", "url": "https://files.pythonhosted.org/packages/b3/b2/6101b966ecbb37060f1c329565f0c95cce0e5858d61b09a93bc25c4c88cc/telegram_garnet-0.2.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0f047d312f50b1c2b1aa5c291d7b37d1", "sha256": "0808811ed755c39a0af0d551e1ca9b3f3a5d9d0878d2486c55e61940157912e5"}, "downloads": -1, "filename": "telegram-garnet-0.2.4.tar.gz", "has_sig": false, "md5_digest": "0f047d312f50b1c2b1aa5c291d7b37d1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7,<4.0", "size": 25909, "upload_time": "2020-04-14T05:49:07", "upload_time_iso_8601": "2020-04-14T05:49:07.344715Z", "url": "https://files.pythonhosted.org/packages/15/68/751c64067e1fe3ec90c5e265df63e513f889e513f131e15175a478773a3c/telegram-garnet-0.2.4.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "3096d424d5671c81e2c4a6515cec9274", "sha256": "c97f5d5a0d8894c8d38c8431cb84b8f364acc98a4cc89e18b1939173c2f1b48c"}, "downloads": -1, "filename": "telegram_garnet-0.2.4-py3-none-any.whl", "has_sig": false, "md5_digest": "3096d424d5671c81e2c4a6515cec9274", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3.7,<4.0", "size": 32054, "upload_time": "2020-04-14T05:49:09", "upload_time_iso_8601": "2020-04-14T05:49:09.709165Z", "url": "https://files.pythonhosted.org/packages/b3/b2/6101b966ecbb37060f1c329565f0c95cce0e5858d61b09a93bc25c4c88cc/telegram_garnet-0.2.4-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0f047d312f50b1c2b1aa5c291d7b37d1", "sha256": "0808811ed755c39a0af0d551e1ca9b3f3a5d9d0878d2486c55e61940157912e5"}, "downloads": -1, "filename": "telegram-garnet-0.2.4.tar.gz", "has_sig": false, "md5_digest": "0f047d312f50b1c2b1aa5c291d7b37d1", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3.7,<4.0", "size": 25909, "upload_time": "2020-04-14T05:49:07", "upload_time_iso_8601": "2020-04-14T05:49:07.344715Z", "url": "https://files.pythonhosted.org/packages/15/68/751c64067e1fe3ec90c5e265df63e513f889e513f131e15175a478773a3c/telegram-garnet-0.2.4.tar.gz", "yanked": false}], "timestamp": "Fri May  8 02:56:55 2020"}