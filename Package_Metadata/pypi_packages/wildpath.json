{"info": {"author": "Lars van Gemerden", "author_email": "gemerden@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 2", "Programming Language :: Python :: 2.7", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.3", "Programming Language :: Python :: 3.4", "Programming Language :: Python :: 3.5", "Programming Language :: Python :: 3.6", "Topic :: Software Development"], "description": ".. figure:: https://travis-ci.org/gemerden/wildpath.svg?branch=master\r\n   :alt: Travis\r\n\r\n   Travis\r\n\r\nWildPath\r\n========\r\n\r\nA path abstraction to access items in composite (e.g. JSON) objects in\r\npython.\r\n\r\nIntroduction\r\n------------\r\n\r\nThis module is intended primarily as a practical tool to access data in\r\ncomplex data structures. Especially accessing multiple items usually\r\nrequires for-loops or other constructs and there is no straightforward\r\nway to pass nested locations as single parameters. This module solves\r\nthis problem by introdicing 2 classes:\r\n\r\n-  ``Path`` allows to get, set and delete single items in the data\r\n   structure; it is optimized for speed,\r\n-  ``WildPath`` does the same and allows wildcards and boolean logic\r\n   (and, or, not) in paths to get, set and delete to multiple items in\r\n   one call,\r\n-  Both have iterators (in the common baseclass) to run through all\r\n   paths and values in a data structure.\r\n\r\nAs an typical example we take the JSON response of a call to\r\n``maps.googleapis.com`` for the route between 2 addresses. The response\r\nis over 390 lines of JSON if nicely formatted. However we will only be\r\ninterested in the geo\\_locations of the individual steps (turn-by-turn\r\ninstructions) of the route.\r\n\r\nIn normal code this would look something like (with ``json_route`` the\r\nresult from the call to the google API):\r\n\r\n.. code:: python\r\n\r\n    def get_geo_locations(json_route):\r\n        geo_locs = []\r\n        for json_step in json_route[\"routes\"][0][\"legs\"][0][\"steps\"]: \r\n            geo_locs.append({\"start_location\": json_step[\"start_location\"],\r\n                             \"end_location\": json_step[\"end_location\"]})\r\n        return geo_locs\r\n\r\n    geo_locations = get_geo_locations(json_route)\r\n\r\nUsing ``WildPath`` the same result is obtained by:\r\n\r\n.. code:: python\r\n\r\n    location_path = WildPath(\"routes.0.legs.0.steps.*.*_location\")\r\n\r\n    geo_locations = location_path.get_in(json_route)  \r\n\r\nBoth produce the same list of items:\r\n\r\n.. code:: python\r\n\r\n    [\r\n        {\r\n            \"start_location\": {\r\n                \"lat\": 52.0800134,\r\n                \"lng\": 4.3271703\r\n            },\r\n            \"end_location\": {\r\n                \"lat\": 52.0805958,\r\n                \"lng\": 4.3286669\r\n            }\r\n        }, \r\n        ...  # etc.\r\n    ]\r\n\r\nEssentially the function definition is replaced by a string, using\r\n``WildPath.get_in`` for the correct lookup logic. This has some\r\nadvantages:\r\n\r\n-  Less lines of code means lower likelyhood of bugs,\r\n-  Better readability and maintainablity (once you get used to the\r\n   path-notation),\r\n-  A ``Path`` or ``WildPath`` is easily serializable\r\n   (``str(Path(\"a.b.c\")) == \"a.b.c\"``), where a function definition is\r\n   not.\r\n\r\nPrerequisites\r\n-------------\r\n\r\nThe module can be installed with ``pip install wildpath``. It is tested\r\nfor both python 2.7 and python 3.3 to 3.6.\r\n\r\nFunctionality\r\n-------------\r\n\r\nThe **``Path``** class supports, with e.g. ``path = Path(\"a.0.b\")`` and\r\n``obj = {\"a\": [{\"b\": 1}]}``:\r\n\r\n-  ``get_in``: getting items from data structures: ``path.get_in(obj)``,\r\n-  ``set_in``: setting values in data structures:\r\n   ``path.set_in(obj, value)``,\r\n-  ``del_in``: deleting items from data structures:\r\n   ``path.del_in(obj)``,\r\n-  ``has_in``: checking whether a value exists at path:\r\n   ``path.has_in(obj)``,\r\n-  ``pop_in``: deleting and returning items from data structures:\r\n   ``path.pop_in(obj)``.\r\n-  ``call_in``: calling the method(s) at the path-location in data\r\n   structures: ``path.call_in(obj, *args, **kwargs)``.\r\n\r\nIt also has some iterators that run through all paths and values in a\r\ndata structure:\r\n\r\n-  ``Path.items(obj)``: iterator over all ``(path, value)`` tuples in\r\n   the object,\r\n-  ``Path.paths(obj)``: iterator over all paths in the object,\r\n-  ``Path.values(obj)``: iterator over all values in the object.\r\n\r\nThe **``WildPath``** class supports the same functionality as ``Path``,\r\nwith the following additions:\r\n\r\n-  Keys referring to mappings (e.g. ``dict``) or python class objects\r\n   can contain wildcards: ``WildPath(\"*.a*.b?\")``, with ``*`` for any\r\n   string and ``?`` for any single character. Wildcards use the standard\r\n   python ``fnmatch.fnmatchcase``,\r\n-  Keys referring to sequences (e.g. ``list``, ``tuple``) can contain\r\n   slices: ``WildPath(\"1:3.::2\")``, with ``:`` from standard python\r\n   slice notation ``some_list[start:stop:step]``,\r\n-  All keys can contain boolean logic, using ``&`` for AND, ``|`` for OR\r\n   and ``!`` for NOT: ``WildPath(\"a*&!*b\")``: keys starting with ``'a'``\r\n   and not ending with ``'b'``. This is also valid for slice keys\r\n   ``WildPath(\"2:4|6:8\")``: indices 2, 3, 6, 7.\r\n\r\nE.g. WildPath.get\\_in returns simplified data-structures, skipping\r\nnon-wildcard/slice keys, so:\r\n``python WildPath(\"a.*.x\").get_in({\"a\": {\"u\": {\"x\":1}, \"v\": {\"x\": 2}}}) == {\"u\": 1, \"v\": 2}``\r\ntakes the value at key \"a\", iterates over keys \"u\" and \"v\" and takes the\r\nvalue at key \"x\".\r\n\r\nNote that:\r\n\r\n-  The iterator methods of ``WildPath`` return paths of type\r\n   ``WildPath``, instead of ``Path``,\r\n-  If a key or index or attribute is not found in the data, a\r\n   ``KeyError``, ``IndexError`` or ``AttributeError`` reesp. will be\r\n   raised,\r\n-  ``get_in`` can take a ``default`` parameter, that is returned if no\r\n   value exists at the path location: ``path.get_in(obj, None)``,\r\n-  ``WildPath.get_in`` can take a ``flat`` parameter, turning the\r\n   resulting data structure into a flat list:\r\n   ``path.get_in(obj, flat=True)``,\r\n-  ``WildPath.get_in`` will return instances of dict, list or a normal\r\n   value.\r\n\r\nExamples\r\n--------\r\n\r\nStarting with this example structure of an agenda item in some tool:\r\n\r\n.. code:: python\r\n\r\n    agenda = {\r\n        \"meeting\": \"progress on project X\",\r\n        \"date\": \"2017-8-14\",\r\n        \"start_time\": \"10:00\",\r\n        \"end_time\": \"11:00\",\r\n        \"invited\": [\"Joe\", \"Ann\", \"Boo\"],\r\n        \"items\": [\r\n            {\r\n                \"name\": \"opening\",\r\n                \"duration\": \"5 minutes\",\r\n                \"subjects\": [\"purpose of the meeting\"],\r\n            },\r\n            {\r\n                \"name\": \"progress\",\r\n                \"duration\": \"25 minutes\",\r\n                \"subjects\": [\"milestones\", \"project delays\", \"actions\"],\r\n            },\r\n            {\r\n                \"name\": \"closing\",\r\n                \"duration\": \"5 minutes\",\r\n                \"subjects\": [\"questions\", \"roundup\"],\r\n            },\r\n        ]\r\n    }\r\n\r\nclass ``Path``\r\n~~~~~~~~~~~~~~\r\n\r\nThe 'Path' class let you get, set or delete items at a specific\r\nlocation:\r\n\r\n.. code:: python\r\n\r\n    from wildpath.paths import Path\r\n\r\n    path = Path(\"items.0.duration\")\r\n    assert str(path) == \"items.0.duration\"  # str(..) returns the original path string\r\n\r\n    duration = path.get_in(agenda)  # retrieves value at path location\r\n    assert duration == \"5 minutes\"\r\n\r\n    path.set_in(agenda, \"10 minutes\")  # sets value at path location\r\n    assert path.get_in(agenda) == \"10 minutes\"\r\n\r\n    path.del_in(agenda)  # deletes key-value at path loation\r\n    assert path.has_in(agenda) == False  # has_in checks the presence of a value at the path location\r\n\r\nclass ``WildPath``\r\n~~~~~~~~~~~~~~~~~~\r\n\r\n``WildPath`` supports the same API as ``Path``, but additionally lets\r\nyou use wildcards and slicing in the path definition to access multiple\r\nitems in the structure (the ``Path`` class is there because for single\r\nlookups it is substantially faster):\r\n\r\n.. code:: python\r\n\r\n    from wildpath.paths import WildPath\r\n\r\n    wildpath = WildPath(\"items.*.duration\")  # basic 'star' notation\r\n\r\n    durations = wildpath.get_in(agenda)  # retrieves all the durations of the items on the agenda\r\n    assert durations == [\"5 minutes\", \"25 minutes\", \"5 minutes\"]\r\n\r\n    wildpath.set_in(agenda, [\"10 minutes\", \"50 minutes\", \"10 minutes\"])  # setting all the values, \r\n    assert wildpath.get_in(agenda) == [\"10 minutes\", \"50 minutes\", \"10 minutes\"]\r\n\r\n    wildpath.set_in(agenda, \"30 minutes\")  #  or replacing all with a single value, \r\n    assert wildpath.get_in(agenda) == [\"30 minutes\", \"30 minutes\", \"30 minutes\"]\r\n\r\n    wildpath.del_in(agenda)  # delete all the items at wildpath from the structure\r\n    assert wildpath.has_in(agenda) == False  # `has_in` checks if all the items at wildpath are there\r\n\r\nTo get the start and end time of the meeting:\r\n\r\n.. code:: python\r\n\r\n    wildpath = WildPath(\"*_time\")\r\n    assert wildpath.get_in(agenda) == {\"start_time\": \"10:00\", \"end_time\": \"11:00\"}\r\n\r\nSimilarly it supports slices as wildcard like path-elements\r\n\r\n.. code:: python\r\n\r\n    wildpath = WildPath(\"items.0:2.name\")\r\n    assert wildpath.get_in(agenda) == [\"opening\", \"progress\"]\r\n\r\n    wildpath = WildPath(\"items.!0:2.name\")  # slices can be negated\r\n    assert wildpath.get_in(agenda) == [ \"closing\"]\r\n\r\n    wildpath = WildPath(\"items.-1::-1.name\")  # extended slicing also works, but orders are not reversed for a negative step parameter\r\n    assert wildpath.get_in(agenda) == [\"opening\", \"progress\", \"closing\"]\r\n\r\nWildPath supports a boolean logic:\r\n\r\n.. code:: python\r\n\r\n    # '|' is the OR operator\r\n\r\n    assert WildPath(\"start_time|end_time\").get_in(agenda) == {\"start_time\": \"10:00\", \"end_time\": \"11:00\"}\r\n\r\n    # '&' is the AND operator\r\n\r\n    assert WildPath(\"start_*&*_time\").get_in(agenda) == {\"start_time\": \"10:00\"}\r\n\r\n\r\n    # '!' is the NOT operator:\r\n\r\n    assert WildPath(\"!item?\").get_in({\"item1\": \"chair\", \"item2\": \"table\", \"count\": 2}) == {\"count\": 2}\r\n\r\n    # parentheses can be used to indicate precedence:\r\n\r\n    assert WildPath(\"!(a|b)\") != WildPath(\"!a|b\")\r\n\r\n**Notes**:\r\n\r\n-  WildPath also supports attribute lookup in nested objects, list\r\n   attributes in objects, etc.,\r\n-  All the examples of ``WildPath.get_in`` also work for ``set_in``,\r\n   ``del_in``, ``pop_in`` and ``has_in``,\r\n-  In ``wildpath.set_in(obj, value)``, value can either be a single\r\n   value (which will be used to set all target values), or a data\r\n   structure with the same 'shape' as the result of\r\n   ``wildpath.get_in(obj)``.\r\n\r\nIterators\r\n~~~~~~~~~\r\n\r\nThe Path classes also have some iterator classmethods defined:\r\n\r\n.. code:: python\r\n\r\n    from wildpath.paths import Path\r\n\r\n    for path, value in Path.items(agenda):\r\n        print(\" \".join([str(path), \":\", value]))\r\n\r\nprints\r\n\r\n.. code:: text\r\n\r\n    date : 2017-8-14\r\n    end_time : 11:00\r\n    invited.0 : Joe\r\n    invited.1 : Ann\r\n    invited.2 : Boo\r\n    items.0.duration : 5 minutes\r\n    items.0.name : opening\r\n    items.0.subjects.0 : purpose of the meeting\r\n    items.1.duration : 25 minutes\r\n    items.1.name : progress\r\n\r\n    etc...\r\n\r\nTo create an alternative representation of the datastructure:\r\n\r\n.. code:: python\r\n\r\n    D = {str(path): value for path, value in Path.items(agenda)}\r\n\r\nPath.items() has an optional argument ``all`` that if set to ``True``\r\nwill iterate over all path, value combination, including intermediary\r\npaths:\r\n\r\n.. code:: python\r\n\r\n    from wildpath.paths import Path\r\n\r\n    for path, value in Path.items(agenda, all=True):\r\n        print(\" \".join([str(path), \":\", value]))\r\n\r\nwill print:\r\n\r\n.. code:: text\r\n\r\n    date : 2017-8-14\r\n    end_time : 11:00\r\n    invited : ['Joe', 'Ann', 'Boo']\r\n    invited.0 : Joe\r\n    invited.1 : Ann\r\n    invited.2 : Boo\r\n    items : [{'duration': '5 minutes', 'subjects': ['purpose of the meeting'], ...]\r\n    items.0 : {'duration': '5 minutes', 'subjects': ['purpose of the meeting'], 'name': 'opening'}\r\n    items.0.duration : 5 minutes\r\n    items.0.name : opening\r\n    items.0.subjects : ['purpose of the meeting']\r\n    items.0.subjects.0 : purpose of the meeting\r\n\r\n    etc...\r\n\r\nWith the ``Path.items(obj, all=True)`` and the ordering the items are\r\nproduced, more manipulations are possible, e.g.:\r\n\r\n.. code:: python\r\n\r\n    from datetime import datetime\r\n    from wildpath.paths import Path\r\n\r\n    sample = {\r\n        \"name\": \"sample\",\r\n        \"times\": [datetime(1999,1,2,3), datetime(1999,1,2,4)]\r\n    }\r\n\r\n    new_sample = {}\r\n    for path, value in Path.items(sample, all=True):\r\n        if isinstance(value, datetime):\r\n            value = str(value)  # all values of type datetime are converted to strings\r\n        path.set_in(new_sample, value)\r\n\r\n    # new_sample is now serializable to JSON\r\n\r\n**Notes**:\r\n\r\n-  Currently these iterators cannot handle circular relationships. This\r\n   will result in a RuntimeError (recursion depth) ,\r\n-  To iterate over attributes in objects, callables and attributes\r\n   starting en ending with \"\\_\\_\" are excluded,\r\n-  The iterators return generators, not lists or dicts. To do this, use\r\n   ``list(Path.items(obj))``, ``dict(Path.items(obj))``,\r\n-  These iterators can also be useful the get an alternative view on a\r\n   datastructure: a starting point to define WildPaths,\r\n-  To turn the items into a ``dict`` with string keys, use\r\n   ``dct = {str(p): v for p, v in Path.items(obj)}``.\r\n\r\nPath manipulations\r\n~~~~~~~~~~~~~~~~~~\r\n\r\n``Path`` and ``WildPath`` are subclasses of tuple (via BasePath), so\r\n(almost) all tuple methods can be used with both, e.g.:\r\n\r\n.. code:: python\r\n\r\n    from wildpath.paths import Path\r\n\r\n    assert Path(\"a.b\") + Path(\"c\") == Path(\"a.b.c\")\r\n    assert Path(\"a.b.c\")[1:] == Path(\"b.c\")\r\n    assert repr(Path(\"a.b.c\")) == \"('a', 'b', 'c')\"\r\n\r\n    # however, tuple.__str__ is overridden to return the input string for the class constructor for easy (de)serialization:\r\n\r\n    assert str(Path(\"a.b.c\")) == \"a.b.c\"\r\n\r\nNote that some methods (like ``__add__`` and ``path[1:]``) are\r\noverridden to return the correct class (Path or WildPath)\r\n\r\nLimitations\r\n-----------\r\n\r\nBecause of the characters used to parse the paths, some keys in the\r\ntarget datastructures will cause the system to fail:\r\n\r\n-  for ``Path`` and ``WildPath``: keys in Mappings (e.g. dict,\r\n   OrderedDict) cannot contain a ``.``,\r\n-  for ``WildPath``: keys in Mappings cannot contain the characters\r\n   ``*``, ``?``, ``!``, ``|`` and ``&``, or to be precise, if they are\r\n   present, they cannot be used in wildpaths for lookups,\r\n-  note that the ``.`` separator can easily be replaced in a subclass,\r\n   allowing paths like ``\"a/b/3/x\"`` instead of ``\"a.b.3.x\"`` (and\r\n   therefore path ``\"a/b.c/3/x\"`` with ``b.c`` a dictionary key):\r\n\r\n.. code:: python\r\n\r\n    from wildpath.paths import Path, WildPath\r\n\r\n    class SlashPath(Path):\r\n        sep = '/'\r\n\r\n    class WildSlashPath(WildPath):\r\n        sep = '/'\r\n\r\nOverriding ``!``, ``|`` and ``&`` will take a little more work: override\r\nclass-attribute ``tokens`` in ``WildPath`` and override\r\n``KeyParser.DEFAULT_TOKENS``. Currently there is no way to override\r\ntokens ``*`` and ``?`` in ``WildPath``.\r\n\r\nTesting\r\n-------\r\n\r\nThe unittests are standard python unittests and can be run as such.\r\n\r\nAuthors\r\n-------\r\n\r\nLars van Gemerden (rational-it) - initial code and documentation.\r\n\r\nLicense\r\n-------\r\n\r\nThis project is usable under the MIT License in LICENSE.txt.\r\n\r\nAcknowledgments\r\n---------------\r\n\r\n-  A big thanks to Jasper Hartong for convincing me to open-source this\r\n   module,\r\n-  To the creators of the module ``boolean.py``, thanks for making\r\n   boolean parsing a lot easier.\r\n\r\n\r\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "access data structure getter setter deleter iterator utility tool path wildcard slice", "license": "MIT License", "maintainer": "", "maintainer_email": "", "name": "wildpath", "package_url": "https://pypi.org/project/wildpath/", "platform": "", "project_url": "https://pypi.org/project/wildpath/", "project_urls": null, "release_url": "https://pypi.org/project/wildpath/0.2.7/", "requires_dist": ["boolean.py"], "requires_python": "", "summary": "easy data structure access utility", "version": "0.2.7", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div>\n<img alt=\"Travis\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/89ad99cf86c23ef836301706ce7b8638ae2262ae/68747470733a2f2f7472617669732d63692e6f72672f67656d657264656e2f77696c64706174682e7376673f6272616e63683d6d6173746572\">\n<p>Travis</p>\n</div>\n<div id=\"wildpath\">\n<h2>WildPath</h2>\n<p>A path abstraction to access items in composite (e.g. JSON) objects in\npython.</p>\n<div id=\"introduction\">\n<h3>Introduction</h3>\n<p>This module is intended primarily as a practical tool to access data in\ncomplex data structures. Especially accessing multiple items usually\nrequires for-loops or other constructs and there is no straightforward\nway to pass nested locations as single parameters. This module solves\nthis problem by introdicing 2 classes:</p>\n<ul>\n<li><tt>Path</tt> allows to get, set and delete single items in the data\nstructure; it is optimized for speed,</li>\n<li><tt>WildPath</tt> does the same and allows wildcards and boolean logic\n(and, or, not) in paths to get, set and delete to multiple items in\none call,</li>\n<li>Both have iterators (in the common baseclass) to run through all\npaths and values in a data structure.</li>\n</ul>\n<p>As an typical example we take the JSON response of a call to\n<tt>maps.googleapis.com</tt> for the route between 2 addresses. The response\nis over 390 lines of JSON if nicely formatted. However we will only be\ninterested in the geo_locations of the individual steps (turn-by-turn\ninstructions) of the route.</p>\n<p>In normal code this would look something like (with <tt>json_route</tt> the\nresult from the call to the google API):</p>\n<pre><span class=\"k\">def</span> <span class=\"nf\">get_geo_locations</span><span class=\"p\">(</span><span class=\"n\">json_route</span><span class=\"p\">):</span>\n    <span class=\"n\">geo_locs</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">json_step</span> <span class=\"ow\">in</span> <span class=\"n\">json_route</span><span class=\"p\">[</span><span class=\"s2\">\"routes\"</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"s2\">\"legs\"</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"s2\">\"steps\"</span><span class=\"p\">]:</span>\n        <span class=\"n\">geo_locs</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">({</span><span class=\"s2\">\"start_location\"</span><span class=\"p\">:</span> <span class=\"n\">json_step</span><span class=\"p\">[</span><span class=\"s2\">\"start_location\"</span><span class=\"p\">],</span>\n                         <span class=\"s2\">\"end_location\"</span><span class=\"p\">:</span> <span class=\"n\">json_step</span><span class=\"p\">[</span><span class=\"s2\">\"end_location\"</span><span class=\"p\">]})</span>\n    <span class=\"k\">return</span> <span class=\"n\">geo_locs</span>\n\n<span class=\"n\">geo_locations</span> <span class=\"o\">=</span> <span class=\"n\">get_geo_locations</span><span class=\"p\">(</span><span class=\"n\">json_route</span><span class=\"p\">)</span>\n</pre>\n<p>Using <tt>WildPath</tt> the same result is obtained by:</p>\n<pre><span class=\"n\">location_path</span> <span class=\"o\">=</span> <span class=\"n\">WildPath</span><span class=\"p\">(</span><span class=\"s2\">\"routes.0.legs.0.steps.*.*_location\"</span><span class=\"p\">)</span>\n\n<span class=\"n\">geo_locations</span> <span class=\"o\">=</span> <span class=\"n\">location_path</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">(</span><span class=\"n\">json_route</span><span class=\"p\">)</span>\n</pre>\n<p>Both produce the same list of items:</p>\n<pre><span class=\"p\">[</span>\n    <span class=\"p\">{</span>\n        <span class=\"s2\">\"start_location\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s2\">\"lat\"</span><span class=\"p\">:</span> <span class=\"mf\">52.0800134</span><span class=\"p\">,</span>\n            <span class=\"s2\">\"lng\"</span><span class=\"p\">:</span> <span class=\"mf\">4.3271703</span>\n        <span class=\"p\">},</span>\n        <span class=\"s2\">\"end_location\"</span><span class=\"p\">:</span> <span class=\"p\">{</span>\n            <span class=\"s2\">\"lat\"</span><span class=\"p\">:</span> <span class=\"mf\">52.0805958</span><span class=\"p\">,</span>\n            <span class=\"s2\">\"lng\"</span><span class=\"p\">:</span> <span class=\"mf\">4.3286669</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n    <span class=\"o\">...</span>  <span class=\"c1\"># etc.</span>\n<span class=\"p\">]</span>\n</pre>\n<p>Essentially the function definition is replaced by a string, using\n<tt>WildPath.get_in</tt> for the correct lookup logic. This has some\nadvantages:</p>\n<ul>\n<li>Less lines of code means lower likelyhood of bugs,</li>\n<li>Better readability and maintainablity (once you get used to the\npath-notation),</li>\n<li>A <tt>Path</tt> or <tt>WildPath</tt> is easily serializable\n(<tt><span class=\"pre\">str(Path(\"a.b.c\"))</span> == \"a.b.c\"</tt>), where a function definition is\nnot.</li>\n</ul>\n</div>\n<div id=\"prerequisites\">\n<h3>Prerequisites</h3>\n<p>The module can be installed with <tt>pip install wildpath</tt>. It is tested\nfor both python 2.7 and python 3.3 to 3.6.</p>\n</div>\n<div id=\"functionality\">\n<h3>Functionality</h3>\n<p>The <strong>``Path``</strong> class supports, with e.g. <tt>path = <span class=\"pre\">Path(\"a.0.b\")</span></tt> and\n<tt>obj = {\"a\": <span class=\"pre\">[{\"b\":</span> <span class=\"pre\">1}]}</span></tt>:</p>\n<ul>\n<li><tt>get_in</tt>: getting items from data structures: <tt>path.get_in(obj)</tt>,</li>\n<li><tt>set_in</tt>: setting values in data structures:\n<tt>path.set_in(obj, value)</tt>,</li>\n<li><tt>del_in</tt>: deleting items from data structures:\n<tt>path.del_in(obj)</tt>,</li>\n<li><tt>has_in</tt>: checking whether a value exists at path:\n<tt>path.has_in(obj)</tt>,</li>\n<li><tt>pop_in</tt>: deleting and returning items from data structures:\n<tt>path.pop_in(obj)</tt>.</li>\n<li><tt>call_in</tt>: calling the method(s) at the path-location in data\nstructures: <tt>path.call_in(obj, *args, **kwargs)</tt>.</li>\n</ul>\n<p>It also has some iterators that run through all paths and values in a\ndata structure:</p>\n<ul>\n<li><tt>Path.items(obj)</tt>: iterator over all <tt>(path, value)</tt> tuples in\nthe object,</li>\n<li><tt>Path.paths(obj)</tt>: iterator over all paths in the object,</li>\n<li><tt>Path.values(obj)</tt>: iterator over all values in the object.</li>\n</ul>\n<p>The <strong>``WildPath``</strong> class supports the same functionality as <tt>Path</tt>,\nwith the following additions:</p>\n<ul>\n<li>Keys referring to mappings (e.g. <tt>dict</tt>) or python class objects\ncan contain wildcards: <tt><span class=\"pre\">WildPath(\"*.a*.b?\")</span></tt>, with <tt>*</tt> for any\nstring and <tt>?</tt> for any single character. Wildcards use the standard\npython <tt>fnmatch.fnmatchcase</tt>,</li>\n<li>Keys referring to sequences (e.g. <tt>list</tt>, <tt>tuple</tt>) can contain\nslices: <tt><span class=\"pre\">WildPath(\"1:3.::2\")</span></tt>, with <tt>:</tt> from standard python\nslice notation <tt>some_list[start:stop:step]</tt>,</li>\n<li>All keys can contain boolean logic, using <tt>&amp;</tt> for AND, <tt>|</tt> for OR\nand <tt>!</tt> for NOT: <tt><span class=\"pre\">WildPath(\"a*&amp;!*b\")</span></tt>: keys starting with <tt>'a'</tt>\nand not ending with <tt>'b'</tt>. This is also valid for slice keys\n<tt><span class=\"pre\">WildPath(\"2:4|6:8\")</span></tt>: indices 2, 3, 6, 7.</li>\n</ul>\n<p>E.g. WildPath.get_in returns simplified data-structures, skipping\nnon-wildcard/slice keys, so:\n<tt>python <span class=\"pre\">WildPath(\"a.*.x\").get_in({\"a\":</span> {\"u\": <span class=\"pre\">{\"x\":1},</span> \"v\": {\"x\": <span class=\"pre\">2}}})</span> == {\"u\": 1, \"v\": 2}</tt>\ntakes the value at key \u201ca\u201d, iterates over keys \u201cu\u201d and \u201cv\u201d and takes the\nvalue at key \u201cx\u201d.</p>\n<p>Note that:</p>\n<ul>\n<li>The iterator methods of <tt>WildPath</tt> return paths of type\n<tt>WildPath</tt>, instead of <tt>Path</tt>,</li>\n<li>If a key or index or attribute is not found in the data, a\n<tt>KeyError</tt>, <tt>IndexError</tt> or <tt>AttributeError</tt> reesp. will be\nraised,</li>\n<li><tt>get_in</tt> can take a <tt>default</tt> parameter, that is returned if no\nvalue exists at the path location: <tt>path.get_in(obj, None)</tt>,</li>\n<li><tt>WildPath.get_in</tt> can take a <tt>flat</tt> parameter, turning the\nresulting data structure into a flat list:\n<tt>path.get_in(obj, flat=True)</tt>,</li>\n<li><tt>WildPath.get_in</tt> will return instances of dict, list or a normal\nvalue.</li>\n</ul>\n</div>\n<div id=\"examples\">\n<h3>Examples</h3>\n<p>Starting with this example structure of an agenda item in some tool:</p>\n<pre><span class=\"n\">agenda</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"meeting\"</span><span class=\"p\">:</span> <span class=\"s2\">\"progress on project X\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"date\"</span><span class=\"p\">:</span> <span class=\"s2\">\"2017-8-14\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"start_time\"</span><span class=\"p\">:</span> <span class=\"s2\">\"10:00\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"end_time\"</span><span class=\"p\">:</span> <span class=\"s2\">\"11:00\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"invited\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"Joe\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Ann\"</span><span class=\"p\">,</span> <span class=\"s2\">\"Boo\"</span><span class=\"p\">],</span>\n    <span class=\"s2\">\"items\"</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n        <span class=\"p\">{</span>\n            <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"opening\"</span><span class=\"p\">,</span>\n            <span class=\"s2\">\"duration\"</span><span class=\"p\">:</span> <span class=\"s2\">\"5 minutes\"</span><span class=\"p\">,</span>\n            <span class=\"s2\">\"subjects\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"purpose of the meeting\"</span><span class=\"p\">],</span>\n        <span class=\"p\">},</span>\n        <span class=\"p\">{</span>\n            <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"progress\"</span><span class=\"p\">,</span>\n            <span class=\"s2\">\"duration\"</span><span class=\"p\">:</span> <span class=\"s2\">\"25 minutes\"</span><span class=\"p\">,</span>\n            <span class=\"s2\">\"subjects\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"milestones\"</span><span class=\"p\">,</span> <span class=\"s2\">\"project delays\"</span><span class=\"p\">,</span> <span class=\"s2\">\"actions\"</span><span class=\"p\">],</span>\n        <span class=\"p\">},</span>\n        <span class=\"p\">{</span>\n            <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"closing\"</span><span class=\"p\">,</span>\n            <span class=\"s2\">\"duration\"</span><span class=\"p\">:</span> <span class=\"s2\">\"5 minutes\"</span><span class=\"p\">,</span>\n            <span class=\"s2\">\"subjects\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"questions\"</span><span class=\"p\">,</span> <span class=\"s2\">\"roundup\"</span><span class=\"p\">],</span>\n        <span class=\"p\">},</span>\n    <span class=\"p\">]</span>\n<span class=\"p\">}</span>\n</pre>\n<div id=\"class-path\">\n<h4>class <tt>Path</tt></h4>\n<p>The \u2018Path\u2019 class let you get, set or delete items at a specific\nlocation:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">wildpath.paths</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span>\n\n<span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"items.0.duration\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s2\">\"items.0.duration\"</span>  <span class=\"c1\"># str(..) returns the original path string</span>\n\n<span class=\"n\">duration</span> <span class=\"o\">=</span> <span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span>  <span class=\"c1\"># retrieves value at path location</span>\n<span class=\"k\">assert</span> <span class=\"n\">duration</span> <span class=\"o\">==</span> <span class=\"s2\">\"5 minutes\"</span>\n\n<span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">set_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">,</span> <span class=\"s2\">\"10 minutes\"</span><span class=\"p\">)</span>  <span class=\"c1\"># sets value at path location</span>\n<span class=\"k\">assert</span> <span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s2\">\"10 minutes\"</span>\n\n<span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">del_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span>  <span class=\"c1\"># deletes key-value at path loation</span>\n<span class=\"k\">assert</span> <span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">has_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>  <span class=\"c1\"># has_in checks the presence of a value at the path location</span>\n</pre>\n</div>\n<div id=\"class-wildpath\">\n<h4>class <tt>WildPath</tt></h4>\n<p><tt>WildPath</tt> supports the same API as <tt>Path</tt>, but additionally lets\nyou use wildcards and slicing in the path definition to access multiple\nitems in the structure (the <tt>Path</tt> class is there because for single\nlookups it is substantially faster):</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">wildpath.paths</span> <span class=\"kn\">import</span> <span class=\"n\">WildPath</span>\n\n<span class=\"n\">wildpath</span> <span class=\"o\">=</span> <span class=\"n\">WildPath</span><span class=\"p\">(</span><span class=\"s2\">\"items.*.duration\"</span><span class=\"p\">)</span>  <span class=\"c1\"># basic 'star' notation</span>\n\n<span class=\"n\">durations</span> <span class=\"o\">=</span> <span class=\"n\">wildpath</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span>  <span class=\"c1\"># retrieves all the durations of the items on the agenda</span>\n<span class=\"k\">assert</span> <span class=\"n\">durations</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s2\">\"5 minutes\"</span><span class=\"p\">,</span> <span class=\"s2\">\"25 minutes\"</span><span class=\"p\">,</span> <span class=\"s2\">\"5 minutes\"</span><span class=\"p\">]</span>\n\n<span class=\"n\">wildpath</span><span class=\"o\">.</span><span class=\"n\">set_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s2\">\"10 minutes\"</span><span class=\"p\">,</span> <span class=\"s2\">\"50 minutes\"</span><span class=\"p\">,</span> <span class=\"s2\">\"10 minutes\"</span><span class=\"p\">])</span>  <span class=\"c1\"># setting all the values,</span>\n<span class=\"k\">assert</span> <span class=\"n\">wildpath</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s2\">\"10 minutes\"</span><span class=\"p\">,</span> <span class=\"s2\">\"50 minutes\"</span><span class=\"p\">,</span> <span class=\"s2\">\"10 minutes\"</span><span class=\"p\">]</span>\n\n<span class=\"n\">wildpath</span><span class=\"o\">.</span><span class=\"n\">set_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">,</span> <span class=\"s2\">\"30 minutes\"</span><span class=\"p\">)</span>  <span class=\"c1\">#  or replacing all with a single value,</span>\n<span class=\"k\">assert</span> <span class=\"n\">wildpath</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s2\">\"30 minutes\"</span><span class=\"p\">,</span> <span class=\"s2\">\"30 minutes\"</span><span class=\"p\">,</span> <span class=\"s2\">\"30 minutes\"</span><span class=\"p\">]</span>\n\n<span class=\"n\">wildpath</span><span class=\"o\">.</span><span class=\"n\">del_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span>  <span class=\"c1\"># delete all the items at wildpath from the structure</span>\n<span class=\"k\">assert</span> <span class=\"n\">wildpath</span><span class=\"o\">.</span><span class=\"n\">has_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kc\">False</span>  <span class=\"c1\"># `has_in` checks if all the items at wildpath are there</span>\n</pre>\n<p>To get the start and end time of the meeting:</p>\n<pre><span class=\"n\">wildpath</span> <span class=\"o\">=</span> <span class=\"n\">WildPath</span><span class=\"p\">(</span><span class=\"s2\">\"*_time\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">wildpath</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">{</span><span class=\"s2\">\"start_time\"</span><span class=\"p\">:</span> <span class=\"s2\">\"10:00\"</span><span class=\"p\">,</span> <span class=\"s2\">\"end_time\"</span><span class=\"p\">:</span> <span class=\"s2\">\"11:00\"</span><span class=\"p\">}</span>\n</pre>\n<p>Similarly it supports slices as wildcard like path-elements</p>\n<pre><span class=\"n\">wildpath</span> <span class=\"o\">=</span> <span class=\"n\">WildPath</span><span class=\"p\">(</span><span class=\"s2\">\"items.0:2.name\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">wildpath</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s2\">\"opening\"</span><span class=\"p\">,</span> <span class=\"s2\">\"progress\"</span><span class=\"p\">]</span>\n\n<span class=\"n\">wildpath</span> <span class=\"o\">=</span> <span class=\"n\">WildPath</span><span class=\"p\">(</span><span class=\"s2\">\"items.!0:2.name\"</span><span class=\"p\">)</span>  <span class=\"c1\"># slices can be negated</span>\n<span class=\"k\">assert</span> <span class=\"n\">wildpath</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span> <span class=\"s2\">\"closing\"</span><span class=\"p\">]</span>\n\n<span class=\"n\">wildpath</span> <span class=\"o\">=</span> <span class=\"n\">WildPath</span><span class=\"p\">(</span><span class=\"s2\">\"items.-1::-1.name\"</span><span class=\"p\">)</span>  <span class=\"c1\"># extended slicing also works, but orders are not reversed for a negative step parameter</span>\n<span class=\"k\">assert</span> <span class=\"n\">wildpath</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"s2\">\"opening\"</span><span class=\"p\">,</span> <span class=\"s2\">\"progress\"</span><span class=\"p\">,</span> <span class=\"s2\">\"closing\"</span><span class=\"p\">]</span>\n</pre>\n<p>WildPath supports a boolean logic:</p>\n<pre><span class=\"c1\"># '|' is the OR operator</span>\n\n<span class=\"k\">assert</span> <span class=\"n\">WildPath</span><span class=\"p\">(</span><span class=\"s2\">\"start_time|end_time\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">{</span><span class=\"s2\">\"start_time\"</span><span class=\"p\">:</span> <span class=\"s2\">\"10:00\"</span><span class=\"p\">,</span> <span class=\"s2\">\"end_time\"</span><span class=\"p\">:</span> <span class=\"s2\">\"11:00\"</span><span class=\"p\">}</span>\n\n<span class=\"c1\"># '&amp;' is the AND operator</span>\n\n<span class=\"k\">assert</span> <span class=\"n\">WildPath</span><span class=\"p\">(</span><span class=\"s2\">\"start_*&amp;*_time\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">{</span><span class=\"s2\">\"start_time\"</span><span class=\"p\">:</span> <span class=\"s2\">\"10:00\"</span><span class=\"p\">}</span>\n\n\n<span class=\"c1\"># '!' is the NOT operator:</span>\n\n<span class=\"k\">assert</span> <span class=\"n\">WildPath</span><span class=\"p\">(</span><span class=\"s2\">\"!item?\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">get_in</span><span class=\"p\">({</span><span class=\"s2\">\"item1\"</span><span class=\"p\">:</span> <span class=\"s2\">\"chair\"</span><span class=\"p\">,</span> <span class=\"s2\">\"item2\"</span><span class=\"p\">:</span> <span class=\"s2\">\"table\"</span><span class=\"p\">,</span> <span class=\"s2\">\"count\"</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">})</span> <span class=\"o\">==</span> <span class=\"p\">{</span><span class=\"s2\">\"count\"</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">}</span>\n\n<span class=\"c1\"># parentheses can be used to indicate precedence:</span>\n\n<span class=\"k\">assert</span> <span class=\"n\">WildPath</span><span class=\"p\">(</span><span class=\"s2\">\"!(a|b)\"</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"n\">WildPath</span><span class=\"p\">(</span><span class=\"s2\">\"!a|b\"</span><span class=\"p\">)</span>\n</pre>\n<p><strong>Notes</strong>:</p>\n<ul>\n<li>WildPath also supports attribute lookup in nested objects, list\nattributes in objects, etc.,</li>\n<li>All the examples of <tt>WildPath.get_in</tt> also work for <tt>set_in</tt>,\n<tt>del_in</tt>, <tt>pop_in</tt> and <tt>has_in</tt>,</li>\n<li>In <tt>wildpath.set_in(obj, value)</tt>, value can either be a single\nvalue (which will be used to set all target values), or a data\nstructure with the same \u2018shape\u2019 as the result of\n<tt>wildpath.get_in(obj)</tt>.</li>\n</ul>\n</div>\n<div id=\"iterators\">\n<h4>Iterators</h4>\n<p>The Path classes also have some iterator classmethods defined:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">wildpath.paths</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span>\n\n<span class=\"k\">for</span> <span class=\"n\">path</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">Path</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\" \"</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">([</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">),</span> <span class=\"s2\">\":\"</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">]))</span>\n</pre>\n<p>prints</p>\n<pre>date : 2017-8-14\nend_time : 11:00\ninvited.0 : Joe\ninvited.1 : Ann\ninvited.2 : Boo\nitems.0.duration : 5 minutes\nitems.0.name : opening\nitems.0.subjects.0 : purpose of the meeting\nitems.1.duration : 25 minutes\nitems.1.name : progress\n\netc...\n</pre>\n<p>To create an alternative representation of the datastructure:</p>\n<pre><span class=\"n\">D</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">):</span> <span class=\"n\">value</span> <span class=\"k\">for</span> <span class=\"n\">path</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">Path</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">)}</span>\n</pre>\n<p>Path.items() has an optional argument <tt>all</tt> that if set to <tt>True</tt>\nwill iterate over all path, value combination, including intermediary\npaths:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">wildpath.paths</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span>\n\n<span class=\"k\">for</span> <span class=\"n\">path</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">Path</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">(</span><span class=\"n\">agenda</span><span class=\"p\">,</span> <span class=\"nb\">all</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">\" \"</span><span class=\"o\">.</span><span class=\"n\">join</span><span class=\"p\">([</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">),</span> <span class=\"s2\">\":\"</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">]))</span>\n</pre>\n<p>will print:</p>\n<pre>date : 2017-8-14\nend_time : 11:00\ninvited : ['Joe', 'Ann', 'Boo']\ninvited.0 : Joe\ninvited.1 : Ann\ninvited.2 : Boo\nitems : [{'duration': '5 minutes', 'subjects': ['purpose of the meeting'], ...]\nitems.0 : {'duration': '5 minutes', 'subjects': ['purpose of the meeting'], 'name': 'opening'}\nitems.0.duration : 5 minutes\nitems.0.name : opening\nitems.0.subjects : ['purpose of the meeting']\nitems.0.subjects.0 : purpose of the meeting\n\netc...\n</pre>\n<p>With the <tt>Path.items(obj, all=True)</tt> and the ordering the items are\nproduced, more manipulations are possible, e.g.:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">datetime</span> <span class=\"kn\">import</span> <span class=\"n\">datetime</span>\n<span class=\"kn\">from</span> <span class=\"nn\">wildpath.paths</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span>\n\n<span class=\"n\">sample</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s2\">\"name\"</span><span class=\"p\">:</span> <span class=\"s2\">\"sample\"</span><span class=\"p\">,</span>\n    <span class=\"s2\">\"times\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"n\">datetime</span><span class=\"p\">(</span><span class=\"mi\">1999</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">),</span> <span class=\"n\">datetime</span><span class=\"p\">(</span><span class=\"mi\">1999</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">)]</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">new_sample</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n<span class=\"k\">for</span> <span class=\"n\">path</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">Path</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">(</span><span class=\"n\">sample</span><span class=\"p\">,</span> <span class=\"nb\">all</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">datetime</span><span class=\"p\">):</span>\n        <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>  <span class=\"c1\"># all values of type datetime are converted to strings</span>\n    <span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">set_in</span><span class=\"p\">(</span><span class=\"n\">new_sample</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># new_sample is now serializable to JSON</span>\n</pre>\n<p><strong>Notes</strong>:</p>\n<ul>\n<li>Currently these iterators cannot handle circular relationships. This\nwill result in a RuntimeError (recursion depth) ,</li>\n<li>To iterate over attributes in objects, callables and attributes\nstarting en ending with \u201c__\u201d are excluded,</li>\n<li>The iterators return generators, not lists or dicts. To do this, use\n<tt>list(Path.items(obj))</tt>, <tt>dict(Path.items(obj))</tt>,</li>\n<li>These iterators can also be useful the get an alternative view on a\ndatastructure: a starting point to define WildPaths,</li>\n<li>To turn the items into a <tt>dict</tt> with string keys, use\n<tt>dct = {str(p): v for p, v in Path.items(obj)}</tt>.</li>\n</ul>\n</div>\n<div id=\"path-manipulations\">\n<h4>Path manipulations</h4>\n<p><tt>Path</tt> and <tt>WildPath</tt> are subclasses of tuple (via BasePath), so\n(almost) all tuple methods can be used with both, e.g.:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">wildpath.paths</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span>\n\n<span class=\"k\">assert</span> <span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"a.b\"</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"c\"</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"a.b.c\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"a.b.c\"</span><span class=\"p\">)[</span><span class=\"mi\">1</span><span class=\"p\">:]</span> <span class=\"o\">==</span> <span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"b.c\"</span><span class=\"p\">)</span>\n<span class=\"k\">assert</span> <span class=\"nb\">repr</span><span class=\"p\">(</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"a.b.c\"</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"s2\">\"('a', 'b', 'c')\"</span>\n\n<span class=\"c1\"># however, tuple.__str__ is overridden to return the input string for the class constructor for easy (de)serialization:</span>\n\n<span class=\"k\">assert</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">Path</span><span class=\"p\">(</span><span class=\"s2\">\"a.b.c\"</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"s2\">\"a.b.c\"</span>\n</pre>\n<p>Note that some methods (like <tt>__add__</tt> and <tt>path[1:]</tt>) are\noverridden to return the correct class (Path or WildPath)</p>\n</div>\n</div>\n<div id=\"limitations\">\n<h3>Limitations</h3>\n<p>Because of the characters used to parse the paths, some keys in the\ntarget datastructures will cause the system to fail:</p>\n<ul>\n<li>for <tt>Path</tt> and <tt>WildPath</tt>: keys in Mappings (e.g. dict,\nOrderedDict) cannot contain a <tt>.</tt>,</li>\n<li>for <tt>WildPath</tt>: keys in Mappings cannot contain the characters\n<tt>*</tt>, <tt>?</tt>, <tt>!</tt>, <tt>|</tt> and <tt>&amp;</tt>, or to be precise, if they are\npresent, they cannot be used in wildpaths for lookups,</li>\n<li>note that the <tt>.</tt> separator can easily be replaced in a subclass,\nallowing paths like <tt>\"a/b/3/x\"</tt> instead of <tt>\"a.b.3.x\"</tt> (and\ntherefore path <tt>\"a/b.c/3/x\"</tt> with <tt>b.c</tt> a dictionary key):</li>\n</ul>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">wildpath.paths</span> <span class=\"kn\">import</span> <span class=\"n\">Path</span><span class=\"p\">,</span> <span class=\"n\">WildPath</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">SlashPath</span><span class=\"p\">(</span><span class=\"n\">Path</span><span class=\"p\">):</span>\n    <span class=\"n\">sep</span> <span class=\"o\">=</span> <span class=\"s1\">'/'</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">WildSlashPath</span><span class=\"p\">(</span><span class=\"n\">WildPath</span><span class=\"p\">):</span>\n    <span class=\"n\">sep</span> <span class=\"o\">=</span> <span class=\"s1\">'/'</span>\n</pre>\n<p>Overriding <tt>!</tt>, <tt>|</tt> and <tt>&amp;</tt> will take a little more work: override\nclass-attribute <tt>tokens</tt> in <tt>WildPath</tt> and override\n<tt>KeyParser.DEFAULT_TOKENS</tt>. Currently there is no way to override\ntokens <tt>*</tt> and <tt>?</tt> in <tt>WildPath</tt>.</p>\n</div>\n<div id=\"testing\">\n<h3>Testing</h3>\n<p>The unittests are standard python unittests and can be run as such.</p>\n</div>\n<div id=\"authors\">\n<h3>Authors</h3>\n<p>Lars van Gemerden (rational-it) - initial code and documentation.</p>\n</div>\n<div id=\"license\">\n<h3>License</h3>\n<p>This project is usable under the MIT License in LICENSE.txt.</p>\n</div>\n<div id=\"acknowledgments\">\n<h3>Acknowledgments</h3>\n<ul>\n<li>A big thanks to Jasper Hartong for convincing me to open-source this\nmodule,</li>\n<li>To the creators of the module <tt>boolean.py</tt>, thanks for making\nboolean parsing a lot easier.</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 4054765, "releases": {"0.1.3": [{"comment_text": "", "digests": {"md5": "552e66ab9e6e0600247c2d7e584d0a25", "sha256": "761ce1ae2d559c4a8eb2fd4846f0e6eb4671404ac3dc08414581077244e098d7"}, "downloads": -1, "filename": "wildpath-0.1.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "552e66ab9e6e0600247c2d7e584d0a25", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 24026, "upload_time": "2017-07-22T10:25:25", "upload_time_iso_8601": "2017-07-22T10:25:25.852192Z", "url": "https://files.pythonhosted.org/packages/11/9a/775c67e24b4b888694fd2020259fd05bb8c3f994b45799e5047da9a11ab7/wildpath-0.1.3-py2.py3-none-any.whl", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "64bec04fea86fa9849dcfb77812704a0", "sha256": "f5265239c823bcb928806a1b86059629c2f73640ac3fddaed489ee11224aeab7"}, "downloads": -1, "filename": "wildpath-0.1.4-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "64bec04fea86fa9849dcfb77812704a0", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 24484, "upload_time": "2017-07-23T07:48:50", "upload_time_iso_8601": "2017-07-23T07:48:50.519021Z", "url": "https://files.pythonhosted.org/packages/07/78/a75121e1a57b6e49754a727478491403006596148d088eaee45ca88d8e15/wildpath-0.1.4-py2.py3-none-any.whl", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "e57db8bbb04470682aa358057ff6b8d0", "sha256": "a7f0833d18b15145eafe56fd0c3f532c7fe3c92e0eb18b8c5699806e549da16b"}, "downloads": -1, "filename": "wildpath-0.1.5-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "e57db8bbb04470682aa358057ff6b8d0", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 24426, "upload_time": "2017-07-23T07:59:53", "upload_time_iso_8601": "2017-07-23T07:59:53.846825Z", "url": "https://files.pythonhosted.org/packages/0c/d4/516665caa724c907aa18fb2b00a25607ee7805d2b141d73eaf55b26117f3/wildpath-0.1.5-py2.py3-none-any.whl", "yanked": false}], "0.1.6": [{"comment_text": "", "digests": {"md5": "63c81c24df253caae5391a5f99e5cb35", "sha256": "da57542d06217be361e3c2750b93d0c748d54402e94cf82e22f7e5194d6bbbe7"}, "downloads": -1, "filename": "wildpath-0.1.6-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "63c81c24df253caae5391a5f99e5cb35", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 24438, "upload_time": "2017-07-23T08:13:35", "upload_time_iso_8601": "2017-07-23T08:13:35.079598Z", "url": "https://files.pythonhosted.org/packages/e7/d6/37d2a8c61eca7fedcb15bc4c1028e291d348fe1e373a0d317168b36ade76/wildpath-0.1.6-py2.py3-none-any.whl", "yanked": false}], "0.1.7": [{"comment_text": "", "digests": {"md5": "12e47e89a021a1ffe17bab74c0d97445", "sha256": "175e67acc747884a211aa6802fd1e3deea698c736a58bdcabc9cf2498f9ca429"}, "downloads": -1, "filename": "wildpath-0.1.7-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "12e47e89a021a1ffe17bab74c0d97445", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 24471, "upload_time": "2017-07-24T07:55:50", "upload_time_iso_8601": "2017-07-24T07:55:50.192969Z", "url": "https://files.pythonhosted.org/packages/cb/90/46bb7f73f741180c30b26b4abba134d717787df277b8b956cc9a30c06da1/wildpath-0.1.7-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "31d5ea789cd56a1ab9c47721cc646368", "sha256": "294c1897d8ac93773bf7111376c02409864fc711c2e858a50e2fb72267188829"}, "downloads": -1, "filename": "wildpath-0.1.7.zip", "has_sig": false, "md5_digest": "31d5ea789cd56a1ab9c47721cc646368", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18115, "upload_time": "2017-07-24T07:55:51", "upload_time_iso_8601": "2017-07-24T07:55:51.496552Z", "url": "https://files.pythonhosted.org/packages/2d/e5/c321dabfef999a0ca4f0ba66dde8d7845fa15adcce3f7b4b04797b070276/wildpath-0.1.7.zip", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "a8f65972db8001374ec47075bb44e6b7", "sha256": "b827689648a5b22ee35c46f4a6f6978cbbb4e90fe70965e9d4c6594aa2021539"}, "downloads": -1, "filename": "wildpath-0.2.0-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a8f65972db8001374ec47075bb44e6b7", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 24539, "upload_time": "2017-08-14T13:39:26", "upload_time_iso_8601": "2017-08-14T13:39:26.923875Z", "url": "https://files.pythonhosted.org/packages/88/db/b72ecccdcfcdf4af5d35dc254b0cee04e66eefd14b4e13af61ada909d4ca/wildpath-0.2.0-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "3d8830cade003799813f5cb4ba2501bd", "sha256": "344d40a44ed914fcc0280393eadf79d714c29a16e98e027187d601b479c56dc0"}, "downloads": -1, "filename": "wildpath-0.2.0.zip", "has_sig": false, "md5_digest": "3d8830cade003799813f5cb4ba2501bd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 18148, "upload_time": "2017-08-14T13:39:28", "upload_time_iso_8601": "2017-08-14T13:39:28.283869Z", "url": "https://files.pythonhosted.org/packages/3c/ba/cf894a819fc3904e0dbe7a2d4d048307a7d947f1f7ed8ff4f7e9e4707c8a/wildpath-0.2.0.zip", "yanked": false}], "0.2.1": [{"comment_text": "", "digests": {"md5": "002fb769b2fdd77c3d21f6eb46a54336", "sha256": "5b8fafe0e19928d46b9e8bb4dafce62eb51b690f6c9c4e267d0045d7b5742483"}, "downloads": -1, "filename": "wildpath-0.2.1-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "002fb769b2fdd77c3d21f6eb46a54336", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 25787, "upload_time": "2017-09-02T15:19:40", "upload_time_iso_8601": "2017-09-02T15:19:40.555021Z", "url": "https://files.pythonhosted.org/packages/f1/a4/19879aefbbde1ea3871c566dd6db47d5628e66eb6ee262acaf5345cbcb24/wildpath-0.2.1-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "0d2da6f3c3ef9d3b1d2da365b7a7e112", "sha256": "9149075d92e16f4bf72dca83ddd8fa037ef249b11feda7b3c8caede08009c1a4"}, "downloads": -1, "filename": "wildpath-0.2.1.zip", "has_sig": false, "md5_digest": "0d2da6f3c3ef9d3b1d2da365b7a7e112", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19397, "upload_time": "2017-09-02T15:19:42", "upload_time_iso_8601": "2017-09-02T15:19:42.090128Z", "url": "https://files.pythonhosted.org/packages/57/f0/c21da163d055c39ed1b03b0d7a761353f5fcffb640bb2babc557521f9935/wildpath-0.2.1.zip", "yanked": false}], "0.2.2": [{"comment_text": "", "digests": {"md5": "aeae499ed505d61687173b67db908ab0", "sha256": "d7dd345846f1ce7e8a55b78081a43eed1f88a3108b5e997db95162f3eb6991d8"}, "downloads": -1, "filename": "wildpath-0.2.2-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "aeae499ed505d61687173b67db908ab0", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 25865, "upload_time": "2017-10-14T16:13:38", "upload_time_iso_8601": "2017-10-14T16:13:38.100113Z", "url": "https://files.pythonhosted.org/packages/ce/23/904be06c594cc52b71e4c4dcd3eb90af870ecb489b9d7ad8894c2cf73d86/wildpath-0.2.2-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "8d0df7f229c4e70df2b45d894170f91f", "sha256": "deab070dd6c9dcb499af1f44e66ae46c4cd2077dfa3720932bf726f962a3dfd6"}, "downloads": -1, "filename": "wildpath-0.2.2.zip", "has_sig": false, "md5_digest": "8d0df7f229c4e70df2b45d894170f91f", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19485, "upload_time": "2017-10-14T16:13:39", "upload_time_iso_8601": "2017-10-14T16:13:39.396408Z", "url": "https://files.pythonhosted.org/packages/7d/0f/53d4df949597a0f3224765990b85e2d12b9d32267a33481d9d783a1ec76f/wildpath-0.2.2.zip", "yanked": false}], "0.2.3": [{"comment_text": "", "digests": {"md5": "c8e61613d968f0f6bcfa7a1cf7558a4a", "sha256": "a2418f534fd51ee65e52d23885164b99f0dcb08da84de585d21f1403fb35f0f6"}, "downloads": -1, "filename": "wildpath-0.2.3-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "c8e61613d968f0f6bcfa7a1cf7558a4a", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 25882, "upload_time": "2017-10-18T12:19:05", "upload_time_iso_8601": "2017-10-18T12:19:05.371398Z", "url": "https://files.pythonhosted.org/packages/86/5e/fbdcb3c8e1b26aaa663b23e8a4fef915510fb4e3215058a540583012f0da/wildpath-0.2.3-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "26480d2d2247905bd3bd2a50db8d1a4c", "sha256": "191fb33d00d1e99e50b3f297eef587aedb01aba7fa80655dbabc636f72c26fd1"}, "downloads": -1, "filename": "wildpath-0.2.3.zip", "has_sig": false, "md5_digest": "26480d2d2247905bd3bd2a50db8d1a4c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19500, "upload_time": "2017-10-18T12:19:06", "upload_time_iso_8601": "2017-10-18T12:19:06.805024Z", "url": "https://files.pythonhosted.org/packages/eb/02/d98037ae683250e036cf21c9e9c4f28a5eddc5492fa6b330aeff8d7b4e47/wildpath-0.2.3.zip", "yanked": false}], "0.2.4": [{"comment_text": "", "digests": {"md5": "d94d164ff8a9580b472eecff9d9eae23", "sha256": "a9ddb57ed5f4b7c2fb834bc1f62032c3d3ef4518133d9abfb8e13762535c8148"}, "downloads": -1, "filename": "wildpath-0.2.4-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "d94d164ff8a9580b472eecff9d9eae23", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 25881, "upload_time": "2017-11-30T17:25:17", "upload_time_iso_8601": "2017-11-30T17:25:17.754511Z", "url": "https://files.pythonhosted.org/packages/dd/85/65955a36950aaac007699df2ec429851d90536c64e8b420bf2f9638ea372/wildpath-0.2.4-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "1c9a588cae2e7bb57a104fbb0e9230e7", "sha256": "5c98c49fda7de0115673a3fe0a34b216cff1a47cd671c87988eba4b7e768062e"}, "downloads": -1, "filename": "wildpath-0.2.4.zip", "has_sig": false, "md5_digest": "1c9a588cae2e7bb57a104fbb0e9230e7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19501, "upload_time": "2017-11-30T17:25:18", "upload_time_iso_8601": "2017-11-30T17:25:18.978273Z", "url": "https://files.pythonhosted.org/packages/15/e4/2183ccbf014bca1c2cab6b48f632a5b4decf942f3ccf169371c8f42f0502/wildpath-0.2.4.zip", "yanked": false}], "0.2.5": [{"comment_text": "", "digests": {"md5": "87151e697d8c5d148161e3db9eac4940", "sha256": "36dbb6033ad1a18eac13108c2ad38407ea731abc631bdcb1f6bd18e2846c0430"}, "downloads": -1, "filename": "wildpath-0.2.5-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "87151e697d8c5d148161e3db9eac4940", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 26005, "upload_time": "2018-07-05T08:14:02", "upload_time_iso_8601": "2018-07-05T08:14:02.938793Z", "url": "https://files.pythonhosted.org/packages/c0/93/f53160c2560f40f3463c282a88dc0789c899e125abb7b4da3322033e0d2d/wildpath-0.2.5-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "6636c3e997c81fa5795f9410333cac80", "sha256": "3906988705aa8730cf731395fe46ff2ba73a341ddd1b996d8629b2d1fed45767"}, "downloads": -1, "filename": "wildpath-0.2.5.zip", "has_sig": false, "md5_digest": "6636c3e997c81fa5795f9410333cac80", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19630, "upload_time": "2018-07-05T08:14:05", "upload_time_iso_8601": "2018-07-05T08:14:05.023668Z", "url": "https://files.pythonhosted.org/packages/b3/c0/7977ec7a611f5816d1ff4acbb52a35a32c1b8b47ff01b14fd5dd8f199d6c/wildpath-0.2.5.zip", "yanked": false}], "0.2.6": [{"comment_text": "", "digests": {"md5": "a93440341a93a874f7a065c3e6a26c64", "sha256": "dffefbb2988395433e5c0e0995bebb4cea593b4814cca3fbc5dda6e5278f3451"}, "downloads": -1, "filename": "wildpath-0.2.6-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "a93440341a93a874f7a065c3e6a26c64", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 25928, "upload_time": "2018-07-05T11:04:38", "upload_time_iso_8601": "2018-07-05T11:04:38.424688Z", "url": "https://files.pythonhosted.org/packages/74/da/7c0f5111688702a92a8e9b755394d1c11fb16e4fc04994e4a5a114489d23/wildpath-0.2.6-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "01b8e015f23422e7d78940add139007c", "sha256": "fb60d468481f9dd5ff2e32108a7ec2005e772e8faea79cc79cc5c852d2760959"}, "downloads": -1, "filename": "wildpath-0.2.6.zip", "has_sig": false, "md5_digest": "01b8e015f23422e7d78940add139007c", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19552, "upload_time": "2018-07-05T11:04:39", "upload_time_iso_8601": "2018-07-05T11:04:39.687125Z", "url": "https://files.pythonhosted.org/packages/e8/20/d8494037bbefd2fb6134d45d80b6ab2bc654f9d005bd4fac3e951c7d7a12/wildpath-0.2.6.zip", "yanked": false}], "0.2.7": [{"comment_text": "", "digests": {"md5": "4fa599e505e3ba188723fc92b010bfdf", "sha256": "8fb9d4cd095332599bafe258b3589e6a3a0c2f0de79a8a1a5acf53188d20452d"}, "downloads": -1, "filename": "wildpath-0.2.7-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "4fa599e505e3ba188723fc92b010bfdf", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 26110, "upload_time": "2018-07-12T14:50:27", "upload_time_iso_8601": "2018-07-12T14:50:27.282065Z", "url": "https://files.pythonhosted.org/packages/a8/ad/2493d32b103bb63582be46f88b74a33c820e3e64513150f2c822c644ecaf/wildpath-0.2.7-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a2c477189f94d1a1e0d6ecdcfe5d4c91", "sha256": "d4929d6aefc648b63b3247f63c3479c7fd57216650546b93419101e637724978"}, "downloads": -1, "filename": "wildpath-0.2.7.zip", "has_sig": false, "md5_digest": "a2c477189f94d1a1e0d6ecdcfe5d4c91", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19735, "upload_time": "2018-07-12T14:50:30", "upload_time_iso_8601": "2018-07-12T14:50:30.989981Z", "url": "https://files.pythonhosted.org/packages/b5/67/349c4ebc492e3274fc4f1603f46175251120de61d469069b8962c33b7600/wildpath-0.2.7.zip", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "4fa599e505e3ba188723fc92b010bfdf", "sha256": "8fb9d4cd095332599bafe258b3589e6a3a0c2f0de79a8a1a5acf53188d20452d"}, "downloads": -1, "filename": "wildpath-0.2.7-py2.py3-none-any.whl", "has_sig": false, "md5_digest": "4fa599e505e3ba188723fc92b010bfdf", "packagetype": "bdist_wheel", "python_version": "py2.py3", "requires_python": null, "size": 26110, "upload_time": "2018-07-12T14:50:27", "upload_time_iso_8601": "2018-07-12T14:50:27.282065Z", "url": "https://files.pythonhosted.org/packages/a8/ad/2493d32b103bb63582be46f88b74a33c820e3e64513150f2c822c644ecaf/wildpath-0.2.7-py2.py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "a2c477189f94d1a1e0d6ecdcfe5d4c91", "sha256": "d4929d6aefc648b63b3247f63c3479c7fd57216650546b93419101e637724978"}, "downloads": -1, "filename": "wildpath-0.2.7.zip", "has_sig": false, "md5_digest": "a2c477189f94d1a1e0d6ecdcfe5d4c91", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19735, "upload_time": "2018-07-12T14:50:30", "upload_time_iso_8601": "2018-07-12T14:50:30.989981Z", "url": "https://files.pythonhosted.org/packages/b5/67/349c4ebc492e3274fc4f1603f46175251120de61d469069b8962c33b7600/wildpath-0.2.7.zip", "yanked": false}], "timestamp": "Fri May  8 03:29:07 2020"}