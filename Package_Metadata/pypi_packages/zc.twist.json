{"info": {"author": "Zope Project", "author_email": "zope-dev@zope.org", "bugtrack_url": null, "classifiers": [], "description": "===================================================\nTwist: Talking to the ZODB in Twisted Reactor Calls\n===================================================\n\nThe twist package contains a few functions and classes, but primarily a\nhelper for having a deferred call on a callable persistent object, or on\na method on a persistent object.  This lets you have a Twisted reactor\ncall or a Twisted deferred callback affect the ZODB.  Everything can be\ndone within the main thread, so it can be full-bore Twisted usage,\nwithout threads.  There are a few important \"gotchas\": see the Gotchas_\nsection below for details.\n\nThe main API is `Partial`.  You can pass it a callable persistent object,\na method of a persistent object, or a normal non-persistent callable,\nand any arguments or keyword arguments of the same sort.  DO NOT\nuse non-persistent data structures (such as lists) of persistent objects\nwith a database connection as arguments.  This is your responsibility.\n\nIf nothing is persistent, the partial will not bother to get a connection,\nand will behave normally.\n\n    >>> from zc.twist import Partial\n    >>> def demo():\n    ...     return 42\n    ...\n    >>> Partial(demo)()\n    42\n\nNow let's imagine a demo object that is persistent and part of a\ndatabase connection.  It has a `count` attribute that starts at 0, a\n`__call__` method that increments count by an `amount` that defaults to\n1, and an `decrement` method that reduces count by an `amount` that\ndefaults to 1 [#set_up]_.  Everything returns the current value of count.\n\n    >>> demo.count\n    0\n    >>> demo()\n    1\n    >>> demo(2)\n    3\n    >>> demo.decrement()\n    2\n    >>> demo.decrement(2)\n    0\n    >>> import transaction\n    >>> transaction.commit()\n\nNow we can make some deferred calls with these examples.  We will use\n`transaction.begin()` to sync our connection with what happened in the\ndeferred call.  Note that we need to have some adapters set up for this\nto work.  The twist module includes implementations of them that we\nwill also assume have been installed [#adapters]_.\n\n    >>> call = Partial(demo)\n    >>> demo.count # hasn't been called yet\n    0\n    >>> deferred = call()\n    >>> demo.count # we haven't synced yet\n    0\n    >>> t = transaction.begin() # sync the connection\n    >>> demo.count # ah-ha!\n    1\n\nWe can use the deferred returned from the call to do something with the\nreturn value.  In this case, the deferred is already completed, so\nadding a callback gets instant execution.\n\n    >>> def show_value(res):\n    ...     print res\n    ...\n    >>> ignore = deferred.addCallback(show_value)\n    1\n\nWe can also pass the method.\n\n    >>> call = Partial(demo.decrement)\n    >>> deferred = call()\n    >>> demo.count\n    1\n    >>> t = transaction.begin()\n    >>> demo.count\n    0\n\nThis also works for slot methods.\n\n    >>> import BTrees\n    >>> tree = root['tree'] = BTrees.family32.OO.BTree()\n    >>> transaction.commit()\n    >>> call = Partial(tree.__setitem__, 'foo', 'bar')\n    >>> deferred = call()\n    >>> len(tree)\n    0\n    >>> t = transaction.begin()\n    >>> tree['foo']\n    'bar'\n\nArguments are passed through.\n\n    >>> call = Partial(demo)\n    >>> deferred = call(2)\n    >>> t = transaction.begin()\n    >>> demo.count\n    2\n    >>> call = Partial(demo.decrement)\n    >>> deferred = call(amount=2)\n    >>> t = transaction.begin()\n    >>> demo.count\n    0\n\nThey can also be set during instantiation.\n\n    >>> call = Partial(demo, 3)\n    >>> deferred = call()\n    >>> t = transaction.begin()\n    >>> demo.count\n    3\n    >>> call = Partial(demo.decrement, amount=3)\n    >>> deferred = call()\n    >>> t = transaction.begin()\n    >>> demo.count\n    0\n\nArguments themselves can be persistent objects.  Let's assume a new demo2\nobject as well.\n\n    >>> demo2.count\n    0\n    >>> def mass_increment(d1, d2, value=1):\n    ...     d1(value)\n    ...     d2(value)\n    ...\n    >>> call = Partial(mass_increment, demo, demo2, value=4)\n    >>> deferred = call()\n    >>> t = transaction.begin()\n    >>> demo.count\n    4\n    >>> demo2.count\n    4\n    >>> demo.count = demo2.count = 0 # cleanup\n    >>> transaction.commit()\n\nConflictErrors make it retry.\n\nIn order to have a chance to simulate a ConflictError, this time imagine\nwe have a runner that can switch execution from the call to our code\nusing `pause`, `retry` and `resume` (this is just for tests--remember,\ncalls used in non-threaded Twisted should be non-blocking!)\n[#conflict_error_setup]_.\n\n    >>> import sys\n    >>> demo.count\n    0\n    >>> call = Partial(demo)\n    >>> runner = Runner(call) # it starts paused in the middle of an attempt\n    >>> call.attempt_count\n    1\n    >>> demo.count = 5 # now we will make a conflicting transaction...\n    >>> transaction.commit()\n    >>> runner.retry()\n    >>> call.attempt_count # so it has to retry\n    2\n    >>> t = transaction.begin()\n    >>> demo.count # our value hasn't changed...\n    5\n    >>> runner.resume() # but now call will be successful on the second attempt\n    >>> call.attempt_count\n    2\n    >>> t = transaction.begin()\n    >>> demo.count\n    6\n\nBy default, after five ConflictError retries, the partial fails, raising the\nlast ConflictError.  This is returned to the deferred.  The failure put\non the deferred will have a sanitized traceback.  Here, imagine we have\na deferred (named `deferred`) created from such a an event\n[#conflict_error_failure]_.\n\n    >>> res = None\n    >>> def get_result(r):\n    ...     global res\n    ...     res = r # we return None to quiet Twisted down on the command line\n    ...\n    >>> d = deferred.addErrback(get_result)\n    >>> print res.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n    ...\n    ZODB.POSException.ConflictError: database conflict error...\n\nYou can control how many ConflictError (and other transaction error) retries\nshould be performed by setting the ``max_transaction_errors`` attribute\n[#max_transaction_errors]_.\n\nZEO ClientDisconnected errors are always retried, with a backoff that, by\ndefault begins at 5 seconds and is never greater than 60 seconds\n[#relies_on_twisted_reactor]_ [#use_original_demo]_ [#client_disconnected]_.\n\nOther errors are returned to the deferred, like a transaction error that has\nexceeded its available retries, as sanitized failures.\n\n    >>> call = Partial(demo)\n    >>> d = call('I do not add well with integers')\n    >>> d = d.addErrback(get_result)\n    >>> print res.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n    ...\n    ...TypeError: unsupported operand type(s) for +=: 'int' and 'str'\n\nThe failure is sanitized in that the traceback is gone and the frame values\nare turned in to reprs.  If you pickle the failure then it truncates the\nreprs to a maximum of 20 characters plus \"[...]\" to indicate the\ntruncation [#show_sanitation]_.\n\nThe call tries to be a good connection citizen, waiting for a connection\nif the pool is at its maximum size.  This code relies on the twisted\nreactor; we'll use a `time_flies` function, which takes seconds to move\nahead, to simulate time passing in the reactor.\n\nWe use powers of 2 for the floating-points numbers (e.g. 0.125) to avoid\na floating-point additive accumulation error that happened in the tests\nwhen values such as 0.1 were used.\n\n    >>> db.setPoolSize(1)\n    >>> db.getPoolSize()\n    1\n    >>> demo.count = 0\n    >>> transaction.commit()\n    >>> call = Partial(demo)\n    >>> res = None\n    >>> deferred = call()\n    >>> d = deferred.addCallback(get_result)\n    >>> call.attempt_count\n    0\n    >>> time_flies(.125) >= 1 # returns number of connection attempts\n    True\n    >>> call.attempt_count\n    0\n    >>> res # None\n    >>> db.setPoolSize(2)\n    >>> db.getPoolSize()\n    2\n    >>> time_flies(.25) >= 1\n    True\n    >>> call.attempt_count > 0\n    True\n    >>> res\n    1\n    >>> t = transaction.begin()\n    >>> demo.count\n    1\n\nIf it takes more than a second or two, it will eventually just decide to grab\none.  This behavior may change.\n\n    >>> db.setPoolSize(1)\n    >>> db.getPoolSize()\n    1\n    >>> call = Partial(demo)\n    >>> res = None\n    >>> deferred = call()\n    >>> d = deferred.addCallback(get_result)\n    >>> call.attempt_count\n    0\n    >>> time_flies(.125) >= 1\n    True\n    >>> call.attempt_count\n    0\n    >>> res # None\n    >>> time_flies(2) >= 2 # for a total of at least 3\n    True\n    >>> res\n    2\n    >>> t = transaction.begin()\n    >>> demo.count\n    2\n\nWithout a running reactor, this functionality will not work\n[#teardown_monkeypatch]_.\n\nYou can also specify a reactor for the partial using ``setReactor``, if\nyou don't want to use the standard one installed by twisted in\n``twisted.internet.reactor``. [#setReactor]_\n\nGotchas\n-------\n\nFor a certain class of jobs, you won't have to think much about using\nthe twist Partial.  For instance, if you are putting a result gathered by\nwork done by deferreds into the ZODB, and that's it, everything should be\npretty simple.  However, unfortunately, you have to think a bit harder for\nother common use cases.\n\n* As already mentioned, do not use arguments that are non-persistent\n  collections (or even persistent objects without a connection) that hold\n  any persistent objects with connections.\n\n* Using persistent objects with connections but that have not been\n  committed to the database will cause problems when used (as callable\n  or argument), perhaps intermittently (if a commit happens before the\n  partial is called, it will work).  Don't do this.\n\n* Do not return values that are persistent objects tied to a connection.\n\n* If you plan on firing off another reactor call on the basis of your\n  work in the callable, realize that the work hasn't really \"happened\"\n  until you commit the transaction.  The partial typically handles commits\n  for you, committing if you return any result and aborting if you raise\n  an error. But if you want to send off a reactor call on the basis of a\n  successful transaction, you'll want to (a) do the work, then (b)\n  commit, then (c) send off the reactor call.  If the commit fails,\n  you'll get the standard abort and retry.\n\n* If you want to handle your own transactions, do not use the thread\n  transaction manager that you get from importing transaction.  This\n  will cause intermittent, hard-to-debug, unexpected problems.  Instead,\n  adapt any persistent object you get to\n  transaction.interfaces.ITransactionManager, and use that manager for\n  commits and aborts.\n\n=========\nFootnotes\n=========\n\n.. [#set_up] We'll actually create the state that the text describes here.\n\n    >>> import persistent\n    >>> class Demo(persistent.Persistent):\n    ...     count = 0\n    ...     def __call__(self, amount=1):\n    ...         self._p_deactivate() # to be able to trigger ClientDisconnected\n    ...         self.count += amount\n    ...         return self.count\n    ...     def decrement(self, amount=1):\n    ...         self.count -= amount\n    ...         return self.count\n    ...\n    >>> from ZODB.tests.util import DB\n    >>> db = DB()\n    >>> conn = db.open()\n    >>> root = conn.root()\n    >>> demo = root['demo'] = Demo()\n    >>> demo2 = root['demo2'] = Demo()\n    >>> import transaction\n    >>> transaction.commit()\n\n.. [#adapters] You must have two adapter registrations: IConnection to\n    ITransactionManager, and IPersistent to IConnection.  We will also\n    register IPersistent to ITransactionManager because the adapter is\n    designed for it.\n\n    >>> from zc.twist import transactionManager, connection\n    >>> import zope.component\n    >>> zope.component.provideAdapter(transactionManager)\n    >>> zope.component.provideAdapter(connection)\n    >>> import ZODB.interfaces\n    >>> zope.component.provideAdapter(\n    ...     transactionManager, adapts=(ZODB.interfaces.IConnection,))\n\n    This quickly tests the adapters:\n\n    >>> ZODB.interfaces.IConnection(demo) is conn\n    True\n    >>> import transaction.interfaces\n    >>> transaction.interfaces.ITransactionManager(demo) is transaction.manager\n    True\n    >>> transaction.interfaces.ITransactionManager(conn) is transaction.manager\n    True\n\n.. [#conflict_error_setup] We also use this runner in the footnote below.\n\n    >>> import threading\n    >>> _main = threading.Lock()\n    >>> _thread = threading.Lock()\n    >>> class AltDemo(persistent.Persistent):\n    ...     count = 0\n    ...     def __call__(self, amount=1):\n    ...         self.count += amount\n    ...         assert _main.locked()\n    ...         _main.release()\n    ...         _thread.acquire()\n    ...         return self.count\n    ...\n    >>> demo = root['altdemo'] = AltDemo()\n    >>> transaction.commit()\n    >>> class Runner(object):\n    ...     def __init__(self, call):\n    ...         self.call = call\n    ...         self.thread = threading.Thread(target=self.run)\n    ...         self.thread.setDaemon(True)\n    ...         _thread.acquire()\n    ...         _main.acquire()\n    ...         self.thread.start()\n    ...         _main.acquire()\n    ...     def run(self):\n    ...         self.running = True\n    ...         self.result = self.call()\n    ...         assert _main.locked()\n    ...         assert _thread.locked()\n    ...         _thread.release()\n    ...         self.running = False\n    ...         _main.release()\n    ...     def retry(self):\n    ...         assert _thread.locked()\n    ...         _thread.release()\n    ...         _main.acquire()\n    ...     def resume(self):\n    ...         while self.running:\n    ...             self.retry()\n    ...         self.thread.join()\n    ...         assert not _thread.locked()\n    ...         assert _main.locked()\n    ...         _main.release()\n\n.. [#conflict_error_failure] Here we create five consecutive conflict errors,\n    which causes the call to give up.\n\n    >>> call = Partial(demo)\n    >>> runner = Runner(call)\n    >>> for i in range(5):\n    ...     demo.count = i\n    ...     transaction.commit() # creates a write conflict\n    ...     runner.retry()\n    ...\n    >>> demo.count\n    4\n\n    When we resume without a conflict error, it is too late: the result is a\n    ConflictError.  The ConflictError is actually shown in the main text.\n\n    >>> runner.resume()\n    >>> demo.count\n    4\n    >>> call.attempt_count\n    5\n    >>> deferred = runner.result\n\n.. [#max_transaction_errors] As the main text mentions, the\n   ``max_transaction_errors`` attribute lets you set how many conflict errors\n   should be retried.\n\n    >>> call = Partial(demo)\n    >>> call.max_transaction_errors\n    5\n    >>> call.max_transaction_errors = 10\n    >>> call.max_transaction_errors\n    10\n    >>> runner = Runner(call)\n    >>> for i in range(10):\n    ...     demo.count = i\n    ...     transaction.commit()\n    ...     runner.retry()\n    ...\n\n   When we resume without a conflict error, it is too late: the result is a\n   ConflictError.\n\n    >>> runner.resume()\n    >>> demo.count\n    9\n    >>> call.attempt_count\n    10\n    >>> deferred = runner.result\n\n    >>> res = None\n    >>> def get_result(r):\n    ...     global res\n    ...     res = r # we return None to quiet Twisted down on the command line\n    ...\n    >>> d = deferred.addErrback(get_result)\n    >>> print res.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    Traceback (most recent call last):\n    ...\n    ZODB.POSException.ConflictError: database conflict error...\n\n   Setting ``None`` means to retry conflict errors forever.  For our example,\n   we will arbitrarily choose 50 iterations to show \"forever\".\n\n    >>> call = Partial(demo)\n    >>> call.max_transaction_errors\n    5\n    >>> call.max_transaction_errors = None\n    >>> print call.max_transaction_errors\n    None\n    >>> runner = Runner(call)\n    >>> for i in range(50):\n    ...     demo.count = i\n    ...     transaction.commit()\n    ...     runner.retry()\n    ...\n\n   Now when we resume without a conflict error, we get a successful result: it\n   never gave up.\n\n    >>> runner.resume()\n    >>> runner.result # doctest: +ELLIPSIS\n    <Deferred at ...  current result: 50>\n    >>> _ = transaction.begin() # we need to sync to get changes\n    >>> demo.count # notice, 49 + 1\n    50\n\n.. [#relies_on_twisted_reactor] We monkeypatch twisted.internet.reactor\n    (and revert it in another footnote below).\n\n    >>> import twisted.internet.reactor\n    >>> oldCallLater = twisted.internet.reactor.callLater\n    >>> import bisect\n    >>> class FauxReactor(object):\n    ...     def __init__(self):\n    ...         self.time = 0\n    ...         self.calls = []\n    ...     def callLater(self, delay, callable, *args, **kw):\n    ...         res = (delay + self.time, callable, args, kw)\n    ...         bisect.insort(self.calls, res)\n    ...         # normally we're supposed to return something but not needed\n    ...     def time_flies(self, time):\n    ...         end = self.time + time\n    ...         ct = 0\n    ...         while self.calls and self.calls[0][0] <= end:\n    ...             self.time, callable, args, kw = self.calls.pop(0)\n    ...             callable(*args, **kw) # normally this would get try...except\n    ...             ct += 1\n    ...         self.time = end\n    ...         return ct\n    ...\n    >>> faux = FauxReactor()\n    >>> twisted.internet.reactor.callLater = faux.callLater\n    >>> time_flies = faux.time_flies\n\n.. [#use_original_demo] The second demo has too much thread code in it:\n    we'll use the old demo for the rest of the discussion.\n\n    >>> demo = root['demo']\n\n.. [#client_disconnected] As the main text describes,\n   ZEO.Exceptions.ClientDisconnected errors will always be retried, but with a\n   backoff.\n\n   First we'll mimic a disconnected ZEO at the start of a transaction.\n\n    >>> from ZEO.Exceptions import ClientDisconnected\n    >>> raise_error = [1]\n    >>> storage_class = db._storage.__class__\n    >>> original_load = storage_class.load\n    >>> def load(self, oid, version):\n    ...     if raise_error:\n    ...         raise_error.pop()\n    ...         raise ClientDisconnected()\n    ...     else:\n    ...         return original_load(self, oid, version)\n    ...\n    >>> _ = transaction.begin()\n    >>> demo.count\n    0\n    >>> call = Partial(demo)\n    >>> storage_class.load = load\n\n   We rely on a reactor to implement delayed calls.  We have a fake reactor\n   called ``faux`` for these examples.  It has a list of pending calls, and\n   we can call ``time_flies`` to make time appear to pass.\n\n    >>> len(faux.calls)\n    0\n\n   When we first call the partial, it will fail, and reschedule for later.\n\n    >>> len(faux.calls)\n    0\n    >>> deferred = call()\n    >>> deferred.called\n    0\n    >>> len(faux.calls)\n    1\n\n   The rescheduling is initially for five seconds later, by default.  In this\n   first example, after the first retry, the call will succeed.\n\n    >>> faux.calls[0][0] - faux.time\n    5\n    >>> time_flies(1) # 1 second\n    0\n    >>> deferred.called\n    0\n    >>> time_flies(1) # 1 second\n    0\n    >>> deferred.called\n    0\n    >>> time_flies(1) # 1 second\n    0\n    >>> deferred.called\n    0\n    >>> time_flies(1) # 1 second\n    0\n    >>> deferred.called\n    0\n    >>> time_flies(1) # 1 second\n    1\n    >>> deferred.called\n    True\n    >>> deferred.result\n    1\n    >>> len(faux.calls)\n    0\n\n   By default, the rescheduling backoff increases by five seconds for every\n   retry, to a maximum of a 60 second backoff.\n\n    >>> call = Partial(demo)\n    >>> raise_error.extend([1] * 30)\n    >>> len(faux.calls)\n    0\n    >>> deferred = call()\n    >>> deferred.called\n    0\n    >>> len(faux.calls)\n    1\n    >>> def run(deferred):\n    ...     sleeps = []\n    ...     for i in range(31):\n    ...         if deferred.called:\n    ...             break\n    ...         else:\n    ...             sleep = faux.calls[0][0] - faux.time\n    ...             sleeps.append(sleep)\n    ...             time_flies(sleep)\n    ...     else:\n    ...         print 'oops'\n    ...     return sleeps\n    ...\n    >>> sleeps = run(deferred)\n    >>> deferred.result\n    2\n    >>> len(sleeps)\n    30\n    >>> sleeps # doctest: +ELLIPSIS\n    [5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 60, 60,..., 60, 60, 60, 60]\n\n   The default backoff values can be changed by setting the instance attributes\n   ``initial_backoff``, ``backoff_increment``, and ``max_backoff``.\n\n    >>> call = Partial(demo)\n    >>> call.initial_backoff\n    5\n    >>> call.backoff_increment\n    5\n    >>> call.max_backoff\n    60\n    >>> call.initial_backoff = 4\n    >>> call.backoff_increment = 2\n    >>> call.max_backoff = 21\n    >>> raise_error.extend([1] * 30)\n    >>> len(faux.calls)\n    0\n    >>> deferred = call()\n    >>> deferred.called\n    0\n    >>> len(faux.calls)\n    1\n    >>> sleeps = run(deferred)\n    >>> deferred.result\n    3\n    >>> len(sleeps)\n    30\n    >>> sleeps # doctest: +ELLIPSIS\n    [4, 6, 8, 10, 12, 14, 16, 18, 20, 21, 21, 21, 21, 21, 21,..., 21, 21, 21]\n\n   A ClientDisconnected error can also occur during transaction commit.\n\n    >>> storage_class.load = original_load\n\n    >>> from transaction import TransactionManager\n    >>> old_commit = TransactionManager.commit\n    >>> commit_count = 0\n    >>> error = None\n    >>> max = 2\n    >>> raise_error = [1] # change state to active\n    >>> def new_commit(self):\n    ...     if raise_error:\n    ...         raise_error.pop()\n    ...         raise ClientDisconnected()\n    ...     else:\n    ...         old_commit(self) # changing state to \"active\" or similar\n    ...\n    >>> TransactionManager.commit = new_commit\n    >>> call = Partial(demo)\n    >>> len(faux.calls)\n    0\n    >>> deferred = call()\n    >>> deferred.called\n    0\n    >>> len(faux.calls)\n    1\n\n    >>> faux.calls[0][0] - faux.time\n    5\n    >>> time_flies(4) # 4 seconds\n    0\n    >>> deferred.called\n    0\n    >>> time_flies(1) # 1 second\n    1\n    >>> deferred.called\n    True\n    >>> deferred.result\n    4\n    >>> len(faux.calls)\n    0\n\n    >>> TransactionManager.commit = old_commit\n    >>> _ = transaction.begin()\n\n.. [#show_sanitation] Before pickling, the failure includes full information\n    about before and after the exception was caught, as well as locals and\n    globals.  Everything has been repr'd, though, and the traceback object\n    removed.\n\n    >>> print res.getTraceback() # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n      File \".../zc/twist/__init__.py\", line ..., in __call__...\n      File \".../twisted/internet/defer.py\", line ..., in addCallback...\n    --- <exception caught here> ---\n      File \".../zc/twist/__init__.py\", line ..., in _call...\n      File \"<doctest README.txt[...]>\", line ..., in __call__...\n    exceptions.TypeError: unsupported operand type(s) for +=: 'int' and 'str'\n    <BLANKLINE>\n\n    (The failure traceback at \"verbose\" detail is wildly verbose--this example\n    takes out more than 90% of the text, just so you know.)\n\n    >>> print res.getTraceback(detail='verbose') # doctest: +ELLIPSIS\n    *--- Failure #... (pickled) ---\n    .../zc/twist/__init__.py:...: __call__(...)\n     [ Locals ]...\n      args : \"('I do not add well with integers',)...\n     ( Globals )...\n      Partial : \"<class 'zc.twist.Partial'>...\n    .../twisted/internet/defer.py:...: addCallback(...)\n     [ Locals ]...\n      args : '(<Deferred at ...\n     ( Globals )...\n      Deferred : '<class twisted.internet.defer.Deferred at ...\n    --- <exception caught here> ---\n    .../zc/twist/__init__.py:...: _call(...)\n     [ Locals ]...\n      args : \"['I do not add well with integers']...\n     ( Globals )...\n      Partial : \"<class 'zc.twist.Partial'>...\n    <doctest README.txt[...]>:...: __call__(...)\n     [ Locals ]...\n      amount : \"'I do not add well with integers'...\n     ( Globals )...\n      Partial : \"<class 'zc.twist.Partial'>...\n    exceptions.TypeError: unsupported operand type(s) for +=: 'int' and 'str'\n    *--- End of Failure #... ---\n    <BLANKLINE>\n\n    After pickling, the failure only includes information for when the\n    exception was caught and beyond (after the \"--- <exception caught\n    here> ---\" lines above), does not have globals, and has local reprs\n    truncated to a maximum of 20 characters plus \"[...]\" to indicate the\n    truncation. This addresses past problems of large pickle size for\n    failures, which can cause performance problems.\n\n    >>> import pickle\n    >>> print pickle.loads(pickle.dumps(res)).getTraceback()\n    ... # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n      File \".../zc/twist/__init__.py\", line ..., in _call\n        res = call(*args, **kwargs)\n      File \"<doctest README.txt[...]>\", line ..., in __call__\n        self.count += amount\n    exceptions.TypeError: unsupported operand type(s) for +=: 'int' and 'str'\n    <BLANKLINE>\n\n    >>> print pickle.loads(pickle.dumps(res)).getTraceback(detail='verbose')\n    ... # doctest: +ELLIPSIS\n    *--- Failure #... (pickled) ---\n    .../src/zc/twist/__init__.py:...: _call(...)\n     [ Locals...\n      self : '<zc.twist.Partial obj[...]...\n     ( Globals )\n    <doctest README.txt[...]>:...: __call__(...)\n     [ Locals...\n      amount : \"'I do not add well wi[...]...\n     ( Globals )\n    exceptions.TypeError: unsupported operand type(s) for +=: 'int' and 'str'\n    *--- End of Failure #... ---\n    <BLANKLINE>\n\n    In some cases, it is possible that a Failure object may include references\n    to itself, for example, indirectly through a zc.async job whose result\n    is a Failure.  Failure's __getstate__ method used to use deepcopy, which\n    in cases like this could result in infinite recursion.\n\n    >>> import zc.twist\n    >>> class Kaboom(Exception):\n    ...     pass\n    >>> class Foo(object):\n    ...     failure = None\n    ...     def fail(self):\n    ...         raise Kaboom, self\n    >>> foo = Foo()\n    >>> try:\n    ...     foo.fail()\n    ... except Kaboom:\n    ...     foo.failure = zc.twist.Failure()\n    >>> ignored = foo.failure.__getstate__() # used to cause RunTimeError.\n\n.. [#teardown_monkeypatch]\n\n    >>> twisted.internet.reactor.callLater = oldCallLater\n\n.. [#setReactor]\n\n    >>> db.setPoolSize(1)\n    >>> db.getPoolSize()\n    1\n    >>> demo.count = 0\n    >>> transaction.commit()\n    >>> call = Partial(demo).setReactor(faux)\n    >>> res = None\n    >>> deferred = call()\n    >>> d = deferred.addCallback(get_result)\n    >>> call.attempt_count\n    0\n    >>> time_flies(.125) >= 1 # returns number of connection attempts\n    True\n    >>> call.attempt_count\n    0\n    >>> res # None\n    >>> db.setPoolSize(2)\n    >>> db.getPoolSize()\n    2\n    >>> time_flies(.25) >= 1\n    True\n    >>> call.attempt_count > 0\n    True\n    >>> res\n    1\n    >>> t = transaction.begin()\n    >>> demo.count\n    1\n\nIf it takes more than a second or two, it will eventually just decide to grab\none.  This behavior may change.\n\n    >>> db.setPoolSize(1)\n    >>> db.getPoolSize()\n    1\n    >>> call = Partial(demo).setReactor(faux)\n    >>> res = None\n    >>> deferred = call()\n    >>> d = deferred.addCallback(get_result)\n    >>> call.attempt_count\n    0\n    >>> time_flies(.125) >= 1\n    True\n    >>> call.attempt_count\n    0\n    >>> res # None\n    >>> time_flies(2) >= 2 # for a total of at least 3\n    True\n    >>> res\n    2\n    >>> t = transaction.begin()\n    >>> demo.count\n    2\n\n\n=======\nChanges\n=======\n\n1.3.1 (2009-11-15)\n------------------\n\n* Added missing import of twisted.python.failure.\n\n* Use db.pool with ZODB >= 3.9 and db._pools with ZODB < 3.9.\n  The tests now pass with ZODB 3.9.\n\n* Tests pass in Python 2.6.\n\n1.3 (2008-06-19)\n----------------\n\n* Handle ZEO.Exceptions.ClientDisconnected errors: retry forever, with a\n  backoff, defaulting to a max backoff of 60 seconds.\n\n* Make number of times that ConflictErrors are retried configurable.\n\n1.2 (2008-04-09)\n----------------\n\n* New subclass of twisted.python.failure.Failure begins with only reprs,\n  and it pickles to exclude the stack, exclude the global vars in the frames,\n  and truncate the reprs of the local vars in the frames.  The goal is to\n  keep the pickle size of Failures down to a manageable size.  ``sanitize``\n  now uses this class.\n\n1.1 (2008-03-27)\n----------------\n\n* Now depends on twisted 8.0.1 or higher, which is newly setuptools\n  compatible.  The twisted build is a little frightening, at least with\n  Py2.4, with multiple warnings and errors, but works.  The dependency\n  change is the reason for the bump to 1.1; this release has no new\n  features.\n\n* setup.py uses os.path\n\n* C extension uses older comment style and has less cruft.\n\n1.0.1 (2008-03-14)\n------------------\n\n* Bugfix: if you passed a slot method like a BTree.__setitem__, bad things\n  would happen.\n\n1.0.0 (2008-03-13)\n------------------\n\n* Add ability to specify an alternate reactor\n\n* Use bootstrap external\n\n0.1.1 (?)\n---------\n\n* use zc.twisted, not twisted in setup.py, until twisted is setuptools-friendly\n\n0.1 (?)\n-------\n\n* Initial release-ish", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://pypi.python.org/pypi/zc.twist", "keywords": null, "license": "ZPL", "maintainer": null, "maintainer_email": null, "name": "zc.twist", "package_url": "https://pypi.org/project/zc.twist/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/zc.twist/", "project_urls": {"Download": "UNKNOWN", "Homepage": "http://pypi.python.org/pypi/zc.twist"}, "release_url": "https://pypi.org/project/zc.twist/1.3.1/", "requires_dist": null, "requires_python": null, "summary": "Mixing Twisted and ZODB", "version": "1.3.1", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"twist-talking-to-the-zodb-in-twisted-reactor-calls\">\n<h2>Twist: Talking to the ZODB in Twisted Reactor Calls</h2>\n<p>The twist package contains a few functions and classes, but primarily a\nhelper for having a deferred call on a callable persistent object, or on\na method on a persistent object.  This lets you have a Twisted reactor\ncall or a Twisted deferred callback affect the ZODB.  Everything can be\ndone within the main thread, so it can be full-bore Twisted usage,\nwithout threads.  There are a few important \u201cgotchas\u201d: see the <a href=\"#gotchas\" rel=\"nofollow\">Gotchas</a>\nsection below for details.</p>\n<p>The main API is <cite>Partial</cite>.  You can pass it a callable persistent object,\na method of a persistent object, or a normal non-persistent callable,\nand any arguments or keyword arguments of the same sort.  DO NOT\nuse non-persistent data structures (such as lists) of persistent objects\nwith a database connection as arguments.  This is your responsibility.</p>\n<p>If nothing is persistent, the partial will not bother to get a connection,\nand will behave normally.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; from zc.twist import Partial\n&gt;&gt;&gt; def demo():\n...     return 42\n...\n&gt;&gt;&gt; Partial(demo)()\n42\n</pre>\n</blockquote>\n<p>Now let\u2019s imagine a demo object that is persistent and part of a\ndatabase connection.  It has a <cite>count</cite> attribute that starts at 0, a\n<cite>__call__</cite> method that increments count by an <cite>amount</cite> that defaults to\n1, and an <cite>decrement</cite> method that reduces count by an <cite>amount</cite> that\ndefaults to 1 <a href=\"#set-up\" id=\"id1\" rel=\"nofollow\">[1]</a>.  Everything returns the current value of count.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; demo.count\n0\n&gt;&gt;&gt; demo()\n1\n&gt;&gt;&gt; demo(2)\n3\n&gt;&gt;&gt; demo.decrement()\n2\n&gt;&gt;&gt; demo.decrement(2)\n0\n&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>Now we can make some deferred calls with these examples.  We will use\n<cite>transaction.begin()</cite> to sync our connection with what happened in the\ndeferred call.  Note that we need to have some adapters set up for this\nto work.  The twist module includes implementations of them that we\nwill also assume have been installed <a href=\"#adapters\" id=\"id2\" rel=\"nofollow\">[2]</a>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; demo.count # hasn't been called yet\n0\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; demo.count # we haven't synced yet\n0\n&gt;&gt;&gt; t = transaction.begin() # sync the connection\n&gt;&gt;&gt; demo.count # ah-ha!\n1\n</pre>\n</blockquote>\n<p>We can use the deferred returned from the call to do something with the\nreturn value.  In this case, the deferred is already completed, so\nadding a callback gets instant execution.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; def show_value(res):\n...     print res\n...\n&gt;&gt;&gt; ignore = deferred.addCallback(show_value)\n1\n</pre>\n</blockquote>\n<p>We can also pass the method.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; call = Partial(demo.decrement)\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; demo.count\n1\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; demo.count\n0\n</pre>\n</blockquote>\n<p>This also works for slot methods.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import BTrees\n&gt;&gt;&gt; tree = root['tree'] = BTrees.family32.OO.BTree()\n&gt;&gt;&gt; transaction.commit()\n&gt;&gt;&gt; call = Partial(tree.__setitem__, 'foo', 'bar')\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; len(tree)\n0\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; tree['foo']\n'bar'\n</pre>\n</blockquote>\n<p>Arguments are passed through.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; deferred = call(2)\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; demo.count\n2\n&gt;&gt;&gt; call = Partial(demo.decrement)\n&gt;&gt;&gt; deferred = call(amount=2)\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; demo.count\n0\n</pre>\n</blockquote>\n<p>They can also be set during instantiation.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; call = Partial(demo, 3)\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; demo.count\n3\n&gt;&gt;&gt; call = Partial(demo.decrement, amount=3)\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; demo.count\n0\n</pre>\n</blockquote>\n<p>Arguments themselves can be persistent objects.  Let\u2019s assume a new demo2\nobject as well.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; demo2.count\n0\n&gt;&gt;&gt; def mass_increment(d1, d2, value=1):\n...     d1(value)\n...     d2(value)\n...\n&gt;&gt;&gt; call = Partial(mass_increment, demo, demo2, value=4)\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; demo.count\n4\n&gt;&gt;&gt; demo2.count\n4\n&gt;&gt;&gt; demo.count = demo2.count = 0 # cleanup\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</blockquote>\n<p>ConflictErrors make it retry.</p>\n<p>In order to have a chance to simulate a ConflictError, this time imagine\nwe have a runner that can switch execution from the call to our code\nusing <cite>pause</cite>, <cite>retry</cite> and <cite>resume</cite> (this is just for tests\u2013remember,\ncalls used in non-threaded Twisted should be non-blocking!)\n<a href=\"#conflict-error-setup\" id=\"id3\" rel=\"nofollow\">[3]</a>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; demo.count\n0\n&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; runner = Runner(call) # it starts paused in the middle of an attempt\n&gt;&gt;&gt; call.attempt_count\n1\n&gt;&gt;&gt; demo.count = 5 # now we will make a conflicting transaction...\n&gt;&gt;&gt; transaction.commit()\n&gt;&gt;&gt; runner.retry()\n&gt;&gt;&gt; call.attempt_count # so it has to retry\n2\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; demo.count # our value hasn't changed...\n5\n&gt;&gt;&gt; runner.resume() # but now call will be successful on the second attempt\n&gt;&gt;&gt; call.attempt_count\n2\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; demo.count\n6\n</pre>\n</blockquote>\n<p>By default, after five ConflictError retries, the partial fails, raising the\nlast ConflictError.  This is returned to the deferred.  The failure put\non the deferred will have a sanitized traceback.  Here, imagine we have\na deferred (named <cite>deferred</cite>) created from such a an event\n<a href=\"#conflict-error-failure\" id=\"id4\" rel=\"nofollow\">[4]</a>.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; res = None\n&gt;&gt;&gt; def get_result(r):\n...     global res\n...     res = r # we return None to quiet Twisted down on the command line\n...\n&gt;&gt;&gt; d = deferred.addErrback(get_result)\n&gt;&gt;&gt; print res.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n...\nZODB.POSException.ConflictError: database conflict error...\n</pre>\n</blockquote>\n<p>You can control how many ConflictError (and other transaction error) retries\nshould be performed by setting the <tt>max_transaction_errors</tt> attribute\n<a href=\"#max-transaction-errors\" id=\"id5\" rel=\"nofollow\">[5]</a>.</p>\n<p>ZEO ClientDisconnected errors are always retried, with a backoff that, by\ndefault begins at 5 seconds and is never greater than 60 seconds\n<a href=\"#relies-on-twisted-reactor\" id=\"id6\" rel=\"nofollow\">[6]</a> <a href=\"#use-original-demo\" id=\"id7\" rel=\"nofollow\">[7]</a> <a href=\"#client-disconnected\" id=\"id8\" rel=\"nofollow\">[8]</a>.</p>\n<p>Other errors are returned to the deferred, like a transaction error that has\nexceeded its available retries, as sanitized failures.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; d = call('I do not add well with integers')\n&gt;&gt;&gt; d = d.addErrback(get_result)\n&gt;&gt;&gt; print res.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n...\n...TypeError: unsupported operand type(s) for +=: 'int' and 'str'\n</pre>\n</blockquote>\n<p>The failure is sanitized in that the traceback is gone and the frame values\nare turned in to reprs.  If you pickle the failure then it truncates the\nreprs to a maximum of 20 characters plus \u201c[\u2026]\u201d to indicate the\ntruncation <a href=\"#show-sanitation\" id=\"id9\" rel=\"nofollow\">[9]</a>.</p>\n<p>The call tries to be a good connection citizen, waiting for a connection\nif the pool is at its maximum size.  This code relies on the twisted\nreactor; we\u2019ll use a <cite>time_flies</cite> function, which takes seconds to move\nahead, to simulate time passing in the reactor.</p>\n<p>We use powers of 2 for the floating-points numbers (e.g. 0.125) to avoid\na floating-point additive accumulation error that happened in the tests\nwhen values such as 0.1 were used.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; db.setPoolSize(1)\n&gt;&gt;&gt; db.getPoolSize()\n1\n&gt;&gt;&gt; demo.count = 0\n&gt;&gt;&gt; transaction.commit()\n&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; res = None\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; d = deferred.addCallback(get_result)\n&gt;&gt;&gt; call.attempt_count\n0\n&gt;&gt;&gt; time_flies(.125) &gt;= 1 # returns number of connection attempts\nTrue\n&gt;&gt;&gt; call.attempt_count\n0\n&gt;&gt;&gt; res # None\n&gt;&gt;&gt; db.setPoolSize(2)\n&gt;&gt;&gt; db.getPoolSize()\n2\n&gt;&gt;&gt; time_flies(.25) &gt;= 1\nTrue\n&gt;&gt;&gt; call.attempt_count &gt; 0\nTrue\n&gt;&gt;&gt; res\n1\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; demo.count\n1\n</pre>\n</blockquote>\n<p>If it takes more than a second or two, it will eventually just decide to grab\none.  This behavior may change.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; db.setPoolSize(1)\n&gt;&gt;&gt; db.getPoolSize()\n1\n&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; res = None\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; d = deferred.addCallback(get_result)\n&gt;&gt;&gt; call.attempt_count\n0\n&gt;&gt;&gt; time_flies(.125) &gt;= 1\nTrue\n&gt;&gt;&gt; call.attempt_count\n0\n&gt;&gt;&gt; res # None\n&gt;&gt;&gt; time_flies(2) &gt;= 2 # for a total of at least 3\nTrue\n&gt;&gt;&gt; res\n2\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; demo.count\n2\n</pre>\n</blockquote>\n<p>Without a running reactor, this functionality will not work\n<a href=\"#teardown-monkeypatch\" id=\"id10\" rel=\"nofollow\">[10]</a>.</p>\n<p>You can also specify a reactor for the partial using <tt>setReactor</tt>, if\nyou don\u2019t want to use the standard one installed by twisted in\n<tt>twisted.internet.reactor</tt>. <a href=\"#setreactor\" id=\"id11\" rel=\"nofollow\">[11]</a></p>\n<div id=\"gotchas\">\n<h3>Gotchas</h3>\n<p>For a certain class of jobs, you won\u2019t have to think much about using\nthe twist Partial.  For instance, if you are putting a result gathered by\nwork done by deferreds into the ZODB, and that\u2019s it, everything should be\npretty simple.  However, unfortunately, you have to think a bit harder for\nother common use cases.</p>\n<ul>\n<li>As already mentioned, do not use arguments that are non-persistent\ncollections (or even persistent objects without a connection) that hold\nany persistent objects with connections.</li>\n<li>Using persistent objects with connections but that have not been\ncommitted to the database will cause problems when used (as callable\nor argument), perhaps intermittently (if a commit happens before the\npartial is called, it will work).  Don\u2019t do this.</li>\n<li>Do not return values that are persistent objects tied to a connection.</li>\n<li>If you plan on firing off another reactor call on the basis of your\nwork in the callable, realize that the work hasn\u2019t really \u201chappened\u201d\nuntil you commit the transaction.  The partial typically handles commits\nfor you, committing if you return any result and aborting if you raise\nan error. But if you want to send off a reactor call on the basis of a\nsuccessful transaction, you\u2019ll want to (a) do the work, then (b)\ncommit, then (c) send off the reactor call.  If the commit fails,\nyou\u2019ll get the standard abort and retry.</li>\n<li>If you want to handle your own transactions, do not use the thread\ntransaction manager that you get from importing transaction.  This\nwill cause intermittent, hard-to-debug, unexpected problems.  Instead,\nadapt any persistent object you get to\ntransaction.interfaces.ITransactionManager, and use that manager for\ncommits and aborts.</li>\n</ul>\n</div>\n</div>\n<div id=\"footnotes\">\n<h2>Footnotes</h2>\n<table id=\"set-up\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id1\" rel=\"nofollow\">[1]</a></td><td><p>We\u2019ll actually create the state that the text describes here.</p>\n<pre>\n&gt;&gt;&gt; import persistent\n&gt;&gt;&gt; class Demo(persistent.Persistent):\n...     count = 0\n...     def __call__(self, amount=1):\n...         self._p_deactivate() # to be able to trigger ClientDisconnected\n...         self.count += amount\n...         return self.count\n...     def decrement(self, amount=1):\n...         self.count -= amount\n...         return self.count\n...\n&gt;&gt;&gt; from ZODB.tests.util import DB\n&gt;&gt;&gt; db = DB()\n&gt;&gt;&gt; conn = db.open()\n&gt;&gt;&gt; root = conn.root()\n&gt;&gt;&gt; demo = root['demo'] = Demo()\n&gt;&gt;&gt; demo2 = root['demo2'] = Demo()\n&gt;&gt;&gt; import transaction\n&gt;&gt;&gt; transaction.commit()\n</pre>\n</td></tr>\n</tbody>\n</table>\n<table id=\"adapters\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id2\" rel=\"nofollow\">[2]</a></td><td><p>You must have two adapter registrations: IConnection to\nITransactionManager, and IPersistent to IConnection.  We will also\nregister IPersistent to ITransactionManager because the adapter is\ndesigned for it.</p>\n<pre>\n&gt;&gt;&gt; from zc.twist import transactionManager, connection\n&gt;&gt;&gt; import zope.component\n&gt;&gt;&gt; zope.component.provideAdapter(transactionManager)\n&gt;&gt;&gt; zope.component.provideAdapter(connection)\n&gt;&gt;&gt; import ZODB.interfaces\n&gt;&gt;&gt; zope.component.provideAdapter(\n...     transactionManager, adapts=(ZODB.interfaces.IConnection,))\n</pre>\n<p>This quickly tests the adapters:</p>\n<pre>\n&gt;&gt;&gt; ZODB.interfaces.IConnection(demo) is conn\nTrue\n&gt;&gt;&gt; import transaction.interfaces\n&gt;&gt;&gt; transaction.interfaces.ITransactionManager(demo) is transaction.manager\nTrue\n&gt;&gt;&gt; transaction.interfaces.ITransactionManager(conn) is transaction.manager\nTrue\n</pre>\n</td></tr>\n</tbody>\n</table>\n<table id=\"conflict-error-setup\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id3\" rel=\"nofollow\">[3]</a></td><td><p>We also use this runner in the footnote below.</p>\n<pre>\n&gt;&gt;&gt; import threading\n&gt;&gt;&gt; _main = threading.Lock()\n&gt;&gt;&gt; _thread = threading.Lock()\n&gt;&gt;&gt; class AltDemo(persistent.Persistent):\n...     count = 0\n...     def __call__(self, amount=1):\n...         self.count += amount\n...         assert _main.locked()\n...         _main.release()\n...         _thread.acquire()\n...         return self.count\n...\n&gt;&gt;&gt; demo = root['altdemo'] = AltDemo()\n&gt;&gt;&gt; transaction.commit()\n&gt;&gt;&gt; class Runner(object):\n...     def __init__(self, call):\n...         self.call = call\n...         self.thread = threading.Thread(target=self.run)\n...         self.thread.setDaemon(True)\n...         _thread.acquire()\n...         _main.acquire()\n...         self.thread.start()\n...         _main.acquire()\n...     def run(self):\n...         self.running = True\n...         self.result = self.call()\n...         assert _main.locked()\n...         assert _thread.locked()\n...         _thread.release()\n...         self.running = False\n...         _main.release()\n...     def retry(self):\n...         assert _thread.locked()\n...         _thread.release()\n...         _main.acquire()\n...     def resume(self):\n...         while self.running:\n...             self.retry()\n...         self.thread.join()\n...         assert not _thread.locked()\n...         assert _main.locked()\n...         _main.release()\n</pre>\n</td></tr>\n</tbody>\n</table>\n<table id=\"conflict-error-failure\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id4\" rel=\"nofollow\">[4]</a></td><td><p>Here we create five consecutive conflict errors,\nwhich causes the call to give up.</p>\n<pre>\n&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; runner = Runner(call)\n&gt;&gt;&gt; for i in range(5):\n...     demo.count = i\n...     transaction.commit() # creates a write conflict\n...     runner.retry()\n...\n&gt;&gt;&gt; demo.count\n4\n</pre>\n<p>When we resume without a conflict error, it is too late: the result is a\nConflictError.  The ConflictError is actually shown in the main text.</p>\n<pre>\n&gt;&gt;&gt; runner.resume()\n&gt;&gt;&gt; demo.count\n4\n&gt;&gt;&gt; call.attempt_count\n5\n&gt;&gt;&gt; deferred = runner.result\n</pre>\n</td></tr>\n</tbody>\n</table>\n<table id=\"max-transaction-errors\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id5\" rel=\"nofollow\">[5]</a></td><td><p>As the main text mentions, the\n<tt>max_transaction_errors</tt> attribute lets you set how many conflict errors\nshould be retried.</p>\n<blockquote>\n<pre>\n&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; call.max_transaction_errors\n5\n&gt;&gt;&gt; call.max_transaction_errors = 10\n&gt;&gt;&gt; call.max_transaction_errors\n10\n&gt;&gt;&gt; runner = Runner(call)\n&gt;&gt;&gt; for i in range(10):\n...     demo.count = i\n...     transaction.commit()\n...     runner.retry()\n...\n</pre>\n</blockquote>\n<p>When we resume without a conflict error, it is too late: the result is a\nConflictError.</p>\n<blockquote>\n<pre>\n&gt;&gt;&gt; runner.resume()\n&gt;&gt;&gt; demo.count\n9\n&gt;&gt;&gt; call.attempt_count\n10\n&gt;&gt;&gt; deferred = runner.result\n</pre>\n<pre>\n&gt;&gt;&gt; res = None\n&gt;&gt;&gt; def get_result(r):\n...     global res\n...     res = r # we return None to quiet Twisted down on the command line\n...\n&gt;&gt;&gt; d = deferred.addErrback(get_result)\n&gt;&gt;&gt; print res.getTraceback() # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n...\nZODB.POSException.ConflictError: database conflict error...\n</pre>\n</blockquote>\n<p>Setting <tt>None</tt> means to retry conflict errors forever.  For our example,\nwe will arbitrarily choose 50 iterations to show \u201cforever\u201d.</p>\n<blockquote>\n<pre>\n&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; call.max_transaction_errors\n5\n&gt;&gt;&gt; call.max_transaction_errors = None\n&gt;&gt;&gt; print call.max_transaction_errors\nNone\n&gt;&gt;&gt; runner = Runner(call)\n&gt;&gt;&gt; for i in range(50):\n...     demo.count = i\n...     transaction.commit()\n...     runner.retry()\n...\n</pre>\n</blockquote>\n<p>Now when we resume without a conflict error, we get a successful result: it\nnever gave up.</p>\n<blockquote>\n<pre>\n&gt;&gt;&gt; runner.resume()\n&gt;&gt;&gt; runner.result # doctest: +ELLIPSIS\n&lt;Deferred at ...  current result: 50&gt;\n&gt;&gt;&gt; _ = transaction.begin() # we need to sync to get changes\n&gt;&gt;&gt; demo.count # notice, 49 + 1\n50\n</pre>\n</blockquote>\n</td></tr>\n</tbody>\n</table>\n<table id=\"relies-on-twisted-reactor\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id6\" rel=\"nofollow\">[6]</a></td><td><p>We monkeypatch twisted.internet.reactor\n(and revert it in another footnote below).</p>\n<pre>\n&gt;&gt;&gt; import twisted.internet.reactor\n&gt;&gt;&gt; oldCallLater = twisted.internet.reactor.callLater\n&gt;&gt;&gt; import bisect\n&gt;&gt;&gt; class FauxReactor(object):\n...     def __init__(self):\n...         self.time = 0\n...         self.calls = []\n...     def callLater(self, delay, callable, *args, **kw):\n...         res = (delay + self.time, callable, args, kw)\n...         bisect.insort(self.calls, res)\n...         # normally we're supposed to return something but not needed\n...     def time_flies(self, time):\n...         end = self.time + time\n...         ct = 0\n...         while self.calls and self.calls[0][0] &lt;= end:\n...             self.time, callable, args, kw = self.calls.pop(0)\n...             callable(*args, **kw) # normally this would get try...except\n...             ct += 1\n...         self.time = end\n...         return ct\n...\n&gt;&gt;&gt; faux = FauxReactor()\n&gt;&gt;&gt; twisted.internet.reactor.callLater = faux.callLater\n&gt;&gt;&gt; time_flies = faux.time_flies\n</pre>\n</td></tr>\n</tbody>\n</table>\n<table id=\"use-original-demo\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id7\" rel=\"nofollow\">[7]</a></td><td><p>The second demo has too much thread code in it:\nwe\u2019ll use the old demo for the rest of the discussion.</p>\n<pre>\n&gt;&gt;&gt; demo = root['demo']\n</pre>\n</td></tr>\n</tbody>\n</table>\n<table id=\"client-disconnected\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id8\" rel=\"nofollow\">[8]</a></td><td><p>As the main text describes,\nZEO.Exceptions.ClientDisconnected errors will always be retried, but with a\nbackoff.</p>\n<p>First we\u2019ll mimic a disconnected ZEO at the start of a transaction.</p>\n<blockquote>\n<pre>\n&gt;&gt;&gt; from ZEO.Exceptions import ClientDisconnected\n&gt;&gt;&gt; raise_error = [1]\n&gt;&gt;&gt; storage_class = db._storage.__class__\n&gt;&gt;&gt; original_load = storage_class.load\n&gt;&gt;&gt; def load(self, oid, version):\n...     if raise_error:\n...         raise_error.pop()\n...         raise ClientDisconnected()\n...     else:\n...         return original_load(self, oid, version)\n...\n&gt;&gt;&gt; _ = transaction.begin()\n&gt;&gt;&gt; demo.count\n0\n&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; storage_class.load = load\n</pre>\n</blockquote>\n<p>We rely on a reactor to implement delayed calls.  We have a fake reactor\ncalled <tt>faux</tt> for these examples.  It has a list of pending calls, and\nwe can call <tt>time_flies</tt> to make time appear to pass.</p>\n<blockquote>\n<pre>\n&gt;&gt;&gt; len(faux.calls)\n0\n</pre>\n</blockquote>\n<p>When we first call the partial, it will fail, and reschedule for later.</p>\n<blockquote>\n<pre>\n&gt;&gt;&gt; len(faux.calls)\n0\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; deferred.called\n0\n&gt;&gt;&gt; len(faux.calls)\n1\n</pre>\n</blockquote>\n<p>The rescheduling is initially for five seconds later, by default.  In this\nfirst example, after the first retry, the call will succeed.</p>\n<blockquote>\n<pre>\n&gt;&gt;&gt; faux.calls[0][0] - faux.time\n5\n&gt;&gt;&gt; time_flies(1) # 1 second\n0\n&gt;&gt;&gt; deferred.called\n0\n&gt;&gt;&gt; time_flies(1) # 1 second\n0\n&gt;&gt;&gt; deferred.called\n0\n&gt;&gt;&gt; time_flies(1) # 1 second\n0\n&gt;&gt;&gt; deferred.called\n0\n&gt;&gt;&gt; time_flies(1) # 1 second\n0\n&gt;&gt;&gt; deferred.called\n0\n&gt;&gt;&gt; time_flies(1) # 1 second\n1\n&gt;&gt;&gt; deferred.called\nTrue\n&gt;&gt;&gt; deferred.result\n1\n&gt;&gt;&gt; len(faux.calls)\n0\n</pre>\n</blockquote>\n<p>By default, the rescheduling backoff increases by five seconds for every\nretry, to a maximum of a 60 second backoff.</p>\n<blockquote>\n<pre>\n&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; raise_error.extend([1] * 30)\n&gt;&gt;&gt; len(faux.calls)\n0\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; deferred.called\n0\n&gt;&gt;&gt; len(faux.calls)\n1\n&gt;&gt;&gt; def run(deferred):\n...     sleeps = []\n...     for i in range(31):\n...         if deferred.called:\n...             break\n...         else:\n...             sleep = faux.calls[0][0] - faux.time\n...             sleeps.append(sleep)\n...             time_flies(sleep)\n...     else:\n...         print 'oops'\n...     return sleeps\n...\n&gt;&gt;&gt; sleeps = run(deferred)\n&gt;&gt;&gt; deferred.result\n2\n&gt;&gt;&gt; len(sleeps)\n30\n&gt;&gt;&gt; sleeps # doctest: +ELLIPSIS\n[5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 60, 60,..., 60, 60, 60, 60]\n</pre>\n</blockquote>\n<p>The default backoff values can be changed by setting the instance attributes\n<tt>initial_backoff</tt>, <tt>backoff_increment</tt>, and <tt>max_backoff</tt>.</p>\n<blockquote>\n<pre>\n&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; call.initial_backoff\n5\n&gt;&gt;&gt; call.backoff_increment\n5\n&gt;&gt;&gt; call.max_backoff\n60\n&gt;&gt;&gt; call.initial_backoff = 4\n&gt;&gt;&gt; call.backoff_increment = 2\n&gt;&gt;&gt; call.max_backoff = 21\n&gt;&gt;&gt; raise_error.extend([1] * 30)\n&gt;&gt;&gt; len(faux.calls)\n0\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; deferred.called\n0\n&gt;&gt;&gt; len(faux.calls)\n1\n&gt;&gt;&gt; sleeps = run(deferred)\n&gt;&gt;&gt; deferred.result\n3\n&gt;&gt;&gt; len(sleeps)\n30\n&gt;&gt;&gt; sleeps # doctest: +ELLIPSIS\n[4, 6, 8, 10, 12, 14, 16, 18, 20, 21, 21, 21, 21, 21, 21,..., 21, 21, 21]\n</pre>\n</blockquote>\n<p>A ClientDisconnected error can also occur during transaction commit.</p>\n<blockquote>\n<pre>\n&gt;&gt;&gt; storage_class.load = original_load\n</pre>\n<pre>\n&gt;&gt;&gt; from transaction import TransactionManager\n&gt;&gt;&gt; old_commit = TransactionManager.commit\n&gt;&gt;&gt; commit_count = 0\n&gt;&gt;&gt; error = None\n&gt;&gt;&gt; max = 2\n&gt;&gt;&gt; raise_error = [1] # change state to active\n&gt;&gt;&gt; def new_commit(self):\n...     if raise_error:\n...         raise_error.pop()\n...         raise ClientDisconnected()\n...     else:\n...         old_commit(self) # changing state to \"active\" or similar\n...\n&gt;&gt;&gt; TransactionManager.commit = new_commit\n&gt;&gt;&gt; call = Partial(demo)\n&gt;&gt;&gt; len(faux.calls)\n0\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; deferred.called\n0\n&gt;&gt;&gt; len(faux.calls)\n1\n</pre>\n<pre>\n&gt;&gt;&gt; faux.calls[0][0] - faux.time\n5\n&gt;&gt;&gt; time_flies(4) # 4 seconds\n0\n&gt;&gt;&gt; deferred.called\n0\n&gt;&gt;&gt; time_flies(1) # 1 second\n1\n&gt;&gt;&gt; deferred.called\nTrue\n&gt;&gt;&gt; deferred.result\n4\n&gt;&gt;&gt; len(faux.calls)\n0\n</pre>\n<pre>\n&gt;&gt;&gt; TransactionManager.commit = old_commit\n&gt;&gt;&gt; _ = transaction.begin()\n</pre>\n</blockquote>\n</td></tr>\n</tbody>\n</table>\n<table id=\"show-sanitation\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id9\" rel=\"nofollow\">[9]</a></td><td><p>Before pickling, the failure includes full information\nabout before and after the exception was caught, as well as locals and\nglobals.  Everything has been repr\u2019d, though, and the traceback object\nremoved.</p>\n<pre>\n&gt;&gt;&gt; print res.getTraceback() # doctest: +ELLIPSIS\nTraceback (most recent call last):\n  File \".../zc/twist/__init__.py\", line ..., in __call__...\n  File \".../twisted/internet/defer.py\", line ..., in addCallback...\n--- &lt;exception caught here&gt; ---\n  File \".../zc/twist/__init__.py\", line ..., in _call...\n  File \"&lt;doctest README.txt[...]&gt;\", line ..., in __call__...\nexceptions.TypeError: unsupported operand type(s) for +=: 'int' and 'str'\n&lt;BLANKLINE&gt;\n</pre>\n<p>(The failure traceback at \u201cverbose\u201d detail is wildly verbose\u2013this example\ntakes out more than 90% of the text, just so you know.)</p>\n<pre>\n&gt;&gt;&gt; print res.getTraceback(detail='verbose') # doctest: +ELLIPSIS\n*--- Failure #... (pickled) ---\n.../zc/twist/__init__.py:...: __call__(...)\n [ Locals ]...\n  args : \"('I do not add well with integers',)...\n ( Globals )...\n  Partial : \"&lt;class 'zc.twist.Partial'&gt;...\n.../twisted/internet/defer.py:...: addCallback(...)\n [ Locals ]...\n  args : '(&lt;Deferred at ...\n ( Globals )...\n  Deferred : '&lt;class twisted.internet.defer.Deferred at ...\n--- &lt;exception caught here&gt; ---\n.../zc/twist/__init__.py:...: _call(...)\n [ Locals ]...\n  args : \"['I do not add well with integers']...\n ( Globals )...\n  Partial : \"&lt;class 'zc.twist.Partial'&gt;...\n&lt;doctest README.txt[...]&gt;:...: __call__(...)\n [ Locals ]...\n  amount : \"'I do not add well with integers'...\n ( Globals )...\n  Partial : \"&lt;class 'zc.twist.Partial'&gt;...\nexceptions.TypeError: unsupported operand type(s) for +=: 'int' and 'str'\n*--- End of Failure #... ---\n&lt;BLANKLINE&gt;\n</pre>\n<p>After pickling, the failure only includes information for when the\nexception was caught and beyond (after the \u201c\u2014 &lt;exception caught\nhere&gt; \u2014\u201d lines above), does not have globals, and has local reprs\ntruncated to a maximum of 20 characters plus \u201c[\u2026]\u201d to indicate the\ntruncation. This addresses past problems of large pickle size for\nfailures, which can cause performance problems.</p>\n<pre>\n&gt;&gt;&gt; import pickle\n&gt;&gt;&gt; print pickle.loads(pickle.dumps(res)).getTraceback()\n... # doctest: +ELLIPSIS\nTraceback (most recent call last):\n  File \".../zc/twist/__init__.py\", line ..., in _call\n    res = call(*args, **kwargs)\n  File \"&lt;doctest README.txt[...]&gt;\", line ..., in __call__\n    self.count += amount\nexceptions.TypeError: unsupported operand type(s) for +=: 'int' and 'str'\n&lt;BLANKLINE&gt;\n</pre>\n<pre>\n&gt;&gt;&gt; print pickle.loads(pickle.dumps(res)).getTraceback(detail='verbose')\n... # doctest: +ELLIPSIS\n*--- Failure #... (pickled) ---\n.../src/zc/twist/__init__.py:...: _call(...)\n [ Locals...\n  self : '&lt;zc.twist.Partial obj[...]...\n ( Globals )\n&lt;doctest README.txt[...]&gt;:...: __call__(...)\n [ Locals...\n  amount : \"'I do not add well wi[...]...\n ( Globals )\nexceptions.TypeError: unsupported operand type(s) for +=: 'int' and 'str'\n*--- End of Failure #... ---\n&lt;BLANKLINE&gt;\n</pre>\n<p>In some cases, it is possible that a Failure object may include references\nto itself, for example, indirectly through a zc.async job whose result\nis a Failure.  Failure\u2019s __getstate__ method used to use deepcopy, which\nin cases like this could result in infinite recursion.</p>\n<pre>\n&gt;&gt;&gt; import zc.twist\n&gt;&gt;&gt; class Kaboom(Exception):\n...     pass\n&gt;&gt;&gt; class Foo(object):\n...     failure = None\n...     def fail(self):\n...         raise Kaboom, self\n&gt;&gt;&gt; foo = Foo()\n&gt;&gt;&gt; try:\n...     foo.fail()\n... except Kaboom:\n...     foo.failure = zc.twist.Failure()\n&gt;&gt;&gt; ignored = foo.failure.__getstate__() # used to cause RunTimeError.\n</pre>\n</td></tr>\n</tbody>\n</table>\n<table id=\"teardown-monkeypatch\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id10\" rel=\"nofollow\">[10]</a></td><td><pre>\n&gt;&gt;&gt; twisted.internet.reactor.callLater = oldCallLater\n</pre>\n</td></tr>\n</tbody>\n</table>\n<table id=\"setreactor\">\n<col><col>\n<tbody>\n<tr><td><a href=\"#id11\" rel=\"nofollow\">[11]</a></td><td><pre>\n&gt;&gt;&gt; db.setPoolSize(1)\n&gt;&gt;&gt; db.getPoolSize()\n1\n&gt;&gt;&gt; demo.count = 0\n&gt;&gt;&gt; transaction.commit()\n&gt;&gt;&gt; call = Partial(demo).setReactor(faux)\n&gt;&gt;&gt; res = None\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; d = deferred.addCallback(get_result)\n&gt;&gt;&gt; call.attempt_count\n0\n&gt;&gt;&gt; time_flies(.125) &gt;= 1 # returns number of connection attempts\nTrue\n&gt;&gt;&gt; call.attempt_count\n0\n&gt;&gt;&gt; res # None\n&gt;&gt;&gt; db.setPoolSize(2)\n&gt;&gt;&gt; db.getPoolSize()\n2\n&gt;&gt;&gt; time_flies(.25) &gt;= 1\nTrue\n&gt;&gt;&gt; call.attempt_count &gt; 0\nTrue\n&gt;&gt;&gt; res\n1\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; demo.count\n1\n</pre>\n</td></tr>\n</tbody>\n</table>\n<p>If it takes more than a second or two, it will eventually just decide to grab\none.  This behavior may change.</p>\n<blockquote>\n<pre>&gt;&gt;&gt; db.setPoolSize(1)\n&gt;&gt;&gt; db.getPoolSize()\n1\n&gt;&gt;&gt; call = Partial(demo).setReactor(faux)\n&gt;&gt;&gt; res = None\n&gt;&gt;&gt; deferred = call()\n&gt;&gt;&gt; d = deferred.addCallback(get_result)\n&gt;&gt;&gt; call.attempt_count\n0\n&gt;&gt;&gt; time_flies(.125) &gt;= 1\nTrue\n&gt;&gt;&gt; call.attempt_count\n0\n&gt;&gt;&gt; res # None\n&gt;&gt;&gt; time_flies(2) &gt;= 2 # for a total of at least 3\nTrue\n&gt;&gt;&gt; res\n2\n&gt;&gt;&gt; t = transaction.begin()\n&gt;&gt;&gt; demo.count\n2\n</pre>\n</blockquote>\n</div>\n<div id=\"changes\">\n<h2>Changes</h2>\n<div id=\"id12\">\n<h3>1.3.1 (2009-11-15)</h3>\n<ul>\n<li>Added missing import of twisted.python.failure.</li>\n<li>Use db.pool with ZODB &gt;= 3.9 and db._pools with ZODB &lt; 3.9.\nThe tests now pass with ZODB 3.9.</li>\n<li>Tests pass in Python 2.6.</li>\n</ul>\n</div>\n<div id=\"id13\">\n<h3>1.3 (2008-06-19)</h3>\n<ul>\n<li>Handle ZEO.Exceptions.ClientDisconnected errors: retry forever, with a\nbackoff, defaulting to a max backoff of 60 seconds.</li>\n<li>Make number of times that ConflictErrors are retried configurable.</li>\n</ul>\n</div>\n<div id=\"id14\">\n<h3>1.2 (2008-04-09)</h3>\n<ul>\n<li>New subclass of twisted.python.failure.Failure begins with only reprs,\nand it pickles to exclude the stack, exclude the global vars in the frames,\nand truncate the reprs of the local vars in the frames.  The goal is to\nkeep the pickle size of Failures down to a manageable size.  <tt>sanitize</tt>\nnow uses this class.</li>\n</ul>\n</div>\n<div id=\"id15\">\n<h3>1.1 (2008-03-27)</h3>\n<ul>\n<li>Now depends on twisted 8.0.1 or higher, which is newly setuptools\ncompatible.  The twisted build is a little frightening, at least with\nPy2.4, with multiple warnings and errors, but works.  The dependency\nchange is the reason for the bump to 1.1; this release has no new\nfeatures.</li>\n<li>setup.py uses os.path</li>\n<li>C extension uses older comment style and has less cruft.</li>\n</ul>\n</div>\n<div id=\"id16\">\n<h3>1.0.1 (2008-03-14)</h3>\n<ul>\n<li>Bugfix: if you passed a slot method like a BTree.__setitem__, bad things\nwould happen.</li>\n</ul>\n</div>\n<div id=\"id17\">\n<h3>1.0.0 (2008-03-13)</h3>\n<ul>\n<li>Add ability to specify an alternate reactor</li>\n<li>Use bootstrap external</li>\n</ul>\n</div>\n<div id=\"id18\">\n<h3>0.1.1 (?)</h3>\n<ul>\n<li>use zc.twisted, not twisted in setup.py, until twisted is setuptools-friendly</li>\n</ul>\n</div>\n<div id=\"id19\">\n<h3>0.1 (?)</h3>\n<ul>\n<li>Initial release-ish</li>\n</ul>\n</div>\n</div>\n\n          </div>"}, "last_serial": 802213, "releases": {"1.0": [{"comment_text": "", "digests": {"md5": "d539532a694ab60c5b655fc86e9058b1", "sha256": "df90b38e356f80758a9a1527d4c7124a46bc03d714e66e72358719ea5c6e0ba2"}, "downloads": -1, "filename": "zc.twist-1.0.tar.gz", "has_sig": false, "md5_digest": "d539532a694ab60c5b655fc86e9058b1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 15392, "upload_time": "2008-03-13T16:07:19", "upload_time_iso_8601": "2008-03-13T16:07:19Z", "url": "https://files.pythonhosted.org/packages/c5/da/400eb978362350ea963e7ef47b330ac9207a7fa7ac365fdf8c369efe5d12/zc.twist-1.0.tar.gz", "yanked": false}], "1.0.1": [{"comment_text": "", "digests": {"md5": "5402922c70f52b3fbcd6e87c5a1110de", "sha256": "5770ca0dde04f29b398d6eaf69bf82ad513e11ddcf5b29d7378e8d46cfdaeb31"}, "downloads": -1, "filename": "zc.twist-1.0.1.tar.gz", "has_sig": false, "md5_digest": "5402922c70f52b3fbcd6e87c5a1110de", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 16554, "upload_time": "2008-03-14T22:31:51", "upload_time_iso_8601": "2008-03-14T22:31:51Z", "url": "https://files.pythonhosted.org/packages/c2/8d/58f9a1433c82a4522cf827f505a2dcf63bbecdcc9967ebd29e08a12093dc/zc.twist-1.0.1.tar.gz", "yanked": false}], "1.1": [{"comment_text": "", "digests": {"md5": "7bfb27435f9dd25a7bb90ca79be166c5", "sha256": "0f2c4e4c3c5280de731fdd4abcc2867b1c3ab3ec4faf53dda0d8d24a5fc50618"}, "downloads": -1, "filename": "zc.twist-1.1.tar.gz", "has_sig": false, "md5_digest": "7bfb27435f9dd25a7bb90ca79be166c5", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 17116, "upload_time": "2008-03-27T16:46:07", "upload_time_iso_8601": "2008-03-27T16:46:07Z", "url": "https://files.pythonhosted.org/packages/4b/85/2db976f15d93726e9454871d3129c176c237cf7cea92185a2935a78497f0/zc.twist-1.1.tar.gz", "yanked": false}], "1.2": [{"comment_text": "", "digests": {"md5": "5f43341462ae2b4cf7364c756643bc63", "sha256": "a57ab65fdd24c9ed26475351267a7ee3c0042228d9833c4b4759bde971d1beb0"}, "downloads": -1, "filename": "zc.twist-1.2.tar.gz", "has_sig": false, "md5_digest": "5f43341462ae2b4cf7364c756643bc63", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19985, "upload_time": "2008-04-09T15:52:31", "upload_time_iso_8601": "2008-04-09T15:52:31Z", "url": "https://files.pythonhosted.org/packages/1c/92/f1bdd9f40a7f175a2242687140a6b3f182dc7a21199dd0de8d667f023f2a/zc.twist-1.2.tar.gz", "yanked": false}], "1.3": [{"comment_text": "", "digests": {"md5": "fcb8eaa7aa623293eaef232d46e1a5dd", "sha256": "448603fbb3bd91d1d5597299ee1f358dab294d9cbdb37fb5b4863bf7eb0af6c8"}, "downloads": -1, "filename": "zc.twist-1.3.tar.gz", "has_sig": false, "md5_digest": "fcb8eaa7aa623293eaef232d46e1a5dd", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 27363, "upload_time": "2008-06-19T21:29:15", "upload_time_iso_8601": "2008-06-19T21:29:15Z", "url": "https://files.pythonhosted.org/packages/15/d9/55192d3016c89a80e38d9d225abcbf42de5634dc867e653075b07440f72c/zc.twist-1.3.tar.gz", "yanked": false}], "1.3.1": [{"comment_text": "", "digests": {"md5": "60bc9506455d9675a280880b74cd4427", "sha256": "99cbf5b4a7c57b8c475a89c6619f21cebbfe561ec9f5b043200337f6c3a3327f"}, "downloads": -1, "filename": "zc.twist-1.3.1.tar.gz", "has_sig": false, "md5_digest": "60bc9506455d9675a280880b74cd4427", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29479, "upload_time": "2009-11-16T02:48:48", "upload_time_iso_8601": "2009-11-16T02:48:48.848125Z", "url": "https://files.pythonhosted.org/packages/37/24/5c7b7bb96b57b732e7cd1c48d8a66f7ade89d035a449fe81711f9812fa47/zc.twist-1.3.1.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "60bc9506455d9675a280880b74cd4427", "sha256": "99cbf5b4a7c57b8c475a89c6619f21cebbfe561ec9f5b043200337f6c3a3327f"}, "downloads": -1, "filename": "zc.twist-1.3.1.tar.gz", "has_sig": false, "md5_digest": "60bc9506455d9675a280880b74cd4427", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 29479, "upload_time": "2009-11-16T02:48:48", "upload_time_iso_8601": "2009-11-16T02:48:48.848125Z", "url": "https://files.pythonhosted.org/packages/37/24/5c7b7bb96b57b732e7cd1c48d8a66f7ade89d035a449fe81711f9812fa47/zc.twist-1.3.1.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:18:53 2020"}