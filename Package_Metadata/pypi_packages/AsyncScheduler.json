{"info": {"author": "Tobias Gawron-Deutsch", "author_email": "tobias@strix.at", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Environment :: Console", "Environment :: No Input/Output (Daemon)", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3"], "description": "Simple Asynchronous Scheduler\n=============================\n\nAsyncScheduler is a wrapper for sched.scheduler that provides\nasynchronous operation out of the box. Thus, starting the scheduler does\nnot block the execution of the next statements. Further, adding and\nremoving events can be done without manually stopping/starting the\nscheduler.\n\nThe event itself is executed synchronously. Consequently, it the\nexecution of the calling method takes longer than the delay to the next\nevent, execution of the next method is postponed until the previous\nmethod returns.\n\nFour different methods are available to add new events: \\* ``enter`` -\nadds a single event to take place in n seconds \\* ``enterabs`` - adds a\nsingle event to take place at time t \\* ``repeat`` - adds a repeating\nevent that is triggered every n seconds \\* ``enterabs`` - adds a\nrepeating event that is triggered at time t for the first time and then\nevery n seconds\n\nExample\n=======\n\nSome events\n-----------\n\nCode\n~~~~\n\n::\n\n    from asyncscheduler import AsyncScheduler\n    from time import sleep\n\n    a = AsyncScheduler()\n    a.start()\n    event = a.enter(1, 1, print, args=(\"event 1\",))\n    a.enter(2, 1, print, args=(\"event 2\",))\n    a.enter(3, 1, print, args=(\"event 3\",))\n    a.enter(4, 1, print, args=(\"event 4\",))\n    a.cancel(event)\n    sleep(3.1)\n    a.clear_scheduler()\n    a.stop()\n\nOutput\n~~~~~~\n\n::\n\n    event 2\n    event 3\n\nDigital clock\n-------------\n\nCode\n~~~~\n\n::\n\n    from asyncscheduler import AsyncScheduler\n    import time, datetime\n\n\n    def display_time():\n        print(\"\\r{}\".format(datetime.datetime.now().strftime(\"%H:%M:%S\")), end='\\r')\n\n\n    a = AsyncScheduler()\n    a.start()\n    a.repeatabs(math.floor(time.time()) + 1, 1, 1, display_time)\n\n    try:\n        while True:\n            time.sleep(0.25)\n    except KeyboardInterrupt:\n        pass\n\n    a.stop()\n\nOutput\n~~~~~~\n\n::\n\n    12:34:56\n\nAPI\n===\n\nenter\n-----\n\n``AsyncScheduler.enter(self, delay, priority, action, args=(), kwargs={})``\n\nAdd an event to the scheduler. It will be executed after the provided\ndelay with 'action(\\*argument, \\*\\*kwargs)'. In case of two events\nscheduled for the same time the priority is used for execution order. A\nlower number means a higher priority.\n\nParameter: \\* ``delay`` - delay call of func for this amount of seconds.\ne.g. 12.34 \\* ``priority`` - events scheduled for the same time are\nprocessed according to their priority. \\* ``action`` - function that is\ncalled upon expires \\* ``args`` - tuple of arguments for this function\n\\* ``kwargs`` - dict of arguments for this function\n\nReturns the instance of the added event.\n\nenterabs\n--------\n\n``AsyncScheduler.enterabs(self, time, priority, action, args=(), kwargs={})``\n\nAdd an event to the scheduler. It will be executed at the provided time\nwith 'action(\\*argument, \\*\\*kwargs)'. In case of two events scheduled\nfor the same time the priority is used for execution order. A lower\nnumber means a higher priority.\n\nParameter: \\* ``time`` - call the action at this time stamp. \\*\n``priority`` - events scheduled for the same time are processed\naccording to their priority. \\* ``action`` - function that is called\nupon expires \\* ``args`` - tuple of arguments for this function \\*\n``kwargs`` - dict of arguments for this function\n\nReturns the instance of the added event.\n\nclear\\_scheduler\n----------------\n\n``AsyncScheduler.clear_scheduler(self)``\n\nCancels all scheduled events.\n\ncancel\n------\n\n``AsyncScheduler.cancel(self, event)``\n\nRemove the provided event from the scheduler. In case of an unknown\nevent, a ValueError will be raised.\n\nParameter: \\* ``event`` - event instance as returned from add\\_event.\n\nrepeat\n------\n\n``repeat(self, every, priority, action, args=(), kwargs={})``\n\nAdd a repeating event to the scheduler. It will be executed each time\nthe provided delay (every-n-seconds) has expired with 'func(\\*argument,\n\\*\\*kwargs)'. In case of two events scheduled for the same time the\npriority is used for execution order. A lower number means a higher\npriority.\n\nSee repeatabs for more information.\n\nParameter: \\* ``time`` - call the action at this time stamp. \\*\n``every`` - every-n-seconds call action. e.g. 12.34 \\* ``priority`` -\nevents scheduled for the same time are processed according to their\npriority. \\* ``action`` - function that is called upon expirey \\*\n``args`` - tuple of arguments for this function \\* ``kwargs`` - dict of\narguments for this function\n\nReturns the instance of the added event.\n\nrepeatabs\n---------\n\n``repeatabs(self, time, every, priority, action, args=(), kwargs={})``\n\nAdd a repeating event to the scheduler. It will be executed each time\nthe provided delay (every-n-seconds) has expired with 'func(\\*argument,\n\\*\\*kwargs)'. The first event is triggered at the provided time. In case\nof two events scheduled for the same time the priority is used for\nexecution order. A lower number means a higher priority.\n\nA repeating event will trigger one last time in case of a regular stop\nwith wait=False (=default).\n\nNote: the returned event instance is the instance of the first iteration\nonly. Thus, after the first iteration it will not be part of\nscheduler.queue no more. Instead a new event for this repeating event\nhas been created. AsyncScheduler keeps track of the current instance and\nuses the first instance for identification of which event to cancel.\nThis is done with the method \\_repeat\\_event\\_hash and the map\n\\_repeat\\_event\\_mapping.\n\nParameter: \\* ``time`` - call the action at this time stamp. \\*\n``every`` - every-n-seconds call action. e.g. 12.34 \\* ``priority`` -\nevents scheduled for the same time are processed according to their\npriority. \\* ``action`` - function that is called upon expirey \\*\n``args`` - tuple of arguments for this function \\* ``kwargs`` - dict of\narguments for this function\n\nReturns the instance of the added event.\n\nstart\n-----\n\n``start(self)``\n\nStarts the scheduler.\n\nstop\n----\n\n``stop(self)``\n\nStops the scheduler. After stop, the scheduler is emptied. Thus, calling\n``start`` after ``stop`` results in a new, blank schedule that must be\nfilled.\n\nTodos\n=====\n\n-  readthedocs\n-  CI/CD\n\nMisc\n====\n\nThe code is written for ``python3`` (and tested with python 3.5).\n\n`Merge\nrequests <https://gitlab.com/tgd1975/simple_asynchronous_scheduler/merge_requests>`__\n/ `bug\nreports <https://gitlab.com/tgd1975/simple_asynchronous_scheduler/issues>`__\nare always welcome.\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://gitlab.com/tgd1975/simple_asynchronous_scheduler/", "keywords": "sched scheduler", "license": "MIT license", "maintainer": "", "maintainer_email": "", "name": "AsyncScheduler", "package_url": "https://pypi.org/project/AsyncScheduler/", "platform": "", "project_url": "https://pypi.org/project/AsyncScheduler/", "project_urls": {"Homepage": "https://gitlab.com/tgd1975/simple_asynchronous_scheduler/"}, "release_url": "https://pypi.org/project/AsyncScheduler/0.2.0/", "requires_dist": null, "requires_python": "", "summary": "A simpler asynchronous scheduler based on pythons sched.scheduler.", "version": "0.2.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"simple-asynchronous-scheduler\">\n<h2>Simple Asynchronous Scheduler</h2>\n<p>AsyncScheduler is a wrapper for sched.scheduler that provides\nasynchronous operation out of the box. Thus, starting the scheduler does\nnot block the execution of the next statements. Further, adding and\nremoving events can be done without manually stopping/starting the\nscheduler.</p>\n<p>The event itself is executed synchronously. Consequently, it the\nexecution of the calling method takes longer than the delay to the next\nevent, execution of the next method is postponed until the previous\nmethod returns.</p>\n<p>Four different methods are available to add new events: * <tt>enter</tt> -\nadds a single event to take place in n seconds * <tt>enterabs</tt> - adds a\nsingle event to take place at time t * <tt>repeat</tt> - adds a repeating\nevent that is triggered every n seconds * <tt>enterabs</tt> - adds a\nrepeating event that is triggered at time t for the first time and then\nevery n seconds</p>\n</div>\n<div id=\"example\">\n<h2>Example</h2>\n<div id=\"some-events\">\n<h3>Some events</h3>\n<div id=\"code\">\n<h4>Code</h4>\n<pre>from asyncscheduler import AsyncScheduler\nfrom time import sleep\n\na = AsyncScheduler()\na.start()\nevent = a.enter(1, 1, print, args=(\"event 1\",))\na.enter(2, 1, print, args=(\"event 2\",))\na.enter(3, 1, print, args=(\"event 3\",))\na.enter(4, 1, print, args=(\"event 4\",))\na.cancel(event)\nsleep(3.1)\na.clear_scheduler()\na.stop()\n</pre>\n</div>\n<div id=\"output\">\n<h4>Output</h4>\n<pre>event 2\nevent 3\n</pre>\n</div>\n</div>\n<div id=\"digital-clock\">\n<h3>Digital clock</h3>\n<div id=\"id1\">\n<h4>Code</h4>\n<pre>from asyncscheduler import AsyncScheduler\nimport time, datetime\n\n\ndef display_time():\n    print(\"\\r{}\".format(datetime.datetime.now().strftime(\"%H:%M:%S\")), end='\\r')\n\n\na = AsyncScheduler()\na.start()\na.repeatabs(math.floor(time.time()) + 1, 1, 1, display_time)\n\ntry:\n    while True:\n        time.sleep(0.25)\nexcept KeyboardInterrupt:\n    pass\n\na.stop()\n</pre>\n</div>\n<div id=\"id2\">\n<h4>Output</h4>\n<pre>12:34:56\n</pre>\n</div>\n</div>\n</div>\n<div id=\"api\">\n<h2>API</h2>\n<div id=\"enter\">\n<h3>enter</h3>\n<p><tt>AsyncScheduler.enter(self, delay, priority, action, <span class=\"pre\">args=(),</span> <span class=\"pre\">kwargs={})</span></tt></p>\n<p>Add an event to the scheduler. It will be executed after the provided\ndelay with \u2018action(*argument, **kwargs)\u2019. In case of two events\nscheduled for the same time the priority is used for execution order. A\nlower number means a higher priority.</p>\n<p>Parameter: * <tt>delay</tt> - delay call of func for this amount of seconds.\ne.g. 12.34 * <tt>priority</tt> - events scheduled for the same time are\nprocessed according to their priority. * <tt>action</tt> - function that is\ncalled upon expires * <tt>args</tt> - tuple of arguments for this function\n* <tt>kwargs</tt> - dict of arguments for this function</p>\n<p>Returns the instance of the added event.</p>\n</div>\n<div id=\"enterabs\">\n<h3>enterabs</h3>\n<p><tt>AsyncScheduler.enterabs(self, time, priority, action, <span class=\"pre\">args=(),</span> <span class=\"pre\">kwargs={})</span></tt></p>\n<p>Add an event to the scheduler. It will be executed at the provided time\nwith \u2018action(*argument, **kwargs)\u2019. In case of two events scheduled\nfor the same time the priority is used for execution order. A lower\nnumber means a higher priority.</p>\n<p>Parameter: * <tt>time</tt> - call the action at this time stamp. *\n<tt>priority</tt> - events scheduled for the same time are processed\naccording to their priority. * <tt>action</tt> - function that is called\nupon expires * <tt>args</tt> - tuple of arguments for this function *\n<tt>kwargs</tt> - dict of arguments for this function</p>\n<p>Returns the instance of the added event.</p>\n</div>\n<div id=\"clear-scheduler\">\n<h3>clear_scheduler</h3>\n<p><tt>AsyncScheduler.clear_scheduler(self)</tt></p>\n<p>Cancels all scheduled events.</p>\n</div>\n<div id=\"cancel\">\n<h3>cancel</h3>\n<p><tt>AsyncScheduler.cancel(self, event)</tt></p>\n<p>Remove the provided event from the scheduler. In case of an unknown\nevent, a ValueError will be raised.</p>\n<p>Parameter: * <tt>event</tt> - event instance as returned from add_event.</p>\n</div>\n<div id=\"repeat\">\n<h3>repeat</h3>\n<p><tt>repeat(self, every, priority, action, <span class=\"pre\">args=(),</span> <span class=\"pre\">kwargs={})</span></tt></p>\n<p>Add a repeating event to the scheduler. It will be executed each time\nthe provided delay (every-n-seconds) has expired with \u2018func(*argument,\n**kwargs)\u2019. In case of two events scheduled for the same time the\npriority is used for execution order. A lower number means a higher\npriority.</p>\n<p>See repeatabs for more information.</p>\n<p>Parameter: * <tt>time</tt> - call the action at this time stamp. *\n<tt>every</tt> - every-n-seconds call action. e.g. 12.34 * <tt>priority</tt> -\nevents scheduled for the same time are processed according to their\npriority. * <tt>action</tt> - function that is called upon expirey *\n<tt>args</tt> - tuple of arguments for this function * <tt>kwargs</tt> - dict of\narguments for this function</p>\n<p>Returns the instance of the added event.</p>\n</div>\n<div id=\"repeatabs\">\n<h3>repeatabs</h3>\n<p><tt>repeatabs(self, time, every, priority, action, <span class=\"pre\">args=(),</span> <span class=\"pre\">kwargs={})</span></tt></p>\n<p>Add a repeating event to the scheduler. It will be executed each time\nthe provided delay (every-n-seconds) has expired with \u2018func(*argument,\n**kwargs)\u2019. The first event is triggered at the provided time. In case\nof two events scheduled for the same time the priority is used for\nexecution order. A lower number means a higher priority.</p>\n<p>A repeating event will trigger one last time in case of a regular stop\nwith wait=False (=default).</p>\n<p>Note: the returned event instance is the instance of the first iteration\nonly. Thus, after the first iteration it will not be part of\nscheduler.queue no more. Instead a new event for this repeating event\nhas been created. AsyncScheduler keeps track of the current instance and\nuses the first instance for identification of which event to cancel.\nThis is done with the method _repeat_event_hash and the map\n_repeat_event_mapping.</p>\n<p>Parameter: * <tt>time</tt> - call the action at this time stamp. *\n<tt>every</tt> - every-n-seconds call action. e.g. 12.34 * <tt>priority</tt> -\nevents scheduled for the same time are processed according to their\npriority. * <tt>action</tt> - function that is called upon expirey *\n<tt>args</tt> - tuple of arguments for this function * <tt>kwargs</tt> - dict of\narguments for this function</p>\n<p>Returns the instance of the added event.</p>\n</div>\n<div id=\"start\">\n<h3>start</h3>\n<p><tt>start(self)</tt></p>\n<p>Starts the scheduler.</p>\n</div>\n<div id=\"stop\">\n<h3>stop</h3>\n<p><tt>stop(self)</tt></p>\n<p>Stops the scheduler. After stop, the scheduler is emptied. Thus, calling\n<tt>start</tt> after <tt>stop</tt> results in a new, blank schedule that must be\nfilled.</p>\n</div>\n</div>\n<div id=\"todos\">\n<h2>Todos</h2>\n<ul>\n<li>readthedocs</li>\n<li>CI/CD</li>\n</ul>\n</div>\n<div id=\"misc\">\n<h2>Misc</h2>\n<p>The code is written for <tt>python3</tt> (and tested with python 3.5).</p>\n<p><a href=\"https://gitlab.com/tgd1975/simple_asynchronous_scheduler/merge_requests\" rel=\"nofollow\">Merge\nrequests</a>\n/ <a href=\"https://gitlab.com/tgd1975/simple_asynchronous_scheduler/issues\" rel=\"nofollow\">bug\nreports</a>\nare always welcome.</p>\n</div>\n\n          </div>"}, "last_serial": 4976881, "releases": {"0.1.0": [{"comment_text": "", "digests": {"md5": "ab1345394c846907b9897a19148f4726", "sha256": "a51dc99eb2339bd6bed70eee239fcab75b0f2dde71114d77a73e51d92456b428"}, "downloads": -1, "filename": "AsyncScheduler-0.1.0.tar.gz", "has_sig": false, "md5_digest": "ab1345394c846907b9897a19148f4726", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 4755, "upload_time": "2019-03-21T20:31:40", "upload_time_iso_8601": "2019-03-21T20:31:40.710558Z", "url": "https://files.pythonhosted.org/packages/8d/e6/4b8085e3d8e08aa6be5880c3676a76cdfd021e153ae2464529f30f176f12/AsyncScheduler-0.1.0.tar.gz", "yanked": false}], "0.2.0": [{"comment_text": "", "digests": {"md5": "0c54ce2bcd4742778c2146e23c775638", "sha256": "d077131667bbcb499d13f906b2cd3670e2c359344a63a949eb1ba69263a25d00"}, "downloads": -1, "filename": "AsyncScheduler-0.2.0.tar.gz", "has_sig": false, "md5_digest": "0c54ce2bcd4742778c2146e23c775638", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7066, "upload_time": "2019-03-23T22:47:55", "upload_time_iso_8601": "2019-03-23T22:47:55.477359Z", "url": "https://files.pythonhosted.org/packages/c8/34/2c72a02768183a17c40376c96dffee1cc82cf0ad2118f8e5853830cf7494/AsyncScheduler-0.2.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0c54ce2bcd4742778c2146e23c775638", "sha256": "d077131667bbcb499d13f906b2cd3670e2c359344a63a949eb1ba69263a25d00"}, "downloads": -1, "filename": "AsyncScheduler-0.2.0.tar.gz", "has_sig": false, "md5_digest": "0c54ce2bcd4742778c2146e23c775638", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 7066, "upload_time": "2019-03-23T22:47:55", "upload_time_iso_8601": "2019-03-23T22:47:55.477359Z", "url": "https://files.pythonhosted.org/packages/c8/34/2c72a02768183a17c40376c96dffee1cc82cf0ad2118f8e5853830cf7494/AsyncScheduler-0.2.0.tar.gz", "yanked": false}], "timestamp": "Thu May  7 18:16:41 2020"}