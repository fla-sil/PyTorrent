{"info": {"author": "Micha\u0142 Jaworski", "author_email": "swistakm@gmail.com", "bugtrack_url": null, "classifiers": ["Development Status :: 4 - Beta", "Intended Audience :: Developers", "License :: OSI Approved :: BSD License", "Operating System :: OS Independent", "Programming Language :: Python", "Programming Language :: Python :: 3"], "description": "|Build Status| |Coverage Status|\n\nfrules - simple functional fuzzy rules\n======================================\n\nFrules stands for **fuzzy/funtional rules**. It allows to work easily\nwith fuzzy rules and variables.\n\nInstallation:\n\n::\n\n    pip install frules\n\nLinguistic variables and expressions\n------------------------------------\n\nExpression is a core concept in frules. ``Expression`` class represents\nsubrange of `linguistic\nvariable <http://en.wikipedia.org/wiki/Fuzzy_logic#Linguistic_variables>`__\nin fuzzy logic.\n\nVariables in classical math take numerical values. in fuzzy logic, the\n*linguistic variables* are non-numeric and are described with\nexpressions. Expressions map continuous variable like nemerical\ntemperature to its linguistic counterpart. For example temperature can\nbe described as cold, warm or hot. There is no strict boundary between\ncold and warm - this is why this expressions are fuzzy.\n\nTo create new expression we use function that takes numerical value of\ncontiunous variable and returns *truth value*. Truth value ranges\nbetween 0 and 1 - it's a degree of membership of continous value to that\nlinguistic variable.\n\n.. code:: python\n\n    from frules.expressions import Expression\n    #We know that anything over 50 degrees is hot and below 40 is't hot\n    hot = Expression(lambda x: min(1, max((x - 40) / 10., 0)))\n\nThis ugly lambda is representation of some fuzzy set. If we take a look\nhow it behaves, we'll see that it in fact returns 1 for anything over\n50, 0 for anything below 40 and some linear values between 40 and 50:\n\n.. code:: python\n\n    >>> map(lambda x: {x: min(1, max((x - 40) / 10., 0))}, xrange(35, 55, 2))\n    [{35: 0}, {37: 0}, {39: 0}, {41: 0.1}, {43: 0.3}, {45: 0.5}, {47: 0.7}, {49: 0.9}, {51: 1}, {53: 1}\n\nUsing a lot of lambdas in practice makes your code a mess. Fuzzy\nexpressions described this way are additionally hard to write because of\nsome value assertions they must satisfy.\n\nThis is why we ancapsulate don't use raw functions and encapsulate them\nwith expressions. Moreover frules provides a bunch of helpers that eases\ndefinition of new expressions. Example of full set of expressions for\ntemperature variable could look this way:\n\n.. code:: python\n\n    from frules.expressions import Expression as E\n    from frules.expressions import ltrapezoid, trapezoid, rtrapezoid\n\n    cold = E(ltrapezoid(10, 20), \"cold\")        # anything below 10, more is fuzzy\n    warm = E(trapezoid(10, 20, 30, 35), \"warm\") # anything between 20 and 30\n    hot = E(rtrapezoid(30, 35), \"hot\")          # anything over 35, less is fuzzy\n\nExpressions can be reused/mixed using logical operators:\n\n.. code:: python\n\n    cold_or_hot = cold || warm\n    not_hot = !hot\n\nOptional names will be helpful when we start to work with fuzzy rules.\n\nFuzzy rules\n-----------\n\nAlthough expressions define linguistic variables, they aren't strictly\nbound to any variable. They are rather the adjectives we use to describe\nsomething and their meaning depends strictly on context. Both *person*\nand *data* could be *big* but this particular adjective has slighlty\ndifferent meaning in each case.\n\n``Rule`` objects bounds continous variable with expressions. Rules also\ncan also be evaluated to see how true they are for given continous\ninput.\n\n::\n\n    >>> from frules.rules import Rule\n    >>> is_hot = Rule(temperature=hot)\n    >>> is_hot.eval(temperature=5)\n    0.8\n\nRules can be mixed using logical operators (``&`` and ``|``) to create\nmore sophisticated rules that allow fuzzy reasoning:\n\n.. code:: python\n\n    from frules.expressions import Expression as E\n    from frules.rules import Rule as R\n    from frules.expressions import ltrapezoid, trapezoid, rtrapezoid\n\n    # car age expressions\n    old = E(ltrapezoid(2001, 2008), \"old\")\n    new = E(rtrapezoid(2013, 2014), \"new\")\n    not_so_old = - (old & new)\n\n    # power expressions\n    strong = E(rtrapezoid(50, 100), \"strong\")\n    weak = E(ltrapezoid(50, 100), \"weak\")\n\n    # price expression\n    expensive = E(rtrapezoid(25000, 30000), \"expensive\")\n    cheap = - expensive\n\n    # yes expression\n    yes = E(lambda yes: float(yes), \"yes\") # converts bool to float\n\n\n    # rules\n    is_attractive = R(production_year=not_so_old) & R(horsepower=strong)\n    should_buy = is_attractive & R(price=cheap)\n\nHaving such set of rules we can do some reasoning:\n\n::\n\n    >>> should_buy\n    (((age = !(old & new) & horsepower = strong) & !None = None) & cost = !expensive)\n    >>> should_buy.eval(horsepower=70, production_year=2012, price=15000)\n    0.4\n    >>>\n    >>> candidates = {\n    ...     \"car1\": {\"horsepower\": 70, \"production_year\": 2012, \"price\": 15000},\n    ...     \"car2\": {\"horsepower\": 150, \"production_year\": 2010, \"price\": 30000},\n    ...     \"car3\": {\"horsepower\": 90, \"production_year\": 2014, \"price\": 10000},\n    ...     \"car4\": {\"horsepower\": 85, \"production_year\": 2009, \"price\": 35000},\n    ... }\n    >>> max(candidates.iteritems(), key=lambda (key, inputs): is_hot.eval(**inputs))\n    ('car3', {'horsepower': 90, 'price': 10000, 'production_year': 2014})\n\n.. |Build Status| image:: https://travis-ci.org/swistakm/frules.svg?branch=master\n   :target: https://travis-ci.org/swistakm/frules\n.. |Coverage Status| image:: https://coveralls.io/repos/swistakm/frules/badge.svg?branch=master\n   :target: https://coveralls.io/r/swistakm/frules?branch=master", "description_content_type": null, "docs_url": null, "download_url": "UNKNOWN", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/swistakm/frules", "keywords": null, "license": "UNKNOWN", "maintainer": null, "maintainer_email": null, "name": "frules", "package_url": "https://pypi.org/project/frules/", "platform": "UNKNOWN", "project_url": "https://pypi.org/project/frules/", "project_urls": {"Download": "UNKNOWN", "Homepage": "https://github.com/swistakm/frules"}, "release_url": "https://pypi.org/project/frules/0.1.2/", "requires_dist": null, "requires_python": null, "summary": "simple functional fuzzy rules implementation", "version": "0.1.2", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p><a href=\"https://travis-ci.org/swistakm/frules\" rel=\"nofollow\"><img alt=\"Build Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/bc02ce227e73eb4da2d8ee31c6e340b252ad9d41/68747470733a2f2f7472617669732d63692e6f72672f7377697374616b6d2f6672756c65732e7376673f6272616e63683d6d6173746572\"></a> <a href=\"https://coveralls.io/r/swistakm/frules?branch=master\" rel=\"nofollow\"><img alt=\"Coverage Status\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/d1b82a41d5bc5a67ee2ac408bf4c5a920dc9fe03/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f7377697374616b6d2f6672756c65732f62616467652e7376673f6272616e63683d6d6173746572\"></a></p>\n<div id=\"frules-simple-functional-fuzzy-rules\">\n<h2>frules - simple functional fuzzy rules</h2>\n<p>Frules stands for <strong>fuzzy/funtional rules</strong>. It allows to work easily\nwith fuzzy rules and variables.</p>\n<p>Installation:</p>\n<pre>pip install frules\n</pre>\n<div id=\"linguistic-variables-and-expressions\">\n<h3>Linguistic variables and expressions</h3>\n<p>Expression is a core concept in frules. <tt>Expression</tt> class represents\nsubrange of <a href=\"http://en.wikipedia.org/wiki/Fuzzy_logic#Linguistic_variables\" rel=\"nofollow\">linguistic\nvariable</a>\nin fuzzy logic.</p>\n<p>Variables in classical math take numerical values. in fuzzy logic, the\n<em>linguistic variables</em> are non-numeric and are described with\nexpressions. Expressions map continuous variable like nemerical\ntemperature to its linguistic counterpart. For example temperature can\nbe described as cold, warm or hot. There is no strict boundary between\ncold and warm - this is why this expressions are fuzzy.</p>\n<p>To create new expression we use function that takes numerical value of\ncontiunous variable and returns <em>truth value</em>. Truth value ranges\nbetween 0 and 1 - it\u2019s a degree of membership of continous value to that\nlinguistic variable.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">frules.expressions</span> <span class=\"kn\">import</span> <span class=\"n\">Expression</span>\n<span class=\"c1\">#We know that anything over 50 degrees is hot and below 40 is't hot</span>\n<span class=\"n\">hot</span> <span class=\"o\">=</span> <span class=\"n\">Expression</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">max</span><span class=\"p\">((</span><span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"mi\">40</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mf\">10.</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)))</span>\n</pre>\n<p>This ugly lambda is representation of some fuzzy set. If we take a look\nhow it behaves, we\u2019ll see that it in fact returns 1 for anything over\n50, 0 for anything below 40 and some linear values between 40 and 50:</p>\n<pre><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">map</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"p\">{</span><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">max</span><span class=\"p\">((</span><span class=\"n\">x</span> <span class=\"o\">-</span> <span class=\"mi\">40</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mf\">10.</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">))},</span> <span class=\"n\">xrange</span><span class=\"p\">(</span><span class=\"mi\">35</span><span class=\"p\">,</span> <span class=\"mi\">55</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n<span class=\"p\">[{</span><span class=\"mi\">35</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"mi\">37</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"mi\">39</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"mi\">41</span><span class=\"p\">:</span> <span class=\"mf\">0.1</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"mi\">43</span><span class=\"p\">:</span> <span class=\"mf\">0.3</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"mi\">45</span><span class=\"p\">:</span> <span class=\"mf\">0.5</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"mi\">47</span><span class=\"p\">:</span> <span class=\"mf\">0.7</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"mi\">49</span><span class=\"p\">:</span> <span class=\"mf\">0.9</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"mi\">51</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"mi\">53</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">}</span>\n</pre>\n<p>Using a lot of lambdas in practice makes your code a mess. Fuzzy\nexpressions described this way are additionally hard to write because of\nsome value assertions they must satisfy.</p>\n<p>This is why we ancapsulate don\u2019t use raw functions and encapsulate them\nwith expressions. Moreover frules provides a bunch of helpers that eases\ndefinition of new expressions. Example of full set of expressions for\ntemperature variable could look this way:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">frules.expressions</span> <span class=\"kn\">import</span> <span class=\"n\">Expression</span> <span class=\"k\">as</span> <span class=\"n\">E</span>\n<span class=\"kn\">from</span> <span class=\"nn\">frules.expressions</span> <span class=\"kn\">import</span> <span class=\"n\">ltrapezoid</span><span class=\"p\">,</span> <span class=\"n\">trapezoid</span><span class=\"p\">,</span> <span class=\"n\">rtrapezoid</span>\n\n<span class=\"n\">cold</span> <span class=\"o\">=</span> <span class=\"n\">E</span><span class=\"p\">(</span><span class=\"n\">ltrapezoid</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">),</span> <span class=\"s2\">\"cold\"</span><span class=\"p\">)</span>        <span class=\"c1\"># anything below 10, more is fuzzy</span>\n<span class=\"n\">warm</span> <span class=\"o\">=</span> <span class=\"n\">E</span><span class=\"p\">(</span><span class=\"n\">trapezoid</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"mi\">35</span><span class=\"p\">),</span> <span class=\"s2\">\"warm\"</span><span class=\"p\">)</span> <span class=\"c1\"># anything between 20 and 30</span>\n<span class=\"n\">hot</span> <span class=\"o\">=</span> <span class=\"n\">E</span><span class=\"p\">(</span><span class=\"n\">rtrapezoid</span><span class=\"p\">(</span><span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"mi\">35</span><span class=\"p\">),</span> <span class=\"s2\">\"hot\"</span><span class=\"p\">)</span>          <span class=\"c1\"># anything over 35, less is fuzzy</span>\n</pre>\n<p>Expressions can be reused/mixed using logical operators:</p>\n<pre><span class=\"n\">cold_or_hot</span> <span class=\"o\">=</span> <span class=\"n\">cold</span> <span class=\"o\">||</span> <span class=\"n\">warm</span>\n<span class=\"n\">not_hot</span> <span class=\"o\">=</span> <span class=\"err\">!</span><span class=\"n\">hot</span>\n</pre>\n<p>Optional names will be helpful when we start to work with fuzzy rules.</p>\n</div>\n<div id=\"fuzzy-rules\">\n<h3>Fuzzy rules</h3>\n<p>Although expressions define linguistic variables, they aren\u2019t strictly\nbound to any variable. They are rather the adjectives we use to describe\nsomething and their meaning depends strictly on context. Both <em>person</em>\nand <em>data</em> could be <em>big</em> but this particular adjective has slighlty\ndifferent meaning in each case.</p>\n<p><tt>Rule</tt> objects bounds continous variable with expressions. Rules also\ncan also be evaluated to see how true they are for given continous\ninput.</p>\n<pre>&gt;&gt;&gt; from frules.rules import Rule\n&gt;&gt;&gt; is_hot = Rule(temperature=hot)\n&gt;&gt;&gt; is_hot.eval(temperature=5)\n0.8\n</pre>\n<p>Rules can be mixed using logical operators (<tt>&amp;</tt> and <tt>|</tt>) to create\nmore sophisticated rules that allow fuzzy reasoning:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">frules.expressions</span> <span class=\"kn\">import</span> <span class=\"n\">Expression</span> <span class=\"k\">as</span> <span class=\"n\">E</span>\n<span class=\"kn\">from</span> <span class=\"nn\">frules.rules</span> <span class=\"kn\">import</span> <span class=\"n\">Rule</span> <span class=\"k\">as</span> <span class=\"n\">R</span>\n<span class=\"kn\">from</span> <span class=\"nn\">frules.expressions</span> <span class=\"kn\">import</span> <span class=\"n\">ltrapezoid</span><span class=\"p\">,</span> <span class=\"n\">trapezoid</span><span class=\"p\">,</span> <span class=\"n\">rtrapezoid</span>\n\n<span class=\"c1\"># car age expressions</span>\n<span class=\"n\">old</span> <span class=\"o\">=</span> <span class=\"n\">E</span><span class=\"p\">(</span><span class=\"n\">ltrapezoid</span><span class=\"p\">(</span><span class=\"mi\">2001</span><span class=\"p\">,</span> <span class=\"mi\">2008</span><span class=\"p\">),</span> <span class=\"s2\">\"old\"</span><span class=\"p\">)</span>\n<span class=\"n\">new</span> <span class=\"o\">=</span> <span class=\"n\">E</span><span class=\"p\">(</span><span class=\"n\">rtrapezoid</span><span class=\"p\">(</span><span class=\"mi\">2013</span><span class=\"p\">,</span> <span class=\"mi\">2014</span><span class=\"p\">),</span> <span class=\"s2\">\"new\"</span><span class=\"p\">)</span>\n<span class=\"n\">not_so_old</span> <span class=\"o\">=</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"n\">old</span> <span class=\"o\">&amp;</span> <span class=\"n\">new</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># power expressions</span>\n<span class=\"n\">strong</span> <span class=\"o\">=</span> <span class=\"n\">E</span><span class=\"p\">(</span><span class=\"n\">rtrapezoid</span><span class=\"p\">(</span><span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">),</span> <span class=\"s2\">\"strong\"</span><span class=\"p\">)</span>\n<span class=\"n\">weak</span> <span class=\"o\">=</span> <span class=\"n\">E</span><span class=\"p\">(</span><span class=\"n\">ltrapezoid</span><span class=\"p\">(</span><span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">),</span> <span class=\"s2\">\"weak\"</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># price expression</span>\n<span class=\"n\">expensive</span> <span class=\"o\">=</span> <span class=\"n\">E</span><span class=\"p\">(</span><span class=\"n\">rtrapezoid</span><span class=\"p\">(</span><span class=\"mi\">25000</span><span class=\"p\">,</span> <span class=\"mi\">30000</span><span class=\"p\">),</span> <span class=\"s2\">\"expensive\"</span><span class=\"p\">)</span>\n<span class=\"n\">cheap</span> <span class=\"o\">=</span> <span class=\"o\">-</span> <span class=\"n\">expensive</span>\n\n<span class=\"c1\"># yes expression</span>\n<span class=\"n\">yes</span> <span class=\"o\">=</span> <span class=\"n\">E</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">yes</span><span class=\"p\">:</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">yes</span><span class=\"p\">),</span> <span class=\"s2\">\"yes\"</span><span class=\"p\">)</span> <span class=\"c1\"># converts bool to float</span>\n\n\n<span class=\"c1\"># rules</span>\n<span class=\"n\">is_attractive</span> <span class=\"o\">=</span> <span class=\"n\">R</span><span class=\"p\">(</span><span class=\"n\">production_year</span><span class=\"o\">=</span><span class=\"n\">not_so_old</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">R</span><span class=\"p\">(</span><span class=\"n\">horsepower</span><span class=\"o\">=</span><span class=\"n\">strong</span><span class=\"p\">)</span>\n<span class=\"n\">should_buy</span> <span class=\"o\">=</span> <span class=\"n\">is_attractive</span> <span class=\"o\">&amp;</span> <span class=\"n\">R</span><span class=\"p\">(</span><span class=\"n\">price</span><span class=\"o\">=</span><span class=\"n\">cheap</span><span class=\"p\">)</span>\n</pre>\n<p>Having such set of rules we can do some reasoning:</p>\n<pre>&gt;&gt;&gt; should_buy\n(((age = !(old &amp; new) &amp; horsepower = strong) &amp; !None = None) &amp; cost = !expensive)\n&gt;&gt;&gt; should_buy.eval(horsepower=70, production_year=2012, price=15000)\n0.4\n&gt;&gt;&gt;\n&gt;&gt;&gt; candidates = {\n...     \"car1\": {\"horsepower\": 70, \"production_year\": 2012, \"price\": 15000},\n...     \"car2\": {\"horsepower\": 150, \"production_year\": 2010, \"price\": 30000},\n...     \"car3\": {\"horsepower\": 90, \"production_year\": 2014, \"price\": 10000},\n...     \"car4\": {\"horsepower\": 85, \"production_year\": 2009, \"price\": 35000},\n... }\n&gt;&gt;&gt; max(candidates.iteritems(), key=lambda (key, inputs): is_hot.eval(**inputs))\n('car3', {'horsepower': 90, 'price': 10000, 'production_year': 2014})\n</pre>\n</div>\n</div>\n\n          </div>"}, "last_serial": 1599114, "releases": {"0.0.1": [{"comment_text": "", "digests": {"md5": "7a40fdb5961898a34811cbb0bba6eda7", "sha256": "ac1d0a892c291999c86aa3ecf91fc3201d88356e3ebb65ba718656a0d096f3f9"}, "downloads": -1, "filename": "frules-0.0.1.tar.gz", "has_sig": false, "md5_digest": "7a40fdb5961898a34811cbb0bba6eda7", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 6230, "upload_time": "2014-02-27T15:11:18", "upload_time_iso_8601": "2014-02-27T15:11:18.345234Z", "url": "https://files.pythonhosted.org/packages/48/de/154daed73fa1f86ebbfe24ae20f0f06e40c14769d487123e500be24e2cbd/frules-0.0.1.tar.gz", "yanked": false}], "0.1.0": [{"comment_text": "", "digests": {"md5": "45a1184a0637cdb19864fb62a9c4fb70", "sha256": "76caaa93e34614a64de552b1bc35467a2e4d0e715e4e1a3cbc3f58fc2e570ccb"}, "downloads": -1, "filename": "frules-0.1.0.tar.gz", "has_sig": false, "md5_digest": "45a1184a0637cdb19864fb62a9c4fb70", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8080, "upload_time": "2014-02-28T14:53:29", "upload_time_iso_8601": "2014-02-28T14:53:29.346696Z", "url": "https://files.pythonhosted.org/packages/a3/9e/d156bd645970778897079f060b1aa26c86c49e1c9fac6ccff8fe65786b80/frules-0.1.0.tar.gz", "yanked": false}], "0.1.1": [{"comment_text": "", "digests": {"md5": "ea73133c60a9874e955085b46316b5ff", "sha256": "68879770bd9d412f07b30eadc7e3a7fd69c82f25b5b2c956127ec406045d4606"}, "downloads": -1, "filename": "frules-0.1.1.tar.gz", "has_sig": false, "md5_digest": "ea73133c60a9874e955085b46316b5ff", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 8532, "upload_time": "2014-05-16T15:04:18", "upload_time_iso_8601": "2014-05-16T15:04:18.991393Z", "url": "https://files.pythonhosted.org/packages/89/a1/31bb80c5a140f6368f50b3d34c7c1f3a4423a7c0b5e78504ac71c6704257/frules-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "540441f77adc2b9fb451f932090451d1", "sha256": "74a8b27ed3f3dba25583c0678831cbd28147b02874c899397f0678cfbbce6761"}, "downloads": -1, "filename": "frules-0.1.2.tar.gz", "has_sig": false, "md5_digest": "540441f77adc2b9fb451f932090451d1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9403, "upload_time": "2015-06-19T14:30:25", "upload_time_iso_8601": "2015-06-19T14:30:25.759777Z", "url": "https://files.pythonhosted.org/packages/12/ee/f8ab2adfcd67744311fe43c775d21489a1a3ca31ece509135e29099f4ae7/frules-0.1.2.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "540441f77adc2b9fb451f932090451d1", "sha256": "74a8b27ed3f3dba25583c0678831cbd28147b02874c899397f0678cfbbce6761"}, "downloads": -1, "filename": "frules-0.1.2.tar.gz", "has_sig": false, "md5_digest": "540441f77adc2b9fb451f932090451d1", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 9403, "upload_time": "2015-06-19T14:30:25", "upload_time_iso_8601": "2015-06-19T14:30:25.759777Z", "url": "https://files.pythonhosted.org/packages/12/ee/f8ab2adfcd67744311fe43c775d21489a1a3ca31ece509135e29099f4ae7/frules-0.1.2.tar.gz", "yanked": false}], "timestamp": "Fri May  8 01:00:08 2020"}