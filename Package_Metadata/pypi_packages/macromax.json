{"info": {"author": "Tom Vettenburg", "author_email": "t.vettenburg@dundee.ac.uk", "bugtrack_url": null, "classifiers": ["Development Status :: 5 - Production/Stable", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Topic :: Scientific/Engineering :: Physics"], "description": "Macroscopic Maxwell Solver\n==========================\n\nIntroduction\n------------\n\nThis Python 3 module enables solving the macroscopic Maxwell equations\nin complex dielectric materials.\n\nThe material properties are defined on a rectangular grid (1D, 2D, or\n3D) for which each voxel defines an isotropic or anistropic\npermittivity. Optionally, a heterogeneous (anisotropic) permeability as\nwell as bi-anisotropic coupling factors may be specified (e.g. for\nchiral media). The source, such as an incident laser field, is specified\nas an oscillating current-density distribution.\n\nThe method iteratively corrects an estimated solution for the electric\nfield (default: all zero). Its memory requirements are on the order of\nthe storage requirements for the material properties and the electric\nfield within the calculation volume. Full details can be found in the\n`open-access <https://doi.org/10.1364/OE.27.011946>`__ manuscript\n`\"Calculating coherent light-wave propagation in large heterogeneous\nmedia.\" <https://doi.org/10.1364/OE.27.011946>`__\n\n**`MIT License <https://opensource.org/licenses/MIT>`__:\nhttps://opensource.org/licenses/MIT**\n\nInstallation\n------------\n\nPrerequisites\n~~~~~~~~~~~~~\n\n| This library requires Python 3 with the modules ``numpy`` and\n  ``scipy`` for the main calculations. These modules will be\n  automatically installed.\n| From the core library, the modules ``sys``, ``io``, and ``os`` are\n  imported; as well as the modules ``logging`` and ``time`` for\n  diagnostics.\n| The ``multiprocessing`` and ``pyfftw`` modules can help speed up the\n  calculations.\n\n| The examples require ``matplotlib`` for displaying the results.\n| The ``pypandoc`` module is required for translating this document to\n  other formats.\n\nThe code has been tested on Python 3.6.\n\nInstalling\n~~~~~~~~~~\n\nInstalling the ``macromax`` module and its dependencies can be done by\nrunning the following command in a terminal:\n\n.. code:: sh\n\n    pip install macromax\n\nThe module comes with a submodule containing example code.\n\n| The ``pypandoc`` module requires the separate installation of\n  ``pandoc``. Please refer to:\n| https://pypi.org/project/pypandoc/ for instructions on its\n  installation for your operating system of choice.\n\nUsage\n-----\n\nThe basic calculation procedure consists of the following steps:\n\n#. define the material\n\n#. define the coherent light source\n\n#. call ``solution = macromax.solve(...)``\n\n#. display the solution\n\nThe ``macromax`` module must be imported to be able to use the ``solve``\nfunction. The module also contains several utility functions that may\nhelp in defining the property and source distributions.\n\nLoading the Python 3 module\n~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe ``macromax`` module can be imported using:\n\n.. code:: python\n\n    import macromax\n\n| **Optional:**\n| If the module is installed without a package manager, it may not be on\n  Python's search path.\n| If necessary, add the library to Python's search path, e.g. using:\n\n.. code:: python\n\n    import sys\n    import os\n    sys.path.append(os.path.dirname(os.getcwd()))\n\nReminder: this library module requires Python 3, ``numpy``, and\n``scipy``. Optionally, ``pyfftw`` can be used to speed up the\ncalculations. The examples also require ``matplotlib``.\n\nSpecifying the material\n~~~~~~~~~~~~~~~~~~~~~~~\n\nDefining the sampling grid\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe material properties are sampled on a plaid uniform rectangular grid\nof voxels. The sample points are defined by one or more linearly\nincreasing coordinate ranges, one range per dimensions. The coordinates\nmust be specified in meters, e.g.:\n\n.. code:: python\n\n    x_range = 50e-9 * np.arange(1000)\n\n| Ranges for multiple dimensions can be passed to ``solve(...)`` as a\n  tuple of ranges:\n| ``ranges = (x_range, y_range)``, or the convenience function\n  ``utils.calc_ranges`` can be used as follows:\n\n.. code:: python\n\n    from macromax import utils\n    data_shape = (200, 400)\n    sample_pitch = 50e-9  # or (50e-9, 50e-9)\n    ranges = utils.calc_ranges(data_shape, sample_pitch)\n\nDefining the material property distributions\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nThe material properties are defined by ndarrays of 2+N dimensions, where\nN can be up to 3 for three-dimensional samples. In each sample point, or\nvoxel, a complex 3x3 matrix defines the anisotropy at that point in the\nsample volume. The first two dimensions of the ndarray are used to store\nthe 3x3 matrix, the following dimensions are the spatial indices x, y,\nand z. Four complex ndarrays can be specified: ``epsilon``, ``mu``,\n``xi``, and ``zeta``. These ndarrays represent the permittivity,\npermeability, and the two coupling factors, respectively.\n\n| When the first two dimensions of a property are found to be both a\n  singleton, i.e. 1x1, that property is assumed to be isotropic.\n  Similarly, singleton spatial dimensions are interpreted as homogeneity\n  in that property.\n| The default permeability ``mu`` is 1, and the coupling contants are\n  zero by default.\n\nBoundary conditions\n'''''''''''''''''''\n\n| The underlying algorithm assumes `periodic boundary\n  conditions <https://en.wikipedia.org/wiki/Periodic_boundary_conditions>`__.\n| Alternative boundary conditions can be implemented by surrounding the\n  calculation area with absorbing (or reflective) layers.\n| Back reflections can be suppressed by e.g. linearly increasing the\n  imaginary part of the permittivity with depth into a boundary with a\n  thickness of a few wavelengths.\n\nDefining the source\n~~~~~~~~~~~~~~~~~~~\n\n| The coherent source is defined by an oscillating current density, to\n  model e.g. an incident laser beam.\n| It is sufficient to define its phase, amplitude, and the direction as\n  a function the spatial coordinates; alongside the angular frequency,\n  omega, of the coherent source.\n| To avoid issues with numerical precision, the current density is\n  multiplied by the angular frequency, omega, and the vacuum\n  permeability, mu\\_0. The source values is proportional to the current\n  density, J, and related as follows: S = i omega mu\\_0 J with units of\n  rad s^-1 H m^-1 A m^-2 = rad V m^-3.\n\nThe source distribution is stored as a complex ndarray with 1+N\ndimensions. The first dimension contains the current 3D direction and\namplitude for each voxel. The complex argument indicates the relative\nphase at each voxel.\n\nCalculating the electromagnetic light field\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nOnce the ``macromax`` module is imported, the solution satisfying the\nmacroscopic Maxwell's equations is calculated by calling:\n\n.. code:: python\n\n    solution = macromax.solve(...)\n\nThe function arguments to ``macromax.solve(...)`` can be the following:\n\n-  ``x_range|ranges``: A vector (1D) or tuple of vectors (2D, or 3D)\n   indicating the spatial coordinates of the sample points. Each vector\n   must be a uniformly increasing array of coordinates, sufficiently\n   dense to avoid aliasing artefacts.\n\n-  ``vacuum_wavelength|wave_number|anguler_frequency``: The wavelength\n   in vacuum of the coherent illumination in units of meters.\n\n-  ``source_distribution``: An ndarray of complex values indicating the\n   source value and direction at each sample point. The source values\n   define the current density in the sample. The first dimension\n   contains the vector index, the following dimensions contain the\n   spatial dimensions.\n\n-  ``epsilon``: A complex ndarray that defines the 3x3 permittivity\n   matrix at all sample points. The first two dimensions contain the\n   matrix indices, the following dimensions contain the spatial\n   dimensions.\n\nAnisotropic material properties such as permittivity can be defined as a\nsquare 3x3 matrix at each sample point. Isotropic materials may be\nrepresented by 1x1 scalars instead (the first two dimensions are\nsingletons). Homogeneous materials may be specified with spatial\nsingleton dimensions.\n\nOptionally one can also specify magnetic and coupling factors:\n\n-  ``mu``: A complex ndarray that defines the 3x3 permeability matrix at\n   all sample points. The first two dimensions contain the matrix\n   indices, the following dimensions contain the spatial dimensions.\n\n-  ``xi`` and ``zeta``: Complex ndarray that define the 3x3 coupling\n   matrices at all sample points. This may be useful to model chiral\n   materials. The first two dimensions contain the matrix indices, the\n   following dimensions contain the spatial dimensions.\n\nIt is often useful to also specify a callback function that tracks\nprogress. This can be done by defining the ``callback``-argument as a\nfunction that takes an intermediate solution as argument. This\nuser-defined callback function can display the intermediate solution and\ncheck if the convergence is adequate. The callback function should\nreturn ``True`` if more iterations are required, and ``False``\notherwise. E.g.:\n\n.. code:: python\n\n    callback=lambda s: s.iteration < 1e4 and s.residue > 1e-4\n\nThe solution object (of the Solution class) fully defines the state of\nthe iteration and the current solution as described below.\n\nThe ``macromax.solve(...)`` function returns a solution object. This\nobject contains the electric field vector distribution as well as\ndiagnostic information such as the number of iterations used and the\nmagnitude of the correction applied in the last iteration. It can also\ncalculate the displacement, magnetizing, and magnetic fields on demand.\nThese fields can be queried as follows:\n\n-  ``solution.E``: Returns the electric field distribution.\n-  ``solution.H``: Returns the magnetizing field distribution.\n-  ``solution.D``: Returns the electric displacement field distribution.\n-  ``solution.B``: Returns the magnetic flux density distribution.\n-  ``solution.S``: The Poynting vector distribution in the sample.\n\nThe field distributions are returned as complex ``numpy`` ndarrays in\nwhich the first dimensions is the polarization or direction index. The\nfollowing dimensions are the spatial dimensions of the problem, e.g. x,\ny, and z, for three-dimensional problems.\n\nThe solution object also keeps track of the iteration itself. It has the\nfollowing diagnostic properties:\n\n-  ``solution.iteration``: The number of iterations performed.\n-  ``solution.residue``: The relative magnitude of the correction during\n   the previous iteration.\n   and it can be used as a Python iterator.\n\nFurther information can be found in the examples and the function and\nclass signature documentation. The examples can be imported using:\n\n.. code:: python\n\n    from macromax import examples\n\nComplete Example\n~~~~~~~~~~~~~~~~\n\n| The following code loads the library, defines the material and light\n  source, calculates the result, and displays it.\n| To keep this example as simple as possible, the calculation is limited\n  to one dimension. Higher dimensional calculations\n| simply require the definition of the material and light source in 2D\n  or 3D.\n\nThe first section of the code loads the ``macromax`` library module as\nwell as its ``utils`` submodule. More\n\n.. code:: python\n\n    import macromax\n\n    import numpy as np\n    import scipy.constants as const\n    import matplotlib.pyplot as plt\n    %matplotlib notebook\n\n    #\n    # Define the material properties\n    #\n    wavelength = 500e-9\n    angular_frequency = 2 * const.pi * const.c / wavelength\n    source_amplitude = 1j * angular_frequency * const.mu_0\n    p_source = np.array([0, 1, 0])  # y-polarized\n\n    # Set the sampling grid\n    nb_samples = 1024\n    sample_pitch = wavelength / 16\n    x_range = sample_pitch * np.arange(nb_samples) - 4e-6\n\n    # define the medium\n    permittivity = np.ones((1, 1, len(x_range)), dtype=np.complex64)\n    # Don't forget absorbing boundary:\n    dist_in_boundary = np.maximum(-(x_range - -1e-6), x_range - 26e-6) / 4e-6\n    permittivity[:, :, (x_range < -1e-6) | (x_range > 26e-6)] = \\\n        1.0 + (0.8j * dist_in_boundary[(x_range < -1e-6) | (x_range > 26e-6)])\n    # glass has a refractive index of about 1.5\n    permittivity[:, :, (x_range >= 10e-6) & (x_range < 20e-6)] = 1.5 ** 2\n\n    #\n    # Define the illumination source\n    #\n    # point source at x = 0\n    source = -source_amplitude * sample_pitch * (np.abs(x_range) < sample_pitch/4)\n    source = p_source[:, np.newaxis] * source[np.newaxis, :]\n\n    #\n    # Solve Maxwell's equations\n    #\n    # (the actual work is done in this line)\n    solution = macromax.solve(x_range, vacuum_wavelength=wavelength,\n        source_distribution=source, epsilon=permittivity)\n\n    #\n    # Display the results\n    #\n    fig, ax = plt.subplots(2, 1, frameon=False, figsize=(8, 6))\n\n    x_range = solution.ranges[0]  # coordinates\n    E = solution.E[1, :]  # Electric field\n    H = solution.H[2, :]  # Magnetizing field\n    S = solution.S[0, :]  # Poynting vector\n    f = solution.f[0, :]  # Optical force\n    # Display the field for the polarization dimension\n    field_to_display = angular_frequency * E\n    max_val_to_display = np.maximum(np.max(np.abs(field_to_display)),\n                                    np.finfo(field_to_display.dtype).eps)\n    poynting_normalization = np.max(np.abs(S)) / max_val_to_display\n    ax[0].plot(x_range * 1e6,\n               np.abs(field_to_display) ** 2 / max_val_to_display,\n               color=[0, 0, 0])[0]\n    ax[0].plot(x_range * 1e6, np.real(S) / poynting_normalization,\n               color=[1, 0, 1])[0]\n    ax[0].plot(x_range * 1e6, np.real(field_to_display),\n               color=[0, 0.7, 0])[0]\n    ax[0].plot(x_range * 1e6, np.imag(field_to_display),\n               color=[1, 0, 0])[0]\n    figure_title = \"Iteration %d, \" % solution.iteration\n    ax[0].set_title(figure_title)\n    ax[0].set_xlabel(\"x  [$\\mu$m]\")\n    ax[0].set_ylabel(\"I, E  [a.u.]\")\n    ax[0].set_xlim(x_range[[0, -1]] * 1e6)\n\n    ax[1].plot(x_range[-1] * 2e6, 0,\n               color=[0, 0, 0], label='I')\n    ax[1].plot(x_range[-1] * 2e6, 0,\n               color=[1, 0, 1], label='$S_{real}$')\n    ax[1].plot(x_range[-1] * 2e6, 0,\n               color=[0, 0.7, 0], label='$E_{real}$')\n    ax[1].plot(x_range[-1] * 2e6, 0,\n               color=[1, 0, 0], label='$E_{imag}$')\n    ax[1].plot(x_range * 1e6, permittivity[0, 0].real,\n               color=[0, 0, 1], label='$\\epsilon_{real}$')\n    ax[1].plot(x_range * 1e6, permittivity[0, 0].imag,\n               color=[0, 0.5, 0.5], label='$\\epsilon_{imag}$')\n    ax[1].set_xlabel('x  [$\\mu$m]')\n    ax[1].set_ylabel('$\\epsilon$, $\\mu$')\n    ax[1].set_xlim(x_range[[0, -1]] * 1e6)\n    ax[1].legend(loc='upper right')\n\nDevelopment\n-----------\n\nSource code organization\n~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe source code is organized as follows:\n\n-  ``/`` (root): Module description and distribution files.\n\n-  ``/macromax``: The iterative solver.\n\n-  ``/macromax/examples``: Examples of how the solver can be used.\n\n-  ``/macromax/tests``: Automated unit tests of the solver's\n   functionality. Use this after making modifications to the solver and\n   extend it if new functionality is added.\n\nThe library functions are contained in ``/macromax``:\n\n-  ``solver``: Defines the ``solve(...)`` function and the ``Solution``\n   class.\n\n-  ``parallel_ops_column``: Defines linear algebra functions to work\n   efficiently with large arrays of 3x3 matrices and 3-vectors.\n\n-  ``utils``: Defines utility functions that can be used to prepare and\n   interpret function arguments.\n\nThe included examples in the ``/macromax/examples`` folder are:\n\n-  ``notebook_example.ipynb``: An iPython notebook demonstrating basic\n   usage of the library.\n\n-  ``air_glass_air_1D.py``: Calculation of the back reflection from an\n   air-glass interface (one-dimensional calculation)\n\n-  ``air_glass_air_2D.py``: Calculation of the refraction and reflection\n   of light hitting a glass window at an angle (two-dimensional\n   calculation)\n\n-  ``birefringent_crystal.py``: Demonstration of how an anisotropic\n   permittivity can split a diagonally polarized Gaussian beam into\n   ordinary and extraordinary beams.\n\n-  ``polarizer.py``: Calculation of light wave traversing a set of two\n   and a set of three polarizers as a demonstration of anisotropic\n   absorption (non-Hermitian permittivity)\n\n-  ``rutile.py``: Scattering from disordered collection of birefringent\n   rutile (TiO2) particles.\n\nTesting\n~~~~~~~\n\n| Unit tests are contained in ``macromax/tests``. The\n  ``ParallelOperations`` class in\n| ``parallel_ops_column.pi`` is pretty well covered and some specific\n  tests have been written for\n| the ``Solution`` class in ``solver.py``. However, the ``utils`` module\n  does not have any\n| tests at present.\n\nTo run the tests:\n\n.. code:: sh\n\n    pip install nose\n    python setup.py test\n\nBuilding and Distributing\n~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe code consists of pure Python 3, hence only packaging is required for\ndistribution.\n\nTo prepare a package for distribution, increase the version number in\n``setup.py``, and run:\n\n.. code:: sh\n\n    python setup.py sdist bdist_wheel\n    pip install . --upgrade\n\nThe package can then be uploaded to a test repository as follows:\n\n.. code:: sh\n\n    twine upload --repository-url https://test.pypi.org/legacy/ dist/*\n\nInstalling from the test repository is done as follows:\n\n.. code:: sh\n\n    pip install -i https://test.pypi.org/simple/ macromax\n\nIntelliJ IDEA project files can be found in ``MacroMax/python/``:\n``MacroMax/python/python.iml`` and the folder ``MacroMax/python/.idea``.\n\n\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "", "keywords": "light electromagnetic propagation anisotropy magnetic chiral optics Maxwell scattering heterogeneous", "license": "MIT", "maintainer": "", "maintainer_email": "", "name": "macromax", "package_url": "https://pypi.org/project/macromax/", "platform": "", "project_url": "https://pypi.org/project/macromax/", "project_urls": null, "release_url": "https://pypi.org/project/macromax/0.0.9/", "requires_dist": ["numpy", "scipy"], "requires_python": ">=3", "summary": "Library for solving macroscopic Maxwell's equations for electromagnetic waves in gain-free heterogeneous (bi-)(an)isotropic (non)magnetic materials. This is of particular interest to calculate the light field within complex, scattering, tissues.", "version": "0.0.9", "yanked": false, "html_description": "<div class=\"project-description\">\n            <div id=\"introduction\">\n<h2>Introduction</h2>\n<p>This Python 3 module enables solving the macroscopic Maxwell equations\nin complex dielectric materials.</p>\n<p>The material properties are defined on a rectangular grid (1D, 2D, or\n3D) for which each voxel defines an isotropic or anistropic\npermittivity. Optionally, a heterogeneous (anisotropic) permeability as\nwell as bi-anisotropic coupling factors may be specified (e.g. for\nchiral media). The source, such as an incident laser field, is specified\nas an oscillating current-density distribution.</p>\n<p>The method iteratively corrects an estimated solution for the electric\nfield (default: all zero). Its memory requirements are on the order of\nthe storage requirements for the material properties and the electric\nfield within the calculation volume. Full details can be found in the\n<a href=\"https://doi.org/10.1364/OE.27.011946\" rel=\"nofollow\">open-access</a> manuscript\n<a href=\"https://doi.org/10.1364/OE.27.011946\" rel=\"nofollow\">\u201cCalculating coherent light-wave propagation in large heterogeneous\nmedia.\u201d</a></p>\n<p><strong>`MIT License &lt;https://opensource.org/licenses/MIT&gt;`__:\nhttps://opensource.org/licenses/MIT</strong></p>\n</div>\n<div id=\"installation\">\n<h2>Installation</h2>\n<div id=\"prerequisites\">\n<h3>Prerequisites</h3>\n<div>\n<div>This library requires Python 3 with the modules <tt>numpy</tt> and\n<tt>scipy</tt> for the main calculations. These modules will be\nautomatically installed.</div>\n<div>From the core library, the modules <tt>sys</tt>, <tt>io</tt>, and <tt>os</tt> are\nimported; as well as the modules <tt>logging</tt> and <tt>time</tt> for\ndiagnostics.</div>\n<div>The <tt>multiprocessing</tt> and <tt>pyfftw</tt> modules can help speed up the\ncalculations.</div>\n</div>\n<div>\n<div>The examples require <tt>matplotlib</tt> for displaying the results.</div>\n<div>The <tt>pypandoc</tt> module is required for translating this document to\nother formats.</div>\n</div>\n<p>The code has been tested on Python 3.6.</p>\n</div>\n<div id=\"installing\">\n<h3>Installing</h3>\n<p>Installing the <tt>macromax</tt> module and its dependencies can be done by\nrunning the following command in a terminal:</p>\n<pre>pip install macromax\n</pre>\n<p>The module comes with a submodule containing example code.</p>\n<div>\n<div>The <tt>pypandoc</tt> module requires the separate installation of\n<tt>pandoc</tt>. Please refer to:</div>\n<div><a href=\"https://pypi.org/project/pypandoc/\" rel=\"nofollow\">https://pypi.org/project/pypandoc/</a> for instructions on its\ninstallation for your operating system of choice.</div>\n</div>\n</div>\n</div>\n<div id=\"usage\">\n<h2>Usage</h2>\n<p>The basic calculation procedure consists of the following steps:</p>\n<ol>\n<li>define the material</li>\n<li>define the coherent light source</li>\n<li>call <tt>solution = <span class=\"pre\">macromax.solve(...)</span></tt></li>\n<li>display the solution</li>\n</ol>\n<p>The <tt>macromax</tt> module must be imported to be able to use the <tt>solve</tt>\nfunction. The module also contains several utility functions that may\nhelp in defining the property and source distributions.</p>\n<div id=\"loading-the-python-3-module\">\n<h3>Loading the Python 3 module</h3>\n<p>The <tt>macromax</tt> module can be imported using:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">macromax</span>\n</pre>\n<div>\n<div><strong>Optional:</strong></div>\n<div>If the module is installed without a package manager, it may not be on\nPython\u2019s search path.</div>\n<div>If necessary, add the library to Python\u2019s search path, e.g. using:</div>\n</div>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">sys</span>\n<span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"n\">sys</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"n\">dirname</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"o\">.</span><span class=\"n\">getcwd</span><span class=\"p\">()))</span>\n</pre>\n<p>Reminder: this library module requires Python 3, <tt>numpy</tt>, and\n<tt>scipy</tt>. Optionally, <tt>pyfftw</tt> can be used to speed up the\ncalculations. The examples also require <tt>matplotlib</tt>.</p>\n</div>\n<div id=\"specifying-the-material\">\n<h3>Specifying the material</h3>\n<div id=\"defining-the-sampling-grid\">\n<h4>Defining the sampling grid</h4>\n<p>The material properties are sampled on a plaid uniform rectangular grid\nof voxels. The sample points are defined by one or more linearly\nincreasing coordinate ranges, one range per dimensions. The coordinates\nmust be specified in meters, e.g.:</p>\n<pre><span class=\"n\">x_range</span> <span class=\"o\">=</span> <span class=\"mf\">50e-9</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">)</span>\n</pre>\n<div>\n<div>Ranges for multiple dimensions can be passed to <tt><span class=\"pre\">solve(...)</span></tt> as a\ntuple of ranges:</div>\n<div><tt>ranges = (x_range, y_range)</tt>, or the convenience function\n<tt>utils.calc_ranges</tt> can be used as follows:</div>\n</div>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">macromax</span> <span class=\"kn\">import</span> <span class=\"n\">utils</span>\n<span class=\"n\">data_shape</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"mi\">400</span><span class=\"p\">)</span>\n<span class=\"n\">sample_pitch</span> <span class=\"o\">=</span> <span class=\"mf\">50e-9</span>  <span class=\"c1\"># or (50e-9, 50e-9)</span>\n<span class=\"n\">ranges</span> <span class=\"o\">=</span> <span class=\"n\">utils</span><span class=\"o\">.</span><span class=\"n\">calc_ranges</span><span class=\"p\">(</span><span class=\"n\">data_shape</span><span class=\"p\">,</span> <span class=\"n\">sample_pitch</span><span class=\"p\">)</span>\n</pre>\n</div>\n<div id=\"defining-the-material-property-distributions\">\n<h4>Defining the material property distributions</h4>\n<p>The material properties are defined by ndarrays of 2+N dimensions, where\nN can be up to 3 for three-dimensional samples. In each sample point, or\nvoxel, a complex 3x3 matrix defines the anisotropy at that point in the\nsample volume. The first two dimensions of the ndarray are used to store\nthe 3x3 matrix, the following dimensions are the spatial indices x, y,\nand z. Four complex ndarrays can be specified: <tt>epsilon</tt>, <tt>mu</tt>,\n<tt>xi</tt>, and <tt>zeta</tt>. These ndarrays represent the permittivity,\npermeability, and the two coupling factors, respectively.</p>\n<div>\n<div>When the first two dimensions of a property are found to be both a\nsingleton, i.e. 1x1, that property is assumed to be isotropic.\nSimilarly, singleton spatial dimensions are interpreted as homogeneity\nin that property.</div>\n<div>The default permeability <tt>mu</tt> is 1, and the coupling contants are\nzero by default.</div>\n</div>\n<div id=\"boundary-conditions\">\n<h5>Boundary conditions</h5>\n<div>\n<div>The underlying algorithm assumes <a href=\"https://en.wikipedia.org/wiki/Periodic_boundary_conditions\" rel=\"nofollow\">periodic boundary\nconditions</a>.</div>\n<div>Alternative boundary conditions can be implemented by surrounding the\ncalculation area with absorbing (or reflective) layers.</div>\n<div>Back reflections can be suppressed by e.g. linearly increasing the\nimaginary part of the permittivity with depth into a boundary with a\nthickness of a few wavelengths.</div>\n</div>\n</div>\n</div>\n</div>\n<div id=\"defining-the-source\">\n<h3>Defining the source</h3>\n<div>\n<div>The coherent source is defined by an oscillating current density, to\nmodel e.g. an incident laser beam.</div>\n<div>It is sufficient to define its phase, amplitude, and the direction as\na function the spatial coordinates; alongside the angular frequency,\nomega, of the coherent source.</div>\n<div>To avoid issues with numerical precision, the current density is\nmultiplied by the angular frequency, omega, and the vacuum\npermeability, mu_0. The source values is proportional to the current\ndensity, J, and related as follows: S = i omega mu_0 J with units of\nrad s^-1 H m^-1 A m^-2 = rad V m^-3.</div>\n</div>\n<p>The source distribution is stored as a complex ndarray with 1+N\ndimensions. The first dimension contains the current 3D direction and\namplitude for each voxel. The complex argument indicates the relative\nphase at each voxel.</p>\n</div>\n<div id=\"calculating-the-electromagnetic-light-field\">\n<h3>Calculating the electromagnetic light field</h3>\n<p>Once the <tt>macromax</tt> module is imported, the solution satisfying the\nmacroscopic Maxwell\u2019s equations is calculated by calling:</p>\n<pre><span class=\"n\">solution</span> <span class=\"o\">=</span> <span class=\"n\">macromax</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n</pre>\n<p>The function arguments to <tt><span class=\"pre\">macromax.solve(...)</span></tt> can be the following:</p>\n<ul>\n<li><tt>x_range|ranges</tt>: A vector (1D) or tuple of vectors (2D, or 3D)\nindicating the spatial coordinates of the sample points. Each vector\nmust be a uniformly increasing array of coordinates, sufficiently\ndense to avoid aliasing artefacts.</li>\n<li><tt>vacuum_wavelength|wave_number|anguler_frequency</tt>: The wavelength\nin vacuum of the coherent illumination in units of meters.</li>\n<li><tt>source_distribution</tt>: An ndarray of complex values indicating the\nsource value and direction at each sample point. The source values\ndefine the current density in the sample. The first dimension\ncontains the vector index, the following dimensions contain the\nspatial dimensions.</li>\n<li><tt>epsilon</tt>: A complex ndarray that defines the 3x3 permittivity\nmatrix at all sample points. The first two dimensions contain the\nmatrix indices, the following dimensions contain the spatial\ndimensions.</li>\n</ul>\n<p>Anisotropic material properties such as permittivity can be defined as a\nsquare 3x3 matrix at each sample point. Isotropic materials may be\nrepresented by 1x1 scalars instead (the first two dimensions are\nsingletons). Homogeneous materials may be specified with spatial\nsingleton dimensions.</p>\n<p>Optionally one can also specify magnetic and coupling factors:</p>\n<ul>\n<li><tt>mu</tt>: A complex ndarray that defines the 3x3 permeability matrix at\nall sample points. The first two dimensions contain the matrix\nindices, the following dimensions contain the spatial dimensions.</li>\n<li><tt>xi</tt> and <tt>zeta</tt>: Complex ndarray that define the 3x3 coupling\nmatrices at all sample points. This may be useful to model chiral\nmaterials. The first two dimensions contain the matrix indices, the\nfollowing dimensions contain the spatial dimensions.</li>\n</ul>\n<p>It is often useful to also specify a callback function that tracks\nprogress. This can be done by defining the <tt>callback</tt>-argument as a\nfunction that takes an intermediate solution as argument. This\nuser-defined callback function can display the intermediate solution and\ncheck if the convergence is adequate. The callback function should\nreturn <tt>True</tt> if more iterations are required, and <tt>False</tt>\notherwise. E.g.:</p>\n<pre><span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"k\">lambda</span> <span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">iteration</span> <span class=\"o\">&lt;</span> <span class=\"mf\">1e4</span> <span class=\"ow\">and</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"n\">residue</span> <span class=\"o\">&gt;</span> <span class=\"mf\">1e-4</span>\n</pre>\n<p>The solution object (of the Solution class) fully defines the state of\nthe iteration and the current solution as described below.</p>\n<p>The <tt><span class=\"pre\">macromax.solve(...)</span></tt> function returns a solution object. This\nobject contains the electric field vector distribution as well as\ndiagnostic information such as the number of iterations used and the\nmagnitude of the correction applied in the last iteration. It can also\ncalculate the displacement, magnetizing, and magnetic fields on demand.\nThese fields can be queried as follows:</p>\n<ul>\n<li><tt>solution.E</tt>: Returns the electric field distribution.</li>\n<li><tt>solution.H</tt>: Returns the magnetizing field distribution.</li>\n<li><tt>solution.D</tt>: Returns the electric displacement field distribution.</li>\n<li><tt>solution.B</tt>: Returns the magnetic flux density distribution.</li>\n<li><tt>solution.S</tt>: The Poynting vector distribution in the sample.</li>\n</ul>\n<p>The field distributions are returned as complex <tt>numpy</tt> ndarrays in\nwhich the first dimensions is the polarization or direction index. The\nfollowing dimensions are the spatial dimensions of the problem, e.g. x,\ny, and z, for three-dimensional problems.</p>\n<p>The solution object also keeps track of the iteration itself. It has the\nfollowing diagnostic properties:</p>\n<ul>\n<li><tt>solution.iteration</tt>: The number of iterations performed.</li>\n<li><tt>solution.residue</tt>: The relative magnitude of the correction during\nthe previous iteration.\nand it can be used as a Python iterator.</li>\n</ul>\n<p>Further information can be found in the examples and the function and\nclass signature documentation. The examples can be imported using:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">macromax</span> <span class=\"kn\">import</span> <span class=\"n\">examples</span>\n</pre>\n</div>\n<div id=\"complete-example\">\n<h3>Complete Example</h3>\n<div>\n<div>The following code loads the library, defines the material and light\nsource, calculates the result, and displays it.</div>\n<div>To keep this example as simple as possible, the calculation is limited\nto one dimension. Higher dimensional calculations</div>\n<div>simply require the definition of the material and light source in 2D\nor 3D.</div>\n</div>\n<p>The first section of the code loads the <tt>macromax</tt> library module as\nwell as its <tt>utils</tt> submodule. More</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">macromax</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">scipy.constants</span> <span class=\"k\">as</span> <span class=\"nn\">const</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"o\">%</span><span class=\"n\">matplotlib</span> <span class=\"n\">notebook</span>\n\n<span class=\"c1\">#</span>\n<span class=\"c1\"># Define the material properties</span>\n<span class=\"c1\">#</span>\n<span class=\"n\">wavelength</span> <span class=\"o\">=</span> <span class=\"mf\">500e-9</span>\n<span class=\"n\">angular_frequency</span> <span class=\"o\">=</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">const</span><span class=\"o\">.</span><span class=\"n\">pi</span> <span class=\"o\">*</span> <span class=\"n\">const</span><span class=\"o\">.</span><span class=\"n\">c</span> <span class=\"o\">/</span> <span class=\"n\">wavelength</span>\n<span class=\"n\">source_amplitude</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"n\">j</span> <span class=\"o\">*</span> <span class=\"n\">angular_frequency</span> <span class=\"o\">*</span> <span class=\"n\">const</span><span class=\"o\">.</span><span class=\"n\">mu_0</span>\n<span class=\"n\">p_source</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])</span>  <span class=\"c1\"># y-polarized</span>\n\n<span class=\"c1\"># Set the sampling grid</span>\n<span class=\"n\">nb_samples</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span>\n<span class=\"n\">sample_pitch</span> <span class=\"o\">=</span> <span class=\"n\">wavelength</span> <span class=\"o\">/</span> <span class=\"mi\">16</span>\n<span class=\"n\">x_range</span> <span class=\"o\">=</span> <span class=\"n\">sample_pitch</span> <span class=\"o\">*</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"n\">nb_samples</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mf\">4e-6</span>\n\n<span class=\"c1\"># define the medium</span>\n<span class=\"n\">permittivity</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ones</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">x_range</span><span class=\"p\">)),</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">complex64</span><span class=\"p\">)</span>\n<span class=\"c1\"># Don't forget absorbing boundary:</span>\n<span class=\"n\">dist_in_boundary</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">maximum</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"p\">(</span><span class=\"n\">x_range</span> <span class=\"o\">-</span> <span class=\"o\">-</span><span class=\"mf\">1e-6</span><span class=\"p\">),</span> <span class=\"n\">x_range</span> <span class=\"o\">-</span> <span class=\"mf\">26e-6</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mf\">4e-6</span>\n<span class=\"n\">permittivity</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"p\">(</span><span class=\"n\">x_range</span> <span class=\"o\">&lt;</span> <span class=\"o\">-</span><span class=\"mf\">1e-6</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"p\">(</span><span class=\"n\">x_range</span> <span class=\"o\">&gt;</span> <span class=\"mf\">26e-6</span><span class=\"p\">)]</span> <span class=\"o\">=</span> \\\n    <span class=\"mf\">1.0</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"mf\">0.8</span><span class=\"n\">j</span> <span class=\"o\">*</span> <span class=\"n\">dist_in_boundary</span><span class=\"p\">[(</span><span class=\"n\">x_range</span> <span class=\"o\">&lt;</span> <span class=\"o\">-</span><span class=\"mf\">1e-6</span><span class=\"p\">)</span> <span class=\"o\">|</span> <span class=\"p\">(</span><span class=\"n\">x_range</span> <span class=\"o\">&gt;</span> <span class=\"mf\">26e-6</span><span class=\"p\">)])</span>\n<span class=\"c1\"># glass has a refractive index of about 1.5</span>\n<span class=\"n\">permittivity</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"p\">(</span><span class=\"n\">x_range</span> <span class=\"o\">&gt;=</span> <span class=\"mf\">10e-6</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"p\">(</span><span class=\"n\">x_range</span> <span class=\"o\">&lt;</span> <span class=\"mf\">20e-6</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"mf\">1.5</span> <span class=\"o\">**</span> <span class=\"mi\">2</span>\n\n<span class=\"c1\">#</span>\n<span class=\"c1\"># Define the illumination source</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># point source at x = 0</span>\n<span class=\"n\">source</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">source_amplitude</span> <span class=\"o\">*</span> <span class=\"n\">sample_pitch</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">abs</span><span class=\"p\">(</span><span class=\"n\">x_range</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">sample_pitch</span><span class=\"o\">/</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n<span class=\"n\">source</span> <span class=\"o\">=</span> <span class=\"n\">p_source</span><span class=\"p\">[:,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">newaxis</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">source</span><span class=\"p\">[</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">newaxis</span><span class=\"p\">,</span> <span class=\"p\">:]</span>\n\n<span class=\"c1\">#</span>\n<span class=\"c1\"># Solve Maxwell's equations</span>\n<span class=\"c1\">#</span>\n<span class=\"c1\"># (the actual work is done in this line)</span>\n<span class=\"n\">solution</span> <span class=\"o\">=</span> <span class=\"n\">macromax</span><span class=\"o\">.</span><span class=\"n\">solve</span><span class=\"p\">(</span><span class=\"n\">x_range</span><span class=\"p\">,</span> <span class=\"n\">vacuum_wavelength</span><span class=\"o\">=</span><span class=\"n\">wavelength</span><span class=\"p\">,</span>\n    <span class=\"n\">source_distribution</span><span class=\"o\">=</span><span class=\"n\">source</span><span class=\"p\">,</span> <span class=\"n\">epsilon</span><span class=\"o\">=</span><span class=\"n\">permittivity</span><span class=\"p\">)</span>\n\n<span class=\"c1\">#</span>\n<span class=\"c1\"># Display the results</span>\n<span class=\"c1\">#</span>\n<span class=\"n\">fig</span><span class=\"p\">,</span> <span class=\"n\">ax</span> <span class=\"o\">=</span> <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">subplots</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">frameon</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"mi\">6</span><span class=\"p\">))</span>\n\n<span class=\"n\">x_range</span> <span class=\"o\">=</span> <span class=\"n\">solution</span><span class=\"o\">.</span><span class=\"n\">ranges</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># coordinates</span>\n<span class=\"n\">E</span> <span class=\"o\">=</span> <span class=\"n\">solution</span><span class=\"o\">.</span><span class=\"n\">E</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">:]</span>  <span class=\"c1\"># Electric field</span>\n<span class=\"n\">H</span> <span class=\"o\">=</span> <span class=\"n\">solution</span><span class=\"o\">.</span><span class=\"n\">H</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">:]</span>  <span class=\"c1\"># Magnetizing field</span>\n<span class=\"n\">S</span> <span class=\"o\">=</span> <span class=\"n\">solution</span><span class=\"o\">.</span><span class=\"n\">S</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">:]</span>  <span class=\"c1\"># Poynting vector</span>\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">solution</span><span class=\"o\">.</span><span class=\"n\">f</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">:]</span>  <span class=\"c1\"># Optical force</span>\n<span class=\"c1\"># Display the field for the polarization dimension</span>\n<span class=\"n\">field_to_display</span> <span class=\"o\">=</span> <span class=\"n\">angular_frequency</span> <span class=\"o\">*</span> <span class=\"n\">E</span>\n<span class=\"n\">max_val_to_display</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">maximum</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">abs</span><span class=\"p\">(</span><span class=\"n\">field_to_display</span><span class=\"p\">)),</span>\n                                <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">finfo</span><span class=\"p\">(</span><span class=\"n\">field_to_display</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">eps</span><span class=\"p\">)</span>\n<span class=\"n\">poynting_normalization</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">abs</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">))</span> <span class=\"o\">/</span> <span class=\"n\">max_val_to_display</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x_range</span> <span class=\"o\">*</span> <span class=\"mf\">1e6</span><span class=\"p\">,</span>\n           <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">abs</span><span class=\"p\">(</span><span class=\"n\">field_to_display</span><span class=\"p\">)</span> <span class=\"o\">**</span> <span class=\"mi\">2</span> <span class=\"o\">/</span> <span class=\"n\">max_val_to_display</span><span class=\"p\">,</span>\n           <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x_range</span> <span class=\"o\">*</span> <span class=\"mf\">1e6</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">real</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"n\">poynting_normalization</span><span class=\"p\">,</span>\n           <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">])[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x_range</span> <span class=\"o\">*</span> <span class=\"mf\">1e6</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">real</span><span class=\"p\">(</span><span class=\"n\">field_to_display</span><span class=\"p\">),</span>\n           <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x_range</span> <span class=\"o\">*</span> <span class=\"mf\">1e6</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">imag</span><span class=\"p\">(</span><span class=\"n\">field_to_display</span><span class=\"p\">),</span>\n           <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">])[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">figure_title</span> <span class=\"o\">=</span> <span class=\"s2\">\"Iteration </span><span class=\"si\">%d</span><span class=\"s2\">, \"</span> <span class=\"o\">%</span> <span class=\"n\">solution</span><span class=\"o\">.</span><span class=\"n\">iteration</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_title</span><span class=\"p\">(</span><span class=\"n\">figure_title</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_xlabel</span><span class=\"p\">(</span><span class=\"s2\">\"x  [$\\mu$m]\"</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_ylabel</span><span class=\"p\">(</span><span class=\"s2\">\"I, E  [a.u.]\"</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_xlim</span><span class=\"p\">(</span><span class=\"n\">x_range</span><span class=\"p\">[[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]</span> <span class=\"o\">*</span> <span class=\"mf\">1e6</span><span class=\"p\">)</span>\n\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x_range</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"mf\">2e6</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n           <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">'I'</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x_range</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"mf\">2e6</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n           <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">'$S_</span><span class=\"si\">{real}</span><span class=\"s1\">$'</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x_range</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"mf\">2e6</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n           <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">'$E_</span><span class=\"si\">{real}</span><span class=\"s1\">$'</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x_range</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"mf\">2e6</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span>\n           <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">'$E_</span><span class=\"si\">{imag}</span><span class=\"s1\">$'</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x_range</span> <span class=\"o\">*</span> <span class=\"mf\">1e6</span><span class=\"p\">,</span> <span class=\"n\">permittivity</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">real</span><span class=\"p\">,</span>\n           <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">'$\\epsilon_</span><span class=\"si\">{real}</span><span class=\"s1\">$'</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x_range</span> <span class=\"o\">*</span> <span class=\"mf\">1e6</span><span class=\"p\">,</span> <span class=\"n\">permittivity</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">imag</span><span class=\"p\">,</span>\n           <span class=\"n\">color</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"p\">],</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">'$\\epsilon_</span><span class=\"si\">{imag}</span><span class=\"s1\">$'</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_xlabel</span><span class=\"p\">(</span><span class=\"s1\">'x  [$\\mu$m]'</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_ylabel</span><span class=\"p\">(</span><span class=\"s1\">'$\\epsilon$, $\\mu$'</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">set_xlim</span><span class=\"p\">(</span><span class=\"n\">x_range</span><span class=\"p\">[[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]]</span> <span class=\"o\">*</span> <span class=\"mf\">1e6</span><span class=\"p\">)</span>\n<span class=\"n\">ax</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">legend</span><span class=\"p\">(</span><span class=\"n\">loc</span><span class=\"o\">=</span><span class=\"s1\">'upper right'</span><span class=\"p\">)</span>\n</pre>\n</div>\n</div>\n<div id=\"development\">\n<h2>Development</h2>\n<div id=\"source-code-organization\">\n<h3>Source code organization</h3>\n<p>The source code is organized as follows:</p>\n<ul>\n<li><tt>/</tt> (root): Module description and distribution files.</li>\n<li><tt>/macromax</tt>: The iterative solver.</li>\n<li><tt>/macromax/examples</tt>: Examples of how the solver can be used.</li>\n<li><tt>/macromax/tests</tt>: Automated unit tests of the solver\u2019s\nfunctionality. Use this after making modifications to the solver and\nextend it if new functionality is added.</li>\n</ul>\n<p>The library functions are contained in <tt>/macromax</tt>:</p>\n<ul>\n<li><tt>solver</tt>: Defines the <tt><span class=\"pre\">solve(...)</span></tt> function and the <tt>Solution</tt>\nclass.</li>\n<li><tt>parallel_ops_column</tt>: Defines linear algebra functions to work\nefficiently with large arrays of 3x3 matrices and 3-vectors.</li>\n<li><tt>utils</tt>: Defines utility functions that can be used to prepare and\ninterpret function arguments.</li>\n</ul>\n<p>The included examples in the <tt>/macromax/examples</tt> folder are:</p>\n<ul>\n<li><tt>notebook_example.ipynb</tt>: An iPython notebook demonstrating basic\nusage of the library.</li>\n<li><tt>air_glass_air_1D.py</tt>: Calculation of the back reflection from an\nair-glass interface (one-dimensional calculation)</li>\n<li><tt>air_glass_air_2D.py</tt>: Calculation of the refraction and reflection\nof light hitting a glass window at an angle (two-dimensional\ncalculation)</li>\n<li><tt>birefringent_crystal.py</tt>: Demonstration of how an anisotropic\npermittivity can split a diagonally polarized Gaussian beam into\nordinary and extraordinary beams.</li>\n<li><tt>polarizer.py</tt>: Calculation of light wave traversing a set of two\nand a set of three polarizers as a demonstration of anisotropic\nabsorption (non-Hermitian permittivity)</li>\n<li><tt>rutile.py</tt>: Scattering from disordered collection of birefringent\nrutile (TiO2) particles.</li>\n</ul>\n</div>\n<div id=\"testing\">\n<h3>Testing</h3>\n<div>\n<div>Unit tests are contained in <tt>macromax/tests</tt>. The\n<tt>ParallelOperations</tt> class in</div>\n<div><tt>parallel_ops_column.pi</tt> is pretty well covered and some specific\ntests have been written for</div>\n<div>the <tt>Solution</tt> class in <tt>solver.py</tt>. However, the <tt>utils</tt> module\ndoes not have any</div>\n<div>tests at present.</div>\n</div>\n<p>To run the tests:</p>\n<pre>pip install nose\npython setup.py <span class=\"nb\">test</span>\n</pre>\n</div>\n<div id=\"building-and-distributing\">\n<h3>Building and Distributing</h3>\n<p>The code consists of pure Python 3, hence only packaging is required for\ndistribution.</p>\n<p>To prepare a package for distribution, increase the version number in\n<tt>setup.py</tt>, and run:</p>\n<pre>python setup.py sdist bdist_wheel\npip install . --upgrade\n</pre>\n<p>The package can then be uploaded to a test repository as follows:</p>\n<pre>twine upload --repository-url https://test.pypi.org/legacy/ dist/*\n</pre>\n<p>Installing from the test repository is done as follows:</p>\n<pre>pip install -i https://test.pypi.org/simple/ macromax\n</pre>\n<p>IntelliJ IDEA project files can be found in <tt>MacroMax/python/</tt>:\n<tt>MacroMax/python/python.iml</tt> and the folder <tt><span class=\"pre\">MacroMax/python/.idea</span></tt>.</p>\n</div>\n</div>\n\n          </div>"}, "last_serial": 5816895, "releases": {"0.0.6": [{"comment_text": "", "digests": {"md5": "4e6e641b70ef34bcc0990e810da50c40", "sha256": "7412d7d62dc1451049ac1a2aaad2338df0c24fdf4a7aec8525c2e512c2a6c2e0"}, "downloads": -1, "filename": "macromax-0.0.6-py3-none-any.whl", "has_sig": false, "md5_digest": "4e6e641b70ef34bcc0990e810da50c40", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 55908, "upload_time": "2018-12-29T18:33:36", "upload_time_iso_8601": "2018-12-29T18:33:36.531872Z", "url": "https://files.pythonhosted.org/packages/d8/91/437bd6248e4aa38a09ee99037dbea9a159083771b6cbc0fc6bfd9cac7225/macromax-0.0.6-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "5c2a42a766012a33ba5115fe9827dada", "sha256": "6b4b699f3b6dd0324361a154d1fe03e9b984d0853b3c4048b6a197998a5a5db9"}, "downloads": -1, "filename": "macromax-0.0.6.tar.gz", "has_sig": false, "md5_digest": "5c2a42a766012a33ba5115fe9827dada", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3", "size": 233429, "upload_time": "2018-12-29T18:33:43", "upload_time_iso_8601": "2018-12-29T18:33:43.871219Z", "url": "https://files.pythonhosted.org/packages/79/e7/438b6fddfbb25076bea70a129037ab4310cd1b522719af476589cfacebb5/macromax-0.0.6.tar.gz", "yanked": false}], "0.0.8": [{"comment_text": "", "digests": {"md5": "e3f77a785947349c2f857ad0b17a6bc8", "sha256": "79dcf5b65e1e755b1d753b03866518a21fc089f386c5c146995324f86492a91b"}, "downloads": -1, "filename": "macromax-0.0.8-py3-none-any.whl", "has_sig": false, "md5_digest": "e3f77a785947349c2f857ad0b17a6bc8", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 56741, "upload_time": "2019-01-17T18:18:33", "upload_time_iso_8601": "2019-01-17T18:18:33.007778Z", "url": "https://files.pythonhosted.org/packages/35/61/441c9d0fa9c1ed59f10c8fe6c9384d4774081ab662452bfcaba25449dce6/macromax-0.0.8-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "495784d862cc902367628b98f6f5d0f9", "sha256": "3689ca493a9a4822ce58733d59697cb228598110b93c2712599d313b855f74ba"}, "downloads": -1, "filename": "macromax-0.0.8.tar.gz", "has_sig": false, "md5_digest": "495784d862cc902367628b98f6f5d0f9", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3", "size": 52819, "upload_time": "2019-01-17T18:18:34", "upload_time_iso_8601": "2019-01-17T18:18:34.701881Z", "url": "https://files.pythonhosted.org/packages/7e/17/0260b046ba628c37adbe7539bd73781a7624b839822c1ae33cbf883b4984/macromax-0.0.8.tar.gz", "yanked": false}], "0.0.9": [{"comment_text": "", "digests": {"md5": "e5027f4bb28532bc5a7d95eb3945085a", "sha256": "8969e1776444b9f96b341c64adc86f848ab0412be18391fdf7caec706e1300d3"}, "downloads": -1, "filename": "macromax-0.0.9-py3-none-any.whl", "has_sig": false, "md5_digest": "e5027f4bb28532bc5a7d95eb3945085a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 61101, "upload_time": "2019-09-11T20:59:43", "upload_time_iso_8601": "2019-09-11T20:59:43.299589Z", "url": "https://files.pythonhosted.org/packages/bc/e0/b7b3424d41fbd8f3aa24e77006bf6c34354949624a3a3478b8086db9e06b/macromax-0.0.9-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fae75ea5a696f1664d16eb5caf127423", "sha256": "f32d217b413b1634475b15e3b381b9e0ad9cc3164ce3fc601d92954ad4dbe67f"}, "downloads": -1, "filename": "macromax-0.0.9.tar.gz", "has_sig": false, "md5_digest": "fae75ea5a696f1664d16eb5caf127423", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3", "size": 51400, "upload_time": "2019-09-11T20:59:45", "upload_time_iso_8601": "2019-09-11T20:59:45.445044Z", "url": "https://files.pythonhosted.org/packages/f2/15/91c832b64ad9341d991a8a2ca1e8daafccd44c36056aafed5f2c2a349724/macromax-0.0.9.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "e5027f4bb28532bc5a7d95eb3945085a", "sha256": "8969e1776444b9f96b341c64adc86f848ab0412be18391fdf7caec706e1300d3"}, "downloads": -1, "filename": "macromax-0.0.9-py3-none-any.whl", "has_sig": false, "md5_digest": "e5027f4bb28532bc5a7d95eb3945085a", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": ">=3", "size": 61101, "upload_time": "2019-09-11T20:59:43", "upload_time_iso_8601": "2019-09-11T20:59:43.299589Z", "url": "https://files.pythonhosted.org/packages/bc/e0/b7b3424d41fbd8f3aa24e77006bf6c34354949624a3a3478b8086db9e06b/macromax-0.0.9-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "fae75ea5a696f1664d16eb5caf127423", "sha256": "f32d217b413b1634475b15e3b381b9e0ad9cc3164ce3fc601d92954ad4dbe67f"}, "downloads": -1, "filename": "macromax-0.0.9.tar.gz", "has_sig": false, "md5_digest": "fae75ea5a696f1664d16eb5caf127423", "packagetype": "sdist", "python_version": "source", "requires_python": ">=3", "size": 51400, "upload_time": "2019-09-11T20:59:45", "upload_time_iso_8601": "2019-09-11T20:59:45.445044Z", "url": "https://files.pythonhosted.org/packages/f2/15/91c832b64ad9341d991a8a2ca1e8daafccd44c36056aafed5f2c2a349724/macromax-0.0.9.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:42:17 2020"}