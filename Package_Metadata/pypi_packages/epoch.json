{"info": {"author": "metagriffin", "author_email": "mg.pypi@metagriffin.net", "bugtrack_url": null, "classifiers": ["Development Status :: 3 - Alpha", "Environment :: Console", "Intended Audience :: Developers", "Intended Audience :: System Administrators", "License :: OSI Approved :: GNU General Public License v3 or later (GPLv3+)", "Natural Language :: English", "Operating System :: OS Independent", "Programming Language :: Python", "Topic :: Software Development", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Utilities"], "description": "==================================\nEpoch Timestamp Management Utility\n==================================\n\nThe `epoch` provides a set of routines that help with the management\nof UNIX epoch timestamps, including generation, adjustment, and\nparsing.\n\n\nProject\n=======\n\n* Homepage: https://github.com/metagriffin/epoch\n* Bugs: https://github.com/metagriffin/epoch/issues\n\n\nInstallation\n============\n\n.. code:: bash\n\n  $ pip install epoch\n\n\nUsage\n=====\n\nThe following routines are available:\n\n* ``epoch.now()`` : float\n\n  Returns a float representation of the current UNIX epoch timestamp,\n  i.e. the number of seconds since 1970/01/01.\n\n* ``epoch.sod([ts][, tz][, offset][, replace])`` : float\n\n  Returns the epoch timestamp of the start of the current day relative\n  to the timezone `tz`. If `ts` is specified, the start of the day\n  containing `ts` is returned. If `offset` is specified, it is taken\n  to be an integral number of days to offset the returned value by.\n  Note that due to leap seconds, daylight savings, etc, this is more\n  complex than just 60 seconds * 60 minutes * 24 hours. If `replace`\n  is specified, it is a dictionary of datetime attributes to replace\n  after all other modifications have been made.\n\n  For example, the following will return the epoch timestamp in\n  Anchorage, AK, USA for tomorrow at 3 PM local time:\n\n  .. code:: python\n\n    epoch.sod(offset=1, tz='America/Anchorage', replace=dict(hour=15))\n\n\n* ``epoch.sow([ts][, tz][, offset][, day][, replace])`` : float\n\n  Returns the epoch timestamp of the start of the current Gregorian\n  week relative to the timezone `tz`. If `ts` is specified, the start\n  of the week containing `ts` is returned. If `offset` is specified,\n  it is taken to be an integral number of weeks to offset the returned\n  value by. Note that due to leap days, leap seconds, daylight\n  savings, etc, this is more complex than just 60 seconds * 60 minutes\n  * 24 hours * 7 days. If `day` is specified, it specifies which day\n  is defined to be the \"first\" day of the week, where ``0`` (the\n  default) is Monday through ``6`` being Sunday. If `replace` is\n  specified, it is a dictionary of datetime attributes to replace\n  after all other modifications have been made (see `epoch.sod` for\n  examples).\n\n* ``epoch.som([ts][, tz][, offset][, replace])`` : float\n\n  Returns the epoch timestamp of the start of the current Gregorian\n  month relative to the timezone `tz`. If `ts` is specified, the start\n  of the month containing `ts` is returned. If `offset` is specified,\n  it is taken to be an integral number of months to offset the\n  returned value by. If `replace` is specified, it is a dictionary of\n  datetime attributes to replace after all other modifications have\n  been made (see `epoch.sod` for examples).\n\n* ``epoch.soy([ts][, tz][, offset][, replace])`` : float\n\n  Returns the epoch timestamp of the start of the current Gregorian\n  year relative to the timezone `tz`. If `ts` is specified, the start\n  of the year containing `ts` is returned. If `offset` is specified,\n  it is taken to be an integral number of years to offset the returned\n  value by. If `replace` is specified, it is a dictionary of datetime\n  attributes to replace after all other modifications have been made\n  (see `epoch.sod` for examples).\n\n* ``epoch.zulu([ts][, ms])`` : string\n\n  Returns the specified epoch time `ts` (or current time if None or\n  not provided) as an ISO 8601 Combined string in zulu time (with\n  millisecond precision), e.g. ``epoch.zulu(1362187446.553)`` =>\n  ``'2013-03-02T01:24:06.553Z'``. If `ms` is True (the default),\n  milliseconds will be included, otherwise truncated. If `ts` has\n  beyond-millisecond precision, it will be truncated to\n  millisecond-level precision.\n\n* ``epoch.parseZulu(text)`` : float\n\n  Parses an ISO 8601 Combined string into an epoch timestamp. Note\n  that this function is limited to microsecond-level accuracy (a\n  `datetime` system library limitation) and isintended to be used with\n  strings generated by `epoch.zulu`, and is therefore not very\n  forgiving. For a much more human-friendly parser, try::\n\n    import dateutil.parser\n    result = dateutil.parser.parse(text, tzinfos = {'UTC': 0}))\n\n  but please note that it does not properly warn about ambiguities;\n  for example ``01/02/03`` gets interpreted without hesitation as\n  ``2003/01/02``... ugh.\n\n* ``epoch.parse(value)`` : float\n\n  Tries the following methods of extracting an epoch timestamp from\n  `text`:\n\n  * Checks for None, integer, or float type (and returns that as-is)\n  * Checks for an all-digits text, and casts that to float\n  * Fallsback to parsing via :func:`epoch.parseZulu`\n\n  Note that this function is intended to be used with code-generated\n  strings (such as those generated by `epoch.zulu`), and is therefore\n  not very forgiving. For a much more human-friendly parser, see the\n  example in :func:`epoch.parseZulu`.\n\n* ``epoch.tsreplace([ts][, tz][, *params])`` : float\n\n  An epoch timestamp-oriented version of `epoch.dtreplace`. Example:\n\n  .. code:: python\n\n    import epoch\n\n    ts = epoch.parse('2015-12-08T14:56:33Z')\n    # ts == 1449586593.0\n\n    ts = epoch.tsreplace(ts, hour=9, minute=30)\n    # ts == 1449567033.0\n    s = epoch.zulu(ts)\n    # s == '2015-12-08T09:30:33.000Z'\n\n    ts = epoch.tsreplace(ts, tz='Europe/Paris', hour=9, minute=30)\n    # ts == 1449563433.0\n    s = epoch.zulu(ts)\n    # s == '2015-12-08T08:30:33.000Z'\n\n* ``epoch.dtreplace(dt[, *params])`` : datetime\n\n  A version of :meth:`datetime.datetime.replace()` that properly\n  maintains the `dt.tzinfo` if the replace will cause DST boundary\n  switching.\n\n* ``epoch.ts2age(ts[, origin][, tz])`` : float\n\n  ## TODO: DOCUMENT\n  ## import pdb;pdb.set_trace()\n\n* ``epoch.age2ts(age[, origin][, tz])`` : float\n\n  ## TODO: DOCUMENT\n  ## import pdb;pdb.set_trace()\n\nNote that the `epoch` package, when working with `datetime` objects,\nalways uses timezone-aware objects.\n", "description_content_type": "", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "http://github.com/metagriffin/epoch", "keywords": "epoch unix timestamp date time utility", "license": "GPLv3+", "maintainer": "", "maintainer_email": "", "name": "epoch", "package_url": "https://pypi.org/project/epoch/", "platform": "any", "project_url": "https://pypi.org/project/epoch/", "project_urls": {"Homepage": "http://github.com/metagriffin/epoch"}, "release_url": "https://pypi.org/project/epoch/0.1.5/", "requires_dist": null, "requires_python": "", "summary": "A utility library to manage and manipulate UNIX epoch timestamps.", "version": "0.1.5", "yanked": false, "html_description": "<div class=\"project-description\">\n            ==================================<br>Epoch Timestamp Management Utility<br>==================================<br><br>The `epoch` provides a set of routines that help with the management<br>of UNIX epoch timestamps, including generation, adjustment, and<br>parsing.<br><br><br>Project<br>=======<br><br>* Homepage: https://github.com/metagriffin/epoch<br>* Bugs: https://github.com/metagriffin/epoch/issues<br><br><br>Installation<br>============<br><br>.. code:: bash<br><br>  $ pip install epoch<br><br><br>Usage<br>=====<br><br>The following routines are available:<br><br>* ``epoch.now()`` : float<br><br>  Returns a float representation of the current UNIX epoch timestamp,<br>  i.e. the number of seconds since 1970/01/01.<br><br>* ``epoch.sod([ts][, tz][, offset][, replace])`` : float<br><br>  Returns the epoch timestamp of the start of the current day relative<br>  to the timezone `tz`. If `ts` is specified, the start of the day<br>  containing `ts` is returned. If `offset` is specified, it is taken<br>  to be an integral number of days to offset the returned value by.<br>  Note that due to leap seconds, daylight savings, etc, this is more<br>  complex than just 60 seconds * 60 minutes * 24 hours. If `replace`<br>  is specified, it is a dictionary of datetime attributes to replace<br>  after all other modifications have been made.<br><br>  For example, the following will return the epoch timestamp in<br>  Anchorage, AK, USA for tomorrow at 3 PM local time:<br><br>  .. code:: python<br><br>    epoch.sod(offset=1, tz='America/Anchorage', replace=dict(hour=15))<br><br><br>* ``epoch.sow([ts][, tz][, offset][, day][, replace])`` : float<br><br>  Returns the epoch timestamp of the start of the current Gregorian<br>  week relative to the timezone `tz`. If `ts` is specified, the start<br>  of the week containing `ts` is returned. If `offset` is specified,<br>  it is taken to be an integral number of weeks to offset the returned<br>  value by. Note that due to leap days, leap seconds, daylight<br>  savings, etc, this is more complex than just 60 seconds * 60 minutes<br>  * 24 hours * 7 days. If `day` is specified, it specifies which day<br>  is defined to be the \"first\" day of the week, where ``0`` (the<br>  default) is Monday through ``6`` being Sunday. If `replace` is<br>  specified, it is a dictionary of datetime attributes to replace<br>  after all other modifications have been made (see `epoch.sod` for<br>  examples).<br><br>* ``epoch.som([ts][, tz][, offset][, replace])`` : float<br><br>  Returns the epoch timestamp of the start of the current Gregorian<br>  month relative to the timezone `tz`. If `ts` is specified, the start<br>  of the month containing `ts` is returned. If `offset` is specified,<br>  it is taken to be an integral number of months to offset the<br>  returned value by. If `replace` is specified, it is a dictionary of<br>  datetime attributes to replace after all other modifications have<br>  been made (see `epoch.sod` for examples).<br><br>* ``epoch.soy([ts][, tz][, offset][, replace])`` : float<br><br>  Returns the epoch timestamp of the start of the current Gregorian<br>  year relative to the timezone `tz`. If `ts` is specified, the start<br>  of the year containing `ts` is returned. If `offset` is specified,<br>  it is taken to be an integral number of years to offset the returned<br>  value by. If `replace` is specified, it is a dictionary of datetime<br>  attributes to replace after all other modifications have been made<br>  (see `epoch.sod` for examples).<br><br>* ``epoch.zulu([ts][, ms])`` : string<br><br>  Returns the specified epoch time `ts` (or current time if None or<br>  not provided) as an ISO 8601 Combined string in zulu time (with<br>  millisecond precision), e.g. ``epoch.zulu(1362187446.553)`` =&gt;<br>  ``'2013-03-02T01:24:06.553Z'``. If `ms` is True (the default),<br>  milliseconds will be included, otherwise truncated. If `ts` has<br>  beyond-millisecond precision, it will be truncated to<br>  millisecond-level precision.<br><br>* ``epoch.parseZulu(text)`` : float<br><br>  Parses an ISO 8601 Combined string into an epoch timestamp. Note<br>  that this function is limited to microsecond-level accuracy (a<br>  `datetime` system library limitation) and isintended to be used with<br>  strings generated by `epoch.zulu`, and is therefore not very<br>  forgiving. For a much more human-friendly parser, try::<br><br>    import dateutil.parser<br>    result = dateutil.parser.parse(text, tzinfos = {'UTC': 0}))<br><br>  but please note that it does not properly warn about ambiguities;<br>  for example ``01/02/03`` gets interpreted without hesitation as<br>  ``2003/01/02``... ugh.<br><br>* ``epoch.parse(value)`` : float<br><br>  Tries the following methods of extracting an epoch timestamp from<br>  `text`:<br><br>  * Checks for None, integer, or float type (and returns that as-is)<br>  * Checks for an all-digits text, and casts that to float<br>  * Fallsback to parsing via :func:`epoch.parseZulu`<br><br>  Note that this function is intended to be used with code-generated<br>  strings (such as those generated by `epoch.zulu`), and is therefore<br>  not very forgiving. For a much more human-friendly parser, see the<br>  example in :func:`epoch.parseZulu`.<br><br>* ``epoch.tsreplace([ts][, tz][, *params])`` : float<br><br>  An epoch timestamp-oriented version of `epoch.dtreplace`. Example:<br><br>  .. code:: python<br><br>    import epoch<br><br>    ts = epoch.parse('2015-12-08T14:56:33Z')<br>    # ts == 1449586593.0<br><br>    ts = epoch.tsreplace(ts, hour=9, minute=30)<br>    # ts == 1449567033.0<br>    s = epoch.zulu(ts)<br>    # s == '2015-12-08T09:30:33.000Z'<br><br>    ts = epoch.tsreplace(ts, tz='Europe/Paris', hour=9, minute=30)<br>    # ts == 1449563433.0<br>    s = epoch.zulu(ts)<br>    # s == '2015-12-08T08:30:33.000Z'<br><br>* ``epoch.dtreplace(dt[, *params])`` : datetime<br><br>  A version of :meth:`datetime.datetime.replace()` that properly<br>  maintains the `dt.tzinfo` if the replace will cause DST boundary<br>  switching.<br><br>* ``epoch.ts2age(ts[, origin][, tz])`` : float<br><br>  ## TODO: DOCUMENT<br>  ## import pdb;pdb.set_trace()<br><br>* ``epoch.age2ts(age[, origin][, tz])`` : float<br><br>  ## TODO: DOCUMENT<br>  ## import pdb;pdb.set_trace()<br><br>Note that the `epoch` package, when working with `datetime` objects,<br>always uses timezone-aware objects.<br>\n          </div>"}, "last_serial": 4603488, "releases": {"0.0.1": [], "0.1.1": [{"comment_text": "", "digests": {"md5": "43b748c1da0ed7f0fdc3b94f3c86bed9", "sha256": "f6eb561d2550b8ea9721908ba90c601bfbc2d045ada1b87ced5b4ba01fbbddbd"}, "downloads": -1, "filename": "epoch-0.1.1.tar.gz", "has_sig": false, "md5_digest": "43b748c1da0ed7f0fdc3b94f3c86bed9", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19333, "upload_time": "2016-09-20T16:06:54", "upload_time_iso_8601": "2016-09-20T16:06:54.184081Z", "url": "https://files.pythonhosted.org/packages/d3/bc/008d0c4df6ed76ae086f6cc22ccbf21f321f2908b2080f47b87e2d09fba0/epoch-0.1.1.tar.gz", "yanked": false}], "0.1.2": [{"comment_text": "", "digests": {"md5": "822859ae8df5038f8aabe1701f822e2e", "sha256": "7b58e165f9491553909a9c663367051640d7e0895cc1d6ca8cc255b11bf31847"}, "downloads": -1, "filename": "epoch-0.1.2.tar.gz", "has_sig": false, "md5_digest": "822859ae8df5038f8aabe1701f822e2e", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 19625, "upload_time": "2016-09-26T13:42:14", "upload_time_iso_8601": "2016-09-26T13:42:14.560381Z", "url": "https://files.pythonhosted.org/packages/9c/56/e7e95debe48a9ea4daed5c866f107ac23c77f6b0522f65250e806b0fc156/epoch-0.1.2.tar.gz", "yanked": false}], "0.1.3": [{"comment_text": "", "digests": {"md5": "0e03739510951166a884efb038557687", "sha256": "b9f7cdfbff56ff9bd9e4dcb5c80e6aed30cd8d792827b99c17d1ac4ba6895aab"}, "downloads": -1, "filename": "epoch-0.1.3.tar.gz", "has_sig": false, "md5_digest": "0e03739510951166a884efb038557687", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21114, "upload_time": "2016-11-12T15:53:05", "upload_time_iso_8601": "2016-11-12T15:53:05.139694Z", "url": "https://files.pythonhosted.org/packages/ae/24/4e7a8a8238eca9c275c3da68a1eb118db67767610ba2731111cdeb44d055/epoch-0.1.3.tar.gz", "yanked": false}], "0.1.4": [{"comment_text": "", "digests": {"md5": "9573aa4db97545d94d13b9788349d7ca", "sha256": "fe1222b37716ea5e6fb2bc70728d714bdb4c4fc58eb5ecdab51c4fc4fc6a2121"}, "downloads": -1, "filename": "epoch-0.1.4.tar.gz", "has_sig": false, "md5_digest": "9573aa4db97545d94d13b9788349d7ca", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 21592, "upload_time": "2017-01-01T19:55:46", "upload_time_iso_8601": "2017-01-01T19:55:46.020497Z", "url": "https://files.pythonhosted.org/packages/26/1c/cd0b9063a0bc91fbb93c85c3b3d48f242f3deeb6cdc8e10a1cb2258a009e/epoch-0.1.4.tar.gz", "yanked": false}], "0.1.5": [{"comment_text": "", "digests": {"md5": "0178e79a3b7b1f065f85180e68bd54f3", "sha256": "c6109e6a11d68fec9bd3107cf41cce16967800c546108c82edb97c423559d709"}, "downloads": -1, "filename": "epoch-0.1.5.tar.gz", "has_sig": false, "md5_digest": "0178e79a3b7b1f065f85180e68bd54f3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23567, "upload_time": "2018-12-15T20:11:41", "upload_time_iso_8601": "2018-12-15T20:11:41.173502Z", "url": "https://files.pythonhosted.org/packages/31/3a/b45b34bf0c867d0d126da3e2431fa3f079daccb6656f99dac3488bfb2651/epoch-0.1.5.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "0178e79a3b7b1f065f85180e68bd54f3", "sha256": "c6109e6a11d68fec9bd3107cf41cce16967800c546108c82edb97c423559d709"}, "downloads": -1, "filename": "epoch-0.1.5.tar.gz", "has_sig": false, "md5_digest": "0178e79a3b7b1f065f85180e68bd54f3", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 23567, "upload_time": "2018-12-15T20:11:41", "upload_time_iso_8601": "2018-12-15T20:11:41.173502Z", "url": "https://files.pythonhosted.org/packages/31/3a/b45b34bf0c867d0d126da3e2431fa3f079daccb6656f99dac3488bfb2651/epoch-0.1.5.tar.gz", "yanked": false}], "timestamp": "Fri May  8 00:45:56 2020"}