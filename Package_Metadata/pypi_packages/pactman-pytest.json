{"info": {"author": "Ondrej Jurcak", "author_email": "ondrej.jurcak@gmail.com", "bugtrack_url": null, "classifiers": ["Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3", "Programming Language :: Python :: 3.6", "Topic :: Software Development :: Testing", "Topic :: Software Development :: Testing :: Acceptance", "Topic :: Software Development :: Testing :: Mocking"], "description": "#Forked pactman\nResolved issue with tags when using pytest. --pact-verify-consumer-tag not was not passed to BrokerConfig when verify using pytest.\nSee pull request to pactman https://github.com/reecetech/pactman/pull/81/commits/21e7c8fdcf4837017e0f86c1fb72a404b80ee254\n\n# pactman\n\n[![](https://img.shields.io/pypi/v/pactman.svg)](https://pypi.org/project/pactman/) [![](https://travis-ci.org/reecetech/pactman.svg?branch=master)](https://travis-ci.org/reecetech/pactman.svg?branch=master)\n\n\nPython version of Pact mocking, generation and verification.\n\nEnables [consumer driven contract testing], providing unit test mocking of provider services\nand DSL for the consumer project, and interaction playback and verification for the service\nprovider project. Currently supports versions 1.1, 2 and 3 of the [Pact specification].\n\nFor more information about what Pact is, and how it can help you\ntest your code more efficiently, check out the [Pact documentation].\n\nContains code originally from the [pact-python](https://github.com/pact-foundation/pact-python) project.\n\npactman is maintained by the [ReeceTech](https://www.reecetech.com.au/) team as part of their toolkit to\nkeep their large (and growing) microservices architecture under control.\n\n* [How to use pactman](#how-to-use-pactman)\n  * [Installation](#installation)\n  * [Writing a Pact](#writing-a-pact)\n  * [Writing the Consumer Test](#writing-the-consumer-test)\n  * [Expecting Variable Content](#expecting-variable-content)\n  * [Verifying Pacts Against a Service](#verifying-pacts-against-a-service)\n* [Development](#development)\n  * [Release History](#release-history)\n\n## pactman vs pact-python\n\nThe key difference is all functionality is implemented in Python, rather than shelling out or forking\nto the ruby implementation. This allows for a much nicer mocking user experience (it mocks urllib3\ndirectly), is faster, less messy configuration (multiple providers means multiple ruby processes spawned\non different ports).\n\nWhere `pact-python` required management of a background Ruby server, and manually starting and stopping\nit, `pactman` allows a much nicer usage like:\n\n```python\nimport requests\nfrom pactman import Consumer, Provider\n\npact = Consumer('Consumer').has_pact_with(Provider('Provider'))\n\ndef test_interaction():\n    pact.given(\"some data exists\").upon_receiving(\"a request\") \\\n        .with_request(\"get\", \"/\", query={\"foo\": [\"bar\"]}).will_respond_with(200)\n    with pact:\n        requests.get(pact.uri, params={\"foo\": [\"bar\"]})\n```\n\nIt also supports a broader set of the pact specification (versions 1.1 through to 3).\n\nThe pact verifier has been engineered from the start to talk to a pact broker (both to discover pacts\nand to return verification results).\n\nThere\u2019s a few other quality of life improvements, but those are the big ones.\n\n# How to use pactman\n\n## Installation\n\n`pactman` requires Python 3.6 to run.\n\n```\npip install pactman\n```\n\n## Writing a Pact\nCreating a complete contract is a two step process:\n\n1. Create a unit test on the consumer side that declares the expectations it has of the provider\n2. Create a provider state that allows the contract to pass when replayed against the provider\n\n## Writing the Consumer Test\n\nIf we have a method that communicates with one of our external services, which we'll call\n`Provider`, and our product, `Consumer` is hitting an endpoint on `Provider` at\n`/users/<user>` to get information about a particular user.\n\nIf the `Consumer`'s code to fetch a user looked like this:\n\n```python\nimport requests\n\ndef get_user(user_name):\n    response = requests.get(f'http://service.example/users/{user_name}')\n    return response.json()\n```\n\nThen `Consumer`'s contract test is a regular unit test, but *using pactman for mocking*,\nand might look something like this:\n\n```python\nimport unittest\nfrom pactman import Consumer, Provider\n\npact = Consumer('Consumer').has_pact_with(Provider('Provider'))\n\nclass GetUserInfoContract(unittest.TestCase):\n  def test_get_user(self):\n    expected = {\n      'username': 'UserA',\n      'id': 123,\n      'groups': ['Editors']\n    }\n\n    pact.given(\n        'UserA exists and is not an administrator'\n    ).upon_receiving(\n        'a request for UserA'\n    ).with_request(\n        'GET', '/users/UserA'\n    ) .will_respond_with(200, body=expected)\n\n    with pact:\n      result = get_user('UserA')\n\n    self.assertEqual(result, expected)\n```\n\nThis does a few important things:\n\n - Defines the Consumer and Provider objects that describe our product and our service under test\n - Uses `given` to define the setup criteria for the Provider `UserA exists and is not an administrator`\n - Defines what the request that is expected to be made by the consumer will contain\n - Defines how the server is expected to respond\n\nUsing the Pact object as a [context manager], we call our method under test\nwhich will then communicate with the Pact mock. The mock will respond with\nthe items we defined, allowing us to assert that the method processed the response and\nreturned the expected value.\n\nIf you want more control over when the mock is configured and the interactions verified,\nuse the `setup` and `verify` methods, respectively:\n\n```python\nConsumer('Consumer').has_pact_with(Provider('Provider')).given(\n    'UserA exists and is not an administrator'\n).upon_receiving(\n    'a request for UserA'\n).with_request(\n    'GET', '/users/UserA'\n) .will_respond_with(200, body=expected)\n\npact.setup()\ntry:\n    # Some additional steps before running the code under test\n    result = get_user('UserA')\n    # Some additional steps before verifying all interactions have occurred\nfinally:\n    pact.verify()\n```\n\n### An important note about pact relationship definition\n\nYou may have noticed that the pact relationship is defined at the module level in our\nexamples:\n\n```python\npact = Consumer('Consumer').has_pact_with(Provider('Provider'))\n```\n\nThis is because it *must only be done once* per test suite. By default the pact file is\ncleared out when that relationship is defined, so if you define it more than once per test\nsuite you'll end up only storing the *last* pact declared per relationship. For more on this\nsubject, see [writing multiple pacts](#writing-multiple-pacts).\n\n### Requests\n\nWhen defining the expected HTTP request that your code is expected to make you\ncan specify the method, path, body, headers, and query:\n\n```python\npact.with_request(\n    method='GET',\n    path='/api/v1/my-resources/',\n    query={'search': 'example'}\n)\n```\n\n`query` is used to specify URL query parameters, so the above example expects\na request made to `/api/v1/my-resources/?search=example`.\n\n```python\npact.with_request(\n    method='POST',\n    path='/api/v1/my-resources/123',\n    body={'user_ids': [1, 2, 3]},\n    headers={'Content-Type': 'application/json'},\n)\n```\n\nYou can define exact values for your expected request like the examples above,\nor you can use the matchers defined later to assist in handling values that are\nvariable.\n\n### Some important has_pact_with() options()\n\nThe `has_pact_with(provider...)` call has quite a few options documented in its API, but a couple are\nworth mentioning in particular:\n\n`version` declares the pact specification version that the provider supports. This defaults to \"2.0.0\", but \"3.0.0\"\nis also acceptable if your provider supports [Pact specification version 3]:\n\n```python\nfrom pactman import Consumer, Provider\npact = Consumer('Consumer').has_pact_with(Provider('Provider'), version='3.0.0')\n```\n\n`file_write_mode` defaults to `\"overwrite\"` and should be that or `\"merge\"`. Overwrite ensures\nthat any existing pact file will be removed when `has_pact_with()` is invoked. Merge will retain\nthe pact file and add new pacts to that file. See [writing multiple pacts](#writing-multiple-pacts).\nIf you absolutely do not want pact files to be written, use `\"never\"`.\n\n`use_mocking_server` defaults to `False` and controls the mocking method used by `pactman`. The default is to\npatch `urllib3`, which is the library underpinning `requests` and is also used by some other projects. If you\nare using a different library to make your HTTP requests which does not use `urllib3` underneath then you will need\nto set the `use_mocking_server` argument to `True`. This causes `pactman` to run an actual HTTP server to mock the\nrequests (the server is listening on `pact.uri` - use that to redirect your HTTP requests to the mock server.) You\nmay also set the `PACT_USE_MOCKING_SERVER` environment variable to \"yes\" to force your entire suite to use the server\napproach. You should declare the pact particpants (consumer and provider) outside of your tests and will need\nto start and stop the mocking service outside of your tests too. The code below shows what using the server might\nlook like:\n\n```python\nimport atexit\nfrom pactman import Consumer, Provider\npact = Consumer('Consumer').has_pact_with(Provider('Provider'), use_mocking_server=True)\npact.start_mocking()\natexit.register(pact.stop_mocking)\n``````\n\nYou'd then use `pact` to declare pacts between those participants.\n\n### Writing multiple pacts\n\nDuring a test run you're likely to need to write multiple pact interactions for a consumer/provider\nrelationship. `pactman` will manage the pact file as follows:\n\n- When `has_pact_with()` is invoked it will by default remove any existing pact JSON file for the\n  stated consumer & provider.\n- You may invoke `Consumer('Consumer').has_pact_with(Provider('Provider'))` once at the start of\n  your tests. This could be done as a pytest module or session fixture, or through some other\n  mechanism and store it in a variable. By convention this is called `pact` in all of our examples.\n- If that is not suitable, you may manually indicate to `has_pact_with()` that it should either\n  retain (`file_write_mode=\"merge\"`) or remove (`file_write_mode=\"overwrite\"`) the existing\n  pact file.\n\n### Some words about given()\n\nYou use `given()` to indicate to the provider that they should have some state in order to\nbe able to satisfy the interaction. You should agree upon the state and its specification\nin discussion with the provider.\n\nIf you are defining a version 3 pact you may define provider states more richly, for example:\n\n```python\n(pact\n    .given(\"this is a simple state as in v2\")\n    .and_given(\"also the user must exist\", username=\"alex\")\n)\n```\n\nNow you may specify additional parameters to accompany your provider state text. These are\npassed as keyword arguments, and they're optional. You may also provider additional provider\nstates using the `and_given()` call, which may be invoked many times if necessary. It and\n`given()` have the same calling convention: a provider state name and any optional parameters.\n\n## Expecting Variable Content\nThe default validity testing of equal values works great if that user information is always\nstatic, but what happens if the user has a last updated field that is set to the current time\nevery time the object is modified? To handle variable data and make your tests more robust,\nthere are several helpful matchers:\n\n### Includes(matcher, sample_data)\n\n*Available in version 3.0.0+ pacts*\n\nAsserts that the value should contain the given substring, for example::\n\n```python\nfrom pactman import Includes, Like\nLike({\n    'id': 123, # match integer, value varies\n    'content': Includes('spam', 'Sample spamming content')  # content must contain the string \"spam\"\n})\n```\n\nThe `matcher` and `sample_data` are used differently by consumer and provider depending\nupon whether they're used in the `with_request()` or `will_respond_with()` sections\nof the pact. Using the above example:\n\n#### Includes in request\nWhen you run the tests for the consumer, the mock will verify that the data\nthe consumer uses in its request contains the `matcher` string, raising an AssertionError\nif invalid. When the contract is verified by the provider, the `sample_data` will be\nused in the request to the real provider service, in this case `'Sample spamming content'`.\n\n#### Includes in response\nWhen you run the tests for the consumer, the mock will return the data you provided\nas `sample_data`, in this case `'Sample spamming content'`. When the contract is verified on the\nprovider, the data returned from the real provider service will be verified to ensure it\ncontains the `matcher` string.\n\n### Term(matcher, sample_data)\nAsserts the value should match the given regular expression. You could use this\nto expect a timestamp with a particular format in the request or response where\nyou know you need a particular format, but are unconcerned about the exact date:\n\n```python\nfrom pactman import Term\n\n(pact\n .given('UserA exists and is not an administrator')\n .upon_receiving('a request for UserA')\n .with_request(\n   'post',\n   '/users/UserA/info',\n   body={'commencement_date': Term('\\d+-\\d+-\\d', '1972-01-01')})\n .will_respond_with(200, body={\n    'username': 'UserA',\n    'last_modified': Term('\\d+-\\d+-\\d+T\\d+:\\d+:\\d+', '2016-12-15T20:16:01')\n }))\n```\n\nThe `matcher` and `sample_data` are used differently by consumer and provider depending\nupon whether they're used in the `with_request()` or `will_respond_with()` sections\nof the pact. Using the above example:\n\n#### Term in request\nWhen you run the tests for the consumer, the mock will verify that the `commencement_date`\nthe consumer uses in its request matches the `matcher`, raising an AssertionError\nif invalid. When the contract is verified by the provider, the `sample_data` will be\nused in the request to the real provider service, in this case `1972-01-01`.\n\n#### Term in response\nWhen you run the tests for the consumer, the mock will return the `last_modified` you provided\nas `sample_data`, in this case `2016-12-15T20:16:01`. When the contract is verified on the\nprovider, the regex will be used to search the response from the real provider service\nand the test will be considered successful if the regex finds a match in the response.\n\n### Like(sample_data)\nAsserts the element's type matches the `sample_data`. For example:\n\n```python\nfrom pactman import Like\nLike(123)  # Matches if the value is an integer\nLike('hello world')  # Matches if the value is a string\nLike(3.14)  # Matches if the value is a float\n```\n\n#### Like in request\nWhen you run the tests for the consumer, the mock will verify that values are\nof the correct type, raising an AssertionError if invalid. When the contract is\nverified by the provider, the `sample_data` will be used in the request to the\nreal provider service.\n\n#### Like in response\nWhen you run the tests for the consumer, the mock will return the `sample_data`.\nWhen the contract is verified on the provider, the values generated by the provider\nservice will be checked to match the type of `sample_data`.\n\n#### Applying Like to complex data structures\nWhen a dictionary is used as an argument for Like, all the child objects (and their child objects etc.)\nwill be matched according to their types, unless you use a more specific matcher like a Term.\n\n```python\nfrom pactman import Like, Term\nLike({\n    'username': Term('[a-zA-Z]+', 'username'),\n    'id': 123, # integer\n    'confirmed': False, # boolean\n    'address': { # dictionary\n        'street': '200 Bourke St' # string\n    }\n})\n```\n\n### EachLike(sample_data, minimum=1)\nAsserts the value is an array type that consists of elements\nlike `sample_data`. It can be used to assert simple arrays:\n\n```python\nfrom pactman import EachLike\nEachLike(1)  # All items are integers\nEachLike('hello')  # All items are strings\n```\n\nOr other matchers can be nested inside to assert more complex objects:\n\n```python\nfrom pactman import EachLike, Term\nEachLike({\n    'username': Term('[a-zA-Z]+', 'username'),\n    'id': 123,\n    'groups': EachLike('administrators')\n})\n```\n\n> Note, you do not need to specify everything that will be returned from the Provider in a\n> JSON response, any extra data that is received will be ignored and the tests will still pass.\n\nFor more information see [Matching](https://docs.pact.io/documentation/matching.html)\n\n### Enforcing equality matching with Equals\n\n*Available in version 3.0.0+ pacts*\n\nIf you have a sub-term of a `Like` which needs to match an exact value like the default\nvalidity test then you can use `Equals`, for example::\n\n```python\nfrom pactman import Equals, Like\nLike({\n    'id': 123, # match integer, value varies\n    'username': Equals('alex')  # username must always be \"alex\"\n})\n```\n\n### Body payload rules\nThe `body` payload is assumed to be JSON data. In the absence of a `Content-Type` header\nwe assume `Content-Type: application/json; charset=UTF-8` (JSON text is Unicode and the\ndefault encoding is UTF-8).\n\nDuring verification non-JSON payloads are compared for equality.\n\nDuring mocking, the HTTP response will be handled as:\n\n1. If there's no `Content-Type` header, assume JSON: serialise with `json.dumps()`, encode to\n   UTF-8 and add the header `Content-Type: application/json; charset=UTF-8`.\n2. If there's a `Content-Type` header and it says `application/json` then serialise with\n   json.dumps() and use the charset in the header, defaulting to UTF-8.\n3. Otherwise pass through the `Content-Type` header and body as-is.\n   Binary data is not supported.\n\n\n## Verifying Pacts Against a Service\nYou have two options for verifying pacts against a service you created:\n\n1. Use the `pactman-verifier` command-line program which replays the pact assertions against\n   a running instance of your service, or\n2. Use the `pytest` support built into pactman to replay the pacts as test cases, allowing\n   use of other testing mechanisms such as mocking and transaction control.\n\n### Using `pactman-verifier`\n\nRun `pactman-verifier -h` to see the options available. To run all pacts registered to a provider in a [Pact Broker]:\n\n    pactman-verifier -b http://pact-broker.example/ <provider name> <provider url> <provider setup url>\n\nYou can pass in a local pact file with `-l`, this will verify the service against the local file instead of the broker:\n\n    pactman-verifier -l /tmp/localpact.json <provider name> <provider url> <provider setup url>\n\nYou can use `--custom-provider-header` to pass in headers to be passed to provider state setup and verify calls. it can\nbe used multiple times\n\n    pactman-verifier -b <broker url> --custom-provider-header \"someheader:value\" --custom-provider-header\n    \"this:that\" <provider name> <provider url> <provider state url>\n\nAn additional header may also be supplied in the `PROVIDER_EXTRA_HEADER` environment variable, though the command\nline argument(s) would override this.\n\n#### Provider States\n\nIn many cases, your contracts will need very specific data to exist on the provider\nto pass successfully. If you are fetching a user profile, that user needs to exist,\nif querying a list of records, one or more records needs to exist. To support\ndecoupling the testing of the consumer and provider, Pact offers the idea of provider\nstates to communicate from the consumer what data should exist on the provider.\n\nWhen setting up the testing of a provider you will also need to setup the management of\nthese provider states. The Pact verifier does this by making additional HTTP requests to\nthe `<provider setup url>` you provide. This URL could be\non the provider application or a separate one. Some strategies for managing state include:\n\n- Having endpoints in your application that are not active in production that create and delete your datastore state\n- A separate application that has access to the same datastore to create and delete,\n  like a separate App Engine module or Docker container pointing to the same datastore\n- A standalone application that can start and stop the other server with different datastore states\n\nFor more information about provider states, refer to the [Pact documentation] on [Provider States].\n\n### Verifying Pacts Using `pytest`\n\nTo verify pacts for a provider you would write a new pytest test module in the provider's test suite.\nIf you don't want it to be exercised in your usual unit test run you can call it `verify_pacts.py`.\n\nYour test code needs to use the `pact_verifier` fixture provided by pactman, invoking\nits `verify()` method with the URL to the running instance of your service (`pytest-django` provides\na handy `live_server` fixture which works well here) and a callback to set up provider states (described\nbelow).\n\nYou'll need to include some extra command-line arguments to pytest (also described below) to indicate\nwhere the pacts should come from, and whether verification results should be posted to a pact broker.\n\nAn example for a Django project might contain:\n\n```python\nfrom django.contrib.auth.models import User\nfrom pactman.verifier.verify import ProviderStateMissing\n\ndef provider_state(name, **params):\n    if name == 'the user \"pat\" exists':\n        User.objects.create(username='pat', fullname=params['fullname'])\n    else:\n        raise ProviderStateMissing(name)\n\ndef test_pacts(live_server, pact_verifier):\n    pact_verifier.verify(live_server.url, provider_state)\n```\n\nThe test function may do any level of mocking and data setup using standard pytest fixtures - so mocking\ndownstream APIs or other interactions within the provider may be done with standard monkeypatching.\n\n#### Provider states using `pytest`\n\nThe `provider_state` function passed to `pact_verifier.verify` will be passed the `providerState` and\n`providerStates` for all pacts being verified.\n\n- For pacts with **providerState** the `name` argument will be the `providerState` value,\n  and `params` will be empty.\n- For pacts with **providerStates** the function will be invoked once per entry in `providerStates`\n  array with the `name` argument taken from the array entry `name` parameter, and `params` from\n  the `params` parameter.\n\n#### Command line options to control `pytest` verifying pacts\n\nOnce you have written the pytest code, you need to invoke pytest with additional arguments:\n\n`--pact-broker-url=<URL>` provides the base URL of the Pact broker to retrieve pacts from for the\nprovider. You must also provide `--pact-provider-name=<ProviderName>` to identify which provider to\nretrieve pacts for from the broker. You may provider `--pact-verify-consumer=<ConsumerName>` to limit\nthe pacts verified to just that consumer. As with the command-line verifier, you may provide basic\nauth details in the broker URL, or through the `PACT_BROKER_AUTH` environment variable. If your broker\nrequires a bearer token you may provide it with `--pact-broker-token=<TOKEN>` or the `PACT_BROKER_TOKEN`\nenvironment variable.\n\n`--pact-files=<file pattern>` verifies some on-disk pact JSON files identified by the wildcard pattern\n(unix glob pattern matching).\n\nIf you pulled the pacts from a broker and wish to publish verification results, use `--pact-publish-results`\nto turn on publishing the results. This option also requires you to specify `--pact-provider-version=<version>`.\n\nSo, for example:\n\n```bash\n# verify some local pacts in /tmp/pacts\n$ pytest --pact-files=/tmp/pacts/*.json tests/verify_pacts.py\n\n# verify some pacts in a broker for the provider MyService\n$ pytest --pact-broker-url=http://pact-broker.example/ --pact-provider-name=MyService tests/verify_pacts.py\n```\n\nIf you need to see the traceback that caused a pact failure you can use the verbosity flag\nto pytest (`pytest -v`).\n\nSee the \"pact\" section in the pytest command-line help (`pytest -h`) for all command-line options.\n\n### Pact Broker Configuration\n\nYou may also specify the broker URL in the environment variable `PACT_BROKER_URL`.\n\nIf HTTP Basic Auth is required for the broker, that may be provided in the URL:\n\n    pactman-verifier -b http://user:password@pact-broker.example/ ...\n    pytest --pact-broker-url=http://user:password@pact-broker.example/ ...\n\nor set in the `PACT_BROKER_AUTH` environment variable as `user:password`.\n\nIf your broker needs a bearer token then you may provide that on the command line or set it in the\nenvironment variable `PACT_BROKER_TOKEN`.\n\n#### Filtering Broker Pacts by Tag\n\nIf your consumer pacts have tags (called \"consumer version tags\" because they attach to specific\nversions) then you may specify the tag(s) to fetch pacts for on the command line. Multiple tags\nmay be specified, and all pacts matching any tags specified will be verified. For example, to ensure\nyou're verifying your Provider against the *production* pact versions from your Consumers, use:\n\n    pactman-verifier --consumer-version-tag=production -b http://pact-broker.example/ ...\n    pytest --pact-verify-consumer-tag=production --pact-broker-url=http://pact-broker.example/ ...\n\n\n# Development\nPlease read [CONTRIBUTING.md](CONTRIBUTING.md)\n\n## Release History\n\n3.0.0 (FUTURE, DEPRECATION WARNINGS)\n\n- remove DEPRECATED `--pact-consumer-name` command-line option\n\n2.25.0\n\n- Add option to allow pytest to succeed even if a pact verification fails\n\n2.24.0\n\n- Better integration of pact failure information in pytest\n\n2.23.0\n\n- Enable setting of authentication credentials when connecting to the pact broker\n- Allow filtering of pacts fetched from broker to be filtered by consumer version tag\n- Improve the naming and organisation of the pytest command line options\n\n2.22.0\n\n- Better implementation of change in 2.21.0\n\n2.21.0\n\n- Handle warning level messages in command line output handler\n\n2.20.0\n\n- Fix pytest mode to correctly detect array element rule failure as a pytest failure\n- Allow restricting pytest verification runs to a single consumer using --pact-consumer-name\n\n2.19.0\n\n- Correct teardown of pact context manager where the pact is used in multiple\n  interactions (`with interaction1, interaction2` instead of `with pact`).\n\n2.18.0\n\n- Correct bug in cleanup that resulted in urllib mocking breaking.\n\n2.17.0\n\n- Handle absence of any provider state (!) in pytest setup.\n\n2.16.0\n\n- Delay shenanigans around checking pacts directory until pacts are actually written\n  to allow module-level pact definition without side effects.\n\n2.15.0\n\n- Fix structure of serialisation for header matching rules.\n- Add `\"never\"` to the `file_write_mode` options.\n- Handle x-www-form-urlencoded POST request bodies.\n\n2.14.0\n\n- Improve verbose messages to clarify what they're saying.\n\n2.13.0\n\n- Add ability to supply additional headers to provider during verification (thanks @ryallsa)\n\n2.12.1\n\n- Fix pact-python Term compatibility\n\n2.12.0\n\n- Add `Equals` and `Includes` matchers for pact v3+\n- Make verification fail if missing header specified in interaction\n- Significantly improved support for pytest provider verification of pacts\n- Turned pact state call failures into warnings rather than errors\n\n2.11.0\n\n- Ensure query param values are lists\n\n2.10.0\n\n- Allow `has_pact_with()` to accept `file_write_mode`\n- Fix bug introduced in 2.9.0 where generating multiple pacts would result in a single pact\n  being recorded\n\n2.9.0\n\n- Fix `with_request` when called with a dict query (thanks Cong)\n- Make `start_mocking()` and `stop_mocking()` optional with non-server mocking\n- Add shortcut so `python -m pactman.verifier.command_line` is just `python -m pactman`\n  (mostly used in testing before release)\n- Handle the `None` provider state\n- Ensure pact spec versions are consistent across all mocks used to generate a pact file\n\n2.8.0\n\n- Close up some edge cases in body content during mocking, and document in README\n\n2.7.0\n\n- Added `and_given()` as a method of defining additonal provider states for v3+ pacts\n- Added more tests for pact generation (serialisation) which fixed a few edge case bugs\n- Fix handling of lower-case HTTP methods in verifier (thanks Cong!)\n\n2.6.1\n\n- Fix issue where mocked `urlopen` didn't handle the correct number of positional arguments\n\n2.6.0\n\n- Fix several issues cause by a failure to detect failure in several test cases\n  (header, path and array element rules may not have been applied)\n- Fix rules applying to a single non-first element in an array\n- Fix generation of consumer / provider name in <v3 pacts\n\n2.5.0\n\n- Fix some bugs around empty array verification\n\n2.4.0\n\n- Create the pact destination dir if it's missing and its parent exists\n\n2.3.0\n\n- Fix some issues around mocking request queries and the mock's verification of same\n- Fix header regex matching in mock verification\n- Actually use the version passed in to `has_pact_with()`\n- Fix some pact v3 generation issues (thanks pan Jacek)\n\n2.2.0\n\n- Reinstate lost result output.\n\n2.1.0\n\n- Corrected the definition of request payload when there is no `body` in the request\n\n2.0.0\n\n- Correctly determine pact verification result when publishing to broker.\n\n1.2.0\n\n- Corrected use of format_path in command line error handling.\n- Tweaked README for clarity.\n\n1.1.0\n\n- Renamed the `pact-verifier` command to `pactman-verifier` to avoid\n  confusion with other pre-existing packages that provide a command-line\n  incompatible `pact-verifier` command.\n- Support verification of HEAD requests (oops).\n\n1.0.8\n\n- Corrected project URL in project metadata (thanks Jonathan Moss)\n- Fix verbose output\n\n1.0.7\n\n- Added some Trove classifiers to aid potential users.\n\n1.0.6\n\n- Corrected mis-named command-line option.\n\n1.0.5\n\n- Corrected some packaging issues\n\n1.0.4\n\n- Initial release of pactman, including ReeceTech's pact-verifier version 3.17 and pact-python version 0.17.0\n\n[consumer driven contract testing]: https://2018.pycon-au.org/talks/44811-pact-in-python/\n[context manager]: https://en.wikibooks.org/wiki/Python_Programming/Context_Managers\n[Pact]: https://www.gitbook.com/book/pact-foundation/pact/details\n[Pact Broker]: https://docs.pact.io/getting_started/sharing_pacts\n[Pact documentation]: https://docs.pact.io/\n[Pact specification]: https://github.com/pact-foundation/pact-specification\n[Pact specification version 3]: https://github.com/pact-foundation/pact-specification/tree/version-3\n[Provider States]: https://docs.pact.io/documentation/provider_states.html\n[pact-provider-verifier]: https://github.com/pact-foundation/pact-provider-verifier\n\n\n", "description_content_type": "text/markdown", "docs_url": null, "download_url": "", "downloads": {"last_day": -1, "last_month": -1, "last_week": -1}, "home_page": "https://github.com/xjurcak/pactman", "keywords": "", "license": "MIT, Copyright (c) 2018 ReeceTech", "maintainer": "", "maintainer_email": "", "name": "pactman-pytest", "package_url": "https://pypi.org/project/pactman-pytest/", "platform": "", "project_url": "https://pypi.org/project/pactman-pytest/", "project_urls": {"Homepage": "https://github.com/xjurcak/pactman"}, "release_url": "https://pypi.org/project/pactman-pytest/2.25.0/", "requires_dist": ["pytest", "requests", "semver", "colorama", "restnavigator"], "requires_python": "", "summary": "Tools for creating and verifying consumer driven contracts using the Pact framework.", "version": "2.25.0", "yanked": false, "html_description": "<div class=\"project-description\">\n            <p>#Forked pactman\nResolved issue with tags when using pytest. --pact-verify-consumer-tag not was not passed to BrokerConfig when verify using pytest.\nSee pull request to pactman <a href=\"https://github.com/reecetech/pactman/pull/81/commits/21e7c8fdcf4837017e0f86c1fb72a404b80ee254\" rel=\"nofollow\">https://github.com/reecetech/pactman/pull/81/commits/21e7c8fdcf4837017e0f86c1fb72a404b80ee254</a></p>\n<h1>pactman</h1>\n<p><a href=\"https://pypi.org/project/pactman/\" rel=\"nofollow\"><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/c3ebd4eadaeb442a5bc5aa209294c60a1a2deb8e/68747470733a2f2f696d672e736869656c64732e696f2f707970692f762f706163746d616e2e737667\"></a> <a href=\"https://travis-ci.org/reecetech/pactman.svg?branch=master\" rel=\"nofollow\"><img alt=\"\" src=\"https://warehouse-camo.ingress.cmh1.psfhosted.org/0476cce9b8f1d214232859e4391d76ed28d1c5cc/68747470733a2f2f7472617669732d63692e6f72672f7265656365746563682f706163746d616e2e7376673f6272616e63683d6d6173746572\"></a></p>\n<p>Python version of Pact mocking, generation and verification.</p>\n<p>Enables <a href=\"https://2018.pycon-au.org/talks/44811-pact-in-python/\" rel=\"nofollow\">consumer driven contract testing</a>, providing unit test mocking of provider services\nand DSL for the consumer project, and interaction playback and verification for the service\nprovider project. Currently supports versions 1.1, 2 and 3 of the <a href=\"https://github.com/pact-foundation/pact-specification\" rel=\"nofollow\">Pact specification</a>.</p>\n<p>For more information about what Pact is, and how it can help you\ntest your code more efficiently, check out the <a href=\"https://docs.pact.io/\" rel=\"nofollow\">Pact documentation</a>.</p>\n<p>Contains code originally from the <a href=\"https://github.com/pact-foundation/pact-python\" rel=\"nofollow\">pact-python</a> project.</p>\n<p>pactman is maintained by the <a href=\"https://www.reecetech.com.au/\" rel=\"nofollow\">ReeceTech</a> team as part of their toolkit to\nkeep their large (and growing) microservices architecture under control.</p>\n<ul>\n<li><a href=\"#how-to-use-pactman\" rel=\"nofollow\">How to use pactman</a>\n<ul>\n<li><a href=\"#installation\" rel=\"nofollow\">Installation</a></li>\n<li><a href=\"#writing-a-pact\" rel=\"nofollow\">Writing a Pact</a></li>\n<li><a href=\"#writing-the-consumer-test\" rel=\"nofollow\">Writing the Consumer Test</a></li>\n<li><a href=\"#expecting-variable-content\" rel=\"nofollow\">Expecting Variable Content</a></li>\n<li><a href=\"#verifying-pacts-against-a-service\" rel=\"nofollow\">Verifying Pacts Against a Service</a></li>\n</ul>\n</li>\n<li><a href=\"#development\" rel=\"nofollow\">Development</a>\n<ul>\n<li><a href=\"#release-history\" rel=\"nofollow\">Release History</a></li>\n</ul>\n</li>\n</ul>\n<h2>pactman vs pact-python</h2>\n<p>The key difference is all functionality is implemented in Python, rather than shelling out or forking\nto the ruby implementation. This allows for a much nicer mocking user experience (it mocks urllib3\ndirectly), is faster, less messy configuration (multiple providers means multiple ruby processes spawned\non different ports).</p>\n<p>Where <code>pact-python</code> required management of a background Ruby server, and manually starting and stopping\nit, <code>pactman</code> allows a much nicer usage like:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">requests</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pactman</span> <span class=\"kn\">import</span> <span class=\"n\">Consumer</span><span class=\"p\">,</span> <span class=\"n\">Provider</span>\n\n<span class=\"n\">pact</span> <span class=\"o\">=</span> <span class=\"n\">Consumer</span><span class=\"p\">(</span><span class=\"s1\">'Consumer'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">has_pact_with</span><span class=\"p\">(</span><span class=\"n\">Provider</span><span class=\"p\">(</span><span class=\"s1\">'Provider'</span><span class=\"p\">))</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_interaction</span><span class=\"p\">():</span>\n    <span class=\"n\">pact</span><span class=\"o\">.</span><span class=\"n\">given</span><span class=\"p\">(</span><span class=\"s2\">\"some data exists\"</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">upon_receiving</span><span class=\"p\">(</span><span class=\"s2\">\"a request\"</span><span class=\"p\">)</span> \\\n        <span class=\"o\">.</span><span class=\"n\">with_request</span><span class=\"p\">(</span><span class=\"s2\">\"get\"</span><span class=\"p\">,</span> <span class=\"s2\">\"/\"</span><span class=\"p\">,</span> <span class=\"n\">query</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s2\">\"foo\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"bar\"</span><span class=\"p\">]})</span><span class=\"o\">.</span><span class=\"n\">will_respond_with</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">)</span>\n    <span class=\"k\">with</span> <span class=\"n\">pact</span><span class=\"p\">:</span>\n        <span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">pact</span><span class=\"o\">.</span><span class=\"n\">uri</span><span class=\"p\">,</span> <span class=\"n\">params</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s2\">\"foo\"</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s2\">\"bar\"</span><span class=\"p\">]})</span>\n</pre>\n<p>It also supports a broader set of the pact specification (versions 1.1 through to 3).</p>\n<p>The pact verifier has been engineered from the start to talk to a pact broker (both to discover pacts\nand to return verification results).</p>\n<p>There\u2019s a few other quality of life improvements, but those are the big ones.</p>\n<h1>How to use pactman</h1>\n<h2>Installation</h2>\n<p><code>pactman</code> requires Python 3.6 to run.</p>\n<pre><code>pip install pactman\n</code></pre>\n<h2>Writing a Pact</h2>\n<p>Creating a complete contract is a two step process:</p>\n<ol>\n<li>Create a unit test on the consumer side that declares the expectations it has of the provider</li>\n<li>Create a provider state that allows the contract to pass when replayed against the provider</li>\n</ol>\n<h2>Writing the Consumer Test</h2>\n<p>If we have a method that communicates with one of our external services, which we'll call\n<code>Provider</code>, and our product, <code>Consumer</code> is hitting an endpoint on <code>Provider</code> at\n<code>/users/&lt;user&gt;</code> to get information about a particular user.</p>\n<p>If the <code>Consumer</code>'s code to fetch a user looked like this:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">requests</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">get_user</span><span class=\"p\">(</span><span class=\"n\">user_name</span><span class=\"p\">):</span>\n    <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">requests</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s1\">'http://service.example/users/</span><span class=\"si\">{</span><span class=\"n\">user_name</span><span class=\"si\">}</span><span class=\"s1\">'</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">response</span><span class=\"o\">.</span><span class=\"n\">json</span><span class=\"p\">()</span>\n</pre>\n<p>Then <code>Consumer</code>'s contract test is a regular unit test, but <em>using pactman for mocking</em>,\nand might look something like this:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">unittest</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pactman</span> <span class=\"kn\">import</span> <span class=\"n\">Consumer</span><span class=\"p\">,</span> <span class=\"n\">Provider</span>\n\n<span class=\"n\">pact</span> <span class=\"o\">=</span> <span class=\"n\">Consumer</span><span class=\"p\">(</span><span class=\"s1\">'Consumer'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">has_pact_with</span><span class=\"p\">(</span><span class=\"n\">Provider</span><span class=\"p\">(</span><span class=\"s1\">'Provider'</span><span class=\"p\">))</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">GetUserInfoContract</span><span class=\"p\">(</span><span class=\"n\">unittest</span><span class=\"o\">.</span><span class=\"n\">TestCase</span><span class=\"p\">):</span>\n  <span class=\"k\">def</span> <span class=\"nf\">test_get_user</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n    <span class=\"n\">expected</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n      <span class=\"s1\">'username'</span><span class=\"p\">:</span> <span class=\"s1\">'UserA'</span><span class=\"p\">,</span>\n      <span class=\"s1\">'id'</span><span class=\"p\">:</span> <span class=\"mi\">123</span><span class=\"p\">,</span>\n      <span class=\"s1\">'groups'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"s1\">'Editors'</span><span class=\"p\">]</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">pact</span><span class=\"o\">.</span><span class=\"n\">given</span><span class=\"p\">(</span>\n        <span class=\"s1\">'UserA exists and is not an administrator'</span>\n    <span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">upon_receiving</span><span class=\"p\">(</span>\n        <span class=\"s1\">'a request for UserA'</span>\n    <span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">with_request</span><span class=\"p\">(</span>\n        <span class=\"s1\">'GET'</span><span class=\"p\">,</span> <span class=\"s1\">'/users/UserA'</span>\n    <span class=\"p\">)</span> <span class=\"o\">.</span><span class=\"n\">will_respond_with</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"n\">body</span><span class=\"o\">=</span><span class=\"n\">expected</span><span class=\"p\">)</span>\n\n    <span class=\"k\">with</span> <span class=\"n\">pact</span><span class=\"p\">:</span>\n      <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">get_user</span><span class=\"p\">(</span><span class=\"s1\">'UserA'</span><span class=\"p\">)</span>\n\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">assertEqual</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">,</span> <span class=\"n\">expected</span><span class=\"p\">)</span>\n</pre>\n<p>This does a few important things:</p>\n<ul>\n<li>Defines the Consumer and Provider objects that describe our product and our service under test</li>\n<li>Uses <code>given</code> to define the setup criteria for the Provider <code>UserA exists and is not an administrator</code></li>\n<li>Defines what the request that is expected to be made by the consumer will contain</li>\n<li>Defines how the server is expected to respond</li>\n</ul>\n<p>Using the Pact object as a <a href=\"https://en.wikibooks.org/wiki/Python_Programming/Context_Managers\" rel=\"nofollow\">context manager</a>, we call our method under test\nwhich will then communicate with the Pact mock. The mock will respond with\nthe items we defined, allowing us to assert that the method processed the response and\nreturned the expected value.</p>\n<p>If you want more control over when the mock is configured and the interactions verified,\nuse the <code>setup</code> and <code>verify</code> methods, respectively:</p>\n<pre><span class=\"n\">Consumer</span><span class=\"p\">(</span><span class=\"s1\">'Consumer'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">has_pact_with</span><span class=\"p\">(</span><span class=\"n\">Provider</span><span class=\"p\">(</span><span class=\"s1\">'Provider'</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">given</span><span class=\"p\">(</span>\n    <span class=\"s1\">'UserA exists and is not an administrator'</span>\n<span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">upon_receiving</span><span class=\"p\">(</span>\n    <span class=\"s1\">'a request for UserA'</span>\n<span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">with_request</span><span class=\"p\">(</span>\n    <span class=\"s1\">'GET'</span><span class=\"p\">,</span> <span class=\"s1\">'/users/UserA'</span>\n<span class=\"p\">)</span> <span class=\"o\">.</span><span class=\"n\">will_respond_with</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"n\">body</span><span class=\"o\">=</span><span class=\"n\">expected</span><span class=\"p\">)</span>\n\n<span class=\"n\">pact</span><span class=\"o\">.</span><span class=\"n\">setup</span><span class=\"p\">()</span>\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"c1\"># Some additional steps before running the code under test</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">get_user</span><span class=\"p\">(</span><span class=\"s1\">'UserA'</span><span class=\"p\">)</span>\n    <span class=\"c1\"># Some additional steps before verifying all interactions have occurred</span>\n<span class=\"k\">finally</span><span class=\"p\">:</span>\n    <span class=\"n\">pact</span><span class=\"o\">.</span><span class=\"n\">verify</span><span class=\"p\">()</span>\n</pre>\n<h3>An important note about pact relationship definition</h3>\n<p>You may have noticed that the pact relationship is defined at the module level in our\nexamples:</p>\n<pre><span class=\"n\">pact</span> <span class=\"o\">=</span> <span class=\"n\">Consumer</span><span class=\"p\">(</span><span class=\"s1\">'Consumer'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">has_pact_with</span><span class=\"p\">(</span><span class=\"n\">Provider</span><span class=\"p\">(</span><span class=\"s1\">'Provider'</span><span class=\"p\">))</span>\n</pre>\n<p>This is because it <em>must only be done once</em> per test suite. By default the pact file is\ncleared out when that relationship is defined, so if you define it more than once per test\nsuite you'll end up only storing the <em>last</em> pact declared per relationship. For more on this\nsubject, see <a href=\"#writing-multiple-pacts\" rel=\"nofollow\">writing multiple pacts</a>.</p>\n<h3>Requests</h3>\n<p>When defining the expected HTTP request that your code is expected to make you\ncan specify the method, path, body, headers, and query:</p>\n<pre><span class=\"n\">pact</span><span class=\"o\">.</span><span class=\"n\">with_request</span><span class=\"p\">(</span>\n    <span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">'GET'</span><span class=\"p\">,</span>\n    <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"s1\">'/api/v1/my-resources/'</span><span class=\"p\">,</span>\n    <span class=\"n\">query</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'search'</span><span class=\"p\">:</span> <span class=\"s1\">'example'</span><span class=\"p\">}</span>\n<span class=\"p\">)</span>\n</pre>\n<p><code>query</code> is used to specify URL query parameters, so the above example expects\na request made to <code>/api/v1/my-resources/?search=example</code>.</p>\n<pre><span class=\"n\">pact</span><span class=\"o\">.</span><span class=\"n\">with_request</span><span class=\"p\">(</span>\n    <span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">'POST'</span><span class=\"p\">,</span>\n    <span class=\"n\">path</span><span class=\"o\">=</span><span class=\"s1\">'/api/v1/my-resources/123'</span><span class=\"p\">,</span>\n    <span class=\"n\">body</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'user_ids'</span><span class=\"p\">:</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">]},</span>\n    <span class=\"n\">headers</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'Content-Type'</span><span class=\"p\">:</span> <span class=\"s1\">'application/json'</span><span class=\"p\">},</span>\n<span class=\"p\">)</span>\n</pre>\n<p>You can define exact values for your expected request like the examples above,\nor you can use the matchers defined later to assist in handling values that are\nvariable.</p>\n<h3>Some important has_pact_with() options()</h3>\n<p>The <code>has_pact_with(provider...)</code> call has quite a few options documented in its API, but a couple are\nworth mentioning in particular:</p>\n<p><code>version</code> declares the pact specification version that the provider supports. This defaults to \"2.0.0\", but \"3.0.0\"\nis also acceptable if your provider supports <a href=\"https://github.com/pact-foundation/pact-specification/tree/version-3\" rel=\"nofollow\">Pact specification version 3</a>:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pactman</span> <span class=\"kn\">import</span> <span class=\"n\">Consumer</span><span class=\"p\">,</span> <span class=\"n\">Provider</span>\n<span class=\"n\">pact</span> <span class=\"o\">=</span> <span class=\"n\">Consumer</span><span class=\"p\">(</span><span class=\"s1\">'Consumer'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">has_pact_with</span><span class=\"p\">(</span><span class=\"n\">Provider</span><span class=\"p\">(</span><span class=\"s1\">'Provider'</span><span class=\"p\">),</span> <span class=\"n\">version</span><span class=\"o\">=</span><span class=\"s1\">'3.0.0'</span><span class=\"p\">)</span>\n</pre>\n<p><code>file_write_mode</code> defaults to <code>\"overwrite\"</code> and should be that or <code>\"merge\"</code>. Overwrite ensures\nthat any existing pact file will be removed when <code>has_pact_with()</code> is invoked. Merge will retain\nthe pact file and add new pacts to that file. See <a href=\"#writing-multiple-pacts\" rel=\"nofollow\">writing multiple pacts</a>.\nIf you absolutely do not want pact files to be written, use <code>\"never\"</code>.</p>\n<p><code>use_mocking_server</code> defaults to <code>False</code> and controls the mocking method used by <code>pactman</code>. The default is to\npatch <code>urllib3</code>, which is the library underpinning <code>requests</code> and is also used by some other projects. If you\nare using a different library to make your HTTP requests which does not use <code>urllib3</code> underneath then you will need\nto set the <code>use_mocking_server</code> argument to <code>True</code>. This causes <code>pactman</code> to run an actual HTTP server to mock the\nrequests (the server is listening on <code>pact.uri</code> - use that to redirect your HTTP requests to the mock server.) You\nmay also set the <code>PACT_USE_MOCKING_SERVER</code> environment variable to \"yes\" to force your entire suite to use the server\napproach. You should declare the pact particpants (consumer and provider) outside of your tests and will need\nto start and stop the mocking service outside of your tests too. The code below shows what using the server might\nlook like:</p>\n<pre><span class=\"kn\">import</span> <span class=\"nn\">atexit</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pactman</span> <span class=\"kn\">import</span> <span class=\"n\">Consumer</span><span class=\"p\">,</span> <span class=\"n\">Provider</span>\n<span class=\"n\">pact</span> <span class=\"o\">=</span> <span class=\"n\">Consumer</span><span class=\"p\">(</span><span class=\"s1\">'Consumer'</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">has_pact_with</span><span class=\"p\">(</span><span class=\"n\">Provider</span><span class=\"p\">(</span><span class=\"s1\">'Provider'</span><span class=\"p\">),</span> <span class=\"n\">use_mocking_server</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n<span class=\"n\">pact</span><span class=\"o\">.</span><span class=\"n\">start_mocking</span><span class=\"p\">()</span>\n<span class=\"n\">atexit</span><span class=\"o\">.</span><span class=\"n\">register</span><span class=\"p\">(</span><span class=\"n\">pact</span><span class=\"o\">.</span><span class=\"n\">stop_mocking</span><span class=\"p\">)</span>\n</pre>\n<p>You'd then use <code>pact</code> to declare pacts between those participants.</p>\n<h3>Writing multiple pacts</h3>\n<p>During a test run you're likely to need to write multiple pact interactions for a consumer/provider\nrelationship. <code>pactman</code> will manage the pact file as follows:</p>\n<ul>\n<li>When <code>has_pact_with()</code> is invoked it will by default remove any existing pact JSON file for the\nstated consumer &amp; provider.</li>\n<li>You may invoke <code>Consumer('Consumer').has_pact_with(Provider('Provider'))</code> once at the start of\nyour tests. This could be done as a pytest module or session fixture, or through some other\nmechanism and store it in a variable. By convention this is called <code>pact</code> in all of our examples.</li>\n<li>If that is not suitable, you may manually indicate to <code>has_pact_with()</code> that it should either\nretain (<code>file_write_mode=\"merge\"</code>) or remove (<code>file_write_mode=\"overwrite\"</code>) the existing\npact file.</li>\n</ul>\n<h3>Some words about given()</h3>\n<p>You use <code>given()</code> to indicate to the provider that they should have some state in order to\nbe able to satisfy the interaction. You should agree upon the state and its specification\nin discussion with the provider.</p>\n<p>If you are defining a version 3 pact you may define provider states more richly, for example:</p>\n<pre><span class=\"p\">(</span><span class=\"n\">pact</span>\n    <span class=\"o\">.</span><span class=\"n\">given</span><span class=\"p\">(</span><span class=\"s2\">\"this is a simple state as in v2\"</span><span class=\"p\">)</span>\n    <span class=\"o\">.</span><span class=\"n\">and_given</span><span class=\"p\">(</span><span class=\"s2\">\"also the user must exist\"</span><span class=\"p\">,</span> <span class=\"n\">username</span><span class=\"o\">=</span><span class=\"s2\">\"alex\"</span><span class=\"p\">)</span>\n<span class=\"p\">)</span>\n</pre>\n<p>Now you may specify additional parameters to accompany your provider state text. These are\npassed as keyword arguments, and they're optional. You may also provider additional provider\nstates using the <code>and_given()</code> call, which may be invoked many times if necessary. It and\n<code>given()</code> have the same calling convention: a provider state name and any optional parameters.</p>\n<h2>Expecting Variable Content</h2>\n<p>The default validity testing of equal values works great if that user information is always\nstatic, but what happens if the user has a last updated field that is set to the current time\nevery time the object is modified? To handle variable data and make your tests more robust,\nthere are several helpful matchers:</p>\n<h3>Includes(matcher, sample_data)</h3>\n<p><em>Available in version 3.0.0+ pacts</em></p>\n<p>Asserts that the value should contain the given substring, for example::</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pactman</span> <span class=\"kn\">import</span> <span class=\"n\">Includes</span><span class=\"p\">,</span> <span class=\"n\">Like</span>\n<span class=\"n\">Like</span><span class=\"p\">({</span>\n    <span class=\"s1\">'id'</span><span class=\"p\">:</span> <span class=\"mi\">123</span><span class=\"p\">,</span> <span class=\"c1\"># match integer, value varies</span>\n    <span class=\"s1\">'content'</span><span class=\"p\">:</span> <span class=\"n\">Includes</span><span class=\"p\">(</span><span class=\"s1\">'spam'</span><span class=\"p\">,</span> <span class=\"s1\">'Sample spamming content'</span><span class=\"p\">)</span>  <span class=\"c1\"># content must contain the string \"spam\"</span>\n<span class=\"p\">})</span>\n</pre>\n<p>The <code>matcher</code> and <code>sample_data</code> are used differently by consumer and provider depending\nupon whether they're used in the <code>with_request()</code> or <code>will_respond_with()</code> sections\nof the pact. Using the above example:</p>\n<h4>Includes in request</h4>\n<p>When you run the tests for the consumer, the mock will verify that the data\nthe consumer uses in its request contains the <code>matcher</code> string, raising an AssertionError\nif invalid. When the contract is verified by the provider, the <code>sample_data</code> will be\nused in the request to the real provider service, in this case <code>'Sample spamming content'</code>.</p>\n<h4>Includes in response</h4>\n<p>When you run the tests for the consumer, the mock will return the data you provided\nas <code>sample_data</code>, in this case <code>'Sample spamming content'</code>. When the contract is verified on the\nprovider, the data returned from the real provider service will be verified to ensure it\ncontains the <code>matcher</code> string.</p>\n<h3>Term(matcher, sample_data)</h3>\n<p>Asserts the value should match the given regular expression. You could use this\nto expect a timestamp with a particular format in the request or response where\nyou know you need a particular format, but are unconcerned about the exact date:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pactman</span> <span class=\"kn\">import</span> <span class=\"n\">Term</span>\n\n<span class=\"p\">(</span><span class=\"n\">pact</span>\n <span class=\"o\">.</span><span class=\"n\">given</span><span class=\"p\">(</span><span class=\"s1\">'UserA exists and is not an administrator'</span><span class=\"p\">)</span>\n <span class=\"o\">.</span><span class=\"n\">upon_receiving</span><span class=\"p\">(</span><span class=\"s1\">'a request for UserA'</span><span class=\"p\">)</span>\n <span class=\"o\">.</span><span class=\"n\">with_request</span><span class=\"p\">(</span>\n   <span class=\"s1\">'post'</span><span class=\"p\">,</span>\n   <span class=\"s1\">'/users/UserA/info'</span><span class=\"p\">,</span>\n   <span class=\"n\">body</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"s1\">'commencement_date'</span><span class=\"p\">:</span> <span class=\"n\">Term</span><span class=\"p\">(</span><span class=\"s1\">'\\d+-\\d+-\\d'</span><span class=\"p\">,</span> <span class=\"s1\">'1972-01-01'</span><span class=\"p\">)})</span>\n <span class=\"o\">.</span><span class=\"n\">will_respond_with</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">,</span> <span class=\"n\">body</span><span class=\"o\">=</span><span class=\"p\">{</span>\n    <span class=\"s1\">'username'</span><span class=\"p\">:</span> <span class=\"s1\">'UserA'</span><span class=\"p\">,</span>\n    <span class=\"s1\">'last_modified'</span><span class=\"p\">:</span> <span class=\"n\">Term</span><span class=\"p\">(</span><span class=\"s1\">'\\d+-\\d+-\\d+T\\d+:\\d+:\\d+'</span><span class=\"p\">,</span> <span class=\"s1\">'2016-12-15T20:16:01'</span><span class=\"p\">)</span>\n <span class=\"p\">}))</span>\n</pre>\n<p>The <code>matcher</code> and <code>sample_data</code> are used differently by consumer and provider depending\nupon whether they're used in the <code>with_request()</code> or <code>will_respond_with()</code> sections\nof the pact. Using the above example:</p>\n<h4>Term in request</h4>\n<p>When you run the tests for the consumer, the mock will verify that the <code>commencement_date</code>\nthe consumer uses in its request matches the <code>matcher</code>, raising an AssertionError\nif invalid. When the contract is verified by the provider, the <code>sample_data</code> will be\nused in the request to the real provider service, in this case <code>1972-01-01</code>.</p>\n<h4>Term in response</h4>\n<p>When you run the tests for the consumer, the mock will return the <code>last_modified</code> you provided\nas <code>sample_data</code>, in this case <code>2016-12-15T20:16:01</code>. When the contract is verified on the\nprovider, the regex will be used to search the response from the real provider service\nand the test will be considered successful if the regex finds a match in the response.</p>\n<h3>Like(sample_data)</h3>\n<p>Asserts the element's type matches the <code>sample_data</code>. For example:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pactman</span> <span class=\"kn\">import</span> <span class=\"n\">Like</span>\n<span class=\"n\">Like</span><span class=\"p\">(</span><span class=\"mi\">123</span><span class=\"p\">)</span>  <span class=\"c1\"># Matches if the value is an integer</span>\n<span class=\"n\">Like</span><span class=\"p\">(</span><span class=\"s1\">'hello world'</span><span class=\"p\">)</span>  <span class=\"c1\"># Matches if the value is a string</span>\n<span class=\"n\">Like</span><span class=\"p\">(</span><span class=\"mf\">3.14</span><span class=\"p\">)</span>  <span class=\"c1\"># Matches if the value is a float</span>\n</pre>\n<h4>Like in request</h4>\n<p>When you run the tests for the consumer, the mock will verify that values are\nof the correct type, raising an AssertionError if invalid. When the contract is\nverified by the provider, the <code>sample_data</code> will be used in the request to the\nreal provider service.</p>\n<h4>Like in response</h4>\n<p>When you run the tests for the consumer, the mock will return the <code>sample_data</code>.\nWhen the contract is verified on the provider, the values generated by the provider\nservice will be checked to match the type of <code>sample_data</code>.</p>\n<h4>Applying Like to complex data structures</h4>\n<p>When a dictionary is used as an argument for Like, all the child objects (and their child objects etc.)\nwill be matched according to their types, unless you use a more specific matcher like a Term.</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pactman</span> <span class=\"kn\">import</span> <span class=\"n\">Like</span><span class=\"p\">,</span> <span class=\"n\">Term</span>\n<span class=\"n\">Like</span><span class=\"p\">({</span>\n    <span class=\"s1\">'username'</span><span class=\"p\">:</span> <span class=\"n\">Term</span><span class=\"p\">(</span><span class=\"s1\">'[a-zA-Z]+'</span><span class=\"p\">,</span> <span class=\"s1\">'username'</span><span class=\"p\">),</span>\n    <span class=\"s1\">'id'</span><span class=\"p\">:</span> <span class=\"mi\">123</span><span class=\"p\">,</span> <span class=\"c1\"># integer</span>\n    <span class=\"s1\">'confirmed'</span><span class=\"p\">:</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"c1\"># boolean</span>\n    <span class=\"s1\">'address'</span><span class=\"p\">:</span> <span class=\"p\">{</span> <span class=\"c1\"># dictionary</span>\n        <span class=\"s1\">'street'</span><span class=\"p\">:</span> <span class=\"s1\">'200 Bourke St'</span> <span class=\"c1\"># string</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">})</span>\n</pre>\n<h3>EachLike(sample_data, minimum=1)</h3>\n<p>Asserts the value is an array type that consists of elements\nlike <code>sample_data</code>. It can be used to assert simple arrays:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pactman</span> <span class=\"kn\">import</span> <span class=\"n\">EachLike</span>\n<span class=\"n\">EachLike</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># All items are integers</span>\n<span class=\"n\">EachLike</span><span class=\"p\">(</span><span class=\"s1\">'hello'</span><span class=\"p\">)</span>  <span class=\"c1\"># All items are strings</span>\n</pre>\n<p>Or other matchers can be nested inside to assert more complex objects:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pactman</span> <span class=\"kn\">import</span> <span class=\"n\">EachLike</span><span class=\"p\">,</span> <span class=\"n\">Term</span>\n<span class=\"n\">EachLike</span><span class=\"p\">({</span>\n    <span class=\"s1\">'username'</span><span class=\"p\">:</span> <span class=\"n\">Term</span><span class=\"p\">(</span><span class=\"s1\">'[a-zA-Z]+'</span><span class=\"p\">,</span> <span class=\"s1\">'username'</span><span class=\"p\">),</span>\n    <span class=\"s1\">'id'</span><span class=\"p\">:</span> <span class=\"mi\">123</span><span class=\"p\">,</span>\n    <span class=\"s1\">'groups'</span><span class=\"p\">:</span> <span class=\"n\">EachLike</span><span class=\"p\">(</span><span class=\"s1\">'administrators'</span><span class=\"p\">)</span>\n<span class=\"p\">})</span>\n</pre>\n<blockquote>\n<p>Note, you do not need to specify everything that will be returned from the Provider in a\nJSON response, any extra data that is received will be ignored and the tests will still pass.</p>\n</blockquote>\n<p>For more information see <a href=\"https://docs.pact.io/documentation/matching.html\" rel=\"nofollow\">Matching</a></p>\n<h3>Enforcing equality matching with Equals</h3>\n<p><em>Available in version 3.0.0+ pacts</em></p>\n<p>If you have a sub-term of a <code>Like</code> which needs to match an exact value like the default\nvalidity test then you can use <code>Equals</code>, for example::</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">pactman</span> <span class=\"kn\">import</span> <span class=\"n\">Equals</span><span class=\"p\">,</span> <span class=\"n\">Like</span>\n<span class=\"n\">Like</span><span class=\"p\">({</span>\n    <span class=\"s1\">'id'</span><span class=\"p\">:</span> <span class=\"mi\">123</span><span class=\"p\">,</span> <span class=\"c1\"># match integer, value varies</span>\n    <span class=\"s1\">'username'</span><span class=\"p\">:</span> <span class=\"n\">Equals</span><span class=\"p\">(</span><span class=\"s1\">'alex'</span><span class=\"p\">)</span>  <span class=\"c1\"># username must always be \"alex\"</span>\n<span class=\"p\">})</span>\n</pre>\n<h3>Body payload rules</h3>\n<p>The <code>body</code> payload is assumed to be JSON data. In the absence of a <code>Content-Type</code> header\nwe assume <code>Content-Type: application/json; charset=UTF-8</code> (JSON text is Unicode and the\ndefault encoding is UTF-8).</p>\n<p>During verification non-JSON payloads are compared for equality.</p>\n<p>During mocking, the HTTP response will be handled as:</p>\n<ol>\n<li>If there's no <code>Content-Type</code> header, assume JSON: serialise with <code>json.dumps()</code>, encode to\nUTF-8 and add the header <code>Content-Type: application/json; charset=UTF-8</code>.</li>\n<li>If there's a <code>Content-Type</code> header and it says <code>application/json</code> then serialise with\njson.dumps() and use the charset in the header, defaulting to UTF-8.</li>\n<li>Otherwise pass through the <code>Content-Type</code> header and body as-is.\nBinary data is not supported.</li>\n</ol>\n<h2>Verifying Pacts Against a Service</h2>\n<p>You have two options for verifying pacts against a service you created:</p>\n<ol>\n<li>Use the <code>pactman-verifier</code> command-line program which replays the pact assertions against\na running instance of your service, or</li>\n<li>Use the <code>pytest</code> support built into pactman to replay the pacts as test cases, allowing\nuse of other testing mechanisms such as mocking and transaction control.</li>\n</ol>\n<h3>Using <code>pactman-verifier</code></h3>\n<p>Run <code>pactman-verifier -h</code> to see the options available. To run all pacts registered to a provider in a <a href=\"https://docs.pact.io/getting_started/sharing_pacts\" rel=\"nofollow\">Pact Broker</a>:</p>\n<pre><code>pactman-verifier -b http://pact-broker.example/ &lt;provider name&gt; &lt;provider url&gt; &lt;provider setup url&gt;\n</code></pre>\n<p>You can pass in a local pact file with <code>-l</code>, this will verify the service against the local file instead of the broker:</p>\n<pre><code>pactman-verifier -l /tmp/localpact.json &lt;provider name&gt; &lt;provider url&gt; &lt;provider setup url&gt;\n</code></pre>\n<p>You can use <code>--custom-provider-header</code> to pass in headers to be passed to provider state setup and verify calls. it can\nbe used multiple times</p>\n<pre><code>pactman-verifier -b &lt;broker url&gt; --custom-provider-header \"someheader:value\" --custom-provider-header\n\"this:that\" &lt;provider name&gt; &lt;provider url&gt; &lt;provider state url&gt;\n</code></pre>\n<p>An additional header may also be supplied in the <code>PROVIDER_EXTRA_HEADER</code> environment variable, though the command\nline argument(s) would override this.</p>\n<h4>Provider States</h4>\n<p>In many cases, your contracts will need very specific data to exist on the provider\nto pass successfully. If you are fetching a user profile, that user needs to exist,\nif querying a list of records, one or more records needs to exist. To support\ndecoupling the testing of the consumer and provider, Pact offers the idea of provider\nstates to communicate from the consumer what data should exist on the provider.</p>\n<p>When setting up the testing of a provider you will also need to setup the management of\nthese provider states. The Pact verifier does this by making additional HTTP requests to\nthe <code>&lt;provider setup url&gt;</code> you provide. This URL could be\non the provider application or a separate one. Some strategies for managing state include:</p>\n<ul>\n<li>Having endpoints in your application that are not active in production that create and delete your datastore state</li>\n<li>A separate application that has access to the same datastore to create and delete,\nlike a separate App Engine module or Docker container pointing to the same datastore</li>\n<li>A standalone application that can start and stop the other server with different datastore states</li>\n</ul>\n<p>For more information about provider states, refer to the <a href=\"https://docs.pact.io/\" rel=\"nofollow\">Pact documentation</a> on <a href=\"https://docs.pact.io/documentation/provider_states.html\" rel=\"nofollow\">Provider States</a>.</p>\n<h3>Verifying Pacts Using <code>pytest</code></h3>\n<p>To verify pacts for a provider you would write a new pytest test module in the provider's test suite.\nIf you don't want it to be exercised in your usual unit test run you can call it <code>verify_pacts.py</code>.</p>\n<p>Your test code needs to use the <code>pact_verifier</code> fixture provided by pactman, invoking\nits <code>verify()</code> method with the URL to the running instance of your service (<code>pytest-django</code> provides\na handy <code>live_server</code> fixture which works well here) and a callback to set up provider states (described\nbelow).</p>\n<p>You'll need to include some extra command-line arguments to pytest (also described below) to indicate\nwhere the pacts should come from, and whether verification results should be posted to a pact broker.</p>\n<p>An example for a Django project might contain:</p>\n<pre><span class=\"kn\">from</span> <span class=\"nn\">django.contrib.auth.models</span> <span class=\"kn\">import</span> <span class=\"n\">User</span>\n<span class=\"kn\">from</span> <span class=\"nn\">pactman.verifier.verify</span> <span class=\"kn\">import</span> <span class=\"n\">ProviderStateMissing</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">provider_state</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">params</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">name</span> <span class=\"o\">==</span> <span class=\"s1\">'the user \"pat\" exists'</span><span class=\"p\">:</span>\n        <span class=\"n\">User</span><span class=\"o\">.</span><span class=\"n\">objects</span><span class=\"o\">.</span><span class=\"n\">create</span><span class=\"p\">(</span><span class=\"n\">username</span><span class=\"o\">=</span><span class=\"s1\">'pat'</span><span class=\"p\">,</span> <span class=\"n\">fullname</span><span class=\"o\">=</span><span class=\"n\">params</span><span class=\"p\">[</span><span class=\"s1\">'fullname'</span><span class=\"p\">])</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"k\">raise</span> <span class=\"n\">ProviderStateMissing</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">)</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">test_pacts</span><span class=\"p\">(</span><span class=\"n\">live_server</span><span class=\"p\">,</span> <span class=\"n\">pact_verifier</span><span class=\"p\">):</span>\n    <span class=\"n\">pact_verifier</span><span class=\"o\">.</span><span class=\"n\">verify</span><span class=\"p\">(</span><span class=\"n\">live_server</span><span class=\"o\">.</span><span class=\"n\">url</span><span class=\"p\">,</span> <span class=\"n\">provider_state</span><span class=\"p\">)</span>\n</pre>\n<p>The test function may do any level of mocking and data setup using standard pytest fixtures - so mocking\ndownstream APIs or other interactions within the provider may be done with standard monkeypatching.</p>\n<h4>Provider states using <code>pytest</code></h4>\n<p>The <code>provider_state</code> function passed to <code>pact_verifier.verify</code> will be passed the <code>providerState</code> and\n<code>providerStates</code> for all pacts being verified.</p>\n<ul>\n<li>For pacts with <strong>providerState</strong> the <code>name</code> argument will be the <code>providerState</code> value,\nand <code>params</code> will be empty.</li>\n<li>For pacts with <strong>providerStates</strong> the function will be invoked once per entry in <code>providerStates</code>\narray with the <code>name</code> argument taken from the array entry <code>name</code> parameter, and <code>params</code> from\nthe <code>params</code> parameter.</li>\n</ul>\n<h4>Command line options to control <code>pytest</code> verifying pacts</h4>\n<p>Once you have written the pytest code, you need to invoke pytest with additional arguments:</p>\n<p><code>--pact-broker-url=&lt;URL&gt;</code> provides the base URL of the Pact broker to retrieve pacts from for the\nprovider. You must also provide <code>--pact-provider-name=&lt;ProviderName&gt;</code> to identify which provider to\nretrieve pacts for from the broker. You may provider <code>--pact-verify-consumer=&lt;ConsumerName&gt;</code> to limit\nthe pacts verified to just that consumer. As with the command-line verifier, you may provide basic\nauth details in the broker URL, or through the <code>PACT_BROKER_AUTH</code> environment variable. If your broker\nrequires a bearer token you may provide it with <code>--pact-broker-token=&lt;TOKEN&gt;</code> or the <code>PACT_BROKER_TOKEN</code>\nenvironment variable.</p>\n<p><code>--pact-files=&lt;file pattern&gt;</code> verifies some on-disk pact JSON files identified by the wildcard pattern\n(unix glob pattern matching).</p>\n<p>If you pulled the pacts from a broker and wish to publish verification results, use <code>--pact-publish-results</code>\nto turn on publishing the results. This option also requires you to specify <code>--pact-provider-version=&lt;version&gt;</code>.</p>\n<p>So, for example:</p>\n<pre><span class=\"c1\"># verify some local pacts in /tmp/pacts</span>\n$ pytest --pact-files<span class=\"o\">=</span>/tmp/pacts/*.json tests/verify_pacts.py\n\n<span class=\"c1\"># verify some pacts in a broker for the provider MyService</span>\n$ pytest --pact-broker-url<span class=\"o\">=</span>http://pact-broker.example/ --pact-provider-name<span class=\"o\">=</span>MyService tests/verify_pacts.py\n</pre>\n<p>If you need to see the traceback that caused a pact failure you can use the verbosity flag\nto pytest (<code>pytest -v</code>).</p>\n<p>See the \"pact\" section in the pytest command-line help (<code>pytest -h</code>) for all command-line options.</p>\n<h3>Pact Broker Configuration</h3>\n<p>You may also specify the broker URL in the environment variable <code>PACT_BROKER_URL</code>.</p>\n<p>If HTTP Basic Auth is required for the broker, that may be provided in the URL:</p>\n<pre><code>pactman-verifier -b http://user:password@pact-broker.example/ ...\npytest --pact-broker-url=http://user:password@pact-broker.example/ ...\n</code></pre>\n<p>or set in the <code>PACT_BROKER_AUTH</code> environment variable as <code>user:password</code>.</p>\n<p>If your broker needs a bearer token then you may provide that on the command line or set it in the\nenvironment variable <code>PACT_BROKER_TOKEN</code>.</p>\n<h4>Filtering Broker Pacts by Tag</h4>\n<p>If your consumer pacts have tags (called \"consumer version tags\" because they attach to specific\nversions) then you may specify the tag(s) to fetch pacts for on the command line. Multiple tags\nmay be specified, and all pacts matching any tags specified will be verified. For example, to ensure\nyou're verifying your Provider against the <em>production</em> pact versions from your Consumers, use:</p>\n<pre><code>pactman-verifier --consumer-version-tag=production -b http://pact-broker.example/ ...\npytest --pact-verify-consumer-tag=production --pact-broker-url=http://pact-broker.example/ ...\n</code></pre>\n<h1>Development</h1>\n<p>Please read <a href=\"CONTRIBUTING.md\" rel=\"nofollow\">CONTRIBUTING.md</a></p>\n<h2>Release History</h2>\n<p>3.0.0 (FUTURE, DEPRECATION WARNINGS)</p>\n<ul>\n<li>remove DEPRECATED <code>--pact-consumer-name</code> command-line option</li>\n</ul>\n<p>2.25.0</p>\n<ul>\n<li>Add option to allow pytest to succeed even if a pact verification fails</li>\n</ul>\n<p>2.24.0</p>\n<ul>\n<li>Better integration of pact failure information in pytest</li>\n</ul>\n<p>2.23.0</p>\n<ul>\n<li>Enable setting of authentication credentials when connecting to the pact broker</li>\n<li>Allow filtering of pacts fetched from broker to be filtered by consumer version tag</li>\n<li>Improve the naming and organisation of the pytest command line options</li>\n</ul>\n<p>2.22.0</p>\n<ul>\n<li>Better implementation of change in 2.21.0</li>\n</ul>\n<p>2.21.0</p>\n<ul>\n<li>Handle warning level messages in command line output handler</li>\n</ul>\n<p>2.20.0</p>\n<ul>\n<li>Fix pytest mode to correctly detect array element rule failure as a pytest failure</li>\n<li>Allow restricting pytest verification runs to a single consumer using --pact-consumer-name</li>\n</ul>\n<p>2.19.0</p>\n<ul>\n<li>Correct teardown of pact context manager where the pact is used in multiple\ninteractions (<code>with interaction1, interaction2</code> instead of <code>with pact</code>).</li>\n</ul>\n<p>2.18.0</p>\n<ul>\n<li>Correct bug in cleanup that resulted in urllib mocking breaking.</li>\n</ul>\n<p>2.17.0</p>\n<ul>\n<li>Handle absence of any provider state (!) in pytest setup.</li>\n</ul>\n<p>2.16.0</p>\n<ul>\n<li>Delay shenanigans around checking pacts directory until pacts are actually written\nto allow module-level pact definition without side effects.</li>\n</ul>\n<p>2.15.0</p>\n<ul>\n<li>Fix structure of serialisation for header matching rules.</li>\n<li>Add <code>\"never\"</code> to the <code>file_write_mode</code> options.</li>\n<li>Handle x-www-form-urlencoded POST request bodies.</li>\n</ul>\n<p>2.14.0</p>\n<ul>\n<li>Improve verbose messages to clarify what they're saying.</li>\n</ul>\n<p>2.13.0</p>\n<ul>\n<li>Add ability to supply additional headers to provider during verification (thanks @ryallsa)</li>\n</ul>\n<p>2.12.1</p>\n<ul>\n<li>Fix pact-python Term compatibility</li>\n</ul>\n<p>2.12.0</p>\n<ul>\n<li>Add <code>Equals</code> and <code>Includes</code> matchers for pact v3+</li>\n<li>Make verification fail if missing header specified in interaction</li>\n<li>Significantly improved support for pytest provider verification of pacts</li>\n<li>Turned pact state call failures into warnings rather than errors</li>\n</ul>\n<p>2.11.0</p>\n<ul>\n<li>Ensure query param values are lists</li>\n</ul>\n<p>2.10.0</p>\n<ul>\n<li>Allow <code>has_pact_with()</code> to accept <code>file_write_mode</code></li>\n<li>Fix bug introduced in 2.9.0 where generating multiple pacts would result in a single pact\nbeing recorded</li>\n</ul>\n<p>2.9.0</p>\n<ul>\n<li>Fix <code>with_request</code> when called with a dict query (thanks Cong)</li>\n<li>Make <code>start_mocking()</code> and <code>stop_mocking()</code> optional with non-server mocking</li>\n<li>Add shortcut so <code>python -m pactman.verifier.command_line</code> is just <code>python -m pactman</code>\n(mostly used in testing before release)</li>\n<li>Handle the <code>None</code> provider state</li>\n<li>Ensure pact spec versions are consistent across all mocks used to generate a pact file</li>\n</ul>\n<p>2.8.0</p>\n<ul>\n<li>Close up some edge cases in body content during mocking, and document in README</li>\n</ul>\n<p>2.7.0</p>\n<ul>\n<li>Added <code>and_given()</code> as a method of defining additonal provider states for v3+ pacts</li>\n<li>Added more tests for pact generation (serialisation) which fixed a few edge case bugs</li>\n<li>Fix handling of lower-case HTTP methods in verifier (thanks Cong!)</li>\n</ul>\n<p>2.6.1</p>\n<ul>\n<li>Fix issue where mocked <code>urlopen</code> didn't handle the correct number of positional arguments</li>\n</ul>\n<p>2.6.0</p>\n<ul>\n<li>Fix several issues cause by a failure to detect failure in several test cases\n(header, path and array element rules may not have been applied)</li>\n<li>Fix rules applying to a single non-first element in an array</li>\n<li>Fix generation of consumer / provider name in &lt;v3 pacts</li>\n</ul>\n<p>2.5.0</p>\n<ul>\n<li>Fix some bugs around empty array verification</li>\n</ul>\n<p>2.4.0</p>\n<ul>\n<li>Create the pact destination dir if it's missing and its parent exists</li>\n</ul>\n<p>2.3.0</p>\n<ul>\n<li>Fix some issues around mocking request queries and the mock's verification of same</li>\n<li>Fix header regex matching in mock verification</li>\n<li>Actually use the version passed in to <code>has_pact_with()</code></li>\n<li>Fix some pact v3 generation issues (thanks pan Jacek)</li>\n</ul>\n<p>2.2.0</p>\n<ul>\n<li>Reinstate lost result output.</li>\n</ul>\n<p>2.1.0</p>\n<ul>\n<li>Corrected the definition of request payload when there is no <code>body</code> in the request</li>\n</ul>\n<p>2.0.0</p>\n<ul>\n<li>Correctly determine pact verification result when publishing to broker.</li>\n</ul>\n<p>1.2.0</p>\n<ul>\n<li>Corrected use of format_path in command line error handling.</li>\n<li>Tweaked README for clarity.</li>\n</ul>\n<p>1.1.0</p>\n<ul>\n<li>Renamed the <code>pact-verifier</code> command to <code>pactman-verifier</code> to avoid\nconfusion with other pre-existing packages that provide a command-line\nincompatible <code>pact-verifier</code> command.</li>\n<li>Support verification of HEAD requests (oops).</li>\n</ul>\n<p>1.0.8</p>\n<ul>\n<li>Corrected project URL in project metadata (thanks Jonathan Moss)</li>\n<li>Fix verbose output</li>\n</ul>\n<p>1.0.7</p>\n<ul>\n<li>Added some Trove classifiers to aid potential users.</li>\n</ul>\n<p>1.0.6</p>\n<ul>\n<li>Corrected mis-named command-line option.</li>\n</ul>\n<p>1.0.5</p>\n<ul>\n<li>Corrected some packaging issues</li>\n</ul>\n<p>1.0.4</p>\n<ul>\n<li>Initial release of pactman, including ReeceTech's pact-verifier version 3.17 and pact-python version 0.17.0</li>\n</ul>\n\n          </div>"}, "last_serial": 6872430, "releases": {"2.25.0": [{"comment_text": "", "digests": {"md5": "eca0323d97f9e5edfaf453da6961bb95", "sha256": "753af72bdd7fbe2f45ee9c1d8688350fa319086785fddaf9016d7164b82742c1"}, "downloads": -1, "filename": "pactman_pytest-2.25.0-py3-none-any.whl", "has_sig": false, "md5_digest": "eca0323d97f9e5edfaf453da6961bb95", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 71941, "upload_time": "2020-03-24T11:34:50", "upload_time_iso_8601": "2020-03-24T11:34:50.489678Z", "url": "https://files.pythonhosted.org/packages/6c/c6/ca1e7b8fa802114c0e5f07c4cd6c55395925f07a3a358a40dfc02cb01da8/pactman_pytest-2.25.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "856b6f847a7d06f94368649d760f6531", "sha256": "44d3e68a1b7a26be653cb98e1f395bb2315721dfb4ee1e511e81129415893747"}, "downloads": -1, "filename": "pactman-pytest-2.25.0.tar.gz", "has_sig": false, "md5_digest": "856b6f847a7d06f94368649d760f6531", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 74239, "upload_time": "2020-03-24T11:34:53", "upload_time_iso_8601": "2020-03-24T11:34:53.791693Z", "url": "https://files.pythonhosted.org/packages/8f/37/d722a5cbc0e4524615c30065aff744b290bcfcb4dcc42d7ae317be43c000/pactman-pytest-2.25.0.tar.gz", "yanked": false}]}, "urls": [{"comment_text": "", "digests": {"md5": "eca0323d97f9e5edfaf453da6961bb95", "sha256": "753af72bdd7fbe2f45ee9c1d8688350fa319086785fddaf9016d7164b82742c1"}, "downloads": -1, "filename": "pactman_pytest-2.25.0-py3-none-any.whl", "has_sig": false, "md5_digest": "eca0323d97f9e5edfaf453da6961bb95", "packagetype": "bdist_wheel", "python_version": "py3", "requires_python": null, "size": 71941, "upload_time": "2020-03-24T11:34:50", "upload_time_iso_8601": "2020-03-24T11:34:50.489678Z", "url": "https://files.pythonhosted.org/packages/6c/c6/ca1e7b8fa802114c0e5f07c4cd6c55395925f07a3a358a40dfc02cb01da8/pactman_pytest-2.25.0-py3-none-any.whl", "yanked": false}, {"comment_text": "", "digests": {"md5": "856b6f847a7d06f94368649d760f6531", "sha256": "44d3e68a1b7a26be653cb98e1f395bb2315721dfb4ee1e511e81129415893747"}, "downloads": -1, "filename": "pactman-pytest-2.25.0.tar.gz", "has_sig": false, "md5_digest": "856b6f847a7d06f94368649d760f6531", "packagetype": "sdist", "python_version": "source", "requires_python": null, "size": 74239, "upload_time": "2020-03-24T11:34:53", "upload_time_iso_8601": "2020-03-24T11:34:53.791693Z", "url": "https://files.pythonhosted.org/packages/8f/37/d722a5cbc0e4524615c30065aff744b290bcfcb4dcc42d7ae317be43c000/pactman-pytest-2.25.0.tar.gz", "yanked": false}], "timestamp": "Fri May  8 03:00:02 2020"}